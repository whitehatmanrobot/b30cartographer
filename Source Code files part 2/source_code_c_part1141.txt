amFiles%\\MSN Gaming Zone\\Windows\\ZNetM.dll", NULL},
    {NULL, L"%ProgramFiles%\\MSN Gaming Zone\\Windows\\zoneclim.dll", NULL},
    {NULL, L"%ProgramFiles%\\MSN Gaming Zone\\Windows\\zonelibM.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\zoneoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\tabletoc.dll", NULL},
#if defined SFCFILES_SKU_TABLET
    {NULL, L"%commonprogramfiles%\\microsoft shared\\speech\\deskres.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\inkball\\inkball.exe", L"tablet.inf"},
    {NULL, L"%systemroot%\\system32\\inked.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\inkobj.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\windows journal\\inkseg.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\speechengines\\microsoft\\sr60\\1033\\itngram.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\windows journal\\jntfiltr.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\windows journal\\jnwdrv.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\windows journal\\jnwdui.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\windows journal\\jnwmon.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\windows journal\\jnwppr.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\windows journal\\journal.exe", L"tablet.inf"},
    {NULL, L"%systemroot%\\system32\\loginkey.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\speechengines\\microsoft\\lexicon60\\1033\\lsr1033.lxa", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\microsoft.ink.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\mshwgst.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\mshwuk.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\mshwusa.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\windows journal\\mspvwctl.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\windows journal\\nbdoc.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\windows journal\\nbkintl.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\windows journal\\nbmaptip.dll", L"tablet.inf"},
    {NULL, L"%programfiles%\\windows journal\\pdialog.exe", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\penchs.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\pencht.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\penjpn.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\penkor.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\penusa.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\speechengines\\microsoft\\lexicon60\\1033\\r1033sr.lxa", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\skchobj.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\skchui.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\speech\\spdesk.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\speechengines\\microsoft\\sr60\\spsreng.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\speechengines\\microsoft\\sr60\\spsrx.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\speechengines\\microsoft\\sr60\\1033\\spsrxui.dll", L"tablet.inf"},
    {NULL, L"%systemroot%\\system32\\stikynot.exe", L"tablet.inf"},
    {NULL, L"%systemroot%\\system32\\tabbtn.dll", L"tablet.inf"},
    {NULL, L"%systemroot%\\system32\\tabbtnu.exe", L"tablet.inf"},
    {NULL, L"%systemroot%\\system32\\tabbtnwl.dll", L"tablet.inf"},
    {NULL, L"%systemroot%\\system32\\tabcal.exe", L"tablet.inf"},
    {NULL, L"%systemroot%\\system32\\tabletpc.cpl", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\tabtip.exe", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\tabtipps.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\tipband.dll", L"tablet.inf"},
    {NULL, L"%systemroot%\\system32\\tipres.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\tipskins.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\tiptsf.dll", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\tpa.exe", L"tablet.inf"},
    {NULL, L"%commonprogramfiles%\\microsoft shared\\ink\\tpcps.dll", L"tablet.inf"},
    {NULL, L"%systemroot%\\system32\\tpgwlnot.dll", L"tablet.inf"},
    {NULL, L"%systemroot%\\system32\\tutmenu.dll", L"tablet.inf"},
    {NULL, L"%systemroot%\\system32\\wisptis.exe", L"tablet.inf"},
#elif defined SFCFILES_SKU_MEDIA
    {NULL, L"%systemroot%\\ehome\\custsat.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\debugsvc.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehcir.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehcm.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehdebug.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehdrop.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehentt.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehepg.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehepgdat.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehepgdec.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehepgnet.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehichun.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehientt.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehiime.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehiplay.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehiproxy.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehituner.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehividctl.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehiwmp.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehplayer.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehproxy.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehrec.exe", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehrecobj.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehres.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehsched.exe", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehshell.exe", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehtray.exe", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\ehui.dll", L"medctroc.inf"}, 
	{NULL, L"%systemroot%\\ehome\\ehuihlp.dll", L"medctroc.inf"},
    {NULL, L"%systemroot%\\ehome\\exhibits.dll", L"medctroc.inf"},
#endif
};

#if defined SFCFILES_SKU_TABLET
#define CountTabFiles (sizeof(TabFiles)/sizeof(TabFiles[0]))
#elif defined SFCFILES_SKU_MEDIA
#define CountMedFiles (sizeof(MedFiles)/sizeof(MedFiles[0]))
#else
#define CountWksFiles (sizeof(WksFiles)/sizeof(WksFiles[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\sm\sfc\rpc\cli\makefile.inc ===
$(O)\sfcapi_c.c : ..\idl\$(O)\sfcapi_c.c
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\sm\sfc\rpc\srv\makefile.inc ===
$(O)\sfcapi_s.c : ..\idl\$(O)\sfcapi_s.c
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\sm\sfc\rpc\idl\imports.h ===
#include <windef.h>

#ifdef MIDL_PASS
#define LPSTR  [string] LPSTR
#define LPTSTR [string] LPTSTR
#define LPWSTR [string] wchar_t *
#define PWSTR  [string] wchar_t *
#define PCWSTR [string] const wchar_t *
#define enum   [v1_enum] enum
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\sm\sfc\postbuild\src\sfcfiles.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sfcfiles.c

Abstract:

    Routines to initialize and retrieve a list of files to be proected by the
    system.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:
    
    Andrew Ritz (andrewr) 2-Jul-199 -- added comments

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "sfcfiles.h"

#if defined(_AMD64_)

#include "amd64_dtc.h"
#include "amd64_ent.h"
#include "amd64_wks.h"

#elif defined(_IA64_)

#include "ia64_dtc.h"
#include "ia64_ent.h"
#include "ia64_wks.h"

#elif defined(_X86_)

#include "x86_dtc.h"
#include "x86_ent.h"
#include "x86_per.h"
#include "x86_srv.h"
#include "x86_wks.h"

#else
#error "No Target Platform"
#endif

//
// Globals
//


//
// module handle
//
HMODULE SfcInstanceHandle;

//
// pointer to tier2 files for this system
//
PPROTECT_FILE_ENTRY Tier2Files;

//
// number of files in the tier 2 list. there must always be at least one file
// in the list of protected files
//
ULONG CountTier2Files;



DWORD
SfcDllEntry(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )
/*++

Routine Description:

    Main Dll Entrypoint

Arguments:

    hInstance - handle to dll module
    Reason    - reason for calling function
    Context   - reserved

Return Value:

    always TRUE

--*/
{
    if (Reason == DLL_PROCESS_ATTACH) {
        SfcInstanceHandle = hInstance;

        //
        // we don't need thread attach/detach notifications
        //
        LdrDisableThreadCalloutsForDll( hInstance );
    }
    return TRUE;
}


NTSTATUS
SfcFilesInit(
    void
    )
/*++

Routine Description:

    Initialization routine.  This routine must be called before 
    SfcGetFiles() can do any work.  The initialization routine 
    determines what embedded file list we should use based on 
    product type and architecture.

Arguments:

    NONE.

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status;
    OSVERSIONINFOEXW ver;
    

    //
    // set the tier2 file pointer based on the product we're running on
    //
    
    //
    // retrieve product information
    //
    RtlZeroMemory( &ver, sizeof(ver) );
    ver.dwOSVersionInfoSize = sizeof(ver);
    Status = RtlGetVersion( (LPOSVERSIONINFOW)&ver );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (ver.wProductType == VER_NT_WORKSTATION) {
#if !defined(_AMD64_) && !defined(_IA64_)
        if (ver.wSuiteMask & VER_SUITE_PERSONAL)
        {
            Tier2Files = PerFiles;
            CountTier2Files = CountPerFiles;
        }
        else
#endif
        {
            Tier2Files = WksFiles;
            CountTier2Files = CountWksFiles;
        }
    } else {
        //
        // Datacenter MUST come before enterprise because the datacenter
        // suite also has the enterprise suite bit set
        //
        if (ver.wSuiteMask & VER_SUITE_DATACENTER) {
            Tier2Files = DtcFiles;
            CountTier2Files = CountDtcFiles;
        } else if (ver.wSuiteMask & VER_SUITE_ENTERPRISE) {
            Tier2Files = EntFiles;
            CountTier2Files = CountEntFiles;
        } 
#if !defined(_AMD64_) && !defined(_IA64_)
        else {
            Tier2Files = SrvFiles;
            CountTier2Files = CountSrvFiles;
        }
#endif
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SfcGetFiles(
    OUT PPROTECT_FILE_ENTRY *Files,
    OUT PULONG FileCount
    )
/*++

Routine Description:

    Retreives pointers to the file list and file count.  Note that we refer to 
    a "tier2" list here but in actuality there is no tier 1 list.
    
Arguments:

    Files - pointer to a PPROTECT_FILE_ENTRY, which is filled in with a pointer
            to the actual protected files list.
    FileCount - pointer to a ULONG which is filled in with the file count.

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status;


    if (CountTier2Files == 0) {
        Status = SfcFilesInit();
        if (!NT_SUCCESS(Status)) {
            *Files = NULL;
            *FileCount = 0;
            return Status;
        }
    }

    ASSERT(Tier2Files != NULL);
    ASSERT(CountTier2Files != 0);

    *Files = Tier2Files;
    *FileCount = CountTier2Files;

    return STATUS_SUCCESS;
}

NTSTATUS
pSfcGetFilesList(
    IN DWORD ListMask,
    OUT PPROTECT_FILE_ENTRY *Files,
    OUT PULONG FileCount
    )
/*++

Routine Description:

    Retreives pointers to the requested file list and file count.
    
    This is an internal testing routine that is used so that we can retrieve
    any file list on a given machine so testing does not have to install more
    than one build to get at multiple file lists
    
Arguments:

    ListMask - specifies a SFCFILESMASK_* constant
    Files - pointer to a PPROTECT_FILE_ENTRY, which is filled in with a pointer
            to the actual protected files list.
    FileCount - pointer to a ULONG which is filled in with the file count.

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS RetVal = STATUS_SUCCESS;

    if (!Files || !FileCount) {
        return(STATUS_INVALID_PARAMETER);
    }

    switch (ListMask) {
        case SFCFILESMASK_PROFESSIONAL:
            *Files = WksFiles;
            *FileCount = CountWksFiles;
            break;
#if !defined(_AMD64_) && !defined(_IA64_)
        case SFCFILESMASK_PERSONAL:
            *Files = PerFiles;
            *FileCount = CountPerFiles;
            break;
        case SFCFILESMASK_SERVER:
            *Files = SrvFiles;
            *FileCount = CountSrvFiles;
            break;
#endif
        case SFCFILESMASK_ADVSERVER:
            *Files = EntFiles;
            *FileCount = CountEntFiles;
            break;
        case SFCFILESMASK_DTCSERVER:
            *Files = DtcFiles;
            *FileCount = CountDtcFiles;
            break;
        default:
            RetVal = STATUS_INVALID_PARAMETER;
    }

    return RetVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\sm\sfc\publish\makefile.inc ===
#
# sfc.h, sfcapip.h, sfcapip.x, sfc.x
#


$(O)\sfc.x $(O)\sfcapip.x: sfc.w
    hsplit -e -o $(O)\sfc.x $(O)\sfcapip.x sfc.w

$(O)\sfc.h: $(O)\sfc.x
    wcshdr < $? > $@

$(O)\sfcapip.h: $(O)\sfcapip.x
    wcshdr < $? > $@

$(O)\sfcfiles.h : sfcfiles.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(SDK_INC_PATH)\sfc.h: $(O)\sfc.h
    $(PUBLISH_CMD) {$?=$@}

$(PROJECT_INC_PATH)\sfcapip.h: $(O)\sfcapip.h
    $(PUBLISH_CMD) {$?=$@}

$(PROJECT_INC_PATH)\sfcfiles.h : $(O)\sfcfiles.h
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\sm\sfc\sfcexts\sfcext.c ===
#include "sfcp.h"
#include "sfcfiles.h"
#include <wchar.h>

#define NOEXTAPI
#include <wdbgexts.h>
#undef DECLARE_API

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD_PTR dwCurrentPc,                  \
        PWINDBG_EXTENSION_APIS lpExtensionApis, \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disasm                  (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) ) \
  : ExtensionApis.lpReadProcessMemoryRoutine( (ULONG_PTR)(a), (b), (c), ((DWORD *)d) ))

#define WriteMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) ) \
  : ExtensionApis.lpWriteProcessMemoryRoutine( (ULONG_PTR)(a), (LPVOID)(b), (c), ((DWORD *)d) ))

#define Ioctl                   (ExtensionApis.lpIoctlRoutine)




WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;



PWSTR
MultiByteToUnicode(
    IN PCSTR String,
    IN UINT  Codepage
    )

/*++

Routine Description:

    Convert a string to unicode.

Arguments:

    String - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if string could not be converted (out of memory or invalid cp)
    Caller can free buffer with MyFree().

--*/

{
    UINT BytesIn8BitString;
    UINT CharsInUnicodeString;
    PWSTR UnicodeString;

    BytesIn8BitString = lstrlenA(String) + 1;

    //
    // Allocate maximally sized buffer.
    // If every character is a single-byte character,
    // then the buffer needs to be twice the size
    // as the 8bit string. Otherwise it might be smaller,
    // as some characters are 2 bytes in their unicode and
    // 8bit representations.
    //
    UnicodeString = malloc(BytesIn8BitString * sizeof(WCHAR));
    if(UnicodeString == NULL) {
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    CharsInUnicodeString = MultiByteToWideChar(
                                Codepage,
                                MB_PRECOMPOSED,
                                String,
                                BytesIn8BitString,
                                UnicodeString,
                                BytesIn8BitString
                                );

    if(CharsInUnicodeString == 0) {
        free(UnicodeString);
        return(NULL);
    }

    return(UnicodeString);

}




void
dump_SFC_REGISTRY_VALUE(
    PSFC_REGISTRY_VALUE srv,
    DWORD_PTR           Addr
    )
{
    SIZE_T cb;
    WCHAR buf[512];

    dprintf( "SFC_REGISTRY_VALUE at %p\n", Addr );
    dprintf( "\tEntry.Flink        = 0x%08x\n", srv->Entry.Flink );
    dprintf( "\tEntry.Blink        = 0x%08x\n", srv->Entry.Blink );
    ReadMemory( srv->FileName.Buffer, buf, srv->FileName.Length+sizeof(WCHAR), &cb);
    dprintf( "\tFileName           = %ws\n",    buf );
    ReadMemory( srv->DirName.Buffer, buf, srv->DirName.Length+sizeof(WCHAR), &cb);
    dprintf( "\tDirName            = %ws\n",    buf );
    ReadMemory( srv->FullPathName.Buffer, buf, srv->FullPathName.Length+sizeof(WCHAR), &cb);
    dprintf( "\tFullPathName       = %ws\n",    buf );
    ReadMemory( srv->InfName.Buffer, buf, srv->FileName.Length+sizeof(WCHAR), &cb);
    dprintf( "\tInfName            = %ws\n",    srv->InfName );
    ReadMemory( srv->SourceFileName.Buffer, buf, srv->SourceFileName.Length+sizeof(WCHAR), &cb);
    dprintf( "\tSourceFileName     = %ws\n",    srv->SourceFileName );
    dprintf( "\tDirHandle          = 0x%08x\n", srv->DirHandle  );
    //dprintf( "\tFlags              = 0x%08x\n", srv->IgnoreNextChange  );
}

void
dump_IMAGE_VALIDATION_DATA(
    PIMAGE_VALIDATION_DATA ivd
    )
{
    dprintf( "DllVersion         = 0x%I64x\n", ivd->DllVersion );
    dprintf( "DllCheckSum        = 0x%08x\n", ivd->DllCheckSum );
    dprintf( "SignatureValid     = %s\n", ivd->SignatureValid ? "true" : "false"  );
    dprintf( "FilePresent        = %s\n", ivd->FilePresent ? "true" : "false"  );
}

void
dump_COMPLETE_VALIDATION_DATA(
    PCOMPLETE_VALIDATION_DATA cvd
    )
{
    dprintf( "*Original*           = 0x%08x\n", &cvd->Original );
    dump_IMAGE_VALIDATION_DATA( &cvd->Original );
    dprintf( "*Cache*              = 0x%08x\n", &cvd->Cache );
    dump_IMAGE_VALIDATION_DATA( &cvd->Cache );
    dprintf( "*New*              = 0x%08x\n", &cvd->New );
    dump_IMAGE_VALIDATION_DATA( &cvd->New );
    dprintf( "RestoreFromReal    = %s\n", cvd->RestoreFromReal ? "true" : "false"  );
    dprintf( "RestoreFromCache   = %s\n", cvd->RestoreFromCache ? "true" : "false"  );
    dprintf( "RestoreFromMedia   = %s\n", cvd->RestoreFromMedia ? "true" : "false"  );
    dprintf( "NotifyUser         = %s\n", cvd->NotifyUser ? "true" : "false"  );
    dprintf( "BadCacheEntry      = %s\n", cvd->BadCacheEntry ? "true" : "false"  );
}

void
dump_RESTORE_QUEUE(
    PRESTORE_QUEUE rq,
    DWORD_PTR  Addr
    )
{
    dprintf( "RESTORE_QUEUE at %p\n", Addr );
    dprintf( "FileQueue = %p\n", rq->FileQueue  );
    dprintf( "QueueCount = %d\n", rq->QueueCount  );
    dprintf( "RestoreInProgress   = %s\n", rq->RestoreInProgress ? "true" : "false"  );
    dprintf( "RestoreComplete   = %s\n", rq->RestoreComplete ? "true" : "false"  );
    dprintf( "RestoreStatus   = %s\n", rq->RestoreStatus ? "true" : "false"  );
    dprintf( "LastErrorCode   = %d (0x%08x)\n", rq->LastErrorCode, rq->LastErrorCode );
    dprintf( "WorkerThreadHandle = %d\n", rq->WorkerThreadHandle );

}

void
dump_VALIDATION_REQUEST_DATA(
    PVALIDATION_REQUEST_DATA vrd,
    DWORD_PTR           Addr
    )
{
    SIZE_T cb;
    SFC_REGISTRY_VALUE RegVal;


    dprintf( "**VALIDATION_REQUEST_DATA at address = 0x%p**\n", Addr );

#if DBG
    if (vrd->Signature != 0x69696969) {
        dprintf( "**** invalid queue entry, signature does not match\n" );
        return;
    }
#endif

    dprintf( "\tEntry.Flink        = 0x%08x\n", vrd->Entry.Flink );
    dprintf( "\tEntry.Blink        = 0x%08x\n", vrd->Entry.Blink );
    dprintf( "\tImageValData       = 0x%08x\n", &vrd->ImageValData );
    dump_COMPLETE_VALIDATION_DATA( &vrd->ImageValData );
    dprintf( "\tRegVal             = 0x%08x\n", vrd->RegVal );
    ReadMemory( vrd->RegVal, &RegVal, sizeof(SFC_REGISTRY_VALUE), &cb);
    dump_SFC_REGISTRY_VALUE( &RegVal, (DWORD_PTR)vrd->RegVal );
    dprintf( "\tChangeType         = %d\n",     vrd->ChangeType );
    dprintf( "\tCopyCompleted      = %s\n",     vrd->CopyCompleted ? "true" : "false"  );
    dprintf( "\tWin32Error         = %d (0x%08x)\n", vrd->Win32Error, vrd->Win32Error  );
    dprintf( "\tFlags              = 0x%08x\n", vrd->Flags );
    dprintf( "\tRetryCount         = 0x%08x\n", vrd->RetryCount );
    dprintf( "\tSyncOnly           = %s\n",     vrd->SyncOnly ? "true" : "false"  );
}

void
dump_PROTECT_FILE_ENTRY(
    PPROTECT_FILE_ENTRY Entry,
    DWORD_PTR           Addr
    )
{
    WCHAR  SourceFileBuffer[MAX_PATH];
    WCHAR  DestFileBuffer[MAX_PATH];
    WCHAR  InfNameBuffer[MAX_PATH];
    SIZE_T cb;

    if (Entry->SourceFileName) {
        ReadMemory( Entry->SourceFileName, SourceFileBuffer, sizeof(SourceFileBuffer), &cb);
    }else {
        SourceFileBuffer[0] = L'\0';
    }

    if (Entry->FileName) {
        ReadMemory( Entry->FileName, DestFileBuffer, sizeof(DestFileBuffer), &cb);
    }else {
        DestFileBuffer[0] = L'\0';
    }

    if (Entry->InfName) {
        ReadMemory( Entry->InfName, InfNameBuffer, sizeof(InfNameBuffer), &cb);
    }else {
        InfNameBuffer[0] = L'\0';
    }

    dprintf( " PROTECT_FILE_ENTRY at %p\n", Addr );
    dprintf( " \tSourceFileName = %S\n" , SourceFileBuffer[0] ? SourceFileBuffer : L"[Same as target name]" );
    dprintf( " \tFileName = %S\n" , DestFileBuffer  );
    dprintf( " \tInfName = %S\n" , InfNameBuffer[0] ? InfNameBuffer : L"[None, default to layout.inf]" );

}

BOOL
DoesProtFileEntryMatch(
    PPROTECT_FILE_ENTRY Entry,
    DWORD_PTR           Addr,
    PCWSTR              FileName
    )
{
    WCHAR  SourceFileBuffer[MAX_PATH];
    WCHAR  DestFileBuffer[MAX_PATH];
    WCHAR  InfNameBuffer[MAX_PATH];
    DWORD  count;
    PCWSTR p;
    SIZE_T cb;
    PCWSTR a[3] = { SourceFileBuffer, DestFileBuffer, InfNameBuffer } ;

    if (Entry->SourceFileName) {
        ReadMemory( Entry->SourceFileName, SourceFileBuffer, sizeof(SourceFileBuffer), &cb);
    }else {
        SourceFileBuffer[0] = L'\0';
    }

    if (Entry->FileName) {
        ReadMemory( Entry->FileName, DestFileBuffer, sizeof(DestFileBuffer), &cb);
    }else {
        DestFileBuffer[0] = L'\0';
    }

    if (Entry->InfName) {
        ReadMemory( Entry->InfName, InfNameBuffer, sizeof(InfNameBuffer), &cb);
    }else {
        InfNameBuffer[0] = L'\0';
    }

    for (count = 0; count < 3; count++) {

        p = wcsrchr( a[count], L'\\' );
        if (p) {
            p += 1;
            if (_wcsicmp(p, FileName)== 0) {
                return(TRUE);
            }
        }
    }

    return(FALSE);

}

BOOL
DoesRegEntryMatch(
    PSFC_REGISTRY_VALUE Entry,
    DWORD_PTR           Addr,
    PCWSTR              FileName
    )
{
    WCHAR  Buffer[MAX_PATH];
    DWORD  count;
    PCWSTR p;
    SIZE_T cb;
    PUNICODE_STRING a[5];

    a[0] = &Entry->FileName;
    a[1] = &Entry->DirName;
    a[2] = &Entry->FullPathName;
    a[3] = &Entry->InfName;
    a[4] = &Entry->SourceFileName;

    for (count = 0; count < 5; count++) {
        if (a[count]->Buffer) {
            ReadMemory( a[count]->Buffer, Buffer, sizeof(Buffer), &cb);
        }
        p = wcsrchr( Buffer, L'\\' );
        if (p) {
            p += 1;
        } else {
            p = Buffer;
        }
        if (_wcsicmp(p, FileName)== 0) {
            return(TRUE);
        }
    }

    return(FALSE);

}



DECLARE_API( help )
{
    INIT_API();

    dprintf( "WFP debugger extension commands:\n" );
    dprintf( "dumpq -  dump validation queue\n" );
    dprintf( "dumpsettings - dump global WFP settings\n" );
    dprintf( "isprotfile [filename] - search for a particular protected file in the list\n" );
    dprintf( "isprotfile [list address] [list count address] [filename] - search for a particular protected file in the list\n" );
    dprintf( "protfile - list all protected files in list\n" );
    dprintf( "protfile - [list address] [list count address] list all protected files in list\n" );
}


DECLARE_API( dumpq )
{
    DWORD_PTR addr;
    SIZE_T cb;
    LIST_ENTRY Next;
    VALIDATION_REQUEST_DATA vrd;



    INIT_API();

    addr = GetExpression( "SfcErrorQueue" );
    if (!addr) {
        dprintf("couldn't get address");
        return;
    }
    dprintf( "SfcErrorQueue address=0x%p\n", addr );

    ReadMemory( addr, &Next, sizeof(Next), &cb);

    if (Next.Flink == (PVOID)addr) {
        dprintf( "queue is empty\n" );
        return;
    }

    do {
        ReadMemory( Next.Flink, &vrd, sizeof(VALIDATION_REQUEST_DATA), &cb);
        dump_VALIDATION_REQUEST_DATA( &vrd, (DWORD_PTR)Next.Flink );
        Next.Flink = vrd.Entry.Flink;
        if (Next.Flink != (PVOID)addr) {
            dprintf( "\n******************************************\n\n" );
        }

        if (CheckControlC() ) {
            dprintf( "\nInterrupted\n\n" );
            break;
        }
    } while (Next.Flink != (PVOID)addr);
}

DECLARE_API( dumpsettings )
{
    DWORD_PTR addr;
    SIZE_T cb;
    DWORD val;


    INIT_API();


    addr = GetExpression( "SFCDisable" );

    if (!addr) {
        dprintf("couldn't get address");
        return;
    }

    ReadMemory( addr, &val, sizeof(DWORD), &cb);
    dprintf( "SFCDisable = %d\n", val );
}

DECLARE_API( dumpregval )
{
    DWORD_PTR addr;
    SIZE_T cb;
    SFC_REGISTRY_VALUE regval;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        addr = GetExpression( lpArgumentString );
    } else {
        dprintf("bogus usage\n");
        return;
    }

    if (!addr) {
        dprintf("couldn't get address");
        return;
    }

    ReadMemory( addr, &regval, sizeof(SFC_REGISTRY_VALUE), &cb);
    dump_SFC_REGISTRY_VALUE( &regval, (DWORD_PTR)addr );

    return;

}


DECLARE_API( dumprq )
{
    DWORD_PTR addr;
    SIZE_T cb;
    RESTORE_QUEUE rq;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        addr = GetExpression( lpArgumentString );
    } else {
        dprintf("bogus usage\n");
        return;
    }

    if (!addr) {
        dprintf("couldn't get address");
        return;
    }

    ReadMemory( addr, &rq, sizeof(RESTORE_QUEUE), &cb);
    dump_RESTORE_QUEUE( &rq, addr );

    return;

}


DECLARE_API( dumpvrd )
{
    DWORD_PTR addr;
    SIZE_T cb;
    VALIDATION_REQUEST_DATA vrd;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        addr = GetExpression( lpArgumentString );
    } else {
        dprintf("bogus usage\n");
        return;
    }

    if (!addr) {
        dprintf("couldn't get address");
        return;
    }

    ReadMemory( addr, &vrd, sizeof(VALIDATION_REQUEST_DATA), &cb);
    dump_VALIDATION_REQUEST_DATA( &vrd, addr );

    return;

}



DECLARE_API( protfile )
{
    DWORD_PTR addrNext, addrTotal;
    SIZE_T cb;
    PROTECT_FILE_ENTRY Next;
    ULONG Total;
    ULONG Current;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        addrNext = GetExpression( lpArgumentString );

        while (*lpArgumentString && (*lpArgumentString != ' ') ) {
           lpArgumentString++;
        }
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        if (*lpArgumentString) {
            addrTotal = GetExpression( lpArgumentString );
        } else {
            dprintf("bogus usage\n");
            return;
        }
    }

    else {
        addrNext = GetExpression( "sfc!Tier2Files" );
        addrTotal = GetExpression( "sfc!CountTier2Files" );
    }

    if (!addrTotal || !addrNext) {
       dprintf("couldn't get address");
       return;
    }

    ReadMemory( addrNext, &Next, sizeof(PROTECT_FILE_ENTRY), &cb);
    ReadMemory( addrTotal, &Total, sizeof(ULONG), &cb);

    dprintf( "Tier2Files: address=0x%p Total=%d\n", addrNext, Total );

    Current = 0;
    while (Current < Total) {

        dump_PROTECT_FILE_ENTRY( &Next, addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)) );

        ReadMemory( addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)), &Next, sizeof(PROTECT_FILE_ENTRY), &cb);

        Current += 1;

        if ( CheckControlC() ) {
           dprintf( "\nInterrupted\n\n" );
           break;
        }
    }


}

DECLARE_API( isprotfile )
{
    DWORD_PTR addrNext, addrTotal;
    PCSTR FileName;
    SIZE_T cb;
    PROTECT_FILE_ENTRY Next;
    ULONG Total;
    ULONG Current;
    BOOL FoundMatch = FALSE;
    PCWSTR FileNameW;


    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        FileName = lpArgumentString;
        addrNext = GetExpression( lpArgumentString );

        while (*lpArgumentString && (*lpArgumentString != ' ') ) {
           lpArgumentString++;
        }
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        if (*lpArgumentString) {
            addrTotal = GetExpression( lpArgumentString );
        } else {
            addrNext = GetExpression( "sfc!Tier2Files" );
            addrTotal = GetExpression( "sfc!CountTier2Files" );
            goto doit;
        }

        while (*lpArgumentString && (*lpArgumentString != ' ') ) {
           lpArgumentString++;
        }
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        if (*lpArgumentString) {
            FileName = lpArgumentString;
        } else {
            dprintf("bogus usage\n");
            return;
        }

    } else {
        dprintf("bogus usage\n");
        return;
    }

doit:

    if (!addrTotal || !addrNext) {
        dprintf("couldn't get address");
        return;
    }

    ReadMemory( addrNext, &Next, sizeof(PROTECT_FILE_ENTRY), &cb);
    ReadMemory( addrTotal, &Total, sizeof(ULONG), &cb);


    FileNameW = MultiByteToUnicode( FileName, CP_ACP );
    if (!FileNameW) {
        dprintf("Error: couldn't convert filename to unicode string\n");
        return;
    }

    Current = 0;
    while (Current < Total) {

        if (DoesProtFileEntryMatch( &Next, addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)),FileNameW )) {
            dump_PROTECT_FILE_ENTRY( &Next, addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)) );
            FoundMatch = TRUE;
        }

        ReadMemory( addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)), &Next, sizeof(PROTECT_FILE_ENTRY), &cb);

        Current += 1;

        if ( CheckControlC() ) {
           dprintf( "\nInterrupted\n\n" );
           break;
        }
    }

    if (!FoundMatch) {
        dprintf( "Couldn't find %s in list\n", FileName );
    }

    free((PVOID)FileNameW);

}

DECLARE_API( regvals )
{
    DWORD_PTR addrNext, addrTotal;
    SIZE_T cb;
    SFC_REGISTRY_VALUE Next;
    ULONG Total;
    ULONG Current;



    INIT_API();

    addrNext = GetExpression( "sfc!SfcProtectedDllsList" );
    addrTotal = GetExpression( "sfc!SfcProtectedDllCount" );

    if (!addrNext || ! addrTotal) {
        dprintf("Error: couldn't resolve sfc!SfcProtectedDllsList and sfc!SfcProtectedDllCount\n");
        return;
    }

    ReadMemory( addrNext, &Next, sizeof(PROTECT_FILE_ENTRY), &cb);
    ReadMemory( addrTotal, &Total, sizeof(ULONG), &cb);


    dprintf( "SfcProtectedDllsList: address=0x%p Total=%d\n", addrNext, Total );

    Current = 0;
    while (Current < Total) {

        dump_SFC_REGISTRY_VALUE( &Next, addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)) );

        ReadMemory( addrNext+(Current*sizeof(SFC_REGISTRY_VALUE)), &Next, sizeof(SFC_REGISTRY_VALUE), &cb);

        Current += 1;

        if ( CheckControlC() ) {
           dprintf( "\nInterrupted\n\n" );
           break;
        }
    }

}


DECLARE_API( getregval )
{
    DWORD_PTR addrNext, addrTotal;
    PCSTR FileName;
    SIZE_T cb;
    SFC_REGISTRY_VALUE Next;
    ULONG Total;
    ULONG Current;
    BOOL FoundMatch = FALSE;
    PCWSTR FileNameW;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        FileName = lpArgumentString;
    } else {
        dprintf("bogus usage\n");
        return;
    }

    addrNext = GetExpression( "sfc!SfcProtectedDllsList" );
    addrTotal = GetExpression( "sfc!SfcProtectedDllCount" );

    if (!addrNext || ! addrTotal) {
        dprintf("Error: couldn't resolve sfc!SfcProtectedDllsList and sfc!SfcProtectedDllCount\n");
        return;
    }

    ReadMemory( addrNext, &Next, sizeof(PROTECT_FILE_ENTRY), &cb);
    ReadMemory( addrTotal, &Total, sizeof(ULONG), &cb);


    FileNameW = MultiByteToUnicode( FileName, CP_ACP );
    if (!FileNameW) {
        dprintf("Error: couldn't convert filename to unicode string\n");
        return;
    }

    Current = 0;
    while (Current < Total) {

        if (DoesRegEntryMatch( &Next, addrNext+(Current*sizeof(SFC_REGISTRY_VALUE)),FileNameW )) {
            dump_SFC_REGISTRY_VALUE( &Next, addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)) );
            FoundMatch = TRUE;
        }

        ReadMemory( addrNext+(Current*sizeof(SFC_REGISTRY_VALUE)), &Next, sizeof(SFC_REGISTRY_VALUE), &cb);

        Current += 1;

        if ( CheckControlC() ) {
           dprintf( "\nInterrupted\n\n" );
           break;
        }
    }

    if (!FoundMatch) {
        dprintf( "Couldn't find %s in list\n", FileName );
    }

    free((PVOID)FileNameW);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\sm\sfc\test\resource.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Resource header file.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

--*/

#define IDC_STATIC                              -1
#define IDI_CDROM                               201
#define IDD_SFC_CD_PROMPT                       402
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\bldrthnk\bldrthnk.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bldrthnk.c

Abstract:

    This module implements a program which generates code to thunk from
    32-bit to 64-bit structures.

    This code is generated as an aid to the AMD64 boot loader, which
    must generate 64-bit structures from 32-bit structures.

Author:

    Forrest C. Foltz (forrestf) 15-May-2000


To use:

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "bldrthnk.h"

//
// Internal type definitions follow
// 

typedef struct _OBJ {
    PCHAR Image;
    LONG ImageSize;
    PDEFINITIONS Definitions;
} OBJ, *POBJ;

typedef struct _TYPE_REC  *PTYPE_REC;
typedef struct _FIELD_REC *PFIELD_REC;

typedef struct _TYPE_REC {
    PTYPE_REC Next;
    PCHAR Name;
    ULONG Size32;
    ULONG Size64;
    PFIELD_REC FieldList;
    BOOL SignExtend;
    BOOL Fabricated;
    BOOL Only64;
} TYPE_REC;

typedef struct _FIELD_REC {
    PFIELD_REC Next;
    PCHAR Name;
    PCHAR TypeName;
    PCHAR SizeFormula;
    ULONG TypeSize32;
    ULONG TypeSize64;
    ULONG Offset32;
    ULONG Offset64;
    ULONG Size32;
    ULONG Size64;
    PTYPE_REC TypeRec;
} FIELD_REC;

//
// Static TYPE_REC describing a 64-bit pointer type
//

TYPE_REC pointer64_typerec = {
    NULL,
    "POINTER64",
    4,
    8,
    NULL,
    TRUE,
    TRUE };

//
// Inline routine to generate a 32-bit pointer value from a ULONGLONG
// value found in an .obj file.
//

__inline
PVOID
CalcPtr(
    IN ULONGLONG Address
    )
{
    return (PVOID)((ULONG)Address);
}

//
// Forward declarations follow
// 

VOID
ApplyFixupsToImage(
    IN PCHAR ObjImage
    );

VOID
__cdecl
CheckCondition(
    int Condition,
    const char *FormatString,
    ...
    );

VOID
FabricateMissingTypes(
    VOID
    );

PTYPE_REC
FindTypeRec(
    IN PCHAR Name
    );

PVOID
GetMem(
    IN ULONG Size
    );

VOID
NewGlobalType(
    IN PTYPE_REC TypeRec
    );

BOOL
ProcessStructure(
    IN ULONG StrucIndex
    );

void
ReadObj(
    IN PCHAR Path,
    OUT POBJ Obj
    );

int
Usage(
    void
    );

VOID
WriteCopyList(
    IN PTYPE_REC TypeRec
    );

VOID
WriteCopyListWorker(
    IN PTYPE_REC TypeRec,
    IN ULONG Offset32,
    IN ULONG Offset64,
    IN PCHAR ParentName
    );

VOID
WriteCopyRoutine(
    IN PTYPE_REC TypeRec
    );

VOID
WriteThunkSource(
    VOID
    );

//
// Global data follows.  
// 

OBJ Obj32;
OBJ Obj64;
PTYPE_REC TypeRecList = NULL;

int
__cdecl
main(
    IN int argc,
    IN char *argv[]
    )

/*++

Routine Description:

    This is the main entrypoint of bldrthnk.exe.  Two command-line arguments
    are expected: first the path to the 32-bit .obj module, the second to
    the path to the 64-bit .obj module.  The .objs are expected to be the
    result of compiling m4-generated structure definition code.

Arguments:

Return value:

    0 for success, non-zero otherwise.

--*/

{
    ULONG strucIndex;

    //
    // argv[1] is the name of the 32-bit obj, argv[2] is the name of the
    // 64-bit obj
    // 

    if (argc != 3) {
        return Usage();
    }

    //
    // Usage:
    //
    // bldrthnk <32-bit.obj> <64-bit.obj>
    //

    ReadObj( argv[1], &Obj32 );
    ReadObj( argv[2], &Obj64 );

    //
    // Process each STRUC_DEF structure
    //

    strucIndex = 0;
    while (ProcessStructure( strucIndex )) {
        strucIndex += 1;
    }

    FabricateMissingTypes();

    //
    // Write out the file
    //

    WriteThunkSource();

    return 0;
}

int
Usage(
    VOID
    )

/*++

Routine Description:

    Displays program usage.

Arguments:

Return value:

--*/

{
    fprintf(stderr, "Usage: bldrthnk.exe <32-bit obj> <64-bit obj>\n");
    return -1;
}

void
ReadObj(
    IN PCHAR Path,
    OUT POBJ Obj
    )

/*++

Routine Description:

    Allocates an appropriate buffer, and reads into it the supplied object
    image in its entirety.

Arguments:

    Path - Supplies the path of the object image to process.

    Obj - Supplies a pointer to an OBJ structure which upon return will
        updated with the appropriate data.

Return value:

    None.

--*/

{
    FILE *objFile;
    int result;
    long objImageSize;
    PCHAR objImage;
    PULONG sigPtr;
    PULONG srchEnd;
    PDEFINITIONS definitions;
    LONGLONG imageBias;

    //
    // Open the file
    //

    objFile = fopen( Path, "rb" );
    CheckCondition( objFile != NULL,
                    "Cannot open %s for reading.\n",
                    Path );

    //
    // Get the file size, allocate a buffer, read it in, and close.
    //

    result = fseek( objFile, 0, SEEK_END );
    CheckCondition( result == 0,
                    "fseek() failed, error %d\n",
                    errno );

    objImageSize = ftell( objFile );
    CheckCondition( objImageSize != -1L,
                    "ftell() failed, error %d\n",
                    errno );

    CheckCondition( objImageSize > 0,
                    "%s appears to be corrupt\n",
                    Path );

    objImage = GetMem( objImageSize );

    result = fseek( objFile, 0, SEEK_SET );
    CheckCondition( result == 0,
                    "fseek() failed, error %d\n",
                    errno );

    result = fread( objImage, 1, objImageSize, objFile );
    CheckCondition( result == objImageSize,
                    "Error reading from %s\n",
                    Path );

    fclose( objFile );

    //
    // Find the start of the "definitions" array by looking for
    // SIG_1 followed by SIG_2
    //

    srchEnd = (PULONG)(objImage + objImageSize - 2 * sizeof(SIG_1));
    sigPtr = (PULONG)objImage;
    definitions = NULL;

    while (sigPtr < srchEnd) {

        if (sigPtr[0] == SIG_1 && sigPtr[1] == SIG_2) {
            definitions = (PDEFINITIONS)sigPtr;
            break;
        }

        sigPtr = (PULONG)((PCHAR)sigPtr + 1);
    }
    CheckCondition( definitions != NULL,
                    "Error: could not find signature in %s\n",
                    Path );

    //
    // Perform fixups on the image
    //

    ApplyFixupsToImage( objImage );

    //
    // Fill in the output structure and return
    // 

    Obj->Image = objImage;
    Obj->ImageSize = objImageSize;
    Obj->Definitions = definitions;
}

VOID
__cdecl
CheckCondition(
    int Condition,
    const char *FormatString,
    ...
    )

/*++

Routine Description:

    Asserts that Condition is non-zero.  If Condition is zero, FormatString
    is processed and displayed, and the program is terminated.

Arguments:

    Condition - Supplies the boolean value to evaluate.

    FormatString, ... - Supplies the format string and optional parameters
        to display in the event of a zero Condition.

Return value:

    None.

--*/

{
    va_list(arglist);

    va_start(arglist, FormatString);

    if( Condition == 0 ){

        //
        // A fatal error was encountered.  Bail.
        //

        vprintf( FormatString, arglist );
        perror( "genxx" );
        exit(-1);
    }
}

BOOL
ProcessStructure(
    IN ULONG StrucIndex
    )

/*++

Routine Description:

    Processes a single pair of structure definitions, 32-bit and 64-bit,
    respectively.

    Processing includes generating a TYPE_REC and associated FIELD_RECs for
    the definition pair.

Arguments:

    StrucIndex - Supplies the index into the array of STRUC_DEF structures
        found within each of the object images.

Return value:

    TRUE if the processing was successful, FALSE otherwise (e.g. a terminating
    record was located).

--*/

{
    PSTRUC_DEF Struc32, Struc64;
    PFIELD_DEF Field32, Field64;

    ULONG strLen;
    ULONG strLen2;
    ULONG strLen3;
    PTYPE_REC typeRec;
    PFIELD_REC fieldRec;
    PFIELD_REC insertNode;
    BOOL only64;

    ULONG index;

    Struc32 = CalcPtr( Obj32.Definitions->Structures[ StrucIndex ] );
    Struc64 = CalcPtr( Obj64.Definitions->Structures[ StrucIndex ] );

    if (Struc64 == NULL) {
        return FALSE;
    }

    if (Struc32 == NULL) {
        only64 = TRUE;
    } else {
        only64 = FALSE;
    }

    CheckCondition( Struc64 != NULL &&
                    ((only64 != FALSE) ||
                     strcmp( Struc32->Name, Struc64->Name ) == 0),
                    "Mismatched structure definitions found.\n" );

    //
    // Allocate and build a TYPE_REC for this STRUC_DEF
    //

    strLen = strlen( Struc64->Name ) + sizeof(char);
    typeRec = GetMem( sizeof(TYPE_REC) + strLen );
    typeRec->Name = (PCHAR)(typeRec + 1);
    typeRec->Only64 = only64;

    memcpy( typeRec->Name, Struc64->Name, strLen );

    if (only64 == FALSE) {
        typeRec->Size32 = Struc32->Size;
    }

    typeRec->Size64 = Struc64->Size;
    typeRec->FieldList = NULL;
    typeRec->SignExtend = FALSE;
    typeRec->Fabricated = FALSE;

    //
    // Create the FIELD_RECs hanging off of this type
    //

    index = 0;
    while (TRUE) {

        if (only64 == FALSE) {
            Field32 = CalcPtr( Struc32->Fields[index] );
        }

        Field64 = CalcPtr( Struc64->Fields[index] );

        if (Field64 == NULL) {
            break;
        }

        if (only64 == FALSE) {
            CheckCondition( strcmp( Field32->Name, Field64->Name ) == 0 &&
                            strcmp( Field32->TypeName, Field64->TypeName ) == 0,
                            "Mismatched structure definitions found.\n" );
        }

        strLen = strlen( Field64->Name ) + sizeof(CHAR);
        strLen2 = strlen( Field64->TypeName ) + sizeof(CHAR);
        strLen3 = strlen( Field64->SizeFormula );
        if (strLen3 > 0) {
            strLen3 += sizeof(CHAR);
        }

        fieldRec = GetMem( sizeof(FIELD_REC) + strLen + strLen2 + strLen3 );
        fieldRec->Name = (PCHAR)(fieldRec + 1);
        fieldRec->TypeName = fieldRec->Name + strLen;

        memcpy( fieldRec->Name, Field64->Name, strLen );
        memcpy( fieldRec->TypeName, Field64->TypeName, strLen2 );

        if (strLen3 > 0) {
            fieldRec->SizeFormula = fieldRec->TypeName + strLen2;
            memcpy( fieldRec->SizeFormula, Field64->SizeFormula, strLen3 );
        } else {
            fieldRec->SizeFormula = NULL;
        }

        if (only64 == FALSE) {
            fieldRec->Offset32 = Field32->Offset;
            fieldRec->Size32 = Field32->Size;
            fieldRec->TypeSize32 = Field32->TypeSize;
        }

        fieldRec->Offset64 = Field64->Offset;
        fieldRec->TypeSize64 = Field64->TypeSize;
        fieldRec->Size64 = Field64->Size;

        fieldRec->Next = NULL;
        fieldRec->TypeRec = NULL;

        //
        // Insert at the end of the list
        //

        insertNode = CONTAINING_RECORD( &typeRec->FieldList,
                                        FIELD_REC,
                                        Next );
        while (insertNode->Next != NULL) {
            insertNode = insertNode->Next;
        }
        insertNode->Next = fieldRec;

        index += 1;
    }

    //
    // Insert it into the global list
    //

    CheckCondition( FindTypeRec( typeRec->Name ) == NULL,
                    "Duplicate definition for structure %s\n",
                    typeRec->Name );

    NewGlobalType( typeRec );

    return TRUE;
}

PTYPE_REC
FindTypeRec(
    IN PCHAR Name
    )

/*++

Routine Description:

    Searches the global list of TYPE_REC structures for one with a name
    that matches the supplied name.

Arguments:

    Name - pointer to a null-terminated string representing the name of
        the sought type.

Return value:

    A pointer to the matching TYPE_REC, or NULL if a match was not found.

--*/

{
    PTYPE_REC typeRec;

    typeRec = TypeRecList;
    while (typeRec != NULL) {

        if (strcmp( Name, typeRec->Name ) == 0) {
            return typeRec;
        }

        typeRec = typeRec->Next;
    }
    return NULL;
}

PVOID
GetMem(
    IN ULONG Size
    )

/*++

Routine Description:

    Memory allocator.  Works just like malloc() except that triggers a
    fatal error in the event of an out-of-memory condition.

Arguments:

    Size - number of bytes to allocate.

Return value:

    Returns a pointer to a block of memory of the specified size.

--*/

{
    PVOID mem;

    mem = malloc( Size );
    CheckCondition( mem != NULL,
                    "Out of memory.\n" );

    return mem;
}

VOID
FabricateMissingTypes(
    VOID
    )

/*++

Routine Description:

    Routine to generate TYPE_REC records for simple types referenced, but
    not defined, by a structure layout file.

Arguments:

    None.

Return value:

    None.

--*/

{
    PTYPE_REC typeRec;
    PTYPE_REC fieldTypeRec;
    PFIELD_REC fieldRec;
    PCHAR fieldTypeName;
    ULONG strLen;

    typeRec = TypeRecList;
    while (typeRec != NULL) {

        fieldRec = typeRec->FieldList;
        while (fieldRec != NULL) {

            fieldTypeRec = FindTypeRec( fieldRec->TypeName );
            if (fieldTypeRec == NULL) {

                if (typeRec->Only64 == FALSE) {
                    CheckCondition( (fieldRec->Size32 == fieldRec->Size64) ||
    
                                    ((fieldRec->Size32 == 1 ||
                                      fieldRec->Size32 == 2 ||
                                      fieldRec->Size32 == 4 ||
                                      fieldRec->Size32 == 8) &&
                                     (fieldRec->Size64 > fieldRec->Size32) &&
                                     (fieldRec->Size64 % fieldRec->Size32 == 0)),
    
                                    "Must specify type %s (%s)\n",
                                    fieldRec->TypeName,
                                    typeRec->Name );
                }

                //
                // No typerec exists for this type.  Assume it is a simple
                // type.
                //

                if ((typeRec->Only64 != FALSE &&
                     fieldRec->Size64 == sizeof(ULONGLONG) &&
                     *fieldRec->TypeName == 'P') ||

                    (fieldRec->Size32 == sizeof(PVOID) &&
                     fieldRec->Size64 == sizeof(ULONGLONG))) {

                    //
                    // Either a pointer or [U]LONG_PTR type.  Make
                    // it longlong.
                    //

                    fieldTypeRec = &pointer64_typerec;

                } else {

                    //
                    // Some other type.
                    // 

                    strLen = strlen( fieldRec->TypeName ) + sizeof(CHAR);
                    fieldTypeRec = GetMem( sizeof(TYPE_REC) + strLen );
                    fieldTypeRec->Name = (PCHAR)(fieldTypeRec + 1);
                    memcpy( fieldTypeRec->Name, fieldRec->TypeName, strLen );
                    fieldTypeRec->Size32 = fieldRec->Size32;
                    fieldTypeRec->Size64 = fieldRec->Size64;
                    fieldTypeRec->FieldList = NULL;
                    fieldTypeRec->SignExtend = TRUE;
                    fieldTypeRec->Fabricated = TRUE;

                    NewGlobalType( fieldTypeRec );
                }

            }
            fieldRec->TypeRec = fieldTypeRec;
            fieldRec = fieldRec->Next;
        }
        typeRec = typeRec->Next;
    }
}

VOID
WriteCopyRecord(
    IN ULONG Offset32,
    IN ULONG Offset64,
    IN PCHAR TypeName,
    IN ULONG Size32,
    IN ULONG Size64,
    IN BOOL SignExtend,
    IN PCHAR FieldName,
    IN BOOL Last
    )

/*++

Routine Description:

    Support routine to generate the text of a copy record.

Arguments:

    Offset32 - Offset of this field within a 32-bit structure layout

    Offset64 - Offset of this field within a 64-bit structure layout

    Size32 - Size of this field within a 32-bit structure layout

    Size64 - Size of this field within a 64-bit structure layout

    SignExtend - Indicates whether this type should be sign extended or not

    FieldName - Name of the field

    Last - Whether this is the last copy record in a zero-terminated list

Return value:

    None

--*/

{
    CHAR buf[ 255 ];

    if (SignExtend) {
        sprintf(buf,"IS_SIGNED_TYPE(%s)", TypeName);
    } else {
        sprintf(buf,"FALSE");
    }

    printf("    { \t0x%x, \t0x%x, \t0x%x, \t0x%x, \t%5s }%s\n",
           Offset32,
           Offset64,
           Size32,
           Size64,
           buf,
           Last ? "" : "," );
}

VOID
WriteDefinition64(
    IN PTYPE_REC TypeRec
    )

/*++

Routine Description:

    Generates a structure definition that represents, to a 32-bit compiler,
    the layout of a 64-bit structure.

Arguments:

    TypeRec - Pointer to the TYPE_REC structure defining this type.

Return value:

    None.

--*/

{
    PFIELD_REC fieldRec;
    ULONG currentOffset;
    PTYPE_REC fieldTypeRec;
    ULONG padBytes;
    ULONG reservedCount;

    currentOffset = 0;
    reservedCount = 0;

    printf("typedef struct _%s_64 {\n", TypeRec->Name );

    fieldRec = TypeRec->FieldList;
    while (fieldRec != NULL) {

        fieldTypeRec = fieldRec->TypeRec;
        padBytes = fieldRec->Offset64 - currentOffset;
        if (padBytes > 0) {

            printf("    UCHAR Reserved%d[ 0x%x ];\n",
                   reservedCount,
                   padBytes );

            currentOffset += padBytes;
            reservedCount += 1;
        }

        printf("    %s%s %s",
            fieldTypeRec->Name,
            fieldTypeRec->Fabricated ? "" : "_64",
            fieldRec->Name );

        if (fieldRec->Size64 > fieldRec->TypeSize64) {

            CheckCondition( fieldRec->Size64 % fieldRec->TypeSize64 == 0,
                            "Internal error type %s.%s\n",
                            TypeRec->Name, fieldRec->Name );

            //
            // This field must be an array
            //

            printf("[%d]", fieldRec->Size64 / fieldRec->TypeSize64);
        }

        printf(";\n");

        currentOffset += fieldRec->Size64;

        fieldRec = fieldRec->Next;
    }

    padBytes = TypeRec->Size64 - currentOffset;
    if (padBytes > 0) {

        printf("    UCHAR Reserved%d[ 0x%x ];\n", reservedCount, padBytes );
        currentOffset += padBytes;
        reservedCount += 1;
    }

    printf("} %s_64, *P%s_64;\n\n", TypeRec->Name, TypeRec->Name );

    fieldRec = TypeRec->FieldList;
    while (fieldRec != NULL) {

        fieldTypeRec = fieldRec->TypeRec;
        printf("C_ASSERT( FIELD_OFFSET(%s_64,%s) == 0x%x);\n",
               TypeRec->Name,
               fieldRec->Name,
               fieldRec->Offset64);

        fieldRec = fieldRec->Next;
    }
    printf("\n");
}

VOID
WriteCopyList(
    IN PTYPE_REC TypeRec
    )

/*++

Routine Description:

    Generates the list of copy records necessary to copy the contents of
    each of the fields with TypeRec from their 32-bit layout to their
    64-bit layout.

Arguments:

    TypeRec - Pointer to the TYPE_REC structure that defines this type.

Return value:

    None.

--*/

{
    PFIELD_REC fieldRec;

    printf("COPY_REC cr3264_%s[] = {\n", TypeRec->Name);

    WriteCopyListWorker( TypeRec, 0, 0, NULL );

    WriteCopyRecord( 0,0,NULL,0,0,FALSE,NULL,TRUE );
    printf("};\n\n");
}

VOID
WriteCopyListWorker(
    IN PTYPE_REC TypeRec,
    IN ULONG Offset32,
    IN ULONG Offset64,
    IN PCHAR ParentName

    )

/*++

Routine Description:

    Recursively-called support routine for WriteCopyList.  This routine
    generates a copy record if this type is not composed of child types,
    otherwise it calls itself recursively for each child type.

Arguments:

    TypeRec - Pointer to the definition of the type to process.

    Offset32 - Current offset within the master structure being defined.

    Offset64 - Current offset within the master structure being defined.

    ParentName - Not currently used.

Return value:

    None.

--*/

{
    PFIELD_REC fieldRec;
    PTYPE_REC typeRec;
    CHAR fieldName[ 255 ];
    PCHAR fieldStart;

    fieldRec = TypeRec->FieldList;
    if (fieldRec == NULL) {

        WriteCopyRecord( Offset32,
                         Offset64,
                         TypeRec->Name,
                         TypeRec->Size32,
                         TypeRec->Size64,
                         TypeRec->SignExtend,
                         ParentName,
                         FALSE );
    } else {

        //
        // Build the field name
        //
    
        if (ParentName != NULL) {
            strcpy( fieldName, ParentName );
            strcat( fieldName, "." );
        } else {
            fieldName[0] = '\0';
        }
        fieldStart = &fieldName[ strlen(fieldName) ];

        do {
            strcpy( fieldStart, fieldRec->Name );

            // typeRec = FindTypeRec( fieldRec->TypeName );
            typeRec = fieldRec->TypeRec;
            WriteCopyListWorker( typeRec,
                                 fieldRec->Offset32 + Offset32,
                                 fieldRec->Offset64 + Offset64,
                                 fieldName );
            fieldRec = fieldRec->Next;
        } while (fieldRec != NULL);
    }
}

VOID
WriteBufferCopies(
    IN PTYPE_REC TypeRec,
    IN PCHAR StrucName
    )
{
    PFIELD_REC fieldRec;
    PTYPE_REC typeRec;
    CHAR strucName[ 255 ];
    CHAR sizeFormula[ 255 ];
    PCHAR fieldPos;
    PCHAR src;
    PCHAR dst;

    if (TypeRec == NULL) {
        return;
    }

    strcpy(strucName,StrucName );
    if (*StrucName != '\0') {
        strcat(strucName,".");
    }
    fieldPos = &strucName[ strlen(strucName) ];

    fieldRec = TypeRec->FieldList;
    while (fieldRec != NULL) {

        strcpy(fieldPos,fieldRec->Name);
        if (fieldRec->SizeFormula != NULL) {

            //
            // Perform substitution on the size formula
            //
        
            dst = sizeFormula;
            src = fieldRec->SizeFormula;
            do {
                if (*src == '%' &&
                    *(src+1) == '1') {

                    dst += sprintf(dst,
                                   "Source->%s%s",
                                   StrucName,
                                   *StrucName == '\0' ? "" : ".");
                    src += 2;
                } else {
                    *dst++ = *src++;
                }
            } while (*src != '\0');
            *dst = '\0';

            printf("\n"
                   "    status = \n"
                   "        CopyBuf( Source->%s,\n"
                   "                 &Destination->%s,\n"
                   "                 %s );\n"
                   "    if (status != ESUCCESS) {\n"
                   "        return status;\n"
                   "    }\n",
                   strucName,
                   strucName,
                   sizeFormula);
        }

        typeRec = fieldRec->TypeRec;
        WriteBufferCopies( typeRec, strucName );

        fieldRec = fieldRec->Next;
    }
}


VOID
WriteThunkSource(
    VOID
    )

/*++

Routine Description:

    Generates the source code and supporting definitions necessary to
    copy all or portions of the contents of 32-bit structures to the
    equivalent 64-bit layout.

Arguments:

    None.

Return value:

    None.

--*/

{
    PTYPE_REC typeRec;

    printf("//\n");
    printf("// Autogenerated file, do not edit\n");
    printf("//\n\n");

    printf("#include <bldrthnk.h>\n\n");
    printf("#pragma warning(disable:4296)\n\n");

    //
    // Output the 64-bit type definitions
    //

    printf("#pragma pack(push,1)\n\n");

    typeRec = TypeRecList;
    while (typeRec != NULL) {

        if (typeRec->Fabricated == FALSE) {
            WriteDefinition64( typeRec );
        }

        typeRec = typeRec->Next;
    }

    printf("#pragma pack(pop)\n\n");

    //
    // Output the copy records
    // 

    typeRec = TypeRecList;
    while (typeRec != NULL) {

        if (typeRec->Only64 == FALSE &&
            typeRec->Fabricated == FALSE) {
            WriteCopyList( typeRec );
        }

        typeRec = typeRec->Next;
    }

    //
    // Generate the copy routines
    //

    typeRec = TypeRecList;
    while (typeRec != NULL) {

        if (typeRec->Only64 == FALSE &&
            typeRec->Fabricated == FALSE) {
            WriteCopyRoutine( typeRec );
        }

        typeRec = typeRec->Next;
    }
    printf("\n");
}

VOID
WriteCopyRoutine(
    IN PTYPE_REC TypeRec
    )

/*++

Routine Description:

    Generates text that implements a function to copy the contents of a
    structure of the specified type from a 32-bit layout to a 64-bit
    layout.

Arguments:

    TypeRec - Pointer to the type for which the function should be generated.

Return value:

    None.

--*/

{
    PCHAR typeName;

    typeName = TypeRec->Name;

    printf("\n"
           "ARC_STATUS\n"
           "__inline\n"
           "static\n"
           "Copy_%s(\n"
           "    IN %s *Source,\n"
           "    OUT %s_64 *Destination\n"
           "    )\n"
           "{\n"
           "    ARC_STATUS status = ESUCCESS;"
           "\n"
           "    DbgPrint(\"BLAMD64: Copy %s->%s_64 (0x%%08x->0x%%08x)\\n\",\n"
           "             (ULONG)Source, (ULONG)Destination );\n"
           "\n"
           "    CopyRec( Source, Destination, cr3264_%s );\n",
           typeName,
           typeName,
           typeName,
           typeName,
           typeName,
           typeName );

    WriteBufferCopies( TypeRec, "" );
    printf("    return status;\n");
    printf("}\n\n");
}

VOID
ApplyFixupsToImage(
    IN PCHAR ObjImage
    )

/*++

Routine Description:

    Processes fixup records found within an object image.

Arguments:

    Pointer to a buffer containing the entire image.

Return value:

    None.

--*/

{
    //
    // Applies fixups to the OBJ image loaded at ObjImage
    //

    PIMAGE_FILE_HEADER fileHeader;
    PIMAGE_SECTION_HEADER sectionHeader;
    PIMAGE_SECTION_HEADER sectionHeaderArray;
    PIMAGE_SYMBOL symbolTable;
    PIMAGE_SYMBOL symbol;
    PIMAGE_RELOCATION reloc;
    PIMAGE_RELOCATION relocArray;
    ULONG sectionNum;
    ULONG relocNum;
    ULONG_PTR targetVa;
    PULONG_PTR fixupVa;

    fileHeader = (PIMAGE_FILE_HEADER)ObjImage;

    //
    // We need the symbol table to apply the fixups
    //

    symbolTable = (PIMAGE_SYMBOL)(ObjImage +
                                  fileHeader->PointerToSymbolTable);

    //
    // Get a pointer to the first element in the section header
    //

    sectionHeaderArray = (PIMAGE_SECTION_HEADER)(ObjImage +
                              sizeof( IMAGE_FILE_HEADER ) +
                              fileHeader->SizeOfOptionalHeader);

    //
    // Apply the fixups for each section
    //

    for( sectionNum = 0;
         sectionNum < fileHeader->NumberOfSections;
         sectionNum++ ){

        sectionHeader = &sectionHeaderArray[ sectionNum ];

        //
        // Apply each fixup in this section
        //

        relocArray = (PIMAGE_RELOCATION)(ObjImage +
                                         sectionHeader->PointerToRelocations);
        for( relocNum = 0;
             relocNum < sectionHeader->NumberOfRelocations;
             relocNum++ ){

            reloc = &relocArray[ relocNum ];

            //
            // The relocation gives us the position in the image of the
            // relocation modification (VirtualAddress).  To find out what
            // to put there, we have to look the symbol up in the symbol index.
            //

            symbol = &symbolTable[ reloc->SymbolTableIndex ];

            targetVa =
                sectionHeaderArray[ symbol->SectionNumber-1 ].PointerToRawData;

            targetVa += symbol->Value;
            targetVa += (ULONG_PTR)ObjImage;

            fixupVa = (PULONG_PTR)(ObjImage +
                                  reloc->VirtualAddress +
                                  sectionHeader->PointerToRawData );

            *fixupVa = targetVa;
        }
    }
}

VOID
NewGlobalType(
    IN PTYPE_REC TypeRec
    )

/*++

Routine Description:

    Inserts a new TYPE_REC structure at the end of the global TYPE_REC
    list.

Arguments:

    TypeRec - Pointer to the TYPE_REC structure to insert.

Return value:

    None.

--*/

{
    PTYPE_REC insertNode;

    insertNode = CONTAINING_RECORD( &TypeRecList,
                                    TYPE_REC,
                                    Next );
    while (insertNode->Next != NULL) {
        insertNode = insertNode->Next;
    }
    insertNode->Next = TypeRec;
    TypeRec->Next = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\sm\sfc\test\test.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbt.h>
#include <initguid.h>
#include <devguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <sfcapip.h>
#include "resource.h"




BOOL
CALLBACK
SfcNotificationCallback(
    IN PFILEINSTALL_STATUS FileInstallStatus,
    IN DWORD_PTR Context
    )
{
    wprintf( L"file=[%s], version=[%I64x], ec=[%d]\n", FileInstallStatus->FileName, FileInstallStatus->Version, FileInstallStatus->Win32Error  );
    return TRUE;
}


PWSTR
addstr(
    PWSTR s1,
    PWSTR s2
    )
{
    wcscpy( s1, s2 );
    return s1 + wcslen(s1) + 1;
}


#define MemAlloc malloc
#define MemFree  free

BOOL
MakeDirectory(
    PCWSTR Dir
    )

/*++

Routine Description:

    Attempt to create all of the directories in the given path.

Arguments:

    Dir                     - Directory path to create

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPTSTR p, NewDir;
    BOOL retval;
    

    NewDir = p = MemAlloc( (wcslen(Dir) + 1) *sizeof(WCHAR) );
    if (p) {
        wcscpy(p, Dir);
    } else {
        return(FALSE);
    }

    
    if (*p != '\\') p += 2;
    while( *++p ) {
        while(*p && *p != TEXT('\\')) p++;
        if (!*p) {
            retval = CreateDirectory( NewDir, NULL );
            MemFree(NewDir);
            return(retval);
        }
        *p = 0;
        retval = CreateDirectory( NewDir, NULL );
        if (!retval && GetLastError() != ERROR_ALREADY_EXISTS) {
            MemFree(NewDir);
            return(retval);
        }
        *p = TEXT('\\');
    }
    
    MemFree( NewDir );

    return(TRUE);
}


PVOID
RegisterForDevChange(
    HWND hDlg
    )
{
    PVOID hNotifyDevNode;
    DEV_BROADCAST_DEVICEINTERFACE FilterData;


    FilterData.dbcc_size       = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    FilterData.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    FilterData.dbcc_classguid  = GUID_DEVCLASS_CDROM;

    hNotifyDevNode = RegisterDeviceNotification( hDlg, &FilterData, DEVICE_NOTIFY_WINDOW_HANDLE );
    if (hNotifyDevNode == NULL) {
    }

    return hNotifyDevNode;
}


INT_PTR
CALLBACK
PromptForMediaDialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DEV_BROADCAST_VOLUME *dbv;
    static UINT QueryCancelAutoPlay = 0;
    static PVOID hNotifyDevNode = NULL;

    if (uMsg == WM_INITDIALOG) {
        hNotifyDevNode = RegisterForDevChange( hwndDlg );
        QueryCancelAutoPlay = RegisterWindowMessage( L"QueryCancelAutoPlay" );
    }
    if (uMsg == WM_COMMAND && LOWORD(wParam) == IDCANCEL) {
        UnregisterDeviceNotification( hNotifyDevNode );
        EndDialog( hwndDlg, 0 );
    }
    if (uMsg == QueryCancelAutoPlay) {
        SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, 1 );
        return 1;
    }
    if (uMsg == WM_DEVICECHANGE) {
        if (wParam == DBT_DEVICEARRIVAL) {
            dbv = (DEV_BROADCAST_VOLUME*)lParam;
            if (dbv->dbcv_devicetype == DBT_DEVTYP_VOLUME) {
                //
                // look for the cd
                //
                DWORD mask,i;
                WCHAR Path[16];
                WCHAR SourcePath[MAX_PATH];
                Path[1] = L':';
                Path[2] = L'\\';
                Path[3] = 0;
                Path[4] = 0;
                for (i=0,mask=dbv->dbcv_unitmask; i<26; i++) {
                    if (mask&1) {
                        Path[0] = (WCHAR)(L'A' + i);
                        Path[3] = 0;
                        if (dbv->dbcv_flags == DBTF_MEDIA) {
                            if (GetDriveType( Path ) == DRIVE_CDROM) {
                                MessageBox( hwndDlg, L"CD was inserted, YEA BABY!", L"Windows File Protection", MB_OK );
                                UnregisterDeviceNotification( hNotifyDevNode );
                                EndDialog( hwndDlg, 1 );
                            }
                        }
                    }
                    mask = mask >> 1;
                }
            }
        }
    }
    return FALSE;
}


int __cdecl wmain( int argc, WCHAR *argv[] )
{
    HANDLE RpcHandle = NULL;
    PROTECTED_FILE_DATA FileData;
    PWSTR fnames;
    PWSTR s;
    BOOL b;
    PROTECTED_FILE_DATA ProtFileData;
    DWORD starttype;
    DWORD quota;
    WCHAR Path[MAX_PATH];

#if 0
    GetPrivateProfileString(L"test",
                            L"path",
                            L"c:\\winnt\\system32",
                            Path,
                            sizeof(Path),
                            L"test.ini");

    return MakeDirectory( Path );
#endif

    if (argc == 2 && _wcsicmp(argv[1],L"/i")==0) {
        RpcHandle = SfcConnectToServer( NULL );
        s = fnames = (PWSTR) LocalAlloc( LPTR, 8192 );
        s = addstr( s, L"%windir%\\system32\\admwprox.dll" );
        s = addstr( s, L"%windir%\\system32\\adsiis.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\certmap.ocx" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\certwiz.ocx" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\cnfgprts.ocx" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\coadmin.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\dt_ctrl.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\fscfg.dll" );
        s = addstr( s, L"%windir%\\system32\\ftpsapi2.dll" );
        s = addstr( s, L"%windir%\\system32\\iisext.dll" );
        s = addstr( s, L"%windir%\\system32\\iismap.dll" );
        s = addstr( s, L"%windir%\\system32\\iisreset.exe" );
        s = addstr( s, L"%windir%\\system32\\iisrstap.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\iisrstas.exe" );
        s = addstr( s, L"%windir%\\system32\\iisrtl.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\iisui.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\inetmgr.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\inetmgr.exe" );
        s = addstr( s, L"%windir%\\system32\\inetsloc.dll" );
        s = addstr( s, L"%windir%\\system32\\infoadmn.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\isatq.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\logui.ocx" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\nntpadm.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\nntpsnap.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\smtpadm.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\smtpsnap.dll" );
        s = addstr( s, L"%windir%\\system32\\staxmem.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\w3scfg.dll" );
        s = addstr( s, L"%windir%\\system32\\wamregps.dll" );

        SfcInstallProtectedFiles( RpcHandle, fnames, TRUE, NULL, NULL, SfcNotificationCallback, 0 );
        return 0;
    }

    if (argc == 2 && _wcsicmp(argv[1],L"/t")==0) {
        RpcHandle = SfcConnectToServer( NULL );
        b = SfcIsFileProtected( RpcHandle, L"%systemroot%\\system32\\kernel32.dll" );
        return 0;
    }

    if (argc == 2 && _wcsicmp(argv[1],L"/x")==0) {
        //RpcHandle = SfcConnectToServer( NULL );
        ZeroMemory( &ProtFileData, sizeof(PROTECTED_FILE_DATA) );
        ProtFileData.FileNumber = 24;
        b = SfcGetNextProtectedFile( RpcHandle, &ProtFileData );
        if (b) {
            wprintf( L"%ws\n", ProtFileData.FileName );
        }
        return 0;
    }

    if (argc == 2 && _wcsicmp(argv[1],L"/c")==0) {
        DialogBoxParam(
            GetModuleHandle(NULL),
            MAKEINTRESOURCE(IDD_SFC_CD_PROMPT),
            NULL,
            PromptForMediaDialogProc,
            0
            );
        return 0;
    }

    if (argc == 2 && _wcsicmp(argv[1],L"/p")==0) {
        TCHAR DllPath[MAX_PATH];
        HMODULE DllMod;

        ExpandEnvironmentStrings(argv[2],DllPath,sizeof(DllPath)/sizeof(TCHAR));
        DllMod = LoadLibrary(DllPath);

        MoveFileEx(DllPath,NULL,MOVEFILE_DELAY_UNTIL_REBOOT);

        FreeLibrary(DllMod);
        
    }




    starttype = GetPrivateProfileInt(L"test",
                                        L"starttype",
                                        0,
                                        L"test.ini");

    quota = GetPrivateProfileInt(L"test",
                                 L"quota",
                                 0,
                                 L"test.ini");



    SfcInitProt( SFC_REGISTRY_OVERRIDE, 
                 starttype, 
                 SFC_SCAN_NORMAL,
                 quota,
                 NULL,
                 NULL,
                 NULL);

    while (TRUE) {
      if (WaitForSingleObject( NtCurrentProcess(), 1000 * 10 ) == WAIT_OBJECT_0) {
         break;
      }

      if (GetPrivateProfileInt(L"test",
                               L"shutdown",
                               0,
                               L"test.ini")) {
         break;
      }      

    }

    SfcTerminateWatcherThread();

    return 0;

    RpcHandle = SfcConnectToServer( NULL );
    SfcInitiateScan( RpcHandle, 0 );
    return 0;

    RpcHandle = SfcConnectToServer( NULL );
    SfcFileException( RpcHandle, argv[1], FILE_ACTION_REMOVED );
    return 0;

    RpcHandle = SfcConnectToServer( NULL );
    FileData.FileNumber = 0;

    while(SfcGetNextProtectedFile(RpcHandle,&FileData)) {
        if (GetFileAttributes(FileData.FileName) != 0xffffffff) {
            wprintf( L"File = %ws\n", FileData.FileName );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\sm\sfc\stress\test.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <sfc.h>

PROTECTED_FILE_DATA pd;
DWORD CachedFiles;
DWORD NonCachedFiles;
DWORD TotalFiles;
WCHAR BackupDir[256];



void
ProcessProtectedFile(
    int FileNumber
    )
{
    int action;
    PWSTR s;
    WCHAR buf[512];


    //
    // get the file name
    //
    ZeroMemory( &pd, sizeof(pd) );
    pd.FileNumber = (DWORD)FileNumber;
    if (!SfcGetNextProtectedFile(NULL,&pd)) {
        return;
    }
    //
    // if the file doesn't exist then there is nothing do to
    //
    if (GetFileAttributes( pd.FileName ) == 0xffffffff) {
        return;
    }
    //
    // backup the file before we mess with it
    //
    wcscpy( buf, BackupDir );
    wcscat( buf, &pd.FileName[2] );
    s = wcsrchr( buf, L'\\' );
    *s = 0;
    CreateDirectory( buf, NULL );
    *s = L'\\';
    CopyFile( pd.FileName, buf, FALSE );
    //
    // now do something
    //
    action = rand() % 3;
    switch (action) {
        case 0:
            //
            // delete the file
            //
            DeleteFile( pd.FileName );
            break;
        case 1:
            //
            // rename the file
            //
            wcscpy( buf, pd.FileName );
            wcscat( buf, L".sfc" );
            MoveFileEx( pd.FileName, buf, MOVEFILE_REPLACE_EXISTING );
            break;
        case 2:
            //
            // move the file
            //
            wcscpy( buf, L"c:\\temp\\sfctemp" );
            wcscat( buf, &pd.FileName[2] );
            MoveFileEx( pd.FileName, buf, MOVEFILE_REPLACE_EXISTING );
            break;
        case 3:
            //
            // change the file attributes
            //
            SetFileAttributes( pd.FileName, GetFileAttributes( pd.FileName ) );
            break;
        default:
            //
            // should not get here....
            //
            return;
    }
}


int __cdecl wmain( int argc, WCHAR *argv[] )
{
    LONG rc;
    HKEY hKey;
    PWSTR s;
    WCHAR buf[512];
    DWORD sz;
    WCHAR CacheDir[512];
    int rnum;
    DWORD FileCount = (DWORD)-1;
    HANDLE SfcDebugBreakEvent;


    if (argc == 2) {
        if (_wcsicmp( argv[1], L"break" ) == 0) {

            SfcDebugBreakEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, L"SfcDebugBreakEvent" );
            if (SfcDebugBreakEvent) {
                SetEvent( SfcDebugBreakEvent );
            } else {
                wprintf( L"could not open the break event, ec=%d\n", GetLastError() );
            }

            return 0;
        } else {
            FileCount = _wtoi( argv[1] );
        }
    }

    rc = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        L"software\\microsoft\\windows nt\\currentversion\\winlogon",
        &hKey
        );
    if (rc != ERROR_SUCCESS) {
        return 0;
    }

    sz = sizeof(buf);

    rc = RegQueryValueEx(
        hKey,
        L"SFCDllCacheDir",
        NULL,
        NULL,
        (LPBYTE)buf,
        &sz
        );
    if (rc != ERROR_SUCCESS) {
        wcscpy( buf, L"%systemroot%\\system32\\dllcache\\" );
    }

    RegCloseKey( hKey );

    if (buf[wcslen(buf)-1] != L'\\') {
        wcscat( buf, L"\\" );
    }

    rc = ExpandEnvironmentStrings( buf, CacheDir, sizeof(CacheDir)/sizeof(WCHAR) );
    if (!rc) {
        return 0;
    }

    wcscpy( BackupDir, L"c:\\temp\\sfcsave" );

    while (SfcGetNextProtectedFile(NULL,&pd)) {
        s = wcsrchr( pd.FileName, L'\\' );
        if (!s) {
            return 0;
        }
        s += 1;
        wcscpy( buf, CacheDir );
        wcscat( buf, s );
        if (GetFileAttributes( buf ) != 0xffffffff) {
            CachedFiles += 1;
        }
    }

    ZeroMemory( &pd, sizeof(pd) );
    pd.FileNumber = 0xffffffff;
    SfcGetNextProtectedFile(NULL,&pd);
    TotalFiles = pd.FileNumber;
    NonCachedFiles = TotalFiles - CachedFiles;

    wprintf( L"cached files     = %d\n", CachedFiles );
    wprintf( L"non-cached files = %d\n", NonCachedFiles );
    wprintf( L"total files      = %d\n", TotalFiles );

    srand( (unsigned int)GetTickCount() );

    while(1) {
        rnum = rand();
        if (rnum&1) {
            rnum = rand() % CachedFiles;
        } else {
            rnum = rand() % TotalFiles;
            if (rnum < (int)CachedFiles) {
                rnum = (rnum + CachedFiles) % TotalFiles;
            }
        }
        ProcessProtectedFile( rnum );
        if (FileCount != (DWORD)-1) {
            FileCount -= 1;
            if (FileCount == 0) {
                break;
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\sm\sfc\sfc_fwd\stub.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    stub.c

Abstract:

    Stubbed out Windows File Protection APIs.  These APIs are "Millenium" SFC 
    apis, which we simply stub out so that any clients programming to these
    APIs may work on both platforms

Author:

    Andrew Ritz (andrewr) 23-Sep-1999

Revision History:
    
    

--*/

#include <windows.h>
#include <srrestoreptapi.h>

DWORD
WINAPI
SfpInstallCatalog(
    IN LPCTSTR pszCatName, 
    IN LPCTSTR pszCatDependency,
    IN PVOID   Reserved
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


DWORD
WINAPI
SfpDeleteCatalog(
    IN LPCTSTR pszCatName,
    IN PVOID Reserved
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


BOOL
WINAPI
SfpVerifyFile(
    IN LPCTSTR pszFileName,
    IN LPTSTR  pszError,
    IN DWORD   dwErrSize
    )
{

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
    
}

#undef SRSetRestorePoint
#undef SRSetRestorePointA
#undef SRSetRestorePointW

typedef BOOL (WINAPI * PSETRESTOREPOINTA) (PRESTOREPOINTINFOA, PSTATEMGRSTATUS);
typedef BOOL (WINAPI * PSETRESTOREPOINTW) (PRESTOREPOINTINFOW, PSTATEMGRSTATUS);

BOOL
WINAPI
SRSetRestorePointA ( PRESTOREPOINTINFOA  pRestorePtSpec,
                     PSTATEMGRSTATUS     pSMgrStatus )
{
    HMODULE hClient = LoadLibrary (L"SRCLIENT.DLL");
    BOOL fReturn = FALSE;
    
    if (hClient != NULL)
    {
        PSETRESTOREPOINTA pSetRestorePointA = (PSETRESTOREPOINTA )
                          GetProcAddress (hClient, "SRSetRestorePointA"); 

        if (pSetRestorePointA != NULL)
        {
            fReturn =  (* pSetRestorePointA) (pRestorePtSpec, pSMgrStatus); 
        }
        else if (pSMgrStatus != NULL)
            pSMgrStatus->nStatus = ERROR_CALL_NOT_IMPLEMENTED;

        FreeLibrary (hClient);
    }
    else if (pSMgrStatus != NULL)
        pSMgrStatus->nStatus = ERROR_CALL_NOT_IMPLEMENTED;

    return fReturn;
}

BOOL
WINAPI
SRSetRestorePointW ( PRESTOREPOINTINFOW  pRestorePtSpec,
                     PSTATEMGRSTATUS     pSMgrStatus )
{
    HMODULE hClient = LoadLibrary (L"SRCLIENT.DLL");
    BOOL fReturn = FALSE;

    if (hClient != NULL)
    {
        PSETRESTOREPOINTW pSetRestorePointW = (PSETRESTOREPOINTW )
                          GetProcAddress (hClient, "SRSetRestorePointW");

        if (pSetRestorePointW != NULL)
        {
            fReturn =  (* pSetRestorePointW) (pRestorePtSpec, pSMgrStatus);
        }
        else if (pSMgrStatus != NULL)
            pSMgrStatus->nStatus = ERROR_CALL_NOT_IMPLEMENTED;

        FreeLibrary (hClient);
    }
    else if (pSMgrStatus != NULL)
        pSMgrStatus->nStatus = ERROR_CALL_NOT_IMPLEMENTED;


    return fReturn;
}

#include <sfcapip.h>

ULONG
MySfcInitProt(
    IN ULONG  OverrideRegistry,
    IN ULONG  RegDisable,        OPTIONAL
    IN ULONG  RegScan,           OPTIONAL
    IN ULONG  RegQuota,          OPTIONAL
    IN HWND   ProgressWindow,    OPTIONAL
    IN PCWSTR SourcePath,        OPTIONAL
    IN PCWSTR IgnoreFiles        OPTIONAL
    )
{
    return SfcInitProt( OverrideRegistry, RegDisable, RegScan, RegQuota, ProgressWindow, SourcePath, IgnoreFiles);
}

VOID
MySfcTerminateWatcherThread(
    VOID
    )
{
    SfcTerminateWatcherThread();
}

HANDLE
WINAPI
MySfcConnectToServer(
    IN PCWSTR ServerName
    )
{
    return SfcConnectToServer(ServerName);
}

VOID
MySfcClose(
    IN HANDLE RpcHandle
    )
{
    SfcClose(RpcHandle);
}

DWORD
WINAPI
MySfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    )
{
    return SfcFileException(RpcHandle, FileName, ExpectedChangeType);
}

DWORD
WINAPI
MySfcInitiateScan(
    IN HANDLE RpcHandle,
    IN DWORD ScanWhen
    )
{
    return SfcInitiateScan(RpcHandle, ScanWhen);
}

BOOL
WINAPI
MySfcInstallProtectedFiles(
    IN HANDLE RpcHandle,
    IN PCWSTR FileNames,
    IN BOOL AllowUI,
    IN PCWSTR ClassName,
    IN PCWSTR WindowName,
    IN PSFCNOTIFICATIONCALLBACK SfcNotificationCallback,
    IN DWORD_PTR Context OPTIONAL
    )
{
    return SfcInstallProtectedFiles(RpcHandle, FileNames, AllowUI, ClassName, WindowName, SfcNotificationCallback, Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\sm\sfc\stress\util.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define VALUE_BUFFER_SIZE 1024


PWSTR
SfcQueryRegString(
    LPWSTR KeyNameStr,
    LPWSTR ValueNameStr
    )
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    WCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;
    PWSTR s;

    //
    // Open the registry key.
    //

    RtlZeroMemory( (PVOID)ValueBuffer, VALUE_BUFFER_SIZE );
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    RtlInitUnicodeString( &KeyName, KeyNameStr );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        return NULL;
    }

    //
    // Query the key value.
    //

    RtlInitUnicodeString( &ValueName, ValueNameStr );
    Status = NtQueryValueKey(
        Key,
        &ValueName,
        KeyValuePartialInformation,
        (PVOID)KeyValueInfo,
        VALUE_BUFFER_SIZE,
        &ValueLength
        );

    NtClose(Key);
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    s = (PWSTR) malloc( KeyValueInfo->DataLength + 16 );
    if (s == NULL) {
        return NULL;
    }

    CopyMemory( s, KeyValueInfo->Data, KeyValueInfo->DataLength );

    return s;
}

ULONG
SfcQueryRegDword(
    LPWSTR KeyNameStr,
    LPWSTR ValueNameStr
    )
{

    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    WCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;

    //
    // Open the registry key.
    //

    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    RtlInitUnicodeString( &KeyName, KeyNameStr );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    //
    // Query the key value.
    //

    RtlInitUnicodeString( &ValueName, ValueNameStr );
    Status = NtQueryValueKey(
        Key,
        &ValueName,
        KeyValuePartialInformation,
        (PVOID)KeyValueInfo,
        VALUE_BUFFER_SIZE,
        &ValueLength
        );

    NtClose(Key);
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    return *((PULONG)&KeyValueInfo->Data);
}


ULONG
ExpandPathString(
    IN PWSTR PathString,
    IN ULONG PathStringLength,
    OUT PUNICODE_STRING FileName,
    OUT PUNICODE_STRING PathName
    )
{
    NTSTATUS Status;
    UNICODE_STRING NewPath;
    UNICODE_STRING SrcPath;
    PWSTR FilePart;


    SrcPath.Length = (USHORT)PathStringLength;
    SrcPath.MaximumLength = SrcPath.Length;
    SrcPath.Buffer = PathString;

    NewPath.Length = 0;
    NewPath.MaximumLength = (MAX_PATH*2) * sizeof(WCHAR);
    NewPath.Buffer = (PWSTR) malloc( NewPath.MaximumLength );
    if (NewPath.Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    Status = RtlExpandEnvironmentStrings_U(
        NULL,
        &SrcPath,
        &NewPath,
        NULL
        );
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    if (FileName == NULL) {
        PathName->Length = NewPath.Length;
        PathName->MaximumLength = NewPath.MaximumLength;
        PathName->Buffer = NewPath.Buffer;
        return STATUS_SUCCESS;
    }

    FilePart = wcsrchr( NewPath.Buffer, L'\\' );
    if (FilePart == NULL) {
        Status = STATUS_NO_MEMORY;
        goto exit;
    }

    *FilePart = 0;
    FilePart += 1;

    PathName->Length = wcslen(NewPath.Buffer) * sizeof(WCHAR);
    PathName->MaximumLength = PathName->Length + 4;
    PathName->Buffer = (PWSTR) malloc( PathName->MaximumLength );
    if (PathName->Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto exit;
    }
    wcscpy( PathName->Buffer, NewPath.Buffer );

    FileName->Length = wcslen(FilePart) * sizeof(WCHAR);
    FileName->MaximumLength = FileName->Length + 4;
    FileName->Buffer = (PWSTR) malloc( FileName->MaximumLength );
    if (FileName->Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        free( PathName->Buffer );
        goto exit;
    }
    wcscpy( FileName->Buffer, FilePart );

    Status = STATUS_SUCCESS;

exit:
    free( NewPath.Buffer );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\sm\sfc\sfpcopy\sfp.c ===
#include <windows.h>

#include <stdio.h>
#include <tchar.h>
#include <shellapi.h>
#include <setupapi.h>
#include <spapip.h>
#include <sfcapip.h>


#define ALLOWRENAMES        TEXT("AllowProtectedRenames")

extern void RestartDialog(VOID *, VOID *, UINT);

void
PrintUsage(
    void
    )
{
    printf("allows copying a protected system file\n");
    printf("if the file is in use, you will have to reboot.\n");
    printf("Usage: sfpcopy -q [source] [destination]\n");
    printf(" q: silent mode: if the file is in use, force a reboot\n");
    return;
}

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}



BOOL
pSetupProtectedRenamesFlag(
    BOOL bSet
    )
{
    HKEY hKey;
    long rslt = ERROR_SUCCESS;

    rslt = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
        0,
        KEY_SET_VALUE,
        &hKey
        );

    if (rslt == ERROR_SUCCESS) {
        DWORD Value = bSet ? 1 : 0;
        rslt = RegSetValueEx(
            hKey,
            TEXT("AllowProtectedRenames"),
            0,
            REG_DWORD,
            (LPBYTE)&Value,
            sizeof(DWORD)
            );

        RegCloseKey(hKey);
    }

    return(rslt == ERROR_SUCCESS);
}


int _cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )
{
    LPTSTR TargetName = NULL,SourceName=NULL;
    TCHAR TargetDir[MAX_PATH];
    TCHAR TempFile[MAX_PATH];
    LPTSTR p;

    BOOL SilentMode = FALSE;
    BOOL NeedReboot = FALSE;
    HANDLE hSfp;
    DWORD Result = NO_ERROR;

    //
    // parse args
    //
    while (--argc) {

        argv++;

        if ((argv[0][0] == TEXT('-')) || (argv[0][0] == TEXT('/'))) {

            switch (argv[0][1]) {
                case TEXT('q'):
                case TEXT('Q'):
                    SilentMode = TRUE;
                    goto Next;
                    break;
                default:
                    PrintUsage();
                    return -1;
            }

        }

        if (!SourceName) {
            SourceName = argv[0];
        } else if (!TargetName) {
            TargetName = argv[0];
        } else {
            PrintUsage();
            return -1;
        }
Next:
    ;
    }

    //
    // Validate files are really there
    //
    if (!SourceName || !TargetName) {
        PrintUsage();
        return -1;
    }

    if (!FileExists(SourceName,NULL)) {
        printf("Invalid Source File\n");
        PrintUsage();
        return -1;
    }

    if (!FileExists(TargetName,NULL)) {
        printf("Invalid Target File\n");
        PrintUsage();
        return -1;
    }

    //
    // unprotect the file
    //
    hSfp = SfcConnectToServer( NULL );
    if (hSfp) {
        if (SfcIsFileProtected(hSfp,TargetName)) {
            Result = SfcFileException(
                hSfp,
                (PWSTR) TargetName,
                (DWORD) -1
                );
            if (Result != NO_ERROR) {
                printf("Couldn't unprotect file, ec = %d\n", Result);
                goto exit;
            }
        } else {
            if (!SilentMode) {
                printf("target file is not protected\n");
            }
        }
        SfcClose(hSfp);
    }

    //
    // copy the file
    //
    _tcscpy(TargetDir,TargetName);
    p = _tcsrchr(TargetDir,TEXT('\\'));
    if (p) {
        *p = (TCHAR)NULL;
    }

    GetTempFileName(TargetDir,TEXT("sfp"),0,TempFile);

    _tprintf( TEXT("Copying %s --> %s\n"), SourceName, TargetName);
    Result = 1;
    if (CopyFile(SourceName,TempFile,FALSE)) {
        if (!MoveFileEx(TempFile,TargetName,MOVEFILE_REPLACE_EXISTING)) {
            if (MoveFileEx(
                    TempFile,
                    TargetName,
                    MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT)
                    )
            {
                NeedReboot = TRUE;
                Result = NO_ERROR;
            }
        } else {
            Result = NO_ERROR;
        }
    } else {
        Result = GetLastError();
    }

    if (Result != NO_ERROR) {
        Result = GetLastError();
        printf("Failed to copy file, ec = %d\n", Result);
    }

    //
    // Reboot if necessary
    //
    if (Result == NO_ERROR && NeedReboot) {

        pSetupProtectedRenamesFlag(TRUE);

        if (SilentMode) {
            HANDLE hToken;
            TOKEN_PRIVILEGES tkp;  // Get a token for this process.

            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &hToken)) {
                printf("Can't force silent reboot\n");
                goto verbose;
            }

            LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);
            tkp.PrivilegeCount = 1;  // one privilege to set
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // Get the shutdown privilege for this process.
            AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);

            //
            // Shut down the system and force all applications to close.
            //
            if (! ExitWindowsEx(EWX_REBOOT|EWX_FORCE , 0) ) {
                printf("Can't force silent reboot\n");
                goto verbose;
            }


        } else {
verbose:
            RestartDialog(NULL,NULL,EWX_REBOOT);
        }
    }

exit:
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\bldrthnk\bldrthnk.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bldrthnk.h

Abstract:

    Include file defining a number of structures used by bldrthnk.c.  This
    file also includes some M4 preprocessor directives, see INCLUDE_M4.

Author:

    Forrest C. Foltz (forrestf) 15-May-2000


To use:

Revision History:

--*/

//
// Maximum identifier name length
// 

#define MAX_NAME_LENGTH 128

//
// FIELD_DEF Describes a field definition within a structure's field list.
//

typedef struct _FIELD_DEF {
    CHAR Name[MAX_NAME_LENGTH];
    CHAR TypeName[MAX_NAME_LENGTH];
    ULONG TypeSize;
    ULONG Offset;
    ULONG Size;
    CHAR  SizeFormula[MAX_NAME_LENGTH];
} FIELD_DEF, *PFIELD_DEF;

//
// STRUC_DEF describes a structure.
//

typedef struct _STRUC_DEF {

    //
    // Name of this structure type
    //

    CHAR Name[MAX_NAME_LENGTH];

    //
    // Total size of the structure
    //

    ULONG Size;

    //
    // Array of field pointers.  Defined as ULONGLONG to ensure an identical
    // layout between 32- and 64-bit objs.
    //

    ULONGLONG Fields[];

}  STRUC_DEF, *PSTRUC_DEF;

//
// Master array of pointers to structure definitions.
//
typedef struct _DEFINITIONS *PDEFINITIONS;
typedef struct _DEFINITIONS {

    //
    // Two signatures, SIG_1 and SIG_2 to facilitate locating this list
    // within an .OBJ.
    //

    ULONG Sig1;
    ULONG Sig2;

    //
    // Array of pointers to STRUC_DEFs.  Defined as ULONGLONG to ensure
    // identical layout between 32- and 64-bit.
    // 

    ULONGLONG Structures[];

} DEFINITIONS;

//
// SIG_1 and SIG_2 are expected to be found in DEFINITIONS.Sig1 and
// DEFINITIONS.Sig2, respectively.
// 

#define SIG_1 (ULONG)'Sig1'
#define SIG_2 (ULONG)'Sig2'

//
// Macro used to generate a boolean value representing whether the given
// type is considered signed or unsigned by the compiler.
// 

#define IS_SIGNED_TYPE(x) (((x)-1) < ((x)0))

#if defined(_WIN64)
#define ONLY64(x) x
#else
#define ONLY64(x) 0
#endif

//
// Structures will ultimately be described as arrays of COPY_REC structures.
// Each COPY_REC structure supplies the information necessary to copy a field
// from a 32-bit structure layout to a 64-bit structure layout.
// 

typedef struct _COPY_REC {

    //
    // Offset of the field in a 32-bit structure.
    //

    USHORT Offset32;

    //
    // Offset of the field in a 64-bit structure.
    //

    USHORT Offset64;

    //
    // Size of the field in a 32-bit structure.
    //

    USHORT Size32;

    //
    // Size of the field in a 64-bit structure.
    //

    USHORT Size64;

    //
    // TRUE if the field should be sign-extended.
    //

    BOOLEAN SignExtend;

} COPY_REC, *PCOPY_REC;

#if !defined(ASSERT)
#define ASSERT(x)
#endif

//
// 64-bit list manipulation macros follow.
// 

#define InitializeListHead64( ListHead )        \
    (ListHead)->Flink = PTR_64(ListHead);       \
    (ListHead)->Blink = PTR_64(ListHead);

#define InsertTailList64( ListHead, Entry ) {   \
    PLIST_ENTRY_64 _EX_Blink;                   \
    PLIST_ENTRY_64 _EX_ListHead;                \
    _EX_ListHead = (ListHead);                  \
    _EX_Blink = PTR_32(_EX_ListHead->Blink);    \
    (Entry)->Flink = PTR_64(_EX_ListHead);      \
    (Entry)->Blink = PTR_64(_EX_Blink);         \
    _EX_Blink->Flink = PTR_64(Entry);           \
    _EX_ListHead->Blink = PTR_64(Entry);        \
    }

VOID
CopyRec(
    IN  PVOID Source,
    OUT PVOID Destination,
    IN  PCOPY_REC CopyRecArray
    );

#if defined(WANT_BLDRTHNK_FUNCTIONS)

ULONG
StringLen(
    IN PCHAR Str
    )
{
    if (Str == NULL) {
        return 0;
    } else {
        return strlen(Str)+sizeof(CHAR);
    }
}

VOID
CopyRec(
    IN  PVOID Source,
    OUT PVOID Destination,
    IN  PCOPY_REC CopyRecArray
    )

/*++

Routine Description:

    CopyRec copies the contents of a 32-bit structure to the equivalent
    64-bit structure.

Arguments:

    Source - Supplies a pointer to the 32-bit source structure.

    Destination - Supplies a pointer to the 64-bit destination structure.

    CopyRecArray - Supplies a pointer to a 0-terminated COPY_REC array
        that describes the relationships between the 32- and 64-bit fields
        within the structure.

Return value:

    None.

--*/

{
    PCOPY_REC copyRec;
    PCHAR signDst;
    ULONG extendBytes;
    PCHAR src;
    PCHAR dst;
    CHAR sign;

    copyRec = CopyRecArray;
    while (copyRec->Size32 != 0) {

        src = (PCHAR)Source + copyRec->Offset32;
        dst = (PCHAR)Destination + copyRec->Offset64;

        //
        // Determine whether this looks like a KSEG0 pointer
        //

        if (copyRec->Size32 == sizeof(PVOID) &&
            copyRec->Size64 == sizeof(POINTER64) &&
            copyRec->SignExtend != FALSE &&
            IS_KSEG0_PTR_X86( *(PULONG)src )) {

            //
            // Source appears to be a KSEG0 pointer.  All pointers
            // must be explicitly "thunked" during the copy phase, so
            // set this pointer to a known value that we can look for
            // later in order to detect pointers that haven't been
            // thunked yet.
            //

            *(POINTER64 *)dst = PTR_64(*(PVOID *)src);

        } else {

            memcpy( dst, src, copyRec->Size32 );
    
            //
            // Determine whether to sign-extend or zero-extend
            //
        
            extendBytes = copyRec->Size64 - copyRec->Size32;
            if (extendBytes > 0) {
        
                signDst = dst + copyRec->Size32;
        
                if (copyRec->SignExtend != FALSE &&
                   (*(signDst-1) & 0x80) != 0) {
        
                       //
                       // Signed value is negative, fill the high bits with
                       // ones.
                       //
        
                    sign = 0xFF;
        
                } else {
        
                    //
                    // Unsigned value or postitive signed value, fill the high
                    // bits with zeros.
                    //
        
                    sign = 0;
                }
        
                memset( signDst, sign, extendBytes );
            }
        }

        copyRec += 1;
    }
}

#endif // WANT_BLDRTHNK_FUNCTIONS

#if defined(INCLUDE_M4)

define(`IFDEF_WIN64',`#if defined(_WIN64)')

//
// Here begin the M4 macros used to build the structure definition module,
// which is subsequently compiled by both the 32- and 64-bit compiler, with
// the resulting object modules processed by bldrthnk.exe.
//
//
// A structure layout file consists of a number of structure definition
// blocks, terminated by a single DD().
//
// For example (underscores prepended to prevent M4 processing):
//
//
// SD( LIST_ENTRY )
// FD( Flink, PLIST_ENTRY )
// FD( Blink, PLIST_ENTRY )
// SE()
//
// DD()
//

define(`STRUC_NAME_LIST',`')
define(`FIELD_NAME_LIST',`')

//
// The SD macro begins the definition of a structure.
//
// Usage: SD( <structure_name> )
//

define(`SD', `define(`STRUC_NAME',`$1')
STRUC_NAME `gs_'STRUC_NAME; define(`_ONLY64',`') define(`STRUC_NAME_LIST', STRUC_NAME_LIST   `(ULONGLONG)&g_'STRUC_NAME cma
     )'
)

define(`SD64', `define(`STRUC_NAME',`$1')
IFDEF_WIN64
STRUC_NAME `gs_'STRUC_NAME; define(`_ONLY64',`#endif') define(`STRUC_NAME_LIST', STRUC_NAME_LIST   ONLY64(`(ULONGLONG)&g_'STRUC_NAME) cma
     )'
)


//
// The FD macro defines a field within a structure definition block
//
// Usage: FD( <field_name>, <type> )
//

define(`FD', `FIELD_DEF `g_'STRUC_NAME`_'$1 = 
    { "$1",
      "$2",
      sizeof($2),
      FIELD_OFFSET(STRUC_NAME,$1),
      sizeof(`gs_'STRUC_NAME.$1),
      "" };
    define(`FIELD_NAME_LIST', FIELD_NAME_LIST   `(ULONGLONG)&g_'STRUC_NAME`_'$1 cma
     )'
)

//
// The FDC macro works like the previous macro, except that it is applied to
// a field that points to a buffer that must be copied as well.
//

define(`FDC', `FIELD_DEF `g_'STRUC_NAME`_'$1 = 
    { "$1",
      "$2",
      sizeof($2),
      FIELD_OFFSET(STRUC_NAME,$1),
      sizeof(`gs_'STRUC_NAME.$1),
      $3 };
    define(`FIELD_NAME_LIST', FIELD_NAME_LIST   `(ULONGLONG)&g_'STRUC_NAME`_'$1 cma
     )'
)


//
// The SE macro marks the end of a structure definition.
//
// Usage: SE()
//

define(`SE', `STRUC_DEF `g_'STRUC_NAME = {
    "STRUC_NAME", sizeof(STRUC_NAME), 
    {
    define(`cma',`,') FIELD_NAME_LIST undefine(`cma')  0 }
    define(`FIELD_NAME_LIST',`')
};'
_ONLY64
)

//
// The DD macro marks the end of all structure definitions, and results
// in the generation of a single DEFINITIONS structure.
//
// Usage: DD()
//

define(`DD', `DEFINITIONS Definitions = {
    SIG_1, SIG_2,
    {
    define(`cma',`,') STRUC_NAME_LIST undefine(`cma')  0 }
}; define(`STRUC_NAME_LIST',`')');

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\devctl\devctl.c ===
/*
 *      Devctl.c
 *
 *      IoCrash
 *
 *      Copyright(c) 1997  Microsoft Corporation
 *
 *      NeillC  23-Oct-97
 *
 * This program is designed to call as many of the user mode native NT API's as
 * possible. The program is written to crash drivers as its primary function.
 *
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <winsock2.h>
#include <mswsock.h>
#include "windows.h"
#include "wmistr.h"
#include "wmiumkm.h"
#include "time.h"
#include "tdi.h"
#include "vdm.h"
#include "sddl.h"

#define MAX_DEVICES             4096
#define PROT_REP              100000
#define MAX_RET                 5000
#define DIAG_RET                  50
#define CRASH_LINE_SIZE         1024
#define SLOP_SENTINAL           0xA5

#define SLOP                      100
#define BIGBUF_SIZE               0x10000
#define RAND_REP                  1000
#define MAX_IOCTL_TAILOR          100
#define INITIAL_IOCTL_TAILOR_SIZE 200

#define FLAGS_DO_IOCTL_NULL        0x00000001
#define FLAGS_DO_IOCTL_RANDOM      0x00000002
#define FLAGS_DO_FSCTL_NULL        0x00000004
#define FLAGS_DO_FSCTL_RANDOM      0x00000008
#define FLAGS_DO_USAGE             0x00000010
#define FLAGS_DO_LOGGING           0x00000020
#define FLAGS_DO_POOLCHECK         0x00000040
#define FLAGS_DO_SKIPDONE          0x00000080
#define FLAGS_DO_SKIPCRASH         0x00000100
#define FLAGS_DO_MISC              0x00000200
#define FLAGS_DO_QUERY             0x00000400
#define FLAGS_DO_SUBOPENS          0x00000800
#define FLAGS_DO_ALLDEVS           0x00001000
#define FLAGS_DO_ZEROEA            0x00002000
#define FLAGS_DO_GRAB              0x00004000
#define FLAGS_DO_ERRORS            0x00008000
#define FLAGS_DO_ALERT             0x00010000
#define FLAGS_DO_LPC               0x00020000
#define FLAGS_DO_MAPNULL           0x00040000
#define FLAGS_DO_STREAMS           0x00080000
#define FLAGS_DO_WINSOCK           0x00100000
#define FLAGS_DO_SYNC              0x00200000
#define FLAGS_DO_DISKS             0x00400000
#define FLAGS_DO_PROT              0x00800000
#define FLAGS_DO_SECURITY          0x01000000
#define FLAGS_DO_IMPERSONATION     0x02000000
#define FLAGS_DO_DIRECT_DEVICE     0x04000000
#define FLAGS_DO_FAILURE_INJECTION 0x08000000
#define FLAGS_DO_PRINT_DEVS        0x10000000
#define FLAGS_DO_RANDOM_DEVICE     0x20000000
#define FLAGS_DO_SYMBOLIC          0x40000000
#define FLAGS_DO_OPEN_CLOSE        0x80000000

#define FLAGS_DO_DRIVER            0x00000001

#define DIAG_NOEXCEPTIONS 0x1

#define OPEN_TYPE_TDI_CONNECTION    1
#define OPEN_TYPE_TDI_ADDR_IP       2
#define OPEN_TYPE_TDI_ADDR_NETBIOS  3
#define OPEN_TYPE_TDI_ADDR_IPX      4
#define OPEN_TYPE_TDI_ADDR_APPLE    5
#define OPEN_TYPE_NAMED_PIPE        6
#define OPEN_TYPE_MAIL_SLOT         7
#define OPEN_TYPE_TREE_CONNECT      8

typedef struct _DEVMAP {
    OBJECT_NAME_INFORMATION *name;
    FILE_NAME_INFORMATION   *filename;
    HANDLE                  handle;
    DEVICE_TYPE             devtype;
    ACCESS_MASK             access;
} DEVMAP, *PDEVMAP;

//
// Define a structure to keep a track of issued IOCTL's. We do this to try and make a
// guess at what IOCTL's/FSCTL's a driver is actualy processing.
//
typedef struct _IOCTLINFO {
   NTSTATUS status;
   ULONG ioctl;
   ULONG count;
} IOCTLINFO, *PIOCTLINFO;

typedef struct _IOCTLREC {
   ULONG total, count, start;
   IOCTLINFO ioctl[];
} IOCTLREC, *PIOCTLREC;

typedef struct _CRASHNODE {
   struct _CRASHNODE *next;
   PWCHAR string;
} CRASHNODE, *PCRASHNODE;

DEVMAP                  devmap[MAX_DEVICES];
ULONG                   devscount;
ULONG                   skipped = 0;
ULONG                   random_device = 0;
UCHAR                   *bigbuf;
FILE                    *skipfile = NULL;
FILE                    *crashfile = NULL;
FILE                    *diag_file = NULL;
PCRASHNODE              crashlist = NULL;
HANDLE                  changethread, randthread, alertthread, mainthread;
SOCKET                  ls, cs;
ULONG                   flags=0, flags2=0;
ULONG                   ioctl_min_function=0;
ULONG                   ioctl_max_function=400 /*0xFFF*/;
ULONG                   ioctl_min_devtype=0;
ULONG                   ioctl_max_devtype=200;
ULONG                   ioctl_inbuf_min=0x0;
ULONG                   ioctl_inbuf_max=0x200;
ULONG                   ioctl_outbuf_min=0;
ULONG                   ioctl_outbuf_max=0x200;
ULONG                   max_random_calls   = 100000;
ULONG                   max_tailured_calls = 10000;
ULONG                   progress_counter=0;
ULONG                   alerted=0;
ULONG                   cid = 0;
HANDLE                  process_handle = NULL;
WCHAR                   lastcrashline[CRASH_LINE_SIZE];
HANDLE                  sync_event = NULL;
ULONG                   sessionid = 0;
PCHAR                   prefix_string = NULL;
HANDLE                  NonAdminToken=NULL;
UNICODE_STRING          DriverName={0};
BOOLEAN                 Impersonating = FALSE;

HANDLE
Create_nonadmin_token ()
/*
    Create a token with administrator filtered out.
*/
{
    HANDLE ProcessToken, RestrictedToken;
    SID_AND_ATTRIBUTES AdminSidAttrib;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY sia = {SECURITY_WORLD_SID_AUTHORITY};


    //
    // Open the process token
    //
    if (!OpenProcessToken (GetCurrentProcess (),
                           MAXIMUM_ALLOWED,
                           &ProcessToken)) {
        printf ("OpenProcessToken failed %d\n", GetLastError ());
        exit (EXIT_FAILURE);
    }

    if (!AllocateAndInitializeSid (&sia, 1, 0, 0, 0, 0, 0, 0, 0, 0, &pSid)) {
        printf ("AllocateAndInitializeSid failed %d\n", GetLastError ());
        CloseHandle (ProcessToken);
        exit (EXIT_FAILURE);
    }

    AdminSidAttrib.Sid = pSid;
    AdminSidAttrib.Attributes = 0;

    if (!CreateRestrictedToken (ProcessToken,
                                DISABLE_MAX_PRIVILEGE, 
                                0,
                                NULL,
                                0,
                                NULL,
                                1,
                                &AdminSidAttrib,
                                &RestrictedToken)) {
        FreeSid (pSid);
        CloseHandle (ProcessToken);
        printf ("CreateRestrictedToken failed %d\n", GetLastError ());
        exit (EXIT_FAILURE);
    }

    FreeSid (pSid);
    CloseHandle (ProcessToken);

    if (!DuplicateToken (RestrictedToken,
                         SecurityDelegation,
                         &NonAdminToken)) {
        CloseHandle (RestrictedToken);
        printf ("DuplicateToken failed %d\n", GetLastError ());
        exit (EXIT_FAILURE);
    }
    CloseHandle (RestrictedToken);

    return NonAdminToken;
}

VOID
Impersonate_nonadmin ()
{
    Impersonating = TRUE;
    if (NonAdminToken != NULL && !SetThreadToken (NULL, NonAdminToken)) {
        printf ("SetThreadToken failed %d\n", GetLastError ());
        exit (EXIT_FAILURE);
    }
}

DWORD
Revert_from_admin ()
{
    Impersonating = FALSE;
    return RevertToSelf ();
}


void
tag_to_wide (PUCHAR t, PWCHAR wt)
{
   ULONG i;

   for (i = 0; i < 4; i++) {
      *wt++ = *t++;
   }
}

/*
   Try and locate pool leaks by looking at pool tag info and lookaside list info.
   Try and locate where handled exceptions might reveal problems in the code.
*/
BOOL
print_diags (ULONG diag_flags, ULONG ret)
{
   static PSYSTEM_POOLTAG_INFORMATION opb=NULL;
   PSYSTEM_POOLTAG_INFORMATION pb;
   static PSYSTEM_LOOKASIDE_INFORMATION olpb=NULL;
   static ULONG olpbl;
   PSYSTEM_LOOKASIDE_INFORMATION lpb;
   ULONG pbl, lpbl, i, j, retlen, retlen1;
   BOOL found, diff, newtag;
   NTSTATUS status;
   static ULONG firsterror = 1;
   static SYSTEM_EXCEPTION_INFORMATION sei, osei;
   WCHAR wtag[4];
   static ULONG lpbi = 1, pbi = 1;

   if ((flags&FLAGS_DO_POOLCHECK) == 0) {
      return FALSE;
   }
   if (!diag_file) {
      diag_file = _wfopen (L"diags.log", L"ab");
      if (!diag_file) {
         printf ("Failed to open diags.log for diagnostics\n");
         exit (EXIT_FAILURE);
      }
   }
   diff = FALSE;
   newtag = FALSE;

   status = NtQuerySystemInformation (SystemExceptionInformation, &sei, sizeof (sei),
                                      &retlen);
   if (!NT_SUCCESS (status)) {
      if (firsterror) {
         printf ("NtQuerySystemInformation for SystemExceptionInformation failed %x\n",
                 status);
         firsterror = 0;
      }
      flags &= ~FLAGS_DO_POOLCHECK;
      return FALSE;
   }
   if (sei.ExceptionDispatchCount > osei.ExceptionDispatchCount &&
       osei.ExceptionDispatchCount) {
      if (!(diag_flags&DIAG_NOEXCEPTIONS)) {
         printf ("Exception count changed from %d to %d\n", osei.ExceptionDispatchCount,
                 sei.ExceptionDispatchCount);
         if (ret == DIAG_RET) {
            fwprintf (diag_file, L"%s Exception count changed from %d to %d\r\n",
                      lastcrashline,
                      osei.ExceptionDispatchCount,
                      sei.ExceptionDispatchCount);
            fflush (diag_file);
         } else if (ret < DIAG_RET) {
            diff = TRUE;
         }
      }
   }
   osei = sei;

   while (1) {
      /*
         Get memory for tag info
      */
      pbl = sizeof (*pb) + pbi * sizeof (pb->TagInfo[0]);
      pb = malloc (pbl);
      if (!pb) {
         printf ("Failed to allocate memory for pool buffer\n");
         exit (EXIT_FAILURE);
      }
      status = NtQuerySystemInformation (SystemPoolTagInformation, pb, pbl, &retlen1);
      if (pbl <= retlen1) {
         ULONG pbio = pbi;
         pbi = 1 + (retlen1 - sizeof (*pb)) / sizeof (pb->TagInfo[0]);
//         printf ("Increasing pooltag list table size to %d from %d\n", pbi, pbio);
         free (pb);
         continue;
      }
      if (!NT_SUCCESS (status)) {
         if (firsterror) {
            printf ("NtQuerySystemInformation failed %x\n", status);
            firsterror = 0;
         }
         flags &= ~FLAGS_DO_POOLCHECK;
         free (pb);
         return FALSE;
      }
      break;
   }

   while (1) {
      /*
         Get memory for lookaside info
      */
      lpbl = sizeof (*lpb) * lpbi;
      lpb = malloc (lpbl);
      if (!pb) {
         printf ("Failed to allocate memory for pool buffer\n");
         exit (EXIT_FAILURE);
      }
      status = NtQuerySystemInformation (SystemLookasideInformation, lpb, lpbl, &retlen);
      if (lpbl <= retlen) {
         ULONG lpbio = lpbi;
         lpbi = 1 + retlen / sizeof (*lpb);
//         printf ("Increasing lookaside list table size to %d from %d\n", lpbi, lpbio);
         free (lpb);
         continue;
      }
      if (!NT_SUCCESS (status)) {
         printf ("NtQuerySystemInformation failed %x\n", status);
         flags &= ~FLAGS_DO_POOLCHECK;
         free (lpb);
         free (pb);
         return FALSE;
      }
      break;
   }
   lpbl = retlen / sizeof (*lpb);
   if (olpb) {
      for (i = 0; i < lpbl; i++) {
         /*
            Quick check here. the tag is probably in the same place it was last time
         */
         if (i < olpbl && lpb[i].Tag == olpb[i].Tag && lpb[i].Type == olpb[i].Type &&
             lpb[i].Size == olpb[i].Size) {
            found = TRUE;
            j = i;
         } else {
            /*
                It has moved so search them all.
            */
            for (j = 0; j < olpbl; j++) {
               if (lpb[i].Tag == olpb[j].Tag && lpb[i].Type == olpb[j].Type &&
                   lpb[i].Size == olpb[j].Size) {
                  found = TRUE;
                  break;
               }
            }
         }
         if (found) {
            if (olpb[i].CurrentDepth > lpb[i].CurrentDepth) {
               printf ("Lookaside: %4.4s, size %d up %d\n",
                       &lpb[i].Tag, lpb[i].Size,
                       olpb[i].CurrentDepth - lpb[i].CurrentDepth);
               diff = TRUE;
               if (ret == DIAG_RET) {
                  tag_to_wide ((PUCHAR)&lpb[i].Tag, wtag);
                  fwprintf (diag_file, L"%s Lookaside: %4.4s, size %d up %d\r\n",
                            lastcrashline,
                            wtag, lpb[i].Size,
                            olpb[i].CurrentDepth - lpb[i].CurrentDepth);
                  fflush (diag_file);
               }
            }
         } else {
            /*
                A new tag has appeared here
            */
            printf ("New Lookaside %4.4s, size %d, depth %d\n",
                    &lpb[i].Tag, lpb[i].Size,
                    lpb[i].CurrentDepth);
            diff = TRUE;
         }
      }
      free (olpb);
   }

   /*
       now do lookaside information
   */
//   printf ("Total tags %d\n", pb->Count);
   if (opb) {
      for (i = 0; i < pb->Count; i++) {
         found = FALSE;
         if (i < opb->Count && pb->TagInfo[i].TagUlong == opb->TagInfo[i].TagUlong) {
            j = i;
            found = TRUE;
         } else {
            for (j = 0; j < pb->Count; j++) {
               if (pb->TagInfo[i].TagUlong == opb->TagInfo[j].TagUlong) {
                  found = TRUE;
                  break;
               }
            }
         }
         if (found) {
            if (pb->TagInfo[i].PagedUsed    > opb->TagInfo[j].PagedUsed ||
                pb->TagInfo[i].NonPagedUsed > opb->TagInfo[j].NonPagedUsed) {
               diff = TRUE;
               printf ("Pool: %4.4s, Paged up %d, NonPaged up %d\n",
                       &pb->TagInfo[i].TagUlong,
                       pb->TagInfo[i].PagedUsed - opb->TagInfo[i].PagedUsed,
                       pb->TagInfo[i].NonPagedUsed - opb->TagInfo[i].NonPagedUsed);
               if (ret == DIAG_RET) {
                  tag_to_wide ((PUCHAR)&pb->TagInfo[i].TagUlong, wtag);
                  fwprintf (diag_file, L"%s Pool: %4.4s, Paged up %d, NonPaged up %d\r\n",
                            lastcrashline,
                            wtag,
                            pb->TagInfo[i].PagedUsed - opb->TagInfo[i].PagedUsed,
                            pb->TagInfo[i].NonPagedUsed - opb->TagInfo[i].NonPagedUsed);
                  fflush (diag_file);
               }
            }
         } else {
            diff = TRUE;
            newtag = TRUE;
            printf ("New tag %4.4s\n", &pb->TagInfo[i].TagUlong);
         }
      }
      free (opb);
   }
   opb = pb;
   olpb = lpb;
   olpbl = lpbl;
   return diff;
}
/*
   Turn on fault injection in the driver verifier
*/
void turn_on_fault_injection ()
{
   ULONG svi;
   NTSTATUS status;

   svi = DRIVER_VERIFIER_SPECIAL_POOLING |
         DRIVER_VERIFIER_FORCE_IRQL_CHECKING |
         DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES;
   status = NtSetSystemInformation (SystemVerifierInformation, &svi, sizeof (svi));
   if (!NT_SUCCESS (status)) {
         printf ("NtSetSystemInformation for SystemVerifierInformation failed %x\n",
                 status);
      flags &= ~FLAGS_DO_FAILURE_INJECTION; // Turn off flag to prevent errors
   }   
}

/*
   Turn off fault injection in the driver verifier
*/
void turn_off_fault_injection ()
{
   ULONG svi;
   NTSTATUS status;

   svi = DRIVER_VERIFIER_SPECIAL_POOLING |
         DRIVER_VERIFIER_FORCE_IRQL_CHECKING;
   status = NtSetSystemInformation (SystemVerifierInformation, &svi, sizeof (svi));
   if (!NT_SUCCESS (status)) {
         printf ("NtSetSystemInformation for SystemVerifierInformation failed %x\n",
                 status);
   }   
}

/*
   Read a line from the crash file and remove returns etc
*/
PWCHAR getline (PWCHAR templine, ULONG size, FILE *file)
{
   PWCHAR ret;
   PWCHAR cp;

   ret = fgetws (templine, size, file);
   if (ret) {
      cp = wcsstr (templine, L"\r");
      if (cp)
         *cp = '\0';
      cp = wcsstr (templine, L"\n");
      if (cp)
         *cp = '\0';
   }
   return ret;
}

/*
    Add a line to the list of lines that crashed us before
*/
VOID add_crash_list (PWCHAR crashline)
{
   PCRASHNODE node;

   node = malloc (sizeof (CRASHNODE));
   if (!node) {
      printf ("Memory allocation failed for crash node!\n");
      exit (EXIT_FAILURE);
   }
   node->next = crashlist;
   crashlist = node;
   node->string = malloc ((wcslen (crashline) + 1) * sizeof (WCHAR));
   if (!node->string) {
      printf ("Memory allocation failed for crash line!\n");
      exit (EXIT_FAILURE);
   }
   wcscpy (node->string, crashline);
}

/*
   See if this operation crashed us before
*/
BOOL crashes (PWCHAR path, PWCHAR thing1, PWCHAR thing2, PWCHAR thing3, PWCHAR thing4)
{
   PWCHAR crashline = NULL;
   PWCHAR templine = NULL;
   BOOL result;
   HANDLE crashfilehandle;
   DWORD retlen;
   BOOL opened;
   PCRASHNODE node;
   ULONG count;
   BOOLEAN StoppedImpersonating;

   progress_counter++;
   _snwprintf (lastcrashline, sizeof (lastcrashline)/sizeof (WCHAR),
               L"%s %s %s %s %s", path, thing1, thing2, thing3, thing4);
   if ((flags&FLAGS_DO_LOGGING) == 0) {
      wprintf (L"%s\n", lastcrashline);
      SetConsoleTitleW (lastcrashline);
      return FALSE;
   }
   crashline = malloc (CRASH_LINE_SIZE*sizeof (WCHAR));
   if (!crashline) {
      printf ("Failed to allocate crash line buffer\n");
      exit (EXIT_FAILURE);
   }
   templine = malloc (CRASH_LINE_SIZE*sizeof (WCHAR));
   if (!templine) {
      printf ("Failed to allocate crash line buffer\n");
      exit (EXIT_FAILURE);
   }
   StoppedImpersonating = FALSE;
   if (Impersonating) {
      Revert_from_admin ();
      StoppedImpersonating = TRUE;
   }
   opened = FALSE;
   if (!skipfile) {
      /*
          First time in openen up the files
      */
      opened = TRUE;
      skipfile = _wfopen (L"crash.log", L"ab");
      if (skipfile) {
         crashfile = _wfopen (L"crashn.log", L"rb");
         if (crashfile) {
            printf ("Opened crashn.log for reading\n");
            crashline[0] = '\0';
            while (getline (templine, CRASH_LINE_SIZE, crashfile)) {
               if (wcslen (templine) > 0) {
                  if (flags&FLAGS_DO_SKIPDONE) {
                     add_crash_list (templine);
                  }
                  wcscpy (crashline, templine);
               }
            }
            fclose (crashfile);
            crashfile = NULL;
            if (crashline[0] != '\0' && wcsncmp (crashline, L"DONE", 4) != 0) {
               fputws (crashline, skipfile);
               fputws (L"\r\n", skipfile);
            }
         }
         fclose (skipfile);
      }
      skipfile = _wfopen (L"crash.log", L"rb");
   }
   if (skipfile && opened) {
      while (getline (crashline, CRASH_LINE_SIZE, skipfile)) {
         if (flags&FLAGS_DO_SKIPCRASH && wcscmp (crashline, L"DONE") != 0) {
            add_crash_list (crashline);
         }
      }
   }
   /*
      Run through crashing lines looking for a match
   */
   result = FALSE;
   _snwprintf (templine, CRASH_LINE_SIZE, L"%s %s %s %s %s", path, thing1, thing2, thing3, thing4);
   SetConsoleTitleW (templine);
   for (node = crashlist; node; node = node->next) {
      if (_wcsicmp (node->string, templine) == 0) {
         result = TRUE;
         break;
      }
   }
   if (!result) {
      print_diags (0, 0);
      count = 0;
      do {
         crashfilehandle = CreateFile("crashn.log", GENERIC_WRITE, 0, NULL, 
                                       OPEN_ALWAYS, FILE_FLAG_WRITE_THROUGH, 0 );
         if (crashfilehandle == INVALID_HANDLE_VALUE) {
            printf ("CreateFile failed for crash logging file %d\n", GetLastError ());
            if (count++ > 20) {
               break;
            } else {
               Sleep (5000);
            }
         }
      } while (crashfilehandle == INVALID_HANDLE_VALUE);

      if (crashfilehandle != INVALID_HANDLE_VALUE) {
         SetFilePointer (crashfilehandle, 0, 0, FILE_END);
         _snwprintf (templine, CRASH_LINE_SIZE,
                     L"%s %s %s %s %s\r\n", path, thing1, thing2, thing3, thing4);
         wprintf (L"%s", templine);
         /*
            This is a bit excessive and costly but I really want to make sure this gets
            logged as the next operation may crash the machine.
         */
         if (!WriteFile (crashfilehandle, templine, wcslen(templine)*sizeof (WCHAR), &retlen, 0)) {
            printf ("WriteFile failed fore crash line %d\n", GetLastError ());
            exit (EXIT_FAILURE);
         }
         if (!FlushFileBuffers (crashfilehandle)) {
            printf ("FlushFileBuffers failed for crash file %d\n", GetLastError ());
            exit (EXIT_FAILURE);
         }
         if (!CloseHandle (crashfilehandle)) {
            printf ("CloseHandle failed for crash file %d\n", GetLastError ());
            exit (EXIT_FAILURE);
         }
      }
   }
   if (StoppedImpersonating) {
       Impersonate_nonadmin ();
   }

   free (crashline);
   free (templine);
   return result;
}


/*
   Hack to get a 32 bit random value from a 15 bit source
*/
ULONG
rand32(
       void
)
{
    return(rand() << 17) + rand() + rand();
}

/*
   RandInRange - produce a random number in some range
*/
ULONG
RandInRange( ULONG lowerb, ULONG upperb )
{
   if( lowerb > upperb ) {
      ULONG temp;
      temp= upperb;

   return lowerb + rand32()%(upperb-lowerb);
      upperb= lowerb;
      upperb= temp;
   }

   return lowerb + rand32()%(upperb-lowerb);

}

/*
   Allocate a buffer with slop and fill the slop with a know value
*/
PVOID
reallocslop(
    PVOID                   p,
    ULONG                   len
)
{
    progress_counter++;
    p = realloc(p,
                len + SLOP);

    memset(p,
           SLOP_SENTINAL,
           len + SLOP);

    return p;
}




/*
   Check to see if the driver wrote too far by checking the slop values
*/
VOID
testslop(
    PVOID                   p,
    ULONG                   len,
    PWCHAR                  what,
    PWCHAR                  subwhat
)
{
    UCHAR                   string[100], *pc;
    ULONG                   i;

    pc = p;

    pc += len;

    for (i = 0; i < SLOP; i++, pc++) {
        if (*pc != SLOP_SENTINAL) {
            wprintf(L"Driver wrote beyond end during %s %s for length %d!\n",
                    what, subwhat, len);

            scanf("%100s",
                  &string);

            break;
        }
    }
}

/*
   Issue different sized EA's
*/
VOID
do_query_ea(
    HANDLE                  handle,
    PWCHAR                  path
)
{
    ULONG                   l, i, old, ret;
    IO_STATUS_BLOCK         iosb;
    ULONG                   tmp;
    PVOID                   buf;
    NTSTATUS                status, last_status;


    if (crashes (path, L"NtQueryEaFile", L"", L"", L""))
       return;

    ret = 0;
    buf = NULL;
    do {
       last_status = 0;

       l = 1024;


       do {
           buf = reallocslop(buf,
                             l);

           status = NtQueryEaFile (handle, &iosb, buf, l, FALSE, NULL, 0, NULL, FALSE);
           if (NT_SUCCESS (status))
              status = iosb.Status;
           testslop(buf,
                    l,
                    L"NtQueryEaFile",
                    L"");

           if (status == STATUS_NOT_IMPLEMENTED ||
               status == STATUS_INVALID_INFO_CLASS ||
               status == STATUS_INVALID_DEVICE_REQUEST ||
               status == STATUS_INVALID_PARAMETER ||
               status == STATUS_ACCESS_DENIED) {

//               break;
           }

           if (!NT_SUCCESS(status) &&
               status != last_status) {

               last_status = status;
               if (flags&FLAGS_DO_ERRORS)
                  printf("NtQueryEaFile failed %x\n",
                         status);
           }
       } while (l-- != 0);

       if (flags&FLAGS_DO_ZEROEA) {
          status = NtQueryEaFile(handle,
                                 &iosb,
                                 (PVOID)-1024,
                                 0,
                                 FALSE, NULL, 0, NULL, FALSE);
       }

       if (!NT_SUCCESS(status)) {
           if (flags&FLAGS_DO_ERRORS)
              printf("NtQueryEaFile failed %x\n",
                     status);
       }
    } while (print_diags (0, ret++) && ret < MAX_RET);

    status = NtCancelIoFile (handle, &iosb);

    free(buf);

    if (!(flags&FLAGS_DO_PROT) || crashes (path, L"NtQueryEaFile prot", L"", L"", L""))
       return;
    status = NtResumeThread (changethread, &tmp);
    if (!NT_SUCCESS (status)) {
       printf ("NtResumeThread failed %x\n", status);
    }

    for (i = 1; i < PROT_REP; i++) {
       if (!VirtualProtect (buf, 1, PAGE_READWRITE, &old)) {
          printf ("VirtualProtect failed %d\n", GetLastError ());
       }
       status = NtQueryEaFile(handle,
                              &iosb,
                              bigbuf,
                              BIGBUF_SIZE,
                              FALSE, NULL, 0, NULL, FALSE);
    }
    status = NtSuspendThread (changethread, &tmp);
    if (!NT_SUCCESS (status)) {
       printf ("NtResumeThread failed %x\n", status);
    }
    if (!VirtualProtect (buf, 1, PAGE_READWRITE, &old)) {
       printf ("VirtualProtect failed %d\n", GetLastError ());
    }

}
/*
   Do volume queries of different lengths
*/
VOID
do_query_volume(
    HANDLE                  handle,
    FS_INFORMATION_CLASS    InfoType,
    ULONG                   bufl,
    PWCHAR                  what,
    PWCHAR                  path
)
{
    ULONG                   l, ret;
    IO_STATUS_BLOCK         iosb;
    PVOID                   buf;
    NTSTATUS                status, last_status;

    if (crashes (path, L"NtQueryVolumeInformationFile", what, L"", L""))
       return;

    ret = 0;
    buf = NULL;
    do {
       last_status = 0;

       l = bufl + 1024;


       do {
           buf = reallocslop(buf,
                             l);

           status = NtQueryVolumeInformationFile(handle,
                                                 &iosb,
                                                 buf,
                                                 l,
                                                 InfoType);

           testslop(buf,
                    l,
                    L"NtQueryVolumeInformationFile",
                    what);

           if (status == STATUS_NOT_IMPLEMENTED ||
               status == STATUS_INVALID_INFO_CLASS ||
               status == STATUS_INVALID_DEVICE_REQUEST ||
               status == STATUS_INVALID_PARAMETER ||
               status == STATUS_ACCESS_DENIED) {

//               break;
           }

           if (!NT_SUCCESS(status) &&
               status != last_status) {

               last_status = status;
               if (flags&FLAGS_DO_ERRORS)
                  wprintf(L"NtQueryVolumeInformationFile for %s failed %x\n",
                          what, status);
           }
       } while (l-- != 0);

       status = NtQueryVolumeInformationFile(handle,
                                             &iosb,
                                             (PVOID)-1024,
                                             0,
                                             InfoType);

       if (!NT_SUCCESS(status)) {
          if (flags&FLAGS_DO_ERRORS)
             wprintf(L"NtQueryVolumeInformationFile for %s failed %x\n",
                     what, status);
       }
    } while (print_diags (0, ret++) && ret < MAX_RET);

    status = NtCancelIoFile (handle, &iosb);
    free(buf);
}

/*
   Do volume sets of different lengths
*/
VOID
do_set_volume(
    HANDLE                  handle,
    FS_INFORMATION_CLASS    InfoType,
    ULONG                   bufl,
    PWCHAR                  what,
    PWCHAR                  path
)
{
    ULONG                   l, i, ret;
    IO_STATUS_BLOCK         iosb;
    PVOID                   buf;
    NTSTATUS                status, last_status;

    if (crashes (path, L"NtSetVolumeInformationFile", what, L"", L""))
       return;

    ret = 0;
    buf = NULL;
    do {
       last_status = 0;

       l = bufl + 1024;


       buf = malloc (l);
       do {
           for (i = 0; i < l; i++) {
              ((PCHAR)buf)[i] = (CHAR) rand ();
           }

           progress_counter++;
           status = NtSetVolumeInformationFile(handle,
                                               &iosb,
                                               buf,
                                               l,
                                               InfoType);

           if (status == STATUS_NOT_IMPLEMENTED ||
               status == STATUS_INVALID_INFO_CLASS ||
               status == STATUS_INVALID_DEVICE_REQUEST ||
               status == STATUS_INVALID_PARAMETER ||
               status == STATUS_ACCESS_DENIED) {

//               break;
           }

           if (!NT_SUCCESS(status) &&
               status != last_status) {

               last_status = status;
               if (flags&FLAGS_DO_ERRORS)
                  wprintf(L"NtSetVolumeInformationFile for %s failed %x\n",
                          what, status);
           }
       } while (l-- != 0);

       progress_counter++;
       status = NtSetVolumeInformationFile(handle,
                                           &iosb,
                                           (PVOID)-1024,
                                           0,
                                           InfoType);

       if (!NT_SUCCESS(status)) {
           if (flags&FLAGS_DO_ERRORS)
              wprintf(L"NtSetVolumeInformationFile for %s failed %x\n",
                      what, status);
       }
    } while (print_diags (0, ret++) && ret < MAX_RET);

    status = NtCancelIoFile (handle, &iosb);
    free(buf);
}

/*
   Do file queries
*/
VOID
do_query_file(
    HANDLE                  handle,
    FILE_INFORMATION_CLASS  InfoType,
    ULONG                   bufl,
    PWCHAR                  what,
    PWCHAR                  path
)
{
    ULONG                   l, i, ret;
    IO_STATUS_BLOCK         iosb;
    PVOID                   buf;
    NTSTATUS                status, last_status;
    ULONG                   tmp;
    DWORD                   old;

    if (crashes (path, L"NtQueryInformationFile", what, L"", L""))
       return;

    ret = 0;
    buf = NULL;
    do {
       last_status = 0;

       l = bufl + 1024;


       do {
           buf = reallocslop(buf,
                             l);
           status = NtQueryInformationFile(handle,
                                           &iosb,
                                           buf,
                                           l,
                                           InfoType);

           testslop(buf,
                    l,
                    L"NtQueryInformationFile",
                    what);

           if (status == STATUS_NOT_IMPLEMENTED ||
               status == STATUS_INVALID_INFO_CLASS ||
               status == STATUS_INVALID_DEVICE_REQUEST ||
               status == STATUS_INVALID_PARAMETER ||
               status == STATUS_ACCESS_DENIED) {

//               break;
           }

           if (!NT_SUCCESS(status) &&
               status != last_status) {
               last_status = status;
               if (flags&FLAGS_DO_ERRORS)
                  wprintf(L"NtQueryInformationFile for %s failed %x\n",
                          what, status);
           }
       } while (l-- != 0);

       status = NtQueryInformationFile(handle,
                                       &iosb,
                                       (PVOID)-1024,
                                       0,
                                       InfoType);

       if (!NT_SUCCESS(status)) {
           if (flags&FLAGS_DO_ERRORS)
              wprintf(L"NtQueryInformationFile for %s failed %x\n",
                      what, status);
       }
    } while (print_diags (0, ret++) && ret < MAX_RET);
    status = NtCancelIoFile (handle, &iosb);
    free(buf);

    if (!(flags&FLAGS_DO_PROT) ||
        crashes (path, L"NtQueryInformationFile prot", L"", L"", L""))
       return;
    status = NtResumeThread (changethread, &tmp);
    if (!NT_SUCCESS (status)) {
       printf ("NtResumeThread failed %x\n", status);
    }

    for (i = 1; i < PROT_REP; i++) {
       if (!VirtualProtect (buf, 1, PAGE_READWRITE, &old)) {
          printf ("VirtualProtect failed %d\n", GetLastError ());
       }
       status = NtQueryInformationFile(handle,
                                       &iosb,
                                       bigbuf,
                                       bufl,
                                       InfoType);
    }
    status = NtSuspendThread (changethread, &tmp);
    if (!NT_SUCCESS (status)) {
       printf ("NtResumeThread failed %x\n", status);
    }
    if (!VirtualProtect (buf, 1, PAGE_READWRITE, &old)) {
       printf ("VirtualProtect failed %d\n", GetLastError ());
    }
}

/*
   Do file sets
*/
VOID
do_set_file(
    HANDLE                  handle,
    FILE_INFORMATION_CLASS  InfoType,
    ULONG                   bufl,
    PWCHAR                  what,
    PWCHAR                  path
)
{
    ULONG                   l, i, ret;
    IO_STATUS_BLOCK         iosb;
    PVOID                   buf;
    NTSTATUS                status, last_status;
    ULONG                   tmp;
    DWORD                   old;

    if (crashes (path, L"NtSetInformationFile", what, L"", L""))
       return;

    ret = 0;
    buf = NULL;
    do {
       last_status = 0;

       l = bufl + 1024;
       buf = malloc (l);
       do {
           for (i = 0; i < l; i++) {
              ((PCHAR)buf)[i] = (CHAR) rand ();
           }
           progress_counter++;
           status = NtSetInformationFile(handle,
                                         &iosb,
                                         buf,
                                         l,
                                         InfoType);

           if (status == STATUS_NOT_IMPLEMENTED ||
               status == STATUS_INVALID_INFO_CLASS ||
               status == STATUS_INVALID_DEVICE_REQUEST ||
               status == STATUS_INVALID_PARAMETER ||
               status == STATUS_ACCESS_DENIED) {

//               break;
           }

           if (!NT_SUCCESS(status) &&
               status != last_status) {
               last_status = status;
               if (flags&FLAGS_DO_ERRORS)
                  wprintf(L"NtSetInformationFile for %s failed %x\n",
                          what, status);
           }
       } while (l-- != 0);

       status = NtSetInformationFile(handle,
                                     &iosb,
                                     (PVOID)-1024,
                                     0,
                                     InfoType);

       if (!NT_SUCCESS(status)) {
           if (flags&FLAGS_DO_ERRORS)
              wprintf(L"NtSetInformationFile for %s failed %x\n",
                      what, status);
       }
    } while (print_diags (0, ret++) && ret < MAX_RET);
    status = NtCancelIoFile (handle, &iosb);
    free(buf);

    if (!(flags&FLAGS_DO_PROT) ||
        crashes (path, L"NtSetInformationFile prot", L"", L"", L""))
       return;
    status = NtResumeThread (changethread, &tmp);
    if (!NT_SUCCESS (status)) {
       printf ("NtResumeThread failed %x\n", status);
    }

    for (i = 1; i < PROT_REP; i++) {
       if (!VirtualProtect (buf, 1, PAGE_READWRITE, &old)) {
          printf ("VirtualProtect failed %d\n", GetLastError ());
       }
       status = NtSetInformationFile(handle,
                                     &iosb,
                                     bigbuf,
                                     bufl,
                                     InfoType);
    }
    status = NtSuspendThread (changethread, &tmp);
    if (!NT_SUCCESS (status)) {
       printf ("NtResumeThread failed %x\n", status);
    }
    if (!VirtualProtect (buf, 1, PAGE_READWRITE, &old)) {
       printf ("VirtualProtect failed %d\n", GetLastError ());
    }
}

/*
   Do object queries with variable length buffers
*/
VOID
do_query_object(
    HANDLE                  handle,
    OBJECT_INFORMATION_CLASS InfoType,
    ULONG                   bufl,
    PWCHAR                  what,
    PWCHAR                  path
)
{
    ULONG                   l, ret;
    IO_STATUS_BLOCK         iosb;
    PVOID                   buf;
    NTSTATUS                status, last_status;

    last_status = 0;

    if (crashes (path, L"NtQueryObject", what, L"", L""))
       return;

    buf = NULL;
    ret = 0;
    do {
       l = bufl + 1024;


       do {
           buf = reallocslop(buf,
                             l);

           status = NtQueryObject(handle,
                                  InfoType,
                                  buf,
                                  l,
                                  NULL);

           testslop(buf, l, L"NtQueryObject", what);

           if (!NT_SUCCESS(status) &&
               status != last_status) {

               last_status = status;
               if (flags&FLAGS_DO_ERRORS)
                  wprintf(L"NtQueryObject for %s failed %x\n",
                          what, status);
           }
       } while (l-- != 0);

       status = NtQueryObject(handle,
                              InfoType,
                              (PVOID)-1024,
                              0,
                              NULL);

       if (!NT_SUCCESS(status)) {
           if (flags&FLAGS_DO_ERRORS)
              wprintf(L"NtQueryObject for %s failed %x\n",
                      what, status);
       }
    } while (print_diags (0, ret++) && ret < MAX_RET);

    status = NtCancelIoFile (handle, &iosb);
    free(buf);
}

/*
   Do query security
*/
VOID
do_query_security(
    HANDLE                  handle,
    SECURITY_INFORMATION    InfoType,
    ULONG                   bufl,
    PWCHAR                  what,
    PWCHAR                  path
)
{
    ULONG                   l, i, tmp, ret;
    IO_STATUS_BLOCK         iosb;
    PVOID                   buf;
    NTSTATUS                status, last_status;
    ULONG                   ln;
    DWORD                   old;

    if (crashes (path, L"NtQuerySecurityObject", what, L"", L""))
       return;

    buf = NULL;
    ret = 0;
    do {
       last_status = 0;

       l = bufl + 1024;


       do {
           buf = reallocslop(buf,
                             l);

           status = NtQuerySecurityObject(handle,
                                          InfoType,
                                          buf,
                                          l,
                                          &ln);

           testslop(buf, l, L"NtQuerySecurityObject", what);

           if (!NT_SUCCESS(status) &&
               status != last_status && status) {

               last_status = status;
               if (flags&FLAGS_DO_ERRORS)
                  wprintf(L"NtQuerySecurityObject for %s failed %x\n",
                         what, status);
           }
       } while (l-- != 0);

       status = NtQuerySecurityObject(handle,
                                      InfoType,
                                      (PVOID)-1024,
                                      0,
                                      &ln);

       if (!NT_SUCCESS(status)) {
           if (flags&FLAGS_DO_ERRORS)
              wprintf(L"NtQuerySecurityObject for %s failed %x\n",
                      what, status);
       }
    } while (print_diags (0, ret++) && ret < MAX_RET);

    status = NtCancelIoFile (handle, &iosb);
    free(buf);

    if (!(flags&FLAGS_DO_PROT) ||
        crashes (path, L"NtQuerySecurityFile prot", L"", L"", L""))
       return;
    status = NtResumeThread (changethread, &tmp);
    if (!NT_SUCCESS (status)) {
       printf ("NtResumeThread failed %x\n", status);
    }

    for (i = 1; i < PROT_REP; i++) {
       if (!VirtualProtect (buf, 1, PAGE_READWRITE, &old)) {
          printf ("VirtualProtect failed %d\n", GetLastError ());
       }
        status = NtQuerySecurityObject(handle,
                                       InfoType,
                                       bigbuf,
                                       bufl,
                                       &ln);
    }
    status = NtSuspendThread (changethread, &tmp);
    if (!NT_SUCCESS (status)) {
       printf ("NtResumeThread failed %x\n", status);
    }
    if (!VirtualProtect (buf, 1, PAGE_READWRITE, &old)) {
       printf ("VirtualProtect failed %d\n", GetLastError ());
    }
}

/*
   Do set security
*/
VOID
do_set_security(
    HANDLE                  handle,
    SECURITY_INFORMATION    InfoType,
    ULONG                   bufl,
    PWCHAR                  what,
    PWCHAR                  path
)
{
    ULONG                   l, i, tmp, ret;
    IO_STATUS_BLOCK         iosb;
    PVOID                   buf;
    NTSTATUS                status, last_status;
    ULONG                   ln;
    DWORD                   old;
    PSECURITY_DESCRIPTOR    psd;
    LPTSTR                  tsd;

    if (crashes (path, L"NtSetSecurityObject", what, L"", L""))
       return;

    psd = malloc (l = 4096);
    if (!psd) {
       printf ("Failed to allocate security descriptor space\n");
       return;
    }
    status = NtQuerySecurityObject(handle,
                                   InfoType,
                                   psd,
                                   l,
                                   &ln);
    if (!NT_SUCCESS(status)) {
       free (psd);
       if (flags&FLAGS_DO_ERRORS)
          wprintf(L"NtQuerySecurityObject for %s failed %x\n",
                  what, status);
       return;
    }
    if (InfoType) {
       if (ConvertSecurityDescriptorToStringSecurityDescriptor (psd,
                                                                SDDL_REVISION_1,
                                                                InfoType,
                                                                &tsd,
                                                                NULL)) {
          printf ("%ws: %s\n", what, tsd);
          LocalFree (tsd);
       } else {
          printf ("ConvertSecurityDescriptorToStringSecurityDescriptor failed %d\n", GetLastError ());
       }
    }
    buf = NULL;
    ret = 0;
    do {
       last_status = 0;

       status = NtSetSecurityObject(handle,
                                    InfoType,
                                    psd);

       if (!NT_SUCCESS(status) &&
           status != last_status && status) {

           last_status = status;
           if (flags&FLAGS_DO_ERRORS)
              wprintf(L"NtSetSecurityObject for %s failed %x\n",
                      what, status);
       }
       status = NtCancelIoFile (handle, &iosb);
    } while (print_diags (0, ret++) && ret < MAX_RET);

    free(psd);
}

/*
   Do all the query functions
*/
NTSTATUS
query_object(
    HANDLE                  handle,
    PDEVMAP                 devmap,
    PWCHAR                  path
)
{
    OBJECT_NAME_INFORMATION *on = NULL;
    FILE_NAME_INFORMATION   *fn = NULL; 
    ULONG                   sfn, son;
    FILE_FS_DEVICE_INFORMATION devinfo;
    NTSTATUS                status;
    static IO_STATUS_BLOCK  iosb;

    sfn = sizeof (*fn) + 1024;
    son = sizeof (*on) + 1024;
    fn = reallocslop(NULL,
                     sfn);
    on = reallocslop(NULL,
                     son);
    if (devmap) {
       devmap->filename = fn;
       devmap->name = on;
    }

    if (fn == NULL || on == NULL) {
        printf("Memory allocation failure in query_object!\n");
        exit(EXIT_FAILURE);
    }

    status = NtQueryObject(handle,
                           ObjectNameInformation,
                           on,
                           son,
                           NULL);

    testslop(on,
             son, L"NtQueryObject", L"ObjectNameInformation");

    if (!NT_SUCCESS(status)) {
        if (flags&FLAGS_DO_ERRORS) {
            wprintf(L"NtQueryObject for ObjectNameInformation failed %x\n",
                   status);
        }

        on->Name.Length = 0;
    } else {
       wprintf (L"Object name is %s\n", on->Name.Buffer);
    }

    status = NtQueryInformationFile(handle,
                                    &iosb,
                                    fn,
                                    sfn,
                                    FileNameInformation);

    testslop(fn,
             sfn,
             L"NtQueryInformationFile",
             L"FileNameInformation");

    if (NT_SUCCESS(status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
        if (flags&FLAGS_DO_ERRORS)
           wprintf(L"NtQueryInformationFile for FileNameInformation failed %x\n",
                   status);
        fn->FileNameLength = 0;
    }

    if (!devmap) {
       free (fn);
       free (on);
    }

    status = NtQueryVolumeInformationFile(handle,
                                          &iosb,
                                          &devinfo,
                                          sizeof (devinfo),
                                          FileFsDeviceInformation);

    if (NT_SUCCESS(status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
        if (flags&FLAGS_DO_ERRORS)
           wprintf(L"NtQueryVolumeInformationFile for FileFsDeviceInformation failed %x\n",
                   status);

        if (devmap)
           devmap->devtype = 0;
    } else {
        if (devmap)
           devmap->devtype = devinfo.DeviceType;
//        printf("Got the device number for a device!\n");
    }

    if (flags&FLAGS_DO_QUERY) {
       //
       // Do loads of different queries with different buffer lengths.
       //
       do_query_object(handle,
                       ObjectNameInformation,
                       sizeof (OBJECT_NAME_INFORMATION),
                       L"ObjectNameInformation",
                       path);

       do_query_file(handle,
                     FileBasicInformation,
                     sizeof (FILE_BASIC_INFORMATION),
                     L"FileBasicInformation",
                     path);

       do_query_file(handle,
                     FileStandardInformation,
                     sizeof (FILE_STANDARD_INFORMATION),
                     L"FileStandardInformation",
                     path);

       do_query_file(handle,
                     FileInternalInformation,
                     sizeof (FILE_INTERNAL_INFORMATION),
                     L"FileInternalInformation",
                     path);

       do_query_file(handle,
                     FileEaInformation,
                     sizeof (FILE_EA_INFORMATION),
                     L"FileEaInformation",
                     path);

       do_query_file(handle,
                     FileAccessInformation,
                     sizeof (FILE_ACCESS_INFORMATION),
                     L"FileAccessInformation",
                     path);

       do_query_file(handle,
                     FileNameInformation,
                     sizeof (FILE_NAME_INFORMATION) + 1024,
                     L"FileNameInformation",
                     path);

//
// We end up turning off alertable handle with this.
//
//       do_query_file(handle,
//                     FileModeInformation,
//                     sizeof (FILE_MODE_INFORMATION),
//                     L"FileModeInformation",
//                     path);

       do_query_file(handle,
                     FileAlignmentInformation,
                     sizeof (FILE_ALIGNMENT_INFORMATION),
                     L"FileAlignmentInformation",
                     path);

       do_query_file(handle,
                     FileAllInformation,
                     sizeof (FILE_ALL_INFORMATION),
                     L"FileAllInformation",
                     path);

       do_query_file(handle,
                     FileStreamInformation,
                     sizeof (FILE_STREAM_INFORMATION),
                     L"FileStreamInformation",
                     path);

       do_query_file(handle,
                     FilePipeInformation,
                     sizeof (FILE_PIPE_INFORMATION),
                     L"FilePipeInformation",
                     path);

       do_query_file(handle,
                     FilePipeLocalInformation,
                     sizeof (FILE_PIPE_LOCAL_INFORMATION),
                     L"FilePipeLocalInformation",
                     path);

       do_query_file(handle,
                     FilePipeRemoteInformation,
                     sizeof (FILE_PIPE_REMOTE_INFORMATION),
                     L"FilePipeRemoteInformation",
                     path);

       do_query_file(handle,
                     FileCompressionInformation,
                     sizeof (FILE_COMPRESSION_INFORMATION),
                     L"FileCompressionInformation",
                     path);

       do_query_file(handle,
                     FileObjectIdInformation,
                     sizeof (FILE_OBJECTID_INFORMATION),
                     L"FileObjectIdInformation",
                     path);

       do_query_file(handle,
                     FileMailslotQueryInformation,
                     sizeof (FILE_MAILSLOT_QUERY_INFORMATION),
                     L"FileMailslotQueryInformation",
                     path);

       do_query_file(handle,
                     FileQuotaInformation,
                     sizeof (FILE_QUOTA_INFORMATION),
                     L"FileQuotaInformation",
                     path);

       do_query_file(handle,
                     FileReparsePointInformation,
                     sizeof (FILE_REPARSE_POINT_INFORMATION),
                     L"FileReparsePointInformation",
                     path);

       do_query_file(handle,
                     FileNetworkOpenInformation,
                     sizeof (FILE_NETWORK_OPEN_INFORMATION),
                     L"FileNetworkOpenInformation",
                     path);

       do_query_file(handle,
                     FileAttributeTagInformation,
                     sizeof (FILE_ATTRIBUTE_TAG_INFORMATION),
                     L"FileAttributeTagInformation",
                     path);

       do_set_file(handle,
                   FileBasicInformation,
                   sizeof (FILE_BASIC_INFORMATION),
                   L"FileBasicInformation",
                   path);

       do_set_file(handle,
                   FileRenameInformation,
                   sizeof (FILE_RENAME_INFORMATION),
                   L"FileRenameInformation",
                   path);

       do_set_file(handle,
                   FileLinkInformation,
                   sizeof (FILE_LINK_INFORMATION),
                   L"FileLinkInformation",
                   path);

       do_set_file(handle,
                   FileDispositionInformation,
                   sizeof (FILE_DISPOSITION_INFORMATION),
                   L"FileDispositionInformation",
                   path);

       do_set_file(handle,
                   FilePositionInformation,
                   sizeof (FILE_POSITION_INFORMATION),
                   L"FilePositionInformation",
                   path);

       do_set_file(handle,
                   FileAllocationInformation,
                   sizeof (FILE_ALLOCATION_INFORMATION),
                   L"FileAllocationInformation",
                   path);

       do_set_file(handle,
                   FileEndOfFileInformation,
                   sizeof (FILE_END_OF_FILE_INFORMATION),
                   L"FileEndOfFileInformation",
                   path);

       do_set_file(handle,
                   FilePipeInformation,
                   sizeof (FILE_PIPE_INFORMATION),
                   L"FilePipeInformation",
                   path);

       do_set_file(handle,
                   FilePipeRemoteInformation,
                   sizeof (FILE_PIPE_REMOTE_INFORMATION),
                   L"FilePipeRemoteInformation",
                   path);

       do_set_file(handle,
                   FileMailslotSetInformation,
                   sizeof (FILE_MAILSLOT_SET_INFORMATION),
                   L"FileMailslotSetInformation",
                   path);

       do_set_file(handle,
                   FileObjectIdInformation,
                   sizeof (FILE_OBJECTID_INFORMATION),
                   L"FileObjectIdInformation",
                   path);

       do_set_file(handle,
                   FileMoveClusterInformation,
                   sizeof (FILE_MOVE_CLUSTER_INFORMATION),
                   L"FileMoveClusterInformation",
                   path);

       do_set_file(handle,
                   FileQuotaInformation,
                   sizeof (FILE_QUOTA_INFORMATION),
                   L"FileQuotaInformation",
                   path);

       do_set_file(handle,
                   FileTrackingInformation,
                   sizeof (FILE_TRACKING_INFORMATION),
                   L"FileTrackingInformation",
                   path);

       do_set_file(handle,
                   FileValidDataLengthInformation,
                   sizeof (FILE_VALID_DATA_LENGTH_INFORMATION),
                   L"FileValidDataLengthInformation",
                   path);

       do_set_file(handle,
                   FileShortNameInformation,
                   sizeof (FILE_NAME_INFORMATION) + 1024,
                   L"FileShortNameInformation",
                   path);

       do_query_volume(handle,
                       FileFsVolumeInformation,
                       sizeof( FILE_FS_VOLUME_INFORMATION ) + 1024,
                       L"FileFsVolumeInformation",
                       path);

       do_query_volume(handle,
                       FileFsSizeInformation,
                       sizeof( FILE_FS_SIZE_INFORMATION ),
                       L"FileFsSizeInformation",
                       path);

       do_query_volume(handle,
                       FileFsDeviceInformation,
                       sizeof( FILE_FS_DEVICE_INFORMATION ) + 1024,
                       L"FileFsDeviceInformation",
                       path);

       do_query_volume(handle,
                       FileFsAttributeInformation,
                       sizeof( FILE_FS_ATTRIBUTE_INFORMATION ),
                       L"FileFsAttributeInformation",
                       path);

       do_query_volume(handle,
                       FileFsControlInformation,
                       sizeof( FILE_FS_CONTROL_INFORMATION ),
                       L"FileFsControlInformation",
                       path);

       do_query_volume(handle,
                       FileFsFullSizeInformation,
                       sizeof( FILE_FS_SIZE_INFORMATION ),
                       L"FileFsFullSizeInformation",
                       path);

       do_query_volume(handle,
                       FileFsObjectIdInformation,
                       sizeof( FILE_FS_OBJECTID_INFORMATION ) + 1024,
                       L"FileFsObjectIdInformation",
                       path);

       do_query_volume(handle,
                       FileFsDriverPathInformation,
                       sizeof( FILE_FS_DRIVER_PATH_INFORMATION ) + 1024,
                       L"FileFsDriverPathInformation",
                       path);

       do_set_volume(handle,
                     FileFsObjectIdInformation,
                     sizeof( FILE_FS_OBJECTID_INFORMATION ) + 1024,
                     L"FileFsObjectIdInformation",
                     path);

       do_set_volume(handle,
                     FileFsControlInformation,
                     sizeof( FILE_FS_CONTROL_INFORMATION ) + 1024,
                     L"FileFsControlInformation",
                     path);

       do_set_volume(handle,
                     FileFsLabelInformation,
                     sizeof( FILE_FS_LABEL_INFORMATION ) + 1024,
                     L"FileFsLabelInformation",
                     path);
    }

    if (flags&FLAGS_DO_SECURITY) {
       do_query_security(handle,
                         0,
                         1024,
                         L"NONE",
                         path);

       do_query_security(handle,
                         OWNER_SECURITY_INFORMATION,
                         1024,
                         L"OWNER_SECURITY_INFORMATION",
                         path);
                       
       do_query_security(handle,
                         GROUP_SECURITY_INFORMATION,
                         1024,
                         L"GROUP_SECURITY_INFORMATION",
                         path);

       do_query_security(handle,
                         DACL_SECURITY_INFORMATION,
                         1024,
                         L"DACL_SECURITY_INFORMATION",
                         path);

       do_query_security(handle,
                         SACL_SECURITY_INFORMATION,
                         1024,
                         L"SACL_SECURITY_INFORMATION",
                         path);

       do_set_security(handle,
                       0,
                       1024,
                       L"NONE",
                       path);

       do_set_security(handle,
                       OWNER_SECURITY_INFORMATION,
                       1024,
                       L"OWNER_SECURITY_INFORMATION",
                       path);
                       
       do_set_security(handle,
                       GROUP_SECURITY_INFORMATION,
                       1024,
                       L"GROUP_SECURITY_INFORMATION",
                       path);

       do_set_security(handle,
                       DACL_SECURITY_INFORMATION,
                       1024,
                       L"DACL_SECURITY_INFORMATION",
                       path);

       do_set_security(handle,
                       SACL_SECURITY_INFORMATION,
                       1024,
                       L"SACL_SECURITY_INFORMATION",
                       path);
    }
    return status;
}

/*
   Do the fast queries on the open path
*/
NTSTATUS
try_fast_query_delete_etc(
    POBJECT_ATTRIBUTES poa,
    PWCHAR             path,
    PWCHAR             type)
{
    PVOID fi = NULL;
    NTSTATUS status;
    ULONG ret;

    if (!(flags&FLAGS_DO_MISC))
       return 0;

    status = STATUS_SUCCESS;
    if (!crashes (path, L"NtQueryAttributesFile", type, L"", L"")) {
        ret = 0;
        do {
           fi = reallocslop(fi,
                            sizeof (FILE_BASIC_INFORMATION));
           status = NtQueryAttributesFile (poa, fi);
           if (!NT_SUCCESS (status)) {
              if (flags&FLAGS_DO_ERRORS)
                 printf ("NtQueryAttributesFile failed %x\n", status);
           }
           testslop(fi,
                    sizeof (FILE_BASIC_INFORMATION), L"NtQueryAttributesFile", L"");
       } while (print_diags (0, ret++) && ret < MAX_RET);
    }

    if (!crashes (path, L"NtQueryFullAttributesFile", type, L"", L"")) {
        ret = 0;
        do {
           fi = reallocslop(fi,
                            sizeof (FILE_NETWORK_OPEN_INFORMATION));
           status = NtQueryFullAttributesFile (poa, fi);
           if (!NT_SUCCESS (status)) {
              if (flags&FLAGS_DO_ERRORS)
                 printf ("NtQueryFullAttributesFile failed %x\n", status);
           }
           testslop(fi,
                    sizeof (FILE_NETWORK_OPEN_INFORMATION), L"NtQueryFULLAttributesFile", L"");
       } while (print_diags (0, ret++) && ret < MAX_RET);
    }

    
    if (!crashes (path, L"NtDeleteFile", type, L"", L"")) {
        ret = 0;
        do {
           status = NtDeleteFile(poa);
           if (!NT_SUCCESS (status)) {
              if (flags&FLAGS_DO_ERRORS)
                 printf ("NtDeleteFile failed %x\n", status);
           }
       } while (print_diags (0, ret++) && ret < MAX_RET);
    }
    free (fi);
    return status;
}

/*
   Do a whole bunch of random things
*/
NTSTATUS misc_functions(
    HANDLE handle,
    PWCHAR path,
    ULONG sync
    )
{
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    PVOID buf;
    ULONG bufl;
    LONG i;
    HANDLE sectionhandle;
    LARGE_INTEGER bo, bl;
    ULONG ret, managed_read, managed_write;

    if (!(flags&FLAGS_DO_MISC))
       return STATUS_SUCCESS;

    buf = malloc (bufl = 1024);
    if (buf == 0) {
       printf ("Failed to allocate buffer!\n");
       exit (EXIT_FAILURE);
    }

    managed_read = 0;
    if (!sync) {
       if (!crashes (path, L"NtReadFile", L"", L"", L"")) {
          for (i = bufl; i >= 0; i--) {
             ret = 0;
             do {
                progress_counter++;
                bo.QuadPart = 0;
                status = NtReadFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                     &bo, NULL);
                if (NT_SUCCESS (status)) {
                   status = iosb.Status;
                   managed_read = 1;
                }
                if (!NT_SUCCESS (status)) {
                   if (flags&FLAGS_DO_ERRORS)
                      printf ("NtReadFile failed %x\n", status);
                }
                progress_counter++;
                bo.QuadPart = 0x7FFFFFFFFFFFFFFF - i + 1;
                status = NtReadFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                     &bo, NULL);
                if (NT_SUCCESS (status))
                   status = iosb.Status;
                if (!NT_SUCCESS (status)) {
                   if (flags&FLAGS_DO_ERRORS)
                      printf ("NtReadFile failed %x\n", status);
                }
                NtCancelIoFile (handle, &iosb);
             } while (print_diags (0, ret++) && ret < MAX_RET);
          }
       }

       if (managed_read) {
          printf ("Managed to read from the device\n");
          if (diag_file) {
             fwprintf (diag_file, L"Managed to read from device %s\r\n", path);
          }
       }

       managed_write = 0;
       if (!crashes (path, L"NtWriteFile", L"", L"", L"")) {
          for (i = bufl; i >= 0; i--) {
             ret = 0;
             do {
                progress_counter++;
                bo.QuadPart = 0;
                status = NtWriteFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                      &bo, NULL);
                if (NT_SUCCESS (status)) {
                   status = iosb.Status;
                   managed_write = 0;
                }
                if (!NT_SUCCESS (status)) {
                   if (flags&FLAGS_DO_ERRORS)
                      printf ("NtWriteFile failed %x\n", status);
                }
                /*
                   Wrap to negative call
                */
                progress_counter++;
                bo.QuadPart = 0x7FFFFFFFFFFFFFFF - i + 1;
                status = NtWriteFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                      &bo, NULL);
                if (NT_SUCCESS (status))
                   status = iosb.Status;
                if (!NT_SUCCESS (status)) {
                   if (flags&FLAGS_DO_ERRORS)
                      printf ("NtWriteFile failed %x\n", status);
                }
                /*
                   Do an append call.
                */
                progress_counter++;
                bo.QuadPart = -1;
                status = NtWriteFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                      &bo, NULL);
                if (NT_SUCCESS (status))
                   status = iosb.Status;
                if (!NT_SUCCESS (status)) {
                   if (flags&FLAGS_DO_ERRORS)
                      printf ("NtWriteFile failed %x\n", status);
                }
                NtCancelIoFile (handle, &iosb);
             } while (print_diags (0, ret++) && ret < MAX_RET);
          }
       }
       if (managed_write) {
          printf ("Managed to write to the device\n");
          if (diag_file) {
             fwprintf (diag_file, L"Managed to write to the device %s\r\n", path);
          }
       }
    }

    if (!crashes (path, L"NtCancelIoFile", L"", L"", L"")) {
       ret = 0;
       do {
          status = NtCancelIoFile (handle, &iosb);
          if (NT_SUCCESS (status))
             status = iosb.Status;
          if (!NT_SUCCESS (status)) {
             if (flags&FLAGS_DO_ERRORS)
                printf ("NtCancelIoFile failed %x\n", status);
          }
       } while (print_diags (0, ret++) && ret < MAX_RET);
    }

    if (!crashes (path, L"NtFlushBuffersFile", L"", L"", L"")) {
       ret = 0;
       do {
          progress_counter++;
          status = NtFlushBuffersFile (handle, &iosb);
          if (NT_SUCCESS (status))
             status = iosb.Status;
          if (!NT_SUCCESS (status)) {
             if (flags&FLAGS_DO_ERRORS)
                printf ("NtFlushBuffersFile failed %x\n", status);
          }
       } while (print_diags (0, ret++) && ret < MAX_RET);
    }
    if (!crashes (path, L"NtQueryDirectoryFile", L"FileNamesInformation", L"", L"")) {
       ULONG first = 1, j, datalen, l;
       WCHAR bufn[1024];
       PFILE_NAMES_INFORMATION tfni;

       for (i = bufl; i >= 0; i--) {
          ret = 0;
          do {
             progress_counter++;
             status = NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                            FileNamesInformation, FALSE, NULL, TRUE);
             if (!NT_SUCCESS (status)) {
                if (flags&FLAGS_DO_ERRORS)
                   printf ("NtQueryDirectoryFile failed for type FileNamesInformation %x\n",
                           status);
             } else if (first && status != STATUS_PENDING) {
                first = 0;
                datalen = (ULONG) iosb.Information;
                for (j = 0; j < datalen; j += tfni->NextEntryOffset) {
                   tfni = (PFILE_NAMES_INFORMATION)((PCHAR)buf + j);
                   memset (bufn, 0, sizeof (bufn));
                   l = tfni->FileNameLength / sizeof (WCHAR);
                   if (l >= sizeof (bufn) / sizeof (bufn[0]))
                      l = sizeof (bufn) / sizeof (bufn[0]) - 1;
                   wcsncpy (bufn, tfni->FileName, l);
                   wprintf (L"-> %s\n", bufn);
                   if (tfni->NextEntryOffset == 0)
                      break;
                }
             }
          } while (print_diags (0, ret++) && ret < MAX_RET);
       }
    }
    if (!crashes (path, L"NtQueryDirectoryFile", L"FileDirectoryInformation", L"", L"")) {
       for (i = bufl; i >= 0; i--) {
          ret = 0;
          do {
             progress_counter++;
             status = NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                            FileDirectoryInformation, FALSE, NULL, TRUE);
             if (NT_SUCCESS (status))
                status = iosb.Status;
             if (!NT_SUCCESS (status)) {
                if (flags&FLAGS_DO_ERRORS)
                   printf ("NtQueryDirectoryFile failed for type FileDirectoryInformation %x\n", status);
             }
          } while (print_diags (0, ret++) && ret < MAX_RET);
       }
    }
    if (!crashes (path, L"NtQueryDirectoryFile", L"FileFullDirectoryInformation", L"", L"")) {
       for (i = bufl; i >= 0; i--) {
          ret = 0;
          do {
             progress_counter++;
             status = NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                            FileFullDirectoryInformation, FALSE, NULL, TRUE);
             if (NT_SUCCESS (status))
                status = iosb.Status;
             if (!NT_SUCCESS (status)) {
                if (flags&FLAGS_DO_ERRORS)
                   printf ("NtQueryDirectoryFile failed for type FileFullDirectoryInformation %x\n", status);
             }
          } while (print_diags (0, ret++) && ret < MAX_RET);
       }
    }

    if (!crashes (path, L"NtQueryDirectoryFile", L"FileBothDirectoryInformation", L"", L"")) {
       for (i = bufl; i >= 0; i--) {
          ret = 0;
          do {
             progress_counter++;
             status = NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                            FileBothDirectoryInformation, FALSE, NULL, TRUE);
             if (NT_SUCCESS (status))
                status = iosb.Status;
             if (!NT_SUCCESS (status)) {
                if (flags&FLAGS_DO_ERRORS)
                   printf ("NtQueryDirectoryFile failed for type FileBothDirectoryInformation %x\n", status);
             }
          } while (print_diags (0, ret++) && ret < MAX_RET);
       }
    }

    if (!crashes (path, L"NtQueryDirectoryFile", L"FileObjectIdInformation", L"", L"")) {
       for (i = bufl; i >= 0; i--) {
          ret = 0;
          do {
             progress_counter++;
             status = NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                            FileObjectIdInformation, FALSE, NULL, TRUE);
             if (NT_SUCCESS (status))
                status = iosb.Status;
             if (!NT_SUCCESS (status)) {
                if (flags&FLAGS_DO_ERRORS)
                   printf ("NtQueryDirectoryFile failed for type FileObjectIdInformation %x\n", status);
             }
          } while (print_diags (0, ret++) && ret < MAX_RET);
       }
    }

    if (!crashes (path, L"NtQueryDirectoryFile", L"FileQuotaInformation", L"", L"")) {
       for (i = bufl; i >= 0; i--) {
          ret = 0;
          do {
             progress_counter++;
             status = NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                            FileQuotaInformation, FALSE, NULL, TRUE);
             if (NT_SUCCESS (status))
                status = iosb.Status;
             if (!NT_SUCCESS (status)) {
                if (flags&FLAGS_DO_ERRORS)
                   printf ("NtQueryDirectoryFile failed for type FileQuotaInformation %x\n", status);
             }
          } while (print_diags (0, ret++) && ret < MAX_RET);
       }
    }

    if (!crashes (path, L"NtQueryDirectoryFile", L"FileReparsePointInformation", L"", L"")) {
       for (i = bufl; i >= 0; i--) {
          ret = 0;
          do {
             progress_counter++;
             status = NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                            FileReparsePointInformation, FALSE, NULL, TRUE);
             if (NT_SUCCESS (status))
                status = iosb.Status;
             if (!NT_SUCCESS (status)) {
                if (flags&FLAGS_DO_ERRORS)
                   printf ("NtQueryDirectoryFile failed for type FileReparsePointInformation %x\n", status);
             }
          } while (print_diags (0, ret++) && ret < MAX_RET);
       }
    }

    if (!crashes (path, L"NtVdmContol", L"VdmQueryDir", L"", L"")) {
       VDMQUERYDIRINFO vqdi;
       UNICODE_STRING name;

       memset (&vqdi, 0, sizeof (vqdi));
       RtlInitUnicodeString (&name, L"*");
       for (i = bufl; i >= 0; i--) {
          ret = 0;
          do {
             progress_counter++;
             vqdi.FileHandle = handle;
             vqdi.FileInformation = buf;
             vqdi.Length = bufl;
             vqdi.FileName = &name;
             
             status = NtVdmControl(VdmQueryDir, &vqdi);
             if (!NT_SUCCESS (status)) {
                if (flags&FLAGS_DO_ERRORS)
                   printf ("NtVdmControl failed for type VdmQueryDir %x\n", status);
             }
          } while (print_diags (0, ret++) && ret < MAX_RET);
       }
    }

    if (!sync) {
       if (!crashes (path, L"NtNotifyChangeDirectoryFile", L"", L"", L"")) {
          for (i = bufl; i >= 0; i--) {
             ret = 0;
             do {
                progress_counter++;
                status = NtNotifyChangeDirectoryFile (handle,
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      &iosb,
                                                      buf,
                                                      i,
                                                      FILE_NOTIFY_CHANGE_FILE_NAME,
                                                      FALSE);
                if (NT_SUCCESS (status))
                   status = iosb.Status;
                if (!NT_SUCCESS (status)) {
                   if (flags&FLAGS_DO_ERRORS)
                      printf ("NtNotifyChangeDirectoryFile failed %x\n", status);
                }
                NtCancelIoFile (handle, &iosb);
             } while (print_diags (0, ret++) && ret < MAX_RET);
          }
       }
    }

    /*
       Query the EA info
    */
    do_query_ea (handle, path);

    if (!crashes (path, L"NtCreateSection", L"", L"", L"")) {
       ret = 0;
       do {
          status = NtCreateSection (&sectionhandle, GENERIC_READ,
                                    NULL, NULL, PAGE_READONLY, SEC_COMMIT, handle);
          if (NT_SUCCESS (status)) {
             printf ("Created a section!\n");
             status = NtClose (sectionhandle);
             if (!NT_SUCCESS (status)) {
                printf ("NtClose on section handle failed %x\n", status);
             }
          } else if (flags&FLAGS_DO_ERRORS){
             printf ("NtCreateSection failed %x\n", status);
          }
       } while (print_diags (0, ret++) && ret < MAX_RET);
       ret = 0;
       do {
          status = NtCreateSection (&sectionhandle, GENERIC_READ,
                                    NULL, NULL, PAGE_READONLY, SEC_IMAGE, handle);
          if (NT_SUCCESS (status)) {
             printf ("Created a section!\n");
             status = NtClose (sectionhandle);
             if (!NT_SUCCESS (status)) {
                printf ("NtClose on section handle failed %x\n", status);
             }
          } else if (flags&FLAGS_DO_ERRORS){
             printf ("NtCreateSection failed for image %x\n", status);
          }
       } while (print_diags (0, ret++) && ret < MAX_RET);
    }

    if (!crashes (path, L"NtLockFile", L"", L"", L"")) {
       ret = 0;
       do {
          progress_counter++;
          bl.QuadPart = 1;
          bo.QuadPart = 1;
          status = NtLockFile (handle, NULL, NULL, NULL, &iosb, &bo, &bl, 0, TRUE, FALSE);
          if (NT_SUCCESS (status) && status != STATUS_PENDING) {
             NtUnlockFile (handle, &iosb, &bo, &bl, 0);
          }
          if (!NT_SUCCESS (status)) {
             if (flags&FLAGS_DO_ERRORS)
                printf ("NtLockFile failed %x\n", status);
          }
          NtCancelIoFile (handle, &iosb);
       } while (print_diags (0, ret++) && ret < MAX_RET);
    }
    if (!crashes (path, L"NtUnlockFile", L"", L"", L"")) {
       ret = 0;
       do {
          progress_counter++;
          status = NtUnlockFile (handle, &iosb, &bo, &bl, 0);
          if (NT_SUCCESS (status))
             status = iosb.Status;
          if (!NT_SUCCESS (status)) {
             if (flags&FLAGS_DO_ERRORS)
                printf ("NtUnlockFile failed %x\n", status);
          }
       } while (print_diags (0, ret++) && ret < MAX_RET);
    }
    if (!crashes (path, L"NtQueryQuotaInformationFile", L"", L"", L"")) {
       for (i = bufl; i >= 0; i--) {
          ret = 0;
          do {
             progress_counter++;
             status = NtQueryQuotaInformationFile(handle, &iosb, buf, i, FALSE, NULL, 0,
                                                  NULL, TRUE);
              if (NT_SUCCESS (status))
                 status = iosb.Status;
             if (!NT_SUCCESS (status)) {
                if (flags&FLAGS_DO_ERRORS)
                   printf ("NtQueryQuotaInformationFile failed %x\n", status);
             }
          } while (print_diags (0, ret++) && ret < MAX_RET);
       }
    }
    if (flags&FLAGS_DO_WINSOCK) {
       if (!crashes (path, L"TransmitFile", L"", L"", L"")) {
         progress_counter++;
         if (!TransmitFile (cs, handle, 10, 0, NULL, NULL, TF_WRITE_BEHIND)) {
            if (flags&FLAGS_DO_ERRORS)
               printf ("TransmitFile failed %d\n", WSAGetLastError ());
         }
       }
    }
    NtCancelIoFile (devmap->handle, &iosb);
    free (buf);
    return status;
}

/*
   Get the access mask for this handle
*/
NTSTATUS
get_handle_access (HANDLE handle, PACCESS_MASK access)
{
   NTSTATUS status;
   OBJECT_BASIC_INFORMATION obi;
   //
   // Find out our handle access so we can know what IOCTLs and FSCTLs we can do.
   //
   status = NtQueryObject (handle,
                           ObjectBasicInformation,
                           &obi,
                           sizeof (obi),
                           NULL);
   if (NT_SUCCESS (status)) {
      *access = obi.GrantedAccess;
   } else {
      printf ("NtQueryObject for handle access failed %x\n", status);
      *access = 0;
   }
   return status;
}

NTSTATUS check_tdi_handle (HANDLE handle)
{
   NTSTATUS status;
   IO_STATUS_BLOCK iosb;
   TDI_REQUEST_QUERY_INFORMATION trqi;
   TDI_PROVIDER_INFO tpi;

   trqi.QueryType = TDI_QUERY_PROVIDER_INFORMATION;
   status = NtDeviceIoControlFile (handle, sync_event, NULL, NULL,
                                   &iosb,
                                   IOCTL_TDI_QUERY_INFORMATION,
                                   &trqi,
                                   sizeof (trqi),
                                   &tpi,
                                   sizeof (tpi));
   if (status == STATUS_PENDING) {
      status = NtWaitForSingleObject (sync_event, FALSE, NULL);
      if (!NT_SUCCESS (status)) {
         printf ("NtWaitForSingleObject failed %x\n", status);
      } else {
         status = iosb.Status;
      }
   }
   if (!NT_SUCCESS (status)) {
      printf ("NtDeviceIoControlFile failed for IOCTL_TDI_QUERY_INFORMATION %x\n", status);
      return status;
   }
   printf ("Detected a TDI driver\n");
   return status;
}
//
// Do a load of opens etc relative from the current handle
//
NTSTATUS
do_sub_open_etc(
    HANDLE handle,
    PWCHAR s,
    PWCHAR path
)
{
    OBJECT_ATTRIBUTES       oa;
    UNICODE_STRING name;
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    ACCESS_MASK access;
    LARGE_INTEGER tmo;
    PWCHAR as;

    if (wcslen (s) > 30) {
       as = L"Big...";
    } else {
       as = s;
    }

    if (crashes (path, L"Sub open", as, L"", L""))
       return STATUS_SUCCESS;

    wprintf (L"Doing sub open for %s\n", as);
    RtlInitUnicodeString (&name, s);
    InitializeObjectAttributes(&oa,
                               &name,
                               OBJ_CASE_INSENSITIVE,
                               handle,
                               NULL);
    status = NtCreateFile(&handle,
                          MAXIMUM_ALLOWED,
                          &oa,
                          &iosb,
                          NULL,
                          0,
                          0,
                          FILE_OPEN,
                          0,
                          NULL,
                          0);
    if (NT_SUCCESS (status))
       status = iosb.Status;
    if (NT_SUCCESS (status)) {
       status = get_handle_access (handle, &access);
       wprintf (L"Sub open for %s worked with access %x\n", as, access);
       if (DELETE&access) {
          printf ("Got delete access to device\n");
          if (diag_file) {
             fwprintf (diag_file, L"Got DELETE access to %s\r\n", path);
          }
       }
       if (WRITE_DAC&access) {
          printf ("Got write_dac access to device\n");
          if (diag_file) {
             fwprintf (diag_file, L"Got WRITE_DAC access to %s\r\n", path);
          }
       }
       if (WRITE_OWNER&access) {
          printf ("Got write_owner access to device\n");
          if (diag_file) {
             fwprintf (diag_file, L"Got WRITE_OWNER access to %s\r\n", path);
          }
       }
       if (FILE_WRITE_ACCESS&access) {
          printf ("Got write access to device\n");
          if (diag_file) {
             fwprintf (diag_file, L"Got FILE_WRITE_ACCESS access to %s\r\n", path);
          }
       }
       if (FILE_READ_ACCESS&access) {
          printf ("Got read access to device\n");
          if (diag_file) {
             fwprintf (diag_file, L"Got FILE_READ_ACCESS access to %s\r\n", path);
          }
       }
       query_object(handle, NULL, path);
       misc_functions (handle, path, 0);
       status = NtClose (handle);
       if (!NT_SUCCESS (status)) {
          printf ("NtClose failed %x\n", status);
       }
    } else {
       printf ("NtCreateFile failed %x\n", status);
    }
    if (crashes (path, L"Sub create pipe", as, L"", L""))
       return STATUS_SUCCESS;

    tmo.QuadPart = 1000;
    status = NtCreateNamedPipeFile (&handle,
                                    MAXIMUM_ALLOWED,
                                    &oa,
                                    &iosb,
                                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                                    FILE_CREATE,
                                    0,
                                    FILE_PIPE_MESSAGE_TYPE,
                                    FILE_PIPE_MESSAGE_MODE,
                                    FILE_PIPE_COMPLETE_OPERATION,
                                    10,
                                    1000, 1000,
                                    &tmo);
    if (NT_SUCCESS (status))
       status = iosb.Status;
    if (NT_SUCCESS (status)) {
       status = get_handle_access (handle, &access);
       wprintf (L"Sub create pipe for %s worked with access %x\n", as, access);
       if (DELETE&access) {
          printf ("Got delete access to device\n");
       }
       if (WRITE_DAC&access) {
          printf ("Got write_dac access to device\n");
       }
       if (WRITE_OWNER&access) {
          printf ("Got write_owner access to device\n");
       }
       query_object(handle, NULL, path);
       misc_functions (handle, path, 0);
       status = NtClose (handle);
       if (!NT_SUCCESS (status)) {
          printf ("NtClose failed %x\n", status);
       }
    } else {
       printf ("NtCreateNamedPipeFile failed %x\n", status);
    }
    if (crashes (path, L"Sub create mailslot", as, L"", L""))
       return STATUS_SUCCESS;

    tmo.QuadPart = 1000;
    status = NtCreateMailslotFile (&handle,
                                   MAXIMUM_ALLOWED,
                                   &oa,
                                   &iosb,
                                   0,
                                   1024,
                                   256,
                                   &tmo);
    if (NT_SUCCESS (status)) {
       status = get_handle_access (handle, &access);
       wprintf (L"Sub create mailslot for %s worked with access %x\n", as, access);
       if (DELETE&access) {
          printf ("Got delete access to device\n");
       }
       if (WRITE_DAC&access) {
          printf ("Got write_dac access to device\n");
       }
       if (WRITE_OWNER&access) {
          printf ("Got write_owner access to device\n");
       }
       query_object(handle, NULL, path);
       misc_functions (handle, path, 0);
       status = NtClose (handle);
       if (!NT_SUCCESS (status)) {
          printf ("NtClose failed %x\n", status);
       }
    } else {
       printf ("NtCreateMailslotFile failed %x\n", status);
    }

    try_fast_query_delete_etc (&oa, path, L"Sub open");
    return status;
}
//
// Try a few opens relative to the device its self.
//
NTSTATUS
try_funny_opens(
    HANDLE handle,
    PWCHAR path
)
{
    ULONG ret, i;
    static PWCHAR big=NULL;
    static ULONG bigl;

    if (!(flags&FLAGS_DO_SUBOPENS))
       return 0;

    if (big == NULL) {
       big = malloc (bigl = 0x10000);
       if (big == NULL) {
          printf ("Memory allocation failure in try_funny_opens!\n");
          exit (EXIT_FAILURE);
       }
       bigl /= sizeof (big[0]);
       for (i = 0; i < bigl; i++)
          big[i] = 'A';
       big[bigl - 3] = '\0';
    }
    ret = 0;
    do {
       do_sub_open_etc (handle, L"", path);
       do_sub_open_etc (handle, L" ", path);
       do_sub_open_etc (handle, L"\\", path);
       do_sub_open_etc (handle, L"\\\\\\\\\\\\", path);
       do_sub_open_etc (handle, big, path);
       if (flags&FLAGS_DO_STREAMS) {
          do_sub_open_etc (handle, L":", path);
          do_sub_open_etc (handle, L" :", path);
          do_sub_open_etc (handle, L": ", path);
          do_sub_open_etc (handle, L": ", path);
          do_sub_open_etc (handle, L"::", path);
          do_sub_open_etc (handle, L": :", path);
          do_sub_open_etc (handle, L"::$UNUSED", path);
          do_sub_open_etc (handle, L"::$STANDARD_INFORMATION", path);
          do_sub_open_etc (handle, L"::$ATTRIBUTE_LIST", path);
          do_sub_open_etc (handle, L"::$FILE_NAME", path);
          do_sub_open_etc (handle, L"::$OBJECT_ID", path);
          do_sub_open_etc (handle, L"::$SECURITY_DESCRIPTOR", path);
          do_sub_open_etc (handle, L"::$VOLUME_NAME", path);
          do_sub_open_etc (handle, L"::$VOLUME_INFORMATION", path);
          do_sub_open_etc (handle, L"::$DATA", path);
          do_sub_open_etc (handle, L"::$INDEX_ROOT", path);
          do_sub_open_etc (handle, L"::$INDEX_ALLOCATION", path);
          do_sub_open_etc (handle, L"::$BITMAP", path);
          do_sub_open_etc (handle, L"::$REPARSE_POINT", path);
          do_sub_open_etc (handle, L"::$EA_INFORMATION", path);
          do_sub_open_etc (handle, L"::$PROPERTY_SET", path);
          do_sub_open_etc (handle, L"::$FIRST_USER_DEFINED_ATTRIBUTE", path);
          do_sub_open_etc (handle, L"::$END", path);
       }
    } while (print_diags (0, ret++) && ret < MAX_RET);
    return 0;
}

VOID
randomize_buf(
    PVOID buf,
    ULONG bufl
)
{
   ULONG i;
   PUCHAR pc = buf;

   for (i = 0; i < bufl; i++) {
      pc[i] = rand() & 0xff;
   }
}

/*
   Thread used to randomize buffers
*/
DWORD WINAPI
randomize(
    PVOID buf
)
{
   ULONG i;
   PUCHAR pc = buf;

   while (1) {
      try {
          for (i = 0; i < BIGBUF_SIZE; i++) {
              pc[i] = rand() & 0xff;
          }
      } except (EXCEPTION_EXECUTE_HANDLER) {
      }
      Sleep (0);
   }
   return 0;
}


// changeprot and alerter won't return and we do not need to be 
// told this by the compiler
#pragma warning(disable:4715)

DWORD WINAPI
changeprot(
    PVOID buf
)
{
   DWORD old;

   while (1) {
      if (!VirtualProtect (buf, 1, PAGE_READONLY, &old)) {
         printf ("VirtualProtect failed %d\n", GetLastError ());
      }
      Sleep (1);
      if (!VirtualProtect (buf, 1, PAGE_NOACCESS, &old)) {
         printf ("VirtualProtect failed %d\n", GetLastError ());
      }
      Sleep (1);
      if (!VirtualProtect (buf, 1, PAGE_GUARD|PAGE_READONLY, &old)) {
         printf ("VirtualProtect failed %d\n", GetLastError ());
      }
      Sleep (1);
   } 
   return 0;
}
 

/*
   Thread used to alert the main
*/
DWORD WINAPI
alerter(
    PVOID handle
)
{
   NTSTATUS status;
   ULONG last = progress_counter, count;

   //
   // Do a nasty hack to keep the main thread moving if it gets stuck in a sync IOCTL
   //
   while (1) {
      if (flags&FLAGS_DO_ALERT) {
         Sleep (0);
      } else {
         last = progress_counter;
         Sleep (60000);
         if (progress_counter == 0 || progress_counter != last) {
            continue;
         }
         printf ("Alerting thread\n");
      }
//      status = NtAlertResumeThread ((HANDLE) handle, &count);
//      if (!NT_SUCCESS (status)) {
//          printf ("NtAlertResumeThread failed %x\n", status);
//      }
      status = NtAlertThread ((HANDLE) handle);
      if (!NT_SUCCESS (status)) {
          printf ("NtAlertThread failed %x\n", status);
      }
      alerted++;
      if (alerted > 10) {
          if (diag_file) {
              fwprintf (diag_file, L"Main thread appears hung. Teminating process\r\n");
              fflush (diag_file);
              NtTerminateProcess (NtCurrentProcess (), 0);
          }
      }
   }
   return 0;
}

#pragma warning(3:4715)

void record_ioctl (PIOCTLREC *piorec, ULONG ioctl, NTSTATUS status)
{
   PIOCTLREC iorec = *piorec;
   IOCTLINFO tmp;
   ULONG i, j, new;

   if (!iorec) {
      iorec = malloc (sizeof (*iorec) +
                      INITIAL_IOCTL_TAILOR_SIZE * sizeof (iorec->ioctl[0]));
      if (!iorec) {
         return;
      }
      *piorec = iorec;
      iorec->total = INITIAL_IOCTL_TAILOR_SIZE;
      iorec->count = 0;
      iorec->start = 0;
   }
   new = 1;
   for (i = 0; i < iorec->count; i++) {
      if (iorec->ioctl[i].ioctl == ioctl && iorec->ioctl[i].status == status) {
         return;
      }
      if (iorec->ioctl[i].status == status) {
         new = 0;
         if (iorec->ioctl[i].count > MAX_IOCTL_TAILOR) {
            return; // too many seen of this one
         }
         if (++iorec->ioctl[i].count > MAX_IOCTL_TAILOR) {
            printf ("Removing IOCTLs with status %X\n", status);
            for (j = i + 1; j < iorec->count; j++) {
               if (iorec->ioctl[j].status == status) {
/*
                  printf ("Removing IOCTL %X with status %X\n",
                          iorec->ioctl[j].ioctl, iorec->ioctl[j].status);
*/
                  iorec->ioctl[j] = iorec->ioctl[--iorec->count];
                  j--;
               }
            }
            tmp = iorec->ioctl[iorec->start];
            iorec->ioctl[iorec->start++] = iorec->ioctl[i];
            iorec->ioctl[i] = tmp;
            return;
         }
         break;
      }
   }
   if (new) {
      printf ("New status for IOCTL %X status %X\n", ioctl, status);
   }
   if (iorec->total == iorec->count) {
      iorec = realloc (iorec, sizeof (*iorec) +
                       iorec->total * 2 * sizeof (iorec->ioctl[0]));
      if (!iorec) {
         return;
      }
      *piorec = iorec;
      iorec->total *= 2;
   }
   i = iorec->count;
   iorec->ioctl[i].status = status;
   iorec->ioctl[i].ioctl = ioctl;
   iorec->ioctl[i].count = 0;
   iorec->count = i + 1;
}

void do_tailored_ioctl (PDEVMAP                 devmap,
                        PWCHAR                  path,
                        PIOCTLREC               iorec,
                        ULONG fsctl)
{
   ULONG                   method, ioctl_val;
   PVOID                   inbuf, outbuf;
   ULONG                   inlen, outlen;
   static IO_STATUS_BLOCK  static_iosb;
   ULONG                   ret;
   ULONG                   i, j, k;
   WCHAR                   num[20];
   NTSTATUS                status;
   ULONG                   tmp;
   DWORD                   old;
   ULONG                   done_something;   

   if (!iorec) {
      return;
   }

   do {
      done_something = 0;
      for (i = 1; i < iorec->count; i++) {
         IOCTLINFO ii;
         if (iorec->ioctl[i-1].ioctl < iorec->ioctl[i].ioctl) {
            continue;
         } else if (iorec->ioctl[i-1].ioctl == iorec->ioctl[i].ioctl &&
                    iorec->ioctl[i-1].count <= iorec->ioctl[i].count) {
            continue;
         }
         ii = iorec->ioctl[i-1];
         iorec->ioctl[i-1] = iorec->ioctl[i];
         iorec->ioctl[i] = ii;
         done_something = 1;
      }
   } while (done_something);

   for (i = 0; i < iorec->count; i++) {
      if (iorec->ioctl[i].count >= MAX_IOCTL_TAILOR) {
         continue;
      }
      if (i > 0 && iorec->ioctl[i].ioctl == iorec->ioctl[i-1].ioctl) {
         continue;
      }
      ioctl_val = iorec->ioctl[i].ioctl;
      method = ioctl_val&0x3;
      _snwprintf (num, sizeof (num) / sizeof (WCHAR), L"%%X%X", ioctl_val);
      if (crashes (path, L"IOCTL value", num, L"", L""))
         continue;

      alerted = 0;
      for (j = 0; j < max_tailured_calls; j += RAND_REP) {
         ret = 0;
         do {
            if (ret != 0) {
               printf ("Re-doing random with ioctl %%X%x\n", ioctl_val);
            }

            for (k = 0; k < RAND_REP; k++) {
               switch(method) {
                  case METHOD_BUFFERED :

                     inlen  = RandInRange( ioctl_inbuf_min,  ioctl_inbuf_max );
                     outlen = RandInRange( ioctl_outbuf_min, ioctl_outbuf_max );

                     inbuf = bigbuf;
                     if (outlen == 0)
                        outbuf = (PVOID) -1024;
                     else
                        outbuf = bigbuf;

                     randomize_buf (inbuf, inlen);
                     break;

                  case METHOD_IN_DIRECT :
                  case METHOD_OUT_DIRECT :

                     inlen  = RandInRange( ioctl_inbuf_min,  ioctl_inbuf_max );
                     outlen = RandInRange( ioctl_outbuf_min, ioctl_outbuf_max );

                     inbuf = bigbuf;
                     outbuf = &bigbuf[BIGBUF_SIZE - outlen];
                     randomize_buf (inbuf, inlen);
                     randomize_buf (outbuf, outlen);

                     break;

                  case METHOD_NEITHER :

                      switch (rand ()&3) {
                         //
                         // Completely random pointers. We may corrupt ourselves here
//                         case 0 :
//                            inlen = rand32();
//                            outlen = rand32();
//
//                            inbuf = (PVOID)rand32();
//                            outbuf = (PVOID)rand32();
//                            break;

                         //
                         // Kernel crashing pointers with smallish lengths
                         case 1 :
                            inbuf = (PVOID) -1024;
                            outbuf = (PVOID) -1024;
                            inlen  = RandInRange( ioctl_inbuf_min,  ioctl_inbuf_max );
                            outlen = RandInRange( ioctl_outbuf_min, ioctl_outbuf_max );
                            break;
                         //
                         // Good pointers
                         case 0 :
                         case 2 :
                            inlen  = RandInRange( ioctl_inbuf_min,  ioctl_inbuf_max );
                            outlen = RandInRange( ioctl_outbuf_min, ioctl_outbuf_max );

                            inbuf  = &bigbuf[BIGBUF_SIZE - outlen];
                            outbuf = &bigbuf[BIGBUF_SIZE - outlen];
                            break;
                         //
                         // Bad user mode pointers
                         case 3 :
                            inlen  = rand() & 0xFFFF;
                            outlen = rand() & 0xFFFF;
                            inbuf  = UintToPtr( rand() & 0xFFFF );
                            outbuf = UintToPtr( rand() & 0xFFFF );
                            break;
                         break;
                   }
               }

               progress_counter++;
               if (!fsctl) {
                  status = NtDeviceIoControlFile(devmap->handle,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 &static_iosb,
                                                 ioctl_val,
                                                 inbuf,
                                                 inlen,
                                                 outbuf,
                                                 outlen);
               } else {
                  status = NtFsControlFile(devmap->handle,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &static_iosb,
                                           ioctl_val,
                                           inbuf,
                                           inlen,
                                           outbuf,
                                           outlen);
               }
            }
            NtCancelIoFile (devmap->handle, &static_iosb);
            if (alerted > 5) {
               break;
            }
         } while (print_diags ((method == METHOD_BUFFERED)?0:DIAG_NOEXCEPTIONS, ret++) && ret < MAX_RET);
         if (alerted > 5) {
            break;
         } 

      }
      if (!(flags&FLAGS_DO_PROT) ||
          crashes (path, L"IOCTL prot value", num, L"", L"")) {
         continue;
      }

      status = NtResumeThread (changethread, &tmp);
      if (!NT_SUCCESS (status)) {
         printf ("NtResumeThread failed %x\n", status);
      }

      for (i = 1; i < PROT_REP; i += RAND_REP) {
         ret = 0;
         do {
            if (ret != 0) {
               printf ("Re-doing random with ioctl %%X%x\n", ioctl_val);
            }
            for (k = 0; k < RAND_REP; k++) {
               if (!VirtualProtect (bigbuf, 1, PAGE_READWRITE, &old)) {
                  printf ("VirtualProtect failed %d\n", GetLastError ());
               }
               inlen  = RandInRange( ioctl_inbuf_min,  ioctl_inbuf_max );
               outlen = RandInRange( ioctl_outbuf_min, ioctl_outbuf_max );

               inbuf = bigbuf;
               outbuf = bigbuf;

               progress_counter++;
               if (!fsctl) {
                  status = NtDeviceIoControlFile(devmap->handle,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 &static_iosb,
                                                 ioctl_val,
                                                 inbuf,
                                                 inlen,
                                                 outbuf,
                                                 outlen);
               } else {
                  status = NtFsControlFile(devmap->handle,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &static_iosb,
                                           ioctl_val,
                                           inbuf,
                                           inlen,
                                           outbuf,
                                           outlen);
               }
            }
            NtCancelIoFile (devmap->handle, &static_iosb);
            if (alerted > 5) {
               break;
            }
         } while (print_diags (DIAG_NOEXCEPTIONS, ret++) && ret < MAX_RET);

         if (alerted > 5) {
            break;
         }
      }
      status = NtSuspendThread (changethread, &tmp);
      if (!NT_SUCCESS (status)) {
         printf ("NtResumeThread failed %x\n", status);
      }
      if (!VirtualProtect (bigbuf, 1, PAGE_READWRITE, &old)) {
         printf ("VirtualProtect failed %d\n", GetLastError ());
      }
   }
}

NTSTATUS
do_ioctl(
    PDEVMAP                 devmap,
    PWCHAR                  path
)
{
    ULONG                   function, method, access, i, j, ioctl_val;
    static IO_STATUS_BLOCK  static_iosb;
    PVOID                   inbuf, outbuf;
    ULONG                   inlen, outlen;
    ULONG                   tmp;
    NTSTATUS                status;
    ULONG                   devtype;
    ULONG                   ret;
    BOOL                    hit_leak;
    WCHAR                   num[20];
    PIOCTLREC               iorec = NULL, fsrec = NULL;
    ULONG                   set_rand;

    if ((flags&(FLAGS_DO_IOCTL_NULL|FLAGS_DO_FSCTL_NULL)) &&
        ioctl_inbuf_min == 0 && ioctl_outbuf_min == 0) {
       //
       // do I/O calls with no buffer
       //
       for (function = ioctl_min_function; function <= ioctl_max_function; function++) {
          _snwprintf (num, sizeof (num) / sizeof (WCHAR), L"%d", function);
          if (crashes (path, L"IOCTL function ", num, L"", L""))
             continue;
          for (devtype = ioctl_min_devtype; devtype <= ioctl_max_devtype; devtype++) {
              ret = 0;
              do {
                 if (ret != 0)
                    printf ("Re-doing devtype = %d, function = %d\n", devtype, function);
                 hit_leak = FALSE;
                 for (access = FILE_ANY_ACCESS;
                      access <= (devmap->access&(FILE_READ_ACCESS|FILE_WRITE_ACCESS));
                      access++) {
                     for (method = 0; method < 4; method++) {
                         ioctl_val = CTL_CODE(devtype, function, method, access);

                         progress_counter++;
                         if ((flags&FLAGS_DO_IOCTL_NULL)) {
                            status = NtDeviceIoControlFile(devmap->handle,
                                                           NULL, NULL, NULL,
                                                           &static_iosb,
                                                           ioctl_val,
                                                           (PVOID) -1024,
                                                           0,
                                                           (PVOID) -1024,
                                                           0);
                            record_ioctl (&iorec, ioctl_val, status);
                         }
                         if ((flags&FLAGS_DO_FSCTL_NULL)) {
                            status = NtFsControlFile(devmap->handle, NULL, NULL, NULL,
                                                     &static_iosb,
                                                     ioctl_val,
                                                     (PVOID) -1024,
                                                     0,
                                                     (PVOID) -1024,
                                                     0);
                            record_ioctl (&fsrec, ioctl_val, status);
                        }
                        Sleep (0);
                     }
                 }
                 if (ret > (MAX_RET * 95 ) / 100) {
                    NtCancelIoFile (devmap->handle, &static_iosb);
                    //
                    // Report exceptions for method buffered.
                    // This may be ok but its worth knowing.
                    //
                    if (print_diags ((method == METHOD_BUFFERED)?0:DIAG_NOEXCEPTIONS, ret++)) {
                       printf ("IOCTL/FSCTL %x devtype %x (%d) function %x (%d) access %x method %x\n",
                               ioctl_val, devtype, devtype, function, function,
                               access, method);
                       hit_leak = TRUE;
                    }
                 }
                 NtCancelIoFile (devmap->handle, &static_iosb);
             } while ((hit_leak || print_diags ((method == METHOD_BUFFERED)?0:DIAG_NOEXCEPTIONS, ret++)) && ret < MAX_RET);
          }
       }
    }


    if (flags&(FLAGS_DO_IOCTL_RANDOM|FLAGS_DO_FSCTL_RANDOM) &&
        !crashes (path, L"IOCTL", L"random", L"", L"")) {
//       if (!(flags&FLAGS_DO_RANDOM_DEVICE)) {
//          status = NtResumeThread (randthread, &tmp);
//          if (!NT_SUCCESS (status)) {
//             printf ("NtResumeThread failed %x\n", status);
//          }
//       }
       for (i = 0; i < max_random_calls; i += RAND_REP) {
           if (ioctl_min_function >= ioctl_max_function)
              function = ioctl_min_function;
           else
              function = RandInRange( ioctl_min_function, ioctl_max_function );
           ret = 0;
           do {
              if (ret != 0) {
                 printf ("Re-doing random with function %x\n", function);
              }
              for (j = 0; j < RAND_REP; j++) {
                 if (ioctl_min_devtype >= ioctl_max_devtype)
                    devtype = ioctl_min_devtype;
                 else
                    devtype = RandInRange( ioctl_min_devtype, ioctl_max_devtype );

                 switch (rand ()&3) {
                    case 0 :
                       if (fsrec && fsrec->count - fsrec->start) {
                          devtype = fsrec->ioctl[fsrec->start + 
                             (rand()%(fsrec->count - fsrec->start))].ioctl>>16;
                       }
                    break;
                    case 1 :
                       if (iorec && iorec->count - iorec->start) {
                          devtype = iorec->ioctl[iorec->start + 
                             (rand()%(iorec->count - iorec->start))].ioctl>>16;
                       }
                    break;
                    case 2 :
                    case 3 :
                    break;
                 }
                 method = rand() & 0x3;

                 access = rand() & devmap->access&(FILE_READ_ACCESS|FILE_WRITE_ACCESS);

                 ioctl_val = CTL_CODE(devtype,
                                      function,
                                      method,
                                      access);

                 set_rand = 0;
                 switch(method) {
                     case METHOD_BUFFERED :

                         inlen  = RandInRange( ioctl_inbuf_min,  ioctl_inbuf_max );
                         outlen = RandInRange( ioctl_outbuf_min, ioctl_outbuf_max );

                         inbuf = bigbuf;
                         if (outlen == 0)
                            outbuf = (PVOID) -1024;
                         else
                            outbuf = bigbuf;

                         set_rand = 1;
                         break;

                     case METHOD_IN_DIRECT :
                     case METHOD_OUT_DIRECT :

                         inlen  = RandInRange( ioctl_inbuf_min,  ioctl_inbuf_max );
                         outlen = RandInRange( ioctl_outbuf_min, ioctl_outbuf_max );

                         inbuf = bigbuf;
                         outbuf = &bigbuf[BIGBUF_SIZE - outlen];
//                         printf ("%p %d %p %d\n", inbuf, inlen, outbuf, outlen);

                         set_rand = 1;
                         break;

                     case METHOD_NEITHER :

                         switch (rand ()&3) {
                            //
                            // Completely random pointers. We may corrupt ourselves here
//                            case 0 :
//                               inlen = rand32();
//                               outlen = rand32();
//
//                               inbuf = (PVOID)rand32();
//                               outbuf = (PVOID)rand32();
//                               break;

                            //
                            // Kernel crashing pointers with smallish lengths
                            case 1 :
                               inbuf = (PVOID) -1024;
                               outbuf = (PVOID) -1024;
                               inlen  = RandInRange( ioctl_inbuf_min,  ioctl_inbuf_max );
                               outlen = RandInRange( ioctl_outbuf_min, ioctl_outbuf_max );
                               break;
                            //
                            // Good pointers
                            case 0 :
                            case 2 :
                               inlen  = RandInRange( ioctl_inbuf_min,  ioctl_inbuf_max );
                               outlen = RandInRange( ioctl_outbuf_min, ioctl_outbuf_max );

                               inbuf = &bigbuf[BIGBUF_SIZE - outlen];
                               outbuf = &bigbuf[BIGBUF_SIZE - outlen];
                               set_rand = 1;
                               break;
                            //
                            // Bad user mode pointers
                            case 3 :
                               inlen = rand() & 0xFFFF;
                               outlen = rand() & 0xFFFF;
                               inbuf =   UintToPtr( rand() & 0xFFFF);
                               outbuf =  UintToPtr( rand() & 0xFFFF);
                               break;
                            break;
                     }
                 }

                 if (set_rand) {
                    randomize_buf (inbuf, inlen);
                 }
                 progress_counter++;
                 if (flags&FLAGS_DO_IOCTL_RANDOM) {
                    status = NtDeviceIoControlFile(devmap->handle,
                                                   NULL,
                                                   NULL,
                                                   NULL,
                                                   &static_iosb,
                                                   ioctl_val,
                                                   inbuf,
                                                   inlen,
                                                   outbuf,
                                                   outlen);
                    record_ioctl (&iorec, ioctl_val, status);
                 }

                 if (flags&FLAGS_DO_FSCTL_RANDOM) {
                    status = NtFsControlFile(devmap->handle,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &static_iosb,
                                             ioctl_val,
                                             inbuf,
                                             inlen,
                                             outbuf,
                                             outlen);
                    record_ioctl (&fsrec, ioctl_val, status);
                }
             }

             NtCancelIoFile (devmap->handle, &static_iosb);
          } while (print_diags ((method == METHOD_BUFFERED)?0:DIAG_NOEXCEPTIONS, ret++) && ret < MAX_RET);
       }

//       if (!(flags&FLAGS_DO_RANDOM_DEVICE)) {
//          status = NtSuspendThread (randthread, &tmp);
//          if (!NT_SUCCESS (status)) {
//             printf ("NtSuspendThread failed %x\n", status);
//          }
//       }
    }
    if (flags&FLAGS_DO_IOCTL_RANDOM) {
       do_tailored_ioctl (devmap, path, iorec, 0);
    }
    if (flags&FLAGS_DO_FSCTL_RANDOM) {
       do_tailored_ioctl (devmap, path, fsrec, 1);
    }

    if (iorec) {
       free (iorec);
    }
    if (fsrec) {
       free (fsrec);
    }
    return 0;
}

PFILE_FULL_EA_INFORMATION build_adr_ea (PCHAR name, USHORT adrtype,
                                        USHORT adrl, PVOID padr,
                                        PULONG peal)
{
   PFILE_FULL_EA_INFORMATION ea = NULL;
   TRANSPORT_ADDRESS UNALIGNED *pta;
   TA_ADDRESS *ptaa;
   ULONG eal;
   ULONG nl;

   nl = strlen (name);
   eal = sizeof (FILE_FULL_EA_INFORMATION) + nl +
         sizeof (TRANSPORT_ADDRESS) - 1 + adrl;
   ea = malloc (eal);
   if (!ea) {
      printf ("Failed to allocate %d bytes\n", eal);
      exit (EXIT_FAILURE);
   }
   memset (ea, 0, eal);
   ea->EaNameLength = (UCHAR) nl;
   strcpy (ea->EaName, name);
   ea->EaValueLength = (USHORT)(eal - sizeof (*ea) - nl);
   pta = (TRANSPORT_ADDRESS UNALIGNED *)(ea->EaName + nl + 1);
   pta->TAAddressCount = 1;
   ptaa = (TA_ADDRESS *) pta->Address;
   ptaa->AddressLength = adrl;
   ptaa->AddressType = adrtype;
   memcpy (ptaa->Address, padr, adrl);
   *peal = eal;
   return ea;
}

PFILE_FULL_EA_INFORMATION build_con_ea (PCHAR name, CONNECTION_CONTEXT ctx,
                                        PULONG peal)
{
   PFILE_FULL_EA_INFORMATION ea = NULL;
   CONNECTION_CONTEXT UNALIGNED *pctx;
   ULONG eal;
   ULONG nl;

   nl = strlen (name);
   eal = sizeof (FILE_FULL_EA_INFORMATION) + nl +
         sizeof (ctx);
   ea = malloc (eal);
   if (!ea) {
      printf ("Failed to allocate %d bytes\n", eal);
      exit (EXIT_FAILURE);
   }
   memset (ea, 0, eal);
   ea->EaNameLength = (UCHAR) nl;
   strcpy (ea->EaName, name);
   ea->EaValueLength = (USHORT)(eal - sizeof (*ea) - nl);
   pctx = (CONNECTION_CONTEXT UNALIGNED*) (ea->EaName + nl + 1);
   *pctx = ctx;
   *peal = eal;
   return ea;
}

#define DRIVER_PREFIX1 L"\\Driver\\"
#define DRIVER_PREFIX2 L"\\FileSystem\\"

NTSTATUS
check_driver (HANDLE handle, 
              PUNICODE_STRING DriverName)
/*
   Check to see if the specified device object is associated with the driver object
*/
{
    PFILE_FS_DRIVER_PATH_INFORMATION fsDpInfo;
    ULONG   fsDpSize;
    ULONG   DriverBufferLength;
    UNICODE_STRING us;
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;

    DriverBufferLength = sizeof (DRIVER_PREFIX1);
    if (sizeof (DRIVER_PREFIX2) >  DriverBufferLength) {
        DriverBufferLength = sizeof (DRIVER_PREFIX2);
    }
    DriverBufferLength += DriverName->Length;

    fsDpSize = sizeof(FILE_FS_DRIVER_PATH_INFORMATION) + DriverBufferLength;

    fsDpInfo = malloc (fsDpSize);
    if (fsDpInfo == 0) {
        printf ("Failed to allocate buffer for driver query\n");
        exit (EXIT_FAILURE);
    }

    ZeroMemory(fsDpInfo, fsDpSize);

    us.MaximumLength = (USHORT)DriverBufferLength;
    us.Length = 0;
    us.Buffer = fsDpInfo->DriverName;
    RtlAppendUnicodeToString (&us, DRIVER_PREFIX1);
    RtlAppendUnicodeStringToString (&us, DriverName);
    fsDpInfo->DriverNameLength = us.Length;


    status = NtQueryVolumeInformationFile(handle,
                                          &iosb,
                                          fsDpInfo,
                                          fsDpSize,
                                          FileFsDriverPathInformation);

    if (NT_SUCCESS (status)) {
        if (fsDpInfo->DriverInPath) {
            status = STATUS_SUCCESS;
        } else {
            status = -1;
        }
        free (fsDpInfo);
        return status;
    }

    us.MaximumLength = (USHORT)DriverBufferLength;
    us.Length = 0;
    us.Buffer = fsDpInfo->DriverName;
    RtlAppendUnicodeToString (&us, DRIVER_PREFIX2);
    RtlAppendUnicodeStringToString (&us, DriverName);
    fsDpInfo->DriverNameLength = us.Length;
    status = NtQueryVolumeInformationFile(handle,
                                          &iosb,
                                          fsDpInfo,
                                          fsDpSize,
                                          FileFsDriverPathInformation);

    if (!NT_SUCCESS (status)) {
        printf ("NtQueryVolumeInformationFile for FileFsDriverPathInformation failed %x\n", status);
        exit (EXIT_FAILURE);
    }
    if (fsDpInfo->DriverInPath) {
        status = STATUS_SUCCESS;
    } else {
        status = -1;
    }
    free (fsDpInfo);
    return status;
}

DWORD
WINAPI
do_open_close_thread (
    LPVOID arg)
{
    ULONG i;
    POBJECT_ATTRIBUTES oa = arg;
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    HANDLE handle;

    for (i = 0; i < 10000; i++) {
        status = NtCreateFile (&handle,
                               MAXIMUM_ALLOWED,
                               oa,
                               &iosb,
                               NULL,
                               0,
                               FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                               FILE_OPEN,
                               0,
                               NULL,
                               0);
        if (NT_SUCCESS (status)) {
            status = NtClose (handle);
            if (!NT_SUCCESS (status)) {
                printf ("NtClose failed %x\n", status);
                exit (EXIT_FAILURE);
            }
        }
    }
    return 0;
}

VOID
do_open_close (POBJECT_ATTRIBUTES oa,
               PUNICODE_STRING    name,
               PWCHAR             path)
/*
    Open and close the device rapidly to catch open close races
*/
{
#define MAX_OPEN_THREAD 4
    HANDLE Thread[MAX_OPEN_THREAD];
    ULONG i;
    DWORD id;

    if (crashes (path, L"OPENCLOSE", L"", L"", L"")) {
        return;
    }

    for (i = 0; i < MAX_OPEN_THREAD; i++) {
        Thread[i] = CreateThread (NULL, 0, do_open_close_thread, oa, 0, &id);
        if (Thread[i] == NULL) {
            printf ("CreateThread failed %d\n", GetLastError ());
            exit (EXIT_FAILURE);
        }
    }
    for (i = 0; i < MAX_OPEN_THREAD; i++) {
        WaitForSingleObject (Thread[i], INFINITE);
        CloseHandle (Thread[i]);
    }
}


/*
   Open device with various options
*/
NTSTATUS
open_device(
    HANDLE                  parent,
    PUNICODE_STRING         name,
    PDEVMAP                 devmap,
    BOOL                    synch,        // Do a synchronous open
    BOOL                    addbackslash, // Add trailing backslash to name
    BOOL                    direct,       // Do a direct open
    ULONG                   opentype,      // Connection, address etc.
    PWCHAR                  path
)
{
    NTSTATUS                  status;
    IO_STATUS_BLOCK           iosb;
    ULONG                     i, l, lw, first;
    WCHAR                     dn[1024];
    UNICODE_STRING            dnu;
    ULONG                     options;
    OBJECT_ATTRIBUTES         oa;
    ACCESS_MASK               am;
    ULONG                     share;
    PFILE_FULL_EA_INFORMATION pea = NULL;
    ULONG                     eal = 0;
    TDI_ADDRESS_IP            ipaddr;
    TDI_ADDRESS_NETBIOS       netbiosaddr;
    TDI_ADDRESS_IPX           ipxaddr;
    TDI_ADDRESS_APPLETALK     appleaddr;
    LARGE_INTEGER tmo;
    PCHAR api;

    if (direct && !(FLAGS_DO_DIRECT_DEVICE&flags)) {
       return STATUS_ACCESS_DENIED;
    }
    l = name->Length;
    if (l >= sizeof (dn))
       l = sizeof (dn) - 1;
    lw = l / sizeof (dn[0]);
    wcsncpy (dn, name->Buffer, lw);
    dn[lw] = '\0';
    RtlInitUnicodeString (&dnu, dn);
    if (addbackslash && dnu.Length < sizeof (dn)) {
       dn[min (dnu.Length, sizeof (dn) - sizeof (dn[0]))/sizeof(dn[0])] = '\\';
       dnu.Length += 2;
    }
    dn[min(dnu.Length, sizeof (dn) - sizeof (dn[0]))/sizeof(dn[0])] = 0;
    
    InitializeObjectAttributes(&oa,
                               &dnu,
                               OBJ_CASE_INSENSITIVE,
                               parent,
                               NULL);

    if ((flags2&FLAGS_DO_DRIVER) != 0) {
        HANDLE handle;
        status = NtCreateFile (&handle,
                               MAXIMUM_ALLOWED,
                               &oa,
                               &iosb,
                               NULL,
                               0,
                               FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                               FILE_OPEN,
                               0,
                               NULL,
                               0);
        if (NT_SUCCESS (status)) {
            status = check_driver (handle, &DriverName);
            NtClose (handle);
            if (!NT_SUCCESS (status)) {
                return status;
            }
        } else {
            wprintf(L"Failed to open device %s for driver checking %x\n",
                    dn, status);
            return -1;
        }
    }

    if ((flags&FLAGS_DO_OPEN_CLOSE) && !synch && !direct && opentype == 0) {
       do_open_close (&oa,
                      name,
                      path);
    }

    devmap->handle = NULL;

    if (direct) {
        options = 0;
        am = SYNCHRONIZE|FILE_READ_ATTRIBUTES|READ_CONTROL|WRITE_OWNER|WRITE_DAC;
    } else if (synch) {
        options = FILE_SYNCHRONOUS_IO_ALERT;
        am = MAXIMUM_ALLOWED|SYNCHRONIZE;
    } else {
        options = 0;
        am = MAXIMUM_ALLOWED;
    }
    if (opentype == OPEN_TYPE_NAMED_PIPE) {
       share = FILE_SHARE_READ|FILE_SHARE_WRITE;
    } else if (opentype == OPEN_TYPE_TREE_CONNECT) {
       share = FILE_SHARE_READ|FILE_SHARE_WRITE;
       options |= FILE_CREATE_TREE_CONNECTION;
    } else {
       share = 0;
    }
    if (opentype == OPEN_TYPE_TDI_CONNECTION) {
       pea = build_con_ea (TdiConnectionContext, (CONNECTION_CONTEXT) 12345, &eal);
    } else if (opentype == OPEN_TYPE_TDI_ADDR_IP) {
      memset (&ipaddr, 0, sizeof (ipaddr));
      pea = build_adr_ea (TdiTransportAddress,
                          TDI_ADDRESS_TYPE_IP,
                          sizeof (ipaddr), &ipaddr,
                          &eal);
    } else if (opentype == OPEN_TYPE_TDI_ADDR_NETBIOS) {
      memset (&netbiosaddr, 0, sizeof (netbiosaddr));
      pea = build_adr_ea (TdiTransportAddress,
                          TDI_ADDRESS_TYPE_NETBIOS,
                          sizeof (netbiosaddr), &netbiosaddr,
                          &eal);
    } else if (opentype == OPEN_TYPE_TDI_ADDR_IPX) {
      memset (&ipxaddr, 0, sizeof (ipxaddr));
      pea = build_adr_ea (TdiTransportAddress,
                          TDI_ADDRESS_TYPE_IPX,
                          sizeof (ipxaddr), &ipxaddr,
                          &eal);
    } else if (opentype == OPEN_TYPE_TDI_ADDR_APPLE) {
      memset (&appleaddr, 0, sizeof (appleaddr));
      pea = build_adr_ea (TdiTransportAddress,
                          TDI_ADDRESS_TYPE_APPLETALK,
                          sizeof (appleaddr), &appleaddr,
                          &eal);
    }

    wprintf(L"Trying to open device %s %s %s %s\n",
            dn, direct?L"direct ":L"", synch?L"synchronous":L"",
            pea?L"TDI open":(opentype == OPEN_TYPE_NAMED_PIPE)?
                            L"NamedPipe":(opentype == OPEN_TYPE_MAIL_SLOT)?
                            L"Mailslot":L"");

    if (crashes (path, L"Open", direct?L"direct":L"", synch?L"synchronous":L"",
                 addbackslash?L"Add backslash":L""))
       status = STATUS_ACCESS_DENIED;
    else {
       do {
          if (opentype == OPEN_TYPE_NAMED_PIPE) {
             tmo.QuadPart = -1000;
             api = "NtCreateNamedPipeFile";
             status = NtCreateNamedPipeFile (&devmap->handle,
                                             am,
                                             &oa,
                                             &iosb,
                                             share,
                                             FILE_CREATE,
                                             options,
                                             FILE_PIPE_MESSAGE_TYPE,
                                             FILE_PIPE_MESSAGE_MODE,
                                             FILE_PIPE_COMPLETE_OPERATION,
                                             10,
                                             1000, 1000,
                                             &tmo);
          } else if (opentype == OPEN_TYPE_MAIL_SLOT) {
             tmo.QuadPart = -1000;
             api = "NtCreateMailslotFile";
             status = NtCreateMailslotFile (&devmap->handle,
                                            am,
                                            &oa,
                                            &iosb,
                                            options,
                                            1024,
                                            256,
                                            &tmo);

          } else {
             api = "NtCreateFile";
             status = NtCreateFile(&devmap->handle,
                                   am,
                                   &oa,
                                   &iosb,
                                   NULL,
                                   0,
                                   share,
                                   FILE_OPEN,
                                   options,
                                   pea,
                                   eal);
          }

          if (status == STATUS_SHARING_VIOLATION) {
             printf ("Hit file share violation for %X\n", share);
             if (share&FILE_SHARE_READ) {
                share &= ~FILE_SHARE_READ;
                if (share&FILE_SHARE_WRITE) {
                   share &= ~FILE_SHARE_WRITE;
                   if (share&FILE_SHARE_DELETE) {
                      break;
                   } else {
                      share |= FILE_SHARE_DELETE;
                   }
                } else {
                   share |= FILE_SHARE_WRITE;
                }
             } else {
                share |= FILE_SHARE_READ;
             }
          } else if (status == STATUS_ACCESS_DENIED) {
             printf ("Hit file protection violation for %X\n", am);
             if (am&MAXIMUM_ALLOWED) {
                am &= ~MAXIMUM_ALLOWED;
                am |= FILE_READ_DATA|FILE_WRITE_DATA|SYNCHRONIZE|FILE_READ_ATTRIBUTES|
                      READ_CONTROL|FILE_APPEND_DATA;
             } else if (am&FILE_WRITE_DATA) {
                am &= ~FILE_WRITE_DATA;
             } else if (am&FILE_APPEND_DATA) {
                am &= ~FILE_APPEND_DATA;
             } else if (am&FILE_READ_DATA) {
                am &= ~FILE_READ_DATA;
             } else if (am&WRITE_OWNER) {
                am &= ~WRITE_OWNER;
             } else if (am&WRITE_DAC) {
                am &= ~WRITE_DAC;
             } else if (am&WRITE_DAC) {
                am &= ~WRITE_DAC;
             } else if (am&READ_CONTROL) {
                am &= ~READ_CONTROL;
             } else if (am&FILE_READ_ATTRIBUTES) {
                am &= ~FILE_READ_ATTRIBUTES;
             } else {
                break;
             }
          }
       } while (status == STATUS_SHARING_VIOLATION || status == STATUS_ACCESS_DENIED);
    }
    if (pea)
       free (pea);
    if (NT_SUCCESS(status)) {
        status = get_handle_access (devmap->handle, &devmap->access);
    }
    if (NT_SUCCESS(status)) {
        wprintf(L"Opened file %s with access %x\n",
                dn,
                devmap->access);

        if (DELETE&devmap->access) {
           printf ("Got delete access to device\n");
        }
        if (WRITE_DAC&devmap->access) {
           printf ("Got write_dac access to device\n");
        }
        if (WRITE_OWNER&devmap->access) {
           printf ("Got write_owner access to device\n");
        }
        query_object(devmap->handle, devmap, path);
        misc_functions (devmap->handle, path, synch);
    } else {
        if (status != STATUS_INVALID_DEVICE_REQUEST &&
            status != STATUS_ACCESS_DENIED) {
            printf("%s failed %x\n", api,
                   status);
        }
    }
    if ((direct && synch) || (addbackslash & !synch && !direct)) // Only do this twice
       try_fast_query_delete_etc (&oa, path, L"Top open");


    return status;
}

/*
   Compare routine for sorting the object directory
*/
int __cdecl compare_unicode (const void *arg1, const void *arg2)
{
   POBJECT_DIRECTORY_INFORMATION s1, s2;
   ULONG i, j;

   s1 = (POBJECT_DIRECTORY_INFORMATION) arg1;
   s2 = (POBJECT_DIRECTORY_INFORMATION) arg2;
   for (i = 0, j = 0;
        (i < s1->Name.Length / sizeof (WCHAR)) &&
        (j < s2->Name.Length / sizeof (WCHAR)); i++, j++) {
      if (s1->Name.Buffer[i] < s2->Name.Buffer[j])
         return -1;
      else if (s1->Name.Buffer[i] > s2->Name.Buffer[j])
         return +1;
   }
   if (i > j)
      return -1;
   else if (i < j)
      return +1;
   else
      return 0;
}


/*
   Do all the various different opens looking for handles
*/
NTSTATUS do_device_opens (HANDLE          handle,
                          PUNICODE_STRING name,
                          PDEVMAP         devmap,
                          PULONG          devscount,
                          PWCHAR          path,
                          PWCHAR          devbuf)
{
   NTSTATUS status;
   ULONG do_tdi_opens=0;
   ULONG OrigDevCount;


   OrigDevCount = *devscount;

   if (flags&FLAGS_DO_SYNC) {
      status = open_device(handle,
                           name,
                           &devmap[*devscount],
                           TRUE,   /* Synchronous           */
                           FALSE,  /* No added backslash    */
                           FALSE,  /* No direct device open */
                           0,
                           path);
 
      if (NT_SUCCESS(status)) {
         if (NT_SUCCESS (check_tdi_handle (devmap[*devscount].handle))) {
            do_tdi_opens = 1;
         }
         try_funny_opens(devmap[*devscount].handle, path);

         do_ioctl(&devmap[*devscount], path);

         *devscount = *devscount + 1;

      } else {
          if (status == -1) {
              return status;
          } else {
              wprintf(L"Failed to open device %s status is %x\n",
                      devbuf,
                      status);
          }
      }
   }


   status = open_device(handle,
                        name,
                        &devmap[*devscount],
                        FALSE,  /* Synchronous             */
                        FALSE,  /* No added backslash      */
                        FALSE,  /* No direct device access */
                        0,
                        path);

   if (NT_SUCCESS(status)) {
      if (!do_tdi_opens && NT_SUCCESS (check_tdi_handle (devmap[*devscount].handle))) {
         do_tdi_opens = 1;
      }
      try_funny_opens(devmap[*devscount].handle, path);
      do_ioctl(&devmap[*devscount], path);

      *devscount = *devscount + 1;
   } else {
      if (status == -1) {
          return status;
      } else {
          wprintf(L"Failed to open device %s status is %x\n",
                  devbuf,
                  status);
      }
   }

   status = open_device(handle,
                        name,
                        &devmap[*devscount],
                        FALSE,  /* Synchronous             */
                        TRUE,   /* No added backslash      */
                        FALSE,  /* No direct device access */
                        0,
                        path);

   if (NT_SUCCESS(status)) {
      try_funny_opens(devmap[*devscount].handle, path);
      do_ioctl(&devmap[*devscount], path);

      *devscount = *devscount + 1;
   } else {
      if (status == -1) {
          return status;
      } else {
          wprintf(L"Failed to open device %s status is %x\n",
                  devbuf,
                  status);
      }
   }

   if (flags&FLAGS_DO_SYNC) {
      status = open_device(handle,
                           name,
                           &devmap[*devscount],
                           TRUE,  /* Synchronous          */
                           FALSE, /* No added backslash   */
                           TRUE,  /* Direct device access */
                           0,
                           path);

      if (NT_SUCCESS(status)) {
         try_funny_opens(devmap[*devscount].handle, path);
         do_ioctl(&devmap[*devscount], path);

         *devscount = *devscount + 1;
      } else {
         if (status == -1) {
             return status;
         } else {
             wprintf(L"Failed to open device %s status is %x\n",
                     devbuf,
                     status);
         }
      }
   }

   if (flags&FLAGS_DO_SYNC) {
      status = open_device(handle,
                           name,
                           &devmap[*devscount],
                           TRUE,  /* Synchronous          */
                           FALSE, /* No added backslash   */
                           FALSE, /* Direct device access */
                           OPEN_TYPE_NAMED_PIPE,
                           path);

      if (NT_SUCCESS(status)) {
         try_funny_opens(devmap[*devscount].handle, path);
         do_ioctl(&devmap[*devscount], path);

         *devscount = *devscount + 1;
      } else {
         if (status == -1) {
             return status;
         } else {
             wprintf(L"Failed to open device %s status is %x\n",
                     devbuf,
                     status);
         }
      }
      status = open_device(handle,
                           name,
                           &devmap[*devscount],
                           TRUE,  /* Synchronous          */
                           FALSE, /* No added backslash   */
                           FALSE, /* Direct device access */
                           OPEN_TYPE_MAIL_SLOT,
                           path);

      if (NT_SUCCESS(status)) {
         try_funny_opens(devmap[*devscount].handle, path);
         do_ioctl(&devmap[*devscount], path);

         *devscount = *devscount + 1;
      } else {
         if (status == -1) {
             return status;
         } else {
             wprintf(L"Failed to open device %s status is %x\n",
                     devbuf,
                     status);
         }
      }
   }
   status = open_device(handle,
                        name,
                        &devmap[*devscount],
                        FALSE, /* Synchronous          */
                        FALSE, /* No added backslash   */
                        FALSE, /* Direct device access */
                        OPEN_TYPE_NAMED_PIPE,
                        path);

   if (NT_SUCCESS(status)) {
      try_funny_opens(devmap[*devscount].handle, path);
      do_ioctl(&devmap[*devscount], path);

      *devscount = *devscount + 1;
   } else {
         if (status == -1) {
             return status;
         } else {
             wprintf(L"Failed to open device %s status is %x\n",
                     devbuf,
                     status);
         }
   }
   status = open_device(handle,
                        name,
                        &devmap[*devscount],
                        FALSE, /* Synchronous          */
                        FALSE, /* No added backslash   */
                        FALSE, /* Direct device access */
                        OPEN_TYPE_MAIL_SLOT,
                        path);

   if (NT_SUCCESS(status)) {
      try_funny_opens(devmap[*devscount].handle, path);
      do_ioctl(&devmap[*devscount], path);

      *devscount = *devscount + 1;
   } else {
         if (status == -1) {
             return status;
         } else {
             wprintf(L"Failed to open device %s status is %x\n",
                     devbuf,
                     status);
         }
   }

   status = open_device(handle,
                        name,
                        &devmap[*devscount],
                        FALSE, /* Synchronous          */
                        FALSE, /* No added backslash   */
                        FALSE, /* Direct device access */
                        OPEN_TYPE_TREE_CONNECT,
                        path);

   if (NT_SUCCESS(status)) {
      try_funny_opens(devmap[*devscount].handle, path);
      do_ioctl(&devmap[*devscount], path);

      *devscount = *devscount + 1;
   } else {
         if (status == -1) {
             return status;
         } else {
             wprintf(L"Failed to open device %s status is %x\n",
                     devbuf,
                     status);
         }
   }

   if (do_tdi_opens) {
      status = open_device(handle,
                           name,
                           &devmap[*devscount],
                           FALSE,  /* Synchronous          */
                           FALSE,  /* No added backslash   */
                           FALSE,  /* Direct device access */
                           OPEN_TYPE_TDI_CONNECTION,
                           path);

      if (NT_SUCCESS(status)) {
         try_funny_opens(devmap[*devscount].handle, path);
         do_ioctl(&devmap[*devscount], path);

         *devscount = *devscount + 1;
      } else {
         if (status == -1) {
             return status;
         } else {
             wprintf(L"Failed to open device %s status is %x\n",
                     devbuf,
                     status);
         }
      }

      status = open_device(handle,
                           name,
                           &devmap[*devscount],
                           FALSE,  /* Synchronous          */
                           FALSE,  /* No added backslash   */
                           FALSE,  /* Direct device access */
                           OPEN_TYPE_TDI_ADDR_IP,
                           path);

      if (NT_SUCCESS(status)) {
         try_funny_opens(devmap[*devscount].handle, path);
         do_ioctl(&devmap[*devscount], path);

         *devscount = *devscount + 1;
      } else {
         if (status == -1) {
             return status;
         } else {
             wprintf(L"Failed to open device %s status is %x\n",
                     devbuf,
                     status);
         }
      }
      status = open_device(handle,
                           name,
                           &devmap[*devscount],
                           FALSE,  /* Synchronous          */
                           FALSE,  /* No added backslash   */
                           FALSE,  /* Direct device access */
                           OPEN_TYPE_TDI_ADDR_IPX,
                           path);

      if (NT_SUCCESS(status)) {
         try_funny_opens(devmap[*devscount].handle, path);
         do_ioctl(&devmap[*devscount], path);

         *devscount = *devscount + 1;
      } else {
         if (status == -1) {
             return status;
         } else {
             wprintf(L"Failed to open device %s status is %x\n",
                     devbuf,
                     status);
         }
      }
      status = open_device(handle,
                           name,
                           &devmap[*devscount],
                           FALSE,  /* Synchronous          */
                           FALSE,  /* No added backslash   */
                           FALSE,  /* Direct device access */
                           OPEN_TYPE_TDI_ADDR_NETBIOS,
                           path);

      if (NT_SUCCESS(status)) {
         try_funny_opens(devmap[*devscount].handle, path);
         do_ioctl(&devmap[*devscount], path);

         *devscount = *devscount + 1;
      } else {
         if (status == -1) {
             return status;
         } else {
             wprintf(L"Failed to open device %s status is %x\n",
                     devbuf,
                     status);
         }
      }
      status = open_device(handle,
                           name,
                           &devmap[*devscount],
                           FALSE,  /* Synchronous          */
                           FALSE,  /* No added backslash   */
                           FALSE,  /* Direct device access */
                           OPEN_TYPE_TDI_ADDR_APPLE,
                           path);

      if (NT_SUCCESS(status)) {
         try_funny_opens(devmap[*devscount].handle, path);
         do_ioctl(&devmap[*devscount], path);

         *devscount = *devscount + 1;
      } else {
         if (status == -1) {
             return status;
         } else {
             wprintf(L"Failed to open device %s status is %x\n",
                     devbuf,
                     status);
         }
      }
   }

   if (OrigDevCount == *devscount) {
       crashes (path, L"FAILED all open attempts", L"", L"", L"");
   }

   crashes (path, L"DONE", L"", L"", L"");

   return status;
}

NTSTATUS
do_lpc_connect (HANDLE          handle,
                PUNICODE_STRING name,
                PDEVMAP         devmap,
                PULONG          devscount,
                PWCHAR          path,
                PWCHAR          devbuf)
{
   HANDLE nhandle;
   NTSTATUS status;
   SECURITY_QUALITY_OF_SERVICE qos;
   ULONG maxmsg, i, opened;
   UNICODE_STRING fullname;

   RtlInitUnicodeString (&fullname, path);
   qos.ImpersonationLevel = SecurityImpersonation;
   qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
   qos.EffectiveOnly = TRUE;
   opened = 0;
   for (i = 0; i < 1000; i++) {
      status = NtConnectPort (&nhandle, &fullname, &qos, NULL, NULL, &maxmsg, NULL, NULL);
      if (!NT_SUCCESS (status)) {
         wprintf (L"NtConnectPort failed to %s %x\n", path, status);
         return status;
      }
      opened++;
      status = NtClose (nhandle);
      if (!NT_SUCCESS (status)) {
         wprintf (L"NtClose of port handle failed %x\n", status);
      }
   }
   if (opened) {
      wprintf (L"Opened port %ws %d times\n", path, opened);
   }
   return status;
}

/*
   Traverse the object tree looking for devices
*/
NTSTATUS
recurse(
    HANDLE                  handle,
    PUNICODE_STRING         name,
    PDEVMAP                 devmap,
    PULONG                  devscount,
    PWCHAR                  path,
    ULONG                   depth
)
{
    HANDLE                  nhandle, shandle;
    NTSTATUS                status;
    OBJECT_ATTRIBUTES       oa;
    OBJECT_DIRECTORY_INFORMATION *od;
    PVOID                   buffer;
    ULONG                   bufferlen;
    ULONG                   context;
    ULONG                   retlen;
    ULONG                   ul;
    UNICODE_STRING          equiv;
    WCHAR                   buf[100], devbuf[200], objtype[80];
    PWCHAR                  npath = NULL;
    static WCHAR            ans[100]={0};
    ULONG                   c;

    if (depth > 10) {
        return STATUS_SUCCESS;
    }
    InitializeObjectAttributes(&oa,
                               name,
                               OBJ_CASE_INSENSITIVE,
                               handle,
                               NULL);

    wcsncpy(devbuf,
            name->Buffer,
            sizeof (devbuf) / sizeof (devbuf[0]));
    
    devbuf[sizeof (devbuf) - 1] = L'\0';

    status = NtOpenDirectoryObject(&nhandle,
                                   MAXIMUM_ALLOWED/*DIRECTORY_QUERY | DIRECTORY_TRAVERSE*/,
                                   &oa);

    if (NT_SUCCESS(status)) {
        context = 0;

        bufferlen = 0x10000;

        buffer = malloc(bufferlen);

        status = NtQueryDirectoryObject(nhandle,
                                        buffer,
                                        bufferlen,
                                        FALSE,
                                        TRUE,
                                        &context,
                                        &retlen);

        if (NT_SUCCESS(status)) {

            for (od = (POBJECT_DIRECTORY_INFORMATION) buffer, c = 0;
                 od->Name.Length != 0 || od->TypeName.Length != 0; od++, c++)
               ;

            qsort (buffer, c, sizeof (*od), compare_unicode);

            for (od = (POBJECT_DIRECTORY_INFORMATION) buffer;
                 *devscount < MAX_DEVICES; od++) {

                if (od->Name.Length == 0 &&
                    od->TypeName.Length == 0) {

                    break;
                }

                wcsncpy(devbuf,
                        od->Name.Buffer,
                        sizeof (devbuf) / sizeof (devbuf[0]));
                devbuf[sizeof (devbuf) / sizeof (devbuf[0]) - 1] = L'\0';

                wcsncpy(objtype,
                        od->TypeName.Buffer,
                        sizeof (objtype) / sizeof (objtype[0]));
                objtype[sizeof (objtype) / sizeof (objtype[0]) - 1] = L'\0';

                npath = realloc (npath,
                                 (wcslen (path) + 1 + wcslen (devbuf) + 1) *
                                    sizeof (WCHAR));
                if (!npath) {
                   printf ("Memory allocation failed for path buffer!");
                   exit (EXIT_FAILURE);
                }
                wcscpy (npath, path);
                if (path[wcslen (path)-1] != '\\' &&
                    devbuf[wcslen (devbuf)-1] != '\\')
                   wcscat (npath, L"\\");
                wcscat (npath, devbuf);
                if (wcsncmp(objtype,
                            L"Directory",
                            od->TypeName.Length / sizeof (WCHAR)) == 0) {

                    recurse(nhandle,
                            &od->Name,
                            devmap,
                            devscount,
                            npath,
                            depth+1);

                } else if (!(flags&FLAGS_DO_LPC) && (
                           wcsncmp(objtype,
                                   L"Device",
                                   od->TypeName.Length / sizeof (WCHAR)) == 0 ||
                           (wcsncmp(objtype,
                                    L"SymbolicLink",
                                    od->TypeName.Length / sizeof (WCHAR)) == 0 && (flags&FLAGS_DO_SYMBOLIC)))) {
                    if (!(flags&FLAGS_DO_ALLDEVS)) {
                       if (skipped == 0) {
                          ans[0] = 0;
                          skipped = 1;
                       }
                       if (ans[0] == '/') {
//                          wprintf (L"Matching \"%s\" against \"%s\"\n", &ans[1], devbuf);
                          if (_wcsnicmp (&ans[1], devbuf, wcslen (&ans[1])) != 0)
                             continue;
                       } else if (ans[0] == '?' || (flags&FLAGS_DO_PRINT_DEVS)) {
                          if (prefix_string) {
                             printf ("%s %ws\\%ws\n", prefix_string, path, devbuf);
                          } else {
                             printf ("%ws %ws\\%ws\n", objtype, path, devbuf);
                          }
                          continue;
                       }

                       progress_counter = 0;
                       if (flags & FLAGS_DO_RANDOM_DEVICE) {
                          if (random_device > 0) {
//                             wprintf (L"%s %s\\%s\n", objtype, path, devbuf);                         
                             random_device--;
                             continue;
                          }
                       } else if (ans[0] != 'a' && ans[0] != 'A') {
                          wprintf (L"Open device %s %s\\%s? ", objtype, path, devbuf);
                          wscanf (L"%100s", ans);
                          if (ans[0] == 'q' || ans[0] == 'Q') {
                             exit (EXIT_SUCCESS);
                          } else if (ans[0] != 'y' && ans[0] != 'Y' &&
                              ans[0] != 'a' && ans[0] != 'A') {
                             continue;
                          }
                       }
                    }
                    if (!(flags&FLAGS_DO_DISKS)) {
                       if (wcsstr (path, L"Harddisk") ||
                           wcsstr (path, L"Ide") ||
                           wcsstr (path, L"Scsi")) {
                          printf ("Skipping this device as it looks like a disk\n");
                          continue;
                       }
                    }

                    if (flags&FLAGS_DO_FAILURE_INJECTION) {
                       turn_on_fault_injection ();
                    }
                    if (flags&FLAGS_DO_IMPERSONATION) {
                        Impersonate_nonadmin ();
                    }

                    status = do_device_opens (nhandle,
                                              &od->Name,
                                              devmap,
                                              devscount,
                                              npath,
                                              devbuf);


                    if (flags&FLAGS_DO_IMPERSONATION) {
                       if (!Revert_from_admin ()) {
                          printf ("Revert_from_admin failed %d\n", GetLastError ());
                          exit (EXIT_FAILURE);
                       }
                    }
                    if (flags&FLAGS_DO_FAILURE_INJECTION) {
                       turn_off_fault_injection ();
                    }
                    print_diags (0, 0);
                    if (flags & FLAGS_DO_RANDOM_DEVICE) {
                       break;
                    }
                } else if ((flags&FLAGS_DO_LPC) &&
                           wcsncmp(od->TypeName.Buffer,
                                   L"Port",
                                   od->TypeName.Length / sizeof (WCHAR)) == 0) {

                     if (!(flags&FLAGS_DO_ALLDEVS)) {
                        if (skipped == 0) {
                           ans[0] = 0;
                           skipped = 1;
                        }
                        if (ans[0] == '/') {
                           wprintf (L"Matching \"%s\" against \"%s\"\n", &ans[1], devbuf);
                           if (_wcsnicmp (&ans[1], devbuf, wcslen (&ans[1])) != 0)
                              continue;
                        } else if (ans[0] == '?') {
                           wprintf (L"%s\\%s\n", path, devbuf);
                           continue;
                        } else if (ans[0] == 'q' || ans[0] == 'Q') {
                           exit (EXIT_SUCCESS);
                        }
                        if (ans[0] != 'a' && ans[0] != 'A') {
                           wprintf (L"Open LPC port %s\\%s? ", path, devbuf);
                           wscanf (L"%100s", ans);
                           if (ans[0] != 'y' && ans[0] != 'Y' &&
                               ans[0] != 'a' && ans[0] != 'A')
                              continue;
                        }
                        if (flags&FLAGS_DO_IMPERSONATION) {
                            Impersonate_nonadmin ();
                        }


                        status = do_lpc_connect (nhandle,
                                                 &od->Name,
                                                 devmap,
                                                 devscount,
                                                 npath,
                                                 devbuf);
                        if (flags&FLAGS_DO_IMPERSONATION) {
                           if (!Revert_from_admin ()) {
                               printf ("Revert_from_admin failed %d\n", GetLastError ());
                               exit (EXIT_FAILURE);
                            }
                        }
                    }
                }
            }
        } else {
            if (status != STATUS_NO_MORE_ENTRIES) {
                wprintf(L"NtQueryDirectoryObject failed %x for directory %s\n",
                        status,
                        devbuf);
            }
        }

        free(buffer);

        NtClose(nhandle);
    } else {
        wprintf(L"NtOpenDirectoryObject failed %x for directory %s\n",
                 status,
                 devbuf);
    }

    free (npath);
    return status;
}

/*
   Look who registers for WMI
*/
void do_wmi ()
{
   UNICODE_STRING name;
   OBJECT_ATTRIBUTES oa;
   NTSTATUS status;
   PKMREGINFO reginfo = NULL;
   HANDLE handle;
   IO_STATUS_BLOCK iosb;
   ULONG reginfol, i;

   RtlInitUnicodeString (&name, L"\\Device\\WMIServiceDevice\\");
   InitializeObjectAttributes (&oa, &name, OBJ_CASE_INSENSITIVE, NULL, NULL);
   status = NtOpenFile (&handle,
                        MAXIMUM_ALLOWED|SYNCHRONIZE,
                        &oa,
                        &iosb,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT);
   if (NT_SUCCESS (status)) {
      status = iosb.Status;
   }
   if (!NT_SUCCESS (status)) {
//      printf ("Failed to open WMI device %x\n", status);
      return;
   }

   reginfo = malloc (reginfol = 4096);
   if (!reginfo) {
      printf ("Memory allocation failure for WMI buffer\n");
      exit (EXIT_FAILURE);
   }
   status = NtDeviceIoControlFile (handle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &iosb,
                                   IOCTL_WMI_GET_ALL_REGISTRANT,
                                   NULL,
                                   0,
                                   reginfo,
                                   reginfol);


   if (NT_SUCCESS (status)) {
      status = iosb.Status;
   }
   if (!NT_SUCCESS (status)) {
      printf ("NtDeviceIoControlFile failed %X\n", status);
   } else {
      for (i = 0; i < iosb.Information / sizeof (*reginfo); i++) {
         printf ("Device %x registered with WMI\n", reginfo[i].ProviderId);
      }
   }

   if (reginfo)
      free (reginfo);
   status = NtClose (handle);
   if (!NT_SUCCESS (status)) {
      printf ("NtClose failed %x\n", status);
   }
}

/*
   Thread to read from a socket so we can test out transmit file
*/
DWORD WINAPI do_listen (LPVOID arg)
{
   SOCKET s;
   struct sockaddr_in sockaddr;
   int l;
   int status;
   DWORD retlen;
   CHAR buf[100];

   l = sizeof (sockaddr);
   s = accept (ls, (struct sockaddr *) &sockaddr, &l);
   if (s == INVALID_SOCKET) {
      printf ("Socket failed %d\n", WSAGetLastError ());
      exit (EXIT_FAILURE);
   }
   while (1) {
      l = recv (s, buf, sizeof (buf), 0);
      if (l == 0) {
         break;
      }
      if (l == SOCKET_ERROR) {
         printf ("recv failed %d\n", WSAGetLastError ());
         exit (EXIT_FAILURE);
      }
   }
   return 0;
}

void do_handle_grab (PDEVMAP devmap,
                     PULONG  devscount)
{
   NTSTATUS status;
   CLIENT_ID clid;
   OBJECT_ATTRIBUTES oa;
   HANDLE handle;

   InitializeObjectAttributes (&oa, NULL, 0, NULL, NULL);
   clid.UniqueThread = 0;
   clid.UniqueProcess =  UlongToHandle( cid );
   status = NtOpenProcess (&handle, PROCESS_DUP_HANDLE, &oa, &clid);
   if (!NT_SUCCESS (status)) {
      printf ("NtOpenProcess for process %d failed %x\n", cid, status);
      return;
   }
   status = NtDuplicateObject (handle, process_handle, NtCurrentProcess (),
                               &devmap->handle, 0, 0, DUPLICATE_SAME_ACCESS);
   if (NT_SUCCESS (status)) {
      *devscount += 1;
      status = get_handle_access (devmap->handle, &devmap->access);
      if (NT_SUCCESS(status)) {
         wprintf(L"Grabbed handle with access %x\n",
                 devmap->access);
         if (DELETE&devmap->access) {
            printf ("Got delete access to device\n");
         }
         if (WRITE_DAC&devmap->access) {
            printf ("Got write_dac access to device\n");
         }
         if (WRITE_OWNER&devmap->access) {
            printf ("Got write_owner access to device\n");
         }
      }
      query_object(devmap->handle, devmap, L"HANDLE");
      misc_functions (devmap->handle, L"HANDLE", 0);
      InitializeObjectAttributes (&oa, NULL, 0, devmap->handle, NULL);
      try_fast_query_delete_etc (&oa, L"HANDLE", L"Top open");
      try_funny_opens(devmap->handle, L"HANDLE");
      do_ioctl(devmap, L"HANDLE");
   } else {
      printf ("NtDuplicateObject failed %x\n", status);
   }

   status = NtClose (handle);
   if (!NT_SUCCESS (status)) {
      printf ("NtClose for process handle failed %x\n", status);
      return;
   }
}

//
// Parse command line
//
void process_parameters(int argc, char *argv[], PUNICODE_STRING name, long *flags, long *flags2)
{
   char c, nc, *p, st;
   int i;
   NTSTATUS status;

   *flags = FLAGS_DO_IOCTL_NULL|FLAGS_DO_IOCTL_RANDOM|
            FLAGS_DO_FSCTL_NULL|FLAGS_DO_FSCTL_RANDOM|
            FLAGS_DO_LOGGING|FLAGS_DO_SKIPCRASH|FLAGS_DO_POOLCHECK|
            FLAGS_DO_MISC|FLAGS_DO_QUERY|FLAGS_DO_SUBOPENS|FLAGS_DO_ZEROEA|
            FLAGS_DO_DISKS|FLAGS_DO_SECURITY|FLAGS_DO_OPEN_CLOSE|
            FLAGS_DO_DIRECT_DEVICE|FLAGS_DO_SYMBOLIC|FLAGS_DO_IMPERSONATION;
   *flags2 = 0;

   name->Length = name->MaximumLength = 0;
   name->Buffer = NULL;
   while (--argc) {
      p = *++argv;
      st = *p;
      if (st == '/' || st == '-' || st == '+') {
         c = *++p;
         nc = *++p;
         nc = (char) toupper (nc);
         switch (toupper (c)) {
            case 'I' :
               if (nc == 'R') {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_IOCTL_RANDOM;
                  else
                     *flags |= FLAGS_DO_IOCTL_RANDOM;
               } else if (nc == 'N') {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_IOCTL_NULL;
                  else
                     *flags |= FLAGS_DO_IOCTL_NULL;
               } else if (nc == 'F') {
                  if (st == '-')
                     *flags &= ~(FLAGS_DO_IOCTL_NULL|FLAGS_DO_FSCTL_NULL|
                                 FLAGS_DO_IOCTL_RANDOM|FLAGS_DO_FSCTL_RANDOM);
                  else
                     *flags |= FLAGS_DO_IOCTL_NULL|FLAGS_DO_FSCTL_NULL|
                               FLAGS_DO_IOCTL_RANDOM|FLAGS_DO_FSCTL_RANDOM;
               } else if (nc == 'M') {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_IMPERSONATION;
                  else
                     *flags |= FLAGS_DO_IMPERSONATION;
               } else if (nc == 'L') {
                  if (argc > 1) {
                     ioctl_inbuf_min = atoi (*++argv);
                     ioctl_inbuf_min = min (ioctl_inbuf_min, BIGBUF_SIZE);
                     argc--;
                     printf ("IOCTL/FSCTL lower input buffer limit %d\n", ioctl_inbuf_min);
                  } else {
                     printf ("IOCTL/FSCTL lower input limit missing\n");
                  }
               } else if (nc == 'U') {
                  if (argc > 1) {
                     ioctl_inbuf_max = atoi (*++argv);
                     ioctl_inbuf_max = min (ioctl_inbuf_max, BIGBUF_SIZE);
                     argc--;
                     printf ("IOCTL/FSCTL upper input buffer limit %d\n", ioctl_inbuf_max);
                  } else {
                     printf ("IOCTL/FSCTL upper input limit missing\n");
                  }
               } else if (!nc) {
                  if (st == '-')
                     *flags &= ~(FLAGS_DO_IOCTL_NULL|FLAGS_DO_IOCTL_RANDOM);
                  else
                     *flags |= FLAGS_DO_IOCTL_NULL|FLAGS_DO_IOCTL_RANDOM;
               }
               break;
            case 'F' :
               if (nc == 'L') {
                  if (argc > 1) {
                     ioctl_min_function = atoi (*++argv);
                     ioctl_min_function = min (ioctl_min_function, 0xFFF);
                     argc--;
                     printf ("IOCTL/FSCTL lower function limit %d\n", ioctl_min_function);
                  } else {
                     printf ("IOCTL/FSCTL lower function limit missing\n");
                  }
               } else if (nc == 'U') {
                  if (argc > 1) {
                     ioctl_max_function = atoi (*++argv);
                     ioctl_max_function = min (ioctl_max_function, 0xFFF);
                     argc--;
                     printf ("IOCTL/FSCTL upper function limit %d\n", ioctl_max_function);
                  } else {
                     printf ("IOCTL/FSCTL upper function limit missing\n");
                  }
               } else if (nc == 'R') {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_FSCTL_RANDOM;
                  else
                     *flags |= FLAGS_DO_FSCTL_RANDOM;
               } else if (nc == 'N') {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_FSCTL_NULL;
                  else
                     *flags |= FLAGS_DO_FSCTL_NULL;
               } else if (nc == 'I') {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_FAILURE_INJECTION;
                  else
                     *flags |= FLAGS_DO_FAILURE_INJECTION;
               } else if (!nc) {
                  if (st == '-')
                     *flags &= ~(FLAGS_DO_FSCTL_NULL|FLAGS_DO_FSCTL_RANDOM);
                  else
                     *flags |= FLAGS_DO_FSCTL_NULL|FLAGS_DO_FSCTL_RANDOM;
               }
               break;
            case 'C' :
               if (st == '-')
                  *flags &= ~FLAGS_DO_SKIPCRASH;
               else
                  *flags |= FLAGS_DO_SKIPCRASH;
               break;
            case 'L' :
               if (st == '-')
                  *flags &= ~FLAGS_DO_LOGGING;
               else
                  *flags |= FLAGS_DO_LOGGING;
               break;
            case 'P' :
               if (!nc) {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_POOLCHECK;
                  else
                     *flags |= FLAGS_DO_POOLCHECK;
               } else if (nc == 'R') {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_PROT;
                  else
                     *flags |= FLAGS_DO_PROT;
               } else if (nc == 'D') {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_PRINT_DEVS;
                  else
                     *flags |= FLAGS_DO_PRINT_DEVS;
               } else if (nc == 'S') {
                  if (argc > 1) {
                     prefix_string = *++argv;
                     argc--;
                  } else {
                     printf ("Prefix string missing\n");
                  }
               }
               break;
            case 'R' :
               if (!nc) {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_SKIPDONE;
                  else
                     *flags |= FLAGS_DO_SKIPDONE;
               } else if (nc == 'D') {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_RANDOM_DEVICE;
                  else
                     *flags |= FLAGS_DO_RANDOM_DEVICE;
               }
               break;
            case 'M' :
               if (st == '-')
                  *flags &= ~FLAGS_DO_MISC;
               else
                  *flags |= FLAGS_DO_MISC;
               break;
            case 'N' :
               if (st == '-')
                  *flags &= ~FLAGS_DO_MAPNULL;
               else
                  *flags |= FLAGS_DO_MAPNULL;
               break;
            case 'O' :
               if (nc == 'L') {
                  if (argc > 1) {
                     ioctl_outbuf_min = atoi (*++argv);
                     ioctl_outbuf_min = min (ioctl_outbuf_min, BIGBUF_SIZE);
                     argc--;
                     printf ("IOCTL/FSCTL lower output buffer limit %d\n", ioctl_outbuf_min);
                  } else {
                     printf ("IOCTL/FSCTL lower output limit missing\n");
                  }
               } else if (nc == 'U') {
                  if (argc > 1) {
                     ioctl_outbuf_max = atoi (*++argv);
                     ioctl_outbuf_max = min (ioctl_outbuf_max, BIGBUF_SIZE);
                     argc--;
                     printf ("IOCTL/FSCTL upper output buffer limit %d\n", ioctl_outbuf_max);
                  } else {
                     printf ("IOCTL/FSCTL upper output limit missing\n");
                  }
               } else if (nc == 'C') {
                   if (st == '-') {
                      *flags &= ~FLAGS_DO_OPEN_CLOSE;
                   } else {
                      *flags |= FLAGS_DO_OPEN_CLOSE;
                   }
               }
               break;
            case 'S' :
               if (nc == 'D') {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_SECURITY;
                  else
                     *flags |= FLAGS_DO_SECURITY;
               } else if (nc == 'L'){
                  if (st == '-')
                     *flags &= ~FLAGS_DO_SYMBOLIC;
                  else
                     *flags |= FLAGS_DO_SYMBOLIC;
               } else {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_SUBOPENS;
                  else
                     *flags |= FLAGS_DO_SUBOPENS;
               }
               break;
            case 'Q' :
               if (st == '-')
                  *flags &= ~FLAGS_DO_QUERY;
               else
                  *flags |= FLAGS_DO_QUERY;
               break;
            case 'A' :
               if (nc == 'L') {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_ALERT;
                  else
                     *flags |= FLAGS_DO_ALERT;
               } else {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_ALLDEVS;
                  else
                     *flags |= FLAGS_DO_ALLDEVS;
               }
               break;
            case 'E' :
               if (st == '-')
                  *flags &= ~FLAGS_DO_ZEROEA;
               else
                  *flags |= FLAGS_DO_ZEROEA;
               break;
            case 'Z' :
               if (st == '-')
                  *flags &= ~FLAGS_DO_LPC;
               else
                  *flags |= FLAGS_DO_LPC;
               break;
            case 'V' :
               if (st == '-')
                  *flags &= ~FLAGS_DO_ERRORS;
               else
                  *flags |= FLAGS_DO_ERRORS;
               break;
            case 'J' :
               if (st == '-')
                  *flags &= ~FLAGS_DO_STREAMS;
               else
                  *flags |= FLAGS_DO_STREAMS;
               break;
            case 'W' :
               if (st == '-')
                  *flags &= ~FLAGS_DO_WINSOCK;
               else
                  *flags |= FLAGS_DO_WINSOCK;
               break;
            case 'K' :
               if (st == '-')
                  *flags &= ~FLAGS_DO_SYNC;
               else
                  *flags |= FLAGS_DO_SYNC;
               break;
            case 'T' :
               if (nc == 'T') {
                  if (argc > 1) {
                     max_tailured_calls = atoi (*++argv);
                     argc--;
                     max_tailured_calls = ((max_tailured_calls + RAND_REP - 1) / RAND_REP) *
                                           RAND_REP;
                     printf ("IOCTL/FSCTL tailured calls %d\n", max_tailured_calls);
                  } else {
                     printf ("IOCTL/FSCTL tailured calls value is missing\n");
                  }
               } else {
                  if (argc > 1) {
                     max_random_calls = atoi (*++argv);
                     argc--;
                     max_random_calls = ((max_random_calls + RAND_REP - 1) / RAND_REP) *
                                        RAND_REP;
                     printf ("IOCTL/FSCTL random calls %d\n", max_random_calls);
                  } else {
                     printf ("IOCTL/FSCTL random calls value is missing\n");
                  }
               }
               break;
            case 'D' :
               if (nc == 'L') {
                  if (argc > 1) {
                     ioctl_min_devtype = atoi (*++argv);
                     argc--;
                     ioctl_min_devtype = min (ioctl_min_devtype, 0xFFFF);
                     printf ("IOCTL/FSCTL lower device type limit %d\n",
                             ioctl_min_devtype);
                  } else {
                     printf ("IOCTL/FSCTL lower device type limit missing\n");
                  }
               } else if (nc == 'U') {
                  if (argc > 1) {
                     ioctl_max_devtype = atoi (*++argv);
                     ioctl_max_devtype = min (ioctl_max_devtype, 0xFFFF);
                     argc--;
                     printf ("IOCTL/FSCTL upper device type limit %d\n",
                             ioctl_max_devtype);
                  } else {
                     printf ("IOCTL/FSCTL upper device type limit missing\n");
                  }
               } else if (nc == 'D') {
                  if (st == '-')
                     *flags &= ~FLAGS_DO_DIRECT_DEVICE;
                  else
                     *flags |= FLAGS_DO_DIRECT_DEVICE;
                  break;
               } else if (nc == 'R') {
                  if (st == '-') {
                      *flags2 &= ~FLAGS_DO_DRIVER;
                  } else {
                      *flags2 |= FLAGS_DO_DRIVER;
                      *flags |= FLAGS_DO_ALLDEVS;
                      if (argc > 1) {
                          status = RtlCreateUnicodeStringFromAsciiz (&DriverName, *++argv);
                          if (!NT_SUCCESS (status)) {
                              printf ("RtlCreateUnicodeStringFromAsciiz failed %x\n", status);
                              exit (EXIT_FAILURE);
                          }
                          argc--;
                      } else {
                          printf ("Input driver name missing on command line\n");
                      }
                  }
                  break;
               } else if (!nc) {
                  if (argc > 1) {
                     status = RtlCreateUnicodeStringFromAsciiz (name, *++argv);
                     if (!NT_SUCCESS (status)) {
                        printf ("RtlCreateUnicodeStringFromAsciiz failed %x\n", status);
                        exit (EXIT_FAILURE);
                     }
                     argc--;
                  } else {
                     printf ("Input device missing on command line\n");
                  }
               }
               break;
            case 'G':
               if (argc > 2) {
                  *flags |= FLAGS_DO_GRAB;
                  cid = atoi (*++argv);
                  process_handle = UlongToHandle( atoi (*++argv) );
                  argc -= 2;
               } else {
                  printf ("Client ID and handle missing\n");
               }
               break;
            case 'Y' :
               if (st == '-')
                  *flags &= ~FLAGS_DO_DISKS;
               else
                  *flags |= FLAGS_DO_DISKS;
               break;
            case '?':
            case 'H':
            default :
               *flags |= FLAGS_DO_USAGE;
               break;
         }
      } else {
         status = RtlCreateUnicodeStringFromAsciiz (name, *argv);
         if (!NT_SUCCESS (status)) {
            printf ("RtlCreateUnicodeStringFromAsciiz failed %x\n", status);
            exit (EXIT_FAILURE);
         }
      }
   }
   ioctl_inbuf_max = max (ioctl_inbuf_min, ioctl_inbuf_max);
   ioctl_outbuf_max = max (ioctl_outbuf_min, ioctl_outbuf_max);
   if (prefix_string && (*flags&FLAGS_DO_PRINT_DEVS) == 0) {
      prefix_string = NULL;
   }
   return;
}

/*
   Print out usage message
*/
void
do_usage (void)
{
   printf ("devctl [/i] [/l] [/il nn] [/iu mm] [devnam]\n\n");
   printf ("/ and + enable options, - disables options\n\n");
   printf ("/a\tDo all devices in system. Don't prompt for yes/no etc\n");
   printf ("/al\tAlert the main thread periodically\n");
   printf ("/c\tEnable or disable skipping operations that aborted or crashed\n");
   printf ("/dd\tEnable or disable the direct device open paths\n");
   printf ("/dl nn\tSets max for device type portion of IOCTL/FSCTL code, default 0\n");
   printf ("/dr drv\tOnly runs on device objects with driver <drv> in their stack\n");
   printf ("/du nn\tSets min limit for device type portion of IOCTL/FSCTL code, default 200\n");
   printf ("/e\tEnable or disable zero length EA's, needed on checked builds\n");
   printf ("/f\tEnable or disable all FSCTL paths\n");
   printf ("/fi\tEnable or disable turning on failure injection in the driver verifier\n");
   printf ("/fn\tEnable or disable FSCTL paths with null buffers\n");
   printf ("/fr\tEnable or disable FSCTL paths with random buffers\n");
   printf ("/fl nn\tSets max for function portion of IOCTL and FSCTL code, default 0\n");
   printf ("/fu nn\tSets min for function portion of IOCTL and FSCTL code, default 400\n");
   printf ("/g c h\tGrabs a handle from another process\n");
   printf ("/h /?\tPrints this message\n");
   printf ("/i\tEnable or disable all IOCTL paths\n");
   printf ("/if\tEnable or disable all FSCTL and IOCTL paths\n");
   printf ("/in\tEnable or disable IOCTL paths with null buffers\n");
   printf ("/il nnn\tSet lower input buffer size\n");
   printf ("/im\tEnable or disable the impersonation of a non-admin during the test\n");
   printf ("/iu nnn\tSet upper input buffer size\n");
   printf ("/ir\tEnable or disable IOCTL paths with random buffers\n");
   printf ("/j\tEnable or disable relative stream opens for filesystems\n");
   printf ("/k\tEnable or disable synchronous handles\n");
   printf ("/l\tEnable or disable logging and skipping failing functions\n");
   printf ("/m\tEnable or disable the misc functions\n");
   printf ("/n\tMap zero page so that NULL pointer de-references don't raise\n");
   printf ("/oc\tEnable or disable the multithreaded open and close stage\n");
   printf ("/ol nnn\tSet lower output buffer size\n");
   printf ("/ou nnn\tSet upper output buffer size\n");
   printf ("/p\tEnable or disable the checks on pool usage via tags and lookaside lists\n");
   printf ("/pd\tPrint out device objects and symbolic links and exit\n");
   printf ("/pr\tEnable or disable protection change tests\n");
   printf ("/ps sss\tSet prefix string for use with /pd\n");
   printf ("/q\tEnable or disable the normal handle query functions\n");
   printf ("/r\tEnable or disable skipping operations already logged as done\n");
   printf ("/rd\tSelect a random device object or symbolic link for testing\n");
   printf ("/s\tEnable or disable the sub or relative opens to obtain handles\n");
   printf ("/sd\tEnable or disable the query and set security functions\n");
   printf ("/sl\tEnable or disable the opening of symbolic links\n");
   printf ("/se nnn\tSet session id to nnn\n");
   printf ("/t nn\tSet max IOCTL/FSCTL calls made with random buffers, default 100000\n");
   printf ("/tt nn\tSet max tailured calls made for discovered IOCTLs/FSCTLs, default 10000\n");
   printf ("/v\tEnable or disable the printing of error status values for calls\n");
   printf ("/w\tEnable or disable the winsock TransmitFile test\n");
   printf ("/y\tEnable or disable touching disk devices\n");
   printf ("\n");
   printf ("Defaults: devctl -a -al +c +dd +dl 0 -dr +du 200 +e +fn +fr +fl 0 fu 400 +im\n");
   printf ("                 +il 0 +in +iu 512 +ir -j -k +l +m -n +oc +ol 0 +ou 512 +p -pr\n");
   printf ("                 +q +s +sd +sl +t 100000 +tt 10000 -v -w +y\n");
}

void change_session (ULONG sessionid)
{
   HANDLE token;

   if (!OpenProcessToken (NtCurrentProcess (), MAXIMUM_ALLOWED, &token)) {
      printf ("OpenProcessToken failed %d\n", GetLastError ());
      return;
   }
   if (SetTokenInformation (token, TokenSessionId, &sessionid, sizeof (sessionid))) {
      printf ("Token session ID changed to %d\n", sessionid);
   } else {
      printf ("SetTokenInformation failed %d\n", GetLastError ());
   }
   if (!CloseHandle (token)) {
      printf ("CloseHandle failed %d\n", GetLastError ());
      return;
   }
}

BOOL
EnableDebugPrivilege (
    )
{
    struct
    {
        DWORD Count;
        LUID_AND_ATTRIBUTES Privilege [1];

    } Info;

    HANDLE Token;
    BOOL Result;

    //
    // open the process token
    //

    Result = OpenProcessToken (
        GetCurrentProcess (),
        TOKEN_ADJUST_PRIVILEGES,
        & Token);

    if( Result != TRUE )
    {       
        return FALSE;
    }

    //
    // prepare the info structure
    //

    Info.Count = 1;
    Info.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

    Result = LookupPrivilegeValue (
        NULL,
        SE_DEBUG_NAME,
        &(Info.Privilege[0].Luid));

    if( Result != TRUE )
    {
        CloseHandle( Token );

        return FALSE;
    }

    //
    // adjust the privileges
    //

    Result = AdjustTokenPrivileges (
        Token,
        FALSE,
        (PTOKEN_PRIVILEGES) &Info,
        0,
        NULL,
        NULL);

    if( Result != TRUE || GetLastError() != ERROR_SUCCESS )
    {
        CloseHandle( Token );

        return FALSE;
    }

    CloseHandle( Token );

    return TRUE;
}

void
__cdecl
main(
    int argc, char **argv
)
{
    ULONG                   seed, i;
    UNICODE_STRING          us;
    ULONG                   id, tmp;
    DWORD                   old;
    NTSTATUS                status;
    UNICODE_STRING          name;
    WSADATA wsadata;
    WORD version;
    int istatus;
    SOCKET s;
    struct sockaddr_in sockaddr;
    char nameb[255];
    HOSTENT *host;
    struct in_addr localaddr;
    DWORD retlen;
    int t;
    HANDLE listenthread;
    struct sockaddr_in laddr;
    SIZE_T size;
    PVOID base;

    //
    // Turn off popups for a missing floppy etc
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);

    Create_nonadmin_token ();

    //
    // Create and event for any requests we really need to work on a async handle
    //
    status = NtCreateEvent (&sync_event, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE);
    if (!NT_SUCCESS (status)) {
       printf ("NtCreateEvent failed %x\n", status);
       exit (EXIT_FAILURE);
    }
    process_parameters (argc, argv, &name, &flags, &flags2);
    if (flags&FLAGS_DO_USAGE) {
       do_usage ();
       exit (EXIT_SUCCESS);
    }
    EnableDebugPrivilege ();

    /*
       Seed RNG
    */


//    printf("Seed? ");
//    scanf("%d", &seed);
//    srand(seed);
    srand ((unsigned) time (NULL));

    //
    // Build a socket etc to handle the TransmitFile API
    //
    do {
       if (!(flags&FLAGS_DO_WINSOCK))
          break;
       if (flags&FLAGS_DO_PRINT_DEVS)
          break;

       version = MAKEWORD (2, 0);
       istatus = WSAStartup (version, &wsadata);
       if (istatus != 0) {
          printf ("Failed to start winsock %x!\n", istatus);
          flags &= ~FLAGS_DO_WINSOCK;
          break;
       }

       istatus = gethostname (nameb, sizeof (nameb));
       if (istatus != 0) {
          printf ("Gethostname failed %d\n", WSAGetLastError ());
          flags &= ~FLAGS_DO_WINSOCK;
          break;
       }

       host = gethostbyname (nameb);
       if (!host) {
          printf ("Gethostbyname failed %d\n", WSAGetLastError ());
          flags &= ~FLAGS_DO_WINSOCK;
          break;
       }
       localaddr = *(struct in_addr *) host->h_addr_list[0];

       ls = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
       if (ls == INVALID_SOCKET) {
          printf ("Socket failed %d\n", WSAGetLastError ());
          flags &= ~FLAGS_DO_WINSOCK;
          break;
       }
       memset (&sockaddr, 0, sizeof (sockaddr));
       sockaddr.sin_family = AF_INET;
       sockaddr.sin_port = htons (0);
       sockaddr.sin_addr = localaddr;
       istatus = bind (ls, (struct sockaddr *) &sockaddr, sizeof (sockaddr));
       if (istatus != 0) {
          printf ("Bind failed %d\n", WSAGetLastError ());
          flags &= ~FLAGS_DO_WINSOCK;
          break;
       }

       istatus = listen (ls, 2);
       if (istatus != 0) {
          printf ("Listen failed %d\n", WSAGetLastError ());
          flags &= ~FLAGS_DO_WINSOCK;
          break;
       }

       t = sizeof (laddr);
       istatus = getsockname (ls, (struct sockaddr *) &laddr, &t);
       if (istatus != 0) {
          printf ("Getsockname failed %d\n", WSAGetLastError ());
          flags &= ~FLAGS_DO_WINSOCK;
          break;
       }
       printf ("Listen socket on port %d address %s\n",
               ntohs (laddr.sin_port), inet_ntoa (laddr.sin_addr));

       listenthread = CreateThread (NULL, 0, do_listen, NULL, 0, &id);
       if (!listenthread) {
          printf ("CreateThread failed %d\n", GetLastError ());
          flags &= ~FLAGS_DO_WINSOCK;
          break;
       }

       cs = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
       if (cs == INVALID_SOCKET) {
          printf ("Socket failed %d\n", WSAGetLastError ());
          flags &= ~FLAGS_DO_WINSOCK;
          break;
       }
       istatus = connect (cs, (struct sockaddr *) &laddr, sizeof (laddr));
       if (istatus != 0) {
          printf ("connect failed %d\n", WSAGetLastError ());
          flags &= ~FLAGS_DO_WINSOCK;
          break;
       }
    } while (FALSE);

    //
    // Build a big buffer to pass to requests
    //
    bigbuf = VirtualAlloc(NULL, BIGBUF_SIZE + SLOP, MEM_COMMIT, PAGE_READWRITE);
    if (!bigbuf) {
       printf ("Failed to allocate I/O buffers %x\n", GetLastError ());
       exit (EXIT_FAILURE);
    }
    //
    // Map the zero page and fill it with junk
    //
    if (flags&FLAGS_DO_MAPNULL) {
       base = (PVOID) 1;
       size = 1;
       status = NtAllocateVirtualMemory (NtCurrentProcess (), &base, 1, &size,
                                         MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
       if (!NT_SUCCESS (status)) {
         printf ("NtAllocateVirtualMemory for zero page failed %x\n", status);
         exit (EXIT_FAILURE);
       }
       for (i = 0; i < size; i++) {
          *((PUCHAR) base + i) = (UCHAR) rand ();
       }
    }
//    randthread = CreateThread (NULL, 0, randomize, bigbuf, CREATE_SUSPENDED, &id);
//    if (!randthread) {
//       printf ("Failed to create radomizing thread %x\n", GetLastError ());
//       exit (EXIT_FAILURE);
//    }
    //
    // Create a thread to change the page protection of our buffer if need be
    //
    if (flags&FLAGS_DO_PROT) {
       changethread = CreateThread (NULL, 0, changeprot, bigbuf, CREATE_SUSPENDED, &id);
       if (!changethread) {
          printf ("Failed to create protection change thread %x\n", GetLastError ());
          exit (EXIT_FAILURE);
       }
    }
    //
    // Get a real handle to our thread to pass to other threads
    //
    status = NtDuplicateObject (NtCurrentProcess (), NtCurrentThread (),
                                NtCurrentProcess (), &mainthread,
                                0, 0, DUPLICATE_SAME_ACCESS);
    if (!NT_SUCCESS (status)) {
       printf ("NtDuplcateObject failed %x\n", status);
       exit (EXIT_FAILURE);
    }
    //
    // Create a thread to alert this one periodicaly or when it thinks we are stuck
    //
    alertthread = CreateThread (NULL, 0, alerter, mainthread, 0, &id);
    if (!alertthread) {
       printf ("Failed to create alerting thread %x\n", GetLastError ());
       exit (EXIT_FAILURE);
    }
//    status = NtSuspendThread (changethread, &tmp);
//    if (!NT_SUCCESS (status)) {
//       printf ("NtSuspendThread failed %x\n", status);
//    }
//    status = NtSuspendThread (randthread, &tmp);
//    if (!NT_SUCCESS (status)) {
//       printf ("NtSuspendThread failed %x\n", status);
//    }
    if (!VirtualProtect (bigbuf, 1, PAGE_READWRITE, &old)) {
       printf ("VirtualProtect failed %d\n", GetLastError ());
    }

    devscount = 0;
    print_diags (0, 0);
    if (flags&FLAGS_DO_GRAB) {
       do_handle_grab (devmap,
                       &devscount);
    }

    /*
     * Crash the system.
     */
    if (name.Length > 0) {
       if (flags&FLAGS_DO_IMPERSONATION) {
           Impersonate_nonadmin ();
       }
 
       status = do_device_opens (NULL,
                                 &name,
                                 devmap,
                                 &devscount,
                                 name.Buffer,
                                 name.Buffer);

       if (flags&FLAGS_DO_IMPERSONATION) {
          if (!Revert_from_admin ()) {
             printf ("Revert_from_admin failed %d\n", GetLastError ());
             exit (EXIT_FAILURE);
          }
       }
    } else {
       do_wmi ();

       random_device = (rand () % 1345) + 1;

       while (1) {

           RtlInitUnicodeString(&us,
                                 L"\\");

           skipped = 0;
           recurse(0,
                    &us,
                    devmap,
                    &devscount,
                    L"",
                    1);

           for (i = 0; i < devscount; i++) {
               free (devmap[i].name);
               devmap[i].name = NULL;
               free (devmap[i].filename);
               devmap[i].filename = NULL;
               NtClose(devmap[i].handle);
           }
           devscount = 0;
           if (flags&(FLAGS_DO_ALLDEVS|FLAGS_DO_PRINT_DEVS)) {
              break;
           }
           if ((flags&FLAGS_DO_RANDOM_DEVICE) && (random_device == 0)) {
              Sleep (30*1000);
              random_device = (rand () % 1345) + 1;
           }
       }
    }
    if ((flags&FLAGS_DO_PRINT_DEVS) == 0) {
        crashes (L"DONE", L"", L"", L"", L"");
    }

    exit(EXIT_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\dmpobj\dmpobj.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dmpobj.c

Abstract:

    This program reads the contents of a specific section from an OBJ
    and emits its contents as a C-compatible UCHAR array.

Author:

    Forrest Foltz (forrestf) 06-Mar-2001

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

ULONG FileSize;

VOID
Usage(VOID) {

    fprintf(stderr,"\n"
                   "DMPOBJ reads the contents of a specific section from\n"
                   "an OBJ image and emits its contents as a c-compatible\n"
                   "UCHAR array.\n\n"
                   "Usage: DMPOBJ <source> <secnam> <varnam>\n"
                   "where: <source> is the full path of the .obj file\n\n"
                   "       <secnam> is the name of the section to emit\n"
                   "                Use ENTIRE_FILE to dump the whole thing\n\n"
                   "       <varnam> is the name to assign to the array\n");

    exit(1);
}

BOOLEAN
OpenFileImage(
    IN PCHAR FilePath,
    OUT HANDLE *FileHandle,
    OUT PCHAR *FileImage
    )
{
    HANDLE fileHandle;
    HANDLE mapHandle;
    PVOID view;

    fileHandle = CreateFile( FilePath,
                             GENERIC_READ,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    FileSize = GetFileSize( fileHandle, NULL );


    mapHandle = CreateFileMapping( fileHandle,
                                   NULL,
                                   PAGE_READONLY,
                                   0,
                                   0,
                                   NULL );
    CloseHandle(fileHandle);
    if (mapHandle == NULL) {
        return FALSE;
    }

    view = MapViewOfFile( mapHandle,
                          FILE_MAP_READ,
                          0,
                          0,
                          0 );

    if (view == NULL) {
        CloseHandle(mapHandle);
        return FALSE;
    }

    *FileHandle = mapHandle;
    *FileImage = view;

    return TRUE;
}

int
__cdecl
main (
    int argc,
    char *argv[]
    )
{
    HANDLE mapHandle;
    PCHAR view;
    BOOLEAN result;

    PCHAR inputPath;
    PCHAR sectionName;
    PCHAR arrayName;

    ULONG numberOfSections;
    ULONG section;

    PIMAGE_FILE_HEADER imageHeader;
    PIMAGE_SECTION_HEADER sectionHeader;
    PIMAGE_SECTION_HEADER indexHeader;

    PUCHAR data;
    PUCHAR dataEnd;

    ULONG column;

    BOOLEAN entireFile;
    ULONG dumpSize;

    if (argc != 4) {
        Usage();
    }

    //
    // Get the user-supplied parameters and open the input image
    //

    inputPath = argv[1];
    sectionName = argv[2];
    arrayName = argv[3];

    result = OpenFileImage( inputPath, &mapHandle, &view );
    if (result == FALSE) {
        fprintf(stderr, "DMPOBJ: could not open file %s for reading.\n");
        exit(1);
    }

    //
    // Find the desired section.  It is is a fatal error to specify a
    // section name that appears in more than one section.
    //

    if (strcmp("ENTIRE_FILE", sectionName) == 0) {

        data = view;
        dumpSize = FileSize;

    } else {

        imageHeader = (PIMAGE_FILE_HEADER)view;
        numberOfSections = imageHeader->NumberOfSections;
    
        indexHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)(imageHeader + 1) +
                      imageHeader->SizeOfOptionalHeader);
    
        sectionHeader = NULL;
        for (section = 0; section < numberOfSections; section += 1) {
    
            if (strncmp(indexHeader->Name,
                        sectionName,
                        IMAGE_SIZEOF_SHORT_NAME) == 0) {
    
                if (sectionHeader != NULL) {
                    fprintf(stderr,
                            "DMPOBJ: multiple instances of section %s "
                            "found in image %s\n",
                            sectionName,
                            inputPath);
                    exit(1);
                }
    
                sectionHeader = indexHeader;
            }
    
            indexHeader += 1;
        }
    
        if (sectionHeader == NULL) {
    
            fprintf(stderr,
                    "DMPOBJ: could not find section %s in image %s\n",
                    sectionName,
                    inputPath);
            exit(1);
        }
    
        data = view + sectionHeader->PointerToRawData;
        dumpSize = sectionHeader->SizeOfRawData;
    }

    //
    // Dump the contents of the section in a format compatible with a
    // C language compiler.
    // 

    fprintf(stdout, "//\n");
    fprintf(stdout, "// DMPOBJ generated file, DO NOT EDIT\n");
    fprintf(stdout, "//\n");
    fprintf(stdout, "// Source:  %s\n", inputPath);
    fprintf(stdout, "// Section: %s\n", sectionName);
    fprintf(stdout, "//\n");
    fprintf(stdout, "\n");

    fprintf(stdout, "const char %s[] = {\n    ",arrayName);

    column = 0;

    dataEnd = data + dumpSize;
    while (data < dataEnd) {

        if (column == 12) {
            fprintf(stdout, "\n    ");
            column = 0;
        }

        fprintf(stdout, "0x%02x", *data);

        if (data < (dataEnd - 1)) {
            fprintf(stdout, ", ");
        }

        column += 1;
        data += 1;
    }

    fprintf(stdout, "\n};\n\n");

    fprintf(stdout,
            "#define %sSize 0x%0x\n\n",
            arrayName,
            dumpSize);

    CloseHandle(mapHandle);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\gs_support\gs_support.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

   gs_support.c

Abstract:

    This module contains the support for the compiler /GS switch

Author:

    Bryan Tuttle (bryant) 01-aug-2000

Revision History:
    Initial version copied from CRT source.  Code must be generic to link into
    usermode or kernemode.  Limited to calling ntdll/ntoskrnl exports or using
    shared memory data.

--*/

#include <nt.h>
#include <ntrtl.h>

DWORD_PTR __security_cookie;

typedef void (__cdecl * failure_report_function)(void);
static failure_report_function user_handler;

void __cdecl __security_init_cookie(void)
{
    __security_cookie = NtGetTickCount() ^ (DWORD_PTR)&__security_cookie;
}

#pragma data_seg(".CRT$XCC")
void (__cdecl *pSecCookieInit)(void) = __security_init_cookie;
#pragma data_seg()

void __cdecl __report_gsfailure(void)
{
    DbgPrint("Stack overwrite detected\n");
    if (user_handler != NULL) {
        __try {
            user_handler();
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }
    DbgBreakPoint();
}

#ifndef _X86_
void __fastcall __security_check_cookie(DWORD_PTR cookie)
{
    /* Immediately return if the local cookie is OK. */
    if (cookie == __security_cookie)
        return;

    /* Report the failure */
    __report_gsfailure();
}

#else

void __declspec(naked) __fastcall __security_check_cookie(DWORD_PTR cookie)
{
    /* x86 version written in asm to preserve all regs */
    __asm {
        cmp ecx, __security_cookie
        jne failure
        ret
failure:
        jmp __report_gsfailure
    }
}

#endif

failure_report_function __cdecl __set_buffer_overrun_handler(failure_report_function handler)
{
    failure_report_function old_handler;

    old_handler = user_handler;
    user_handler = handler;

    return old_handler;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\compinst.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    showinst.c

Abstract:

    This program compares the actions described by two Installation Modification Log file
    created by the INSTALER program

Author:

    Steve Wood (stevewo) 15-Jan-1996

Revision History:

--*/

#include "instutil.h"
#include "iml.h"

BOOLEAN VerboseOutput;

BOOLEAN
CompareIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml1,
    PINSTALLATION_MODIFICATION_LOGFILE pIml2
    );

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    char *s;
    PWSTR ImlPathAlt = NULL;
    PINSTALLATION_MODIFICATION_LOGFILE pIml1 = NULL;
    PINSTALLATION_MODIFICATION_LOGFILE pIml2 = NULL;

    InitCommonCode( "COMPINST",
                    "InstallationName2 [-v]",
                    "-v verbose output\n"
                  );
    VerboseOutput = FALSE;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'v':
                        VerboseOutput = TRUE;
                        break;
                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                        break;
                    }
                }
            }
        else
        if (!CommonArgProcessing( &argc, &argv )) {
            if (ImlPathAlt != NULL) {
                Usage( "Too many installation names specified - '%s'", (ULONG)s );
                }

            ImlPathAlt = FormatImlPath( InstalerDirectory, GetArgAsUnicode( s ) );
            }
        }

    if (ImlPath == NULL || ImlPathAlt == NULL) {
        Usage( "Must specify two installation names to compare", 0 );
        }

    if (!SetCurrentDirectory( InstalerDirectory )) {
        FatalError( "Unable to change to '%ws' directory (%u)",
                    (ULONG)InstalerDirectory,
                    GetLastError()
                  );
        }

    pIml1 = LoadIml( ImlPath );
    if (pIml1 == NULL) {
        FatalError( "Unable to load '%ws' (%u)",
                    (ULONG)ImlPath,
                    GetLastError()
                  );
        }

    pIml2 = LoadIml( ImlPathAlt );
    if (pIml2 == NULL) {
        FatalError( "Unable to load '%ws' (%u)",
                    (ULONG)ImlPathAlt,
                    GetLastError()
                  );
        }

    printf( "Displaying differences between:\n" );
    printf( "   Installation 1: %ws\n", ImlPath );
    printf( "   Installation 2: %ws\n", ImlPathAlt );
    exit( CompareIml( pIml1, pIml2 ) == FALSE );
    return 0;
}

typedef struct _IML_GENERIC_RECORD {
    POFFSET Next;                   // IML_GENERIC_RECORD
    ULONG Action;
    POFFSET Name;                   // WCHAR
    POFFSET Records;                // IML_GENERIC_RECORD
} IML_GENERIC_RECORD, *PIML_GENERIC_RECORD;


typedef
VOID
(*PIML_PRINT_RECORD_ROUTINE)(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    PIML_GENERIC_RECORD pGeneric,
    PWSTR Parents[],
    ULONG Depth,
    ULONG i
    );

typedef
BOOLEAN
(*PIML_COMPARE_CONTENTS_ROUTINE)(
    PINSTALLATION_MODIFICATION_LOGFILE pIml1,
    PIML_GENERIC_RECORD pGeneric1,
    PINSTALLATION_MODIFICATION_LOGFILE pIml2,
    PIML_GENERIC_RECORD pGeneric2,
    PWSTR Parents[]
    );


PINSTALLATION_MODIFICATION_LOGFILE pSortIml;

int
__cdecl
CompareGeneric(
    const void *Reference1,
    const void *Reference2
    )
{
    PIML_GENERIC_RECORD p1 = *(PIML_GENERIC_RECORD *)Reference1;
    PIML_GENERIC_RECORD p2 = *(PIML_GENERIC_RECORD *)Reference2;

    if (p1->Name == 0) {
        if (p2->Name == 0) {
            return 0;
            }
        else {
            return -1;
            }
        }
    else
    if (p2->Name == 0) {
        return 1;
        }

    return _wcsicmp( MP( PWSTR, pSortIml, p1->Name ),
                     MP( PWSTR, pSortIml, p2->Name )
                   );
}


PIML_GENERIC_RECORD *
GetSortedGenericListAsArray(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    PIML_GENERIC_RECORD pGeneric
    )
{
    PIML_GENERIC_RECORD p, *pp;
    ULONG n;

    p = pGeneric;
    n = 1;
    while (p != NULL) {
        n += 1;
        p = MP( PIML_GENERIC_RECORD, pIml, p->Next );
        }

    pp = HeapAlloc( GetProcessHeap(), 0, n * sizeof( *pp ) );
    if (pp == NULL) {
        printf ("Memory allocation failure\n");
        ExitProcess (0);
    }
    p = pGeneric;
    n = 0;
    while (p != NULL) {
        pp[ n++ ] = p;
        p = MP( PIML_GENERIC_RECORD, pIml, p->Next );
        }
    pp[ n ] = NULL;

    pSortIml = pIml;
    qsort( (void *)pp, n, sizeof( *pp ), CompareGeneric );
    pSortIml = NULL;
    return pp;
}

BOOLEAN
CompareGenericIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml1,
    PIML_GENERIC_RECORD pGeneric1,
    PINSTALLATION_MODIFICATION_LOGFILE pIml2,
    PIML_GENERIC_RECORD pGeneric2,
    PWSTR Parents[],
    ULONG Depth,
    PIML_PRINT_RECORD_ROUTINE PrintRecordRoutine,
    PIML_COMPARE_CONTENTS_ROUTINE CompareContentsRoutine
    )
{
    PVOID pBufferToFree1;
    PVOID pBufferToFree2;
    PIML_GENERIC_RECORD *ppGeneric1;
    PIML_GENERIC_RECORD *ppGeneric2;
    PIML_GENERIC_RECORD pShow1;
    PIML_GENERIC_RECORD pShow2;
    BOOLEAN Result = FALSE;
    PWSTR s1, s2;
    int cmpResult;

    ppGeneric1 = GetSortedGenericListAsArray( pIml1, pGeneric1 );
    if (ppGeneric1 == NULL) {
        return FALSE;
        }
    pBufferToFree1 = ppGeneric1;

    ppGeneric2 = GetSortedGenericListAsArray( pIml2, pGeneric2 );
    if (ppGeneric2 == NULL) {
        HeapFree( GetProcessHeap(), 0, pBufferToFree1 );
        return FALSE;
        }
    pBufferToFree2 = ppGeneric2;

    pGeneric1 = *ppGeneric1++;
    pGeneric2 = *ppGeneric2++;

    while (TRUE) {
        pShow1 = NULL;
        pShow2 = NULL;
        if (pGeneric1 == NULL) {
            if (pGeneric2 == NULL) {
                break;
                }

            //
            // pGeneric2 is new
            //

            pShow2 = pGeneric2;
            pGeneric2 = *ppGeneric2++;
            Result = FALSE;
            }
        else
        if (pGeneric2 == NULL) {
            //
            // pGeneric1 is new
            //
            pShow1 = pGeneric1;
            pGeneric1 = *ppGeneric1++;
            Result = FALSE;
            }
        else {
            s1 = MP( PWSTR, pIml1, pGeneric1->Name );
            s2 = MP( PWSTR, pIml2, pGeneric2->Name );

            if (s1 == NULL) {
                if (s2 == NULL) {
                    cmpResult = 0;
                    }
                else {
                    cmpResult = -1;
                    }
                }
            else
            if (s2 == NULL) {
                cmpResult = 1;
                }
            else {
                cmpResult = _wcsicmp( s1, s2 );
                }
            if (cmpResult == 0) {
                if (Depth > 1) {
                    Parents[ Depth - 1 ] = MP( PWSTR, pIml1, pGeneric1->Name );
                    Result = CompareGenericIml( pIml1,
                                                MP( PIML_GENERIC_RECORD, pIml1, pGeneric1->Records ),
                                                pIml2,
                                                MP( PIML_GENERIC_RECORD, pIml2, pGeneric2->Records ),
                                                Parents,
                                                Depth - 1,
                                                PrintRecordRoutine,
                                                CompareContentsRoutine
                                              );
                    }
                else {
                    Result = (*CompareContentsRoutine)( pIml1, pGeneric1,
                                                        pIml2, pGeneric2,
                                                        Parents
                                                      );
                    }

                pGeneric1 = *ppGeneric1++;
                pGeneric2 = *ppGeneric2++;
                }
            else
            if (cmpResult > 0) {
                pShow2 = pGeneric2;
                pGeneric2 = *ppGeneric2++;
                }
            else {
                pShow1 = pGeneric1;
                pGeneric1 = *ppGeneric1++;
                }
            }

        if (pShow1) {
            (*PrintRecordRoutine)( pIml1, pShow1, Parents, Depth, 1 );
            }

        if (pShow2) {
            (*PrintRecordRoutine)( pIml2, pShow2, Parents, Depth, 2 );
            }
        }

    HeapFree( GetProcessHeap(), 0, pBufferToFree1 );
    HeapFree( GetProcessHeap(), 0, pBufferToFree2 );
    return Result;
}


char *FileActionStrings[] = {
    "CreateNewFile",
    "ModifyOldFile",
    "DeleteOldFile",
    "RenameOldFile",
    "ModifyFileDateTime",
    "ModifyFileAttributes"
};


PWSTR
FormatFileTime(
    LPFILETIME LastWriteTime
    )
{
    FILETIME LocalFileTime;
    SYSTEMTIME DateTime;
    static WCHAR DateTimeBuffer[ 128 ];

    FileTimeToLocalFileTime( LastWriteTime, &LocalFileTime );
    FileTimeToSystemTime( &LocalFileTime, &DateTime );

    _snwprintf( DateTimeBuffer,
                128,
                L"%02u/%02u/%04u %02u:%02u:%02u",
                (ULONG)DateTime.wMonth,
                (ULONG)DateTime.wDay,
                (ULONG)DateTime.wYear,
                (ULONG)DateTime.wHour,
                (ULONG)DateTime.wMinute,
                (ULONG)DateTime.wSecond
              );

    return DateTimeBuffer;
}


VOID
PrintFileRecordIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    PIML_GENERIC_RECORD pGeneric,
    PWSTR Parents[],
    ULONG Depth,
    ULONG i
    )
{
    PIML_FILE_RECORD pFile = (PIML_FILE_RECORD)pGeneric;

    printf( "File: %ws\n    %u: %s\n",
            MP( PWSTR, pIml, pFile->Name ),
            i, FileActionStrings[ pFile->Action ]
          );
}

BOOLEAN
CompareFileContentsIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml1,
    PIML_GENERIC_RECORD pGeneric1,
    PINSTALLATION_MODIFICATION_LOGFILE pIml2,
    PIML_GENERIC_RECORD pGeneric2,
    PWSTR Parents[]
    )
{
    PIML_FILE_RECORD pFile1 = (PIML_FILE_RECORD)pGeneric1;
    PIML_FILE_RECORD pFile2 = (PIML_FILE_RECORD)pGeneric2;
    PIML_FILE_RECORD_CONTENTS pFileContents1;
    PIML_FILE_RECORD_CONTENTS pFileContents2;
    BOOLEAN ActionsDiffer = FALSE;
    BOOLEAN DatesDiffer = FALSE;
    BOOLEAN AttributesDiffer = FALSE;
    BOOLEAN SizesDiffer = FALSE;
    BOOLEAN ContentsDiffer = FALSE;
    BOOLEAN Result = TRUE;
    PCHAR s1, s2;
    ULONG n;

    pFileContents1 = MP( PIML_FILE_RECORD_CONTENTS, pIml1, pFile1->NewFile );
    pFileContents2 = MP( PIML_FILE_RECORD_CONTENTS, pIml2, pFile2->NewFile );

    if (pFile1->Action != pFile2->Action) {
        ActionsDiffer = TRUE;
        Result = FALSE;
        }
    else
    if (pFileContents1 != NULL && pFileContents2 != NULL) {
        if (pFile1->Action != CreateNewFile &&
            ((pFileContents1->LastWriteTime.dwHighDateTime !=
              pFileContents2->LastWriteTime.dwHighDateTime
             ) ||
             (pFileContents1->LastWriteTime.dwLowDateTime !=
              pFileContents2->LastWriteTime.dwLowDateTime
             )
            )
           ) {
            DatesDiffer = TRUE;
            Result = FALSE;
            }

        if (pFileContents1->FileAttributes != pFileContents2->FileAttributes) {
            AttributesDiffer = TRUE;
            Result = FALSE;
            }

        if (pFileContents1->FileSize != pFileContents2->FileSize) {
            SizesDiffer = TRUE;
            Result = FALSE;
            }
        else
        if (pFileContents1->Contents == 0 ||
            pFileContents2->Contents == 0 ||
            memcmp( MP( PVOID, pIml1, pFileContents1->Contents ),
                    MP( PVOID, pIml2, pFileContents2->Contents ),
                    pFileContents1->FileSize
                  ) != 0
           ) {
            s1 = MP( PVOID, pIml1, pFileContents1->Contents );
            s2 = MP( PVOID, pIml2, pFileContents2->Contents );
            if (s1 == NULL || s2 == NULL) {
                n = 0;
                }
            else {
                n = pFileContents1->FileSize;
                }
            while (n) {
                if (*s1 != *s2) {
                    n = pFileContents1->FileSize - n;
                    break;
                    }

                n -= 1;
                s1 += 1;
                s2 += 1;
                }

            ContentsDiffer = TRUE;
            Result = FALSE;
            }
        }

    if (!Result) {
        printf( "File: %ws\n", MP( PWSTR, pIml1, pFile1->Name ) );
        if (ActionsDiffer) {
            printf( "    1: Action - %s\n", FileActionStrings[ pFile1->Action ] );
            printf( "    2: Action - %s\n", FileActionStrings[ pFile2->Action ] );
            }
        if (DatesDiffer) {
            printf( "    1: LastWriteTime - %ws\n",
                    FormatFileTime( &pFileContents1->LastWriteTime )
                  );
            printf( "    2: LastWriteTime - %ws\n",
                    FormatFileTime( &pFileContents2->LastWriteTime )
                  );
            }
        if (AttributesDiffer) {
            printf( "    1: Attributes - 0x%08x\n", pFileContents1->FileAttributes );
            printf( "    2: Attributes - 0x%08x\n", pFileContents2->FileAttributes );
            }
        if (SizesDiffer) {
            printf( "    1: File Size - 0x%08x\n", pFileContents1->FileSize );
            printf( "    2: File Size - 0x%08x\n", pFileContents2->FileSize );
            }
        if (ContentsDiffer) {
            printf( "    1: Contents Differs\n" );
            printf( "    2: from each other at offset %08x\n", n );
            }
        }

    return Result;
}


char *KeyActionStrings[] = {
    "CreateNewKey",
    "DeleteOldKey",
    "ModifyKeyValues"
};

char *ValueActionStrings[] = {
    "CreateNewValue",
    "DeleteOldValue",
    "ModifyOldValue"
};


char *ValueTypeStrings[] = {
    "REG_NONE",
    "REG_SZ",
    "REG_EXPAND_SZ",
    "REG_BINARY",
    "REG_DWORD",
    "REG_DWORD_BIG_ENDIAN",
    "REG_LINK",
    "REG_MULTI_SZ",
    "REG_RESOURCE_LIST",
    "REG_FULL_RESOURCE_DESCRIPTOR",
    "REG_RESOURCE_REQUIREMENTS_LIST"
};

VOID
PrintKeyValueRecordIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    PIML_GENERIC_RECORD pGeneric,
    PWSTR Parents[],
    ULONG Depth,
    ULONG i
    )
{
    PIML_KEY_RECORD pKey = (PIML_KEY_RECORD)pGeneric;
    PIML_VALUE_RECORD pValue = (PIML_VALUE_RECORD)pGeneric;

    if (Depth == 2) {
        printf( "Key: %ws\n    %u: %s\n",
                MP( PWSTR, pIml, pKey->Name ),
                i, KeyActionStrings[ pKey->Action ]
              );
        }
    else {
        if (Parents[ 1 ] != NULL) {
            printf( "Key: %ws\n", Parents[ 1 ] );
            Parents[ 1 ] = NULL;
            }

        printf( "    Value: %ws\n        %u: %s\n",
                MP( PWSTR, pIml, pValue->Name ),
                i, ValueActionStrings[ pValue->Action ]
              );
        }
}

UCHAR BlanksForPadding[] =
    "                                                                                  ";

VOID
PrintValueContents(
    PCHAR PrefixString,
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    PIML_VALUE_RECORD_CONTENTS pValueContents
    )
{
    ULONG ValueType;
    ULONG ValueLength;
    PVOID ValueData;
    ULONG cbPrefix, cb, i, j;
    PWSTR pw;
    PULONG p;

    ValueType = pValueContents->Type;
    ValueLength = pValueContents->Length;
    ValueData = MP( PVOID, pIml, pValueContents->Data );

    cbPrefix = printf( "%s", PrefixString );
    cb = cbPrefix + printf( "%s", ValueTypeStrings[ ValueType ] );

    switch( ValueType ) {
    case REG_SZ:
    case REG_LINK:
    case REG_EXPAND_SZ:
        pw = (PWSTR)ValueData;
        printf( " (%u) \"%.*ws\"\n", ValueLength, ValueLength/sizeof(WCHAR), pw );
        break;

    case REG_MULTI_SZ:
        pw = (PWSTR)ValueData;
        i  = 0;
        if (*pw)
        while (i < (ValueLength - 1) / sizeof( WCHAR )) {
            if (i > 0) {
                printf( " \\\n%.*s", cbPrefix, BlanksForPadding );
                }
            printf( "\"%ws\" ", pw+i );
            do {
                ++i;
                }
            while (pw[i] != UNICODE_NULL);

            ++i;
            }
        printf( "\n" );
        break;

    case REG_DWORD:
    case REG_DWORD_BIG_ENDIAN:
        printf( " 0x%08x\n", *(PULONG)ValueData );
        break;

    case REG_RESOURCE_LIST:
    case REG_FULL_RESOURCE_DESCRIPTOR:
    case REG_RESOURCE_REQUIREMENTS_LIST:
    case REG_BINARY:
    case REG_NONE:
        cb = printf( " [0x%08lx]", ValueLength );

        if (ValueLength != 0) {
            p = (PULONG)ValueData;
            i = (ValueLength + 3) / sizeof( ULONG );
            for (j=0; j<i; j++) {
                if ((cbPrefix + cb + 11) > 78) {
                    printf( " \\\n%.*s", cbPrefix, BlanksForPadding );
                    cb = 0;
                    }
                else {
                    cb += printf( " " );
                    }

                cb += printf( "0x%08lx", *p++ );
                }
            }

        printf( "\n" );
        break;
    }
}

BOOLEAN
CompareKeyValueContentsIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml1,
    PIML_GENERIC_RECORD pGeneric1,
    PINSTALLATION_MODIFICATION_LOGFILE pIml2,
    PIML_GENERIC_RECORD pGeneric2,
    PWSTR Parents[]
    )
{
    PIML_VALUE_RECORD pValue1 = (PIML_VALUE_RECORD)pGeneric1;
    PIML_VALUE_RECORD pValue2 = (PIML_VALUE_RECORD)pGeneric2;
    PIML_VALUE_RECORD_CONTENTS pValueContents1;
    PIML_VALUE_RECORD_CONTENTS pValueContents2;
    BOOLEAN ActionsDiffer = FALSE;
    BOOLEAN TypesDiffer = FALSE;
    BOOLEAN LengthsDiffer = FALSE;
    BOOLEAN ContentsDiffer = FALSE;
    BOOLEAN Result = TRUE;
    PCHAR s1, s2;
    ULONG n;

    pValueContents1 = MP( PIML_VALUE_RECORD_CONTENTS, pIml1, pValue1->NewValue );
    pValueContents2 = MP( PIML_VALUE_RECORD_CONTENTS, pIml2, pValue2->NewValue );

    if (pValue1->Action != pValue2->Action) {
        ActionsDiffer = TRUE;
        Result = FALSE;
        }
    else
    if (pValueContents1 != NULL && pValueContents2 != NULL) {
        if (pValue1->Action != CreateNewValue &&
            (pValueContents1->Type != pValueContents2->Type)
           ) {
            TypesDiffer = TRUE;
            Result = FALSE;
            }

        if (pValueContents1->Length != pValueContents2->Length) {
            LengthsDiffer = TRUE;
            Result = FALSE;
            }
        else
        if (pValueContents1->Data == 0 ||
            pValueContents2->Data == 0 ||
            memcmp( MP( PVOID, pIml1, pValueContents1->Data ),
                    MP( PVOID, pIml2, pValueContents2->Data ),
                    pValueContents1->Length
                  ) != 0
           ) {
            s1 = MP( PVOID, pIml1, pValueContents1->Data );
            s2 = MP( PVOID, pIml2, pValueContents2->Data );
            if (s1 == NULL || s2 == NULL) {
                n = 0;
                }
            else {
                n = pValueContents1->Length;
                }
            while (n) {
                if (*s1 != *s2) {
                    n = pValueContents1->Length - n;
                    break;
                    }

                n -= 1;
                s1 += 1;
                s2 += 1;
                }

            ContentsDiffer = TRUE;
            Result = FALSE;
            }
        }

    if (!Result) {
        if (Parents[ 2 ] != NULL) {
            printf( "Key: %ws\n", Parents[ 2 ] );
            Parents[ 2 ] = NULL;
            }

        printf( "    Value: %ws\n", MP( PWSTR, pIml1, pValue1->Name ) );
        if (ActionsDiffer) {
            printf( "        1: Action - %s\n", ValueActionStrings[ pValue1->Action ] );
            printf( "        2: Action - %s\n", ValueActionStrings[ pValue2->Action ] );
            }
        if (TypesDiffer || LengthsDiffer || ContentsDiffer ) {
            PrintValueContents( "        1: ", pIml1, pValueContents1 );
            PrintValueContents( "        2: ", pIml2, pValueContents2 );
            }
        }

    return Result;
}


char *IniActionStrings[] = {
    "CreateNewIniFile",
    "ModifyOldIniFile"
};

char *SectionActionStrings[] = {
    "CreateNewSection",
    "DeleteOldSection",
    "ModifySectionVariables"
};

char *VariableActionStrings[] = {
    "CreateNewVariable",
    "DeleteOldVariable",
    "ModifyOldVariable"
};

VOID
PrintIniSectionVariableRecordIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    PIML_GENERIC_RECORD pGeneric,
    PWSTR Parents[],
    ULONG Depth,
    ULONG i
    )
{
    PIML_INI_RECORD pIni = (PIML_INI_RECORD)pGeneric;
    PIML_INISECTION_RECORD pSection = (PIML_INISECTION_RECORD)pGeneric;
    PIML_INIVARIABLE_RECORD pVariable = (PIML_INIVARIABLE_RECORD)pGeneric;

    if (Depth == 3) {
        printf( "Ini File: %ws\n    %u: %s\n",
                MP( PWSTR, pIml, pIni->Name ),
                i, IniActionStrings[ pIni->Action ]
              );
        }
    else
    if (Depth == 2) {
        if (Parents[ 2 ] != NULL) {
            printf( "Ini File: %ws\n", Parents[ 2 ] );
            Parents[ 2 ] = NULL;
            }

        printf( "    Section: %ws\n    %u: %s\n",
                MP( PWSTR, pIml, pSection->Name ),
                i, SectionActionStrings[ pSection->Action ]
              );
        }
    else {
        if (Parents[ 2 ] != NULL) {
            printf( "Ini File: %ws\n", Parents[ 2 ] );
            Parents[ 2 ] = NULL;
            }

        if (Parents[ 1 ] != NULL) {
            printf( "    Section: %ws\n", Parents[ 1 ] );
            Parents[ 1 ] = NULL;
            }

        printf( "        Variable: %ws\n            %u: %s\n",
                MP( PWSTR, pIml, pVariable->Name ),
                i, VariableActionStrings[ pVariable->Action ]
              );
        }
}

BOOLEAN
CompareIniSectionVariableContentsIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml1,
    PIML_GENERIC_RECORD pGeneric1,
    PINSTALLATION_MODIFICATION_LOGFILE pIml2,
    PIML_GENERIC_RECORD pGeneric2,
    PWSTR Parents[]
    )
{
    PIML_INIVARIABLE_RECORD pVariable1 = (PIML_INIVARIABLE_RECORD)pGeneric1;
    PIML_INIVARIABLE_RECORD pVariable2 = (PIML_INIVARIABLE_RECORD)pGeneric2;
    PWSTR  pVariableContents1;
    PWSTR  pVariableContents2;
    BOOLEAN ActionsDiffer = FALSE;
    BOOLEAN ContentsDiffer = FALSE;
    BOOLEAN Result = TRUE;

    pVariableContents1 = MP( PWSTR, pIml1, pVariable1->NewValue );
    pVariableContents2 = MP( PWSTR, pIml2, pVariable2->NewValue );

    if (pVariable1->Action != pVariable2->Action) {
        ActionsDiffer = TRUE;
        Result = FALSE;
        }
    else
    if (pVariableContents1 != NULL && pVariableContents2 != NULL) {
        if (wcscmp( pVariableContents1, pVariableContents2 ) != 0) {
            ContentsDiffer = TRUE;
            Result = FALSE;
            }
        }

    if (!Result) {
        if (Parents[ 2 ] != NULL) {
            printf( "Ini File: %ws\n", Parents[ 2 ] );
            Parents[ 2 ] = NULL;
            }

        if (Parents[ 1 ] != NULL) {
            printf( "    Section: %ws\n", Parents[ 1 ] );
            Parents[ 1 ] = NULL;
            }

        printf( "        Variable: %ws\n", MP( PWSTR, pIml1, pVariable1->Name ) );
        if (ActionsDiffer) {
            printf( "            1: Action - %s\n", VariableActionStrings[ pVariable1->Action ] );
            printf( "            2: Action - %s\n", VariableActionStrings[ pVariable2->Action ] );
            }
        if (ContentsDiffer) {
            printf( "            1: '%ws'\n", pVariableContents1 );
            printf( "            2: '%ws'\n", pVariableContents2 );
            }
        }

    return Result;
}




BOOLEAN
CompareIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml1,
    PINSTALLATION_MODIFICATION_LOGFILE pIml2
    )
{
    BOOLEAN Result = TRUE;
    PWSTR Parents[ 3 ];

    Result &= CompareGenericIml( pIml1, MP( PIML_GENERIC_RECORD, pIml1, pIml1->FileRecords ),
                                 pIml2, MP( PIML_GENERIC_RECORD, pIml2, pIml2->FileRecords ),
                                 NULL,
                                 1,
                                 PrintFileRecordIml,
                                 CompareFileContentsIml
                               );

    memset( Parents, 0, sizeof( Parents ) );
    Result &= CompareGenericIml( pIml1, MP( PIML_GENERIC_RECORD, pIml1, pIml1->KeyRecords ),
                                 pIml2, MP( PIML_GENERIC_RECORD, pIml2, pIml2->KeyRecords ),
                                 Parents,
                                 2,
                                 PrintKeyValueRecordIml,
                                 CompareKeyValueContentsIml
                               );

    memset( Parents, 0, sizeof( Parents ) );
    Result &= CompareGenericIml( pIml1, MP( PIML_GENERIC_RECORD, pIml1, pIml1->IniRecords ),
                                 pIml2, MP( PIML_GENERIC_RECORD, pIml2, pIml2->IniRecords ),
                                 Parents,
                                 3,
                                 PrintIniSectionVariableRecordIml,
                                 CompareIniSectionVariableContentsIml
                               );

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\genxx\genxx.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    genxx.c

Abstract:

    This module implements a program which generates structure offset
    definitions for kernel structures that are accessed in assembly code.

Author:

    Forrest C. Foltz (forrestf) 20-Jan-98


To use:

    This program reads an OBJ file generated by the target platform's
    compiler.

    To generate such an OBJ, go to ke\up and do a "nmake UMAPPL=gen<plt>",
    where <plt> is a platform identifier like i386, etc.

    All you need from this latter step is the OBJ, the link phase will not
    succeed which is fine.

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define SKIP_M4
#include <genxx.h>

//
// Internal structure definitions, macros, constants
//

#define ARRAY_SIZE( x ) (sizeof( x ) / sizeof( (x)[0] ))

typedef struct _OUTPUT_FILE *POUTPUT_FILE;
typedef struct _OUTPUT_FILE {
    POUTPUT_FILE Next;
    ULONG EnableMask;
    BOOLEAN IncFormat;
    FILE *File;
} OUTPUT_FILE;

//
// Function prototypes follow
//

VOID
ApplyFixupsToImage( VOID );

VOID
BuildHeaderFiles(
    STRUC_ELEMENT UNALIGNED *StrucArray
    );

VOID
__cdecl
CheckCondition(
    int Condition,
    const char *format,
    ...
    );

VOID
AddNewOutputFile(
    PUCHAR RootRelativePath,
    ULONG Flags
    );

VOID
AddNewAbsoluteOutputFile(
    PUCHAR AbsolutePath,
    ULONG Flags
    );

VOID
CloseOutputFiles( VOID );

VOID
_cdecl
HeaderPrint(
    ULONG EnableFlags,
    ULONG Type,
    ...
    );

PSTRUC_ELEMENT
FindStructureElementArray(
    PCHAR Buffer,
    ULONG BufferSize
    );

VOID
GetEnvironment( VOID );

PSTRUC_ELEMENT
LoadObjImage(
    PUCHAR ImagePath
    );

PCHAR
StripWhiteSpace(
    PCHAR String
    );

VOID
Usage( VOID );

//
// Constant tables follow
//

const char *PreprocessedFormatStringArray[] = {

    // SEF_EQUATE
    "#define %s 0x%0x\n",

    // SEF_EQUATE64
    "#define %s 0x%016I64x\n",

    // SEF_COMMENT
    "\n"
    "//\n"
    "// %s\n"
    "//\n"
    "\n",

    // SEF_STRING
    "%s\n",

    // SEF_BITFLD
    "#define %s_MASK  0x%I64x\n"
    "#define %s 0x%0x\n",

    // SEF_BITALIAS
    "#define %s 0x%0x\n",

    // SEF_STRUCTURE
    "struct %s {\n"
    "    UCHAR fill[ %d ];\n"
    "}; // %s\n"

};

const char *Asm386FormatStringArray[] = {

    // SEF_EQUATE
    "%s equ 0%04XH\n",

    // SEF_EQUATE64
    "%s equ 0%016I64XH\n",

    // SEF_COMMENT
    "\n"
    ";\n"
    ";  %s\n"
    ";\n"
    "\n",

    // SEF_STRING
    "%s",

    // SEF_BITFLD
    "%s_MASK  equ 0%I64XH\n"
    "%s equ 0%0XH\n",

    // SEF_BITALIAS
    "%s equ 0%08XH\n",

    // SEF_STRUCTURE
    "%s  struc\n"
    "  db %d dup(0)\n"
    "%s  ends\n"
};

//
// Each platform contains a list of generated header files.
//

typedef struct {
    PCHAR HeaderPath;
    ULONG Flags;
} HEADERPATH, *PHEADERPATH;

HEADERPATH HeaderListi386[] = {
    { "public\\sdk\\inc\\ks386.inc", SEF_KERNEL | SEF_INC_FORMAT },
    { "base\\ntos\\inc\\hal386.inc", SEF_HAL | SEF_INC_FORMAT },
    { NULL, 0 }
};

HEADERPATH HeaderListIa64[] = {
    { "public\\sdk\\inc\\ksia64.h", SEF_KERNEL | SEF_H_FORMAT },
    { "base\\ntos\\inc\\halia64.h", SEF_HAL | SEF_H_FORMAT },
    { NULL, 0 }
};

HEADERPATH HeaderListVdm[] = {
    { "public\\internal\\base\\inc\\vdmtib.inc", SEF_INC_FORMAT },
    { NULL, 0 }
};

HEADERPATH HeaderListAmd64[] = {
    { "public\\sdk\\inc\\ksamd64.inc", SEF_KERNEL | SEF_INC_FORMAT },
    { "base\\ntos\\inc\\halamd64.inc", SEF_HAL | SEF_INC_FORMAT },
    { NULL, 0 }
};

typedef struct {
    PCHAR PlatformName;
    PCHAR ObjPath;
    PHEADERPATH HeaderPathList;
} PLATFORM, *PPLATFORM;

PLATFORM PlatformList[] = {

    { "i386",
      "base\\ntos\\ke\\up\\obj\\i386\\geni386.obj",
      HeaderListi386 },

    { "ia64",
      "base\\ntos\\ke\\up\\obj\\ia64\\genia64.obj",
      HeaderListIa64 },

    { "vdm",
      "base\\ntos\\vdm\\up\\obj\\i386\\genvdm.obj",
      HeaderListVdm },

    { "amd64",
      "base\\ntos\\ke\\up\\obj\\amd64\\genamd64.obj",
      HeaderListAmd64 },

    { NULL, NULL, NULL }
};

const char MarkerString[] = MARKER_STRING;

//
// Global vars follow
//

POUTPUT_FILE OutputFileList;

PCHAR ObjImage;
CHAR HalHeaderPath[ MAX_PATH ];
CHAR KernelHeaderPath[ MAX_PATH ];
CHAR HeaderPath[ MAX_PATH ];
CHAR ObjectPath[ MAX_PATH ];
CHAR NtRoot[ MAX_PATH ];
CHAR TempBuf[ MAX_PATH ];
BOOL fOutputSpecified;
BOOL fHalHeaderPath;
BOOL fKernelHeaderPath;
BOOL fIncFormat;

//
// The actual code...
//

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    int argNum;
    char *arg;
    int platformIndex;
    int fileIndex;
    BOOL validSwitch;
    PSTRUC_ELEMENT strucArray;
    PPLATFORM platform;
    PHEADERPATH headerPath;

    GetEnvironment();

    //
    // Assume no platform specified, then see if we can find one.
    //

    ObjectPath[ 0 ] = '\0';
    for( argNum = 1; argNum < argc; argNum++ ){

        validSwitch = FALSE;

        arg = argv[ argNum ];
        if( *arg == '/' || *arg == '-' ){

            //
            // A switch was passed.  See what it is.
            //

            arg++;

            switch( *arg ){

            case 'o':

                //
                // Specified an output file
                //

                fOutputSpecified = TRUE;
                strcpy( HeaderPath, arg+1 );
                validSwitch = TRUE;
                break;

            case 's':

                //
                // Specified include file suffix (either 'h' or 'inc')
                //

                if( _stricmp( arg+1, "inc" ) == 0 ){

                    //
                    // We would like the "inc" format, thanks
                    //

                    fIncFormat = TRUE;

                } else {

                    CheckCondition( _stricmp( arg+1, "h" ) == 0,
                                    "Invalid suffix option: -s[inc|h]\n");
                }
                validSwitch = TRUE;
                break;

            case 'k':

                //
                // Kernel header path.  Save off.
                //
                fKernelHeaderPath = TRUE;
                strcpy( KernelHeaderPath, arg+1 );
                validSwitch = TRUE;
                break;

            case 'h':

                //
                // Hal header path.  Save off.
                //
                fHalHeaderPath = TRUE;
                strcpy( HalHeaderPath, arg+1 );
                validSwitch = TRUE;
                break;

            default:

                //
                // Check our platform list.
                //

                platform = PlatformList;
                while( platform->PlatformName != NULL ){

                    if( _stricmp( platform->PlatformName,
                                  arg ) == 0 ){

                        //
                        // Platform was specified, we will build the path to
                        // the obj.
                        //

                        sprintf( ObjectPath,
                                 "%s\\%s",
                                 NtRoot,
                                 platform->ObjPath );

                        //
                        // Add the header paths too.
                        //

                        headerPath = platform->HeaderPathList;
                        while( headerPath->HeaderPath != NULL ){

                            if (fHalHeaderPath && (headerPath->Flags & SEF_HAL)) {
                                strcpy(TempBuf, HalHeaderPath);
                                AddNewAbsoluteOutputFile( HalHeaderPath, headerPath->Flags );
                            } else
                            if (fKernelHeaderPath && (headerPath->Flags & SEF_KERNEL)) {
                                strcpy(TempBuf, KernelHeaderPath);
                                AddNewAbsoluteOutputFile( KernelHeaderPath, headerPath->Flags );
                            } else {
                                AddNewOutputFile( headerPath->HeaderPath,
                                                  headerPath->Flags );
                            }

                            headerPath++;
                        }

                        validSwitch = TRUE;
                        break;
                    }

                    platform++;
                }
                break;
            }

            if( validSwitch == FALSE ){
                Usage();
            }

        } else {

            //
            // We are dealing with something that is not a switch.  The only
            // possibility is the path to the object file.
            //

            strcpy( ObjectPath, arg );
        }
    }

    CheckCondition( ObjectPath[0] != '\0',
                    "Object path not specified\n" );

    if( fOutputSpecified != FALSE ){

        //
        // The output path was specified
        //

        AddNewAbsoluteOutputFile( HeaderPath,
                                  fIncFormat ? SEF_INC_FORMAT : SEF_H_FORMAT );
    }

    strucArray = LoadObjImage( ObjectPath );

    BuildHeaderFiles( strucArray );

    CloseOutputFiles();

    //
    // Indicate success.
    //

    return 0;
}

VOID
AddNewAbsoluteOutputFile(
    PUCHAR AbsolutePath,
    ULONG Flags
    )
{
    POUTPUT_FILE outputFile;

    outputFile = malloc( sizeof( OUTPUT_FILE ));
    CheckCondition( outputFile != NULL, "Out of memory\n" );

    outputFile->EnableMask = (ULONG)(Flags & SEF_ENABLE_MASK);

    if( (Flags & SEF_INC_FORMAT_MASK) == SEF_INC_FORMAT ){

        //
        // This file will be created in '.inc' format for the 386 assembler.
        //

        outputFile->IncFormat = TRUE;
    } else {

        //
        // This file will be created in '.h' format for the standard C
        // preprocessor.
        //

        outputFile->IncFormat = FALSE;
    }

    outputFile->File = fopen( AbsolutePath, "w" );
    CheckCondition( outputFile->File != NULL,
                    "Cannot open %s for writing.\n",
                    TempBuf );

    printf("%s -> %s\n", ObjectPath, TempBuf );

    //
    // Link this structure into the list of output files
    //

    outputFile->Next = OutputFileList;
    OutputFileList = outputFile;
}

VOID
AddNewOutputFile(
    PUCHAR RootRelativePath,
    ULONG Flags
    )
{
    //
    // Create the canonoical file path and open the file.
    //

    sprintf( TempBuf,
             "%s\\%s",
             NtRoot,
             RootRelativePath );

    AddNewAbsoluteOutputFile( TempBuf, Flags );
}

VOID
CloseOutputFiles( VOID )
{
    POUTPUT_FILE outputFile;

    outputFile = OutputFileList;
    while( outputFile != NULL ){

        fclose( outputFile->File );
        outputFile = outputFile->Next;
    }
}


PSTRUC_ELEMENT
LoadObjImage(
    PUCHAR ImagePath
    )
{
    long           objImageSize;
    int            result;
    PSTRUC_ELEMENT strucArray;
    FILE *         objFile;

    //
    // Open up and read the platform-specific .obj file.
    //

    objFile = fopen( ImagePath, "rb" );
    CheckCondition( objFile != NULL,
                    "Cannot open %s for reading.\n"
                    "This file must have been created by the compiler for the "
                    "target platform.\n",
                    ImagePath );

    //
    // Get the file size, allocate a buffer, read it in, and close.
    //

    result = fseek( objFile, 0, SEEK_END );
    CheckCondition( result == 0,
                    "fseek() failed, error %d\n",
                    errno );

    objImageSize = ftell( objFile );
    CheckCondition( objImageSize != -1L,
                    "ftell() failed, error %d\n",
                    errno );

    CheckCondition( objImageSize > 0,
                    "%s appears to be corrupt\n",
                    ImagePath );

    ObjImage = malloc( objImageSize );
    CheckCondition( ObjImage != NULL,
                    "Out of memory\n" );

    result = fseek( objFile, 0, SEEK_SET );
    CheckCondition( result == 0,
                    "fseek() failed, error %d\n",
                    errno );

    result = fread( ObjImage, 1, objImageSize, objFile );
    CheckCondition( result == objImageSize,
                    "Error reading from %s\n",
                    ImagePath );

    fclose( objFile );

    //
    // Even though this is just an .obj file, we want it "fixed up"
    //

    ApplyFixupsToImage();

    //
    // Got the image, find the beginning of the array.
    //

    strucArray = FindStructureElementArray( ObjImage,
                                            objImageSize );
    CheckCondition( strucArray != NULL,
                    "%s does not contain a structure description array.\n",
                    ImagePath );

    return strucArray;
}

VOID
BuildHeaderFiles(
    STRUC_ELEMENT UNALIGNED *StrucArray
    )
{
    STRUC_ELEMENT UNALIGNED *strucArray;
    ULONG          runningEnableMask;
    ULONG          enableMask;
    ULONG          sefType;
    const char    *formatString;
    ULONG          bitFieldStart;
    PUINT64        bitFieldPtr;
    UINT64         bitFieldData;
    PCHAR          name;
    BOOLEAN        finished;

    //
    // Process each element in the array.  The first element is the
    // marker string element, so it is skipped.
    //

    runningEnableMask = 0;
    finished = FALSE;
    strucArray = StrucArray;

    do{
        strucArray++;

        sefType = (ULONG)(strucArray->Flags & SEF_TYPE_MASK);

        if( sefType == SEF_BITFLD ){

            //
            // For bitfields, the enable mask is set explicitly
            //

            enableMask = (ULONG)(strucArray->Flags & SEF_ENABLE_MASK);

        } else {

            //
            // For everything else, we use the current runningEnableMask
            //

            enableMask = runningEnableMask;
        }

        switch( sefType ){

            case SEF_BITFLD:

                //
                // This kind of element is tricky.  "Equate" is actually a
                // pointer to a bitfield structure.  This structure has had
                // a portion of it (the bitfield) initialized to ones.
                //
                // It is the job of this case to poke around in that
                // structure in order to determine where the bitfield landed.
                //

                bitFieldPtr = (PINT64)(strucArray->Equate);
                bitFieldData = *bitFieldPtr;

                //
                // Determine the zero-based starting bitnumber of the field.
                //

                bitFieldStart = 0;
                while( (bitFieldData & ((UINT64)1 << bitFieldStart)) == 0 ){

                    bitFieldStart++;
                }

                name = StripWhiteSpace( strucArray->Name );

                if( *name != '\0'){

                    HeaderPrint( enableMask,
                                 sefType,
                                 name,
                                 bitFieldData,
                                 name,
                                 bitFieldStart );
                }

                //
                // A bitfield can be followed by any number of
                // SEF_BITALIAS entries.  These are alias names for the
                // bitmask that was just defined.
                //

                while( TRUE ){

                    sefType = (ULONG)((strucArray+1)->Flags & SEF_TYPE_MASK);
                    if( sefType != SEF_BITALIAS ){

                        //
                        // No more aliases.
                        //

                        break;
                    }

                    //
                    // This is a bitmask alias field, process it.
                    //

                    strucArray++;

                    name = StripWhiteSpace( strucArray->Name );

                    HeaderPrint( enableMask,
                                 sefType,
                                 name,
                                 bitFieldData );

                }
                break;

            case SEF_END:
                finished = TRUE;
                break;

            case SEF_EQUATE:

                if( (LONG64)strucArray->Equate < 0 ){

                    //
                    // Negative constant
                    //

                    if( (LONG64)strucArray->Equate < LONG_MIN ){

                        //
                        // More negative than can be represented in 32 bits
                        //

                        sefType = SEF_EQUATE64;

                    } else {

                        //
                        // Falls within [LONG_MIN..0], Leave as SEF_EQUATE32
                        //
                    }

                } else if( (ULONG64)strucArray->Equate > (ULONG_MAX) ){

                    //
                    // More positive than can be represented in 32 bits
                    //

                    sefType = SEF_EQUATE64;
                }

                //
                // Fall through
                //

            case SEF_EQUATE64:
            case SEF_COMMENT:
                HeaderPrint( enableMask,
                             sefType,
                             strucArray->Name,
                             (UINT64)strucArray->Equate );
                break;

            case SEF_STRING:
                HeaderPrint( enableMask,
                             sefType,
                             strucArray->Name,
                             strucArray->Equate );
                break;

            case SEF_STRUCTURE:
                HeaderPrint( enableMask,
                             sefType,
                             strucArray->Name,
                             (ULONG)strucArray->Equate,
                             strucArray->Name );
                break;

            case SEF_SETMASK:
                runningEnableMask |= strucArray->Equate;
                break;

            case SEF_CLRMASK:
                runningEnableMask &= ~strucArray->Equate;
                break;

            case SEF_PATH:

                //
                // Add another output file to our list.
                //

                CheckCondition( fOutputSpecified == FALSE,
                                "setPath() in %s incompatible with -o flag\n",
                                ObjectPath );

                AddNewOutputFile( strucArray->Name,
                                  (ULONG)strucArray->Flags );
                break;

            default:

                //
                // Found an SEF_TYPE we don't know about.  This is fatal.
                //

                CheckCondition( FALSE,
                                "Unknown structure type %d.  "
                                "Need an updated genxx.exe?\n",
                                sefType );
                break;

        }

    } while( finished == FALSE );
}

VOID
__cdecl
CheckCondition(
    int Condition,
    const char *FormatString,
    ...
    )
{
    va_list(arglist);

    va_start(arglist, FormatString);

    if( Condition == 0 ){

        //
        // A fatal error was encountered.  Bail.
        //

        vprintf( FormatString, arglist );
        perror( "genxx" );
        exit(1);
    }
}

VOID
_cdecl
HeaderPrint(
    ULONG EnableFlags,
    ULONG Type,
    ...
    )
{
    POUTPUT_FILE outputFile;
    char const *formatString;

    va_list arglist;

    //
    // Send the output to each output file as appropriate
    //

    outputFile = OutputFileList;
    while( outputFile != NULL ){

        va_start( arglist, Type );

        if( outputFile->EnableMask == 0 ||
            (outputFile->EnableMask & EnableFlags) != 0 ){

            //
            // Either this output file gets everything, or the mask
            // matches.  Figure out which format to use... '.h' or '.inc'
            // style.
            //

            if( Type == SEF_STRING ){

                //
                // For SEF_STRING, strucArray->Name *is* the format string.
                //

                formatString = va_arg( arglist, PUCHAR );

            } else if( outputFile->IncFormat != FALSE ){

                //
                // Use the ".inc" format
                //

                formatString = Asm386FormatStringArray[ Type ];

            } else {

                //
                // Use the ".h" format
                //

                formatString = PreprocessedFormatStringArray[ Type ];
            }

            //
            // Now send it
            //

            vfprintf( outputFile->File, formatString, arglist );
        }

        va_end( arglist );

        //
        // Process all current output files.
        //

        outputFile = outputFile->Next;
    }
}

VOID
GetEnvironment( VOID )
{
    char *ntDrive;
    char *ntRoot;

    //
    // Set NtRoot = %_NTDRIVE%\%_NTROOT%
    //

    ntDrive = getenv( "_NTDRIVE" );
    ntRoot = getenv( "_NTROOT" );
    if( ntDrive != NULL && ntRoot != NULL ){

        sprintf( NtRoot, "%s%s", ntDrive, ntRoot );

    } else {

        //
        // If either _NTDRIVE or _NTROOT were not found in the environment,
        // let's try with \nt.
        //

        strcpy( NtRoot, "\\nt" );
    }
}

PSTRUC_ELEMENT
FindStructureElementArray(
    PCHAR Buffer,
    ULONG BufferSize
    )
{
    PCHAR searchPoint;
    PCHAR searchEndPoint;
    PSTRUC_ELEMENT strucElement;

    //
    // Search Buffer for the beginning of a structure element array.
    // The first element in this array contains MARKER_STRING.
    //

    searchPoint = Buffer;
    searchEndPoint = Buffer + BufferSize - sizeof( MarkerString );

    do{
        //
        // We scan the buffer a character at a time until we find a character
        // that matches the first character in MarkerString.
        //

        if( *searchPoint != MarkerString[ 0 ] ){
            continue;
        }

        //
        // When a matching char is found, the rest of the string is compared.
        //

        if( strcmp( searchPoint, MarkerString ) == 0 ){

            //
            // It matched too, we're done.
            //

            strucElement = CONTAINING_RECORD( searchPoint,
                                              STRUC_ELEMENT,
                                              Name );
            return strucElement;
        }

    } while( searchPoint++ < searchEndPoint );

    //
    // Fell out of the loop, we couldn't find the string.
    //

    return NULL;
}

VOID
Usage( VOID ){

    int platformIndex;
    PPLATFORM platform;


    printf("genxx: [");
    platform = PlatformList;
    while( platform->PlatformName != NULL ){

        printf("-%s|", platform->PlatformName );
        platform++;
    }

    printf("<objpath>] [-s<h|inc>] [-o<outputpath>]\n");
    exit(1);
}

VOID
ApplyFixupsToImage( VOID )
{
    //
    // Applies fixups to the OBJ image loaded at ObjImage
    //

    PIMAGE_FILE_HEADER fileHeader;
    PIMAGE_SECTION_HEADER sectionHeader;
    PIMAGE_SECTION_HEADER sectionHeaderArray;
    PIMAGE_SYMBOL symbolTable;
    PIMAGE_SYMBOL symbol;
    PIMAGE_RELOCATION reloc;
    PIMAGE_RELOCATION relocArray;
    ULONG sectionNum;
    ULONG relocNum;
    ULONG_PTR targetVa;
    PULONG_PTR fixupVa;

    fileHeader = (PIMAGE_FILE_HEADER)ObjImage;

    //
    // We need the symbol table to apply the fixups
    //

    symbolTable = (PIMAGE_SYMBOL)(ObjImage + fileHeader->PointerToSymbolTable);

    //
    // Get a pointer to the first element in the section header
    //

    sectionHeaderArray = (PIMAGE_SECTION_HEADER)(ObjImage +
                              sizeof( IMAGE_FILE_HEADER ) +
                              fileHeader->SizeOfOptionalHeader);

    //
    // Apply the fixups for each section
    //

    for( sectionNum = 0;
         sectionNum < fileHeader->NumberOfSections;
         sectionNum++ ){

        sectionHeader = &sectionHeaderArray[ sectionNum ];

        if (memcmp(sectionHeader->Name, ".data", sizeof(".data")+1)) {
            // Not .data - don't bother with the fixup
            continue;
        }

        //
        // Apply each fixup in this section
        //

        relocArray = (PIMAGE_RELOCATION)(ObjImage +
                                         sectionHeader->PointerToRelocations);
        for( relocNum = 0;
             relocNum < sectionHeader->NumberOfRelocations;
             relocNum++ ){

            reloc = &relocArray[ relocNum ];

            //
            // The relocation gives us the position in the image of the
            // relocation modification (VirtualAddress).  To find out what
            // to put there, we have to look the symbol up in the symbol index.
            //

            symbol = &symbolTable[ reloc->SymbolTableIndex ];

            targetVa =
                sectionHeaderArray[ symbol->SectionNumber-1 ].PointerToRawData;

            targetVa += symbol->Value;
            targetVa += (ULONG_PTR)ObjImage;

            fixupVa = (PULONG_PTR)(ObjImage +
                                  reloc->VirtualAddress +
                                  sectionHeader->PointerToRawData );

            *fixupVa = targetVa;
        }
    }
}

BOOLEAN
IsWhiteSpace(
    CHAR Char
    )
{
    if( Char == '\t' ||
        Char == ' '  ||
        Char == '\r' ||
        Char == '\n' ){

        return TRUE;
    } else {
        return FALSE;
    }
}

PCHAR
StripWhiteSpace(
    PCHAR String
    )
{
    PCHAR chr;
    ULONG strLen;

    strLen = strlen( String );
    if( strLen == 0 ){
        return String;
    }

    //
    // Strip off trailing whitespace
    //

    chr = String + strLen - 1;
    while( IsWhiteSpace( *chr )){
        *chr = '\0';
        chr--;
    }

    //
    // Advance past leading whitespace
    //

    chr = String;
    while( IsWhiteSpace( *chr )){
        chr++;
    }

    return chr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\debug.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Main loop for INSTALER program

Author:

    Steve Wood (stevewo) 09-Aug-1994

Revision History:

--*/

#include "instaler.h"

DWORD
DebugEventHandler(
    LPDEBUG_EVENT DebugEvent
    );

VOID
InstallBreakpointsForDLL(
    PPROCESS_INFO Process,
    LPVOID BaseOfDll
    );

VOID
RemoveBreakpointsForDLL(
    PPROCESS_INFO Process,
    LPVOID BaseOfDll
    );

char *DebugEventNames[] = {
    "Unknown debug event",
    "EXCEPTION_DEBUG_EVENT",
    "CREATE_THREAD_DEBUG_EVENT",
    "CREATE_PROCESS_DEBUG_EVENT",
    "EXIT_THREAD_DEBUG_EVENT",
    "EXIT_PROCESS_DEBUG_EVENT",
    "LOAD_DLL_DEBUG_EVENT",
    "UNLOAD_DLL_DEBUG_EVENT",
    "OUTPUT_DEBUG_STRING_EVENT",
    "RIP_EVENT",
    "Unknown debug event",
    "Unknown debug event",
    "Unknown debug event",
    "Unknown debug event",
    "Unknown debug event",
    "Unknown debug event",
    "Unknown debug event",
    "Unknown debug event",
    "Unknown debug event",
    "Unknown debug event",
    NULL
};


VOID
DebugEventLoop( VOID )
{
    DEBUG_EVENT DebugEvent;
    DWORD ContinueStatus;
    DWORD OldPriority;

    //
    // We want to process debug events quickly
    //

    OldPriority = GetPriorityClass( GetCurrentProcess() );
    SetPriorityClass( GetCurrentProcess(), HIGH_PRIORITY_CLASS );

    do {
        if (!WaitForDebugEvent( &DebugEvent, INFINITE )) {
            DeclareError( INSTALER_WAITDEBUGEVENT_FAILED, GetLastError() );
            ExitProcess( 1 );
            }

        if (DebugEvent.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) {
            if (DebugEvent.u.Exception.ExceptionRecord.ExceptionCode != STATUS_BREAKPOINT &&
                DebugEvent.u.Exception.ExceptionRecord.ExceptionCode != STATUS_SINGLE_STEP
               ) {
                DbgEvent( DBGEVENT, ( "Debug exception event - Code: %x  Address: %x  Info: [%u] %x %x %x %x\n",
                                      DebugEvent.u.Exception.ExceptionRecord.ExceptionCode,
                                      DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress,
                                      DebugEvent.u.Exception.ExceptionRecord.NumberParameters,
                                      DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 0 ],
                                      DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 1 ],
                                      DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 2 ],
                                      DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 3 ]
                                    )
                        );
                }
            }
        else {
            DbgEvent( DBGEVENT, ( "Debug %s (%x) event\n",
                                  DebugEventNames[ DebugEvent.dwDebugEventCode ],
                                  DebugEvent.dwDebugEventCode
                                )
                    );
            }
        ContinueStatus = DebugEventHandler( &DebugEvent );
        if (!ContinueDebugEvent( DebugEvent.dwProcessId,
                                 DebugEvent.dwThreadId,
                                 ContinueStatus
                               )
           ) {
            DeclareError( INSTALER_CONTDEBUGEVENT_FAILED, GetLastError() );
            ExitProcess( 1 );
            }
        }
    while (!IsListEmpty( &ProcessListHead ));


    //
    // Drop back to old priority to interact with user.
    //

    SetPriorityClass( GetCurrentProcess(), OldPriority );
}


DWORD
DebugEventHandler(
    LPDEBUG_EVENT DebugEvent
    )
{
    DWORD ContinueStatus;
    PPROCESS_INFO Process;
    PTHREAD_INFO Thread;
    PBREAKPOINT_INFO Breakpoint;

    ContinueStatus = (DWORD)DBG_CONTINUE;
    if (FindProcessAndThreadForEvent( DebugEvent, &Process, &Thread )) {
        switch (DebugEvent->dwDebugEventCode) {
            case CREATE_PROCESS_DEBUG_EVENT:
                //
                // Create process event includes first thread of process
                // as well.  Remember process and thread in our process tree
                //

                if (AddProcess( DebugEvent, &Process )) {
                    InheritHandles( Process );
                    AddThread( DebugEvent, Process, &Thread );
                    }
                break;

            case EXIT_PROCESS_DEBUG_EVENT:
                //
                // Exit process event includes last thread of process
                // as well.  Remove process and thread from our process tree
                //

                if (DeleteThread( Process, Thread )) {
                    DeleteProcess( Process );
                    }
                break;

            case CREATE_THREAD_DEBUG_EVENT:
                //
                // Create thread.  Remember thread in our process tree.
                //

                AddThread( DebugEvent, Process, &Thread );
                break;

            case EXIT_THREAD_DEBUG_EVENT:
                //
                // Exit thread.  Remove thread from our process tree.
                //

                DeleteThread( Process, Thread );
                break;

            case LOAD_DLL_DEBUG_EVENT:
                //
                // DLL just mapped into process address space.  See if it is one
                // of the ones we care about and if so, install the necessary
                // breakpoints.
                //

                InstallBreakpointsForDLL( Process, DebugEvent->u.LoadDll.lpBaseOfDll );
                break;

            case UNLOAD_DLL_DEBUG_EVENT:
                //
                // DLL just unmapped from process address space.  See if it is one
                // of the ones we care about and if so, remove the breakpoints we
                // installed when it was mapped.
                //

                RemoveBreakpointsForDLL( Process, DebugEvent->u.UnloadDll.lpBaseOfDll );
                break;

            case OUTPUT_DEBUG_STRING_EVENT:
            case RIP_EVENT:
                //
                // Ignore these
                //
                break;

            case EXCEPTION_DEBUG_EVENT:
                //
                // Assume we wont handle this exception
                //

                ContinueStatus = (DWORD)DBG_EXCEPTION_NOT_HANDLED;
                switch (DebugEvent->u.Exception.ExceptionRecord.ExceptionCode) {
                    //
                    // Breakpoint exception.
                    //

                    case STATUS_BREAKPOINT:
                        EnterCriticalSection( &BreakTable );
                        if (Thread->BreakpointToStepOver != NULL) {
                            //
                            // If this breakpoint was in place to step over an API entry
                            // point breakpoint, then deal with it by ending single
                            // step mode, resuming all threads in the process and
                            // reinstalling the API breakpoint we just stepped over.
                            // Finally return handled for this exception so the
                            // thread can proceed.
                            //

                            EndSingleStepBreakpoint( Process, Thread );
                            HandleThreadsForSingleStep( Process, Thread, FALSE );
                            InstallBreakpoint( Process, Thread->BreakpointToStepOver );
                            Thread->BreakpointToStepOver = NULL;
                            ContinueStatus = (DWORD)DBG_EXCEPTION_HANDLED;
                            }
                        else {
                            //
                            // Otherwise, see if this breakpoint is either an API entry
                            // point breakpoint for the process or a return address
                            // breakpoint for a thread in the process.
                            //
                            Breakpoint = FindBreakpoint( DebugEvent->u.Exception.ExceptionRecord.ExceptionAddress,
                                                         Process,
                                                         Thread
                                                       );
                            if (Breakpoint != NULL) {
                                //
                                // This is one of our breakpoints, call the breakpoint
                                // handler.
                                //
                                if (HandleBreakpoint( Process, Thread, Breakpoint )) {
                                    //
                                    // Now single step over this breakpoint, by removing it and
                                    // setting a breakpoint at the next instruction (or using
                                    // single stepmode if the processor supports it).  We also
                                    // suspend all the threads in the process except this one so
                                    // we know the next breakpoint/single step exception we see
                                    // for this process will be for this one.
                                    //

                                    Thread->BreakpointToStepOver = Breakpoint;
                                    RemoveBreakpoint( Process, Breakpoint );
                                    HandleThreadsForSingleStep( Process, Thread, TRUE );
                                    BeginSingleStepBreakpoint( Process, Thread );
                                    }
                                else {
                                    Thread->BreakpointToStepOver = NULL;
                                    }

                                ContinueStatus = (DWORD)DBG_EXCEPTION_HANDLED;
                                }
                            else {
                                DbgEvent( DBGEVENT, ( "Skipping over hardcoded breakpoint at %x\n",
                                                      DebugEvent->u.Exception.ExceptionRecord.ExceptionAddress
                                                    )
                                        );

                                //
                                // If not one of our breakpoints, assume it is a hardcoded
                                // breakpoint and skip over it.  This will get by the one
                                // breakpoint in LdrInit triggered by the process being
                                // invoked with DEBUG_PROCESS.
                                //

                                if (SkipOverHardcodedBreakpoint( Process,
                                                                 Thread,
                                                                 DebugEvent->u.Exception.ExceptionRecord.ExceptionAddress
                                                               )
                                   ) {
                                    //
                                    // If we successfully skipped over this hard-coded breakpoint
                                    // then return handled for this exception.
                                    //

                                    ContinueStatus = (DWORD)DBG_EXCEPTION_HANDLED;
                                    }
                                }
                            }
                        LeaveCriticalSection( &BreakTable );
                        break;

                    case STATUS_SINGLE_STEP:
                        //
                        // We should only see this exception on processors that
                        // support a single step mode.
                        //

                        EnterCriticalSection( &BreakTable );
                        if (Thread->BreakpointToStepOver != NULL) {
                            EndSingleStepBreakpoint( Process, Thread );
                            HandleThreadsForSingleStep( Process, Thread, FALSE );
                            InstallBreakpoint( Process, Thread->BreakpointToStepOver );
                            Thread->BreakpointToStepOver = NULL;
                            ContinueStatus = (DWORD)DBG_EXCEPTION_HANDLED;
                            }
                        LeaveCriticalSection( &BreakTable );
                        break;

                    case STATUS_VDM_EVENT:
                        //
                        // Returning NOT_HANDLED will cause the default behavior to
                        // occur.
                        //
                        break;

                    default:
                        DbgEvent( DBGEVENT, ( "Unknown exception: %08x at %08x\n",
                                              DebugEvent->u.Exception.ExceptionRecord.ExceptionCode,
                                              DebugEvent->u.Exception.ExceptionRecord.ExceptionAddress
                                            )
                                );
                        break;
                    }
                break;

            default:
                DbgEvent( DBGEVENT, ( "Unknown debug event\n" ) );
                break;
            }
        }
    return( ContinueStatus );
}


VOID
InstallBreakpointsForDLL(
    PPROCESS_INFO Process,
    LPVOID BaseOfDll
    )
{
    UCHAR ModuleIndex, ApiIndex;
    PBREAKPOINT_INFO Breakpoint;

    //
    // Loop over module table to see if the base address of this DLL matches
    // one of the module handles we want to set breakpoints in.  If not, ignore
    // event.
    //

    for (ModuleIndex=0; ModuleIndex<MAXIMUM_MODULE_INDEX; ModuleIndex++) {
        if (ModuleInfo[ ModuleIndex ].ModuleHandle == BaseOfDll) {
            //
            // Loop over the list of API entry points for this module and set
            // a process specific breakpoint at the first instruction of each
            // entrypoint.
            //

            for (ApiIndex=0; ApiIndex<MAXIMUM_API_INDEX; ApiIndex++) {
                if (ModuleIndex == ApiInfo[ ApiIndex ].ModuleIndex) {
                    if (CreateBreakpoint( ApiInfo[ ApiIndex ].EntryPointAddress,
                                          Process,
                                          NULL,    // process specific
                                          ApiIndex,
                                          NULL,
                                          &Breakpoint
                                        )
                       ) {
                        Breakpoint->ModuleName = ModuleInfo[ ApiInfo[ ApiIndex ].ModuleIndex ].ModuleName;
                        Breakpoint->ProcedureName = ApiInfo[ ApiIndex ].EntryPointName;
                        DbgEvent( DBGEVENT, ( "Installed breakpoint for %ws!%s at %08x\n",
                                               Breakpoint->ModuleName,
                                               Breakpoint->ProcedureName,
                                               ApiInfo[ ApiIndex ].EntryPointAddress
                                            )
                                );
                        }
                    }
                }
            break;
            }
        }
}

VOID
RemoveBreakpointsForDLL(
    PPROCESS_INFO Process,
    LPVOID BaseOfDll
    )
{
    UCHAR ModuleIndex, ApiIndex;

    //
    // Loop over module index to see if the base address of this DLL matches
    // one of the module handles we set breakpoints in above.  If not, ignore
    // event.
    //

    for (ModuleIndex=0; ModuleIndex<MAXIMUM_MODULE_INDEX; ModuleIndex++) {
        if (ModuleInfo[ ModuleIndex ].ModuleHandle == BaseOfDll) {
            //
            // Loop over the list of API entry points for this module and remove
            // each process specific breakpoint set above for each entrypoint.
            //

            for (ApiIndex=0; ApiIndex<MAXIMUM_API_INDEX; ApiIndex++) {
                if (ModuleIndex == ApiInfo[ ApiIndex ].ModuleIndex) {
                    DestroyBreakpoint( ApiInfo[ ApiIndex ].EntryPointAddress,
                                       Process,
                                       NULL     // process specific
                                     );
                    }
                }
            break;
            }
        }
}


BOOLEAN
InstallBreakpoint(
    PPROCESS_INFO Process,
    PBREAKPOINT_INFO Breakpoint
    )
{
    if (!Breakpoint->SavedInstructionValid &&
        !ReadMemory( Process,
                     Breakpoint->Address,
                     &Breakpoint->SavedInstruction,
                     SizeofBreakpointInstruction,
                     "save instruction"
                    )
       ) {
        return FALSE;
        }
    else
    if (!WriteMemory( Process,
                      Breakpoint->Address,
                      BreakpointInstruction,
                      SizeofBreakpointInstruction,
                      "breakpoint instruction"
                    )
       ) {
        return FALSE;
        }
    else {
        Breakpoint->SavedInstructionValid = TRUE;
        return TRUE;
        }
}

BOOLEAN
RemoveBreakpoint(
    PPROCESS_INFO Process,
    PBREAKPOINT_INFO Breakpoint
    )
{
    if (!Breakpoint->SavedInstructionValid ||
        !WriteMemory( Process,
                      Breakpoint->Address,
                      &Breakpoint->SavedInstruction,
                      SizeofBreakpointInstruction,
                      "restore saved instruction"
                    )
       ) {
        return FALSE;
        }
    else {
        return TRUE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\error.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    error.c

Abstract:

    Error handle module for the INSTALER program

Author:

    Steve Wood (stevewo) 09-Aug-1994

Revision History:

--*/

#include "instaler.h"

VOID
TraceDisplay(
    const char *FormatString,
    ...
    )
{
    va_list arglist;

    va_start( arglist, FormatString );
    vprintf( FormatString, arglist );
    if (InstalerLogFile) {
        vfprintf( InstalerLogFile, FormatString, arglist );
        }
    va_end( arglist );
    fflush( stdout );
    return;
}

VOID
CDECL
DeclareError(
    UINT ErrorCode,
    UINT SupplementalErrorCode,
    ...
    )
{
    va_list arglist;
    HMODULE ModuleHandle;
    DWORD Flags, Size;
    WCHAR MessageBuffer[ 512 ];

    va_start( arglist, SupplementalErrorCode );

    if ((ErrorCode & 0x0FFF0000) >> 16 == FACILITY_APPLICATION) {
        ModuleHandle = InstalerModuleHandle;
        Flags = FORMAT_MESSAGE_FROM_HMODULE;
        }
    else
    if ((ErrorCode & 0x0FFF0000) == FACILITY_NT) {
        ErrorCode ^= FACILITY_NT;
        ModuleHandle = ModuleInfo[ NTDLL_MODULE_INDEX ].ModuleHandle;
        Flags = FORMAT_MESSAGE_FROM_HMODULE;
        }
    else {
        ModuleHandle = NULL;
        Flags = FORMAT_MESSAGE_FROM_SYSTEM;
        }

    Size = FormatMessage( Flags,
                          (LPCVOID)ModuleHandle,
                          ErrorCode,
                          0,
                          MessageBuffer,
                          sizeof( MessageBuffer ) / sizeof( WCHAR ),
                          &arglist
                        );
    va_end( arglist );

    if (Size != 0) {
        printf( "INSTALER: %ws", MessageBuffer );
        }
    else {
        printf( "INSTALER: Unable to get message text for %08x\n", ErrorCode );
        }

    if (ModuleHandle == InstalerModuleHandle &&
        SupplementalErrorCode != 0 &&
        SupplementalErrorCode != ERROR_GEN_FAILURE &&
        SupplementalErrorCode != STATUS_UNSUCCESSFUL
       ) {
        if ((SupplementalErrorCode & 0x0FFF0000) == FACILITY_NT) {
            SupplementalErrorCode ^= FACILITY_NT;
            ModuleHandle = ModuleInfo[ NTDLL_MODULE_INDEX ].ModuleHandle;
            Flags = FORMAT_MESSAGE_FROM_HMODULE;
            }
        else {
            ModuleHandle = NULL;
            Flags = FORMAT_MESSAGE_FROM_SYSTEM;
            }
        Size = FormatMessage( Flags,
                              (LPCVOID)ModuleHandle,
                              SupplementalErrorCode,
                              0,
                              MessageBuffer,
                              sizeof( MessageBuffer ) / sizeof( WCHAR ),
                              NULL
                            );
        if (Size != 0) {
            while (Size != 0 && MessageBuffer[ Size ] <= L' ') {
                MessageBuffer[ Size ] = UNICODE_NULL;
                Size -= 1;
                }

            printf( "          '%ws'\n", MessageBuffer );
            }
        else {
            printf( "INSTALER: Unable to get message text for %08x\n", SupplementalErrorCode );
            }
        }



    return;
}

WCHAR MessageBoxTitle[ MAX_PATH ];


UINT
CDECL
AskUser(
    UINT MessageBoxFlags,
    UINT MessageId,
    UINT NumberOfArguments,
    ...
    )
{
    va_list arglist;
    HMODULE ModuleHandle;
    DWORD Flags, Size;
    WCHAR MessageBuffer[ 512 ];
    PWSTR s;
    ULONG Args[ 24 ];
    PULONG p;

    if (MessageBoxTitle[ 0 ] == UNICODE_NULL) {
        Args[ 0 ] = (ULONG)InstallationName;
        Args[ 1 ] = 0;
        Size = FormatMessageW( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               (LPCVOID)InstalerModuleHandle,
                               INSTALER_ASKUSER_TITLE,
                               0,
                               MessageBoxTitle,
                               sizeof( MessageBoxTitle ) / sizeof( WCHAR ),
                               (va_list *)Args
                             );
        if (Size == 0) {
            _snwprintf( MessageBoxTitle,
                        sizeof( MessageBoxTitle ) / sizeof( WCHAR ),
                        L"Application Installation Monitor Program - %ws",
                        InstallationName
                      );
            }
        else {
            if ((s = wcschr( MessageBoxTitle, L'\r' )) ||
                (s = wcschr( MessageBoxTitle, L'\n' ))
               ) {
                *s = UNICODE_NULL;
                }
            }
        }

    va_start( arglist, NumberOfArguments );
    p = Args;
    while (NumberOfArguments--) {
        *p++ = va_arg( arglist, ULONG );
        }
    *p++ = 0;
    va_end( arglist );

    Size = FormatMessageW( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           (LPCVOID)InstalerModuleHandle,
                           MessageId,
                           0,
                           MessageBuffer,
                           sizeof( MessageBuffer ) / sizeof( WCHAR ),
                           (va_list *)Args
                         );

    if (Size != 0) {
        return MessageBox( NULL,
                           MessageBuffer,
                           MessageBoxTitle,
                           MB_SETFOREGROUND | MessageBoxFlags
                         );
        }
    else {
        return IDOK;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\file.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    file.c

Abstract:

    This module implements the functions to save references to files for the
    INSTALER program.  Part of each reference is a handle to a backup copy
    of a file if the reference is a write/delete/rename.

Author:

    Steve Wood (stevewo) 22-Aug-1994

Revision History:

--*/

#include "instaler.h"


BOOLEAN
CreateFileReference(
    PWSTR Name,
    BOOLEAN WriteAccess,
    PFILE_REFERENCE *ReturnedReference
    )
{
    PFILE_REFERENCE p;
    PWSTR BackupFileName;
    WIN32_FIND_DATAW FindFileData;
    HANDLE FindFileHandle;

    *ReturnedReference = NULL;
    p = FindFileReference( Name );
    if (p != NULL) {
        if (p->WriteAccess) {
            *ReturnedReference = p;
            return TRUE;
            }
        }
    else {
        p = AllocMem( sizeof( *p ) );
        if (p == NULL) {
            return FALSE;
            }

        InsertTailList( &FileReferenceListHead, &p->Entry );
        NumberOfFileReferences += 1;
        p->Name = Name;
        }

    BackupFileName = L"";
    FindFileHandle = NULL;
    if ((p->WriteAccess = WriteAccess) &&
        (FindFileHandle = FindFirstFileW( p->Name, &FindFileData )) != INVALID_HANDLE_VALUE
       ) {
        if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            p->DirectoryFile = TRUE;
            }
        else {
            p->BackupFileAttributes = FindFileData.dwFileAttributes;
            p->BackupLastWriteTime = FindFileData.ftLastWriteTime;
            p->BackupFileSize.LowPart = FindFileData.nFileSizeLow;
            p->BackupFileSize.HighPart = FindFileData.nFileSizeHigh;
            BackupFileName = CreateBackupFileName( &p->BackupFileUniqueId );
            if (BackupFileName == NULL ||
                !CopyFileW( Name, BackupFileName, TRUE )
               ) {
                p->BackupFileUniqueId = 0xFFFF;     // Backup failed.
                DeclareError( INSTALER_CANT_ACCESS_FILE, GetLastError(), Name );
                }
            }
        }
    else {
        p->Created = p->WriteAccess;
        }

    if (FindFileHandle != NULL) {
        FindClose( FindFileHandle );
        }

    *ReturnedReference = p;
    return TRUE;
}


BOOLEAN
CompleteFileReference(
    PFILE_REFERENCE p,
    BOOLEAN CallSuccessful,
    BOOLEAN Deleted,
    PFILE_REFERENCE RenameReference
    )
{
    DWORD dwFileAttributes;

    if (!CallSuccessful) {
        DestroyFileReference( p );
        return FALSE;
        }

    if (RenameReference) {
        if (RenameReference->Created) {
            LogEvent( INSTALER_EVENT_RENAME_TEMP_FILE,
                      3,
                      RenameReference->DirectoryFile ? L"directory" : L"file",
                      RenameReference->Name,
                      p->Name
                    );

            RenameReference->Name = p->Name;
            DestroyFileReference( p );
            return FALSE;
            }

        RenameReference->Deleted = TRUE;

        LogEvent( INSTALER_EVENT_RENAME_FILE,
                  3,
                  RenameReference->DirectoryFile ? L"directory" : L"file",
                  RenameReference->Name,
                  p->Name
                );
        }
    else
    if (Deleted && p->Created) {
        LogEvent( INSTALER_EVENT_DELETE_TEMP_FILE,
                  2,
                  p->DirectoryFile ? L"directory" : L"file",
                  p->Name
                );
        DestroyFileReference( p );
        return FALSE;
        }
    else {
        if (wcschr( p->Name, '\\' ) == NULL) {
            //
            // If no path separator, must be volume open.  Treat
            // as directory and dont touch file
            //
            p->DirectoryFile = TRUE;
            }
        else
        if ((dwFileAttributes = GetFileAttributes( p->Name )) != 0xFFFFFFFF) {
            p->DirectoryFile = (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
            }

        if (Deleted) {
            LogEvent( INSTALER_EVENT_DELETE_FILE,
                      2,
                      p->DirectoryFile ? L"directory" : L"file",
                      p->Name
                    );
            }
        else
        if (p->WriteAccess) {
            if (p->Created) {
                LogEvent( INSTALER_EVENT_CREATE_FILE,
                          2,
                          p->DirectoryFile ? L"directory" : L"file",
                          p->Name
                        );
                }
            else {
                LogEvent( INSTALER_EVENT_WRITE_FILE,
                          2,
                          p->DirectoryFile ? L"directory" : L"file",
                          p->Name
                        );
                }
            }
        else {
            LogEvent( INSTALER_EVENT_READ_FILE,
                      2,
                      p->DirectoryFile ? L"directory" : L"file",
                      p->Name
                    );
            }
        }

    p->Deleted = Deleted;
    return TRUE;
}


BOOLEAN
DestroyFileReference(
    PFILE_REFERENCE p
    )
{
    PWSTR BackupFileName;

    if (!p->Created &&
        (BackupFileName = FormatTempFileName( NULL, &p->BackupFileUniqueId ))
       ) {
        DeleteFileW( BackupFileName );
        }

    if (p->DateModified || p->AttributesModified) {
        return FALSE;
        }

    RemoveEntryList( &p->Entry );
    NumberOfFileReferences -= 1;
    FreeMem( &p );
    return TRUE;
}



PVOID
MapFileForRead(
    PWSTR FileName,
    PULONG FileSize
    )
{
    HANDLE FileHandle, MappingHandle;
    PVOID FileData;
    ULONG HighFileSize;

    FileData = NULL;
    FileHandle = CreateFileW( FileName,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL
                            );
    if (FileHandle != INVALID_HANDLE_VALUE) {
        *FileSize = GetFileSize( FileHandle, &HighFileSize );
        if (*FileSize == 0) {
            CloseHandle( FileHandle );
            return (PVOID)0xFFFFFFFF;
            }

        MappingHandle = CreateFileMappingW( FileHandle,
                                            NULL,
                                            PAGE_READONLY,
                                            0,
                                            *FileSize,
                                            NULL
                                          );
        CloseHandle( FileHandle );
        if (MappingHandle != NULL) {
            FileData = MapViewOfFile( MappingHandle,
                                      FILE_MAP_READ,
                                      0,
                                      0,
                                      *FileSize
                                    );
            CloseHandle( MappingHandle );
            }
        }

    return FileData;
}


BOOLEAN
AreFileContentsEqual(
    PWSTR FileName1,
    PWSTR FileName2
    )
{
    PVOID FileData1, FileData2;
    ULONG FileSize1, FileSize2;
    BOOLEAN Result;

    Result = FALSE;
    if (FileData1 = MapFileForRead( FileName1, &FileSize1 )) {
        if (FileData2 = MapFileForRead( FileName2, &FileSize2 )) {
            if (FileSize1 == FileSize2 &&
                RtlCompareMemory( FileData1, FileData2, FileSize1 ) == FileSize1
               ) {
                Result = TRUE;
                }
            if (FileData2 != (PVOID)0xFFFFFFFF) {
                UnmapViewOfFile( FileData2 );
                }
            }
        else {
            DeclareError( INSTALER_CANT_ACCESS_FILE, GetLastError(), FileName2 );
            }

        if (FileData1 != (PVOID)0xFFFFFFFF) {
            UnmapViewOfFile( FileData1 );
            }
        }
    else {
        DeclareError( INSTALER_CANT_ACCESS_FILE, GetLastError(), FileName1 );
        }

    return Result;
}

BOOLEAN
IsNewFileSameAsBackup(
    PFILE_REFERENCE p
    )
{
    WIN32_FIND_DATAW FindFileData;
    HANDLE FindFileHandle;
    PWSTR BackupFileName;

    if ((FindFileHandle = FindFirstFileW( p->Name, &FindFileData )) != INVALID_HANDLE_VALUE) {
        FindClose( FindFileHandle );
        if (p->BackupFileAttributes != FindFileData.dwFileAttributes) {
            p->AttributesModified = TRUE;
            }

        if (p->BackupLastWriteTime.dwLowDateTime != FindFileData.ftLastWriteTime.dwLowDateTime ||
            p->BackupLastWriteTime.dwHighDateTime != FindFileData.ftLastWriteTime.dwHighDateTime
           ) {
            p->DateModified = TRUE;
            }

        if (BackupFileName = FormatTempFileName( NULL, &p->BackupFileUniqueId )) {
            if (p->BackupFileSize.LowPart != FindFileData.nFileSizeLow ||
                p->BackupFileSize.HighPart != FindFileData.nFileSizeHigh ||
                !AreFileContentsEqual( BackupFileName, p->Name )
               ) {
                p->ContentsModified = TRUE;
                return FALSE;
                }
            }

        return TRUE;
        }
    else {
        return FALSE;
        }
}

PFILE_REFERENCE
FindFileReference(
    PWSTR Name
    )
{
    PFILE_REFERENCE p;
    PLIST_ENTRY Head, Next;

    Head = &FileReferenceListHead;
    Next = Head->Flink;
    while (Head != Next) {
        p = CONTAINING_RECORD( Next, FILE_REFERENCE, Entry );
        if (p->Name == Name) {
            return p;
            }

        Next = Next->Flink;
        }

    return NULL;
}


VOID
DumpFileReferenceList(
    FILE *LogFile
    )
{
    PFILE_REFERENCE p;
    PLIST_ENTRY Head, Next;

    Head = &FileReferenceListHead;
    Next = Head->Flink;
    while (Head != Next) {
        p = CONTAINING_RECORD( Next, FILE_REFERENCE, Entry );
        if (p->WriteAccess) {
            if (!p->Deleted) {
                if (p->BackupFileUniqueId == 0) {
                    if (p->Created) {
                        ImlAddFileRecord( pImlNew,
                                          CreateNewFile,
                                          p->Name,
                                          NULL,
                                          NULL,
                                          0
                                        );
                        }
                    }
                else {
                    if (p->ContentsModified) {
                        if (ImlAddFileRecord( pImlNew,
                                              ModifyOldFile,
                                              p->Name,
                                              FormatTempFileName( NULL, &p->BackupFileUniqueId ),
                                              NULL,
                                              0
                                            )
                           ) {
                            DeleteFile( FormatTempFileName( NULL, &p->BackupFileUniqueId ) );
                            }
                        }
                    else
                    if (p->DateModified) {
                        ImlAddFileRecord( pImlNew,
                                          ModifyFileDateTime,
                                          p->Name,
                                          NULL,
                                          &p->BackupLastWriteTime,
                                          p->BackupFileAttributes
                                        );
                        }
                    else {
                        ImlAddFileRecord( pImlNew,
                                          ModifyFileAttributes,
                                          p->Name,
                                          NULL,
                                          &p->BackupLastWriteTime,
                                          p->BackupFileAttributes
                                        );
                        }
                    }
                }
            else {
                if (ImlAddFileRecord( pImlNew,
                                      DeleteOldFile,
                                      p->Name,
                                      FormatTempFileName( NULL, &p->BackupFileUniqueId ),
                                      NULL,
                                      0
                                    )
                   ) {
                    DeleteFile( FormatTempFileName( NULL, &p->BackupFileUniqueId ) );
                    }
                }
            }

        Next = Next->Flink;
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\fileman.c ===
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include "resource.h"
#include "hlist.h"


#define TYPE_FILE  1
#define TYPE_DIR   2


LRESULT WndProc(HWND,UINT,WPARAM,LPARAM);

HINSTANCE  hControlLib;
HINSTANCE  hInst;
HBITMAP    hFileBmp;
HBITMAP    hDirBmp;
HWND       hwndList;


BOOL HListInitialize(HMODULE);



int _cdecl
main(
    int argc,
    char *argv[]
    )
{
    WNDCLASS    wndclass;
    HWND        hwnd;
    MSG         msg;


    hInst = GetModuleHandle( NULL );

    HListInitialize( hInst );

    hFileBmp = LoadBitmap( hInst, MAKEINTRESOURCE(FILEBMP) );
    hDirBmp  = LoadBitmap( hInst, MAKEINTRESOURCE(DIRBMP) );

    wndclass.style         = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc   = WndProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = 0;
    wndclass.hInstance     = hInst;
    wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION);
    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
    wndclass.hbrBackground = GetStockObject (WHITE_BRUSH);
    wndclass.lpszMenuName  = NULL;
    wndclass.lpszClassName = "test";
    RegisterClass (&wndclass);

    hwnd = CreateWindow(
        "test",
        "Test Custon Control App",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        GetModuleHandle(NULL),
        NULL );

    ShowWindow( hwnd, SW_SHOW );
    UpdateWindow( hwnd );

    while (GetMessage( &msg, NULL, 0, 0 )) {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    return 0;
}

DWORD CALLBACK
ExpansionCallback(
    LPDWORD type,
    LPSTR   *str,
    LPSTR   ref,
    DWORD   level,
    DWORD   nchild
    )
{
    static WIN32_FIND_DATA fd = {0};
    static HANDLE          hFind = NULL;
    static CHAR            Dir[MAX_PATH*3];
    CHAR                   NewDir[MAX_PATH*3];
    LPSTR                  p;


    if ((!hFind) && (*type == TYPE_FILE)) {
        MessageBeep( 0 );
        return HLB_END;
    }

    if (!hFind) {
        if (nchild) {
            //
            // this node needs to be collapsed
            //
            return HLB_COLLAPSE;
        }

        if (!GetCurrentDirectory( sizeof(Dir), Dir )) {
            return HLB_IGNORE;
        }
        p = ref;
        NewDir[0] = 0;
        while (p && *p) {
            p += (strlen(p) + 1);
        }
        while (p != ref) {
            p -= 2;
            while (*p && p != ref) {
                p--;
            }
            if (!*p) {
                p++;
            }
            strcat( NewDir, p );
            strcat( NewDir, "\\" );
        }
        if (!SetCurrentDirectory( NewDir )) {
            return HLB_END;
        }
        hFind = FindFirstFile( "*.*", &fd );
        if (hFind == INVALID_HANDLE_VALUE) {
            hFind = NULL;
            MessageBeep( 0 );
            return HLB_END;
        }
    } else {
        if (!FindNextFile( hFind, &fd )) {
            FindClose( hFind );
            SetCurrentDirectory( Dir );
            hFind = NULL;
            return HLB_END;
        }
    }


    *str = fd.cFileName;

    if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        *type = TYPE_DIR;
    } else {
        *type = TYPE_FILE;
    }

    if (level && fd.cFileName[0] == '.') {
        return HLB_IGNORE;
    }

    return HLB_EXPAND;
}

VOID
FillListBox(
    VOID
    )
{
    WIN32_FIND_DATA fd;
    HANDLE          hFind;
    DWORD           type;


    hFind = FindFirstFile( "*.*", &fd );
    if (hFind == INVALID_HANDLE_VALUE) {
        return;
    }

    do {
        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            type = TYPE_DIR;
        } else {
            type = TYPE_FILE;
        }
        SendMessage( hwndList, HLB_ADDSTRING, type, (LPARAM) fd.cFileName );
    } while(FindNextFile( hFind, &fd ));

    FindClose( hFind );
}

LRESULT
WndProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    RECT cRect;


    switch (message) {
        case WM_CREATE:
            GetClientRect( hwnd, &cRect );
            hwndList = CreateWindow(
                "HList",
                NULL,
                WS_CHILD | WS_VISIBLE,
                cRect.left,
                cRect.top,
                cRect.right  - cRect.left,
                cRect.bottom - cRect.top,
                hwnd,
                NULL,
                GetModuleHandle(NULL),
                NULL );
            SendMessage( hwndList, HLB_REGISTER_CALLBACK, 0, (LPARAM)ExpansionCallback );
            SendMessage( hwndList, HLB_REGISTER_TYPE, TYPE_FILE, (LPARAM)hFileBmp );
            SendMessage( hwndList, HLB_REGISTER_TYPE, TYPE_DIR, (LPARAM)hDirBmp );
            FillListBox();
            break;

        case WM_DESTROY:
            PostQuitMessage( 0 );
            return 0;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\event.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    event.c

Abstract:

    Log formatted events to a file and possibly the console too

Author:

    Steve Wood (stevewo) 09-Aug-1994

Revision History:

--*/

#include "instaler.h"

VOID
CDECL
LogEvent(
    UINT MessageId,
    UINT NumberOfArguments,
    ...
    )
{
    va_list arglist;
    HMODULE ModuleHandle;
    DWORD Flags, Size;
    WCHAR MessageBuffer[ 512 ];
    PWSTR s;
    ULONG Args[ 24 ];
    PULONG p;

    va_start( arglist, NumberOfArguments );
    p = Args;
    while (NumberOfArguments--) {
        *p++ = va_arg( arglist, ULONG );
        }
    *p++ = ((GetTickCount() - StartProcessTickCount) / 1000);   // Seconds since the start
    *p++ = 0;
    va_end( arglist );

    Size = FormatMessageW( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           (LPCVOID)InstalerModuleHandle,
                           MessageId,
                           0,
                           MessageBuffer,
                           sizeof( MessageBuffer ) / sizeof( WCHAR ),
                           (va_list *)Args
                         );
    if (Size != 0) {
        s = MessageBuffer;
        while (s = wcschr( s, L'\r' )) {
            if (s[1] == '\n') {
                wcscpy( s, s+1 );
                }
            else {
                s += 1;
                }
            }
        printf( "%ws", MessageBuffer );
        if (InstalerLogFile) {
            fprintf( InstalerLogFile, "%ws", MessageBuffer );
            }
        }
    else {
        printf( "INSTALER: Unable to get message text for %08x\n", MessageId );
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\hlist.h ===
//
// hlist defines
//
#define HLB_ADDSTRING           WM_USER+100
#define HLB_INSERTSTRING        WM_USER+101
#define HLB_REGISTER_TYPE       WM_USER+102
#define HLB_REGISTER_CALLBACK   WM_USER+103

#define HLB_IGNORE              0
#define HLB_EXPAND              1
#define HLB_COLLAPSE            2
#define HLB_END                 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\handledb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    handledb.c

Abstract:

    This module contains the code to maintain an open handle data base for the
    INSTALER program.  This is used to track path names associated with open
    handles so we can construct full paths from relative opens.

Author:

    Steve Wood (stevewo) 11-Aug-1994

Revision History:

--*/

#include "instaler.h"

char *HandleTypes[] = {
    "File/Key",
    "File",
    "Key"
};

POPENHANDLE_INFO
FindOpenHandle(
    PPROCESS_INFO Process,
    HANDLE Handle,
    ULONG Type
    )
{
    PLIST_ENTRY Next, Head;
    POPENHANDLE_INFO p;

    Head = &Process->OpenHandleListHead;
    Next = Head->Flink;
    while (Next != Head) {
        p = CONTAINING_RECORD( Next, OPENHANDLE_INFO, Entry );
        if (p->Handle == Handle && (Type == (ULONG)-1 || p->Type == Type)) {
            return p;
            }

        Next = Next->Flink;
        }

    return NULL;
}

BOOLEAN
AddOpenHandle(
    PPROCESS_INFO Process,
    HANDLE Handle,
    ULONG Type,
    PWSTR Name,
    BOOLEAN InheritHandle
    )
{
    POPENHANDLE_INFO p;

    if (Type == (ULONG)-1) {
        return FALSE;
        }

    if (FindOpenHandle( Process, Handle, Type ) != NULL) {
        return FALSE;
        }

    p = AllocMem( sizeof( *p ) );
    if (p == NULL) {
        return FALSE;
        }

    p->Handle = Handle;
    p->Type = (USHORT)Type;
    p->Inherit = InheritHandle;
    p->Name = Name;
    p->LengthOfName = (USHORT)(wcslen( Name ) * sizeof( WCHAR ));
    if (Type == HANDLE_TYPE_FILE && p->LengthOfName == (3 * sizeof( WCHAR ))) {
        p->RootDirectory = TRUE;
        }

    InsertHeadList( &Process->OpenHandleListHead, &p->Entry );

    return TRUE;
}


BOOLEAN
DeleteOpenHandle(
    PPROCESS_INFO Process,
    HANDLE Handle,
    ULONG Type
    )
{
    POPENHANDLE_INFO p;

    p = FindOpenHandle( Process, Handle, Type );
    if (p == NULL) {
        //
        // We will see lots of close calls for handles we dont care
        // about.  Ignore them quietly.
        //
        return FALSE;
        }

    RemoveEntryList( &p->Entry );
    FreeMem( &p->QueryName );
    FreeMem( &p );
    return TRUE;
}


static BOOLEAN IgnoredFirstProcess = FALSE;

VOID
InheritHandles(
    PPROCESS_INFO Process
    )
{
    PPROCESS_INFO ParentProcess;
    PLIST_ENTRY Prev, Head;
    POPENHANDLE_INFO p;

    if (Process->ProcessInformation.InheritedFromUniqueProcessId == 0) {
        return;
        }

    ParentProcess = FindProcessById( Process->ProcessInformation.InheritedFromUniqueProcessId );
    if (ParentProcess == NULL) {
        if (!IgnoredFirstProcess) {
            IgnoredFirstProcess = TRUE;
            }
        else {
            DbgEvent( INTERNALERROR, ("Unable to find parent process (%x)\n", Process->ProcessInformation.InheritedFromUniqueProcessId ) );
            }

        return;
        }

    Head = &ParentProcess->OpenHandleListHead;
    Prev = Head->Blink;
    while (Prev != Head) {
        p = CONTAINING_RECORD( Prev, OPENHANDLE_INFO, Entry );
        if (p->Inherit) {
            if (!AddOpenHandle( Process,
                                p->Handle,
                                p->Type,
                                p->Name,
                                TRUE
                              )
               ) {
                DbgEvent( INTERNALERROR, ("Unable to inherit %s handle (%x) for '%ws' from process (%x)\n",
                                          HandleTypes[ 1+p->Type ],
                                          p->Handle,
                                          p->Name,
                                          Process->ProcessInformation.InheritedFromUniqueProcessId
                                         )
                        );
                }
            }

        Prev = Prev->Blink;
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\hlist.c ===
#include <windows.h>
#include <custcntl.h>
#include <commdlg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "hlist.h"


typedef DWORD (CALLBACK* HLISTCALLBACK)(LPDWORD,LPSTR*,LPSTR,DWORD,DWORD);

#define XBITMAP              16
#define YBITMAP              16
#define MARGIN               6
#define INDENT               (XBITMAP + MARGIN)
#define MIDDLE               ((XBITMAP/2) + MARGIN)
#define LINE_COLOR           RGB(255,0,0)

#define CLASS_NAME           "HList"
#define DESCRIPTION          "Heir List Box"

#define DEFAULT_STYLE        WS_CHILD               |   \
                             WS_VISIBLE             |   \
                             WS_VSCROLL             |   \
                             WS_HSCROLL             |   \
                             WS_BORDER              |   \
                             LBS_NOTIFY             |   \
                             LBS_NOINTEGRALHEIGHT   |   \
                             LBS_WANTKEYBOARDINPUT  |   \
                             LBS_SORT               |   \
                             LBS_OWNERDRAWFIXED



typedef struct _HLISTTYPE {
    struct _HLISTTYPE   *next;
    DWORD               type;
    HBITMAP             bitmap;
} HLISTTYPE, *LPHLISTTYPE;

typedef struct _HLISTINFO {
    HWND          hwndList;
    LPHLISTTYPE   typeList;
    HLISTCALLBACK lpCallback;
} HLISTINFO, *LPHLISTINFO;

typedef struct _ITEMDATA {
    struct _ITEMDATA    *parent;
    DWORD               type;
    DWORD               level;
    DWORD               nchild;
    DWORD               childnum;
    LPSTR               str;
    HBITMAP             bitmap;
} ITEMDATA, *LPITEMDATA;


static HMODULE hInstance;


LRESULT        HListWndProc(HWND,UINT,WPARAM,LPARAM);


BOOL
HListInitialize(
    HMODULE hModule
    )
{
    WNDCLASS       wndclass;


    hInstance = hModule;

    wndclass.style          = CS_HREDRAW | CS_VREDRAW | CS_GLOBALCLASS;
    wndclass.lpfnWndProc    = HListWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = 4;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = NULL;
    wndclass.hCursor        = LoadCursor( NULL, IDC_ARROW );
    wndclass.hbrBackground  = (HBRUSH) (COLOR_WINDOW + 1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = CLASS_NAME;
    if (!RegisterClass( &wndclass )) {
        return FALSE;
    }

    return TRUE;
}

VOID
CollapseNode(
    HWND       hwnd,
    LPITEMDATA lpid,
    DWORD      nItem
    )
{
    DWORD       i;
    LPITEMDATA  lpidChild;


    for (i=0; i<lpid->nchild; i++) {
        lpidChild = (LPITEMDATA) SendMessage( hwnd, LB_GETITEMDATA, nItem, 0 );
        if (lpidChild->nchild) {
            CollapseNode( hwnd, lpidChild, nItem+1 );
        }
        SendMessage( hwnd, LB_DELETESTRING, nItem, 0 );
    }

    lpid->nchild = 0;
}

LRESULT
HListWndProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    RECT                cRect;
    HFONT               hFont;
    LPHLISTINFO         hli;
    LPHLISTTYPE         hlt;
    LPHLISTTYPE         hltNext;
    LPMEASUREITEMSTRUCT lpmis;
    LPDELETEITEMSTRUCT  lplis;
    LPDRAWITEMSTRUCT    lpdis;
    HBITMAP             hbmp;
    HBITMAP             hbmpOld;
    HDC                 hdc;
    TEXTMETRIC          tm;
    int                 x;
    int                 y;
    int                 nItem;
    RECT                rcBitmap;
    LPITEMDATA          lpid;
    LPITEMDATA          lpidParent;
    DWORD               type;
    LPSTR               str;
    DWORD               rval;
    DWORD               level;
    LPSTR               ref;
    LPSTR               p;
    POINT               pt;
    DWORD               childnum;
    DWORD               i;
    HPEN                hpen;
    HPEN                oldhpen;


    switch (message) {
        case WM_CREATE:
            hli = (LPHLISTINFO) malloc( sizeof(HLISTINFO) );
            ZeroMemory( hli, sizeof(HLISTINFO) );
            GetClientRect( hwnd, &cRect );
            hli->hwndList = CreateWindow(
                "LISTBOX",
                NULL,
                DEFAULT_STYLE,
                cRect.left,
                cRect.top,
                cRect.right  - cRect.left,
                cRect.bottom - cRect.top,
                hwnd,
                NULL,
                GetModuleHandle(NULL),
                NULL );
            hFont = GetStockObject( SYSTEM_FIXED_FONT );
            SendMessage( hli->hwndList, WM_SETFONT, (WPARAM)hFont, (LPARAM)FALSE );
            SetFocus( hli->hwndList );
            SetWindowLong( hwnd, 0, (DWORD)hli );
            break;

        case WM_SIZE:
            hli = (LPHLISTINFO) GetWindowLong( hwnd, 0 );
            GetClientRect( hwnd, &cRect );
            MoveWindow(
                hli->hwndList,
                cRect.left,
                cRect.top,
                cRect.right - cRect.left,
                cRect.bottom - cRect.top,
                TRUE );
            break;

        case WM_DESTROY:
            hli = (LPHLISTINFO) GetWindowLong( hwnd, 0 );
            hlt = hli->typeList;
            while (hlt) {
                hltNext = hlt->next;
                free( hlt );
                hlt = hltNext;
            }
            DestroyWindow( hli->hwndList );
            hli->hwndList = NULL;
            free( hli );
            SetWindowLong( hwnd, 0, 0 );
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == LBN_DBLCLK) {
                hli = (LPHLISTINFO) GetWindowLong( hwnd, 0 );
                if (hli->lpCallback) {
                    nItem = SendMessage( hli->hwndList, LB_GETCURSEL, 0, 0 );

                    lpidParent = (LPITEMDATA) SendMessage( hli->hwndList, LB_GETITEMDATA, nItem, 0 );

                    y = 0;
                    lpid = lpidParent;
                    while (lpid) {
                        y += (strlen(lpid->str) + 1);
                        lpid = lpid->parent;
                    }
                    y += 16;
                    p = ref = malloc( y );
                    lpid = lpidParent;
                    while (lpid) {
                        strcpy( p, lpid->str );
                        p += (strlen(p) + 1);
                        lpid = lpid->parent;
                    }
                    *p = '\0';

                    level = lpidParent->level + 1;
                    type = lpidParent->type;
                    str = lpidParent->str;
                    rval = (hli->lpCallback)( &type, &str, ref, level, lpidParent->nchild );

                    if (rval == HLB_COLLAPSE) {
                        CollapseNode( hli->hwndList, lpidParent, nItem+1 );
                        break;
                    }

                    childnum = 1;
                    while (rval != HLB_END) {
                        if (rval == HLB_EXPAND) {
                            hlt = hli->typeList;
                            while (hlt && hlt->type != type) {
                                hlt = hlt->next;
                            }
                            if (!hlt) {
                                break;
                            }
                            lpidParent->nchild++;
                            lpid = (LPITEMDATA) malloc( sizeof(ITEMDATA) );
                            lpid->type = type;
                            lpid->nchild = 0;
                            lpid->level = level;
                            lpid->bitmap = hlt->bitmap;
                            lpid->str = _strdup( (LPSTR)str );
                            lpid->parent = lpidParent;
                            lpid->childnum = childnum++;
                            nItem = SendMessage( hli->hwndList, LB_INSERTSTRING, nItem+1, (LPARAM)lpid->str );
                            SendMessage( hli->hwndList, LB_SETITEMDATA, nItem, (LPARAM) lpid );
                        }
                        rval = (hli->lpCallback)( &type, &str, ref, level, 0 );
                    }
                    free( ref );
                }
            }
            break;

        case HLB_REGISTER_CALLBACK:
            hli = (LPHLISTINFO) GetWindowLong( hwnd, 0 );
            hli->lpCallback = (HLISTCALLBACK) lParam;
            return 1;

        case HLB_REGISTER_TYPE:
            //
            // wParam = type token
            // lParam = the bitmap
            //
            hli = (LPHLISTINFO) GetWindowLong( hwnd, 0 );
            if (!hli->typeList) {
                hli->typeList = (LPHLISTTYPE) malloc( sizeof(HLISTTYPE) );
                hlt = hli->typeList;
            } else {
                hlt = hli->typeList;
                while (hlt->next) {
                    hlt = hlt->next;
                }
                hlt->next = (LPHLISTTYPE) malloc( sizeof(HLISTTYPE) );
                hlt = hlt->next;
            }
            hlt->type = (WPARAM) wParam;
            hlt->bitmap = (HBITMAP) lParam;
            hlt->next = NULL;
            return 1;

        case HLB_ADDSTRING:
            //
            // wParam = type
            // lParam = string
            //
            hli = (LPHLISTINFO) GetWindowLong( hwnd, 0 );
            hlt = hli->typeList;
            while (hlt && hlt->type != wParam) {
                hlt = hlt->next;
            }
            if (!hlt) {
                return 0;
            }
            lpid = (LPITEMDATA) malloc( sizeof(ITEMDATA) );
            lpid->type = hlt->type;
            lpid->level = 0;
            lpid->nchild = 0;
            lpid->bitmap = hlt->bitmap;
            lpid->str = _strdup( (LPSTR)lParam );
            lpid->parent = NULL;
            lpid->childnum = 0;
            nItem = SendMessage( hli->hwndList, LB_ADDSTRING, 0, (LPARAM)lpid->str );
            SendMessage( hli->hwndList, LB_SETITEMDATA, nItem, (LPARAM) lpid );
            return 1;

        case WM_MEASUREITEM:
            lpmis = (LPMEASUREITEMSTRUCT) lParam;
            lpmis->itemHeight  = YBITMAP;
            return 1;

        case WM_DELETEITEM:
            lplis = (LPDELETEITEMSTRUCT) lParam;
            lpid = (LPITEMDATA) lplis->itemData;
            free( lpid->str );
            free( lpid );
            return 1;

        case WM_DRAWITEM:
            lpdis = (LPDRAWITEMSTRUCT) lParam;

            if (lpdis->itemID == -1) {
                break;
            }

            switch (lpdis->itemAction) {
                case ODA_SELECT:
                case ODA_DRAWENTIRE:
                    lpid = (LPITEMDATA) SendMessage( lpdis->hwndItem, LB_GETITEMDATA, lpdis->itemID, 0 );
                    hbmp = lpid->bitmap;

                    hdc = CreateCompatibleDC( lpdis->hDC );
                    hbmpOld = SelectObject( hdc, hbmp );

                    lpdis->rcItem.left +=  (lpid->level * INDENT);

                    BitBlt(
                        lpdis->hDC,
                        lpdis->rcItem.left,
                        lpdis->rcItem.top,
                        lpdis->rcItem.right - lpdis->rcItem.left,
                        lpdis->rcItem.bottom - lpdis->rcItem.top,
                        hdc,
                        0,
                        0,
                        SRCCOPY );

                    GetTextMetrics( lpdis->hDC, &tm );

                    y = (lpdis->rcItem.bottom + lpdis->rcItem.top - tm.tmHeight) / 2;

                    TextOut( lpdis->hDC, XBITMAP + MARGIN + (lpid->level * INDENT), y, lpid->str, strlen(lpid->str) );

                    SelectObject( hdc, hbmpOld );

                    //
                    // now draw lines
                    //
                    if (lpid->level) {

                        hpen = CreatePen( PS_SOLID, 1, LINE_COLOR );
                        oldhpen = SelectObject( lpdis->hDC, hpen );

                        y = lpdis->rcItem.top + ((lpdis->rcItem.bottom - lpdis->rcItem.top) / 2);
                        MoveToEx(
                            lpdis->hDC,
                            lpdis->rcItem.left - 1,
                            y,
                            &pt );

                        LineTo(
                            lpdis->hDC,
                            lpdis->rcItem.left - MIDDLE,
                            y );

                        MoveToEx(
                            lpdis->hDC,
                            lpdis->rcItem.left - MIDDLE,
                            lpdis->rcItem.top,
                            &pt );

                        if (lpid->childnum < lpid->parent->nchild) {
                            y = lpdis->rcItem.bottom;
                        } else {
                            y++;
                        }

                        LineTo(
                            lpdis->hDC,
                            lpdis->rcItem.left - MIDDLE,
                            y );

                        if (lpid->level > 1) {
                            x = lpdis->rcItem.left - MIDDLE;
                            y = lpdis->rcItem.top;
                            for (i=1; i<lpid->level; i++) {
                                MoveToEx(
                                    lpdis->hDC,
                                    x - (i * INDENT),
                                    y,
                                    &pt );
                                LineTo(
                                    lpdis->hDC,
                                    x - (i * INDENT),
                                    lpdis->rcItem.bottom );
                            }
                        }

                        SelectObject( lpdis->hDC, oldhpen );
                        DeleteObject( hpen );
                    }

                    DeleteDC( hdc );

                    if (lpdis->itemState & ODS_SELECTED) {
                        rcBitmap.left = lpdis->rcItem.left;
                        rcBitmap.top = lpdis->rcItem.top;
                        rcBitmap.right = lpdis->rcItem.left + XBITMAP + (tm.tmMaxCharWidth * strlen(lpid->str)) + MARGIN + 2;
                        rcBitmap.bottom = lpdis->rcItem.top + YBITMAP;
                        DrawFocusRect( lpdis->hDC, &rcBitmap );
                    }

                    break;

                case ODA_FOCUS:
                    break;
            }
            return 1;

        case LB_ADDSTRING:
            return SendMessage( hwnd, HLB_ADDSTRING, 1, lParam );

        case LB_INSERTSTRING:
        case LB_DELETESTRING:
        case LB_SELITEMRANGEEX:
        case LB_RESETCONTENT:
        case LB_SETSEL:
        case LB_SETCURSEL:
        case LB_GETSEL:
        case LB_GETCURSEL:
        case LB_GETTEXT:
        case LB_GETTEXTLEN:
        case LB_GETCOUNT:
        case LB_SELECTSTRING:
        case LB_DIR:
        case LB_ADDFILE:
        case LB_GETTOPINDEX:
        case LB_FINDSTRING:
        case LB_GETSELCOUNT:
        case LB_GETSELITEMS:
        case LB_SETTABSTOPS:
        case LB_GETHORIZONTALEXTENT:
        case LB_SETHORIZONTALEXTENT:
        case LB_SETCOLUMNWIDTH:
        case LB_SETTOPINDEX:
        case LB_GETITEMRECT:
        case LB_GETITEMDATA:
        case LB_SETITEMDATA:
        case LB_SELITEMRANGE:
        case LB_SETANCHORINDEX:
        case LB_GETANCHORINDEX:
        case LB_SETCARETINDEX:
        case LB_GETCARETINDEX:
        case LB_SETITEMHEIGHT:
        case LB_GETITEMHEIGHT:
        case LB_FINDSTRINGEXACT:
        case LB_SETLOCALE:
        case LB_GETLOCALE:
        case LB_SETCOUNT:
            hli = (LPHLISTINFO) GetWindowLong( hwnd, 0 );
            return SendMessage( hli->hwndList, message, wParam, lParam );
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\iml.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    iml.h

Abstract:

    Header for for creating, accessing and manipulating Installation Modification
    Log files (.IML extension) created by INSTALER.EXE

Author:

    Steve Wood (stevewo) 23-Jan-1996

--*/

typedef ULONG POFFSET;

#define MP(t,b,o) ((t)((o) ? (PVOID)((ULONG)(b) + (o)) : NULL))

typedef struct _INSTALLATION_MODIFICATION_LOGFILE {
    ULONG Signature;
    USHORT HeaderSize;
    USHORT Flags;
    HANDLE FileHandle;
    ULONG FileOffset;
    ULONG NumberOfFileRecords;
    POFFSET FileRecords;            // IML_FILE_RECORD
    ULONG NumberOfKeyRecords;
    POFFSET KeyRecords;             // IML_KEY_RECORD
    ULONG NumberOfIniRecords;
    POFFSET IniRecords;             // IML_INI_RECORD
} INSTALLATION_MODIFICATION_LOGFILE, *PINSTALLATION_MODIFICATION_LOGFILE;

#define IML_SIGNATURE 0xFF0AA0FF

#define IML_FLAG_CONTAINS_NEWFILECONTENTS 0x0001
#define IML_FLAG_ACTIONS_UNDONE           0x0002

PWSTR
FormatImlPath(
    PWSTR DirectoryPath,
    PWSTR InstallationName
    );

PINSTALLATION_MODIFICATION_LOGFILE
CreateIml(
    PWSTR ImlPath,
    BOOLEAN IncludeCreateFileContents
    );

PINSTALLATION_MODIFICATION_LOGFILE
LoadIml(
    PWSTR ImlPath
    );

BOOLEAN
CloseIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml
    );

typedef enum _IML_FILE_ACTION {
    CreateNewFile,
    ModifyOldFile,
    DeleteOldFile,
    ModifyFileDateTime,
    ModifyFileAttributes
} IML_FILE_ACTION;

typedef struct _IML_FILE_RECORD_CONTENTS {
    FILETIME LastWriteTime;
    DWORD FileAttributes;
    DWORD FileSize;
    POFFSET Contents;               // VOID
} IML_FILE_RECORD_CONTENTS, *PIML_FILE_RECORD_CONTENTS;


typedef struct _IML_FILE_RECORD {
    POFFSET Next;                   // IML_FILE_RECORD
    IML_FILE_ACTION Action;
    POFFSET Name;                   // WCHAR
    POFFSET OldFile;                // IML_FILE_RECORD_CONTENTS
    POFFSET NewFile;                // IML_FILE_RECORD_CONTENTS
} IML_FILE_RECORD, *PIML_FILE_RECORD;

BOOLEAN
ImlAddFileRecord(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    IML_FILE_ACTION Action,
    PWSTR Name,
    PWSTR BackupFileName,
    PFILETIME BackupLastWriteTime,
    DWORD BackupFileAttributes
    );

typedef enum _IML_VALUE_ACTION {
    CreateNewValue,
    DeleteOldValue,
    ModifyOldValue
} IML_VALUE_ACTION;

typedef struct _IML_VALUE_RECORD_CONTENTS {
    DWORD Type;
    DWORD Length;
    POFFSET Data;                   // VOID
} IML_VALUE_RECORD_CONTENTS, *PIML_VALUE_RECORD_CONTENTS;

typedef struct _IML_VALUE_RECORD {
    POFFSET Next;                   // IML_VALUE_RECORD
    IML_VALUE_ACTION Action;
    POFFSET Name;                   // WCHAR
    POFFSET OldValue;               // IML_VALUE_RECORD_CONTENTS
    POFFSET NewValue;               // IML_VALUE_RECORD_CONTENTS
} IML_VALUE_RECORD, *PIML_VALUE_RECORD;

BOOLEAN
ImlAddValueRecord(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    IML_VALUE_ACTION Action,
    PWSTR Name,
    DWORD ValueType,
    ULONG ValueLength,
    PVOID ValueData,
    DWORD BackupValueType,
    ULONG BackupValueLength,
    PVOID BackupValueData,
    POFFSET *Values                 // IML_VALUE_RECORD
    );

typedef enum _IML_KEY_ACTION {
    CreateNewKey,
    DeleteOldKey,
    ModifyKeyValues
} IML_KEY_ACTION;

typedef struct _IML_KEY_RECORD {
    POFFSET Next;                   // IML_KEY_RECORD
    IML_KEY_ACTION Action;
    POFFSET Name;                   // WCHAR
    POFFSET Values;                 // IML_VALUE_RECORD
} IML_KEY_RECORD, *PIML_KEY_RECORD;

BOOLEAN
ImlAddKeyRecord(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    IML_KEY_ACTION Action,
    PWSTR Name,
    POFFSET Values                  // IML_VALUE_RECORD
    );

typedef enum _IML_INIVARIABLE_ACTION {
    CreateNewVariable,
    DeleteOldVariable,
    ModifyOldVariable
} IML_INIVARIABLE_ACTION;

typedef struct _IML_INIVARIABLE_RECORD {
    POFFSET Next;                   // IML_INIVARIABLE_RECORD
    IML_INIVARIABLE_ACTION Action;
    POFFSET Name;                   // WCHAR
    POFFSET OldValue;               // WCHAR
    POFFSET NewValue;               // WCHAR
} IML_INIVARIABLE_RECORD, *PIML_INIVARIABLE_RECORD;

BOOLEAN
ImlAddIniVariableRecord(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    IML_INIVARIABLE_ACTION Action,
    PWSTR Name,
    PWSTR OldValue,
    PWSTR NewValue,
    POFFSET *Variables              // IML_INIVARIABLE_RECORD
    );

typedef enum _IML_INISECTION_ACTION {
    CreateNewSection,
    DeleteOldSection,
    ModifySectionVariables
} IML_INISECTION_ACTION;

typedef struct _IML_INISECTION_RECORD {
    POFFSET Next;                   // IML_INISECTION_RECORD
    IML_INISECTION_ACTION Action;
    POFFSET Name;                   // WCHAR
    POFFSET Variables;              // IML_INIVARIABLE_RECORD
} IML_INISECTION_RECORD, *PIML_INISECTION_RECORD;

BOOLEAN
ImlAddIniSectionRecord(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    IML_INISECTION_ACTION Action,
    PWSTR Name,
    POFFSET Variables,              // IML_INIVARIABLE_RECORD
    POFFSET *Sections               // IML_INISECTION_RECORD
    );

typedef enum _IML_INI_ACTION {
    CreateNewIniFile,
    ModifyOldIniFile
} IML_INI_ACTION;

typedef struct _IML_INI_RECORD {
    POFFSET Next;                   // IML_INI_RECORD
    IML_INI_ACTION Action;
    POFFSET Name;                   // WCHAR
    POFFSET Sections;               // IML_INISECTION_RECORD
    FILETIME LastWriteTime;
} IML_INI_RECORD, *PIML_INI_RECORD;


BOOLEAN
ImlAddIniRecord(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    IML_INI_ACTION Action,
    PWSTR Name,
    PFILETIME BackupLastWriteTime,
    POFFSET Sections                // IML_INISECTION_RECORD
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\iml.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    iml.c

Abstract:

    This module contains routines for creating and accessing Installation
    Modification Log files (.IML)

Author:

    Steve Wood (stevewo) 15-Jan-1996

Revision History:

--*/

#include "instutil.h"
#include "iml.h"

PWSTR
FormatImlPath(
    PWSTR DirectoryPath,
    PWSTR InstallationName
    )
{
    PWSTR ImlPath;
    ULONG n;

    n = wcslen( DirectoryPath ) + wcslen( InstallationName ) + 8;
    ImlPath = HeapAlloc( GetProcessHeap(), 0, (n  * sizeof( WCHAR )) );
    if (ImlPath != NULL) {
        _snwprintf( ImlPath, n, L"%s%s.IML", DirectoryPath, InstallationName );
        }

    return ImlPath;
}


PINSTALLATION_MODIFICATION_LOGFILE
CreateIml(
    PWSTR ImlPath,
    BOOLEAN IncludeCreateFileContents
    )
{
    HANDLE FileHandle;
    PINSTALLATION_MODIFICATION_LOGFILE pIml;

    pIml = NULL;
    FileHandle = CreateFile( ImlPath,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_ALWAYS,
                             0,
                             NULL
                           );
    if (FileHandle != INVALID_HANDLE_VALUE) {
        pIml = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof( *pIml ) );
        if (pIml != NULL) {
            pIml->Signature = IML_SIGNATURE;
            pIml->FileHandle = FileHandle;
            pIml->FileOffset = ROUND_UP( sizeof( *pIml ), 8 );
            if (IncludeCreateFileContents) {
                pIml->Flags = IML_FLAG_CONTAINS_NEWFILECONTENTS;
                }

            SetFilePointer( pIml->FileHandle, pIml->FileOffset, NULL, FILE_BEGIN );
            }
        }

    return pIml;
}


PINSTALLATION_MODIFICATION_LOGFILE
LoadIml(
    PWSTR ImlPath
    )
{
    HANDLE FileHandle, MappingHandle;
    PINSTALLATION_MODIFICATION_LOGFILE pIml;

    pIml = NULL;
    FileHandle = CreateFile( ImlPath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );
    if (FileHandle != INVALID_HANDLE_VALUE) {
        MappingHandle = CreateFileMapping( FileHandle,
                                           NULL,
                                           PAGE_READONLY,
                                           0,
                                           0,
                                           NULL
                                         );
        CloseHandle( FileHandle );
        if (MappingHandle != NULL) {
            pIml = MapViewOfFile( MappingHandle,
                                  FILE_MAP_READ,
                                  0,
                                  0,
                                  0
                                );
            CloseHandle( MappingHandle );
            if (pIml != NULL) {
                if (pIml->Signature != IML_SIGNATURE) {
                    UnmapViewOfFile( pIml );
                    pIml = NULL;
                    SetLastError( ERROR_BAD_FORMAT );
                    }

                }
            }
        }

    return pIml;
}


BOOLEAN
CloseIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml
    )
{
    HANDLE FileHandle;
    BOOLEAN Result;
    ULONG BytesWritten;

    if (pIml->FileHandle == NULL) {
        if (!UnmapViewOfFile( pIml )) {
            return FALSE;
            }
        else {
            Result = TRUE;
            }
        }
    else {
        FileHandle = pIml->FileHandle;
        pIml->FileHandle = NULL;
        if (!SetEndOfFile( FileHandle ) ||
            SetFilePointer( FileHandle, 0, NULL, FILE_BEGIN ) != 0 ||
            !WriteFile( FileHandle,
                        pIml,
                        sizeof( *pIml ),
                        &BytesWritten,
                        NULL
                      ) ||
            BytesWritten != sizeof( *pIml )
           ) {
            Result = FALSE;
            }
        else {
            Result = TRUE;
            }
        CloseHandle( FileHandle );
        }

    return Result;
}


POFFSET
ImlWrite(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    PVOID p,
    ULONG Size
    )
{
    POFFSET Result;
    ULONG BytesWritten;

    if (!WriteFile( pIml->FileHandle,
                    p,
                    Size,
                    &BytesWritten,
                    NULL
                  ) ||
        BytesWritten != Size
       ) {
        return 0;
        }

    Result = pIml->FileOffset;
    pIml->FileOffset += ROUND_UP( Size, 8 );
    SetFilePointer( pIml->FileHandle,
                    pIml->FileOffset,
                    NULL,
                    FILE_BEGIN
                  );
    return Result;
}

POFFSET
ImlWriteString(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    PWSTR Name
    )
{
    if (Name == NULL) {
        return 0;
        }
    else {
        return ImlWrite( pIml, Name, (wcslen( Name ) + 1) * sizeof( WCHAR ) );
        }
}


POFFSET
ImlWriteFileContents(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    PWSTR FileName
    )
{
    HANDLE hFindFirst, hFile, hMapping;
    WIN32_FIND_DATA FindFileData;
    PVOID p;
    IML_FILE_RECORD_CONTENTS ImlFileContentsRecord;

    hFindFirst = FindFirstFile( FileName, &FindFileData );
    if (hFindFirst == INVALID_HANDLE_VALUE) {
        return 0;
        }
    FindClose( hFindFirst );

    ImlFileContentsRecord.LastWriteTime = FindFileData.ftLastWriteTime;
    ImlFileContentsRecord.FileAttributes = FindFileData.dwFileAttributes;
    if (!(ImlFileContentsRecord.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        ImlFileContentsRecord.FileSize = FindFileData.nFileSizeLow;
        hFile = CreateFile( FileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL
                          );
        if (hFile == INVALID_HANDLE_VALUE) {
            printf( "*** CreateFile( '%ws' ) failed (%u)\n", FileName, GetLastError() );
            return 0;
            }

        if (ImlFileContentsRecord.FileSize != 0) {
            hMapping = CreateFileMapping( hFile,
                                         NULL,
                                         PAGE_READONLY,
                                         0,
                                         0,
                                         NULL
                                       );
            CloseHandle( hFile );
            hFile = NULL;
            if (hMapping == NULL) {
                printf( "*** CreateFileMapping( '%ws' ) failed (%u)\n", FileName, GetLastError() );
                return 0;
                }

            p = MapViewOfFile( hMapping,
                               FILE_MAP_READ,
                               0,
                               0,
                               0
                             );
            CloseHandle( hMapping );
            if (p == NULL) {
                printf( "*** MapViewOfFile( '%ws' ) failed (%u)\n", FileName, GetLastError() );
                return 0;
                }
            }
        else {
            CloseHandle( hFile );
            p = NULL;
            }
        }
    else {
        ImlFileContentsRecord.FileSize = 0;
        p = NULL;
        }

    ImlFileContentsRecord.Contents = ImlWrite( pIml, p, ImlFileContentsRecord.FileSize );
    if (p != NULL) {
        UnmapViewOfFile( p );
        }

    return ImlWrite( pIml,
                     &ImlFileContentsRecord,
                     sizeof( ImlFileContentsRecord )
                   );
}

BOOLEAN
ImlAddFileRecord(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    IML_FILE_ACTION Action,
    PWSTR Name,
    PWSTR BackupFileName,
    PFILETIME BackupLastWriteTime,
    DWORD BackupFileAttributes
    )
{
    IML_FILE_RECORD ImlFileRecord;
    IML_FILE_RECORD_CONTENTS ImlFileContentsRecord;

    memset( &ImlFileRecord, 0, sizeof( ImlFileRecord ) );
    ImlFileRecord.Action = Action;
    ImlFileRecord.Name = ImlWriteString( pIml, Name );
    if (Action == CreateNewFile) {
        if ((pIml->Flags & IML_FLAG_CONTAINS_NEWFILECONTENTS) != 0) {
            ImlFileRecord.NewFile = ImlWriteFileContents( pIml, Name );
            }
        }
    else
    if (Action == ModifyOldFile ||
        Action == DeleteOldFile
       ) {
        if (BackupFileName != NULL) {
            ImlFileRecord.OldFile = ImlWriteFileContents( pIml, BackupFileName );
            }

        if (Action == ModifyOldFile &&
            (pIml->Flags & IML_FLAG_CONTAINS_NEWFILECONTENTS) != 0
           ) {
            ImlFileRecord.NewFile = ImlWriteFileContents( pIml, Name );
            }
        }
    else {
        ImlFileContentsRecord.LastWriteTime = *BackupLastWriteTime;
        ImlFileContentsRecord.FileAttributes = BackupFileAttributes;
        ImlFileContentsRecord.FileSize = 0;
        ImlFileContentsRecord.Contents = 0;
        ImlFileRecord.OldFile = ImlWrite( pIml,
                                          &ImlFileContentsRecord,
                                          sizeof( ImlFileContentsRecord )
                                        );
        }

    ImlFileRecord.Next = pIml->FileRecords;
    pIml->FileRecords = ImlWrite( pIml, &ImlFileRecord, sizeof( ImlFileRecord ) );
    pIml->NumberOfFileRecords += 1;
    return TRUE;
}


BOOLEAN
ImlAddValueRecord(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    IML_VALUE_ACTION Action,
    PWSTR Name,
    DWORD ValueType,
    ULONG ValueLength,
    PVOID ValueData,
    DWORD BackupValueType,
    ULONG BackupValueLength,
    PVOID BackupValueData,
    POFFSET *Values
    )
{
    IML_VALUE_RECORD ImlValueRecord;
    IML_VALUE_RECORD_CONTENTS ImlValueContentsRecord;

    memset( &ImlValueRecord, 0, sizeof( ImlValueRecord ) );
    ImlValueRecord.Action = Action;
    ImlValueRecord.Name = ImlWriteString( pIml, Name );
    if (Action != DeleteOldValue) {
        ImlValueContentsRecord.Type = ValueType;
        ImlValueContentsRecord.Length = ValueLength;
        ImlValueContentsRecord.Data = ImlWrite( pIml, ValueData, ValueLength );
        ImlValueRecord.NewValue = ImlWrite( pIml,
                                            &ImlValueContentsRecord,
                                            sizeof( ImlValueContentsRecord )
                                          );
        }
    if (Action != CreateNewValue) {
        ImlValueContentsRecord.Type = BackupValueType;
        ImlValueContentsRecord.Length = BackupValueLength;
        ImlValueContentsRecord.Data = ImlWrite( pIml, BackupValueData, BackupValueLength );
        ImlValueRecord.OldValue = ImlWrite( pIml,
                                            &ImlValueContentsRecord,
                                            sizeof( ImlValueContentsRecord )
                                          );
        }

    ImlValueRecord.Next = *Values;
    *Values = ImlWrite( pIml, &ImlValueRecord, sizeof( ImlValueRecord ) );
    return TRUE;
}


BOOLEAN
ImlAddKeyRecord(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    IML_KEY_ACTION Action,
    PWSTR Name,
    POFFSET Values
    )
{
    IML_KEY_RECORD ImlKeyRecord;

    memset( &ImlKeyRecord, 0, sizeof( ImlKeyRecord ) );
    ImlKeyRecord.Action = Action;
    ImlKeyRecord.Name = ImlWriteString( pIml, Name );
    ImlKeyRecord.Values = Values;
    ImlKeyRecord.Next = pIml->KeyRecords;
    pIml->KeyRecords = ImlWrite( pIml, &ImlKeyRecord, sizeof( ImlKeyRecord ) );
    pIml->NumberOfKeyRecords += 1;
    return TRUE;
}



BOOLEAN
ImlAddIniVariableRecord(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    IML_INIVARIABLE_ACTION Action,
    PWSTR Name,
    PWSTR OldValue,
    PWSTR NewValue,
    POFFSET *Variables
    )
{
    IML_INIVARIABLE_RECORD ImlIniVariableRecord;

    memset( &ImlIniVariableRecord, 0, sizeof( ImlIniVariableRecord ) );
    ImlIniVariableRecord.Action = Action;
    ImlIniVariableRecord.Name = ImlWriteString( pIml, Name );
    ImlIniVariableRecord.OldValue = ImlWriteString( pIml, OldValue );
    ImlIniVariableRecord.NewValue = ImlWriteString( pIml, NewValue );
    ImlIniVariableRecord.Next = *Variables;
    *Variables  = ImlWrite( pIml, &ImlIniVariableRecord, sizeof( ImlIniVariableRecord ) );
    return TRUE;
}

BOOLEAN
ImlAddIniSectionRecord(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    IML_INISECTION_ACTION Action,
    PWSTR Name,
    POFFSET Variables,
    POFFSET *Sections
    )
{
    IML_INISECTION_RECORD ImlIniSectionRecord;

    memset( &ImlIniSectionRecord, 0, sizeof( ImlIniSectionRecord ) );
    ImlIniSectionRecord.Action = Action;
    ImlIniSectionRecord.Name = ImlWriteString( pIml, Name );
    ImlIniSectionRecord.Variables = Variables;
    ImlIniSectionRecord.Next = *Sections;
    *Sections  = ImlWrite( pIml, &ImlIniSectionRecord, sizeof( ImlIniSectionRecord ) );
    return TRUE;
}

BOOLEAN
ImlAddIniRecord(
    PINSTALLATION_MODIFICATION_LOGFILE pIml,
    IML_INI_ACTION Action,
    PWSTR Name,
    PFILETIME BackupLastWriteTime,
    POFFSET Sections
    )
{
    IML_INI_RECORD ImlIniRecord;

    memset( &ImlIniRecord, 0, sizeof( ImlIniRecord ) );
    ImlIniRecord.Action = Action;
    ImlIniRecord.Name = ImlWriteString( pIml, Name );
    ImlIniRecord.LastWriteTime = *BackupLastWriteTime;
    ImlIniRecord.Sections = Sections;
    ImlIniRecord.Next = pIml->IniRecords;
    pIml->IniRecords = ImlWrite( pIml, &ImlIniRecord, sizeof( ImlIniRecord ) );
    pIml->NumberOfIniRecords += 1;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\handler.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    handler.c

Abstract:

    This module contains the individual API handler routines for the INSTALER program

Author:

    Steve Wood (stevewo) 10-Aug-1994

Revision History:

--*/

#include "instaler.h"
#include <ntstatus.dbg>


BOOLEAN
HandleBreakpoint(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PBREAKPOINT_INFO Breakpoint
    )
{
    BOOLEAN Result;
    API_SAVED_PARAMETERS SavedParameters;
    UCHAR ApiIndex;
    PBREAKPOINT_INFO ReturnBreakpoint;

    Result = FALSE;
    ApiIndex = Breakpoint->ApiIndex;
    if (ApiInfo[ ApiIndex ].ModuleIndex < Thread->ModuleIndexCurrentlyIn) {
        return TRUE;
        }

    DbgEvent( DBGEVENT, ( "Processing Breakpoint at %ws!%s\n",
                          Breakpoint->ModuleName,
                          Breakpoint->ProcedureName
                        )
            );

    if (!Breakpoint->SavedParametersValid) {
        memset( &SavedParameters, 0, sizeof( SavedParameters ) );

        Result = TRUE;
        if (ExtractProcedureParameters( Process,
                                        Thread,
                                        (PVOID)&SavedParameters.ReturnAddress,
                                        ApiInfo[ ApiIndex ].SizeOfParameters,
                                        (PULONG)&SavedParameters.InputParameters
                                      )
           ) {
            if (ApiInfo[ ApiIndex ].EntryPointHandler == NULL ||
                (ApiInfo[ ApiIndex ].EntryPointHandler)( Process,
                                                         Thread,
                                                         &SavedParameters
                                                       )
               ) {
                if (SavedParameters.ReturnAddress == NULL) {
                    Result = FALSE;
                    }
                else
                if (CreateBreakpoint( SavedParameters.ReturnAddress,
                                      Process,
                                      Thread,  // thread specific
                                      ApiIndex,
                                      &SavedParameters,
                                      &ReturnBreakpoint
                                    )
                   ) {
                    ReturnBreakpoint->ModuleName = L"Return from";
                    ReturnBreakpoint->ProcedureName = Breakpoint->ProcedureName;
                    Thread->ModuleIndexCurrentlyIn = ApiInfo[ ApiIndex ].ModuleIndex;
                    SuspendAllButThisThread( Process, Thread );
                    }
                }
            }

#if DBG
        TrimTemporaryBuffer();
#endif
        }
    else {
        if (UndoReturnAddressBreakpoint( Process, Thread ) &&
            ExtractProcedureReturnValue( Process,
                                         Thread,
                                         &Breakpoint->SavedParameters.ReturnValue,
                                         ApiInfo[ ApiIndex ].SizeOfReturnValue
                                       )
           ) {
            Breakpoint->SavedParameters.ReturnValueValid = TRUE;
            if (ApiInfo[ ApiIndex ].EntryPointHandler != NULL) {
                (ApiInfo[ ApiIndex ].EntryPointHandler)( Process,
                                                         Thread,
                                                         &Breakpoint->SavedParameters
                                                       );
                }
            }

        Thread->ModuleIndexCurrentlyIn = 0;
        FreeSavedCallState( &Breakpoint->SavedParameters.SavedCallState );
        DestroyBreakpoint( Breakpoint->Address, Process, Thread );
        ResumeAllButThisThread( Process, Thread );
#if DBG
        TrimTemporaryBuffer();
#endif
        Result = FALSE;
        }

    return Result;
}


BOOLEAN
CreateSavedCallState(
    PPROCESS_INFO Process,
    PAPI_SAVED_CALL_STATE SavedCallState,
    API_ACTION Action,
    ULONG Type,
    PWSTR FullName,
    ...
    )
{
    va_list arglist;

    va_start( arglist, FullName );
    SavedCallState->Action = Action;
    SavedCallState->Type = Type;
    SavedCallState->FullName = FullName;
    switch (Action) {
        case OpenPath:
            SavedCallState->PathOpen.InheritHandle = va_arg( arglist, BOOLEAN );
            SavedCallState->PathOpen.WriteAccessRequested = va_arg( arglist, BOOLEAN );
            SavedCallState->PathOpen.ResultHandleAddress = va_arg( arglist, PHANDLE );
            break;

        case RenamePath:
            SavedCallState->PathRename.NewName = va_arg( arglist, PWSTR );
            SavedCallState->PathRename.ReplaceIfExists = va_arg( arglist, BOOLEAN );
            break;

        case DeletePath:
        case QueryPath:
        case SetValue:
        case DeleteValue:
            break;

        case WriteIniValue:
            SavedCallState->SetIniValue.SectionName = va_arg( arglist, PWSTR );
            SavedCallState->SetIniValue.VariableName = va_arg( arglist, PWSTR );
            SavedCallState->SetIniValue.VariableValue = va_arg( arglist, PWSTR );
            break;

        case WriteIniSection:
            SavedCallState->SetIniSection.SectionName = va_arg( arglist, PWSTR );
            SavedCallState->SetIniSection.SectionValue = va_arg( arglist, PWSTR );
            break;

        default:
            return FALSE;
        }
    va_end( arglist );

    return TRUE;
}

VOID
FreeSavedCallState(
    PAPI_SAVED_CALL_STATE CallState
    )
{
    switch (CallState->Action) {
        case WriteIniValue:
            FreeMem( &CallState->SetIniValue.VariableValue );
            break;

        case WriteIniSection:
            FreeMem( &CallState->SetIniSection.SectionValue );
            break;
        }

    return;
}



BOOLEAN
CaptureObjectAttributes(
    PPROCESS_INFO Process,
    POBJECT_ATTRIBUTES ObjectAttributesAddress,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PUNICODE_STRING ObjectName
    )
{
    if (ObjectAttributesAddress != NULL &&
        ReadMemory( Process,
                    ObjectAttributesAddress,
                    ObjectAttributes,
                    sizeof( *ObjectAttributes ),
                    "object attributes"
                  ) &&
        ObjectAttributes->ObjectName != NULL &&
        ReadMemory( Process,
                    ObjectAttributes->ObjectName,
                    ObjectName,
                    sizeof( *ObjectName ),
                    "object name string"
                  )
       ) {
        return TRUE;
        }
    else {
        return FALSE;
        }
}

BOOLEAN
CaptureFullName(
    PPROCESS_INFO Process,
    ULONG Type,
    HANDLE RootDirectory,
    PWSTR Name,
    ULONG Length,
    PWSTR *ReturnedFullName
    )
{
    POPENHANDLE_INFO HandleInfo;
    UNICODE_STRING FullName;
    ULONG LengthOfName;
    PWSTR s;
    BOOLEAN Result;

    *ReturnedFullName = NULL;
    if (RootDirectory != NULL) {
        HandleInfo = FindOpenHandle( Process,
                                     RootDirectory,
                                     Type
                                   );
        if (HandleInfo == NULL) {
            //
            // If handle not found then we dont care about this open
            // as it is relative to a device that is not local.
            //
            return FALSE;
            }
        }
    else {
        HandleInfo = NULL;
        }

    LengthOfName = Length + sizeof( UNICODE_NULL );
    if (HandleInfo != NULL) {
        LengthOfName += HandleInfo->LengthOfName +
                        sizeof( OBJ_NAME_PATH_SEPARATOR );
        }

    FullName.Buffer = AllocMem( LengthOfName );
    if (FullName.Buffer == NULL) {
        return FALSE;
        }

    s = FullName.Buffer;
    if (HandleInfo != NULL) {
        RtlMoveMemory( s,
                       HandleInfo->Name,
                       HandleInfo->LengthOfName
                     );
        s = &FullName.Buffer[ HandleInfo->LengthOfName / sizeof( WCHAR ) ];
        if (s[-1] != OBJ_NAME_PATH_SEPARATOR) {
            *s++ = OBJ_NAME_PATH_SEPARATOR;
            }
        }

    if (!ReadMemory( Process,
                     Name,
                     s,
                     Length,
                     "object name buffer"
                   )
       ) {
        FreeMem( &FullName.Buffer );
        return FALSE;
        }

    s = &s[ Length / sizeof( WCHAR ) ];
    *s = UNICODE_NULL;
    FullName.Length = (PCHAR)s - (PCHAR)FullName.Buffer;
    FullName.MaximumLength = (USHORT)(FullName.Length + sizeof( UNICODE_NULL ));
    if (HandleInfo == NULL && Type == HANDLE_TYPE_FILE) {
        Result = IsDriveLetterPath( &FullName );
        }
    else {
        Result = TRUE;
        }
    *ReturnedFullName = AddName( &FullName );
    FreeMem( &FullName.Buffer );
    return Result;
}


BOOLEAN
CaptureOpenState(
    PPROCESS_INFO Process,
    PAPI_SAVED_PARAMETERS Parameters,
    POBJECT_ATTRIBUTES ObjectAttributesAddress,
    BOOLEAN WriteAccess,
    PHANDLE ResultHandleAddress,
    ULONG Type
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ObjectName;
    PWSTR FullName;
    BOOLEAN Result;

    Result = FALSE;
    if (CaptureObjectAttributes( Process,
                                 ObjectAttributesAddress,
                                 &ObjectAttributes,
                                 &ObjectName
                               ) &&
        CaptureFullName( Process,
                         Type,
                         ObjectAttributes.RootDirectory,
                         ObjectName.Buffer,
                         ObjectName.Length,
                         &FullName
                       ) &&
        CreateSavedCallState( Process,
                              &Parameters->SavedCallState,
                              OpenPath,
                              Type,
                              FullName,
                              (BOOLEAN)((ObjectAttributes.Attributes & OBJ_INHERIT) != 0),
                              WriteAccess,
                              ResultHandleAddress
                            )
       ) {
        if (Type == HANDLE_TYPE_FILE) {
            Result = CreateFileReference( FullName,
                                          Parameters->SavedCallState.PathOpen.WriteAccessRequested,
                                          (PFILE_REFERENCE *)&Parameters->SavedCallState.Reference
                                        );
            }
        else {
            Result = CreateKeyReference( FullName,
                                         Parameters->SavedCallState.PathOpen.WriteAccessRequested,
                                         (PKEY_REFERENCE *)&Parameters->SavedCallState.Reference
                                       );
            }
        }

    return Result;
}


BOOLEAN
CompleteOpenState(
    PPROCESS_INFO Process,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PAPI_SAVED_CALL_STATE p = &Parameters->SavedCallState;
    HANDLE Handle;
    BOOLEAN CallSuccessful;
    PFILE_REFERENCE FileReference;
    PKEY_REFERENCE KeyReference;

    if (NT_SUCCESS( Parameters->ReturnValue.ReturnedLong ) &&
        ReadMemory( Process,
                    p->PathOpen.ResultHandleAddress,
                    &Handle,
                    sizeof( Handle ),
                    "result handle"
                  ) &&
        AddOpenHandle( Process,
                       Handle,
                       p->Type,
                       p->FullName,
                       p->PathOpen.InheritHandle
                     )
       ) {
        CallSuccessful = TRUE;
        }
    else {
        CallSuccessful = FALSE;
        }
    IncrementOpenCount( p->FullName, CallSuccessful );

    if (p->Type == HANDLE_TYPE_FILE) {
        FileReference = (PFILE_REFERENCE)p->Reference;
        CompleteFileReference( FileReference,
                               CallSuccessful,
                               FALSE,
                               NULL
                             );
        }
    else
    if (p->Type == HANDLE_TYPE_KEY) {
        KeyReference = (PKEY_REFERENCE)p->Reference;
        CompleteKeyReference( (PKEY_REFERENCE)p->Reference,
                              CallSuccessful,
                              FALSE
                            );
        }

    return TRUE;
}

#if TRACE_ENABLED


ENUM_TYPE_NAMES FileAccessNames[] = {
    FILE_READ_DATA,                 "FILE_READ_DATA",
    FILE_READ_DATA,                 "FILE_READ_DATA",
    FILE_WRITE_DATA,                "FILE_WRITE_DATA",
    FILE_APPEND_DATA,               "FILE_APPEND_DATA",
    FILE_READ_EA,                   "FILE_READ_EA",
    FILE_WRITE_EA,                  "FILE_WRITE_EA",
    FILE_EXECUTE,                   "FILE_EXECUTE",
    FILE_DELETE_CHILD,              "FILE_DELETE_CHILD",
    FILE_READ_ATTRIBUTES,           "FILE_READ_ATTRIBUTES",
    FILE_WRITE_ATTRIBUTES,          "FILE_WRITE_ATTRIBUTES",
    DELETE,                         "DELETE",
    READ_CONTROL,                   "READ_CONTROL",
    WRITE_DAC,                      "WRITE_DAC",
    WRITE_OWNER,                    "WRITE_OWNER",
    SYNCHRONIZE,                    "SYNCHRONIZE",
    GENERIC_READ,                   "GENERIC_READ",
    GENERIC_WRITE,                  "GENERIC_WRITE",
    GENERIC_EXECUTE,                "GENERIC_EXECUTE",
    GENERIC_ALL,                    "GENERIC_ALL",
    0xFFFFFFFF,                     "%x"
};


ENUM_TYPE_NAMES FileShareNames[] = {
    FILE_SHARE_READ,                "FILE_SHARE_READ",
    FILE_SHARE_WRITE,               "FILE_SHARE_WRITE",
    FILE_SHARE_DELETE,              "FILE_SHARE_DELETE",
    0xFFFFFFFF,                     "FILE_SHARE_NONE"
};

ENUM_TYPE_NAMES FileCreateDispositionNames[] = {
    FILE_SUPERSEDE,                 "FILE_SUPERSEDE",
    FILE_OPEN,                      "FILE_OPEN",
    FILE_CREATE,                    "FILE_CREATE",
    FILE_OPEN_IF,                   "FILE_OPEN_IF",
    FILE_OVERWRITE,                 "FILE_OVERWRITE",
    FILE_OVERWRITE_IF,              "FILE_OVERWRITE_IF",
    0xFFFFFFFF,                     "%x"
};

ENUM_TYPE_NAMES FileCreateOptionNames[] = {
    FILE_DIRECTORY_FILE,            "FILE_DIRECTORY_FILE",
    FILE_WRITE_THROUGH,             "FILE_WRITE_THROUGH",
    FILE_SEQUENTIAL_ONLY,           "FILE_SEQUENTIAL_ONLY",
    FILE_NO_INTERMEDIATE_BUFFERING, "FILE_NO_INTERMEDIATE_BUFFERING",
    FILE_SYNCHRONOUS_IO_ALERT,      "FILE_SYNCHRONOUS_IO_ALERT",
    FILE_SYNCHRONOUS_IO_NONALERT,   "FILE_SYNCHRONOUS_IO_NONALERT",
    FILE_NON_DIRECTORY_FILE,        "FILE_NON_DIRECTORY_FILE",
    FILE_CREATE_TREE_CONNECTION,    "FILE_CREATE_TREE_CONNECTION",
    FILE_COMPLETE_IF_OPLOCKED,      "FILE_COMPLETE_IF_OPLOCKED",
    FILE_NO_EA_KNOWLEDGE,           "FILE_NO_EA_KNOWLEDGE",
    FILE_RANDOM_ACCESS,             "FILE_RANDOM_ACCESS",
    FILE_DELETE_ON_CLOSE,           "FILE_DELETE_ON_CLOSE",
    FILE_OPEN_BY_FILE_ID,           "FILE_OPEN_BY_FILE_ID",
    FILE_OPEN_FOR_BACKUP_INTENT,    "FILE_OPEN_FOR_BACKUP_INTENT",
    FILE_NO_COMPRESSION,            "FILE_NO_COMPRESSION",
    0xFFFFFFFF,                     "%x"
};


ENUM_TYPE_NAMES FileIoStatusInfoNames[] = {
    FILE_SUPERSEDED,                "FILE_SUPERSEDED",
    FILE_OPENED,                    "FILE_OPENED",
    FILE_CREATED,                   "FILE_CREATED",
    FILE_OVERWRITTEN,               "FILE_OVERWRITTEN",
    FILE_EXISTS,                    "FILE_EXISTS",
    FILE_DOES_NOT_EXIST,            "FILE_DOES_NOT_EXIST",
    0xFFFFFFFF,                     "%x"
};


ENUM_TYPE_NAMES SetFileInfoClassNames[] = {
    FileDirectoryInformation,       "FileDirectoryInformation",
    FileFullDirectoryInformation,   "FileFullDirectoryInformation",
    FileBothDirectoryInformation,   "FileBothDirectoryInformation",
    FileBasicInformation,           "FileBasicInformation",
    FileStandardInformation,        "FileStandardInformation",
    FileInternalInformation,        "FileInternalInformation",
    FileEaInformation,              "FileEaInformation",
    FileAccessInformation,          "FileAccessInformation",
    FileNameInformation,            "FileNameInformation",
    FileRenameInformation,          "FileRenameInformation",
    FileLinkInformation,            "FileLinkInformation",
    FileNamesInformation,           "FileNamesInformation",
    FileDispositionInformation,     "FileDispositionInformation",
    FilePositionInformation,        "FilePositionInformation",
    FileFullEaInformation,          "FileFullEaInformation",
    FileModeInformation,            "FileModeInformation",
    FileAlignmentInformation,       "FileAlignmentInformation",
    FileAllInformation,             "FileAllInformation",
    FileAllocationInformation,      "FileAllocationInformation",
    FileEndOfFileInformation,       "FileEndOfFileInformation",
    FileAlternateNameInformation,   "FileAlternateNameInformation",
    FileStreamInformation,          "FileStreamInformation",
    FilePipeInformation,            "FilePipeInformation",
    FilePipeLocalInformation,       "FilePipeLocalInformation",
    FilePipeRemoteInformation,      "FilePipeRemoteInformation",
    FileMailslotQueryInformation,   "FileMailslotQueryInformation",
    FileMailslotSetInformation,     "FileMailslotSetInformation",
    FileCompressionInformation,     "FileCompressionInformation",
    FileCompletionInformation,      "FileCompletionInformation",
    FileMoveClusterInformation,     "FileMoveClusterInformation",
    0xFFFFFFFF,                     "%x"
};

ENUM_TYPE_NAMES KeyCreateOptionNames[] = {
    REG_OPTION_VOLATILE,            "REG_OPTION_VOLATILE",
    REG_OPTION_CREATE_LINK,         "REG_OPTION_CREATE_LINK",
    REG_OPTION_BACKUP_RESTORE,      "REG_OPTION_BACKUP_RESTORE",
    0xFFFFFFFF,                     "%x"
};

ENUM_TYPE_NAMES KeyDispositionNames[] = {
    REG_CREATED_NEW_KEY,            "REG_CREATED_NEW_KEY",
    REG_OPENED_EXISTING_KEY,        "REG_OPENED_EXISTING_KEY",
    0xFFFFFFFF,                     "%x"
};


#endif // TRACE_ENABLED

BOOLEAN
IsFileWriteAccessRequested(
    ACCESS_MASK DesiredAccess,
    ULONG CreateDisposition
    )
{
    if (DesiredAccess & (GENERIC_WRITE |
                         GENERIC_ALL |
                         DELETE |
                         FILE_WRITE_DATA |
                         FILE_APPEND_DATA
                        )
       ) {
        return TRUE;
        }

    if (CreateDisposition != FILE_OPEN && CreateDisposition != FILE_OPEN_IF) {
        return TRUE;
        }

    return FALSE;
}

BOOLEAN
NtCreateFileHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PCREATEFILE_PARAMETERS p = &Parameters->InputParameters.CreateFile;
    BOOLEAN Result;

    if (!Parameters->ReturnValueValid) {
        Result = CaptureOpenState( Process,
                                   Parameters,
                                   p->ObjectAttributes,
                                   IsFileWriteAccessRequested( p->DesiredAccess, p->CreateDisposition ),
                                   p->FileHandle,
                                   HANDLE_TYPE_FILE
                                 );


        if (Result
            // && Parameters->SavedCallState.PathOpen.WriteAccessRequested
           ) {
            DbgEvent( CREATEEVENT, ( "NtCreateFile called:\n"
                                     "    Name:   %ws\n"
                                     "    Access: %s\n"
                                     "    Share:  %s\n"
                                     "    Create: %s\n"
                                     "    Options:%s\n",
                                     Parameters->SavedCallState.FullName,
                                     FormatEnumType( 0,
                                                     FileAccessNames,
                                                     p->DesiredAccess,
                                                     TRUE
                                                   ),
                                     FormatEnumType( 1,
                                                     FileShareNames,
                                                     p->ShareAccess,
                                                     TRUE
                                                   ),
                                     FormatEnumType( 2,
                                                     FileCreateDispositionNames,
                                                     p->CreateDisposition,
                                                     FALSE
                                                   ),
                                     FormatEnumType( 3,
                                                     FileCreateOptionNames,
                                                     p->CreateOptions,
                                                     TRUE
                                                   )
                                   )
                    );
            }
        }
    else {
        Result = CompleteOpenState( Process,
                                    Parameters
                                  );
        if (Result
            // && Parameters->SavedCallState.PathOpen.WriteAccessRequested
           ) {
            IO_STATUS_BLOCK IoStatusBlock;

            ReadMemory( Process,
                        p->IoStatusBlock,
                        &IoStatusBlock,
                        sizeof( IoStatusBlock ),
                        "IoStatusBlock"
                      );
            DbgEvent( CREATEEVENT, ( "*** Returned %s [%s %s]\n",
                                     FormatEnumType( 0,
                                                     (PENUM_TYPE_NAMES)ntstatusSymbolicNames,
                                                     Parameters->ReturnValue.ReturnedLong,
                                                     FALSE
                                                   ),
                                     FormatEnumType( 1,
                                                     (PENUM_TYPE_NAMES)ntstatusSymbolicNames,
                                                     IoStatusBlock.Status,
                                                     FALSE
                                                   ),
                                     FormatEnumType( 2,
                                                     FileIoStatusInfoNames,
                                                     IoStatusBlock.Information,
                                                     FALSE
                                                   )
                                   )
                    );
            }
        }

    return Result;
}

BOOLEAN
NtOpenFileHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    POPENFILE_PARAMETERS p = &Parameters->InputParameters.OpenFile;
    BOOLEAN Result;

    if (!Parameters->ReturnValueValid) {
        Result = CaptureOpenState( Process,
                                   Parameters,
                                   p->ObjectAttributes,
                                   IsFileWriteAccessRequested( p->DesiredAccess, FILE_OPEN ),
                                   p->FileHandle,
                                   HANDLE_TYPE_FILE
                                 );
        if (Result
            // && Parameters->SavedCallState.PathOpen.WriteAccessRequested
           ) {
            DbgEvent( CREATEEVENT, ( "NtOpenFile called:\n"
                                     "    Name:   %ws\n"
                                     "    Access: %s\n"
                                     "    Share:  %s\n"
                                     "    Options:%s\n",
                                     Parameters->SavedCallState.FullName,
                                     FormatEnumType( 0,
                                                     FileAccessNames,
                                                     p->DesiredAccess,
                                                     TRUE
                                                   ),
                                     FormatEnumType( 1,
                                                     FileShareNames,
                                                     p->ShareAccess,
                                                     TRUE
                                                   ),
                                     FormatEnumType( 2,
                                                     FileCreateOptionNames,
                                                     p->OpenOptions,
                                                     TRUE
                                                   )
                                   )
                    );
            }
        }
    else {
        Result = CompleteOpenState( Process,
                                    Parameters
                                  );
        if (Result
            // && Parameters->SavedCallState.PathOpen.WriteAccessRequested
           ) {
            IO_STATUS_BLOCK IoStatusBlock;

            ReadMemory( Process,
                        p->IoStatusBlock,
                        &IoStatusBlock,
                        sizeof( IoStatusBlock ),
                        "IoStatusBlock"
                      );
            DbgEvent( CREATEEVENT, ( "*** Returned %s [%s %s]\n",
                                     FormatEnumType( 0,
                                                     (PENUM_TYPE_NAMES)ntstatusSymbolicNames,
                                                     Parameters->ReturnValue.ReturnedLong,
                                                     FALSE
                                                   ),
                                     FormatEnumType( 1,
                                                     (PENUM_TYPE_NAMES)ntstatusSymbolicNames,
                                                     IoStatusBlock.Status,
                                                     FALSE
                                                   ),
                                     FormatEnumType( 2,
                                                     FileIoStatusInfoNames,
                                                     IoStatusBlock.Information,
                                                     FALSE
                                                   )
                                   )
                    );
            }
        }

    return Result;
}

BOOLEAN
NtDeleteFileHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PDELETEFILE_PARAMETERS p = &Parameters->InputParameters.DeleteFile;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ObjectName;
    PWSTR FullName;
    BOOLEAN Result, CallSuccessful;
    PFILE_REFERENCE FileReference;

    if (!Parameters->ReturnValueValid) {
        if (CaptureObjectAttributes( Process,
                                     p->ObjectAttributes,
                                     &ObjectAttributes,
                                     &ObjectName
                                   ) &&
            CaptureFullName( Process,
                             HANDLE_TYPE_FILE,
                             ObjectAttributes.RootDirectory,
                             ObjectName.Buffer,
                             ObjectName.Length,
                             &FullName
                           ) &&
            CreateSavedCallState( Process,
                                  &Parameters->SavedCallState,
                                  DeletePath,
                                  HANDLE_TYPE_FILE,
                                  FullName
                                )
           ) {
            Result = CreateFileReference( FullName,
                                          TRUE,
                                          (PFILE_REFERENCE *)&Parameters->SavedCallState.Reference
                                        );
            }
        else {
            Result = FALSE;
            }

        return Result;
        }
    else {
        if (NT_SUCCESS( Parameters->ReturnValue.ReturnedLong )) {
            CallSuccessful = TRUE;
            }
        else {
            CallSuccessful = FALSE;
            }

        FileReference = (PFILE_REFERENCE)Parameters->SavedCallState.Reference;
        CompleteFileReference( FileReference,
                               CallSuccessful,
                               TRUE,
                               NULL
                             );

        return TRUE;
        }
}

#undef DeleteFile


BOOLEAN
NtSetInformationFileHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PSETINFORMATIONFILE_PARAMETERS p = &Parameters->InputParameters.SetInformationFile;
    POPENHANDLE_INFO HandleInfo;
    FILE_RENAME_INFORMATION RenameInformation;
    FILE_DISPOSITION_INFORMATION DispositionInformation;
    PWSTR NewName, OldName;
    PFILE_REFERENCE OldFileReference;
    PFILE_REFERENCE NewFileReference;
    BOOLEAN Result, CallSuccessful;

    HandleInfo = FindOpenHandle( Process,
                                 p->FileHandle,
                                 HANDLE_TYPE_FILE
                               );
    if (HandleInfo == NULL) {
        Result = FALSE;
        }
    else
    if (p->FileInformationClass == FileRenameInformation) {
        //
        // Renaming an open file.
        //
        if (!Parameters->ReturnValueValid) {
            if (ReadMemory( Process,
                            p->FileInformation,
                            &RenameInformation,
                            FIELD_OFFSET( FILE_RENAME_INFORMATION, FileName ),
                            "rename information"
                          ) &&
                CaptureFullName( Process,
                                 HANDLE_TYPE_FILE,
                                 RenameInformation.RootDirectory,
                                 &((PFILE_RENAME_INFORMATION)(p->FileInformation))->FileName[ 0 ],
                                 RenameInformation.FileNameLength,
                                 &NewName
                               ) &&
                CreateSavedCallState( Process,
                                      &Parameters->SavedCallState,
                                      RenamePath,
                                      HANDLE_TYPE_FILE,
                                      HandleInfo->Name,
                                      NewName,
                                      RenameInformation.ReplaceIfExists
                                    )
               ) {
                Result = CreateFileReference( NewName,
                                              RenameInformation.ReplaceIfExists,
                                              (PFILE_REFERENCE *)&Parameters->SavedCallState.Reference
                                            );
                }
            else {
                Result = FALSE;
                }
            }
        else {
            OldName = NULL;
            if (NT_SUCCESS( Parameters->ReturnValue.ReturnedLong )) {
                CallSuccessful = TRUE;
                OldFileReference = FindFileReference( HandleInfo->Name );
                if (OldFileReference) {
                    OldName = OldFileReference->Name;
                    }
                }
            else {
                CallSuccessful = FALSE;
                OldFileReference = NULL;
                }

            NewFileReference = (PFILE_REFERENCE)Parameters->SavedCallState.Reference;
            NewName = NewFileReference->Name;
            CompleteFileReference( NewFileReference,
                                   CallSuccessful,
                                   (BOOLEAN)(!NewFileReference->Created),
                                   OldFileReference
                                 );
            Result = TRUE;
            }
        }
    else
    if (p->FileInformationClass == FileDispositionInformation) {
        //
        // Marking an open file for delete.
        //
        if (!Parameters->ReturnValueValid) {
            if (ReadMemory( Process,
                            p->FileInformation,
                            &DispositionInformation,
                            sizeof( DispositionInformation ),
                            "disposition information"
                          ) &&
                DispositionInformation.DeleteFile &&
                CreateSavedCallState( Process,
                                      &Parameters->SavedCallState,
                                      DeletePath,
                                      HANDLE_TYPE_FILE,
                                      HandleInfo->Name
                                    )
               ) {
                Result = TRUE;
                }
            else {
                Result = FALSE;
                }
            }
        else {
            if (NT_SUCCESS( Parameters->ReturnValue.ReturnedLong )) {
                if (OldFileReference = FindFileReference( HandleInfo->Name )) {
                    if (OldFileReference->Created) {
                        LogEvent( INSTALER_EVENT_DELETE_TEMP_FILE,
                                  2,
                                  OldFileReference->DirectoryFile ? L"directory" : L"file",
                                  OldFileReference->Name
                                );
                        DestroyFileReference( OldFileReference );
                        }
                    else {
                        OldFileReference->Deleted = TRUE;
                        LogEvent( INSTALER_EVENT_DELETE_FILE,
                                  2,
                                  OldFileReference->DirectoryFile ? L"directory" : L"file",
                                  OldFileReference->Name
                                );
                        }
                    }
                }

            Result = TRUE;
            }
        }
    else {
        Result = FALSE;
        }

    return Result;
}




BOOLEAN
CaptureUnicodeString(
    PPROCESS_INFO Process,
    PUNICODE_STRING UnicodeStringAddress,
    PWSTR *ReturnedString
    )
{
    UNICODE_STRING UnicodeString;
    PWSTR s;

    s = NULL;
    if (ReadMemory( Process,
                    UnicodeStringAddress,
                    &UnicodeString,
                    sizeof( UnicodeString ),
                    "unicode string"
                  ) &&
        ((s = AllocMem( UnicodeString.Length + sizeof( UNICODE_NULL ) )) != NULL) &&
        ReadMemory( Process,
                    UnicodeString.Buffer,
                    s,
                    UnicodeString.Length,
                    "unicode string buffer"
                  )
       ) {
        *ReturnedString = s;
        return TRUE;
        }

    FreeMem( &s );
    return FALSE;
}


BOOLEAN
NtQueryAttributesFileHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PQUERYATTRIBUTESFILE_PARAMETERS p = &Parameters->InputParameters.QueryAttributesFile;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ObjectName;
    PWSTR FullName;
    NTSTATUS Status;
    BOOLEAN Result;
    CHAR Buffer[ MAX_PATH ];

    if (!Parameters->ReturnValueValid) {
        FullName = NULL;
        Result = FALSE;
        if (CaptureObjectAttributes( Process,
                                     p->ObjectAttributes,
                                     &ObjectAttributes,
                                     &ObjectName
                                   ) &&
            CaptureFullName( Process,
                             HANDLE_TYPE_FILE,
                             ObjectAttributes.RootDirectory,
                             ObjectName.Buffer,
                             ObjectName.Length,
                             &FullName
                           ) &&
            CreateSavedCallState( Process,
                                  &Parameters->SavedCallState,
                                  QueryPath,
                                  HANDLE_TYPE_FILE,
                                  FullName
                                )
           ) {
            Result = CreateFileReference( FullName,
                                          FALSE,
                                          (PFILE_REFERENCE *)&Parameters->SavedCallState.Reference
                                        );
            }
        else {
            Result = FALSE;
            }

        return Result;
        }
    else {
        FILE_BASIC_INFORMATION FileInformation;

        ReadMemory( Process,
                    p->FileInformation,
                    &FileInformation,
                    sizeof( FileInformation ),
                    "FileInformation"
                  );
        return TRUE;
        }
}

BOOLEAN
NtQueryDirectoryFileHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PQUERYDIRECTORYFILE_PARAMETERS p = &Parameters->InputParameters.QueryDirectoryFile;
    POPENHANDLE_INFO HandleInfo;
    PWSTR FileName;
    NTSTATUS Status;
    BOOLEAN Result;
    PULONG pNextEntryOffset;
    ULONG NextEntryOffset;
    ULONG EntriesReturned;

    if (!Parameters->ReturnValueValid) {
        FileName = NULL;
        Result = FALSE;
        if ((HandleInfo = FindOpenHandle( Process,
                                          p->FileHandle,
                                          HANDLE_TYPE_FILE
                                        )
            ) != NULL &&
            p->FileName != NULL &&
            CaptureUnicodeString( Process,
                                  p->FileName,
                                  &FileName
                                )
           ) {
            if (HandleInfo->RootDirectory &&
                !wcscmp( FileName, L"*" ) || !wcscmp( FileName, L"*.*" )
               ) {
                if (AskUserOnce) {
                    AskUserOnce = FALSE;
                    if (AskUser( MB_OKCANCEL,
                                 INSTALER_ASKUSER_ROOTSCAN,
                                 1,
                                 HandleInfo->Name
                               ) == IDCANCEL
                       ) {
                        FailAllScansOfRootDirectories = TRUE;
                        }
                    }

                Parameters->AbortCall = FailAllScansOfRootDirectories;
                }

            if (FileName) {
                HandleInfo->QueryName = FileName;
                }
            }

        return TRUE;
        }
    else {
        if (Parameters->AbortCall) {
            //
            // If we get here, then user wanted to fail this call.
            //
            Status = STATUS_NO_MORE_FILES;
            SetProcedureReturnValue( Process,
                                     Thread,
                                     &Status,
                                     sizeof( Status )
                                   );
            return TRUE;
            }
        else  {
            if ((HandleInfo = FindOpenHandle( Process,
                                              p->FileHandle,
                                              HANDLE_TYPE_FILE
                                            )
                ) != NULL
               ) {
                //
                // If successful, count entries returned
                //
                if (NT_SUCCESS( Parameters->ReturnValue.ReturnedLong )) {
                    //
                    // Return buffer is a set of records, the first DWORD of each contains
                    // the offset to the next one or zero to indicate the end.  Count them.
                    //
                    pNextEntryOffset = (PULONG)p->FileInformation;
                    EntriesReturned = 1;
                    while (ReadMemory( Process,
                                       pNextEntryOffset,
                                       &NextEntryOffset,
                                       sizeof( NextEntryOffset ),
                                       "DirectoryInformation"
                                     ) &&
                           NextEntryOffset != 0
                          ) {
                        pNextEntryOffset = (PULONG)((PCHAR)pNextEntryOffset + NextEntryOffset);
                        EntriesReturned += 1;
                        }

                    LogEvent( INSTALER_EVENT_SCAN_DIRECTORY,
                              3,
                              HandleInfo->Name,
                              HandleInfo->QueryName ? HandleInfo->QueryName : L"*",
                              EntriesReturned
                            );

                    }
                else {
                    FreeMem( &HandleInfo->QueryName );
                    }
                }
            }

        return TRUE;
        }
}


BOOLEAN
IsKeyWriteAccessRequested(
    ACCESS_MASK DesiredAccess
    )
{
    if (DesiredAccess & (GENERIC_WRITE |
                         GENERIC_ALL |
                         DELETE |
                         KEY_SET_VALUE |
                         KEY_CREATE_SUB_KEY |
                         KEY_CREATE_LINK
                        )
       ) {
        return TRUE;
        }

    return FALSE;
}

BOOLEAN
NtCreateKeyHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PCREATEKEY_PARAMETERS p = &Parameters->InputParameters.CreateKey;
    BOOLEAN Result;

    if (!Parameters->ReturnValueValid) {
        Result = CaptureOpenState( Process,
                                   Parameters,
                                   p->ObjectAttributes,
                                   IsKeyWriteAccessRequested( p->DesiredAccess ),
                                   p->KeyHandle,
                                   HANDLE_TYPE_KEY
                                 );
        }
    else {
        Result = CompleteOpenState( Process,
                                    Parameters
                                  );
        }

    return Result;
}

BOOLEAN
NtOpenKeyHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    POPENKEY_PARAMETERS p = &Parameters->InputParameters.OpenKey;
    BOOLEAN Result;

    if (!Parameters->ReturnValueValid) {
        Result = CaptureOpenState( Process,
                                   Parameters,
                                   p->ObjectAttributes,
                                   IsKeyWriteAccessRequested( p->DesiredAccess ),
                                   p->KeyHandle,
                                   HANDLE_TYPE_KEY
                                 );
        }
    else {
        Result = CompleteOpenState( Process,
                                    Parameters
                                  );
        }

    return Result;
}

BOOLEAN
NtDeleteKeyHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PDELETEKEY_PARAMETERS p = &Parameters->InputParameters.DeleteKey;
    POPENHANDLE_INFO HandleInfo;
    PKEY_REFERENCE OldKeyReference;
    BOOLEAN Result;

    //
    // Marking an open key for delete.
    //
    HandleInfo = FindOpenHandle( Process,
                                 p->KeyHandle,
                                 HANDLE_TYPE_KEY
                               );
    if (HandleInfo == NULL) {
        Result = FALSE;
        }
    else
    if (!Parameters->ReturnValueValid) {
        if (CreateSavedCallState( Process,
                                  &Parameters->SavedCallState,
                                  DeletePath,
                                  HANDLE_TYPE_KEY,
                                  HandleInfo->Name
                                )
           ) {
            Result = TRUE;
            }
        else {
            Result = FALSE;
            }
        }
    else {
        if (NT_SUCCESS( Parameters->ReturnValue.ReturnedLong )) {
            if (OldKeyReference = FindKeyReference( HandleInfo->Name )) {
                if (OldKeyReference->Created) {
                    LogEvent( INSTALER_EVENT_DELETE_TEMP_KEY,
                              1,
                              OldKeyReference->Name
                            );
                    DestroyKeyReference( OldKeyReference );
                    }
                else {
                    MarkKeyDeleted( OldKeyReference );
                    LogEvent( INSTALER_EVENT_DELETE_KEY,
                              1,
                              OldKeyReference->Name
                            );
                    }
                }
            }

        Result = TRUE;
        }

    return Result;
}

BOOLEAN
CaptureValueName(
    PPROCESS_INFO Process,
    PUNICODE_STRING Name,
    PWSTR *ReturnedValueName
    )
{
    UNICODE_STRING ValueName;
    PWSTR s;

    *ReturnedValueName = NULL;
    if (Name == NULL ||
        !ReadMemory( Process,
                     Name,
                     &ValueName,
                     sizeof( ValueName ),
                     "value name string"
                   )
       ) {
        return FALSE;
        }

    s = AllocMem( ValueName.Length + sizeof( UNICODE_NULL ) );
    if (s == NULL) {
        return FALSE;
        }

    if (!ReadMemory( Process,
                     ValueName.Buffer,
                     s,
                     ValueName.Length,
                     "value name buffer"
                   )
       ) {
        FreeMem( &s );
        return FALSE;
        }

    s[ ValueName.Length / sizeof( WCHAR ) ] = UNICODE_NULL;
    ValueName.Buffer = s;
    ValueName.MaximumLength = (USHORT)(ValueName.Length + sizeof( UNICODE_NULL ));
    *ReturnedValueName = AddName( &ValueName );
    FreeMem( &ValueName.Buffer );
    return TRUE;
}


BOOLEAN
NtSetValueKeyHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PSETVALUEKEY_PARAMETERS p = &Parameters->InputParameters.SetValueKey;
    POPENHANDLE_INFO HandleInfo;
    PWSTR ValueName;
    PKEY_REFERENCE KeyReference;
    PVALUE_REFERENCE ValueReference;
    BOOLEAN Result;

    //
    // Setting a value
    //
    HandleInfo = FindOpenHandle( Process,
                                 p->KeyHandle,
                                 HANDLE_TYPE_KEY
                               );
    if (HandleInfo == NULL) {
        Result = FALSE;
        }
    else
    if (!Parameters->ReturnValueValid) {
        if (CaptureValueName( Process,
                              p->ValueName,
                              &ValueName
                            ) &&
            CreateSavedCallState( Process,
                                  &Parameters->SavedCallState,
                                  SetValue,
                                  HANDLE_TYPE_KEY,
                                  ValueName
                                )
           ) {
            Result = TRUE;
            }
        else {
            Result = FALSE;
            }
        }
    else {
        if (NT_SUCCESS( Parameters->ReturnValue.ReturnedLong ) &&
            (KeyReference = FindKeyReference( HandleInfo->Name ))
           ) {
            CreateValueReference( Process,
                                  KeyReference,
                                  Parameters->SavedCallState.FullName,
                                  p->TitleIndex,
                                  p->Type,
                                  p->Data,
                                  p->DataLength,
                                  &ValueReference
                                );

            if (ValueReference != NULL) {
                LogEvent( INSTALER_EVENT_SET_KEY_VALUE,
                          2,
                          ValueReference->Name,
                          KeyReference->Name
                        );
                }
            }

        Result = TRUE;
        }

    return Result;
}

BOOLEAN
NtDeleteValueKeyHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PDELETEVALUEKEY_PARAMETERS p = &Parameters->InputParameters.DeleteValueKey;
    POPENHANDLE_INFO HandleInfo;
    PWSTR ValueName;
    PKEY_REFERENCE KeyReference;
    PVALUE_REFERENCE ValueReference;
    BOOLEAN Result;

    //
    // Marking a value for delete.
    //
    HandleInfo = FindOpenHandle( Process,
                                 p->KeyHandle,
                                 HANDLE_TYPE_KEY
                               );
    if (HandleInfo == NULL) {
        Result = FALSE;
        }
    else
    if (!Parameters->ReturnValueValid) {
        if (CaptureValueName( Process,
                              p->ValueName,
                              &ValueName
                            ) &&
            CreateSavedCallState( Process,
                                  &Parameters->SavedCallState,
                                  DeleteValue,
                                  HANDLE_TYPE_KEY,
                                  ValueName
                                )
           ) {
            Result = TRUE;
            }
        else {
            Result = FALSE;
            }
        }
    else {
        if (NT_SUCCESS( Parameters->ReturnValue.ReturnedLong ) &&
            (KeyReference = FindKeyReference( HandleInfo->Name )) &&
            (ValueReference = FindValueReference( KeyReference, Parameters->SavedCallState.FullName ))
           ) {
            if (ValueReference->Created) {
                LogEvent( INSTALER_EVENT_DELETE_KEY_TEMP_VALUE,
                          2,
                          ValueReference->Name,
                          KeyReference->Name
                        );
                DestroyValueReference( ValueReference );
                }
            else {
                ValueReference->Deleted = TRUE;
                LogEvent( INSTALER_EVENT_DELETE_KEY_VALUE,
                          2,
                          ValueReference->Name,
                          KeyReference->Name
                        );
                }
            }

        Result = TRUE;
        }

    return Result;
}


BOOLEAN
NtCloseHandleHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PCLOSEHANDLE_PARAMETERS p = &Parameters->InputParameters.CloseHandle;
    POPENHANDLE_INFO HandleInfo;
    PFILE_REFERENCE FileReference;

    HandleInfo = FindOpenHandle( Process, p->Handle, (ULONG)-1 );
    if (!Parameters->ReturnValueValid) {
        if (HandleInfo != NULL) {
            return TRUE;
            }
        else {
            return FALSE;
            }
        }
    else {
        if (NT_SUCCESS( Parameters->ReturnValue.ReturnedLong )) {
            if (HandleInfo != NULL &&
                HandleInfo->Type == HANDLE_TYPE_FILE &&
                (FileReference = FindFileReference( HandleInfo->Name )) != NULL &&
                FileReference->WriteAccess &&
                !FileReference->Created &&
                !FileReference->DirectoryFile &&
                IsNewFileSameAsBackup( FileReference )
               ) {
                DestroyFileReference( FileReference );
                FileReference = NULL;
                }

            DeleteOpenHandle( Process, p->Handle, (ULONG)-1 );
            }

        return TRUE;
        }
}

UCHAR AnsiStringBuffer[ MAX_PATH+1 ];
WCHAR UnicodeStringBuffer[ MAX_PATH+1 ];

BOOLEAN
CaptureAnsiAsUnicode(
    PPROCESS_INFO Process,
    LPCSTR Address,
    BOOLEAN DoubleNullTermination,
    PWSTR *ReturnedName,
    PWSTR *ReturnedData
    )
{
    NTSTATUS Status;
    ULONG BytesRead;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    if (Address == NULL) {
        if (ReturnedName != NULL) {
            *ReturnedName = NULL;
            }
        else {
            *ReturnedData = NULL;
            }
        return TRUE;
        }

    BytesRead = FillTemporaryBuffer( Process,
                                     (PVOID)Address,
                                     FALSE,
                                     DoubleNullTermination
                                   );
    if (BytesRead != 0 && BytesRead < 0x7FFF) {
        AnsiString.Buffer = TemporaryBuffer;
        AnsiString.Length = (USHORT)BytesRead;
        AnsiString.MaximumLength = (USHORT)BytesRead;
        Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, TRUE );
        if (NT_SUCCESS( Status )) {
            if (ReturnedName != NULL) {
                *ReturnedName = AddName( &UnicodeString );
                RtlFreeUnicodeString( &UnicodeString );
                return TRUE;
                }
            else {
                *ReturnedData = UnicodeString.Buffer;
                return TRUE;
                }
            }
        }

    return FALSE;
}


BOOLEAN
CaptureUnicode(
    PPROCESS_INFO Process,
    LPCWSTR Address,
    BOOLEAN DoubleNullTermination,
    PWSTR *ReturnedName,
    PWSTR *ReturnedData
    )
{
    ULONG BytesRead;
    UNICODE_STRING UnicodeString;

    if (Address == NULL) {
        if (ReturnedName != NULL) {
            *ReturnedName = NULL;
            }
        else {
            *ReturnedData = NULL;
            }
        return TRUE;
        }

    BytesRead = FillTemporaryBuffer( Process,
                                     (PVOID)Address,
                                     TRUE,
                                     DoubleNullTermination
                                   );
    if (BytesRead != 0 && (BytesRead & 1) == 0 && BytesRead <= 0xFFFC) {
        if (ReturnedName != NULL) {
            RtlInitUnicodeString( &UnicodeString, TemporaryBuffer );
            *ReturnedName = AddName( &UnicodeString );
            return TRUE;
            }
        else {
            *ReturnedData = AllocMem( BytesRead + sizeof( UNICODE_NULL ) );
            if (*ReturnedData != NULL) {
                memmove( *ReturnedData, TemporaryBuffer, BytesRead );
                return TRUE;
                }
            }
        }

    return FALSE;
}


BOOLEAN
GetVersionHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    DWORD dwVersion;

    if (!Parameters->ReturnValueValid) {
        if (AskUserOnce) {
            AskUserOnce = FALSE;
            if (AskUser( MB_OKCANCEL,
                         INSTALER_ASKUSER_GETVERSION,
                         0
                       ) == IDCANCEL
               ) {
                DefaultGetVersionToWin95 = TRUE;
                }
            else {
                DefaultGetVersionToWin95 = FALSE;
                }
            }

        LogEvent( INSTALER_EVENT_GETVERSION,
                  1,
                  DefaultGetVersionToWin95 ? L"Windows 95" : L"Windows NT"
                );
        Parameters->AbortCall = DefaultGetVersionToWin95;
        return Parameters->AbortCall;
        }
    else {
        dwVersion = 0xC0000004;     // What Windows 95 returns
        SetProcedureReturnValue( Process,
                                 Thread,
                                 &dwVersion,
                                 sizeof( dwVersion )
                               );
        return TRUE;
        }
}

BOOLEAN
GetVersionExWHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PGETVERSIONEXW_PARAMETERS p = &Parameters->InputParameters.GetVersionExW;
    OSVERSIONINFOW VersionInformation;

    if (!Parameters->ReturnValueValid) {
        if (AskUserOnce) {
            AskUserOnce = FALSE;
            if (AskUser( MB_OKCANCEL,
                         INSTALER_ASKUSER_GETVERSION,
                         0
                       ) == IDCANCEL
               ) {
                DefaultGetVersionToWin95 = TRUE;
                }
            else {
                DefaultGetVersionToWin95 = FALSE;
                }
            }

        Parameters->AbortCall = DefaultGetVersionToWin95;
        return Parameters->AbortCall;
        }
    else {
        memset( &VersionInformation, 0, sizeof( VersionInformation ) );
        VersionInformation.dwMajorVersion = 4;
        VersionInformation.dwBuildNumber  = 0x3B6;  // What Windows 95 returns
        VersionInformation.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS;
        WriteMemory( Process,
                     p->lpVersionInformation,
                     &VersionInformation,
                     sizeof( VersionInformation ),
                     "GetVersionExW"
                   );

        return TRUE;
        }
}

BOOLEAN
SetCurrentDirectoryAHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PSETCURRENTDIRECTORYA_PARAMETERS p = &Parameters->InputParameters.SetCurrentDirectoryA;
    PWSTR PathName;
    WCHAR PathBuffer[ MAX_PATH ];

    if (!Parameters->ReturnValueValid) {
        if (CaptureAnsiAsUnicode( Process, p->lpPathName, FALSE, NULL, &PathName ) && PathName != NULL) {
            Parameters->CurrentDirectory = AllocMem( (wcslen( PathName ) + 1) * sizeof( WCHAR ) );
            if (Parameters->CurrentDirectory != NULL) {
                wcscpy( Parameters->CurrentDirectory, PathName );
                return TRUE;
                }
            }

        return FALSE;
        }
    else {
        if (Parameters->ReturnValue.ReturnedBool != 0) {
            if (SetCurrentDirectory( Parameters->CurrentDirectory ) &&
                GetCurrentDirectory( MAX_PATH, PathBuffer )
               ) {
                LogEvent( INSTALER_EVENT_SET_DIRECTORY,
                          1,
                          PathBuffer
                        );
                }
            }

        FreeMem( &Parameters->CurrentDirectory );
        return TRUE;
        }
}

BOOLEAN
SetCurrentDirectoryWHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PSETCURRENTDIRECTORYW_PARAMETERS p = &Parameters->InputParameters.SetCurrentDirectoryW;
    PWSTR PathName;
    WCHAR PathBuffer[ MAX_PATH ];

    if (!Parameters->ReturnValueValid) {
        if (CaptureUnicode( Process, p->lpPathName, FALSE, NULL, &PathName ) && PathName != NULL) {
            Parameters->CurrentDirectory = AllocMem( (wcslen( PathName ) + 1) * sizeof( WCHAR ) );
            if (Parameters->CurrentDirectory != NULL) {
                wcscpy( Parameters->CurrentDirectory, PathName );
                return TRUE;
                }
            }

        return FALSE;
        }
    else {
        if (Parameters->ReturnValue.ReturnedBool != 0) {
            if (SetCurrentDirectory( Parameters->CurrentDirectory ) &&
                GetCurrentDirectory( MAX_PATH, PathBuffer )
               ) {
                LogEvent( INSTALER_EVENT_SET_DIRECTORY,
                          1,
                          PathBuffer
                        );
                }
            }

        FreeMem( &Parameters->CurrentDirectory );
        return TRUE;
        }
}

BOOLEAN
GetIniFilePath(
    PWSTR IniFileName,
    PWSTR *ReturnedIniFilePath
    )
{
    NTSTATUS Status;
    UNICODE_STRING FileName, UnicodeString;
    PWSTR FilePart;
    DWORD n;

    if (IniFileName == NULL) {
        RtlInitUnicodeString( &FileName, L"win.ini" );
        }
    else {
        RtlInitUnicodeString( &FileName, IniFileName );
        }

    if ((FileName.Length > sizeof( WCHAR ) &&
         FileName.Buffer[ 1 ] == L':'
        ) ||
        (FileName.Length != 0 &&
         wcscspn( FileName.Buffer, L"\\/" ) != (FileName.Length / sizeof( WCHAR ))
        )
       ) {
        UnicodeString.MaximumLength = (USHORT)(MAX_PATH * sizeof( WCHAR  ));
        UnicodeString.Buffer = AllocMem( UnicodeString.MaximumLength );
        if (UnicodeString.Buffer == NULL) {
            Status = STATUS_NO_MEMORY;
            }
        else {
            UnicodeString.Length = 0;
            n = GetFullPathNameW( FileName.Buffer,
                                  UnicodeString.MaximumLength / sizeof( WCHAR ),
                                  UnicodeString.Buffer,
                                  &FilePart
                                );
            if (n > UnicodeString.MaximumLength) {
                Status = STATUS_BUFFER_TOO_SMALL;
                }
            else {
                UnicodeString.Length = (USHORT)(n * sizeof( WCHAR ));
                Status = STATUS_SUCCESS;
                }
            }
        }
    else {
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = (USHORT)(WindowsDirectory.Length +
                                               sizeof( WCHAR  ) +
                                               FileName.Length +
                                               sizeof( UNICODE_NULL )
                                              );
        UnicodeString.Buffer = AllocMem( UnicodeString.MaximumLength );
        if (UnicodeString.Buffer == NULL) {
            Status = STATUS_NO_MEMORY;
            }
        else {
            RtlCopyUnicodeString( &UnicodeString, &WindowsDirectory );
            Status = RtlAppendUnicodeToString( &UnicodeString,
                                               L"\\"
                                             );
            if (NT_SUCCESS( Status )) {
                Status = RtlAppendUnicodeStringToString( &UnicodeString,
                                                         &FileName
                                                       );
                }
            }
        }

    if (IniFileName != NULL) {
        FreeMem( &IniFileName );
        }

    if (NT_SUCCESS( Status )) {
        *ReturnedIniFilePath = AddName( &UnicodeString );
        FreeMem( &UnicodeString.Buffer );
        return TRUE;
        }
    else {
        FreeMem( &UnicodeString.Buffer );
        return FALSE;
        }
}

BOOLEAN
WritePrivateProfileStringEntry(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters,
    PWSTR IniFilePath,
    PWSTR SectionName,
    PWSTR VariableName,
    PWSTR VariableValue
    )
{
    if (CreateSavedCallState( Process,
                              &Parameters->SavedCallState,
                              WriteIniValue,
                              HANDLE_TYPE_NONE,
                              IniFilePath,
                              SectionName,
                              VariableName,
                              VariableValue
                            ) &&
        CreateIniFileReference( IniFilePath,
                                (PINI_FILE_REFERENCE *)&Parameters->SavedCallState.Reference
                              )
       ) {
        return TRUE;
        }
    else {
        FreeMem( &VariableValue );
        return FALSE;
        }
}


BOOLEAN
WritePrivateProfileStringExit(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PAPI_SAVED_CALL_STATE CallState;
    PINI_FILE_REFERENCE IniFileReference;
    PINI_SECTION_REFERENCE IniSectionReference;
    PINI_VARIABLE_REFERENCE IniVariableReference;

    if (Parameters->ReturnValue.ReturnedLong != 0) {
        CallState = &Parameters->SavedCallState;
        if (CallState->FullName == NULL &&
            CallState->SetIniValue.SectionName == NULL &&
            CallState->SetIniValue.VariableName == NULL
           ) {
            //
            // Ignore calls to flush INI cache
            //

            return FALSE;
        }

        IniFileReference = FindIniFileReference( CallState->FullName );
        if (IniFileReference == NULL) {
            return TRUE;
        }

        IniSectionReference = FindIniSectionReference( IniFileReference,
                                                       CallState->SetIniValue.SectionName,
                                                       (BOOLEAN)(CallState->SetIniValue.VariableName != NULL)
                                                     );
        if (IniSectionReference == NULL) {
            return TRUE;
        }

        if (CallState->SetIniValue.VariableName == NULL) {
            IniSectionReference->Deleted = TRUE;
            LogEvent( INSTALER_EVENT_INI_DELETE_SECTION,
                      2,
                      CallState->FullName,
                      CallState->SetIniValue.SectionName
                    );
        } else {
            IniVariableReference = FindIniVariableReference( IniSectionReference,
                                                             CallState->SetIniValue.VariableName,
                                                             (BOOLEAN)(CallState->SetIniValue.VariableValue != NULL)
                                                           );
            if (IniVariableReference != NULL) {
                if (CallState->SetIniValue.VariableValue != NULL) {
                    FreeMem( &IniVariableReference->Value );
                    IniVariableReference->Value = CallState->SetIniValue.VariableValue;
                    CallState->SetIniValue.VariableValue = NULL;
                    if (!IniVariableReference->Created) {
                        if (!wcscmp( IniVariableReference->Value,
                                     IniVariableReference->OriginalValue
                                   )
                           ) {
                            FreeMem( &IniVariableReference->Value );
                        } else {
                            IniVariableReference->Modified = TRUE;
                            LogEvent( INSTALER_EVENT_INI_CHANGE,
                                      5,
                                      CallState->FullName,
                                      CallState->SetIniValue.SectionName,
                                      CallState->SetIniValue.VariableName,
                                      IniVariableReference->Value,
                                      IniVariableReference->OriginalValue
                                    );
                        }
                    } else {
                        LogEvent( INSTALER_EVENT_INI_CREATE,
                                  4,
                                  CallState->FullName,
                                  CallState->SetIniValue.SectionName,
                                  CallState->SetIniValue.VariableName,
                                  IniVariableReference->Value
                                );
                    }

                } else if (!IniVariableReference->Created) {
                    IniVariableReference->Deleted = TRUE;
                    LogEvent( INSTALER_EVENT_INI_DELETE,
                              4,
                              CallState->FullName,
                              CallState->SetIniValue.SectionName,
                              CallState->SetIniValue.VariableName,
                              IniVariableReference->OriginalValue
                            );
                } else {
                    DestroyIniVariableReference( IniVariableReference );
                }
            }
        }
    }

    return TRUE;
}


BOOLEAN
WritePrivateProfileStringAHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PWRITEPRIVATEPROFILESTRINGA_PARAMETERS p = &Parameters->InputParameters.WritePrivateProfileStringA;
    PWSTR SectionName, VariableName, FileName, VariableValue;
    PWSTR IniFilePath;

    if (!Parameters->ReturnValueValid) {
        FileName = NULL;
        VariableValue = NULL;
        if (CaptureAnsiAsUnicode( Process, p->lpFileName, FALSE, NULL, &FileName ) &&
            GetIniFilePath( FileName, &IniFilePath ) &&
            CaptureAnsiAsUnicode( Process, p->lpAppName, FALSE, &SectionName, NULL ) &&
            CaptureAnsiAsUnicode( Process, p->lpKeyName, FALSE, &VariableName, NULL ) &&
            CaptureAnsiAsUnicode( Process, p->lpString, FALSE, NULL, &VariableValue )
           ) {
            if (FileName != NULL || SectionName != NULL) {
                return WritePrivateProfileStringEntry( Process,
                                                       Thread,
                                                       Parameters,
                                                       IniFilePath,
                                                       SectionName,
                                                       VariableName,
                                                       VariableValue
                                                     );
                }
            }

        return TRUE;
        }
    else {
        return WritePrivateProfileStringExit( Process,
                                              Thread,
                                              Parameters
                                            );
        }
}

BOOLEAN
WritePrivateProfileStringWHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PWRITEPRIVATEPROFILESTRINGW_PARAMETERS p = &Parameters->InputParameters.WritePrivateProfileStringW;
    PWSTR SectionName, VariableName, FileName, VariableValue;
    PWSTR IniFilePath;

    if (!Parameters->ReturnValueValid) {
        FileName = NULL;
        IniFilePath = NULL;
        SectionName = NULL;
        VariableName = NULL;
        VariableValue = NULL;
        if (CaptureUnicode( Process, p->lpFileName, FALSE, NULL, &FileName ) &&
            GetIniFilePath( FileName, &IniFilePath ) &&
            CaptureUnicode( Process, p->lpAppName, FALSE, &SectionName, NULL ) &&
            CaptureUnicode( Process, p->lpKeyName, FALSE, &VariableName, NULL ) &&
            CaptureUnicode( Process, p->lpString, FALSE, NULL, &VariableValue )
        ) {

            if (FileName != NULL || SectionName != NULL) {
                return WritePrivateProfileStringEntry( Process,
                                                       Thread,
                                                       Parameters,
                                                       IniFilePath,
                                                       SectionName,
                                                       VariableName,
                                                       VariableValue );
            }
        }

        return TRUE;
    }

    return WritePrivateProfileStringExit( Process,
                                          Thread,
                                          Parameters );
}


BOOLEAN
WritePrivateProfileSectionEntry(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters,
    PWSTR IniFilePath,
    PWSTR SectionName,
    PWSTR SectionValue
    )
{
    if (CreateSavedCallState( Process,
                              &Parameters->SavedCallState,
                              WriteIniSection,
                              HANDLE_TYPE_NONE,
                              IniFilePath,
                              SectionName,
                              SectionValue )
     &&
        CreateIniFileReference( IniFilePath,
                                (PINI_FILE_REFERENCE *)&Parameters->SavedCallState.Reference )
    ) {
        return TRUE;
    }

    FreeMem( &SectionValue );
    return FALSE;
}


BOOLEAN
WritePrivateProfileSectionExit(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PAPI_SAVED_CALL_STATE CallState;
    PINI_FILE_REFERENCE IniFileReference;
    PINI_SECTION_REFERENCE IniSectionReference;
    PINI_VARIABLE_REFERENCE IniVariableReference;
    PWSTR VariableName, VariableValue;
    UNICODE_STRING UnicodeString;

    if (Parameters->ReturnValue.ReturnedLong != 0) {
        CallState = &Parameters->SavedCallState;

        IniFileReference = FindIniFileReference( CallState->FullName );
        if (IniFileReference == NULL) {
            return TRUE;
        }

        IniSectionReference = FindIniSectionReference( IniFileReference,
                                                       CallState->SetIniSection.SectionName,
                                                       (BOOLEAN)(CallState->SetIniSection.SectionValue != NULL) );
        if (IniSectionReference == NULL) {
            return TRUE;
        }

        if (CallState->SetIniSection.SectionValue == NULL) {
            IniSectionReference->Deleted = TRUE;

        } else {
            VariableName = CallState->SetIniSection.SectionValue;
            while (*VariableName) {
                VariableValue = VariableName;
                while (*VariableValue != UNICODE_NULL && *VariableValue != L'=') {
                    VariableValue += 1;
                }

                if (*VariableValue != L'=') {
                    break;
                }

                *VariableValue++ = UNICODE_NULL;

                RtlInitUnicodeString( &UnicodeString, VariableName );
                IniVariableReference = FindIniVariableReference( IniSectionReference,
                                                                 AddName( &UnicodeString ),
                                                                 (BOOLEAN)(*VariableValue != UNICODE_NULL)
                                                               );
                if (IniVariableReference != NULL) {
                    if (*VariableValue != UNICODE_NULL) {
                        FreeMem( &IniVariableReference->Value );
                        IniVariableReference->Value = AllocMem( (wcslen( VariableValue ) + 1) * sizeof( WCHAR ) );
                        wcscpy( IniVariableReference->Value, VariableValue );
                        if (!IniVariableReference->Created) {
                            if (!wcscmp( IniVariableReference->Value,
                                         IniVariableReference->OriginalValue
                                       ) )
                            {
                                FreeMem( &IniVariableReference->Value );
                            } else {
                                IniVariableReference->Modified = TRUE;
                            }
                        }
                    }                    else
                    if (!IniVariableReference->Created) {
                        IniVariableReference->Deleted = TRUE;
                    } else {
                        DestroyIniVariableReference( IniVariableReference );
                    }
                }

                VariableName = VariableValue;
                while (*VariableName++ != UNICODE_NULL) {}
            }
        }
    }

    return TRUE;
}


BOOLEAN
WritePrivateProfileSectionAHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PWRITEPRIVATEPROFILESECTIONA_PARAMETERS p = &Parameters->InputParameters.WritePrivateProfileSectionA;
    PWSTR SectionName, FileName, SectionValue;
    PWSTR IniFilePath;

    if (!Parameters->ReturnValueValid) {
        FileName = NULL;
        SectionValue = NULL;
        if (CaptureAnsiAsUnicode( Process, p->lpFileName, FALSE, NULL, &FileName ) &&
            GetIniFilePath( FileName, &IniFilePath ) &&
            CaptureAnsiAsUnicode( Process, p->lpAppName, FALSE, &SectionName, NULL ) &&
            CaptureAnsiAsUnicode( Process, p->lpString, TRUE, NULL, &SectionValue )
           ) {
            return WritePrivateProfileSectionEntry( Process,
                                                    Thread,
                                                    Parameters,
                                                    IniFilePath,
                                                    SectionName,
                                                    SectionValue
                                                  );
            }
        return FALSE;
        }
    else {
        return WritePrivateProfileSectionExit( Process,
                                               Thread,
                                               Parameters
                                             );
        }
}

BOOLEAN
WritePrivateProfileSectionWHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PWRITEPRIVATEPROFILESECTIONW_PARAMETERS p = &Parameters->InputParameters.WritePrivateProfileSectionW;
    PWSTR SectionName, FileName, SectionValue;
    PWSTR IniFilePath;

    if (!Parameters->ReturnValueValid) {
        FileName = NULL;
        SectionValue = NULL;
        if (CaptureUnicode( Process, p->lpFileName, FALSE, NULL, &FileName ) &&
            GetIniFilePath( FileName, &IniFilePath ) &&
            CaptureUnicode( Process, p->lpAppName, FALSE, &SectionName, NULL ) &&
            CaptureUnicode( Process, p->lpString, TRUE, NULL, &SectionValue )
           ) {
            return WritePrivateProfileSectionEntry( Process,
                                                    Thread,
                                                    Parameters,
                                                    IniFilePath,
                                                    SectionName,
                                                    SectionValue
                                                  );
            }
        return FALSE;
        }
    else {
        return WritePrivateProfileSectionExit( Process,
                                               Thread,
                                               Parameters
                                             );
        }
}


BOOLEAN
RegConnectRegistryWHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PREGCONNECTREGISTRYW_PARAMETERS p = &Parameters->InputParameters.RegConnectRegistryW;
    PWSTR MachineName;
    LONG ErrorCode;
    HKEY hKey;

    if (!Parameters->ReturnValueValid) {
        MachineName = NULL;
        if (!CaptureUnicode( Process, p->lpMachineName, FALSE, NULL, &MachineName )) {
            MachineName = L"Unknown";
            }

        if (AskUser( MB_OKCANCEL,
                     INSTALER_ASKUSER_REGCONNECT,
                     1,
                     MachineName
                   ) == IDCANCEL
           ) {
            FreeMem( &MachineName );
            Parameters->AbortCall = TRUE;
            return TRUE;
            }
        else {
            FreeMem( &MachineName );
            return FALSE;
            }
        }
    else
    if (Parameters->ReturnValue.ReturnedLong == 0) {
        ErrorCode = ERROR_ACCESS_DENIED;
        if (SetProcedureReturnValue( Process,
                                     Thread,
                                     &ErrorCode,
                                     sizeof( ErrorCode )
                                   )
           ) {
            if (ReadMemory( Process,
                            p->phkResult,
                            &hKey,
                            sizeof( hKey ),
                            "phkResult"
                          )
               ) {
                RegCloseKey( hKey );
                hKey = NULL;
                WriteMemory( Process,
                             p->phkResult,
                             &hKey,
                             sizeof( hKey ),
                             "phkResult"
                           );
                }
            }
        }

    return TRUE;
}


BOOLEAN
ExitWindowsExHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    )
{
    PEXITWINDOWSEX_PARAMETERS p = &Parameters->InputParameters.ExitWindowsEx;
    PWSTR MachineName;
    LONG ErrorCode;
    HKEY hKey;

    if (!Parameters->ReturnValueValid) {
        //
        // About to shutdown, save .IML file
        //
        return TRUE;
        }
    else
    if (!Parameters->ReturnValue.ReturnedBool) {
        //
        // Shutdown attempt failed, keep going
        //
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\ini.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ini.c

Abstract:

    This module implements the functions to save references to .INI file
    sections and values for the INSTALER program.  Part of each reference is
    a a backup copy of sections and values for an .INI file.

Author:

    Steve Wood (stevewo) 22-Aug-1994

Revision History:

--*/

#include "instaler.h"


BOOLEAN
CreateIniFileReference(
    PWSTR Name,
    PINI_FILE_REFERENCE *ReturnedReference
    )
{
    PINI_FILE_REFERENCE p;
    PINI_SECTION_REFERENCE p1;
    PINI_VARIABLE_REFERENCE p2;
    PWSTR SectionName;
    PWSTR VariableName;
    PWSTR VariableValue;
    UNICODE_STRING UnicodeString;
    PLIST_ENTRY Head, Next;
    ULONG n, n1;
    BOOLEAN Result;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindFileData;

    p = FindIniFileReference( Name );
    if (p != NULL) {
        *ReturnedReference = p;
        return TRUE;
        }

    p = AllocMem( sizeof( *p ) );
    if (p == NULL) {
        return FALSE;
        }

    p->Name = Name;
    InitializeListHead( &p->SectionReferencesListHead );
    InsertTailList( &IniReferenceListHead, &p->Entry );
    FindHandle = FindFirstFile( Name, &FindFileData );
    if (FindHandle == INVALID_HANDLE_VALUE) {
        p->Created = TRUE;
        *ReturnedReference = p;
        return TRUE;
        }
    FindClose( FindHandle );
    p->BackupLastWriteTime = FindFileData.ftLastWriteTime;

    GrowTemporaryBuffer( n = 0xF000 );
    SectionName = TemporaryBuffer;

    Result = TRUE;
    n1 = GetPrivateProfileStringW( NULL,
                                   NULL,
                                   L"",
                                   SectionName,
                                   n,
                                   Name
                                 );
    if (n1 == 0 || n1 == n-2) {
        Result = FALSE;
        }
    else {
        while (*SectionName != UNICODE_NULL) {
            p1 = AllocMem( sizeof( *p1 ) );
            if (p1 == NULL) {
                Result = FALSE;
                break;
                }

            RtlInitUnicodeString( &UnicodeString, SectionName );
            p1->Name = AddName( &UnicodeString );
            if (FindIniSectionReference( p, p1->Name, FALSE )) {
                FreeMem( &p1 );
                }
            else {
                InitializeListHead( &p1->VariableReferencesListHead );
                InsertTailList( &p->SectionReferencesListHead, &p1->Entry );
                }
            while (*SectionName++ != UNICODE_NULL) {
                }
            }
        }

    VariableName = TemporaryBuffer;
    Head = &p->SectionReferencesListHead;
    Next = Head->Flink;
    while (Result && (Head != Next)) {
        p1 = CONTAINING_RECORD( Next, INI_SECTION_REFERENCE, Entry );
        n1 = GetPrivateProfileSectionW( p1->Name,
                                        VariableName,
                                        n,
                                        Name
                                      );
        if (n1 == n-2) {
            Result = FALSE;
            break;
            }

        while (*VariableName != UNICODE_NULL) {
            VariableValue = VariableName;
            while (*VariableValue != UNICODE_NULL && *VariableValue != L'=') {
                VariableValue += 1;
                }

            if (*VariableValue != L'=') {
                Result = FALSE;
                break;
                }
            *VariableValue++ = UNICODE_NULL;

            p2 = AllocMem( sizeof( *p2 ) + ((wcslen( VariableValue ) + 1) * sizeof( WCHAR )) );
            if (p2 == NULL) {
                Result = FALSE;
                break;
                }
            RtlInitUnicodeString( &UnicodeString, VariableName );
            p2->Name = AddName( &UnicodeString );
            p2->OriginalValue = (PWSTR)(p2+1);
            wcscpy( p2->OriginalValue, VariableValue );
            InsertTailList( &p1->VariableReferencesListHead, &p2->Entry );

            VariableName = VariableValue;
            while (*VariableName++ != UNICODE_NULL) {
                }
            }

        Next = Next->Flink;
        }


    if (Result) {
        *ReturnedReference = p;
        }
    else {
        DestroyIniFileReference( p );
        }

    return Result;
}


BOOLEAN
DestroyIniFileReference(
    PINI_FILE_REFERENCE p
    )
{
    PLIST_ENTRY Next, Head;
    PINI_SECTION_REFERENCE p1;

    Head = &p->SectionReferencesListHead;
    Next = Head->Flink;
    while (Head != Next) {
        p1 = CONTAINING_RECORD( Next, INI_SECTION_REFERENCE, Entry );
        Next = Next->Flink;
        DestroyIniSectionReference( p1 );
        }

    RemoveEntryList( &p->Entry );
    FreeMem( &p );
    return TRUE;
}


BOOLEAN
DestroyIniSectionReference(
    PINI_SECTION_REFERENCE p1
    )
{
    PLIST_ENTRY Next, Head;
    PINI_VARIABLE_REFERENCE p2;

    Head = &p1->VariableReferencesListHead;
    Next = Head->Flink;
    while (Head != Next) {
        p2 = CONTAINING_RECORD( Next, INI_VARIABLE_REFERENCE, Entry );
        Next = Next->Flink;
        DestroyIniVariableReference( p2 );
        }

    RemoveEntryList( &p1->Entry );
    FreeMem( &p1 );
    return TRUE;
}


BOOLEAN
DestroyIniVariableReference(
    PINI_VARIABLE_REFERENCE p2
    )
{
    RemoveEntryList( &p2->Entry );
    FreeMem( &p2 );
    return TRUE;
}


PINI_FILE_REFERENCE
FindIniFileReference(
    PWSTR Name
    )
{
    PINI_FILE_REFERENCE p;
    PLIST_ENTRY Next, Head;

    Head = &IniReferenceListHead;
    Next = Head->Flink;
    while (Head != Next) {
        p = CONTAINING_RECORD( Next, INI_FILE_REFERENCE, Entry );
        if (p->Name == Name) {
            return p;
            }

        Next = Next->Flink;
        }

    return NULL;
}

PINI_SECTION_REFERENCE
FindIniSectionReference(
    PINI_FILE_REFERENCE p,
    PWSTR Name,
    BOOLEAN CreateOkay
    )
{
    PLIST_ENTRY Next, Head;
    PINI_SECTION_REFERENCE p1;

    Head = &p->SectionReferencesListHead;
    Next = Head->Flink;
    while (Head != Next) {
        p1 = CONTAINING_RECORD( Next, INI_SECTION_REFERENCE, Entry );
        if (p1->Name == Name) {
            return p1;
            }

        Next = Next->Flink;
        }

    if (CreateOkay) {
        p1 = AllocMem( sizeof( *p1 ) );
        if (p1 != NULL) {
            p1->Created = TRUE;
            p1->Name = Name;
            InitializeListHead( &p1->VariableReferencesListHead );
            InsertTailList( &p->SectionReferencesListHead, &p1->Entry );
            }
        }
    else {
        p1 = NULL;
        }

    return p1;
}


PINI_VARIABLE_REFERENCE
FindIniVariableReference(
    PINI_SECTION_REFERENCE p1,
    PWSTR Name,
    BOOLEAN CreateOkay
    )
{
    PLIST_ENTRY Next, Head;
    PINI_VARIABLE_REFERENCE p2;

    Head = &p1->VariableReferencesListHead;
    Next = Head->Flink;
    while (Head != Next) {
        p2 = CONTAINING_RECORD( Next, INI_VARIABLE_REFERENCE, Entry );
        if (p2->Name == Name) {
            return p2;
            }

        Next = Next->Flink;
        }

    if (CreateOkay) {
        p2 = AllocMem( sizeof( *p2 ) );
        if (p2 != NULL) {
            p2->Created = TRUE;
            p2->Name = Name;
            InsertTailList( &p1->VariableReferencesListHead, &p2->Entry );
            }
        }
    else {
        p2 = NULL;
        }

    return p2;
}


VOID
DumpIniFileReferenceList(
    FILE *LogFile
    )
{
    PINI_FILE_REFERENCE p;
    PINI_SECTION_REFERENCE p1;
    PINI_VARIABLE_REFERENCE p2;
    PLIST_ENTRY Head, Next;
    PLIST_ENTRY Head1, Next1;
    PLIST_ENTRY Head2, Next2;
    POFFSET Variables;
    POFFSET Sections;


    Head = &IniReferenceListHead;
    Next = Head->Blink;
    while (Head != Next) {
        p = CONTAINING_RECORD( Next, INI_FILE_REFERENCE, Entry );
        Sections = 0;
        Head1 = &p->SectionReferencesListHead;
        Next1 = Head1->Blink;
        while (Head1 != Next1) {
            p1 = CONTAINING_RECORD( Next1, INI_SECTION_REFERENCE, Entry );
            Variables = 0;
            Head2 = &p1->VariableReferencesListHead;
            Next2 = Head2->Blink;
            while (Head2 != Next2) {
                p2 = CONTAINING_RECORD( Next2, INI_VARIABLE_REFERENCE, Entry );
                if (p2->Created || p2->Deleted || p2->Modified) {
                    ImlAddIniVariableRecord( pImlNew,
                                             p2->Created ? CreateNewVariable :
                                             p2->Deleted ? DeleteOldVariable : ModifyOldVariable,
                                             p2->Name,
                                             p2->OriginalValue,
                                             p2->Value,
                                             &Variables
                                           );
                    }
                Next2 = Next2->Blink;
                }

            if (Variables != 0) {
                ImlAddIniSectionRecord( pImlNew,
                                        p1->Created ? CreateNewSection :
                                        p1->Deleted ? DeleteOldSection :  ModifySectionVariables,
                                        p1->Name,
                                        Variables,
                                        &Sections
                                      );
                }

            Next1 = Next1->Blink;
            }

        if (Sections != 0) {
            ImlAddIniRecord( pImlNew,
                             p->Created ? CreateNewIniFile : ModifyOldIniFile,
                             p->Name,
                             &p->BackupLastWriteTime,
                             Sections
                           );
            }

        Next = Next->Blink;
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\instaler.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    instaler.h

Abstract:

    Main include file for the INSTALER application.

Author:

    Steve Wood (stevewo) 09-Aug-1994

Revision History:

--*/

#ifdef RC_INVOKED
#include <windows.h>

#define FILEBMP  500
#define DIRBMP   501

#else

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdmdbg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "errormsg.h"

//
// Data structures and entry points in ERROR.C
//

#define TRACE_ENABLED 1

#if TRACE_ENABLED
extern ULONG EnabledTraceEvents;

#define DBG_MASK_DBGEVENT       0x00000001
#define DBG_MASK_INTERNALERROR  0x00000002
#define DBG_MASK_MEMORYERROR    0x00000004
#define DBG_MASK_CREATEEVENT    0x00000008

VOID
TraceDisplay(
    const char *FormatString,
    ...
    );

#define DbgEvent( m, x ) if (EnabledTraceEvents & (DBG_MASK_##m)) TraceDisplay x
#define TestDbgEvent( m ) (EnabledTraceEvents & (DBG_MASK_##m))
#else
#define DbgEvent( m, x )
#define TestDbgEvent( m ) (FALSE)
#endif


VOID
CDECL
DeclareError(
    UINT ErrorCode,
    UINT SupplementalErrorCode,
    ...
    );

UINT
CDECL
AskUser(
    UINT MessageBoxFlags,
    UINT MessageId,
    UINT NumberOfArguments,
    ...
    );


//
// Data structures and entry points in EVENT.C
//

VOID
CDECL
LogEvent(
    UINT MessageId,
    UINT NumberOfArguments,
    ...
    );

//
// Data structures and entry points in PROCESS.C
//

#define HANDLE_TYPE_FILE 0
#define HANDLE_TYPE_KEY 1
#define HANDLE_TYPE_NONE 2

typedef struct _OPENHANDLE_INFO {
    LIST_ENTRY Entry;
    HANDLE Handle;
    BOOLEAN Inherit;
    BOOLEAN RootDirectory;
    USHORT Type;
    USHORT LengthOfName;
    PWSTR Name;

    //
    // Union for handlers that need to store state in a handle during
    // use.
    //
    union {
        PWSTR QueryName;
    };
} OPENHANDLE_INFO, *POPENHANDLE_INFO;

typedef struct _PROCESS_INFO {
    LIST_ENTRY Entry;
    LIST_ENTRY ThreadListHead;
    LIST_ENTRY BreakpointListHead;
    LIST_ENTRY OpenHandleListHead;
    DWORD Id;
    HANDLE Handle;
    PROCESS_BASIC_INFORMATION ProcessInformation;
    WCHAR ImageFileName[ 32 ];
} PROCESS_INFO, *PPROCESS_INFO;

typedef struct _THREAD_INFO {
    LIST_ENTRY Entry;
    LIST_ENTRY BreakpointListHead;
    DWORD Id;
    HANDLE Handle;
    PVOID StartAddress;
    ULONG ModuleIndexCurrentlyIn;
    BOOLEAN SingleStepExpected;
    struct _BREAKPOINT_INFO *BreakpointToStepOver;
} THREAD_INFO, *PTHREAD_INFO;

LIST_ENTRY ProcessListHead;

BOOLEAN
AddProcess(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO *ReturnedProcess
    );

BOOLEAN
DeleteProcess(
    PPROCESS_INFO Process
    );

BOOLEAN
AddThread(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO Process,
    PTHREAD_INFO *ReturnedThread
    );

BOOLEAN
DeleteThread(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    );

PPROCESS_INFO
FindProcessById(
    ULONG Id
    );

BOOLEAN
FindProcessAndThreadForEvent(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO *ReturnedProcess,
    PTHREAD_INFO *ReturnedThread
    );

BOOLEAN
HandleThreadsForSingleStep(
    PPROCESS_INFO Process,
    PTHREAD_INFO ThreadToSingleStep,
    BOOLEAN SuspendThreads
    );

BOOLEAN
ReadMemory(
    PPROCESS_INFO Process,
    PVOID Address,
    PVOID DataRead,
    ULONG BytesToRead,
    PCHAR Reason
    );

BOOLEAN
WriteMemory(
    PPROCESS_INFO Process,
    PVOID Address,
    PVOID DataToWrite,
    ULONG BytesToWrite,
    PCHAR Reason
    );

PVOID
AllocMem(
    ULONG Size
    );

VOID
FreeMem(
    PVOID *p
    );


//
// Data structures and entry points in MACHINE.C
//

PVOID BreakpointInstruction;
ULONG SizeofBreakpointInstruction;

PVOID
GetAddressForEntryPointBreakpoint(
    PVOID EntryPointAddress,
    DWORD NumberOfFunctionTableEntries OPTIONAL,
    PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionTableEntries OPTIONAL
    );

BOOLEAN
SkipOverHardcodedBreakpoint(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PVOID BreakpointAddress
    );

BOOLEAN
ExtractProcedureParameters(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PULONG ReturnAddress,
    ULONG SizeOfParameters,
    PULONG Parameters
    );

BOOLEAN
ExtractProcedureReturnValue(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PVOID ReturnValue,
    ULONG SizeOfReturnValue
    );

BOOLEAN
SetProcedureReturnValue(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PVOID ReturnValue,
    ULONG SizeOfReturnValue
    );

BOOLEAN
ForceReturnToCaller(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    ULONG SizeOfParameters,
    PVOID ReturnAddress,
    PVOID ReturnValue,
    ULONG SizeOfReturnValue
    );

BOOLEAN
UndoReturnAddressBreakpoint(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    );

BOOLEAN
BeginSingleStepBreakpoint(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    );

BOOLEAN
EndSingleStepBreakpoint(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    );

typedef enum _API_ACTION {
    QueryPath,
    OpenPath,
    RenamePath,
    DeletePath,
    SetValue,
    DeleteValue,
    WriteIniValue,
    WriteIniSection
} API_ACTION;

typedef struct _API_SAVED_CALL_STATE {
    LIST_ENTRY Entry;
    API_ACTION Action;
    ULONG Type;
    PWSTR FullName;
    PVOID Reference;
    union {
        struct {
            BOOLEAN InheritHandle;
            BOOLEAN WriteAccessRequested;
            PHANDLE ResultHandleAddress;
        } PathOpen;
        struct {
            PWSTR NewName;
            BOOLEAN ReplaceIfExists;
        } PathRename;
        struct {
            PWSTR SectionName;
            PWSTR VariableName;
            PWSTR VariableValue;
        } SetIniValue;
        struct {
            PWSTR SectionName;
            PWSTR SectionValue;
        } SetIniSection;
    };
} API_SAVED_CALL_STATE, *PAPI_SAVED_CALL_STATE;

BOOLEAN
CreateSavedCallState(
    PPROCESS_INFO Process,
    PAPI_SAVED_CALL_STATE SavedCallState,
    API_ACTION Action,
    ULONG Type,
    PWSTR FullName,
    ...
    );

VOID
FreeSavedCallState(
    PAPI_SAVED_CALL_STATE CallState
    );



//
// Data structures and entry points in HANDLER.C
//

typedef struct _CREATEFILE_PARAMETERS {
    PHANDLE FileHandle;
    ACCESS_MASK DesiredAccess;
    POBJECT_ATTRIBUTES ObjectAttributes;
    PIO_STATUS_BLOCK IoStatusBlock;
    PLARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG CreateDisposition;
    ULONG CreateOptions;
} CREATEFILE_PARAMETERS, *PCREATEFILE_PARAMETERS;

typedef struct _OPENFILE_PARAMETERS {
    PHANDLE FileHandle;
    ACCESS_MASK DesiredAccess;
    POBJECT_ATTRIBUTES ObjectAttributes;
    PIO_STATUS_BLOCK IoStatusBlock;
    ULONG ShareAccess;
    ULONG OpenOptions;
} OPENFILE_PARAMETERS, *POPENFILE_PARAMETERS;

typedef struct _DELETEFILE_PARAMETERS {
    POBJECT_ATTRIBUTES ObjectAttributes;
} DELETEFILE_PARAMETERS, *PDELETEFILE_PARAMETERS;

typedef struct _SETINFORMATIONFILE_PARAMETERS {
    HANDLE FileHandle;
    PIO_STATUS_BLOCK IoStatusBlock;
    PVOID FileInformation;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
} SETINFORMATIONFILE_PARAMETERS, *PSETINFORMATIONFILE_PARAMETERS;

typedef struct _QUERYATTRIBUTESFILE_PARAMETERS {
    POBJECT_ATTRIBUTES ObjectAttributes;
    PFILE_BASIC_INFORMATION FileInformation;
} QUERYATTRIBUTESFILE_PARAMETERS, *PQUERYATTRIBUTESFILE_PARAMETERS;

typedef struct _QUERYDIRECTORYFILE_PARAMETERS {
    HANDLE FileHandle;
    HANDLE Event;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PIO_STATUS_BLOCK IoStatusBlock;
    PVOID FileInformation;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    BOOLEAN ReturnSingleEntry;
    PUNICODE_STRING FileName;
    BOOLEAN RestartScan;
} QUERYDIRECTORYFILE_PARAMETERS, *PQUERYDIRECTORYFILE_PARAMETERS;

typedef struct _CREATEKEY_PARAMETERS {
    PHANDLE KeyHandle;
    ACCESS_MASK DesiredAccess;
    POBJECT_ATTRIBUTES ObjectAttributes;
    ULONG TitleIndex;
    PUNICODE_STRING Class;
    ULONG CreateOptions;
    PULONG Disposition;
} CREATEKEY_PARAMETERS, *PCREATEKEY_PARAMETERS;

typedef struct _OPENKEY_PARAMETERS {
    PHANDLE KeyHandle;
    ACCESS_MASK DesiredAccess;
    POBJECT_ATTRIBUTES ObjectAttributes;
} OPENKEY_PARAMETERS, *POPENKEY_PARAMETERS;

typedef struct _DELETEKEY_PARAMETERS {
    HANDLE KeyHandle;
} DELETEKEY_PARAMETERS, *PDELETEKEY_PARAMETERS;

typedef struct _SETVALUEKEY_PARAMETERS {
    HANDLE KeyHandle;
    PUNICODE_STRING ValueName;
    ULONG TitleIndex;
    ULONG Type;
    PVOID Data;
    ULONG DataLength;
} SETVALUEKEY_PARAMETERS, *PSETVALUEKEY_PARAMETERS;

typedef struct _DELETEVALUEKEY_PARAMETERS {
    HANDLE KeyHandle;
    PUNICODE_STRING ValueName;
} DELETEVALUEKEY_PARAMETERS, *PDELETEVALUEKEY_PARAMETERS;

typedef struct _CLOSEHANDLE_PARAMETERS {
    HANDLE Handle;
} CLOSEHANDLE_PARAMETERS, *PCLOSEHANDLE_PARAMETERS;

typedef struct _GETVERSIONEXW_PARAMETERS {
    LPOSVERSIONINFOA lpVersionInformation;
} GETVERSIONEXW_PARAMETERS, *PGETVERSIONEXW_PARAMETERS;

typedef struct _SETCURRENTDIRECTORYA_PARAMETERS {
    LPSTR lpPathName;
} SETCURRENTDIRECTORYA_PARAMETERS, *PSETCURRENTDIRECTORYA_PARAMETERS;

typedef struct _SETCURRENTDIRECTORYW_PARAMETERS {
    PWSTR lpPathName;
} SETCURRENTDIRECTORYW_PARAMETERS, *PSETCURRENTDIRECTORYW_PARAMETERS;

typedef struct _WRITEPRIVATEPROFILESTRINGA_PARAMETERS {
    LPCSTR lpAppName;
    LPCSTR lpKeyName;
    LPCSTR lpString;
    LPCSTR lpFileName;
} WRITEPRIVATEPROFILESTRINGA_PARAMETERS, *PWRITEPRIVATEPROFILESTRINGA_PARAMETERS;

typedef struct _WRITEPRIVATEPROFILESTRINGW_PARAMETERS {
    LPCWSTR lpAppName;
    LPCWSTR lpKeyName;
    LPCWSTR lpString;
    LPCWSTR lpFileName;
} WRITEPRIVATEPROFILESTRINGW_PARAMETERS, *PWRITEPRIVATEPROFILESTRINGW_PARAMETERS;

typedef struct _WRITEPRIVATEPROFILESECTIONA_PARAMETERS {
    LPCSTR lpAppName;
    LPCSTR lpString;
    LPCSTR lpFileName;
} WRITEPRIVATEPROFILESECTIONA_PARAMETERS, *PWRITEPRIVATEPROFILESECTIONA_PARAMETERS;

typedef struct _WRITEPRIVATEPROFILESECTIONW_PARAMETERS {
    LPCWSTR lpAppName;
    LPCWSTR lpString;
    LPCWSTR lpFileName;
} WRITEPRIVATEPROFILESECTIONW_PARAMETERS, *PWRITEPRIVATEPROFILESECTIONW_PARAMETERS;

typedef struct _REGCONNECTREGISTRYW_PARAMETERS {
    LPWSTR lpMachineName;
    HKEY hKey;
    PHKEY phkResult;
} REGCONNECTREGISTRYW_PARAMETERS, *PREGCONNECTREGISTRYW_PARAMETERS;

typedef struct _EXITWINDOWSEX_PARAMETERS {
    DWORD uFlags;
    DWORD dwReserved;
} EXITWINDOWSEX_PARAMETERS, *PEXITWINDOWSEX_PARAMETERS;

typedef struct _API_SAVED_PARAMETERS {
    API_SAVED_CALL_STATE SavedCallState;
    union {
        CREATEFILE_PARAMETERS CreateFile;
        OPENFILE_PARAMETERS OpenFile;
        DELETEFILE_PARAMETERS DeleteFile;
        SETINFORMATIONFILE_PARAMETERS SetInformationFile;
        QUERYATTRIBUTESFILE_PARAMETERS QueryAttributesFile;
        QUERYDIRECTORYFILE_PARAMETERS QueryDirectoryFile;
        CREATEKEY_PARAMETERS CreateKey;
        OPENKEY_PARAMETERS OpenKey;
        DELETEKEY_PARAMETERS DeleteKey;
        SETVALUEKEY_PARAMETERS SetValueKey;
        DELETEVALUEKEY_PARAMETERS DeleteValueKey;
        CLOSEHANDLE_PARAMETERS CloseHandle;
        GETVERSIONEXW_PARAMETERS GetVersionExW;
        SETCURRENTDIRECTORYA_PARAMETERS SetCurrentDirectoryA;
        SETCURRENTDIRECTORYW_PARAMETERS SetCurrentDirectoryW;
        WRITEPRIVATEPROFILESTRINGA_PARAMETERS WritePrivateProfileStringA;
        WRITEPRIVATEPROFILESTRINGW_PARAMETERS WritePrivateProfileStringW;
        WRITEPRIVATEPROFILESECTIONA_PARAMETERS WritePrivateProfileSectionA;
        WRITEPRIVATEPROFILESECTIONW_PARAMETERS WritePrivateProfileSectionW;
        REGCONNECTREGISTRYW_PARAMETERS RegConnectRegistryW;
        EXITWINDOWSEX_PARAMETERS ExitWindowsEx;
    } InputParameters;
    PVOID ReturnAddress;
    union {
        UCHAR ReturnedByte;
        USHORT ReturnedShort;
        ULONG ReturnedLong;
        ULONGLONG ReturnedQuad;
        BOOL ReturnedBool;
    } ReturnValue;
    BOOLEAN ReturnValueValid;

    //
    // Union for handlers that need to store state between entry and
    // exit, without the overhead of allocating an API_SAVED_CALL_STATE
    //
    union {
        BOOLEAN AbortCall;
        PWSTR CurrentDirectory;
    };
} API_SAVED_PARAMETERS, *PAPI_SAVED_PARAMETERS;

BOOLEAN
NtCreateFileHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
NtOpenFileHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
NtDeleteFileHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
NtSetInformationFileHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
NtQueryAttributesFileHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
NtQueryDirectoryFileHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
NtCreateKeyHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
NtOpenKeyHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
NtDeleteKeyHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
NtSetValueKeyHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
NtDeleteValueKeyHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );


BOOLEAN
NtCloseHandleHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
GetVersionHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
GetVersionExWHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
SetCurrentDirectoryAHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
SetCurrentDirectoryWHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
WritePrivateProfileStringAHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
WritePrivateProfileStringWHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
WritePrivateProfileSectionAHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
WritePrivateProfileSectionWHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
RegConnectRegistryWHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

BOOLEAN
ExitWindowsExHandler(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

//
// Data structures and entry points in DEBUG.C
//

CRITICAL_SECTION BreakTable;

typedef struct _BREAKPOINT_INFO {
    LIST_ENTRY Entry;
    PVOID Address;
    UCHAR ApiIndex;
    PWSTR ModuleName;
    LPSTR ProcedureName;
    BOOLEAN SavedInstructionValid;
    BOOLEAN SavedParametersValid;
    union {
        UCHAR Byte;
        USHORT Short;
        ULONG Long;
        ULONGLONG LongLong;
    } SavedInstruction;
    API_SAVED_PARAMETERS SavedParameters;
} BREAKPOINT_INFO, *PBREAKPOINT_INFO;

VOID
DebugEventLoop( VOID );


BOOLEAN
InstallBreakpoint(
    PPROCESS_INFO Process,
    PBREAKPOINT_INFO Breakpoint
    );

BOOLEAN
RemoveBreakpoint(
    PPROCESS_INFO Process,
    PBREAKPOINT_INFO Breakpoint
    );

BOOLEAN
HandleBreakpoint(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PBREAKPOINT_INFO Breakpoint
    );


BOOLEAN
CreateBreakpoint(
    PVOID Address,
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    UCHAR ApiIndex,
    PVOID SavedParameters,
    PBREAKPOINT_INFO *Breakpoint
    );

BOOLEAN
DestroyBreakpoint(
    PVOID Address,
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    );

PBREAKPOINT_INFO
FindBreakpoint(
    PVOID Address,
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    );

VOID
SuspendAllButThisThread(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    );

VOID
ResumeAllButThisThread(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    );



//
// Data structures and entry points in HANDLEDB.C
//

POPENHANDLE_INFO
FindOpenHandle(
    PPROCESS_INFO Process,
    HANDLE Handle,
    ULONG Type
    );

BOOLEAN
AddOpenHandle(
    PPROCESS_INFO Process,
    HANDLE Handle,
    ULONG Type,
    PWSTR Name,
    BOOLEAN InheritHandle
    );

BOOLEAN
DeleteOpenHandle(
    PPROCESS_INFO Process,
    HANDLE Handle,
    ULONG Type
    );

VOID
InheritHandles(
    PPROCESS_INFO Process
    );



//
// Data structures and entry points in FILE.C
//


typedef struct _FILE_REFERENCE {
    LIST_ENTRY Entry;
    PWSTR Name;
    ULONG PrefixLength;
    BOOLEAN WriteAccess;
    BOOLEAN Deleted;
    BOOLEAN Created;
    BOOLEAN AttributesModified;
    BOOLEAN DateModified;
    BOOLEAN ContentsModified;
    BOOLEAN DirectoryFile;
    USHORT BackupFileUniqueId;
    DWORD BackupFileAttributes;
    FILETIME BackupLastWriteTime;
    ULARGE_INTEGER BackupFileSize;
} FILE_REFERENCE, *PFILE_REFERENCE;


BOOLEAN
CreateFileReference(
    PWSTR Name,
    BOOLEAN WriteAccess,
    PFILE_REFERENCE *ReturnedReference
    );

BOOLEAN
CompleteFileReference(
    PFILE_REFERENCE p,
    BOOLEAN CallSuccessful,
    BOOLEAN Delete,
    PFILE_REFERENCE RenameReference
    );

BOOLEAN
DestroyFileReference(
    PFILE_REFERENCE p
    );

BOOLEAN
IsNewFileSameAsBackup(
    PFILE_REFERENCE p
    );

PFILE_REFERENCE
FindFileReference(
    PWSTR Name
    );

VOID
DumpFileReferenceList(
    FILE *LogFile
    );

//
// Data structures and entry points in KEY.C
//

typedef struct _KEY_REFERENCE {
    LIST_ENTRY Entry;
    PWSTR Name;
    ULONG PrefixLength;
    BOOLEAN WriteAccess;
    BOOLEAN Deleted;
    BOOLEAN Created;
    PKEY_FULL_INFORMATION BackupKeyInfo;
    LIST_ENTRY ValueReferencesListHead;
} KEY_REFERENCE, *PKEY_REFERENCE;

typedef struct _VALUE_REFERENCE {
    LIST_ENTRY Entry;
    PWSTR Name;
    BOOLEAN Modified;
    BOOLEAN Deleted;
    BOOLEAN Created;
    PKEY_VALUE_PARTIAL_INFORMATION Value;
    KEY_VALUE_PARTIAL_INFORMATION OriginalValue;
} VALUE_REFERENCE, *PVALUE_REFERENCE;

BOOLEAN
CreateKeyReference(
    PWSTR Name,
    BOOLEAN WriteAccess,
    PKEY_REFERENCE *ReturnedReference
    );

BOOLEAN
CompleteKeyReference(
    PKEY_REFERENCE p,
    BOOLEAN CallSuccessful,
    BOOLEAN Delete
    );

BOOLEAN
DestroyKeyReference(
    PKEY_REFERENCE p
    );

PKEY_REFERENCE
FindKeyReference(
    PWSTR Name
    );

VOID
MarkKeyDeleted(
    PKEY_REFERENCE KeyReference
    );

BOOLEAN
CreateValueReference(
    PPROCESS_INFO Process,
    PKEY_REFERENCE KeyReference,
    PWSTR Name,
    ULONG TitleIndex,
    ULONG Type,
    PVOID Data,
    ULONG DataLength,
    PVALUE_REFERENCE *ReturnedValueReference
    );

PVALUE_REFERENCE
FindValueReference(
    PKEY_REFERENCE KeyReference,
    PWSTR Name
    );

BOOLEAN
DestroyValueReference(
    PVALUE_REFERENCE p
    );

VOID
DumpKeyReferenceList(
    FILE *LogFile
    );

//
// Data structures and entry points in INI.C
//

typedef struct _INI_FILE_REFERENCE {
    LIST_ENTRY Entry;
    PWSTR Name;
    ULONG PrefixLength;
    BOOLEAN Created;
    FILETIME BackupLastWriteTime;
    LIST_ENTRY SectionReferencesListHead;
} INI_FILE_REFERENCE, *PINI_FILE_REFERENCE;

typedef struct _INI_SECTION_REFERENCE {
    LIST_ENTRY Entry;
    PWSTR Name;
    BOOLEAN Deleted;
    BOOLEAN Created;
    LIST_ENTRY VariableReferencesListHead;
} INI_SECTION_REFERENCE, *PINI_SECTION_REFERENCE;

typedef struct _INI_VARIABLE_REFERENCE {
    LIST_ENTRY Entry;
    PWSTR Name;
    BOOLEAN Modified;
    BOOLEAN Deleted;
    BOOLEAN Created;
    PWSTR OriginalValue;
    PWSTR Value;
} INI_VARIABLE_REFERENCE, *PINI_VARIABLE_REFERENCE;


BOOLEAN
CreateIniFileReference(
    PWSTR Name,
    PINI_FILE_REFERENCE *ReturnedReference
    );

BOOLEAN
DestroyIniFileReference(
    PINI_FILE_REFERENCE p
    );

BOOLEAN
DestroyIniSectionReference(
    PINI_SECTION_REFERENCE p1
    );

BOOLEAN
DestroyIniVariableReference(
    PINI_VARIABLE_REFERENCE p2
    );

PINI_FILE_REFERENCE
FindIniFileReference(
    PWSTR Name
    );

PINI_SECTION_REFERENCE
FindIniSectionReference(
    PINI_FILE_REFERENCE p,
    PWSTR Name,
    BOOLEAN CreateOkay
    );

PINI_VARIABLE_REFERENCE
FindIniVariableReference(
    PINI_SECTION_REFERENCE p1,
    PWSTR Name,
    BOOLEAN CreateOkay
    );

VOID
DumpIniFileReferenceList(
    FILE *LogFile
    );

//
// Data structures and entry points in NAMEDB.C
//

PWSTR
AddName(
    PUNICODE_STRING Name
    );

VOID
DumpNameDataBase(
    FILE *LogFile
    );

BOOLEAN
IncrementOpenCount(
    PWSTR Name,
    BOOLEAN CallSuccessful
    );

ULONG
QueryOpenCount(
    PWSTR Name,
    BOOLEAN CallSuccessful
    );



//
// Data structures and entry points in INIT.C
//

HMODULE InstalerModuleHandle;
HANDLE AppHeap;
UNICODE_STRING WindowsDirectory;
ULONG StartProcessTickCount;
FILE *InstalerLogFile;
BOOLEAN AskUserOnce;
BOOLEAN DefaultGetVersionToWin95;
BOOLEAN FailAllScansOfRootDirectories;



LIST_ENTRY FileReferenceListHead;
ULONG NumberOfFileReferences;
LIST_ENTRY KeyReferenceListHead;
ULONG NumberOfKeyReferences;
LIST_ENTRY IniReferenceListHead;
ULONG NumberOfIniReferences;

#define NTDLL_MODULE_INDEX 0
#define KERNEL32_MODULE_INDEX 1
#define ADVAPI32_MODULE_INDEX 2
#define USER32_MODULE_INDEX 3
#define MAXIMUM_MODULE_INDEX 4

typedef struct _MODULE_INFO {
    PWSTR ModuleName;
    HMODULE ModuleHandle;
} MODULE_INFO, *PMODULE_INFO;

MODULE_INFO ModuleInfo[ MAXIMUM_MODULE_INDEX ];

typedef BOOLEAN (*PAPI_HANDLER)(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PAPI_SAVED_PARAMETERS Parameters
    );

typedef struct _API_INFO {
    ULONG ModuleIndex;
    LPSTR EntryPointName;                   // Exported names are ANSI only
    PVOID EntryPointAddress;
    PAPI_HANDLER EntryPointHandler;
    ULONG SizeOfParameters;
    ULONG SizeOfReturnValue;
} API_INFO, *PAPI_INFO;

#define NTCREATEFILE_INDEX                  0
#define NTOPENFILE_INDEX                    1
#define NTDELETEFILE_INDEX                  2
#define NTSETINFORMATIONFILE_INDEX          3
#define NTQUERYATTRIBUTESFILE_INDEX         4
#define NTQUERYDIRECTORYFILE_INDEX          5
#define NTCREATEKEY_INDEX                   6
#define NTOPENKEY_INDEX                     7
#define NTDELETEKEY_INDEX                   8
#define NTSETVALUEKEY_INDEX                 9
#define NTDELETEVALUEKEY_INDEX              10
#define NTCLOSEHANDLE_INDEX                 11
#define GETVERSION_INDEX                    12
#define GETVERSIONEXW_INDEX                 13
#define SETCURRENTDIRECTORYA_INDEX          14
#define SETCURRENTDIRECTORYW_INDEX          15
#define WRITEPRIVATEPROFILESTRINGA_INDEX    16
#define WRITEPRIVATEPROFILESTRINGW_INDEX    17
#define WRITEPRIVATEPROFILESECTIONA_INDEX   18
#define WRITEPRIVATEPROFILESECTIONW_INDEX   19
#define GETPRIVATEPROFILESTRINGA_INDEX      20
#define GETPRIVATEPROFILESTRINGW_INDEX      21
#define GETPRIVATEPROFILESECTIONA_INDEX     22
#define GETPRIVATEPROFILESECTIONW_INDEX     23
#define REGCONNECTREGISTRYW_INDEX           24
#define EXITWINDOWSEX_INDEX                 25
#define MAXIMUM_API_INDEX                   26

API_INFO ApiInfo[ MAXIMUM_API_INDEX ];

typedef struct _DRIVE_LETTER_INFO {
    WCHAR DriveLetter;
    BOOLEAN DriveLetterValid;
    UNICODE_STRING NtLinkTarget;
} DRIVE_LETTER_INFO, *PDRIVE_LETTER_INFO;

UNICODE_STRING UNCPrefix;
UNICODE_STRING DriveLetterPrefix;
UNICODE_STRING AltDriveLetterPrefix;
DRIVE_LETTER_INFO DriveLetters[ 32 ];

BOOLEAN
InitializeInstaler(
    int argc,
    char *argv[]
    );

PVOID
LookupEntryPointInIAT(
    HMODULE ModuleHandle,
    PCHAR EntryPointName
    );

BOOLEAN
IsDriveLetterPath(
    PUNICODE_STRING Path
    );


PVOID TemporaryBuffer;
ULONG TemporaryBufferLength;
ULONG TemporaryBufferLengthGrowth;
ULONG TemporaryBufferMaximumLength;

VOID
TrimTemporaryBuffer( VOID );

BOOLEAN
GrowTemporaryBuffer(
    ULONG NeededSize
    );

ULONG
FillTemporaryBuffer(
    PPROCESS_INFO Process,
    PVOID Address,
    BOOLEAN Unicode,
    BOOLEAN DoubleNullTermination
    );

#include "instutil.h"
#include "iml.h"

PINSTALLATION_MODIFICATION_LOGFILE pImlNew;


#endif // defined( RC_INVOKED )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\instutil.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    instutil.c

Abstract:

    Common code for INSTALER.EXE, DISPINST.EXE, COMPINST.EXE and UNDOINST.EXE

Author:

    Steve Wood (stevewo) 14-Jan-1996

Revision History:

--*/

#include "instutil.h"
#include "iml.h"

LPSTR SavedModuleName;
LPSTR SavedModuleUsage1;
LPSTR SavedModuleUsage2;

WCHAR AltTempFilePathBuffer[ MAX_PATH ];
PWSTR AltTempFilePathFileName;
WCHAR TempFilePathBuffer[ MAX_PATH ];
PWSTR TempFilePathFileName;
USHORT TempFileNextUniqueId;

BOOL WINAPI
CtrlCHandler(
    ULONG CtrlType
    )
{
    //
    // Ignore control C interrupts.  Let child process deal with them
    // if it wants.  If it doesn't then it will terminate and we will
    // get control and terminate ourselves
    //

    return TRUE;
}

void
InitCommonCode(
    LPSTR ModuleName,
    LPSTR ModuleUsage1,
    LPSTR ModuleUsage2
    )
{
    SavedModuleName = ModuleName;
    SavedModuleUsage1 = ModuleUsage1;
    SavedModuleUsage2 = ModuleUsage2;

    GetTempPath( sizeof( TempFilePathBuffer ) / sizeof( WCHAR ),
                 TempFilePathBuffer
               );
    TempFilePathFileName = TempFilePathBuffer + wcslen( TempFilePathBuffer );
    TempFileNextUniqueId = (USHORT)0x0001;

    InstalerDirectory[ 0 ] = UNICODE_NULL;
    return;
}

void
DisplayIndentedString(
    ULONG IndentAmount,
    PCHAR sBegin
    )
{
    PCHAR sEnd;

    while (sBegin != NULL) {
        sEnd = sBegin;
        while (*sEnd && *sEnd != '\n') {
            sEnd += 1;
            }

        fprintf( stderr, "%.*s%.*s\n",
                 IndentAmount,
                 "                                                      ",
                 sEnd - sBegin, sBegin
               );

        if (*sEnd == '\0') {
            break;
            }
        else {
            sBegin = ++sEnd;
            }
        }
    return;
}


void
Usage(
    LPSTR Message,
    ULONG MessageParameter
    )
{
    ULONG n;
    LPSTR sBegin, sEnd;

    n = fprintf( stderr, "usage: %s ", SavedModuleName );
    fprintf( stderr, "InstallationName\n" );
    DisplayIndentedString( n, SavedModuleUsage1 );
    fprintf( stderr, "\n" );

    n = fprintf( stderr, "where: " );
    fprintf( stderr, "InstallationName specifies a name for the installation.  This is a required parameter.\n" );
    DisplayIndentedString( n,
                           "-? Displays this message."
                         );
    fprintf( stderr, "\n" );
    DisplayIndentedString( n, SavedModuleUsage2 );

    if (Message != NULL) {
        fprintf( stderr, "\n" );
        }

    //
    // No return from FatalError
    //
    FatalError( Message, MessageParameter, 0 );
}

void
FatalError(
    LPSTR Message,
    ULONG MessageParameter1,
    ULONG MessageParameter2
    )
{
    if (Message != NULL) {
        fprintf( stderr, "%s: ", SavedModuleName );
        fprintf( stderr, Message, MessageParameter1, MessageParameter2 );
        fprintf( stderr, "\n" );
        }

    exit( 1 );
}


PWSTR
GetArgAsUnicode(
    LPSTR s
    )
{
    ULONG n;
    PWSTR ps;

    n = strlen( s );
    ps = HeapAlloc( GetProcessHeap(),
                    0,
                    (n + 1) * sizeof( WCHAR )
                  );
    if (ps == NULL) {
        FatalError( "Out of memory", 0, 0 );
        }

    if (MultiByteToWideChar( CP_ACP,
                             MB_PRECOMPOSED,
                             s,
                             n,
                             ps,
                             n
                           ) != (LONG)n
       ) {
        FatalError( "Unable to convert parameter '%s' to Unicode (%u)", (ULONG)s, GetLastError() );
        }

    ps[ n ] = UNICODE_NULL;
    return ps;
}


void
CommonSwitchProcessing(
    PULONG argc,
    PCHAR **argv,
    CHAR c
    )
{
    DWORD dwFileAttributes;
    PWSTR s;

    switch( c = (CHAR)tolower( c ) ) {
        case 'd':
            DebugOutput = TRUE;
            break;

        case '?':
            Usage( NULL, 0 );
            break;

        default:
            Usage( "Invalid switch (-%c)", (ULONG)c );
            break;
        }

    return;
}


BOOLEAN
CommonArgProcessing(
    PULONG argc,
    PCHAR **argv
    )
{
    PWSTR s;

    if (InstallationName == NULL) {
        if (GetCurrentDirectory( MAX_PATH, InstalerDirectory ) != 0) {
            s = wcschr( InstalerDirectory, UNICODE_NULL );
            if (s && s > InstalerDirectory && s[-1] != L'\\') {
                *s++ = L'\\';
                *s = UNICODE_NULL;
            }

            InstallationName = GetArgAsUnicode( **argv );
            ImlPath = FormatImlPath( InstalerDirectory, InstallationName );
            return TRUE;
        }
    }
    return FALSE;
}

PWSTR
FormatTempFileName(
    PWSTR Directory,
    PUSHORT TempFileUniqueId
    )
{
    if (*TempFileUniqueId == 0) {
        *TempFileUniqueId = (USHORT)(TempFileNextUniqueId++);
        if (TempFileNextUniqueId == 0) {
            return NULL;
            }
        }
    else
    if (*TempFileUniqueId == 0xFFFF) {
        return NULL;
        }

    if (Directory != NULL) {
        GetFullPathName( Directory, MAX_PATH, AltTempFilePathBuffer, &AltTempFilePathFileName );
        AltTempFilePathFileName = wcsrchr( AltTempFilePathBuffer, TEXT('\\') );
        AltTempFilePathFileName += 1;
        swprintf( AltTempFilePathFileName, L"~INS%04x.TMP", *TempFileUniqueId );
        return AltTempFilePathBuffer;
        }
    else {
        swprintf( TempFilePathFileName, L"~INS%04x.TMP", *TempFileUniqueId );
        return TempFilePathBuffer;
        }
}

PWSTR
CreateBackupFileName(
    PUSHORT TempFileUniqueId
    )
{
    PWSTR BackupFileName;

    while (BackupFileName = FormatTempFileName( NULL, TempFileUniqueId )) {
        if (GetFileAttributesW( BackupFileName ) == 0xFFFFFFFF) {
            break;
            }
        else {
            *TempFileUniqueId = 0;      // Temp file name existed, try next unique id
            }
        }

    return BackupFileName;
}


UCHAR EnumTypeBuffer0[ 512 ];
UCHAR EnumTypeBuffer1[ 512 ];
UCHAR EnumTypeBuffer2[ 512 ];
UCHAR EnumTypeBuffer3[ 512 ];
LPSTR EnumTypeBuffers[ 4 ] = {
    EnumTypeBuffer0,
    EnumTypeBuffer1,
    EnumTypeBuffer2,
    EnumTypeBuffer3
};

LPSTR
FormatEnumType(
    ULONG BufferIndex,
    PENUM_TYPE_NAMES Table,
    ULONG Value,
    BOOLEAN FlagFormat
    )
{
    LPSTR s, FlagsBuffer = EnumTypeBuffers[ BufferIndex ];

    FlagsBuffer[ 0 ] = '\0';
    while (Table->Value != 0xFFFFFFFF) {
        if (FlagFormat) {
            if (Table->Value & Value) {
                if (FlagsBuffer[ 0 ] != '\0') {
                    strcat( FlagsBuffer, " | " );
                    }

                strcat( FlagsBuffer, Table->Name );
                Value &= ~Table->Value;
                if (Value == 0) {
                    return FlagsBuffer;
                    }
                }
            }
        else
        if (Table->Value == Value) {
            if (Value == 0) {
                if (!strcmp( Table->Name, "STATUS_WAIT_0" )) {
                    return "STATUS_SUCCESS";
                    }
                else
                if (!strcmp( Table->Name, "ERROR_SUCCESS" )) {
                    return "NO_ERROR";
                    }
                }
            return Table->Name;
            }

        Table += 1;
        }

    s = FlagsBuffer;
    if (FlagFormat) {
        if (s[ 0 ] != '\0') {
            strcat( s, " | " );
            s += strlen( s );
            }
        }

    sprintf( s, Table->Name ? Table->Name : "%x", Value );
    return FlagsBuffer;
}



ENUM_TYPE_NAMES ValueDataTypeNames[] = {
    REG_NONE,                      "REG_NONE",
    REG_SZ,                        "REG_SZ",
    REG_EXPAND_SZ,                 "REG_EXPAND_SZ",
    REG_BINARY,                    "REG_BINARY",
    REG_DWORD,                     "REG_DWORD",
    REG_DWORD_BIG_ENDIAN,          "REG_DWORD_BIG_ENDIAN",
    REG_LINK,                      "REG_LINK",
    REG_MULTI_SZ,                  "REG_MULTI_SZ",
    REG_RESOURCE_LIST,             "REG_RESOURCE_LIST",
    REG_FULL_RESOURCE_DESCRIPTOR,  "REG_FULL_RESOURCE_DESCRIPTOR",
    REG_RESOURCE_REQUIREMENTS_LIST,"REG_RESOURCE_REQUIREMENTS_LIST",
    0xFFFFFFFF,                     "%x"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\init.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This is the initialization module for the INSTALER program.

Author:

    Steve Wood (stevewo) 09-Aug-1994

Revision History:

--*/

#include "instaler.h"

#if TRACE_ENABLED
ULONG EnabledTraceEvents = DBG_MASK_INTERNALERROR |
                           DBG_MASK_MEMORYERROR;
#endif

MODULE_INFO ModuleInfo[ MAXIMUM_MODULE_INDEX ] = {
    {L"NTDLL", NULL},
    {L"KERNEL32", NULL},
    {L"ADVAPI32", NULL},
    {L"USER32", NULL}
};



API_INFO ApiInfo[ MAXIMUM_API_INDEX ] = {
    {NTDLL_MODULE_INDEX,    "NtCreateFile",                 NULL, NtCreateFileHandler               , sizeof( CREATEFILE_PARAMETERS )                   , sizeof( NTSTATUS )},
    {NTDLL_MODULE_INDEX,    "NtOpenFile",                   NULL, NtOpenFileHandler                 , sizeof( OPENFILE_PARAMETERS )                     , sizeof( NTSTATUS )},
    {NTDLL_MODULE_INDEX,    "NtDeleteFile",                 NULL, NtDeleteFileHandler               , sizeof( DELETEFILE_PARAMETERS )                   , sizeof( NTSTATUS )},
    {NTDLL_MODULE_INDEX,    "NtSetInformationFile",         NULL, NtSetInformationFileHandler       , sizeof( SETINFORMATIONFILE_PARAMETERS )           , sizeof( NTSTATUS )},
    {NTDLL_MODULE_INDEX,    "NtQueryAttributesFile",        NULL, NtQueryAttributesFileHandler      , sizeof( QUERYATTRIBUTESFILE_PARAMETERS )          , sizeof( NTSTATUS )},
    {NTDLL_MODULE_INDEX,    "NtQueryDirectoryFile",         NULL, NtQueryDirectoryFileHandler       , sizeof( QUERYDIRECTORYFILE_PARAMETERS )           , sizeof( NTSTATUS )},
    {NTDLL_MODULE_INDEX,    "NtCreateKey",                  NULL, NtCreateKeyHandler                , sizeof( CREATEKEY_PARAMETERS )                    , sizeof( NTSTATUS )},
    {NTDLL_MODULE_INDEX,    "NtOpenKey",                    NULL, NtOpenKeyHandler                  , sizeof( OPENKEY_PARAMETERS )                      , sizeof( NTSTATUS )},
    {NTDLL_MODULE_INDEX,    "NtDeleteKey",                  NULL, NtDeleteKeyHandler                , sizeof( DELETEKEY_PARAMETERS )                    , sizeof( NTSTATUS )},
    {NTDLL_MODULE_INDEX,    "NtSetValueKey",                NULL, NtSetValueKeyHandler              , sizeof( SETVALUEKEY_PARAMETERS )                  , sizeof( NTSTATUS )},
    {NTDLL_MODULE_INDEX,    "NtDeleteValueKey",             NULL, NtDeleteValueKeyHandler           , sizeof( DELETEVALUEKEY_PARAMETERS )               , sizeof( NTSTATUS )},
    {NTDLL_MODULE_INDEX,    "NtClose",                      NULL, NtCloseHandleHandler              , sizeof( CLOSEHANDLE_PARAMETERS )                  , sizeof( NTSTATUS )},
    {KERNEL32_MODULE_INDEX, "GetVersion",                   NULL, GetVersionHandler                 , 0                                                 , sizeof( DWORD )},
    {KERNEL32_MODULE_INDEX, "GetVersionExW",                NULL, GetVersionExWHandler              , sizeof( GETVERSIONEXW_PARAMETERS )                , sizeof( BOOL )},
    {KERNEL32_MODULE_INDEX, "SetCurrentDirectoryA",         NULL, SetCurrentDirectoryAHandler       , sizeof( SETCURRENTDIRECTORYA_PARAMETERS )         , sizeof( BOOL )},
    {KERNEL32_MODULE_INDEX, "SetCurrentDirectoryW",         NULL, SetCurrentDirectoryWHandler       , sizeof( SETCURRENTDIRECTORYW_PARAMETERS )         , sizeof( BOOL )},
    {KERNEL32_MODULE_INDEX, "WritePrivateProfileStringA",   NULL, WritePrivateProfileStringAHandler , sizeof( WRITEPRIVATEPROFILESTRINGA_PARAMETERS )   , sizeof( DWORD )},
    {KERNEL32_MODULE_INDEX, "WritePrivateProfileStringW",   NULL, WritePrivateProfileStringWHandler , sizeof( WRITEPRIVATEPROFILESTRINGW_PARAMETERS )   , sizeof( DWORD )},
    {KERNEL32_MODULE_INDEX, "WritePrivateProfileSectionA",  NULL, WritePrivateProfileSectionAHandler, sizeof( WRITEPRIVATEPROFILESECTIONA_PARAMETERS )  , sizeof( DWORD )},
    {KERNEL32_MODULE_INDEX, "WritePrivateProfileSectionW",  NULL, WritePrivateProfileSectionWHandler, sizeof( WRITEPRIVATEPROFILESECTIONW_PARAMETERS )  , sizeof( DWORD )},
    {KERNEL32_MODULE_INDEX, "GetPrivateProfileStringW",     NULL, NULL, 0, sizeof( DWORD )},
    {KERNEL32_MODULE_INDEX, "GetPrivateProfileStringA",     NULL, NULL, 0, sizeof( DWORD )},
    {KERNEL32_MODULE_INDEX, "GetPrivateProfileSectionW",    NULL, NULL, 0, sizeof( DWORD )},
    {KERNEL32_MODULE_INDEX, "GetPrivateProfileSectionA",    NULL, NULL, 0, sizeof( DWORD )},
    {ADVAPI32_MODULE_INDEX, "RegConnectRegistryW",          NULL, RegConnectRegistryWHandler        , sizeof( REGCONNECTREGISTRYW_PARAMETERS )          , sizeof( DWORD )},
    {USER32_MODULE_INDEX,   "ExitWindowsEx",                NULL, ExitWindowsExHandler              , sizeof( EXITWINDOWSEX_PARAMETERS )                , sizeof( BOOL )}
};

BOOLEAN
LoadApplicationForDebug(
    PWSTR CommandLine
    );

BOOLEAN
LoadDriveLetterDefinitions( VOID );

WCHAR WindowsDirectoryBuffer[ MAX_PATH ];
UNICODE_STRING WindowsDirectory;

BOOLEAN
InitializeInstaler(
    int argc,
    char *argv[]
    )
{
    UINT ModuleIndex, ApiIndex;
    PWSTR CommandLine;
    UINT i;
    LPSTR s;
    UCHAR c;
    SYSTEM_INFO SystemInfo;
    BOOLEAN ProcessingDebugSwitch;

    InitCommonCode( "INSTALER",
                    "[-9] [-r] [-dAE] CommandLine...",
                    "-9 specifies that GetVersion should lie and tell application\n"
                    "   that it is running on Windows 95\n"
                    "-r specifies that attempts to do a wildcard scan of the root\n"
                    "   directory of a drive should fail.\n"
                    "-d specifies one or more debugging message options\n"
                    "   A - shows all errors\n"
                    "   E - shows all debug events\n"
                    "   C - shows all create API calls\n"
                  );

    AppHeap = GetProcessHeap();
    InstalerModuleHandle = GetModuleHandle( NULL );

    if (GetWindowsDirectoryW( WindowsDirectoryBuffer, MAX_PATH ) == 0) {
        return FALSE;
    }
    RtlInitUnicodeString( &WindowsDirectory, WindowsDirectoryBuffer );

    GetSystemInfo( &SystemInfo );

    TemporaryBufferLengthGrowth = SystemInfo.dwPageSize;
    TemporaryBufferMaximumLength = ((128 * 1024) + SystemInfo.dwAllocationGranularity - 1) &
                                   ~SystemInfo.dwAllocationGranularity;
    TemporaryBuffer = VirtualAlloc( NULL,
                                    TemporaryBufferMaximumLength,
                                    MEM_RESERVE,
                                    PAGE_READWRITE
                                  );
    if (TemporaryBuffer == NULL) {
        return FALSE;
    }

    InitializeListHead( &ProcessListHead );
    InitializeListHead( &FileReferenceListHead );
    InitializeListHead( &KeyReferenceListHead );
    InitializeListHead( &IniReferenceListHead );
    InitializeCriticalSection( &BreakTable );

    //
    // Loop over the table of modules and make sure each is loaded in our
    // address space so we can access their export tables.
    //
    for (ModuleIndex=0; ModuleIndex<MAXIMUM_MODULE_INDEX; ModuleIndex++) {
        ModuleInfo[ ModuleIndex ].ModuleHandle =
            GetModuleHandle( ModuleInfo[ ModuleIndex ].ModuleName );

        if (ModuleInfo[ ModuleIndex ].ModuleHandle == NULL) {
            //
            // Bail if any are missing.
            //
            DeclareError( INSTALER_MISSING_MODULE,
                          GetLastError(),
                          ModuleInfo[ ModuleIndex ].ModuleName
                        );
            return FALSE;
            }
        }

    //
    // Now loop over the table of entry points that we care about and
    // get the address of each entry point from the

    for (ApiIndex=0; ApiIndex<MAXIMUM_API_INDEX; ApiIndex++) {
        ModuleIndex = ApiInfo[ ApiIndex ].ModuleIndex;

        ApiInfo[ ApiIndex ].EntryPointAddress =
            LookupEntryPointInIAT( ModuleInfo[ ModuleIndex ].ModuleHandle,
                                   ApiInfo[ ApiIndex ].EntryPointName
                                 );

        if (ApiInfo[ ApiIndex ].EntryPointAddress == NULL) {
            //
            // Bail if we are unable to get the address of any of them
            //
            DeclareError( INSTALER_MISSING_ENTRYPOINT,
                          GetLastError(),
                          ApiInfo[ ApiIndex ].EntryPointName,
                          ModuleInfo[ ModuleIndex ].ModuleName
                        );
            return FALSE;
            }
        }

    CommandLine = NULL;
    ProcessingDebugSwitch = FALSE;
    AskUserOnce = FALSE;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                case '9':
                    DefaultGetVersionToWin95 = TRUE;
                    break;

                case 'r':
                    FailAllScansOfRootDirectories = TRUE;
                    break;
#if TRACE_ENABLED
                case 'd':
                    ProcessingDebugSwitch = TRUE;
                    break;

                case 'a':
                    if (ProcessingDebugSwitch) {
                        EnabledTraceEvents = 0xFFFFFFFF;
                        break;
                    }
                case 'e':
                    if (ProcessingDebugSwitch) {
                        EnabledTraceEvents |= DBG_MASK_DBGEVENT;
                        break;
                    }
                case 'c':
                    if (ProcessingDebugSwitch) {
                        EnabledTraceEvents |= DBG_MASK_CREATEEVENT;
                        break;
                    }
#endif
                default:
                    if (!ProcessingDebugSwitch) {
                        CommonSwitchProcessing( &argc, &argv, *s );

                    } else {
                        Usage( "Invalid debug switch (-%c)", (ULONG)*s );
                    }
                    break;
                }
            }

            ProcessingDebugSwitch = FALSE;

        } else if (!CommonArgProcessing( &argc, &argv )) {
            CommandLine = GetCommandLine();
            while (*CommandLine && *CommandLine <= L' ') {
                CommandLine += 1;
                }

            while (*CommandLine && *CommandLine > L' ') {
                CommandLine += 1;
                }

            CommandLine = wcsstr( CommandLine, GetArgAsUnicode( s ) );
            break;
        }
    }

    if (ImlPath == NULL) {
        Usage( "Must specify an installation name as first argument", 0 );
    }

    if (CommandLine == NULL) {
        Usage( "Command line missing", 0 );
    }

    pImlNew = CreateIml( ImlPath, FALSE );
    if (pImlNew == NULL) {
        FatalError( "Unable to create %ws (%u)\n",
                    (ULONG)ImlPath,
                    GetLastError()
                  );
    }

    //
    // Ready to roll.  Cache the drive letter information and then load
    // the application with the DEBUG option so we can watch what it does
    //
    if (!LoadDriveLetterDefinitions() ||
        !LoadApplicationForDebug( CommandLine )
       ) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
LoadApplicationForDebug(
    PWSTR CommandLine
    )
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    PWSTR ImageFilePath;
    PWSTR ImageFileName;
    PWSTR CurrentDirectory;
    PWSTR TemporaryNull;
    WCHAR TemporaryChar;
    ULONG Length;
    WCHAR PathBuffer[ MAX_PATH ];

    TemporaryNull = CommandLine;
    while(TemporaryChar = *TemporaryNull) {
        if (TemporaryChar == L' ' || TemporaryChar == L'\t') {
            *TemporaryNull = UNICODE_NULL;
            break;
        }

        TemporaryNull += 1;
    }

    ImageFilePath = AllocMem( MAX_PATH * sizeof( WCHAR ) );
    Length = SearchPath( NULL,
                         CommandLine,
                         L".exe",
                         MAX_PATH,
                         ImageFilePath,
                         &ImageFileName
                       );
    *TemporaryNull = TemporaryChar;
    if (!Length || Length >= MAX_PATH) {
        DeclareError( INSTALER_CANT_DEBUG_PROGRAM,
                      GetLastError(),
                      CommandLine
                    );
        return FALSE;
    }

    if (ImageFileName != NULL &&
        ImageFileName > ImageFilePath &&
        ImageFileName[ -1 ] == L'\\'
       ) {
        ImageFileName[ -1 ] = UNICODE_NULL;
        CurrentDirectory = wcscpy( PathBuffer, ImageFilePath );
        ImageFileName[ -1 ] = L'\\';
        SetCurrentDirectory( CurrentDirectory );

    } else {
        CurrentDirectory = NULL;
    }

    memset( &StartupInfo, 0, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof(StartupInfo);

    //
    // Create the process with DEBUG option, as a separate WOW so we only see our
    // application's damage.
    //
    if (!CreateProcess( ImageFilePath,
                        CommandLine,
                        NULL,
                        NULL,
                        FALSE,                          // No handles to inherit
                        DEBUG_PROCESS |
                          CREATE_SEPARATE_WOW_VDM,      // Ignored for 32 bit apps
                        NULL,
                        CurrentDirectory,
                        &StartupInfo,
                        &ProcessInformation
                      ) ) {

        DeclareError( INSTALER_CANT_DEBUG_PROGRAM,
                      GetLastError(),
                      CommandLine
                    );
        return FALSE;
    }

    sprintf( (LPSTR)PathBuffer, "%ws%ws.log", InstalerDirectory, InstallationName );
    InstalerLogFile = fopen( (LPSTR)PathBuffer, "w" );

    //
    // Will pick up the process and thread handles with the
    // CREATE_PROCESS_DEBUG_EVENT and CREATE_PROCESS_THREAD_EVENT
    //
    return TRUE;
}


PVOID
LookupEntryPointInIAT(
    HMODULE ModuleHandle,
    PCHAR EntryPointName
    )
{
    PIMAGE_EXPORT_DIRECTORY Exports;
    PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionTableEntries;
    DWORD NumberOfFunctionTableEntries;
    ULONG ExportSize, FunctionTableSize;
    PCHAR *EntryPointNames;
    PULONG EntryPointAddresses;
    PUSHORT EntryPointOrdinals;
    PVOID EntryPointAddress;
    ULONG i;

    Exports = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData( ModuleHandle,
                                                                     TRUE,
                                                                     IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                                     &ExportSize
                                                                   );
    if (Exports == NULL) {
        return NULL;
    }

    FunctionTableEntries = (PIMAGE_RUNTIME_FUNCTION_ENTRY)
        RtlImageDirectoryEntryToData( ModuleHandle,
                                      TRUE,
                                      IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                      &FunctionTableSize
                                    );
    if (FunctionTableEntries != NULL) {
        NumberOfFunctionTableEntries = FunctionTableSize / sizeof( IMAGE_RUNTIME_FUNCTION_ENTRY );

    } else {
        NumberOfFunctionTableEntries = 0;
    }

    EntryPointNames = (PCHAR *)((PCHAR)ModuleHandle + (ULONG)Exports->AddressOfNames);
    EntryPointOrdinals = (PUSHORT)((PCHAR)ModuleHandle + (ULONG)Exports->AddressOfNameOrdinals);
    EntryPointAddresses = (PULONG)((PCHAR)ModuleHandle + (ULONG)Exports->AddressOfFunctions);
    for (i=0; i<Exports->NumberOfNames; i++) {
        EntryPointAddress = (PVOID)((PCHAR)ModuleHandle +
                                    EntryPointAddresses[ EntryPointOrdinals[ i ] ]
                                   );
        if ((ULONG)EntryPointAddress > (ULONG)Exports &&
             (ULONG)EntryPointAddress < ((ULONG)Exports + ExportSize) ) {
            //
            // Skip this... It's a forwarded reference
            //

        } else if (!_stricmp( EntryPointName, (PCHAR)ModuleHandle + (ULONG)EntryPointNames[ i ] )) {
            return GetAddressForEntryPointBreakpoint( EntryPointAddress,
                                                      NumberOfFunctionTableEntries,
                                                      FunctionTableEntries
                                                    );
        }
    }

    DbgEvent( INTERNALERROR, ( "Unable to find entry point '%s' in module at %x\n", EntryPointName, ModuleHandle ) );
    return NULL;
}


PVOID
GetAddressForEntryPointBreakpoint(
    PVOID EntryPointAddress,
    DWORD NumberOfFunctionTableEntries OPTIONAL,
    PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionTableEntries OPTIONAL
    )
{
    PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionEntry;
    PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionTable;
    LONG High;
    LONG Low;
    LONG Middle;

    //
    // If no function table, then okay to set breakpoint at exported
    // address.
    //
    if (NumberOfFunctionTableEntries == 0) {
        return EntryPointAddress;
    }

    //
    // Initialize search indicies.
    //
    Low = 0;
    High = NumberOfFunctionTableEntries - 1;
    FunctionTable = FunctionTableEntries;

    //
    // Perform binary search on the function table for a function table
    // entry that subsumes the specified PC.
    //
    while (High >= Low) {
        //
        // Compute next probe index and test entry. If the specified PC
        // is greater than of equal to the beginning address and less
        // than the ending address of the function table entry, then
        // return the address of the function table entry. Otherwise,
        // continue the search.
        //
        Middle = (Low + High) >> 1;
        FunctionEntry = &FunctionTable[Middle];
        if        ((ULONG)EntryPointAddress < FunctionEntry->BeginAddress) {
            High = Middle - 1;

        } else if ((ULONG)EntryPointAddress >= FunctionEntry->EndAddress) {
            Low = Middle + 1;
        } else {
            break;
        }
    }

    //
    // A function table entry for the specified PC was not found.  Just use
    // the exported address and hope for the best.
    //
    return EntryPointAddress;
}


BOOLEAN
LoadDriveLetterDefinitions( VOID )
{
    PVOID Buffer;
    ULONG BufferSize;
    ULONG cchDeviceName;
    ULONG cch;
    ULONG cchTargetPath;
    PWSTR DeviceName;
    PWSTR TargetPath;
    ULONG DriveLetterIndex;
    ULONG cb;
    PDRIVE_LETTER_INFO p;

    RtlInitUnicodeString( &AltDriveLetterPrefix, L"\\DosDevices\\" );
    RtlInitUnicodeString( &DriveLetterPrefix, L"\\??\\" );
    RtlInitUnicodeString( &UNCPrefix, L"UNC\\" );

    BufferSize = 0x1000;
    Buffer = VirtualAlloc( NULL, BufferSize, MEM_COMMIT, PAGE_READWRITE );
    if (Buffer == NULL) {
        DbgEvent( INTERNALERROR, ( "VirtualAlloc( %0x8 ) failed (%u)\n", BufferSize, GetLastError() ) );
        return FALSE;
    }

    cchTargetPath = BufferSize / sizeof( WCHAR );
    cchDeviceName = QueryDosDeviceW( NULL,
                                     Buffer,
                                     cchTargetPath
                                   );
    if (cchDeviceName == 0) {
        DbgEvent( INTERNALERROR, ( "QueryDosDeviceW( NULL ) failed (%u)\n", GetLastError() ) );
        return FALSE;
    }

    cchTargetPath -= (cchDeviceName + 2);
    DeviceName = Buffer;
    TargetPath = DeviceName + 2 + cchDeviceName;
    while (*DeviceName) {
        if (wcslen( DeviceName ) == 2 &&
            DeviceName[ 1 ] == L':' &&
            _wcsupr( DeviceName ) &&
            DeviceName[ 0 ] >= L'@' &&
            DeviceName[ 0 ] <= L'_'
           ) {
            cch = QueryDosDeviceW( DeviceName, TargetPath, cchTargetPath );
            if (cch == 0) {
                DbgEvent( INTERNALERROR, ( "QueryDosDeviceW( %ws ) failed (%u)\n", DeviceName, GetLastError() ) );
                return FALSE;
            }

            DriveLetterIndex = DeviceName[ 0 ] - L'@';
            p = &DriveLetters[ DriveLetterIndex ];
            p->DriveLetter = (WCHAR)(L'@' + DriveLetterIndex);
            cb = (cch+1) * sizeof( WCHAR );
            p->NtLinkTarget.Buffer = AllocMem( cb );
            if (p->NtLinkTarget.Buffer == NULL) {
                return FALSE;
            }
            MoveMemory( p->NtLinkTarget.Buffer, TargetPath, cb );
            p->NtLinkTarget.Length = (USHORT)( cb - sizeof( WCHAR ));
            p->NtLinkTarget.MaximumLength = (USHORT)cb;
            p->DriveLetterValid = TRUE;
        }

        while (*DeviceName++) {}
    }

    return TRUE;
}


BOOLEAN
IsDriveLetterPath(
    PUNICODE_STRING Path
    )
{
    ULONG DriveLetterIndex;
    PDRIVE_LETTER_INFO p;
    PUNICODE_STRING Prefix;

    if (RtlPrefixUnicodeString( Prefix = &DriveLetterPrefix, Path, TRUE ) ||
        RtlPrefixUnicodeString( Prefix = &AltDriveLetterPrefix, Path, TRUE ) ) {

        Path->Length -= Prefix->Length;
        RtlMoveMemory( Path->Buffer,
                       (PCHAR)(Path->Buffer) + Prefix->Length,
                       Path->Length + sizeof( UNICODE_NULL )
                     );
        if (RtlPrefixUnicodeString( &UNCPrefix, Path, TRUE )) {
            Path->Length -= UNCPrefix.Length;
            Path->Buffer[0] = L'\\';
            Path->Buffer[1] = L'\\';
            RtlMoveMemory( &Path->Buffer[2],
                           (PCHAR)(Path->Buffer) + UNCPrefix.Length,
                           Path->Length + sizeof( UNICODE_NULL )
                         );
            Path->Length += 2 * sizeof( WCHAR );
        }

        return TRUE;
    }

    for (DriveLetterIndex=0, p = &DriveLetters[ DriveLetterIndex ];
         DriveLetterIndex<32;
         DriveLetterIndex++, p++
        )
    {

        if (p->DriveLetterValid &&
            RtlPrefixUnicodeString( &p->NtLinkTarget, Path, TRUE )
           )
        {
            Path->Length -= p->NtLinkTarget.Length;
            RtlMoveMemory( &Path->Buffer[ 2 ],
                           (PCHAR)(Path->Buffer) + p->NtLinkTarget.Length,
                           Path->Length + sizeof( UNICODE_NULL )
                         );
            Path->Buffer[ 0 ] = p->DriveLetter;
            Path->Buffer[ 1 ] = L':';
            Path->Length += 2;
            return TRUE;
        }
    }

    return FALSE;
}



VOID
TrimTemporaryBuffer( VOID )
{
    PVOID CommitAddress;

    if (TemporaryBufferLength == 0) {
        return;
    }

    if (VirtualFree( (PCHAR)TemporaryBuffer,
                     TemporaryBufferLength,
                     MEM_DECOMMIT
                   )
       )
    {
        TemporaryBufferLength = 0;
    }

    return;
}

BOOLEAN
GrowTemporaryBuffer(
    ULONG NeededSize
    )
{
    PVOID CommitAddress;

    if (NeededSize <= TemporaryBufferLength) {
        return TRUE;
    }

    if (TemporaryBufferLength == TemporaryBufferMaximumLength) {
        return FALSE;
    }

    CommitAddress = VirtualAlloc( (PCHAR)TemporaryBuffer + TemporaryBufferLength,
                                  NeededSize - TemporaryBufferLength,
                                  MEM_COMMIT,
                                  PAGE_READWRITE
                                );
    if (CommitAddress == NULL) {
        DbgEvent( INTERNALERROR, ( "VirtualAlloc( %0x8 ) failed (%u)\n",
                                   NeededSize - TemporaryBufferLength,
                                   GetLastError()
                                 )
                );

        return FALSE;
    }

    TemporaryBufferLength += TemporaryBufferLengthGrowth;
    return TRUE;
}

ULONG
FillTemporaryBuffer(
    PPROCESS_INFO Process,
    PVOID Address,
    BOOLEAN Unicode,
    BOOLEAN DoubleNullTermination
    )
{
    ULONG BytesRead;
    ULONG TotalBytesRead;
    PVOID Source;
    PVOID Destination;
    LPSTR s1;
    PWSTR s2;
    BOOLEAN MoreToRead;
    BOOLEAN SeenOneNull;

    TotalBytesRead = 0;
    Destination = (PCHAR)TemporaryBuffer;
    MoreToRead = TRUE;
    SeenOneNull = FALSE;
    while (MoreToRead) {
        TotalBytesRead += TemporaryBufferLengthGrowth;
        if (!GrowTemporaryBuffer( TotalBytesRead )) {
            return 0;
        }

        Source = Destination;
        BytesRead = 0;
        if (!ReadProcessMemory( Process->Handle,
                                Address,
                                Destination,
                                TemporaryBufferLengthGrowth,
                                &BytesRead
                              )
           )
        {
            if (BytesRead == 0) {
                MoreToRead = FALSE;
            } else {
                return 0;
            }
        }

        Destination = (PCHAR)Destination + TotalBytesRead;
        if (Unicode) {
            s2 = (PWSTR)Source;
            while (s2 < (PWSTR)Destination) {
                if (*s2 == UNICODE_NULL) {
                    if (SeenOneNull || !DoubleNullTermination) {
                        return (PCHAR)s2 - (PCHAR)TemporaryBuffer;
                    } else {
                        SeenOneNull = TRUE;
                    }
                } else {
                    SeenOneNull = FALSE;
                }

                s2++;
            }

        }  else {
            s1 = (LPSTR)Source;
            while (s1 < (LPSTR)Destination) {
                if (*s1 == '\0') {
                    if (SeenOneNull || !DoubleNullTermination) {
                        return (PCHAR)s1 - (PCHAR)TemporaryBuffer;
                    } else {
                        SeenOneNull = TRUE;
                    }

                } else {
                    SeenOneNull = FALSE;
                }

                s1++;
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\instutil.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    instutil.h

Abstract:

    Header file for common definition for programs that manipulate the output of
    the INSTALER.EXE program (e.g. DISPINST.EXE, COMPINST.EXE, UNDOINST.EXE)

Author:

    Steve Wood (stevewo) 14-Jan-1996

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

WCHAR InstalerDirectory[ MAX_PATH ];
PWSTR InstallationName;
PWSTR ImlPath;
BOOLEAN DebugOutput;

//
// Useful rounding macros that the rounding amount is always a
// power of two.
//

#define ROUND_DOWN( Size, Amount ) ((DWORD)(Size) & ~((Amount) - 1))
#define ROUND_UP( Size, Amount ) (((DWORD)(Size) + ((Amount) - 1)) & ~((Amount) - 1))

void
InitCommonCode(
    LPSTR ModuleName,
    LPSTR ModuleUsage1,
    LPSTR ModuleUsage2
    );

void
Usage(
    LPSTR Message,
    ULONG MessageParameter
    );

void
FatalError(
    LPSTR Message,
    ULONG MessageParameter1,
    ULONG MessageParameter2
    );

void
InputMessage(
    PWSTR FileName,
    ULONG LineNumber,
    BOOLEAN Error,
    LPSTR Message,
    ULONG MessageParameter1,
    ULONG MessageParameter2
    );

PWSTR
GetArgAsUnicode(
    LPSTR s
    );

void
CommonSwitchProcessing(
    PULONG argc,
    PCHAR **argv,
    CHAR c
    );

BOOLEAN
CommonArgProcessing(
    PULONG argc,
    PCHAR **argv
    );

PWSTR
FormatTempFileName(
    PWSTR Directory,
    PUSHORT TempFileUniqueId
    );


PWSTR
CreateBackupFileName(
    PUSHORT TempFileUniqueId
    );


typedef struct _ENUM_TYPE_NAMES {
    ULONG Value;
    LPSTR Name;
} ENUM_TYPE_NAMES, *PENUM_TYPE_NAMES;

LPSTR
FormatEnumType(
    ULONG BufferIndex,
    PENUM_TYPE_NAMES Table,
    ULONG Value,
    BOOLEAN FlagFormat
    );

ENUM_TYPE_NAMES ValueDataTypeNames[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\instaler.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    instaler.c

Abstract:

    USAGE: instaler "setup/install command line"

    Main source file for the INSTALER application.  This application is
    intended for use as a wrapper application around another
    application's setup/install program.  This program uses the Debugger
    API calls to set breakpoints in the setup/install program and its
    descendents at all calls to NT/Win32 API calls that modify the
    current system.  The API calls that are tracked include:

        NtCreateFile
        NtDeleteFile
        NtSetInformationFile (FileRenameInformation, FileDispositionInformation)
        NtCreateKey
        NtOpenKey
        NtDeleteKey
        NtSetValueKey
        NtDeleteValueKey
        GetVersion
        GetVersionExW
        WriteProfileStringA/W
        WritePrivateProfileStringA/W
        WriteProfileSectionA/W
        WritePrivateProfileSectionA/W
        RegConnectRegistryW

    This program sets breakpoints around each of the above API entry
    points.  At the breakpoint at the entry to an API call, the
    parameters are inspected and if the call is going to overwrite some
    state (e.g.  create/open a file/key for write access, store a new
    key value or profile string), then this program will save the old
    state in a temporary directory before letting the API call proceed.
    At the exit from the API call, it will determine if the operation
    was successful.  If not, the saved state will be discarded.  If
    successful, it will keep the saved state for when the application
    setup/install program completes.  Part of the Create/Open API
    tracking is the maintenance of a handle database so that relative opens
    can be handled correctly with the full path.

Author:

    Steve Wood (stevewo) 09-Aug-1994

--*/

#include "instaler.h"

BOOLEAN
SortReferenceList(
    PLIST_ENTRY OldHead,
    ULONG NumberOfEntriesInList
    );

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    if (!InitializeInstaler( argc, argv )) {
        ExitProcess( 1 );
        }
    else {
        StartProcessTickCount = GetTickCount();
        DebugEventLoop();
        printf( "Creating %ws\n", ImlPath );
        SortReferenceList( &FileReferenceListHead, NumberOfFileReferences );
        SortReferenceList( &KeyReferenceListHead, NumberOfKeyReferences );
        SortReferenceList( &IniReferenceListHead, NumberOfIniReferences );
        DumpFileReferenceList( InstalerLogFile );
        DumpKeyReferenceList( InstalerLogFile );
        DumpIniFileReferenceList( InstalerLogFile );
        DumpNameDataBase( InstalerLogFile );
        CloseIml( pImlNew );
        fclose( InstalerLogFile );
        ExitProcess( 0 );
        }

    return 0;
}


typedef struct _GENERIC_REFERENCE {
    LIST_ENTRY Entry;
    PWSTR Name;
} GENERIC_REFERENCE, *PGENERIC_REFERENCE;


int
__cdecl
CompareReferences(
    const void *Reference1,
    const void *Reference2
    )
{
    PGENERIC_REFERENCE p1 = *(PGENERIC_REFERENCE *)Reference1;
    PGENERIC_REFERENCE p2 = *(PGENERIC_REFERENCE *)Reference2;

    return _wcsicmp( p1->Name, p2->Name );
}


BOOLEAN
SortReferenceList(
    PLIST_ENTRY Head,
    ULONG NumberOfEntriesInList
    )
{
    PGENERIC_REFERENCE p, *SortedArray;
    PLIST_ENTRY Next;
    ULONG i;

    if (NumberOfEntriesInList == 0) {
        return TRUE;
        }

    SortedArray = AllocMem( NumberOfEntriesInList * sizeof( *SortedArray ) );
    if (SortedArray == NULL) {
        return FALSE;
        }

    Next = Head->Flink;
    i = 0;
    while (Head != Next) {
        p = CONTAINING_RECORD( Next, GENERIC_REFERENCE, Entry );
        if (i >= NumberOfEntriesInList) {
            break;
            }

        SortedArray[ i++ ] = p;
        Next = Next->Flink;
        }

    qsort( (void *)SortedArray,
           NumberOfEntriesInList,
           sizeof( *SortedArray ),
           CompareReferences
         );

    InitializeListHead( Head );
    for (i=0; i<NumberOfEntriesInList; i++) {
        p = SortedArray[ i ];
        InsertTailList( Head, &p->Entry );
        }

    FreeMem( (PVOID *)&SortedArray );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\makefile.inc ===
instaler.rc: $(O)\errormsg.rc

showinst.rc: $(O)\errormsg.rc

undoinst.rc: $(O)\errormsg.rc

compinst.rc: $(O)\errormsg.rc

$(O)\instaler.res: instaler.rc

$(O)\testins1.res: testins1.rc

$(O)\testins2.res: testins2.rc

$(O)\showinst.res: showinst.rc

$(O)\undoinst.res: undoinst.rc

$(O)\compinst.res: compinst.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\namedb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    namedb.c

Abstract:

    This module maintains a database of path names detected by the INSTALER program

Author:

    Steve Wood (stevewo) 20-Aug-1994

Revision History:

--*/


#include "instaler.h"

typedef struct _NAME_TABLE_ENTRY {
    struct _NAME_TABLE_ENTRY *HashLink;
    UNICODE_STRING Name;
    ULONG OpenCount;
    ULONG FailedOpenCount;
} NAME_TABLE_ENTRY, *PNAME_TABLE_ENTRY;

#define NUMBER_OF_HASH_BUCKETS 37
PNAME_TABLE_ENTRY NameTableBuckets[ NUMBER_OF_HASH_BUCKETS ];

BOOLEAN
IncrementOpenCount(
    PWSTR Name,
    BOOLEAN CallSuccessful
    )
{
    PNAME_TABLE_ENTRY p;

    p = (PNAME_TABLE_ENTRY)Name - 1;
    if (p->Name.Buffer == Name) {
        if (CallSuccessful) {
            p->OpenCount += 1;
            }
        else {
            p->FailedOpenCount += 1;
            }
        return TRUE;
        }
    else {
        return FALSE;
        }
}

ULONG
QueryOpenCount(
    PWSTR Name,
    BOOLEAN CallSuccessful
    )
{
    PNAME_TABLE_ENTRY p;

    p = (PNAME_TABLE_ENTRY)Name - 1;
    if (p->Name.Buffer == Name) {
        if (CallSuccessful) {
            return p->OpenCount;
            }
        else {
            return p->FailedOpenCount;
            }

        }
    else {
        return 0;
        }
}

PWSTR
AddName(
    PUNICODE_STRING Name
    )
{
    ULONG n, Hash;
    WCHAR c;
    PWCH s;
    PNAME_TABLE_ENTRY *pp, p;

    n = Name->Length / sizeof( c );
    s = Name->Buffer;
    Hash = 0;
    while (n--) {
        c = RtlUpcaseUnicodeChar( *s++ );
        Hash = Hash + (c << 1) + (c >> 1) + c;
        }

    pp = &NameTableBuckets[ Hash % NUMBER_OF_HASH_BUCKETS ];
    while (p = *pp) {
        if (RtlEqualUnicodeString( &p->Name, Name, TRUE )) {
            return p->Name.Buffer;
            }
        else {
            pp = &p->HashLink;
            }
        }

    p = AllocMem( sizeof( *p ) + Name->Length + sizeof( UNICODE_NULL ) );
    if (p == NULL) {
        printf ("Memory allocation failure\n");
        ExitProcess (0);
    }
    *pp = p;
    p->HashLink = NULL;
    p->Name.Buffer = (PWSTR)(p + 1);
    p->Name.Length = Name->Length;
    p->Name.MaximumLength = (USHORT)(Name->Length + sizeof( UNICODE_NULL ));
    RtlMoveMemory( p->Name.Buffer, Name->Buffer, Name->Length );
    p->Name.Buffer[ Name->Length / sizeof( WCHAR ) ] = UNICODE_NULL;
    return p->Name.Buffer;
}


VOID
DumpNameDataBase(
    FILE *LogFile
    )
{
    ULONG i;
    PNAME_TABLE_ENTRY p;

#if 0
    fprintf( LogFile, "Name Data Base entries:\n" );
    for (i=0; i<NUMBER_OF_HASH_BUCKETS; i++) {
        p = NameTableBuckets[ i ];
        if (p != NULL) {
            fprintf( LogFile, "Bucket[ %02u ]:\n", i );
            while (p) {
                fprintf( LogFile, "    %ws\n", p->Name.Buffer );
                p = p->HashLink;
                }
            }
        }
    fprintf( LogFile, "\n" );
#endif

    fprintf( LogFile, "List of paths with non-zero successful open counts\n" );
    for (i=0; i<NUMBER_OF_HASH_BUCKETS; i++) {
        p = NameTableBuckets[ i ];
        if (p != NULL) {
            while (p) {
                if (p->OpenCount != 0) {
                    fprintf( LogFile, "  %4u %ws\n", p->OpenCount, p->Name.Buffer );
                    }

                p = p->HashLink;
                }
            }
        }
    fprintf( LogFile, "\n" );
    fprintf( LogFile, "List of paths with non-zero failed open counts\n" );
    for (i=0; i<NUMBER_OF_HASH_BUCKETS; i++) {
        p = NameTableBuckets[ i ];
        if (p != NULL) {
            while (p) {
                if (p->FailedOpenCount != 0) {
                    fprintf( LogFile, "  %4u %ws\n", p->FailedOpenCount, p->Name.Buffer );
                    }

                p = p->HashLink;
                }
            }
        }
    fprintf( LogFile, "\n" );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\key.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    key.c

Abstract:

    This module implements the functions to save references to registry
    keys and values for the INSTALER program.  Part of each reference is
    a a backup copy of a key information and its values that have been
    changed/deleted.

Author:

    Steve Wood (stevewo) 22-Aug-1994

Revision History:

--*/

#include "instaler.h"

#define DEFAULT_KEY_VALUE_BUFFER_SIZE 512
PKEY_VALUE_FULL_INFORMATION KeyValueInformation;

VOID
BackupKeyInfo(
    PKEY_REFERENCE p
    )
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    KEY_FULL_INFORMATION KeyInformation;
    ULONG ResultLength;
    ULONG ValueIndex;
    UNICODE_STRING ValueName;
    PVALUE_REFERENCE ValueReference;

    RtlInitUnicodeString( &KeyName, p->Name );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &KeyHandle,
                        KEY_READ,
                        &ObjectAttributes
                      );
    if (!NT_SUCCESS( Status )) {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            p->Created = TRUE;
            p->WriteAccess = TRUE;
            }

        fprintf( InstalerLogFile, "*** Unable to open key %ws (%x)\n", p->Name, Status );
        return;
        }

    if (!p->WriteAccess) {
        NtClose( KeyHandle );
        return;
        }

    fprintf( InstalerLogFile, "Saving values for %ws\n", p->Name );
    if (KeyValueInformation == NULL) {
        KeyValueInformation = AllocMem( DEFAULT_KEY_VALUE_BUFFER_SIZE );
        if (KeyValueInformation == NULL) {
            fprintf( InstalerLogFile, "*** No memory for key value information\n" );
            return;
            }
        }

    Status = NtQueryKey( KeyHandle,
                         KeyFullInformation,
                         &KeyInformation,
                         sizeof( KeyInformation ),
                         &ResultLength
                       );
    if (!NT_SUCCESS( Status ) && Status != STATUS_BUFFER_OVERFLOW) {
        NtClose( KeyHandle );
        fprintf( InstalerLogFile, "*** Unable to query key (%x)\n", Status );
        return;
        }

    p->BackupKeyInfo = AllocMem( ResultLength );
    if (p->BackupKeyInfo == NULL) {
        NtClose( KeyHandle );
        fprintf( InstalerLogFile, "*** No memory for backup information\n" );
        return;
        }

    if (!NT_SUCCESS( Status )) {
        Status = NtQueryKey( KeyHandle,
                             KeyFullInformation,
                             p->BackupKeyInfo,
                             ResultLength,
                             &ResultLength
                           );
        if (!NT_SUCCESS( Status )) {
            NtClose( KeyHandle );
            fprintf( InstalerLogFile, "*** Unable to query key (%x)\n", Status );
            return;
            }
        }
    else {
        memmove( p->BackupKeyInfo, &KeyInformation, ResultLength );
        }


    for (ValueIndex = 0; TRUE; ValueIndex++) {
        Status = NtEnumerateValueKey( KeyHandle,
                                      ValueIndex,
                                      KeyValueFullInformation,
                                      KeyValueInformation,
                                      DEFAULT_KEY_VALUE_BUFFER_SIZE,
                                      &ResultLength
                                    );
        if (!NT_SUCCESS( Status ) && Status != STATUS_BUFFER_OVERFLOW) {
            break;
            }

        ValueReference = AllocMem( FIELD_OFFSET( VALUE_REFERENCE, OriginalValue ) +
                                   FIELD_OFFSET( KEY_VALUE_PARTIAL_INFORMATION, Data ) +
                                   KeyValueInformation->DataLength
                                 );
        if (ValueReference == NULL) {
            fprintf( InstalerLogFile, "*** No memory for value ref\n", Status );
            break;
            }

        if (KeyValueInformation->NameLength != 0) {
            ValueName.Length = (USHORT)KeyValueInformation->NameLength;
            ValueName.MaximumLength = ValueName.Length;
            ValueName.Buffer = KeyValueInformation->Name;
            ValueReference->Name = AddName( &ValueName );
            fprintf( InstalerLogFile, "    Saving data for '%ws'\n", ValueReference->Name );
            }
        else {
            fprintf( InstalerLogFile, "    Saving data for empty value name\n" );
            }

        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = NtEnumerateValueKey( KeyHandle,
                                          ValueIndex,
                                          KeyValuePartialInformation,
                                          &ValueReference->OriginalValue,
                                          FIELD_OFFSET( KEY_VALUE_PARTIAL_INFORMATION, Data ) +
                                            KeyValueInformation->DataLength,
                                          &ResultLength
                                        );
            if (!NT_SUCCESS( Status )) {
                FreeMem( &ValueReference );
                break;
                }
            }
        else {
            ValueReference->OriginalValue.TitleIndex = KeyValueInformation->TitleIndex;
            ValueReference->OriginalValue.Type       = KeyValueInformation->Type;
            ValueReference->OriginalValue.DataLength = KeyValueInformation->DataLength;
            memmove( &ValueReference->OriginalValue.Data,
                     (PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset,
                     KeyValueInformation->DataLength
                   );
            }

        InsertTailList( &p->ValueReferencesListHead, &ValueReference->Entry );
        }

    NtClose( KeyHandle );
    return;
}



BOOLEAN
CreateKeyReference(
    PWSTR Name,
    BOOLEAN WriteAccess,
    PKEY_REFERENCE *ReturnedReference
    )
{
    PKEY_REFERENCE p;

    *ReturnedReference = NULL;
    p = FindKeyReference( Name );
    if (p != NULL) {
        if (p->WriteAccess) {
            *ReturnedReference = p;
            return TRUE;
            }
        }
    else {
        p = AllocMem( sizeof( *p ) );
        if (p == NULL) {
            return FALSE;
            }

        p->Name = Name;
        InsertTailList( &KeyReferenceListHead, &p->Entry );
        NumberOfKeyReferences += 1;
        }

    InitializeListHead( &p->ValueReferencesListHead );
    p->WriteAccess = WriteAccess;
    BackupKeyInfo( p );

    *ReturnedReference = p;
    return TRUE;
}


BOOLEAN
CompleteKeyReference(
    PKEY_REFERENCE p,
    BOOLEAN CallSuccessful,
    BOOLEAN Deleted
    )
{
    if (!CallSuccessful) {
        DestroyKeyReference( p );
        return FALSE;
        }

    if (Deleted && p->Created) {
        LogEvent( INSTALER_EVENT_DELETE_TEMP_KEY,
                  1,
                  p->Name
                );
        DestroyKeyReference( p );
        return FALSE;
        }

    if (Deleted) {
        LogEvent( INSTALER_EVENT_DELETE_KEY,
                  1,
                  p->Name
                );
        }
    else
    if (p->WriteAccess) {
        LogEvent( INSTALER_EVENT_WRITE_KEY,
                  1,
                  p->Name
                );
        }
    else {
        LogEvent( INSTALER_EVENT_READ_KEY,
                  1,
                  p->Name
                );
        }

    p->Deleted = Deleted;
    return TRUE;
}


BOOLEAN
DestroyKeyReference(
    PKEY_REFERENCE p
    )
{
    RemoveEntryList( &p->Entry );
    NumberOfKeyReferences -= 1;
    FreeMem( &p );
    return TRUE;
}

PKEY_REFERENCE
FindKeyReference(
    PWSTR Name
    )
{
    PKEY_REFERENCE p;
    PLIST_ENTRY Head, Next;

    Head = &KeyReferenceListHead;
    Next = Head->Flink;
    while (Head != Next) {
        p = CONTAINING_RECORD( Next, KEY_REFERENCE, Entry );
        if (p->Name == Name) {
            return p;
            }

        Next = Next->Flink;
        }

    return NULL;
}

VOID
MarkKeyDeleted(
    PKEY_REFERENCE KeyReference
    )
{
    PVALUE_REFERENCE p;
    PLIST_ENTRY Head, Next;

    KeyReference->Deleted = TRUE;
    Head = &KeyReference->ValueReferencesListHead;
    Next = Head->Flink;
    while (Head != Next) {
        p = CONTAINING_RECORD( Next, VALUE_REFERENCE, Entry );
        Next = Next->Flink;
        if (p->Created || KeyReference->Created) {
            DestroyValueReference( p );
            }
        else {
            p->Deleted = TRUE;
            }
        }

    if (KeyReference->Created) {
        DestroyKeyReference( KeyReference );
        }

    return;
}

BOOLEAN
CreateValueReference(
    PPROCESS_INFO Process,
    PKEY_REFERENCE KeyReference,
    PWSTR Name,
    ULONG TitleIndex,
    ULONG Type,
    PVOID Data,
    ULONG DataLength,
    PVALUE_REFERENCE *ReturnedValueReference
    )
{
    PVALUE_REFERENCE p;
    PKEY_VALUE_PARTIAL_INFORMATION OldValue, NewValue;

    *ReturnedValueReference = NULL;

    NewValue = AllocMem( FIELD_OFFSET( KEY_VALUE_PARTIAL_INFORMATION, Data ) +
                         DataLength
                       );
    if (NewValue == NULL) {
        return FALSE;
        }

    NewValue->TitleIndex = TitleIndex;
    NewValue->Type = Type;
    NewValue->DataLength = DataLength;
    if (!ReadMemory( Process,
                     Data,
                     &NewValue->Data[0],
                     DataLength,
                     "new value data"
                   )
       ) {
        FreeMem( &NewValue );
        return FALSE;
        }

    p = FindValueReference( KeyReference, Name );
    if (p != NULL) {
        FreeMem( &p->Value );
        p->Value = NewValue;
        OldValue = &p->OriginalValue;
        if (OldValue->TitleIndex == NewValue->TitleIndex &&
            OldValue->Type == NewValue->Type &&
            OldValue->DataLength == NewValue->DataLength &&
            RtlCompareMemory( &OldValue->Data, &NewValue->Data, OldValue->DataLength )
           ) {
            FreeMem( &p->Value );
            }
        else {
            p->Modified = TRUE;
            }

        return TRUE;
        }

    p = AllocMem( FIELD_OFFSET( VALUE_REFERENCE, OriginalValue ) );
    if (p == NULL) {
        FreeMem( &NewValue );
        return FALSE;
        }

    p->Name = Name;
    p->Created = TRUE;
    p->Value = NewValue;
    InsertTailList( &KeyReference->ValueReferencesListHead, &p->Entry );

    *ReturnedValueReference = p;
    return TRUE;
}


PVALUE_REFERENCE
FindValueReference(
    PKEY_REFERENCE KeyReference,
    PWSTR Name
    )
{
    PVALUE_REFERENCE p;
    PLIST_ENTRY Head, Next;

    Head = &KeyReference->ValueReferencesListHead;
    Next = Head->Flink;
    while (Head != Next) {
        p = CONTAINING_RECORD( Next, VALUE_REFERENCE, Entry );
        if (p->Name == Name) {
            return p;
            }

        Next = Next->Flink;
        }

    return NULL;
}


BOOLEAN
DestroyValueReference(
    PVALUE_REFERENCE p
    )
{
    RemoveEntryList( &p->Entry );
    FreeMem( &p );
    return TRUE;
}


VOID
DumpKeyReferenceList(
    FILE *LogFile
    )
{
    PKEY_REFERENCE p;
    PLIST_ENTRY Head, Next;
    PVALUE_REFERENCE p1;
    PLIST_ENTRY Head1, Next1;
    PKEY_VALUE_PARTIAL_INFORMATION OldValue, NewValue;
    KEY_VALUE_PARTIAL_INFORMATION NullValue;
    POFFSET Values;

    memset( &NullValue, 0, sizeof( NullValue ) );
    NullValue.Type = REG_SZ;

    Head = &KeyReferenceListHead;
    Next = Head->Flink;
    while (Head != Next) {
        p = CONTAINING_RECORD( Next, KEY_REFERENCE, Entry );
        if (p->Created || p->WriteAccess) {
            Values = 0;
            Head1 = &p->ValueReferencesListHead;
            Next1 = Head1->Flink;
            while (Head1 != Next1) {
                p1 = CONTAINING_RECORD( Next1, VALUE_REFERENCE, Entry );
                NewValue = p1->Value;
                if (NewValue == NULL) {
                    NewValue = &NullValue;
                    }

                OldValue = &p1->OriginalValue;
                if (!p1->Deleted) {
                    if (p1->Created) {
                        ImlAddValueRecord( pImlNew,
                                           CreateNewValue,
                                           p1->Name,
                                           NewValue->Type,
                                           NewValue->DataLength,
                                           NewValue->Data,
                                           0,
                                           0,
                                           NULL,
                                           &Values
                                         );
                        }
                    else
                    if (p1->Modified) {
                        ImlAddValueRecord( pImlNew,
                                           ModifyOldValue,
                                           p1->Name,
                                           NewValue->Type,
                                           NewValue->DataLength,
                                           NewValue->Data,
                                           OldValue->Type,
                                           OldValue->DataLength,
                                           OldValue->Data,
                                           &Values
                                         );
                        }
                    }
                else {
                    ImlAddValueRecord( pImlNew,
                                       DeleteOldValue,
                                       p1->Name,
                                       0,
                                       0,
                                       NULL,
                                       OldValue->Type,
                                       OldValue->DataLength,
                                       OldValue->Data,
                                       &Values
                                     );
                    }

                Next1 = Next1->Flink;
                }

            ImlAddKeyRecord( pImlNew,
                             p->Created ? CreateNewKey :
                             p->Deleted ? DeleteOldKey : ModifyKeyValues,
                             p->Name,
                             Values
                           );
            }

        Next = Next->Flink;
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\res.h ===
#define FILEBMP  500
#define DIRBMP   501
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\test.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    test.c

Abstract:

    This is a test program that issues various Kernel 32 file/registry/INI file
    API calls so that we can see if the INSTALER program figures out correctly
    what is being done.

    This program assumes that the following conditions exist:

        TEST subdirectory


Author:

    Steve Wood (stevewo) 13-Aug-1994

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>

UCHAR AnsiBuffer[ MAX_PATH ];
WCHAR UnicodeBuffer[ MAX_PATH ];


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    FILE *File0;
    FILE *File1;
    FILE *File2;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN TranslationStatus;
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    UNICODE_STRING KeyName;
    UNICODE_STRING SubKeyName;
    UNICODE_STRING ValueName;
    HANDLE FileHandle, FindHandle, KeyHandle, SubKeyHandle;
    ULONG ValueDWord = 0x12345678;
    WIN32_FIND_DATAW FindFileData;
    LPSTR s1;
    PWSTR s2;
    UCHAR AnsiBuffer[ MAX_PATH ];
    WCHAR UnicodeBuffer[ MAX_PATH ];
    DWORD dwVersion;
    OSVERSIONINFO VersionInfo;
    HKEY hKey;

    //
    // File operations we want to test:
    //
    //  Creating a new file.
    //  Deleting that file using DeleteFile (which does NtOpenFile and NtSetInformationFile
    //  with Delete Dispostion).  (INSTALER should use this to forget about create).
    //  Creating a new file with the same name.
    //  Deleting that file using NtDeleteFile.  (again INSTALER should not care).
    //
    //  Open the TEST1 file for read access (INSTALER should not care).
    //  Open the TEST2 file for write access (INSTALER should not care).
    //  Open the TEST2 file for write access (INSTALER should not care).
    //  Open the TEST2 file for write access (INSTALER should not care).
    //
    //

    // printf( "TEST: GetFileAttributes( .\\test1 )\n" );
    GetFileAttributesA( ".\\test1" );
#if 0
    dwVersion = GetVersion();
    if ((dwVersion >> 30) ^ 0x2 == VER_PLATFORM_WIN32_WINDOWS) {
        printf( "GetVersion returns Windows 95\n" );
        }
    else
    if ((dwVersion >> 30) ^ 0x2 == VER_PLATFORM_WIN32_NT) {
        printf( "GetVersion returns Windows NT\n" );
        }
    else {
        printf( "GetVersion returns %x\n", dwVersion );
        }
    fflush(stdout);

    VersionInfo.dwOSVersionInfoSize = sizeof( VersionInfo );
    GetVersionEx( &VersionInfo );
    if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
        printf( "GetVersionEx returns Windows 95\n" );
        }
    else
    if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        printf( "GetVersionEx returns Windows NT\n" );
        }
    else {
        printf( "GetVersionEx returns %x\n", VersionInfo.dwPlatformId );
        }
    fflush(stdout);

    if (RegConnectRegistryA( "\\\\stevewo_dbgr", HKEY_USERS, &hKey )) {
        printf( "RegConnectRegistryA( \\stevewo_dbgr ) failed (hKey == %x).\n", hKey );
        }
    else {
        printf( "RegConnectRegistryA( \\stevewo_dbgr ) succeeded (hKey == %x).\n", hKey );
        RegCloseKey( hKey );
        }

    if (RegConnectRegistryW( L"\\\\stevewo_dbgr", HKEY_USERS, &hKey )) {
        printf( "RegConnectRegistryW( \\stevewo_dbgr ) failed (hKey == %x).\n", hKey );
        }
    else {
        printf( "RegConnectRegistryW( \\stevewo_dbgr ) succeeded (hKey == %x).\n", hKey );
        RegCloseKey( hKey );
        }
#endif

    RtlInitUnicodeString( &FileName, L"\\DosDevices\\A:" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    // printf( "TEST: NtOpenFile( %wZ ) should succeed without touching floppy.\n", &FileName );
    Status = NtOpenFile( &FileHandle,
                         SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                       );
    if (!NT_SUCCESS( Status )) {
        printf( "TEST: Failed - Status == %x\n", Status );
        }
    else {
        NtClose( FileHandle );
        }

    // printf( "TEST: FindFirstFileW( C:\\*.* should fail.\n" );
    FindHandle = FindFirstFileW( L"C:\\*.*", &FindFileData );
    if (FindHandle != INVALID_HANDLE_VALUE) {
        printf( "TEST: *** oops, it worked.\n" );
        FindClose( FindHandle );
        }
    // printf( "TEST: FindFirstFileW( \\TMP\\*.* should work.\n" );
    FindHandle = FindFirstFileW( L"\\TMP\\*.*", &FindFileData );
    if (FindHandle == INVALID_HANDLE_VALUE) {
        printf( "TEST: *** oops, it failed.\n" );
        }
    else {
        FindClose( FindHandle );
        }

    // printf( "TEST: opening .\\test0 for write access.\n" );
    if (File0 = fopen( "test0.", "w" )) {
        fprintf( File0, "This is test file 0\n" );
        // printf( "TEST: closing .\\test0\n" );
        fclose( File0 );
        // printf( "TEST: deleting .\\test0 using DeleteFile (open, set, close)\n" );
        DeleteFile( L"test0" );
        }

    // printf( "TEST: opening .\\test0 for write access.\n" );
    if (File0 = fopen( "test0.", "w" )) {
        fprintf( File0, "This is test file 0\n" );
        // printf( "TEST: closing .\\test0\n" );
        fclose( File0 );

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                L"test0",
                                &FileName,
                                NULL,
                                &RelativeName
                                );

        if (TranslationStatus ) {
            FreeBuffer = FileName.Buffer;
            if ( RelativeName.RelativeName.Length ) {
                FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
                }
            else {
                RelativeName.ContainingDirectory = NULL;
                }

            InitializeObjectAttributes( &ObjectAttributes,
                                        &FileName,
                                        OBJ_CASE_INSENSITIVE,
                                        RelativeName.ContainingDirectory,
                                        NULL
                                      );
            // printf( "TEST: deleting .\\test0 using NtDeleteFile\n" );
            Status = NtDeleteFile( &ObjectAttributes );
            RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );
            }
        }

    // printf( "TEST: opening .\\test1 for write access.\n" );
    if (File1 = fopen( "test1.", "w" )) {
        fprintf( File1, "This is test file 1\n" );
        // printf( "TEST: closing .\\test1\n" );
        fclose( File1 );
        }

    // printf( "TEST: opening .\\test2 for write access (Instaler should noticed contents different)\n" );
    if (File2 = fopen( "test2.", "w" )) {
        fprintf( File2, "This is test file 2\n" );
        // printf( "TEST: closing .\\test2\n" );
        fclose( File2 );
        }

    // printf( "TEST: opening .\\test0.tmp for write access.\n" );
    if (File0 = fopen( "test0.tmp", "w" )) {
        fprintf( File0, "This is test file tmp files\n" );
        // printf( "TEST: closing .\\test0.tmp\n" );
        fclose( File0 );
        // printf( "TEST: deleting .\\test0 using DeleteFile (open, set, close)\n" );
        rename("test0.tmp", "test0.fin");
        }

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\Software\\Test" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    // printf( "TEST: opening %wZ for write access\n", &KeyName );
    Status = NtOpenKey( &KeyHandle,
                        KEY_WRITE,
                        &ObjectAttributes
                      );
    if (NT_SUCCESS( Status )) {
        RtlInitUnicodeString( &ValueName, L"Test0" );
        // printf( "TEST: setting %wZ . %wZ value\n", &KeyName, &ValueName );
        Status = NtSetValueKey( KeyHandle,
                                &ValueName,
                                0,
                                REG_SZ,
                                "0",
                                2 * sizeof( WCHAR )
                              );

        RtlInitUnicodeString( &ValueName, L"Test1" );
        // printf( "TEST: deleting %wZ . %wZ value\n", &KeyName, &ValueName );
        Status = NtDeleteValueKey( KeyHandle,
                                   &ValueName
                                 );

        RtlInitUnicodeString( &ValueName, L"Test2" );
        // printf( "TEST: setting %wZ . %wZ value\n", &KeyName, &ValueName );
        Status = NtSetValueKey( KeyHandle,
                                &ValueName,
                                0,
                                REG_DWORD,
                                &ValueDWord,
                                sizeof( ValueDWord )
                              );
        RtlInitUnicodeString( &SubKeyName, L"Test3" );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &SubKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    KeyHandle,
                                    NULL
                                  );
        // printf( "TEST: opening %wZ\\%wZ for write access\n", &KeyName, &SubKeyName );
        Status = NtOpenKey( &SubKeyHandle,
                            DELETE | KEY_WRITE,
                            &ObjectAttributes
                          );
        if (NT_SUCCESS( Status )) {
            // printf( "TEST: deleting %wZ\\%wZ key and values\n", &KeyName, &SubKeyName );
            Status = NtDeleteKey( SubKeyHandle );
            NtClose( SubKeyHandle );
            }

        RtlInitUnicodeString( &SubKeyName, L"Test4" );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &SubKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    KeyHandle,
                                    NULL
                                  );
        // printf( "TEST: creating %wZ\\%wZ for write access\n", &KeyName, &SubKeyName );
        Status = NtCreateKey( &SubKeyHandle,
                              DELETE | KEY_WRITE,
                              &ObjectAttributes,
                              0,
                              NULL,
                              0,
                              NULL
                            );
        if (NT_SUCCESS( Status )) {
            RtlInitUnicodeString( &ValueName, L"Test4" );
            // printf( "TEST: creating %wZ\\%wZ %wZ value\n", &KeyName, &SubKeyName, &ValueName );
            Status = NtSetValueKey( SubKeyHandle,
                                    &ValueName,
                                    0,
                                    REG_DWORD,
                                    &ValueDWord,
                                    sizeof( ValueDWord )
                                  );
            NtClose( SubKeyHandle );
            }

        RtlInitUnicodeString( &SubKeyName, L"Test5" );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &SubKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    KeyHandle,
                                    NULL
                                  );
        // printf( "TEST: creating %wZ\\%wZ for write access\n", &KeyName, &SubKeyName );
        Status = NtCreateKey( &SubKeyHandle,
                              DELETE | KEY_WRITE,
                              &ObjectAttributes,
                              0,
                              NULL,
                              0,
                              NULL
                            );
        if (NT_SUCCESS( Status )) {
            RtlInitUnicodeString( &ValueName, L"Test5" );
            // printf( "TEST: creating %wZ\\%wZ %wZ value\n", &KeyName, &SubKeyName, &ValueName );
            Status = NtSetValueKey( SubKeyHandle,
                                    &ValueName,
                                    0,
                                    REG_DWORD,
                                    &ValueDWord,
                                    sizeof( ValueDWord )
                                  );
            // printf( "TEST: deleting %wZ\\%wZ key and values\n", &KeyName, &SubKeyName );
            Status = NtDeleteKey( SubKeyHandle );
            NtClose( SubKeyHandle );
            }

        NtClose( KeyHandle );
        }

    GetPrivateProfileStringA( "test", NULL, "",
                              AnsiBuffer,
                              sizeof( AnsiBuffer ),
                              ".\\test.ini"
                            );

    GetPrivateProfileStringW( L"test", NULL, L"",
                              UnicodeBuffer,
                              sizeof( UnicodeBuffer ),
                              L".\\test.ini"
                            );


    if (!SetCurrentDirectoryA( ".." )) {
        printf( "TEST: SetCurrentDirectory to '..' failed (%u)\n", GetLastError() );
        }

    WriteProfileString( L"fonts", L"FooBar", L"1" );

    WriteProfileString( L"fonts", L"Rockwell Italic (TrueType)", L"ROCKI.FOT" );

    if (!SetCurrentDirectoryW( L"test" )) {
        printf( "TEST: SetCurrentDirectory to 'test' failed (%u)\n", GetLastError() );
        }

    WritePrivateProfileStringA( "test", "test1", "-1", ".\\test.ini" );

    WritePrivateProfileStringW( L"test", L"test1", L"-2", L".\\test.ini" );

    WritePrivateProfileSectionA( "test1", "test0=0\0test1=1\0test2=2\0", ".\\test.ini" );

    WritePrivateProfileSectionW( L"test2", L"test0=0\0test1=1\0test2=2\0", L".\\test.ini" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\testins1.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    testins1.c

Abstract:

    This is a test program that issues various Kernel 32 file/registry/INI file
    API calls so that we can see if the INSTALER program figures out correctly
    what is being done.

Author:

    Steve Wood (stevewo) 13-Aug-1994

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>

UCHAR AnsiBuffer[ MAX_PATH ];
WCHAR UnicodeBuffer[ MAX_PATH ];


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    FILE *File0;
    FILE *File1;
    FILE *File2;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN TranslationStatus;
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    UNICODE_STRING KeyName;
    UNICODE_STRING SubKeyName;
    UNICODE_STRING ValueName;
    HANDLE FileHandle, FindHandle, KeyHandle, SubKeyHandle;
    ULONG ValueDWord = 0x12345678;
    WIN32_FIND_DATAW FindFileData;
    LPSTR s1;
    PWSTR s2;
    UCHAR AnsiBuffer[ MAX_PATH ];
    WCHAR UnicodeBuffer[ MAX_PATH ];
    DWORD dwVersion;
    OSVERSIONINFO VersionInfo;
    HKEY hKey;

    //
    // File operations we want to test:
    //
    //  Creating a new file.
    //  Deleting that file using DeleteFile (which does NtOpenFile and NtSetInformationFile
    //  with Delete Dispostion).  (INSTALER should use this to forget about create).
    //  Creating a new file with the same name.
    //  Deleting that file using NtDeleteFile.  (again INSTALER should not care).
    //
    //  Open the TEST1 file for read access (INSTALER should not care).
    //  Open the TEST2 file for write access (INSTALER should not care).
    //  Open the TEST2 file for write access (INSTALER should not care).
    //  Open the TEST2 file for write access (INSTALER should not care).
    //
    //

    // printf( "TEST: GetFileAttributes( .\\test1 )\n" );
    GetFileAttributesA( ".\\test1" );
#if 0
    dwVersion = GetVersion();
    if ((dwVersion >> 30) ^ 0x2 == VER_PLATFORM_WIN32_WINDOWS) {
        printf( "GetVersion returns Windows 95\n" );
        }
    else
    if ((dwVersion >> 30) ^ 0x2 == VER_PLATFORM_WIN32_NT) {
        printf( "GetVersion returns Windows NT\n" );
        }
    else {
        printf( "GetVersion returns %x\n", dwVersion );
        }
    fflush(stdout);

    VersionInfo.dwOSVersionInfoSize = sizeof( VersionInfo );
    GetVersionEx( &VersionInfo );
    if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
        printf( "GetVersionEx returns Windows 95\n" );
        }
    else
    if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        printf( "GetVersionEx returns Windows NT\n" );
        }
    else {
        printf( "GetVersionEx returns %x\n", VersionInfo.dwPlatformId );
        }
    fflush(stdout);

    if (RegConnectRegistryA( "\\\\stevewo_dbgr", HKEY_USERS, &hKey )) {
        printf( "RegConnectRegistryA( \\stevewo_dbgr ) failed (hKey == %x).\n", hKey );
        }
    else {
        printf( "RegConnectRegistryA( \\stevewo_dbgr ) succeeded (hKey == %x).\n", hKey );
        RegCloseKey( hKey );
        }

    if (RegConnectRegistryW( L"\\\\stevewo_dbgr", HKEY_USERS, &hKey )) {
        printf( "RegConnectRegistryW( \\stevewo_dbgr ) failed (hKey == %x).\n", hKey );
        }
    else {
        printf( "RegConnectRegistryW( \\stevewo_dbgr ) succeeded (hKey == %x).\n", hKey );
        RegCloseKey( hKey );
        }
#endif

    RtlInitUnicodeString( &FileName, L"\\DosDevices\\A:" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    // printf( "TEST: NtOpenFile( %wZ ) should succeed without touching floppy.\n", &FileName );
    Status = NtOpenFile( &FileHandle,
                         SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                       );
    if (!NT_SUCCESS( Status )) {
        printf( "TEST: Failed - Status == %x\n", Status );
        }
    else {
        NtClose( FileHandle );
        }

    // printf( "TEST: FindFirstFileW( C:\\*.* should fail.\n" );
    FindHandle = FindFirstFileW( L"C:\\*.*", &FindFileData );
    if (FindHandle != INVALID_HANDLE_VALUE) {
        printf( "TEST: *** oops, it worked.\n" );
        FindClose( FindHandle );
        }
    // printf( "TEST: FindFirstFileW( \\TMP\\*.* should work.\n" );
    FindHandle = FindFirstFileW( L"\\TMP\\*.*", &FindFileData );
    if (FindHandle == INVALID_HANDLE_VALUE) {
        printf( "TEST: *** oops, it failed.\n" );
        }
    else {
        FindClose( FindHandle );
        }

    // printf( "TEST: opening .\\test0 for write access.\n" );
    if (File0 = fopen( "test0.", "w" )) {
        fprintf( File0, "This is test file 0\n" );
        // printf( "TEST: closing .\\test0\n" );
        fclose( File0 );
        // printf( "TEST: deleting .\\test0 using DeleteFile (open, set, close)\n" );
        DeleteFile( L"test0" );
        }

    // printf( "TEST: opening .\\test0 for write access.\n" );
    if (File0 = fopen( "test0.", "w" )) {
        fprintf( File0, "This is test file 0\n" );
        // printf( "TEST: closing .\\test0\n" );
        fclose( File0 );

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                L"test0",
                                &FileName,
                                NULL,
                                &RelativeName
                                );

        if (TranslationStatus ) {
            FreeBuffer = FileName.Buffer;
            if ( RelativeName.RelativeName.Length ) {
                FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
                }
            else {
                RelativeName.ContainingDirectory = NULL;
                }

            InitializeObjectAttributes( &ObjectAttributes,
                                        &FileName,
                                        OBJ_CASE_INSENSITIVE,
                                        RelativeName.ContainingDirectory,
                                        NULL
                                      );
            // printf( "TEST: deleting .\\test0 using NtDeleteFile\n" );
            Status = NtDeleteFile( &ObjectAttributes );
            RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );
            }
        }

    // printf( "TEST: opening .\\test1 for write access.\n" );
    if (File1 = fopen( "test1.", "w" )) {
        fprintf( File1, "This is test file 1\n" );
        // printf( "TEST: closing .\\test1\n" );
        fclose( File1 );
        }

    // printf( "TEST: opening .\\test2 for write access (Instaler should noticed contents different)\n" );
    if (File2 = fopen( "test2.", "w" )) {
        fprintf( File2, "This is test file 2\n" );
        // printf( "TEST: closing .\\test2\n" );
        fclose( File2 );
        }

    // printf( "TEST: opening .\\test0.tmp for write access.\n" );
    if (File0 = fopen( "test0.tmp", "w" )) {
        fprintf( File0, "This is test file tmp files\n" );
        // printf( "TEST: closing .\\test0.tmp\n" );
        fclose( File0 );
        // printf( "TEST: deleting .\\test0 using DeleteFile (open, set, close)\n" );
        rename("test0.tmp", "test0.fin");
        }

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\Software\\Test" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    // printf( "TEST: opening %wZ for write access\n", &KeyName );
    Status = NtOpenKey( &KeyHandle,
                        KEY_WRITE,
                        &ObjectAttributes
                      );
    if (NT_SUCCESS( Status )) {
        RtlInitUnicodeString( &ValueName, L"Test0" );
        // printf( "TEST: setting %wZ . %wZ value\n", &KeyName, &ValueName );
        Status = NtSetValueKey( KeyHandle,
                                &ValueName,
                                0,
                                REG_SZ,
                                "0",
                                2 * sizeof( WCHAR )
                              );

        RtlInitUnicodeString( &ValueName, L"Test1" );
        // printf( "TEST: deleting %wZ . %wZ value\n", &KeyName, &ValueName );
        Status = NtDeleteValueKey( KeyHandle,
                                   &ValueName
                                 );

        RtlInitUnicodeString( &ValueName, L"Test2" );
        // printf( "TEST: setting %wZ . %wZ value\n", &KeyName, &ValueName );
        Status = NtSetValueKey( KeyHandle,
                                &ValueName,
                                0,
                                REG_DWORD,
                                &ValueDWord,
                                sizeof( ValueDWord )
                              );
        RtlInitUnicodeString( &SubKeyName, L"Test3" );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &SubKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    KeyHandle,
                                    NULL
                                  );
        // printf( "TEST: opening %wZ\\%wZ for write access\n", &KeyName, &SubKeyName );
        Status = NtOpenKey( &SubKeyHandle,
                            DELETE | KEY_WRITE,
                            &ObjectAttributes
                          );
        if (NT_SUCCESS( Status )) {
            // printf( "TEST: deleting %wZ\\%wZ key and values\n", &KeyName, &SubKeyName );
            Status = NtDeleteKey( SubKeyHandle );
            NtClose( SubKeyHandle );
            }

        RtlInitUnicodeString( &SubKeyName, L"Test4" );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &SubKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    KeyHandle,
                                    NULL
                                  );
        // printf( "TEST: creating %wZ\\%wZ for write access\n", &KeyName, &SubKeyName );
        Status = NtCreateKey( &SubKeyHandle,
                              DELETE | KEY_WRITE,
                              &ObjectAttributes,
                              0,
                              NULL,
                              0,
                              NULL
                            );
        if (NT_SUCCESS( Status )) {
            RtlInitUnicodeString( &ValueName, L"Test4" );
            // printf( "TEST: creating %wZ\\%wZ %wZ value\n", &KeyName, &SubKeyName, &ValueName );
            Status = NtSetValueKey( SubKeyHandle,
                                    &ValueName,
                                    0,
                                    REG_DWORD,
                                    &ValueDWord,
                                    sizeof( ValueDWord )
                                  );
            NtClose( SubKeyHandle );
            }

        RtlInitUnicodeString( &SubKeyName, L"Test5" );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &SubKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    KeyHandle,
                                    NULL
                                  );
        // printf( "TEST: creating %wZ\\%wZ for write access\n", &KeyName, &SubKeyName );
        Status = NtCreateKey( &SubKeyHandle,
                              DELETE | KEY_WRITE,
                              &ObjectAttributes,
                              0,
                              NULL,
                              0,
                              NULL
                            );
        if (NT_SUCCESS( Status )) {
            RtlInitUnicodeString( &ValueName, L"Test5" );
            // printf( "TEST: creating %wZ\\%wZ %wZ value\n", &KeyName, &SubKeyName, &ValueName );
            Status = NtSetValueKey( SubKeyHandle,
                                    &ValueName,
                                    0,
                                    REG_DWORD,
                                    &ValueDWord,
                                    sizeof( ValueDWord )
                                  );
            // printf( "TEST: deleting %wZ\\%wZ key and values\n", &KeyName, &SubKeyName );
            Status = NtDeleteKey( SubKeyHandle );
            NtClose( SubKeyHandle );
            }

        NtClose( KeyHandle );
        }

    GetPrivateProfileStringA( "test", NULL, "",
                              AnsiBuffer,
                              sizeof( AnsiBuffer ),
                              ".\\test.ini"
                            );

    GetPrivateProfileStringW( L"test", NULL, L"",
                              UnicodeBuffer,
                              sizeof( UnicodeBuffer ),
                              L".\\test.ini"
                            );


    if (!SetCurrentDirectoryA( ".." )) {
        printf( "TEST: SetCurrentDirectory to '..' failed (%u)\n", GetLastError() );
        }

    WriteProfileString( L"fonts", L"FooBar", L"1" );

    WriteProfileString( L"fonts", L"Rockwell Italic (TrueType)", L"ROCKI.FOT" );

    if (!SetCurrentDirectoryW( L"test" )) {
        printf( "TEST: SetCurrentDirectory to 'test' failed (%u)\n", GetLastError() );
        }

    WritePrivateProfileStringA( "test", "test1", "-1", ".\\test.ini" );

    WritePrivateProfileStringW( L"test", L"test1", L"-2", L".\\test.ini" );

    WritePrivateProfileSectionA( "test1", "test0=0\0test1=1\0test2=2\0", ".\\test.ini" );

    WritePrivateProfileSectionW( L"test2", L"test0=0\0test1=1\0test2=2\0", L".\\test.ini" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\showinst.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    showinst.c

Abstract:

    This program displays the contents of an Installation Modification Log file
    created by the INSTALER program

Author:

    Steve Wood (stevewo) 15-Jan-1996

Revision History:

--*/

#include "instutil.h"
#include "iml.h"

BOOLEAN DisplayContentsOfTextFiles;

int
ProcessShowIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml
    );

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    int Result;
    char *s;
    PWSTR pw;
    PINSTALLATION_MODIFICATION_LOGFILE pIml;

    InitCommonCode( "SHOWINST",
                    "[-c]",
                    "-c specifies to display the contents of text files\n"
                  );
    DisplayContentsOfTextFiles = FALSE;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'c':
                        DisplayContentsOfTextFiles = TRUE;
                        break;
                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                        break;
                    }
                }
            }
        else
        if (!CommonArgProcessing( &argc, &argv )) {
            Usage( "Arguments not supported - '%s'", (ULONG)s );
            }
        }

    if (ImlPath == NULL) {
        Usage( "Must specify an installation name as first argument", 0 );
        }

    if (!SetCurrentDirectory( InstalerDirectory )) {
        FatalError( "Unable to change to '%ws' directory (%u)",
                    (ULONG)InstalerDirectory,
                    GetLastError()
                  );
        }

    pIml = LoadIml( ImlPath );
    if (pIml == NULL) {
        FatalError( "Unable to open '%ws' (%u)",
                    (ULONG)ImlPath,
                    GetLastError()
                  );
        }
    Result = ProcessShowIml( pIml );

    CloseIml( pIml );
    exit( Result );
    return Result;
}

int
ProcessShowIml(
    PINSTALLATION_MODIFICATION_LOGFILE pIml
    )
{
    PIML_FILE_RECORD pFile;
    PIML_FILE_RECORD_CONTENTS pOldFile;
    PIML_FILE_RECORD_CONTENTS pNewFile;
    PIML_KEY_RECORD pKey;
    PIML_VALUE_RECORD pValue;
    PIML_VALUE_RECORD_CONTENTS pOldValue;
    PIML_VALUE_RECORD_CONTENTS pNewValue;
    PIML_INI_RECORD pIni;
    PIML_INISECTION_RECORD pSection;
    PIML_INIVARIABLE_RECORD pVariable;
    BOOLEAN FileNameShown;
    BOOLEAN SectionNameShown;

    if (pIml->NumberOfFileRecords > 0) {
        printf( "File Modifications:\n" );
        pFile = MP( PIML_FILE_RECORD, pIml, pIml->FileRecords );
        while (pFile != NULL) {
            pOldFile = MP( PIML_FILE_RECORD_CONTENTS, pIml, pFile->OldFile );
            pNewFile = MP( PIML_FILE_RECORD_CONTENTS, pIml, pFile->NewFile );
            printf( "    %ws - ", MP( PWSTR, pIml, pFile->Name ) );
            switch( pFile->Action ) {
                case CreateNewFile:
                    printf( "created\n" );
                    break;

                case ModifyOldFile:
                    printf( "overwritten\n" );
                    if (pOldFile != NULL) {
                        printf( "        Old size is %u bytes\n", pOldFile->FileSize );
                        }
                    break;

                case DeleteOldFile:
                    printf( "deleted\n" );
                    if (pOldFile != NULL) {
                        printf( "        Old size is %u bytes\n", pOldFile->FileSize );
                        }
                    break;

                case ModifyFileDateTime:
                    printf( "date/time modified\n" );
                    break;

                case ModifyFileAttributes:
                    printf( "attributes modified\n" );
                    break;
                }

            pFile = MP( PIML_FILE_RECORD, pIml, pFile->Next );
            }

        printf( "\n" );
        }

    if (pIml->NumberOfKeyRecords > 0) {
        printf( "Registry Modifications:\n" );
        pKey = MP( PIML_KEY_RECORD, pIml, pIml->KeyRecords );
        while (pKey != NULL) {
            printf( "    %ws - ", MP( PWSTR, pIml, pKey->Name ) );
            switch( pKey->Action ) {
                case CreateNewKey:
                    printf( "created\n" );
                    break;

                case DeleteOldKey:
                    printf( "deleted\n" );
                    break;


                case ModifyKeyValues:
                    printf( "modified\n" );
                    break;

                }

            pValue = MP( PIML_VALUE_RECORD, pIml, pKey->Values );
            while (pValue != NULL) {
                pOldValue = MP( PIML_VALUE_RECORD_CONTENTS, pIml, pValue->OldValue );
                pNewValue = MP( PIML_VALUE_RECORD_CONTENTS, pIml, pValue->NewValue );
                printf( "        %ws - ", MP( PWSTR, pIml, pValue->Name ) );
                if (pValue->Action != DeleteOldValue) {
                    printf( "%s [%x]",
                            FormatEnumType( 0, ValueDataTypeNames, pNewValue->Type, FALSE ),
                            pNewValue->Length
                          );
                    if (pNewValue->Type == REG_SZ ||
                        pNewValue->Type == REG_EXPAND_SZ
                       ) {
                        printf( " '%ws'", MP( PWSTR, pIml, pNewValue->Data ) );
                        }
                    else
                    if (pNewValue->Type == REG_DWORD) {
                        printf( " 0x%x", *MP( PULONG, pIml, pNewValue->Data ) );
                        }
                    }

                if (pValue->Action == CreateNewValue) {
                    printf( " (created)\n" );
                    }
                else  {
                    if (pValue->Action == DeleteOldValue) {
                        printf( " (deleted" );
                        }
                    else {
                        printf( " (modified" );
                        }

                    printf( " - was %s [%x]",
                            FormatEnumType( 0, ValueDataTypeNames, pOldValue->Type, FALSE ),
                            pOldValue->Length
                          );
                    if (pOldValue->Type == REG_SZ ||
                        pOldValue->Type == REG_EXPAND_SZ
                       ) {
                        printf( " '%ws'", MP( PWSTR, pIml, pOldValue->Data ) );
                        }
                    else
                    if (pOldValue->Type == REG_DWORD) {
                        printf( " 0x%x", *MP( PULONG, pIml, pOldValue->Data ) );
                        }

                    printf( " )\n" );
                    }

                pValue = MP( PIML_VALUE_RECORD, pIml, pValue->Next );
                }

            pKey = MP( PIML_KEY_RECORD, pIml, pKey->Next );
            }

        printf( "\n" );
        }

    if (pIml->NumberOfIniRecords > 0) {
        printf( ".INI File modifications:\n" );
        pIni = MP( PIML_INI_RECORD, pIml, pIml->IniRecords );
        while (pIni != NULL) {
            FileNameShown = FALSE;
            pSection = MP( PIML_INISECTION_RECORD, pIml, pIni->Sections );
            while (pSection != NULL) {
                SectionNameShown = FALSE;
                pVariable = MP( PIML_INIVARIABLE_RECORD, pIml, pSection->Variables );
                while (pVariable != NULL) {
                    if (!FileNameShown) {
                        printf( "%ws", MP( PWSTR, pIml, pIni->Name ) );
                        if (pIni->Action == CreateNewIniFile) {
                            printf( " (created)" );
                            }
                        printf( "\n" );
                        FileNameShown = TRUE;
                        }

                    if (!SectionNameShown) {
                        printf( "    [%ws]", MP( PWSTR, pIml, pSection->Name ) );
                        if (pSection->Action == CreateNewSection) {
                            printf( " (created)" );
                            }
                        else
                        if (pSection->Action == DeleteOldSection) {
                            printf( " (deleted)" );
                            }
                        printf( "\n" );

                        SectionNameShown = TRUE;
                        }

                    printf( "        %ws = ", MP( PWSTR, pIml, pVariable->Name ) );
                    if (pVariable->Action == CreateNewVariable) {
                        printf( "'%ws' (created)\n", MP( PWSTR, pIml, pVariable->NewValue ) );
                        }
                    else
                    if (pVariable->Action == DeleteOldVariable) {
                        printf( " (deleted - was '%ws')\n", MP( PWSTR, pIml, pVariable->OldValue ) );
                        }
                    else {
                        printf( "'%ws' (modified - was '%ws')\n",
                                MP( PWSTR, pIml, pVariable->NewValue ),
                                MP( PWSTR, pIml, pVariable->OldValue )
                              );
                        }

                    pVariable = MP( PIML_INIVARIABLE_RECORD, pIml, pVariable->Next );
                    }

                pSection = MP( PIML_INISECTION_RECORD, pIml, pSection->Next );
                }

            if (FileNameShown) {
                printf( "\n" );
                }

            pIni = MP( PIML_INI_RECORD, pIml, pIni->Next );
            }
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\process.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module maintains state about each process/thread created by the application
    setup/install program.

Author:

    Steve Wood (stevewo) 09-Aug-1994

Revision History:

--*/

#include "instaler.h"

BOOLEAN
AddProcess(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO *ReturnedProcess
    )
{
    NTSTATUS Status;
    PPROCESS_INFO Process;
    RTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PEB Peb;
    PWSTR FreeBuffer, s;

    Process = AllocMem( sizeof( *Process ) );
    if (Process == NULL) {
        return FALSE;
        }

    Process->Id = DebugEvent->dwProcessId;
    Process->Handle = DebugEvent->u.CreateProcessInfo.hProcess;
    InitializeListHead( &Process->ThreadListHead );
    InitializeListHead( &Process->BreakpointListHead );
    InitializeListHead( &Process->OpenHandleListHead );
    InsertTailList( &ProcessListHead, &Process->Entry );
    *ReturnedProcess = Process;

    Status = NtQueryInformationProcess( Process->Handle,
                                        ProcessBasicInformation,
                                        &Process->ProcessInformation,
                                        sizeof( Process->ProcessInformation ),
                                        NULL
                                      );
    FreeBuffer = NULL;
    if (ReadMemory( Process,
                    Process->ProcessInformation.PebBaseAddress,
                    &Peb,
                    sizeof( Peb ),
                    "PEB"
                  ) &&
        Peb.ProcessParameters != NULL &&
        ReadMemory( Process,
                    Peb.ProcessParameters,
                    &ProcessParameters,
                    sizeof( ProcessParameters ),
                    "ProcessParameters"
                  ) &&
        ProcessParameters.ImagePathName.Length != 0 &&
        (FreeBuffer = AllocMem( ProcessParameters.ImagePathName.Length + sizeof( UNICODE_NULL ) )) != NULL &&
        ReadMemory( Process,
                    ProcessParameters.Flags & RTL_USER_PROC_PARAMS_NORMALIZED ?
                        ProcessParameters.ImagePathName.Buffer :
                        (PWSTR)((ULONG)(ProcessParameters.ImagePathName.Buffer) + (PCHAR)(Peb.ProcessParameters)),
                    FreeBuffer,
                    ProcessParameters.ImagePathName.Length,
                    "Image File Name"
                  )
       ) {
        s = (PWSTR)((PCHAR)FreeBuffer + ProcessParameters.ImagePathName.Length);
        while (s > FreeBuffer && s[ -1 ] != OBJ_NAME_PATH_SEPARATOR) {
            s--;
            }

        wcsncpy( Process->ImageFileName,
                 s,
                 (sizeof( Process->ImageFileName ) - sizeof( UNICODE_NULL )) / sizeof( WCHAR )
               );
        }
    FreeMem( &FreeBuffer );
    return TRUE;
}

BOOLEAN
DeleteProcess(
    PPROCESS_INFO Process
    )
{
    PLIST_ENTRY Next, Head;
    PTHREAD_INFO Thread;
    PBREAKPOINT_INFO Breakpoint;
    POPENHANDLE_INFO p;

    RemoveEntryList( &Process->Entry );

    Head = &Process->ThreadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Thread = CONTAINING_RECORD( Next, THREAD_INFO, Entry );
        Next = Next->Flink;
        DeleteThread( Process, Thread );
        }

    Head = &Process->BreakpointListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Breakpoint = CONTAINING_RECORD( Next, BREAKPOINT_INFO, Entry );
        Next = Next->Flink;
        DestroyBreakpoint( Breakpoint->Address, Process, NULL );
        }


    Head = &Process->OpenHandleListHead;
    Next = Head->Flink;
    while (Next != Head) {
        p = CONTAINING_RECORD( Next, OPENHANDLE_INFO, Entry );
        Next = Next->Flink;
        DeleteOpenHandle( Process, p->Handle, p->Type );
        }

    FreeMem( &Process );
    return TRUE;
}


BOOLEAN
AddThread(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO Process,
    PTHREAD_INFO *ReturnedThread
    )
{
    PTHREAD_INFO Thread;

    Thread = AllocMem( sizeof( *Thread ) );
    if (Thread == NULL) {
        return FALSE;
        }

    Thread->Id = DebugEvent->dwThreadId;
    if (DebugEvent->dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {
        Thread->Handle = DebugEvent->u.CreateProcessInfo.hThread;
        Thread->StartAddress = DebugEvent->u.CreateProcessInfo.lpStartAddress;
        }
    else {
        Thread->Handle = DebugEvent->u.CreateThread.hThread;
        Thread->StartAddress = DebugEvent->u.CreateThread.lpStartAddress;
        }
    Thread->SingleStepExpected = FALSE;
    InitializeListHead( &Thread->BreakpointListHead );
    InsertTailList( &Process->ThreadListHead, &Thread->Entry );
    *ReturnedThread = Thread;
    return TRUE;
}

BOOLEAN
DeleteThread(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    )
{
    PLIST_ENTRY Next, Head;
    PBREAKPOINT_INFO Breakpoint;

    RemoveEntryList( &Thread->Entry );

    Head = &Thread->BreakpointListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Breakpoint = CONTAINING_RECORD( Next, BREAKPOINT_INFO, Entry );
        Next = Next->Flink;
        DestroyBreakpoint( Breakpoint->Address, Process, Thread );
        }

    FreeMem( &Thread );
    return TRUE;
}


PPROCESS_INFO
FindProcessById(
    ULONG Id
    )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_INFO Process;

    Head = &ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_INFO, Entry );
        if (Process->Id == Id) {
            return Process;
            }

        Next = Next->Flink;
        }

    return NULL;
}

BOOLEAN
FindProcessAndThreadForEvent(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO *ReturnedProcess,
    PTHREAD_INFO *ReturnedThread
    )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_INFO Process;
    PTHREAD_INFO Thread;

    Head = &ProcessListHead;
    Next = Head->Flink;
    Process = NULL;
    Thread = NULL;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_INFO, Entry );
        if (Process->Id == DebugEvent->dwProcessId) {
            Head = &Process->ThreadListHead;
            Next = Head->Flink;
            while (Next != Head) {
                Thread = CONTAINING_RECORD( Next, THREAD_INFO, Entry );
                if (Thread->Id == DebugEvent->dwThreadId) {
                    break;
                    }

                Thread = NULL;
                Next = Next->Flink;
                }

            break;
            }

        Process = NULL;
        Next = Next->Flink;
        }

    *ReturnedProcess = Process;
    *ReturnedThread = Thread;

    if (DebugEvent->dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {
        if (Process != NULL) {
            DeclareError( INSTALER_DUPLICATE_PROCESS_ID, 0, DebugEvent->dwProcessId );
            return FALSE;
            }
        }
    else
    if (DebugEvent->dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT) {
        if (Thread != NULL) {
            DeclareError( INSTALER_DUPLICATE_THREAD_ID, 0, DebugEvent->dwThreadId, DebugEvent->dwProcessId );
            return FALSE;
            }
        if (Process == NULL) {
            DeclareError( INSTALER_MISSING_PROCESS_ID, 0, DebugEvent->dwProcessId );
            return FALSE;
            }
        }
    else
    if (Process == NULL) {
        DeclareError( INSTALER_MISSING_PROCESS_ID, 0, DebugEvent->dwProcessId );
        return FALSE;
        }
    else
    if (Thread == NULL) {
        DeclareError( INSTALER_MISSING_THREAD_ID, 0, DebugEvent->dwThreadId, DebugEvent->dwProcessId );
        return FALSE;
        }

    return TRUE;
}


VOID
SuspendAllButThisThread(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    )
{
    PTHREAD_INFO Thread1;
    PLIST_ENTRY Next, Head;

    if (Thread != NULL) {
        Head = &Process->ThreadListHead;
        Next = Head->Flink;
        while (Next != Head) {
            Thread1 = CONTAINING_RECORD( Next, THREAD_INFO, Entry );
            if (Thread1 != Thread) {
                NtSuspendThread( Thread1->Handle, NULL );
                }

            Next = Next->Flink;
            }
        }

    return;
}

VOID
ResumeAllButThisThread(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    )
{
    PTHREAD_INFO Thread1;
    PLIST_ENTRY Next, Head;

    if (Thread != NULL) {
        Head = &Process->ThreadListHead;
        Next = Head->Flink;
        while (Next != Head) {
            Thread1 = CONTAINING_RECORD( Next, THREAD_INFO, Entry );
            if (Thread1 != Thread) {
                NtResumeThread( Thread1->Handle, NULL );
                }

            Next = Next->Flink;
            }
        }

    return;
}

PBREAKPOINT_INFO
FindBreakpoint(
    LPVOID Address,
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    )
{
    PBREAKPOINT_INFO Breakpoint;
    PLIST_ENTRY Next, Head;

    if (Thread != NULL) {
        Head = &Thread->BreakpointListHead;
        Next = Head->Flink;
        while (Next != Head) {
            Breakpoint = CONTAINING_RECORD( Next, BREAKPOINT_INFO, Entry );
            if (Breakpoint->Address == Address) {
                return Breakpoint;
                }

            Next = Next->Flink;
            }
        }

    Head = &Process->BreakpointListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Breakpoint = CONTAINING_RECORD( Next, BREAKPOINT_INFO, Entry );
        if (Breakpoint->Address == Address) {
            return Breakpoint;
            }

        Next = Next->Flink;
        }

    return NULL;
}

BOOLEAN
CreateBreakpoint(
    LPVOID Address,
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    UCHAR ApiIndex,
    PAPI_SAVED_PARAMETERS SavedParameters,
    PBREAKPOINT_INFO *ReturnedBreakpoint
    )
{
    PBREAKPOINT_INFO Breakpoint;

    Breakpoint = FindBreakpoint( Address, Process, Thread );

    if (ARGUMENT_PRESENT( ReturnedBreakpoint )) {
        *ReturnedBreakpoint = Breakpoint;
        }

    if (Breakpoint != NULL) {
        return (Breakpoint->ApiIndex == ApiIndex);
        }

    Breakpoint = AllocMem( sizeof( *Breakpoint ) );
    if (Breakpoint == NULL) {
        return FALSE;
        }

    Breakpoint->Address = Address;
    Breakpoint->ApiIndex = ApiIndex;
    if (ARGUMENT_PRESENT( SavedParameters )) {
        Breakpoint->SavedParameters = *SavedParameters;
        Breakpoint->SavedParametersValid = TRUE;
        }
    else {
        Breakpoint->SavedParametersValid = FALSE;
        }

    if (Thread != NULL) {
        InsertTailList( &Thread->BreakpointListHead, &Breakpoint->Entry );
        }
    else {
        InsertTailList( &Process->BreakpointListHead, &Breakpoint->Entry );
        }

    InstallBreakpoint( Process, Breakpoint );

    if (ARGUMENT_PRESENT( ReturnedBreakpoint )) {
        *ReturnedBreakpoint = Breakpoint;
        }

    return TRUE;
}


BOOLEAN
DestroyBreakpoint(
    LPVOID Address,
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    )
{
    PBREAKPOINT_INFO Breakpoint;

    Breakpoint = FindBreakpoint( Address, Process, Thread );
    if (Breakpoint == NULL) {
        return FALSE;
        }

    RemoveBreakpoint( Process, Breakpoint );

    RemoveEntryList( &Breakpoint->Entry );

    FreeMem( &Breakpoint );
    return TRUE;
}


BOOLEAN
HandleThreadsForSingleStep(
    PPROCESS_INFO Process,
    PTHREAD_INFO ThreadToSingleStep,
    BOOLEAN SuspendThreads
    )
{
    PLIST_ENTRY Next, Head;
    PTHREAD_INFO Thread;

    Head = &Process->ThreadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Thread = CONTAINING_RECORD( Next, THREAD_INFO, Entry );
        if (Thread != ThreadToSingleStep) {
            if (SuspendThreads) {
                if (Thread->BreakpointToStepOver == NULL) {
                    SuspendThread( Thread->Handle );
                    }
                }
            else {
                ResumeThread( Thread->Handle );
                }

            break;
            }

        Next = Next->Flink;
        }

    return TRUE;
}


BOOLEAN
ReadMemory(
    PPROCESS_INFO Process,
    PVOID Address,
    PVOID DataRead,
    ULONG BytesToRead,
    PCHAR Reason
    )
{
    ULONG BytesRead;

    if (!ReadProcessMemory( Process->Handle,
                            Address,
                            DataRead,
                            BytesToRead,
                            &BytesRead
                          ) ||
        BytesRead != BytesToRead
       ) {
        DbgEvent( MEMORYERROR, ( "Read memory from %x for %x bytes failed (%u) - '%s'\n",
                                 Address,
                                 BytesToRead,
                                 GetLastError(),
                                 Reason
                               )
                );
        return FALSE;
        }
    else {
        return TRUE;
        }
}


BOOLEAN
WriteMemory(
    PPROCESS_INFO Process,
    PVOID Address,
    PVOID DataToWrite,
    ULONG BytesToWrite,
    PCHAR Reason
    )
{
    ULONG BytesWritten;
    ULONG OldProtection;
    BOOLEAN Result;

    if (WriteProcessMemory( Process->Handle,
                            Address,
                            DataToWrite,
                            BytesToWrite,
                            &BytesWritten
                          ) &&
        BytesWritten == BytesToWrite
       ) {
        return TRUE;
        }

    Result = FALSE;
    if (GetLastError() == ERROR_NOACCESS &&
        VirtualProtectEx( Process->Handle,
                          Address,
                          BytesToWrite,
                          PAGE_READWRITE,
                          &OldProtection
                        )
       ) {
        if (WriteProcessMemory( Process->Handle,
                                Address,
                                DataToWrite,
                                BytesToWrite,
                                &BytesWritten
                              ) &&
            BytesWritten == BytesToWrite
           ) {
            Result = TRUE;
            }
        VirtualProtectEx( Process->Handle,
                          Address,
                          BytesToWrite,
                          OldProtection,
                          &OldProtection
                        );
        if (Result) {
            return TRUE;
            }
        }

    DbgEvent( MEMORYERROR, ( "Write memory to %x for %x bytes failed (%u) - '%s'\n",
                             Address,
                             BytesToWrite,
                             GetLastError(),
                             Reason
                           )
            );
    return FALSE;
}


PVOID
AllocMem(
    ULONG Size
    )
{
    PVOID p;

    p = HeapAlloc( AppHeap, HEAP_ZERO_MEMORY, Size );
    if (p == NULL) {
        DbgEvent( INTERNALERROR, ( "HeapAlloc( %0x8 ) failed\n", Size ) );
        }



    return p;
}


VOID
FreeMem(
    PVOID *p
    )
{
    if (*p != NULL) {
        HeapFree( AppHeap, 0, *p );
        *p = NULL;
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\undoinst.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    undoinst.c

Abstract:

    This program undoes the actions described by an Installation Modification Log file
    created by the INSTALER program

Author:

    Steve Wood (stevewo) 15-Jan-1996

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "instutil.h"
#include "iml.h"

BOOLEAN RedoScript;
BOOLEAN VerboseOutput;

int
ProcessUndoIml(
    PINSTALLATION_MODIFICATION_LOGFILE pImlUndo,
    PINSTALLATION_MODIFICATION_LOGFILE pImlRedo
    );

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    int Result;
    char *s;
    PINSTALLATION_MODIFICATION_LOGFILE pImlUndo;
    PINSTALLATION_MODIFICATION_LOGFILE pImlRedo;
    USHORT RedoScriptId;

    InitCommonCode( "UNDOINST",
                    "[-r] [-v]",
                    "-r replace contents of input .IML file with redo script to undo the undo\n"
                    "-v verbose output\n"
                  );
    RedoScript = FALSE;
    VerboseOutput = FALSE;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'r':
                        RedoScript = TRUE;
                        break;
                    case 'v':
                        VerboseOutput = TRUE;
                        break;
                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                        break;
                    }
                }
            }
        else
        if (!CommonArgProcessing( &argc, &argv )) {
            Usage( "Arguments not supported - '%s'", (ULONG)s );
            }
        }

    if (ImlPath == NULL) {
        Usage( "Must specify an installation name as first argument", 0 );
        }

    if (!SetCurrentDirectory( InstalerDirectory )) {
        FatalError( "Unable to change to '%ws' directory (%u)",
                    (ULONG)InstalerDirectory,
                    GetLastError()
                  );
        }

    pImlUndo = LoadIml( ImlPath );
    if (pImlUndo == NULL) {
        FatalError( "Unable to open '%ws' (%u)",
                    (ULONG)ImlPath,
                    GetLastError()
                  );
        }
    if (RedoScript) {
        RedoScriptId = 0;
        if (CreateBackupFileName( &RedoScriptId ) == NULL) {
            FatalError( "Unable to create temporary file for redo script (%u)\n",
                        GetLastError(),
                        0
                      );
            }

        pImlRedo = CreateIml( FormatTempFileName( InstalerDirectory, &RedoScriptId ), TRUE );
        if (pImlRedo == NULL) {
            FatalError( "Unable to create redo script '%ws' (%u)\n",
                        (ULONG)FormatTempFileName( InstalerDirectory, &RedoScriptId ),
                        GetLastError()
                      );
            }
        }
    else {
        pImlRedo = NULL;
        }

    Result = ProcessUndoIml( pImlUndo, pImlRedo );

    CloseIml( pImlUndo );
    if (pImlRedo != NULL) {
        CloseIml( pImlRedo );
        if (!MoveFileEx( FormatTempFileName( InstalerDirectory, &RedoScriptId ),
                         ImlPath,
                         MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED
                       )
           ) {
            FatalError( "Unable to rename redo script '%ws' (%u)\n",
                        (ULONG)FormatTempFileName( InstalerDirectory, &RedoScriptId ),
                        GetLastError()
                      );
            }
        }

    exit( Result );
    return Result;
}


BOOL
DeleteFileOrDirectory(
    PWSTR Name
    )
{
    DWORD FileAttributes;

    FileAttributes = GetFileAttributes( Name );
    if (FileAttributes == 0xFFFFFFFF) {
        return TRUE;
        }

    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        return RemoveDirectory( Name );
        }
    else {
        return DeleteFile( Name );
        }
}

BOOLEAN
ProcessUndoFileIml(
    PINSTALLATION_MODIFICATION_LOGFILE pImlUndo,
    PIML_FILE_RECORD pFile
    )
{
    PIML_FILE_RECORD_CONTENTS pOldFile;
    PIML_FILE_RECORD_CONTENTS pNewFile;
    USHORT UniqueId = 0;
    HANDLE FileHandle;
    PWSTR BackupFileName;
    DWORD FileAttributes;
    DWORD BytesWritten;

    pOldFile = MP( PIML_FILE_RECORD_CONTENTS, pImlUndo, pFile->OldFile );
    pNewFile = MP( PIML_FILE_RECORD_CONTENTS, pImlUndo, pFile->NewFile );
    printf( "    %ws - ", MP( PWSTR, pImlUndo, pFile->Name ) );
    switch( pFile->Action ) {
        case CreateNewFile:
            printf( "deleting" );
            SetFileAttributes( MP( PWSTR, pImlUndo, pFile->Name ),
                               FILE_ATTRIBUTE_NORMAL
                             );
            if (!DeleteFileOrDirectory( MP( PWSTR, pImlUndo, pFile->Name ) )) {
                printf( " - error (%u)", GetLastError() );
                }
            printf( "\n" );
            break;

        case ModifyOldFile:
        case DeleteOldFile:
            FileAttributes = GetFileAttributes( MP( PWSTR, pImlUndo, pFile->Name ) );
            printf( "restoring old file" );
            if (FileAttributes != 0xFFFFFFFF) {
                SetFileAttributes( MP( PWSTR, pImlUndo, pFile->Name ),
                                   FILE_ATTRIBUTE_NORMAL
                                 );
                BackupFileName = CreateBackupFileName( &UniqueId );
                if (BackupFileName == NULL) {
                    printf( " - unable to find temporary name for restore\n" );
                    break;
                    }
                else
                if (!MoveFile( MP( PWSTR, pImlUndo, pFile->Name ),
                               BackupFileName
                             )
                   ) {
                    printf( " - unable to rename existing to temporary name (%u)\n",
                            GetLastError()
                          );
                    break;
                    }
                }
            else {
                BackupFileName = NULL;
                }

            if (pOldFile != NULL) {
                if (pOldFile->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    if (!CreateDirectory( MP( PWSTR, pImlUndo, pFile->Name ), NULL )) {
                        printf( " - unable to create directory (%u)",
                                GetLastError()
                              );
                        }
                    }
                else {
                    FileHandle = CreateFile( MP( PWSTR, pImlUndo, pFile->Name ),
                                             GENERIC_WRITE,
                                             FILE_SHARE_READ,
                                             NULL,
                                             CREATE_NEW,
                                             0,
                                             NULL
                                           );
                    if (FileHandle != INVALID_HANDLE_VALUE) {
                        if (WriteFile( FileHandle,
                                       MP( PVOID, pImlUndo, pOldFile->Contents ),
                                       pOldFile->FileSize,
                                       &BytesWritten,
                                       NULL
                                     ) &&
                            BytesWritten == pOldFile->FileSize
                           ) {
                            if (!SetFileAttributes( MP( PWSTR, pImlUndo, pFile->Name ),
                                                    pOldFile->FileAttributes
                                                  )
                               ) {
                                printf( " - unable to restore attributes (%u)",
                                        GetLastError()
                                      );
                                }
                            else
                            if (!SetFileTime( FileHandle,
                                              &pOldFile->LastWriteTime,
                                              &pOldFile->LastWriteTime,
                                              &pOldFile->LastWriteTime
                                            )
                               ) {
                                printf( " - unable to restore last write time (%u)",
                                        GetLastError()
                                      );
                                }
                            else
                            if (BackupFileName != NULL) {
                                DeleteFile( BackupFileName );
                                BackupFileName = NULL;
                                }
                            }
                        else {
                            printf( " - unable to restore contents (%u)",
                                    GetLastError()
                                  );
                            }

                        CloseHandle( FileHandle );
                        }
                    else {
                        printf( " - unable to create file (%u)",
                                GetLastError()
                              );
                        }
                    }
                }
            else {
                printf( " - old contents missing from .IML file" );
                }

            if (BackupFileName != NULL) {
                DeleteFile( MP( PWSTR, pImlUndo, pFile->Name ) );
                MoveFile( BackupFileName, MP( PWSTR, pImlUndo, pFile->Name ) );
                }
            printf( "\n" );
            break;

        case ModifyFileDateTime:
            printf( "restoring date/time\n" );
            FileHandle = CreateFile( MP( PWSTR, pImlUndo, pFile->Name ),
                                     FILE_WRITE_ATTRIBUTES,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL
                                   );
            if (FileHandle != INVALID_HANDLE_VALUE) {
                if (!SetFileTime( FileHandle,
                                  &pOldFile->LastWriteTime,
                                  &pOldFile->LastWriteTime,
                                  &pOldFile->LastWriteTime
                                )
                   ) {
                    printf( " - unable to restore last write time (%u)",
                            GetLastError()
                          );
                    }

                CloseHandle( FileHandle );
                }
            else {
                printf( " - unable to open file (%u)",
                        GetLastError()
                      );
                }
            break;

        case ModifyFileAttributes:
            printf( "restoring attributes" );
            if (!SetFileAttributes( MP( PWSTR, pImlUndo, pFile->Name ),
                                    pOldFile->FileAttributes
                                  )
               ) {
                printf( " - unable to restore attributes (%u)",
                        GetLastError()
                      );
                }
            printf( "\n" );
            break;
        }

    return TRUE;
}


BOOLEAN
ProcessRedoFileIml(
    PINSTALLATION_MODIFICATION_LOGFILE pImlUndo,
    PIML_FILE_RECORD pFile,
    PINSTALLATION_MODIFICATION_LOGFILE pImlRedo
    )
{
    HANDLE FindHandle;
    WIN32_FIND_DATA FindFileData;

    if (pFile->Action == CreateNewFile) {
        //
        // Created a new file.  So do the same in the redo
        // script, with the existing contents of the new file
        //
        ImlAddFileRecord( pImlRedo,
                          CreateNewFile,
                          MP( PWSTR, pImlUndo, pFile->Name ),
                          NULL,
                          NULL,
                          0
                        );
        }
    else
    if (pFile->Action == ModifyOldFile) {
        //
        // Modified an existing file.  Create a similar record
        // in the redo script that will hold the new contents
        //
        ImlAddFileRecord( pImlRedo,
                          ModifyOldFile,
                          MP( PWSTR, pImlUndo, pFile->Name ),
                          NULL,
                          NULL,
                          0
                        );
        }
    else {
        //
        // Modified the file attributes and/or date and time.  Get the current
        // values and save them in the redo script
        //
        FindHandle = FindFirstFile( MP( PWSTR, pImlUndo, pFile->Name ),
                                    &FindFileData
                                  );
        if (FindHandle != INVALID_HANDLE_VALUE) {
            ImlAddFileRecord( pImlRedo,
                              ModifyFileDateTime,
                              MP( PWSTR, pImlUndo, pFile->Name ),
                              NULL,
                              &FindFileData.ftLastWriteTime,
                              FindFileData.dwFileAttributes
                            );
            FindClose( FindHandle );
            }
        }

    return TRUE;
}


BOOLEAN
ProcessUndoKeyIml(
    PINSTALLATION_MODIFICATION_LOGFILE pImlUndo,
    PIML_KEY_RECORD pKey
    )
{
    PIML_VALUE_RECORD pValue;
    PIML_VALUE_RECORD_CONTENTS pOldValue;
    PIML_VALUE_RECORD_CONTENTS pNewValue;
    NTSTATUS Status;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    UNICODE_STRING ValueName;

    KeyHandle = NULL;
    if (pKey->Values != 0 || pKey->Action == CreateNewKey) {
        printf( "    %ws - ", MP( PWSTR, pImlUndo, pKey->Name ) );
        RtlInitUnicodeString( &KeyName, MP( PWSTR, pImlUndo, pKey->Name ) );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &KeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                  );
        if (pKey->Action != DeleteOldKey) {
            if (pKey->Action == CreateNewKey) {
                printf( "deleting" );
                }
            else {
                printf( "modifying" );
                }
            Status = NtOpenKey( &KeyHandle, DELETE | GENERIC_WRITE, &ObjectAttributes );
            }
        else {
            printf( "creating" );
            Status = NtCreateKey( &KeyHandle,
                                  GENERIC_WRITE,
                                  &ObjectAttributes,
                                  0,
                                  NULL,
                                  0,
                                  NULL
                                );
            }

        if (!NT_SUCCESS( Status )) {
            KeyHandle = NULL;
            printf( " - failed (0x%08x)", Status );
            }
        printf( "\n" );

        if (KeyHandle != NULL) {
            pValue = MP( PIML_VALUE_RECORD, pImlUndo, pKey->Values );
            while (pValue != NULL) {
                pOldValue = MP( PIML_VALUE_RECORD_CONTENTS, pImlUndo, pValue->OldValue );
                pNewValue = MP( PIML_VALUE_RECORD_CONTENTS, pImlUndo, pValue->NewValue );
                printf( "        %ws - ", MP( PWSTR, pImlUndo, pValue->Name ) );
                RtlInitUnicodeString( &ValueName,
                                      MP( PWSTR, pImlUndo, pValue->Name )
                                    );
                if (pValue->Action == CreateNewValue) {
                    printf( "deleting" );
                    Status = NtDeleteValueKey( KeyHandle, &ValueName );
                    }
                else {
                    if (pValue->Action == DeleteOldValue) {
                        printf( "creating" );
                        }
                    else {
                        printf( "restoring" );
                        }

                    Status = NtSetValueKey( KeyHandle,
                                            &ValueName,
                                            0,
                                            pOldValue->Type,
                                            MP( PWSTR, pImlUndo, pOldValue->Data ),
                                            pOldValue->Length
                                          );
                    }

                if (!NT_SUCCESS( Status )) {
                    printf( " - failed (0x%08x)", Status );
                    }
                printf( "\n" );

                pValue = MP( PIML_VALUE_RECORD, pImlUndo, pValue->Next );
                }
            }
        }

    if (KeyHandle != NULL) {
        if (pKey->Action == CreateNewKey) {
            Status = NtDeleteKey( KeyHandle );
            if (!NT_SUCCESS( Status )) {
                printf( "    *** delete of above key failed (0x%08x)", Status );
                }
            }
        NtClose( KeyHandle );
        }

    return TRUE;
}


BOOLEAN
ProcessRedoKeyIml(
    PINSTALLATION_MODIFICATION_LOGFILE pImlUndo,
    PIML_KEY_RECORD pKey,
    PINSTALLATION_MODIFICATION_LOGFILE pImlRedo
    )
{
    PIML_VALUE_RECORD pValue;
    PIML_VALUE_RECORD_CONTENTS pOldValue;
    PIML_VALUE_RECORD_CONTENTS pNewValue;
    POFFSET Values;

    Values = 0;
    if ((pKey->Values != 0 || pKey->Action == CreateNewKey) &&
        pKey->Action != DeleteOldKey
       ) {
        //
        // Created or modified an existing key and/or values.
        //
        pValue = MP( PIML_VALUE_RECORD, pImlUndo, pKey->Values );
        while (pValue != NULL) {
            pOldValue = MP( PIML_VALUE_RECORD_CONTENTS, pImlUndo, pValue->OldValue );
            pNewValue = MP( PIML_VALUE_RECORD_CONTENTS, pImlUndo, pValue->NewValue );
            if (pValue->Action == CreateNewValue) {
                if (pNewValue != NULL) {
                    ImlAddValueRecord( pImlRedo,
                                       pValue->Action,
                                       MP( PWSTR, pImlUndo, pValue->Name ),
                                       pNewValue->Type,
                                       pNewValue->Length,
                                       MP( PWSTR, pImlUndo, pNewValue->Data ),
                                       0,
                                       0,
                                       NULL,
                                       &Values
                                     );
                    }
                }
            else
            if (pValue->Action == ModifyOldValue) {
                if (pOldValue != NULL && pNewValue != NULL) {
                    ImlAddValueRecord( pImlRedo,
                                       pValue->Action,
                                       MP( PWSTR, pImlUndo, pValue->Name ),
                                       pNewValue->Type,
                                       pNewValue->Length,
                                       MP( PWSTR, pImlUndo, pNewValue->Data ),
                                       pOldValue->Type,
                                       pOldValue->Length,
                                       MP( PWSTR, pImlUndo, pOldValue->Data ),
                                       &Values
                                     );
                    }
                }
            else
            if (pValue->Action == DeleteOldValue) {
                if (pOldValue != NULL) {
                    ImlAddValueRecord( pImlRedo,
                                       pValue->Action,
                                       MP( PWSTR, pImlUndo, pValue->Name ),
                                       0,
                                       0,
                                       NULL,
                                       pOldValue->Type,
                                       pOldValue->Length,
                                       MP( PWSTR, pImlUndo, pOldValue->Data ),
                                       &Values
                                     );
                    }
                }

            pValue = MP( PIML_VALUE_RECORD, pImlUndo, pValue->Next );
            }
        }

    ImlAddKeyRecord( pImlRedo,
                     pKey->Action,
                     MP( PWSTR, pImlUndo, pKey->Name ),
                     Values
                   );
    return TRUE;
}

BOOLEAN
ProcessUndoIniIml(
    PINSTALLATION_MODIFICATION_LOGFILE pImlUndo,
    PIML_INI_RECORD pIni
    )
{
    PIML_INISECTION_RECORD pSection;
    PIML_INIVARIABLE_RECORD pVariable;
    HANDLE FileHandle;
    BOOLEAN FileNameShown;
    BOOLEAN SectionNameShown;

    FileNameShown = FALSE;
    pSection = MP( PIML_INISECTION_RECORD, pImlUndo, pIni->Sections );
    while (pSection != NULL) {
        SectionNameShown = FALSE;
        pVariable = MP( PIML_INIVARIABLE_RECORD, pImlUndo, pSection->Variables );
        while (pVariable != NULL) {
            if (!FileNameShown) {
                printf( "%ws\n", MP( PWSTR, pImlUndo, pIni->Name ) );
                FileNameShown = TRUE;
                }

            if (!SectionNameShown) {
                printf( "    [%ws]", MP( PWSTR, pImlUndo, pSection->Name ) );
                if (pSection->Action == DeleteOldSection) {
                    printf( " - deleting" );
                    }
                printf( "\n" );
                SectionNameShown = TRUE;
                }

            printf( "        %ws = ", MP( PWSTR, pImlUndo, pVariable->Name ) );
            if (pVariable->Action == CreateNewVariable) {
                printf( "deleting" );
                if (!WritePrivateProfileString( MP( PWSTR, pImlUndo, pSection->Name ),
                                                MP( PWSTR, pImlUndo, pVariable->Name ),
                                                NULL,
                                                MP( PWSTR, pImlUndo, pIni->Name )
                                              )
                   ) {
                    printf( " - failed (%u)", GetLastError() );
                    }
                printf( "\n" );
                }
            else {
                printf( "restoring" );
                if (!WritePrivateProfileString( MP( PWSTR, pImlUndo, pSection->Name ),
                                                MP( PWSTR, pImlUndo, pVariable->Name ),
                                                MP( PWSTR, pImlUndo, pVariable->OldValue ),
                                                MP( PWSTR, pImlUndo, pIni->Name )
                                              )
                   ) {
                    printf( " - failed (%u)", GetLastError() );
                    }
                printf( "\n" );
                }

            pVariable = MP( PIML_INIVARIABLE_RECORD, pImlUndo, pVariable->Next );
            }

        if (pSection->Action == CreateNewSection) {
            if (!FileNameShown) {
                printf( "%ws\n", MP( PWSTR, pImlUndo, pIni->Name ) );
                FileNameShown = TRUE;
                }

            if (!SectionNameShown) {
                printf( "    [%ws]", MP( PWSTR, pImlUndo, pSection->Name ) );
                if (pSection->Action == CreateNewSection) {
                    printf( " - deleting" );
                    }
                SectionNameShown = TRUE;
                printf( "\n" );
                }

            if (!WritePrivateProfileSection( MP( PWSTR, pImlUndo, pSection->Name ),
                                             NULL,
                                             MP( PWSTR, pImlUndo, pIni->Name )
                                           )
               ) {
                printf( "    *** delete of above section name failed (%u)\n",
                        GetLastError()
                      );
                }
            }

        pSection = MP( PIML_INISECTION_RECORD, pImlUndo, pSection->Next );
        }

    if (pIni->Action == CreateNewIniFile) {
        printf( "%ws - deleting", MP( PWSTR, pImlUndo, pIni->Name ) );
        if (!DeleteFile( MP( PWSTR, pImlUndo, pIni->Name ) )) {
            printf( " - failed (%u)", GetLastError() );
            }
        printf( "\n" );
        FileNameShown = TRUE;
        }
    else {
        FileHandle = CreateFile( MP( PWSTR, pImlUndo, pIni->Name ),
                                 FILE_WRITE_ATTRIBUTES,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL
                               );
        if (FileHandle != INVALID_HANDLE_VALUE) {
            SetFileTime( FileHandle,
                         &pIni->LastWriteTime,
                         &pIni->LastWriteTime,
                         &pIni->LastWriteTime
                       );
            CloseHandle( FileHandle );
            }
        }

    if (FileNameShown) {
        printf( "\n" );
        }
    return TRUE;
}


BOOLEAN
ProcessRedoIniIml(
    PINSTALLATION_MODIFICATION_LOGFILE pImlUndo,
    PIML_INI_RECORD pIni,
    PINSTALLATION_MODIFICATION_LOGFILE pImlRedo
    )
{
    PIML_INISECTION_RECORD pSection;
    PIML_INIVARIABLE_RECORD pVariable;
    POFFSET Variables, Sections;

    pSection = MP( PIML_INISECTION_RECORD, pImlUndo, pIni->Sections );
    Sections = 0;
    while (pSection != NULL) {
        pVariable = MP( PIML_INIVARIABLE_RECORD, pImlUndo, pSection->Variables );
        Variables = 0;
        while (pVariable != NULL) {
            ImlAddIniVariableRecord( pImlRedo,
                                     pVariable->Action,
                                     MP( PWSTR, pImlUndo, pVariable->Name ),
                                     MP( PWSTR, pImlUndo, pVariable->OldValue ),
                                     MP( PWSTR, pImlUndo, pVariable->NewValue ),
                                     &Variables
                                   );

            pVariable = MP( PIML_INIVARIABLE_RECORD, pImlUndo, pVariable->Next );
            }

        if (Variables != 0) {
            ImlAddIniSectionRecord( pImlRedo,
                                    pSection->Action,
                                    MP( PWSTR, pImlUndo, pSection->Name ),
                                    Variables,
                                    &Sections
                                  );
            }

        pSection = MP( PIML_INISECTION_RECORD, pImlUndo, pSection->Next );
        }

    if (Sections != 0) {
        ImlAddIniRecord( pImlRedo,
                         pIni->Action,
                         MP( PWSTR, pImlUndo, pIni->Name ),
                         &pIni->LastWriteTime,
                         Sections
                       );
        }

    return TRUE;
}


int
ProcessUndoIml(
    PINSTALLATION_MODIFICATION_LOGFILE pImlUndo,
    PINSTALLATION_MODIFICATION_LOGFILE pImlRedo
    )
{
    PIML_FILE_RECORD pFile;
    PIML_KEY_RECORD pKey;
    PIML_INI_RECORD pIni;

    if (pImlUndo->NumberOfFileRecords > 0) {
        printf( "Undoing File Modifications:\n" );
        pFile = MP( PIML_FILE_RECORD, pImlUndo, pImlUndo->FileRecords );
        while (pFile != NULL) {
            if (pFile->Name != 0) {
                if (pImlRedo != NULL) {
                    ProcessRedoFileIml( pImlUndo, pFile, pImlRedo );
                    }

                ProcessUndoFileIml( pImlUndo, pFile );
                }

            pFile = MP( PIML_FILE_RECORD, pImlUndo, pFile->Next );
            }

        printf( "\n" );
        }

    if (pImlUndo->NumberOfKeyRecords > 0) {
        printf( "Undoing Registry Modifications:\n" );
        pKey = MP( PIML_KEY_RECORD, pImlUndo, pImlUndo->KeyRecords );
        while (pKey != NULL) {
            if (pImlRedo != NULL) {
                ProcessRedoKeyIml( pImlUndo, pKey, pImlRedo );
                }

            ProcessUndoKeyIml( pImlUndo, pKey );

            pKey = MP( PIML_KEY_RECORD, pImlUndo, pKey->Next );
            }

        printf( "\n" );
        }

    if (pImlUndo->NumberOfIniRecords > 0) {
        printf( "Undoing .INI File modifications:\n" );
        pIni = MP( PIML_INI_RECORD, pImlUndo, pImlUndo->IniRecords );
        while (pIni != NULL) {
            if (pImlRedo != NULL) {
                ProcessRedoIniIml( pImlUndo, pIni, pImlRedo );
                }

            ProcessUndoIniIml( pImlUndo, pIni);

            pIni = MP( PIML_INI_RECORD, pImlUndo, pIni->Next );
            }
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\i386\machine.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    machine.c

Abstract:

    This file contains machine specific code to support the INSTALER
    program.  Specifically, routines to fetch parameters from the
    registers/stack of a target process, routines to set a breakpoint
    and step over an instruction at a breakpoint.

Author:

    Steve Wood (stevewo) 10-Aug-1994

Revision History:

--*/

#include "instaler.h"

#define BREAKPOINT_OPCODE 0xCC
#define INT_OPCODE 0xCD

UCHAR InstructionBuffer = BREAKPOINT_OPCODE;
PVOID BreakpointInstruction = (PVOID)&InstructionBuffer;
ULONG SizeofBreakpointInstruction = sizeof( InstructionBuffer );

BOOLEAN
SkipOverHardcodedBreakpoint(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PVOID BreakpointAddress
    )
{
    UCHAR InstructionByte;
    CONTEXT Context;

    Context.ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to get context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }

    if (!ReadMemory( Process,
                     BreakpointAddress,
                     &InstructionByte,
                     sizeof( InstructionByte ),
                     "hard coded breakpoint"
                   )
       ) {
        return FALSE;
        }

    if (InstructionByte == BREAKPOINT_OPCODE) {
        Context.Eip = (ULONG)((PCHAR)BreakpointAddress + 1);
        }
    else
    if (InstructionByte == INT_OPCODE) {
        Context.Eip = (ULONG)((PCHAR)BreakpointAddress + 2);
        }
    else {
        return FALSE;
        }

    if (!SetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to set context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }
    else {
        return TRUE;
        }
}


BOOLEAN
ExtractProcedureParameters(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PULONG ReturnAddress,
    ULONG SizeOfParameters,
    PULONG Parameters
    )
{
    UINT i;
    ULONG NumberOfParameters;
    CONTEXT Context;
    ULONG StackBuffer[ 1+31 ];

    NumberOfParameters = SizeOfParameters / sizeof( ULONG );
    if ((NumberOfParameters * sizeof( ULONG )) != SizeOfParameters ||
        NumberOfParameters > 31
       ) {
        DbgEvent( INTERNALERROR, ( "Invalid parameter size %x\n", SizeOfParameters ) );
        return FALSE;
        }

    Context.ContextFlags = CONTEXT_CONTROL;
    if (!GetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to get context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }

    if (!ReadMemory( Process,
                     (PVOID)Context.Esp,
                     StackBuffer,
                     SizeOfParameters +  sizeof( ULONG ),
                     "parameters"
                   )
       ) {
        return FALSE;
        }

    *ReturnAddress = StackBuffer[ 0 ];
    for (i=0; i<NumberOfParameters; i++) {
        Parameters[ i ] = StackBuffer[ 1+i ];
        }

    return TRUE;
}


BOOLEAN
ExtractProcedureReturnValue(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PVOID ReturnValue,
    ULONG SizeOfReturnValue
    )
{
    CONTEXT Context;

    Context.ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to get context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }

    switch (SizeOfReturnValue) {
        case sizeof( UCHAR ):
            *(PUCHAR)ReturnValue = (UCHAR)Context.Eax;
            break;
        case sizeof( USHORT ):
            *(PUSHORT)ReturnValue = (USHORT)Context.Eax;
            break;
        case sizeof( ULONG ):
            *(PULONG)ReturnValue = (ULONG)Context.Eax;
            break;
        case sizeof( ULONGLONG ):
            *(PULONGLONG)ReturnValue = (ULONGLONG)Context.Edx << 32 | Context.Eax;
            break;
        default:
            DbgEvent( INTERNALERROR, ( "Invalid return value size (%u)\n", SizeOfReturnValue ) );
            return FALSE;
        }

    return TRUE;
}

BOOLEAN
SetProcedureReturnValue(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    PVOID ReturnValue,
    ULONG SizeOfReturnValue
    )
{
    CONTEXT Context;

    Context.ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to get context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }

    switch (SizeOfReturnValue) {
        case sizeof( UCHAR ):
            (UCHAR)Context.Eax = *(PUCHAR)ReturnValue;
            break;
        case sizeof( USHORT ):
            (USHORT)Context.Eax = *(PUSHORT)ReturnValue;
            break;
        case sizeof( ULONG ):
            (ULONG)Context.Eax = *(PULONG)ReturnValue;
            break;
        case sizeof( ULONGLONG ):
            (ULONG)Context.Eax = *(PULONG)ReturnValue;
            (ULONG)Context.Edx = *((PULONG)ReturnValue + 1);
            break;
        default:
            DbgEvent( INTERNALERROR, ( "Invalid return value size (%u)\n", SizeOfReturnValue ) );
            return FALSE;
        }

    if (!SetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to set context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }
    else {
        return TRUE;
        }
}

BOOLEAN
ForceReturnToCaller(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread,
    ULONG SizeOfParameters,
    PVOID ReturnAddress,
    PVOID ReturnValue,
    ULONG SizeOfReturnValue
    )
{
    CONTEXT Context;

    Context.ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to get context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }

    switch (SizeOfReturnValue) {
        case sizeof( UCHAR ):
            (UCHAR)Context.Eax = *(PUCHAR)ReturnValue;
            break;
        case sizeof( USHORT ):
            (USHORT)Context.Eax = *(PUSHORT)ReturnValue;
            break;
        case sizeof( ULONG ):
            (ULONG)Context.Eax = *(PULONG)ReturnValue;
            break;
        case sizeof( ULONGLONG ):
            (ULONG)Context.Eax = *(PULONG)ReturnValue;
            (ULONG)Context.Edx = *((PULONG)ReturnValue + 1);
            break;
        default:
            DbgEvent( INTERNALERROR, ( "Invalid return value size (%u)\n", SizeOfReturnValue ) );
            return FALSE;
        }

    Context.Eip = (ULONG)ReturnAddress;
    Context.Esp = Context.Esp + sizeof( ReturnAddress ) + SizeOfParameters;

    if (!SetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to set context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }
    else {
        return TRUE;
        }
}



BOOLEAN
UndoReturnAddressBreakpoint(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    )
{
    CONTEXT Context;

    Context.ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to get context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }

    Context.Eip -= 1;       // Back up to where breakpoint instruction was
    if (!SetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to set context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }
    else {
        return TRUE;
        }
}


BOOLEAN
BeginSingleStepBreakpoint(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    )
{
    CONTEXT Context;

    Context.ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to get context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }

    Context.Eip -= 1;       // Back up to where breakpoint instruction was
    Context.EFlags |= V86FLAGS_TRACE;
    if (!SetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to set context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }
    else {
        return TRUE;
        }
}


BOOLEAN
EndSingleStepBreakpoint(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    )
{
    CONTEXT Context;

    Context.ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to get context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }

    Context.EFlags &= ~V86FLAGS_TRACE;
    if (!SetThreadContext( Thread->Handle, &Context )) {
        DbgEvent( INTERNALERROR, ( "Failed to set context for thread %x (%x) - %u\n", Thread->Id, Thread->Handle, GetLastError() ) );
        return FALSE;
        }
    else {
        return TRUE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\instaler\testins2.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    testins2.c

Abstract:

    This is a test program that issues various Kernel 32 file/registry/INI file
    API calls so that we can see if the INSTALER program figures out correctly
    what is being done.

Author:

    Steve Wood (stevewo) 13-Aug-1994

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>

UCHAR AnsiBuffer[ MAX_PATH ];
WCHAR UnicodeBuffer[ MAX_PATH ];


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    FILE *File0;
    FILE *File1;
    FILE *File2;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN TranslationStatus;
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    UNICODE_STRING KeyName;
    UNICODE_STRING SubKeyName;
    UNICODE_STRING ValueName;
    HANDLE FileHandle, FindHandle, KeyHandle, SubKeyHandle;
    ULONG ValueDWord = 0x12345679;
    WIN32_FIND_DATAW FindFileData;
    LPSTR s1;
    PWSTR s2;
    UCHAR AnsiBuffer[ MAX_PATH ];
    WCHAR UnicodeBuffer[ MAX_PATH ];
    DWORD dwVersion;
    OSVERSIONINFO VersionInfo;
    HKEY hKey;

    //
    // File operations we want to test:
    //
    //  Creating a new file.
    //  Deleting that file using DeleteFile (which does NtOpenFile and NtSetInformationFile
    //  with Delete Dispostion).  (INSTALER should use this to forget about create).
    //  Creating a new file with the same name.
    //  Deleting that file using NtDeleteFile.  (again INSTALER should not care).
    //
    //  Open the TEST1 file for read access (INSTALER should not care).
    //  Open the TEST2 file for write access (INSTALER should not care).
    //  Open the TEST2 file for write access (INSTALER should not care).
    //  Open the TEST2 file for write access (INSTALER should not care).
    //
    //

    // printf( "TEST: GetFileAttributes( .\\test1 )\n" );
    GetFileAttributesA( ".\\test1" );
#if 0
    dwVersion = GetVersion();
    if ((dwVersion >> 30) ^ 0x2 == VER_PLATFORM_WIN32_WINDOWS) {
        printf( "GetVersion returns Windows 95\n" );
        }
    else
    if ((dwVersion >> 30) ^ 0x2 == VER_PLATFORM_WIN32_NT) {
        printf( "GetVersion returns Windows NT\n" );
        }
    else {
        printf( "GetVersion returns %x\n", dwVersion );
        }
    fflush(stdout);

    VersionInfo.dwOSVersionInfoSize = sizeof( VersionInfo );
    GetVersionEx( &VersionInfo );
    if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
        printf( "GetVersionEx returns Windows 95\n" );
        }
    else
    if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        printf( "GetVersionEx returns Windows NT\n" );
        }
    else {
        printf( "GetVersionEx returns %x\n", VersionInfo.dwPlatformId );
        }
    fflush(stdout);

    if (RegConnectRegistryA( "\\\\stevewo_dbgr", HKEY_USERS, &hKey )) {
        printf( "RegConnectRegistryA( \\stevewo_dbgr ) failed (hKey == %x).\n", hKey );
        }
    else {
        printf( "RegConnectRegistryA( \\stevewo_dbgr ) succeeded (hKey == %x).\n", hKey );
        RegCloseKey( hKey );
        }

    if (RegConnectRegistryW( L"\\\\stevewo_dbgr", HKEY_USERS, &hKey )) {
        printf( "RegConnectRegistryW( \\stevewo_dbgr ) failed (hKey == %x).\n", hKey );
        }
    else {
        printf( "RegConnectRegistryW( \\stevewo_dbgr ) succeeded (hKey == %x).\n", hKey );
        RegCloseKey( hKey );
        }
#endif

    RtlInitUnicodeString( &FileName, L"\\DosDevices\\A:" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    // printf( "TEST: NtOpenFile( %wZ ) should succeed without touching floppy.\n", &FileName );
    Status = NtOpenFile( &FileHandle,
                         SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                       );
    if (!NT_SUCCESS( Status )) {
        printf( "TEST: Failed - Status == %x\n", Status );
        }
    else {
        NtClose( FileHandle );
        }

    // printf( "TEST: FindFirstFileW( C:\\*.* should fail.\n" );
    FindHandle = FindFirstFileW( L"C:\\*.*", &FindFileData );
    if (FindHandle != INVALID_HANDLE_VALUE) {
        printf( "TEST: *** oops, it worked.\n" );
        FindClose( FindHandle );
        }
    // printf( "TEST: FindFirstFileW( \\TMP\\*.* should work.\n" );
    FindHandle = FindFirstFileW( L"\\TMP\\*.*", &FindFileData );
    if (FindHandle == INVALID_HANDLE_VALUE) {
        printf( "TEST: *** oops, it failed.\n" );
        }
    else {
        FindClose( FindHandle );
        }

    // printf( "TEST: opening .\\test0 for write access.\n" );
    if (File0 = fopen( "test0.", "w" )) {
        fprintf( File0, "This is test file 0\n" );
        // printf( "TEST: closing .\\test0\n" );
        fclose( File0 );
        // printf( "TEST: deleting .\\test0 using DeleteFile (open, set, close)\n" );
        DeleteFile( L"test0" );
        }

    // printf( "TEST: opening .\\test0 for write access.\n" );
    if (File0 = fopen( "test0.", "w" )) {
        fprintf( File0, "This is test file 0\n" );
        // printf( "TEST: closing .\\test0\n" );
        fclose( File0 );
#if 0
        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                L"test0",
                                &FileName,
                                NULL,
                                &RelativeName
                                );

        if (TranslationStatus ) {
            FreeBuffer = FileName.Buffer;
            if ( RelativeName.RelativeName.Length ) {
                FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
                }
            else {
                RelativeName.ContainingDirectory = NULL;
                }

            InitializeObjectAttributes( &ObjectAttributes,
                                        &FileName,
                                        OBJ_CASE_INSENSITIVE,
                                        RelativeName.ContainingDirectory,
                                        NULL
                                      );
            // printf( "TEST: deleting .\\test0 using NtDeleteFile\n" );
            Status = NtDeleteFile( &ObjectAttributes );
            RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );
            }
#endif
        }

    // printf( "TEST: opening .\\test1 for write access.\n" );
    if (File1 = fopen( "test1.", "w" )) {
        fprintf( File1, "This is test file 1a\n" );
        // printf( "TEST: closing .\\test1\n" );
        fclose( File1 );
        }

    // printf( "TEST: opening .\\test2 for write access (Instaler should noticed contents different)\n" );
    if (File2 = fopen( "test2.", "w" )) {
        fprintf( File2, "This is test file 2\n" );
        // printf( "TEST: closing .\\test2\n" );
        fclose( File2 );
        }

    // printf( "TEST: opening .\\test0.tmp for write access.\n" );
    if (File0 = fopen( "test0.tmp", "w" )) {
        fprintf( File0, "This is test file tmp files\n" );
        // printf( "TEST: closing .\\test0.tmp\n" );
        fclose( File0 );
        // printf( "TEST: deleting .\\test0 using DeleteFile (open, set, close)\n" );
        rename("test0.tmp", "test0.fin");
        }
    rename("test1.", "test2.fin");
    rename("test3.", "test3.fin");

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\Software\\Test" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    // printf( "TEST: opening %wZ for write access\n", &KeyName );
    Status = NtOpenKey( &KeyHandle,
                        KEY_WRITE,
                        &ObjectAttributes
                      );
    if (NT_SUCCESS( Status )) {
        RtlInitUnicodeString( &ValueName, L"Test0" );
        // printf( "TEST: setting %wZ . %wZ value\n", &KeyName, &ValueName );
        Status = NtSetValueKey( KeyHandle,
                                &ValueName,
                                0,
                                REG_SZ,
                                "1",
                                2 * sizeof( WCHAR )
                              );

        RtlInitUnicodeString( &ValueName, L"Test1" );
        // printf( "TEST: deleting %wZ . %wZ value\n", &KeyName, &ValueName );
        Status = NtDeleteValueKey( KeyHandle,
                                   &ValueName
                                 );

        RtlInitUnicodeString( &ValueName, L"Test2" );
        // printf( "TEST: setting %wZ . %wZ value\n", &KeyName, &ValueName );
        Status = NtSetValueKey( KeyHandle,
                                &ValueName,
                                0,
                                REG_DWORD,
                                &ValueDWord,
                                sizeof( ValueDWord )
                              );
        RtlInitUnicodeString( &SubKeyName, L"Test3" );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &SubKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    KeyHandle,
                                    NULL
                                  );
        // printf( "TEST: opening %wZ\\%wZ for write access\n", &KeyName, &SubKeyName );
        Status = NtOpenKey( &SubKeyHandle,
                            DELETE | KEY_WRITE,
                            &ObjectAttributes
                          );
        if (NT_SUCCESS( Status )) {
            // printf( "TEST: deleting %wZ\\%wZ key and values\n", &KeyName, &SubKeyName );
            Status = NtDeleteKey( SubKeyHandle );
            NtClose( SubKeyHandle );
            }

        RtlInitUnicodeString( &SubKeyName, L"Test4" );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &SubKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    KeyHandle,
                                    NULL
                                  );
        // printf( "TEST: creating %wZ\\%wZ for write access\n", &KeyName, &SubKeyName );
        Status = NtCreateKey( &SubKeyHandle,
                              DELETE | KEY_WRITE,
                              &ObjectAttributes,
                              0,
                              NULL,
                              0,
                              NULL
                            );
        if (NT_SUCCESS( Status )) {
            RtlInitUnicodeString( &ValueName, L"Test4" );
            // printf( "TEST: creating %wZ\\%wZ %wZ value\n", &KeyName, &SubKeyName, &ValueName );
            Status = NtSetValueKey( SubKeyHandle,
                                    &ValueName,
                                    0,
                                    REG_DWORD,
                                    &ValueDWord,
                                    sizeof( ValueDWord )
                                  );
            NtClose( SubKeyHandle );
            }

        RtlInitUnicodeString( &SubKeyName, L"Test5" );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &SubKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    KeyHandle,
                                    NULL
                                  );
        // printf( "TEST: creating %wZ\\%wZ for write access\n", &KeyName, &SubKeyName );
        Status = NtCreateKey( &SubKeyHandle,
                              DELETE | KEY_WRITE,
                              &ObjectAttributes,
                              0,
                              NULL,
                              0,
                              NULL
                            );
        if (NT_SUCCESS( Status )) {
            RtlInitUnicodeString( &ValueName, L"Test5" );
            // printf( "TEST: creating %wZ\\%wZ %wZ value\n", &KeyName, &SubKeyName, &ValueName );
            Status = NtSetValueKey( SubKeyHandle,
                                    &ValueName,
                                    0,
                                    REG_DWORD,
                                    &ValueDWord,
                                    sizeof( ValueDWord )
                                  );
            // printf( "TEST: deleting %wZ\\%wZ key and values\n", &KeyName, &SubKeyName );
            Status = NtDeleteKey( SubKeyHandle );
            NtClose( SubKeyHandle );
            }

        NtClose( KeyHandle );
        }

    GetPrivateProfileStringA( "test", NULL, "",
                              AnsiBuffer,
                              sizeof( AnsiBuffer ),
                              ".\\test.ini"
                            );

    GetPrivateProfileStringW( L"test", NULL, L"",
                              UnicodeBuffer,
                              sizeof( UnicodeBuffer ),
                              L".\\test.ini"
                            );


    if (!SetCurrentDirectoryA( ".." )) {
        printf( "TEST: SetCurrentDirectory to '..' failed (%u)\n", GetLastError() );
        }

    WriteProfileString( L"fonts", L"FooBar", L"2" );

    WriteProfileString( L"fonts", L"Rockwell Italic (TrueType)", L"ROCKI.FOT" );

    if (!SetCurrentDirectoryW( L"test" )) {
        printf( "TEST: SetCurrentDirectory to 'test' failed (%u)\n", GetLastError() );
        }

    WritePrivateProfileStringA( "test", "test1", "-1", ".\\test.ini" );

    WritePrivateProfileStringW( L"test", L"test1", L"-3", L".\\test.ini" );

    WritePrivateProfileSectionA( "test1", "test0=0\0test1=1\0test2=2\0", ".\\test.ini" );

    WritePrivateProfileSectionW( L"test2", L"test0=0\0test1=2\0test2=2\0", L".\\test.ini" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\acpi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    acpi.c

Abstract:

    WinDbg Extension Api for interpretting ACPI data structures
    Supports rsdt, fadt, facs, mapic, gbl and inf

Author:

    Ported to 64 bit by Graham Laverty (t-gralav) 10-Mar-2000

    Based on Code by:
        Stephane Plante (splante) 21-Mar-1997
        Peter Wieland (peterwie) 16-Oct-1995
        Ken Reneris (kenr) 06-June-1994

Environment:

    User Mode.

Revision History:

   Ported to 64 bit by Graham Laverty (t-gralav) 10-Mar-2000

--*/
#include "precomp.h"
#pragma hdrstop // Needed ? (what does it do?)

//
// Verbose flags (for device extensions)
//
#define VERBOSE_1       0x01
#define VERBOSE_2       0x02

//
// BUG BUG
// These need to be converted to enums in the ACPI Driver
//

#define DATAF_BUFF_ALIAS        0x00000001
#define DATAF_GLOBAL_LOCK       0x00000002
#define OBJTYPE_UNKNOWN         0x00
#define OBJTYPE_INTDATA         0x01
#define OBJTYPE_STRDATA         0x02
#define OBJTYPE_BUFFDATA        0x03
#define OBJTYPE_PKGDATA         0x04
#define OBJTYPE_FIELDUNIT       0x05
#define OBJTYPE_DEVICE          0x06
#define OBJTYPE_EVENT           0x07
#define OBJTYPE_METHOD          0x08
#define OBJTYPE_MUTEX           0x09
#define OBJTYPE_OPREGION        0x0a
#define OBJTYPE_POWERRES        0x0b
#define OBJTYPE_PROCESSOR       0x0c
#define OBJTYPE_THERMALZONE     0x0d
#define OBJTYPE_BUFFFIELD       0x0e
#define OBJTYPE_DDBHANDLE       0x0f
#define OBJTYPE_DEBUG           0x10
#define OBJTYPE_INTERNAL        0x80
#define OBJTYPE_OBJALIAS        (OBJTYPE_INTERNAL + 0x00)
#define OBJTYPE_DATAALIAS       (OBJTYPE_INTERNAL + 0x01)
#define OBJTYPE_BANKFIELD       (OBJTYPE_INTERNAL + 0x02)
#define OBJTYPE_FIELD           (OBJTYPE_INTERNAL + 0x03)
#define OBJTYPE_INDEXFIELD      (OBJTYPE_INTERNAL + 0x04)
#define OBJTYPE_DATA            (OBJTYPE_INTERNAL + 0x05)
#define OBJTYPE_DATAFIELD       (OBJTYPE_INTERNAL + 0x06)
#define OBJTYPE_DATAOBJ         (OBJTYPE_INTERNAL + 0x07)

// definition of FADT.flags bits

// this one bit flag indicates whether or not the WBINVD instruction works properly,if this bit is not set we can not use S2, S3 states, or
// C3 on MP machines
#define         WRITEBACKINVALIDATE_WORKS_BIT           0
#define         WRITEBACKINVALIDATE_WORKS               (1 << WRITEBACKINVALIDATE_WORKS_BIT)

//  this flag indicates if wbinvd works EXCEPT that it does not invalidate the cache
#define         WRITEBACKINVALIDATE_DOESNT_INVALIDATE_BIT   1
#define         WRITEBACKINVALIDATE_DOESNT_INVALIDATE       (1 << WRITEBACKINVALIDATE_DOESNT_INVALIDATE_BIT)

//  this flag indicates that the C1 state is supported on all processors.
#define         SYSTEM_SUPPORTS_C1_BIT                  2
#define         SYSTEM_SUPPORTS_C1                      (1 << SYSTEM_SUPPORTS_C1_BIT)

// this one bit flag indicates whether support for the C2 state is restricted to uniprocessor machines
#define         P_LVL2_UP_ONLY_BIT                      3
#define         P_LVL2_UP_ONLY                          (1 << P_LVL2_UP_ONLY_BIT)

//      this bit indicates whether the PWR button is treated as a fix feature (0) or a generic feature (1)
#define         PWR_BUTTON_GENERIC_BIT                  4
#define         PWR_BUTTON_GENERIC                      (1 << PWR_BUTTON_GENERIC_BIT)

#define         SLEEP_BUTTON_GENERIC_BIT                5
#define         SLEEP_BUTTON_GENERIC                    (1 << SLEEP_BUTTON_GENERIC_BIT)
//      this bit indicates whether the RTC wakeup status is reported in fix register space (0) or not (1)
#define         RTC_WAKE_GENERIC_BIT                    6
#define         RTC_WAKE_GENERIC                        (1 << RTC_WAKE_GENERIC_BIT)

#define         RTC_WAKE_FROM_S4_BIT                    7
#define         RTC_WAKE_FROM_S4                        (1 << RTC_WAKE_FROM_S4_BIT)

// This bit indicates whether the machine implements a 24 or 32 bit timer.
#define         TMR_VAL_EXT_BIT                         8
#define         TMR_VAL_EXT                             (1 << TMR_VAL_EXT_BIT)

// This bit indicates whether the machine supports docking
//#define         DCK_CAP_BIT                             9
//#define         DCK_CAP                                 (1 << DCK_CAP_BIT)

// This bit indicates whether the machine supports reset
#define         RESET_CAP_BIT                           10
#define         RESET_CAP                               (1 << RESET_CAP_BIT)


//
// Definition of FADT.boot_arch flags
//

#define LEGACY_DEVICES  1
#define I8042           2

//
// Verbose flags (for contexts)
//

#define VERBOSE_CONTEXT 0x01
#define VERBOSE_CALL    0x02
#define VERBOSE_HEAP    0x04
#define VERBOSE_OBJECT  0x08
#define VERBOSE_NSOBJ   0x10
#define VERBOSE_RECURSE 0x20

UCHAR  Buffer[2048];
#define RSDP_SIGNATURE 0x2052545020445352       // "RSD PTR "
#define RSDT_SIGNATURE 0x54445352               // "RSDT"
#define FADT_SIGNATURE  0x50434146      // "FACP"
#define FACS_SIGNATURE  0x53434146      // "FACS"
#define APIC_SIGNATURE  0x43495041      // "APIC"

#ifndef NEC_98
#define RSDP_SEARCH_RANGE_BEGIN         0xE0000         // physical address where we begin searching for the RSDP
#else   // NEC_98
#define RSDP_SEARCH_RANGE_BEGIN         0xE8000         // physical address where we begin searching for the RSDP
#endif  // NEC_98
#define RSDP_SEARCH_RANGE_END           0xFFFFF
#define RSDP_SEARCH_RANGE_LENGTH        (RSDP_SEARCH_RANGE_END-RSDP_SEARCH_RANGE_BEGIN+1)
#define RSDP_SEARCH_INTERVAL            16      // search on 16 byte boundaries

// FACS Stuff ************************************************************************************

// FACS Flags definitions

#define         FACS_S4BIOS_SUPPORTED_BIT   0   // flag indicates whether or not the BIOS will save/restore memory around S4
#define         FACS_S4BIOS_SUPPORTED       (1 << FACS_S4BIOS_SUPPORTED_BIT)

// FACS.GlobalLock bit field definitions

#define         GL_PENDING_BIT          0x00
#define         GL_PENDING                      (1 << GL_PENDING_BIT)

#define         GL_OWNER_BIT            0x01
#define         GL_OWNER                        (1 << GL_OWNER_BIT)

//#define GL_NON_RESERVED_BITS_MASK       (GL_PENDING+GL_OWNED)


// MAPIC Stuff ************************************************************************************

// Multiple APIC description table


// Multiple APIC structure flags

#define PCAT_COMPAT_BIT 0   // indicates that the system also has a dual 8259 pic setup.
#define PCAT_COMPAT     (1 << PCAT_COMPAT_BIT)

// APIC Structure Types
#define PROCESSOR_LOCAL_APIC            0
#define IO_APIC                         1
#define ISA_VECTOR_OVERRIDE             2
#define IO_NMI_SOURCE                   3
#define LOCAL_NMI_SOURCE                4
#define ADDRESS_EXTENSION_STRUCTURE         5
#define IO_SAPIC                            6
#define LOCAL_SAPIC                         7
#define PLATFORM_INTERRUPT_SOURCE           8
#define PROCESSOR_LOCAL_APIC_LENGTH     8
#define IO_APIC_LENGTH                  12
#define ISA_VECTOR_OVERRIDE_LENGTH          10

#define IO_NMI_SOURCE_LENGTH            8
#define LOCAL_NMI_SOURCE_LENGTH         6
#define PLATFORM_INTERRUPT_SOURCE_LENGTH    16
#define IO_SAPIC_LENGTH                     16
#define PROCESSOR_LOCAL_SAPIC_LENGTH        12

// Platform Interrupt Types
#define PLATFORM_INT_PMI  1
#define PLATFORM_INT_INIT 2
#define PLATFORM_INT_CPE  3

// Processor Local APIC Flags
#define PLAF_ENABLED_BIT    0
#define PLAF_ENABLED        (1 << PLAF_ENABLED_BIT)

// These defines come from the MPS 1.4 spec, section 4.3.4 and they are referenced as
// such in the ACPI spec.
#define PO_BITS                     3
#define POLARITY_HIGH               1
#define POLARITY_LOW                3
#define POLARITY_CONFORMS_WITH_BUS  0
#define EL_BITS                     0xc
#define EL_BIT_SHIFT                2
#define EL_EDGE_TRIGGERED           4
#define EL_LEVEL_TRIGGERED          0xc
#define EL_CONFORMS_WITH_BUS        0

#define FADT_REV_1_SIZE 116
#define FADT_REV_2_SIZE 129
#define FADT_REV_3_SIZE 244


// GBL Stuff ************************************************************************************

    //
    // This structure lets us know the state of one entry in the RSDT
    //


// INF Stuff ************************************************************************************

    //
    // descriptions of bits in ACPIInformation.ACPI_Flags
    //
    #define C2_SUPPORTED_BIT        3
    #define C2_SUPPORTED            (1 << C2_SUPPORTED_BIT)

    #define C3_SUPPORTED_BIT        4
    #define C3_SUPPORTED            (1 << C3_SUPPORTED_BIT)

    #define C3_PREFERRED_BIT        5
    #define C3_PREFERRED            (1 << C3_PREFERRED_BIT)

    //
    // descriptions of bits in ACPIInformation.ACPI_Capabilities
    //
    #define CSTATE_C1_BIT           4
    #define CSTATE_C1               (1 << CSTATE_C1_BIT)

    #define CSTATE_C2_BIT           5
    #define CSTATE_C2               (1 << CSTATE_C2_BIT)

    #define CSTATE_C3_BIT           6
    #define CSTATE_C3               (1 << CSTATE_C3_BIT)

    #define DUMP_FLAG_NO_INDENT         0x000001
    #define DUMP_FLAG_NO_EOL            0x000002
    #define DUMP_FLAG_SINGLE_LINE       0x000004
    #define DUMP_FLAG_TABLE             0x000008
    #define DUMP_FLAG_LONG_NAME         0x000010
    #define DUMP_FLAG_SHORT_NAME        0x000020
    #define DUMP_FLAG_SHOW_BIT          0x000040
    #define DUMP_FLAG_ALREADY_INDENTED  0x000080

    typedef struct _FLAG_RECORD {
        ULONGLONG   Bit;
        PCCHAR      ShortName;
        PCCHAR      LongName;
        PCCHAR      NotShortName;
        PCCHAR      NotLongName;
    } FLAG_RECORD, *PFLAG_RECORD;

FLAG_RECORD PM1ControlFlags[] = {
    { 0x0001, "", "SCI_EN" , NULL, NULL },
    { 0x0002, "", "BM_RLD" , NULL, NULL },
    { 0x0004, "", "GBL_RLS" , NULL, NULL },
    { 0x0400, "", "SLP_TYP0" , NULL, NULL },
    { 0x0800, "", "SLP_TYP1" , NULL, NULL },
    { 0x1000, "", "SLP_TYP2" , NULL, NULL  },
    { 0x2000, "", "SLP_EN" , NULL, NULL  },
};

FLAG_RECORD PM1StatusFlags[] = {
    { 0x0001, "", "TMR_STS" , NULL, NULL },
    { 0x0010, "", "BM_STS" , NULL, NULL },
    { 0x0020, "", "GBL_STS" , NULL, NULL },
    { 0x0100, "", "PWRBTN_STS" , NULL, NULL },
    { 0x0200, "", "SLPBTN_STS" , NULL, NULL },
    { 0x0400, "", "RTC_STS" , NULL, NULL },
    { 0x8000, "", "WAK_STS" , NULL, NULL },
};

FLAG_RECORD PM1EnableFlags[] = {
    { 0x0001, "", "TMR_EN" , NULL, NULL },
    { 0x0020, "", "GBL_EN" , NULL, NULL },
    { 0x0100, "", "PWRBTN_EN" , NULL, NULL },
    { 0x0200, "", "SLPBTN_EN" , NULL, NULL },
    { 0x0400, "", "RTC_EN" , NULL, NULL },
};


#define RSDTELEMENT_MAPPED      0x1


ULONG64              AcpiRsdtAddress = 0;
ULONG64              AcpiFadtAddress = 0;
ULONG64              AcpiFacsAddress = 0;
ULONG64              AcpiMapicAddress = 0;

//
// Local Function Prototypes
//

VOID dumpNSObject(IN ULONG64 Address, IN ULONG Verbose, IN ULONG IndentLevel);

//
// Actual code
//


BOOL
ReadPhysicalOrVirtual(
    IN      ULONG64 Address,
    IN      PVOID   Buffer,
    IN      ULONG   Size,
    IN  OUT PULONG  ReturnLength,
    IN      BOOL    Virtual
    )
/*++

Routine Description:

    This is a way to abstract out the differences between ROM images
    and mapped memory

Arguments:

    Address         - Where (either physical, or virtual) the buffer is located
    Buffer          - Address of where to copy the memory to
    Size            - How many bytes to copy (maximum)
    ReturnLength    - How many bytes where copied
    Virtual         - False if this is physical memory

--*/
{
    BOOL                status = TRUE;
    PHYSICAL_ADDRESS    physicalAddress = { 0L, 0L };

    if (Virtual) {

        status = ReadMemory(
            Address,
            Buffer,
            Size,
            ReturnLength
            );

    } else {

        physicalAddress.QuadPart = Address;
        ReadPhysical(
            physicalAddress.QuadPart,
            Buffer,
            Size,
            ReturnLength
            );

    }

    if (ReturnLength && *ReturnLength != Size) {

        //
        // Didn't get enough memory
        //
        status = FALSE;

    }
    return status;
}


BOOLEAN
findRSDT(
    IN  PULONG64 Address
    )
/*++

Routine Description:

    This searchs the memory on the target system for the RSDT pointer

Arguments:

    Address - Where to store the result

Return Value:

    TRUE    - If we found the RSDT

--*/
{
    PHYSICAL_ADDRESS    address = { 0L, 0L };
    UCHAR               index;
    UCHAR               sum;
    ULONG64             limit;
    ULONG               returnLength = 0;
    ULONG64             start, initAddress;
    ULONGLONG           compSignature;
    ULONG               addr;
    int                 siz;


    //
    // Calculate the start and end of the search range
    //
    start = RSDP_SEARCH_RANGE_BEGIN;
    limit = start + RSDP_SEARCH_RANGE_LENGTH - RSDP_SEARCH_INTERVAL;

    dprintf( "Searching for RSDP.");

    //
    // Loop for a while
    //
    for (; start <= limit; start += RSDP_SEARCH_INTERVAL) {

        if (start % (RSDP_SEARCH_INTERVAL * 100 ) == 0) {

            dprintf(".");
            if (CheckControlC()) {
                return FALSE;
            }

        }
        //
        // Read the data from the target
        //
        address.LowPart = (ULONG) start;

        memset( Buffer, 0, GetTypeSize("hal!_RSDT_32") );
        ReadPhysical( address.QuadPart, &Buffer, GetTypeSize("hal!_RSDP"), &returnLength);

        if (returnLength != GetTypeSize("hal!_RSDP")) {

            dprintf(
                "%#08lx: Read %#08lx of %#08lx bytes\n",
                start,
                returnLength,
                GetTypeSize("hal!_RSDP")
                );
            return FALSE;

        }

        //
        // Is this a match?
        //

        // INIT TYPE READ PHYSICAL TAKES MAYBE 15 TIME LONGER!
        initAddress = InitTypeReadPhysical( address.QuadPart, hal!_RSDP );

        if ( ReadField(Signature) != RSDP_SIGNATURE) {

            continue;

        }

        //
        // Check the checksum out
        //
        for (index = 0, sum = 0; index < GetTypeSize("hal!_RSDP"); index++) {

            sum = (UCHAR) (sum + *( (UCHAR *) ( (ULONG64) &Buffer + index ) ) );

        }
        if (sum != 0) {

            continue;

        }

        //
        // Found RSDP
        //
        dprintf("\nRSDP - %016I64x\n", start );

        initAddress = InitTypeReadPhysical( address.QuadPart, hal!_RSDP );
// The following error message has been remarked out because the FIRST call to
// a InitTypeReadPhysical does NOT access the memory (and returns error 0x01:
// MEMORY_READ_ERROR.  This is done when ReadField happens, so IT STILL WORKS.
// The false error message is a kd bug, and will be fixed in a later build.
// Once this has been done, feel free to unremark it.
//        if (initAddress) {
//            dprintf("Failed to initialize hal!_RSDP.  Error code: %d.", initAddress);
//        }

        initAddress = ReadField(Signature);
        memset( Buffer, 0, 2048 );
        memcpy( Buffer, &initAddress, GetTypeSize("ULONGLONG") );
        dprintf("  Signature:   %s\n", Buffer );
        dprintf("  Checksum:    %#03x\n", (UCHAR) ReadField(Checksum) );

        initAddress = ReadField(OEMID);
        GetFieldOffset( "hal!_RSDP", "OEMID", &addr);
        memset( Buffer, 0, GetTypeSize("ULONGLONG") );
        ReadPhysical( (address.QuadPart + (ULONG64) addr), &Buffer, 6, &returnLength);
        if (returnLength != 6) { // 6 is hard-coded in the specs
            dprintf( "%#08lx: Read %#08lx of 6 bytes in OEMID\n", (address.QuadPart + (ULONG64)addr), returnLength, GetTypeSize("hal!_RSDP") );
            return FALSE;
        }
        dprintf("  OEMID:       %s\n", Buffer );
        dprintf("  Reserved:    %#02x\n", ReadField(Reserved) );
        dprintf("  RsdtAddress: %016I64x\n", ReadField(RsdtAddress) );

        //
        // Done
        //
        *Address = ReadField(RsdtAddress);//rsdp.RsdtAddress;
        return TRUE;

    }

    return FALSE;

}

PUCHAR
ReadPhysVirField(
    IN  ULONG64             Address,
    IN  PUCHAR              StructName,
    IN  PUCHAR              FieldName,
    IN  ULONG               Length,
    IN  BOOLEAN             Physical
    )
/*++

Routine Description:

    This function returns a text string field from physical or virtual memory
    into Buffer, then returns Buffer

Arugments:

    Address     - Where the table is located
    StructName  - Structure name
    FieldName   - Field name
    Length      - Length (number of characters) in field
    Physical    - Read from Physical (TRUE) or Virtual Memory

Return Value:

    String containing contents

--*/

{
        ULONG   addr;
        ULONG   returnLength;
        memset( Buffer, 0, Length + 1);
        GetFieldOffset( StructName, FieldName, &addr);
        if (Physical) {
            ReadPhysical( (Address + (ULONG64) addr), &Buffer, Length, &returnLength);
        } else {
            ReadMemory( (Address + (ULONG64) addr), &Buffer, Length, &returnLength);
        }
        return Buffer;
}

VOID
dumpHeader(
    IN  ULONG64             Address,
    IN  BOOLEAN             Verbose,
    IN  BOOLEAN             Physical
    )
/*++

Routine Description:

    This function dumps out a table header

Arugments:

    Address - Where the table is located
    Header  - The table header
    Verbose - How much information to give

Return Value:

    NULL

--*/
{
    if (Physical) {
        InitTypeReadPhysical( Address, hal!_DESCRIPTION_HEADER);
    } else {
        InitTypeRead( Address, hal!_DESCRIPTION_HEADER);
    }

    if (Verbose) {

        dprintf(
            "HEADER - %016I64x\n"
            "  Signature:               %s\n"
            "  Length:                  0x%08lx\n"
            "  Revision:                0x%02x\n"
            "  Checksum:                0x%02x\n",
            Address,
            ReadPhysVirField(Address, "hal!_DESCRIPTION_HEADER", "Signature", sizeof(ULONG), Physical),
            (ULONG) ReadField(Length),
            (UCHAR) ReadField(Revision),
            (UCHAR) ReadField(Checksum)
            );

        dprintf("  OEMID:                   %s\n", ReadPhysVirField(Address, "hal!_DESCRIPTION_HEADER", "OEMID", 6, Physical) );
        dprintf("  OEMTableID:              %s\n", ReadPhysVirField(Address, "hal!_DESCRIPTION_HEADER", "OEMTableID", 8, Physical) );
        dprintf("  OEMRevision:             0x%08lx\n", ReadField(OEMRevision) );
        dprintf("  CreatorID:               %s\n", ReadPhysVirField(Address, "hal!_DESCRIPTION_HEADER", "CreatorID", 4, Physical) );
        dprintf("  CreatorRev:              0x%08lx\n", ReadField(CreatorRev) );

    } else {

        dprintf(
            "  %s @(%016I64x) Rev: %#03x Len: %#08lx",
            ReadPhysVirField(Address, "hal!_DESCRIPTION_HEADER", "Signature", sizeof(ULONG64), Physical),
            Address,
            (UCHAR) ReadField(Revision),
            (ULONG) ReadField(Length)
            );
        dprintf(" TableID: %s\n", ReadPhysVirField(Address, "hal!_DESCRIPTION_HEADER", "OEMTableID", 8, Physical) );
    }
    return;
}

VOID
dumpRSDT(
    IN  ULONG64  Address,
    IN  BOOLEAN  Physical
    )
/*++

Routine Description:

    This search the dumps the RSDT table

Arguments:

    Pointer to the table

Return Value:

    NONE

--*/
{
    BOOL                status;
    ULONG64             index;
    ULONG64             numEntries;
    ULONG               addr;
    ULONG               returnLength = 0;
    ULONG64             a;

    dprintf("RSDT - ");

    if (Physical) { // The following do NOT have their status read as a bug in the return value would give us errors when none exist.  The signature check would catch them, anyway.
        InitTypeReadPhysical( Address, hal!_DESCRIPTION_HEADER);
    } else {
        InitTypeRead( Address, hal!_DESCRIPTION_HEADER);
    }

    if (ReadField(Signature) != RSDT_SIGNATURE) {
        dprintf(
            "dumpRSDT: Invalid Signature 0x%08lx != RSDT_SIGNATURE\n",
            ReadField(Signature)
            );
        dumpHeader( Address, TRUE, Physical );
        return;
    }

    dumpHeader( Address, TRUE, Physical );
    dprintf("RSDT - BODY - %016I64x\n", Address + GetTypeSize("hal!_DESCRIPTION_HEADER") );
    numEntries = ( ReadField(Length) - GetTypeSize("hal!_DESCRIPTION_HEADER") ) /
        sizeof(ULONG);
    GetFieldOffset( "hal!_RSDT_32", "Tables", &addr);

    for (index = 0; index < numEntries; index++) {

        //
        // Note: unless things radically change, the pointers in the
        // rsdt will always point to bios memory!
        //
        if (Physical) {
            ReadPhysical(Address + index + (ULONG64) addr, &a, 4, &returnLength);
        } else {
            ReadPointer(Address + index + (ULONG64) addr, &a);
        }
        dumpHeader( a, FALSE, TRUE );
    }

    return;
}

VOID
dumpFADT(
    IN  ULONG64   Address
    )
/*++

Routine Description:

    This dumps the FADT at the specified address

Arguments:

    The address where the FADT is located at

Return Value:

    NONE

--*/
{
    ULONG               fadtLength;
    ULONG               addr;
    ULONG               flags;
    UCHAR               Revision;
    UCHAR               AddressSpaceID;
    ULONG64             reset_reg_addr;
    PCHAR               addressSpace;
    BOOLEAN             Physical = FALSE;

    //
    // First check to see if we find the correct things
    //
    dprintf("FADT -- %p", Address);

    if (Physical) {
        InitTypeReadPhysical( Address, hal!_DESCRIPTION_HEADER);
    } else {
        InitTypeRead( Address, hal!_DESCRIPTION_HEADER);
    }

    if (ReadField(Signature) != FADT_SIGNATURE) {
        dprintf(
            "dumpRSDT: Invalid Signature 0x%08lx != FADT_SIGNATURE\n",
            ReadField(Signature)
            );
        dumpHeader( Address, TRUE, Physical );
        return;
    }

    Revision = (UCHAR)ReadField(Revision);
    
    if (Revision == 1) {
        fadtLength = FADT_REV_1_SIZE;
    } else if (Revision == 2) {
        fadtLength = FADT_REV_2_SIZE;
    } else if (Revision == 3) {
        fadtLength = FADT_REV_3_SIZE;
    } else {
        dprintf("FADT revision is %d, which is not understood by this debugger\n", Revision);
        fadtLength = FADT_REV_3_SIZE;
    }


    //
    // Do we have a correctly sized data structure
    //

    if ((ULONG) ReadField(Length) < fadtLength) {

        dprintf(
            "dumpFADT: (%016I64x) Length (%#08lx) is not the size of the FADT (%#08lx)\n",
            Address,
            (ULONG) ReadField(Length),
            fadtLength
            );
        dumpHeader( Address, TRUE, Physical );
        return;

    }

    //
    // Dump the table
    //
    dumpHeader( Address, TRUE, Physical );

    if (Physical) { // Physical/Virtual should have been established above
        InitTypeReadPhysical( Address, hal!_FADT);
    } else {
        InitTypeRead( Address, hal!_FADT);
    }

    dprintf(
        "FADT - BODY - %016I64x\n"
        "  FACS:                    0x%08lx\n"
        "  DSDT:                    0x%08lx\n"
        "  Int Model:               %s\n"
        "  SCI Vector:              0x%03x\n"
        "  SMI Port:                0x%08lx\n"
        "  ACPI On Value:           0x%03x\n"
          "  ACPI Off Value:          0x%03x\n"
        "  SMI CMD For S4 State:    0x%03x\n"
        "  PM1A Event Block:        0x%08lx\n"
        "  PM1B Event Block:        0x%08lx\n"
        "  PM1 Event Length:        0x%03x\n"
        "  PM1A Control Block:      0x%08lx\n"
        "  PM1B Control Block:      0x%08lx\n"
        "  PM1 Control Length:      0x%03x\n"
        "  PM2 Control Block:       0x%08lx\n"
        "  PM2 Control Length:      0x%03x\n"
        "  PM Timer Block:          0x%08lx\n"
        "  PM Timer Length:         0x%03x\n"
        "  GP0 Block:               0x%08lx\n"
        "  GP0 Length:              0x%03x\n"
        "  GP1 Block:               0x%08lx\n"
        "  GP1 Length:              0x%08lx\n"
        "  GP1 Base:                0x%08lx\n"
        "  C2 Latency:              0x%05lx\n"
        "  C3 Latency:              0x%05lx\n"
        "  Memory Flush Size:       0x%05lx\n"
        "  Memory Flush Stride:     0x%05lx\n"
        "  Duty Cycle Index:        0x%03x\n"
        "  Duty Cycle Index Width:  0x%03x\n"
        "  Day Alarm Index:         0x%03x\n"
        "  Month Alarm Index:       0x%03x\n"
        "  Century byte (CMOS):     0x%03x\n"
        "  Boot Architecture:       0x%04x\n"
        "  Flags:                   0x%08lx\n",
        Address + GetTypeSize("hal!_DESCRIPTION_HEADER"),
        (ULONG) ReadField(facs),
        (ULONG) ReadField(dsdt),
        (ReadField(int_model) == 0 ? "Dual PIC" : "Multiple APIC" ),
        (USHORT) ReadField(sci_int_vector),
        (ULONG) ReadField(smi_cmd_io_port),
        (UCHAR) ReadField(acpi_on_value),
        (UCHAR) ReadField(acpi_off_value),
        (UCHAR) ReadField(s4bios_req),
        (ULONG) ReadField(pm1a_evt_blk_io_port),
        (ULONG) ReadField(pm1b_evt_blk_io_port),
        (UCHAR) ReadField(pm1_evt_len),
        (ULONG) ReadField(pm1a_ctrl_blk_io_port),
        (ULONG) ReadField(pm1b_ctrl_blk_io_port),
        (UCHAR) ReadField(pm1_ctrl_len),
        (ULONG) ReadField(pm2_ctrl_blk_io_port),
        (UCHAR) ReadField(pm2_ctrl_len),
        (ULONG) ReadField(pm_tmr_blk_io_port),
        (UCHAR) ReadField(pm_tmr_len),
        (ULONG) ReadField(gp0_blk_io_port),
        (UCHAR) ReadField(gp0_blk_len),
        (ULONG) ReadField(gp1_blk_io_port),
        (UCHAR) ReadField(gp1_blk_len),
        (UCHAR) ReadField(gp1_base),
        (USHORT) ReadField(lvl2_latency),
        (USHORT) ReadField(lvl3_latency),
#ifndef _IA64_   // XXTF
        (USHORT) ReadField(flush_size),
        (USHORT) ReadField(flush_stride),
        (UCHAR) ReadField(duty_offset),
        (UCHAR) ReadField(duty_width),
#endif
        (UCHAR) ReadField(day_alarm_index),
        (UCHAR) ReadField(month_alarm_index),
        (UCHAR) ReadField(century_alarm_index),
        (USHORT) ReadField(boot_arch),
        (ULONG) ReadField(flags)
        );
    flags = (ULONG) ReadField(flags);
    if (flags & WRITEBACKINVALIDATE_WORKS) {

        dprintf("    Write Back Invalidate is supported\n");

    }
    if (flags & WRITEBACKINVALIDATE_DOESNT_INVALIDATE) {

        dprintf("    Write Back Invalidate doesn't invalidate the caches\n");

    }
    if (flags & SYSTEM_SUPPORTS_C1) {

        dprintf("    System supports C1 Power state on all processors\n");

    }
    if (flags & P_LVL2_UP_ONLY) {

        dprintf("    System supports C2 in MP and UP configurations\n");

    }
    if (flags & PWR_BUTTON_GENERIC) {

        dprintf("    Power Button is treated as a generic feature\n");

    }
    if (flags & SLEEP_BUTTON_GENERIC) {

        dprintf("    Sleep Button is treated as a generic feature\n");

    }
    if (flags & RTC_WAKE_GENERIC) {

        dprintf("    RTC Wake is not supported in fixed register space\n");

    }
    if (flags & RTC_WAKE_FROM_S4) {

        dprintf("    RTC Wake can work from an S4 state\n");

    }
    if (flags & TMR_VAL_EXT) {

        dprintf("    TMR_VAL implemented as 32-bit value\n");

    }
    if (Revision > 1) {

        if (!(ReadField(boot_arch) & LEGACY_DEVICES)) {

            dprintf("    The machine does not contain legacy ISA devices\n");
        }
        if (!(ReadField(boot_arch) & I8042)) {

            dprintf("    The machine does not contain a legacy i8042\n");
        }
        if (flags & RESET_CAP) {

            dprintf("    The reset register is supported\n");
            dprintf("      Reset Val: %x\n", ReadField(reset_val));

            GetFieldOffset("hal!_FADT", "reset_reg", &addr);
            GetFieldValue(Address + (ULONG64)addr, "hal!_GEN_ADDR", "AddressSpaceID", AddressSpaceID);
            switch (AddressSpaceID) {
            case 0:
                addressSpace = "Memory";
                break;
            case 1:
                addressSpace = "I/O";
                break;
            case 2:
                addressSpace = "PCIConfig";
                break;
            default:
                addressSpace = "undefined";
            }
            GetFieldOffset("hal!_GEN_ADDR", "Address", &addr);
            GetFieldValue(Address + (ULONG64)addr, "hal!_LARGE_INTEGER", "QuadPart", reset_reg_addr);

            dprintf("      Reset register: %s - %016I64x\n",
                    addressSpace,
                    reset_reg_addr
                    );

        }

    }
    return;
}



BOOL
GetUlongPtr (
    IN  PCHAR   String,
    IN  PULONG64 Address
    )
{
    ULONG64  Location;

    Location = GetExpression( String );
    if (!Location) {

        dprintf("Sorry: Unable to get %s.\n",String);
        return FALSE;

    }

    return ReadPointer(Location, Address);
}


DECLARE_API( rsdt )
{

    BOOLEAN Physical = FALSE;
    if (args != NULL) {

        AcpiRsdtAddress = GetExpression( args ); // Should work

    }
    if (AcpiRsdtAddress == 0) {

        UINT64          status;         // formerly BOOL
        ULONG64         address;

        status = GetUlongPtr( "ACPI!AcpiInformation", &address );

        if (status == TRUE) {
            status = GetFieldValue(address,"ACPI!_ACPIInformation","RootSystemDescTable",AcpiRsdtAddress);
        }

    }
    if (AcpiRsdtAddress == 0) {

        if (!findRSDT( &AcpiRsdtAddress) ) {

            dprintf("Could not locate the RSDT pointer\n");
            return E_INVALIDARG;

        }
        Physical = TRUE;

    }

    dumpRSDT( AcpiRsdtAddress, Physical );
    return S_OK;

}
DECLARE_API( fadt )
{

    if (args != NULL && *args != '\0') {

        AcpiFadtAddress = GetExpression( args );

    }

    if (AcpiFadtAddress == 0) {
        AcpiFadtAddress = GetExpression( "HAL!HalpFixedAcpiDescTable" );
    }

    if (AcpiFadtAddress == 0) {

        dprintf("fadt <address>\n");
        return E_INVALIDARG;

    }
    dumpFADT( AcpiFadtAddress );
    return S_OK;

}

VOID
dumpFACS(
    IN  ULONG64  Address
    )
/*++

Routine Description:

    This dumps the FADT at the specified address

Arguments:

    The address where the FADT is located at

Return Value:

    NONE

--*/
{
    BOOLEAN Physical = FALSE;

    //
    // Read the data
    //
    dprintf("FACS - %016I64x\n", Address);


    if (Physical) {
        InitTypeReadPhysical( Address, hal!_FACS);
    } else {
        InitTypeRead( Address, hal!_FACS);
    }

    if (ReadField(Signature) != FACS_SIGNATURE) {
        dprintf(
        "dumpFACS: Invalid Signature 0x%08lx != FACS_SIGNATURE\n",
        (ULONG) ReadField(Signature)
        );
        return;
    }


    //
    // Dump the table
    //
    dprintf(
        "  Signature:               %s\n"
        "  Length:                  %#08lx\n"
        "  Hardware Signature:      %#08lx\n"
        "  Firmware Wake Vector:    %#08lx\n"
        "  Global Lock :            %#08lx\n",
        ReadPhysVirField(Address, "hal!_FACS", "Signature", sizeof(ULONG), Physical),
        ReadField(Length),
        ReadField(HardwareSignature),
        ReadField(pFirmwareWakingVector),
        ReadField(GlobalLock)
        );

    if ( (ReadField(GlobalLock) & GL_PENDING) ) {

        dprintf("    Request for Ownership Pending\n");

    }
    if ( (ReadField(GlobalLock) & GL_OWNER) ) {

        dprintf("    Global Lock is Owned\n");

    }
    dprintf("  Flags:                   %#08lx\n", (ULONG) ReadField(Flags) );
    if ( (ReadField(Flags) & FACS_S4BIOS_SUPPORTED) ) {

        dprintf("    S4BIOS_REQ Supported\n");

    }
    return;
}

DECLARE_API( facs )
{

    if (args != NULL) {

        AcpiFacsAddress = GetExpression( args );
    }

    if (AcpiFacsAddress == 0) {

        BOOL            status;
        UINT64          address;

        status = GetUlongPtr( "ACPI!AcpiInformation", &address );
        if (status == TRUE) {
            status = GetFieldValue(address,"ACPI!_ACPIInformation","FirmwareACPIControlStructure",AcpiFacsAddress);
        }
    }

    if (AcpiFacsAddress == 0) {

        dprintf("facs <address>\n");
        return E_INVALIDARG;

    }

    dumpFACS( AcpiFacsAddress );
    return S_OK;

}
// ReturnXxx Functions - these are just a few functions I wrote that simplify
// dealing with certain types of Symbols
CHAR
ReturnChar(
    IN  ULONG64    Address,
    IN  PUCHAR     StructName,
    IN  PUCHAR     FieldName
    )
/*++
Routine Description:
    Return char using GetFieldValue
--*/
{
    char    returnChar;
    
    if (GetFieldValue(Address, StructName, FieldName, returnChar)){
        
        //
        //  Failed. try just the base symbols name before giving up
        //
        PUCHAR  symName=NULL;
        ULONG   i;

        for(i=strlen(StructName); i > 0 && StructName[i] != '!'; i--);
        i++;
        symName = StructName + i;

        //
        //  Try again
        //
        GetFieldValue(Address, symName, FieldName, returnChar);

    }
    return returnChar;
}

ULONG
ReturnUSHORT(
    IN  ULONG64    Address,
    IN  PUCHAR     StructName,
    IN  PUCHAR     FieldName
    )
/*++
Routine Description:
    Return USHORT using GetFieldValue
--*/
{
    USHORT   returnUSHORT;

    if (GetFieldValue(Address, StructName, FieldName, returnUSHORT)){
        
        //
        //  Failed. try just the base symbols name before giving up
        //
        PUCHAR  symName=NULL;
        ULONG   i;

        for(i=strlen(StructName); i > 0 && StructName[i] != '!'; i--);
        i++;
        symName = StructName + i;

        //
        //  Try again
        //
        GetFieldValue(Address, symName, FieldName, returnUSHORT);

    }
    return returnUSHORT;
}

ULONG
ReturnULONG(
    IN  ULONG64    Address,
    IN  PUCHAR     StructName,
    IN  PUCHAR     FieldName
    )
/*++
Routine Description:
    Return ULONG using GetFieldValue
--*/
{
    ULONG   returnULONG;

    if (GetFieldValue(Address, StructName, FieldName, returnULONG)){
        
        //
        //  Failed. try just the base symbols name before giving up
        //
        PUCHAR  symName=NULL;
        ULONG   i;

        for(i=strlen(StructName); i > 0 && StructName[i] != '!'; i--);
        i++;
        symName = StructName + i;
        
        //
        //  Try again
        //
        GetFieldValue(Address, symName, FieldName, returnULONG);

    }
    return returnULONG;
}

ULONG64
ReturnULONG64(
    IN  ULONG64    Address,
    IN  PUCHAR     StructName,
    IN  PUCHAR     FieldName
    )
/*++
Routine Description:
    Return ULONG64 using GetFieldValue
--*/
{
    ULONG64   returnULONG64;

    if (GetFieldValue(Address, StructName, FieldName, returnULONG64)){
        
        //
        //  Failed. try just the base symbols name before giving up
        //
        PUCHAR  symName=NULL;
        ULONG   i;

        for(i=strlen(StructName); i > 0 && StructName[i] != '!'; i--);
        i++;
        symName = StructName + i;
        
        //
        //  Try again
        //
        GetFieldValue(Address, symName, FieldName, returnULONG64);

    }
    return returnULONG64;
}


VOID
dumpMAPIC(
    IN  ULONG64    Address
    )
/*++

Routine Description:

    This dumps the multiple apic table

Arguments:

    Address of the table

Return Value:

    None

--*/
{
    BOOL                hasMPSFlags;
    BOOL                status;
    BOOL                virtualMemory;
    ULONG               mapicLength;
    ULONG64             iso;                // interruptSourceOverride
    USHORT              isoFlags;
    ULONG64             buffer;
    ULONG64             limit;
    ULONG               index;
    ULONG               returnLength;
    ULONG               flags;
    ULONG               get_value;
    BOOLEAN             Physical = FALSE;

    //
    // First check to see if we find the correct things
    //
    dprintf("MAPIC - ");

    if (Physical) {
        InitTypeReadPhysical( Address, hal!_DESCRIPTION_HEADER);
    } else {
        InitTypeRead( Address, hal!_DESCRIPTION_HEADER);
    }

    if (ReadField(Signature) != APIC_SIGNATURE) {
        dprintf(
        "dumpFACS: Invalid Signature 0x%08lx != APIC_SIGNATURE (%x)\n",
        (ULONG) ReadField(Signature),
        APIC_SIGNATURE
        );
        return;
    }

    mapicLength = (ULONG)ReadField(Length);

    dumpHeader( Address, TRUE, FALSE );
    dprintf("MAPIC - BODY - %016I64x\n", Address + GetTypeSize("hal!_DESCRIPTION_HEADER") );
    dprintf("  Local APIC Address:      %#08lx\n", ReturnULONG(Address, "hal!_MAPIC","LocalAPICAddress"));
    GetFieldValue(Address,"hal!_MAPIC","Flags",get_value);
    dprintf("  Flags:                   %#08lx\n", get_value );
    if (get_value & PCAT_COMPAT) { // Check the flags
        dprintf("    PC-AT dual 8259 compatible setup\n");
    }

    //gsig2
    GetFieldOffset( "hal!_MAPIC", "APICTables", &get_value);

    buffer = Address + get_value;
    limit = ( Address + ReadField(Length) );

    while (buffer < limit) {
       
        if (CheckControlC()) {
            break;
        }

        //
        // Assume that no flags are set
        //
        hasMPSFlags = FALSE;

        //
        // Lets see what kind of table we have?
        //
        iso = (ULONG64) buffer;

        //
        // Is it a localApic?
        //
        
        if (ReturnChar(iso, "acpi!_PROCLOCALAPIC", "Type") == PROCESSOR_LOCAL_APIC) {

            buffer += ReturnChar(iso, "acpi!_PROCLOCALAPIC", "Length");

            dprintf(
                "  Processor Local Apic\n"
                "    ACPI Processor ID:     0x%02x\n"
                "    APIC ID:               0x%02x\n"
                "    Flags:                 0x%08lx\n",
                ReturnChar(iso, "acpi!_PROCLOCALAPIC", "ACPIProcessorID"),
                ReturnChar(iso, "acpi!_PROCLOCALAPIC", "APICID"),
                ReturnULONG(iso, "acpi!_PROCLOCALAPIC", "Flags")
                );
            if (ReturnULONG(iso, "acpi!_PROCLOCALAPIC", "Flags") & PLAF_ENABLED) {
                dprintf("      Processor is Enabled\n");
            }
            if (ReturnChar(iso, "acpi!_PROCLOCALAPIC", "Length") != PROCESSOR_LOCAL_APIC_LENGTH) {
                dprintf(
                    "  Local Apic has length 0x%x instead of 0x%x\n",
                    ReturnChar(iso, "acpi!_PROCLOCALAPIC", "Length"),
                    PROCESSOR_LOCAL_APIC_LENGTH
                    );
                break;
            }
          } else if (ReturnChar(iso, "hal!_IOAPIC", "Type") == IO_APIC) {

            buffer += ReturnChar(iso, "hal!_IOAPIC", "Length");

            dprintf(
                "  IO Apic\n"
                "    IO APIC ID:            0x%02x\n"
                "    IO APIC ADDRESS:       0x%08lx\n"
                "    System Vector Base:    0x%08lx\n",
                ReturnChar(iso, "hal!_IOAPIC", "IOAPICID"),
                ReturnULONG(iso, "hal!_IOAPIC", "IOAPICAddress"),
                ReturnULONG(iso, "hal!_IOAPIC", "SystemVectorBase")
                );
            if (ReturnChar(iso, "hal!_IOAPIC", "Length") != IO_APIC_LENGTH) {
                dprintf(
                    "  IO Apic has length 0x%x instead of 0x%x\n",
                    ReturnChar(iso, "hal!_IOAPIC", "Length"),
                    IO_APIC_LENGTH
                    );
                break;
            }
        } else if (ReturnChar(iso,"hal!_ISA_VECTOR","Type") == ISA_VECTOR_OVERRIDE) {
            buffer += ReturnChar(iso, "hal!_ISA_VECTOR", "Length");
            GetFieldValue(iso, "hal!_ISA_VECTOR", "Flags", isoFlags);
            dprintf(
                "  Interrupt Source Override\n"
                "    Bus:                   0x%02x\n"
                "    Source:                0x%02x\n"
                "    Global Interrupt:      0x%08lx\n"
                "    Flags:                 0x%04x\n",
                ReturnChar(iso, "hal!_ISA_VECTOR", "Bus"),
                ReturnChar(iso, "hal!_ISA_VECTOR", "Source"),
                ReturnULONG(iso, "hal!_ISA_VECTOR", "GlobalSystemInterruptVector"),
                isoFlags
                );
            if (ReturnChar(iso,"hal!_ISA_VECTOR","Length") != ISA_VECTOR_OVERRIDE_LENGTH) {
                dprintf(
                    "  Interrupt Source Override has length 0x%x instead of 0x%x\n",
                    ReturnChar(iso, "hal!_ISA_VECTOR", "Length"),
                    ISA_VECTOR_OVERRIDE_LENGTH
                    );
                break;
            }
            hasMPSFlags = TRUE;
            flags = isoFlags;
        } else if (ReturnChar(iso,"acpi!_IO_NMISOURCE","Type") == IO_NMI_SOURCE) {
            buffer += ReturnChar(iso, "acpi!_IO_NMISOURCE", "Length");
            GetFieldValue(iso, "acpi!_IO_NMISOURCE", "Flags", isoFlags);
            dprintf(
                "  Non Maskable Interrupt Source - on I/O APIC\n"
                "    Flags:                 0x%02x\n"
                "    Global Interrupt:      0x%08lx\n",
                isoFlags,
                ReturnULONG(iso, "acpi!_IO_NMISOURCE", "GlobalSystemInterruptVector")
                );
            if (ReturnChar(iso,"acpi!_IO_NMISOURCE","Length") != IO_NMI_SOURCE_LENGTH) {
                dprintf(
                    "  Non Maskable Interrupt source has length 0x%x instead of 0x%x\n",
                    ReturnChar(iso, "acpi!_IO_NMISOURCE", "Length"),
                    IO_NMI_SOURCE_LENGTH
                    );
                break;
            }
            hasMPSFlags = TRUE;
            flags = isoFlags;
        } else if (ReturnChar(iso,"hal!_LOCAL_NMISOURCE","Type")  == LOCAL_NMI_SOURCE) {
            buffer += ReturnChar(iso, "hal!_LOCAL_NMISOURCE", "Length");
            GetFieldValue(iso, "hal!_LOCAL_NMISOURCE", "Flags", isoFlags);
            dprintf(
                "  Non Maskable Interrupt Source - local to processor\n"
                "    Flags:                 0x%04x\n"
                "    Processor:             0x%02x %s\n"
                "    LINTIN:                0x%02x\n",
                isoFlags,
                ReturnChar(iso, "hal!_LOCAL_NMISOURCE", "ProcessorID"),
                ReturnChar(iso,"hal!_LOCAL_NMISOURCE","ProcessorID") == 0xff ? "(all)" : "",
                ReturnChar(iso, "hal!_LOCAL_NMISOURCE", "LINTIN")
                );
            if (ReturnChar(iso,"hal!_LOCAL_NMISOURCE","Length") != LOCAL_NMI_SOURCE_LENGTH) {
                dprintf(
                    "  Non Maskable Interrupt source has length 0x%x instead of 0x%x\n",
                    ReturnChar(iso, "hal!_LOCAL_NMISOURCE", "Length"),
                    IO_NMI_SOURCE_LENGTH
                    );
                break;
            }

            hasMPSFlags = TRUE;
            flags = isoFlags;
        } else if (ReturnChar(iso, "hal!_PROCLOCALSAPIC", "Type") == LOCAL_SAPIC) {
            buffer += ReturnChar(iso, "hal!_PROCLOCALSAPIC", "Length");
            dprintf(
                "  Processor Local SAPIC\n"
                "    ACPI Processor ID:     0x%02x\n"
                "    APIC ID:               0x%02x\n"
                "    APIC EID:              0x%02x\n"
                "    Flags:                 0x%08lx\n",
                ReturnChar(iso, "hal!_PROCLOCALSAPIC", "ACPIProcessorID"),
                ReturnChar(iso, "hal!_PROCLOCALSAPIC", "APICID"),
                ReturnChar(iso, "hal!_PROCLOCALSAPIC", "APICEID"),
                ReturnULONG(iso, "hal!_PROCLOCALSAPIC", "Flags")
                );
            if (ReturnChar(iso, "hal!_PROCLOCALSAPIC", "Length") != PROCESSOR_LOCAL_SAPIC_LENGTH) {
                dprintf(
                    "  Processor Local SAPIC has length 0x%x instead of 0x%x\n",
                    ReturnChar(iso, "hal!_PROCLOCALSAPIC", "Length"),
                    PROCESSOR_LOCAL_SAPIC_LENGTH
                    );
                break;
            }
        } else if (ReturnChar(iso, "hal!_IOSAPIC", "Type") == IO_SAPIC) {
            buffer += ReturnChar(iso, "hal!_IOSAPIC", "Length");
            dprintf(
                "  IO SApic\n"
                "    IO SAPIC ADDRESS:      0x%016I64x\n"
                "    System Vector Base:    0x%08lx\n",
                ReturnULONG64(iso, "hal!_IOSAPIC", "IOSAPICAddress"),
                ReturnULONG(iso, "hal!_IOSAPIC", "SystemVectorBase")
                );
            if (ReturnChar(iso, "hal!_IOSAPIC", "Length") != IO_SAPIC_LENGTH) {
                dprintf(
                    "  IO SApic has length 0x%x instead of 0x%x\n",
                    ReturnChar(iso, "hal!_IOSAPIC", "Length"),
                    IO_SAPIC_LENGTH
                    );
                break;
            }
        } else if (ReturnChar(iso, "hal!_PLATFORM_INTERRUPT", "Type") == PLATFORM_INTERRUPT_SOURCE) {

            UCHAR InterruptType = ReturnChar(iso, "hal!_PLATFORM_INTERRUPT", "InterruptType");

            buffer += ReturnChar(iso, "hal!_PLATFORM_INTERRUPT", "Length");
            dprintf(
                "  Platform Interrupt Source\n"
                "    Flags:                 0x%04x\n"
                "    Interrupt Type:        %s\n"
                "    APICID:                0x%02x\n"
                "    APICEID:               0x%02x\n"
                "    IOSAPICVector:         0x%02x\n"
                "    GlobalVector:          0x%08x\n",
                ReturnUSHORT(iso, "hal!_PLATFORM_INTERRUPT", "Flags"),
                InterruptType == PLATFORM_INT_PMI ? "PMI" : 
                    (InterruptType == PLATFORM_INT_INIT ? "INIT" :
                        (InterruptType == PLATFORM_INT_CPE ? "CPE" : "UNKNOWN")),
                ReturnChar(iso, "hal!_PLATFORM_INTERRUPT", "APICID"),
                ReturnChar(iso, "hal!_PLATFORM_INTERRUPT", "APICEID"),
                ReturnChar(iso, "hal!_PLATFORM_INTERRUPT", "IOSAPICVector"),
                ReturnULONG(iso, "hal!_PLATFORM_INTERRUPT", "GlobalVector")
                );
            if (ReturnChar(iso, "hal!_PLATFORM_INTERRUPT", "Length") != PLATFORM_INTERRUPT_SOURCE_LENGTH) {
                dprintf(
                    "  Platform Interrupt Source has length 0x%x instead of 0x%x\n",
                    ReturnChar(iso, "hal!_PLATFORM_INTERRUPT", "Length"),
                    PLATFORM_INTERRUPT_SOURCE_LENGTH
                    );
                break;
            }
        } else {
            dprintf("  UNKNOWN RECORD (%p)\n", iso);
            dprintf("    Type:                  0x%08x\n", ReturnChar(iso,"hal!_IOAPIC","Type"));
            dprintf("    Length:                0x%08x\n", ReturnChar(iso,"hal!_IOAPIC","Length"));
            
            //
            //  Dont spin forever if we encounter an known with zero length
            //
            if ((ReturnChar(iso,"hal!_IOAPIC","Length")) == 0) {
                break;
            }

            buffer += ReturnChar(iso,"hal!_IOAPIC","Length");

            
        }
        //
        // Do we have any flags to dump out?
        //
        if (hasMPSFlags) {
            switch (flags & PO_BITS) {
            case POLARITY_HIGH:
                dprintf("      POLARITY_HIGH\n");
                break;
            case POLARITY_LOW:
                dprintf("      POLARITY_LOW\n");
                break;
            case POLARITY_CONFORMS_WITH_BUS:
                dprintf("      POLARITY_CONFORMS_WITH_BUS\n");
                break;
            default:
                dprintf("      POLARITY_UNKNOWN\n");
                break;
            }
            switch (flags & EL_BITS) {
            case EL_EDGE_TRIGGERED:
                dprintf("      EL_EDGE_TRIGGERED\n");
                break;
            case EL_LEVEL_TRIGGERED:
                dprintf("      EL_LEVEL_TRIGGERED\n");
                break;
            case EL_CONFORMS_WITH_BUS:
                dprintf("      EL_CONFORMS_WITH_BUS\n");
                break;
            default:
                dprintf("      EL_UNKNOWN\n");
                break;
            }
        }
    }
    return;
}

DECLARE_API( mapic )
{
    if (args != NULL) {

        AcpiMapicAddress = GetExpression( args );
    }

    if (AcpiMapicAddress == 0) {

        BOOL            status;
        ULONG64         address;

        status = GetUlongPtr( "ACPI!AcpiInformation", &address );
        if (status == TRUE) {
            status = GetFieldValue(address,"ACPI!_ACPIInformation","MultipleApicTable",AcpiMapicAddress);
        }
    }

    if (AcpiMapicAddress == 0) {
        dprintf("mapic <address>\n");
        return E_INVALIDARG;
    }

    dumpMAPIC( AcpiMapicAddress );
    return S_OK;

}
VOID
dumpGBLEntry(
    IN  ULONG64             Address,
    IN  ULONG               Verbose
    )
/*++

Routine Description:

    This routine actually prints the rule for the table at the
    specified address

Arguments:

    Address - where the table is located

Return Value:

    None

--*/
{
    BOOL                status;
    UCHAR               tableId[7];
    UCHAR               entryId[20];

    //
    // Read the header for the table
    //

    InitTypeRead( Address, hal!_DESCRIPTION_HEADER);
    //
    // Don't print out a table unless its the FACP or we are being verbose
    //
    if (!(Verbose & VERBOSE_2) && ReadField(Signature) != FADT_SIGNATURE) {

        return;
    }

    //
    // Initialize the table id field
    //
    memset( tableId, 0, 7 );
    tableId[0] = '\"';
    memcpy( &tableId[1], ReadPhysVirField(Address, "hal!_DESCRIPTION_HEADER", "Signature", sizeof(ULONG), FALSE), sizeof(ULONG) );
    strcat( tableId, "\"" );

    //
    // Get the entry ready for the OEM Id
    //
    memset( entryId, 0, 20 );
    entryId[0] = '\"';
    memcpy( &entryId[1], ReadPhysVirField(Address, "hal!_DESCRIPTION_HEADER", "OEMID", 6, FALSE), 6 );
    strcat( entryId, "\"");
    dprintf("AcpiOemId=%s,%s\n", tableId, entryId );

    //
    // Get the entry ready for the OEM Table Id
    //
    memset( entryId, 0, 20 );
    entryId[0] = '\"';
    memcpy( &entryId[1], ReadPhysVirField(Address, "hal!_DESCRIPTION_HEADER", "OEMTableID", 8, FALSE), 8 );
    strcat( entryId, "\"");
    dprintf("AcpiOemTableId=%s,%s\n", tableId, entryId );

    //
    // Get the entry ready for the OEM Revision
    //
    dprintf("AcpiOemRevision=\">=\",%s,%x\n", tableId, (ULONG)ReadField(OEMRevision) );

    //
    // Get the entry ready for the ACPI revision
    //
    if (ReadField(Revision) != 1) {

        dprintf("AcpiRevision=\">=\",%s,%x\n", tableId, (UCHAR)ReadField(Revision) );
    }

    //
    // Get the entry ready for the ACPI Creator Revision
    //
    dprintf("AcpiCreatorRevision=\">=\",%s,%x\n", tableId, (ULONG)ReadField(CreatorRev) );
}

VOID
dumpGBL(
    ULONG   Verbose
    )
/*++

Routine Description:

    This routine reads in all the system tables and prints out
    what the ACPI Good Bios List Entry for this machine should
    be

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL                status;
    ULONG64             dateAddress;
    PUCHAR              tempPtr;
    ULONG               i;
    ULONG               numElements;
    ULONG               returnLength;
    ULONG64             address;
    ULONG64             address2;
    ULONG               addr;
    ULONG64             addroffset;

    //
    // Remember where the date address is stored
    //
    dateAddress = 0xFFFF5;

    //
    // Make sure that we can read the pointer
    //
    address2 = GetExpression( "ACPI!RsdtInformation" );
    if (!address2) {
        dprintf("dumpGBL: Could not find RsdtInformation\n");
        return;
    }

    status = ReadPointer(address2, &address);
    if (status == FALSE || !address) {
        dprintf("dumpGBL: No RsdtInformation present\n");
        return;
    }

    //
    // Read the ACPInformation table, so that we know where the RSDT lives
    //
    address2 = GetExpression( "ACPI!AcpiInformation" );
    if (!address2) {
        dprintf("dumpGBL: Could not find AcpiInformation\n");
        return;
    }
    status = ReadPointer(address2, &address2);
    if (status == FALSE || !address2) {
        dprintf("dumpGBL: Could not read AcpiInformation\n");
        return;
    }
    
    InitTypeRead( address2, ACPI!_ACPIInformation);

    //
    // Read in the header for the RSDT
    //
    address2 = ReadField(RootSystemDescTable);

    //
    // The number of elements in the table is the first entry
    // in the structure
    //
    //status = ReadMemory(address, &numElements, GetTypeSize("acpi!_ULONG"), &returnLength);
    status = ReadMemory(address, &numElements, sizeof(ULONG), &returnLength);
    //if (status == FALSE || returnLength != GetTypeSize("acpi!_ULONG") ) {
    if (status == FALSE || returnLength != sizeof(ULONG) ) {

        dprintf("dumpGBL: Could not read RsdtInformation\n");
        return;

    }

    //
    // If there are no elements, then return
    //
    if (numElements == 0) {

        dprintf("dumpGBL: No tables the RsdtInformation\n");
        return;

    }

    //
    // Dump a header so that people know what this is
    //
    memset( Buffer, 0, 2048 );
    ReadPhysical( dateAddress, Buffer, 8, &returnLength );
    dprintf("\nGood Bios List Entry --- Machine BIOS Date %s\n\n", Buffer);
    memset( Buffer, 0, 2048 );
    GetFieldOffset( "hal!_DESCRIPTION_HEADER", "OEMID", &addr);
    ReadMemory( (address2 + (ULONG64) addr), &Buffer, 6, &returnLength);
    tempPtr = Buffer;
    while (*tempPtr) { if (*tempPtr == ' ') { *tempPtr = '\0'; break; } tempPtr++; }
    GetFieldOffset( "hal!_DESCRIPTION_HEADER", "OEMTableID", &addr);
    ReadMemory( (address2 + (ULONG64) addr), tempPtr, 8, &returnLength);
    while (*tempPtr) { if (*tempPtr == ' ') { *tempPtr = '\0'; break; } tempPtr++; }
    ReadPhysical( dateAddress, tempPtr, 8, &returnLength );
    while (*tempPtr) { if (*tempPtr == ' ') { *tempPtr = '\0'; break; } tempPtr++; }

    //
    // This is the entry name
    //
    dprintf("[%s]\n", Buffer );

    //
    // Dump all the tables that are loaded in the RSDT table
    //
    GetFieldOffset( "ACPI!_RSDTINFORMATION", "Tables", &addr); // Get Tables offset
    for (i = 0; i < numElements; i++) {

        addroffset = address + (ULONG64)addr + (ULONG64)(GetTypeSize("ACPI!RSDTELEMENT") * i);
        
        InitTypeRead(addroffset, ACPI!RSDTELEMENT);
        if (!(ReadField(Flags) & RSDTELEMENT_MAPPED) ) {
            continue;
        }

        dumpGBLEntry( ReadField(Address), Verbose );

    }

    //
    // Dump the entry for the RSDT
    //
    dumpGBLEntry( address2, Verbose );

    //
    // Add some whitespace
    //
    dprintf("\n");

    //
    // Done
    //
    return;
}

DECLARE_API( gbl )
{
    ULONG   verbose = VERBOSE_1;

    if (args != NULL) {

        if (!strcmp(args, "-v")) {

            verbose |= VERBOSE_2;
        }
    }

    dumpGBL( verbose );

    return S_OK;
}
/*************************** INF Starts Here ********************************/
ULONG
dumpFlags(
    IN  ULONGLONG       Value,
    IN  PFLAG_RECORD    FlagRecords,
    IN  ULONG           FlagRecordSize,
    IN  ULONG           IndentLevel,
    IN  ULONG           Flags
    )
/*++

Routine Description:

    This routine dumps the flags specified in Value according to the
    description passing into FlagRecords. The formating is affected by
    the flags field

Arguments:

    Value           - The values
    FlagRecord      - What each bit in the flags means
    FlagRecordSize  - How many flags there are
    IndentLevel     - The base indent level
    Flags           - How we will process the flags

Return Value:

    ULONG   - the number of characters printed. 0 if we printed nothing

--*/
#define STATUS_PRINTED          0x00000001
#define STATUS_INDENTED         0x00000002
#define STATUS_NEED_COUNTING    0x00000004
#define STATUS_COUNTED          0x00000008
{
    PCHAR       string;
    UCHAR       indent[80];
    ULONG       column = IndentLevel;
    ULONG       currentStatus = 0;
    ULONG       fixedSize = 0;
    ULONG       stringSize;
    ULONG       tempCount;
    ULONG       totalCount = 0;
    ULONG64     i, j, k;

    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    //
    // Do we need to make a table?
    //
    if ( (Flags & DUMP_FLAG_TABLE) &&
        !(Flags & DUMP_FLAG_SINGLE_LINE) ) {

        currentStatus |= STATUS_NEED_COUNTING;

    }
    if ( (Flags & DUMP_FLAG_ALREADY_INDENTED) ) {

        currentStatus |= STATUS_INDENTED;

    }

    //
    // loop over all the steps that we need to do
    //
    while (1) {

        for (i = 0; i < 32; i++) {

            k = (1 << i);
            for (j = 0; j < FlagRecordSize; j++) {

                if (!(FlagRecords[j].Bit & Value) ) {

                    //
                    // Are we looking at the correct bit?
                    //
                    if (!(FlagRecords[j].Bit & k) ) {

                        continue;

                    }

                    //
                    // Yes, we are, so pick the not-present values
                    //
                    if ( (Flags & DUMP_FLAG_LONG_NAME && FlagRecords[j].NotLongName == NULL) ||
                         (Flags & DUMP_FLAG_SHORT_NAME && FlagRecords[j].NotShortName == NULL) ) {

                        continue;

                    }

                    if ( (Flags & DUMP_FLAG_LONG_NAME) ) {

                        string = FlagRecords[j].NotLongName;

                    } else if ( (Flags & DUMP_FLAG_SHORT_NAME) ) {

                        string = FlagRecords[j].NotShortName;

                    }

                } else {

                    //
                    // Are we looking at the correct bit?
                    //
                    if (!(FlagRecords[j].Bit & k) ) {

                        continue;

                    }

                    //
                    // Yes, we are, so pick the not-present values
                    //
                    if ( (Flags & DUMP_FLAG_LONG_NAME && FlagRecords[j].LongName == NULL) ||
                         (Flags & DUMP_FLAG_SHORT_NAME && FlagRecords[j].ShortName == NULL) ) {

                        continue;

                    }

                    if ( (Flags & DUMP_FLAG_LONG_NAME) ) {

                        string = FlagRecords[j].LongName;

                    } else if ( (Flags & DUMP_FLAG_SHORT_NAME) ) {

                        string = FlagRecords[j].ShortName;

                    }

                }

                if (currentStatus & STATUS_NEED_COUNTING) {

                    stringSize = strlen( string ) + 1;
                    if (Flags & DUMP_FLAG_SHOW_BIT) {

                        stringSize += (4 + ( (ULONG) i / 4));
                        if ( (i % 4) != 0) {

                            stringSize++;

                        }

                    }
                    if (stringSize > fixedSize) {

                        fixedSize = stringSize;

                    }
                    continue;

                }

                if (currentStatus & STATUS_COUNTED) {

                    stringSize = fixedSize;

                } else {

                    stringSize = strlen( string ) + 1;
                    if (Flags & DUMP_FLAG_SHOW_BIT) {

                        stringSize += (4 + ( (ULONG) i / 4));
                        if ( (i % 4) != 0) {

                            stringSize++;

                        }

                    }

                }

                if (!(Flags & DUMP_FLAG_SINGLE_LINE) ) {

                    if ( (stringSize + column) > 79 ) {

                        dprintf("\n%n", &tempCount);
                        currentStatus &= ~STATUS_INDENTED;
                        totalCount += tempCount;
                        column = 0;

                    }
                }
                if (!(Flags & DUMP_FLAG_NO_INDENT) ) {

                    if (!(currentStatus & STATUS_INDENTED) ) {

                        dprintf("%s%n", indent, &tempCount);
                        currentStatus |= STATUS_INDENTED;
                        totalCount += tempCount;
                        column += IndentLevel;

                    }

                }
                if ( (Flags & DUMP_FLAG_SHOW_BIT) ) {

                    dprintf("%I64x - %n", k, &tempCount);
                    tempCount++; // to account for the fact that we dump
                                 // another space at the end of the string
                    totalCount += tempCount;
                    column += tempCount;

                } else {

                    tempCount = 0;

                }

                //
                // Actually print the string
                //
                dprintf( "%.*s %n", (stringSize - tempCount), string, &tempCount );
                if (Flags & DUMP_FLAG_SHOW_BIT) {

                    dprintf(" ");

                }

                totalCount += tempCount;
                column += tempCount;

            }

        }

        //
        // Change states
        //
        if (currentStatus & STATUS_NEED_COUNTING) {

            currentStatus &= ~STATUS_NEED_COUNTING;
            currentStatus |= STATUS_COUNTED;
            continue;

        }

        if (!(Flags & DUMP_FLAG_NO_EOL) && totalCount != 0) {

            dprintf("\n");
            totalCount++;

        }

        //
        // Done
        //
        break;

    }

    return totalCount;

}

VOID
dumpPM1ControlRegister(
    IN  ULONG   Value,
    IN  ULONG   IndentLevel
    )
{


    //
    // Dump the PM1 Control Flags
    //
    dumpFlags(
        (Value & 0xFF),
        PM1ControlFlags,
        sizeof(PM1ControlFlags) / sizeof(FLAG_RECORD),
        IndentLevel,
        (DUMP_FLAG_LONG_NAME | DUMP_FLAG_SHOW_BIT | DUMP_FLAG_TABLE)
        );

}


VOID
dumpPM1StatusRegister(
    IN  ULONG   Value,
    IN  ULONG   IndentLevel
    )
{
    //
    // Dump the PM1 Status Flags
    //
    dumpFlags(
        (Value & 0xFFFF),
        PM1StatusFlags,
        (sizeof(PM1StatusFlags) / sizeof(FLAG_RECORD)),
        IndentLevel,
        (DUMP_FLAG_LONG_NAME | DUMP_FLAG_SHOW_BIT | DUMP_FLAG_TABLE)
        );

    //
    // Switch to the PM1 Enable Flags
    //
    Value >>= 16;


    //
    // Dump the PM1 Enable Flags
    //
    dumpFlags(
        (Value & 0xFFFF),
        PM1EnableFlags,
        (sizeof(PM1EnableFlags) / sizeof(FLAG_RECORD)),
        IndentLevel,
        (DUMP_FLAG_LONG_NAME | DUMP_FLAG_SHOW_BIT | DUMP_FLAG_TABLE)
        );
}

VOID
dumpAcpiInformation(
    VOID
    )
{
    BOOL            status;
    ULONG64         address;
    ULONG           returnLength;
    ULONG           size;
    ULONG           value;
    ULONG           addr;
    ULONG           i;
    ULONG64         getValue;
    ULONG64         getValue2;

    status = GetUlongPtr( "ACPI!AcpiInformation", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiInformation: Could not read ACPI!AcpiInformation\n");
        return;

    }
    InitTypeRead(address, ACPI!_ACPIInformation);

    dprintf("ACPIInformation (%p)\n", address);
    dprintf(
        "  RSDT                     - %p\n",
        ReadField(RootSystemDescTable)
        );
    dprintf(
        "  FADT                     - %p\n",
        ReadField(FixedACPIDescTable)
        );
    dprintf(
        "  FACS                     - %p\n",
        ReadField(FirmwareACPIControlStructure)
        );
    dprintf(
        "  DSDT                     - %p\n",
        ReadField(DiffSystemDescTable)
        );
    dprintf(
        "  GlobalLock               - %p\n",
        ReadField(GlobalLock)
        );
    dprintf(
        "  GlobalLockQueue          - F - %p B - %p\n",
        ReadField(GlobalLockQueue.Flink),
        ReadField(GlobalLockQueue.Blink)
        );
    dprintf(
        "  GlobalLockQueueLock      - %p\n",
        ReadField(GlobalLockQueueLock)
        );
    dprintf(
        "  GlobalLockOwnerContext   - %p\n",
        ReadField(GlobalLockOwnerContext)
        );
    dprintf(
        "  GlobalLockOwnerDepth     - %p\n",
        ReadField(GlobalLockOwnerDepth)
        );
    dprintf(
        "  ACPIOnly                 - %s\n",
        (ReadField(ACPIOnly) ? "TRUE" : "FALSE" )
        );
    dprintf(
        "  PM1a_BLK                 - %p",
        ReadField(PM1a_BLK)
        );
    if (ReadField(PM1a_BLK)) {

        size = 4;
        value = 0;
        ReadIoSpace64( (ULONG) ReadField(PM1a_BLK), &value, &size );
        if (size) {

            dprintf(" (%04x) (%04x)\n", (value & 0xFFFF), (value >> 16) );
            dumpPM1StatusRegister( value, 5 );

        } else {

            dprintf(" (N/A)\n" );

        }

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  PM1b_BLK                 - %p",
        ReadField(PM1b_BLK)
        );
    if (ReadField(PM1b_BLK)) {

        size = 4;
        value = 0;
        ReadIoSpace64( (ULONG) ReadField(PM1b_BLK), &value, &size );
        if (size) {

            dprintf(" (%04x) (%04x)\n", (value & 0xFFFF), (value >> 16) );
            dumpPM1StatusRegister( value, 5 );

        } else {

            dprintf(" (N/A)\n" );

        }

    } else {

        dprintf(" (N/A)\n" );

    }
    dprintf(
        "  PM1a_CTRL_BLK            - %p",
        ReadField(PM1a_CTRL_BLK)
        );
    if (ReadField(PM1a_CTRL_BLK)) {

        size = 2;
        value = 0;
        ReadIoSpace64( (ULONG) ReadField(PM1a_CTRL_BLK), &value, &size );
        if (size) {

            dprintf(" (%04x)\n", (value & 0xFFFF) );
            dumpPM1ControlRegister( value, 5 );

        } else {

            dprintf(" (N/A)\n" );

        }

    } else {

        dprintf(" (N/A)\n" );

    }
    dprintf(
        "  PM1b_CTRL_BLK            - %p",
        ReadField(PM1b_CTRL_BLK)
        );

    if (ReadField(PM1b_CTRL_BLK)) {

        size = 2;
        value = 0;
        ReadIoSpace64( (ULONG) ReadField(PM1b_CTRL_BLK), &value, &size );
        if (size) {

            dprintf(" (%04x)\n", (value & 0xFFFF));
            dumpPM1ControlRegister( value, 5 );

        } else {

            dprintf(" (N/A)\n" );

        }

    } else {

        dprintf(" (N/A)\n" );

    }
    dprintf(
        "  PM2_CTRL_BLK             - %p",
        ReadField(PM2_CTRL_BLK)
        );
    if (ReadField(PM2_CTRL_BLK)) {

        size = 1;
        value = 0;
        ReadIoSpace64( (ULONG) ReadField(PM2_CTRL_BLK), &value, &size );
        if (size) {

            dprintf(" (%02x)\n", (value & 0xFF) );
            if (value & 0x1) {

                dprintf("     0 - ARB_DIS\n");

            }

        } else {

            dprintf(" (N/A)\n");

        }

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  PM_TMR                   - %p",
        ReadField(PM_TMR)
        );
    if (ReadField(PM_TMR)) {

        size = 4;
        value = 0;
        ReadIoSpace64( (ULONG) ReadField(PM_TMR), &value, &size );
        if (size) {

            dprintf(" (%08lx)\n", value );

        } else {

            dprintf(" (N/A)\n");

        }

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP0_BLK                  - %p",
        ReadField(GP0_BLK)
        );
    if (ReadField(GP0_BLK)) {

        for(i = 0; i < ReadField(Gpe0Size); i++) {

            size = 1;
            value = 0;
            ReadIoSpace64( (ULONG) ReadField(GP0_BLK) + i, &value, &size );
            if (size) {

                dprintf(" (%02x)", value );

            } else {

                dprintf(" (N/A)" );

            }

        }
        dprintf("\n");

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP0_ENABLE               - %p",
        ReadField(GP0_ENABLE)
        );
    if (ReadField(GP0_ENABLE)) {

        for(i = 0; i < ReadField(Gpe0Size); i++) {

            size = 1;
            value = 0;
            ReadIoSpace64( (ULONG) ReadField(GP0_ENABLE) + i, &value, &size );
            if (size) {

                dprintf(" (%02x)", value );

            } else {

                dprintf(" (N/A)" );

            }

        }
        dprintf("\n");

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP0_LEN                  - %p\n",
        ReadField(GP0_LEN)
        );
    dprintf(
        "  GP0_SIZE                 - %p\n",
        ReadField(Gpe0Size)
        );
    dprintf(
        "  GP1_BLK                  - %p",
        ReadField(GP1_BLK)
        );
    if (ReadField(GP1_BLK)) {

        for(i = 0; i < ReadField(Gpe0Size); i++) {

            size = 1;
            value = 0;
            ReadIoSpace64( (ULONG) ReadField(GP1_BLK) + i, &value, &size );
            if (size) {

                dprintf(" (%02x)", value );

            } else {

                dprintf(" (N/A)" );

            }

        }
        dprintf("\n");

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP1_ENABLE               - %p",
        ReadField(GP1_ENABLE)
        );
    if (ReadField(GP1_ENABLE)) {

        for(i = 0; i < ReadField(Gpe0Size); i++) {

            size = 1;
            value = 0;
            ReadIoSpace64( (ULONG) ReadField(GP1_ENABLE) + i, &value, &size );
            if (size) {

                dprintf(" (%02x)", value );

            } else {

                dprintf(" (N/A)" );

            }

        }
        dprintf("\n");

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP1_LEN                  - %x\n",
        ReadField(GP1_LEN)
        );
    dprintf(
        "  GP1_SIZE                 - %x\n",
        ReadField(Gpe1Size)
        );
    dprintf(
        "  GP1_BASE_INDEX           - %x\n",
        ReadField(GP1_Base_Index)
        );
    dprintf(
        "  GPE_SIZE                 - %x\n",
        ReadField(GpeSize)
        );
    dprintf(
        "  PM1_EN_BITS              - %04x\n",
        ReadField(pm1_en_bits)
        );
    dumpPM1StatusRegister( ( (ULONG) ReadField(pm1_en_bits) << 16), 5 );
    dprintf(
        "  PM1_WAKE_MASK            - %04x\n",
        ReadField(pm1_wake_mask)
        );
    dumpPM1StatusRegister( ( (ULONG) ReadField(acpiInformation.pm1_wake_mask) << 16), 5 );
    dprintf(
        "  C2_LATENCY               - %x\n",
        ReadField(c2_latency)
        );
    dprintf(
        "  C3_LATENCY               - %x\n",
        ReadField(c3_latency)
        );
    dprintf(
        "  ACPI_FLAGS               - %x\n",
        ReadField(ACPI_Flags)
        );
    if (ReadField(ACPI_Flags) & C2_SUPPORTED) {

        dprintf("    %2d - C2_SUPPORTED\n", C2_SUPPORTED_BIT);

    }
    if (ReadField(ACPI_Flags) & C3_SUPPORTED) {

        dprintf("    %2d - C3_SUPPORTED\n", C3_SUPPORTED_BIT);

    }
    if (ReadField(ACPI_Flags) & C3_PREFERRED) {

        dprintf("    %2d - C3_PREFERRED\n", C3_PREFERRED_BIT);

    }
    dprintf(
        "  ACPI_CAPABILITIES        - %x\n",
        ReadField(ACPI_Capabilities)
        );
    if (ReadField(ACPI_Capabilities) & CSTATE_C1) {

        dprintf("    %2d - CSTATE_C1\n", CSTATE_C1_BIT );

    }    if (ReadField(ACPI_Capabilities) & CSTATE_C2) {

        dprintf("    %2d - CSTATE_C2\n", CSTATE_C2_BIT );

    }    if (ReadField(ACPI_Capabilities) & CSTATE_C3) {

        dprintf("    %2d - CSTATE_C3\n", CSTATE_C3_BIT );

    }
}

DECLARE_API( acpiinf )
{
    dumpAcpiInformation( );
    return S_OK;
}

VOID
dumpObject(
    IN  ULONG64   Object,
    IN  ULONG     Verbose,
    IN  ULONG     IndentLevel
    )
/*++

Routine Description:

    This dumps an Objdata so that it can be understand --- great for debugging some of the
    AML code

Arguments:

    Object - Address of OBJDATA structure


Return Value:

    None

--*/
{
    ULONG64     s;
    NTSTATUS    status;
    UCHAR       buffer[2048];
    UCHAR       indent[80];
    ULONG64     max;
    ULONG64     pbDataBuffoffset = 0;
    ULONG64     offset = 0;
    UCHAR       StrBuffer[2048];

    //
    // Init the buffers
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    //
    // Get the offset to pbDataBuff
    //

    InitTypeRead (Object, acpi!_ObjData);
    pbDataBuffoffset = ReadField (pbDataBuff);

    dprintf("%sObject Data - %016I64x Type - ", indent, Object);

    //
    // First step is to read whatever the buffer points to, if it
    // points to something
    //

    switch( ReadField (dwDataType) ) {
        case OBJTYPE_INTDATA:
            dprintf(
                "%02I64x <Integer> Value=%016I64x\n",
                ReadField (dwDataType),
                ReadField (uipDataValue)
                );
            break;

        case OBJTYPE_STRDATA:

            if (ReadField (pbDataBuff) != 0) {

                max = (ReadField (dwDataLen) > 2047 ? 2047 : ReadField (dwDataLen) );

            }
            buffer[max] = '\0';

            ReadMemory (pbDataBuffoffset,
                        StrBuffer,
                        (ULONG) max,
                        NULL);

            dprintf(
                "%02I64x <String> String=%s\n",
                ReadField (dwDataType),
                StrBuffer
                );
            break;

        case OBJTYPE_BUFFDATA:
            dprintf(
                "%02I64x <Buffer> Ptr=%016I64lx Length = %2I64x\n",
                ReadField (dwDataType),
                ReadField (pbDataBuff),
                ReadField (dwDataLen)
                );
            break;

        case OBJTYPE_PKGDATA: {

            ULONG64       i = 0;
            ULONG64       j = 0;
            ULONG64       datatype = ReadField (dwDataType);

            InitTypeRead (pbDataBuffoffset, acpi!_PackageObj);
            j = ReadField (dwcElements);

            dprintf(
                "%02I64x <Package> NumElements=%016I64x\n",
                datatype,
                j
                );

            if (Verbose & VERBOSE_OBJECT) {

                for (; i < j; i++) {

                    GetFieldOffset ("acpi!_PackageObj", "adata", (ULONG*) &offset);
                    offset += (GetTypeSize ("acpi!_ObjData") * i);

                    dumpObject(offset + pbDataBuffoffset,
                               Verbose,
                               IndentLevel+ 2
                               );

                }

            }

            break;

        }
        case OBJTYPE_FIELDUNIT: {

            dprintf(
                "%02I64x <Field Unit> ",
                ReadField (dwDataType)
                );

            InitTypeRead (pbDataBuffoffset, acpi!_FieldUnitObj);

            dprintf(
                "Parent=%016I64x Offset=%016I64x Start=%016I64x Num=%x Flags=%x\n",
                ReadField (pnsFieldParent),
                ReadField (FieldDesc.dwByteOffset),
                ReadField (FieldDesc.dwStartBitPos),
                ReadField (FieldDesc.dwNumBits),
                ReadField (FieldDesc.dwFieldFlags)
                );

            break;

        }
        case OBJTYPE_DEVICE:
            dprintf(
                "%02I64x <Device>\n",
                ReadField (dwDataType)
                );
            break;
        case OBJTYPE_EVENT:
            dprintf(
                "%02I64x <Event> PKEvent=%016I64x\n",
                ReadField (dwDataType),
                ReadField (pbDataBuff)
                );
            break;
        case OBJTYPE_METHOD: {

            ULONG64 offset, size;

            GetFieldOffset ("acpi!_MethodObj", "abCodeBuff", (ULONG *) &offset);
            size = ReadField (dwDataLen) - GetTypeSize ("acpi!_MethodObj") + ANYSIZE_ARRAY;

            dprintf(
                "%02I64x <Method>",
                ReadField (dwDataType)
                );

            InitTypeRead (pbDataBuffoffset, acpi!_MethodObj);

            dprintf(
                "Flags=%016I64x Start=%016I64x Len=%016I64x\n",
                ReadField (bMethodFlags),
                offset + pbDataBuffoffset,
                size
                );

            break;

        }
        case OBJTYPE_MUTEX:

            dprintf(
                "%02I64x <Mutex> Mutex=%016I64x\n",
                ReadField (dwDataType),
                ReadField (pbDataBuff)
                );
            break;

        case OBJTYPE_OPREGION: {

            dprintf(
                "%02I64x <Operational Region>",
                ReadField (dwDataType)
                );

            InitTypeRead (pbDataBuffoffset, acpi!_OpRegionObj);

            dprintf(
                 "RegionSpace=%02x OffSet=%016I64x Len=%016I64x\n",
                 ReadField(bRegionSpace),
                 ReadField(uipOffset),
                 ReadField(dwLen)
                 );

            break;

        }

        case OBJTYPE_POWERRES: {

            dprintf(
                "%02I64x <Power Resource> ",
                ReadField (dwDataType)
                );

            InitTypeRead (pbDataBuffoffset, acpi!_PowerResObj);

            dprintf(
                "SystemLevel=S%d Order=%x\n",
                ReadField (bSystemLevel),
                ReadField (bResOrder)
                );

            break;

        }

        case OBJTYPE_PROCESSOR: {

            dprintf(
                "%02I64x <Processor> ",
                ReadField (dwDataType)
                );

            if (InitTypeRead (pbDataBuffoffset, acpi!_ProcessorObj))
            {
                dprintf ("Error reading acpi!_ProcessorObj\n");
                return;
            }

            dprintf(
                 "AcpiID=%016I64x PBlk=%016I64x PBlkLen=%016I64x\n",
                 ReadField (bApicID),
                 ReadField (dwPBlk),
                 ReadField (dwPBlkLen)
                 );

            break;

        }

        case OBJTYPE_THERMALZONE:

            dprintf(
                "%02I64x <Thermal Zone>\n",
                ReadField (dwDataType)
                );
            break;

        case OBJTYPE_BUFFFIELD: {

            dprintf(
                "%02I64x <Buffer Field>",
                ReadField (dwDataType)
                );

            InitTypeRead (pbDataBuffoffset, acpi!_BuffFieldObj);

            dprintf(
                "Ptr=%016I64x Len=%0164I64x Offset=%0164I64x Start=%016I64x NumBits=%x Flags=%x\n",
                ReadField (pbDataBuff),
                ReadField (dwBuffLen),
                ReadField (FieldDesc.dwByteOffset),
                ReadField (FieldDesc.dwStartBitPos),
                ReadField (FieldDesc.dwNumBits),
                ReadField (FieldDesc.dwFieldFlags)
                );

            break;

        }

        case OBJTYPE_DDBHANDLE:
            dprintf(
                "%02I64x <DDB Handle> Handle=%016I64x\n",
                ReadField (dwDataType),
                ReadField (pbDataBuff)
                );
            break;
        case OBJTYPE_DEBUG:
            dprintf(
                "%02I64x <Internal Debug>\n",
                ReadField (dwDataType)
                );
            break;
        case OBJTYPE_OBJALIAS:

            dprintf(
                "%02I64x <Internal Object Alias> NS Object=%016I64x\n",
                ReadField (dwDataType),
                ReadField (uipDataValue)
                );
            dumpNSObject( ReadField (uipDataValue), Verbose, IndentLevel + 2 );
            break;

        case OBJTYPE_DATAALIAS: {

            dprintf(
                "%02I64x <Internal Data Alias> Data Object=%016I64x\n",
                ReadField (dwDataType),
                ReadField (uipDataValue)
                );

            dumpObject(
                ReadField (uipDataValue),
                Verbose,
                IndentLevel + 2
                );
            break;

        }
        case OBJTYPE_BANKFIELD:

            dprintf(
                "%02I64x <Internal Bank Field>\n",
                ReadField (dwDataType)
                );
            break;

        case OBJTYPE_FIELD:

            dprintf(
                "%02I64x <Internal Field>\n",
                ReadField (dwDataType)
                );
            break;

        case OBJTYPE_INDEXFIELD:

            dprintf(
                "%02I64x <Index Field>\n",
                ReadField (dwDataType)
                );
            break;

        case OBJTYPE_UNKNOWN:
        default:

            dprintf(
                "%02I64x <Unknown>\n",
                ReadField (dwDataType)
                );
            break;
    }
}


DECLARE_API( nsobj )
{
    ULONG64 address = 0;

    if (!strlen(args)) {

        ReadPointer(GetExpression ("acpi!gpnsnamespaceroot"), &address);

    } else {

        address = UtilStringToUlong64 ((UCHAR *)args);
    }

    if (!address) {

        dprintf ("nsobj: Error parsing arguments\n");
        return E_INVALIDARG;
    }

    dprintf ("nsobj:  dumping object at %I64x\n", address);

    dumpNSObject( address, 0xFFFF, 0 );

    return S_OK;
}

VOID
dumpNSObject(
    IN  ULONG64 Address,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
/*++

Routine Description:

    This function dumps a Name space object

Arguments:

    Address     - Where to find the object
    Verbose     - Should the object be dumped as well?
    IndentLevel - How much to indent

Return Value:

    None

--*/
{
    ULONG64 s;
    UCHAR   buffer[5];
    UCHAR   indent[80];
    ULONG   offset = 0;

    //
    // Init the buffers
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';
    buffer[4] = '\0';

    //
    // First step is to read the root NS
    //

    s = InitTypeRead (Address, acpi!_NSObj);

    if (s) {

        dprintf("%sdumpNSObject: could not read %x(%I64x)\n", indent,Address,s);
        return;

    }

    s = ReadField (dwNameSeg);

    if (ReadField(dwNameSeg) != 0) {

        memcpy( buffer, (UCHAR *) &s, 4 );

    } else {

        sprintf( buffer, "    ");

    }

    dprintf(
        "%sNameSpace Object %s (%016I64x) - Device %016I64x\n",
        indent,
        buffer,
        Address,
        ReadField (Context)
        );

    if (Verbose & VERBOSE_NSOBJ) {

        dprintf(
            "%s  Flink %016I64x  Blink  %016I64x\n%s  Parent %016I64x  Child %016I64x\n",
            indent,
            ReadField (list.plistNext),
            ReadField (list.plistPrev),
            indent,
            ReadField (pnsParent),
            ReadField (pnsFirstChild)
            );

    }

    dprintf(
        "%s  Value %016I64x  Length %016I64x\n%s  Buffer %016I64x  Flags %016I64x\n",
        indent,
        ReadField (ObjData.uipDataValue),
        ReadField (ObjData.dwDataLen),
        indent,
        ReadField (ObjData.pbDataBuff),
        ReadField (ObjData.dwfData)
        );

    if (ReadField (ObjData.dwfData) & DATAF_BUFF_ALIAS) {

        dprintf("  Alias" );

    }
    if (ReadField (ObjData.dwfData) & DATAF_GLOBAL_LOCK) {

        dprintf("  Lock");

    }
    dprintf("\n");

    GetFieldOffset ("acpi!_NSObj", "ObjData", (ULONG *) &offset);

    dumpObject(Address + offset, Verbose, IndentLevel + 4);
}


VOID
dumpNSTree(
    IN  ULONG64   Address,
    IN  ULONG       Level
    )
/*++

Routine Description:

    This thing dumps the NS tree

Arguments:

    Address - Where to find the root node --- we start dumping at the children

Return Value:

    None

--*/
{
    BOOL        end = FALSE;
    ULONG64     s;
    UCHAR       buffer[5];
    ULONG64     next;
    ULONG       back;
    ULONG64     m1 = 0;
    ULONG64     m2 = 0;
    ULONG       reason;
    ULONG64     dataBuffSize;
    UCHAR       StrBuffer[2048];
    ULONG64     r = 0;

    buffer[4] = '\0';
    memset( StrBuffer, '0', 2048 );


    //
    // Indent
    //
    for (m1 = 0; m1 < Level; m1 ++) {

        dprintf("| ");

    }

    //
    // First step is to read the root NS
    //

    InitTypeRead (Address, acpi!_NSObj);

    if (ReadField (dwNameSeg) != 0) {

        s = ReadField (dwNameSeg);
        memcpy( buffer, (UCHAR*) &s, 4 );
        dprintf("%4s ", buffer );

    } else {

        dprintf("     " );

    }
    dprintf(
        "(%016I64x) - ", Address );

    if (ReadField (Context) != 0) {

        dprintf("Device %016I64x\n", ReadField (Context) );

    } else {

        //
        // We need to read the pbDataBuff here
        //

        switch(ReadField (ObjData.dwDataType)) {
            default:
            case OBJTYPE_UNKNOWN:       dprintf("Unknown\n");           break;
            case OBJTYPE_INTDATA:

                dprintf("Integer - %016I64x\n", ReadField (ObjData.uipDataValue));
                break;

            case OBJTYPE_STRDATA:

                dataBuffSize = (ReadField (ObjData.dwDataLen) > 2047 ?
                2047 : ReadField (ObjData.dwDataLen));

                //dprintf ("blah:%016I64x, %lx\n", ReadField (ObjData.pbDataBuff), dataBuffSize);

                ReadMemory(
                    ReadField (ObjData.pbDataBuff),
                    StrBuffer,
                    (ULONG) dataBuffSize,
                    NULL
                    );

                if (!s) {

                    dprintf(
                        "dumpNSTree: could not read %x\n",
                        ReadField (ObjData.pbDataBuff)
                        );
                    return;

                }

                StrBuffer[dataBuffSize+1] = '\0';

                dprintf(
                     "String - %s\n",
                     StrBuffer
                     );
                break;

            case OBJTYPE_BUFFDATA:

                dprintf(
                     "Buffer - %08lx L=%04x\n",
                     ReadField (ObjData.pbDataBuff),
                     ReadField (ObjData.dwDataLen)
                     );
                break;

            case OBJTYPE_PKGDATA: {

                InitTypeRead (ReadField (ObjData.pbDataBuff), acpi!_PackageObj);

                dprintf("Package - NumElements %x\n", ReadField (dwcElements));
                break;

            }
            case OBJTYPE_FIELDUNIT:{

                InitTypeRead (ReadField (ObjData.pbDataBuff), acpi!_FieldUnitObj);

                dprintf(
                    "FieldUnit - Parent %016I64x Offset %016I64x Start %016I64x "
                    "Num %016I64x Flags %016I64x\n",
                    ReadField (pnsFieldParent),
                    ReadField (FieldDesc.dwByteOffset),
                    ReadField (FieldDesc.dwStartBitPos),
                    ReadField (FieldDesc.dwNumBits),
                    ReadField (FieldDesc.dwFieldFlags)
                    );

                break;

            }
            case OBJTYPE_DEVICE:

                dprintf("Device\n");
                break;

            case OBJTYPE_EVENT:

                dprintf("Event - PKEvent %016I64x\n", ReadField (ObjData.pbDataBuff));
                break;

            case OBJTYPE_METHOD: {

                ULONG64 size, offset, pbdatabuff;

                pbdatabuff = ReadField (ObjData.pbDataBuff);
                size = ReadField (ObjData.dwDataLen);
                GetFieldOffset ("acpi!_MethodObj", "abCodeBuff", (ULONG*) &offset);

                InitTypeRead (pbdatabuff, acpi!_MethodObj);

                dprintf(
                     "Method - Flags %016I64x Start %016I64x Len %016I64x\n",
                     ReadField (bMethodFlags),
                     offset + pbdatabuff,
                     size - GetTypeSize ("acpi!_MethodObj") + ANYSIZE_ARRAY
                     );

                 break;

            }
            case OBJTYPE_OPREGION: {

                InitTypeRead (ReadField (ObjData.pbDataBuff), acpi!_OpRegionObj);

                dprintf(
                    "Opregion - RegionsSpace=%02x OffSet=%016I64x Len=%016I64x\n",
                    ReadField (bRegionSpace),
                    ReadField (uipOffset),
                    ReadField (dwLen)
                    );
                break;

            }
            case OBJTYPE_BUFFFIELD: {

                InitTypeRead (ReadField (ObjData.pbDataBuff), acpi!_BuffFieldObj);

                dprintf(
                    "Buffer Field Ptr=%x Len=%x Offset=%x Start=%x"
                    "NumBits=%x Flgas=%x\n",
                    ReadField (pbDataBuff),
                    ReadField (dwBuffLen),
                    ReadField (FieldDesc.dwByteOffset),
                    ReadField (FieldDesc.dwStartBitPos),
                    ReadField (FieldDesc.dwNumBits),
                    ReadField (FieldDesc.dwFieldFlags)
                    );
                break;

            }
            case OBJTYPE_FIELD: {

                dprintf("Field\n");
                break;

            }
            case OBJTYPE_INDEXFIELD:    dprintf("Index Field\n");       break;

            case OBJTYPE_MUTEX:         dprintf("Mutex\n");             break;
            case OBJTYPE_POWERRES:      dprintf("Power Resource\n");    break;
            case OBJTYPE_PROCESSOR:     dprintf("Processor\n");         break;
            case OBJTYPE_THERMALZONE:   dprintf("Thermal Zone\n");      break;
            case OBJTYPE_DDBHANDLE:     dprintf("DDB Handle\n");        break;
            case OBJTYPE_DEBUG:         dprintf("Debug\n");             break;
            case OBJTYPE_OBJALIAS:      dprintf("Object Alias\n");      break;
            case OBJTYPE_DATAALIAS:     dprintf("Data Alias\n");        break;
            case OBJTYPE_BANKFIELD:     dprintf("Bank Field\n");        break;

        }

    }
    m1 = next = ReadField (pnsFirstChild);

    while (next != 0 && end == FALSE) {

        if (CheckControlC()) {

            break;

        }

        dumpNSTree( next, Level + 1);
        InitTypeRead (next, acpi!_NSObj);

        //
        // Do the end check tests
        //
        if ( m2 == 0) {

            m2 = ReadField (list.plistPrev);

        } else if (m1 == ReadField (list.plistNext)) {

            end = TRUE;
            reason = 1;

        } else if (m2 == next) {

            end = TRUE;
            reason = 2;
        }

        next = ReadField (list.plistNext);

    }

}

DECLARE_API( nstree )
{
    ULONG64 address = 0;

    if (!strlen(args)) {

        ReadPointer(GetExpression ("acpi!gpnsnamespaceroot"), &address);

    } else {

        address = UtilStringToUlong64 ((UCHAR *)args);
    }

    if (!address) {

        dprintf ("nstree: Error parsing arguments\n");
        return E_INVALIDARG;
    }

    dprintf ("nstree:  dumping object at %I64x\n", address);

    dumpNSTree( address, 0 );

    return S_OK;
}

//
// Flags for interrupt vectors
//

#define VECTOR_MODE         1
#define VECTOR_LEVEL        1
#define VECTOR_EDGE         0
#define VECTOR_POLARITY     2
#define VECTOR_ACTIVE_LOW   2
#define VECTOR_ACTIVE_HIGH  0

//
// Vector Type:
//
// VECTOR_SIGNAL = standard edge-triggered or
//		   level-sensitive interrupt vector
//
// VECTOR_MESSAGE = an MSI (Message Signalled Interrupt) vector
//

#define VECTOR_TYPE         4
#define VECTOR_SIGNAL       0
#define VECTOR_MESSAGE      4

#define IS_LEVEL_TRIGGERED(vectorFlags) \
    (vectorFlags & VECTOR_LEVEL)

#define IS_EDGE_TRIGGERED(vectorFlags) \
    !(vectorFlags & VECTOR_LEVEL)

#define IS_ACTIVE_LOW(vectorFlags) \
    (vectorFlags & VECTOR_ACTIVE_LOW)

#define IS_ACTIVE_HIGH(vectorFlags) \
    !(vectorFlags & VECTOR_ACTIVE_LOW)

#define TOKEN_VALUE 0x57575757
#define EMPTY_BLOCK_VALUE 0x58585858
#define VECTOR_HASH_TABLE_LENGTH 0x1f
#define VECTOR_HASH_TABLE_WIDTH 2

VOID
dumpHashTableEntry(
    IN  ULONG64 VectorBlock
    )
{
    InitTypeRead (VectorBlock, acpi!_VECTOR_BLOCK);

    dprintf("%04x  Count/temp: %02d/%02d  ",
            ReadField (Entry.Vector),
            ReadField (Entry.Count),
            ReadField (Entry.TempCount));

    dprintf("Flags: (%s %s)  TempFlags(%s %s)\n",
            (ReadField (Entry.Flags) & VECTOR_MODE) == VECTOR_LEVEL ?
                "level" : "edge",
            (ReadField (Entry.Flags) & VECTOR_POLARITY) == VECTOR_ACTIVE_LOW ?
                "low" : "high",
            (ReadField (Entry.TempFlags) & VECTOR_MODE) == VECTOR_LEVEL ?
                "level" : "edge",
            (ReadField (Entry.TempFlags) & VECTOR_POLARITY) == VECTOR_ACTIVE_LOW ?
                "low" : "high");

}

VOID
dumpIrqArb(
    IN  ULONG64   IrqArb
    )
{
    ULONG64 Address;
    ULONG64 Flink;
    LIST_ENTRY64 ListEntry;
    ULONG64 nextNode;
    ULONG64 ListHead;
    ULONG64 linkNode;
    ULONG64 attachedDevs;
    ULONG   attachedDevOffset;
    ULONG64 hashTable, hashTablePtr;
    ULONG64 hashEntry;
    ULONG   hashEntrySize;
    ULONG   i,j;
    ULONG64 retVal;

    retVal = InitTypeRead (IrqArb, nt!_ARBITER_INSTANCE);
    if (retVal) {
        dprintf("Failed to get symbol nt!_ARBITER_INSTANCE\n");
        return;
    }
    
    Address = ReadField(Extension);
    dprintf("ACPI IRQ Arbiter:  %016I64x   Extension: %016I64x\n",
            IrqArb, Address);

    retVal = InitTypeRead (Address, acpi!ARBITER_EXTENSION);
    if (retVal) {
        dprintf("Failed to get symbol acpi!ARBITER_EXTENSION\n");
        return;
    }
    
    ListHead = ReadField(LinkNodeHead);
    dprintf("\nLink nodes in use:  (list head at %016I64x )\n", ListHead);

    ListEntry.Flink = ReadField(LinkNodeHead.Flink);
    ListEntry.Blink = Address;

    //dprintf("%016I64x, %016I64x\n", ListEntry.Flink, ListEntry.Blink);

    if (ListHead == ListEntry.Flink) {
        dprintf("\tNone.\n");
    }

    if (GetFieldOffset("acpi!LINK_NODE", "AttachedDevices", &attachedDevOffset)) {
        dprintf("symbol lookup acpi!LINK_NODE failed\n");
        return;
    }

    nextNode = ListEntry.Flink;

    while (nextNode != ListEntry.Blink) {

        //dprintf("nextNode: %016I64x\n", nextNode);
        retVal = InitTypeRead (nextNode, acpi!LINK_NODE);
        if (retVal) {
            dprintf("Failed to get type acpi!LINK_NODE\n");
            break;
        }

        dprintf("\n");
        dumpNSObject( ReadField(NameSpaceObject), 0xFFFF, 3 );
        InitTypeRead (nextNode, acpi!LINK_NODE);
        dprintf("\n\tVector/temp: (%x/%x) RefCount/temp: (%d/%d) Flags: %x\n",
                (ULONG)(ReadField(CurrentIrq) & 0xffffffff),
                (ULONG)(ReadField(TempIrq) & 0xffffffff),
                ReadField(ReferenceCount),
                ReadField(TempRefCount),
                ReadField(Flags));

        attachedDevs = ReadField(AttachedDevices.Next);
        //dprintf("attachedDevs: %p  nextNode: %p attachedDevOffset: %x\n",
        //        attachedDevs, nextNode, attachedDevOffset);

        while (attachedDevs != (nextNode + attachedDevOffset)) {

            InitTypeRead(attachedDevs, acpi!LINK_NODE_ATTACHED_DEVICES);

            //dprintf("\t\tAttached PDO: %016I64x\n", ReadField(Pdo));

            attachedDevs = ReadField(List.Next);

            if (CheckControlC()) {
                break;
            }
        }

        InitTypeRead (nextNode, acpi!LINK_NODE);
        nextNode = ReadField(List.Flink);
        
        if (CheckControlC()) {
            break;
        }
    }

    hashTablePtr = GetExpression( "acpi!irqhashtable" );
    if (!hashTablePtr) {
        dprintf("couldn't read symbol acpi!irqhashtable\n");
        return;
    }

    retVal = ReadPointer(hashTablePtr, &hashTable);
    if (!retVal) {
        return;
    }

    hashEntrySize = GetTypeSize("acpi!_VECTOR_BLOCK");

    dprintf("\n\nIRQ Hash Table (at %016I64x ):\n",
            hashTable);

    for (i = 0; i < VECTOR_HASH_TABLE_LENGTH; i++) {

        hashEntry = hashTable + (i * VECTOR_HASH_TABLE_WIDTH * hashEntrySize);
        
DumpVectorTableStartRow:
        for (j = 0; j < VECTOR_HASH_TABLE_WIDTH; j++) {

            InitTypeRead(hashEntry, acpi!_VECTOR_BLOCK);
            
            if (ReadField(Chain.Token) == TOKEN_VALUE) {

                hashEntry = ReadField(Chain.Next);
                
                dumpHashTableEntry(hashEntry);

                goto DumpVectorTableStartRow;
            }

            if (ReadField(Entry.Vector) != EMPTY_BLOCK_VALUE) {

                dumpHashTableEntry(hashEntry);
            }

            hashEntry += hashEntrySize;
            if (CheckControlC()) {
                break;
            }
        }
        
        if (CheckControlC()) {
            break;
        }
    }
}

DECLARE_API( acpiirqarb )
{
    ULONG64   irqArbiter;

    irqArbiter = GetExpression( "acpi!acpiarbiter" );

    if (!irqArbiter) {
        dprintf("failed to find address of arbiter\n");
        return E_INVALIDARG;
    }

    dumpIrqArb(irqArbiter);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\amd64.h ===
#ifndef _KDEXTS_AMD64_H_
#define _KDEXTS_AMD64_H_

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    amd64.h

Abstract:

    This file contains definitions which are specific to amd64 platforms.

Author:

    Forrest Foltz (forrestf)

Environment:

    User Mode.

Revision History:

--*/

//
// MM constants.
// 

#define PXE_BASE_AMD64    0xFFFFF6FB7DBED000UI64
#define PPE_BASE_AMD64    0xFFFFF6FB7DA00000UI64
#define PDE_BASE_AMD64    0xFFFFF6FB40000000UI64
#define PTE_BASE_AMD64    0xFFFFF68000000000UI64

#define PXE_TOP_AMD64     0xFFFFF6FB7DBEDFFFUI64
#define PPE_TOP_AMD64     0xFFFFF6FB7DBFFFFFUI64
#define PDE_TOP_AMD64     0xFFFFF6FB7FFFFFFFUI64
#define PTE_TOP_AMD64     0xFFFFF6FFFFFFFFFFUI64

#define MM_SESSION_SPACE_DEFAULT_AMD64 0xFFFFF90000000000UI64

//
// Each of the four levels of an AMD64 machine decode 9 bits of address space.
// 

#define TABLE_DECODE_BITS_AMD64 9

//
// Standard page is 4K, or 12 bits
//

#define PAGE_SHIFT_AMD64        12
#define PAGE_MASK_AMD64         (((ULONG64)1 << PAGE_SHIFT_AMD64) - 1)

//
// Large page is 2GB, or 21 bits
//

#define LARGE_PAGE_SHIFT_AMD64  21
#define LARGE_PAGE_MASK_AMD64   (((ULONG64)1 << LARGE_PAGE_SHIFT_AMD64) - 1)

//
// Number of bits required to shift a VA in order to right-justify the
// decode bits associated with a particular level of mapping.
// 

#define PTI_SHIFT_AMD64   (PAGE_SHIFT_AMD64 + TABLE_DECODE_BITS_AMD64 * 0)
#define PDI_SHIFT_AMD64   (PAGE_SHIFT_AMD64 + TABLE_DECODE_BITS_AMD64 * 1)
#define PPI_SHIFT_AMD64   (PAGE_SHIFT_AMD64 + TABLE_DECODE_BITS_AMD64 * 2)
#define PXI_SHIFT_AMD64   (PAGE_SHIFT_AMD64 + TABLE_DECODE_BITS_AMD64 * 3)

#define PTE_SHIFT_AMD64     3

//
// The AMD64 architecture can decode up to 52 bits of physical address
// space.  The following masks are used to isolate those bits within a PTE
// associated with a physical address.
//

#define PTE_PHYSICAL_BITS_AMD64 ((((ULONG64)1 << 52) - 1) & ~PAGE_MASK_AMD64)
#define PTE_LARGE_PHYSICAL_BITS_AMD64 ((((ULONG64)1 << 52) - 1) & ~LARGE_PAGE_MASK_AMD64)

//
// The AMD64 architecture supports 48 bits of VA.
//

#define AMD64_VA_BITS 48
#define AMD64_VA_HIGH_BIT ((ULONG64)1 << (AMD64_VA_BITS - 1))
#define AMD64_VA_MASK     (((ULONG64)1 << AMD64_VA_BITS) - 1)

#define AMD64_VA_SHIFT (63 - 47)              // address sign extend shift count

//
// Inline used to sign extend a 48-bit value
//

ULONG64
__inline
VA_SIGN_EXTEND_AMD64 (
    IN ULONG64 Va
    )
{
    if ((Va & AMD64_VA_HIGH_BIT) != 0) {

        //
        // The highest VA bit is set, so sign-extend it
        //

        Va |= ((ULONG64)-1 ^ AMD64_VA_MASK);
    }

    return Va;
}

//
// Flags in a HARDWARE_PTE
//

#define MM_PTE_VALID_MASK_AMD64         0x1

#if defined(NT_UP)
#define MM_PTE_WRITE_MASK_AMD64         0x2
#else
#define MM_PTE_WRITE_MASK_AMD64         0x800
#endif

#define MM_PTE_OWNER_MASK_AMD64         0x4
#define MM_PTE_WRITE_THROUGH_MASK_AMD64 0x8
#define MM_PTE_CACHE_DISABLE_MASK_AMD64 0x10
#define MM_PTE_ACCESS_MASK_AMD64        0x20

#if defined(NT_UP)
#define MM_PTE_DIRTY_MASK_AMD64         0x40
#else
#define MM_PTE_DIRTY_MASK_AMD64         0x42
#endif

#define MM_PTE_LARGE_PAGE_MASK_AMD64    0x80
#define MM_PTE_GLOBAL_MASK_AMD64        0x100
#define MM_PTE_COPY_ON_WRITE_MASK_AMD64 0x200
#define MM_PTE_PROTOTYPE_MASK_AMD64     0x400
#define MM_PTE_TRANSITION_MASK_AMD64    0x800

#define MM_PTE_PROTECTION_MASK_AMD64    0x3e0
#define MM_PTE_PAGEFILE_MASK_AMD64      0x01e

#define MI_PTE_LOOKUP_NEEDED_AMD64      (0xFFFFFFFF)

#endif // _KDEXTS_AMD64_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\amli.c ===
/*** amli.c - AML Debugger functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,2001 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 *  hanumany    5/10/01     Ported to handle 64bit debugging.  
 *  
 */

#include "precomp.h"
#include "amlikd.h"

/*** Macros
*/

#define ReadAtAddress(A,V,S) { ULONG _r;                   \
    if (!ReadMemory((A), &(V), (S), &_r ) || (_r < (S))) {  \
        dprintf("Can't Read Memory at %08p\n", (A));         \
        rc = DBGERR_CMD_FAILED;                                              \
    }                                                        \
}

#define WriteAtAddress(A,V,S) { ULONG _r;                  \
    if (!WriteMemory( (A), &(V), (S), &_r ) || (_r < (S))) {\
        dprintf("Can't Write Memory at %p\n", (A));        \
        rc = DBGERR_CMD_FAILED;                              \
    }                                                        \
}

/*** Local data
 */

char gcszTokenSeps[] = " \t\n";
ULONG dwfDebuggerON = 0, dwfDebuggerOFF = 0;
ULONG dwfAMLIInitON = 0, dwfAMLIInitOFF = 0;
ULONG dwCmdArg = 0;

CMDARG ArgsHelp[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgHelp,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDNS[] =
{
    "s", AT_ENABLE, 0, &dwCmdArg, DNSF_RECURSE, NULL,
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgDNS,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsFind[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgFind,
    NULL, AT_END, 0, NULL, 0, NULL
};

DBGCMD DbgCmds[] =
{
    "?", 0, ArgsHelp, AMLIDbgHelp,
    "debugger", 0, NULL, AMLIDbgDebugger,
    "dns", 0, ArgsDNS, AMLIDbgDNS,
    "find", 0, ArgsFind, AMLIDbgFind,
    NULL, 0, NULL, NULL
};

PSZ pszSwitchChars = "-/";
PSZ pszOptionSeps = "=:";

ASLTERM TermTable[] =
{
    "DefinitionBlock", CD, 0, OP_NONE,     NULL, NULL, OL|CL|LL|AF|AV,
    "Include",         CD, 0, OP_NONE,     NULL, NULL, AF,
    "External",        CD, 0, OP_NONE,     NULL, "uX", AF,

    // Short Objects
    "Zero",            CN, 0, OP_ZERO,     NULL, NULL, 0,
    "One",             CN, 0, OP_ONE,      NULL, NULL, 0,
    "Ones",            CN, 0, OP_ONES,     NULL, NULL, 0,
    "Revision",        CN, 0, OP_REVISION, NULL, NULL, 0,
    "Arg0",            SN, 0, OP_ARG0,     NULL, NULL, 0,
    "Arg1",            SN, 0, OP_ARG1,     NULL, NULL, 0,
    "Arg2",            SN, 0, OP_ARG2,     NULL, NULL, 0,
    "Arg3",            SN, 0, OP_ARG3,     NULL, NULL, 0,
    "Arg4",            SN, 0, OP_ARG4,     NULL, NULL, 0,
    "Arg5",            SN, 0, OP_ARG5,     NULL, NULL, 0,
    "Arg6",            SN, 0, OP_ARG6,     NULL, NULL, 0,
    "Local0",          SN, 0, OP_LOCAL0,   NULL, NULL, 0,
    "Local1",          SN, 0, OP_LOCAL1,   NULL, NULL, 0,
    "Local2",          SN, 0, OP_LOCAL2,   NULL, NULL, 0,
    "Local3",          SN, 0, OP_LOCAL3,   NULL, NULL, 0,
    "Local4",          SN, 0, OP_LOCAL4,   NULL, NULL, 0,
    "Local5",          SN, 0, OP_LOCAL5,   NULL, NULL, 0,
    "Local6",          SN, 0, OP_LOCAL6,   NULL, NULL, 0,
    "Local7",          SN, 0, OP_LOCAL7,   NULL, NULL, 0,
    "Debug",           SN, 0, OP_DEBUG,    NULL, NULL, 0,

    // Named Terms
    "Alias",           NS, 0, OP_ALIAS,    "NN", "Ua", 0,
    "Name",            NS, 0, OP_NAME,     "NO", "u",  0,
    "Scope",           NS, 0, OP_SCOPE,    "N",  "S",  OL|LN|CC,

    // Data Objects
    "Buffer",          DO, 0, OP_BUFFER,   "C", "U",  DL|LN,
    "Package",         DO, 0, OP_PACKAGE,  "B", NULL, PL|LN,
    "EISAID",          DO, 0, OP_DWORD,    NULL,NULL, AF,

    // Argument Keywords
    "AnyAcc",          KW, AANY, OP_NONE, NULL, "A", 0,
    "ByteAcc",         KW, AB,   OP_NONE, NULL, "A", 0,
    "WordAcc",         KW, AW,   OP_NONE, NULL, "A", 0,
    "DWordAcc",        KW, ADW,  OP_NONE, NULL, "A", 0,
    "BlockAcc",        KW, ABLK, OP_NONE, NULL, "A", 0,
    "SMBSendRecvAcc",  KW, ASSR, OP_NONE, NULL, "A", 0,
    "SMBQuickAcc",     KW, ASQ,  OP_NONE, NULL, "A", 0,

    "Lock",            KW, LK,   OP_NONE, NULL, "B", 0,
    "NoLock",          KW, NOLK, OP_NONE, NULL, "B", 0,

    "Preserve",        KW, PSRV, OP_NONE, NULL, "C", 0,
    "WriteAsOnes",     KW, WA1S, OP_NONE, NULL, "C", 0,
    "WriteAsZeros",    KW, WA0S, OP_NONE, NULL, "C", 0,

    "SystemMemory",    KW, MEM,  OP_NONE, NULL, "D", 0,
    "SystemIO",        KW, IO,   OP_NONE, NULL, "D", 0,
    "PCI_Config",      KW, CFG,  OP_NONE, NULL, "D", 0,
    "EmbeddedControl", KW, EC,   OP_NONE, NULL, "D", 0,
    "SMBus",           KW, SMB,  OP_NONE, NULL, "D", 0,

    "Serialized",      KW, SER,  OP_NONE, NULL, "E", 0,
    "NotSerialized",   KW, NOSER,OP_NONE, NULL, "E", 0,

    "MTR",             KW, OMTR, OP_NONE, NULL, "F", 0,
    "MEQ",             KW, OMEQ, OP_NONE, NULL, "F", 0,
    "MLE",             KW, OMLE, OP_NONE, NULL, "F", 0,
    "MLT",             KW, OMLT, OP_NONE, NULL, "F", 0,
    "MGE",             KW, OMGE, OP_NONE, NULL, "F", 0,
    "MGT",             KW, OMGT, OP_NONE, NULL, "F", 0,

    "Edge",            KW, _HE,  OP_NONE, NULL, "G", 0,
    "Level",           KW, _LL,  OP_NONE, NULL, "G", 0,

    "ActiveHigh",      KW, _HE,  OP_NONE, NULL, "H", 0,
    "ActiveLow",       KW, _LL,  OP_NONE, NULL, "H", 0,

    "Shared",          KW, _SHR, OP_NONE, NULL, "I", 0,
    "Exclusive",       KW, _EXC, OP_NONE, NULL, "I", 0,

    "Compatibility",   KW, COMP, OP_NONE, NULL, "J", 0,
    "TypeA",           KW, TYPA, OP_NONE, NULL, "J", 0,
    "TypeB",           KW, TYPB, OP_NONE, NULL, "J", 0,
    "TypeF",           KW, TYPF, OP_NONE, NULL, "J", 0,

    "BusMaster",       KW, BM,   OP_NONE, NULL, "K", 0,
    "NotBusMaster",    KW, NOBM, OP_NONE, NULL, "K", 0,

    "Transfer8",       KW, X8,   OP_NONE, NULL, "L", 0,
    "Transfer8_16",    KW, X816, OP_NONE, NULL, "L", 0,
    "Transfer16",      KW, X16,  OP_NONE, NULL, "L", 0,

    "Decode16",        KW, DC16, OP_NONE, NULL, "M", 0,
    "Decode10",        KW, DC10, OP_NONE, NULL, "M", 0,

    "ReadWrite",       KW, _RW,  OP_NONE, NULL, "N", 0,
    "ReadOnly",        KW, _ROM, OP_NONE, NULL, "N", 0,

    "ResourceConsumer",KW, RCS,  OP_NONE, NULL, "O", 0,
    "ResourceProducer",KW, RPD,  OP_NONE, NULL, "O", 0,

    "SubDecode",       KW, BSD,  OP_NONE, NULL, "P", 0,
    "PosDecode",       KW, BPD,  OP_NONE, NULL, "P", 0,

    "MinFixed",        KW, MIF,  OP_NONE, NULL, "Q", 0,
    "MinNotFixed",     KW, NMIF, OP_NONE, NULL, "Q", 0,

    "MaxFixed",        KW, MAF,  OP_NONE, NULL, "R", 0,
    "MaxNotFixed",     KW, NMAF, OP_NONE, NULL, "R", 0,

    "Cacheable",       KW, CACH, OP_NONE, NULL, "S", 0,
    "WriteCombining",  KW, WRCB, OP_NONE, NULL, "S", 0,
    "Prefetchable",    KW, PREF, OP_NONE, NULL, "S", 0,
    "NonCacheable",    KW, NCAC, OP_NONE, NULL, "S", 0,

    "ISAOnlyRanges",   KW, ISA,  OP_NONE, NULL, "T", 0,
    "NonISAOnlyRanges",KW, NISA, OP_NONE, NULL, "T", 0,
    "EntireRange",     KW, ERNG, OP_NONE, NULL, "T", 0,

    "ExtEdge",         KW, ($HGH | $EDG),  OP_NONE, NULL, "U", 0,
    "ExtLevel",        KW, ($LOW | $LVL),  OP_NONE, NULL, "U", 0,

    "ExtActiveHigh",   KW, ($HGH | $EDG),  OP_NONE, NULL, "V", 0,
    "ExtActiveLow",    KW, ($LOW | $LVL),  OP_NONE, NULL, "V", 0,

    "ExtShared",       KW, $SHR, OP_NONE, NULL, "W", 0,
    "ExtExclusive",    KW, $EXC, OP_NONE, NULL, "W", 0,

    "UnknownObj",      KW, UNK,  OP_NONE, NULL, "X", 0,
    "IntObj",          KW, INT,  OP_NONE, NULL, "X", 0,
    "StrObj",          KW, STR,  OP_NONE, NULL, "X", 0,
    "BuffObj",         KW, BUF,  OP_NONE, NULL, "X", 0,
    "PkgObj",          KW, PKG,  OP_NONE, NULL, "X", 0,
    "FieldUnitObj",    KW, FDU,  OP_NONE, NULL, "X", 0,
    "DeviceObj",       KW, DEV,  OP_NONE, NULL, "X", 0,
    "EventObj",        KW, EVT,  OP_NONE, NULL, "X", 0,
    "MethodObj",       KW, MET,  OP_NONE, NULL, "X", 0,
    "MutexObj",        KW, MUT,  OP_NONE, NULL, "X", 0,
    "OpRegionObj",     KW, OPR,  OP_NONE, NULL, "X", 0,
    "PowerResObj",     KW, PWR,  OP_NONE, NULL, "X", 0,
    "ThermalZoneObj",  KW, THM,  OP_NONE, NULL, "X", 0,
    "BuffFieldObj",    KW, BFD,  OP_NONE, NULL, "X", 0,
    "DDBHandleObj",    KW, DDB,  OP_NONE, NULL, "X", 0,

    // Field Macros
    "Offset",          FM, 0, OP_NONE, NULL, NULL, 0,
    "AccessAs",        FM, 0, 0x01,    NULL, "A" , AF,

    // Named Object Creators
    "BankField",       NO, 0, OP_BANKFIELD,  "NNCKkk","OFUABC", FL|FM|LN|AF,
    "CreateBitField",  NO, 0, OP_BITFIELD,   "CCN",   "UUb",    0,
    "CreateByteField", NO, 0, OP_BYTEFIELD,  "CCN",   "UUb",    0,
    "CreateDWordField",NO, 0, OP_DWORDFIELD, "CCN",   "UUb",    0,
    "CreateField",     NO, 0, OP_CREATEFIELD,"CCCN",  "UUUb",   0,
    "CreateWordField", NO, 0, OP_WORDFIELD,  "CCN",   "UUb",    0,
    "Device",          NO, 0, OP_DEVICE,     "N",     "d",      OL|LN|CC,
    "Event",           NO, 0, OP_EVENT,      "N",     "e",      0,
    "Field",           NO, 0, OP_FIELD,      "NKkk",  "OABC",   FL|FM|LN|AF,
    "IndexField",      NO, 0, OP_IDXFIELD,   "NNKkk", "FFABC",  FL|FM|LN|AF,
    "Method",          NO, 0, OP_METHOD,     "NKk",   "m!E",    CL|OL|LN|AF|CC|SK,
    "Mutex",           NO, 0, OP_MUTEX,      "NB",    "x",      0,
    "OperationRegion", NO, 0, OP_OPREGION,   "NKCC",  "oDUU",   AF,
    "PowerResource",   NO, 0, OP_POWERRES,   "NBW",   "p",      OL|LN|CC,
    "Processor",       NO, 0, OP_PROCESSOR,  "NBDB",  "c",      OL|LN|CC,
    "ThermalZone",     NO, 0, OP_THERMALZONE,"N",     "t",      OL|LN|CC,

    // Type 1 Opcode Terms
    "Break",           C1, 0, OP_BREAK,       NULL,  NULL, 0,
    "BreakPoint",      C1, 0, OP_BREAKPOINT,  NULL,  NULL, 0,
    "Else",            C1, 0, OP_ELSE,        NULL,  NULL, AF|CL|OL|LN,
    "Fatal",           C1, 0, OP_FATAL,       "BDC", "  U",0,
    "If",              C1, 0, OP_IF,          "C",   "U",  CL|OL|LN,
    "Load",            C1, 0, OP_LOAD,        "NS",  "UU", 0,
    "Noop",            C1, 0, OP_NOP,         NULL,  NULL, 0,
    "Notify",          C1, 0, OP_NOTIFY,      "SC",  "UU", 0,
    "Release",         C1, 0, OP_RELEASE,     "S",   "X",  0,
    "Reset",           C1, 0, OP_RESET,       "S",   "E",  0,
    "Return",          C1, 0, OP_RETURN,      "C",   "U",  0,
    "Signal",          C1, 0, OP_SIGNAL,      "S",   "E",  0,
    "Sleep",           C1, 0, OP_SLEEP,       "C",   "U",  0,
    "Stall",           C1, 0, OP_STALL,       "C",   "U",  0,
    "Unload",          C1, 0, OP_UNLOAD,      "S",   "U",  0,
    "While",           C1, 0, OP_WHILE,       "C",   "U",  CL|OL|LN,

    // Type 2 Opcode Terms
    "Acquire",         C2, 0, OP_ACQUIRE,     "SW",     "X",  0,
    "Add",             C2, 0, OP_ADD,         "CCS",    "UUU",0,
    "And",             C2, 0, OP_AND,         "CCS",    "UUU",0,
    "Concatenate",     C2, 0, OP_CONCAT,      "CCS",    "UUU",0,
    "CondRefOf",       C2, 0, OP_CONDREFOF,   "SS",     "UU", 0,
    "Decrement",       C2, 0, OP_DECREMENT,   "S",      "U",  0,
    "DerefOf",         C2, 0, OP_DEREFOF,     "C",      "U",  0,
    "Divide",          C2, 0, OP_DIVIDE,      "CCSS",   "UUUU",0,
    "FindSetLeftBit",  C2, 0, OP_FINDSETLBIT, "CS",     "UU", 0,
    "FindSetRightBit", C2, 0, OP_FINDSETRBIT, "CS",     "UU", 0,
    "FromBCD",         C2, 0, OP_FROMBCD,     "CS",     "UU", 0,
    "Increment",       C2, 0, OP_INCREMENT,   "S",      "U",  0,
    "Index",           C2, 0, OP_INDEX,       "CCS",    "UUU",0,
    "LAnd",            C2, 0, OP_LAND,        "CC",     "UU", 0,
    "LEqual",          C2, 0, OP_LEQ,         "CC",     "UU", 0,
    "LGreater",        C2, 0, OP_LG,          "CC",     "UU", 0,
    "LGreaterEqual",   C2, 0, OP_LGEQ,        "CC",     "UU", 0,
    "LLess",           C2, 0, OP_LL,          "CC",     "UU", 0,
    "LLessEqual",      C2, 0, OP_LLEQ,        "CC",     "UU", 0,
    "LNot",            C2, 0, OP_LNOT,        "C",      "U",  0,
    "LNotEqual",       C2, 0, OP_LNOTEQ,      "CC",     "UU", 0,
    "LOr",             C2, 0, OP_LOR,         "CC",     "UU", 0,
    "Match",           C2, 0, OP_MATCH,       "CKCKCC", "UFUFUU",AF,
    "Multiply",        C2, 0, OP_MULTIPLY,    "CCS",    "UUU",0,
    "NAnd",            C2, 0, OP_NAND,        "CCS",    "UUU",0,
    "NOr",             C2, 0, OP_NOR,         "CCS",    "UUU",0,
    "Not",             C2, 0, OP_NOT,         "CS",     "UU", 0,
    "ObjectType",      C2, 0, OP_OBJTYPE,     "S",      "U",  0,
    "Or",              C2, 0, OP_OR,          "CCS",    "UUU",0,
    "RefOf",           C2, 0, OP_REFOF,       "S",      "U",  0,
    "ShiftLeft",       C2, 0, OP_SHIFTL,      "CCS",    "UUU",0,
    "ShiftRight",      C2, 0, OP_SHIFTR,      "CCS",    "UUU",0,
    "SizeOf",          C2, 0, OP_SIZEOF,      "S",      "U",  0,
    "Store",           C2, 0, OP_STORE,       "CS",     "UU", 0,
    "Subtract",        C2, 0, OP_SUBTRACT,    "CCS",    "UUU",0,
    "ToBCD",           C2, 0, OP_TOBCD,       "CS",     "UU", 0,
    "Wait",            C2, 0, OP_WAIT,        "SC",     "E",  0,
    "XOr",             C2, 0, OP_XOR,         "CCS",    "UUU",0,

    NULL,              0,  0, OP_NONE,   NULL, NULL, 0
};

UCHAR OpClassTable[256] =
{ //0x00                0x01                0x02                0x03
    CONSTOBJ,           CONSTOBJ,           INVALID,            INVALID,
  //0x04                0x05                0x06                0x07
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0x08                0x09                0x0a                0x0b
    CODEOBJ,            INVALID,            DATAOBJ,            DATAOBJ,
  //0x0c                0x0d                0x0e                0x0f
    DATAOBJ,            DATAOBJ,            INVALID,            INVALID,
  //0x10                0x11                0x12                0x13
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x14                0x15                0x16                0x17
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0x18                0x19                0x1a                0x1b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x1c                0x1d                0x1e                0x1f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x20                0x21                0x22                0x23
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x24                0x25                0x26                0x27
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x28                0x29                0x2a                0x2b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x2c                0x2d                0x2e                0x2f
    INVALID,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x30                0x31                0x32                0x33
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x34                0x35                0x36                0x37
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x38                0x39                0x3a                0x3b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x3c                0x3d                0x3e                0x3f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x40                0x41                0x42                0x43
    INVALID,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x44                0x45                0x46                0x47
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x48                0x49                0x4a                0x4b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x4c                0x4d                0x4e                0x4f
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x50                0x51                0x52                0x53
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x54                0x55                0x56                0x57
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x58                0x59                0x5a                0x5b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            INVALID,
  //0x5c                0x5d                0x5e                0x5f
    NAMEOBJ,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x60                0x61                0x62                0x63
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x64                0x65                0x66                0x67
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x68                0x69                0x6a                0x6b
    ARGOBJ,             ARGOBJ,             ARGOBJ,             ARGOBJ,
  //0x6c                0x6d                0x6e                0x6f
    ARGOBJ,             ARGOBJ,             ARGOBJ,             INVALID,
  //0x70                0x71                0x72                0x73
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x74                0x75                0x76                0x77
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x78                0x79                0x7a                0x7b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x7c                0x7d                0x7e                0x7f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x80                0x81                0x82                0x83
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x84                0x85                0x86                0x87
    INVALID,            INVALID,            CODEOBJ,            CODEOBJ,
  //0x88                0x89                0x8a                0x8b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x8c                0x8d                0x8e                0x8f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x90                0x91                0x92                0x93
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x94                0x95                0x96                0x97
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0x98                0x99                0x9a                0x9b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x9c                0x9d                0x9e                0x9f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xa0                0xa1                0xa2                0xa3
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0xa4                0xa5                0xa6                0xa7
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0xa8                0xa9                0xaa                0xab
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xac                0xad                0xae                0xaf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb0                0xb1                0xb2                0xb3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb4                0xb5                0xb6                0xb7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb8                0xb9                0xba                0xbb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xbc                0xbd                0xbe                0xbf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc0                0xc1                0xc2                0xc3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc4                0xc5                0xc6                0xc7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc8                0xc9                0xca                0xcb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xcc                0xcd                0xce                0xcf
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0xd0                0xd1                0xd2                0xd3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd4                0xd5                0xd6                0xd7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd8                0xd9                0xda                0xdb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xdc                0xdd                0xde                0xdf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe0                0xe1                0xe2                0xe3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe4                0xe5                0xe6                0xe7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe8                0xe9                0xea                0xeb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xec                0xed                0xee                0xef
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf0                0xf1                0xf2                0xf3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf4                0xf5                0xf6                0xf7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf8                0xf9                0xfa                0xfb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xfc                0xfd                0xfe                0xff
    INVALID,            INVALID,            INVALID,            CONSTOBJ
};

OPMAP ExOpClassTable[] =
{
    EXOP_MUTEX,         CODEOBJ,
    EXOP_EVENT,         CODEOBJ,
    EXOP_CONDREFOF,     CODEOBJ,
    EXOP_CREATEFIELD,   CODEOBJ,
    EXOP_LOAD,          CODEOBJ,
    EXOP_STALL,         CODEOBJ,
    EXOP_SLEEP,         CODEOBJ,
    EXOP_ACQUIRE,       CODEOBJ,
    EXOP_SIGNAL,        CODEOBJ,
    EXOP_WAIT,          CODEOBJ,
    EXOP_RESET,         CODEOBJ,
    EXOP_RELEASE,       CODEOBJ,
    EXOP_FROMBCD,       CODEOBJ,
    EXOP_TOBCD,         CODEOBJ,
    EXOP_UNLOAD,        CODEOBJ,
    EXOP_REVISION,      CODEOBJ,
    EXOP_DEBUG,         CODEOBJ,
    EXOP_FATAL,         CODEOBJ,
    EXOP_OPREGION,      CODEOBJ,
    EXOP_FIELD,         CODEOBJ,
    EXOP_DEVICE,        CODEOBJ,
    EXOP_PROCESSOR,     CODEOBJ,
    EXOP_POWERRES,      CODEOBJ,
    EXOP_THERMALZONE,   CODEOBJ,
    EXOP_IDXFIELD,      CODEOBJ,
    EXOP_BANKFIELD,     CODEOBJ,
    0,                  0
};


/*** END Local data
 */


DECLARE_API( amli )
/*++

Routine Description:

    Invoke AMLI debugger

Arguments:

    None

Return Value:

    None

--*/
{
    if ((args == NULL) || (*args == '\0'))
    {
        dprintf("Usage: amli <cmd> [arguments ...]\n"
                "where <cmd> is one of the following:\n");
        AMLIDbgHelp(NULL, NULL, 0, 0);
        dprintf("\n");
    }
    else
    {
        AMLIDbgExecuteCmd((PSZ)args);
        dprintf("\n");
    }
    return S_OK;
}


/***EP  AMLIDbgExecuteCmd - Parse and execute a debugger command
 *
 *  ENTRY
 *      pszCmd -> command string
 *
 *  EXIT
 *      None
 */

VOID STDCALL AMLIDbgExecuteCmd(PSZ pszCmd)
{
    PSZ psz;
    int i;
    ULONG dwNumArgs = 0, dwNonSWArgs = 0;

    if ((psz = strtok(pszCmd, gcszTokenSeps)) != NULL)
    {
        for (i = 0; DbgCmds[i].pszCmd != NULL; i++)
        {
            if (strcmp(psz, DbgCmds[i].pszCmd) == 0)
            {
                if ((DbgCmds[i].pArgTable == NULL) ||
                    (DbgParseArgs(DbgCmds[i].pArgTable,
                                  &dwNumArgs,
                                  &dwNonSWArgs,
                                  gcszTokenSeps) == ARGERR_NONE))
                {
                    ASSERT(DbgCmds[i].pfnCmd != NULL);
                    DbgCmds[i].pfnCmd(NULL, NULL, dwNumArgs, dwNonSWArgs);
                }
                break;
            }
        }
    }
    else
    {
        DBG_ERROR(("invalid command \"%s\"", pszCmd));
    }
}       //AMLIDbgExecuteCmd

/***LP  AMLIDbgHelp - help
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgHelp(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                       ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwNonSWArgs);
    //
    // User typed ? <cmd>
    //
    if (pszArg != NULL)
    {
        if (strcmp(pszArg, "?") == 0)
        {
            dprintf("\nHelp:\n");
            dprintf("Usage: ? [<Cmd>]\n");
            dprintf("<Cmd> - command to get help on\n");
        }
        else if (strcmp(pszArg, "debugger") == 0)
        {
            dprintf("\nRequest entering AMLI debugger:\n");
            dprintf("Usage: debugger\n");
        }
        else if (strcmp(pszArg, "dns") == 0)
        {
            dprintf("\nDump Name Space Object:\n");
            dprintf("Usage: dns [[/s] [<NameStr> | <Addr>]]\n");
            dprintf("s         - recursively dump the name space subtree\n");
            dprintf("<NameStr> - name space path (dump whole name space if absent)\n");
            dprintf("<Addr>    - specify address of the name space object\n");
        }
        else if (strcmp(pszArg, "find") == 0)
        {
            dprintf("\nFind NameSpace Object:\n");
            dprintf("Usage: find <NameSeg>\n");
            dprintf("<NameSeg> - Name of the NameSpace object without path\n");
        }
        else
        {
            DBG_ERROR(("invalid help command - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }
    }
    //
    // User typed just a "?" without any arguments
    //
    else if (dwArgNum == 0)
    {
        dprintf("\n");
        dprintf("Help                     - ? [<Cmd>]\n");
        dprintf("Request entering debugger- debugger\n");
        dprintf("Dump Name Space Object   - dns [[/s] [<NameStr> | <Addr>]]\n");
        dprintf("Find NameSpace Object    - find <NameSeg>\n");
    }

    return rc;
}       //AMLIDbgHelp


/***LP  AMLIDbgDebugger - Request entering debugger
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgDebugger(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs)
{
    LONG    rc = DBGERR_NONE;
    ULONG64 Address = 0;
    DWORD   dwfDebugger = 0;
    ULONG   Offset = 0;
    
    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        Address = GetExpression("ACPI!gDebugger");
        InitTypeRead(Address, ACPI!_dbgr);
        if(Address != 0)
        {
            dwfDebugger = (ULONG)ReadField(dwfDebugger);
            dwfDebugger |= DBGF_DEBUGGER_REQ;
            GetFieldOffset("ACPI!_dbgr", "dwfDebugger", &Offset);
            Address = Address + (ULONG64)Offset;
            WriteAtAddress(Address, dwfDebugger, sizeof(dwfDebugger));
            if(rc != DBGERR_NONE)
            {
                DBG_ERROR(("failed to set dwfDebugger"));
            }
        }
        else
        {
            DBG_ERROR(("failed to get debugger flag address"));
            rc = DBGERR_CMD_FAILED;
        }
    }
    else
    {
        DBG_ERROR(("invalid debugger command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //AMLIDbgDebugger

/***LP  AMLIDbgDNS - Dump Name Space
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgDNS(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                      ULONG dwNonSWArgs)
{
    LONG    rc = DBGERR_NONE;
    ULONG64 ObjData;
    ULONG64 uipNSObj;

    DEREF(pArg);
    DEREF(dwNonSWArgs);
    //
    // User specified name space path or name space node address
    //
    if (pszArg != NULL)
    {
        if (!IsNumber(pszArg, 16, &uipNSObj))
        {
            //
            // The argument is not an address, could be a name space path.
            //
            _strupr(pszArg);
            rc = DumpNSObj(pszArg,
                           (BOOLEAN)((dwCmdArg & DNSF_RECURSE) != 0));
        }
        else if (InitTypeRead(uipNSObj, ACPI!_NSObj))
        {
            DBG_ERROR(("failed to Initialize NameSpace object at %I64x", uipNSObj));
            rc = DBGERR_INVALID_CMD;
        }
        else
        {
            dprintf("\nACPI Name Space: %s (%I64x)\n",
                   GetObjAddrPath(uipNSObj), uipNSObj);
            if (dwCmdArg & DNSF_RECURSE)
            {
                DumpNSTree(&uipNSObj, 0);
            }
            else
            {
                InitTypeRead(uipNSObj, ACPI!_NSObj);
                ObjData = ReadField(ObjData);
                AMLIDumpObject(&ObjData, NameSegString((ULONG)ReadField(dwNameSeg)), 0);
            }
        }
    }
    else
    {
        if (dwArgNum == 0)
        {
            //
            // User typed "dns" but did not specify any name space path
            // or address.
            //
            rc = DumpNSObj(NAMESTR_ROOT, TRUE);
        }

        dwCmdArg = 0;
    }

    return rc;
}       //AMLIDbgDNS

/***LP  DumpNSObj - Dump name space object
 *
 *  ENTRY
 *      pszPath -> name space path string
 *      fRecursive - TRUE if also dump the subtree recursively
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_ code
 */

LONG LOCAL DumpNSObj(PSZ pszPath, BOOLEAN fRecursive)
{
    LONG rc = DBGERR_NONE;
    ULONG64 uipns=0;
    ULONG64 NSObj=0;
    ULONG64 ObjData=0;
    ULONG   dwNameSeg = 0;

    if ((rc = GetNSObj(pszPath, NULL, &uipns, &NSObj,
                       NSF_LOCAL_SCOPE | NSF_WARN_NOTFOUND)) == DBGERR_NONE)
    {
        dprintf("\nACPI Name Space: %s (%I64x)\n", pszPath, uipns);
        if (!fRecursive)
        {
            char szName[sizeof(NAMESEG) + 1] = {0};

            InitTypeRead(NSObj, ACPI!_NSObj);
            dwNameSeg = (ULONG)ReadField(dwNameSeg);
            STRCPYN(szName, (PSZ)&dwNameSeg, sizeof(NAMESEG));
            ObjData = ReadField(ObjData);
            AMLIDumpObject(&ObjData, szName, 0);
        }
        else
        {
            DumpNSTree(&NSObj, 0);
        }
    }
    return rc;
}       //DumpNSObj

/***LP  DumpNSTree - Dump all the name space objects in the subtree
 *
 *  ENTRY
 *      pnsObj -> name space subtree root
 *      dwLevel - indent level
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpNSTree(PULONG64 pnsObj, ULONG dwLevel)
{
    char    szName[sizeof(NAMESEG) + 1] = {0};
    ULONG64 uipns, uipnsNext;
    ULONG64 NSObj, FirstChild, Obj;
    ULONG   dwNameSeg = 0;
    
    //
    // First, dump myself
    //
    if(InitTypeRead(*pnsObj, ACPI!_NSObj))
            dprintf("DumpNSTree: Failed to initialize pnsObj (%I64x)\n", *pnsObj);
    else
    {
        FirstChild = ReadField(pnsFirstChild);
        dwNameSeg = (ULONG)ReadField(dwNameSeg);    
        STRCPYN(szName, (PSZ)&dwNameSeg, sizeof(NAMESEG));
        Obj = (ULONG64)ReadField(ObjData);
        AMLIDumpObject(&Obj, szName, dwLevel);
        //
        // Then, recursively dump each of my children
        //
        for (uipns = FirstChild;
             (uipns != 0) && ((NSObj = uipns) !=0) && (InitTypeRead(NSObj, ACPI!_NSObj) == 0);
             uipns = uipnsNext)
        {
            //
            // If this is the last child, we have no more.
            //
            uipnsNext = ((ReadField(list.plistNext) ==
                                      FirstChild)?
                                    0: ReadField(list.plistNext));
            //
            // Dump a child
            //
            DumpNSTree(&NSObj, dwLevel + 1);
        }
    }
}       //DumpNSTree

/***LP  AMLIDbgFind - Find NameSpace Object
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwfDataSize - data size flags
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgFind(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                       ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    ULONG dwLen;
    ULONG64 NSRoot=0;

    DEREF(pArg);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
    
        dwLen = strlen(pszArg);
        _strupr(pszArg);
        if (dwLen > sizeof(NAMESEG))
        {
            DBG_ERROR(("invalid NameSeg - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }
        else if(ReadPointer(GetExpression("acpi!gpnsnamespaceroot"), &NSRoot))
        {
            NAMESEG dwName;

            dwName = NAMESEG_BLANK;
            memcpy(&dwName, pszArg, dwLen);
            if (!FindNSObj(dwName, &NSRoot))
            {
                dprintf("No such NameSpace object - %s\n", pszArg);
            }
        }
        else
        {
            DBG_ERROR(("failed to read NameSpace root object"));
        }
    }
    else if (dwArgNum == 0)
    {
        DBG_ERROR(("invalid Find command"));
        rc = DBGERR_INVALID_CMD;
    }


    return rc;
}       //AMLIDbgFind

/***LP  FindNSObj - Find and print the full path of a name space object
 *
 *  ENTRY
 *      dwName - NameSeg of the name space object
 *      nsRoot - root of subtree to search for object
 *
 *  EXIT-SUCCESS
 *      returns TRUE - found at least one match
 *  EXIT-FAILURE
 *      returns FALSE - found no match
 */

BOOLEAN LOCAL FindNSObj(NAMESEG dwName, PULONG64 pnsRoot)
{
    BOOLEAN rc = FALSE;
    ULONG64 uip=0, uipNext=0,  TempNext=0, FirstChild = 0;
    ULONG   dwNameSeg=0;
    ULONG   Offset = 0;

    
    if (pnsRoot != 0)
    {
        if(InitTypeRead(*pnsRoot, ACPI!_NSObj))
            dprintf("FindNSObj: Failed to initialize pnsRoot \n");
        else
        {
            dwNameSeg = (ULONG)ReadField(dwNameSeg);
        }
            
        if (dwName == dwNameSeg)
        {
            dprintf("%s\n", GetObjectPath(pnsRoot));
            rc = TRUE;
        }

        
        FirstChild = ReadField(pnsFirstChild);
        
        if (FirstChild != 0)
        {
            for (uip = FirstChild; 
                 uip != 0 && InitTypeRead(uip, ACPI!_NSObj) == 0;   
                 uip = uipNext)
            {
                
                
                if(InitTypeRead(uip, ACPI!_NSObj))
                    dprintf("FindNSObj: Failed to initialize uip \n");
                
                TempNext = ReadField(list.plistNext);
        
                
                uipNext = ((TempNext == FirstChild) ?
                              0: TempNext);

        
                rc |= FindNSObj(dwName, &uip);
            }
        }
    }

    return rc;
}       //FindNSObj


/***LP  GetObjectPath - get object namespace path
 *
 *  ENTRY
 *      pns -> object
 *
 *  EXIT
 *      returns name space path
 */

PSZ LOCAL GetObjectPath(PULONG64 pns)
{
    static char szPath[MAX_NAME_LEN + 1] = {0};
    ULONG64 NSParent, NSGrandParent;
    ULONG   NameSeg=0;
    ULONG   Length = 0;
    int i;

    if (pns != NULL)
    {
        if(InitTypeRead(*pns, ACPI!_NSObj))
            dprintf("GetObjectPath: Failed to initialize pns \n");

        NSParent = ReadField(pnsParent);
        
        if (NSParent == 0)
        {
            strcpy(szPath, "\\");
        }
        else 
        {
            GetObjectPath(&NSParent);

            if(InitTypeRead(NSParent, ACPI!_NSObj))
                dprintf("GetObjectPath: Failed to initialize NSParent \n");
    
            NSGrandParent = ReadField(pnsParent);
        
            if (NSGrandParent != 0)
            {
                strcat(szPath, ".");
            }

            if(InitTypeRead(*pns, ACPI!_NSObj))
                dprintf("GetObjectPath: Failed to initialize pns \n");
    
            NameSeg = (ULONG)ReadField(dwNameSeg);
            
            StrCat(szPath, (PSZ)&NameSeg, sizeof(NAMESEG));
        
        }

        for (i = StrLen(szPath, -1) - 1; i >= 0; --i)
        {
            if (szPath[i] == '_')
                szPath[i] = '\0';
            else
                break;
        }
    }
    else
    {
        szPath[0] = '\0';
    }
    
    return szPath;
}       //GetObjectPath

/***LP  GetObjAddrPath - get object namespace path
 *
 *  ENTRY
 *      uipns - object address
 *
 *  EXIT
 *      returns name space path
 */

PSZ LOCAL GetObjAddrPath(ULONG64 uipns)
{
    PSZ     psz = NULL;
   
    if (uipns == 0)
    {
        psz = "<null>";
    }
    else 
    {
        psz = GetObjectPath(&uipns);
    }
    
    return psz;
}       //GetObjAddrPath

/***LP  AMLIDumpObject - Dump object info.
 *
 *  ENTRY
 *      pdata -> data
 *      pszName -> object name
 *      iLevel - indent level
 *
 *  EXIT
 *      None
 *
 *  NOTE
 *      If iLevel is negative, no indentation and newline are printed.
 */

VOID LOCAL AMLIDumpObject(PULONG64 pdata, PSZ pszName, int iLevel)
{
    BOOLEAN fPrintNewLine = (BOOLEAN)(iLevel >= 0);
    int i;
    char szName1[sizeof(NAMESEG) + 1],
         szName2[sizeof(NAMESEG) + 1];

    for (i = 0; i < iLevel; ++i)
    {
        dprintf("| ");
    }

    if (pszName == NULL)
    {
        pszName = "";
    }

    if(InitTypeRead(*pdata, ACPI!_ObjData))
        dprintf("AMLIDumpObject: Failed to initialize ObjData (%I64x) \n", pdata);
    else
    {
        switch ((ULONG)ReadField(dwDataType))
        {
            case OBJTYPE_UNKNOWN:
                dprintf("Unknown(%s)", pszName);
                break;

            case OBJTYPE_INTDATA:
                dprintf("Integer(%s:Value=0x%016I64x[%d])",
                       pszName, ReadField(uipDataValue), ReadField(uipDataValue));
                break;

            case OBJTYPE_STRDATA:
            {
                PSZ psz = 0;

                if ((psz = (PSZ)LocalAlloc(LPTR, (ULONG)ReadField(dwDataLen))) == NULL)
                {
                    DBG_ERROR(("AMLIDumpObject: failed to allocate object buffer (size=%d)",
                               (ULONG)ReadField(dwDataLen)));
                }
                else if (!ReadMemory((ULONG64)ReadField(pbDataBuff),
                                     psz,
                                     (ULONG)ReadField(dwDataLen),
                                     NULL))
                {
                    DBG_ERROR(("AMLIDumpObject: failed to read object buffer at %I64x", (ULONG64)ReadField(pbDataBuff)));
                    LocalFree(psz);
                    psz = NULL;
                }
                
                dprintf("String(%s:Str=\"%s\")", pszName, psz);

                if(psz)
                    LocalFree(psz);

                break;
            }
            case OBJTYPE_BUFFDATA:
            {
                PUCHAR pbData = 0;

                if ((pbData = (PUCHAR)LocalAlloc(LPTR, (ULONG)ReadField(dwDataLen))) == NULL)
                {
                    DBG_ERROR(("AMLIDumpObject: failed to allocate object buffer (size=%d)",
                               (ULONG)ReadField(dwDataLen)));
                }
                else if (!ReadMemory((ULONG64)ReadField(pbDataBuff),
                                     pbData,
                                     (ULONG)ReadField(dwDataLen),
                                     NULL))
                {
                    DBG_ERROR(("AMLIDumpObject: failed to read object buffer at %I64x", (ULONG64)ReadField(pbDataBuff)));
                    LocalFree(pbData);
                    pbData = NULL;
                }
                dprintf("Buffer(%s:Ptr=%x,Len=%d)",
                       pszName, (PUCHAR)ReadField(pbDataBuff), (ULONG)ReadField(dwDataLen));
                PrintBuffData(pbData, (ULONG)ReadField(dwDataLen));
                LocalFree(pbData);
                break;
            }
            case OBJTYPE_PKGDATA:
            {
                                
                ULONG64 Pkg;
                ULONG64 PkgNext = 0;
                ULONG   dwcElements = 0;
                ULONG64 offset = 0;
                
                Pkg = ReadField (pbDataBuff);

                InitTypeRead(Pkg, ACPI!_PackageObj); 
                dwcElements = (int)ReadField(dwcElements);

                dprintf("Package(%s:NumElements=%d){", pszName, dwcElements);

                if (fPrintNewLine)
                {
                    dprintf("\n");
                }

                for (i = 0; i < (int)dwcElements; ++i)
                {
                   
                    GetFieldOffset("acpi!_PackageObj", "adata", (ULONG*) &offset);
                    offset += (GetTypeSize ("acpi!_ObjData") * i);
                                            
                    PkgNext = offset + Pkg;
                    AMLIDumpObject(&PkgNext,
                               NULL,
                               fPrintNewLine? iLevel + 1: -1);
                    
                    if (!fPrintNewLine && (i < (int)dwcElements))
                    {
                        dprintf(",");
                    }
                }

                for (i = 0; i < iLevel; ++i)
                {
                    dprintf("| ");
                }

                dprintf("}");
                break;
            }
            case OBJTYPE_FIELDUNIT:
            {
                
                InitTypeRead((ULONG64)ReadField(pbDataBuff), ACPI!_FieldUnitObj);
                
                dprintf("FieldUnit(%s:FieldParent=%I64x,ByteOffset=0x%x,StartBit=0x%x,NumBits=%d,FieldFlags=0x%x)",
                       pszName,
                       ReadField(pnsFieldParent),
                       (ULONG)ReadField(FieldDesc.dwByteOffset),
                       (ULONG)ReadField(FieldDesc.dwStartBitPos),
                       (ULONG)ReadField(FieldDesc.dwNumBits),
                       (ULONG)ReadField(FieldDesc.dwFieldFlags));
                break;
            }
            case OBJTYPE_DEVICE:
                dprintf("Device(%s)", pszName);
                break;

            case OBJTYPE_EVENT:
                dprintf("Event(%s:pKEvent=%x)", pszName, ReadField(pbDataBuff));
                break;

            case OBJTYPE_METHOD:
            {
               
                ULONG       DataLength = 0;
                ULONG       Offset = 0;
                ULONG64     pbDataBuff = 0;
                
                DataLength = (ULONG)ReadField(dwDataLen);
                pbDataBuff = (ULONG64)ReadField(pbDataBuff);
                InitTypeRead(pbDataBuff, ACPI!_MethodObj);
                GetFieldOffset("ACPI!_MethodObj", "abCodeBuff", &Offset);

                dprintf("Method(%s:Flags=0x%x,CodeBuff=%I64x,Len=%d)",
                       pszName, (UCHAR)ReadField(bMethodFlags), 
                       (ULONG64)Offset + pbDataBuff,
                       DataLength - Offset);
                break;
            }
            case OBJTYPE_MUTEX:
                dprintf("Mutex(%s:pKMutex=%I64x)", pszName, (PULONG64)ReadField(pbDataBuff));
                break;

            case OBJTYPE_OPREGION:
            {
                InitTypeRead((ULONG64)ReadField(pbDataBuff), ACPI!_OpRegionObj);
                
                dprintf("OpRegion(%s:RegionSpace=%s,Offset=0x%I64x,Len=%d)",
                       pszName,
                       GetRegionSpaceName((UCHAR)ReadField(bRegionSpace)),
                       (ULONG64)ReadField(uipOffset),
                       (ULONG)ReadField(dwLen));
                break;
            }
            case OBJTYPE_POWERRES:
            {
               
                InitTypeRead((ULONG64)ReadField(pbDataBuff), ACPI!_PowerResObj);
                
                dprintf("PowerResource(%s:SystemLevel=0x%x,ResOrder=%d)",
                       pszName, (UCHAR)ReadField(bSystemLevel), (UCHAR)ReadField(bResOrder));
                break;
            }
            case OBJTYPE_PROCESSOR:
            {
                InitTypeRead((ULONG64)ReadField(pbDataBuff), ACPI!_ProcessorObj);
                
                dprintf("Processor(%s:Processor ID=0x%x,PBlk=0x%x,PBlkLen=%d)",
                       pszName,
                       (UCHAR)ReadField(bApicID),
                       (ULONG)ReadField(dwPBlk),
                       (ULONG)ReadField(dwPBlkLen));
                break;
            }
            case OBJTYPE_THERMALZONE:
                dprintf("ThermalZone(%s)", pszName);
                break;

            case OBJTYPE_BUFFFIELD:
            {
                
                InitTypeRead((ULONG64)ReadField(pbDataBuff), ACPI!_BuffFieldObj);
                
                dprintf("BufferField(%s:Ptr=%I64x,Len=%d,ByteOffset=0x%x,StartBit=0x%x,NumBits=%d,FieldFlags=0x%x)",
                       pszName, 
                       ReadField(pbDataBuff), 
                       (ULONG)ReadField(dwBuffLen),
                       (ULONG)ReadField(FieldDesc.dwByteOffset), 
                       (ULONG)ReadField(FieldDesc.dwStartBitPos),
                       (ULONG)ReadField(FieldDesc.dwNumBits), 
                       (ULONG)ReadField(FieldDesc.dwFieldFlags));
                break;
            }
            case OBJTYPE_DDBHANDLE:
                dprintf("DDBHandle(%s:Handle=%I64x)", pszName, (ULONG64)ReadField(pbDataBuff));
                break;

            case OBJTYPE_OBJALIAS:
            {
                ULONG64 NSObj = 0;
                ULONG dwDataType;

                NSObj = ReadField(pnsAlias);

                if (NSObj)
                {
                    InitTypeRead(NSObj, ACPI!_NSObj);
                    
                    dwDataType = (ULONG)ReadField(ObjData.dwDataType);
                }
                else
                {
                    dwDataType = OBJTYPE_UNKNOWN;
                }
                dprintf("ObjectAlias(%s:Alias=%s,Type=%s)",
                       pszName, GetObjAddrPath(NSObj),
                       AMLIGetObjectTypeName(dwDataType));
                break;
            }
            case OBJTYPE_DATAALIAS:
            {
                ULONG64 Obj = 0;

                dprintf("DataAlias(%s:Link=%I64x)", pszName, ReadField(pdataAlias));
                Obj = ReadField(pdataAlias);
                if (fPrintNewLine && Obj)
                {
                    AMLIDumpObject(&Obj, NULL, iLevel + 1);
                    fPrintNewLine = FALSE;
                }
                break;
            }
            case OBJTYPE_BANKFIELD:
            {
                ULONG64 NSObj = 0;
                ULONG64 DataBuff = 0;
                ULONG   dwNameSeg = 0;
    
                DataBuff = (ULONG64)ReadField(pbDataBuff);
                
                InitTypeRead(DataBuff, ACPI!_BankFieldObj);
                NSObj = ReadField(pnsBase);
                InitTypeRead(NSObj, ACPI!_NSObj);
                
                if (NSObj)
                {
                    dwNameSeg = (ULONG)ReadField(dwNameSeg);
                    STRCPYN(szName1, (PSZ)&dwNameSeg, sizeof(NAMESEG));
                }
                else
                {
                    szName1[0] = '\0';
                }

                InitTypeRead(DataBuff, ACPI!_BankFieldObj);
                NSObj = ReadField(pnsBank);
                InitTypeRead(NSObj, ACPI!_NSObj);
                
                if (NSObj)
                {
                    dwNameSeg = (ULONG)ReadField(dwNameSeg);
                    STRCPYN(szName2, (PSZ)&dwNameSeg, sizeof(NAMESEG));
                }
                else
                {
                    szName2[0] = '\0';
                }

                InitTypeRead(DataBuff, ACPI!_BankFieldObj);
                dprintf("BankField(%s:Base=%s,BankName=%s,BankValue=0x%x)",
                       pszName, szName1, szName2, (ULONG)ReadField(dwBankValue));
                break;
            }
            case OBJTYPE_FIELD:
            {
                ULONG64 NSObj = 0;
                ULONG64 pf = 0;
                ULONG   dwNameSeg = 0;
                
                pf = ReadField(pbDataBuff);
                InitTypeRead(pf, ACPI!_FieldObj);
                NSObj = ReadField(pnsBase);
                InitTypeRead(NSObj, ACPI!_NSObj);
                
                if (NSObj)
                {
                    dwNameSeg = (ULONG)ReadField(dwNameSeg);
                    STRCPYN(szName1, (PSZ)&dwNameSeg, sizeof(NAMESEG));
                }
                else
                {
                    szName1[0] = '\0';
                }
                dprintf("Field(%s:Base=%s)", pszName, szName1);
                break;
            }
            case OBJTYPE_INDEXFIELD:
            {
                ULONG64 pif = 0;
                ULONG64 NSObj = 0;
                ULONG   dwNameSeg = 0;
                
                pif = (ULONG64)ReadField(pbDataBuff);
                
                InitTypeRead(pif, ACPI!_IndexFieldObj);
                NSObj = ReadField(pnsIndex);
                InitTypeRead(NSObj, ACPI!_NSObj);
                
                if (NSObj)
                {
                    dwNameSeg = (ULONG)ReadField(dwNameSeg);
                    STRCPYN(szName1, (PSZ)&dwNameSeg, sizeof(NAMESEG));
                }
                else
                {
                    szName1[0] = '\0';
                }

                InitTypeRead(pif, ACPI!_IndexFieldObj);
                NSObj = ReadField(pnsData);
                InitTypeRead(NSObj, ACPI!_NSObj);
                
                if (NSObj)
                {
                    dwNameSeg = (ULONG)ReadField(dwNameSeg);
                    STRCPYN(szName2, (PSZ)&dwNameSeg, sizeof(NAMESEG));
                }
                else
                {
                    szName2[0] = '\0';
                }

                dprintf("IndexField(%s:IndexName=%s,DataName=%s)",
                       pszName, szName1, szName2);
                break;
            }
            default:
                DBG_ERROR(("unexpected data object type (type=%x)",
                            (ULONG)ReadField(dwDataType)));
        }
    }

    if (fPrintNewLine)
    {
        dprintf("\n");
    }

}       //DumpObject

/***LP  AMLIGetObjectTypeName - get object type name
 *
 *  ENTRY
 *      dwObjType - object type
 *
 *  EXIT
 *      return object type name
 */

PSZ LOCAL AMLIGetObjectTypeName(ULONG dwObjType)
{
    PSZ psz = NULL;
    int i;
    static struct
    {
        ULONG dwObjType;
        PSZ   pszObjTypeName;
    } ObjTypeTable[] =
        {
            OBJTYPE_UNKNOWN,    "Unknown",
            OBJTYPE_INTDATA,    "Integer",
            OBJTYPE_STRDATA,    "String",
            OBJTYPE_BUFFDATA,   "Buffer",
            OBJTYPE_PKGDATA,    "Package",
            OBJTYPE_FIELDUNIT,  "FieldUnit",
            OBJTYPE_DEVICE,     "Device",
            OBJTYPE_EVENT,      "Event",
            OBJTYPE_METHOD,     "Method",
            OBJTYPE_MUTEX,      "Mutex",
            OBJTYPE_OPREGION,   "OpRegion",
            OBJTYPE_POWERRES,   "PowerResource",
            OBJTYPE_PROCESSOR,  "Processor",
            OBJTYPE_THERMALZONE,"ThermalZone",
            OBJTYPE_BUFFFIELD,  "BuffField",
            OBJTYPE_DDBHANDLE,  "DDBHandle",
            OBJTYPE_DEBUG,      "Debug",
            OBJTYPE_OBJALIAS,   "ObjAlias",
            OBJTYPE_DATAALIAS,  "DataAlias",
            OBJTYPE_BANKFIELD,  "BankField",
            OBJTYPE_FIELD,      "Field",
            OBJTYPE_INDEXFIELD, "IndexField",
            OBJTYPE_DATA,       "Data",
            OBJTYPE_DATAFIELD,  "DataField",
            OBJTYPE_DATAOBJ,    "DataObject",
            0,                  NULL
        };

    for (i = 0; ObjTypeTable[i].pszObjTypeName != NULL; ++i)
    {
        if (dwObjType == ObjTypeTable[i].dwObjType)
        {
            psz = ObjTypeTable[i].pszObjTypeName;
            break;
        }
    }

    return psz;
}       //GetObjectTypeName

/***LP  GetRegionSpaceName - get region space name
 *
 *  ENTRY
 *      bRegionSpace - region space
 *
 *  EXIT
 *      return object type name
 */

PSZ LOCAL GetRegionSpaceName(UCHAR bRegionSpace)
{
    PSZ psz = NULL;
    int i;
    static PSZ pszVendorDefined = "VendorDefined";
    static struct
    {
        UCHAR bRegionSpace;
        PSZ   pszRegionSpaceName;
    } RegionNameTable[] =
        {
            REGSPACE_MEM,       "SystemMemory",
            REGSPACE_IO,        "SystemIO",
            REGSPACE_PCICFG,    "PCIConfigSpace",
            REGSPACE_EC,        "EmbeddedController",
            REGSPACE_SMB,       "SMBus",
            0,                  NULL
        };

    for (i = 0; RegionNameTable[i].pszRegionSpaceName != NULL; ++i)
    {
        if (bRegionSpace == RegionNameTable[i].bRegionSpace)
        {
            psz = RegionNameTable[i].pszRegionSpaceName;
            break;
        }
    }

    if (psz == NULL)
    {
        psz = pszVendorDefined;
    }

    return psz;
}       //GetRegionSpaceName


/***LP  PrintBuffData - Print buffer data
 *
 *  ENTRY
 *      pb -> buffer
 *      dwLen - length of buffer
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintBuffData(PUCHAR pb, ULONG dwLen)
{
    int i, j;

    dprintf("{");
    for (i = j = 0; i < (int)dwLen; ++i)
    {
        if (j == 0)
            dprintf("\n\t0x%02x", pb[i]);
        else
            dprintf(",0x%02x", pb[i]);

        j++;
        if (j >= 14)
            j = 0;
    }
    dprintf("}");

}       //PrintBuffData


/***LP  IsNumber - Check if string is a number, if so return the number
 *
 *  ENTRY
 *      pszStr -> string
 *      dwBase - base
 *      puipValue -> to hold the number
 *
 *  EXIT-SUCCESS
 *      returns TRUE - the string is a number
 *  EXIT-FAILURE
 *      returns FALSE - the string is not a number
 */

BOOLEAN LOCAL IsNumber(PSZ pszStr, ULONG dwBase, PULONG64 puipValue)
{
    BOOLEAN rc=TRUE;
    PSZ psz;

    *puipValue = AMLIUtilStringToUlong64(pszStr, &psz, dwBase);
    rc = ((psz != pszStr) && (*psz == '\0'))? TRUE: FALSE;
    return rc;
}       //IsNumber


/***EP  DbgParseArgs - parse command arguments
 *
 *  ENTRY
 *      pArgs -> command argument table
 *      pdwNumArgs -> to hold the number of arguments parsed
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *      pszTokenSeps -> token separator characters string
 *
 *  EXIT-SUCCESS
 *      returns ARGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DbgParseArgs(PCMDARG ArgTable, PULONG pdwNumArgs,
                        PULONG pdwNonSWArgs, PSZ pszTokenSeps)
{
    LONG rc = ARGERR_NONE;
    PSZ psz;

    *pdwNumArgs = 0;
    *pdwNonSWArgs = 0;
    while ((psz = strtok(NULL, pszTokenSeps)) != NULL)
    {
        (*pdwNumArgs)++;
        if ((rc = DbgParseOneArg(ArgTable, psz, *pdwNumArgs, pdwNonSWArgs)) !=
            ARGERR_NONE)
        {
            break;
        }
    }

    return rc;
}       //DbgParseArgs

/***LP  DbgParseOneArg - parse one command argument
 *
 *  ENTRY
 *      pArgs -> command argument table
 *      psz -> argument string
 *      dwArgNum - argument number
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *
 *  EXIT-SUCCESS
 *      returns ARGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DbgParseOneArg(PCMDARG ArgTable, PSZ psz, ULONG dwArgNum,
                          PULONG pdwNonSWArgs)
{
    LONG rc = ARGERR_NONE;
    PCMDARG pArg;
    PSZ pszEnd;

    if ((pArg = DbgMatchArg(ArgTable, &psz, pdwNonSWArgs)) != NULL)
    {
        switch (pArg->dwArgType)
        {
            case AT_STRING:
            case AT_NUM:
                if (pArg->dwfArg & AF_SEP)
                {
                    if ((*psz != '\0') &&
                        (strchr(pszOptionSeps, *psz) != NULL))
                    {
                        psz++;
                    }
                    else
                    {
                        ARG_ERROR(("argument missing option separator - %s",
                                   psz));
                        rc = ARGERR_SEP_NOT_FOUND;
                        break;
                    }
                }

                if (pArg->dwArgType == AT_STRING)
                {
                    *((PSZ *)pArg->pvArgData) = psz;
                }
                else
                {
                    *((PLONG)pArg->pvArgData) =
                        strtol(psz, &pszEnd, pArg->dwArgParam);
                    if (psz == pszEnd)
                    {
                        ARG_ERROR(("invalid numeric argument - %s", psz));
                        rc = ARGERR_INVALID_NUMBER;
                        break;
                    }
                }

                if (pArg->pfnArg != NULL)
                {
                    rc = pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs);
                }
                break;

            case AT_ENABLE:
            case AT_DISABLE:
                if (pArg->dwArgType == AT_ENABLE)
                    *((PULONG)pArg->pvArgData) |= pArg->dwArgParam;
                else
                    *((PULONG)pArg->pvArgData) &= ~pArg->dwArgParam;

                if ((pArg->pfnArg != NULL) &&
                    (pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs) !=
                     ARGERR_NONE))
                {
                    break;
                }

                if (*psz != '\0')
                {
                    rc = DbgParseOneArg(ArgTable, psz, dwArgNum, pdwNonSWArgs);
                }
                break;

            case AT_ACTION:
                ASSERT(pArg->pfnArg != NULL);
                rc = pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs);
                break;

            default:
                ARG_ERROR(("invalid argument table"));
                rc = ARGERR_ASSERT_FAILED;
        }
    }
    else
    {
        ARG_ERROR(("invalid command argument - %s", psz));
        rc = ARGERR_INVALID_ARG;
    }

    return rc;
}       //DbgParseOneArg

/***LP  DbgMatchArg - match argument type from argument table
 *
 *  ENTRY
 *      ArgTable -> argument table
 *      ppsz -> argument string pointer
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *
 *  EXIT-SUCCESS
 *      returns pointer to argument entry matched
 *  EXIT-FAILURE
 *      returns NULL
 */

PCMDARG LOCAL DbgMatchArg(PCMDARG ArgTable, PSZ *ppsz, PULONG pdwNonSWArgs)
{
    PCMDARG pArg;

    for (pArg = ArgTable; pArg->dwArgType != AT_END; pArg++)
    {
        if (pArg->pszArgID == NULL)     //NULL means match anything.
        {
            (*pdwNonSWArgs)++;
            break;
        }
        else
        {
            ULONG dwLen;

            if (strchr(pszSwitchChars, **ppsz) != NULL)
                (*ppsz)++;

            dwLen = strlen(pArg->pszArgID);
            if (StrCmp(pArg->pszArgID, *ppsz, dwLen,
                       (BOOLEAN)((pArg->dwfArg & AF_NOI) != 0)) == 0)
            {
                (*ppsz) += dwLen;
                break;
            }
        }
    }

    if (pArg->dwArgType == AT_END)
        pArg = NULL;

    return pArg;
}       //DbgMatchArg

/***EP  MemZero - Fill target buffer with zeros
 *
 *  ENTRY
 *      uipAddr - target buffer address
 *      dwSize - target buffer size
 *
 *  EXIT
 *      None
 */

VOID MemZero(ULONG64 uipAddr, ULONG dwSize)
{
    PUCHAR pbBuff;
    //
    // LPTR will zero init the buffer
    //
    if ((pbBuff = LocalAlloc(LPTR, dwSize)) != NULL)
    {
        if (!WriteMemory(uipAddr, pbBuff, dwSize, NULL))
        {
            DBG_ERROR(("MemZero: failed to write memory"));
        }
        LocalFree(pbBuff);
    }
    else
    {
        DBG_ERROR(("MemZero: failed to allocate buffer"));
    }
}       //MemZero

/***EP  ReadMemByte - Read a byte from target address
 *
 *  ENTRY
 *      uipAddr - target address
 *
 *  EXIT
 *      None
 */

BYTE ReadMemByte(ULONG64 uipAddr)
{
    BYTE bData = 0;

    if (!ReadMemory(uipAddr, &bData, sizeof(bData), NULL))
    {
        DBG_ERROR(("ReadMemByte: failed to read address %I64x", uipAddr));
    }

    return bData;
}       //ReadMemByte

/***EP  ReadMemWord - Read a word from target address
 *
 *  ENTRY
 *      uipAddr - target address
 *
 *  EXIT
 *      None
 */

WORD ReadMemWord(ULONG64 uipAddr)
{
    WORD wData = 0;

    if (!ReadMemory(uipAddr, &wData, sizeof(wData), NULL))
    {
        DBG_ERROR(("ReadMemWord: failed to read address %I64x", uipAddr));
    }

    return wData;
}       //ReadMemWord

/***EP  ReadMemDWord - Read a dword from target address
 *
 *  ENTRY
 *      uipAddr - target address
 *
 *  EXIT
 *      None
 */

DWORD ReadMemDWord(ULONG64 uipAddr)
{
    DWORD dwData = 0;

    if (!ReadMemory(uipAddr, &dwData, sizeof(dwData), NULL))
    {
        DBG_ERROR(("ReadMemDWord: failed to read address %I64x", uipAddr));
    }

    return dwData;
}       //ReadMemDWord

/***EP  ReadMemUlong64 - Read a ulong64 from target address
 *
 *  ENTRY
 *      uipAddr - target address
 *
 *  EXIT
 *      64 bit address
 */

ULONG64 ReadMemUlong64(ULONG64 uipAddr)
{
    ULONG_PTR uipData = 0;

    if (!ReadMemory(uipAddr, &uipData, sizeof(uipData), NULL))
    {
        DBG_ERROR(("ReadMemUlong64: failed to read address %I64x", uipAddr));
    }

    return uipData;
}       //ReadMemUlongPtr

/***LP  GetObjBuff - Allocate and read object buffer
 *
 *  ENTRY
 *      pdata -> object data
 *
 *  EXIT
 *      return the allocated object buffer pointer
 */


/***LP  GetNSObj - Find a name space object
 *
 *  ENTRY
 *      pszObjPath -> object path string
 *      pnsScope - object scope to start the search (NULL means root)
 *      puipns -> to hold the pnsobj address if found
 *      pns -> buffer to hold the object found
 *      dwfNS - flags
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_ code
 */

LONG LOCAL GetNSObj(PSZ pszObjPath, PULONG64 pnsScope, PULONG64 puipns,
                    PULONG64 pns, ULONG dwfNS)
{
    LONG rc = DBGERR_NONE;
    BOOLEAN fSearchUp = (BOOLEAN)(!(dwfNS & NSF_LOCAL_SCOPE) &&
                                  (pszObjPath[0] != '\\') &&
                                  (pszObjPath[0] != '^') &&
                                  (StrLen(pszObjPath, -1) <= sizeof(NAMESEG)));
    BOOLEAN fMatch = TRUE;
    PSZ psz;
    ULONG64 NSObj, NSChildObj;
    ULONG64 NSScope=0, UIPns=0, NSO=0;
    
    if(pnsScope)
        NSScope = *pnsScope;
    if(puipns)
        UIPns = *puipns;
    if(pns)
        NSO = *pns;
    
    if (*pszObjPath == '\\')
    {
        psz = &pszObjPath[1];
        NSScope = 0;
    }
    else
    {
        if(NSScope)
        {
            if(InitTypeRead(NSScope, ACPI!_NSObj))
                dprintf("GetNSObj: Failed to initialize NSScope (%I64x)\n", NSScope);
        }
        
        for (psz = pszObjPath;
             (*psz == '^') && (NSScope != 0) &&
             (ReadField(pnsParent) != 0);
             psz++)
        {
            NSObj = ReadField(pnsParent);
            if (!NSObj)
            {
                DBG_ERROR(("failed to read parent object at %I64x",
                           ReadField(pnsParent)));
                rc = DBGERR_CMD_FAILED;
                break;
            }
            else
            {
                NSScope = NSObj;
                if(InitTypeRead(NSScope, ACPI!_NSObj))
                    dprintf("GetNSObj: Failed to initialize for NSScope (%I64x)\n", NSScope);
            }
        }
        if ((rc == DBGERR_NONE) && (*psz == '^'))
        {
            if (dwfNS & NSF_WARN_NOTFOUND)
            {
                DBG_ERROR(("object %s not found", pszObjPath));
            }
            rc = DBGERR_CMD_FAILED;
        }
    }

    if ((rc == DBGERR_NONE) && (NSScope == 0))
    {
        ReadPointer(GetExpression("acpi!gpnsnamespaceroot"), &UIPns);

        if (UIPns == 0)
        {
            DBG_ERROR(("failed to get root object address"));
            rc = DBGERR_CMD_FAILED;
        }
        else
        {
            NSObj =  UIPns;
            NSScope = NSObj;
        }
    }

    while ((rc == DBGERR_NONE) && (*psz != '\0'))
    {
        InitTypeRead(NSScope, ACPI!_NSObj);
        if (ReadField(pnsFirstChild) == 0)
        {
            fMatch = FALSE;
        }
        else
        {
            PSZ pszEnd = strchr(psz, '.');
            ULONG dwLen = (ULONG)(pszEnd? (pszEnd - psz): StrLen(psz, -1));

            if (dwLen > sizeof(NAMESEG))
            {
                DBG_ERROR(("invalid name path %s", pszObjPath));
                rc = DBGERR_CMD_FAILED;
            }
            else
            {
                NAMESEG dwName = NAMESEG_BLANK;
                BOOLEAN fFound = FALSE;
                ULONG64 uip;
                ULONG64 uipFirstChild = ReadField(pnsFirstChild);

                MEMCPY(&dwName, psz, dwLen);
                //
                // Search all siblings for a matching NameSeg.
                //
                for (uip = uipFirstChild;
                     ((uip != 0) && ((NSChildObj = uip) != 0) && (InitTypeRead(NSChildObj, ACPI!_NSObj) == 0));
                     uip = ((ULONG64)ReadField(list.plistNext) ==
                            uipFirstChild)?
                           0: (ULONG64)ReadField(list.plistNext))
                {
                    
                    if ((ULONG)ReadField(dwNameSeg) == dwName)
                    {
                        UIPns = uip;
                        fFound = TRUE;
                        NSObj = NSChildObj;
                        NSScope = NSObj;
                        break;
                    }
                }

                if (fFound)
                {
                    psz += dwLen;
                    if (*psz == '.')
                    {
                        psz++;
                    }
                }
                else
                {
                    fMatch = FALSE;
                }
            }
        }

        if ((rc == DBGERR_NONE) && !fMatch)
        {
            InitTypeRead(NSScope, ACPI!_NSObj);
            if (fSearchUp && ((NSObj = ReadField(pnsParent)) != 0))
            {
                
                fMatch = TRUE;
                NSScope = NSObj;
            
            }
            else
            {
                if (dwfNS & NSF_WARN_NOTFOUND)
                {
                    DBG_ERROR(("object %s not found", pszObjPath));
                }
                rc = DBGERR_CMD_FAILED;
            }
        }
    }

    
    if (rc != DBGERR_NONE)
    {
        UIPns = 0;
    }
    else
    {
        NSO = NSScope;
    }

    if(puipns)
        *puipns = UIPns; 
    if(pnsScope)
        *pnsScope = NSScope;
    if(pns)
        *pns = NSO;

    return rc;
}       //GetNSObj

/***LP  NameSegString - convert a NameSeg to an ASCIIZ stri
 *
 *  ENTRY
 *      dwNameSeg - NameSeg
 *
 *  EXIT
 *      returns string
 */

PSZ LOCAL NameSegString(ULONG dwNameSeg)
{
    static char szNameSeg[sizeof(NAMESEG) + 1] = {0};

    STRCPYN(szNameSeg, (PSZ)&dwNameSeg, sizeof(NAMESEG));

    return szNameSeg;
}       //NameSegString


/***EP  StrCat - concatenate strings
 *
 *  ENTRY
 *      pszDst -> destination string
 *      pszSrc -> source string
 *      n - number of bytes to concatenate
 *
 *  EXIT
 *      returns pszDst
 */

PSZ LOCAL StrCat(PSZ pszDst, PSZ pszSrc, ULONG n)
{
    ULONG dwSrcLen, dwDstLen;

    
    ASSERT(pszDst != NULL);
    ASSERT(pszSrc != NULL);

    dwSrcLen = StrLen(pszSrc, n);
    if ((n == (ULONG)(-1)) || (n > dwSrcLen))
        n = dwSrcLen;

    dwDstLen = StrLen(pszDst, (ULONG)(-1));
    MEMCPY(&pszDst[dwDstLen], pszSrc, n);
    pszDst[dwDstLen + n] = '\0';

    return pszDst;
}       //StrCat
/***EP  StrLen - determine string length
 *
 *  ENTRY
 *      psz -> string
 *      n - limiting length
 *
 *  EXIT
 *      returns string length
 */

ULONG LOCAL StrLen(PSZ psz, ULONG n)
{
    ULONG dwLen;

    ASSERT(psz != NULL);
    if (n != (ULONG)-1)
        n++;
    for (dwLen = 0; (dwLen <= n) && (*psz != '\0'); psz++)
        dwLen++;

    return dwLen;
}       //StrLen

/***EP  StrCmp - compare strings
 *
 *  ENTRY
 *      psz1 -> string 1
 *      psz2 -> string 2
 *      n - number of bytes to compare
 *      fMatchCase - TRUE if case sensitive
 *
 *  EXIT
 *      returns 0  if string 1 == string 2
 *              <0 if string 1 < string 2
 *              >0 if string 1 > string 2
 */

LONG LOCAL StrCmp(PSZ psz1, PSZ psz2, ULONG n, BOOLEAN fMatchCase)
{
    LONG rc;
    ULONG dwLen1, dwLen2;
    ULONG i;

    ASSERT(psz1 != NULL);
    ASSERT(psz2 != NULL);

    dwLen1 = StrLen(psz1, n);
    dwLen2 = StrLen(psz2, n);
    if (n == (ULONG)(-1))
        n = (dwLen1 > dwLen2)? dwLen1: dwLen2;

    if (fMatchCase)
    {
        for (i = 0, rc = 0;
             (rc == 0) && (i < n) && (i < dwLen1) && (i < dwLen2);
             ++i)
        {
            rc = (LONG)(psz1[i] - psz2[i]);
        }
    }
    else
    {
        for (i = 0, rc = 0;
             (rc == 0) && (i < n) && (i < dwLen1) && (i < dwLen2);
             ++i)
        {
            rc = (LONG)(TOUPPER(psz1[i]) - TOUPPER(psz2[i]));
        }
    }

    if ((rc == 0) && (i < n))
    {
        if (i < dwLen1)
            rc = (LONG)psz1[i];
        else if (i < dwLen2)
            rc = (LONG)(-psz2[i]);
    }

    return rc;
}       //StrCmp


/***EP  StrCpy - copy string
 *
 *  ENTRY
 *      pszDst -> destination string
 *      pszSrc -> source string
 *      n - number of bytes to copy
 *
 *  EXIT
 *      returns pszDst
 */
PSZ LOCAL StrCpy(PSZ pszDst, PSZ pszSrc, ULONG n)
{
    ULONG dwSrcLen;

    ASSERT(pszDst != NULL);
    ASSERT(pszSrc != NULL);

    dwSrcLen = StrLen(pszSrc, n);
    if ((n == (ULONG)(-1)) || (n > dwSrcLen))
        n = dwSrcLen;

    MEMCPY(pszDst, pszSrc, n);
    pszDst[n] = '\0';

    return pszDst;
}       //StrCpy


ULONG64
AMLIUtilStringToUlong64 (
    PSZ   String,
    PSZ   *End,
    ULONG Base  
   )
{
    UCHAR LowDword[9], HighDword[9];
    
    ZeroMemory (&HighDword, sizeof (HighDword));
    ZeroMemory (&LowDword, sizeof (LowDword));

    if (strlen (String) > 8) {

        memcpy (&LowDword, (void *) &String[strlen (String) - 8], 8);
        memcpy (&HighDword, (void *) &String[0], strlen (String) - 8);

    } else {

        return strtoul (String, End, Base);
    }
    
    return ((ULONG64) strtoul (HighDword, 0, Base) << 32) + strtoul (LowDword, End, Base);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\apic.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    apic.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris (kenr) 06-June-1994

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
//#include "apic.h"
//#include <ntapic.inc>

#pragma hdrstop

#define LU_SIZE     0x400

#define LU_ID_REGISTER          0x00000020
#define LU_VERS_REGISTER        0x00000030
#define LU_TPR                  0x00000080
#define LU_APR                  0x00000090
#define LU_PPR                  0x000000A0
#define LU_EOI                  0x000000B0
#define LU_REMOTE_REGISTER      0x000000C0

#define LU_DEST                 0x000000D0
#define LU_DEST_FORMAT          0x000000E0

#define LU_SPURIOUS_VECTOR      0x000000F0
#define LU_FAULT_VECTOR         0x00000370

#define LU_ISR_0                0x00000100
#define LU_TMR_0                0x00000180
#define LU_IRR_0                0x00000200
#define LU_ERROR_STATUS         0x00000280
#define LU_INT_CMD_LOW          0x00000300
#define LU_INT_CMD_HIGH         0x00000310
#define LU_TIMER_VECTOR         0x00000320
#define LU_INT_VECTOR_0         0x00000350
#define LU_INT_VECTOR_1         0x00000360
#define LU_INITIAL_COUNT        0x00000380
#define LU_CURRENT_COUNT        0x00000390
#define LU_DIVIDER_CONFIG       0x000003E0


#define IO_REGISTER_SELECT      0x00000000
#define IO_REGISTER_WINDOW      0x00000010

#define IO_ID_REGISTER          0x00000000
#define IO_VERS_REGISTER        0x00000001
#define IO_ARB_ID_REGISTER      0x00000002
#define IO_REDIR_BASE           0x00000010

#define NMI_VECTOR              0xff
#define DESTINATION_SHIFT       24

BOOLEAN
GetPhysicalAddress (
    IN ULONG64 Address,
    OUT PULONG64 PhysAddress
    );


ULONG
ApicRead (
    ULONG64 Address,
    ULONG   Offset
    )
{
    ULONG   Data, result;

    ReadMemoryUncached(Address + Offset, &Data, sizeof (ULONG), &result);
    return Data;
}

ULONG
IoApicRead (
    ULONG64 PhysAddress,
    ULONG   Offset
    )
{
    ULONG   Data = 0, result;

    PhysAddress += IO_REGISTER_SELECT;
    WritePhysical(PhysAddress, &Offset, sizeof(ULONG), &result);

    PhysAddress += IO_REGISTER_WINDOW - IO_REGISTER_SELECT;
    ReadPhysical(PhysAddress, &Data, sizeof (ULONG), &result);
    return Data;
}

ULONG
IoSApicRead (
    ULONG64 VirtualAddress,
    ULONG   Offset
    )
{
    ULONG   Data = 0, result;

    WriteMemoryUncached(VirtualAddress + IO_REGISTER_SELECT, &Offset, sizeof(ULONG), &result);

    ReadMemoryUncached(VirtualAddress + IO_REGISTER_WINDOW, &Data, sizeof(Data), &result);

    return Data;
}



ULONG
ApicDumpSetBits (
    PUCHAR  Desc,
    PULONG  Bits
    )
{
    PULONG  p;
    ULONG   i;
    BOOLEAN FoundOne;
    BOOLEAN InSetRange;
    BOOLEAN MultipleBitsInRange;
    BOOLEAN status;

    dprintf(Desc);

    i = 0;
    p = Bits;
    FoundOne = FALSE;
    InSetRange = FALSE;

    for (i = 0; i < 0x100; i++) {

        if (*p & (1 << (i & 0x1F))) {

            if (!InSetRange) {

                InSetRange = TRUE;
                MultipleBitsInRange = FALSE;

                if (FoundOne) {
                    dprintf(", ");
                }

                dprintf("%.2X", i);

                FoundOne = TRUE;

            } else if (!MultipleBitsInRange) {

                MultipleBitsInRange = TRUE;
                dprintf("-");
            }

        } else {

            if (InSetRange) {

                if (MultipleBitsInRange == TRUE) {
                    dprintf("%x",i-1);
                }

                InSetRange = FALSE;
            }
        }

        if ((i & 0x1F) == 0x1F) {
            p++;
        }
    }

    if (InSetRange && MultipleBitsInRange) {

        if (MultipleBitsInRange == TRUE) {
            dprintf("%x", i - 1);
        }
    }

    dprintf ("\n");
    return 0;
}

ULONG
ApicReadAndDumpBits (
    PUCHAR  Desc,
    ULONG64 Address,
    ULONG   Offset
    )
{
    #define SETREGISTERS (256 / 32)

    ULONG   Bits [SETREGISTERS];
    PULONG  p;
    ULONG   i, result;
    ULONG64 MemAddr;
    BOOLEAN status;

    //
    // Read the bytes
    //

    MemAddr = Address + Offset;

    for (i = 0; i < SETREGISTERS; i++) {

        status = ReadMemoryUncached(MemAddr, &Bits[i], sizeof(DWORD), &result);

        if (status == FALSE) {
            dprintf("Unable to read 4 bytes at offset %UI64\n",
                    MemAddr);
            return E_INVALIDARG;
        }

        MemAddr += 0x10;
    }

    ApicDumpSetBits(Desc, Bits);

    return 0;
}

ULONG
ApicDumpRedir (
    PUCHAR      Desc,
    BOOLEAN     CommandReg,
    BOOLEAN     DestSelf,
    ULONG       lh,
    ULONG       ll
    )
{
    static PUCHAR DelMode[] = {
        "FixedDel",
        "LowestDl",
        "res010  ",
        "remoterd",
        "NMI     ",
        "RESET   ",
        "res110  ",
        "ExtINTA "
        };

    static PUCHAR DesShDesc[] = { "",
        "  Dest=Self",
        "   Dest=ALL",
        " Dest=Othrs"
        };

    ULONG   del, dest, delstat, rirr, trig, masked, destsh, pol;

    del     = (ll >> 8)  & 0x7;
    dest    = (ll >> 11) & 0x1;
    delstat = (ll >> 12) & 0x1;
    pol     = (ll >> 13) & 0x1;
    rirr    = (ll >> 14) & 0x1;
    trig    = (ll >> 15) & 0x1;
    masked  = (ll >> 16) & 0x1;
    destsh  = (ll >> 18) & 0x3;

    if (CommandReg) {
        // command reg's don't have a mask
        masked = 0;
    }

    dprintf ("%s: %08x  Vec:%02X  %s  ",
            Desc,
            ll,
            ll & 0xff,
            DelMode [ del ]
            );

    if (DestSelf) {
        dprintf (DesShDesc[1]);
    } else if (CommandReg  &&  destsh) {
        dprintf (DesShDesc[destsh]);
    } else {
        if (dest) {
            dprintf ("Lg:%08x", lh);
        } else {
            dprintf ("PhysDest:%02X", (lh >> 56) & 0xFF);
        }
    }

    dprintf ("%s %s  %s  %s %s\n",
            delstat ? "-Pend"   : "     ",
            trig    ? "lvl"     : "edg",
            pol     ? "low "    : "high",
            rirr    ? "rirr"    : "    ",
            masked  ? "masked"  : "      "
            );

    return 0;
}

#define IA64_DEBUG_CONTROL_SPACE_KSPECIAL       3

typedef struct  _REGISTER_LOOKUP_TABLE
{
    LPSTR       FieldName;
    PULONGLONG  Variable;
}   REGISTER_LOOKUP_TABLE, *PREGISTER_LOOKUP_TABLE;

BOOL
ReadKSpecialRegisters(DWORD Cpu, PREGISTER_LOOKUP_TABLE Table, ULONG TableSize)
{
    PUCHAR  buffer;
    ULONG   size;
    ULONG   offset;
    ULONG   i;

    size = GetTypeSize("nt!KSPECIAL_REGISTERS");

    if (size == 0) {
        dprintf("Can't find the size of KSPECIAL_REGISTERS\n");
        return FALSE;
    }

    if ((buffer = LocalAlloc(LPTR, size)) == NULL) {
        dprintf("Can't allocate memory for KSPECIAL_REGISTERS\n");
        return FALSE;
    }

    ReadControlSpace64((USHORT)Cpu, IA64_DEBUG_CONTROL_SPACE_KSPECIAL, buffer, size);

    for (i = 0; i < TableSize; i++) {

        if (GetFieldOffsetEx("KSPECIAL_REGISTERS", Table[i].FieldName, &offset, &size) != S_OK) {
            dprintf("Can't get offset of %s\n", Table[i].FieldName);
            return FALSE;
        }

        if (size != sizeof(ULONGLONG)) {

            dprintf("Sizeof %s (%d) is not sizeof(ULONGLONG)\n", Table[i].FieldName, size);
            return FALSE;
        }

        *Table[i].Variable = *(PULONGLONG)&buffer[offset];
    }

    LocalFree(buffer);

    return TRUE;
}

PUCHAR  DeliveryModes[8] =  {
    "INT", "INT w/Hint", "PMI", "RSV3", "NMI", "INIT", "RSV6", "ExtINT"
};

void
DumpSApicRedir(
    PUCHAR      Description,
    ULONG       HighHalf,
    ULONG       LowHalf
    )
{
    dprintf("%s: %.8X  Vec:%.2X  %-10s  %.2X%.2X%s  %s  %s  %s\n",
            Description,
            LowHalf,
            (ULONG)(LowHalf & 0xFF),
            DeliveryModes[(ULONG)(LowHalf >> 8) & 0x7],
            (HighHalf >> 24) & 0xFF,
            (HighHalf >> 16) & 0xFF,
            (LowHalf & (1 << 12)) ? "-Pend" : "     ",
            (LowHalf & (1 << 15)) ? "lvl" : "edg",
            (LowHalf & (1 << 13)) ? "low" : "high",
            (LowHalf & (1 << 16)) ? "masked" : "      "
            );
}

void
DumpLocalSapic(ULONG Processor, LPCSTR Args)
{
    DWORD       cpu;
    ULONGLONG   SaLID;
    ULONGLONG   SaTPR;
    ULONGLONG   SaIRR[4];
    ULONGLONG   SaITV;
    ULONGLONG   SaPMV;
    ULONGLONG   SaCMCV;
    ULONGLONG   SaLRR[2];

    REGISTER_LOOKUP_TABLE   registerTable[] = {
        { "SaLID",  &SaLID },
        { "SaTPR",  &SaTPR },
        { "SaIRR0", &SaIRR[0] },
        { "SaIRR1", &SaIRR[1] },
        { "SaIRR2", &SaIRR[2] },
        { "SaIRR3", &SaIRR[3] },
        { "SaITV",  &SaITV },
        { "SaPMV",  &SaPMV },
        { "SaCMCV", &SaCMCV },
        { "SaLRR0", &SaLRR[0] },
        { "SaLRR1", &SaLRR[1] }
    };

    if (Args[0] == '\0') {

        cpu = Processor;
    }
    else {

        cpu = atoi(Args);
    }

    if (!ReadKSpecialRegisters(cpu, registerTable, sizeof(registerTable) / sizeof(registerTable[0]))) {

        return;
    }

    dprintf("Local Sapic for processor %d\n", cpu);
    dprintf("LID: EID = %d, ID = %d\n", (ULONG)((SaLID >> 16) & 0xFF), (ULONG)((SaLID >> 24) & 0xFF));
    dprintf("TPR: Mask Interrupt Class = %d, Mask Maskable Interrupts = %s\n", (ULONG)(SaTPR >> 4) & 0xF, (SaTPR & (1 << 16)) ? "TRUE" : "FALSE");

    ApicDumpSetBits("IRR: ", (PULONG)&SaIRR[0]);

    dprintf("ITV: Vector = 0x%.2X, Masked = %s\n", (ULONG)(SaITV & 0xFF), (SaITV & (1 << 16)) ? "TRUE" : "FALSE");
    dprintf("PMV: Vector = 0x%.2X, Masked = %s\n", (ULONG)(SaPMV & 0xFF), (SaPMV & (1 << 16)) ? "TRUE" : "FALSE");
    dprintf("CMCV: Vector = 0x%.2X, Masked = %s\n", (ULONG)(SaCMCV & 0xFF), (SaCMCV & (1 << 16)) ? "TRUE" : "FALSE");

    DumpSApicRedir("LRR0", (ULONG)(SaLRR[0] >> 32), (ULONG)SaLRR[0]);
    DumpSApicRedir("LRR1", (ULONG)(SaLRR[1] >> 32), (ULONG)SaLRR[1]);

}


DECLARE_API( apic )

/*++

Routine Description:

    Dumps local apic

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/
{
    static PUCHAR divbase[] = { "2", "4", "8", "f" };
    static PUCHAR clktype[] = { "clk", "tmbase", "%s/%s", "??%s/%s" };
    ULONG64       Address;
    ULONG       result, junk, l, ll, lh, clkvec;
    UCHAR       s[40];

    INIT_API();

    if (TargetMachine == IMAGE_FILE_MACHINE_IA64) {

        ULONG   processor;

        GetCurrentProcessor(Client, &processor, NULL);

        DumpLocalSapic(processor, args);

        EXIT_API();

        return S_OK;
    }

    if (TargetMachine != IMAGE_FILE_MACHINE_I386 &&
        TargetMachine != IMAGE_FILE_MACHINE_AMD64) {
        dprintf("X86 and AMD64 only API.\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    if ((Address = GetExpression(args)) == 0) {

        //
        // Default Apic address
        //

        Address = 0xfffe0000;
    }

    if (Address == 0) {

        //
        // Use default for MPS systems.
        //

        Address = 0xfffe0000;
    }

    Address = (ULONG64) (LONG64) (LONG) Address;

    if ( !ReadMemoryUncached(
                Address + LU_ID_REGISTER,
                (PVOID)&junk,
                4,
                &result
                ) ) {
        dprintf("Unable to read lapic\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    if ( !ReadMemoryUncached(
                Address + LU_DIVIDER_CONFIG,
                (PVOID)&junk,
                4,
                &result
                ) ) {
        dprintf("Unable to read lapic\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    dprintf ("Apic @ %08x  ID:%x (%x)  LogDesc:%08x  DestFmt:%08x  TPR %02X\n",
        (ULONG)Address,
        ApicRead (Address, LU_ID_REGISTER) >> 24,
        ApicRead (Address, LU_VERS_REGISTER),
        ApicRead (Address, LU_DEST),
        ApicRead (Address, LU_DEST_FORMAT),
        ApicRead (Address, LU_TPR)
        );

    l  = ApicRead (Address, LU_SPURIOUS_VECTOR);
    ll = ApicRead (Address, LU_DIVIDER_CONFIG);
    clkvec = ApicRead (Address, LU_TIMER_VECTOR);
    sprintf (s, clktype[ (clkvec >> 18) & 0x3 ],
        clktype [ (ll >> 2) & 0x1 ],
        divbase [ ll & 0x3]
        );

    dprintf ("TimeCnt: %08x%s%s  SpurVec:%02x  FaultVec:%02x  error:%x%s\n",
        ApicRead (Address, LU_INITIAL_COUNT),
        s,
        ((clkvec >> 17) & 1) ? "" : "-oneshot",
        l & 0xff,
        ApicRead (Address, LU_FAULT_VECTOR),
        ApicRead (Address, LU_ERROR_STATUS),
        l & 0x100 ? "" : "  DISABLED"
        );

    ll = ApicRead (Address, LU_INT_CMD_LOW);
    lh = ApicRead (Address, LU_INT_CMD_HIGH);
    ApicDumpRedir ("Ipi Cmd", TRUE,  FALSE, lh, ll);
    ApicDumpRedir ("Timer..", FALSE, TRUE, 0, clkvec);
    ApicDumpRedir ("Linti0.", FALSE, TRUE, 0, ApicRead (Address, LU_INT_VECTOR_0));
    ApicDumpRedir ("Linti1.", FALSE, TRUE, 0, ApicRead (Address, LU_INT_VECTOR_1));

    ApicReadAndDumpBits ("TMR: ", Address, LU_TMR_0);
    ApicReadAndDumpBits ("IRR: ", Address, LU_IRR_0);
    ApicReadAndDumpBits ("ISR: ", Address, LU_ISR_0);

    EXIT_API();
    return S_OK;
}

void
DumpIoSApic(
    IN LPCSTR   Args
    )
{
    ULONG64     address;
    ULONG       ioSapicCount;
    ULONG       index;
    ULONG64     apicDebugAddresses;
    ULONG       apicDebugSize;
    ULONG64     apicVirtualAddress;
    ULONG64     apicPhysicalAddress;
    ULONG       ll, lh;
    ULONG       i, max;
    UCHAR       s[40];

    address = GetExpression("hal!HalpMpInfo");

    if (address == 0) {
        dprintf("Can't find hal!HalpMpInfo\n");
        return;
    }

    if (GetFieldValue(address, "hal!_MPINFO", "IoSapicCount", ioSapicCount) != 0) {
        dprintf("Error reading IoSapicCount\n");
        return;
    }

    address = GetExpression("Hal!HalpApicDebugAddresses");

    if (address == 0) {
        dprintf("Can't find Hal!HalpApicDebugAddresses\n");
        return;
    }

    if (ReadPtr(address, &apicDebugAddresses) != 0) {
        dprintf("Error reading Hal!HalpApicDebugAddresses\n");
        return;
    }

    apicDebugSize = GetTypeSize("hal!_IOAPIC_DEBUG_TABLE");

    if (apicDebugSize == 0) {
        dprintf("Can't find hal!_IOAPIC_DEBUG_TABLE\n");
        return;
    }

    for (index = 0; index < ioSapicCount; index++) {

        GetFieldValue(apicDebugAddresses + (index * apicDebugSize),
                      "hal!_IOAPIC_DEBUG_TABLE", "IoSapicRegs",
                      apicVirtualAddress);

        apicPhysicalAddress = 0;

        GetPhysicalAddress(apicVirtualAddress, &apicPhysicalAddress);

        ll = IoSApicRead(apicVirtualAddress, IO_VERS_REGISTER);

        dprintf("I/O SAPIC @ %.8X, Version = %.2X (0x%.8X)\n", (ULONG)apicPhysicalAddress, (ll & 0xFF), ll);

        max = (ll >> 16) & 0xff;

        //
        // Dump inti table
        //

        max *= 2;

        for (i = 0; i <= max; i += 2) {
            ll = IoSApicRead(apicVirtualAddress, IO_REDIR_BASE + i + 0);
            lh = IoSApicRead(apicVirtualAddress, IO_REDIR_BASE + i + 1);

            sprintf(s, "Inti%02X", i / 2);

            DumpSApicRedir(s, lh, ll);
        }
    }
}

DECLARE_API( ioapic )

/*++

Routine Description:

    Dumps io apic

Arguments:

    args - Supplies the address in hex, if no address is specified, all IOApics will be dumped.

Return Value:

    None

--*/
{
    ULONG64     PhysAddress;
    ULONG64     Address;
    ULONG       i, ll, lh, max, IOApicCount;
    UCHAR       s[40];
    BOOLEAN     Converted;
    ULONG64     addr;
    UCHAR       count;

    INIT_API();

    if (TargetMachine == IMAGE_FILE_MACHINE_IA64) {

        DumpIoSApic(args);

        EXIT_API();
        return S_OK;
    }

    if (TargetMachine != IMAGE_FILE_MACHINE_I386 &&
        TargetMachine != IMAGE_FILE_MACHINE_AMD64) {
        dprintf("X86 or AMD64 only API.\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    Address = GetExpression(args);

    Converted = GetPhysicalAddress (Address, &PhysAddress);

    if (Converted) {
        IOApicCount = 1;
    } else {

        //
        // Get a copy of the global data structure Hal!HalpMpInfoTable.
        //

        addr = GetExpression("Hal!HalpMpInfoTable");

        if (addr == 0) {
            dprintf ("Error retrieving address of HalpMpInfoTable\n");
            EXIT_API();
            return E_INVALIDARG;
        }

        if (InitTypeRead(addr, Hal!HalpMpInfo)) {
            dprintf ("Error reading HalpMpInfoTable\n");
            EXIT_API();
            return E_INVALIDARG;
        }

        IOApicCount = (ULONG) ReadField(IOApicCount);
        Address =  ReadField(IoApicBase[0]);
        Converted = GetPhysicalAddress ( Address, &PhysAddress);
    }

    for (count = 0; count < IOApicCount; count++) {

        ll = IoApicRead (PhysAddress, IO_VERS_REGISTER),
        max = (ll >> 16) & 0xff;
        dprintf ("IoApic @ %08x  ID:%x (%x)  Arb:%x\n",
            (ULONG)Address,
            IoApicRead (PhysAddress, IO_ID_REGISTER) >> 24,
            ll & 0xFF,
            IoApicRead (PhysAddress, IO_ARB_ID_REGISTER)
        );

        //
        // Dump inti table
        //

        max *= 2;
        for (i=0; i <= max; i += 2) {
            ll = IoApicRead (PhysAddress, IO_REDIR_BASE+i+0);
            lh = IoApicRead (PhysAddress, IO_REDIR_BASE+i+1);
            sprintf (s, "Inti%02X.", i/2);
            ApicDumpRedir (s, FALSE, FALSE, lh, ll);
        }

        //
        // Get the next IoApic Virtual Address, convert it to Physical
        // and break if this conversion fails.
        //

        Address = ReadField(IoApicBase[count+1]);
        Converted = GetPhysicalAddress ( Address, &PhysAddress);

        if (!Converted) {
            break;
        }

        dprintf ("\n");
    }

    EXIT_API();
    return S_OK;
}

DECLARE_API( sendnmi )

/*++

Routine Description:

    Send an IPI to the processors in the argument bitmask (affinity).
    (Used for debugging when a processor is spinning with interrupts
    disabled).

Arguments:

    KAFFINITY BitMask   Supplied a mask of processors to send the
                        IPI to.

Return Value:

    Success.

--*/

{
    ULONG64 Address;
    ULONG64 ApicAddress;
    UCHAR   MaxProcsPerCluster;
    ULONG   i;
    ULONG64 TargetSet;
    ULONG64 ActiveProcessors;
    ULONG   Length;
    ULONG   ApicDWord;
    ULONG   junk;

    //
    // APIC/XAPIC machines only.
    // This should be doable on IA64 and AMD64 as well but I don't know
    // how at time of writing.  PeterJ.
    //

    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("Sorry, only know how to send NMI on an APIC machine.\n");
        return E_INVALIDARG;
    }

    if (strstr(args, "?") ||
        ((TargetSet = GetExpression(args)) == 0)) {
        dprintf("usage: sendnmi bitmask\n"
                "       where bitmask is the set of processors an NMI\n"
                "       is to be sent to.\n");
        return E_INVALIDARG;
    }

    //
    // See if we can get the cluster mode from the HAL.
    // (On AMD64 and IA64, this information would be in the kernel).
    //

    Address = GetExpression("hal!HalpMaxProcsPerCluster");
    if (!Address) {
        dprintf("Unable to get APIC configuration information from the HAL\n");
        dprintf("Cannot continue.\n");
        return E_INVALIDARG;
    }

    if (!ReadMemoryUncached(Address,
                    &MaxProcsPerCluster,
                    sizeof(MaxProcsPerCluster),
                    &i) || (i != sizeof(MaxProcsPerCluster))) {
        dprintf("Unable to read system memory, quitting.\n");
        return E_INVALIDARG;
    }

    Address = GetExpression("nt!KeActiveProcessors");
    Length = GetTypeSize("nt!KeActiveProcessors");
    if ((!Address) || (!((Length == 4) || (Length == 8)))) {
        dprintf("Unable to get processor configuration from kernel\n");
        dprintf("Cannot continue.\n");
        return E_INVALIDARG;
    }

    ActiveProcessors = 0;
    if (!ReadMemoryUncached(Address,
                    &ActiveProcessors,
                    Length,
                    &i) || (i != Length) || (ActiveProcessors == 0)) {
        dprintf("Unable to read processor configuration from kernel.\n");
        dprintf("Cannot continue.\n");
        return E_INVALIDARG;
    }

    if ((TargetSet & ActiveProcessors) != TargetSet) {
        dprintf("Target processor set (%I64x) contains processors not in\n"
                "system processor set (%I64x).\n",
                TargetSet,
                ActiveProcessors);
        dprintf("Cannot continue.\n");
        return E_INVALIDARG;
    }

    ApicAddress = 0xfffe0000;

    ApicAddress = (ULONG64) (LONG64) (LONG) ApicAddress;

    if ((!ReadMemoryUncached(ApicAddress,
                     &junk,
                     1,
                     &i)) ||
        (!ReadMemoryUncached(ApicAddress + LU_SIZE - 1,
                     &junk,
                     1,
                     &i)) ||
        (!ReadMemoryUncached(ApicAddress + LU_INT_CMD_LOW,
                     &ApicDWord,
                     sizeof(ApicDWord),
                     &i)) ||
        (i != sizeof(ApicDWord))) {
        dprintf("Unable to read lapic\n");
        dprintf("Cannot continue.\n");
        return E_INVALIDARG;
    }

    if ((ApicDWord & DELIVERY_PENDING) != 0) {
        dprintf("Local APIC is busy, can't use it right now.\n");
        dprintf("This is probably indicative of an APIC error.\n");
        return E_INVALIDARG;
    }

    if (MaxProcsPerCluster == 0) {

        //
        // APIC is not in cluster mode.   This makes life easy.
        // Sanity: This means there's 8 or less processors.
        //

        if (TargetSet > 0xff) {
            dprintf("APIC is in non-cluster mode thus it cannot support\n"
                    "more than 8 processors yet the target mask includes\n"
                    "processors outside that range.  Something is not right.\n"
                    "quitting.\n");
            return E_INVALIDARG;
        }

        dprintf("Sending NMI to processors in set %I64x\n", TargetSet);

        ApicDWord = ((ULONG)TargetSet) << DESTINATION_SHIFT;
        WriteMemory(ApicAddress + LU_INT_CMD_HIGH,
                    &ApicDWord,
                    sizeof(ApicDWord),
                    &i);
        ApicDWord = DELIVER_NMI |
                    LOGICAL_DESTINATION |
                    ICR_USE_DEST_FIELD |
                    NMI_VECTOR;
        WriteMemory(ApicAddress + LU_INT_CMD_LOW,
                    &ApicDWord,
                    sizeof(ApicDWord),
                    &i);

        dprintf("Sent.\n");
    } else {
        dprintf("APIC is in cluster mode, don't know how to do this yet.\n");
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\amlikd.h ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    amlikd.h

Abstract:

    This header file (re)defines various flags used by the amli extension. These definitions
    are copied from different header files in the acpi and acpi kd ext dirs.

--*/

#ifndef _AMLIKD_
#define _AMLIKD_


/*** Defn's
*/
#define ConPrintf               dprintf
#define MZERO                   MemZero
#define ADDROF(s)               GetExpression("ACPI!" s)
#define FIELDADDROF(s,t,f)      (PULONG64)(ADDROF(s) + FIELD_OFFSET(t, f))
#define READMEMBYTE             ReadMemByte
#define READMEMWORD             ReadMemWord
#define READMEMDWORD            ReadMemDWord
#define READMEMULONGPTR         ReadMemUlongPtr
#define READSYMBYTE(s)          ReadMemByte(ADDROF(s))
#define READSYMWORD(s)          ReadMemWord(ADDROF(s))
#define READSYMDWORD(s)         ReadMemDWord(ADDROF(s))
#define READSYMULONGPTR(s)      ReadMemUlongPtr(ADDROF(s))
#define WRITEMEMBYTE(a,d)       WriteMemory(a, &(d), sizeof(BYTE), NULL)
#define WRITEMEMWORD(a,d)       WriteMemory(a, &(d), sizeof(WORD), NULL)
#define WRITEMEMDWORD(a,d)      WriteMemory(a, &(d), sizeof(DWORD), NULL)
#define WRITEMEMULONGPTR(a,d)   WriteMemory(a, &(d), sizeof(ULONG_PTR), NULL)
#define WRITESYMBYTE(s,d)       WRITEMEMBYTE(ADDROF(s), d)
#define WRITESYMWORD(s,d)       WRITEMEMWORD(ADDROF(s), d)
#define WRITESYMDWORD(s,d)      WRITEMEMDWORD(ADDROF(s), d)
#define WRITESYMULONGPTR(s,d)   WRITEMEMULONGPTR(ADDROF(s), d)
#define EXOP(op)                (((op) << 8) | OP_EXT_PREFIX)
#define LOCAL                   __cdecl
#define STDCALL                 __stdcall
#define MODNAME                 "AMLI"
#define DBG_ERROR(x)            ConPrintf(MODNAME "_DBGERR: ");         \
                                ConPrintf x;                            \
                                ConPrintf("\n");
#define ARG_ERROR(x)            ConPrintf(MODNAME "_ARGERR: ");         \
                                ConPrintf x;                            \
                                ConPrintf("\n");
#define DEREF(x)                ((x) = (x))
#define ISLOWER(c)              (((c) >= 'a') && ((c) <= 'z'))
#define TOUPPER(c)              ((CHAR)(ISLOWER(c)? ((c) & 0xdf): (c)))
#define MEMCPY                  RtlCopyMemory
#define MEMZERO                 RtlZeroMemory
#define STRCPY(s1,s2)           StrCpy(s1, s2, (ULONG)(-1))
#define STRCPYN(s1,s2,n)        StrCpy(s1, s2, (ULONG)(n))


#define MAX_NAME_LEN            255
#define NAMESEG_ROOT            0x5f5f5f5c      // "\___"
#define NAMESEG_BLANK           0x5f5f5f5f      // "____"
#define NAMESEG_NONE            0x00000000      // ""
#define NAMESTR_ROOT            "\\"

// DNS flags
#define DNSF_RECURSE            0x00000001
// DS flags
#define DSF_VERBOSE             0x00000001

// dwfDebug flags
#define DBGF_IN_DEBUGGER        0x00000001
#define DBGF_IN_VXDMODE         0x00000002
#define DBGF_IN_KDSHELL         0x00000004
#define DBGF_VERBOSE_ON         0x00000008
#define DBGF_AMLTRACE_ON        0x00000010
#define DBGF_TRIGGER_MODE       0x00000020
#define DBGF_SINGLE_STEP        0x00000040
#define DBGF_STEP_OVER          0x00000080
#define DBGF_STEP_MODES         (DBGF_SINGLE_STEP | DBGF_STEP_OVER)
#define DBGF_TRACE_NONEST       0x00000100
#define DBGF_DUMPDATA_PHYADDR   0x00000200

#define DBGF_DEBUGGER_REQ       0x00001000
#define DBGF_CHECKING_TRACE     0x00002000
#define DBGF_ERRBREAK_ON        0x00004000
#define DBGF_LOGEVENT_ON        0x00008000
#define DBGF_LOGEVENT_MUTEX     0x00010000
#define DBGF_DEBUG_SPEW_ON      0x00020000

// dwfAMLIInit flags
#define AMLIIF_INIT_BREAK       0x00000001      //break at AMLIInit completion
#define AMLIIF_LOADDDB_BREAK    0x00000002      //break at LoadDDB completion
#define AMLIIF_NOCHK_TABLEVER   0x80000000      //do not check table version

// Error codes
#define UNASMERR_NONE           0
#define UNASMERR_FATAL          -1
#define UNASMERR_INVALID_OPCODE -2
#define UNASMERR_ABORT          -3

// Opcode classes
#define OPCLASS_INVALID         0
#define OPCLASS_DATA_OBJ        1
#define OPCLASS_NAME_OBJ        2
#define OPCLASS_CONST_OBJ       3
#define OPCLASS_CODE_OBJ        4
#define OPCLASS_ARG_OBJ         5
#define OPCLASS_LOCAL_OBJ       6

// NameSpace object types
#define NSTYPE_UNKNOWN          'U'
#define NSTYPE_SCOPE            'S'
#define NSTYPE_FIELDUNIT        'F'
#define NSTYPE_DEVICE           'D'
#define NSTYPE_EVENT            'E'
#define NSTYPE_METHOD           'M'
#define NSTYPE_MUTEX            'X'
#define NSTYPE_OPREGION         'O'
#define NSTYPE_POWERRES         'P'
#define NSTYPE_PROCESSOR        'C'
#define NSTYPE_THERMALZONE      'T'
#define NSTYPE_OBJALIAS         'A'
#define NSTYPE_BUFFFIELD        'B'

// Term classes
#define UTC_PNP_MACRO           0x00100000
#define UTC_REF_OBJECT          0x00200000
#define UTC_FIELD_MACRO         0x00400000
#define UTC_DATA_OBJECT         0x00800000
#define UTC_NAMED_OBJECT        0x01000000
#define UTC_NAMESPACE_MODIFIER  0x02000000
#define UTC_OPCODE_TYPE1        0x04000000
#define UTC_OPCODE_TYPE2        0x08000000
#define UTC_CONST_NAME          0x10000000
#define UTC_SHORT_NAME          0x20000000
#define UTC_COMPILER_DIRECTIVE  0x40000000
#define UTC_KEYWORD             0x80000000
#define UTC_OPCODE              (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2 |  \
                                 UTC_SHORT_NAME | UTC_CONST_NAME |      \
                                 UTC_DATA_OBJECT)

// Term flags
#define TF_ACTION_FLIST         0x00000001
#define TF_ACTION_VLIST         0x00000002
#define TF_PACKAGE_LEN          0x00000004
#define TF_CHANGE_CHILDSCOPE    0x00000008
#define TF_DELAY_UNASM          0x00000010
#define TF_FIELD_MACRO          UTC_FIELD_MACRO
#define TF_DATA_OBJECT          UTC_DATA_OBJECT
#define TF_NAMED_OBJECT         UTC_NAMED_OBJECT
#define TF_NAMESPACE_MODIFIER   UTC_NAMESPACE_MODIFIER
#define TF_OPCODE_TYPE1         UTC_OPCODE_TYPE1
#define TF_OPCODE_TYPE2         UTC_OPCODE_TYPE2
#define TF_CONST_NAME           UTC_CONST_NAME
#define TF_SHORT_NAME           UTC_SHORT_NAME
#define TF_COMPILER_DIRECTIVE   UTC_COMPILER_DIRECTIVE
#define TF_KEYWORD              UTC_KEYWORD
#define TF_PNP_MACRO            UTC_PNP_MACRO
#define TF_OBJECT_LIST          (UTC_NAMED_OBJECT | UTC_NAMESPACE_MODIFIER)
#define TF_CODE_LIST            (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2)
#define TF_DATA_LIST            0x00010000
#define TF_FIELD_LIST           0x00020000
#define TF_BYTE_LIST            0x00040000
#define TF_DWORD_LIST           0x00080000
#define TF_PACKAGE_LIST         (UTC_DATA_OBJECT | UTC_SHORT_NAME | \
                                 UTC_CONST_NAME)
#define TF_ALL_LISTS            (TF_DATA_OBJECT | TF_NAMED_OBJECT | \
                                 TF_NAMESPACE_MODIFIER | TF_OPCODE_TYPE1 | \
                                 TF_OPCODE_TYPE2 | TF_SHORT_NAME | \
                                 TF_CONST_NAME | TF_COMPILER_DIRECTIVE | \
                                 TF_DATA_LIST | TF_PACKAGE_LIST | \
                                 TF_FIELD_LIST | TF_PNP_MACRO | TF_BYTE_LIST |\
                                 TF_DWORD_LIST)


/*** Opcode values
 */

#define OP_NONE                 0xffffffff      //not a valid opcode

#define OP_ZERO                 0x00
#define OP_ONE                  0x01
#define OP_ALIAS                0x06
#define OP_NAME                 0x08
#define OP_BYTE                 0x0a
#define OP_WORD                 0x0b
#define OP_DWORD                0x0c
#define OP_STRING               0x0d
#define OP_SCOPE                0x10
#define OP_BUFFER               0x11
#define OP_PACKAGE              0x12
#define OP_METHOD               0x14
#define OP_DUAL_NAME_PREFIX     0x2e    // '.'
#define OP_MULTI_NAME_PREFIX    0x2f    // '/'
#define OP_EXT_PREFIX           0x5b    // '['
#define OP_ROOT_PREFIX          0x5c    // '\'
#define OP_PARENT_PREFIX        0x5e    // '^'
#define OP_LOCAL0               0x60    // '`'
#define OP_LOCAL1               0x61    // 'a'
#define OP_LOCAL2               0x62    // 'b'
#define OP_LOCAL3               0x63    // 'c'
#define OP_LOCAL4               0x64    // 'd'
#define OP_LOCAL5               0x65    // 'e'
#define OP_LOCAL6               0x66    // 'f'
#define OP_LOCAL7               0x67    // 'g'
#define OP_ARG0                 0x68    // 'h'
#define OP_ARG1                 0x69    // 'i'
#define OP_ARG2                 0x6a    // 'j'
#define OP_ARG3                 0x6b    // 'k'
#define OP_ARG4                 0x6c    // 'l'
#define OP_ARG5                 0x6d    // 'm'
#define OP_ARG6                 0x6e    // 'n'
#define OP_STORE                0x70    // 'p'
#define OP_REFOF                0x71
#define OP_ADD                  0x72
#define OP_CONCAT               0x73
#define OP_SUBTRACT             0x74
#define OP_INCREMENT            0x75
#define OP_DECREMENT            0x76
#define OP_MULTIPLY             0x77
#define OP_DIVIDE               0x78
#define OP_SHIFTL               0x79
#define OP_SHIFTR               0x7a
#define OP_AND                  0x7b
#define OP_NAND                 0x7c
#define OP_OR                   0x7d
#define OP_NOR                  0x7e
#define OP_XOR                  0x7f
#define OP_NOT                  0x80
#define OP_FINDSETLBIT          0x81
#define OP_FINDSETRBIT          0x82
#define OP_DEREFOF		0x83
#define OP_NOTIFY               0x86
#define OP_SIZEOF               0x87
#define OP_INDEX                0x88
#define OP_MATCH                0x89
#define OP_DWORDFIELD           0x8a
#define OP_WORDFIELD            0x8b
#define OP_BYTEFIELD            0x8c
#define OP_BITFIELD             0x8d
#define OP_OBJTYPE              0x8e
#define OP_LAND                 0x90
#define OP_LOR                  0x91
#define OP_LNOT                 0x92
#define OP_LNOTEQ               0x9392
#define OP_LLEQ                 0x9492
#define OP_LGEQ                 0x9592
#define OP_LEQ                  0x93
#define OP_LG                   0x94
#define OP_LL                   0x95
#define OP_IF                   0xa0
#define OP_ELSE                 0xa1
#define OP_WHILE                0xa2
#define OP_NOP                  0xa3
#define OP_RETURN               0xa4
#define OP_BREAK                0xa5
#define OP_OSI                  0xca
#define OP_BREAKPOINT           0xcc
#define OP_ONES                 0xff

#define EXOP_MUTEX              0x01
#define EXOP_EVENT              0x02
#define EXOP_CONDREFOF          0x12
#define EXOP_CREATEFIELD        0x13
#define EXOP_LOAD               0x20
#define EXOP_STALL              0x21
#define EXOP_SLEEP              0x22
#define EXOP_ACQUIRE            0x23
#define EXOP_SIGNAL             0x24
#define EXOP_WAIT               0x25
#define EXOP_RESET              0x26
#define EXOP_RELEASE            0x27
#define EXOP_FROMBCD            0x28
#define EXOP_TOBCD              0x29
#define EXOP_UNLOAD             0x2a
#define EXOP_REVISION           0x30
#define EXOP_DEBUG              0x31
#define EXOP_FATAL              0x32
#define EXOP_OPREGION           0x80
#define EXOP_FIELD              0x81
#define EXOP_DEVICE             0x82
#define EXOP_PROCESSOR          0x83
#define EXOP_POWERRES           0x84
#define EXOP_THERMALZONE        0x85
#define EXOP_IDXFIELD           0x86
#define EXOP_BANKFIELD          0x87

#define OP_MUTEX                EXOP(EXOP_MUTEX)
#define OP_EVENT                EXOP(EXOP_EVENT)
#define OP_CONDREFOF            EXOP(EXOP_CONDREFOF)
#define OP_CREATEFIELD          EXOP(EXOP_CREATEFIELD)
#define OP_LOAD                 EXOP(EXOP_LOAD)
#define OP_STALL                EXOP(EXOP_STALL)
#define OP_SLEEP                EXOP(EXOP_SLEEP)
#define OP_ACQUIRE              EXOP(EXOP_ACQUIRE)
#define OP_SIGNAL               EXOP(EXOP_SIGNAL)
#define OP_WAIT                 EXOP(EXOP_WAIT)
#define OP_RESET                EXOP(EXOP_RESET)
#define OP_RELEASE              EXOP(EXOP_RELEASE)
#define OP_FROMBCD              EXOP(EXOP_FROMBCD)
#define OP_TOBCD                EXOP(EXOP_TOBCD)
#define OP_UNLOAD               EXOP(EXOP_UNLOAD)
#define OP_REVISION             EXOP(EXOP_REVISION)
#define OP_DEBUG                EXOP(EXOP_DEBUG)
#define OP_FATAL                EXOP(EXOP_FATAL)
#define OP_OPREGION             EXOP(EXOP_OPREGION)
#define OP_FIELD                EXOP(EXOP_FIELD)
#define OP_DEVICE               EXOP(EXOP_DEVICE)
#define OP_PROCESSOR            EXOP(EXOP_PROCESSOR)
#define OP_POWERRES             EXOP(EXOP_POWERRES)
#define OP_THERMALZONE          EXOP(EXOP_THERMALZONE)
#define OP_IDXFIELD             EXOP(EXOP_IDXFIELD)
#define OP_BANKFIELD            EXOP(EXOP_BANKFIELD)

/*** Field flags
 */

#define ACCTYPE_MASK            0x0f
#define ACCTYPE_ANY             0x00    //AnyAcc
#define ACCTYPE_BYTE            0x01    //ByteAcc
#define ACCTYPE_WORD            0x02    //WordAcc
#define ACCTYPE_DWORD           0x03    //DWordAcc
#define ACCTYPE_BLOCK           0x04    //BlockAcc
#define ACCTYPE_SMBSENDRECV     0x05    //SMBSendRecvAcc
#define ACCTYPE_SMBQUICK        0x06    //SMBQuickAcc
#define LOCKRULE_MASK           0x10
#define LOCKRULE_NOLOCK         0x00    //NoLock
#define LOCKRULE_LOCK           0x10    //Lock
#define UPDATERULE_MASK         0x60
#define UPDATERULE_PRESERVE     0x00    //Preserve
#define UPDATERULE_WRITEASONES  0x20    //WriteAsOnes
#define UPDATERULE_WRITEASZEROS 0x40    //WriteAsZeros
//
// Returns 1, 2 or 4 for BYTE, WORD or DWORD respectively and returns 1 for
// any other sizes.
//
#define ACCSIZE(f)		(((((f) & ACCTYPE_MASK) >= ACCTYPE_BYTE) &&   \
				  (((f) & ACCTYPE_MASK) <= ACCTYPE_DWORD))?   \
				 (1 << (((f) & ACCTYPE_MASK) - 1)): 1)

/*** Operation region space
 */

#define REGSPACE_MEM            0       //SystemMemory
#define REGSPACE_IO             1       //SystemIO
#define REGSPACE_PCICFG         2       //PCI_Config
#define REGSPACE_EC             3       //EmbeddedControl
#define REGSPACE_SMB			4		//SMBus
#define REGSPACE_CMOSCFG		5		//Cmos_Config
#define REGSPACE_PCIBARTARGET	6		//PCIBARTarget


/*** Method flags
 */

#define METHOD_NUMARG_MASK      0x07
#define METHOD_SYNCMASK         0x08
#define METHOD_NOTSERIALIZED    0x00
#define METHOD_SERIALIZED       0x08

/*** Match operation values
 */

#define MTR                     0
#define MEQ                     1
#define MLE                     2
#define MLT                     3
#define MGE                     4
#define MGT                     5

/*** IRQ Flags for short descriptor
 */

#define _HE			0x01	//ActiveHigh, EdgeTrigger
#define _LL			0x08	//ActiveLow, LevelTrigger
#define _SHR			0x10	//Shared
#define _EXC			0x00	//Exclusive

/*** IRQ Flags for long descriptor
 */

#define $EDG			0x02	//EdgeTrigger
#define $LVL			0x00	//LevelTrigger
#define $LOW			0x04	//ActiveLow
#define $HGH			0x00	//ActiveHigh
#define $SHR			0x08	//Shared
#define $EXC			0x00	//Exclusive

/*** DMA Flags
 */

#define X8                      0x00    //Transfer8
#define X816                    0x01    //Transfer8_16
#define X16                     0x02    //Transfer16
#define NOBM                    0x00    //NotBusMaster
#define BM                      0x04    //BusMaster
#define COMP                    0x00    //Compatibility
#define TYPA                    0x20    //TypeA
#define TYPB                    0x40    //TypeB
#define TYPF                    0x60    //TypeF

/*** IO Flags
 */

#define DC16                    0x01    //Decode16
#define DC10                    0x00    //Decode10

/*** Memory Flags
 */

#define _RW                     0x01    //Read/Write
#define _ROM                    0x00    //Read only

/*** Address Space Descriptor General Flags
 */

#define RCS                     0x01    //Resource Consumer
#define RPD                     0x00    //Resource Producer
#define BSD                     0x02    //Bridge Subtractive Decode
#define BPD                     0x00    //Bridge Positive Decode
#define MIF                     0x04    //Min address is fixed
#define NMIF                    0x00    //Min address is not fixed
#define MAF                     0x08    //Max address is fixed
#define NMAF                    0x00    //Max address is not fixed

/*** Memory Address Space Flags
 */

#define CACH                    0x02    //Cacheable
#define WRCB                    0x04    //WriteCombining
#define PREF                    0x06    //Prefetchable
#define NCAC                    0x00    //Non-Cacheable

/*** IO Address Space Flags
 */

#define ISA                     0x02    //ISAOnly ranges
#define NISA                    0x01    //NonISAOnly ranges
#define ERNG                    0x03    //Entire range

#define MAX_ARGS		7
#define MAX_NSPATH_LEN		1275	//approx. 255*4 + 255 (255 NameSegs)


//
// N: NameStr
// O: DataObj (num, string, buffer, package)
// K: Keyword (e.g. NoLock, ByteAcc etc.)
// D: DWord integer
// W: Word integer
// B: Byte integer
// U: Numeric (any size integer)
// S: SuperName (NameStr + Localx + Argx + Ret)
// C: Opcode
// Z: ASCIIZ string
//
#define AF      TF_ACTION_FLIST         //process after fixed list is parsed
#define AV      TF_ACTION_VLIST         //process after variable list is parsed
#define LN      TF_PACKAGE_LEN          //term requires package length
#define CC      TF_CHANGE_CHILDSCOPE    //change to child scope
#define DL      TF_DATA_LIST            //term expects buffer data list
#define PL      TF_PACKAGE_LIST         //term expects package list
#define FL      TF_FIELD_LIST           //term expects FieldList
#define OL      TF_OBJECT_LIST          //term expects ObjectList
#define LL      TF_COMPILER_DIRECTIVE   //term expects compiler directives
#define CL      TF_CODE_LIST            //term expects CodeList
#define AL      TF_ALL_LISTS            //term expects anything
#define ML      TF_PNP_MACRO            //term expects PNPMacro
#define BL      TF_BYTE_LIST            //term expects ByteList
#define DD      TF_DWORD_LIST           //term expects DWordList
#define SK      TF_DELAY_UNASM          //term cannot be unasmed on the first pass

#define CD      UTC_COMPILER_DIRECTIVE
#define FM      UTC_FIELD_MACRO
#define CN      UTC_CONST_NAME
#define SN      UTC_SHORT_NAME
#define NS      UTC_NAMESPACE_MODIFIER
#define DO      UTC_DATA_OBJECT
#define KW      UTC_KEYWORD
#define NO      UTC_NAMED_OBJECT
#define C1      UTC_OPCODE_TYPE1
#define C2      UTC_OPCODE_TYPE2
#define RO      UTC_REF_OBJECT
#define PM      UTC_PNP_MACRO

#define UNK     OBJTYPE_UNKNOWN
#define INT     OBJTYPE_INTDATA
#define STR     OBJTYPE_STRDATA
#define BUF     OBJTYPE_BUFFDATA
#define PKG     OBJTYPE_PKGDATA
#define FDU     OBJTYPE_FIELDUNIT
#define DEV     OBJTYPE_DEVICE
#define EVT     OBJTYPE_EVENT
#define MET     OBJTYPE_METHOD
#define MUT     OBJTYPE_MUTEX
#define OPR     OBJTYPE_OPREGION
#define PWR     OBJTYPE_POWERRES
#define THM     OBJTYPE_THERMALZONE
#define BFD     OBJTYPE_BUFFFIELD
#define DDB     OBJTYPE_DDBHANDLE

//
// Field flags
//
#define AANY    (ACCTYPE_ANY | (ACCTYPE_MASK << 8))
#define AB      (ACCTYPE_BYTE | (ACCTYPE_MASK << 8))
#define AW      (ACCTYPE_WORD | (ACCTYPE_MASK << 8))
#define ADW     (ACCTYPE_DWORD | (ACCTYPE_MASK << 8))
#define ABLK    (ACCTYPE_BLOCK | (ACCTYPE_MASK << 8))
#define ASSR    (ACCTYPE_SMBSENDRECV | (ACCTYPE_MASK << 8))
#define ASQ     (ACCTYPE_SMBQUICK | (ACCTYPE_MASK << 8))
#define LK      (LOCKRULE_LOCK | (LOCKRULE_MASK << 8))
#define NOLK    (LOCKRULE_NOLOCK | (LOCKRULE_MASK << 8))
#define PSRV    (UPDATERULE_PRESERVE | (UPDATERULE_MASK << 8))
#define WA1S    (UPDATERULE_WRITEASONES | (UPDATERULE_MASK << 8))
#define WA0S    (UPDATERULE_WRITEASZEROS | (UPDATERULE_MASK << 8))

//
// Operation region space
//
#define MEM     (REGSPACE_MEM | 0xff00)
#define IO      (REGSPACE_IO | 0xff00)
#define CFG     (REGSPACE_PCICFG | 0xff00)
#define EC      (REGSPACE_EC | 0xff00)
#define SMB     (REGSPACE_SMB | 0xff00)

//
// Method flags
//
#define SER     (METHOD_SERIALIZED | (METHOD_SYNCMASK << 8))
#define NOSER   (METHOD_NOTSERIALIZED | (METHOD_SYNCMASK << 8))

//
// Match operation values
//
#define OMTR    (MTR | 0xff00)
#define OMEQ    (MEQ | 0xff00)
#define OMLE    (MLE | 0xff00)
#define OMLT    (MLT | 0xff00)
#define OMGE    (MGE | 0xff00)
#define OMGT    (MGT | 0xff00)


#define INVALID  OPCLASS_INVALID
#define DATAOBJ  OPCLASS_DATA_OBJ
#define NAMEOBJ  OPCLASS_NAME_OBJ
#define CONSTOBJ OPCLASS_CONST_OBJ
#define CODEOBJ  OPCLASS_CODE_OBJ
#define ARGOBJ   OPCLASS_ARG_OBJ
#define LOCALOBJ OPCLASS_LOCAL_OBJ

// Error codes
#define ARGERR_NONE             0
#define ARGERR_SEP_NOT_FOUND    -1
#define ARGERR_INVALID_NUMBER   -2
#define ARGERR_INVALID_ARG      -3
#define ARGERR_ASSERT_FAILED    -4

// Command argument flags
#define AF_NOI                  0x00000001      //NoIgnoreCase
#define AF_SEP                  0x00000002      //require separator

// Command argument types
#define AT_END                  0               //end marker of arg table
#define AT_STRING               1
#define AT_NUM                  2
#define AT_ENABLE               3
#define AT_DISABLE              4
#define AT_ACTION               5

// Debugger error codes
#define DBGERR_NONE             0
#define DBGERR_QUIT             -1
#define DBGERR_INVALID_CMD      -2
#define DBGERR_PARSE_ARGS       -3
#define DBGERR_CMD_FAILED       -4
#define DBGERR_INTERNAL_ERR -5

// dwfFlags for AMLIGetNameSpaceObject
#define NSF_LOCAL_SCOPE         0x00000001

// dwfNS local flags
#define NSF_EXIST_OK            0x00010000      //for CreateNameSpaceObject
#define NSF_WARN_NOTFOUND       0x80000000      //for GetNameSpaceObject

/*** Type definitions
 */
typedef CHAR *PSZ;
typedef ULONG NAMESEG;
typedef UCHAR *PUCHAR;
typedef struct _cmdarg CMDARG;
typedef CMDARG *PCMDARG;
typedef LONG (LOCAL *PFNARG)(PCMDARG, PSZ, ULONG, ULONG);

struct _cmdarg
{
    PSZ    pszArgID;            //argument ID string
    ULONG  dwArgType;           //AT_*
    ULONG  dwfArg;              //AF_*
    PVOID  pvArgData;           //AT_END: none
                                //AT_STRING: PPSZ - ptr. to string ptr.
                                //AT_NUM: PLONG - ptr. to number
                                //AT_ENABLE: PULONG - ptr. to flags
                                //AT_DISABLE: PULONG - ptr. to flags
                                //AT_ACTION: none
    ULONG  dwArgParam;          //AT_END: none
                                //AT_STRING: none
                                //AT_NUM: base
                                //AT_ENABLE: flag bit mask
                                //AT_DISABLE: flag bit mask
                                //AT_ACTION: none
    PFNARG pfnArg;              //ptr. to argument verification function or
                                //  action function if AT_ACTION
};

typedef struct _dbgcmd
{
    PSZ     pszCmd;
    ULONG   dwfCmd;
    PCMDARG pArgTable;
    PFNARG  pfnCmd;
} DBGCMD, *PDBGCMD;

typedef struct _aslterm
    {
        PUCHAR  ID;
        ULONG   TermClass;
        ULONG   TermData;
        ULONG   OpCode;
        PUCHAR  UnAsmArgTypes;
        PUCHAR  ArgActions;
        ULONG   Flags;
    } ASLTERM, *PASLTERM;

    typedef struct _opmap
    {
        UCHAR   ExtendedOpCode;
        UCHAR   OpCodeClass;
    } OPMAP, *POPMAP;

//dwDataType values
typedef enum _OBJTYPES {
    OBJTYPE_UNKNOWN = 0,
    OBJTYPE_INTDATA,
    OBJTYPE_STRDATA,
    OBJTYPE_BUFFDATA,
    OBJTYPE_PKGDATA,
    OBJTYPE_FIELDUNIT,
    OBJTYPE_DEVICE,
    OBJTYPE_EVENT,
    OBJTYPE_METHOD,
    OBJTYPE_MUTEX,
    OBJTYPE_OPREGION,
    OBJTYPE_POWERRES,
    OBJTYPE_PROCESSOR,
    OBJTYPE_THERMALZONE,
    OBJTYPE_BUFFFIELD,
    OBJTYPE_DDBHANDLE,
    OBJTYPE_DEBUG,
//These are internal object types (not to be exported to the ASL code)
    OBJTYPE_INTERNAL = 0x80,
    OBJTYPE_OBJALIAS = 0x80,
    OBJTYPE_DATAALIAS,
    OBJTYPE_BANKFIELD,
    OBJTYPE_FIELD,
    OBJTYPE_INDEXFIELD,
    OBJTYPE_DATA,
    OBJTYPE_DATAFIELD,
    OBJTYPE_DATAOBJ,
} OBJTYPES;


/*** Local function prototypes
 */

LONG LOCAL AMLIDbgDebugger(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgDNS(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DumpNSObj(PSZ pszPath, BOOLEAN fRecursive);
VOID LOCAL DumpNSTree(PULONG64 pnsObj, ULONG dwLevel);
LONG LOCAL AMLIDbgFind(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
BOOLEAN LOCAL FindNSObj(NAMESEG dwName, PULONG64 pnsRoot);
PSZ LOCAL GetObjectPath(PULONG64 pns);
PSZ LOCAL GetObjAddrPath(ULONG64 uipns);
VOID LOCAL AMLIDumpObject(PULONG64 pdata, PSZ pszName, int iLevel);
PSZ LOCAL AMLIGetObjectTypeName(ULONG dwObjType);
PSZ LOCAL GetRegionSpaceName(UCHAR bRegionSpace);
BOOLEAN LOCAL FindObjSymbol(ULONG64 uipObj, PULONG64 puipns, PULONG pdwOffset);
VOID LOCAL PrintBuffData(PUCHAR pb, ULONG dwLen);
BOOLEAN LOCAL IsNumber(PSZ pszStr, ULONG dwBase, PULONG64 puipValue);
LONG LOCAL DbgParseArgs(PCMDARG ArgTable, PULONG pdwNumArgs, PULONG pdwNonSWArgs, PSZ pszTokenSeps);
LONG LOCAL DbgParseOneArg(PCMDARG ArgTable, PSZ psz, ULONG dwArgNum, PULONG pdwNonSWArgs);
PCMDARG LOCAL DbgMatchArg(PCMDARG ArgTable, PSZ *ppsz, PULONG pdwNonSWArgs);
VOID MemZero(ULONG64 uipAddr, ULONG dwSize);
BYTE ReadMemByte(ULONG64 uipAddr);
WORD ReadMemWord(ULONG64 uipAddr);
DWORD ReadMemDWord(ULONG64 uipAddr);
ULONG_PTR ReadMemUlongPtr(ULONG64 uipAddr);
PVOID LOCAL GetObjBuff(PULONG64 pdata);
LONG LOCAL GetNSObj(PSZ pszObjPath, PULONG64 pnsScope, PULONG64 puipns, PULONG64 pns, ULONG dwfNS);
PSZ LOCAL NameSegString(ULONG dwNameSeg);
VOID STDCALL AMLIDbgExecuteCmd(PSZ pszCmd);
LONG LOCAL AMLIDbgHelp(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
PSZ LOCAL StrCat(PSZ pszDst, PSZ pszSrc, ULONG n);
ULONG LOCAL StrLen(PSZ psz, ULONG n);
LONG LOCAL StrCmp(PSZ psz1, PSZ psz2, ULONG n, BOOLEAN fMatchCase);
PSZ LOCAL StrCpy(PSZ pszDst, PSZ pszSrc, ULONG n);
ULONG64 AMLIUtilStringToUlong64(PSZ String, PSZ *End, ULONG Base);

#endif //_AMLIKD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\bushnd.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bushnd.c

Abstract:

    KD Extension for BUS_HANDLER data structures.

Author:

    Peter Johnston (peterj) 13-May-1998

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"

//
// The following typedef is copied directly from nthals\bushnd.c.
//

/*
typedef struct _HAL_BUS_HANDLER {
    LIST_ENTRY      AllHandlers;
    ULONG           ReferenceCount;
    BUS_HANDLER     Handler;
} HAL_BUS_HANDLER, *PHAL_BUS_HANDLER;
*/

BOOLEAN
bushndReadMemory(
    ULONG64 S,
    PVOID D,
    ULONG Len
    )

/*++

Routine Description:

    Wrapper for ReadMemory that's somewhat easier to use.   Also
    does a small amount of failsafe stuff, like failing the read
    if the user pressed control-C.

Arguments:

    S       Source Address in host memory to read data from.
    D       Destination address in local memory.
    Len     length in bytes.

Return Value:

    Returns TRUE if the operation was successful, FALSE otherwise.

--*/

{
    ULONG result;

    //
    // Sanity:  Only read kernel mode addresses.   Kernel mode
    // addresses are always greater than 2GB.   Being greater than
    // 2GB doesn't ensure it's kernel mode, but if it's less than
    // 2GB it is certainly NOT kernel mode.
    //

    if (S < 0x80000000) {
        dprintf("bushnd sanity: refusing to read usermode address %p\n", S);
        return FALSE;
    }

    if (!ReadMemory(S,
                    D,
                    Len,
                    &result) && (result == Len)) {

        dprintf("Unable to read structure at %p.  ", S);
        return FALSE;
    }

    if (CheckControlC()) {
        dprintf("Terminating operation at user request.\n");
        return FALSE;
    }
    return TRUE;
}

PUCHAR
bushndInterfaceType(
    IN INTERFACE_TYPE InterfaceType
    )
{
    switch (InterfaceType) {
    case InterfaceTypeUndefined:    return "InterfaceTypeUndefined";
    case Internal:                  return "Internal";
    case Isa:                       return "Isa";
    case Eisa:                      return "Eisa";
    case MicroChannel:              return "Micro Channel";
    case TurboChannel:              return "Turbo Channel";
    case PCIBus:                    return "PCI";
    case VMEBus:                    return "VME";
    case NuBus:                     return "NuBus";
    case PCMCIABus:                 return "PCMCIA";
    case CBus:                      return "CBus";
    case MPIBus:                    return "MPIBus";
    case MPSABus:                   return "MPSABus";
    case ProcessorInternal:         return "Processor Internal";
    case InternalPowerBus:          return "Internal Power Bus";
    case PNPISABus:                 return "PnP Isa";
    case PNPBus:                    return "PnP Bus";
    default:                        return "** Unknown Interface Type **";
    }
}

VOID
bushndDisplayAddressRange(
    IN ULONG64          HostAddress,
    IN PUCHAR           String
    )

/*++

Routine Description:

    Display a set of ranges.   Used by bushndDisplayBusRanges.
    (Pretty much just lifted this code from nthals/rangesup.c).

Arguments:

    Pointer to a PSUPPORTED_RANGE structure.   This is a linked
    list of the ranges of this type for this bus handler.

    Note: On entry we are pointing at a local copy of the first
    PSUPPORTED_RANGE of this type embedded in the BUS_HANDLER
    structure.   We don't want to modify that so subsequent
    ranges are read into a seperate local structure.

    String.   What sort of range this is (a heading).

Return Value:

    None.

--*/

{
    ULONG64 Limit, Base, SystemBase, Next;

    do {

        InitTypeRead(HostAddress, SUPPORTED_RANGE);

        Limit = ReadField(Limit); Base = ReadField(Base);
        SystemBase = ReadField(SystemBase);

        if (Limit) {

            //
            // Address->Limit == 0 means skip this range,... otherwise,...
            //
            // Print this range.
            //

            dprintf("  %s: %x:%08x - %x:%08x (tran %x:%08x space %d (r@%p))\n",
                    String,
                    (ULONG)(Base >> 32),
                    (ULONG)(Base),
                    (ULONG)(Limit >> 32),
                    (ULONG)(Limit),
                    (ULONG)(SystemBase >> 32),
                    (ULONG)(SystemBase),
                    (ULONG)ReadField(SystemAddressSpace),
                    HostAddress
                    );
            String = "        ";
        }

        //
        // Advance.
        //

        if (!(HostAddress = ReadField(Next))) {
            return;
        }

        if (GetFieldValue(HostAddress, "SUPPORTED_RANGE", 
                          "Next", Next)) {
            dprintf("Unable to follow range list.\n");
            return;
        }

        //
        // Quick saftey check,... make sure we don't follow a
        // self pointer,... would be good to do some more checking.
        //

        if (Next == HostAddress) {

            //
            // Self pointer.
            //

            dprintf("Ill-formed list, points to self at %p\n", HostAddress);
            return;
        }

    } while (TRUE);
}

VOID
bushndDisplayBusRanges(
    IN ULONG64 BusAddresses
    )
{
    ULONG Version, Offset;

    if (!BusAddresses) {
        dprintf("  No ranges associated with this bus.\n");
        return;
    }

    if (GetFieldValue(BusAddresses, "SUPPORTED_RANGES",
                      "Version", Version)) {
        dprintf("Cannot dump ranges for this bus handler.\n");
        return;
    }

    GetFieldOffset("SUPPORTED_RANGES", "IO", &Offset);
    bushndDisplayAddressRange(BusAddresses + Offset,
                              "IO......");
    GetFieldOffset("SUPPORTED_RANGES", "Memory", &Offset);
    bushndDisplayAddressRange(BusAddresses + Offset,
                              "Memory..");
    GetFieldOffset("SUPPORTED_RANGES", "PrefetchMemory", &Offset);
    bushndDisplayAddressRange(BusAddresses + Offset,
                              "PFMemory");
    GetFieldOffset("SUPPORTED_RANGES", "Dma", &Offset);
    bushndDisplayAddressRange(BusAddresses + Offset,
                              "DMA.....");
}

VOID
bushndDisplaySymbol(
    IN PUCHAR Name,
    IN ULONG64  Address
    )
{
    UCHAR    Symbol[256];
    ULONG64  Displacement;

    GetSymbol((LONG64)Address, Symbol, &Displacement);
    dprintf("  %s  %08p     (%s)\n", Name, Address, Symbol);
}

DECLARE_API( bushnd )

/*++

Routine Description:

    If no handler specified, dump the list of handlers and some simple
    info about each of them.

    If a handler is specified, dump everything we know about it.

Arguments:

    Bus handler address [optional].

Return Value:

    None.

--*/

{
    ULONG64        Handler;
    ULONG64        HostHandler;
    ULONG64        HalBusHandler;
    ULONG64        HandlerListHead;
    UCHAR          SymbolBuffer[256];

    HostHandler = GetExpression(args);

    if (HostHandler) {
        ULONG Version, InitTypeRead, InterfaceType;
        ULONG64 DeviceObject, BusData;

        //
        // User supplied a handler address, dump details for that bus
        // handler.
        //


        if (GetFieldValue(HostHandler, "BUS_HANDLER",
                          "Version", Version)) {

            dprintf("-- Cannot continue --\n");
            return E_INVALIDARG;
        }
        InitTypeRead(HostHandler, BUS_HANDLER);
        InterfaceType = (ULONG) ReadField(InterfaceType);
        dprintf("Dump of bus handler %p\n", HostHandler);
        dprintf("  Version              %d\n",  Version);
        dprintf("  Interface Type (%d) = %s\n",
                InterfaceType,
                bushndInterfaceType(InterfaceType));
        dprintf("  Bus Number           %d\n", (ULONG) ReadField(BusNumber));
        if (DeviceObject = ReadField(DeviceObject)) {
            dprintf("  Device Object        %p\n",
                    DeviceObject);
        }
        dprintf("  Parent Bus Handler   %p\n", ReadField(ParentHandler));
        if (BusData = ReadField(BusData)) {
            dprintf("  BusData              %p\n", BusData);
        }

        bushndDisplaySymbol("GetBusData         ", ReadField(GetBusData));
        bushndDisplaySymbol("SetBusData         ", ReadField(SetBusData));
        bushndDisplaySymbol("AdjustResourceList ", ReadField(AdjustResourceList));
        bushndDisplaySymbol("AssignSlotResources", ReadField(AssignSlotResources));
        bushndDisplaySymbol("GetInterruptVector ", ReadField(GetInterruptVector));
        bushndDisplaySymbol("TranslateBusAddress", ReadField(TranslateBusAddress));

        bushndDisplayBusRanges(ReadField(BusAddresses));

    } else {
        ULONG   Off;

        //
        // User did not supply a handler address, try to find the
        // list of all bus handlers and dump a summary of each handler.
        //

        HandlerListHead = GetExpression("hal!HalpAllBusHandlers");

        if (!HandlerListHead) {

            //
            // Couldn't get address of HalpAllBusHandlers.  Whine
            // at user.
            //

            dprintf(
                "Unable to get address of HalpAllBusHandlers, most likely\n"
                "cause is failure to load HAL symbols, or, this HAL might\n"
                "not actually use bus handlers.   "
                );

            dprintf("-- Cannot continue --");
            return E_INVALIDARG;
        }

        if (GetFieldValue(HandlerListHead, "LIST_ENTRY",
                          "Flink", HalBusHandler)) {
            dprintf(
                "Could not read HalpAllBusHandlers from host memory (%p).\n"
                "This is most likely caused by incorrect HAL symbols.\n",
                HandlerListHead
                );

            dprintf("-- Cannot continue --\n");
            return E_INVALIDARG;
        }

        if (HalBusHandler == HandlerListHead) {

            dprintf(
                "HalpAllBusHandlers found (at %p) but list is empty.\n",
                HandlerListHead
                );

            dprintf("-- Cannot continue --\n");
            return E_INVALIDARG;
        }

        GetFieldOffset("hal!_HAL_BUS_HANDLER", "Handler", &Off);

        //
        // In theory, we now have the handler list.  Walk it.
        //

        do {
            ULONG64 Next;
            ULONG BusNumber, InterfaceType;

            if (GetFieldValue(HalBusHandler, "hal!_HAL_BUS_HANDLER",
                              "AllHandlers.Flink", Next)) {

                dprintf("-- Cannot continue --\n");
                return E_INVALIDARG;
            }

            //
            // Brief summary.
            //

            Handler = HalBusHandler + Off;
            GetFieldValue(HalBusHandler, "hal!_HAL_BUS_HANDLER", "BusNumber", BusNumber);
            GetFieldValue(HalBusHandler, "hal!_HAL_BUS_HANDLER", "Handler.InterfaceType", InterfaceType);
            dprintf(
                "%p  bus %d, type %s\n",
                Handler,
                BusNumber,
                bushndInterfaceType(InterfaceType)
                );
            
            //
            // Advance to next.
            //

            HalBusHandler = Next;

        } while (HalBusHandler != HandlerListHead);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\calldata.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    calldata.c

Abstract:

    WinDbg Extension Api

Author:

    David N. Cutler (davec) 22-May-1994

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


typedef struct CALL_HASH_READ {
    ULONG64 CallersAddress;
    ULONG64 CallersCaller;
    ULONG   CallCount;
} CALL_HASH_READ, *PCALL_HASH_READ;


int __cdecl
HashCompare(
    const void * Element1,
    const void * Element2
    );

DECLARE_API( calldata )

/*++

Routine Description:

    Dump call data hash table

Arguments:

    arg - name-of-hash-table

Return Value:

    None

--*/

{
    UCHAR Buffer[256];
    ULONG64 Displacement=0;
    ULONG64 End=0;
    ULONG Index;
    ULONG64 CallData;
    ULONG64 Next;
    ULONG  Result;
    UCHAR  TableName[80];
    PCALL_HASH_READ CallerArray;
    ULONG NumberCallers = 0;
    ULONG ArraySize = 1000;
    ULONG64 HashTable_Flink;

    //
    // If a table name was not specified, then don't attempt to dump the
    // table.
    //

    if (args[0] == '\0') {
        dprintf("A call data table name must be specified\n");
        return E_INVALIDARG;
    }

    //
    // Get the address of the specified call performance data and read the
    // contents of the structure.
    //

    strcpy(&TableName[0], args);
    dprintf("**** Dump Call Performance Data For %s ****\n\n", &TableName[0]);
    CallData = GetExpression(&TableName[0]);
    if ((CallData == 0) ||
        (GetFieldValue(CallData, "_CALL_PERFORMANCE_DATA", "HashTable.Flink", HashTable_Flink)
          != FALSE)) {

        //
        // The target build does not support specified call performance data.
        //

        dprintf("%08p: No call performance data available\n", CallData);

    } else {
        ULONG HashTableOffset;
        
        GetFieldOffset("_CALL_PERFORMANCE_DATA", "HashTable", &HashTableOffset);

        //
        // Dump the specified call data.
        //
        CallerArray = LocalAlloc(LMEM_FIXED, sizeof(CALL_HASH_READ) * ArraySize);
        if (CallerArray==NULL) {
            dprintf("Couldn't allocate memory for caller array\n");
            return E_INVALIDARG;
        }

        dprintf("Loading data");
        for (Index = 0; Index < CALL_HASH_TABLE_SIZE; Index += 1) {
            UCHAR CallHash[] = "_CALL_HASH_ENTRY";

            End =  HashTableOffset + CallData + GetTypeSize("_LIST_ENTRY") * Index;

            GetFieldValue(End, "_LIST_ENTRY", "Flink", Next);

            while (Next != End) {
                if (!GetFieldValue(Next, CallHash, "CallersCaller", CallerArray[NumberCallers].CallersCaller) &&
                    !GetFieldValue(Next, CallHash, "CallersAddress", CallerArray[NumberCallers].CallersAddress) &&
                    !GetFieldValue(Next, CallHash, "CallCount", CallerArray[NumberCallers].CallCount)) {

                    NumberCallers++;

                    if (NumberCallers == ArraySize) {

                        //
                        // Grow the caller array
                        //
                        PCALL_HASH_READ NewArray;

                        ArraySize = ArraySize * 2;
                        NewArray = LocalAlloc(LMEM_FIXED, sizeof(CALL_HASH_READ) * ArraySize);
                        if (NewArray == NULL) {
                            dprintf("Couldn't allocate memory to extend caller array\n");
                            LocalFree(CallerArray);
                            return E_INVALIDARG;
                        }
                        CopyMemory(NewArray, CallerArray, sizeof(CALL_HASH_READ) * NumberCallers);
                        LocalFree(CallerArray);
                        CallerArray = NewArray;
                    }

                    if ((NumberCallers % 10) == 0) {
                        dprintf(".");
                    }
                }

                GetFieldValue(Next, CallHash, "ListEntry.Flink", Next);
                if (CheckControlC()) {
                    LocalFree(CallerArray);
                    return E_INVALIDARG;
                }
            }
            if (CheckControlC()) {
                return E_INVALIDARG;
            }
        }

        qsort((PVOID)CallerArray,
              NumberCallers,
              sizeof(CALL_HASH_READ),
              HashCompare);

        dprintf("\n  Number    Caller/Caller's Caller\n\n");

        for (Index = 0; Index < NumberCallers; Index++) {
            GetSymbol(CallerArray[Index].CallersAddress,
                      Buffer,
                      &Displacement);

            dprintf("%10d  %s", CallerArray[Index].CallCount, Buffer);
            if (Displacement != 0) {
                dprintf("+0x%1p", Displacement);
            }

            if (CallerArray[Index].CallersCaller != 0) {
                dprintf("\n");
                GetSymbol(CallerArray[Index].CallersCaller,
                          Buffer,
                          &Displacement);

                dprintf("            %s", Buffer);
                if (Displacement != 0) {
                    dprintf("+0x%1p", Displacement);
                }
            }
            dprintf("\n");
            if (CheckControlC()) {
                break;
            }
        }

        LocalFree(CallerArray);
    }

    return S_OK;
}

int __cdecl
HashCompare(
    const void * Element1,
    const void * Element2
    )

/*++

Routine Description:

    Provides a comparison of hash elements for the qsort library function

Arguments:

    Element1 - Supplies pointer to the key for the search

    Element2 - Supplies element to be compared to the key

Return Value:

    > 0     - Element1 < Element2
    = 0     - Element1 == Element2
    < 0     - Element1 > Element2

--*/

{
    PCALL_HASH_READ Hash1 = (PCALL_HASH_READ)Element1;
    PCALL_HASH_READ Hash2 = (PCALL_HASH_READ)Element2;

    if (Hash1->CallCount < Hash2->CallCount) {
        return(1);
    }
    else if (Hash1->CallCount > Hash2->CallCount) {
        return(-1);
    } else {
        return(0);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\bugdump.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    bugdump.c

Abstract:

    WinDbg Extension Api

Author:

    David N. Cutler (davec) 6-Aug-1994

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "string.h"

//
// Declare storage for bug check dump buffer and component name.
//

#define BUFFER_SIZE (1 << 12)
#define NAME_SIZE (1 << 5)

ULONG DumpBuffer[BUFFER_SIZE / sizeof(ULONG)];
UCHAR NameBuffer[NAME_SIZE + 1];

DECLARE_API( bugdump )

/*++

Routine Description:

    Dump bug check callback data.

Arguments:

    arg - Supplies the optional component name.

Return Value:

    None.

--*/

{

    ULONG64 CallbackAddress;
    ULONG64 ComponentAddress;
    PUCHAR ComponentName;
    ULONG DataLength;
    PUCHAR DumpState;
    ULONG Limit;
    ULONG64 ListHead;
    ULONG Index;
    ULONG Inner;
    ULONG64 NextEntry;
    ULONG Result, Offset;

    //
    // If a componetn name name is specified, then only dump that components
    // data. Otherwise, dump the components data for all components that are
    // recorded in the bug check call back list.
    //

    if (args[0] != '\0') {
        ComponentName = (PUCHAR)&args[0];

    } else {
        ComponentName = NULL;
    }

    //
    // Get the address and contents of the bug check callback listhead.
    //

    dprintf("**** Dump of Bug Check Data ****\n");
    ListHead = GetNtDebuggerData(KeBugCheckCallbackListHead);
    if ((ListHead == 0) ||
        GetFieldValue(ListHead, "LIST_ENTRY", "Flink", NextEntry)) {

        //
        // The target build does not bug check callbacks.
        //

        dprintf("%08p: No bug check callback data available\n", ListHead);

    } else {

        GetFieldOffset("KBUGCHECK_CALLBACK_RECORD", "Entry", &Offset);

        //
        // Dump the specified bug check callback data.
        //

        while (NextEntry != ListHead) {

            //
            // Compute the address of the next callback record and read it.
            //

            CallbackAddress = NextEntry - Offset;

            if (GetFieldValue(CallbackAddress, "KBUGCHECK_CALLBACK_RECORD", 
                              "Entry.Flink", NextEntry)) {

                //
                // The target callback record could not be read.
                //

                dprintf("%08p: Bug check callback record could not be read\n",
                        CallbackAddress);

                break;

            } else {
                ULONG State;

                //
                // Set the address of struct to be read
                //
                InitTypeRead(CallbackAddress, KBUGCHECK_CALLBACK_RECORD);

                //
                // Read the component name.
                //

                ComponentAddress = ReadField(Component);

                for (Index = 0; Index < NAME_SIZE; Index += 1) {
                    if (ReadMemory(ComponentAddress,
                                   &NameBuffer[Index],
                                   sizeof(UCHAR),
                                   &Result) == FALSE) {

                        NameBuffer[Index] = '\0';
                    }

                    ComponentAddress += 1;
                    if (NameBuffer[Index] == '\0') {
                        break;
                    }
                }

                NameBuffer[Index] = '\0';

                //
                // If a component name is specified, then compare the
                // component with the specified name. If the component
                // name does not match, then continue with the next
                // entry in the list.
                //

                if (ComponentName != NULL) {
                    if (_stricmp(ComponentName, &NameBuffer[0]) != 0) {
                        continue;
                    }
                }

                //
                // Either all bug callback records are being dumped or the
                // specified component has been found. Dump the contents of
                // the dump buffer, if the state of the callback record is
                // not inserted.
                //

                dprintf("  Dumping data for component %s \n", &NameBuffer[0]);
                State = (ULONG) ReadField(State);
                if (State == BufferInserted) {
                    dprintf("    No bug check dump data available\n\n");

                } else {
                    if (State == BufferStarted) {
                        DumpState = "Dump started/not finished";

                    } else if (State == BufferFinished) {
                        DumpState = "Dump started/finished";

                    } else {
                        DumpState = "Dump started/not completed";
                    }

                    dprintf("    Buffer state - %s\n\n", DumpState);
                    DataLength = (ULONG) ReadField(Length);
                    if (DataLength > BUFFER_SIZE) {
                        DataLength = BUFFER_SIZE;
                    }

                    RtlZeroMemory(&DumpBuffer[0], BUFFER_SIZE);
                    if (ReadMemory(ReadField(Buffer),
                                   &DumpBuffer[0],
                                   DataLength,
                                   &Result) == FALSE) {

                        dprintf("%08lx: Bug check dump data could not be read\n",
                                Result);

                    } else {

                        //
                        // Display bug check data.
                        //

                        DataLength = (DataLength + sizeof(ULONG) - 1) / sizeof(ULONG);
                        for (Index = 0; Index < DataLength; Index += 4) {
                            dprintf("%08lx", Index * 4);
                            Limit = Index + 4;
                            if (Limit > DataLength) {
                                Limit = DataLength;
                            }

                            for (Inner = Index; Inner < Limit; Inner += 1) {
                                dprintf(" %08lx", DumpBuffer[Inner]);
                            }

                            dprintf("\n");
                        }

                        dprintf("\n");
                    }
                }

                if (ComponentName != NULL) {
                    break;
                }
            }
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\dcr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ia64 dcr

Abstract:

    KD Extension Api

Author:

    Thierry Fevrier (v-thief)

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ia64.h"

//
// EmDcrFields: EM register fields for the Default Control Register.
//

EM_REG_FIELD EmDcrFields[] = {
        { "pp", "Privileged Performance Monitor Default" , 0x1, 0 },   // 0
        { "be", "Big-Endian Default"  , 0x1, 1 },   // 1
        { "lc", "IA-32 Lock check Enable", 0x1, 2 }, // 2
        { "rv", "reserved1", 0x5, 3 }, // 3-7
        { "dm", "Defer TLB Miss faults only", 0x1, 8 }, // 8
        { "dp", "Defer Page Not Present faults only", 0x1, 9 }, // 9
        { "dk", "Defer Key Miss faults only", 0x1, 10 }, // 10
        { "dx", "Defer Key Permission faults only",    0x1, 11 }, // 11
        { "dr", "Defer Access Rights faults only", 0x1, 12 }, // 12
        { "da", "Defer Access Bit faults only", 0x1, 13 }, // 13
        { "dd", "Defer Debug faults only", 0x1,1420 }, // 14
        { "rv", "reserved2", 0x31, 15 }, // 15-63
};

VOID
DisplayDcrIA64( 
    IN const PCHAR         Header,
    IN       EM_DCR        EmDcr,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( EM_DCRToULong64(EmDcr), EmDcrFields, DisplayMode );
    }
    else   {
       dprintf(
            "pp be lc dm dp dk dx dr da dd\n"
            "%1I64x %1I64x %1I64x %1I64x %1I64x %1I64x %1I64x %1I64x %1I64x %1I64x\n",
            EmDcr.pp,
            EmDcr.be,
            EmDcr.lc,
            EmDcr.dm,
            EmDcr.dp,
            EmDcr.dk,
            EmDcr.dx,
            EmDcr.dr,
            EmDcr.da,
            EmDcr.dd
            );
    }
    return;
} // DisplayDcrIA64()

DECLARE_API( dcr )

/*++

Routine Description:

    Dumps an IA64 Processor Default Control Register

Arguments:

    args - Supplies the address in hex or @dcr.

Return Value:

    None

--*/

{
    ULONG64     dcrValue;
    ULONG       result;
    ULONG       flags = 0;
    char       *header;

    if (GetExpressionEx(args,&dcrValue, &args)) {
        flags = (ULONG) GetExpression(args);
    } else {
        dprintf("USAGE: !dcr 0xValue [display_mode:0,1,2]\n");
        dprintf("USAGE: !dcr @dcr    [display_mode:0,1,2]\n");
        return E_INVALIDARG;
    }

    header = (flags > DISPLAY_MIN) ? NULL : "\tdcr:\t";

    switch ( TargetMachine ) {
        case IMAGE_FILE_MACHINE_IA64:
            DisplayDcrIA64( header, ULong64ToEM_DCR(dcrValue), flags );
            break;

        default:
            dprintf("!dcr not implemented for this architecture.\n");
            break;
    }

    return S_OK;

} // !dcr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\deadlock.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    deadlock.c

Abstract:

    WinDbg Extension Api

Author:

    Jordan Tigani (jtigani) 
    Silviu Calinoiu (silviuc)

Environment:

    User Mode

Revision History:

    5-30-00 File created (jtigani)

--*/
    
#include "precomp.h"
#pragma hdrstop

//
// This has to be in sync with the definition from
// ntos\verifier\vfdeadlock.c
//

#define VI_DEADLOCK_HASH_BINS 0x1F

#if 0
typedef enum _VI_DEADLOCK_RESOURCE_TYPE {
    ViDeadlockUnknown = 0,
    ViDeadlockMutex,
    ViDeadlockFastMutex,
    ViDeadlockFastMutexUnsafe,
    ViDeadlockSpinLock,
    ViDeadlockQueuedSpinLock,
    ViDeadlockTypeMaximum
} VI_DEADLOCK_RESOURCE_TYPE, *PVI_DEADLOCK_RESOURCE_TYPE;
#endif

PUCHAR ResourceTypes[] = 
{
    "Unknown",
    "Mutex",
    "Fast Mutex",
    "Fast Mutex Unsafe",
    "Spinlock",
    "Queued Spinlock",        
};

#define RESOURCE_TYPE_MAXIMUM 5

#define DEADLOCK_EXT_FLAG_DUMP_STACKS      1
#define DEADLOCK_EXT_FLAG_DUMP_NODES       2
#define DEADLOCK_EXT_FLAG_ANALYZE          4

extern
VOID
DumpSymbolicAddress(
    ULONG64 Address,
    PUCHAR  Buffer,
    BOOL    AlwaysShowHex
    );

#define MAX_DEADLOCK_PARTICIPANTS 32


#define VI_MAX_STACK_DEPTH 8
typedef struct _DEADLOCK_VECTOR 
{    
    ULONG64 Thread;
    ULONG64 Node;
    ULONG64 ResourceAddress;    
    ULONG64 StackAddress;
    ULONG64 ParentStackAddress;
    ULONG64 ThreadEntry;
    ULONG   Type;
    BOOLEAN TryAcquire;
} DEADLOCK_VECTOR, *PDEADLOCK_VECTOR;

extern 
ULONG64
ReadPvoid (
    ULONG64 Address
    );

extern
ULONG
ReadUlong(
    ULONG64 Address
    );


//
// Forward declarations for local functions
//

VOID
PrintGlobalStatistics (
    ULONG64 GlobalsAddress
    );
    
BOOLEAN
SearchForResource (
    ULONG64 GlobalsAddress,
    ULONG64 ResourceAddress
    );

BOOLEAN
SearchForThread (
    ULONG64 GlobalsAddress,
    ULONG64 ThreadAddress
    );

BOOLEAN
AnalyzeResource (
    ULONG64 Resource,
    BOOLEAN Verbose
    );

BOOLEAN
AnalyzeResources (
    ULONG64 GlobalsAddress
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////// Deadlocks
/////////////////////////////////////////////////////////////////////

//
// Defines copied from nt\base\ntos\verifier\vfdeadlock.c .
//

#define VI_DEADLOCK_ISSUE_SELF_DEADLOCK           0x1000
#define VI_DEADLOCK_ISSUE_DEADLOCK_DETECTED       0x1001
#define VI_DEADLOCK_ISSUE_UNINITIALIZED_RESOURCE  0x1002
#define VI_DEADLOCK_ISSUE_UNEXPECTED_RELEASE      0x1003
#define VI_DEADLOCK_ISSUE_UNEXPECTED_THREAD       0x1004
#define VI_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION 0x1005
#define VI_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES  0x1006
#define VI_DEADLOCK_ISSUE_UNACQUIRED_RESOURCE     0x1007



#define DUMP_FIELD(Name) dprintf ("%-20s %I64u \n", #Name, ReadField (Name))

DECLARE_API( deadlock )

/*++

Routine Description:

    Verifier deadlock detection module extension.

Arguments:

    arg - not used for now.

Return Value:

    None.

--*/

{
    ULONG64 GlobalsPointer;
    ULONG64 GlobalsAddress;
    ULONG64 InitializedAddress;
    ULONG64 EnabledAddress;    
    ULONG64 InstigatorAddress;
    ULONG64 ParticipantAddress;
    ULONG64 LastResourceAddress;
    ULONG64 RootAddress;
    ULONG64 CurrentResourceAddress;
    ULONG64 CurrentThread;
    ULONG64 ThreadForChain;
    ULONG64 CurrentStack;
    ULONG64 NextStack;
    ULONG64 SymbolOffset;

    ULONG StackTraceSize;
            
    ULONG Processor=0;
    ULONG ParticipantOffset;
    ULONG StackOffset;
    ULONG ParentStackOffset;
    ULONG InitializedValue;
    ULONG EnabledValue;
    ULONG NumberOfParticipants;
    ULONG NumberOfResources;
    ULONG NumberOfThreads;
    ULONG ThreadNumber;
    ULONG ResourceNumber;
    ULONG ResourceType;
    ULONG TryAcquireUsed;
    
    
    ULONG PtrSize;
    ULONG J, I;

    BOOLEAN DumpStacks = FALSE;
    BOOLEAN DumpNodes  = FALSE;
    BOOLEAN Analyze = FALSE;

    ULONG64 Flags;

    UCHAR SymbolName[512];

    HANDLE CurrentThreadHandle = NULL;

    DEADLOCK_VECTOR Participants[MAX_DEADLOCK_PARTICIPANTS+1];

    ULONG64 Issue[4];
    ULONG64 SearchAddress = 0;

    //
    // Check if help requested
    //

    if (strstr (args, "?")) {
        
        dprintf ("\n");
        dprintf ("!deadlock             Statistics and deadlock layout \n");
        dprintf ("!deadlock 3           Detailed deadlock layout \n");
        dprintf ("!deadlock ADDRESS     Search for ADDRESS among deadlock verifier data \n");
        dprintf ("\n");
        return S_OK;
    }

    Flags = GetExpression(args);

    if (Flags > 0x10000000) {
        
        SearchAddress = Flags;
    }
    else {

        if (Flags & DEADLOCK_EXT_FLAG_DUMP_STACKS) {
            DumpStacks = TRUE;
        }

        if (Flags & DEADLOCK_EXT_FLAG_DUMP_NODES) {
            DumpNodes = TRUE;
        }
    
        if (Flags & DEADLOCK_EXT_FLAG_ANALYZE) {
            Analyze = TRUE;
        }
    }

    GlobalsPointer = (ULONG64) GetExpression ("nt!ViDeadlockGlobals");
    EnabledAddress = (ULONG64) GetExpression ("nt!ViDeadlockDetectionEnabled");    

    if (GlobalsPointer == 0 || EnabledAddress == 0) {
        dprintf ("Error: incorrect symbols for kernel \n");
        return E_INVALIDARG;
    }

    GlobalsAddress = 0;
    ReadPointer (GlobalsPointer, &GlobalsAddress);
    EnabledValue = ReadUlong (EnabledAddress);

    if (GlobalsAddress == 0) {
        dprintf ("Deadlock detection not initialized \n");
        return E_INVALIDARG;
    }
    
    InitializedValue = 1;

    if (EnabledValue == 0) {
        dprintf ("Deadlock detection not enabled \n");
        return E_INVALIDARG;
    }

    //
    // Do a search if this is requested.
    //

    if (SearchAddress) {
        
        BOOLEAN FoundSomething = FALSE;

        dprintf ("Searching for %p ... \n", SearchAddress);

        if (FoundSomething == FALSE) {
            FoundSomething = SearchForResource (GlobalsAddress, SearchAddress);
        }
        
        if (FoundSomething == FALSE) {
            FoundSomething = SearchForThread (GlobalsAddress, SearchAddress);
        }

        return S_OK;
    }

    //
    // Analyze if this is needed.
    //

    if (Analyze) {
        
        AnalyzeResources (GlobalsAddress);

        return S_OK;
    }

    //
    // Get the ViDeadlockIssue[0..3] vector.
    //

    {
        ULONG ValueSize;
        ULONG64 IssueAddress;
        ULONG I;

        ValueSize = DBG_PTR_SIZE;

        IssueAddress = GetExpression ("nt!ViDeadlockIssue");

        for (I = 0; I < 4; I += 1) {

            ReadPointer (IssueAddress + I * ValueSize, &(Issue[I]));
        }

        if (Issue[0] == 0) {

            dprintf ("\n");
            PrintGlobalStatistics (GlobalsAddress);
            dprintf ("\nNo deadlock verifier issues. \n");
            
            return S_OK;
        }
        else {
            
            if (ValueSize == 4) {
                dprintf ("issue: %08X %08X %08X %08X \n", 
                         Issue[0], Issue[1], Issue[2], Issue[3]);
            }
            else {
                dprintf ("issue: %I64X %I64X %I64X %I64X \n", 
                         Issue[0], Issue[1], Issue[2], Issue[3]);
            }
        }

        switch (Issue[0]) {
        
        case VI_DEADLOCK_ISSUE_SELF_DEADLOCK:
            dprintf ("Resource %I64X is acquired recursively. \n", Issue[1]);
            return S_OK;
        
        case VI_DEADLOCK_ISSUE_DEADLOCK_DETECTED:
            break;
        
        case VI_DEADLOCK_ISSUE_UNINITIALIZED_RESOURCE:
            dprintf ("Resource %I64X is used before being initialized. \n", Issue[1]);
            return S_OK;
        
        case VI_DEADLOCK_ISSUE_UNEXPECTED_RELEASE:
            dprintf ("Resource %I64X is released out of order. \n", Issue[2]);
            return S_OK;
        
        case VI_DEADLOCK_ISSUE_UNEXPECTED_THREAD:
            dprintf ("Current thread is releasing resource %I64X which was acquired in thread %I64X. \n", 
                     Issue[1], Issue[2]);
            return S_OK;
        
        case VI_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION:
            dprintf ("Resource %I64X has already been initialized. \n", Issue[1]);
            return S_OK;
        
        case VI_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES:
            dprintf ("Deleting thread %I64X which still holds resource %I64X . \n",
                     Issue[1], Issue[2]);
            return S_OK;
        
        case VI_DEADLOCK_ISSUE_UNACQUIRED_RESOURCE:
            dprintf ("Releasing resource %I64X that was never acquired. \n", Issue[1]);
            return S_OK;
        
        default:
            dprintf ("Unrecognized issue code %I64X ! \n", Issue[0]);
            return S_OK;
        }
    }

    //
    // Figure out how big a pointer is
    //

    PtrSize = DBG_PTR_SIZE;

    if (PtrSize == 0) {
        dprintf ("Cannot get size of PVOID \n");
        return E_INVALIDARG;
    }

    GetCurrentProcessor(Client, &Processor, &CurrentThreadHandle);
    GetCurrentThreadAddr( Processor, &CurrentThread );

    //
    // Dump the globals structure
    //

    InitTypeRead (GlobalsAddress, nt!_VI_DEADLOCK_GLOBALS);

    //
    // Find out the address of the resource that causes the deadlock
    //         
    
    InstigatorAddress = ReadField(Instigator);
    
    NumberOfParticipants = (ULONG) ReadField(NumberOfParticipants);

    if (NumberOfParticipants > MAX_DEADLOCK_PARTICIPANTS) {
        dprintf("\nCannot have %x participants in a deadlock!\n",NumberOfParticipants);
        return E_INVALIDARG;

    }

    if (0 == NumberOfParticipants) {
        dprintf("\nNo deadlock detected\n");

        return S_OK;
    }

    GetFieldOffset("nt!_VI_DEADLOCK_GLOBALS",
                   "Participant", 
                   &ParticipantOffset
                   );
    ParticipantAddress = GlobalsAddress + ParticipantOffset;

    //
    // Read the vector of VI_DEADLOCK_NODEs that
    // participate in the deadlock. 
    //
    //    

    for (J = 0; J < NumberOfParticipants; J++) {    
        Participants[J].Node = ReadPvoid(ParticipantAddress + J * PtrSize);
        // dprintf("Participant %c: %08x\n", 'A' + J, Participants[J].Node);
    }
    
    //
    // Gather the information we'll need to print out exact
    // context for the deadlock.
    //  
    GetFieldOffset("nt!_VI_DEADLOCK_NODE",
                   "StackTrace",
                   &StackOffset
                   );
    GetFieldOffset("nt!_VI_DEADLOCK_NODE",
                   "ParentStackTrace",
                   &ParentStackOffset
                   );
          
    
    //
    // The stack trace size is 1 on free builds and 6 (or bigger) on
    // checked builds. We assume that the ParentStackTrace field comes
    // immediately after StackTrace field in the NODE structure.
    //
    
    StackTraceSize = (ParentStackOffset - StackOffset) / PtrSize;

    for (J = 0; J < NumberOfParticipants; J++) {
        
        InitTypeRead (Participants[J].Node, nt!_VI_DEADLOCK_NODE);
     

        RootAddress  = ReadField(Root);        

        GetFieldValue(RootAddress, 
                      "nt!_VI_DEADLOCK_RESOURCE",
                      "ResourceAddress"                      , 
                      Participants[J].ResourceAddress
                      );

        GetFieldValue(RootAddress, 
                      "nt!_VI_DEADLOCK_RESOURCE",
                      "Type", 
                      Participants[J].Type
                      );


        if (Participants[J].Type > RESOURCE_TYPE_MAXIMUM) {
            Participants[J].Type = 0;
        }        

        Participants[J].ThreadEntry         = ReadField(ThreadEntry);
        Participants[J].StackAddress        = Participants[J].Node + StackOffset;                                          
        Participants[J].ParentStackAddress  = Participants[J].Node + 
                                              ParentStackOffset;
        Participants[J].TryAcquire          = (BOOLEAN) ReadField(OnlyTryAcquireUsed);

        
        GetFieldValue(Participants[J].ThreadEntry, 
                     "nt!_VI_DEADLOCK_THREAD",
                      "Thread", 
                      Participants[J].Thread
                      );        


    }

    if (Participants[0].ResourceAddress != InstigatorAddress) {
        dprintf("\nDeadlock Improperly formed participant list\n");
        return E_INVALIDARG;
    }

    //
    // The last participant is the Instigator of the deadlock
    //    
    Participants[NumberOfParticipants].Thread = CurrentThread;
    Participants[NumberOfParticipants].Node = 0;
    Participants[NumberOfParticipants].ResourceAddress = InstigatorAddress;
    Participants[NumberOfParticipants].StackAddress  = 0;
    Participants[NumberOfParticipants].ParentStackAddress = 
        Participants[NumberOfParticipants-1].StackAddress;    
    Participants[NumberOfParticipants].Type = 
        Participants[0].Type;
    Participants[NumberOfParticipants].TryAcquire = FALSE; // can't cause a deadlock with try
    Participants[NumberOfParticipants].ThreadEntry = 0;
    
    //
    // At this point we have all of the raw data we need.
    // We have to munge it up a bit so that we have the most
    // recent data. For instance, take the simple deadlock AB-BA.
    // The stack for A in the AB context may be wrong because
    // another thread may have come and taken A at a different point.
    // This is why we have the parent stack address.
    //
    // So the rules we have to adhere to are as follows:
    // Where we have a chain, (eg ABC meaning A taken then B then C),
    // the thread used will always be the thread for the last resource taken,
    // and the stacks used will be the the childs parent stack where
    // applicable.
    //
    // For example, if C was taken by thread 1, A & B would be munged
    // to use thread 1. Since in order to get to C, A and B must have
    // been taken by thread 1 at some point, even if the thread they
    // have saved now is a different one. C would use its own stack,
    // B would use C's parent stack, since that was the stack that
    // B had been acquired with when C was taken, and A will use
    // B's parent stack.
    //
    // We can identify the start of a chain when the same resource
    // is on the participant list twice in a row.
    //

    LastResourceAddress = InstigatorAddress;
    
    NumberOfResources   = 0;
    NumberOfThreads     = 0;

    for (J = 0; J <= NumberOfParticipants; J++) {
        I = NumberOfParticipants - J;

        CurrentResourceAddress = Participants[I].ResourceAddress;

        if (CurrentResourceAddress == LastResourceAddress) {

            //
            // This is the beginning of a chain. Use the current
            // stack and the current thread, and set the chain
            // thread to ours
            //

            ThreadForChain = Participants[I].Thread;
            CurrentStack   = Participants[I].StackAddress;
            NumberOfThreads++;
        } else {
            //
            // This is a resource we haven't seen before
            //
            NumberOfResources++;
        }

        NextStack = Participants[I].ParentStackAddress;


        Participants[I].StackAddress = CurrentStack;
        Participants[I].Thread       = ThreadForChain;        
        //
        // Parent stack isn't used any more -- nullify it.
        //
        Participants[I].ParentStackAddress = 0;

        CurrentStack = NextStack;
        LastResourceAddress = CurrentResourceAddress;
    }        

    //
    // Now that we've munged the vectors, we can go ahead and print out the 
    // deadlock information.
    //
    
    dprintf("\nDeadlock detected (%d resources in %d threads):\n\n",NumberOfResources, NumberOfThreads);

    if (! DumpStacks ) 
    {
        //
        // Print out the 'short' form 
        // Example:
        //
        // !dealock detected:
        // Thread 1: A B
        // Thread 2: B C
        // Thread 3: C A
        //
        // Thread 1 = <address>
        // Thread 2 = <address>
        // Thread 3 = <address>
        //
        // Lock A = <address> (spinlock)
        // Lock B = <address> (mutex)
        // Lock C = <address> (spinlock)
        //
        
        ThreadNumber = 0;    
        ResourceNumber = 0;
        J=0;
        
        //
        // Dump out the deadlock topology
        //
        
        while (J <= NumberOfParticipants)
        {
            ThreadForChain = Participants[J].Thread;
            dprintf("Thread %d: ",ThreadNumber);
            
            do {            
                if (J == NumberOfParticipants) {
                    ResourceNumber = 0;
                }
                
                dprintf("%c ",
                    'A' + ResourceNumber                    
                    );                                                                                                 
                J++;
                ResourceNumber++;
                
            } while( J <= NumberOfParticipants && Participants[J].ResourceAddress != Participants[J-1].ResourceAddress);
            
            dprintf("\n");
            
            ThreadNumber++;
            ResourceNumber--;
        }
        dprintf("\nWhere:\n");
        
        //
        // Dump out the thread addresses
        //
        
        ThreadNumber = 0;    
        ResourceNumber = 0;
        J=0;
        while (J <= NumberOfParticipants) {

            ThreadForChain = Participants[J].Thread;
            dprintf("Thread %d = %08x\n",ThreadNumber, ThreadForChain);
            
            do {            
                
                if (J == NumberOfParticipants) {
                    ResourceNumber = 0;
                }
                J++;
                ResourceNumber++;
                
            } while( J <= NumberOfParticipants && Participants[J].ResourceAddress != Participants[J-1].ResourceAddress);
                                    
            ThreadNumber++;
            ResourceNumber--;
        }
        
        //
        // Dump out the resource addresses
        //

        ThreadNumber = 0;    
        ResourceNumber = 0;
        J=0;
#if 1
        while (J < NumberOfParticipants)
        {                                 
            while(J < NumberOfParticipants && Participants[J].ResourceAddress != Participants[J+1].ResourceAddress) {
                
                if (Participants[J].ResourceAddress != Participants[J+1].ResourceAddress) {
                    CHAR Buffer[0xFF];
                    ULONG64 Displacement = 0;
                    GetSymbol(Participants[J].ResourceAddress, Buffer, &Displacement);

                    dprintf("Lock %c =   %s", 'A' + ResourceNumber, Buffer );
                    if (Displacement != 0) {                    
                        dprintf("%s%x", (Displacement < 0xFFF)?"+0x":"",Displacement);
                    }                
                    dprintf(" Type '%s' ",ResourceTypes[Participants[J].Type]);                    
                    dprintf("\n");
                                        
                    ResourceNumber++;
                }
                J++;                                
            }                                    
            J++;            
        }
        
#endif        
    } else {
        
        //
        // Dump out verbose deadlock information -- with stacks
        // Here is an exapmle:
        //
        //        Deadlock detected (3 resources in 3 threads):
        //
        //Thread 0 (829785B0) took locks in the following order:
        //
        //    Lock A (Spinlock) @ bfc7c254
        //    Node:    82887F88
        //    Stack:   NDIS!ndisNotifyMiniports+0xC1
        //             NDIS!ndisPowerStateCallback+0x6E
        //             ntkrnlmp!ExNotifyCallback+0x72
        //             ntkrnlmp!PopDispatchCallback+0x13
        //             ntkrnlmp!PopPolicyWorkerNotify+0x8F
        //             ntkrnlmp!PopPolicyWorkerThread+0x10F
        //             ntkrnlmp!ExpWorkerThread+0x294
        //             ntkrnlmp!PspSystemThreadStartup+0x4B
        //
        //    Lock B (Spinlock) @ 8283b87c
        //    Node:    82879148
        //    Stack:   NDIS!ndisDereferenceRef+0x10F
        //             NDIS!ndisDereferenceDriver+0x3A
        //             NDIS!ndisNotifyMiniports+0xD1
        //             NDIS!ndisPowerStateCallback+0x6E
        //             ntkrnlmp!ExNotifyCallback+0x72
        //             ntkrnlmp!PopDispatchCallback+0x13
        //             ntkrnlmp!PopPolicyWorkerNotify+0x8F
        //             ntkrnlmp!PopPolicyWorkerThread+0x10F
        //
        //Thread 1 (829785B0) took locks in the following order:
        //
        //    Lock B (Spinlock) @ 8283b87c
        //    Node:    82879008
        //    Stack:   NDIS!ndisReferenceNextUnprocessedMiniport+0x3E
        //             NDIS!ndisNotifyMiniports+0xB3
        //             NDIS!ndisPowerStateCallback+0x6E
        //             ntkrnlmp!ExNotifyCallback+0x72
        //             ntkrnlmp!PopDispatchCallback+0x13
        //             ntkrnlmp!PopPolicyWorkerNotify+0x8F
        //             ntkrnlmp!PopPolicyWorkerThread+0x10F
        //             ntkrnlmp!ExpWorkerThread+0x294
        //
        //    Lock C (Spinlock) @ 82862b48
        //    Node:    8288D008
        //    Stack:   NDIS!ndisReferenceRef+0x10F
        //             NDIS!ndisReferenceMiniport+0x4A
        //             NDIS!ndisReferenceNextUnprocessedMiniport+0x70
        //             NDIS!ndisNotifyMiniports+0xB3
        //             NDIS!ndisPowerStateCallback+0x6E
        //             ntkrnlmp!ExNotifyCallback+0x72
        //             ntkrnlmp!PopDispatchCallback+0x13
        //             ntkrnlmp!PopPolicyWorkerNotify+0x8F
        //
        //Thread 2 (82978310) took locks in the following order:
        //
        //    Lock C (Spinlock) @ 82862b48
        //    Node:    82904708
        //    Stack:   NDIS!ndisPnPRemoveDevice+0x20B
        //             NDIS!ndisPnPDispatch+0x319
        //             ntkrnlmp!IopfCallDriver+0x62
        //             ntkrnlmp!IovCallDriver+0x9D
        //             ntkrnlmp!IopSynchronousCall+0xFA
        //             ntkrnlmp!IopRemoveDevice+0x11E
        //           ntkrnlmp!IopDeleteLockedDeviceNode+0x3AF
        //            ntkrnlmp!IopDeleteLockedDeviceNodes+0xF5
        //
        //    Lock A (Spinlock) @ bfc7c254
        //  Stack:   << Current stack >>
        //
        
        
        ThreadNumber = 0;
        ResourceNumber = 0;
        J=0;
        
        while (J <= NumberOfParticipants) {

            ThreadForChain = Participants[J].Thread;
            dprintf("Thread %d: %08X",ThreadNumber, ThreadForChain);
            if (DumpNodes && Participants[J].ThreadEntry) {
                    dprintf(" (ThreadEntry = %X)\n   ", (ULONG) Participants[J].ThreadEntry);
            }
            dprintf(" took locks in the following order:\n\n");
            
            
            //
            // This is a do .. while so that we can never get an infinite loop.
            //
            do {
                UINT64 CurrentStackAddress;
                UINT64 StackFrame;
                CHAR Buffer[0xFF];
                ULONG64 Displacement = 0;

                
                if (J == NumberOfParticipants) {
                    ResourceNumber = 0;
                }
                
                GetSymbol(Participants[J].ResourceAddress, Buffer, &Displacement);
                                                
                dprintf("    Lock %c -- %s", 'A' + ResourceNumber, Buffer );                
                if (Displacement != 0) {
                    dprintf("%s%x", (Displacement < 0xFFF)?"+0x":"",Displacement);
                }                
                dprintf(" (%s)\n",ResourceTypes[Participants[J].Type]);
                
                
                if (DumpNodes && Participants[J].Node)
                    dprintf("    Node:    %X\n", (ULONG) Participants[J].Node);
                
                dprintf("    Stack:   ");
                
                CurrentStackAddress = Participants[J].StackAddress;
                
                if (CurrentStackAddress == 0) {
                    
                    dprintf ("<< Current stack >>\n");
                    
                } else  {
                    
                    for (I = 0; I < StackTraceSize; I++) {
                        
                        SymbolName[0] = '\0';
                        StackFrame = ReadPvoid(CurrentStackAddress);
                        if (0 == StackFrame)
                            break;
                        
                        GetSymbol(StackFrame, SymbolName, &SymbolOffset);
                        
                        if (I) {
                            dprintf("             ");
                        }
                        
                        if ((LONG64) SymbolOffset > 0 ) {
                            dprintf ("%s+0x%X\n", 
                                SymbolName, (ULONG) SymbolOffset);
                        } else {
                            dprintf ("%X\n", (ULONG) StackFrame);
                        }                    
                        
                        CurrentStackAddress += PtrSize;
                    }
                }
                
                dprintf("\n");
                J++;
                ResourceNumber++;
                
            } while( J <= NumberOfParticipants && Participants[J].ResourceAddress != Participants[J-1].ResourceAddress);
            
            ThreadNumber++;
            ResourceNumber--;
        }
    }
    
    return S_OK;
}


VOID
PrintGlobalStatistics (
    ULONG64 GlobalsAddress
    )
{
    ULONG AllocationFailures;
    ULONG64 MemoryUsed;
    ULONG NodesTrimmed;
    ULONG MaxNodesSearched;
    ULONG SequenceNumber;

    //
    // Dump the globals structure
    //

    InitTypeRead (GlobalsAddress, nt!_VI_DEADLOCK_GLOBALS);

    //
    // Print some simple statistics
    //

    dprintf ("Resources: %u\n", (ULONG) ReadField (Resources[0]));
    dprintf ("Nodes:     %u\n", (ULONG) ReadField (Nodes[0]));
    dprintf ("Threads:   %u\n", (ULONG) ReadField (Threads[0]));
    dprintf ("\n");

    MemoryUsed = ReadField (BytesAllocated);

    if (MemoryUsed > 1024 * 1024) {
        dprintf ("%I64u bytes of kernel pool used.\n", MemoryUsed);
    }

    AllocationFailures = (ULONG) ReadField (AllocationFailures);

    if (AllocationFailures > 0) {
        dprintf ("Allocation failures encountered (%u).\n", AllocationFailures);
    }

    NodesTrimmed = (ULONG) ReadField (NodesTrimmedBasedOnAge);
    dprintf ("Nodes trimmed based on age %u.\n", NodesTrimmed);
    NodesTrimmed = (ULONG) ReadField (NodesTrimmedBasedOnCount);
    dprintf ("Nodes trimmed based on count %u.\n", NodesTrimmed);

    dprintf ("Analyze calls %u.\n", (ULONG) ReadField (SequenceNumber));
    dprintf ("Maximum nodes searched %u.\n", (ULONG) ReadField (MaxNodesSearched));
}


BOOLEAN
SearchForResource (
    ULONG64 GlobalsAddress,
    ULONG64 ResourceAddress
    )
{
    ULONG I;
    ULONG64 Bucket;
    ULONG64 SizeOfBucket;
    BOOLEAN ResourceFound = FALSE;
    ULONG64 SizeOfResource;
    ULONG FlinkOffset = 0;
    ULONG64 Current;
    ULONG64 CurrentResource;
    ULONG Magic;

    SizeOfBucket = GetTypeSize("LIST_ENTRY");
    SizeOfResource = GetTypeSize("nt!_VI_DEADLOCK_RESOURCE");

    GetFieldOffset("nt!_VI_DEADLOCK_RESOURCE",
                   "HashChainList", 
                   &FlinkOffset);

    if (SizeOfBucket == 0 || SizeOfResource == 0 || FlinkOffset == 0) {
        dprintf ("Error: cannot get size for verifier types. \n");
        return FALSE;
    }

    InitTypeRead (GlobalsAddress, nt!_VI_DEADLOCK_GLOBALS);

    Bucket = ReadField (ResourceDatabase);

    if (Bucket == 0) {
        dprintf ("Error: cannot get resource database address. \n");
        return FALSE;
    }

    for (I = 0; I < VI_DEADLOCK_HASH_BINS; I += 1) {
        
        // traverse it ...

        Current = ReadPvoid(Bucket);

        while (Current != Bucket) {

            InitTypeRead (Current - FlinkOffset, nt!_VI_DEADLOCK_RESOURCE);
            CurrentResource = ReadField (ResourceAddress);

            if (CurrentResource == ResourceAddress || 
                ResourceAddress == Current - FlinkOffset) {
                
                CurrentResource = Current - FlinkOffset;
                ResourceFound = TRUE;
                break;
            }

            Current = ReadPvoid(Current);

            if (CheckControlC()) {
                dprintf ("\nSearch interrupted ... \n");
                return TRUE;
            }
        }

        if (ResourceFound) {
            break;
        }

        dprintf (".");

        Bucket += SizeOfBucket;

    }

    dprintf ("\n");

    if (ResourceFound == FALSE) {

        dprintf ("No resource correspoding to %p has been found. \n", 
                 ResourceAddress);
    }
    else {

        dprintf ("Found a deadlock verifier resource descriptor @ %p \n", 
                CurrentResource);

    }

    return ResourceFound;
}


BOOLEAN
SearchForThread (
    ULONG64 GlobalsAddress,
    ULONG64 ThreadAddress
    )
{
    ULONG I;
    ULONG64 Bucket;
    ULONG64 SizeOfBucket;
    BOOLEAN ThreadFound = FALSE;
    ULONG64 SizeOfThread;
    ULONG FlinkOffset = 0;
    ULONG64 Current;
    ULONG64 CurrentThread;

    SizeOfBucket = GetTypeSize("LIST_ENTRY");
    SizeOfThread = GetTypeSize("nt!_VI_DEADLOCK_THREAD");

    GetFieldOffset("nt!_VI_DEADLOCK_THREAD",
                   "ListEntry", 
                   &FlinkOffset);

    if (SizeOfBucket == 0 || SizeOfThread == 0 || FlinkOffset == 0) {
        dprintf ("Error: cannot get size for verifier types. \n");
        return FALSE;
    }

    InitTypeRead (GlobalsAddress, nt!_VI_DEADLOCK_GLOBALS);

    Bucket = ReadField (ThreadDatabase);

    if (Bucket == 0) {
        dprintf ("Error: cannot get thread database address. \n");
        return FALSE;
    }

    for (I = 0; I < VI_DEADLOCK_HASH_BINS; I += 1) {
        
        // traverse it ...

        Current = ReadPvoid(Bucket);

        while (Current != Bucket) {

            InitTypeRead (Current - FlinkOffset, nt!_VI_DEADLOCK_THREAD);
            CurrentThread = ReadField (ThreadAddress);

            if (CurrentThread == ThreadAddress || 
                ThreadAddress == Current - FlinkOffset) {
                
                CurrentThread = Current - FlinkOffset;
                ThreadFound = TRUE;
                break;
            }

            Current = ReadPvoid(Current);
            
            if (CheckControlC()) {
                dprintf ("\nSearch interrupted ... \n");
                return TRUE;
            }
        }

        if (ThreadFound) {
            break;
        }
        
        dprintf (".");

        Bucket += SizeOfBucket;

    }

    dprintf ("\n");

    if (ThreadFound == FALSE) {

        dprintf ("No thread correspoding to %p has been found. \n", 
                 ThreadAddress);
    }
    else {

        dprintf ("Found a deadlock verifier thread descriptor @ %p \n", 
                CurrentThread);

    }

    return ThreadFound;
}


VOID
DumpResourceStructure (
    )
{

}


ULONG
GetNodeLevel (
    ULONG64 Node
    )
{
    ULONG Level = 0;

    while (Node != 0) {
        
        Level += 1;

        if (Level > 12) {
            dprintf ("Level > 12 !!! \n");
            break;
        }

        InitTypeRead (Node, nt!_VI_DEADLOCK_NODE);
        Node = ReadField (Parent);
    }

    return Level;
}

BOOLEAN
AnalyzeResource (
    ULONG64 Resource,
    BOOLEAN Verbose
    )
{
    ULONG64 Start;
    ULONG64 Current;
    ULONG64 Node;
    ULONG64 Parent;
    ULONG FlinkOffset;
    ULONG RootsCount = 0;
    ULONG NodesCount = 0;
    ULONG Levels[8];
    ULONG ResourceFlinkOffset;
    ULONG I;
    ULONG Level;
    ULONG NodeCounter = 0;

    ZeroMemory (Levels, sizeof Levels);

    GetFieldOffset("nt!_VI_DEADLOCK_NODE",
                   "ResourceList", 
                   &FlinkOffset);

    GetFieldOffset("nt!_VI_DEADLOCK_RESOURCE",
                   "ResourceList", 
                   &ResourceFlinkOffset);

    InitTypeRead (Resource, nt!_VI_DEADLOCK_RESOURCE);

    if (! Verbose) {
        
        if (ReadField(NodeCount) < 4) {
            return TRUE;
        }

        dprintf ("Resource (%p) : %I64u %I64u %I64u ", 
                 Resource,
                 ReadField(Type), 
                 ReadField(NodeCount), 
                 ReadField(RecursionCount));
    }
    
    Start = Resource + ResourceFlinkOffset;
    Current = ReadPvoid (Start);

    while (Start != Current) {
        
        Node = Current - FlinkOffset;

        Level = (GetNodeLevel(Node) - 1) % 8;
        Levels[Level] += 1;

        NodesCount += 1;

        if (NodesCount && NodesCount % 1000 == 0) {
            dprintf (".");
        }

        Current = ReadPvoid (Current);

        if (CheckControlC()) {
            return FALSE;
        }
    }

    dprintf ("[");
    for (I = 0; I < 8; I += 1) {
        dprintf ("%u ", Levels[I]);
    }
    dprintf ("]\n");
    
    return TRUE;
}

BOOLEAN
AnalyzeResources (
    ULONG64 GlobalsAddress
    )
/*++

    This routine analyzes all resource to make sure we do not have
    zombie nodes laying around.

--*/
{
    ULONG I;
    ULONG64 Bucket;
    ULONG64 SizeOfBucket;
    ULONG64 SizeOfResource;
    ULONG FlinkOffset = 0;
    ULONG64 Current;
    ULONG64 CurrentResource;
    ULONG Magic;
    BOOLEAN Finished;
    ULONG ResourceCount = 0;

    dprintf ("Analyzing resources (%p) ... \n", GlobalsAddress);

    SizeOfBucket = GetTypeSize("LIST_ENTRY");
    SizeOfResource = GetTypeSize("nt!_VI_DEADLOCK_RESOURCE");

    GetFieldOffset("nt!_VI_DEADLOCK_RESOURCE",
                   "HashChainList", 
                   &FlinkOffset);

    if (SizeOfBucket == 0 || SizeOfResource == 0 || FlinkOffset == 0) {
        dprintf ("Error: cannot get size for verifier types. \n");
        return FALSE;
    }

    InitTypeRead (GlobalsAddress, nt!_VI_DEADLOCK_GLOBALS);

    Bucket = ReadField (ResourceDatabase);

    if (Bucket == 0) {
        dprintf ("Error: cannot get resource database address. \n");
        return FALSE;
    }

    for (I = 0; I < VI_DEADLOCK_HASH_BINS; I += 1) {
        
        // traverse it ...

        Current = ReadPvoid(Bucket);

        while (Current != Bucket) {

            Finished = AnalyzeResource (Current - FlinkOffset, FALSE);
            ResourceCount += 1;

            if (ResourceCount % 256 == 0) {
                dprintf (".\n");
            }

            Current = ReadPvoid(Current);

            if (CheckControlC() || !Finished) {
                dprintf ("\nSearch interrupted ... \n");
                return TRUE;
            }
        }

        Bucket += SizeOfBucket;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\cc.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Cc.c

Abstract:

    WinDbg Extension Api for examining cache manager data structures

Author:

    Keith Kaplan [KeithKa]    17-Apr-97

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"

#undef CREATE_NEW
#undef OPEN_EXISTING

#undef FlagOn
#undef WordAlign
#undef LongAlign
#undef QuadAlign

#pragma hdrstop

//
//  DUMP_WITH_OFFSET -- for dumping values contained in structures.
//

#define DUMP_WITH_OFFSET(type, ptr, element, label)     \
        dprintf( "\n(%03x) %08x %s ",                   \
        FIELD_OFFSET(type, element),                    \
        ptr.element,                                    \
        label )

//
//  DUMP_LL_W_OFFSET -- for dumping longlongs contained in structures.
//

#define DUMP_LL_W_OFFSET(type, ptr, element, label)     \
        dprintf( "\n(%03x) %I64x %s ",                  \
        FIELD_OFFSET(type, element),                    \
        ptr.element,                                    \
        label )

//
//  DUMP_EMBW_OFFSET -- for dumping addresses of values embedded in structures.
//

#define DUMP_EMBW_OFFSET(type, ptr, element, label)     \
        dprintf( "\n(%03x) %08x %s ",                   \
        FIELD_OFFSET(type, element),                    \
        ptr + FIELD_OFFSET(type, element),              \
        label )

#define RM( Addr, Obj, pObj, Type, Result, label )                              \
    (pObj) = (Type) (Addr);                                                     \
    if ( !ReadMemory( (DWORD) (pObj), &(Obj), sizeof( Obj ), &(Result)) ) {     \
        if (label) {                                                            \
            dprintf( "Unable to read memory at %p (%s)\n", (pObj), (label) );\
        } else {                                                                \
            dprintf( "Unable to read memory at %p\n", (pObj) );              \
        }                                                                       \
        return;                                                                 \
    }

//
// The help strings printed out
//

static LPSTR Extensions[] = {
    "Cache Manager Debugger Extensions:\n",
    "bcb        [addr]               Dump Buffer Control Block",
    "scm        [addr]               Dump Shared Cache Map",
    "finddata   [FileObject Offset]  Find cached data at given offset in file object",
    "defwrites                       Dump deferred write queue",
    0
};

typedef PVOID (*STRUCT_DUMP_ROUTINE)(
    IN ULONG64 Address,
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    );


VOID
DumpBcb (
    IN ULONG64 Address,
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    );

VOID
DumpPcm (
    IN ULONG64 Address,
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    );

VOID
DumpScm (
    IN ULONG64 Address,
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    );


typedef struct {
    CSHORT TypeCode;
    char *Text;
} MY_NODE_TYPE;


static MY_NODE_TYPE NodeTypeCodes[] = {
    {   CACHE_NTC_SHARED_CACHE_MAP,  "Shared Cache Map" },
    {   CACHE_NTC_PRIVATE_CACHE_MAP, "Private Cache Map" },
    {   CACHE_NTC_BCB,               "Bcb" },
    {   CACHE_NTC_DEFERRED_WRITE,    "Deferred Write" },
    {   CACHE_NTC_MBCB,              "Mbcb" },
    {   CACHE_NTC_OBCB,              "Obcb" },
    {   CACHE_NTC_MBCB_GRANDE,       "Mcb Grande" },
    {   0,                           "Unknown" }
};


static const char *
TypeCodeGuess (
    IN CSHORT TypeCode
    )

/*++

Routine Description:

    Guess at a structure's type code

Arguments:

    TypeCode - Type code from the data structure

Return Value:

    None

--*/

{
    int i = 0;

    while (NodeTypeCodes[i].TypeCode != 0 &&
           NodeTypeCodes[i].TypeCode != TypeCode) {

        i++;

    }

    return NodeTypeCodes[i].Text;
}


VOID
DumpBcb (
    IN ULONG64 Address,
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    )

/*++

Routine Description:

    Dump a specific bcb.

Arguments:

    Address - Gives the address of the bcb to dump

Return Value:

    None

--*/

{
    ULONG Result, NodeTypeCode;

    UNREFERENCED_PARAMETER( Options );
    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );

    dprintf( "\n  Bcb: %08p", Address );

    if (GetFieldValue(Address, "BCB", "NodeTypeCode", NodeTypeCode) ) {
        dprintf("Unable to read BCB at %p.\n", Address);
        return;
    }
    //
    //  Type of a bcb must be CACHE_NTC_BCB.
    //

    if (NodeTypeCode != CACHE_NTC_BCB) {

        dprintf( "\nBCB signature does not match, type code is %s",
                 TypeCodeGuess((CSHORT) NodeTypeCode ));
        return;
    } else {
        dprintf("Use 'dt -n BCB %p' to dump BCB", Address);
        return;
    }
#if 0
    RM( Address, Bcb, pBcb, PBCB, Result, "Bcb" );

    //
    //  Before we get into too much trouble, make sure this looks like a bcb.
    //

    //
    //  Type of a bcb must be CACHE_NTC_BCB.
    //

    if (Bcb.NodeTypeCode != CACHE_NTC_BCB) {

        dprintf( "\nBCB signature does not match, type code is %s",
                 TypeCodeGuess( Bcb.NodeTypeCode ));
        return;
    }

    //
    //  Having established that this looks like a bcb, let's dump the
    //  interesting parts.
    //

    DUMP_WITH_OFFSET( BCB, Bcb,     PinCount,       "PinCount        " );
    DUMP_WITH_OFFSET( BCB, Bcb,     ByteLength,     "ByteLength      " );
    DUMP_LL_W_OFFSET( BCB, Bcb,     FileOffset,     "FileOffset      " );
    DUMP_LL_W_OFFSET( BCB, Bcb,     BeyondLastByte, "BeyondLastByte  " );
    DUMP_LL_W_OFFSET( BCB, Bcb,     OldestLsn,      "OldestLsn       " );
    DUMP_LL_W_OFFSET( BCB, Bcb,     NewestLsn,      "NewestLsn       " );
    DUMP_WITH_OFFSET( BCB, Bcb,     Vacb,           "Vacb            " );
    DUMP_EMBW_OFFSET( BCB, Address, Resource,       "Resource        " );
    DUMP_WITH_OFFSET( BCB, Bcb,     SharedCacheMap, "SharedCacheMap  " );
    DUMP_WITH_OFFSET( BCB, Bcb,     BaseAddress,    "BaseAddress     " );

    if (Bcb.Dirty) {

        dprintf( "\n Dirty" );

    } else {

        dprintf( "\n Not dirty" );
    }

    dprintf( "\n" );

    return;
#endif
}


VOID
DumpFindData (
    IN ULONG64 FileObjectAddress,
    IN LONG ffset,
    USHORT Processor,
    HANDLE hCurrentThread
    )

/*++

Routine Description:

    Dump the cache contents for a given file object at the given offset.

Arguments:

    FileObjectAddress - Gives the address of the file object to dump

    Offset - Gives the offset within the file to dump

Return Value:

    None

--*/

{
    ULONG Result;
    ULONG64 pFileObject;
    ULONG64 pScm;
    ULONG64 pSop;
    ULONG64 VacbAddr;          //  the address of the vacb
    ULONG64 *pVacbAddr;
    ULONG64 VacbAddrAddr;      //  the address of the address of the vacb
    ULONG64 pVacb;
    ULONG VacbNumber;
    ULONG OffsetWithinVacb;
    ULONG Level;
    ULONG Shift;
    ULONG OffsetForLevel;
    LONGLONG Offset = ffset;
    LONGLONG OriginalOffset = Offset;
    LONGLONG LevelMask;
    ULONG PtrSize = DBG_PTR_SIZE;
    ULONG Type, InVacbsOffset;
    ULONG64 SectionObjectPointer, SharedCacheMap, Vacbs, SectionSize_Quad;

    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );

    //
    //  Before we get into too much trouble, make sure this looks like a FileObject or SCM.
    //

    if (GetFieldValue(FileObjectAddress, "FILE_OBJECT", "Type", Type)) {
        dprintf("Unable to read FILE_OBJECT at %p\n", FileObjectAddress);
        return;
    }

    //
    //  Type must be IO_TYPE_FILE or a CACHE_NTC_SHARED_CACHE_MAP
    //

    if (Type != CACHE_NTC_SHARED_CACHE_MAP) {

        dprintf( "\n  FindData for FileObject %08p", FileObjectAddress );

        if (Type != IO_TYPE_FILE) {

            dprintf( "\nFILE_OBJECT type signature does not match, type code is %s",
                     TypeCodeGuess((USHORT) Type ));
            return;
        }

        GetFieldValue(FileObjectAddress, "FILE_OBJECT", 
                      "SectionObjectPointer", SectionObjectPointer);
        dprintf( "   Section Object Pointers: %08p", SectionObjectPointer );

        if (GetFieldValue(SectionObjectPointer, 
                          "SECTION_OBJECT_POINTERS",
                          "SharedCacheMap",
                          SharedCacheMap)) {
            dprintf("Unable to read SECTION_OBJECT_POINTERS at %p\n", SectionObjectPointer);
            return;
        }
        
        dprintf( "\n  Shared Cache Map: %08p", SharedCacheMap );

    } else {

        dprintf( "\n  FindData for SharedCacheMap %08p", FileObjectAddress );

        SharedCacheMap =  FileObjectAddress;
    }
    
    if (GetFieldValue(SharedCacheMap, 
                      "SHARED_CACHE_MAP",
                      "Vacbs",
                      Vacbs)) {
        dprintf("Unable to read SHARED_CACHE_MAP at %p\n", SharedCacheMap);
        return;
    }
    GetFieldValue(SharedCacheMap, "SHARED_CACHE_MAP",
                  "SectionSize.QuadPart", SectionSize_Quad);

    OffsetWithinVacb = (((ULONG) Offset) & (VACB_MAPPING_GRANULARITY - 1));
    GetFieldOffset("SHARED_CACHE_MAP", "InitialVacbs", &InVacbsOffset);

    dprintf( "         File Offset: %I64x ", Offset );

    if (Vacbs == (SharedCacheMap + InVacbsOffset)) {
        CHAR Buff[50];
        //
        //  Small file case -- we're using one of the Vacbs in the Shared Cache Map's
        //  embedded array.
        //

        VacbNumber = (ULONG) (Offset >> VACB_OFFSET_SHIFT);

        if (VacbNumber >= PREALLOCATED_VACBS) {

            dprintf( "\nInvalid VacbNumber for resident Vacb" );
            return;
        }

        sprintf(Buff, "InitialVacbs[%d]", VacbNumber);
        GetFieldValue(SharedCacheMap, "SHARED_CACHE_MAP",
                      Buff, VacbAddr);

        dprintf( "in VACB number %x", VacbNumber );

    } else if (SectionSize_Quad <= VACB_SIZE_OF_FIRST_LEVEL) {

        //
        //  Medium file case -- we're using a single level (linear) structure to
        //  store the Vacbs.
        //

        VacbNumber = (ULONG) (Offset >> VACB_OFFSET_SHIFT);
        VacbAddrAddr = Vacbs + (VacbNumber * PtrSize);
        if (!ReadPointer(VacbAddrAddr, &VacbAddr)) {
            dprintf("Unable to read at %p\n", VacbAddrAddr);
            return;
        }
//        RM( VacbAddrAddr, VacbAddr, pVacbAddr, PVOID, Result, "VACB array" );

        dprintf( "in VACB number %x", VacbNumber );

    } else {

        //
        //  Large file case -- multilevel Vacb storage.
        //

        Level = 0;
        Shift = VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT;
        
        //
        //  Loop to calculate how many levels we have and how much we have to
        //  shift to index into the first level.
        //

        do {

            Level += 1;
            Shift += VACB_LEVEL_SHIFT;

        } while (SectionSize_Quad > ((ULONG64)1 << Shift));
    
        //
        //  Now descend the tree to the bottom level to get the caller's Vacb.
        //



        Shift -= VACB_LEVEL_SHIFT;
//        dprintf( "Shift: 0x%x\n", Shift );

        OffsetForLevel = (ULONG) (Offset >> Shift);
        VacbAddrAddr = Vacbs + (OffsetForLevel * PtrSize);
        if (!ReadPointer(VacbAddrAddr, &VacbAddr)) {
            dprintf("Unable to read at %p\n", VacbAddrAddr);
            return;
        } 

        while ((VacbAddr != 0) && (Level != 0)) {

            Level -= 1;

            Offset &= ((LONGLONG)1 << Shift) - 1;

            Shift -= VACB_LEVEL_SHIFT;

//            dprintf( "Shift: 0x%x\n", Shift );

            OffsetForLevel = (ULONG) (Offset >> Shift);
            VacbAddrAddr = VacbAddr + (OffsetForLevel * PtrSize);
            if (!ReadPointer(VacbAddrAddr, &VacbAddr)) {
                dprintf("Unable to read at %p\n", VacbAddrAddr);
                return;
            } 
        }
    }

    if (VacbAddr != 0) {
        ULONG64 Base;

        dprintf( "\n  Vacb: %08p", VacbAddr );
        if (GetFieldValue(VacbAddr, "VACB", "BaseAddress", Base)) {
            dprintf("Unable to read VACB at %p.", VacbAddr);
            return;
        }
        dprintf( "\n  Your data is at: %08p", (Base + OffsetWithinVacb) );

    } else {

        dprintf( "\n  Data at offset %I64x not mapped", OriginalOffset );
    }

    dprintf( "\n" );

    return;
}


VOID
DumpPcm (
    IN ULONG64 Address,
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    )

/*++

Routine Description:

    Dump a specific private cache map.

Arguments:

    Address - Gives the address of the private cache map to dump

Return Value:

    None

--*/

{
    ULONG Result, NodeTypeCode;
    ULONG64 pPcm;

    UNREFERENCED_PARAMETER( Options );
    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );

    dprintf( "\n  Private cache map: %08p", Address );

    if (GetFieldValue(Address, "PRIVATE_CACHE_MAP",
                      "NodeTypeCode", NodeTypeCode)) {
        dprintf("Unable to read PRIVATE_CACHE_MAP at %p\n", Address);
        return;
    }

//    RM( Address, Pcm, pPcm, PPRIVATE_CACHE_MAP, Result, "PrivateCacheMap" );

    //
    //  Before we get into too much trouble, make sure this looks like a private cache map.
    //

    //
    //  Type of a private cache map must be CACHE_NTC_PRIVATE_CACHE_MAP.
    //

    if (NodeTypeCode != CACHE_NTC_PRIVATE_CACHE_MAP) {

        dprintf( "\nPrivate cache map signature does not match, type code is %s",
                 TypeCodeGuess( (USHORT) NodeTypeCode ));
        return;
    } else {
        dprintf("Use 'dt PRIVATE_CACHE_MAP %p' to dump PCM\n", Address);
        return;
    }
#if 0
    DUMP_WITH_OFFSET( PRIVATE_CACHE_MAP, Pcm,     FileObject,           "FileObject           " );

    DUMP_LL_W_OFFSET( PRIVATE_CACHE_MAP, Pcm,     FileOffset1,          "FileOffset1          " );
    DUMP_LL_W_OFFSET( PRIVATE_CACHE_MAP, Pcm,     BeyondLastByte1,      "BeyondLastByte1      " );
    DUMP_LL_W_OFFSET( PRIVATE_CACHE_MAP, Pcm,     FileOffset2,          "FileOffset2          " );
    DUMP_LL_W_OFFSET( PRIVATE_CACHE_MAP, Pcm,     BeyondLastByte2,      "BeyondLastByte2      " );

    DUMP_EMBW_OFFSET( PRIVATE_CACHE_MAP, Address, ReadAheadSpinLock,    "ReadAheadSpinLock    " );

    DUMP_WITH_OFFSET( PRIVATE_CACHE_MAP, Pcm,     ReadAheadMask,        "ReadAheadMask        " );

    dprintf( "\n ReadAhead -- " );

    if (Pcm.ReadAheadActive) {

        dprintf( "Active, " );

    } else {

        dprintf( "Not active, " );
    }

    if (Pcm.ReadAheadEnabled) {

        dprintf( "Enabled" );

    } else {

        dprintf( "Not enabled" );
    }

    dprintf( "\n" );
#endif
    return;
}


VOID
DumpScm (
    IN ULONG64 Address,
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    )

/*++

Routine Description:

    Dump a specific shared cache map.

Arguments:

    Address - Gives the address of the shared cache map to dump

Return Value:

    None

--*/

{
    ULONG Result, NodeTypeCode;
    ULONG64 pScm;

    UNREFERENCED_PARAMETER( Options );
    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );

    dprintf( "\n  Shared cache map: %08p", Address );
    
    if (GetFieldValue(Address, "SHARED_CACHE_MAP",
                      "NodeTypeCode", NodeTypeCode)) {
        dprintf("Unable to read SHARED_CACHE_MAP at %p\n", Address);
        return;
    }

//    RM( Address, Scm, pScm, PSHARED_CACHE_MAP, Result, "SharedCacheMap" );

    //
    //  Before we get into too much trouble, make sure this looks like a shared cache map.
    //

    //
    //  Type of a shared cache map must be CACHE_NTC_SHARED_CACHE_MAP.
    //

    if (NodeTypeCode != CACHE_NTC_SHARED_CACHE_MAP) {

        dprintf( "\nShared cache map signature does not match, type code is %s",
                 TypeCodeGuess( (USHORT) NodeTypeCode ));
        return;
    } else {
        dprintf("Use 'dt SHARED_CACHE_MAP %p' to dump PCM\n", Address);
        return;
    }
#if 0
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     OpenCount,           "OpenCount          " );

    DUMP_LL_W_OFFSET( SHARED_CACHE_MAP, Scm,     FileSize,            "FileSize           " );
    DUMP_LL_W_OFFSET( SHARED_CACHE_MAP, Scm,     SectionSize,         "SectionSize        " );
    DUMP_LL_W_OFFSET( SHARED_CACHE_MAP, Scm,     ValidDataLength,     "ValidDataLength    " );
    DUMP_LL_W_OFFSET( SHARED_CACHE_MAP, Scm,     ValidDataGoal,       "ValidDataGoal      " );

    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     FileObject,          "FileObject         " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     ActiveVacb,          "ActiveVacb         " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     ActivePage,          "ActivePage         " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     NeedToZero,          "NeedToZero         " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     NeedToZeroPage,      "NeedToZeroPage     " );

    DUMP_EMBW_OFFSET( SHARED_CACHE_MAP, Address, ActiveVacbSpinLock,  "ActiveVacbSpinLock " );

    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     VacbActiveCount,     "VacbActiveCount    " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     Mbcb,                "Mbcb               " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     DirtyPages,          "DirtyPages         " );

    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     Section,             "Section            " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     Status,              "Status             " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     CreateEvent,         "CreateEvent        " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     WaitOnActiveCount,   "WaitOnActiveCount  " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     PagesToWrite,        "PagesToWrite       " );

    DUMP_LL_W_OFFSET( SHARED_CACHE_MAP, Scm,     BeyondLastFlush,     "BeyondLastFlush    " );

    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     Callbacks,           "Callbacks          " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     LazyWriteContext,    "LazyWriteContext   " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     LogHandle,           "LogHandle          " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     FlushToLsnRoutine,   "FlushToLsnRoutine  " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     DirtyPageThreshold,  "DirtyPageThreshold " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     LazyWritePassCount,  "LazyWritePassCount " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     UninitializeEvent,   "UninitializeEvent  " );
    DUMP_WITH_OFFSET( SHARED_CACHE_MAP, Scm,     NeedToZeroVacb,      "NeedToZeroVacb     " );

    DUMP_EMBW_OFFSET( SHARED_CACHE_MAP, Address, BcbSpinLock,         "BcbSpinLock        " );
    DUMP_EMBW_OFFSET( SHARED_CACHE_MAP, Address, Event,               "Event              " );
    DUMP_EMBW_OFFSET( SHARED_CACHE_MAP, Address, PrivateCacheMap,     "PrivateCacheMap    " );

    dprintf( "\n" );
#endif
    return;
}



VOID
DumpDeferredWrites (
    IN ULONG64 Address,
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    )

/*++

Routine Description:

    Dump a specific shared cache map.

Arguments:

    Address - Gives the address of the shared cache map to dump

Return Value:

    None

--*/

{
    ULONG64 ListHeadAddr;
    ULONG Result;
    ULONG Temp;
    ULONG64 GlobalAddress;
    ULONG Value;
    ULONG64 CcTotalDirtyPages=0;
    ULONG64 CcDirtyPageThreshold=0;
    ULONG64 MmAvailablePages=0;
    ULONG64 MmThrottleTop=0;
    ULONG64 MmThrottleBottom=0;
    ULONG64 CcSingleDirtySourceDominant=0;
    ULONG64 CcDirtyPageHysteresisThreshold=0;
    ULONG64 Total;
    ULONG   Offset;
    ULONG64 Flink;

    BOOLEAN CheckLazyWriter = FALSE;
    BOOLEAN CheckMappedPageWriter = FALSE;
    BOOLEAN CheckModifiedPageWriter = FALSE;

    UNREFERENCED_PARAMETER( Options );
    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( Address );

    dprintf( "*** Cache Write Throttle Analysis ***\n\n" );
    
    CcTotalDirtyPages = GetUlongFromAddress( GlobalAddress = GetExpression( "nt!CcTotalDirtyPages" ));
    
    CcDirtyPageThreshold = GetUlongFromAddress( GlobalAddress = GetExpression( "nt!CcDirtyPageThreshold" ));
    
    if (GlobalAddress = GetExpression( "nt!CcDirtyPageHysteresisThreshold" )) {
        CcDirtyPageHysteresisThreshold = GetUlongFromAddress( GlobalAddress );
    } else {
        //
        //  Write hysteresis is new to Whistler.  Assume that if the symbol or read fails
        //  that we're dealing with a downlevel OS.
        //
        
        CcDirtyPageHysteresisThreshold = 0;
    }
    
    MmAvailablePages = GetUlongFromAddress( GlobalAddress = GetExpression( "nt!MmAvailablePages" ));
    
    MmThrottleTop = GetUlongFromAddress( GlobalAddress = GetExpression( "nt!MmThrottleTop" ));
    
    MmThrottleBottom = GetUlongFromAddress( GlobalAddress = GetExpression( "nt!MmThrottleBottom" ));

    if (GetFieldValue( GlobalAddress = GetExpression( "nt!MmModifiedPageListHead" ),
                       "nt!_MMPFNLIST",
                       "Total",
                       Total)) { 
        dprintf("Unable to read nt!_MMPFNLIST at %p\n", GlobalAddress);
        return; 
    }
    
    if (!ReadPointer( GlobalAddress = GetExpression( "nt!CcSingleDirtySourceDominant" ),
                       &CcSingleDirtySourceDominant)) { 
        //
        // CcSingleDirtySourceDominant is present in newer builds only
        //
        if (GlobalAddress) {
            dprintf("Unable to read nt!CcSingleDirtySourceDominant at %p\n", GlobalAddress); 
            return; 
        } else {
            CcSingleDirtySourceDominant = 0;
        }
    }

    dprintf("\tCcTotalDirtyPages:              %8u (%8u Kb)\n"
            "\tCcDirtyPageThreshold:           %8u (%8u Kb)\n",
            (ULONG) CcTotalDirtyPages, (ULONG) CcTotalDirtyPages*_KB,
            (ULONG) CcDirtyPageThreshold, (ULONG) CcDirtyPageThreshold*_KB);

    if (CcDirtyPageHysteresisThreshold) {
        
        dprintf("\tCcDirtyPageHysteresisThreshold: %8u (%8u Kb)\n",
                (ULONG) CcDirtyPageHysteresisThreshold, (ULONG) CcDirtyPageHysteresisThreshold*_KB);
    }

    dprintf("\tMmAvailablePages:               %8u (%8u Kb)\n"
            "\tMmThrottleTop:                  %8u (%8u Kb)\n"
            "\tMmThrottleBottom:               %8u (%8u Kb)\n"
            "\tMmModifiedPageListHead.Total:   %8u (%8u Kb)\n\n",
            (ULONG) MmAvailablePages, (ULONG) MmAvailablePages*_KB,
            (ULONG) MmThrottleTop, (ULONG) MmThrottleTop*_KB,
            (ULONG) MmThrottleBottom, (ULONG) MmThrottleBottom*_KB,
            (ULONG) Total, (ULONG) Total*_KB );


    
    //
    //  Cc element of the throttle.
    //

    if (CcDirtyPageHysteresisThreshold) {
        
        if (CcSingleDirtySourceDominant) {

            dprintf("Active write hysteresis with CcSingleDirtySourceDominant (%p)\n",
                    CcSingleDirtySourceDominant);

            //
            //  Split this up in the rare case where the transition is occuring.
            //

            if (CcTotalDirtyPages > CcDirtyPageHysteresisThreshold) {
                dprintf("CcTotalDirtyPages > CcDirtyPageHysteresisThreshold, writes may be throttled\n");
                CheckLazyWriter = TRUE;
            }
        }
    }

    if (CcTotalDirtyPages < CcDirtyPageThreshold) {

// From cc.h
#define WRITE_CHARGE_THRESHOLD          (64 * PageSize)

        if (CcTotalDirtyPages + (WRITE_CHARGE_THRESHOLD/PageSize) >= CcDirtyPageThreshold) {
            
            //
            //  Fortunately, this is in pages, not bytes. The target's page size could be different.
            //
            
            dprintf("CcTotalDirtyPages within %u (max charge) pages of the threshold, writes\n"
                    "  may be throttled\n",
                    (WRITE_CHARGE_THRESHOLD/PageSize));
            CheckLazyWriter = TRUE;
        
        }

    } else {

        dprintf("CcTotalDirtyPages >= CcDirtyPageThreshold, writes throttled\n");
        CheckLazyWriter = TRUE;
    }

    //
    //  Mm element of the throttle.
    //
    
    if (MmAvailablePages <= MmThrottleTop) {

        if (MmAvailablePages <= MmThrottleBottom) {

            dprintf("MmAvailablePages <= MmThrottleTop,\n  ");
            dprintf("and MmAvailablePages <= MmThrottleBottom, writes throttled\n  ");
            CheckMappedPageWriter = TRUE;
        }

        if (Total >= 1000) {

            if (!CheckMappedPageWriter) {
                dprintf("MmAvailablePages <= MmThrottleTop,\n  ");
            }
            dprintf("and modified page list >= 1000, writes throttled\n  ");
            CheckModifiedPageWriter = TRUE;
        }
    }

    //
    //  Suggest useful things.
    //
    
    if (CheckMappedPageWriter || CheckModifiedPageWriter || CheckLazyWriter) {
        dprintf("\nCheck these thread(s): ");
        if (CheckMappedPageWriter) {
            dprintf("MiMappedPageWriter ");
        }
        if (CheckModifiedPageWriter) {
            dprintf("MiModifiedPageWriter ");
        }
        if (CheckLazyWriter) {
            dprintf("CcWriteBehind(LazyWriter)");
        }
        dprintf("\n");

        if (CheckModifiedPageWriter || CheckMappedPageWriter) {
            dprintf("Check system process for the Mm page writers, !vm 3\n");
        }
        if (CheckLazyWriter) {
            dprintf("Check critical workqueue for the lazy writer, !exqueue 16\n");
        }
    } else {
        dprintf("Write throttles not engaged\n");
    }
    
    ListHeadAddr = GetExpression( "nt!CcDeferredWrites" );
    if (!ListHeadAddr) {
        dprintf( "Unable to get address of CcDeferredWrites\n" );
        return;
    }

    GetFieldOffset("nt!_DEFERRED_WRITE", "DeferredWriteLinks", &Offset);
    if (GetFieldValue( ListHeadAddr - Offset, 
                       "nt!_DEFERRED_WRITE",
                       "DeferredWriteLinks.Flink",
                       Flink)) {

        dprintf( "Cannot read nt!_DEFERRED_WRITE at %p\n", ListHeadAddr - Offset);
        return;
    }
    
    if (Flink != ListHeadAddr) {
        ULONG64 Next, Event;
        

        dprintf("Cc Deferred Write list: (CcDeferredWrites)\n");
        do {
    
            if (GetFieldValue( Flink - Offset, 
                               "nt!_DEFERRED_WRITE",
                               "DeferredWriteLinks.Flink",
                               Next)) {

                dprintf( "Cannot read nt!_DEFERRED_WRITE at %p\n", Flink - Offset);
                return;
            }
            
            InitTypeRead((Flink - Offset), nt!_DEFERRED_WRITE);

            dprintf( "  File: %p ", ReadField(FileObject) );
            if (Event = ReadField(Event)) {
                dprintf("Event: %p\n", Event );
            } else {
                UCHAR Name[0x100];
                ULONG64 Displacement, PostRoutine;

                GetSymbol( (PostRoutine = ReadField(PostRoutine)), Name, &Displacement );
                dprintf("CallBack: %s (%p) ", Name, PostRoutine );
                dprintf("Context1: %p ", ReadField(Context1) );
                dprintf("Context2: %p\n", ReadField(Context2) );
            }
    
            if (CheckControlC()) {
                break;
            }
    
        } while ( (Flink = Next) != ListHeadAddr  );
        
        dprintf( "\n" );
    }

    return;
}


ULONG
DumpBcbList (
    IN PFIELD_INFO ListElement,
    IN PVOID Context
    )
/*++

Routine Description:

    Enumeration callback function for the bcblist

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/
{
    ULONG Signature;
    ULONG PinCount = 0;
    ULONG Dirty = 0;
    LONGLONG Offset = 0;
    LONG Options = (LONG)(ULONG_PTR) Context;

    if (GetFieldValue( ListElement->address, "BCB", "NodeTypeCode", Signature )) {
        dprintf( "Unable to read bcb at 0x%I64x\n", ListElement->address );
    } else {
        if (Signature == CACHE_NTC_BCB) {

            GetFieldValue( ListElement->address, "BCB", "PinCount", PinCount );
            GetFieldValue( ListElement->address, "BCB", "Dirty", Dirty );
            GetFieldValue( ListElement->address, "BCB", "FileOffset.QuadPart", Offset );
            
            if ((Options != 0) || (PinCount != 0)) {
                dprintf( "  Bcb: %p @ 0x%I64x PinCount: 0x%x Dirty: %x\n", ListElement->address, Offset, PinCount, Dirty );
            }
        }
    }

    return FALSE;
}

VOID
DumpLevel(
    ULONG64 Address,
    ULONG64 MaxSize,
    ULONG64 Offset,
    ULONG Options,
    ULONG Level,
    ULONG *Count,
    ULONG *CountActive
    )
/*++

Routine Description:

    Dump a vacb level recursively.

Arguments:
                                                         
    Address - Gives the address of the vacb level to dump
    
    MaxSize - the total section size
    
    Offset - Current offset within the section being dumped. Should be 0 for 1st caller
    
    Options - if non zero dump everything otherwise only dump referenced vacbs
    
    Level - how many levels of vacbs there are
    
    Count, CountActive - accumulators for counts of VACBs and active VACBs
    
Return Value:

    None

--*/

{
    int Index;
    ULONG PtrSize;
    ULONG64 SubAddress;
    ULONG64 Overlay = 0;
    ULONG64 Limit;
    ULONG64 Increment;
    USHORT ActiveCount;

    Limit = (MaxSize - Offset) >> VACB_OFFSET_SHIFT; 
    if (Limit > (1<<VACB_LEVEL_SHIFT) ) {
        Limit = (1<<VACB_LEVEL_SHIFT);
    }

    Increment = 1 << ((VACB_LEVEL_SHIFT * (Level - 1)) + VACB_OFFSET_SHIFT );

    PtrSize = DBG_PTR_SIZE;

    for (Index=0; Index < Limit; Index++ ) {

        if (!ReadPointer( Address + PtrSize * Index, &SubAddress )) {
            dprintf( "Unable to read subaddress at 0x%I64x\n", Address + PtrSize * Index );
            return;
        }
        
        if (SubAddress != 0) {

            if (Level == 1) {

                *Count = *Count + 1;

                if (GetFieldValue(SubAddress, "VACB", "Overlay.FileOffset.QuadPart", Overlay)) {
                    dprintf( "Unable to read overlay at %p\n", SubAddress );
                    return;
                }

                //
                //  If verbose print all vacbs o.w. print any vacbs with reference count
                //

                ActiveCount = (USHORT) (Overlay & 0xFFFF);

                if (ActiveCount != 0) {
                    
                    *CountActive = *CountActive + 1;
                }

                if (ActiveCount != 0 || Options != 0) {
                    dprintf( "%16I64x ActiveCount %u @ Vacb %p\n", (Overlay & ~(0xFFFF)), ActiveCount, SubAddress );
                }
                
            } else {

                DumpLevel( SubAddress, MaxSize, Offset + Increment * Index, Options, Level - 1, Count, CountActive );
            }
        }
    }
}



VOID
DumpOpenMaps (
    IN ULONG64 Address,
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    )

/*++

Routine Description:

    Dump a specific shared cache map.

Arguments:

    Address - Gives the address of the shared cache map to dump

Return Value:

    None

--*/

{
    ULONG64 FirstBcb;
    ULONGLONG SectionSize;
    LONG Level;
    LONG Shift;
    ULONG64 Vacbs;
    ULONG ActiveCount = 0, Count = 0;

    UNREFERENCED_PARAMETER( Options );
    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( Address );

    dprintf( "SharedCacheMap  %p\n", Address );

    //
    //  First look for mapped vacbs
    // 

    if (GetFieldValue( Address, "SHARED_CACHE_MAP", "SectionSize.QuadPart", SectionSize )) {
        dprintf( "Unable to read sectionsize at 0x%I64x\n", Address );
        return;
    }

    if (GetFieldValue( Address, "SHARED_CACHE_MAP", "Vacbs", Vacbs )) {
        dprintf( "Unable to read vacbs at 0x%I64x\n", Address );
        return;
    }

    dprintf( "Section Size    %I64x\n", SectionSize );

    //
    //  Large file case -- multilevel Vacb storage.
    //

    Level = 0;
    Shift = VACB_OFFSET_SHIFT;

    //
    //  Loop to calculate how many levels we have and how much we have to
    //  shift to index into the first level.
    //

    while (SectionSize > ((ULONG64)1 << Shift)) {

        Level += 1;
        Shift += VACB_LEVEL_SHIFT;
    } 

    dprintf( "Levels          %d\n", Level );
    
    if (GetFieldValue( Address, "SHARED_CACHE_MAP", "VacbActiveCount", ActiveCount )) {
        dprintf( "Unable to read ActiveVacbCount at 0x%I64x\n", Address );
        return;
    }

    dprintf("VacbActiveCount %u\n\n", ActiveCount );

    //
    //  Now spit out all of the Vacbs.
    //

    Count = ActiveCount = 0;
    
    DumpLevel( Vacbs, SectionSize, 0, Options, Level, &Count, &ActiveCount );

    dprintf( "\n" );

    dprintf( "Total VACBs %u Active %u\n", Count, ActiveCount );

    if (GetFieldValue( Address, "SHARED_CACHE_MAP", "BcbList.Flink", FirstBcb )) {
        dprintf( "Unable to read bcblist at 0x%I64x\n", Address );
        return;
    }

    ListType( "SHARED_CACHE_MAP", FirstBcb, 1, "BcbList.Flink", (PVOID)(ULONG_PTR) Options, DumpBcbList );

    return;
}



//
//  Entry points, parameter parsers, etc. below
//


static
VOID
ParseAndDump (
    IN PCHAR args,
    IN STRUCT_DUMP_ROUTINE DumpFunction,
    USHORT Processor,
    HANDLE hCurrentThread
    )

/*++

Routine Description:

    Parse command line arguments and dump an ntfs structure.

Arguments:

    Args - String of arguments to parse.

    DumpFunction - Function to call with parsed arguments.

Return Value:                                                                                                                                                   %u

    None

--*/

{
    ULONG64 StructToDump;
    LONG Options;
    LPSTR arg2 = args;

    //
    //  If the caller specified an address then that's the item we dump
    //

    StructToDump = 0;
    Options = 0;


    if (GetExpressionEx(args,&StructToDump, &args )) {
        Options = (ULONG)GetExpression( args );
    }

#ifdef CDAVIS_DEBUG
    if (!StructToDump){
        dprintf("unable to get expression %s\n",arg2);
        return;
    }
#endif 

    (*DumpFunction) ( StructToDump, Options, Processor, hCurrentThread );

    dprintf( "\n" );

    return;
}


static
VOID
PrintHelp (
    VOID
    )
/*++

Routine Description:

    Dump out one line of help for each DECLARE_API

Arguments:

    None

Return Value:

    None

--*/
{
    int i;

    for( i=0; Extensions[i]; i++ )
        dprintf( "   %s\n", Extensions[i] );
}


DECLARE_API( bcb )

/*++

Routine Description:

    Dump bcb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    ULONG dwProcessor;
    HANDLE hCurrentThread;
    
    if (!GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread)) {
        dwProcessor = 0;
        hCurrentThread = 0;
    }

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpBcb, (USHORT)dwProcessor, hCurrentThread );

    return S_OK;
}


DECLARE_API( cchelp )

/*++

Routine Description:

    Dump help message

Arguments:

    None

Return Value:

    None

--*/

{
    PrintHelp();
    return S_OK;
}


DECLARE_API( finddata )

/*++

Routine Description:

    Dump bcb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    ULONG dwProcessor;
    HANDLE hCurrentThread;
    
    if (!GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread)) {
        dwProcessor = 0;
        hCurrentThread = 0;
    }
    
    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpFindData, (USHORT)dwProcessor, hCurrentThread );

    return S_OK;
}


DECLARE_API( pcm )

/*++

Routine Description:

    Dump private cache map struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    ULONG dwProcessor;
    HANDLE hCurrentThread;
    
    if (!GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread)) {
        dwProcessor = 0;
        hCurrentThread = 0;
    }
    
    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpPcm, (USHORT)dwProcessor, hCurrentThread );

    return S_OK;
}


DECLARE_API( scm )

/*++

Routine Description:

    Dump shared cache map struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    ULONG dwProcessor;
    HANDLE hCurrentThread;

    if (!GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread)) {
        dwProcessor = 0;
        hCurrentThread = 0;
    }
    
    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpScm, (USHORT)dwProcessor, hCurrentThread );

    return S_OK;
}



DECLARE_API( defwrites )

/*++

Routine Description:

    Dump deferred write queue

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    ULONG dwProcessor;
    HANDLE hCurrentThread;


    if (!GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread)) {
        dwProcessor = 0;
        hCurrentThread = 0;
    }
    
    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpDeferredWrites, (USHORT)dwProcessor, hCurrentThread );

    return S_OK;
}


DECLARE_API( openmaps )

/*++

Routine Description:

    Find referenced bcbs and vacbs in a cache map

Arguments:

    arg - [Shared cache map address] 

Return Value:

    None

--*/

{
    ULONG dwProcessor;
    HANDLE hCurrentThread;


    if (!GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread)) {
        dwProcessor = 0;
        hCurrentThread = 0;
    }
    
    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpOpenMaps, (USHORT)dwProcessor, hCurrentThread );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\cpuinfo.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    cpuinfo.c

Abstract:

    WinDbg Extension Api

Author:

    Peter Johnston (peterj) 19-April-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#include "i386.h"
#include "amd64.h"
#include "ia64.h"
#pragma hdrstop

#define MAXIMUM_IA64_VECTOR     256

#if !defined(ROUND_UP)

//
// Macro to round Val up to the next Bnd boundary.  Bnd must be an integral
// power of two.
//

#define ROUND_UP( Val, Bnd ) \
    (((Val) + ((Bnd) - 1)) & ~((Bnd) - 1))

#endif // !ROUND_UP

VOID
DumpCpuInfoIA64(
    ULONG processor,
    BOOLEAN doHead
)
{
    HRESULT Hr;
    ULONG   number;
    ULONG64 prcb;
    UCHAR vendorString[16];

    if (doHead)
    {
        dprintf("CP M/R/F/A Manufacturer     SerialNumber     Features\n");
    }

    Hr = g_ExtData->ReadProcessorSystemData(processor,
                                            DEBUG_DATA_KPRCB_OFFSET,
                                            &prcb,
                                            sizeof(prcb),
                                            NULL);

    if (Hr != S_OK)
    {
        return;
    }

    if ( GetFieldValue(prcb, "nt!_KPRCB", "ProcessorVendorString", vendorString) )   {
        dprintf("Unable to read VendorString from Processor %u KPRCB, quitting\n", processor);
        return;
    }

    if ( InitTypeRead( prcb, nt!_KPRCB ))    {
        dprintf("Unable to read KPRCB for processor %u, quitting.\n", processor);
        return;
    }

    number = (ULONG)ReadField(Number);
    if ( number != processor ) {

        //
        // Processor number isn't what we expected.  Bail out.
        // This will need revisiting at some stage in the future
        // when we support a discontiguous set of processor numbers.
        //

        dprintf("Processor %d mismatch with processor number in KPRCB = %d, quitting\n",
                processor,
                number );
        return;
    }

    dprintf("%2d %d,%d,%d,%d %-16s %016I64x %016I64x\n",
            number,
            (ULONG) ReadField(ProcessorModel),
            (ULONG) ReadField(ProcessorRevision),
            (ULONG) ReadField(ProcessorFamily),
            (ULONG) ReadField(ProcessorArchRev),
            vendorString,
            (ULONGLONG) ReadField(ProcessorSerialNumber),
            (ULONGLONG) ReadField(ProcessorFeatureBits)
            );

    return;

}

VOID
DumpCpuInfoX86(
    ULONG processor,
    BOOLEAN doHead
)
{
    HRESULT Hr;
    ULONG64 Prcb;
    UCHAR   sigWarn1, sigWarn2;
    LARGE_INTEGER updateSignature;
    PROCESSORINFO pi;

    if (doHead)
    {
        dprintf("CP F/M/S Manufacturer  MHz Update Signature Features\n");
    }

    if (!Ioctl(IG_KD_CONTEXT, &pi, sizeof(pi))) {
        dprintf("Unable to get processor info, quitting\n");
        return;
    }

    CHAR   VendorString[20]={0};

    Hr = g_ExtData->ReadProcessorSystemData(processor,
                                            DEBUG_DATA_KPRCB_OFFSET,
                                            &Prcb,
                                            sizeof(Prcb),
                                            NULL);

    if (Hr != S_OK)
    {
        return;
    }

    if (InitTypeRead(Prcb, nt!_KPRCB)) {
        dprintf("Unable to read PRCB for processor %u, quitting.\n",
                processor);
        return;
    }

    if ((ULONG) ReadField(Number) != processor) {

        //
        // Processor number isn't what I expected.  Bail out.
        // This will need revisiting at some stage in the future
        // when we support a discontiguous set of processor numbers.
        //

        dprintf("Processor %d mismatch with processor number in PRCB %d, quitting\n",
                processor,
                (ULONG) ReadField(Number));
        return;
    }

    if (ReadField(CpuID) == 0) {

        //
        // This processor doesn't support CPUID,... not likely in
        // an MP environment but also means we don't have anything
        // useful to say.
        //

        dprintf("Processor %d doesn't support CPUID, quitting.\n",
                processor);

        return;
    }

    //
    // If this is an Intel processor, family 6 (or, presumably
    // above family 6) read the current UpdateSignature from
    // the processor rather than using what was there when we
    // booted,... it may havee been updated.
    //
    // Actually, this can't be done unless we can switch processors
    // from within an extension.   So, mark the processor we did
    // it for (unless there's only one processor).
    //

    *((PULONG64) &updateSignature) = ReadField(UpdateSignature);
    sigWarn1 = sigWarn2 = ' ';
    GetFieldValue(Prcb, "nt!_KPRCB", "VendorString", VendorString);
    if ((!strcmp(VendorString, "GenuineIntel")) &&
        ((ULONG) ReadField(CpuType) >= 6)) {

        if ((ULONG) ReadField(Number) == pi.Processor)
        {
            if (TargetMachine == IMAGE_FILE_MACHINE_I386)
            {
                READ_WRITE_MSR msr;

                msr.Msr = 0x8b;
                msr.Value = 0;

                if (Ioctl(IG_READ_MSR, &msr, sizeof(msr)))
                {
                    updateSignature.QuadPart = msr.Value;
                }
            }

            if (pi.NumberProcessors != 1)
            {
                sigWarn1 = '>';
                sigWarn2 = '<';
            }
        }
    }

    //
    // This extension could pretty much be !PRCB but it's a
    // subset,... perhaps we should have a !PRCB?
    //

    dprintf("%2d %d,%d,%d %12s%5d%c%08x%08x%c%08x\n",
            (ULONG) ReadField(Number),
            (ULONG) ReadField(CpuType),
            ((ULONG) ReadField(CpuStep) >> 8) & 0xff,
            (ULONG) ReadField(CpuStep) & 0xff,
            VendorString,
            (ULONG) ReadField(MHz),
            sigWarn1,
            updateSignature.u.HighPart,
            updateSignature.u.LowPart,
            sigWarn2,
            (ULONG) ReadField(FeatureBits));

}

DECLARE_API( cpuinfo )

/*++

Routine Description:

    Gather up any info we know is still in memory that we gleaned
    using the CPUID instruction,.... and a few other interesting
    tidbits as well.

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG64 processor;
    BOOLEAN first = TRUE;
    ULONG64 NumProcessors = 0;

    INIT_API();

    g_ExtControl->GetNumberProcessors((PULONG) &NumProcessors);

    if (GetExpressionEx(args, &processor, &args))
    {
        //
        // The user specified a procesor number.
        //

        if (processor >= NumProcessors)
        {
            dprintf("cpuinfo: invalid processor number specified\n");
        }
        else
        {
            NumProcessors = processor + 1;
        }
    }
    else
    {
        //
        // Enumerate all the processors
        //

        processor = 0;
    }

    while (processor < NumProcessors)
    {
        switch( TargetMachine )
        {
        case IMAGE_FILE_MACHINE_I386:
            DumpCpuInfoX86((ULONG)processor, first);
            break;

        case IMAGE_FILE_MACHINE_IA64:
            DumpCpuInfoIA64((ULONG)processor, first);
            break;

        default:
            dprintf("!cpuinfo not supported for this target machine: %ld\n", TargetMachine);
            processor = NumProcessors;
        }

        processor++;
        first = FALSE;
    }

    EXIT_API();

    return S_OK;
}


DECLARE_API( prcb )

/*++

Routine Description:

    Displays the PRCB

Arguments:

    args - the processor number ( default is 0 )

Return Value:

    None

--*/

{
    HRESULT Hr;
    ULONG64 Address=0;
    ULONG Processor;
    ULONG Prcb;

    INIT_API();

    Processor = (ULONG) GetExpression(args);

    Hr = g_ExtData->ReadProcessorSystemData(Processor,
                                            DEBUG_DATA_KPRCB_OFFSET,
                                            &Address,
                                            sizeof(Address),
                                            NULL);

    if (Hr != S_OK)
    {
        dprintf("Cannot get PRCB address\n");
        return E_INVALIDARG;
    }

    if (InitTypeRead(Address, nt!_KPRCB) )
    {
        dprintf("Unable to read PRCB\n");
        return E_INVALIDARG;
    }

    dprintf("PRCB for Processor %d at %16p:\n",
                    Processor, Address);
    dprintf("Major %d Minor %d\n",
                    (ULONG) ReadField(MajorVersion),
                    (ULONG) ReadField(MinorVersion));

    dprintf("Threads--  Current %16p Next %16p Idle %16p\n",
                    ReadField(CurrentThread),
                    ReadField(NextThread),
                    ReadField(IdleThread));

    dprintf("Number %d SetMember %08lx\n",
                    (ULONG) ReadField(Number),
                    (ULONG) ReadField(SetMember));

    dprintf("Interrupt Count -- %08lx\n",
                    (ULONG) ReadField(InterruptCount));

    dprintf("Times -- Dpc    %08lx Interrupt %08lx \n",
                    (ULONG) ReadField(DpcTime),
                    (ULONG) ReadField(InterruptTime));

    dprintf("         Kernel %08lx User      %08lx \n",
                    (ULONG) ReadField(KernelTime),
                    (ULONG) ReadField(UserTime));

    EXIT_API();

    return S_OK;
}


VOID
DumpPcrX86(
    ULONG64 pPcr
    )
{
    ULONG ListHeadOff;
    PROCESSORINFO pi;
    ULONG Result;
    ULONG64 Prcb, DpcFlink;

    InitTypeRead(pPcr, nt!_KPCR);

    //
    // Print out the PCR
    //

    dprintf("\tNtTib.ExceptionList: %08lx\n", (ULONG) ReadField(NtTib.ExceptionList));
    dprintf("\t    NtTib.StackBase: %08lx\n", (ULONG) ReadField(NtTib.StackBase));
    dprintf("\t   NtTib.StackLimit: %08lx\n", (ULONG) ReadField(NtTib.StackLimit));
    dprintf("\t NtTib.SubSystemTib: %08lx\n", (ULONG) ReadField(NtTib.SubSystemTib));
    dprintf("\t      NtTib.Version: %08lx\n", (ULONG) ReadField(NtTib.Version));
    dprintf("\t  NtTib.UserPointer: %08lx\n", (ULONG) ReadField(NtTib.ArbitraryUserPointer));
    dprintf("\t      NtTib.SelfTib: %08lx\n", (ULONG) ReadField(NtTib.Self));
    dprintf("\n");
    dprintf("\t            SelfPcr: %08lx\n", (ULONG) ReadField(SelfPcr));
    dprintf("\t               Prcb: %08lx\n", (ULONG) ReadField(Prcb));
    dprintf("\t               Irql: %08lx\n", (ULONG) ReadField(Irql));
    dprintf("\t                IRR: %08lx\n", (ULONG) ReadField(IRR));
    dprintf("\t                IDR: %08lx\n", (ULONG) ReadField(IDR));
    dprintf("\t      InterruptMode: %08lx\n", (ULONG) ReadField(InterruptMode));
    dprintf("\t                IDT: %08lx\n", (ULONG) ReadField(IDT));
    dprintf("\t                GDT: %08lx\n", (ULONG) ReadField(GDT));
    dprintf("\t                TSS: %08lx\n", (ULONG) ReadField(TSS));
    dprintf("\n");
    dprintf("\t      CurrentThread: %08lx\n", (ULONG) ReadField(PrcbData.CurrentThread));
    dprintf("\t         NextThread: %08lx\n", (ULONG) ReadField(PrcbData.NextThread));
    dprintf("\t         IdleThread: %08lx\n", (ULONG) ReadField(PrcbData.IdleThread));

    GetKdContext( &pi );

    dprintf("\n");

    dprintf( "\t          DpcQueue: ");

    DpcFlink = ReadField(PrcbData.DpcListHead.Flink);
    GetFieldOffset("nt!_KPRCB", "DpcListHead", &ListHeadOff);
    Prcb = ReadField(Prcb);
    while (DpcFlink != (Prcb + ListHeadOff )) {

        CHAR Name[0x100];
        ULONG64 Displacement, DeferredRoutine;

        Name[0] = 0;
        dprintf(" 0x%p ", (DpcFlink) - 4 );

        if (GetFieldValue( DpcFlink - 4, "nt!_KDPC", "DeferredRoutine", DeferredRoutine )) {
            dprintf( "Failed to read DPC at 0x%p\n", DpcFlink - 4 );
            break;
        }

        GetSymbol( DeferredRoutine, Name, &Displacement );
        dprintf("0x%p %s\n\t                    ", DeferredRoutine, Name );

        if (CheckControlC()) {
            break;
        }
        GetFieldValue( DpcFlink - 4, "nt!_KDPC", "DpcListEntry.Flink", DpcFlink);

    }

    dprintf("\n");
}


DECLARE_API( pcr )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG Processor = 0;
    ULONG64 Pkpcr;
    ULONG   MajorVersion, Off;
    HRESULT Hr;

    INIT_API();

    if (!*args) {
        GetCurrentProcessor(Client, &Processor, NULL);
    } else {
        Processor = (ULONG) GetExpression(args);
    }

    Hr = g_ExtData->ReadProcessorSystemData(Processor,
                                            DEBUG_DATA_KPCR_OFFSET,
                                            &Pkpcr,
                                            sizeof(Pkpcr),
                                            NULL);

    if (Hr != S_OK)
    {
        dprintf("Cannot get PRCB address\n");
        return E_INVALIDARG;
    }

    if (GetFieldValue(Pkpcr, "nt!_KPCR", "MajorVersion", MajorVersion)) {
        dprintf("Unable to read the PCR at %p\n", Pkpcr);
        return E_INVALIDARG;
    }

    //
    // Print out some interesting fields
    //
    InitTypeRead(Pkpcr, nt!_KPCR);
    dprintf("KPCR for Processor %d at %08p:\n", Processor, Pkpcr);
    dprintf("    Major %d Minor %d\n",
                    MajorVersion,
                    (ULONG) ReadField(MinorVersion));
    switch (TargetMachine) {
    case IMAGE_FILE_MACHINE_I386:
        DumpPcrX86(Pkpcr);
        break;
    case IMAGE_FILE_MACHINE_IA64:
        dprintf("\n");
        dprintf("\t               Prcb:  %016I64X\n", ReadField(Prcb));
        dprintf("\t      CurrentThread:  %016I64X\n", ReadField(CurrentThread));
        dprintf("\t       InitialStack:  %016I64X\n", ReadField(InitialStack));
        dprintf("\t         StackLimit:  %016I64X\n", ReadField(StackLimit));
        dprintf("\t      InitialBStore:  %016I64X\n", ReadField(InitialBStore));
        dprintf("\t        BStoreLimit:  %016I64X\n", ReadField(BStoreLimit));
        dprintf("\t         PanicStack:  %016I64X\n", ReadField(PanicStack));
        dprintf("\t        CurrentIrql:  0x%lx\n",    (ULONG)ReadField(CurrentIrql));
        dprintf("\n");
        break;
    default:
        dprintf("Panic Stack %08p\n", ReadField(PanicStack));
        dprintf("Dpc Stack %08p\n", ReadField(DpcStack));
        dprintf("Irql addresses:\n");
        GetFieldOffset("KPCR", "IrqlMask", &Off);
        dprintf("    Mask    %08p\n",Pkpcr + Off);
        GetFieldOffset("KPCR", "IrqlTable", &Off);
        dprintf("    Table   %08p\n", Pkpcr + Off);
        GetFieldOffset("KPCR", "InterruptRoutine", &Off);
        dprintf("    Routine %08p\n", Pkpcr + Off);
    } /* switch */

    EXIT_API();

    return S_OK;
}

#define TYPE_NO_MATCH 0xFFFE

#define IH_WITH_SYMBOLS    TRUE
#define IH_WITHOUT_SYMBOLS FALSE

typedef struct _INTERRUPTION_MAP {
    ULONG Type;
    PCSTR Name;
    PCSTR OptionalField;
} INTERRUPTION_MAP;

static INTERRUPTION_MAP CodeToName[] = {
    0x0, "VHPT FAULT", "IFA",
    0x4, "ITLB FAULT", "IIPA",
    0x8, "DTLB FAULT", "IFA",
    0xc, "ALT ITLB FAULT", "IIPA",
    0x10, "ALT DTLB FAULT", "IFA",
    0x14, "DATA NESTED TLB", "IFA",
    0x18, "INST KEY MISS", "IIPA",
    0x1c, "DATA KEY MISS", "IFA",
    0x20, "DIRTY BIT FAULT", "IFA",
    0x24, "INST ACCESS BIT", "IIPA",
    0x28, "DATA ACCESS BIT", "IFA",
    0x2c, "BREAK INST FAULT", "IIM",
    0x30, "EXTERNAL INTERRUPT", "IVR",
    0x50, "PAGE NOT PRESENT", "IFA",
    0x51, "KEY PERMISSION", "IFA",
    0x52, "INST ACCESS RIGHT", "IIPA",
    0x53, "DATA ACCESS RIGHT", "IFA",
    0x54, "GENERAL EXCEPTION", "ISR",
    0x55, "DISABLED FP FAULT", "ISR",
    0x56, "NAT CONSUMPTION", "ISR",
    0x57, "SPECULATION FAULT", "IIM",
    0x59, "DEBUG FAULT", "ISR",
    0x5a, "UNALIGNED REF", "IFA",
    0x5b, "LOCKED DATA REF", "ISR",
    0x5c, "FP FAULT", "ISR",
    0x5d, "FP TRAP", "ISR",
    0x5e, "LOWER PRIV TRAP", "IIPA",
    0x5f, "TAKEN BRANCH TRAP", "IIPA",
    0x60, "SINGLE STEP TRAP", "IIPA",
    0x69, "IA32 EXCEPTION", "R0",
    0x6a, "IA32 INTERCEPT", "R0",
    0x6b, "IA32 INTERRUPT", "R0",
    0x80, "KERNEL SYSCALL", "Num",
    0x81, "USER SYSCALL", "Num",
    0x90, "THREAD SWITCH", "OSP",
    0x91, "PROCESS SWITCH", "OSP",
    TYPE_NO_MATCH, " ", "OPT"
};

#define DumpHistoryValidIIP( _IHistoryRecord ) \
    ( ((_IHistoryRecord).InterruptionType != 0x90 /* THREAD_SWITCH  */) && \
      ((_IHistoryRecord).InterruptionType != 0x91 /* PROCESS_SWITCH */) )

VOID
DumpHistory(
    IHISTORY_RECORD  History[],
    ULONG            Count,
    BOOLEAN          WithSymbols
    )
{
    ULONG index;
    ULONG i;
    BOOL  printed;

    dprintf("Total # of interruptions = %lu\n", Count);
    dprintf("Vector              IIP                   IPSR          ExtraField %s\n", WithSymbols ? "           IIP Symbol" : "" );
    Count = (ULONG)(Count % MAX_NUMBER_OF_IHISTORY_RECORDS);
    for (index = 0; index < MAX_NUMBER_OF_IHISTORY_RECORDS; index++) {
        printed = FALSE;
        for (i = 0; i < sizeof(CodeToName)/sizeof(CodeToName[0]); i++) {
            if (History[Count].InterruptionType == CodeToName[i].Type) {
                CCHAR     symbol[256];
                PCHAR     s;
                ULONG64   displacement;
                ULONGLONG iip;

                iip = History[Count].IIP;
                s   = "";
                if ( WithSymbols && DumpHistoryValidIIP( History[Count]) )  {
                    symbol[0] = '!';
                    GetSymbol( iip, symbol, &displacement);
                    s = (PCHAR)symbol + strlen( (PCHAR)symbol );
                    if (s == (PCHAR)symbol ) {
                        // sprintf( s, (IsPtr64() ? "0x%I64x" : "0x%08x"), iip );
                        sprintf( s, "0x%016I64x", iip );
                    }
                    else {
                        if ( displacement ) {
                            // sprintf( s, (IsPtr64() ? "+0x%016I64x" : "+0x%08x"), displacement );
                            sprintf( s, "+0x%I64x", displacement );
                        }
                    }
                    s = symbol;
                }
                dprintf( "%18s  %16I64x  %16I64x  %s= %16I64x %s\n",
                         CodeToName[i].Name,
                         iip,
                         History[Count].IPSR,
                         CodeToName[i].OptionalField,
                         History[Count].Extra0,
                         s
                        );
                printed = TRUE;
                break;
            }
        }
        if ( !printed )  {
            dprintf("VECTOR 0x%lx - unknown for !ih...\n", History[Count].InterruptionType);
        }
        Count++;
        if (Count == MAX_NUMBER_OF_IHISTORY_RECORDS) Count = 0;
    }
    return;

} // DumpHistory

HRESULT DoIH(
    PDEBUG_CLIENT Client,
    PCSTR         args,
    BOOLEAN       WithSymbols
    )
/*++

Routine Description:

    WorkHorse function to dump processors interrupt history records

Arguments:

    Client      - debug engine interface client
    args        - the processor number ( default is the current )
    WithSymbols - BOOLEAN to specify with or without the IIP Symbols

Return Value:

    HRESULT

--*/

{
    ULONG   processor;
    ULONG   interruptionCount;
    ULONG64 pcrAddress;
    HRESULT Hr;

    //
    // This extension is IA64 specific...
    //

    if ( TargetMachine != IMAGE_FILE_MACHINE_IA64 )
    {
        dprintf("ih: IA64 specific extension...\n");
        return E_INVALIDARG;
    }

    INIT_API();

    GetCurrentProcessor(Client, &processor, NULL);
    if ( *args )
    {
       processor = (ULONG)GetExpression( args );
    }

    Hr = g_ExtData->ReadProcessorSystemData(processor,
                                            DEBUG_DATA_KPCR_OFFSET,
                                            &pcrAddress,
                                            sizeof(pcrAddress),
                                            NULL);


    if (Hr != S_OK)
    {
        dprintf("ih: Cannot get PCR address\n");
    }
    else
    {
        if (GetFieldValue( pcrAddress, "NT!_KPCR", "InterruptionCount", interruptionCount ) )
        {
            dprintf("ih: failed to read KPCR for processor %lu\n", processor);
            Hr = E_INVALIDARG;
        }
        else
        {
            //
            // Read and display Interrupt history
            //

            ULONG           result;
            IHISTORY_RECORD history[MAX_NUMBER_OF_IHISTORY_RECORDS];

            if (!ReadMemory(pcrAddress+0x1000,
                            (PVOID)history,
                            sizeof(history),
                            &result))
            {
                dprintf("ih: unable to read interrupt history records at %p - result=%lu\n",
                         pcrAddress + 0x1000, result);

                Hr = E_INVALIDARG;
            }
            else
            {
                DumpHistory(history, interruptionCount, WithSymbols);
            }
        }
    }

    EXIT_API();

    return Hr;

} // DoIH()

DECLARE_API( ihs )

/*++

Routine Description:

    Dumps the interrupt history records with IIP symbols

Arguments:

    args - the processor number ( default is current processor )

Return Value:

    None

--*/

{

    return( DoIH( Client, args, IH_WITH_SYMBOLS ) );

} // !ihs

DECLARE_API( ih )

/*++

Routine Description:

    Dumps the interrupt history records

Arguments:

    args - the processor number ( default is current processor )

Return Value:

    None

--*/

{

    return( DoIH( Client, args, IH_WITHOUT_SYMBOLS ) );

} // !ih

VOID
DumpBTHistory(
    ULONGLONG Bth[],        // Branch Trace record
    ULONG64   BthAddress,   // BTH Virtual Address
    ULONG     MaxBtrNumber // Maximum number of records
    )
{
    ULONG rec;

    dprintf( "BTH @ 0x%I64x:\n"
             "   b mp slot address            symbol\n"
             , BthAddress);

    for ( rec = 0; rec < (MaxBtrNumber - 1) ; rec++ ) {
        DisplayBtbPmdIA64( "   ", Bth[rec], DISPLAY_MIN );
    }

    DisplayBtbIndexPmdIA64( "BTB Index: ", Bth[rec], DISPLAY_MIN );

    return;

} // DumpBTHistory()

DECLARE_API( bth )

/*++

Routine Description:

    Dumps the IA-64 branch trace buffer saved in _KPCR.
    The '!btb' extension dumps the processor branch trace buffer configuration and trace registers.

Arguments:

    args - the processor number ( default is the current processor )

Return Value:

    None

--*/

{
    ULONG   processor;
    ULONG   interruptionCount;
    ULONG64 pcrAddress;
    HRESULT Hr;

    //
    // This extension is IA64 specific...
    //

    if ( TargetMachine != IMAGE_FILE_MACHINE_IA64 )
    {
        dprintf("ih: IA64 specific extension...\n");
        return E_INVALIDARG;
    }

    INIT_API();

    GetCurrentProcessor(Client, &processor, NULL);
    if ( *args )
    {
       processor = (ULONG)GetExpression( args );
    }

    Hr = g_ExtData->ReadProcessorSystemData(processor,
                                            DEBUG_DATA_KPCR_OFFSET,
                                            &pcrAddress,
                                            sizeof(pcrAddress),
                                            NULL);
   if (Hr != S_OK)
    {
        dprintf("Cannot get PCR address\n");
    }
    else
    {
        ULONG pcrSize;

        pcrSize = GetTypeSize("nt!_KPCR");
        if ( pcrSize == 0 ) {
            dprintf( "bth: failed to get _KPCR size\n" );
            Hr = E_FAIL;
        }
        else  {
            ULONG     result;
            ULONG64   bthAddress;
            ULONGLONG bth[MAX_NUMBER_OF_BTBHISTORY_RECORDS];

            pcrSize = ROUND_UP( pcrSize, 16 );
            bthAddress = pcrAddress + (ULONG64)pcrSize;
            if ( !ReadMemory( bthAddress, bth, sizeof(bth), &result ) ) {
                dprintf( "bth: unable to read branch trace history records at %p - result=%lu\n",
                         bthAddress, result);
                Hr = E_FAIL;
            }
            else {
                DumpBTHistory( bth, bthAddress, (ULONG)(sizeof(bth)/sizeof(bth[0])) );
            }
        }
    }

    EXIT_API();

    return Hr;

} // !bth

DECLARE_API( btb )

/*++

Routine Description:

    Dumps the IA-64 branch trace buffer.

Arguments:

    args - the processor number ( default is the current processor )

Return Value:

    None

--*/

{
    ULONG   processor;
    ULONG   interruptionCount;
    ULONG64 pcrAddress;
    ULONG64 msr;
    ULONG   reg;
    HRESULT Hr = S_OK;

    //
    // This extension is IA64 specific...
    //

    if ( TargetMachine != IMAGE_FILE_MACHINE_IA64 )
    {
        dprintf("ih: IA64 specific extension...\n");
        return E_INVALIDARG;
    }

    INIT_API();

    GetCurrentProcessor(Client, &processor, NULL);

    dprintf("BTB for processor %ld:\n"
            "   b mp slot address            symbol\n"
            , processor);

// Thierry 11/20/2000 - FIXFIX - This is Itanium specific. Should be using PMD[] but
//                               not currently collected in _KSPECIAL_REGISTERS.
    for ( reg = 0; reg < 8; reg++) {
        msr = 0;
        ReadMsr( 680 + reg, &msr );
        DisplayBtbPmdIA64( "   ", msr, DISPLAY_MIN );
    }

    EXIT_API();

    return Hr;

} // !btb


DECLARE_API( idt )
{
    ULONG64 Pkpcr;
    ULONG64 Address;
    ULONG64 IdtAddress;
    ULONG DispatchCodeOffset;
    ULONG ListEntryOffset;
    UCHAR currentIdt, endIdt;
    ULONG64 displacement;
    ULONG64 unexpectedStart, unexpectedEnd;
    BOOLEAN argsPresent = FALSE;
    ULONG64 firstIntObj;
    ULONG64 flink;
    ULONG   idtEntrySize;
    CHAR    buffer[100];
    ULONG   processor;
    ULONG   idtChainCount;
    HRESULT Hr;
    USHORT  interruptObjectType;

    if ( TargetMachine != IMAGE_FILE_MACHINE_I386 &&
         TargetMachine != IMAGE_FILE_MACHINE_AMD64 ) {

        dprintf("Unsupported platform\n");
        if ( TargetMachine == IMAGE_FILE_MACHINE_IA64 ) {
            dprintf("Use !ivt on IA64\n");
        }

        return E_INVALIDARG;
    }

    INIT_API();

    GetCurrentProcessor(Client, &processor, NULL);

    Hr = g_ExtData->ReadProcessorSystemData(processor,
                                            DEBUG_DATA_KPCR_OFFSET,
                                            &Pkpcr,
                                            sizeof(Pkpcr),
                                            NULL);

    EXIT_API();

    if (Hr != S_OK)
    {
        dprintf("Cannot get PCR address\n");
        return E_INVALIDARG;
    }

    if (argsPresent = strlen(args) ? TRUE : FALSE) {
        currentIdt = endIdt = (UCHAR)strtoul(args, NULL, 16);
    } else {
        if (TargetMachine == IMAGE_FILE_MACHINE_AMD64) {
            currentIdt = 0;
        } else {
            currentIdt = 0x30;
        }
        endIdt     = 0xfe;
    }

    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {

        unexpectedStart = GetExpression("nt!KiStartUnexpectedRange");
        unexpectedEnd = GetExpression("nt!KiEndUnexpectedRange");

    } else if (TargetMachine == IMAGE_FILE_MACHINE_AMD64) {

        unexpectedStart = GetExpression("nt!KxUnexpectedInterrupt1");
        unexpectedEnd = GetExpression("nt!KxUnexpectedInterrupt255");
    }

    if (!unexpectedStart || !unexpectedEnd) {

        dprintf("\n\nCan't read kernel symbols.\n");
        return E_INVALIDARG;
    }

    dprintf("\nDumping IDT:\n\n");

    //
    // Find the offset of the Dispatch Code in the
    // interrupt object, so that we can simulate
    // a "CONTAINING_RECORD" later.
    //

    GetFieldOffset("nt!_KINTERRUPT", "DispatchCode", &DispatchCodeOffset);
    GetFieldOffset("nt!_KINTERRUPT", "InterruptListEntry", &ListEntryOffset);

    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {
        idtEntrySize = GetTypeSize("nt!_KIDTENTRY");
    } else if (TargetMachine == IMAGE_FILE_MACHINE_AMD64) {
        idtEntrySize = GetTypeSize("nt!_KIDTENTRY64");
    }

    interruptObjectType = (USHORT)GetExpression("val nt!InterruptObject");

    InitTypeRead(Pkpcr, nt!_KPCR);

    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {
        IdtAddress = ReadField(IDT);
    } else if (TargetMachine == IMAGE_FILE_MACHINE_AMD64) {
        IdtAddress = ReadField(IdtBase);
    }

    for (; currentIdt <= endIdt; currentIdt++) {

        Address = (ULONG64)(IdtAddress + (currentIdt * idtEntrySize));

        if (TargetMachine == IMAGE_FILE_MACHINE_I386) {

            InitTypeRead(Address, nt!_KIDTENTRY);

            Address = ReadField(ExtendedOffset) & 0xFFFFFFFF;
            Address <<= 16;

            Address |= ReadField(Offset) & 0xFFFF;
            Address |= 0xFFFFFFFF00000000;

        } else if (TargetMachine == IMAGE_FILE_MACHINE_AMD64) {

            InitTypeRead(Address, nt!_KIDTENTRY64);

            Address = ReadField(OffsetHigh) & 0xFFFFFFFF;
            Address <<= 16;

            Address |= ReadField(OffsetMiddle) & 0xFFFF;
            Address <<= 16;

            Address |= ReadField(OffsetLow) & 0xFFFF;
        }

        if (Address >= unexpectedStart && Address <= unexpectedEnd) {

            //
            // IDT entry contains "unexpected interrupt."  This
            // means that this vector isn't interesting.
            //

            if (argsPresent) {

                //
                // The user was specifying a specific vector.
                //
                dprintf("Vector %x not connected\n", currentIdt);
            }

            continue;
        }

        dprintf("\n%x:\n", currentIdt);

        //
        // Work backwards from the code to the containing interrupt
        // object.
        //

        Address -= DispatchCodeOffset;

        firstIntObj = Address;
        idtChainCount = 0;

        InitTypeRead(Address, nt!_KINTERRUPT);

        if (ReadField(Type) != interruptObjectType)
        {
            GetSymbol(Address + DispatchCodeOffset, buffer, &displacement);

            if (buffer[0] != '\0') {

                if (displacement != 0) {

                    dprintf("\t%s+0x%I64X\n", buffer, displacement);

                } else {

                    dprintf("\t%s\n", buffer);
                }

            } else {

                dprintf("\t%I64X\n", Address + DispatchCodeOffset);
            }

            continue;
        }

        while (TRUE) {

            GetSymbol(ReadField(ServiceRoutine), buffer, &displacement);

            if (buffer[0] != '\0') {

                if (displacement != 0) {

                    dprintf("\t%s+0x%I64X (%I64X)\n", buffer, displacement, Address);

                } else {

                    dprintf("\t%s (%I64X)\n", buffer, Address);
                }

            } else {

                dprintf("\t%I64X (%I64X)\n", ReadField(ServiceRoutine), Address);
            }

            InitTypeRead(ListEntryOffset + Address, nt!_LIST_ENTRY);

            flink = ReadField(Flink);
            if (flink == 0 ||
                flink == (firstIntObj + ListEntryOffset)) {

                break;
            }

            Address = flink - ListEntryOffset;

            InitTypeRead(Address, nt!_KINTERRUPT);

            if (CheckControlC()) {
                break;
            }

            if (idtChainCount++ > 50) {

                //
                // We are clearly going nowhere.
                //

                break;
            }
        }
     }

    dprintf("\n");
    return S_OK;
}

DECLARE_API( ivt )
{
    ULONG64 Pkpcr;
    ULONG64 Address;
    ULONG64 idtEntry;
    ULONG DispatchCodeOffset;
    ULONG ListEntryOffset;
    ULONG InterruptRoutineOffset;
    ULONG64 unexpectedInterrupt;
    ULONG64 chainedDispatch;
    ULONG64 currentInterruptAddress;
    ULONG64 PcrInterruptRoutineAddress;
    ULONG currentIdt, endIdt;
    BOOLEAN argsPresent = FALSE;
    ULONG64   firstIntObj;
    ULONG   idtEntrySize;
    CHAR    buffer[100];
    ULONG   processor;
    ULONG   idtChainCount;
    HRESULT Hr;
    ULONG64 displacement;
    ULONG   result;
    USHORT  interruptObjectType;

    if ( IMAGE_FILE_MACHINE_IA64 != TargetMachine) {
        dprintf("Don't know how to dump the IVT on anything but IA64, use !idt on x86\n");
        return E_INVALIDARG;
    }

    INIT_API();

    GetCurrentProcessor(Client, &processor, NULL);

    Hr = g_ExtData->ReadProcessorSystemData(processor,
                                            DEBUG_DATA_KPCR_OFFSET,
                                            &Pkpcr,
                                            sizeof(Pkpcr),
                                            NULL);

    EXIT_API();

    if (Hr != S_OK)
    {
        dprintf("Cannot get PCR address\n");
        return E_INVALIDARG;
    }

    unexpectedInterrupt = GetExpression("nt!KxUnexpectedInterrupt");

    if (unexpectedInterrupt == 0) {
        dprintf("\n\nCan't read kernel symbols.\n");
        return E_INVALIDARG;
    }

    chainedDispatch = GetExpression("nt!KiChainedDispatch");
    interruptObjectType = (USHORT)GetExpression("val nt!InterruptObject");

    GetFieldOffset("nt!_KINTERRUPT", "DispatchCode", &DispatchCodeOffset);
    GetFieldOffset("nt!_KINTERRUPT", "InterruptListEntry", &ListEntryOffset);
    GetFieldOffset("nt!_KPCR", "InterruptRoutine", &InterruptRoutineOffset);

    unexpectedInterrupt += DispatchCodeOffset;

    idtEntrySize = GetTypeSize("nt!PKINTERRUPT_ROUTINE");

    if (argsPresent = strlen(args) ? TRUE : FALSE) {

        currentIdt = endIdt = strtoul(args, NULL, 16);

        if (currentIdt >= MAXIMUM_IA64_VECTOR) {
            dprintf("\n\nInvalid argument \"%s\", maximum vector = %d\n", args, MAXIMUM_IA64_VECTOR);
            return E_INVALIDARG;
        }

    } else {

        currentIdt = 0;
        endIdt     = MAXIMUM_IA64_VECTOR - 1;
    }

    dprintf("\nDumping IA64 IVT:\n\n");

    PcrInterruptRoutineAddress = Pkpcr + InterruptRoutineOffset;

    for (; currentIdt <= endIdt; currentIdt++) {

        Address = (ULONG64)(PcrInterruptRoutineAddress + (currentIdt * idtEntrySize));

        if (!ReadMemory(Address, &idtEntry, sizeof(idtEntry), &result)) {

            dprintf( "Can't read entry for vector %02X at %p - result=%lu\n",
                     currentIdt, Address, result);
            break;
        }

        Address = idtEntry;

        if (Address == unexpectedInterrupt) {

            //
            // IDT entry contains "unexpected interrupt."  This
            // means that this vector isn't interesting.
            //

            if (argsPresent) {

                //
                // The user was specifying a specific vector.
                //
                dprintf("Vector %x not connected\n", currentIdt);
            }

            continue;
        }

        dprintf("\n%x:\n", currentIdt);

        //
        // Work backwards from the code to the containing interrupt
        // object.
        //

        Address -= DispatchCodeOffset;

        firstIntObj = Address;
        idtChainCount = 0;

        InitTypeRead(Address, nt!_KINTERRUPT);

        if (ReadField(Type) != interruptObjectType)
        {
            GetSymbol(Address + DispatchCodeOffset, buffer, &displacement);
            if (buffer[0] != '\0') {

                if (displacement != 0) {

                    dprintf("\t%s+0x%I64X\n", buffer, displacement);

                } else {

                    dprintf("\t%s\n", buffer);
                }

            } else {

                dprintf("\t%p\n", Address + DispatchCodeOffset);
            }

            continue;
        }

        while (TRUE) {

            GetSymbol(ReadField(ServiceRoutine), buffer, &displacement);
            if (buffer[0] != '\0') {

                if (displacement != 0) {

                    dprintf("\t%s+0x%I64X (%p)\n", buffer, displacement, Address);

                } else {

                    dprintf("\t%s (%p)\n", buffer, Address);
                }

            } else {

                dprintf("\t%p (%p)\n", ReadField(ServiceRoutine), Address);
            }

            if (ReadField(DispatchAddress) != chainedDispatch) {

                break;
            }

            InitTypeRead(ListEntryOffset + Address, nt!_LIST_ENTRY);

            if (ReadField(Flink) == (firstIntObj + ListEntryOffset)) {

                break;
            }

            Address = ReadField(Flink) - ListEntryOffset;

            InitTypeRead(Address, nt!_KINTERRUPT);

            if (CheckControlC()) {
                break;
            }

            if (idtChainCount++ > 50) {

                //
                // We are clearly going nowhere.
                //

                break;
            }
        }
    }

    dprintf("\n");

    return S_OK;
}


//
// MCA MSR architecture definitions
//

//
// MSR addresses for Pentium Style Machine Check Exception
//

#define MCE_MSR_MC_ADDR                 0x0
#define MCE_MSR_MC_TYPE                 0x1

//
// MSR addresses for Pentium Pro Style Machine Check Architecture
//

//
// Global capability, status and control register addresses
//

#define MCA_MSR_MCG_CAP             0x179
#define MCA_MSR_MCG_STATUS          0x17a
#define MCA_MSR_MCG_CTL             0x17b
#define MCA_MSR_MCG_EAX             0x180
#define MCA_MSR_MCG_EFLAGS          0x188
#define MCA_MSR_MCG_EIP             0x189

//
// Control, Status, Address, and Misc register address for
// bank 0. Other bank registers are at a stride of MCA_NUM_REGS
// from corresponding bank 0 register.
//

#define MCA_NUM_REGS                4

#define MCA_MSR_MC0_CTL             0x400
#define MCA_MSR_MC0_STATUS          0x401
#define MCA_MSR_MC0_ADDR            0x402
#define MCA_MSR_MC0_MISC            0x403

//
// Flags used to determine if the MCE or MCA feature is
// available. Used with HalpFeatureBits.
//

#define HAL_MCA_PRESENT         0x4
#define HAL_MCE_PRESENT         0x8

//
// Flags to decode errors in MCI_STATUS register of MCA banks
//

#define MCA_EC_NO_ERROR          0x0000
#define MCA_EC_UNCLASSIFIED      0x0001
#define MCA_EC_ROMPARITY         0x0002
#define MCA_EC_EXTERN            0x0003
#define MCA_EC_FRC               0x0004

#include "pshpack1.h"

//
// Global Machine Check Capability Register
//

typedef struct _MCA_MCG_CAPABILITY {
    union {
        struct {
            ULONG       McaCnt:8;
            ULONG       McaCntlPresent:1;
            ULONG       McaExtPresent:1;
            ULONG       Reserved_1: 6;
            ULONG       McaExtCnt: 8;
            ULONG       Reserved_2: 8;
            ULONG       Reserved_3;
        } hw;
        ULONGLONG       QuadPart;
    } u;
} MCA_MCG_CAPABILITY, *PMCA_MCG_CAPABILITY;

//
// Global Machine Check Status Register
//

typedef struct _MCA_MCG_STATUS {
    union {
        struct {
            ULONG       RestartIPValid:1;
            ULONG       ErrorIPValid:1;
            ULONG       McCheckInProgress:1;
            ULONG       Reserved_1:29;
            ULONG       Reserved_2;
        } hw;

        ULONGLONG       QuadPart;
    } u;
} MCA_MCG_STATUS, *PMCA_MCG_STATUS;

//
// MCA COD field in status register for interpreting errors
//

typedef struct _MCA_COD {
    union {
        struct {
            USHORT  Level:2;
            USHORT  Type:2;
            USHORT  Request:4;
            USHORT  BusErrInfo:4;
            USHORT  Other:4;
        } hw;

        USHORT ShortPart;
    } u;
} MCA_COD, *PMCA_COD;

//
// STATUS register for each MCA bank.
//

typedef struct _MCA_MCI_STATUS {
    union {
        struct {
            MCA_COD     McaCod;
            USHORT      MsCod;
            ULONG       OtherInfo:25;
            ULONG       Damage:1;
            ULONG       AddressValid:1;
            ULONG       MiscValid:1;
            ULONG       Enabled:1;
            ULONG       UnCorrected:1;
            ULONG       OverFlow:1;
            ULONG       Valid:1;
        } hw;
        ULONGLONG       QuadPart;
    } u;
} MCA_MCI_STATUS, *PMCA_MCI_STATUS;

//
// ADDR register for each MCA bank
//

typedef struct _MCA_MCI_ADDR{
    union {
        struct {
            ULONG Address;
            ULONG Reserved;
        } hw;
        ULONGLONG       QuadPart;
    } u;
} MCA_MCI_ADDR, *PMCA_MCI_ADDR;

#include "poppack.h"

//
// Machine Check Error Description
//

// Any Reserved/Generic entry

CHAR Reserved[] = "Reserved";
CHAR Generic[] = "Generic";

// Transaction Types

CHAR TransInstruction[] = "Instruction";
CHAR TransData[] = "Data";

static CHAR *TransType[] = {TransInstruction,
                            TransData,
                            Generic,
                            Reserved
                            };

// Level Encodings

CHAR Level0[] = "Level 0";
CHAR Level1[] = "Level 1";
CHAR Level2[] = "Level 2";

static CHAR *Level[] = {
                        Level0,
                        Level1,
                        Level2,
                        Generic
                        };

// Request Encodings

CHAR ReqGenericRead[]  = "Generic Read";
CHAR ReqGenericWrite[] = "Generic Write";
CHAR ReqDataRead[]     = "Data Read";
CHAR ReqDataWrite[]    = "Data Write";
CHAR ReqInstrFetch[]   = "Instruction Fetch";
CHAR ReqPrefetch[]     = "Prefetch";
CHAR ReqEviction[]     = "Eviction";
CHAR ReqSnoop[]        = "Snoop";

static CHAR *Request[] = {
                          Generic,
                          ReqGenericRead,
                          ReqGenericWrite,
                          ReqDataRead,
                          ReqDataWrite,
                          ReqInstrFetch,
                          ReqPrefetch,
                          ReqEviction,
                          ReqSnoop,
                          Reserved,
                          Reserved,
                          Reserved,
                          Reserved,
                          Reserved,
                          Reserved,
                          Reserved
                          };

// Memory Hierarchy Error Encodings

CHAR MemHierMemAccess[] = "Memory Access";
CHAR MemHierIO[]        = "I/O";
CHAR MemHierOther[]     = "Other Transaction";

static CHAR *MemoryHierarchy[] = {
                                  MemHierMemAccess,
                                  Reserved,
                                  MemHierIO,
                                  MemHierOther
                                };

// Time Out Status

CHAR TimeOut[] = "Timed Out";
CHAR NoTimeOut[] = "Did Not Time Out";

static CHAR *TimeOutCode[] = {
                          NoTimeOut,
                          TimeOut
                          };

// Participation Status

CHAR PartSource[] = "Source";
CHAR PartResponds[] = "Responds";
CHAR PartObserver[] = "Observer";

static CHAR *ParticipCode[] = {
                                PartSource,
                                PartResponds,
                                PartObserver,
                                Generic
                              };

//
// Register names for registers starting at MCA_MSR_MCG_EAX
//

char *RegNames[] = {
    "eax", "ebx", "ecx", "edx", "esi", "edi", "ebp", "esp",
    "eflags", "eip", "misc"
};

VOID
DecodeError (
    IN MCA_MCI_STATUS MciStatus
    )
/*++

Routine Description:

    Decode the machine check error logged to the status register
    Model specific errors are not decoded.

Arguments:

    MciStatus: Contents of Machine Check Status register

Return Value:

    None

--*/
{
    MCA_COD McaCod;

    McaCod = MciStatus.u.hw.McaCod;

    //
    // Decode Errors: First identify simple errors and then
    // handle compound errors as default case
    //

    switch(McaCod.u.ShortPart) {
        case MCA_EC_NO_ERROR:
            dprintf("\t\tNo Error\n");
            break;

        case MCA_EC_UNCLASSIFIED:
            dprintf("\t\tUnclassified Error\n");
            break;

        case MCA_EC_ROMPARITY:
            dprintf("\t\tMicrocode ROM Parity Error\n");
            break;

        case MCA_EC_EXTERN:
            dprintf("\t\tExternal Error\n");
            break;

        case MCA_EC_FRC:
            dprintf("\t\tFRC Error\n");
            break;

        default:        // check for complex error conditions

            if (McaCod.u.hw.BusErrInfo == 0x4) {
                dprintf("\t\tInternal Unclassified Error\n");
            } else if (McaCod.u.hw.BusErrInfo == 0) {

                // TLB Unit Error

                dprintf("\t\t%s TLB %s Error\n",
                         TransType[McaCod.u.hw.Type],
                         Level[McaCod.u.hw.Level]);

            } else if (McaCod.u.hw.BusErrInfo == 1) {

                // Memory Unit Error

                dprintf("\t\t%s Cache %s %s Error\n",
                        TransType[McaCod.u.hw.Type],
                        Level[McaCod.u.hw.Level],
                        Request[McaCod.u.hw.Request]);
            } else if (McaCod.u.hw.BusErrInfo >= 8) {

                // Bus/Interconnect Error

                dprintf("\t\tBus %s, Local Processor: %s, %s Error\n",
                        Level[McaCod.u.hw.Level],
                        ParticipCode[((McaCod.u.hw.BusErrInfo & 0x6)>>1)],
                        Request[McaCod.u.hw.Request]);
                dprintf("%s Request %s\n",
                        MemoryHierarchy[McaCod.u.hw.Type],
                        TimeOutCode[McaCod.u.hw.BusErrInfo & 0x1]);
            } else {
                dprintf("\t\tUnresolved compound error code\n");
            }
            break;
    }
}

HRESULT
McaX86(
   PCSTR     args
    )
/*++

Routine Description:

    Dumps X86 processors machine check architecture registers
    and interprets any logged errors

Arguments:

    args

Return Value:

    HRESULT

--*/
{
    MCA_MCG_CAPABILITY  Capabilities;
    MCA_MCG_STATUS      McgStatus;
    MCA_MCI_STATUS      MciStatus;
    MCA_MCI_ADDR        MciAddress;
    ULONGLONG           MciControl;
    ULONGLONG           MciMisc;
    ULONG               Index,i;
    PUCHAR              p;
    ULONG               FeatureBits = 0;
    ULONG               Cr4Value;
    BOOLEAN             Cr4MCEnabled = FALSE;
    BOOLEAN             RegsValid = FALSE;
    ULONGLONG           MachineCheckAddress, MachineCheckType;
    ULARGE_INTEGER      RegValue;

    //
    // Quick sanity check for Machine Check availability.
    // Support included for both Pentium Style MCE and Pentium
    // Pro Style MCA.
    //

    i = (ULONG) GetExpression(args);

    if (i != 1) {
        i = (ULONG) GetExpression("hal!HalpFeatureBits");
        if (!i) {
            dprintf ("HalpFeatureBits not found\n");
            return E_INVALIDARG;
        }

        FeatureBits = 0;
        ReadMemory(i, &FeatureBits, sizeof(i), &i);
        if (FeatureBits == -1  ||
            (!(FeatureBits & HAL_MCA_PRESENT) &&
             !(FeatureBits & HAL_MCE_PRESENT))) {
            dprintf ("Machine Check feature not present\n");
            return E_INVALIDARG;
        }
    }

    //
    // Read cr4 to determine if CR4.MCE is enabled.
    // This enables the Machine Check exception reporting
    //

    Cr4Value = (ULONG) GetExpression("@Cr4");
    if (Cr4Value & CR4_MCE_X86) {
        Cr4MCEnabled = TRUE;
    }

    if (FeatureBits & HAL_MCE_PRESENT) {

        // Read P5_MC_ADDR Register and P5_MC_TYPE Register

        ReadMsr(MCE_MSR_MC_ADDR, &MachineCheckAddress);
        ReadMsr(MCE_MSR_MC_TYPE, &MachineCheckType);

        dprintf ("MCE: %s, Cycle Address: 0x%.8x%.8x, Type: 0x%.8x%.8x\n\n",
                (Cr4MCEnabled ? "Enabled" : "Disabled"),
                (ULONG)(MachineCheckAddress >> 32),
                (ULONG)(MachineCheckAddress),
                (ULONG)(MachineCheckType >> 32),
                (ULONG)(MachineCheckType));
    }

    Capabilities.u.QuadPart = (ULONGLONG)0;
    if (FeatureBits & HAL_MCA_PRESENT) {

        //
        // Dump MCA registers
        //

        ReadMsr(MCA_MSR_MCG_CAP, &Capabilities.u.QuadPart);
        ReadMsr(MCA_MSR_MCG_STATUS, &McgStatus.u.QuadPart);

        dprintf ("MCA: %s, Banks %d, Control Reg: %s, Machine Check: %s.\n",
                 (Cr4MCEnabled ? "Enabled" : "Disabled"),
                 Capabilities.u.hw.McaCnt,
                 Capabilities.u.hw.McaCntlPresent ? "Supported" : "Not Supported",
                 McgStatus.u.hw.McCheckInProgress ? "In Progress" : "None"
        );

       if (McgStatus.u.hw.McCheckInProgress && McgStatus.u.hw.ErrorIPValid) {
        dprintf ("MCA: Error IP Valid\n");
        }

       if (McgStatus.u.hw.McCheckInProgress && McgStatus.u.hw.RestartIPValid) {
        dprintf ("MCA: Restart IP Valid\n");
        }

        //
        // Scan all the banks to check if any machines checks have been
        // logged and decode the errors if any.
        //

        dprintf ("Bank  Error  Control Register     Status Register\n");
        for (Index=0; Index < (ULONG) Capabilities.u.hw.McaCnt; Index++) {

            ReadMsr(MCA_MSR_MC0_CTL+MCA_NUM_REGS*Index, &MciControl);
            ReadMsr(MCA_MSR_MC0_STATUS+MCA_NUM_REGS*Index, &MciStatus.u.QuadPart);

            dprintf (" %2d.  %s  0x%.8x%.8x   0x%.8x%.8x\n",
                        Index,
                        (MciStatus.u.hw.Valid ? "Valid" : "None "),
                        (ULONG) (MciControl >> 32),
                        (ULONG) (MciControl),
                        (ULONG) (MciStatus.u.QuadPart>>32),
                        (ULONG) (MciStatus.u.QuadPart)
                        );

            if (MciStatus.u.hw.Valid) {
                DecodeError(MciStatus);
            }

            if (MciStatus.u.hw.AddressValid) {
                ReadMsr(MCA_MSR_MC0_ADDR+MCA_NUM_REGS*Index, &MciAddress.u.QuadPart);
                dprintf ("\t\tAddress Reg 0x%.8x%.8x ",
                            (ULONG) (MciAddress.u.QuadPart>>32),
                            (ULONG) (MciAddress.u.QuadPart)
                        );
            }

            if (MciStatus.u.hw.MiscValid) {
                ReadMsr(MCA_MSR_MC0_MISC+MCA_NUM_REGS*Index, &MciMisc);
                dprintf ("\t\tMisc Reg 0x%.8x%.8x ",
                            (ULONG) (MciMisc >> 32),
                            (ULONG) (MciMisc)
                        );
                }
            dprintf("\n");
        }
    }

    if (Capabilities.u.hw.McaExtPresent && Capabilities.u.hw.McaExtCnt) {

        dprintf ("Registers Saved: %d.", Capabilities.u.hw.McaExtCnt);

        RegsValid = FALSE;
        for (i = 0; i < Capabilities.u.hw.McaExtCnt; i++) {
            if (i % 2 == 0) {
                dprintf("\n");
            }

            ReadMsr(MCA_MSR_MCG_EAX+i, &RegValue.QuadPart);

            if ((i == MCA_MSR_MCG_EFLAGS-MCA_MSR_MCG_EAX) && RegValue.LowPart) {
                RegsValid = TRUE;
            }

            if (i < sizeof(RegNames)/sizeof(RegNames[0])) {
                dprintf("%7s: 0x%08x 0x%08x", RegNames[i], RegValue.HighPart, RegValue.LowPart);
            } else {
                dprintf("  Reg%02d: 0x%08x 0x%08x", i, RegValue.HighPart, RegValue.LowPart);
            }
        }
        dprintf("\n");

        if (!RegsValid) {
            dprintf("(Register state does not appear to be valid.)\n");
        }

        dprintf("\n");
    } else {
        dprintf("No register state available.\n\n");
    }

    return S_OK;

} // McaX86()

#define ERROR_RECORD_HEADER_FORMAT_IA64 \
             "MCA Error Record Header @ 0x%I64x 0x%I64x\n"  \
             "\tId        : 0x%I64x\n"              \
             "\tRevision  : 0x%x\n"                 \
             "\t\tMajor : %x\n"                     \
             "\t\tMinor : %x\n"                     \
             "\tSeverity  : 0x%x [%s]\n"            \
             "\tValid     : 0x%x\n"                 \
             "\t\tPlatformId: %x\n"                 \
             "\tLength    : 0x%x\n"                 \
             "\tTimeStamp : 0x%I64x\n"              \
             "\t\tSeconds: %x\n"                    \
             "\t\tMinutes: %x\n"                    \
             "\t\tHours  : %x\n"                    \
             "\t\tDay    : %x\n"                    \
             "\t\tMonth  : %x\n"                    \
             "\t\tYear   : %x\n"                    \
             "\t\tCentury: %x\n"                    \
             "\tPlatformId: %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\n" \
             "%s\n\n"

#define ERROR_SECTION_HEADER_FORMAT_IA64 \
             "MCA Error Section Header @ 0x%I64x 0x%I64x\n" \
             "\t%08X-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X [%s]\n" \
             "\tRevision    : 0x%x\n"               \
             "\t\tMajor : %x\n"                     \
             "\t\tMinor : %x\n"                     \
             "\tRecoveryInfo: 0x%x\n"               \
             "\t\tCorrected   : %x\n"               \
             "\t\tNotContained: %x\n"               \
             "\t\tReset       : %x\n"               \
             "\t\tReserved    : %x\n"               \
             "\t\tValid       : %x\n"               \
             "\tReserved    : 0x%x\n"               \
             "\tLength      : 0x%x\n"

#define ERROR_PROCESSOR_FORMAT_IA64 \
             "\tValid         : 0x%I64x\n" \
             "\t\tErrorMap        : %x\n"  \
             "\t\tStateParameter  : %x\n"  \
             "\t\tCRLid           : %x\n"  \
             "\t\tStaticStruct    : %x\n"  \
             "\t\tCacheCheckNum   : %x\n"  \
             "\t\tTlbCheckNum     : %x\n"  \
             "\t\tBusCheckNum     : %x\n"  \
             "\t\tRegFileCheckNum : %x\n"  \
             "\t\tMsCheckNum      : %x\n"  \
             "\t\tCpuIdInfo       : %x\n"  \
             "\t\tReserved        : %I64x\n"

#define ERROR_PROCESSOR_ERROR_MAP_FORMAT_IA64 \
             "\tErrorMap      : 0x%I64x\n" \
             "\t\tCid             : %x\n"  \
             "\t\tTid             : %x\n"  \
             "\t\tEic             : %x\n"  \
             "\t\tEdc             : %x\n"  \
             "\t\tEit             : %x\n"  \
             "\t\tEdt             : %x\n"  \
             "\t\tEbh             : %x\n"  \
             "\t\tErf             : %x\n"  \
             "\t\tEms             : %x\n"  \
             "\t\tReserved        : %x\n"

#define ERROR_MODINFO_FORMAT_IA64 \
             "\t%s[%ld]:\n" \
             "\t\tValid      : 0x%I64x\n" \
             "\t\t\tCheckInfo          : %x\n"  \
             "\t\t\tRequestorIdentifier: %x\n"  \
             "\t\t\tResponderIdentifier: %x\n"  \
             "\t\t\tTargetIdentifier   : %x\n"  \
             "\t\t\tPreciseIP          : %x\n"  \
             "\t\t\tReserved           : %I64x\n"  \
             "\t\tCheckInfo  : 0x%I64x\n" \
             "\t\tRequestedId: 0x%I64x\n" \
             "\t\tResponderId: 0x%I64x\n" \
             "\t\tTargetId   : 0x%I64x\n" \
             "\t\tPreciseIP  : 0x%I64x\n"

#define ERROR_PROCESSOR_CPUID_INFO_FORMAT_IA64 \
             "\t\tCpuId0  : 0x%I64x\n" \
             "\t\tCpuId1  : 0x%I64x\n" \
             "\t\tCpuId2  : 0x%I64x\n" \
             "\t\tCpuId3  : 0x%I64x\n" \
             "\t\tCpuId4  : 0x%I64x\n" \
             "\t\tReserved: 0x%I64x\n"

#define ERROR_PROCESSOR_STATIC_INFO_FORMAT_IA64 \
             "\t\tValid      : 0x%I64x\n" \
             "\t\t\tMinState: %x\n"  \
             "\t\t\tBRs     : %x\n"  \
             "\t\t\tCRs     : %x\n"  \
             "\t\t\tARs     : %x\n"  \
             "\t\t\tRRs     : %x\n"  \
             "\t\t\tFRs     : %x\n"  \
             "\t\t\tReserved: %I64x\n"

#define ERROR_PLATFORM_SPECIFIC_FORMAT_IA64 \
             "\tValid           : 0x%I64x\n" \
             "\t\tErrorStatus     : %x\n"  \
             "\t\tRequestorId     : %x\n"  \
             "\t\tResponderId     : %x\n"  \
             "\t\tTargetId        : %x\n"  \
             "\t\tBusSpecificData : %x\n"  \
             "\t\tOemId           : %x\n"  \
             "\t\tOemData         : %x\n"  \
             "\t\tOemDevicePath   : %x\n"  \
             "\t\tReserved        : %I64x\n" \
             "\tErrorStatus     : 0x%I64x\n" \
             "\tRequestorId     : 0x%I64x\n" \
             "\tResponderId     : 0x%I64x\n" \
             "\tTargetId        : 0x%I64x\n" \
             "\tBusSpecificData : 0x%I64x\n" 

typedef enum _ERROR_SECTION_HEADER_TYPE_IA64 {
    ERROR_SECTION_UNKNOWN   = 0,
    ERROR_SECTION_PROCESSOR,
    ERROR_SECTION_MEMORY,
    ERROR_SECTION_PCI_BUS,
    ERROR_SECTION_PCI_COMPONENT,
    ERROR_SECTION_SYSTEM_EVENT_LOG,
    ERROR_SECTION_SMBIOS,
    ERROR_SECTION_PLATFORM_SPECIFIC,
    ERROR_SECTION_PLATFORM_BUS,
    ERROR_SECTION_PLATFORM_HOST_CONTROLLER,
} ERROR_SECTION_HEADER_TYPE_IA64;

ERROR_DEVICE_GUID_IA64 gErrorProcessorGuid              = ERROR_PROCESSOR_GUID_IA64;
ERROR_DEVICE_GUID_IA64 gErrorMemoryGuid                 = ERROR_MEMORY_GUID_IA64;
ERROR_DEVICE_GUID_IA64 gErrorPciBusGuid                 = ERROR_PCI_BUS_GUID_IA64;
ERROR_DEVICE_GUID_IA64 gErrorPciComponentGuid           = ERROR_PCI_COMPONENT_GUID_IA64;
ERROR_DEVICE_GUID_IA64 gErrorSystemEventLogGuid         = ERROR_SYSTEM_EVENT_LOG_GUID_IA64;
ERROR_DEVICE_GUID_IA64 gErrorSmbiosGuid                 = ERROR_SMBIOS_GUID_IA64;
ERROR_DEVICE_GUID_IA64 gErrorPlatformSpecificGuid       = ERROR_PLATFORM_SPECIFIC_GUID_IA64;
ERROR_DEVICE_GUID_IA64 gErrorPlatformBusGuid            = ERROR_PLATFORM_BUS_GUID_IA64;
ERROR_DEVICE_GUID_IA64 gErrorPlatformHostControllerGuid = ERROR_PLATFORM_HOST_CONTROLLER_GUID_IA64;

//
// _HALP_SAL_PAL_DATA.Flags definitions
// <extracted from i64fw.h>
//

#ifndef HALP_SALPAL_FIX_MCE_LOG_ID
#define HALP_SALPAL_FIX_MCE_LOG_ID                   0x1
#define HALP_SALPAL_MCE_PROCESSOR_CPUIDINFO_OMITTED  0x2
#define HALP_SALPAL_MCE_PROCESSOR_STATICINFO_PARTIAL 0x4
#endif  // !HALP_SALPAL_FIX_MCE_LOG_ID

USHORT gHalpSalPalDataFlags = 0;

VOID
ExecCommand(
   IN PCSTR Cmd
   )
{
    if (g_ExtClient && (ExtQuery(g_ExtClient) == S_OK)) {
          g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT, Cmd, DEBUG_EXECUTE_DEFAULT );
    }
} // ExecCommand()

BOOLEAN /* TRUE: Error was found, FALSE: successful */
SetErrorDeviceGuid(
    PCSTR                    DeviceGuidString,
    PERROR_DEVICE_GUID_IA64  DeviceGuid,
    BOOLEAN                  ErrorType
    )
{
    ULONG64 guidAddress;

    guidAddress = GetExpression( DeviceGuidString );
    if ( guidAddress && !ErrorType ) {
        //
        // WARNING: the following code assumes ERROR_DEVICE_GUID will not change
        //          its definition and is identical to ERROR_DEVICE_GUID_IA64.
        //
        ERROR_DEVICE_GUID_IA64 devGuid;
        ULONG cbRead;

        if ( ReadMemory( guidAddress, &devGuid, sizeof(devGuid), &cbRead ) &&
             (cbRead == sizeof(devGuid)) ) {
            *DeviceGuid = devGuid;
            return FALSE;
        }
        dprintf("%s memory-read failed", DeviceGuidString );
    }
    else  {
        dprintf("%s not found", DeviceGuidString );
    }

    dprintf(": using known Error Device GUID...\n");
    return TRUE;

} // SetErrorDeviceGuid()

VOID
SetErrorDeviceGuids(
    VOID
    )
{
    ULONG64 guidAddress;
    BOOLEAN errorFound;
    BOOLEAN errorType;
    ULONG   errorDeviceGuidSize;

    errorFound = FALSE;
    errorType  = FALSE;

    //
    // WARNING: the following code assumes the ERROR_DEVICE_GUID definition will not change
    //          and is identical to ERROR_DEVICE_GUID_IA64.
    //

    errorDeviceGuidSize = GetTypeSize( "hal!_ERROR_DEVICE_GUID" );
    if ( errorDeviceGuidSize == 0 ) {
        // pre-SAL 3.0 check-in hal
        errorType = TRUE;
    }
    else if ( errorDeviceGuidSize != sizeof( ERROR_DEVICE_GUID_IA64 ) )  {
        errorType = TRUE;
        dprintf("!mca: ERROR_DEVICE_GUID invalid definition...\n");
    }

    //
    // Initialize extension-global Error Device Guids.
    //

    errorFound |= SetErrorDeviceGuid("hal!HalpErrorProcessorGuid", &gErrorProcessorGuid,errorType);
    errorFound |= SetErrorDeviceGuid("hal!HalpErrorMemoryGuid", &gErrorMemoryGuid,errorType);
    errorFound |= SetErrorDeviceGuid("hal!HalpErrorPciBusGuid", &gErrorPciBusGuid,errorType);
    errorFound |= SetErrorDeviceGuid("hal!HalpErrorPciComponentGuid", &gErrorPciComponentGuid,errorType);
    errorFound |= SetErrorDeviceGuid("hal!HalpErrorSystemEventLogGuid", &gErrorSystemEventLogGuid,errorType);
    errorFound |= SetErrorDeviceGuid("hal!HalpErrorSmbiosGuid", &gErrorSmbiosGuid,errorType);
    errorFound |= SetErrorDeviceGuid("hal!HalpErrorPlatformSpecificGuid", &gErrorPlatformSpecificGuid,errorType);
    errorFound |= SetErrorDeviceGuid("hal!HalpErrorPlatformBusGuid", &gErrorPlatformBusGuid,errorType);
    errorFound |= SetErrorDeviceGuid("hal!HalpErrorPlatformHostControllerGuid", &gErrorPlatformHostControllerGuid,errorType);

    if ( errorFound )   {
        dprintf("\n");
    }

    return;

} // SetErrorDeviceGuids()

typedef struct _TYPED_SYMBOL_HANDLE  {
    ULONG64 Module;
    ULONG   TypeId;
    ULONG   Spare;
    BOOLEAN Found;
    CHAR    Name[MAX_PATH];
} TYPED_SYMBOL_HANDLE, *PTYPED_SYMBOL_HANDLE;

__inline
VOID
InitTypedSymbol(
    PTYPED_SYMBOL_HANDLE Handle,
    ULONG64              Module,
    ULONG                TypeId,
    BOOLEAN              Found
    )
{
    Handle->Module  = Module;
    Handle->TypeId  = TypeId;
    Handle->Found   = Found;
    Handle->Name[0] = '\0';
    return;
} // InitTypedSymbol()

__inline
BOOLEAN
IsTypedSymbolFound(
    PTYPED_SYMBOL_HANDLE Handle
    )
{
    return Handle->Found;
} // IsTypedSymbolFound()

__inline
HRESULT
GetTypedSymbolName(
    PTYPED_SYMBOL_HANDLE Handle,
    ULONG64              Value
    )
{
    HRESULT hr;
    if ( !IsTypedSymbolFound( Handle ) )    {
        return E_INVALIDARG;
    }
    return( g_ExtSymbols->GetConstantName( Handle->Module,
                                       Handle->TypeId,
                                       Value,
                                       Handle->Name,
                                       sizeof(Handle->Name),
                                       NULL) );
} // GetTypedSymbolName()

TYPED_SYMBOL_HANDLE gErrorSeverity;

#if 0
VOID
SetErrorSeverityValues(
    VOID
    )
{
    HRESULT hr;
    ULONG   typeId;
    ULONG64 module;

    hr = g_ExtSymbols->GetSymbolTypeId("hal!_ERROR_SEVERITY_VALUE", &typeId, &module);
    if ( SUCCEEDED(hr) )    {
        InitTypedSymbol( &gErrorSeverity, module, typeId, TRUE );
    }
    return;
} // SetErrorSeverityValues()
#endif 

__inline
VOID
SetTypedSymbol(
    PTYPED_SYMBOL_HANDLE Handle,
    PCSTR                Symbol
    )
{
    HRESULT hr;
    ULONG   typeId;
    ULONG64 module;

    hr = g_ExtSymbols->GetSymbolTypeId( Symbol, &typeId, &module);
    if ( SUCCEEDED(hr) )    {
        InitTypedSymbol( Handle, module, typeId, TRUE );
    }
    return;
} // SetTypedSymbol()

#define SetErrorTypedSymbol( _Handle, _Symbol ) SetTypedSymbol( &(_Handle), #_Symbol )

#define SetErrorSeverityValues() SetErrorTypedSymbol( gErrorSeverity, hal!_ERROR_SEVERITY_VALUE )

PCSTR
ErrorSeverityValueString(
    ULONG SeverityValue
    )
{
    HRESULT hr;

    hr = GetTypedSymbolName( &gErrorSeverity, SeverityValue );
    if ( SUCCEEDED( hr ) )  {
       return gErrorSeverity.Name;
    }

    //
    // Fall back to known values...
    //

    switch( SeverityValue ) {
        case ErrorRecoverable_IA64:
            return("ErrorRecoverable");

        case ErrorFatal_IA64:
            return("ErrorFatal");

        case ErrorCorrected_IA64:
            return("ErrorCorrected");

        default:
            return("ErrorOthers");
    }

} // ErrorSeverityValueString()

BOOLEAN
CompareTypedErrorDeviceGuid(
    PERROR_DEVICE_GUID_IA64 RefGuid
    )
{
    if ( ( RefGuid->Data1    == (ULONG)  ReadField(Guid.Data1) ) &&
         ( RefGuid->Data2    == (USHORT) ReadField(Guid.Data2) ) &&
         ( RefGuid->Data3    == (USHORT) ReadField(Guid.Data3) ) &&
         ( RefGuid->Data4[0] == (UCHAR)  ReadField(Guid.Data4[0]) ) &&
         ( RefGuid->Data4[1] == (UCHAR)  ReadField(Guid.Data4[1]) ) &&
         ( RefGuid->Data4[2] == (UCHAR)  ReadField(Guid.Data4[2]) ) &&
         ( RefGuid->Data4[3] == (UCHAR)  ReadField(Guid.Data4[3]) ) &&
         ( RefGuid->Data4[4] == (UCHAR)  ReadField(Guid.Data4[4]) ) &&
         ( RefGuid->Data4[5] == (UCHAR)  ReadField(Guid.Data4[5]) ) &&
         ( RefGuid->Data4[6] == (UCHAR)  ReadField(Guid.Data4[6]) ) &&
         ( RefGuid->Data4[7] == (UCHAR)  ReadField(Guid.Data4[7]) ) )   {
        return TRUE;
    }

    return FALSE;

} // CompareTypedErrorDeviceGuid()

UCHAR gZeroedOemPlatformId[16] = { 0 };

BOOLEAN
CompareTypedOemPlatformId(
    UCHAR RefOemPlatformId[]
    )
{
    ULONG i;

    for ( i = 0; i < 16; i++ )  {
        if (RefOemPlatformId[i] != (UCHAR) ReadField(OemPlatformId[i]) )    {
            return FALSE;
        }
    }
    return TRUE;
} // CompareTypedOemPlatformId()

ERROR_SECTION_HEADER_TYPE_IA64
GetTypedErrorSectionType(
    VOID
    )
{
    if ( CompareTypedErrorDeviceGuid( &gErrorProcessorGuid ) )  {
        return ERROR_SECTION_PROCESSOR;
    }
    if ( CompareTypedErrorDeviceGuid( &gErrorMemoryGuid ) )  {
        return ERROR_SECTION_MEMORY;
    }
    if ( CompareTypedErrorDeviceGuid( &gErrorPciBusGuid ) )  {
        return ERROR_SECTION_PCI_BUS;
    }
    if ( CompareTypedErrorDeviceGuid( &gErrorPciComponentGuid ) )  {
        return ERROR_SECTION_PCI_COMPONENT;
    }
    if ( CompareTypedErrorDeviceGuid( &gErrorSystemEventLogGuid ) )  {
        return ERROR_SECTION_SYSTEM_EVENT_LOG;
    }
    if ( CompareTypedErrorDeviceGuid( &gErrorSmbiosGuid ) )  {
        return ERROR_SECTION_SMBIOS;
    }
    if ( CompareTypedErrorDeviceGuid( &gErrorPlatformSpecificGuid ) )  {
        return ERROR_SECTION_PLATFORM_SPECIFIC;
    }
    if ( CompareTypedErrorDeviceGuid( &gErrorPlatformBusGuid ) )  {
        return ERROR_SECTION_PLATFORM_BUS;
    }
    if ( CompareTypedErrorDeviceGuid( &gErrorPlatformHostControllerGuid ) )  {
        return ERROR_SECTION_PLATFORM_HOST_CONTROLLER;
    }

    return ERROR_SECTION_UNKNOWN;

} // GetTypedErrorSectionType()

PCSTR
ErrorSectionTypeString(
    ERROR_SECTION_HEADER_TYPE_IA64 ErrorSectionType
    )
{
    switch( ErrorSectionType )  {
        case ERROR_SECTION_PROCESSOR:
            return( "Processor" );
        case ERROR_SECTION_MEMORY:
            return( "Memory" );
        case ERROR_SECTION_PCI_BUS:
            return( "PciBus" );
        case ERROR_SECTION_PCI_COMPONENT:
            return( "PciComponent" );
        case ERROR_SECTION_SYSTEM_EVENT_LOG:
            return( "SystemEventLog" );
        case ERROR_SECTION_SMBIOS:
            return( "Smbios" );
        case ERROR_SECTION_PLATFORM_SPECIFIC:
            return( "PlatformSpecific" );
        case ERROR_SECTION_PLATFORM_BUS:
            return( "PlatformBus" );
        case ERROR_SECTION_PLATFORM_HOST_CONTROLLER:
            return( "PlatformHostController" );
        default:
            return( "Unknown Error Device" );
    }

} // ErrorSectionTypeString()

VOID
DumpIa64ErrorRecordHeader(
   PERROR_RECORD_HEADER_IA64 Header,
   ULONG64                   HeaderAddress
   )
{
    ULONG errorSeverity;

    errorSeverity = Header->ErrorSeverity;
    dprintf( ERROR_RECORD_HEADER_FORMAT_IA64,
             (ULONGLONG) HeaderAddress, (HeaderAddress + (ULONG64)Header->Length),
             (ULONGLONG) Header->Id,
             (ULONG)     Header->Revision.Revision,
             (ULONG)     Header->Revision.Major, (ULONG) Header->Revision.Minor,
                         errorSeverity, ErrorSeverityValueString( errorSeverity ),
             (ULONG)     Header->Valid.Valid,
             (ULONG)     Header->Valid.OemPlatformID,
             (ULONG)     Header->Length,
             (ULONGLONG) Header->TimeStamp.TimeStamp,
             (ULONG)     Header->TimeStamp.Seconds,
             (ULONG)     Header->TimeStamp.Minutes,
             (ULONG)     Header->TimeStamp.Hours,
             (ULONG)     Header->TimeStamp.Day,
             (ULONG)     Header->TimeStamp.Month,
             (ULONG)     Header->TimeStamp.Year,
             (ULONG)     Header->TimeStamp.Century,
             (ULONG)     ReadField(OemPlatformId[0x0]),
             (ULONG)     ReadField(OemPlatformId[0x1]),
             (ULONG)     ReadField(OemPlatformId[0x2]),
             (ULONG)     ReadField(OemPlatformId[0x3]),
             (ULONG)     ReadField(OemPlatformId[0x4]),
             (ULONG)     ReadField(OemPlatformId[0x5]),
             (ULONG)     ReadField(OemPlatformId[0x6]),
             (ULONG)     ReadField(OemPlatformId[0x7]),
             (ULONG)     ReadField(OemPlatformId[0x8]),
             (ULONG)     ReadField(OemPlatformId[0x9]),
             (ULONG)     ReadField(OemPlatformId[0xa]),
             (ULONG)     ReadField(OemPlatformId[0xb]),
             (ULONG)     ReadField(OemPlatformId[0xc]),
             (ULONG)     ReadField(OemPlatformId[0xd]),
             (ULONG)     ReadField(OemPlatformId[0xe]),
             (ULONG)     ReadField(OemPlatformId[0xf]),
             ""
            );

    return;

} // DumpIa64ErrorRecordHeader()

ULONG64
DtErrorModInfos(
    ULONG64 ModInfo,
    ULONG   CheckNum,
    ULONG   ModInfoSize,
    PCSTR   ModInfoName
    )
{
    ULONG64            modInfo;
    ULONG              modInfoSize;
    ULONG64            modInfoMax;
    ERROR_MODINFO_IA64 modInfoStruct;
    ULONG              modInfoNum;

    modInfo     = ModInfo;
    modInfoSize = ModInfoSize ? ModInfoSize : sizeof(modInfoStruct);
    modInfoMax  = modInfo + (CheckNum * modInfoSize);
    modInfoNum  = 0;
    dprintf("\t%s[%ld]\n", ModInfoName, CheckNum);
    while( modInfo < modInfoMax ) {
        if ( ModInfoSize )  {
            CHAR cmd[MAX_PATH];
            sprintf(cmd, "dt -o -r hal!_ERROR_MODINFO 0x%I64x", modInfo);
            dprintf("\t%s[%ld]:\n", ModInfoName, modInfoNum);
            ExecCommand(cmd);
        }
        else {
            ULONG bytesRead = 0;
            ReadMemory(modInfo, &modInfoStruct, modInfoSize, &bytesRead );
            if ( bytesRead >= modInfoSize  ) {
                dprintf( ERROR_MODINFO_FORMAT_IA64,
                        ModInfoName, modInfoNum,
                         modInfoStruct.Valid,
                        (ULONG)     modInfoStruct.Valid.CheckInfo,
                        (ULONG)     modInfoStruct.Valid.RequestorIdentifier,
                        (ULONG)     modInfoStruct.Valid.ResponderIdentifier,
                        (ULONG)     modInfoStruct.Valid.TargetIdentifier,
                        (ULONG)     modInfoStruct.Valid.PreciseIP,
                        (ULONGLONG) modInfoStruct.Valid.Reserved,
                        (ULONGLONG) modInfoStruct.CheckInfo,
                        (ULONGLONG) modInfoStruct.RequestedId,
                        (ULONGLONG) modInfoStruct.ResponderId,
                        (ULONGLONG) modInfoStruct.TargetId,
                        (ULONGLONG) modInfoStruct.PreciseIP
                      );
            }
            else {
               dprintf("Reading _ERROR_MODINFO directly from memory failed @ 0x%I64x.\n", modInfo );
            }
        }
        modInfo += (ULONG64)modInfoSize;
        modInfoNum++;
    }

    return( modInfo );

} // DtErrorModInfos()

ULONG64
DtErrorProcessorStaticInfo(
    ULONG64 StaticInfo,
    ULONG64 SectionMax
    )
{
    ULONG   offset;
    ULONG64 valid;
    CHAR    cmd[MAX_PATH];
    ULONG   i;
    HRESULT hr;
    ULONG64 moduleValid;
    ULONG   typeIdValid;
    ULONG64 moduleStaticInfo;
    ULONG   typeIdStaticInfo;
    CHAR    field[MAX_PATH];

    hr = g_ExtSymbols->GetSymbolTypeId( "hal!_ERROR_PROCESSOR_STATIC_INFO_VALID", 
                                        &typeIdValid, 
                                        &moduleValid);
    if ( !SUCCEEDED(hr) )   {
        dprintf("Unable to get hal!_ERROR_PROCESSOR_STATIC_INFO_VALID type. Stop processing...\n");
        return( 0 );
    }
    hr = g_ExtSymbols->GetSymbolTypeId( "hal!_ERROR_PROCESSOR_STATIC_INFO", 
                                        &typeIdStaticInfo, 
                                        &moduleStaticInfo);
    if ( !SUCCEEDED(hr) )   {
        dprintf("Unable to get hal!_ERROR_PROCESSOR_STATIC_INFO type. Stop processing...\n");
        return( 0 );
    }

    //
    //
    // Display the valid structure.
    //

    offset = 0;
    GetFieldOffset("hal!_ERROR_PROCESSOR_STATIC_INFO" , "Valid", &offset );
    valid = StaticInfo + (ULONG64)offset;
    dprintf("\t\tValid @ 0x%I64x\n", valid);
    sprintf(cmd, "dt -o -r hal!_ERROR_PROCESSOR_STATIC_INFO_VALID 0x%I64x", valid );
    ExecCommand( cmd );

    //
    // Pass through all the valid _ERROR_PROCESSOR_STATIC_INFO fields and dump them.
    //

for (i=0; ;i++) {
    hr = g_ExtSymbols->GetFieldName(moduleValid, typeIdValid, i, field, sizeof(field), NULL);
    if ( hr == S_OK) {
        ULONG64 val; 
        ULONG   size = 0;
        // g_ExtSymbols->GetFieldOffset(moduleValid, typeIdValid, field, &offset);
        GetFieldValue(valid, "hal!_ERROR_PROCESSOR_STATIC_INFO_VALID", field, val);
// dprintf("XX\t %lx (+%03lx) %s %ld\n", i, offset, field, (ULONG)val);
        // g_ExtSymbols->GetFieldOffset(moduleStaticInfo, typeIdStaticInfo, field, &offset);
        GetFieldOffsetEx("hal!_ERROR_PROCESSOR_STATIC_INFO", field, &offset, &size);
// dprintf("XX\t\t %lx (+%03lx) %ld %s\n", i, offset, size, field);
        if (val && offset ) { // Valid is the first entry.
            ULONG64 fieldAddress, fieldAddressMax;
            // XXTF: Get the field size here...
            // g_ExtSymbols->GetFieldSize(moduleStaticInfo, typeIdStaticInfo, field, &size);
            fieldAddress    = StaticInfo + (ULONG64)offset;
            fieldAddressMax = fieldAddress + (ULONG64)size - sizeof(ULONG64);
            dprintf("\t\t%s @ 0x%I64x 0x%I64x\n", field, fieldAddress, fieldAddressMax);
            if ( fieldAddressMax > SectionMax )   {
                dprintf("\t\tInvalid Entry: %s size greater than SectionMax 0x%I64x", SectionMax);
            }
            if ( strcmp(field, "MinState") && size )    {
               sprintf(cmd, "dqs 0x%I64x 0x%I64x", fieldAddress, fieldAddressMax );
               ExecCommand( cmd );
            }
        }
    } else if (hr == E_INVALIDARG) {
        // All Fields done
        break;
    } else {
        dprintf("GetFieldName Failed %lx\n", hr);
        break;
    }
}

    // XXTF: Later we should set to length of _ERROR_PROCESSOR_STATIC_INFO if success
    return 0; 

} // DtErrorProcessorStaticInfo()

HRESULT
DtErrorSectionProcessor(
    IN ULONG64 Section
    )
{
     ULONG64 sectionMax;
     ULONG   sectionSize;
     ULONG   sectionLength;
     ULONG   modInfoSize;
     ULONG   cacheModInfos, tlbModInfos;
     ULONG   busModInfos, regFileModInfos, msModInfos;
     ULONG64 modInfo, modInfoMax;
     ULONG64 cpuidInfo;
     ULONG   cpuidInfoSize;
     ULONG64 staticInfo;
     ULONG   staticInfoSize;
     BOOLEAN stateParameterValid;
     ULONG   stateParameterSize;
     ULONG   stateParameterOffset;
     BOOLEAN crLidValid;
     ULONG   crLidSize;
     ULONG   crLidOffset;
     BOOLEAN errorMapValid;
     CHAR    cmd[MAX_PATH];

     sectionSize = GetTypeSize( "hal!_ERROR_PROCESSOR" );
     if ( sectionSize == 0 )   {
        dprintf( "Unable to get HAL!_ERROR_PROCESSOR type size\n" );
        return( E_FAIL );
     }

     stateParameterValid = FALSE;
     stateParameterSize = GetTypeSize( "hal!_ERROR_PROCESSOR_STATE_PARAMETER" );
     if ( stateParameterSize && 
          !GetFieldOffset("hal!_ERROR_PROCESSOR", "StateParameter", &stateParameterOffset ) ) {
        stateParameterValid = TRUE;
     }
     crLidValid = FALSE;
     crLidSize = GetTypeSize( "hal!_PROCESSOR_LOCAL_ID" );
     if ( crLidSize && 
          !GetFieldOffset("hal!_ERROR_PROCESSOR", "CRLid", &crLidOffset ) ) {
        crLidValid = TRUE;
     }
     errorMapValid = FALSE;
     if ( GetTypeSize( "hal!_ERROR_PROCESSOR_ERROR_MAP" ) ) {
        errorMapValid = TRUE;
     }

     if ( InitTypeRead( Section, hal!_ERROR_PROCESSOR ) )    {
        dprintf( "Unable to read HAL!_ERROR_PROCESSOR at 0x%I64x\n", Section );
        return( E_FAIL );
     }

     sectionLength   = (ULONG) ReadField(Header.Length);
     sectionMax      = Section + (ULONG64)sectionLength;

     cacheModInfos   = (ULONG) ReadField(Valid.CacheCheckNum);
     tlbModInfos     = (ULONG) ReadField(Valid.TlbCheckNum);
     busModInfos     = (ULONG) ReadField(Valid.BusCheckNum);
     regFileModInfos = (ULONG) ReadField(Valid.RegFileCheckNum);
     msModInfos      = (ULONG) ReadField(Valid.MsCheckNum);

     dprintf( ERROR_PROCESSOR_FORMAT_IA64,
              (ULONGLONG) ReadField(Valid),
              (ULONG)     ReadField(Valid.ErrorMap),
              (ULONG)     ReadField(Valid.StateParameter),
              (ULONG)     ReadField(Valid.CRLid),
              (ULONG)     ReadField(Valid.StaticStruct),
              cacheModInfos,
              tlbModInfos,
              busModInfos,
              regFileModInfos,
              msModInfos,
              (ULONG)     ReadField(Valid.CpuIdInfo),
              (ULONGLONG) ReadField(Valid.Reserved)
            );

    if ( errorMapValid )    {
        dprintf( ERROR_PROCESSOR_ERROR_MAP_FORMAT_IA64,
                (ULONGLONG) ReadField(ErrorMap),
                (ULONG)     ReadField(ErrorMap.Cid),
                (ULONG)     ReadField(ErrorMap.Tid),
                (ULONG)     ReadField(ErrorMap.Eic),
                (ULONG)     ReadField(ErrorMap.Edc),
                (ULONG)     ReadField(ErrorMap.Eit),
                (ULONG)     ReadField(ErrorMap.Edt),
                (ULONG)     ReadField(ErrorMap.Ebh),
                (ULONG)     ReadField(ErrorMap.Erf),
                (ULONG)     ReadField(ErrorMap.Ems),
                (ULONG)     ReadField(ErrorMap.Reserved)
               );
    }
    else   {
         ERROR_PROCESSOR_ERROR_MAP_IA64 errorMap;
         errorMap.ErrorMap = (ULONGLONG) ReadField(ErrorMap);
         dprintf( ERROR_PROCESSOR_ERROR_MAP_FORMAT_IA64,
                 (ULONGLONG) errorMap.ErrorMap,
                 (ULONG)     errorMap.Cid,
                 (ULONG)     errorMap.Tid,
                 (ULONG)     errorMap.Eic,
                 (ULONG)     errorMap.Edc,
                 (ULONG)     errorMap.Eit,
                 (ULONG)     errorMap.Edt,
                 (ULONG)     errorMap.Ebh,
                 (ULONG)     errorMap.Erf,
                 (ULONG)     errorMap.Ems,
                 (ULONG)     errorMap.Reserved
                );
    }

    dprintf("\tStateParameter: 0x%I64x\n", (ULONGLONG) ReadField(StateParameter));
    if ( stateParameterValid )  {
        sprintf(cmd, "dt -o -r hal!_ERROR_PROCESSOR_STATE_PARAMETER 0x%I64x", 
                     Section + (ULONG64)stateParameterOffset );
        ExecCommand( cmd );
    }
    dprintf("\tCRLid         : 0x%I64x\n", (ULONGLONG) ReadField(CRLid));
    if ( crLidValid )  {
        sprintf(cmd, "dt -o -r hal!_PROCESSOR_LOCAL_ID 0x%I64x", Section + (ULONG64)crLidOffset );
        ExecCommand( cmd );
    }

    //
    // Check if _ERROR_MODINFO a known type?
    //

    modInfo     = Section + (ULONG64)sectionSize;
    modInfoSize = GetTypeSize( "hal!_ERROR_MODINFO" );

    //
    // Dump Cache ModInfo structures if any
    //

    if ( cacheModInfos )    {
        modInfo = DtErrorModInfos( modInfo, cacheModInfos, modInfoSize, "CacheErrorInfo" );
    }

    //
    // Dump TLB ModInfo structures if any
    //

    if ( tlbModInfos )    {
        modInfo = DtErrorModInfos( modInfo, tlbModInfos, modInfoSize, "TlbErrorInfo" );
    }

    //
    // Dump BUS ModInfo structures if any
    //

    if ( busModInfos )    {
        modInfo = DtErrorModInfos( modInfo, busModInfos, modInfoSize, "BusErrorInfo" );
    }

    //
    // Dump REGISTERS FILES ModInfo structures if any
    //

    if ( regFileModInfos )    {
        modInfo = DtErrorModInfos( modInfo, regFileModInfos, modInfoSize, "RegFileErrorInfo" );
    }

    //
    // Dump MS ModInfo structures if any
    //

    if ( msModInfos )    {
        modInfo = DtErrorModInfos( modInfo, msModInfos, modInfoSize, "MsErrorInfo" );
    }

    //
    // Dump CPUID Info
    //

// XXTF: DO NOT CHECK this in - This is for Raj's private SAL test - Lion Build 270D.
// gHalpSalPalDataFlags |= HALP_SALPAL_MCE_PROCESSOR_CPUIDINFO_OMITTED;

    cpuidInfo     = modInfo;
if ( gHalpSalPalDataFlags & HALP_SALPAL_MCE_PROCESSOR_CPUIDINFO_OMITTED )  {
    dprintf("\tCpuIdInfo  @ 0x%I64x FW-omitted\n", cpuidInfo);
    cpuidInfoSize = 0;
}
else  {

    if ( cpuidInfo >= sectionMax )  {
        dprintf("\tCpuIdInfo  @ 0x%I64x\n", cpuidInfo);
        dprintf("Invalid ERROR_PROCESSOR: cpuidInfo >= sectionMax\n");
        return E_FAIL;
    }
    cpuidInfoSize = GetTypeSize( "hal!_ERROR_PROCESSOR_CPUID_INFO" );
    dprintf("\tCpuIdInfo  @ 0x%I64x", cpuidInfo);
    if ( cpuidInfoSize )    {
        dprintf(" 0x%I64x\n", cpuidInfo + (ULONG64)cpuidInfoSize);
        if ( (cpuidInfo + cpuidInfoSize) > sectionMax )  {
            dprintf("\nInvalid ERROR_PROCESSOR: (cpuidInfo+cpuidInfoSize) > sectionMax\n");
            return E_FAIL;
        }
        sprintf(cmd, "dt -o -r hal!_ERROR_PROCESSOR_CPUID_INFO 0x%I64x", cpuidInfo );
        ExecCommand( cmd );
    }
    else  {
        ERROR_PROCESSOR_CPUID_INFO_IA64 cpuidInfoStruct;
        ULONG                           bytesRead;

        bytesRead = 0;
        cpuidInfoSize = sizeof(cpuidInfoStruct);
        dprintf(" 0x%I64x\n", cpuidInfo + (ULONG64)cpuidInfoSize);
        if ( (cpuidInfo + cpuidInfoSize) > sectionMax )  {
            dprintf("\nInvalid ERROR_PROCESSOR: (cpuidInfo+cpuidInfoSize) > sectionMax\n");
            return E_FAIL;
        }
        ReadMemory(cpuidInfo, &cpuidInfoStruct, cpuidInfoSize, &bytesRead );
        if ( bytesRead >= cpuidInfoSize  ) {
            dprintf( ERROR_PROCESSOR_CPUID_INFO_FORMAT_IA64,
                     cpuidInfoStruct.CpuId0,
                     cpuidInfoStruct.CpuId1,
                     cpuidInfoStruct.CpuId2,
                     cpuidInfoStruct.CpuId3,
                     cpuidInfoStruct.CpuId4,
                     cpuidInfoStruct.Reserved
                   );
        }
        else {
            dprintf("Reading _ERROR_PROCESSOR_CPUID_INFO directly from memory failed @ 0x%I64x.\n", cpuidInfo );
        }

    }
}

    //
    // Dump Processor Static Info
    //

// XXTF BUGBUG - 04/16/2001 - TEMP for kd extension test.
// XXTF: DO NOT CHECK this in - This is for Raj's private SAL test - Lion Build 270D.
// gHalpSalPalDataFlags |= HALP_SALPAL_MCE_PROCESSOR_STATICINFO_PARTIAL;

    staticInfo     = cpuidInfo + cpuidInfoSize;
    if ( staticInfo >= sectionMax )  {
        dprintf("Invalid ERROR_PROCESSOR: staticInfo >= sectionMax\n");
        return E_FAIL;
    }
    staticInfoSize = GetTypeSize( "hal!_ERROR_PROCESSOR_STATIC_INFO" );
    dprintf("\tStaticInfo @ 0x%I64x", staticInfo);
    if ( staticInfoSize )    {
        dprintf(" 0x%I64x\n", staticInfo + (ULONG64)staticInfoSize);
        if ( !(gHalpSalPalDataFlags & HALP_SALPAL_MCE_PROCESSOR_STATICINFO_PARTIAL) && 
             (staticInfo + staticInfoSize) > sectionMax )  {
            dprintf("\nInvalid ERROR_PROCESSOR: (staticInfo+staticInfoSize) > sectionMax\n");
            return E_FAIL;
        }
        (VOID) DtErrorProcessorStaticInfo( staticInfo, sectionMax );
    }
    else    {
        ERROR_PROCESSOR_STATIC_INFO_IA64 staticInfoStruct;
        ULONG                            bytesRead;

        bytesRead = 0;
        staticInfoSize = sizeof(staticInfoStruct);
        dprintf(" 0x%I64x\n", staticInfo + (ULONG64)staticInfoSize);
        if ( !(gHalpSalPalDataFlags & HALP_SALPAL_MCE_PROCESSOR_STATICINFO_PARTIAL) && 
             (staticInfo + staticInfoSize) > sectionMax )  {
            dprintf("\nInvalid ERROR_PROCESSOR: (staticInfo+staticInfoSize) > sectionMax\n");
            return E_FAIL;
        }
        ReadMemory(staticInfo, &staticInfoStruct, staticInfoSize, &bytesRead );
        if ( bytesRead >= staticInfoSize  ) {
            ULONG64  minState, brs, crs, ars, rrs, frs;
            PULONG64 minStateValuePtr;

            minState = staticInfo + FIELD_OFFSET( _ERROR_PROCESSOR_STATIC_INFO_IA64, MinState);
            brs      = staticInfo + FIELD_OFFSET( _ERROR_PROCESSOR_STATIC_INFO_IA64, BR);
            crs      = staticInfo + FIELD_OFFSET( _ERROR_PROCESSOR_STATIC_INFO_IA64, CR);
            ars      = staticInfo + FIELD_OFFSET( _ERROR_PROCESSOR_STATIC_INFO_IA64, AR);
            rrs      = staticInfo + FIELD_OFFSET( _ERROR_PROCESSOR_STATIC_INFO_IA64, RR);
            frs      = staticInfo + FIELD_OFFSET( _ERROR_PROCESSOR_STATIC_INFO_IA64, FR);

            minStateValuePtr = (PULONG64)&(staticInfoStruct.MinState[0]);

            dprintf( ERROR_PROCESSOR_STATIC_INFO_FORMAT_IA64,
                     (ULONGLONG) staticInfoStruct.Valid.Valid,
                     (ULONG)     staticInfoStruct.Valid.MinState,
                     (ULONG)     staticInfoStruct.Valid.BRs,
                     (ULONG)     staticInfoStruct.Valid.CRs,
                     (ULONG)     staticInfoStruct.Valid.ARs,
                     (ULONG)     staticInfoStruct.Valid.RRs,
                     (ULONG)     staticInfoStruct.Valid.FRs,
                     (ULONGLONG) staticInfoStruct.Valid.Reserved
                     );
            dprintf( "\t\tMinState @ 0x%I64x 0x%I64x\n", minState, brs - sizeof(ULONGLONG) );
            sprintf(cmd, "dqs 0x%I64x 0x%I64x", minState, brs - sizeof(ULONGLONG) );
            ExecCommand( cmd );
            dprintf( "\t\tBRs @ 0x%I64x\n", brs, crs - sizeof(ULONGLONG) );
            sprintf(cmd, "dqs 0x%I64x 0x%I64x", brs, crs - sizeof(ULONGLONG) );
            ExecCommand( cmd );
            dprintf( "\t\tCRs @ 0x%I64x 0x%I64x\n", crs, ars - sizeof(ULONGLONG) );
            sprintf(cmd, "dqs 0x%I64x 0x%I64x", crs, ars - sizeof(ULONGLONG) );
            ExecCommand( cmd );
            dprintf( "\t\tARs @ 0x%I64x 0x%I64x\n", ars, rrs - sizeof(ULONGLONG) );
            sprintf(cmd, "dqs 0x%I64x 0x%I64x", ars, rrs - sizeof(ULONGLONG) );
            ExecCommand( cmd );
            dprintf( "\t\tRRs @ 0x%I64x 0x%I64x\n", rrs, frs - sizeof(ULONGLONG) );
            sprintf(cmd, "dqs 0x%I64x 0x%I64x", rrs, frs - sizeof(ULONGLONG) );
            ExecCommand( cmd );
            dprintf( "\t\tFRs @ 0x%I64x 0x%I64x\n", frs, staticInfo + (ULONG64)staticInfoSize - sizeof(ULONGLONG) );
            sprintf(cmd, "dqs 0x%I64x 0x%I64x", frs, staticInfo + (ULONG64)staticInfoSize - sizeof(ULONGLONG) );
            ExecCommand( cmd );
        }
        else {
            dprintf("Reading _ERROR_PROCESSOR_STATIC_INFO directly from memory failed @ 0x%I64x.\n", staticInfo );
        }
    }

    // ouf!
    return S_OK;

} // DtErrrorSectionProcessor()

ULONG64
DtErrorOemData(
    ULONG64   OemData,
    USHORT    OemDataLength
   )
{
    ULONG oemDataSize;
    CHAR cmd[MAX_PATH];
    // XXTF: should be fixed later and use field type and offset, instead of USHORT type.
    USHORT length;

    length = OemDataLength;
    oemDataSize = GetTypeSize("hal!_ERROR_OEM_DATA");
    // Do not print the following header if 'dt -r hal!_ERROR_PLATFORM_SPECIFIC type was found.
    if ( !oemDataSize )   { 
        dprintf("\tOemData @ 0x%I64x", OemData);
        dprintf(" 0x%I64x\n\t\tLength\t: 0x%x\n", OemData + (ULONG64)length - sizeof(BYTE), length);
        oemDataSize = sizeof(_ERROR_OEM_DATA_IA64);
    }
    sprintf(cmd, "db 0x%I64x 0x%I64x\n", OemData + (ULONG64)oemDataSize, 
                                         OemData + (ULONG64)(length - sizeof(length)) - sizeof(BYTE));
    ExecCommand(cmd);
    return( OemData + (ULONG64)length );

} // DtErrorOemData()

VOID
DtErrorOemDevicePath(
    ULONG64 OemDevicePath,
    ULONG64 OemDevicePathMax
    )
{
    CHAR cmd[MAX_PATH];

    dprintf("\tOemDevicePath @ 0x%I64x 0x%I64x\n", OemDevicePath, OemDevicePathMax );
    sprintf(cmd, "db 0x%I64x 0x%I64x\n", OemDevicePath, OemDevicePathMax - sizeof(UCHAR) );
    ExecCommand( cmd );
    return;

} // DtErrorOemDevicePath()

VOID
DtErrorOemId(
    ULONG64 OemId
    )
{
    CHAR cmd[MAX_PATH];

    dprintf("\tOemId @ 0x%I64x 0x%I64x\n", OemId, OemId + (ULONG64)16 );
    sprintf(cmd, "db 0x%I64x 0x%I64x\n", OemId, OemId + (ULONG64)15 );
    ExecCommand( cmd );
    return;
} // DtErrorOemId()

HRESULT
DtErrorSectionPlatformSpecific(
    IN ULONG64 Section
    )
{
    ULONG sectionSize;
    ULONG64 oemData;
    ULONG64 devicePath; 
    ULONG   sectionLength;
    ULONG   oemDataLength;

    sectionSize = GetTypeSize( "hal!_ERROR_PLATFORM_SPECIFIC" );
    if ( sectionSize )  {
        CHAR cmd[MAX_PATH];
        sprintf(cmd, "dt -r hal!_ERROR_PLATFORM_SPECIFIC 0x%I64x", Section);
        ExecCommand( cmd );
        oemData = Section + (ULONG64)sectionSize;
        GetFieldValue( Section, "hal!_ERROR_PLATFORM_SPECIFIC", "OemData.Length", oemDataLength );
        devicePath = DtErrorOemData( oemData, (USHORT)oemDataLength );
        GetFieldValue( Section, "hal!_ERROR_PLATFORM_SPECIFIC", "Header.Length", sectionLength );
        DtErrorOemDevicePath( devicePath, Section + (ULONG64)sectionLength  );
    }
    else   {
        ERROR_PLATFORM_SPECIFIC_IA64 platformSpecific;
        ULONG cbRead = 0;
        ULONG64 oemId;

        sectionSize = sizeof(platformSpecific);
        ReadMemory( Section, &platformSpecific, sectionSize, &cbRead );
        if ( cbRead >= sectionSize )    {
            sectionLength = platformSpecific.Header.Length;
            dprintf( ERROR_PLATFORM_SPECIFIC_FORMAT_IA64,
                         platformSpecific.Valid.Valid,
                        (ULONG)     platformSpecific.Valid.ErrorStatus,
                        (ULONG)     platformSpecific.Valid.RequestorId,
                        (ULONG)     platformSpecific.Valid.ResponderId,
                        (ULONG)     platformSpecific.Valid.TargetId,
                        (ULONG)     platformSpecific.Valid.BusSpecificData,
                        (ULONG)     platformSpecific.Valid.OemId,
                        (ULONG)     platformSpecific.Valid.OemData,
                        (ULONG)     platformSpecific.Valid.OemDevicePath,
                        (ULONGLONG) platformSpecific.Valid.Reserved,
                        (ULONGLONG) platformSpecific.ErrorStatus.Status,
                        (ULONGLONG) platformSpecific.RequestorId,
                        (ULONGLONG) platformSpecific.ResponderId,
                        (ULONGLONG) platformSpecific.TargetId,
                        (ULONGLONG) platformSpecific.BusSpecificData.BusSpecificData 
                        );
            oemId   = Section + (ULONG64)FIELD_OFFSET(_ERROR_PLATFORM_SPECIFIC_IA64, OemId);
            DtErrorOemId( oemId );
            oemData = Section + (ULONG64)FIELD_OFFSET(_ERROR_PLATFORM_SPECIFIC_IA64, OemData);
            DtErrorOemData( oemData, platformSpecific.OemData.Length );
            devicePath = oemData + platformSpecific.OemData.Length;
            DtErrorOemDevicePath( devicePath, Section + (ULONG64)sectionLength  );
        }
        else  {
            dprintf("Reading _ERROR_PLATFORM_SPECIFIC directly from memory failed @ 0x%I64x.\n", Section );
        }
    }

    return S_OK;

} // DtErrorSectionPlatformSpecific()

ULONGLONG gMceProcNumberMaskTimeStamp = 0;

HRESULT
DtMcaLog(
    IN ULONG64 McaLog,
    IN ULONG   RecordSize
    )
{
    ULONG     recordLength;
    ULONG     recordRevision;
    ULONG64   section;
    ULONG64   sectionMax;
    ULONG     errorSeverity;
    ULONG     sectionSize;
    CHAR      procNumberString[64];
    ULONGLONG timeStamp;
    HRESULT   hr;

    //
    // Handle pre-SAL 3.0 formats with zero'ed OEM Platform Id appended to the SAL 2.0 version,
    // but with HAL exporting _ERROR_RECORD_HEADER type.
    //

    recordRevision = (ULONG)ReadField(Revision);
    if ( recordRevision < 0x2 /* ERROR_REVISION_SAL_03_00 */ )  {
        if ( CompareTypedOemPlatformId( gZeroedOemPlatformId ) )   {
            RecordSize += sizeof( gZeroedOemPlatformId );
        }
        gHalpSalPalDataFlags |= HALP_SALPAL_MCE_PROCESSOR_CPUIDINFO_OMITTED;
        gHalpSalPalDataFlags |= HALP_SALPAL_MCE_PROCESSOR_STATICINFO_PARTIAL;
    }
    else if ( RecordSize == 0x18 )   {
    //
    // Handle SAL 3.0 formats but with HAL exposing _ERROR_RECORD_HEADER definition
    // without PlatformId field.
    //
        RecordSize += sizeof( gZeroedOemPlatformId );

    //
    // Handle SAL 3.0 formats but without CPUID_INFO member and with HAL not exposing
    // _ERROR_PROCESSOR_CPUID_INFO and as such HALs which do not support the SAL/PAL FW
    // workaround framework.
    //
        gHalpSalPalDataFlags |= HALP_SALPAL_MCE_PROCESSOR_CPUIDINFO_OMITTED;
        gHalpSalPalDataFlags |= HALP_SALPAL_MCE_PROCESSOR_STATICINFO_PARTIAL;
    }

    //
    // If HAL added the processor number to the ERROR_RECORD_HEADER,
    // consider this here.
    //

    procNumberString[0] = '\0';
    timeStamp = ReadField(TimeStamp);
    if ( gMceProcNumberMaskTimeStamp )  {
        ULONG     procNumber;
        procNumber = (ULONG) ReadField(TimeStamp.Reserved);
        (void)sprintf(procNumberString, "\tProcNumber: %ld", procNumber);
        timeStamp &= gMceProcNumberMaskTimeStamp;
    }

    //
    // Back to standard processing here.
    //

    recordLength  = (ULONG)ReadField(Length);
    errorSeverity = (ULONG)ReadField(ErrorSeverity);
    dprintf( ERROR_RECORD_HEADER_FORMAT_IA64,
             McaLog, (McaLog + (ULONG64)recordLength),
             (ULONGLONG) ReadField(Id),
             (ULONG)     ReadField(Revision),
             (ULONG)     ReadField(Revision.Major), (ULONG) ReadField(Revision.Minor),
                         errorSeverity, ErrorSeverityValueString( errorSeverity ),
             (ULONG)     ReadField(Valid),
             (ULONG)     ReadField(Valid.OemPlatformID),
                         recordLength,       
                         timeStamp,
             (ULONG)     ReadField(TimeStamp.Seconds),
             (ULONG)     ReadField(TimeStamp.Minutes),
             (ULONG)     ReadField(TimeStamp.Hours),
             (ULONG)     ReadField(TimeStamp.Day),
             (ULONG)     ReadField(TimeStamp.Month),
             (ULONG)     ReadField(TimeStamp.Year),
             (ULONG)     ReadField(TimeStamp.Century),
             (ULONG)     ReadField(OemPlatformId[0x0]),
             (ULONG)     ReadField(OemPlatformId[0x1]),
             (ULONG)     ReadField(OemPlatformId[0x2]),
             (ULONG)     ReadField(OemPlatformId[0x3]),
             (ULONG)     ReadField(OemPlatformId[0x4]),
             (ULONG)     ReadField(OemPlatformId[0x5]),
             (ULONG)     ReadField(OemPlatformId[0x6]),
             (ULONG)     ReadField(OemPlatformId[0x7]),
             (ULONG)     ReadField(OemPlatformId[0x8]),
             (ULONG)     ReadField(OemPlatformId[0x9]),
             (ULONG)     ReadField(OemPlatformId[0xa]),
             (ULONG)     ReadField(OemPlatformId[0xb]),
             (ULONG)     ReadField(OemPlatformId[0xc]),
             (ULONG)     ReadField(OemPlatformId[0xd]),
             (ULONG)     ReadField(OemPlatformId[0xe]),
             (ULONG)     ReadField(OemPlatformId[0xf]),
             procNumberString
           );

    if ( recordLength <= RecordSize )  {
        dprintf( "Invalid RecordLength = %ld. <= RecordSize = %ld. Stop processing...\n\n",
                 recordLength,
                 RecordSize );
        return( E_FAIL );
    }

    sectionSize = GetTypeSize( "hal!_ERROR_SECTION_HEADER" );
    if ( sectionSize == 0 ) {
        dprintf( "Unable to get HAL!_ERROR_SECTION_HEADER type size\n\n" );
        return( E_FAIL );
    }
    if ( recordLength < (RecordSize + sectionSize) )    {
        dprintf("Invalid RecordLength = %ld. < (RecordSize=%ld + SectionSize = %ld). Stop processing...\n\n",
                 recordLength,
                 RecordSize,
                 sectionSize );
        return( E_FAIL );
    }

    //
    // Initialize Error Sections processing.
    //

    SetErrorDeviceGuids();

    //
    // Pass through all the record sections.
    //

    section    = McaLog + (ULONG64)RecordSize;
    sectionMax = McaLog + recordLength;
    if ( sectionMax <= (section + sectionSize) )   { // This should not happen...
        dprintf("Invalid RecordLength = %ld. SectionMax < (Section + SectionSize). Stop processing...\n\n",
                 recordLength);
        return( E_FAIL );
    }

    hr = S_OK;
    while( (section < sectionMax) /* successful or not, we proceed... && SUCCEEDED(hr) */  )   {
        ULONG                          sectionLength;
        ERROR_SECTION_HEADER_TYPE_IA64 sectionType;

        if ( InitTypeRead( section, hal!_ERROR_SECTION_HEADER ) )    {
            dprintf( "Unable to read HAL!_ERROR_SECTION_HEADER at 0x%I64x. Stop processing...\n\n", section );
            return( E_FAIL );
        }

        sectionLength = (ULONG)ReadField( Length );
        sectionType = GetTypedErrorSectionType();

        dprintf( ERROR_SECTION_HEADER_FORMAT_IA64,
                 section, (section + (ULONG64)sectionLength),
                 (ULONG) ReadField(Guid.Data1),
                 (ULONG) ReadField(Guid.Data2),
                 (ULONG) ReadField(Guid.Data3),
                 (ULONG) ReadField(Guid.Data4[0]),
                 (ULONG) ReadField(Guid.Data4[1]),
                 (ULONG) ReadField(Guid.Data4[2]),
                 (ULONG) ReadField(Guid.Data4[3]),
                 (ULONG) ReadField(Guid.Data4[4]),
                 (ULONG) ReadField(Guid.Data4[5]),
                 (ULONG) ReadField(Guid.Data4[6]),
                 (ULONG) ReadField(Guid.Data4[7]),
                 ErrorSectionTypeString( sectionType ),
                 (ULONG) ReadField(Revision),
                 (ULONG) ReadField(Revision.Major), (ULONG) ReadField(Revision.Minor),
                 (ULONG) ReadField(RecoveryInfo),
                 (ULONG) ReadField(RecoveryInfo.Corrected),
                 (ULONG) ReadField(RecoveryInfo.NotContained),
                 (ULONG) ReadField(RecoveryInfo.Reset),
                 (ULONG) ReadField(RecoveryInfo.Reserved),
                 (ULONG) ReadField(RecoveryInfo.Valid),
                 (ULONG) ReadField(Reserved),
                 sectionLength
               );

        switch( sectionType ) {

            case ERROR_SECTION_PROCESSOR:
               hr = DtErrorSectionProcessor( section );
               break;

            case ERROR_SECTION_PLATFORM_SPECIFIC:
               hr = DtErrorSectionPlatformSpecific( section );
               break;

            case ERROR_SECTION_UNKNOWN:
            default: // includes all the section types with incomplete processing...
               hr = S_OK;
               break;
        }
        if ( sectionLength )    {
            dprintf( "\n" );
        }
        else  {
            // Prevents looping on the same section...
            dprintf("Invalid section Length = 0. Stop processing...\n\n");
            return( E_FAIL );
        }
        section += sectionLength;
    }

    return( hr );

} // DtMcaLog()


#define LOW2HIGH FALSE
#define HIGH2LOW TRUE 

HRESULT
DtBitMapEnum(
    ULONG64 Module,
    ULONG   TypeId,
    UINT    BitMap,   // Enums are unsigned ints
    BOOLEAN HighToLow
    )
/*++

Routine Description:

    This function dumps out a bitmap value composed of enums

Arugments:

    Module -
    TypeId - 
    BitMap - 

Return Value:

    HRESULT

--*/
{
    ULONG   size;
    HRESULT hr;

    hr = g_ExtSymbols->GetTypeSize( Module, TypeId, &size );
    if ( SUCCEEDED(hr) ) {
        CHAR    name[MAX_PATH];

        if ( BitMap )  {
            ULONG map = (ULONG)BitMap;
            ULONG   i = 0;
            BOOLEAN first = TRUE;

            size *= 8;
            dprintf("[");
            while( map && (i <size) )    {
                ULONG val;
                val = (HighToLow) ? ((ULONG)0x80000000 >> i) : (0x1 << i);
                if ( map & val )    {
                    hr = g_ExtSymbols->GetConstantName( Module, 
                                                         TypeId, 
                                                         (ULONG64)val, 
                                                         name, 
                                                         sizeof(name), 
                                                         NULL );
                    if ( first )    {
                        first = FALSE;
                    }
                    else {
                        dprintf("|");
                    }
                    if ( SUCCEEDED(hr) )    {
                        dprintf("%s", name);
                        if ( !strcmp(name, "HAL_MCE_PROCNUMBER") )  {
                            gMceProcNumberMaskTimeStamp = (ULONGLONG)(LONG)~val;
                        }
                    }
                    else  {
                        dprintf("0x%lx", val);
                    }
                    map &= ~val;
                }
                i++;
            }
            dprintf("]");
        }
        else  {
            // BitMap = 0
            hr = g_ExtSymbols->GetConstantName( Module, 
                                                 TypeId, 
                                                 (ULONG64)BitMap, 
                                                 name, 
                                                 sizeof(name), 
                                                 NULL 
                                               );
            if ( SUCCEEDED(hr) )    {
               dprintf("[%s]", name);
            }
        }
    }
    return hr;

} // DtBitMapEnum()

VOID
InitMcaIa64(
    PCSTR args
    )
//
// IA-64 !mca extension global initializations
//
{
    USHORT  flags;
    ULONG64 halpSalPalDataAddress;

    halpSalPalDataAddress = GetExpression("hal!HalpSalPalData");
    if ( !InitTypeRead( halpSalPalDataAddress, hal!_HALP_SAL_PAL_DATA) ) {
        gHalpSalPalDataFlags = (USHORT)ReadField( Flags );
    }
    // TF 04/27/01 TEMPTEMP
    // Added the feature to force gHalpSalPalDataFlags to a known value to 
    // handle IA64 developers-release Firmware, without rebuilding the target hal.
    flags = 0;
    if (args && *args)  {
        flags = (USHORT)GetExpression( args );
        dprintf("hal!HalpSalPalDataFlags is forced to 0x%lx - was 0x%lx\n\n", flags, gHalpSalPalDataFlags);
        gHalpSalPalDataFlags = flags;
    }

    SetErrorSeverityValues();

    return;

} // InitMcaIa64()

HRESULT
McaIa64(
    PCSTR args
    )
/*++

Routine Description:

    Dumps processors IA64 Machine Check record and interprets any logged errors

Arguments:

   PCSTR         args

Return Value:

    None

--*/
{
    HRESULT status;
    ULONG64 mcaLog;
    ULONG   recordSize;
    ULONG   featureBits;

// Thierry: 10/01/2000
// Very simple processing for now. We will be adding features with time.
// As a first enhancement, we could access the fist mca log address directly from
// _KPCR.OsMcaResource.EventPool.
//

    status = S_OK;
    if (!GetExpressionEx(args,&mcaLog, &args)) {
        dprintf("USAGE: !mca 0xValue\n");
        return E_INVALIDARG;
    }

    //
    // Present HAL Feature Bits
    //

    status = GetGlobal("hal!HalpFeatureBits", featureBits);
    if ( SUCCEEDED(status) ) {
        ULONG   typeId;
        ULONG64 module;

        dprintf("hal!HalpFeatureBits: 0x%lx ", featureBits);
        status = g_ExtSymbols->GetSymbolTypeId("hal!_HALP_FEATURE", &typeId, &module);
        if ( SUCCEEDED(status) )    {
            DtBitMapEnum( module, typeId, featureBits, LOW2HIGH ); 
        }
        dprintf("\n\n");
    }
    else  {
        dprintf ("hal!HalpFeatureBits not found... sympath problems?.\n\n");
    }
    
    //
    // Global initializations for record processing functions.
    //

    InitMcaIa64( args );

    //
    // Does our HAL pdb file have knowledge of IA64 Error formats?
    //

    recordSize = GetTypeSize( "hal!_ERROR_RECORD_HEADER" );
    if ( recordSize && (InitTypeRead( mcaLog, hal!_ERROR_RECORD_HEADER ) == 0) )    {

       status = DtMcaLog( mcaLog, recordSize );

    }
    else   {
       //
       // In case we cannot extract the ERROR_RECORD_HEADER type, fall back here...
       //

       ERROR_RECORD_HEADER_IA64 recordHeader;
       ULONG                    recordHeaderSize = (ULONG)sizeof(recordHeader);
       ULONG                    bytesRead = 0;

       status = E_FAIL;
       dprintf("Unable to read HAL!_ERROR_RECORD_HEADER at 0x%I64x\n", mcaLog );
       dprintf("Trying to read _ERROR_RECORD_HEADER directly from memory...\n" );

       //
       // Let's try to read error record from memory.
       //

       ReadMemory( mcaLog, &recordHeader, recordHeaderSize, &bytesRead );
       if ( bytesRead >= recordHeaderSize ) {
            DumpIa64ErrorRecordHeader( &recordHeader, mcaLog );
            //
            // no validity check is done inside the current version of DumpIa64ErrorRecordHeader
            // Simply return S_OK.
            status = S_OK;
       }
       else {
          dprintf("Reading _ERROR_RECORD_HEADER directly from memory failed.\n" );
       }
    }

    return status;

} // McaIa64()


DECLARE_API( mca )
/*++

Routine Description:

    Dumps processors machine check architecture registers
    and interprets any logged errors

Arguments:

   PDEBUG_CLIENT Client
   PCSTR         args

Return Value:

    None

--*/
{
    HRESULT status;
    ULONG   processor = 0;

    INIT_API();

    GetCurrentProcessor(Client, &processor, NULL);

    //
    // Simply dispatch to the right target machine handler.
    //

    switch( TargetMachine ) {
        case IMAGE_FILE_MACHINE_I386:
            // Display architectural MCA information.
            status = McaX86( args );
            // Finally, Display stepping information for current processor.
            DumpCpuInfoX86( processor, TRUE );
            break;

        case IMAGE_FILE_MACHINE_IA64:
            // Display architectural MCA information.
            status = McaIa64( args );
            // Finally, Display stepping information for current processor.
            DumpCpuInfoIA64( processor, TRUE );
            break;

        default:
            dprintf("!mca is not supported for this target machine:%ld\n", TargetMachine);
            status = E_INVALIDARG;

    }

    EXIT_API();
    return status;

} // !mca
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\dbgprint.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dbgprint.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

DECLARE_API( dbgprint )

/*++

Routine Description:

    This routine dumps the DbgPrint buffer.

Arguments:

    args - not used

Return Value:

    None

--*/

{
    ULONG64 BufferBase;
    ULONG64 BufferEnd;
    ULONG64 WritePointer;
    PUCHAR LocalBuffer;
    PUCHAR LocalBufferEnd;
    PUCHAR p;
    PUCHAR Start;
    ULONG result;



    BufferBase = GetNtDebuggerData( KdPrintCircularBuffer );
    BufferEnd = GetNtDebuggerData( KdPrintCircularBufferEnd );
    WritePointer = GetNtDebuggerDataPtrValue( KdPrintWritePointer );

    if (!BufferBase || !BufferEnd || !WritePointer) {
        dprintf("Can't find DbgPrint buffer\n");
        goto exit;
    }

    LocalBuffer =  LocalAlloc(LPTR, (ULONG) ( BufferEnd - BufferBase));

    if (!LocalBuffer) {
        dprintf("Could not allocate memory for local copy of DbgPrint buffer\n");
        goto exit;
    }

    if ((!ReadMemory(BufferBase,
                     LocalBuffer,
                     (ULONG) (BufferEnd - BufferBase),
                     &result)) || (result < BufferEnd - BufferBase)) {
        dprintf("%08p: Could not read DbgPrint buffer\n", BufferBase);
        goto exit;
    }

    LocalBufferEnd = LocalBuffer + BufferEnd - BufferBase;
    Start = LocalBuffer + ((ULONG) WritePointer - BufferBase);

    p = Start;
    do {
        //
        // consume NULs
        //
        while (p < LocalBufferEnd && *p == 0) {
            p++;
        }

        if (p < LocalBufferEnd) {
            //
            // print a string and consume it
            //
            dprintf("%s", p);
            while (p < LocalBufferEnd && *p != 0) {
                p++;
            }
        }
    } while (p < LocalBufferEnd);

    //
    // repeat until we hit the start
    //

    p = LocalBuffer;

    while (p < Start && *p == 0) {
        p++;
    }
    if (p < Start) {
        dprintf("%s", p);
        while (p < Start && *p != 0) {
            p++;
        }
    }

exit:
    if (LocalBuffer) {
        LocalFree( LocalBuffer );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\device.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    device.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#define FLAG_NAME(flag)           {flag, #flag}

FLAG_NAME DeviceObjectExtensionFlags[] = {
    FLAG_NAME(DOE_UNLOAD_PENDING),                          // 00000001
    FLAG_NAME(DOE_DELETE_PENDING),                          // 00000002
    FLAG_NAME(DOE_REMOVE_PENDING),                          // 00000004
    FLAG_NAME(DOE_REMOVE_PROCESSED),                        // 00000008
    FLAG_NAME(DOE_START_PENDING),                           // 00000010
    FLAG_NAME(DOE_RAW_FDO),                                 // 20000000
    FLAG_NAME(DOE_BOTTOM_OF_FDO_STACK),                     // 40000000
    FLAG_NAME(DOE_DESIGNATED_FDO),                          // 80000000
    { 0, 0 }
};

DECLARE_API( devobj )

/*++

Routine Description:

    Dump a device object.

Arguments:

    args - the location of the device object to dump.

Return Value:

    None

--*/

{
    ULONG64 deviceToDump ;
    char deviceExprBuf[256] ;
    char *deviceExpr ;

    //
    // !devobj DeviceAddress DumpLevel
    //    where DeviceAddress can be an expression or device name
    //    and DumpLevel is a hex mask
    //
    strcpy(deviceExprBuf, "\\Device\\") ;
    deviceExpr = deviceExprBuf+strlen(deviceExprBuf) ;
    deviceToDump = 0 ;

    strcpy(deviceExpr, args) ;

    //
    // The debugger will treat C0000000 as a symbol first, then a number if
    // no match comes up. We sanely reverse this ordering.
    //
    if (IsHexNumber(deviceExpr)) {

        deviceToDump = GetExpression(deviceExpr) ;

    } else if (deviceExpr[0] == '\\') {

        deviceToDump = FindObjectByName( deviceExpr, 0);

    } else if (isalpha(deviceExpr[0])) {

        //
        // Perhaps it's an object. Try with \\Device\\ prepended...
        //
        deviceToDump = FindObjectByName((PUCHAR) deviceExprBuf, 0);
    }

    if (deviceToDump == 0) {

        //
        // Last try, is it an expression to evaluate?
        //
        deviceToDump = GetExpression( deviceExpr ) ;
    }


    if(deviceToDump == 0) {
        dprintf("Device object %s not found\n", args);
        return E_INVALIDARG;
    }

    DumpDevice( deviceToDump, 0, TRUE);

    return S_OK;
}


VOID
DumpDevice(
    ULONG64 DeviceAddress,
    ULONG   FieldLength,
    BOOLEAN FullDetail
    )

/*++

Routine Description:

    Displays the driver name for the device object if FullDetail == FALSE.
    Otherwise displays more information about the device and the device queue.

Arguments:

    DeviceAddress - address of device object to dump.
    FieldLength   - Width of printf field for driver name (eg %11s).
    FullDetail    - TRUE means the device object name, driver name, and
                    information about Irps queued to the device.

Return Value:

    None

--*/

{
    ULONG                      result;
    ULONG                      i;
    ULONG64                    nextEntry;
    ULONG64                    queueAddress;
    ULONG64                    irp;
    BOOLEAN                    devObjExtRead;
    ULONG     Type=0, ReferenceCount=0, DeviceType=0, Flags=0, DeviceObjEx_ExtensionFlags=0,
       DeviceQueue_Busy=0;
    ULONG64   DriverObject=0, CurrentIrp=0, Vpb=0, DeviceObjectExtension=0, 
       DeviceExtension=0, DeviceObjEx_Dope=0, DeviceObjEx_DeviceNode=0, 
       DeviceObjEx_AttachedTo=0, AttachedDevice=0, DeviceQueue_Dev_Flink=0,
       DeviceQueue_Dev_Blink=0;
#define RECUR            DBG_DUMP_FIELD_RECUR_ON_THIS
#define F_ADDR           DBG_DUMP_FIELD_RETURN_ADDRESS
#define COPY             DBG_DUMP_FIELD_COPY_FIELD_DATA
    FIELD_INFO deviceFields[] = {
       {"DriverObject",   NULL, 0, COPY, 0, (PVOID) &DriverObject},
       {"Type",           NULL, 0, COPY, 0, (PVOID) &Type},
       {"CurrentIrp",     NULL, 0, COPY, 0, (PVOID) &CurrentIrp},
       {"ReferenceCount", NULL, 0, COPY, 0, (PVOID) &ReferenceCount},
       {"DeviceType",     NULL, 0, COPY, 0, (PVOID) &DeviceType},
       {"Flags",          NULL, 0, COPY, 0, (PVOID) &Flags},
       {"Vpb",            NULL, 0, COPY, 0, (PVOID) &Vpb},
       {"DeviceObjectExtension", NULL, 0, COPY | RECUR, 0, (PVOID) &DeviceObjectExtension},
       {"DeviceObjectExtension->Dope", NULL, 0, COPY, 0, (PVOID) &DeviceObjEx_Dope},
       {"DeviceObjectExtension->DeviceNode", NULL, 0, COPY, 0, (PVOID) &DeviceObjEx_DeviceNode},
       {"DeviceObjectExtension->ExtensionFlags", NULL, 0, COPY, 0, (PVOID) &DeviceObjEx_ExtensionFlags},
       {"DeviceObjectExtension->AttachedTo", NULL, 0, COPY, 0, (PVOID) &DeviceObjEx_AttachedTo},
       {"DeviceExtension",NULL, 0, COPY, 0, (PVOID) &DeviceExtension},
       {"AttachedDevice", NULL, 0, COPY, 0, (PVOID) &AttachedDevice},
       {"DeviceQueue",    NULL, 0, RECUR,0, NULL},
       {"DeviceQueue.Busy",  NULL, 0, COPY, 0, (PVOID) &DeviceQueue_Busy},
       {"DeviceQueue.DeviceListHead",   NULL, 0, RECUR | F_ADDR, 0, NULL},
       {"DeviceQueue.DeviceListHead.Flink",   NULL, 0, COPY | F_ADDR, 0, (PVOID) &DeviceQueue_Dev_Flink},
       {"DeviceQueue.DeviceListHead.Blink",   NULL, 0, COPY | F_ADDR, 0, (PVOID) &DeviceQueue_Dev_Blink},
    };
    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), "nt!_DEVICE_OBJECT", DBG_DUMP_NO_PRINT, DeviceAddress,
       NULL, NULL, NULL, sizeof (deviceFields) / sizeof (FIELD_INFO), &deviceFields[0]
    };

    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("%08p: Could not read device object or _DEVICE_OBJECT not found\n", DeviceAddress);
        return;
    }

    if (Type != IO_TYPE_DEVICE) {
        dprintf("%08p: is not a device object\n", DeviceAddress);
        return;
    }

    if (FullDetail == TRUE) {

        //
        // Dump the device name if present.
        //
        dprintf("Device object (%08p) is for:\n ", DeviceAddress);

        DumpObjectName(DeviceAddress) ;
    }

    DumpDriver( DriverObject, FieldLength, 0);

    if (FullDetail == TRUE) {
        //
        // Dump Irps related to driver.
        //

        dprintf(" DriverObject %08p\n", DriverObject);
        dprintf("Current Irp %08p RefCount %d Type %08lx Flags %08lx\n",
                CurrentIrp,
                ReferenceCount,
                DeviceType,
                Flags);

        if (Vpb) {
            dprintf("Vpb %08p ", Vpb);
        }

        dprintf("DevExt %08p DevObjExt %08p ",
                DeviceExtension,
                DeviceObjectExtension);

        devObjExtRead = FALSE ;
        if (DeviceObjectExtension) {

            devObjExtRead = TRUE ;

            if (DeviceObjEx_Dope) {
                dprintf("Dope %08p ", DeviceObjEx_Dope);
            }

            if(DeviceObjEx_DeviceNode) {
                dprintf("DevNode %08p ",
                        DeviceObjEx_DeviceNode);
            }

            dprintf("\n");

            DumpFlags(0,
                      "ExtensionFlags",
                      DeviceObjEx_ExtensionFlags,
                      DeviceObjectExtensionFlags);

        } else {

            dprintf("\n");

        }

        if (AttachedDevice) {
            dprintf("AttachedDevice (Upper) %08p", AttachedDevice);
            DumpDevice(AttachedDevice, 0, FALSE) ;
            dprintf("\n") ;
        }

        if (devObjExtRead && DeviceObjEx_AttachedTo) {
           dprintf("AttachedTo (Lower) %08p", DeviceObjEx_AttachedTo);
           DumpDevice(DeviceObjEx_AttachedTo, 0, FALSE) ;
           dprintf("\n") ;
        }

        if (DeviceQueue_Busy) {

            ULONG64 listHead = DeviceAddress, DevFlinkAddress;

            for (i=0; i<DevSym.nFields; i++) { 
                if (!strcmp(deviceFields[i].fName, "DeviceQueue.DeviceListHead")) {
                    listHead = deviceFields[i].address;
                }
                if (!strcmp(deviceFields[i].fName, "DeviceQueue.DeviceListHead.Flink")) {
                    DevFlinkAddress = deviceFields[i].address;
                }

            }

            // listHead += FIELD_OFFSET(DEVICE_OBJECT, DeviceQueue.DeviceListHead);

            if (DeviceQueue_Dev_Flink == listHead) {
                dprintf("Device queue is busy -- Queue empty.\n");
            // } else if (IsListEmpty(& DeviceQueue.DeviceListHead)) {
            //    dprintf("Device queue is busy -- Queue empty\n");
            } else if(DeviceQueue_Dev_Flink == DeviceQueue_Dev_Blink) {
                dprintf("Device queue is busy - Queue flink = blink\n");
            } else {
                ULONG64 DevListOffset=0, DevQEntryOffset=0;
                FIELD_INFO getOffset = {0};

                //
                // Get offsets required for list
                //
                DevSym.addr = 0; DevSym.nFields =1; DevSym.Fields = &getOffset;

                DevSym.sName = "nt!_KDEVICE_QUEUE_ENTRY"; getOffset.fName = "DeviceListEntry";
                Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
                DevListOffset = getOffset.address;
                DevSym.sName = "nt!_IRP"; getOffset.fName = "Tail.Overlay.DeviceQueueEntry";
                Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
                DevQEntryOffset = getOffset.address;

                dprintf("DeviceQueue: ");
                
                nextEntry = DeviceQueue_Dev_Flink;
                i = 0;

                /*
                while ((PCH) nextEntry != (PCH)
                    ((PCH) DeviceAddress +
                         ((PCH) &deviceObject.DeviceQueue.DeviceListHead.Flink -
                              (PCH) &deviceObject))) {
                              */
                while (nextEntry != (DevFlinkAddress)) {
                    ULONG64 DevList_Flink=0;

                    queueAddress = nextEntry - DevListOffset;
                        
                    /*CONTAINING_RECORD(nextEntry,KDEVICE_QUEUE_ENTRY,
                                                     DeviceListEntry);*/
                    GetFieldValue(queueAddress, "_KDEVICE_QUEUE_ENTRY", "DeviceListEntry.Flink", DevList_Flink);

                    nextEntry = DevList_Flink;

                    irp = queueAddress - DevQEntryOffset;

                    /*CONTAINING_RECORD(queueAddress,
                                            IRP,
                                            Tail.Overlay.DeviceQueueEntry);*/

                    dprintf("%08p%s",
                            irp,
                            (i & 0x03) == 0x03 ? "\n\t     " : " ");
                    if (CheckControlC()) {
                        break;
                    }
                    ++i;
                }
                dprintf("\n");
            }
        } else {
            dprintf("Device queue is not busy.\n");
        }
    }
}

VOID
DumpObjectName(
   ULONG64 ObjectAddress
   )
{
   ULONG64                    pObjectHeader;
   ULONG64                    pNameInfo;
   PUCHAR                     buffer;
   UNICODE_STRING             unicodeString;
   ULONG                      result, NameInfoOffset=0;
   ULONG                      off=0;
   
   if (GetFieldOffset("_OBJECT_HEADER", "Body", &off)) {
       // Type not found
       return; 
   }

   pObjectHeader = ObjectAddress - off;

   if (!GetFieldValue(pObjectHeader, "_OBJECT_HEADER", "NameInfoOffset", NameInfoOffset)) {
       ULONG64 bufferAddr=0;
       ULONG Len=0, MaxLen=0;
       
       // 
       // Get Name info's address
       //
       
       pNameInfo = (NameInfoOffset ? (pObjectHeader - NameInfoOffset) : 0);

       if (!InitTypeRead(pNameInfo, _OBJECT_HEADER_NAME_INFO)) {
           Len    = (ULONG) ReadField(Name.Length);
           MaxLen = (ULONG) ReadField(Name.MaximumLength);
           bufferAddr =     ReadField(Name.Buffer);
           buffer = LocalAlloc(LPTR, MaxLen);
           if (buffer != NULL) {
               unicodeString.MaximumLength = (USHORT) MaxLen;
               unicodeString.Length = (USHORT) Len;
               unicodeString.Buffer = (PWSTR)buffer;
               if (ReadMemory(bufferAddr,
                              buffer,
                              unicodeString.Length,
                              &result) && (result == unicodeString.Length)) {
                   dprintf("%wZ", &unicodeString);
               }
               LocalFree(buffer);
           }
       }

   }
}



HRESULT
GetDevObjInfo(
    IN ULONG64 DeviceObject,
    OUT PDEBUG_DEVICE_OBJECT_INFO pDevObjInfo)
{

    ZeroMemory(pDevObjInfo, sizeof(DEBUG_DEVICE_OBJECT_INFO));
    
    pDevObjInfo->SizeOfStruct = sizeof(DEBUG_DEVICE_OBJECT_INFO);
    pDevObjInfo->DevObjAddress = DeviceObject;
    if (InitTypeRead(DeviceObject, nt!_DEVICE_OBJECT)) {
	return E_INVALIDARG;
    }
    pDevObjInfo->CurrentIrp      = ReadField(CurrentIrp);
    pDevObjInfo->DevExtension    = ReadField(DevExtension);
    pDevObjInfo->DevObjExtension = ReadField(DevObjExtension);
    pDevObjInfo->DriverObject    = ReadField(DriverObject);
    pDevObjInfo->QBusy           = (BOOL) ReadField(DeviceQueue.Busy);
    pDevObjInfo->ReferenceCount  = (ULONG) ReadField(ReferenceCount);

    return S_OK;
}


EXTENSION_API( GetDevObjInfo )(
    IN PDEBUG_CLIENT Client,
    IN ULONG64 DeviceObject,
    OUT PDEBUG_DEVICE_OBJECT_INFO pDevObjInfo)
{
    HRESULT Hr = E_FAIL;

    INIT_API();

    if (pDevObjInfo && (pDevObjInfo->SizeOfStruct == sizeof(DEBUG_DEVICE_OBJECT_INFO))) {
        Hr = GetDevObjInfo(DeviceObject, pDevObjInfo);
    }
    EXIT_API();
    return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\devstack.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    devstack.c

Abstract:

    WinDbg Extension Api

Author:

    Adrian Oney (adriao) 29-Sep-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop
/*
#define FLAG_NAME(flag)           {flag, #flag}

FLAG_NAME DeviceObjectExtensionFlags[] = {
    FLAG_NAME(DOE_UNLOAD_PENDING),                          // 00000001
    FLAG_NAME(DOE_DELETE_PENDING),                          // 00000002
    FLAG_NAME(DOE_REMOVE_PENDING),                          // 00000004
    FLAG_NAME(DOE_REMOVE_PROCESSED),                        // 00000008
    FLAG_NAME(DOE_RAW_FDO),                                 // 20000000
    FLAG_NAME(DOE_BOTTOM_OF_FDO_STACK),                     // 40000000
    FLAG_NAME(DOE_DESIGNATED_FDO),                          // 80000000
    { 0, 0 }
};
*/

VOID
DumpDeviceStack(
    ULONG64 DeviceAddress
    );

DECLARE_API( devstack )

/*++

Routine Description:

    Dump a device object.

Arguments:

    args - the location of the device object to dump.

Return Value:

    None

--*/

{
    ULONG64 deviceToDump ;
    char deviceExprBuf[256] ;
    char *deviceExpr ;

    //
    // !devstack DeviceAddress DumpLevel
    //    where DeviceAddress can be an expression or device name
    //    and DumpLevel is a hex mask
    //
    strcpy(deviceExprBuf, "\\Device\\") ;
    deviceExpr = deviceExprBuf+strlen(deviceExprBuf) ;
    deviceToDump = 0 ;

    strcpy(deviceExpr, args) ;
    //
    // sscanf(args, "%s %lx", deviceExpr, &Flags);
    //

    //
    // The debugger will treat C0000000 as a symbol first, then a number if
    // no match comes up. We sanely reverse this ordering.
    //
    if (IsHexNumber(deviceExpr)) {

        deviceToDump = GetExpression (deviceExpr) ;

    } else if (deviceExpr[0] == '\\') {

        deviceToDump = FindObjectByName( deviceExpr, 0);

    } else if (isalpha(deviceExpr[0])) {

        //
        // Perhaps it's an object. Try with \\Device\\ prepended...
        //
        deviceToDump = FindObjectByName((PUCHAR) deviceExprBuf, 0);
    }

    if (deviceToDump == 0) {

        //
        // Last try, is it an expression to evaluate?
        //
        deviceToDump = GetExpression( deviceExpr ) ;
    }


    if(deviceToDump == 0) {
        dprintf("Device object %s not found\n", args);
        return E_INVALIDARG;
    }

    DumpDeviceStack(deviceToDump);
    return S_OK;
}


VOID
DumpDeviceStack(
    ULONG64 DeviceAddress
    )

/*++

Routine Description:

    Displays the driver name for the device object .
    Otherwise displays more information about the device and the device queue.

Arguments:

    DeviceAddress - address of device object to dump.

Return Value:

    None

--*/

{
    ULONG     result;
    ULONG     i;
    ULONG64   nextEntry;
    BOOLEAN   devObjExtRead;
    ULONG64   currentDeviceObject ;
    ULONG64   DeviceNode=0 ;
    ULONG64   AttachedDevice;
    ULONG64   DeviceObjectExtension;
    ULONG     Type;

    if (!IsPtr64()) {
        DeviceAddress = (ULONG64) (LONG64) (LONG) DeviceAddress;
    }
    //
    // Find top of stack...
    //
    currentDeviceObject = DeviceAddress;
    dprintf("  !DevObj   !DrvObj            !DevExt   ObjectName\n") ;
    while(1) {

        if (GetFieldValue(currentDeviceObject,"nt!_DEVICE_OBJECT","Type",Type)) {
            dprintf("%08p: Could not read device object\n", currentDeviceObject);
            return;
        }

        if (Type != IO_TYPE_DEVICE) {
            dprintf("%08p: is not a device object\n", currentDeviceObject);
            return;
        }

        GetFieldValue(currentDeviceObject,"nt!_DEVICE_OBJECT",
                      "AttachedDevice", AttachedDevice);

        if ((!AttachedDevice)||CheckControlC()) {
            break;
        }

        currentDeviceObject = AttachedDevice ;
    }

    //
    // Crawl back down...
    //
    while(1) {
        ULONG64 DeviceExtension, AttachedTo;

        InitTypeRead(currentDeviceObject, nt!_DEVICE_OBJECT);
        dprintf("%c %08p ",
                (currentDeviceObject == DeviceAddress) ? '>' : ' ',
                currentDeviceObject
            ) ;

        DumpDevice(currentDeviceObject, 20, FALSE) ;

        InitTypeRead(currentDeviceObject, nt!_DEVICE_OBJECT);
        dprintf("%08p  ", (DeviceExtension = ReadField(DeviceExtension)));

        //
        // Dump the device name if present.
        //
        DumpObjectName(currentDeviceObject) ;

        InitTypeRead(currentDeviceObject, nt!_DEVICE_OBJECT);
        devObjExtRead = FALSE ;
        if (DeviceObjectExtension = ReadField(DeviceObjectExtension)) {

            //
            // grab a copy of the device object extension as well
            //
            if(!GetFieldValue(DeviceObjectExtension,"nt!_DEVOBJ_EXTENSION",
                              "AttachedTo",AttachedTo)) {

                devObjExtRead = TRUE ;
            }
            GetFieldValue(DeviceObjectExtension,"nt!_DEVOBJ_EXTENSION",
                          "DeviceNode", DeviceNode);
        }

        if (!devObjExtRead) {

            dprintf("\n%#08p: Could not read device object extension\n",
                    currentDeviceObject);

            return ;
        }

        dprintf("\n");
/*
        DumpFlags(0,
            "ExtensionFlags",
            deviceObjectExtension.ExtensionFlags,
            DeviceObjectExtensionFlags);
        }
*/
        currentDeviceObject = AttachedTo ;

        if ((!currentDeviceObject)||CheckControlC()) {
            break;
        }

        if (GetFieldValue(currentDeviceObject,"nt!_DEVICE_OBJECT","Type",Type)) {
            dprintf("%08p: Could not read device object\n", currentDeviceObject);
            return;
        }
    }

    if(DeviceNode) {
        UNICODE_STRING64 InstancePath, ServiceName;

        dprintf("!DevNode %08p :\n", DeviceNode);

        if (GetFieldValue(DeviceNode,
                          "nt!_DEVICE_NODE",
                          "InstancePath.Length",
                          InstancePath.Length)) {

            dprintf(
                "%08p: Could not read device node\n",
                DeviceNode
                );

            return;
        }
        InitTypeRead(DeviceNode, nt!_DEVICE_NODE);
        InstancePath.MaximumLength = (USHORT) ReadField(InstancePath.MaximumLength);
        InstancePath.Buffer = ReadField(InstancePath.Buffer);
        ServiceName.Length = (USHORT) ReadField(ServiceName.Length);
        ServiceName.MaximumLength = (USHORT) ReadField(ServiceName.MaximumLength);
        ServiceName.Buffer = ReadField(ServiceName.Buffer);
        if (InstancePath.Buffer != 0) {

            dprintf("  DeviceInst is \"");
            DumpUnicode64(InstancePath);
            dprintf("\"\n");
        }

        if (ServiceName.Buffer != 0) {

            dprintf("  ServiceName is \"");
            DumpUnicode64(ServiceName);
            dprintf("\"\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\devnode.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    devnode.c

Abstract:

    WinDbg Extension Api

Revision History:

--*/


#include "precomp.h"
//#include "pci.h"
#pragma hdrstop

#include "stddef.h"
#include <initguid.h>

#define FLAG_NAME(flag)           {flag, #flag}

FLAG_NAME DeviceNodeFlags[] = {
    FLAG_NAME(DNF_MADEUP),                                  // 00000001
    FLAG_NAME(DNF_DUPLICATE),                               // 00000002
    FLAG_NAME(DNF_HAL_NODE),                                // 00000004
    FLAG_NAME(DNF_REENUMERATE),                             // 00000008
    FLAG_NAME(DNF_ENUMERATED),                              // 00000010
    FLAG_NAME(DNF_IDS_QUERIED),                             // 00000020
    FLAG_NAME(DNF_HAS_BOOT_CONFIG),                         // 00000040
    FLAG_NAME(DNF_BOOT_CONFIG_RESERVED),                    // 00000080
    FLAG_NAME(DNF_NO_RESOURCE_REQUIRED),                    // 00000100
    FLAG_NAME(DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED),     // 00000200
    FLAG_NAME(DNF_RESOURCE_REQUIREMENTS_CHANGED),           // 00000400
    FLAG_NAME(DNF_NON_STOPPED_REBALANCE),                   // 00000800
    FLAG_NAME(DNF_LEGACY_DRIVER),                           // 00001000
    FLAG_NAME(DNF_HAS_PROBLEM),                             // 00002000
    FLAG_NAME(DNF_HAS_PRIVATE_PROBLEM),                     // 00004000
    FLAG_NAME(DNF_HARDWARE_VERIFICATION),                   // 00008000
    FLAG_NAME(DNF_DEVICE_GONE),                             // 00010000
    FLAG_NAME(DNF_LEGACY_RESOURCE_DEVICENODE),              // 00020000
    FLAG_NAME(DNF_NEEDS_REBALANCE),                         // 00040000
    FLAG_NAME(DNF_LOCKED_FOR_EJECT),                        // 00080000
    FLAG_NAME(DNF_DRIVER_BLOCKED),                          // 00100000
    {0,0}
};

FLAG_NAME DeviceNodeUserFlags[] = {
    FLAG_NAME(DNUF_WILL_BE_REMOVED),                        // 00000001
    FLAG_NAME(DNUF_DONT_SHOW_IN_UI),                        // 00000002
    FLAG_NAME(DNUF_NEED_RESTART),                           // 00000004
    FLAG_NAME(DNUF_NOT_DISABLEABLE),                        // 00000008
    FLAG_NAME(DNUF_SHUTDOWN_QUERIED),                       // 00000010
    FLAG_NAME(DNUF_SHUTDOWN_SUBTREE_DONE),                  // 00000020
    {0,0}
};

#define DeviceD1           0x00000001
#define DeviceD2           0x00000002
#define LockSupported      0x00000004
#define EjectSupported     0x00000008
#define Removable          0x00000010
#define DockDevice         0x00000020
#define UniqueID           0x00000040
#define SilentInstall      0x00000080
#define RawDeviceOK        0x00000100
#define SurpriseRemovalOK  0x00000200
#define WakeFromD0         0x00000400
#define WakeFromD1         0x00000800
#define WakeFromD2         0x00001000
#define WakeFromD3         0x00002000
#define HardwareDisabled   0x00004000
#define NonDynamic         0x00008000
#define WarmEjectSupported 0x00010000
#define NoDisplayInUI      0x00020000

FLAG_NAME DeviceNodeCapabilityFlags[] = {
    FLAG_NAME(DeviceD1),                                    // 00000001
    FLAG_NAME(DeviceD2),                                    // 00000002
    FLAG_NAME(LockSupported),                               // 00000004
    FLAG_NAME(EjectSupported),                              // 00000008
    FLAG_NAME(Removable),                                   // 00000010
    FLAG_NAME(DockDevice),                                  // 00000020
    FLAG_NAME(UniqueID),                                    // 00000040
    FLAG_NAME(SilentInstall),                               // 00000080
    FLAG_NAME(RawDeviceOK),                                 // 00000100
    FLAG_NAME(SurpriseRemovalOK),                           // 00000200
    FLAG_NAME(WakeFromD0),                                  // 00000400
    FLAG_NAME(WakeFromD1),                                  // 00000800
    FLAG_NAME(WakeFromD2),                                  // 00001000
    FLAG_NAME(WakeFromD3),                                  // 00002000
    FLAG_NAME(HardwareDisabled),                            // 00004000
    FLAG_NAME(NonDynamic),                                  // 00008000
    FLAG_NAME(WarmEjectSupported),                          // 00010000
    FLAG_NAME(NoDisplayInUI),                               // 00020000
    {0,0}
};

#define PROBLEM_MAP_SIZE    0x32

#if PROBLEM_MAP_SIZE != NUM_CM_PROB
#error Add new problem code to DevNodeProblems and update PROBLEM_MAP_SIZE.
#endif

PUCHAR  DevNodeProblems[] = {
    NULL,
    "CM_PROB_NOT_CONFIGURED",
    "CM_PROB_DEVLOADER_FAILED",
    "CM_PROB_OUT_OF_MEMORY",
    "CM_PROB_ENTRY_IS_WRONG_TYPE",
    "CM_PROB_LACKED_ARBITRATOR",
    "CM_PROB_BOOT_CONFIG_CONFLICT",
    "CM_PROB_FAILED_FILTER",
    "CM_PROB_DEVLOADER_NOT_FOUND",
    "CM_PROB_INVALID_DATA",
    "CM_PROB_FAILED_START",
    "CM_PROB_LIAR",
    "CM_PROB_NORMAL_CONFLICT",
    "CM_PROB_NOT_VERIFIED",
    "CM_PROB_NEED_RESTART",
    "CM_PROB_REENUMERATION",
    "CM_PROB_PARTIAL_LOG_CONF",
    "CM_PROB_UNKNOWN_RESOURCE",
    "CM_PROB_REINSTALL",
    "CM_PROB_REGISTRY",
    "CM_PROB_VXDLDR",
    "CM_PROB_WILL_BE_REMOVED",
    "CM_PROB_DISABLED",
    "CM_PROB_DEVLOADER_NOT_READY",
    "CM_PROB_DEVICE_NOT_THERE",
    "CM_PROB_MOVED",
    "CM_PROB_TOO_EARLY",
    "CM_PROB_NO_VALID_LOG_CONF",
    "CM_PROB_FAILED_INSTALL",
    "CM_PROB_HARDWARE_DISABLED",
    "CM_PROB_CANT_SHARE_IRQ",
    "CM_PROB_FAILED_ADD",
    "CM_PROB_DISABLED_SERVICE",
    "CM_PROB_TRANSLATION_FAILED",
    "CM_PROB_NO_SOFTCONFIG",
    "CM_PROB_BIOS_TABLE",
    "CM_PROB_IRQ_TRANSLATION_FAILED",
    "CM_PROB_FAILED_DRIVER_ENTRY",
    "CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD",
    "CM_PROB_DRIVER_FAILED_LOAD",
    "CM_PROB_DRIVER_SERVICE_KEY_INVALID",
    "CM_PROB_LEGACY_SERVICE_NO_DEVICES",
    "CM_PROB_DUPLICATE_DEVICE",
    "CM_PROB_FAILED_POST_START",
    "CM_PROB_HALTED",
    "CM_PROB_PHANTOM",
    "CM_PROB_SYSTEM_SHUTDOWN",
    "CM_PROB_HELD_FOR_EJECT",
    "CM_PROB_DRIVER_BLOCKED",
    "CM_PROB_REGISTRY_TOO_LARGE"
};

extern
VOID
DevExtIsapnp(
    ULONG64 Extension
    );

extern
VOID
DevExtPcmcia(
    ULONG64 Extension
    );

extern
VOID
DevExtUsbd(
    ULONG64 Extension
    );

extern
VOID
DevExtOpenHCI(
    ULONG64 Extension
    );

extern
VOID
DevExtUHCD(
    ULONG64 Extension
    );

extern
VOID
DevExtHID(
    ULONG64   Extension
    );

extern
VOID
DevExtUsbhub(
    ULONG64   Extension
    );

VOID
DumpResourceDescriptorHeader(
    ULONG Depth,
    ULONG Number,
    UCHAR Option,
    UCHAR Type,
    UCHAR SharingDisposition,
    USHORT Flags
    );

BOOLEAN
DumpDevNode(
    ULONG64         DeviceNode,
    ULONG           Depth,
    BOOLEAN         DumpSibling,
    BOOLEAN         DumpChild,
    BOOLEAN         DumpCmRes,
    BOOLEAN         DumpCmResReqList,
    BOOLEAN         DumpCmResTrans,
    BOOLEAN         DumpOnlyDevnodesWithProblems,
    BOOLEAN         DumpOnlyNonStartedDevnodes,
    PUNICODE_STRING ServiceName,
    BOOLEAN         PrintDefault
    );

BOOLEAN
DumpPendingEjects(
    BOOLEAN DumpCmRes,
    BOOLEAN DumpCmResReqList,
    BOOLEAN DumpCmResTrans
    );

BOOLEAN
DumpPendingRemovals(
    BOOLEAN DumpCmRes,
    BOOLEAN DumpCmResReqList,
    BOOLEAN DumpCmResTrans
    );


BOOLEAN
DumpDeviceEventEntry(
    ULONG64                 DeviceEvent,
    ULONG64                 ListHead,
    BOOL                    FollowLinks
    );
VOID
DumpPlugPlayEventBlock(
    ULONG64                 PlugPlayEventBlock,
    ULONG                   Size
    );


BOOLEAN
DumpResourceList64(
    LPSTR Description,
    ULONG Depth,
    ULONG64 ResourceList
    );

BOOLEAN
DumpResourceRequirementList64(
    ULONG   Depth,
    ULONG64 ResourceRequirementList
    );

BOOLEAN
DumpE820ResourceList64(
    ULONG   Depth,
    ULONG64 ResourceList
    );

BOOLEAN
DumpArbiter(
    IN DWORD   Depth,
    IN ULONG64 ArbiterAddr,
    IN BOOLEAN DisplayAliases
    );

#define ARBITER_DUMP_IO         0x1
#define ARBITER_DUMP_MEMORY     0x2
#define ARBITER_DUMP_IRQ        0x4
#define ARBITER_DUMP_DMA        0x8
#define ARBITER_DUMP_BUS_NUMBER 0x10
#define ARBITER_NO_DUMP_ALIASES 0x100

#define ARBITER_DUMP_ALL    (ARBITER_DUMP_IO        |  \
                             ARBITER_DUMP_MEMORY    |  \
                             ARBITER_DUMP_IRQ       |  \
                             ARBITER_DUMP_DMA       |  \
                             ARBITER_DUMP_BUS_NUMBER)

BOOLEAN
DumpArbitersForDevNode(
    IN DWORD   Depth,
    IN ULONG64 DevNodeAddr,
    IN DWORD   Flags
    );

BOOLEAN
DumpRangeList(
    IN DWORD   Depth,
    IN ULONG64 RangeListHead,
    IN BOOLEAN IsMerged,
    IN BOOLEAN OwnerIsDevObj,
    IN BOOLEAN DisplayAliases
    );

VOID
PrintDevNodeState(
    IN ULONG Depth,
    IN PUCHAR Field,
    IN ULONG State
    );

DECLARE_API( ioreslist )

/*++

Routine Description:

    Dump a device object.

Arguments:

    args - the location of the device object to dump.

Return Value:

    None

--*/

{
    ULONG64 requirementList;

    requirementList = GetExpression(args);
    DumpResourceRequirementList64(0, requirementList);

    return S_OK;
}

DECLARE_API( cmreslist )

/*++

Routine Description:

    Dump a device object.

Arguments:

    args - the location of the device object to dump.

Return Value:

    None

--*/

{
    ULONG64 resourceList;

    resourceList = GetExpression(args);
    DumpResourceList64("CmResourceList", 0, resourceList);

    return S_OK;
}

DECLARE_API( e820reslist )

/*++

Routine Description:

    Dump an e820 resource table

Arguments:

    args - the location of the resources list to dump

Return Value:

    None

--*/
{
    ULONG64 resourceList;

    resourceList = GetExpression(args);
    DumpE820ResourceList64(0, resourceList );
    return S_OK;
}

#define DUMP_CHILD                  1
#define DUMP_CM_RES                 2
#define DUMP_CM_RES_REQ_LIST        4
#define DUMP_CM_RES_TRANS           8
#define DUMP_NOT_STARTED            0x10
#define DUMP_PROBLEMS               0x20

BOOLEAN
xReadMemory(
    ULONG64 S,
    PVOID D,
    ULONG Len
    )
{
    ULONG result;

    return (ReadMemory((S), D, Len, &result) && (result == Len));
}

DECLARE_API( devnode )

/*++

Routine Description:

    Dump a device object.

Arguments:

    args - the location of the device object to dump.

Return Value:

    None

--*/

{
    ULONG64         deviceNode=0;
    ULONG           verbose = 0;
    PUCHAR          buffer = NULL;
    UNICODE_STRING  serviceName;
    ANSI_STRING     ansiString;
    BOOLEAN         serviceNameAllocated = FALSE;
    NTSTATUS        status;
    ULONG64         tmp;

    buffer = LocalAlloc(LPTR, 256);
    if (buffer) {

        RtlZeroMemory(buffer, 256);

        if (GetExpressionEx(args, &deviceNode, &args)) {
            if (sscanf(args, "%lx %s", &verbose, buffer)) {

                if (buffer [0] != '\0') {

                    RtlInitAnsiString(&ansiString, (PCSZ)buffer);

                    status = RtlAnsiStringToUnicodeString(&serviceName,
                                                          &ansiString,
                                                          TRUE);
                    if (NT_SUCCESS(status)) {
                        serviceNameAllocated = TRUE;
                    }
                }
            }

        }
        LocalFree(buffer);
    } else if (GetExpressionEx(args, &deviceNode, &args)) {
        if (sscanf(args,"%lx", &tmp)) {
            verbose = (ULONG) tmp;
        }
    }

    if (deviceNode == 0) {
        ULONG64 addr = GetExpression( "nt!IopRootDeviceNode" );
        ULONG64 dummy;

        if (addr == 0) {
            dprintf("Error retrieving address of IopRootDeviceNode\n");
            return E_INVALIDARG;
        }

        if (!ReadPointer(addr, &deviceNode)) {
            dprintf("Error reading value of IopRootDeviceNode (%#010p)\n", addr);
            return E_INVALIDARG;
        }

        dprintf("Dumping IopRootDeviceNode (= %#08p)\n", deviceNode);

    } else if (deviceNode == 1) {

        DumpPendingRemovals((BOOLEAN) ((verbose & DUMP_CM_RES) != 0),
                            (BOOLEAN) ((verbose & DUMP_CM_RES_REQ_LIST) != 0),
                            (BOOLEAN) ((verbose & DUMP_CM_RES_TRANS) != 0)
                            );
        return E_INVALIDARG;

    } else if (deviceNode == 2) {

        DumpPendingEjects((BOOLEAN) ((verbose & DUMP_CM_RES) != 0),
                          (BOOLEAN) ((verbose & DUMP_CM_RES_REQ_LIST) != 0),
                          (BOOLEAN) ((verbose & DUMP_CM_RES_TRANS) != 0)
                          );
        return E_INVALIDARG;

    }

    if (serviceNameAllocated) {
        DumpDevNode( deviceNode,
                     0,
                     FALSE,
                     (BOOLEAN) ((verbose & DUMP_CHILD) != 0),
                     (BOOLEAN) ((verbose & DUMP_CM_RES) != 0),
                     (BOOLEAN) ((verbose & DUMP_CM_RES_REQ_LIST) != 0),
                     (BOOLEAN) ((verbose & DUMP_CM_RES_TRANS) != 0),
                     (BOOLEAN) ((verbose & DUMP_PROBLEMS) != 0),
                     (BOOLEAN) ((verbose & DUMP_NOT_STARTED) != 0),
                     &serviceName,
                     FALSE
                     );
        RtlFreeUnicodeString(&serviceName);
    } else {
        DumpDevNode( deviceNode,
                     0,
                     FALSE,
                     (BOOLEAN) ((verbose & DUMP_CHILD) != 0),
                     (BOOLEAN) ((verbose & DUMP_CM_RES) != 0),
                     (BOOLEAN) ((verbose & DUMP_CM_RES_REQ_LIST) != 0),
                     (BOOLEAN) ((verbose & DUMP_CM_RES_TRANS) != 0),
                     (BOOLEAN) ((verbose & DUMP_PROBLEMS) != 0),
                     (BOOLEAN) ((verbose & DUMP_NOT_STARTED) != 0),
                     NULL,
                     FALSE
                     );
    }

    return S_OK;
}

static CCHAR DebugBuffer[300];

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    )
{
    va_list ap;
    ULONG   i;

    for (i=0; i<Depth; i++) {
        dprintf ("  ");
    }

    va_start(ap, S);

    vsprintf(DebugBuffer, S, ap);

    dprintf(DebugBuffer);

    va_end(ap);
}

VOID
DumpFlags(
    ULONG Depth,
    LPSTR FlagDescription,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;

    UCHAR prolog[64];

    sprintf(prolog, "%s (%#010x)  ", FlagDescription, Flags);

    xdprintf(Depth, "%s", prolog);

    if (Flags == 0) {
        dprintf("\n");
        return;
    }

    memset(prolog, ' ', strlen(prolog));

    for (i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if ((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if (count != 0) {

                dprintf(", ");

                //
                // Only print two flags per line.
                //

                if ((count % 2) == 0) {
                    dprintf("\n");
                    xdprintf(Depth, "%s", prolog);
                }
            }

            dprintf("%s", flag->Name);

            count++;
        }
    }

    dprintf("\n");

    if ((Flags & (~mask)) != 0) {
        xdprintf(Depth, "%sUnknown flags %#010lx\n", prolog, (Flags & (~mask)));
    }

    return;
}

BOOLEAN
DumpE820ResourceList64(
    ULONG   Depth,
    ULONG64 ResourceList
    )
{
    BOOLEAN continueDump = TRUE;
    CHAR    Buff[80];
    ULONG   i;
    ULONG   ListOffset;
    ULONG64 Count;
    ULONG64 Type;
    ULONG64 V1;
    ULONG64 V2;

#define Res2(F, V) GetFieldValue(ResourceList, "nt!_ACPI_BIOS_MULTI_NODE", #F, V)
#define Res(F)     GetFieldValue(ResourceList, "nt!_ACPI_BIOS_MULTI_NODE", #F, F)
#define Entry(F,V) (sprintf(Buff,"E820Entry[%lx].%s",i,#F),\
                    GetFieldValue(ResourceList,"nt!_ACPI_BIOS_MULTI_NODE", Buff, V))


    if (ResourceList == 0) {
        goto GetOut;
    }
    if (Res(Count)) {
        goto GetOut;
    }
    if (Count == 0) {
        goto GetOut;
    }

    xdprintf(Depth, "ACPI_BIOS_MULTI_NODE (an E820 Resource List) at %#010p\n", ResourceList);
    Depth++;

    for (i = 0; i < Count; i++) {

        if (CheckControlC()) {
            continueDump = FALSE;
            break;
        }
        Entry(Type,Type);

        switch(Type) {
            case 1: // AcpiAddressRangeMemory
                xdprintf(Depth,"Memory   - ");
                break;
            case 2: // AcpiAddressRangeReserved
                xdprintf(Depth,"Reserved - ");
                break;
            case 3: // AcpiAddressRangeACPI
                xdprintf(Depth,"ACPI     - ");
                break;
            case 4: // AcpiAddressRangeNVS
                xdprintf(Depth,"NVS      - ");
                break;
            case 5: // AcpiAddressRangeMaximum
            default:
                xdprintf(Depth,"Unknown  - ");
                break;
        }

        Entry(Base.QuadPart, V1);
        Entry(Length.QuadPart, V2);
        dprintf( "%16I64x - %#16I64x (Length %#10I64x)", V1, (V1 + V2 - 1), V2 );
        if (Type == 2) {
            dprintf(" [Ignored]");
        }
        if (Type == 3 || Type == 4) {
            if (V2 > 0xFFFFFFFF) {
                dprintf(" [Illegal Range]");
            }
        }
        dprintf("\n");
    }
    GetOut:
#undef Res
#undef Res2
#undef Entry
    return continueDump;
}

BOOLEAN
DumpResourceRequirementList64(
    ULONG    Depth,
    ULONG64  ResourceRequirementList
    )
{
    ULONG64   requirementList = 0;
    ULONG64   resourceList;
    ULONG64   descriptors;
    ULONG     ListSize;

    ULONG     i;
    ULONG     j;
    ULONG     k;
    ULONG     result;
    BOOLEAN   continueDump = TRUE;
    ULONG     InterfaceType, BusNumber, SlotNumber, Reserved1, Reserved2, Reserved3;
    ULONG     AlternativeLists;
    ULONG     ListOffset, SizeOfIoResList, SizeofIoDesc;

#define Res2(F, V) GetFieldValue(ResourceRequirementList, "nt!_IO_RESOURCE_REQUIREMENTS_LIST", #F, V)
#define Res(F)     GetFieldValue(ResourceRequirementList, "nt!_IO_RESOURCE_REQUIREMENTS_LIST", #F, F)

    if (ResourceRequirementList == 0) {
        goto GetOut;
    }

    if (Res(ListSize)) {
        goto GetOut;
    }

    if (ListSize == 0) {
        goto GetOut;
    }

    Res(InterfaceType); Res(BusNumber); Res(SlotNumber);
    xdprintf(Depth, "IoResList at ");
    dprintf("%#010p : Interface %#x  Bus %#x  Slot %#x\n",
            ResourceRequirementList,
            InterfaceType,
            BusNumber,
            SlotNumber);

    Res2(Reserved[0], Reserved1); Res2(Reserved[1], Reserved2);
    Res2(Reserved[2], Reserved3);
    if ((Reserved1 |
         Reserved2 |
         Reserved3) != 0) {

        xdprintf(Depth, "Reserved Values = {%#010lx, %#010lx, %#010lx}\n",
                 Reserved1,
                 Reserved2,
                 Reserved3);
    }

    Depth++;

    Res(AlternativeLists);
    GetFieldOffset("nt!_IO_RESOURCE_REQUIREMENTS_LIST", "List", &ListOffset);
    resourceList = ResourceRequirementList + ListOffset;
    SizeOfIoResList = GetTypeSize("IO_RESOURCE_LIST");
    SizeofIoDesc = GetTypeSize("IO_RESOURCE_DESCRIPTOR");
    for (i = 0; i < AlternativeLists; i++) {
        ULONG Version, Revision, Count;

        if (CheckControlC()) {
            continueDump = FALSE;
            break;
        }

        GetFieldValue(resourceList, "nt!_IO_RESOURCE_LIST", "Version", Version);
        GetFieldValue(resourceList, "nt!_IO_RESOURCE_LIST", "Revision", Revision);
        GetFieldValue(resourceList, "nt!_IO_RESOURCE_LIST", "Count", Count);

        xdprintf(Depth, "Alternative %d (Version %d.%d)\n",
                 i,
                 Version,
                 Revision);

        Depth++;

        for (j = 0; j < Count; j++) {
            CHAR Buff[80];
            ULONG64 Q1, Q2;
            ULONG Option, Type, ShareDisposition, Flags, V1, V2, V3, Data[3];

#define Desc(F,V) (sprintf(Buff,"Descriptors[%lx].%s",j, #F), \
                   GetFieldValue(resourceList, "nt!_IO_RESOURCE_LIST", Buff, V))

            if (CheckControlC()) {
                continueDump = FALSE;
                goto GetOut;
            }

//            descriptors = resourceList->Descriptors + j;

            Desc(Option,Option); Desc(Type,Type);
            Desc(ShareDisposition,ShareDisposition);
            Desc(Flags,Flags);

            DumpResourceDescriptorHeader(Depth,
                                         j,
                                         (UCHAR)Option,
                                         (UCHAR) Type,
                                         (UCHAR) ShareDisposition,
                                         (USHORT) Flags);

            Depth++;

            switch (Type) {
            case CmResourceTypeBusNumber:

                Desc(u.BusNumber.MinBusNumber, V1);
                Desc(u.BusNumber.MaxBusNumber, V2);
                Desc(u.BusNumber.Length, V3);
                xdprintf(Depth, "0x%x - 0x%x for length 0x%x\n",
                         V1, V2, V3);
                break;

            case CmResourceTypePort:
            case CmResourceTypeMemory:
                Desc(u.Generic.Length, V1);
                Desc(u.Generic.Alignment, V2);
                Desc(u.Port.MinimumAddress.QuadPart, Q1);
                Desc(u.Port.MaximumAddress.QuadPart, Q2);
                xdprintf(Depth, "%#08lx byte range with alignment %#08lx\n", V1, V2);
                xdprintf(Depth, "%I64x - %#I64x\n", Q1, Q2);
                break;

            case CmResourceTypeInterrupt:

                Desc(u.Interrupt.MinimumVector,V1);
                Desc(u.Interrupt.MaximumVector,V2);
                xdprintf(Depth, "0x%x - 0x%x\n", V1,V2);
                break;

            default:
                Desc(u.DevicePrivate.Data, Data);
                xdprintf(Depth,
                         "Data:              : 0x%x 0x%x 0x%x\n",
                         Data[0],
                         Data[1],
                         Data[2]);
                break;
            }

            Depth--;
#undef Desc
        }

        Depth--;

        resourceList += (SizeOfIoResList + SizeofIoDesc*(j-1));
    }

GetOut:
    xdprintf(Depth, "\n");
#undef Res
#undef Res2
    return continueDump;
}

BOOLEAN
DumpResourceList64(
    LPSTR Description,
    ULONG Depth,
    ULONG64 ResourceList
    )
{
    ULONG64  resourceListWalker;
    ULONG    i;
    ULONG    j;
    ULONG    k;
    BOOLEAN  continueDump = TRUE;
    ULONG Count, ListSize, ListOffset;
    ULONG64 ListAddr;

    if (ResourceList == 0) {

        goto GetOut;
    }

    resourceListWalker = ResourceList;

    if (GetFieldOffset("nt!_CM_RESOURCE_LIST", "List", &ListOffset)) {
        goto GetOut;
    }
    ListAddr = ResourceList + ListOffset;


    GetFieldValue(ResourceList, "nt!_CM_RESOURCE_LIST", "Count", Count);


    resourceListWalker = ListAddr;

    for (i = 0; i < Count; i++) {
        ULONG Partial_Count=0, PartialListAddr, BusNumber=0, Partial_Version=0, Partial_Revision=0;
        CHAR ResListType[] = "nt!_CM_FULL_RESOURCE_DESCRIPTOR";
        ULONG64 InterfaceType=0;
        ULONG PartDescOffset;

        if (CheckControlC()) {
            continueDump = FALSE;
            break;
        }

        GetFieldValue(resourceListWalker, ResListType, "InterfaceType", InterfaceType);
        GetFieldValue(resourceListWalker, ResListType, "BusNumber",     BusNumber);
        GetFieldValue(resourceListWalker, ResListType, "PartialResourceList.Version",   Partial_Version);
        GetFieldValue(resourceListWalker, ResListType, "PartialResourceList.Revision",  Partial_Revision);
        GetFieldValue(resourceListWalker, ResListType, "PartialResourceList.Count",     Partial_Count);

        GetFieldOffset(ResListType, "PartialResourceList.PartialDescriptors", &PartDescOffset);
        resourceListWalker = resourceListWalker + PartDescOffset;

        xdprintf(Depth, "%s at ", Description);
        dprintf("%#010p  Version %d.%d  Interface %#x  Bus #%#x\n",
                ResourceList,
                Partial_Version,
                Partial_Revision,
                (ULONG) InterfaceType,
                BusNumber);

        Depth++;

        for (j = 0; j < Partial_Count; j++) {
            CHAR PartResType[] = "nt!_CM_PARTIAL_RESOURCE_DESCRIPTOR";
            ULONG Type=0, ShareDisposition=0, Flags=0, sz,  u_Port_Length=0, u_Memory_Length=0,
                u_Interrupt_Level=0, u_Interrupt_Vector=0,
                u_Dma_Channel=0, u_Dma_Port=0, u_Dma_Reserved1=0, u_BusNumber_Start=0,
                u_BusNumber_Length=0, u_DevicePrivate_Data[3];
            ULONG64 u_Port_QuadPart=0, u_Memory_QuadPart=0, u_Interrupt_Affinity=0;

            if (CheckControlC()) {
                continueDump = FALSE;
                goto GetOut;
            }

            sz = GetTypeSize(PartResType);
            if (GetFieldValue(resourceListWalker,
                              PartResType,
                              "Type",
                              Type)) {
                goto GetOut;
            }
            GetFieldValue(resourceListWalker, PartResType, "ShareDisposition", ShareDisposition);
            GetFieldValue(resourceListWalker, PartResType, "Flags", Flags);


            xdprintf(Depth, "Entry %d - %s (%#x) %s (%#x)\n",
                     j,
                     (Type == CmResourceTypeNull ? "Null" :
                      Type == CmResourceTypePort ? "Port" :
                      Type == CmResourceTypeInterrupt ? "Interrupt" :
                      Type == CmResourceTypeMemory ? "Memory" :
                      Type == CmResourceTypeDma ? "Dma" :
                      Type == CmResourceTypeDeviceSpecific ? "DeviceSpecific" :
                      Type == CmResourceTypeBusNumber ? "BusNumber" :
                      Type == CmResourceTypeDevicePrivate ? "DevicePrivate" :
                      Type == CmResourceTypeConfigData ? "ConfigData" : "Unknown"),
                      Type,
                     (ShareDisposition == CmResourceShareUndetermined ? "Undetermined Sharing" :
                      ShareDisposition == CmResourceShareDeviceExclusive ? "Device Exclusive" :
                      ShareDisposition == CmResourceShareDriverExclusive ? "Driver Exclusive" :
                      ShareDisposition == CmResourceShareShared ? "Shared" : "Unknown Sharing"),
                      ShareDisposition);

            Depth++;

            xdprintf(Depth, "Flags (%#04wx) - ", Flags);

            switch (Type) {

            case CmResourceTypePort:

                //
                // CM_RESOURCE_PORT_MEMORY = ~CM_RESOURCE_PORT_IO
                //
                if ( (~Flags) & ~CM_RESOURCE_PORT_MEMORY) {
                    dprintf("PORT_MEMORY ");
                }
                if (Flags & CM_RESOURCE_PORT_IO) {
                    dprintf("PORT_IO ");
                }
                if (Flags & CM_RESOURCE_PORT_10_BIT_DECODE) {
                    dprintf("10_BIT_DECODE ");
                }
                if (Flags & CM_RESOURCE_PORT_12_BIT_DECODE) {
                    dprintf("12_BIT_DECODE ");
                }
                if (Flags & CM_RESOURCE_PORT_16_BIT_DECODE) {
                    dprintf("16_BIT_DECODE ");
                }
                if (Flags & CM_RESOURCE_PORT_POSITIVE_DECODE) {
                    dprintf("POSITIVE_DECODE ");
                }
                if (Flags & CM_RESOURCE_PORT_PASSIVE_DECODE) {
                    dprintf ("PASSIVE_DECODE ");
                }
                if (Flags & CM_RESOURCE_PORT_WINDOW_DECODE) {
                    dprintf ("WINDOW_DECODE ");
                }

                dprintf("\n");

                GetFieldValue(resourceListWalker, PartResType, "u.Port.Start.QuadPart", u_Port_QuadPart);
                GetFieldValue(resourceListWalker, PartResType, "u.Port.Length",         u_Port_Length);

                xdprintf(Depth, "Range starts at %#I64lx for %#x bytes\n",
                         u_Port_QuadPart,
                         u_Port_Length);

                break;

            case CmResourceTypeMemory:

                if (Flags == CM_RESOURCE_MEMORY_READ_WRITE) {
                    dprintf("READ_WRITE ");
                }
                if (Flags & CM_RESOURCE_MEMORY_READ_ONLY) {
                    dprintf("READ_ONLY ");
                }
                if (Flags & CM_RESOURCE_MEMORY_WRITE_ONLY) {
                    dprintf("WRITE_ONLY ");
                }
                if (Flags & CM_RESOURCE_MEMORY_PREFETCHABLE) {
                    dprintf("PREFETCHABLE ");
                }
                if (Flags & CM_RESOURCE_MEMORY_COMBINEDWRITE) {
                    dprintf("COMBINEDWRITE ");
                }
                if (Flags & CM_RESOURCE_MEMORY_24) {
                    dprintf("MEMORY_24 ");
                }

                dprintf("\n");

                GetFieldValue(resourceListWalker, PartResType, "u.Memory.Start.QuadPart", u_Memory_QuadPart);
                GetFieldValue(resourceListWalker, PartResType, "u.Memory.Length",       u_Memory_Length);

                xdprintf(Depth, "Range starts at %#018I64lx for %#x bytes\n",
                         u_Memory_QuadPart,
                         u_Memory_Length);

                break;

            case CmResourceTypeInterrupt:

                if (Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
                    dprintf("LEVEL_SENSITIVE ");
                }
                if (Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
                    dprintf("LATCHED ");
                }

                dprintf("\n");

                GetFieldValue(resourceListWalker, PartResType, "u.Interrupt.Level",     u_Interrupt_Level);
                GetFieldValue(resourceListWalker, PartResType, "u.Interrupt.Vector",    u_Interrupt_Vector);
                GetFieldValue(resourceListWalker, PartResType, "u.Interrupt.Affinity",  u_Interrupt_Affinity);

                xdprintf(Depth, "Level %#x, Vector %#x, Affinity %#I64x\n",
                         u_Interrupt_Level,
                         u_Interrupt_Vector,
                         u_Interrupt_Affinity);

                break;

            case CmResourceTypeDma:

                if (Flags & CM_RESOURCE_DMA_8) {
                    dprintf("DMA_8 ");
                }
                if (Flags & CM_RESOURCE_DMA_16) {
                    dprintf("DMA_16 ");
                }
                if (Flags & CM_RESOURCE_DMA_32) {
                    dprintf("DMA_32 ");
                }
                if (Flags & CM_RESOURCE_DMA_8_AND_16) {
                    dprintf("DMA_8_AND_16 ");
                }
                if (Flags & CM_RESOURCE_DMA_BUS_MASTER) {
                    dprintf("DMA_BUS_MASTER ");
                }
                if (Flags & CM_RESOURCE_DMA_TYPE_A) {
                    dprintf("DMA_A ");
                }
                if (Flags & CM_RESOURCE_DMA_TYPE_B) {
                    dprintf("DMA_B ");
                }
                if (Flags & CM_RESOURCE_DMA_TYPE_F) {
                    dprintf("DMA_F ");
                }
                dprintf("\n");

                GetFieldValue(resourceListWalker, PartResType, "u.Dma.Channel",         u_Dma_Channel);
                GetFieldValue(resourceListWalker, PartResType, "u.Dma.Port",            u_Dma_Port);
                GetFieldValue(resourceListWalker, PartResType, "u.Dma.Reserved1",       u_Dma_Reserved1);

                xdprintf(Depth, "Channel %#x Port %#x (Reserved1 %#x)\n",
                         u_Dma_Channel,
                         u_Dma_Port,
                         u_Dma_Reserved1);
                break;

            case CmResourceTypeBusNumber:

                dprintf("\n");

                GetFieldValue(resourceListWalker, PartResType, "u.BusNumber.Start",     u_BusNumber_Start);
                GetFieldValue(resourceListWalker, PartResType, "u.BusNumber.Length",    u_BusNumber_Length);

                xdprintf(Depth, "Range starts at %#010lx for %#x values\n",
                         u_BusNumber_Start,
                         u_BusNumber_Length);
                break;

            default:

                dprintf("\n");

                GetFieldValue(resourceListWalker, PartResType, "u.DevicePrivate.Data",  u_DevicePrivate_Data);

                xdprintf(Depth, "Data - {%#010lx, %#010lx, %#010lx}\n",
                         u_DevicePrivate_Data[0],
                         u_DevicePrivate_Data[1],
                         u_DevicePrivate_Data[2]);
                break;
            }

            Depth--;
            resourceListWalker += sz; // sizeof(partialDescriptors);
        }
    }

GetOut:
    xdprintf(Depth, "\n");

    return continueDump;
}

BOOLEAN
DumpRelationsList(
    ULONG64 RelationsList,
    BOOLEAN DumpCmRes,
    BOOLEAN DumpCmResReqList,
    BOOLEAN DumpCmResTrans
    )
{
    ULONG64 listEntryAddr;
    ULONG64 deviceObjectAddr;
    ULONG i, j, EntrySize;
    BOOLEAN continueDump = TRUE;
    CHAR    RelListType[] = "nt!_RELATION_LIST", RelListentryType[] = "nt!_RELATION_LIST_ENTRY";
    ULONG64 EntryAddr;
    ULONG Count=0, TagCount=0, FirstLevel=0, MaxLevel=0;
    ULONG EntryOffset;

    if (GetFieldValue(RelationsList, RelListType, "Count",Count)) {
        xdprintf(1, "Error reading relation list @ ");
        dprintf("0x%08p)\n", RelationsList);
        return continueDump;
    }
    EntrySize = DBG_PTR_SIZE;
    GetFieldOffset(RelListType, "Entries", &EntryOffset);
    EntryAddr=RelationsList + EntryOffset;


    GetFieldValue(RelationsList, RelListType, "TagCount",   TagCount);
    GetFieldValue(RelationsList, RelListType, "FirstLevel", FirstLevel);
    GetFieldValue(RelationsList, RelListType, "MaxLevel",   MaxLevel);

    xdprintf(1, "Relation List @ "); dprintf("0x%08p\n", RelationsList);
    xdprintf(2, "Count = %d, TagCount = %d, FirstLevel = %d, MaxLevel = %d\n",
             Count,
             TagCount,
             FirstLevel,
             MaxLevel);

    for (i = 0; i <= (MaxLevel - FirstLevel); i++) {
        ULONG res,Entry_Count=0, MaxCount=0, DeviceSize;
        ULONG64 DeviceAddr;
        FIELD_INFO relListEntryFields[] = {
            {"Devices",    "", 0, DBG_DUMP_FIELD_RETURN_ADDRESS,  0, NULL},
        };

        if (CheckControlC()) {
            continueDump = FALSE;
            break;
        }

        listEntryAddr = 0;
        if (ReadPointer( EntryAddr + i*EntrySize,
                        &listEntryAddr)) {

            if (!listEntryAddr) {
                xdprintf(2, "Null relation list entry\n");

            }else if (!GetFieldValue(listEntryAddr, RelListentryType,
                                     "Count",Entry_Count)) {
                ULONG DeviceOffset;

                GetFieldOffset(RelListentryType, "Devices", &DeviceOffset);
                DeviceAddr = listEntryAddr + DeviceOffset;
                DeviceSize = EntrySize; // == pointer size


                GetFieldValue(listEntryAddr, RelListentryType, "MaxCount",   MaxCount);

                xdprintf(2, "Relation List Entry @ "); dprintf("0x%08p\n", listEntryAddr);
                xdprintf(3, "Count = %d, MaxCount = %d\n", Entry_Count, MaxCount);
                xdprintf(3, "Devices at level %d\n", FirstLevel + i);


                for (j = 0; j < Entry_Count; j++) {
                    if (CheckControlC()) {
                        continueDump = FALSE;
                        break;
                    }

                    if (ReadPointer( DeviceAddr + j*DeviceSize,
                                    &deviceObjectAddr)) {
                        ULONG64 DeviceNode=0;
                        FIELD_INFO DevObjFields[] = {
                            // Implicitly reads the pointer DeviceObjectExtension and its field DeviceNode
                            {"DeviceObjectExtension", "", 0, DBG_DUMP_FIELD_RECUR_ON_THIS, 0, NULL},
                            {"DeviceObjectExtension.DeviceNode", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &DeviceNode}
                        };

                        if (!deviceObjectAddr) {
                            continue;
                        }

                        xdprintf(4, "Device Object = ");
                        dprintf("0x%08p (%sagged, %sirect)\n",
                                deviceObjectAddr & ~3,
                                (deviceObjectAddr & 1) ? "T" : "Not t",
                                (deviceObjectAddr & 2) ? "D" : "Ind");

                        if (!GetFieldValue(deviceObjectAddr, "nt!_DEVICE_OBJECT",
                                           "DeviceObjectExtension.DeviceNode",
                                           DeviceNode)) {
                            if (DeviceNode) {
                                continueDump = DumpDevNode(DeviceNode,
                                                           5,
                                                           FALSE,
                                                           FALSE,
                                                           DumpCmRes,
                                                           DumpCmResReqList,
                                                           DumpCmResTrans,
                                                           FALSE,
                                                           FALSE,
                                                           (PUNICODE_STRING)NULL,
                                                           TRUE);
                            }


                        } else {

                            xdprintf(5, "Error reading device object @ ");
                            dprintf("0x%08p)\n",deviceObjectAddr);
                        }
                    } else {

                        xdprintf(4, "Error reading relation list entry device ");
                        dprintf("%d @ 0x%08p)\n",
                                j,
                                DeviceAddr + j*DeviceSize);
                    }
                    if (!continueDump) {
                        break;
                    }
                }
            } else {

                xdprintf(2, "Error reading relation list entry @ ");
                dprintf("0x%08p)\n",
                        listEntryAddr);
            }
        } else {
            xdprintf(1, "Error reading relation list entry ");
            dprintf("%d @ 0x%08p)\n",
                    i,
                    EntryAddr + i*EntrySize);
        }
        if (!continueDump) {
            break;
        }
    }
    return continueDump;
}

BOOLEAN
DumpPendingRemovals(
    BOOLEAN DumpCmRes,
    BOOLEAN DumpCmResReqList,
    BOOLEAN DumpCmResTrans
    )
{
    ULONG64 listHeadAddr, pendingEntryAddr;
    BOOLEAN continueDump = TRUE;
    ULONG64 Head_Blink=0, Head_Flink=0, Link_Flink=0;

    listHeadAddr = GetExpression( "nt!IopPendingSurpriseRemovals" );

    if (listHeadAddr == 0) {
        dprintf("Error retrieving address of IopPendingSurpriseRemovals\n");
        return continueDump;
    }

    if (GetFieldValue(listHeadAddr, "nt!_LIST_ENTRY", "Flink", Head_Flink) ||
        GetFieldValue(listHeadAddr, "nt!_LIST_ENTRY", "Blink", Head_Blink)) {
        dprintf("Error reading value of IopPendingSurpriseRemovals (0x%08p)\n", listHeadAddr);
        return continueDump;
    }

    if (Head_Flink == listHeadAddr) {
        dprintf("There are no removals currently pending\n");
        return continueDump;
    }

    for (pendingEntryAddr = Head_Flink;
         pendingEntryAddr != listHeadAddr;
         pendingEntryAddr = Link_Flink) {
        ULONG64 RelationsList=0, DeviceObject=0;
        if (CheckControlC()) {
            continueDump = FALSE;
            break;
        }


        if (GetFieldValue(pendingEntryAddr, "nt!_PENDING_RELATIONS_LIST_ENTRY", "DeviceObject", DeviceObject)){
            dprintf("Error reading pending relations list entry (0x%08p)\n", pendingEntryAddr);
            return continueDump;
        }
        GetFieldValue(pendingEntryAddr, "nt!_PENDING_RELATIONS_LIST_ENTRY", "Link.Flink", Link_Flink);
        GetFieldValue(pendingEntryAddr, "nt!_PENDING_RELATIONS_LIST_ENTRY", "RelationsList", RelationsList);

        dprintf("Pending Removal of PDO 0x%08p, Pending Relations List Entry @ 0x%08p\n",
                DeviceObject,
                pendingEntryAddr
                );

        continueDump = DumpRelationsList( RelationsList,
                                          DumpCmRes,
                                          DumpCmResReqList,
                                          DumpCmResTrans
                                          );

        if (!continueDump) {
            break;
        }
    }

    return continueDump;
}

BOOLEAN
DumpPendingEjects(
    BOOLEAN DumpCmRes,
    BOOLEAN DumpCmResReqList,
    BOOLEAN DumpCmResTrans
    )
{
    ULONG64 listHeadAddr, pendingEntryAddr;
    BOOLEAN continueDump = TRUE;
    ULONG64 Head_Blink=0, Head_Flink=0, Link_Flink=0;

    listHeadAddr = GetExpression( "nt!IopPendingEjects" );

    if (listHeadAddr == 0) {
        dprintf("Error retrieving address of IopEjects\n");
        return continueDump;
    }

    if (GetFieldValue(listHeadAddr, "nt!_LIST_ENTRY", "Flink", Head_Flink) ||
        GetFieldValue(listHeadAddr, "nt!_LIST_ENTRY", "Blink", Head_Blink)) {
        dprintf("Error reading value of IopPendingSurpriseRemovals (0x%08p)\n", listHeadAddr);
        return continueDump;
    }

    if (Head_Flink == listHeadAddr) {
        dprintf("There are no ejects currently pending\n");
        return continueDump;
    }

    for (pendingEntryAddr = Head_Flink;
         pendingEntryAddr != listHeadAddr;
         pendingEntryAddr = Link_Flink) {
        ULONG64 RelationsList=0, DeviceObject=0, EjectIrp=0;

        if (CheckControlC()) {
            continueDump = FALSE;
            break;
        }

        if (GetFieldValue(pendingEntryAddr, "nt!_PENDING_RELATIONS_LIST_ENTRY", "DeviceObject", DeviceObject)){
            dprintf("Error reading pending relations list entry (0x%08p)\n", pendingEntryAddr);
            return continueDump;
        }
        GetFieldValue(pendingEntryAddr, "nt!_PENDING_RELATIONS_LIST_ENTRY", "Link.Flink", Link_Flink);
        GetFieldValue(pendingEntryAddr, "nt!_PENDING_RELATIONS_LIST_ENTRY", "RelationsList", RelationsList);
        GetFieldValue(pendingEntryAddr, "nt!_PENDING_RELATIONS_LIST_ENTRY", "EjectIrp", EjectIrp);

        dprintf("Pending Eject of PDO 0x%08p, EjectIrp = 0x%08p, \nPending Relations List Entry @ 0x%08p\n",
                DeviceObject,
                EjectIrp,
                pendingEntryAddr
                );

       continueDump = DumpRelationsList( RelationsList,
                     DumpCmRes,
                     DumpCmResReqList,
                     DumpCmResTrans
                     );

       if (!continueDump) {
       break;
       }
   }

   return continueDump;
}


BOOLEAN
DumpDevNode(
    ULONG64         DeviceNode,
    ULONG           Depth,
    BOOLEAN         DumpSibling,
    BOOLEAN         DumpChild,
    BOOLEAN         DumpCmRes,
    BOOLEAN         DumpCmResReqList,
    BOOLEAN         DumpCmResTrans,
    BOOLEAN         DumpOnlyDevnodesWithProblems,
    BOOLEAN         DumpOnlyNonStartedDevnodes,
    PUNICODE_STRING ServiceName OPTIONAL,
    BOOLEAN         PrintDefault
    )

/*++

Routine Description:

    Displays the driver name for the device object if FullDetail == FALSE.
    Otherwise displays more information about the device and the device queue.

Arguments:

    DeviceAddress - address of device object to dump.
    FullDetail    - TRUE means the device object name, driver name, and
                    information about Irps queued to the device.

    DumpOnlyDevnodesWithFlags -
        if set, then the only devnodes that will be dumped are
        those with one of the FlagsSet bits set or one of the
        FlagsNotSet bits not set.

Return Value:

    None

--*/

{
    ULONG           result;
//    DEVICE_NODE     deviceNode;
    BOOLEAN         print = TRUE;
    BOOLEAN         continueDump = TRUE;
    CHAR            DevNodeType[]="nt!_DEVICE_NODE";
    USHORT          ServiceName_Len=0, ServiceName_MaxLen=0, InstancePath_Len=0, InstancePath_Max=0;
    ULONG           Flags=0, BusNumber=0, Header_SignalState=0, UserFlags=0;
    ULONG           CapabilityFlags=0, DisableableDepends=0, Problem=0;
    ULONG           FailureStatus=0, State=0, PreviousState=0;
    ULONG           StateHistoryEntry = 0;
    ULONG           StateHistoryValue = 0;
    ULONG64         ServiceName_Buff=0, PhysicalDeviceObject=0, Parent=0, Sibling=0,
       Child=0, InterfaceType=0, DuplicatePDO=0, TargetDeviceNotify_Blink=0, TargetDeviceNotify_Flink=0,
       PreviousResourceList=0, ResourceList=0, BootResources=0, ResourceListTranslated=0,
       ResourceRequirements=0, InstancePath_Buff=0, PreviousResourceRequirements=0;
    ULONG64 TargetDeviceNotifyAddress;
    ULONG           AmountRead;

    PNP_DEVNODE_STATE StateHistory[STATE_HISTORY_SIZE];

    if (CheckControlC()) {
        return FALSE;
    }

    GetFieldOffset("nt!_DEVICE_NODE", "TargetDeviceNotify", &result);
    TargetDeviceNotifyAddress = DeviceNode + result;

#define DevFld(F) GetFieldValue(DeviceNode, DevNodeType, #F, F)
#define DevFld2(F, V) GetFieldValue(DeviceNode, DevNodeType, #F, V)

    if (DevFld2(ServiceName.Length, ServiceName_Len)) {
        xdprintf(Depth, "");
        dprintf("%08p: Could not read device node\n", DeviceNode);
        return TRUE;
    }

    DevFld2(ServiceName.MaximumLength, ServiceName_MaxLen);
    DevFld2(ServiceName.Buffer, ServiceName_Buff);
    DevFld(Flags);   DevFld(PhysicalDeviceObject); DevFld(Parent);
    DevFld(Sibling); DevFld(Child);                DevFld(InterfaceType);
    DevFld(BusNumber);DevFld(DuplicatePDO);        DevFld(State);
    DevFld(PreviousState);
    DevFld2(InstancePath.Length, InstancePath_Len);
    DevFld2(InstancePath.MaximumLength, InstancePath_Max);
    DevFld2(InstancePath.Buffer, InstancePath_Buff);
    DevFld2(TargetDeviceNotify.Blink, TargetDeviceNotify_Blink);
    DevFld2(TargetDeviceNotify.Flink, TargetDeviceNotify_Flink);
    DevFld(UserFlags); DevFld(CapabilityFlags);   DevFld(DisableableDepends);
    DevFld(Problem);   DevFld(FailureStatus);
    DevFld(PreviousResourceList);              DevFld(PreviousResourceRequirements);
    DevFld(ResourceList);
    DevFld(BootResources);                     DevFld(ResourceListTranslated);
    DevFld(ResourceRequirements);              DevFld(StateHistoryEntry);
#undef DevFld
#undef DevFld2

    //
    // Check if printing should be suppressed
    //
    if (!PrintDefault && ServiceName != NULL) {
        if ((ServiceName_Buff == 0) || (ServiceName_MaxLen <= 0)) {
            print = FALSE;
        } else {
            //
            // Compare the service names
            //
            UNICODE_STRING v;

            v.Buffer = LocalAlloc(LPTR, ServiceName_MaxLen);
            if (v.Buffer != NULL) {
                v.MaximumLength = ServiceName_MaxLen;
                v.Length = ServiceName_Len;
                if (ReadMemory(ServiceName_Buff,
                               v.Buffer,
                               ServiceName_Len,
                               (PULONG) &AmountRead)) {

                    if (RtlCompareUnicodeString(ServiceName,
                                                &v,
                                                TRUE) != 0) {
                        //
                        // We are not interested in this devnode
                        //
                        print = FALSE;
                    }
                }
                LocalFree(v.Buffer);
            }
        }
    }

    if (DumpOnlyDevnodesWithProblems) {
        print = (BOOLEAN) ((Flags & (DNF_HAS_PROBLEM | DNF_HAS_PRIVATE_PROBLEM)) != 0);
    } else if (DumpOnlyNonStartedDevnodes) {
        print = (BOOLEAN) (State != DeviceNodeStarted);
    }

    if (print) {
        xdprintf(Depth, "");
        dprintf("DevNode %#010p for PDO %#010p\n",
                DeviceNode,
                PhysicalDeviceObject);
        Depth++;

        if (!DumpChild) {
            xdprintf(Depth, "");
            dprintf("Parent %#010p   Sibling %#010p   Child %#010p\n",
                     Parent,
                     Sibling,
                     Child);

            if ((LONG) InterfaceType != -1 ||
                (BusNumber != -1 && BusNumber != -16)) {

                xdprintf(Depth, "InterfaceType %#x  Bus Number %#x\n",
                         (LONG) InterfaceType,
                         BusNumber);
            }

            if (DuplicatePDO != 0) {
                dprintf("Duplicate PDO %#010p", DuplicatePDO);
            }
        }

        if (InstancePath_Buff != 0) {
            UNICODE_STRING64 v;

            xdprintf(Depth, "InstancePath is \"");
            v.MaximumLength = InstancePath_Max;
            v.Length = InstancePath_Len;
                v.Buffer = InstancePath_Buff;
            DumpUnicode64(v);
            dprintf("\"\n");
        }

        if (ServiceName_Buff != 0) {
            UNICODE_STRING64 v;

            xdprintf(Depth, "ServiceName is \"");
            v.MaximumLength = ServiceName_MaxLen;
            v.Length = ServiceName_Len;
            v.Buffer = ServiceName_Buff;
            DumpUnicode64(v);
            dprintf("\"\n");
        }

        if ((TargetDeviceNotify_Flink != 0 ||
            TargetDeviceNotify_Blink != 0) &&
            (TargetDeviceNotify_Blink != TargetDeviceNotifyAddress ||
             TargetDeviceNotify_Flink != TargetDeviceNotifyAddress)) {
            xdprintf(Depth, "TargetDeviceNotify List - ");
            dprintf ("f %#010p  b %#010p\n",
                     TargetDeviceNotify_Flink,
                     TargetDeviceNotify_Blink);
        }

        PrintDevNodeState(Depth, "State", State);

        PrintDevNodeState(Depth, "Previous State", PreviousState);

        if (!DumpChild) {
            GetFieldOffset("nt!_DEVICE_NODE", "StateHistory", &result);

            if (ReadMemory(DeviceNode+result,
                           StateHistory,
                           sizeof(PNP_DEVNODE_STATE) * STATE_HISTORY_SIZE,
                           &AmountRead)) {

                UCHAR   Description[20];
                ULONG   index;
                INT     i;

                for (i = STATE_HISTORY_SIZE - 1; i >= 0; i--) {

                    index = (i + StateHistoryEntry) % STATE_HISTORY_SIZE;

                    sprintf(Description, "StateHistory[%02d]", index);
                    PrintDevNodeState(Depth, Description, StateHistory[index]);
                }
            }
            DumpFlags(Depth, "Flags", Flags, DeviceNodeFlags);

            if (UserFlags != 0) {
                DumpFlags(Depth, "UserFlags", UserFlags, DeviceNodeUserFlags);
            }

            if (CapabilityFlags != 0) {
                DumpFlags(Depth, "CapabilityFlags", CapabilityFlags, DeviceNodeCapabilityFlags);
            }

            if (DisableableDepends != 0) {
                xdprintf(Depth, "DisableableDepends = %d (%s)\n", DisableableDepends,
                                        (UserFlags&DNUF_NOT_DISABLEABLE)?"including self":"from children");
            }
        }

        if (Flags & DNF_HAS_PROBLEM) {

            if (Problem < NUM_CM_PROB && DevNodeProblems[Problem] != NULL) {
                xdprintf(Depth, "Problem = %s\n", DevNodeProblems[Problem]);
            } else {
                xdprintf(Depth, "Problem = Unknown problem (%d)\n", Problem);
            }
            if (Problem == CM_PROB_FAILED_START) {
                xdprintf(Depth, "Failure Status %#010lx\n", FailureStatus);
                continueDump = DumpResourceList64( "Previous CmResourceList",
                                                   Depth,
                           PreviousResourceList);

                if (continueDump) {

                    continueDump = DumpResourceRequirementList64( Depth,
                                                                  PreviousResourceRequirements);
                }
            }
        }

        if (continueDump && DumpCmRes) {
            continueDump = DumpResourceList64( "CmResourceList",
                                               Depth,
                                               ResourceList);

            if (continueDump) {
                continueDump = DumpResourceList64( "BootResourcesList",
                                                   Depth,
                                                   BootResources);
            }
        }

        if (continueDump && DumpCmResTrans) {
            continueDump = DumpResourceList64( "TranslatedResourceList",
                                               Depth,
                                               ResourceListTranslated);
        }

        if (continueDump && DumpCmResReqList) {
            continueDump = DumpResourceRequirementList64( Depth,
                                                          ResourceRequirements);
        }
    }

    if (continueDump && DumpChild && Child) {
        continueDump = DumpDevNode( Child,
                                    Depth,
                                    DumpChild,      // whem dumping a child, dump its siblings, too
                                    DumpChild,
                                    DumpCmRes,
                                    DumpCmResReqList,
                                    DumpCmResTrans,
                                    DumpOnlyDevnodesWithProblems,
                                    DumpOnlyNonStartedDevnodes,
                                    ServiceName,
                                    print
                                    );
    }

    if (continueDump && DumpSibling && Sibling) {
        continueDump = DumpDevNode( Sibling,
                                    (print ? (Depth - 1):Depth),
                                    DumpSibling,
                                    DumpChild,
                                    DumpCmRes,
                                    DumpCmResReqList,
                                    DumpCmResTrans,
                                    DumpOnlyDevnodesWithProblems,
                                    DumpOnlyNonStartedDevnodes,
                                    ServiceName,
                                    PrintDefault
                                    );
    }

    return continueDump;
}

LPSTR
GetCmResourceTypeString(
    IN UCHAR Type
    )
{
    LPSTR typeString;

    switch (Type) {
    case CmResourceTypeNull:
        typeString = "Null";
        break;

    case CmResourceTypePort:
        typeString = "Port";
        break;

    case CmResourceTypeInterrupt:
        typeString = "Interrupt";
        break;

    case CmResourceTypeMemory:
        typeString = "Memory";
        break;

    case CmResourceTypeDma:
        typeString = "Dma";
        break;

    case CmResourceTypeDeviceSpecific:
        typeString = "DeviceSpeific";
        break;

    case CmResourceTypeBusNumber:
        typeString = "BusNumber";
        break;

    case CmResourceTypeMaximum:
        typeString = "Maximum";
        break;

    case CmResourceTypeNonArbitrated:
        typeString = "NonArbitrated/ConfigData";
        break;

    case CmResourceTypeDevicePrivate:
        typeString = "DevicePrivate";
        break;

    case CmResourceTypePcCardConfig:
        typeString = "PcCardConfig";
        break;

    default:
        typeString = "Unknown";
        break;
    }

    return typeString;
}

VOID
DumpResourceDescriptorHeader(
    ULONG Depth,
    ULONG Number,
    UCHAR Option,
    UCHAR Type,
    UCHAR SharingDisposition,
    USHORT Flags
    )
{
    PUCHAR typeString;
    PUCHAR sharingString;

    xdprintf (Depth, "");

    if (Option & IO_RESOURCE_PREFERRED) {
        dprintf("Preferred ");
    }
    if (Option & IO_RESOURCE_DEFAULT) {
        dprintf("Default ");
    }
    if (Option & IO_RESOURCE_ALTERNATIVE) {
        dprintf("Alternative ");
    }

    dprintf ("Descriptor %d - ", Number);

    typeString = GetCmResourceTypeString(Type);

    switch (SharingDisposition) {
    case CmResourceShareUndetermined:
        sharingString = "Undetermined Sharing";
        break;

    case CmResourceShareDeviceExclusive:
        sharingString = "Device Exclusive";
        break;

    case CmResourceShareDriverExclusive:
        sharingString = "Driver Exclusive";
        break;

    case CmResourceShareShared:
        sharingString = "Shared";
        break;

    default:
        sharingString = "Unknown Sharing";
        break;
    }

    dprintf("%s (%#x) %s (%#x)\n",
           typeString,
           Type,
           sharingString,
           SharingDisposition);

    Depth++;

    xdprintf (Depth, "Flags (%#04wx) - ", Flags);

    switch (Type) {

    case CmResourceTypePort:

        if (Flags == CM_RESOURCE_PORT_MEMORY) {
            dprintf ("PORT_MEMORY ");
        }
        if (Flags & CM_RESOURCE_PORT_IO) {
            dprintf ("PORT_IO ");
        }
        if (Flags & CM_RESOURCE_PORT_10_BIT_DECODE) {
            dprintf ("10_BIT_DECODE ");
        }
        if (Flags & CM_RESOURCE_PORT_12_BIT_DECODE) {
            dprintf ("12_BIT_DECODE ");
        }
        if (Flags & CM_RESOURCE_PORT_16_BIT_DECODE) {
            dprintf ("16_BIT_DECODE ");
        }
        if (Flags & CM_RESOURCE_PORT_POSITIVE_DECODE) {
            dprintf ("POSITIVE_DECODE ");
        }
        break;

    case CmResourceTypeMemory:

        if (Flags == CM_RESOURCE_MEMORY_READ_WRITE) {
            dprintf ("READ_WRITE ");
        }
        if (Flags & CM_RESOURCE_MEMORY_READ_ONLY) {
            dprintf ("READ_ONLY ");
        }
        if (Flags & CM_RESOURCE_MEMORY_WRITE_ONLY) {
            dprintf ("WRITE_ONLY ");
        }
        if (Flags & CM_RESOURCE_MEMORY_PREFETCHABLE) {
            dprintf ("PREFETCHABLE ");
        }
        if (Flags & CM_RESOURCE_MEMORY_COMBINEDWRITE) {
            dprintf ("COMBINEDWRITE ");
        }
        if (Flags & CM_RESOURCE_MEMORY_24) {
            dprintf ("MEMORY_24 ");
        }
        break;

    case CmResourceTypeInterrupt:

        if (Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
            dprintf ("LEVEL_SENSITIVE ");
        }
        if (Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
            dprintf ("LATCHED ");
        }
        break;

    case CmResourceTypeDma:

        if (Flags & CM_RESOURCE_DMA_8) {
            dprintf ("DMA_8 ");
        }
        if (Flags & CM_RESOURCE_DMA_16) {
            dprintf ("DMA_16 ");
        }
        if (Flags & CM_RESOURCE_DMA_32) {
            dprintf ("DMA_32 ");
        }
        if (Flags & CM_RESOURCE_DMA_8_AND_16) {
            dprintf ("DMA_8_AND_16");
        }
        if (Flags & CM_RESOURCE_DMA_TYPE_A) {
            dprintf ("DMA_TYPE_A");
        }
        if (Flags & CM_RESOURCE_DMA_TYPE_B) {
            dprintf ("DMA_TYPE_B");
        }
        if (Flags & CM_RESOURCE_DMA_TYPE_F) {
            dprintf ("DMA_TYPE_F");
        }
        break;

    }

    dprintf("\n");
}

DECLARE_API( arbiter )

/*++

Routine Description:

    Dumps all the arbiters in the system, their allocated ranges, and
    the owners of the ranges.

    !arbiter [flags]
        flags  1 - I/O port arbiters
               2 - memory arbiters
               4 - IRQ arbiters
               8 - DMA arbiters


    If no flags are specified, all arbiters are dumped.

Arguments:

    args - optional flags specifying which arbiters to dump

Return Value:

    None

--*/

{
    DWORD Flags=0;
    ULONG64 addr;
    ULONG64 deviceNode;

    Flags = (ULONG) GetExpression(args);

    if (Flags == 0) {
        Flags = ARBITER_DUMP_ALL;
    } else if (Flags == ARBITER_NO_DUMP_ALIASES) {
        Flags = ARBITER_NO_DUMP_ALIASES + ARBITER_DUMP_ALL;
    }

    //
    // Find the root devnode and dump its arbiters
    //

    addr = GetExpression( "nt!IopRootDeviceNode" );
    if (addr == 0) {
        dprintf("Error retrieving address of IopRootDeviceNode\n");
        return E_INVALIDARG;
    }

    if (!ReadPointer(addr, &deviceNode)) {
        dprintf("Error reading value of IopRootDeviceNode (%#010p)\n", addr);
        return E_INVALIDARG;
    }

    DumpArbitersForDevNode(0, deviceNode, Flags);
    return S_OK;
}


BOOLEAN
DumpArbitersForDevNode(
    IN DWORD   Depth,
    IN ULONG64 DevNodeAddr,
    IN DWORD   Flags
    )
/*++

Routine Description:

    Dumps all the arbiters for the specified devnode. Recursively calls
    itself on the specified devnode's children.

Arguments:

    Depth - Supplies the print depth.

    DevNodeAddr - Supplies the address of the devnode.

    Flags - Supplies the type of arbiters to dump:
        ARBITER_DUMP_IO
        ARBITER_DUMP_MEMORY
        ARBITER_DUMP_IRQ
        ARBITER_DUMP_DMA

Return Value:

    None

--*/

{
    ULONG                       result;
    ULONG64                     NextArbiter, startAddress;
    ULONG64                     ArbiterAddr;
    BOOLEAN                     PrintedHeader = FALSE;
    BOOLEAN                     continueDump = TRUE;
    UCHAR                       devNodeType[] = "nt!_DEVICE_NODE";
    ULONG                       DevArbOffset, DevNodeOffset;
    ULONG64 DeviceArbiterList_Flink=0, InstancePath_Buffer=0, Child=0, Sibling=0;
    UNICODE_STRING64            InstancePath;

    // Get offset for listing
    if (GetFieldOffset("nt!_PI_RESOURCE_ARBITER_ENTRY", "DeviceArbiterList.Flink", &DevArbOffset)) {
        return TRUE;
    }

    if (GetFieldValue(DevNodeAddr, devNodeType, "DeviceArbiterList.Flink", DeviceArbiterList_Flink)) {
        xdprintf(Depth, ""); dprintf("%08p: Could not read device node\n", DevNodeAddr);
        return TRUE;
    }
    GetFieldOffset("nt!_DEVICE_NODE", "DeviceArbiterList.Flink", &DevNodeOffset);
    GetFieldValue(DevNodeAddr, devNodeType, "Child", Child);
    GetFieldValue(DevNodeAddr, devNodeType, "Sibling", Sibling);
    GetFieldValue(DevNodeAddr, devNodeType, "InstancePath.Buffer", InstancePath.Buffer);
    GetFieldValue(DevNodeAddr, devNodeType, "InstancePath.Length", InstancePath.Length);
    GetFieldValue(DevNodeAddr, devNodeType, "InstancePath.MaximumLength", InstancePath.MaximumLength);


    //
    // Dump the list of arbiters
    //
    startAddress = DevNodeAddr + DevNodeOffset;

    NextArbiter = DeviceArbiterList_Flink;
    while (NextArbiter != startAddress) {
        ULONG ResourceType=0;
        if (CheckControlC()) {
            return FALSE;
        }
        ArbiterAddr = NextArbiter - DevArbOffset;
            // CONTAINING_RECORD(NextArbiter, PI_RESOURCE_ARBITER_ENTRY, DeviceArbiterList);


        if (GetFieldValue(ArbiterAddr, "nt!_PI_RESOURCE_ARBITER_ENTRY", "ResourceType", ResourceType)) {
            xdprintf(Depth, "Could not read arbiter entry ");
            dprintf("%08p for devnode %08p\n", ArbiterAddr, DevNodeAddr);
            break;
        }

        if (((ResourceType == CmResourceTypePort) && (Flags & ARBITER_DUMP_IO)) ||
            ((ResourceType == CmResourceTypeInterrupt) && (Flags & ARBITER_DUMP_IRQ)) ||
            ((ResourceType == CmResourceTypeMemory) && (Flags & ARBITER_DUMP_MEMORY)) ||
            ((ResourceType == CmResourceTypeDma) && (Flags & ARBITER_DUMP_DMA)) ||
            ((ResourceType == CmResourceTypeBusNumber) && (Flags & ARBITER_DUMP_BUS_NUMBER))) {

            if (!PrintedHeader) {
                dprintf("\n");
                xdprintf(Depth, ""); dprintf("DEVNODE %08p ", DevNodeAddr);

                if (InstancePath.Buffer != 0) {
                    dprintf("(");
                    DumpUnicode64(InstancePath);
                    dprintf(")");
                }
                dprintf("\n");
                PrintedHeader = TRUE;
            }

            continueDump = DumpArbiter( Depth+1,
                                        ArbiterAddr,
                                        // &ArbiterEntry,
                                        (BOOLEAN)!(Flags & ARBITER_NO_DUMP_ALIASES)
                                        );

            if (!continueDump) {
                break;
            }
        }

        GetFieldValue(ArbiterAddr, "nt!_PI_RESOURCE_ARBITER_ENTRY", "DeviceArbiterList.Flink", NextArbiter);
    }

    //
    // Dump this devnode's children (if any)
    //
    if (continueDump && Child) {
        continueDump = DumpArbitersForDevNode( Depth + 1, Child, Flags);
    }

    //
    // Dump this devnode's siblings (if any)
    //
    if (continueDump && Sibling) {
        continueDump = DumpArbitersForDevNode( Depth, Sibling, Flags);
    }

    return continueDump;
}


BOOLEAN
DumpArbiter(
    IN DWORD   Depth,
    IN ULONG64 ArbiterAddr,
    IN BOOLEAN DisplayAliases
    )
/*++

Routine Description:

    Dumps out the specified arbiter.

Arguments:

    Depth - Supplies the print depth.

    ArbiterAddr - Supplies the original address of the arbiter (on the target)

    Arbiter - Supplies the arbiter

Return Value:

    None.

--*/

{
    ULONG64                 PciInstance;
    ULONG64                 InstanceAddr;
    BOOL                    IsPciArbiter = FALSE;
    WCHAR                   NameBuffer[64];
    BOOLEAN                 continueDump = TRUE;
    UCHAR                   ArbiterTyp[] = "nt!_PI_RESOURCE_ARBITER_ENTRY";
    UCHAR                   ArbIntfTyp[] = "nt!_ARBITER_INTERFACE";
    ULONG64                 ArbiterInterface=0, Context=0, NamePtr=0, ResourceType=0;
    ULONG                   ListHeadOff;

    //
    // First obtain the ARBITER_INTERFACE.
    //
    if (GetFieldValue(ArbiterAddr, ArbiterTyp, "ArbiterInterface", ArbiterInterface)) {
        dprintf("Error reading ArbiterInterface %08p for ArbiterEntry at %08p\n",
                ArbiterInterface,
                ArbiterAddr);
        return continueDump;
    }
    if (!ArbiterInterface ||
        GetFieldValue(ArbiterInterface, ArbIntfTyp, "Context", Context)) {
        dprintf("Error reading ArbiterInterface %08p for ArbiterEntry at %08p\n",
                ArbiterInterface,
                ArbiterAddr);
        return continueDump;
    }

    //
    // Now that we have the ARBITER_INTERFACE we need to get the ARBITER_INSTANCE.
    // This is not as easy as it should be since PeterJ is paranoid and encrypts the
    // pointer to it. Luckily, we know his secret encryption method and can decrypt it.
    // First we have to figure out if this is PCI's arbiter. Quick hack check is to see
    // if the low bit is set.
    //
    if (Context & 1) {
        ULONG Offset;

        GetFieldOffset("nt!_PCI_ARBITER_INSTANCE", "CommonInstance", &Offset);

        IsPciArbiter = TRUE;
        PciInstance = (Context ^ PciFdoExtensionType);
        InstanceAddr = PciInstance + Offset;
    } else {
        //
        // We will assume that the context is just a pointer to an ARBITER_INSTANCE structure
        //
        InstanceAddr = Context;
    }

    //
    // Read the instance
    //
    if (GetFieldValue(InstanceAddr, "nt!_ARBITER_INSTANCE", "Name", NamePtr)) {
        dprintf("Error reading ArbiterInstance %08p for ArbiterInterface at %08p\n",
                InstanceAddr,
                ArbiterInterface);
        return continueDump;
    }

    GetFieldValue(InstanceAddr, "nt!_ARBITER_INSTANCE", "ResourceType", ResourceType);
    xdprintf(Depth,
             "%s Arbiter \"",
             GetCmResourceTypeString((UCHAR)ResourceType));

    if (NamePtr != 0) {
        ULONG result;

        if (ReadMemory(NamePtr,NameBuffer,sizeof(NameBuffer),&result)) {
            dprintf("%ws",NameBuffer);
        }
    }

    dprintf("\" at %08p\n",InstanceAddr);

    xdprintf(Depth+1,"Allocated ranges:\n");

    GetFieldOffset("nt!_RTL_RANGE_LIST", "ListHead", &ListHeadOff);
    InitTypeRead(InstanceAddr, nt!_ARBITER_INSTANCE);
    continueDump = DumpRangeList( Depth+2,
                                  ReadField(Allocation) + ListHeadOff,
                                  FALSE,
                                  TRUE,
                                  DisplayAliases);

    if (continueDump) {

        InitTypeRead(InstanceAddr, nt!_ARBITER_INSTANCE);
        xdprintf(Depth+1,"Possible allocation:\n");
        continueDump = DumpRangeList(Depth+2, ReadField(PossibleAllocation) + ListHeadOff,
                                     FALSE, TRUE, DisplayAliases);
    }

    return continueDump;
}

VOID
DumpRangeEntry(
              IN DWORD   Depth,
              IN ULONG64 RangeEntry,
              IN BOOLEAN OwnerIsDevObj,
              IN BOOLEAN DisplayAliases
              )
/*++

Routine Description:

    Dumps out the specified RTLP_RANGE_LIST_ENTRY

Arguments:

    Depth - Supplies the print depth.

    RangeList - Supplies the address of the RTLP_RANGE_LIST_ENTRY

    OwnerIsDevObj - Indicates that the owner field is a pointer to a DEVICE_OBJECT

Return Value:

    None.

--*/

{
   ULONG PrivateFlags=0, Attributes=0, PublicFlags=0;
   ULONG64  Owner=0, Start=0, End=0;

   if (GetFieldValue(RangeEntry, "nt!_RTLP_RANGE_LIST_ENTRY", "PrivateFlags", PrivateFlags)) {
       dprintf("Cannot find _RTLP_RANGE_LIST_ENTRY type.\n");
       return ;
   }

//   dprintf("Range Entry %p\n", RangeEntry);

   GetFieldValue(RangeEntry, "nt!_RTLP_RANGE_LIST_ENTRY", "Attributes", Attributes);
   GetFieldValue(RangeEntry, "nt!_RTLP_RANGE_LIST_ENTRY", "Start", Start);
   GetFieldValue(RangeEntry, "nt!_RTLP_RANGE_LIST_ENTRY", "End", End);
   GetFieldValue(RangeEntry, "nt!_RTLP_RANGE_LIST_ENTRY", "PublicFlags", PublicFlags);
   GetFieldValue(RangeEntry, "nt!_RTLP_RANGE_LIST_ENTRY", "Allocated.Owner", Owner);

   if (!(PrivateFlags & RTLP_RANGE_LIST_ENTRY_MERGED)) {
       ULONG64 DeviceObjectExtension=0, DeviceNode=0;

       if ((Attributes & ARBITER_RANGE_ALIAS) && !DisplayAliases) {
           return;
       }

       if (OwnerIsDevObj && Owner) {

           if (GetFieldValue(Owner, "nt!_DEVICE_OBJECT", "DeviceObjectExtension", DeviceObjectExtension)) {
               dprintf("Error reading DeviceObject %08p\n",
                       Owner
                       );
               return;
           }

           if (GetFieldValue(DeviceObjectExtension, "nt!_DEVOBJ_EXTENSION", "DeviceNode", DeviceNode)) {
               dprintf("Error reading DeviceObjectExtension %08p\n",
                       DeviceObjectExtension
                       );
               return;
           }

      }

      xdprintf(Depth,
               "%016I64x - %016I64x %c%c%c%c%c",
               Start,
               End,
               PublicFlags & RTL_RANGE_SHARED ? 'S' : ' ',
               PublicFlags & RTL_RANGE_CONFLICT ? 'C' : ' ',
               (Attributes & ARBITER_RANGE_BOOT_ALLOCATED)? 'B' : (Attributes & ARBITER_RANGE_SHARE_DRIVER_EXCLUSIVE)? 'D' : ' ',
               Attributes & ARBITER_RANGE_ALIAS ? 'A' : ' ',
               Attributes & ARBITER_RANGE_POSITIVE_DECODE ? 'P' : ' ');
      dprintf(" %08p ",Owner);

      if (Owner) {
          UNICODE_STRING64  ServiceName;

          GetFieldValue(DeviceNode, "nt!_DEVICE_NODE", "ServiceName.Buffer", ServiceName.Buffer);
          if (OwnerIsDevObj && ServiceName.Buffer) {
              GetFieldValue(DeviceNode, "nt!_DEVICE_NODE", "ServiceName.Length", ServiceName.Length);
              GetFieldValue(DeviceNode, "nt!_DEVICE_NODE", "ServiceName.MaximumLength", ServiceName.MaximumLength);

              dprintf(" (");
              DumpUnicode64(ServiceName);
              dprintf(")");
          }
      } else {

          dprintf("<Not on bus>");

      }
   } else {

       xdprintf(Depth,
                "%016I64x - %016I64x %c%c ",
                Start,
                End,
                PublicFlags & RTL_RANGE_SHARED ? 'S' : ' ',
                PublicFlags & RTL_RANGE_CONFLICT ? 'C' : ' '
           );
   }

   dprintf("\n");
}

BOOLEAN
DumpRangeList(
             IN DWORD   Depth,
             IN ULONG64 RangeListHead,
             IN BOOLEAN IsMerged,
             IN BOOLEAN OwnerIsDevObj,
             IN BOOLEAN DisplayAliases
             )
/*++

Routine Description:

    Dumps out the specified RTL_RANGE_LIST

Arguments:

    Depth - Supplies the print depth.

    RangeListHead - Supplies the address of the LIST_ENTRY containing the RTLP_RANGE_LIST_ENTRYs

    IsMerged - Indicates whether this list is in a merged range

    OwnerIsDevObj - Indicates that the owner field is a pointer to a DEVICE_OBJECT

Return Value:

    None.

--*/

{
    ULONG64                 ListEntry, EntryAddr;
    ULONG                   ListEntryOffset, ListHeadOffset;
    BOOLEAN                 continueDump = TRUE;

    GetFieldOffset("nt!_RTLP_RANGE_LIST_ENTRY", "ListEntry", &ListEntryOffset);
    GetFieldOffset("nt!_RTLP_RANGE_LIST_ENTRY", "Merged.ListHead", &ListHeadOffset);

    //
    // Read the range list
    //
    if (GetFieldValue(RangeListHead, "nt!_LIST_ENTRY", "Flink", ListEntry)) {
        dprintf("Error reading RangeList %08p\n", RangeListHead);
        return TRUE;
    }

    if (ListEntry == RangeListHead) {
        xdprintf(Depth, "< none >\n");
        return TRUE;
    }

    while (ListEntry != RangeListHead) {
        ULONG PrivateFlags=0;
        ULONG64 ListHeadAddr=0;

        if (CheckControlC()) {
            continueDump = FALSE;
            break;
        }

        EntryAddr = ListEntry - ListEntryOffset;
        if (GetFieldValue(EntryAddr, "nt!_RTLP_RANGE_LIST_ENTRY", "PrivateFlags", PrivateFlags)) {
            dprintf("Error reading RangeEntry %08p from RangeList %08p\n",
                    EntryAddr,
                    RangeListHead);
            return TRUE;
        }

        if (PrivateFlags & RTLP_RANGE_LIST_ENTRY_MERGED) {
            //
            // This is a merged range list, call ourselves recursively
            //
            DumpRangeEntry(Depth, EntryAddr, FALSE, DisplayAliases);

            continueDump = DumpRangeList(Depth + 1, EntryAddr + ListHeadOffset, TRUE, TRUE, DisplayAliases);

            if (!continueDump) {
                break;
            }

        } else {

            DumpRangeEntry(Depth, EntryAddr, OwnerIsDevObj, DisplayAliases);

        }

        GetFieldValue(EntryAddr, "nt!_RTLP_RANGE_LIST_ENTRY", "ListEntry.Flink", ListEntry);
    }

    return continueDump;
}

DECLARE_API( range )

/*++

Routine Description:

    Dumps an RTL_RANGE_LIST

Arguments:

    args - specifies the address of the RTL_RANGE_LIST

Return Value:

    None

--*/
{
    ULONG                   ListHeadOffset;
    BOOLEAN                 continueDump = TRUE;
    ULONG64 RangeList;

    if (GetFieldOffset("nt!_RTL_RANGE_LIST", "ListHead", &ListHeadOffset)) {
        dprintf("Cannot find _RTL_RANGE_LIST type.\n");
        return E_INVALIDARG;
    }

    RangeList = GetExpression(args);

    DumpRangeList(0, RangeList + ListHeadOffset, FALSE, FALSE, TRUE);

    return S_OK;
}

ULONG
DumpArbList(
    PFIELD_INFO ListElement,
    PVOID       Context
    )
{
    UCHAR                   andOr = ' ';
    ULONG                   resourceType = 0xffffffff;
    ULONG                   remaining;
    PULONG                  data;

    PCHAR headingDefault = "  Owner      Data";
    PCHAR formatDefault = "%c %s %c %08x %08x %08x %08x %08x %08x\n";

    PCHAR headingMemIo = "  Owner        Length  Alignment   Minimum Address - Maximum Address\n";
    PCHAR formatMemIo = "%c %s %c %8x   %8x  %08x%08x - %08x%08x\n";

    PCHAR headingIrqDma = "  Owner       Minimum - Maximum\n";
    PCHAR formatIrqDma = "%c %s %c %8x - %-8x\n";

    PCHAR   heading = headingDefault;
    PCHAR   format  = formatDefault;

    CHAR    shared;
    CHAR    ownerBuffer[20];
    PCHAR   ownerBlank = "        ";
    PCHAR   ownerText = ownerBlank;
    ULONG64 pcurrent=ListElement->address;
    ULONG64 palternative;
    static ULONG64          previousOwner = 0;
    BOOLEAN                 doHeading = TRUE;
    BOOLEAN                 verbose = FALSE;
    ULONG                   Flag = *((PULONG) Context);
    ULONG   AlternativeCount=0, resDescSize;
    ULONG64 PhysicalDeviceObject, Alternatives;
    ULONG Flags=0, InterfaceType=0, RequestSource=0;

    //
    // Check if user wants out.
    //

    if (CheckControlC()) {
        dprintf("User terminated with <control>C\n");
        return TRUE;
    }

    if ((LONG64)pcurrent >= 0) {
        dprintf("List broken, forward entry is not a valid kernel address.\n");
        return TRUE;
    }

    if (Flag & 1) {
        verbose = TRUE;
    }

    //
    // Get the arbitration list entry from host memory.
    //

    if (GetFieldValue(pcurrent, "nt!_ARBITER_LIST_ENTRY", "PhysicalDeviceObject",  PhysicalDeviceObject)) {
        dprintf("Couldn't read _ARBITER_LIST_ENTRY at %p\n", pcurrent);
        return TRUE;
    }

    //
    // Check if we've changed device objects.
    //

    if (previousOwner != PhysicalDeviceObject) {
        previousOwner = PhysicalDeviceObject;
        sprintf(ownerBuffer, "%08p", previousOwner);
        ownerText = ownerBuffer;
        andOr = ' ';
        if (verbose) {
            doHeading = TRUE;
        }
    }

    //
    // Run the alternatives for this device object.
    //

    GetFieldValue(pcurrent, "nt!_ARBITER_LIST_ENTRY", "AlternativeCount", AlternativeCount);
    GetFieldValue(pcurrent, "nt!_ARBITER_LIST_ENTRY", "Alternatives", Alternatives);

    GetFieldValue(pcurrent, "nt!_ARBITER_LIST_ENTRY", "Flags", Flags);
    GetFieldValue(pcurrent, "nt!_ARBITER_LIST_ENTRY", "InterfaceType", InterfaceType);
    GetFieldValue(pcurrent, "nt!_ARBITER_LIST_ENTRY", "RequestSource", RequestSource);

    resDescSize = GetTypeSize("nt!_IO_RESOURCE_DESCRIPTOR");
    for (remaining = AlternativeCount, palternative = Alternatives;
         remaining;
         remaining--, palternative+=resDescSize) {
        ULONG Type=0, ShareDisposition=0, Gen_Length=0, Gen_Alignment=0;
        ULONG Gen_Min_Low, Gen_Min_Hi=0, Gen_Max_Low=0, Gen_Max_Hi=0;
        ULONG Int_Min=0, Int_Max=0, DevData[6]={0};

        //
        // Check if user wants out.
        //

        if (CheckControlC()) {
            dprintf("User terminated with <control>C\n");
            return TRUE;
        }

        //
        // Read this resource descriptor from memory.  (An optimization
        // would be to read the entire array or to buffer it).
        //

        if (GetFieldValue(palternative, "nt!_IO_RESOURCE_DESCRIPTOR", "Type", Type)){
            dprintf("Couldn't read IO_RESOURCE_DESCRIPTOR at %08p, quitting.\n",
                    palternative
                    );
            return TRUE;
        }
        if (Type != resourceType) {
            if (resourceType == 0xffffffff) {

                //
                // Go look at the first alternative to figure out what
                // resource type is being arbitrated.
                //

                resourceType = Type;

                switch (resourceType) {
                case CmResourceTypeNull:
                    dprintf("Arbitration list resource type is NULL.  Seems odd.\n");
                    break;
                case CmResourceTypePort:
                    dprintf("Arbitrating CmResourceTypePort resources\n");
                    format = formatMemIo;
                    heading = headingMemIo;
                    break;
                case CmResourceTypeInterrupt:
                    dprintf("Arbitrating CmResourceTypeInterrupt resources\n");
                    format = formatIrqDma;
                    heading = headingIrqDma;
                    break;
                case CmResourceTypeMemory:
                    dprintf("Arbitrating CmResourceTypeMemory resources\n");
                    format = formatMemIo;
                    heading = headingMemIo;
                    break;
                case CmResourceTypeDma:
                    dprintf("Arbitrating CmResourceTypeDma resources\n");
                    format = formatIrqDma;
                    heading = headingIrqDma;
                    break;
                default:
                    dprintf("Arbitrating resource type 0x%x\n");
                }
            } else {
                dprintf("error: Resource Type change, arbiters don't do multiple\n");
                dprintf("types. Resource Type was 0x%x, new type 0x%x, quitting.\n", Type);
                return TRUE;
            }
        }

        if (doHeading) {
            if (verbose) {
                dprintf("Owning object %08p, Flags 0x%x, Interface 0x%x, Source 0x%x\n",
                        PhysicalDeviceObject,
                        Flags,
                        InterfaceType,
                        RequestSource
                        );
            }
            dprintf(heading);
            doHeading = FALSE;
        }

        GetFieldValue(palternative, "nt!_IO_RESOURCE_DESCRIPTOR", "ShareDisposition", ShareDisposition);

        shared = ShareDisposition == CmResourceShareShared ? 'S' : ' ';

        switch (resourceType) {
        case CmResourceTypePort:
        case CmResourceTypeMemory:
            GetFieldValue(palternative, "nt!_IO_RESOURCE_DESCRIPTOR", "u.Generic.Length", Gen_Length);
            GetFieldValue(palternative, "nt!_IO_RESOURCE_DESCRIPTOR", "u.Generic.Alignment", Gen_Alignment);
            GetFieldValue(palternative, "nt!_IO_RESOURCE_DESCRIPTOR", "u.Generic.MinimumAddress.HighPart", Gen_Min_Hi);
            GetFieldValue(palternative, "nt!_IO_RESOURCE_DESCRIPTOR", "u.Generic.MinimumAddress.LowPart", Gen_Min_Low);
            GetFieldValue(palternative, "nt!_IO_RESOURCE_DESCRIPTOR", "u.Generic.MaximumAddress.HighPart", Gen_Max_Hi);
            GetFieldValue(palternative, "nt!_IO_RESOURCE_DESCRIPTOR", "u.Generic.MaximumAddress.LowPart", Gen_Max_Low );

            dprintf(format,
                    andOr,
                    ownerText,
                    shared,
                    Gen_Length,
                    Gen_Alignment,
                    Gen_Min_Hi,
                    Gen_Min_Low,
                    Gen_Max_Hi,
                    Gen_Max_Low
                    );
            break;
        case CmResourceTypeInterrupt:
        case CmResourceTypeDma:

            //
            // Dma and Interrupt are same format,... overload.
            //
            GetFieldValue(palternative, "nt!_IO_RESOURCE_DESCRIPTOR", "u.Interrupt.MinimumVector", Int_Min);
            GetFieldValue(palternative, "nt!_IO_RESOURCE_DESCRIPTOR", "u.Interrupt.MaximumVector", Int_Max);

            dprintf(format,
                    andOr,
                    ownerText,
                    shared,
                    Int_Min,
                    Int_Max
                    );
            break;
        default:
            GetFieldValue(palternative, "nt!_IO_RESOURCE_DESCRIPTOR", "u.DevicePrivate.Data", DevData);
            data = DevData;
            dprintf(format,
                    andOr,
                    ownerText,
                    shared,
                    *data,
                    *(data + 0),
                    *(data + 1),
                    *(data + 2),
                    *(data + 3),
                    *(data + 4),
                    *(data + 5)
                    );
            break;
        }
        ownerText = ownerBlank;
        andOr = '|';
    }
    if (AlternativeCount == 0) {

        //
        // Get here if the alternatives list was empty.
        //

        if (doHeading) {
            dprintf("Owning object %08p, Flags 0x%x, Interface 0x%x\n",
                    PhysicalDeviceObject,
                    Flags,
                    InterfaceType
                    );
        }
        dprintf("Arbiter list entry (@%08p) has 0 resources.  Seems odd.\n",
                pcurrent
                );
    }
    andOr = '&';

    return FALSE; // Continue dumping the list
}

DECLARE_API( arblist )

/*++

Routine Description:

    Dumps an arbitration list (2nd parameter to PnpTestAllocation).

    !arblist address

    If no address specified we try to tell you what to do.

Arguments:

    address of the arbitration list.

Return Value:

    None

--*/

{
    ULONG64                 ArbitrationList = 0;
    ULONG                   Flags = 0;
    ULONG64                 pcurrent;
    ULONG64                 palternative;
    ULONG64 KModeCheck;
    BOOL    Ptr64 = IsPtr64();

    if (GetExpressionEx(args, &ArbitrationList, &args)) {
        Flags = (ULONG) GetExpression(args);
    }

    if (ArbitrationList == 0) {
        dprintf("!arblist <address> [flags]\n");
        dprintf("  <address> is the address of an arbitration list.\n");
        dprintf("  [flags]   Bitmask used to adjust what is printed.\n");
        dprintf("            0001 Include interface, flags and source for each device\n");
        dprintf("\n");
        dprintf("  Prints out an arbitration list.  An arbitration list\n");
        dprintf("  is the set of resources for which arbitration is\n");
        dprintf("  needed.  (eg second parameter to PnpTestAllocation).\n");
        return E_INVALIDARG;
    }

    if (Ptr64) {
        KModeCheck = 0x8000000000000000L;
    } else {
        KModeCheck = 0xffffffff80000000L;
    }

    //
    // The argument is a pointer to a list head.
    //

    if (!((LONG64)ArbitrationList & KModeCheck)) {
        dprintf("The arbitration list pointer must be a kernel mode address.\n");
        return E_INVALIDARG;
    }

    if (GetFieldValue(ArbitrationList, "nt!_LIST_ENTRY", "Flink", pcurrent)) {
        dprintf("error reading arbitration list ListHead, cannot continue.\n");
        return E_INVALIDARG;
    }

    //
    // A little validation.
    //

    if (!(pcurrent & KModeCheck)) {
        dprintf("%08p does not point to a valid list head.\n", ArbitrationList);
        return E_INVALIDARG;
    }

    if (pcurrent == ArbitrationList) {
        dprintf("%08p points to an empty list.\n", ArbitrationList);
        return E_INVALIDARG;
    }

    //
    // Run the list.
    //

    ListType("_ARBITER_LIST_ENTRY", pcurrent, TRUE, "ListEntry.Flink", (PVOID) &Flags, DumpArbList);

    return S_OK;
}

ULONG
TokenizeString(
              PUCHAR Input,
              PUCHAR *Output,
              ULONG  Max
              )

/*++

Routine Description:

    Convert an input string of white space delimited tokens into
    an array of strings.   The routine will produce an array of
    pointers to strings where the (maximum) size of the array is
    given by Max.   Note, if Max is too small to fully tokenize the
    string, the last element of the array will point to the remainder
    of the string.

Arguments:

    Input       Input string
    Output      Pointer to an array which will be filled in with
                pointers to each new token.
    Max         Maximum number of strings.

Return Value:

    Number of tokens found.

--*/

{
   ULONG count = 0;
   PUCHAR tok;
   BOOLEAN inToken = FALSE;
   UCHAR c;

   if (Max == 0) {
      return 0;
   }

   while ((c = *Input++) != '\0') {

      if (isspace(c)) {

         if (!inToken) {

            //
            // Continue skipping characters.
            //

            continue;
         }

         //
         // Found end of Token, delimit it and change state.
         //

         inToken = FALSE;
         *(Input - 1) = '\0';

      } else {

         //
         // Non-blank character.
         //

         if (inToken) {

            //
            // Continue search for end of token.
            //

            continue;
         }

         //
         // New Token.
         //

         inToken = TRUE;
         *Output++ = Input - 1;
         count++;

         if (count == Max) {

            //
            // We can't find any more so return what we still
            // have as the last thing.
            //

            return count;
         }
      }
   }
   return count;
}

//
// DevExtPCI
//
// Data structures and functions to implement !devext pci.
//

PUCHAR DevExtPciDeviceState[] = {
    "PciNotStarted",
    "PciStarted",
    "PciDeleted",
    "PciStopped",
    "PciSurpriseRemoved",
    "PciSynchronizedOperation"
};

PUCHAR DevExtPciSystemPowerState[] = {
    "Unspecified",
    "Working",
    "Sleeping1",
    "Sleeping2",
    "Sleeping3",
    "Hibernate",
    "Shutdown"
};

PUCHAR DevExtPciDevicePowerState[] = {
    "Unspecified",
    "D0",
    "D1",
    "D2",
    "D3"
};

struct {
    USHORT  VendorId;
    PUCHAR  VendorName;
} DevExtPciVendors[] = {
    { 0x003D, "LOCKHEED MARTIN"},
    { 0x0E11, "COMPAQ"},
    { 0x1002, "ATI TECHNOLOGIES INC"},
    { 0x1003, "ULSI SYSTEMS"},
    { 0x1004, "VLSI TECHNOLOGY INC"},
    { 0x1006, "REPLY GROUP"},
    { 0x1007, "NETFRAME SYSTEMS INC"},
    { 0x1008, "EPSON"},
    { 0x100A, "PHOENIX TECHNOLOGIES"},
    { 0x100B, "NATIONAL SEMICONDUCTOR CORPORATION"},
    { 0x100C, "TSENG LABS INC"},
    { 0x100D, "AST RESEARCH INC"},
    { 0x1010, "VIDEO LOGIC LTD"},
    { 0x1011, "DIGITAL EQUIPMENT CORPORATION"},
    { 0x1012, "MICRONICS COMPUTERS INC"},
    { 0x1013, "CIRRUS LOGIC"},
    { 0x1014, "IBM"},
    { 0x1015, "LSI LOGIC CORP OF CANADA"},
    { 0x1016, "ICL PERSONAL SYSTEMS"},
    { 0x1017, "SPEA SOFTWARE AG"},
    { 0x1018, "UNISYS SYSTEMS"},
    { 0x1019, "ELITEGROUP COMPUTER SYS"},
    { 0x101A, "NCR"},
    { 0x101C, "WESTERN DIGITAL"},
    { 0x101E, "AMERICAN MEGATRENDS"},
    { 0x101F, "PICTURETEL"},
    { 0x1021, "OKI ELECTRIC INDUSTRY"},
    { 0x1022, "ADVANCED MICRO DEVICES"},
    { 0x1023, "TRIDENT MICROSYSTEMS"},
    { 0x1025, "ACER INCORPORATED"},
    { 0x1028, "DELL COMPUTER CORPORATION"},
    { 0x102B, "MATROX"},
    { 0x102C, "CHIPS AND TECHNOLOGIES"},
    { 0x102E, "OLIVETTI ADVANCED TECHNOLOGY"},
    { 0x102F, "TOSHIBA AMERICA ELECT."},
    { 0x1030, "TMC RESEARCH"},
    { 0x1031, "MIRO COMPUTER PRODUCTS AG"},
    { 0x1033, "NEC CORPORATION"},
    { 0x1033, "NEC CORPORATION"},
    { 0x1034, "BURNDY CORPORATION"},
    { 0x1035, "COMP.&COMM. RESH. LAB"},
    { 0x1036, "FUTURE DOMAIN"},
    { 0x1037, "HITACHI MICRO SYSTEMS"},
    { 0x1038, "AMP, INC"},
    { 0x1039, "SILICON INTEGRATED SYSTEM"},
    { 0x103A, "SEIKO EPSON CORPORATION"},
    { 0x103B, "TATUNG CO. OF AMERICA"},
    { 0x103C, "HEWLETT PACKARD"},
    { 0x103E, "SOLLIDAY ENGINEERING"},
    { 0x103F, "SYNOPSYS INC."},
    { 0x1040, "ACCELGRAPHICS INC."},
    { 0x1042, "PC TECHNOLOGY INC"},
    { 0x1043, "ASUSTEK COMPUTER, INC."},
    { 0x1044, "DISTRIBUTED PROCESSING TECHNOLOGY"},
    { 0x1045, "OPTI"},
    { 0x1046, "IPC CORPORATION, LTD."},
    { 0x1047, "GENOA SYSTEMS CORP"},
    { 0x1048, "ELSA GMBH"},
    { 0x1049, "FOUNTAIN TECHNOLOGY"},
    { 0x104A, "SGS THOMSON"},
    { 0x104B, "BUSLOGIC"},
    { 0x104C, "TEXAS INSTRUMENTS"},
    { 0x104D, "SONY CORPORATION"},
    { 0x104E, "OAK TECHNOLOGY, INC"},
    { 0x1050, "WINBOND ELECTRONICS CORP"},
    { 0x1051, "ANIGMA, INC."},
    { 0x1055, "EFAR MICROSYSTEMS"},
    { 0x1057, "MOTOROLA"},
    { 0x1058, "ELECTRONICS & TELEC. RSH"},
    { 0x1059, "TEKNOR INDUSTRIAL COMPUTERS INC"},
    { 0x105A, "PROMISE TECHNOLOGY"},
    { 0x105B, "FOXCONN INTERNATIONAL"},
    { 0x105C, "WIPRO INFOTECH LIMITED"},
    { 0x105D, "NUMBER 9 COMPUTER COMPANY"},
    { 0x105E, "VTECH COMPUTERS LTD"},
    { 0x105F, "INFOTRONIC AMERICA INC"},
    { 0x1060, "UNITED MICROELECTRONICS"},
    { 0x1061, "I.T.T."},
    { 0x1062, "MASPAR COMPUTER CORP"},
    { 0x1063, "OCEAN OFFICE AUTOMATION"},
    { 0x1064, "ALCATEL CIT"},
    { 0x1065, "TEXAS MICROSYSTEMS"},
    { 0x1066, "PICOPOWER TECHNOLOGY"},
    { 0x1067, "MITSUBISHI ELECTRONICS"},
    { 0x1068, "DIVERSIFIED TECHNOLOGY"},
    { 0x1069, "MYLEX CORPORATION"},
    { 0x106B, "APPLE COMPUTER INC."},
    { 0x106C, "HYUNDAI ELECTRONICS AMERI"},
    { 0x106D, "SEQUENT"},
    { 0x106E, "DFI, INC"},
    { 0x106F, "CITY GATE DEVELOPMENT LTD"},
    { 0x1070, "DAEWOO TELECOM LTD"},
    { 0x1073, "YAMAHA CORPORATION"},
    { 0x1074, "NEXGEN MICROSYSTEME"},
    { 0x1075, "ADVANCED INTEGRATION RES."},
    { 0x1076, "CHAINTECH COMPUTER CO. LTD"},
    { 0x1077, "Q LOGIC"},
    { 0x1078, "CYRIX CORPORATION"},
    { 0x1079, "I-BUS"},
    { 0x107B, "GATEWAY 2000"},
    { 0x107C, "LG ELECTRONICS"},
    { 0x107D, "LEADTEK RESEARCH INC."},
    { 0x107E, "INTERPHASE CORPORATION"},
    { 0x107F, "DATA TECHNOLOGY CORPORATION"},
    { 0x1080, "CYPRESS SEMICONDUCTOR"},
    { 0x1081, "RADIUS"},
    { 0x1083, "FOREX COMPUTER CORPORATION"},
    { 0x1085, "TULIP COMPUTERS INT.B.V."},
    { 0x1089, "DATA GENERAL CORPORATION"},
    { 0x108A, "BIT 3 COMPUTER"},
    { 0x108C, "OAKLEIGH SYSTEMS INC."},
    { 0x108D, "OLICOM"},
    { 0x108E, "SUN MICROSYSTEMS"},
    { 0x108F, "SYSTEMSOFT"},
    { 0x1090, "ENCORE COMPUTER CORPORATION"},
    { 0x1091, "INTERGRAPH CORPORATION"},
    { 0x1092, "DIAMOND MULTMEDIA SYSTEMS"},
    { 0x1093, "NATIONAL INSTRUMENTS"},
    { 0x1094, "FIRST INT'L COMPUTERS"},
    { 0x1095, "CMD TECHNOLOGY INC"},
    { 0x1096, "ALACRON"},
    { 0x1098, "QUANTUM DESIGNS (H.K.) LTD"},
    { 0x109B, "GEMLIGHT COMPUTER LTD."},
    { 0x109E, "BROOKTREE CORPORATION"},
    { 0x109F, "TRIGEM COMPUTER INC."},
    { 0x10A0, "MEIDENSHA CORPORATION"},
    { 0x10A2, "QUANTUM CORPORATION"},
    { 0x10A3, "EVEREX SYSTEMS INC"},
    { 0x10A5, "RACAL INTERLAN"},
    { 0x10A8, "SIERRA SEMICONDUCTOR"},
    { 0x10A9, "SILICON GRAPHICS"},
    { 0x10AA, "ACC MICROELECTRONICS"},
    { 0x10AD, "SYMPHONY LABS"},
    { 0x10AE, "CORNERSTONE TECHNOLOGY"},
    { 0x10B0, "CARDEXPERT TECHNOLOGY"},
    { 0x10B1, "CABLETRON SYSTEMS INC"},
    { 0x10B2, "RAYTHEON COMPANY"},
    { 0x10B3, "DATABOOK INC"},
    { 0x10B4, "STB SYSTEMS INC"},
    { 0x10B5, "PLX TECHNOLOGY"},
    { 0x10B6, "MADGE NETWORKS"},
    { 0x10B7, "3COM CORPORATION"},
    { 0x10B8, "STANDARD MICROSYSTEMS"},
    { 0x10B9, "ACER LABS"},
    { 0x10BA, "MITSUBISHI ELECTRONICS CORP."},
    { 0x10BC, "ADVANCED LOGIC RESEARCH"},
    { 0x10BD, "SURECOM TECHNOLOGY"},
    { 0x10C0, "BOCA RESEARCH INC."},
    { 0x10C1, "ICM CO., LTD."},
    { 0x10C2, "AUSPEX SYSTEMS INC."},
    { 0x10C3, "SAMSUNG SEMICONDUCTORS"},
    { 0x10C4, "AWARD SOFTWARE INTERNATIONAL INC."},
    { 0x10C5, "XEROX CORPORATION"},
    { 0x10C6, "RAMBUS INC."},
    { 0x10C8, "NEOMAGIC CORPORATION"},
    { 0x10C9, "DATAEXPERT CORPORATION"},
    { 0x10CB, "OMRON CORPORATION"},
    { 0x10CC, "MENTOR ARC INC"},
    { 0x10CD, "ADVANCED SYSTEM PRODUCTS, INC"},
    { 0x10D0, "FUJITSU LIMITED"},
    { 0x10D1, "FUTURE+ SYSTEMS"},
    { 0x10D2, "MOLEX INCORPORATED"},
    { 0x10D3, "JABIL CIRCUIT INC"},
    { 0x10D4, "HUALON MICROELECTRONICS"},
    { 0x10D6, "CETIA"},
    { 0x10D7, "BCM ADVANCED"},
    { 0x10D8, "ADVANCED PERIPHERALS LABS"},
    { 0x10DA, "THOMAS-CONRAD CORPORATION"},
    { 0x10DC, "CERN/ECP/EDU"},
    { 0x10DD, "EVANS & SUTHERLAND"},
    { 0x10DE, "NVIDIA CORPORATION"},
    { 0x10DF, "EMULEX CORPORATION"},
    { 0x10E0, "INTEGRATED MICRO SOLUTIONS INC."},
    { 0x10E1, "TEKRAM TECHNOLOGY CO.,LTD."},
    { 0x10E2, "APTIX CORPORATION"},
    { 0x10E3, "TUNDRA SEMICONDUCTOR (formerly NEWBRIDGE MICROSYSTEMS)"},
    { 0x10E4, "TANDEM COMPUTERS"},
    { 0x10E5, "MICRO INDUSTRIES CORPORATION"},
    { 0x10E6, "GAINBERY COMPUTER PRODUCTS INC."},
    { 0x10E7, "VADEM"},
    { 0x10E8, "APPLIED MICRO CIRCUITS CORPORATION"},
    { 0x10E9, "ALPS ELECTRIC CO. LTD."},
    { 0x10EB, "ARTISTS GRAPHICS"},
    { 0x10EC, "REALTEK SEMICONDUCTOR CO., LTD."},
    { 0x10ED, "ASCII CORPORATION"},
    { 0x10EE, "XILINX CORPORATION"},
    { 0x10EF, "RACORE COMPUTER PRODUCTS, INC."},
    { 0x10F0, "PERITEK CORPORATION"},
    { 0x10F1, "TYAN COMPUTER"},
    { 0x10F3, "ALARIS, INC."},
    { 0x10F4, "S-MOS SYSTEMS"},
    { 0x10F5, "NKK CORPORATION"},
    { 0x10F6, "CREATIVE ELECTRONIC SYSTEMS SA"},
    { 0x10F7, "MATSUSHITA ELECTRIC INDUSTRIAL CO., LTD."},
    { 0x10F8, "ALTOS INDIA LTD"},
    { 0x10F9, "PC DIRECT"},
    { 0x10FA, "TRUEVISION"},
    { 0x10FB, "THESYS GES. F. MIKROELEKTRONIK MGH"},
    { 0x10FC, "I-O DATA DEVICE, INC."},
    { 0x10FD, "SOYO COMPUTER INC."},
    { 0x10FE, "FAST ELECTRONIC GMBH"},
    { 0x10FF, "NCUBE"},
    { 0x1100, "JAZZ MULTIMEDIA"},
    { 0x1101, "INITIO CORPORATION"},
    { 0x1102, "CREATIVE LABS"},
    { 0x1103, "TRIONES TECHNOLOGIES, INC."},
    { 0x1104, "RASTEROPS"},
    { 0x1105, "SIGMA DESIGNS, INC"},
    { 0x1106, "VIA TECHNOLOGIES, INC."},
    { 0x1107, "STRATUS COMPUTERS"},
    { 0x1108, "PROTEON, INC."},
    { 0x1109, "COGENT DATA TECHNOLOGIES"},
    { 0x110A, "SIEMENS NIXDORF IS/AG"},
    { 0x110B, "CHROMATIC RESEARCH INC."},
    { 0x110C, "MINI-MAX TECHNOLOGY, INC."},
    { 0x110D, "ZNYX ADVANCED SYSTEMS"},
    { 0x110E, "CPU TECHNOLOGY"},
    { 0x110F, "ROSS TECHNOLOGY"},
    { 0x1110, "Fire Power Systems, Inc."},
    { 0x1111, "SANTA CRUZ OPERATION"},
    { 0x1112, "RNS (formerly ROCKWELL NETWORK SYSTEMS)"},
    { 0x1114, "ATMEL CORPORATION"},
    { 0x1117, "DATACUBE, INC"},
    { 0x1118, "BERG ELECTRONICS"},
    { 0x1119, "VORTEX COMPUTERSYSTEME GMBH"},
    { 0x111A, "EFFICIENT NETWORKS"},
    { 0x111B, "LITTON GCS"},
    { 0x111C, "TRICORD SYSTEMS"},
    { 0x111D, "INTEGRATED DEVICE TECH"},
    { 0x111F, "PRECISION DIGITAL IMAGES"},
    { 0x1120, "EMC CORPORATION"},
    { 0x1122, "MULTI-TECH SYSTEMS, INC."},
    { 0x1123, "EXCELLENT DESIGN, INC."},
    { 0x1124, "LEUTRON VISION AG"},
    { 0x1127, "FORE SYSTEMS INC"},
    { 0x1129, "FIRMWORKS"},
    { 0x112A, "HERMES ELECTRONICS COMPANY, LTD."},
    { 0x112B, "LINOTYPE - HELL AG"},
    { 0x112C, "ZENITH DATA SYSTEMS"},
    { 0x112E, "INFOMEDIA MICROELECTRONICS INC."},
    { 0x112F, "IMAGING TECHNLOGY INC"},
    { 0x1130, "COMPUTERVISION"},
    { 0x1131, "PHILIPS SEMICONDUCTORS"},
    { 0x1132, "MITEL CORP."},
    { 0x1133, "EICON TECHNOLOGY CORPORATION"},
    { 0x1134, "MERCURY COMPUTER SYSTEMS"},
    { 0x1135, "FUJI XEROX CO LTD"},
    { 0x1136, "MOMENTUM DATA SYSTEMS"},
    { 0x1137, "CISCO SYSTEMS INC"},
    { 0x1138, "ZIATECH CORPORATION"},
    { 0x1139, "DYNAMIC PICTURES INC"},
    { 0x113A, "FWB  INC"},
    { 0x113B, "NETWORK COMPUTING DEVICES"},
    { 0x113C, "CYCLONE MICROSYSTEMS"},
    { 0x113D, "LEADING EDGE PRODUCTS INC"},
    { 0x113E, "SANYO ELECTRIC CO"},
    { 0x113F, "EQUINOX SYSTEMS"},
    { 0x1140, "INTERVOICE INC"},
    { 0x1141, "CREST MICROSYSTEM INC"},
    { 0x1142, "ALLIANCE SEMICONDUCTOR CORPORATION"},
    { 0x1143, "NETPOWER, INC"},
    { 0x1144, "CINCINNATI MILACRON"},
    { 0x1145, "WORKBIT CORP"},
    { 0x1146, "FORCE COMPUTERS"},
    { 0x1147, "INTERFACE CORP"},
    { 0x1148, "SYSKONNECT"},
    { 0x1149, "WIN SYSTEM CORPORATION"},
    { 0x114A, "VMIC"},
    { 0x114B, "CANOPUS CO., LTD"},
    { 0x114C, "ANNABOOKS"},
    { 0x114D, "IC CORPORATION"},
    { 0x114E, "NIKON SYSTEMS INC"},
    { 0x114F, "DIGI INTERNATIONAL"},
    { 0x1151, "JAE ELECTRONICS INC."},
    { 0x1152, "MEGATEK"},
    { 0x1153, "LAND WIN ELECTRONIC CORP"},
    { 0x1154, "MELCO INC"},
    { 0x1155, "PINE TECHNOLOGY LTD"},
    { 0x1156, "PERISCOPE ENGINEERING"},
    { 0x1157, "AVSYS CORPORATION"},
    { 0x1158, "VOARX R & D INC"},
    { 0x1159, "MUTECH CORP"},
    { 0x115A, "HARLEQUIN LTD"},
    { 0x115B, "PARALLAX GRAPHICS"},
    { 0x115C, "PHOTRON LTD."},
    { 0x115D, "XIRCOM"},
    { 0x115E, "PEER PROTOCOLS INC"},
    { 0x115F, "MAXTOR CORPORATION"},
    { 0x1160, "MEGASOFT INC"},
    { 0x1161, "PFU LIMITED"},
    { 0x1162, "OA LABORATORY CO LTD"},
    { 0x1163, "RENDITION"},
    { 0x1164, "ADVANCED PERIPHERALS TECH"},
    { 0x1165, "IMAGRAPH"},
    { 0x1166, "RELIANCE COMPUTER CORP."},
    { 0x1167, "MUTOH INDUSTRIES INC"},
    { 0x1168, "THINE ELECTRONICS INC"},
    { 0x116A, "POLARIS COMMUNICATIONS"},
    { 0x116B, "CONNECTWARE INC"},
    { 0x116C, "INTELLIGENT RESOURCES"},
    { 0x116E, "ELECTRONICS FOR IMAGING"},
    { 0x116F, "WORKSTATION TECHNOLOGY"},
    { 0x1170, "INVENTEC CORPORATION"},
    { 0x1171, "LOUGHBOROUGH SOUND IMAGES"},
    { 0x1172, "ALTERA CORPORATION"},
    { 0x1173, "ADOBE SYSTEMS, INC"},
    { 0x1174, "BRIDGEPORT MACHINES"},
    { 0x1175, "MITRON COMPUTER INC."},
    { 0x1176, "SBE INCORPORATED"},
    { 0x1177, "SILICON ENGINEERING"},
    { 0x1178, "ALFA, INC."},
    { 0x117A, "A-TREND TECHNOLOGY"},
    { 0x117C, "ATTO TECHNOLOGY"},
    { 0x117D, "BECTON & DICKINSON"},
    { 0x117E, "T/R SYSTEMS"},
    { 0x117F, "INTEGRATED CIRCUIT SYSTEMS"},
    { 0x1180, "RICOH CO LTD"},
    { 0x1181, "TELMATICS INTERNATIONAL"},
    { 0x1183, "FUJIKURA LTD"},
    { 0x1184, "FORKS INC"},
    { 0x1185, "DATAWORLD"},
    { 0x1186, "D-LINK SYSTEM INC"},
    { 0x1187, "ADVANCED TECHNOLOGY LABORATORIES"},
    { 0x1188, "SHIMA SEIKI MANUFACTURING LTD."},
    { 0x1189, "MATSUSHITA ELECTRONICS CO LTD"},
    { 0x118A, "HILEVEL TECHNOLOGY"},
    { 0x118B, "HYPERTEC PTY LIMITED"},
    { 0x118C, "COROLLARY, INC"},
    { 0x118D, "BITFLOW INC"},
    { 0x118E, "HERMSTEDT GMBH"},
    { 0x118F, "GREEN LOGIC"},
    { 0x1191, "ARTOP ELECTRONIC CORP"},
    { 0x1192, "DENSAN CO., LTD"},
    { 0x1193, "ZEITNET INC."},
    { 0x1194, "TOUCAN TECHNOLOGY"},
    { 0x1195, "RATOC SYSTEM INC"},
    { 0x1196, "HYTEC ELECTRONICS LTD"},
    { 0x1197, "GAGE APPLIED SCIENCES, INC."},
    { 0x1198, "LAMBDA SYSTEMS INC"},
    { 0x1199, "ATTACHMATE CORPORATION"},
    { 0x1199, "DIGITAL COMMUNICATIONS ASSOCIATES INC"},
    { 0x119A, "MIND SHARE, INC."},
    { 0x119B, "OMEGA MICRO INC."},
    { 0x119C, "INFORMATION TECHNOLOGY INST."},
    { 0x119D, "BUG SAPPORO JAPAN"},
    { 0x119E, "FUJITSU"},
    { 0x119F, "BULL HN INFORMATION SYSTEMS"},
    { 0x11A0, "CONVEX COMPUTER CORPORATION"},
    { 0x11A1, "HAMAMATSU PHOTONICS K.K."},
    { 0x11A2, "SIERRA RESEARCH AND TECHNOLOGY"},
    { 0x11A4, "BARCO GRAPHICS NV"},
    { 0x11A5, "MICROUNITY SYSTEMS ENG. INC"},
    { 0x11A6, "PURE DATA"},
    { 0x11A7, "POWER COMPUTING CORP."},
    { 0x11A8, "SYSTECH CORP."},
    { 0x11A9, "INNOSYS"},
    { 0x11AA, "ACTEL"},
    { 0x11AB, "GALILEO TECHNOLOGY LTD."},
    { 0x11AC, "CANON INFORMATION SYSTEMS"},
    { 0x11AD, "LITE-ON COMMUNICATIONS INC"},
    { 0x11AE, "AZTECH SYSTEM LTD"},
    { 0x11AE, "SCITEX  CORPORATION"},
    { 0x11AF, "AVID TECHNOLOGY INC"},
    { 0x11AF, "PRO-LOG CORPORATION"},
    { 0x11B0, "V3 SEMICONDUCTOR"},
    { 0x11B1, "APRICOT COMPUTERS"},
    { 0x11B2, "EASTMAN KODAK"},
    { 0x11B3, "BARR SYSTEMS INC."},
    { 0x11B4, "LEITCH TECHNOLOGY INTERNATIONAL"},
    { 0x11B5, "RADSTONE TECHNOLOGY PLC"},
    { 0x11B6, "UNITED VIDEO CORP"},
    { 0x11B8, "XPOINT TECHNOLOGIES INC"},
    { 0x11B9, "PATHLIGHT TECHNOLOGY INC"},
    { 0x11BA, "VIDEOTRON CORP"},
    { 0x11BB, "PYRAMID TECHNOLOGY"},
    { 0x11BC, "NETWORK PERIPHERALS INC"},
    { 0x11BD, "PINNACLE SYSTEMS INC."},
    { 0x11BE, "INTERNATIONAL MICROCIRCUITS INC"},
    { 0x11BF, "ASTRODESIGN,  INC."},
    { 0x11C0, "HEWLETT PACKARD"},
    { 0x11C1, "AT&T MICROELECTRONICS"},
    { 0x11C2, "SAND MICROELECTRONICS"},
    { 0x11C4, "DOCUMENT TECHNOLOGIES, IND"},
    { 0x11C5, "SHIVA CORPORATION"},
    { 0x11C6, "DAINIPPON SCREEN MFG. CO. LTD"},
    { 0x11C7, "D.C.M. DATA SYSTEMS"},
    { 0x11C8, "DOLPHIN INTERCONNECT"},
    { 0x11C9, "MAGMA"},
    { 0x11CA, "LSI SYSTEMS, INC"},
    { 0x11CB, "SPECIALIX RESEARCH LTD"},
    { 0x11CC, "MICHELS & KLEBERHOFF COMPUTER GMBH"},
    { 0x11CD, "HAL COMPUTER SYSTEMS, INC."},
    { 0x11CE, "PRIMARY RATE INC"},
    { 0x11CF, "PIONEER ELECTRONIC CORPORATION"},
    { 0x11D0, "LORAL FREDERAL SYSTEMS - MANASSAS"},
    { 0x11D1, "AURAVISION"},
    { 0x11D2, "INTERCOM INC."},
    { 0x11D3, "TRANCELL SYSTEMS INC"},
    { 0x11D4, "ANALOG DEVICES"},
    { 0x11D5, "IKON CORPORATION"},
    { 0x11D6, "TEKELEC TECHNOLOGIES"},
    { 0x11D7, "TRENTON TERMINALS INC"},
    { 0x11D8, "IMAGE TECHNOLOGIES DEVELOPMENT"},
    { 0x11D9, "TEC CORPORATION"},
    { 0x11DA, "NOVELL"},
    { 0x11DB, "SEGA ENTERPRISES LITD"},
    { 0x11DC, "QUESTRA CORPORATION"},
    { 0x11DD, "CROSFIELD ELECTRONICS LIMITED"},
    { 0x11DE, "ZORAN CORPORATION"},
    { 0x11DF, "NEW WAVE PDG"},
    { 0x11E0, "CRAY COMMUNICATIONS A/S"},
    { 0x11E1, "GEC PLESSEY SEMI INC."},
    { 0x11E2, "SAMSUNG INFORMATION SYSTEMS AMERICA"},
    { 0x11E3, "QUICKLOGIC CORPORATION"},
    { 0x11E4, "SECOND WAVE INC"},
    { 0x11E5, "IIX CONSULTING"},
    { 0x11E6, "MITSUI-ZOSEN SYSTEM RESEARCH"},
    { 0x11E7, "TOSHIBA AMERICA, ELEC. COMPANY"},
    { 0x11E8, "DIGITAL PROCESSING SYSTEMS INC."},
    { 0x11E9, "HIGHWATER DESIGNS LTD."},
    { 0x11EA, "ELSAG BAILEY"},
    { 0x11EB, "FORMATION INC."},
    { 0x11EC, "CORECO INC"},
    { 0x11ED, "MEDIAMATICS"},
    { 0x11EE, "DOME IMAGING SYSTEMS INC"},
    { 0x11EF, "NICOLET TECHNOLOGIES B.V."},
    { 0x11F0, "COMPU-SHACK GMBH"},
    { 0x11F1, "SYMBIOS LOGIC INC"},
    { 0x11F2, "PICTURE TEL JAPAN K.K."},
    { 0x11F3, "KEITHLEY METRABYTE"},
    { 0x11F4, "KINETIC SYSTEMS CORPORATION"},
    { 0x11F5, "COMPUTING DEVICES INTERNATIONAL"},
    { 0x11F6, "POWERMATIC DATA SYSTEMS LTD"},
    { 0x11F7, "SCIENTIFIC ATLANTA"},
    { 0x11F8, "PMC-SIERRA INC"},
    { 0x11F9, "I-CUBE INC"},
    { 0x11FA, "KASAN ELECTRONICS COMPANY, LTD."},
    { 0x11FB, "DATEL INC"},
    { 0x11FC, "SILICON MAGIC"},
    { 0x11FD, "HIGH STREET CONSULTANTS"},
    { 0x11FE, "COMTROL CORPORATION"},
    { 0x11FF, "SCION CORPORATION"},
    { 0x1200, "CSS CORPORATION"},
    { 0x1201, "VISTA CONTROLS CORP"},
    { 0x1202, "NETWORK GENERAL CORP."},
    { 0x1203, "BAYER CORPORATION, AGFA DIVISION"},
    { 0x1204, "LATTICE SEMICONDUCTOR CORPORATION"},
    { 0x1205, "ARRAY CORPORATION"},
    { 0x1206, "AMDAHL CORPORATION"},
    { 0x1208, "PARSYTEC GMBH"},
    { 0x1209, "SCI SYSTEMS INC"},
    { 0x120A, "SYNAPTEL"},
    { 0x120B, "ADAPTIVE SOLUTIONS"},
    { 0x120D, "COMPRESSION LABS, INC."},
    { 0x120E, "CYCLADES CORPORATION"},
    { 0x120F, "ESSENTIAL COMMUNICATIONS"},
    { 0x1210, "HYPERPARALLEL TECHNOLOGIES"},
    { 0x1211, "BRAINTECH INC"},
    { 0x1212, "KINGSTON TECHNOLOGY CORP."},
    { 0x1213, "APPLIED INTELLIGENT SYSTEMS, INC."},
    { 0x1214, "PERFORMANCE TECHNOLOGIES, INC."},
    { 0x1215, "INTERWARE CO., LTD"},
    { 0x1216, "PURUP PREPRESS A/S"},
    { 0x1217, "2 MICRO, INC."},
    { 0x1218, "HYBRICON CORP."},
    { 0x1219, "FIRST VIRTUAL CORPORATION"},
    { 0x121A, "3DFX INTERACTIVE, INC."},
    { 0x121B, "ADVANCED TELECOMMUNICATIONS MODULES"},
    { 0x121C, "NIPPON TEXA CO., LTD"},
    { 0x121D, "LIPPERT AUTOMATIONSTECHNIK GMBH"},
    { 0x121E, "CSPI"},
    { 0x121F, "ARCUS TECHNOLOGY, INC."},
    { 0x1220, "ARIEL CORPORATION"},
    { 0x1221, "CONTEC CO., LTD"},
    { 0x1222, "ANCOR COMMUNICATIONS, INC."},
    { 0x1223, "HEURIKON/COMPUTER PRODUCTS"},
    { 0x122C, "SICAN GMBH"},
    { 0x1234, "TECHNICAL CORP."},
    { 0x1239, "THE 3DO Company"},
    { 0x124F, "INFORTREND TECHNOLOGY INC."},
    { 0x126F, "SILICON MOTION"},
    { 0x1275, "NETWORK APPLIANCE"},
    { 0x1278, "TRANSTECH PARALLEL SYSTEMS"},
    { 0x127B, "PIXERA CORPORATION"},
    { 0x1297, "HOLCO ENTERPRISE"},
    { 0x12A1, "SIMPACT, INC"},
    { 0x12BA, "BITTWARE RESEARCH SYSTEMS, INC."},
    { 0x12E7, "SEBRING SYSTEMS, INC."},
    { 0x12EB, "AUREAL SEMICONDUCTOR"},
    { 0x3D3D, "3DLABS"},
    { 0x4005, "AVANCE LOGIC  INC"},
    { 0x5333, "S3 INC."},
    { 0x8086, "INTEL"},
    { 0x8E0E, "COMPUTONE CORPORATION"},
    { 0x9004, "ADAPTEC"},
    { 0xE159, "TIGER JET NETWORK INC."},
    { 0xEDD8, "ARK LOGIC INC"}
};

//
//  Taken from the PCI driver
//
#define PCI_TYPE0_RANGE_COUNT   ((PCI_TYPE0_ADDRESSES) + 1)
#define PCI_TYPE1_RANGE_COUNT   ((PCI_TYPE1_ADDRESSES) + 4)
#define PCI_TYPE2_RANGE_COUNT   ((PCI_TYPE2_ADDRESSES) + 1)

#if PCI_TYPE0_RANGE_COUNT > PCI_TYPE1_RANGE_COUNT
    #if PCI_TYPE0_RANGE_COUNT > PCI_TYPE2_RANGE_COUNT
        #define PCI_MAX_RANGE_COUNT PCI_TYPE0_RANGE_COUNT
    #else
        #define PCI_MAX_RANGE_COUNT PCI_TYPE2_RANGE_COUNT
    #endif
#else
    #if PCI_TYPE1_RANGE_COUNT > PCI_TYPE2_RANGE_COUNT
        #define PCI_MAX_RANGE_COUNT PCI_TYPE1_RANGE_COUNT
    #else
        #define PCI_MAX_RANGE_COUNT PCI_TYPE2_RANGE_COUNT
    #endif
#endif


VOID
DevExtUsage()
{
   dprintf("!devext <addess> <type>\n");
   dprintf("  <address> is the address of a device extension to\n");
   dprintf("            be dumped.\n");
   dprintf("  <type>    is the type of the object owning this extension:\n");
   dprintf("            PCI if it is a PCI device extension\n");
   dprintf("            ISAPNP if it is an ISAPNP device extension\n");
   dprintf("            PCMCIA if it a PCMCIA device extension\n");
   dprintf("            USBD OPENHCI UHCD if it is a USB Host Controller extension\n");
   dprintf("            USBHUB if it is a USB Hub extension\n");
   dprintf("            HID if it is a HID device extension\n");

   return;
}

VOID
DevExtPciFindClassCodes(
    ULONG PdoxBaseClass,
    ULONG PdoxSubClass,
    PUCHAR * BaseClass,
    PUCHAR * SubClass
    )
{
   PUCHAR bc = "Unknown Base Class";
   PUCHAR sc = "Unknown Sub Class";

   switch (PdoxBaseClass) {
   case PCI_CLASS_PRE_20:

      // Class 00 - PCI_CLASS_PRE_20:

      bc = "Pre PCI 2.0";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_PRE_20_NON_VGA:
         sc = "Pre PCI 2.0 Non-VGA Device";
         break;
      case PCI_SUBCLASS_PRE_20_VGA:
         sc = "Pre PCI 2.0 VGA Device";
         break;
      }
      break;

   case PCI_CLASS_MASS_STORAGE_CTLR:

      // Class 01 - PCI_CLASS_MASS_STORAGE_CTLR:

      bc = "Mass Storage Controller";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_MSC_SCSI_BUS_CTLR:
         sc = "SCSI";
         break;
      case PCI_SUBCLASS_MSC_IDE_CTLR:
         sc = "IDE";
         break;
      case PCI_SUBCLASS_MSC_FLOPPY_CTLR:
         sc = "Floppy";
         break;
      case PCI_SUBCLASS_MSC_IPI_CTLR:
         sc = "IPI";
         break;
      case PCI_SUBCLASS_MSC_RAID_CTLR:
         sc = "RAID";
         break;
      case PCI_SUBCLASS_MSC_OTHER:
         sc = "'Other'";
         break;
      }
      break;

   case PCI_CLASS_NETWORK_CTLR:

      // Class 02 - PCI_CLASS_NETWORK_CTLR:

      bc = "Network Controller";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_NET_ETHERNET_CTLR:
         sc = "Ethernet";
         break;
      case PCI_SUBCLASS_NET_TOKEN_RING_CTLR:
         sc = "Token Ring";
         break;
      case PCI_SUBCLASS_NET_FDDI_CTLR:
         sc = "FDDI";
         break;
      case PCI_SUBCLASS_NET_ATM_CTLR:
         sc = "ATM";
         break;
      case PCI_SUBCLASS_NET_OTHER:
         sc = "'Other'";
         break;
      }
      break;

   case PCI_CLASS_DISPLAY_CTLR:

      // Class 03 - PCI_CLASS_DISPLAY_CTLR:

      // N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte:

      bc = "Display Controller";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_VID_VGA_CTLR:
         sc = "VGA";
         break;
      case PCI_SUBCLASS_VID_XGA_CTLR:
         sc = "XGA";
         break;
      case PCI_SUBCLASS_VID_OTHER:
         sc = "'Other'";
         break;
      }
      break;

   case PCI_CLASS_MULTIMEDIA_DEV:

      // Class 04 - PCI_CLASS_MULTIMEDIA_DEV:

      bc = "Multimedia Device";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_MM_VIDEO_DEV:
         sc = "Video";
         break;
      case PCI_SUBCLASS_MM_AUDIO_DEV:
         sc = "Audio";
         break;
      case PCI_SUBCLASS_MM_OTHER:
         sc = "'Other'";
         break;
      }
      break;

   case PCI_CLASS_MEMORY_CTLR:

      // Class 05 - PCI_CLASS_MEMORY_CTLR:

      bc = "Memory Controller";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_MEM_RAM:
         sc = "RAM";
         break;
      case PCI_SUBCLASS_MEM_FLASH:
         sc = "FLASH";
         break;
      case PCI_SUBCLASS_MEM_OTHER:
         sc = "'Other'";
         break;
      }
      break;

   case PCI_CLASS_BRIDGE_DEV:

      // Class 06 - PCI_CLASS_BRIDGE_DEV:

      bc = "Bridge";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_BR_HOST:
         sc = "HOST to PCI";
         break;
      case PCI_SUBCLASS_BR_ISA:
         sc = "PCI to ISA";
         break;
      case PCI_SUBCLASS_BR_EISA:
         sc = "PCI to EISA";
         break;
      case PCI_SUBCLASS_BR_MCA:
         sc = "PCI to MCA";
         break;
      case PCI_SUBCLASS_BR_PCI_TO_PCI:
         sc = "PCI to PCI";
         break;
      case PCI_SUBCLASS_BR_PCMCIA:
         sc = "PCI to PCMCIA";
         break;
      case PCI_SUBCLASS_BR_NUBUS:
         sc = "PCI to NUBUS";
         break;
      case PCI_SUBCLASS_BR_CARDBUS:
         sc = "PCI to CardBus";
         break;
      case PCI_SUBCLASS_BR_OTHER:
         sc = "PCI to 'Other'";
         break;
      }
      break;

   case PCI_CLASS_SIMPLE_COMMS_CTLR:

      // Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR:

      // N.B. Sub Class 00 and 01 additional info in Interface byte:

      bc = "Simple Serial Communications Controller";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_COM_SERIAL:
         sc = "Serial Port";
         break;
      case PCI_SUBCLASS_COM_PARALLEL:
         sc = "Parallel Port";
         break;
      case PCI_SUBCLASS_COM_OTHER:
         sc = "'Other'";
         break;
      }
      break;

   case PCI_CLASS_BASE_SYSTEM_DEV:

      // Class 08 - PCI_CLASS_BASE_SYSTEM_DEV:

      // N.B. See Interface byte for additional info.:

      bc = "Base System Device";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_SYS_INTERRUPT_CTLR:
         sc = "Interrupt Controller";
         break;
      case PCI_SUBCLASS_SYS_DMA_CTLR:
         sc = "DMA Controller";
         break;
      case PCI_SUBCLASS_SYS_SYSTEM_TIMER:
         sc = "System Timer";
         break;
      case PCI_SUBCLASS_SYS_REAL_TIME_CLOCK:
         sc = "Real Time Clock";
         break;
      case PCI_SUBCLASS_SYS_OTHER:
         sc = "'Other' base system device";
         break;
      }
      break;

   case PCI_CLASS_INPUT_DEV:

      // Class 09 - PCI_CLASS_INPUT_DEV:

      bc = "Input Device";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_INP_KEYBOARD:
         sc = "Keyboard";
         break;
      case PCI_SUBCLASS_INP_DIGITIZER:
         sc = "Digitizer";
         break;
      case PCI_SUBCLASS_INP_MOUSE:
         sc = "Mouse";
         break;
      case PCI_SUBCLASS_INP_OTHER:
         sc = "'Other'";
         break;
      }
      break;

   case PCI_CLASS_DOCKING_STATION:

      // Class 0a - PCI_CLASS_DOCKING_STATION:

      bc = "Docking Station";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_DOC_GENERIC:
         sc = "Generic";
         break;
      case PCI_SUBCLASS_DOC_OTHER:
         sc = "'Other'";
         break;
      }
      break;

   case PCI_CLASS_PROCESSOR:

      // Class 0b - PCI_CLASS_PROCESSOR:

      bc = "Processor";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_PROC_386:
         sc = "386";
         break;
      case PCI_SUBCLASS_PROC_486:
         sc = "486";
         break;
      case PCI_SUBCLASS_PROC_PENTIUM:
         sc = "Pentium";
         break;
      case PCI_SUBCLASS_PROC_ALPHA:
         sc = "Alpha";
         break;
      case PCI_SUBCLASS_PROC_POWERPC:
         sc = "PowerPC";
         break;
      case PCI_SUBCLASS_PROC_COPROCESSOR:
         sc = "CoProcessor";
         break;
      }
      break;

   case PCI_CLASS_SERIAL_BUS_CTLR:

      // Class 0c - PCI_CLASS_SERIAL_BUS_CTLR:

      bc = "Serial Bus Controller";

      switch (PdoxSubClass) {
      case PCI_SUBCLASS_SB_IEEE1394:
         sc = "1394";
         break;
      case PCI_SUBCLASS_SB_ACCESS:
         sc = "Access Bus";
         break;
      case PCI_SUBCLASS_SB_SSA:
         sc = "SSA";
         break;
      case PCI_SUBCLASS_SB_USB:
         sc = "USB";
         break;
      case PCI_SUBCLASS_SB_FIBRE_CHANNEL:
         sc = "Fibre Channel";
         break;
      }
      break;

   case PCI_CLASS_NOT_DEFINED:

      bc = "(Explicitly) Undefined";
      break;
   }
   *BaseClass = bc;
   *SubClass  = sc;
}


VOID
DevExtPciPrintDeviceState(
    PCI_OBJECT_STATE State
    )
{
    if ((sizeof(DevExtPciDeviceState) / sizeof(DevExtPciDeviceState[0])) !=
        PciMaxObjectState) {
        dprintf("\nWARNING: PCI_OBJECT_STATE enumeration changed, please review.\n");
    }

    if (State >= PciMaxObjectState) {
        dprintf("Unknown PCI Object state.\n");
        return;
    }

    dprintf("  Driver State = %s\n", DevExtPciDeviceState[State]);
}

//#if 0
VOID
DevExtPciPrintPowerState(
    ULONG64    Power
    )
{
#define MAXSYSPOWSTATES \
    (sizeof(DevExtPciSystemPowerState) / sizeof(DevExtPciSystemPowerState[0]))
#define MAXDEVPOWSTATES \
    (sizeof(DevExtPciDevicePowerState) / sizeof(DevExtPciDevicePowerState[0]))

   SYSTEM_POWER_STATE   index;
   DEVICE_POWER_STATE   systemStateMapping[PowerSystemMaximum];
   ULONG64              pwrState, waitWakeIrp=0;
   PUCHAR sw, sc, dd, dc, dw;

   //
   // A little sanity.
   //

   if (MAXSYSPOWSTATES != PowerSystemMaximum) {
      dprintf("WARNING: System Power State definition has changed, ext dll is out of date.\n");
   }

   if (MAXDEVPOWSTATES != PowerDeviceMaximum) {
      dprintf("WARNING: Device Power State definition has changed, ext dll is out of date.\n");
   }

   sw = sc = dc = dw = "<*BAD VAL*>";

   GetFieldValue(Power, "pci!PCI_POWER_STATE", "CurrentSystemState", pwrState);
   if (pwrState < PowerSystemMaximum) {
      sc = DevExtPciSystemPowerState[pwrState];
   }

   GetFieldValue(Power, "pci!PCI_POWER_STATE", "CurrentDeviceState", pwrState);
   if (pwrState < PowerDeviceMaximum) {
      dc = DevExtPciDevicePowerState[pwrState];
   }

   GetFieldValue(Power, "pci!PCI_POWER_STATE", "DeviceWakeLevel", pwrState);
   if (pwrState < PowerDeviceMaximum) {
      dw = DevExtPciDevicePowerState[pwrState];
   }

   GetFieldValue(Power, "pci!PCI_POWER_STATE", "SystemWakeLevel", pwrState);
   if (pwrState < PowerSystemMaximum) {
      sw = DevExtPciSystemPowerState[pwrState];
   }

   dprintf(
          "  CurrentState:          System %s,  Device %s\n"
          "  WakeLevel:             System %s,  Device %s\n",
          sc,
          dc,
          sw,
          dw
          );

   GetFieldValue(Power, "pci!PCI_POWER_STATE", "SystemStateMapping", systemStateMapping);

   for (index = PowerSystemWorking; index < PowerSystemMaximum; index++) {

       if (systemStateMapping[index] != PowerDeviceUnspecified) {

           if (systemStateMapping[index] < PowerDeviceMaximum) {

               dc = DevExtPciDevicePowerState[systemStateMapping[index]];

           } else {

               dc = "<*BAD VAL*>";

           }
           dprintf("  %s:\t%s\n",
                  DevExtPciSystemPowerState[index],
                  dc
                  );

       }

   }

   GetFieldValue(Power, "pci!PCI_POWER_STATE", "WaitWakeIrp", waitWakeIrp);

   if (waitWakeIrp) {
      dprintf("  WaitWakeIrp:           %#08p\n",
             waitWakeIrp
             );
   }

#undef MAXSYSPOWSTATES
#undef MAXDEVPOWSTATES
}

VOID
DevExtPciPrintSecondaryExtensions(
    ULONG64  ListEntry
    )
{
    ULONG64     extension = 0, extype = 0;

    if (!ListEntry) {
        return;
    }
    xdprintf(1, "Secondary Extensions\n");
    do {

        GetFieldValue(ListEntry, "pci!PCI_SECONDARY_EXTENSION", "ExtensionType", extype);

        switch (extype) {
        case PciArb_Io:
            xdprintf(2, "Arbiter    - IO Port");
         break;
        case PciArb_Memory:
            xdprintf(2, "Arbiter    - Memory");
            break;
        case PciArb_Interrupt:
            xdprintf(2, "Arbiter    - Interrupt");
            break;
        case PciArb_BusNumber:
            xdprintf(2, "Arbiter    - Bus Number");
            break;
        case PciTrans_Interrupt:
            xdprintf(2, "Translator - Interrupt");
            break;
        case PciInterface_BusHandler:
            xdprintf(2, "Interface  - Bus Handler");
            break;
        case PciInterface_IntRouteHandler:
            xdprintf(2, "Interface  - Interrupt Route Handler");
            break;
        default:
            xdprintf(2, "Unknown Extension Type.");
            break;
        }
        dprintf("\n");

        GetFieldValue(ListEntry, "nt!_SINGLE_LIST_ENTRY", "Next", ListEntry);

    } while (ListEntry);
}

PUCHAR
DevExtPciFindVendorId(
    USHORT VendorId
    )

/*++

Routine Description:

    Get the vendor name given the vendor ID (assuming we know it).

Arguments:

    VendorId    16 bit PCI Vendor ID.

Return Value:

    Pointer to the vendor's name (or NULL).

--*/

{
#define PCIIDCOUNT (sizeof(DevExtPciVendors) / sizeof(DevExtPciVendors[0]))

   ULONG index;

   //
   // Yep, a binary search would be much faster, good thing we only
   // do this once per user iteration.
   //

   for (index = 0; index < PCIIDCOUNT; index++) {
      if (DevExtPciVendors[index].VendorId == VendorId) {
         return DevExtPciVendors[index].VendorName;
      }
   }
   return NULL;

#undef PCIIDCOUNT
}





#define GET_PCI_PDO_FIELD(Pdo,Field,Value) \
    GetPciExtensionField(TRUE, Pdo, Field, sizeof(Value), (PVOID)(&(Value)))

#define GET_PCI_FDO_FIELD(Fdo,Field,Value) \
    GetPciExtensionField(FALSE, Fdo, Field, sizeof(Value), (PVOID)(&(Value)))

ULONG
GetPciExtensionField(
    IN  BOOLEAN IsPdo,  // TRUE for PDO, false for FDO
    IN  ULONG64 TypeAddress,
    IN  PUCHAR  Field,
    IN  ULONG   OutSize,
    OUT PVOID   OutValue
    )
{
    ULONG ret;
    static PCHAR pciFDO = "nt!_PCI_FDO_EXTENSION", pciPDO = "nt!_PCI_PDO_EXTENSION";



    //
    // Try the post Win2k name for a pci extension (includes a PCI_ prefix)
    //

    // This would work for public symbols
    ret = GetFieldData(TypeAddress,
                       IsPdo ? pciPDO : pciFDO,
                       Field,
                       OutSize,
                       OutValue
                       );
    if (ret) {

        pciFDO = "pci!PCI_FDO_EXTENSION";
        pciPDO = "pci!PCI_PDO_EXTENSION";

        //
        // If we have private symbols, nt won't have those types, so try in pci
        //
        ret = GetFieldData(TypeAddress,
                           IsPdo ? pciPDO : pciFDO,
                           Field,
                           OutSize,
                           OutValue
                           );
    }


    //
    // If that failed then fall back on the name without the PCI_ prefix.  This
    // allows debugging Win2k clients with the post Win2k debugger
    //

    if (ret) {
        ret = GetFieldData(TypeAddress,
                           IsPdo ? "pci!PDO_EXTENSION" : "pci!FDO_EXTENSION",
                           Field,
                           OutSize,
                           OutValue
                           );
    }

    if (ret) {
        // didn't find anything, reste these
        pciFDO = "nt!_PCI_FDO_EXTENSION";
        pciPDO = "nt!_PCI_PDO_EXTENSION";
    }
    return ret;
}

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


VOID
DevExtPciGetBusDevFunc(
    IN ULONG64 PdoExt,
    OUT PULONG Bus,
    OUT PULONG Dev,
    OUT PULONG Func
    )
{
    ULONG BaseBus=0;
    ULONG64 ParentFdoExtension=0;
    PCI_SLOT_NUMBER slot;


    GET_PCI_PDO_FIELD(PdoExt, "ParentFdoExtension", ParentFdoExtension);

    if (GET_PCI_FDO_FIELD(ParentFdoExtension, "BaseBus", BaseBus)) {
       dprintf(
              "Failed to read memory at %08x for sizeof FDO Extension.\n",
              ParentFdoExtension
              );
    }

    if (GET_PCI_PDO_FIELD(PdoExt, "Slot", slot)){
        dprintf(
              "Failed to read memory at %08x\n",
              PdoExt
              );
    }

    *Bus = BaseBus;
    *Dev = slot.u.bits.DeviceNumber;
    *Func = slot.u.bits.FunctionNumber;

}

VOID
DevExtPci(
         ULONG64 Extension
         )

/*++

Routine Description:

    Dump a PCI Device extension.

Arguments:

    Extension   Address of the extension to be dumped.

Return Value:

    None.

--*/

{

   ULONG64       pdo=0, fdoX=0, pdoX=0, pcifield=0;
   ULONG         Signature=0, fieldoffset=0;
   ULONG         bus=0xff,dev=0xff,func=0xff;
   USHORT        vendorId=0xffff, deviceId=0xffff, subsystemVendorId=0xfff, subsystemId=0xffff;
   UCHAR         deviceState, baseClass, subClass, progIf, revisionId, interruptPin, rawInterruptLine, adjustedInterruptLine;
   UCHAR         secBus=0xff, subBus=0xff;
   PUCHAR        s;
   PUCHAR        bc;
   PUCHAR        sc;
   ULONG         i;
   BOOLEAN       found, subDecode=FALSE, isaBit=FALSE, vgaBit=FALSE;

   if (GET_PCI_PDO_FIELD(Extension, "ExtensionType", Signature)) {
      dprintf(
             "Failed to read PCI object signature at %008p, giving up.\n",
             Extension
             );
      return;
   }

   switch (Signature) {
   case PciPdoExtensionType:

      //
      // PDO Extension.
      //

      DevExtPciGetBusDevFunc(Extension, &bus, &dev, &func);
      dprintf("PDO Extension, Bus 0x%x, Device %x, Function %d.\n",
             bus, dev, func
             );

      GET_PCI_PDO_FIELD(Extension, "PhysicalDeviceObject", pdo);
      GET_PCI_PDO_FIELD(Extension, "ParentFdoExtension", fdoX);

      dprintf("  DevObj %#08p PCI Parent Bus FDO DevExt %#08p\n",
             pdo, fdoX
             );

      GET_PCI_PDO_FIELD(Extension, "DeviceState", deviceState);
      GET_PCI_PDO_FIELD(Extension, "VendorId", vendorId);
      GET_PCI_PDO_FIELD(Extension, "DeviceId", deviceId);

      DevExtPciPrintDeviceState(deviceState);

      s = DevExtPciFindVendorId(vendorId);
      if (s != NULL) {
         dprintf("  Vendor ID %04x (%s)  Device ID %04X\n",
                vendorId,
                s,
                deviceId
                );
      } else {
         dprintf(
                "  Vendor ID %04x, Device ID %04X\n",
                vendorId,
                deviceId
                );
      }

      GET_PCI_PDO_FIELD(Extension, "SubsystemVendorId", subsystemVendorId);
      GET_PCI_PDO_FIELD(Extension, "SubsystemId", subsystemId);

      if (subsystemVendorId || subsystemId) {
         s = DevExtPciFindVendorId(subsystemVendorId);
         if (s != NULL) {
            dprintf(
                   "  Subsystem Vendor ID %04x (%s)  Subsystem ID %04X\n",
                   subsystemVendorId,
                   s,
                   subsystemId
                   );
         } else {
            dprintf("  Subsystem Vendor ID %04x, Subsystem ID %04X\n",
                   subsystemVendorId,
                   subsystemId
                   );
         }
      }

      GET_PCI_PDO_FIELD(Extension, "BaseClass", baseClass);
      GET_PCI_PDO_FIELD(Extension, "SubClass", subClass);

      DevExtPciFindClassCodes(baseClass, subClass, &bc, &sc);

      dprintf("  Class Base/Sub %02x/%02x  (%s/%s)\n",
             baseClass,
             subClass,
             bc,
             sc);

      GET_PCI_PDO_FIELD(Extension, "ProgIf", progIf);
      GET_PCI_PDO_FIELD(Extension, "RevisionId", revisionId);
      GET_PCI_PDO_FIELD(Extension, "InterruptPin", interruptPin);
      GET_PCI_PDO_FIELD(Extension, "RawInterruptLine", rawInterruptLine);
      GET_PCI_PDO_FIELD(Extension, "AdjustedInterruptLine", adjustedInterruptLine);
      dprintf("  Programming Interface: %02x, Revision: %02x, IntPin: %02x, Line Raw/Adj %02x/%02x\n",
             progIf,
             revisionId,
             interruptPin,
             rawInterruptLine,
             adjustedInterruptLine
             );

      {
          USHORT enables=0;

          GET_PCI_PDO_FIELD(Extension, "CommandEnables", enables);

          dprintf("  Enables ((cmd & 7) = %x): %s%s%s",
                enables,
                enables == 0 ? "<none>" :
                (enables & PCI_ENABLE_BUS_MASTER)         ? "B" : "",
                (enables & PCI_ENABLE_MEMORY_SPACE)       ? "M" : "",
                (enables & PCI_ENABLE_IO_SPACE)           ? "I" : ""
                );

          GET_PCI_PDO_FIELD(Extension, "CapabilitiesPtr", pcifield);


          if (pcifield) {
              dprintf("   Capabilities Pointer = %02x\n", pcifield);
          } else {
              dprintf("   Capabilities Pointer = <none>\n");
          }
      }

      GetFieldOffset("pci!PCI_PDO_EXTENSION", "PowerState", &fieldoffset);

      DevExtPciPrintPowerState(Extension+fieldoffset);

      if (baseClass == PCI_CLASS_BRIDGE_DEV) {

          if ((subClass == PCI_SUBCLASS_BR_PCI_TO_PCI) ||
              (subClass == PCI_SUBCLASS_BR_CARDBUS)) {

              GetFieldOffset("pci!PCI_PDO_EXTENSION", "Dependent", &fieldoffset);

              GetFieldValue(Extension+fieldoffset,
                           "pci!PCI_HEADER_TYPE_DEPENDENT",
                           "type1.SecondaryBus",
                           secBus);

              GetFieldValue(Extension+fieldoffset,
                           "pci!PCI_HEADER_TYPE_DEPENDENT",
                           "type1.SecondaryBus",
                           subBus);

              dprintf("  Bridge PCI-%s Secondary Bus = 0x%x, Subordinate Bus = 0x%x\n",
                      subClass == PCI_SUBCLASS_BR_PCI_TO_PCI
                      ? "PCI" : "CardBus",
                      secBus,
                      subBus
                      );

              GetFieldValue(Extension+fieldoffset,
                           "pci!PCI_HEADER_TYPE_DEPENDENT",
                           "type1.SubtractiveDecode",
                           subDecode);

              GetFieldValue(Extension+fieldoffset,
                           "pci!PCI_HEADER_TYPE_DEPENDENT",
                           "type1.IsaBitSet",
                           isaBit);

              GetFieldValue(Extension+fieldoffset,
                           "pci!PCI_HEADER_TYPE_DEPENDENT",
                           "type1.VgaBitSet",
                           vgaBit);

            if (subDecode || isaBit || vgaBit) {
               CHAR preceed = ' ';

               dprintf("  Bridge Flags:");

               if (subDecode) {
                  dprintf("%c Subtractive Decode", preceed);
                  preceed = ',';
               }
               if (isaBit) {
                  dprintf("%c ISA", preceed);
                  preceed = ',';
               }
               if (vgaBit) {
                  dprintf("%c VGA", preceed);
                  preceed = ',';
               }
               dprintf("\n");
            }
         }
      }

      //
      //  Now lets parse our PCI_FUNCTION_RESOURCES struct
      //

      pcifield = 0;
      GET_PCI_PDO_FIELD(Extension, "Resources", pcifield);

      dprintf("  Requirements:");

      if (pcifield) {

          ULONG64 limit = 0, current=0;
          ULONG   ioSize=0, cmSize=0, type=0;
          ULONG   alignment, length, minhighpart, minlowpart, maxhighpart, maxlowpart;

          ioSize = GetTypeSize("nt!IO_RESOURCE_DESCRIPTOR");
          cmSize = GetTypeSize("nt!CM_PARTIAL_RESOURCE_DESCRIPTOR");

          //
          //  Limit begins at offset 0
          //
          limit = pcifield;

          found = FALSE;
          dprintf(" Alignment  Length    Minimum          Maximum\n");
          for (i = 0; i < PCI_MAX_RANGE_COUNT; i++) {

              type=0;

              GetFieldValue(limit, "nt!IO_RESOURCE_DESCRIPTOR", "Type", type);

              if (type == CmResourceTypeNull) {
                  continue;
              }

              GetFieldValue(limit, "nt!IO_RESOURCE_DESCRIPTOR", "u.Generic.Alignment", alignment);
              GetFieldValue(limit, "nt!IO_RESOURCE_DESCRIPTOR", "u.Generic.Length", length);
              GetFieldValue(limit, "nt!IO_RESOURCE_DESCRIPTOR", "u.Generic.MinimumAddress.HighPart", minhighpart);
              GetFieldValue(limit, "nt!IO_RESOURCE_DESCRIPTOR", "u.Generic.MinimumAddress.LowPart", minlowpart);
              GetFieldValue(limit, "nt!IO_RESOURCE_DESCRIPTOR", "u.Generic.MaximumAddress.HighPart", maxhighpart);
              GetFieldValue(limit, "nt!IO_RESOURCE_DESCRIPTOR", "u.Generic.MaximumAddress.LowPart", maxlowpart);

              dprintf("        %s: %08x   %08x  %08x%08x %08x%08x\n",
                      type == CmResourceTypeMemory ? "Memory" : "    Io",
                      alignment,
                      length,
                      minhighpart,
                      minlowpart,
                      maxhighpart,
                      maxlowpart
                      );

              limit += ioSize;
          }

          //
          //  Get the offset for Current so we can dump it next
          //
          GetFieldOffset("pci!PCI_FUNCTION_RESOURCES", "Current", &fieldoffset);

          current = pcifield+fieldoffset;

          dprintf("  Current:");
          for (i = 0; i < PCI_MAX_RANGE_COUNT; i++) {

              type=0;
              length=0;
              maxhighpart=0;
              maxlowpart=0;

              GetFieldValue(current, "nt!CM_PARTIAL_RESOURCE_DESCRIPTOR", "Type", type);

              if (type == CmResourceTypeNull) {
                  continue;
              }

              if (!found) {
                  dprintf(" Start            Length\n");
                  found = TRUE;
              }

              GetFieldValue(current, "nt!CM_PARTIAL_RESOURCE_DESCRIPTOR", "u.Generic.Start.HighPart", maxhighpart);
              GetFieldValue(current, "nt!CM_PARTIAL_RESOURCE_DESCRIPTOR", "u.Generic.Start.LowPart", maxlowpart);
              GetFieldValue(current, "nt!CM_PARTIAL_RESOURCE_DESCRIPTOR", "u.Generic.Length", length);

              dprintf("   %s: %08x%08x %08x\n",
                      type == CmResourceTypeMemory ? "Memory" : "    Io",
                      maxhighpart,
                      maxlowpart,
                      length
                      );

              current += cmSize;
          }

          if (!found) {
              dprintf(" <none>\n");
          }

      } else {
         dprintf(" <none>\n");
      }

      GetFieldOffset("pci!PCI_PDO_EXTENSION", "SecondaryExtension", &fieldoffset);

      GetFieldValue(Extension+fieldoffset, "nt!_SINGLE_LIST_ENTRY", "Next", pcifield);

      DevExtPciPrintSecondaryExtensions(pcifield);

      break;

   case PciFdoExtensionType:

       //
       // FDO Extension
       //

       GET_PCI_FDO_FIELD(Extension, "BaseBus", bus);
       GET_PCI_FDO_FIELD(Extension, "PhysicalDeviceObject", pdo);

       dprintf("FDO Extension, Bus 0x%x, Parent PDO %#08p  Bus is ", bus,pdo);

       GET_PCI_FDO_FIELD(Extension, "BusRootFdoExtension", pcifield);

       if (pcifield == Extension) {
           dprintf("a root bus.\n");
       } else {

           GET_PCI_FDO_FIELD(Extension, "PhysicalDeviceObject", pcifield);

           GetFieldValue(pcifield, "nt!_DEVICE_OBJECT", "DeviceExtension", pdoX);

           if (!pdoX) {
               dprintf("a child bus.\n");
           }else{
               DevExtPciGetBusDevFunc(pdoX, &bus, &dev, &func);
               dprintf("a child of bus 0x%x.\n", bus);
           }

       }

       GET_PCI_FDO_FIELD(Extension, "DeviceState", deviceState);
       DevExtPciPrintDeviceState(deviceState);

       GetFieldOffset("pci!PCI_FDO_EXTENSION", "PowerState", &fieldoffset);
       DevExtPciPrintPowerState(Extension+fieldoffset);

       GET_PCI_FDO_FIELD(Extension, "ChildWaitWakeCount", pcifield);

       if (pcifield) {
           dprintf("Number of PDO's with outstanding WAIT_WAKEs = %d\n", pcifield);
       }

      {
         PUCHAR   heading = "  Child PDOXs:";
         ULONG    counter = 0;
         ULONG64  list = 0;

         GET_PCI_FDO_FIELD(Extension, "ChildPdoList", list);

         while (list) {
            if (counter == 0) {
               dprintf(heading);
               heading = "\n              ";
               counter = 1;
            } else if (counter == 2) {
               counter = 0;
            } else {
               counter++;
            }
            dprintf("  %#08p", list);

            GET_PCI_PDO_FIELD(list, "Next", list);
         }

        dprintf("\n");

      }

      GetFieldOffset("pci!PCI_FDO_EXTENSION", "SecondaryExtension", &fieldoffset);

      GetFieldValue(Extension+fieldoffset, "nt!_SINGLE_LIST_ENTRY", "Next", pcifield);

      DevExtPciPrintSecondaryExtensions(pcifield);

      break;
   default:
      dprintf("%08x doesn't seem to point to a PCI PDO or FDO extension,\n");
      dprintf("the PCI Device object extension signatures don't match.\n");
      return;
   }
}


DECLARE_API( devext )

/*++

Routine Description:

    Dumps a device extension.

Arguments:

    address     Address of the device extension to be dumped.
    type        Type of device extension.

Return Value:

    None

--*/

{

#define DEVEXT_MAXTOKENS 3
#define DEVEXT_MAXBUFFER 80
#define DEVEXT_USAGE()   { DevExtUsage(); return E_INVALIDARG; }

   ULONG64  Extension = 0;
   PUCHAR   ExtensionType;
   PUCHAR   Tokens[DEVEXT_MAXTOKENS];
   UCHAR    Buffer[DEVEXT_MAXBUFFER];
   PUCHAR   s;
   UCHAR    c;
   ULONG    count;

   //
   // Validate parameters.   Tokenize the incoming string, the first
   // argument should be a (kernel mode) address, the second a string.
   //

   //
   // args is const, we need to modify the buffer, copy it.
   //

   for (count = 0; count < DEVEXT_MAXBUFFER; count++) {
      if ((Buffer[count] = args[count]) == '\0') {
         break;
      }
   }
   if (count == DEVEXT_MAXBUFFER) {
      dprintf("Buffer to small to contain input arguments\n");
      DEVEXT_USAGE();
   }

   if (TokenizeString(Buffer, Tokens, DEVEXT_MAXTOKENS) !=
       (DEVEXT_MAXTOKENS - 1)) {
      DEVEXT_USAGE();
   }

   if ((Extension = GetExpression(Tokens[0])) == 0) {
      DEVEXT_USAGE();
   }

   // Signextend it
   if (DBG_PTR_SIZE == sizeof(ULONG)) {
       Extension = (ULONG64) (LONG64) (LONG) Extension;
   }
   if ((LONG64)Extension >= 0) {
      DEVEXT_USAGE();
   }

   //
   // The second argument should be a string telling us what kind of
   // device extension to dump.  Convert it to upper case to make life
   // easier.
   //

   s = Tokens[1];
   while ((c = *s) != '\0') {
      *s++ = (UCHAR)toupper(c);
   }

   s = Tokens[1];
   if (!strcmp(s, "PCI")) {

      //
      // It's a PCI device extension.
      //
      DevExtPci(Extension);

   } else if (!strcmp(s, "PCMCIA")) {
      //
      // It's a PCMCIA device extension
      //
      DevExtPcmcia(Extension);

   } else if (!strcmp(s, "USBD")) {
      //
      // It's a USBD device extension
      //
      DevExtUsbd(Extension);

   } else if (!strcmp(s, "OPENHCI")) {
      //
      // It's a OpenHCI device extension
      //
      DevExtOpenHCI(Extension);

   } else if (!strcmp(s, "UHCD")) {
      //
      // It's a UHCD device extension
      //
      DevExtUHCD(Extension);


   } else if (!strcmp(s, "HID")) {
      //
      // It's a HID device extension
      //
      DevExtHID(Extension);

   } else if (!strcmp(s, "USBHUB")) {
      //
      // It's a usbhub device extension
      //
       DevExtUsbhub(Extension);

   } else if (!strcmp(s, "ISAPNP")) {
      //
      // Congratulations! It's an ISAPNP device extension
      //
      DevExtIsapnp(Extension);

#if 0

   } else if (!strcmp(s, "SOME_OTHER_EXTENSION_TYPE")) {

      //
      // It's some other extension type.
      //

      DevExtSomeOther(Extension);

#endif
   } else {
      dprintf("Device extension type '%s' is not handled by !devext.\n", s);
   }
   return S_OK;
}


//
// pcitree data structures and functions
//

BOOLEAN
pcitreeProcessBus(
                 ULONG Indent,
                 ULONG64 InMemoryBusFdoX,
                 ULONG64 TreeTop
                 )
{
    ULONG64 BusFdoX=InMemoryBusFdoX;
    ULONG64 next;
    PUCHAR bc, sc, vendor;
    ULONG BaseBus, BaseClass, SubClass;
    ULONG64 ChildPdoList;

#define PdoxFld(F,V) GET_PCI_PDO_FIELD(next, #F, V)

    GET_PCI_FDO_FIELD(BusFdoX, "BaseBus", BaseBus);
    GET_PCI_FDO_FIELD(BusFdoX, "ChildPdoList", next);
    xdprintf(Indent,"");
    dprintf( "Bus 0x%x (FDO Ext %08p)\n",
             BaseBus,
             InMemoryBusFdoX);

   if (next == 0) {
      xdprintf(Indent, "No devices have been enumerated on this bus.\n");
      return TRUE;
   }

   Indent++;
   do {
       ULONG DeviceId, VendorId, DeviceNumber, FunctionNumber;
       ULONG64 BridgeFdoExtension;

       if (CheckControlC()) {
           return FALSE;
       }
       if (PdoxFld(BaseClass,BaseClass)) {
           xdprintf(Indent,"FAILED to read PDO Ext at ");
           dprintf("%08p, cannot continue this bus.\n",
                   next
                   );
           return TRUE;
       }

       PdoxFld(SubClass,SubClass);
       PdoxFld(DeviceId,DeviceId);
       PdoxFld(VendorId,VendorId);
       PdoxFld(Slot.u.bits.DeviceNumber,DeviceNumber);
       PdoxFld(Slot.u.bits.FunctionNumber,FunctionNumber);

       DevExtPciFindClassCodes(BaseClass, SubClass, &bc, &sc);

       xdprintf(Indent, "");
       dprintf("%02x%02x %04x%04x (d=%x,%s f=%d) devext %08p %s/%s\n",
              BaseClass,
              SubClass,
              DeviceId,
              VendorId,
              DeviceNumber,
              (DeviceNumber > 9 ? "" : " "),
              FunctionNumber,
              next,
              bc,
              sc
              );

#if 0

      // removed, too talkative. plj.

       vendor = DevExtPciFindVendorId(PdoX.VendorId);
       if (vendor) {
           xdprintf(Indent, "     (%s)\n", vendor);
       }

#endif

       if (BaseClass == PCI_CLASS_BRIDGE_DEV && SubClass == PCI_SUBCLASS_BR_PCI_TO_PCI) {

         //
         // Process child bus.
         //


           PdoxFld(BridgeFdoExtension,BridgeFdoExtension);

           //
           // Recurse.
           //

           if (pcitreeProcessBus(Indent, BridgeFdoExtension, TreeTop) == FALSE) {

               //
               // Error, exit.
               //

               return FALSE;
           }

       }

       PdoxFld(Next, next);

   } while (next);

#undef PdoxFld

   return TRUE;
}

DECLARE_API( pcitree )

/*++

Routine Description:

    Dumps the pci tree.   (Why is this here?   Because the other PCI stuff
    ended up in here because devnode was such a useful base).

Arguments:

    None

Return Value:

    None

--*/

{
   ULONG         Signature;
   ULONG64 TreeTop;
   ULONG64 list;
   ULONG64 addr;
   ULONG indent = 0;
   ULONG rootCount = 0;

   addr = GetExpression("Pci!PciFdoExtensionListHead");

   if (addr == 0) {
      dprintf("Error retrieving address of PciFdoExtensionListHead\n");
      return E_INVALIDARG;
   }

   if (!ReadPointer(addr, &list)) {
      dprintf("Error reading PciFdoExtensionListHead (@%08p)\n", addr);
      return E_INVALIDARG;
   }

   if (list == 0) {
      dprintf(
             "PciFdoExtensionListHead forward pointer is NULL, list is empty\n"
             );
      return E_INVALIDARG;
   }

   TreeTop = list;

   do {
       ULONG64 BusRootFdoExtension;

      if (CheckControlC()) {
         dprintf("User terminated with <control>C\n");
         break;
      }

      if (GET_PCI_FDO_FIELD(list, "BusRootFdoExtension", BusRootFdoExtension)) {
         dprintf(
                "Error reading PCI FDO extension at %08p, quitting.\n",
                list
                );
         return E_INVALIDARG;
      }

      if (BusRootFdoExtension == list) {

         //
         // This is the FDO for a root bus.
         //

         rootCount++;
         if (pcitreeProcessBus(0, list, TreeTop) == FALSE) {

            //
            // Asked not to continue;
            //

            dprintf("User terminated output.\n");
            break;
         }
      }

      GET_PCI_FDO_FIELD(list, "List.Next", list);

   } while (list != 0);

   dprintf("Total PCI Root busses processed = %d\n", rootCount);
   return S_OK;
}


VOID
DumpDeviceCapabilities(
    ULONG64 caps
    ) {
   FIELD_INFO fields [] = {
      { "DeviceD1",      "Spare1",       0, 0, 0, NULL},
      { "DeviceD2",      "\tDeviceD2",   0, 0, 0, NULL},
      { "LockSupported", "\tLock",       0, 0, 0, NULL},
      { "EjectSupported","\tEject",      0, 0, 0, NULL},
      { "Removeable",    "\tRemoveable", 0, 0, 0, NULL},
      { "DockDevice",    "\nDock Device",0, 0, 0, NULL},
      { "UniqueID",      "Unique ID",    0, 0, 0, NULL},
      { "SilentInstall", "\tSilent Install", 0, 0, 0, NULL},
      { "RawDeviceOK",   "\tRawDeviceOK",0, 0, 0, NULL},
      { "Address",       "\nAddress",    0, 0, 0, NULL},
      { "UINumber",      "",             0, 0, 0, NULL},
      { "DeviceState",   "\nDevice State : ",  0, DBG_DUMP_FIELD_ARRAY , 0, NULL},
      { "SystemWake",    "\nSystemWake", 0, 0, 0, NULL},
      { "DeviceWake",    "",             0, 0, 0, NULL},
   };
   UCHAR nm[] = "_DEVICE_CAPABILITIES";
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM),
      &nm[0],
      DBG_DUMP_NO_OFFSET | DBG_DUMP_COMPACT_OUT,
      caps,
      NULL,
      NULL,
      NULL,
      sizeof (fields) / sizeof (FIELD_INFO),
      &fields[0],
   };
   dprintf ("PnP CAPS: \n");

   Ioctl(IG_DUMP_SYMBOL_INFO, &Sym, sizeof (Sym));

}

#if 0
VOID
DumpDeviceCapabilities(
    PDEVICE_CAPABILITIES caps
    )
{
    ULONG i,j,k;
    ULONG bitmask;

    PCHAR bits [] = {
        "Spare1",
        "Spare1",
        "Lock",
        "Eject",
        "Removeable",
        "Dock Device",
        "Unique ID",
        "Silent Install",
        "RawDeviceOK"
        };

    bitmask = * (((PULONG) caps) + 1);

    dprintf ("PnP CAPS: ");
    for (i = 0, j = 1, k = 0; i < sizeof (bits); i++, j <<= 1) {

        if (bitmask & j) {

            if (k) {
                dprintf("\n          ");
            }
            k ^= 1;

            dprintf(bits [i]);
        }
    }
    dprintf("\n");

    dprintf("          Address %x UINumber %x \n",
            caps->Address,
            caps->UINumber);

    dprintf("          Device State [");

    for (i = 0; i < PowerSystemMaximum; i ++) {
        dprintf ("%02x ", (caps->DeviceState [i] & 0xFF));
    }
    dprintf("]\n");

    dprintf("          System Wake %x Device Wake %x\n",
            caps->SystemWake,
            caps->DeviceWake);
    dprintf("\n");
}
#endif

VOID
DumpTranslator(
    IN DWORD Depth,
    IN ULONG64 TranslatorAddr
    )
/*++

Routine Description:

    Dumps out the specified translator.

Arguments:

    Depth - Supplies the print depth.

    TranslatorAddr - Supplies the original address of the arbiter (on the target)

    Translator - Supplies the arbiter

Return Value:

    None.

--*/

{
//    TRANSLATOR_INTERFACE    interface;
    UCHAR                   buffer[256];
    ULONG64                 displacement;
    ULONG                   ResourceType;
    ULONG64                 TranslatorInterface, TranslateResources, TranslateResourceRequirements;

    if (GetFieldValue(TranslatorAddr,
                     "nt!_PI_RESOURCE_TRANSLATOR_ENTRY",
                      "ResourceType",
                      ResourceType)) {
        xdprintf( Depth, "");
        dprintf( "Could not read translator entry %08p\n",
                 TranslatorAddr
                 );
        return;
    }

    GetFieldValue(TranslatorAddr,"nt!_PI_RESOURCE_TRANSLATOR_ENTRY","TranslatorInterface", TranslatorInterface);
    xdprintf(Depth,
             "%s Translator\n",
             GetCmResourceTypeString((UCHAR)ResourceType)
             );

    if (GetFieldValue(TranslatorInterface,
                      "nt!_TRANSLATOR_INTERFACE",
                      "TranslateResources",
                      TranslateResources)) {
        dprintf("Error reading TranslatorInterface %08p for TranslatorEntry at %08p\n",
                TranslatorInterface,
                TranslatorAddr);

        return;
    }

    GetSymbol(TranslateResources, buffer, &displacement);

    xdprintf(Depth+1, "Resources:    %s", buffer, displacement);

    if (displacement != 0) {
        dprintf("+0x%1p\n", displacement);
    } else {
        dprintf("\n");
    }

    GetFieldValue(TranslatorInterface,"nt!_TRANSLATOR_INTERFACE",
                  "TranslateResourceRequirements",TranslateResourceRequirements);
    GetSymbol(TranslateResourceRequirements, buffer, &displacement);

    xdprintf(Depth+1, "Requirements: %s", buffer, displacement);

    if (displacement != 0) {
        dprintf("+0x%1p\n", displacement);
    } else {
        dprintf("\n");
    }

    return;
}


BOOLEAN
DumpTranslatorsForDevNode(
    IN DWORD   Depth,
    IN ULONG64 DevNodeAddr,
    IN DWORD   Flags
    )
/*++

Routine Description:

    Dumps all the translators for the specified devnode. Recursively calls
    itself on the specified devnode's children.

Arguments:

    Depth - Supplies the print depth.

    DevNodeAddr - Supplies the address of the devnode.

    Flags - Supplies the type of arbiters to dump:
        ARBITER_DUMP_IO
        ARBITER_DUMP_MEMORY
        ARBITER_DUMP_IRQ
        ARBITER_DUMP_DMA

Return Value:

    None

--*/

{
    ULONG    result;
    ULONG64  nextTranslator;
    ULONG64  translatorAddr;
    BOOLEAN  PrintedHeader = FALSE;
    BOOLEAN  continueDump = TRUE;
    ULONG    DeviceTranslatorListOffset, TransEntryOffset;
    ULONG64  Child, Sibling;

    if (GetFieldOffset("nt!_DEVICE_NODE", "DeviceTranslatorList", &DeviceTranslatorListOffset)) {
        dprintf("_DEVICE_NODE type not found.\n");
        return continueDump;
    }
    if (GetFieldOffset("nt!_PI_RESOURCE_TRANSLATOR_ENTRY", "DeviceTranslatorList", &TransEntryOffset)) {
        dprintf("_PI_RESOURCE_TRANSLATOR_ENTRY type not found.\n");
        return continueDump;
    }

    if (GetFieldValue(DevNodeAddr,
                      "nt!_DEVICE_NODE",
                      "DeviceTranslatorList.Flink",
                      nextTranslator)) {
        xdprintf(Depth, ""); dprintf("%08p: Could not read device node\n", DevNodeAddr);
        return continueDump;
    }

//    dprintf("Next %p, Devnode %p, Trans Off %x", nextTranslator, DevNodeAddr, DeviceTranslatorListOffset);
    //
    // Dump the list of translators
    //
    while (nextTranslator != DevNodeAddr+DeviceTranslatorListOffset) {
        ULONG ResourceType;

        if (CheckControlC()) {
            continueDump = FALSE;
            break;
        }

        translatorAddr = (nextTranslator-TransEntryOffset);
        if (GetFieldValue(translatorAddr,
                         "nt!_PI_RESOURCE_TRANSLATOR_ENTRY",
                          "ResourceType",
                          ResourceType)) {
            xdprintf( Depth, "");
            dprintf ("Could not read translator entry %08p for devnode %08p\n",
                      translatorAddr,
                      DevNodeAddr);
            break;
        }

        if (!PrintedHeader) {
            UNICODE_STRING64 u;

            dprintf("\n");
            xdprintf(Depth, ""); dprintf("DEVNODE %08p ", DevNodeAddr);
            GetFieldValue(DevNodeAddr,"nt!_DEVICE_NODE","InstancePath.Buffer", u.Buffer);
            GetFieldValue(DevNodeAddr,"nt!_DEVICE_NODE","InstancePath.Length", u.Length);
            GetFieldValue(DevNodeAddr,"nt!_DEVICE_NODE","InstancePath.MaximumLength", u.MaximumLength);
            if (u.Buffer != 0) {
                dprintf("(");
                DumpUnicode64(u);
                dprintf(")");
            }
            dprintf("\n");
            PrintedHeader = TRUE;
        }


        if (((ResourceType == CmResourceTypePort) && (Flags & ARBITER_DUMP_IO)) ||
            ((ResourceType == CmResourceTypeInterrupt) && (Flags & ARBITER_DUMP_IRQ)) ||
            ((ResourceType == CmResourceTypeMemory) && (Flags & ARBITER_DUMP_MEMORY)) ||
            ((ResourceType == CmResourceTypeDma) && (Flags & ARBITER_DUMP_DMA)) ||
            ((ResourceType == CmResourceTypeBusNumber) && (Flags & ARBITER_DUMP_BUS_NUMBER))) {

            DumpTranslator( Depth+1, translatorAddr);
        }

        GetFieldValue(translatorAddr,"nt!_PI_RESOURCE_TRANSLATOR_ENTRY","DeviceTranslatorList.Flink",nextTranslator);
    }

    GetFieldValue(DevNodeAddr,"nt!_DEVICE_NODE","Sibling", Sibling);
    GetFieldValue(DevNodeAddr,"nt!_DEVICE_NODE","Child", Child);

    //
    // Dump this devnode's children (if any)
    //
    if (continueDump && Child) {
        continueDump = DumpTranslatorsForDevNode( Depth+1, Child, Flags);
    }

    //
    // Dump this devnode's siblings (if any)
    //
    if (continueDump && Sibling) {
        continueDump = DumpTranslatorsForDevNode( Depth, Sibling, Flags);
    }

    return continueDump;
}


DECLARE_API( translator )

/*++

Routine Description:

    Dumps all the translators in the system

    !translator [flags]
        flags  1 - I/O port arbiters
               2 - memory arbiters
               4 - IRQ arbiters
               8 - DMA arbiters

    If no flags are specified, all translators are dumped.

Arguments:

    args - optional flags specifying which arbiters to dump

Return Value:

    None

--*/

{
   DWORD Flags=0;
   ULONG64 addr;
   ULONG64 deviceNode;

   if (!(Flags = (ULONG) GetExpression(args))) {
      Flags = ARBITER_DUMP_ALL;
   }

   //
   // Find the root devnode and dump its arbiters
   //

   addr = GetExpression( "nt!IopRootDeviceNode" );
   if (addr == 0) {
      dprintf("Error retrieving address of IopRootDeviceNode\n");
      return E_INVALIDARG;
   }

   if (!ReadPointer(addr, &deviceNode)) {
      dprintf("Error reading value of IopRootDeviceNode (%#010p)\n", addr);
      return E_INVALIDARG;
   }

   DumpTranslatorsForDevNode(0, deviceNode, Flags);

   return S_OK;
}

#define RAW_RANGE_DUMP_STATS_ONLY   0x00000001

VOID
DumpRawRangeEntry(
    IN DWORD   Depth,
    IN ULONG64 RangeEntry
    )
/*++

Routine Description:

    Dumps out the specified RTLP_RANGE_LIST_ENTRY

Arguments:

    Depth - Supplies the print depth.

    RangeList - Supplies the address of the RTLP_RANGE_LIST_ENTRY

    OwnerIsDevObj - Indicates that the owner field is a pointer to a DEVICE_OBJECT

Return Value:

    None.

--*/

{
    ULONG PublicFlags;
    ULONG64 UserData, Owner;
    ULONG64 Start, End;

    GetFieldValue(RangeEntry, "nt!_RTLP_RANGE_LIST_ENTRY", "Start", Start);
    GetFieldValue(RangeEntry, "nt!_RTLP_RANGE_LIST_ENTRY", "End", End);
    GetFieldValue(RangeEntry, "nt!_RTLP_RANGE_LIST_ENTRY", "PublicFlags", PublicFlags);
    GetFieldValue(RangeEntry, "nt!_RTLP_RANGE_LIST_ENTRY", "Allocated.UserData", UserData);
    GetFieldValue(RangeEntry, "nt!_RTLP_RANGE_LIST_ENTRY", "Allocated.Owner", Owner);

    xdprintf(Depth, "");
    dprintf ("%016I64x - %016I64x %c%c %08p %08p\n",
             Start,
             End,
             PublicFlags & RTL_RANGE_SHARED ? 'S' : ' ',
             PublicFlags & RTL_RANGE_CONFLICT ? 'C' : ' ',
             UserData,
             Owner
             );
}

BOOLEAN
DumpRawRangeList(
    IN DWORD   Depth,
    IN ULONG64 RangeListHead,
    IN ULONG   Flags,
    IN PULONG  MergedCount OPTIONAL,
    IN PULONG  EntryCount
    )
/*++

Routine Description:

    Dumps out the specified RTL_RANGE_LIST

Arguments:

    Depth - Supplies the print depth.

    RangeListHead - Supplies the address of the LIST_ENTRY containing the RTLP_RANGE_LIST_ENTRYs

Return Value:

    None.

--*/

{
    ULONG64       EntryAddr;
    ULONG64       ListEntry;
    ULONG         ListEntryOffset;
    BOOLEAN       continueDump = TRUE;

    //
    // Read the range list
    //
    if (GetFieldValue(RangeListHead, "nt!_LIST_ENTRY", "Flink", ListEntry)) {
        dprintf("Error reading RangeList %08p\n", RangeListHead);
        return continueDump;
    }

    if (ListEntry == RangeListHead) {
        xdprintf(Depth, "< none >\n");
        return continueDump;
    }
    GetFieldOffset("nt!RTLP_RANGE_LIST_ENTRY", "ListEntry", &ListEntryOffset);

    while (ListEntry != RangeListHead) {
        ULONG PrivateFlags;
        ULONG64 Start, End;

        if (CheckControlC()) {
            continueDump = FALSE;
            break;
        }

        EntryAddr = ( ListEntry - ListEntryOffset);

        if (GetFieldValue(EntryAddr, "nt!_RTLP_RANGE_LIST_ENTRY",
                          "PrivateFlags", PrivateFlags)) {
            dprintf("Error reading RangeEntry %08p from RangeList %08p\n",
                    EntryAddr,
                    RangeListHead);
            return continueDump;
        }

        (*EntryCount)++;

        if (PrivateFlags & RTLP_RANGE_LIST_ENTRY_MERGED) {
            ULONG MergedOffset;

            //
            // This is a merged range list, call ourselves recursively
            //
            if (MergedCount) {
                (*MergedCount)++;
            }
            if (!(Flags & RAW_RANGE_DUMP_STATS_ONLY)) {
                GetFieldValue(EntryAddr, "nt!_RTLP_RANGE_LIST_ENTRY", "Start", Start);
                GetFieldValue(EntryAddr, "nt!_RTLP_RANGE_LIST_ENTRY", "End", End);
                xdprintf(Depth, "Merged Range - %I64x-%I64x\n", Start, End);
            }

            GetFieldOffset("nt!_RTLP_RANGE_LIST_ENTRY", "Merged.ListHead", &MergedOffset);
            continueDump = DumpRawRangeList( Depth+1,
                                             EntryAddr + MergedOffset,
                                             Flags,
                                             MergedCount,
                                             EntryCount);

            if (!continueDump) {
                break;
            }

        } else if (!(Flags & RAW_RANGE_DUMP_STATS_ONLY)) {
            DumpRawRangeEntry(Depth, EntryAddr);
        }

        GetFieldValue(EntryAddr, "nt!_RTLP_RANGE_LIST_ENTRY", "ListEntry.Flink", ListEntry);
    }

    return continueDump;
}

DECLARE_API( rawrange )

/*++

Routine Description:

    Dumps an RTL_RANGE_LIST

Arguments:

    args - specifies the address of the RTL_RANGE_LIST

Return Value:

    None

--*/
{
    ULONG64 RangeList=0;
    ULONG   mergedCount = 0, entryCount = 0, flags=0, Offset;

    if (GetExpressionEx(args, &RangeList, &args)) {
        flags = (ULONG) GetExpression(args);
    }

    GetFieldOffset("nt!_RTLP_RANGE_LIST_ENTRY", "ListHead", &Offset);
    DumpRawRangeList(0, RangeList + Offset, flags, &mergedCount, &entryCount);

    dprintf("Stats\nMerged = %i\nEntries = %i\n", mergedCount, entryCount);

    return S_OK;
}


VOID
DumpIoResourceDescriptor(
    IN ULONG   Depth,
    IN ULONG64 Descriptor
    )
{
    ULONG64 Q1, Q2;
    ULONG Option, Type, ShareDisposition, Flags, V1, V2, V3, Data[3];

#define Desc(F,V) GetFieldValue(Descriptor, "nt!IO_RESOURCE_LIST", #F, V)

    Desc(Option,Option); Desc(Type,Type);
    Desc(ShareDisposition,ShareDisposition);
    Desc(Flags,Flags);

    DumpResourceDescriptorHeader(Depth,
                                 0,
                                 (UCHAR) Option,
                                 (UCHAR) Type,
                                 (UCHAR) ShareDisposition,
                                 (USHORT) Flags);

    Depth++;

    switch (Type) {
    case CmResourceTypeBusNumber:

        Desc(u.BusNumber.MinBusNumber, V1);
        Desc(u.BusNumber.MaxBusNumber, V2);
        Desc(u.BusNumber.Length, V3);
        xdprintf(Depth, "0x%x - 0x%x for length 0x%x\n",
                 V1, V2, V3);
        break;

    case CmResourceTypePort:
    case CmResourceTypeMemory:
        Desc(u.Generic.Length, V1);
        Desc(u.Generic.Alignment, V2);
        Desc(u.Port.MinimumAddress.QuadPart, Q1);
        Desc(u.Port.MaximumAddress.QuadPart, Q2);
        xdprintf(Depth, "%#08lx byte range with alignment %#08lx\n", V1, V2);
        xdprintf(Depth, "%I64x - %#I64x\n", Q1, Q2);

    case CmResourceTypeInterrupt:

        Desc(u.Interrupt.MinimumVector,V1);
        Desc(u.Interrupt.MaximumVector,V2);
        xdprintf(Depth, "0x%x - 0x%x\n", V1,V2);
        break;

    case CmResourceTypeDma:

        Desc(u.Dma.MinimumChannel,V1);
        Desc(u.Dma.MaximumChannel,V2);
        xdprintf(Depth, "0x%x - 0x%x\n",V1, V2);
        break;


    default:
        Desc(u.DevicePrivate.Data, Data);
        xdprintf(Depth,
                 "Data:              : 0x%x 0x%x 0x%x\n",
                 Data[0],
                 Data[1],
                 Data[2]);
        break;
    }
#undef Desc
}

DECLARE_API( ioresdes )
{
    ULONG64 descriptorAddr;

    descriptorAddr = GetExpression(args);

    DumpIoResourceDescriptor(0, descriptorAddr);

    return S_OK;
}

DECLARE_API( pnpevent )

/*++

Routine Description:

    Dump a device object.

Arguments:

    args - the location of the device object to dump.

Return Value:

    None

--*/

{
    ULONG64     deviceEventListAddr;
    ULONG64     listHead;
    ULONG64     deviceEvent = 0;
    ULONG       verbose = 0;
    ULONG64     address;
    ULONG       offset;
    BOOL        followLinks;
    ULONG64     status = 0, flink = 0, blink = 0;
    ULONG       eventQ_Header_SignalState = 0, lk_Event_Hdr_SignalState = 0;


    address = GetExpression( "nt!PpDeviceEventList" );

    if (address == 0) {
        dprintf("Error retrieving address of PpDeviceEventList\n");
        return E_INVALIDARG;
    }

    if (!ReadPointer(address, &deviceEventListAddr)) {
        dprintf("Error reading value of PpDeviceEventList (%#010lx)\n", address);
        return E_INVALIDARG;
    }

    if (GetFieldOffset("nt!_PNP_DEVICE_EVENT_LIST", "List", &offset)) {
        dprintf("Cannot find _PNP_DEVICE_EVENT_LIST.List type.\n");
        return E_INVALIDARG;
    }

    listHead = deviceEventListAddr + offset;

    dprintf("Dumping PpDeviceEventList @ 0x%08p\n", deviceEventListAddr);

    if (GetFieldValue(deviceEventListAddr, "nt!_PNP_DEVICE_EVENT_LIST", "Status", status)) {
        dprintf("Error reading PpDeviceEventList->Status (%#010p)\n", deviceEventListAddr);
        return E_INVALIDARG;
    }

    if (GetFieldValue(deviceEventListAddr, "nt!_PNP_DEVICE_EVENT_LIST", "EventQueueMutex.Header.SignalState", eventQ_Header_SignalState)) {
        dprintf("Error reading PpDeviceEventList->EventQueueMutex.Header.SignalState (%#010p)\n", deviceEventListAddr);
        return E_INVALIDARG;
    }

    if (GetFieldValue(deviceEventListAddr, "nt!_PNP_DEVICE_EVENT_LIST", "Lock.Event.Header.SignalState", lk_Event_Hdr_SignalState)) {
        dprintf("Error reading PpDeviceEventList->Lock.Event.Header.SignalState (%#010p)\n", deviceEventListAddr);
        return E_INVALIDARG;
    }

    if (GetFieldValue(deviceEventListAddr, "nt!_PNP_DEVICE_EVENT_LIST", "List.Flink", flink)) {
        dprintf("Error reading PpDeviceEventList->List.Flink (%#010p)\n", deviceEventListAddr);
        return E_INVALIDARG;
    }

    if (GetFieldValue(deviceEventListAddr, "nt!_PNP_DEVICE_EVENT_LIST", "List.Blink", blink)) {
        dprintf("Error reading PpDeviceEventList->List.Blink (%#010p)\n", deviceEventListAddr);
        return E_INVALIDARG;
    }

    dprintf("  Status = 0x%08I64X, EventQueueMutex is %sheld, Lock is %sheld\n",
            status,
            eventQ_Header_SignalState ? "not " : "",
            lk_Event_Hdr_SignalState ? "not " : "",
            flink, blink);

    dprintf("  List = 0x%08p, 0x%08p\n", flink, blink);

    if (GetExpressionEx(args, &deviceEvent, &args)) {
        verbose = (ULONG) GetExpression(args);
    }

    if (deviceEvent == 0) {

        ULONG   listEntryOffset = 0;

        if (flink == listHead) {
            dprintf("Event list is empty\n");
            return E_INVALIDARG;
        }

        //
        // Now get addtess of PNP_DEVICE_EVENT_ENTRY
        //
        if (GetFieldOffset("nt!_PNP_DEVICE_EVENT_ENTRY", "ListEntry", &offset)) {
            dprintf("Cannot find _PNP_DEVICE_EVENT_ENTRY type.\n");
            return E_INVALIDARG;
        }

        deviceEvent = flink - offset; //  CONTAINING_RECORD(deviceEventList.List.Flink, PNP_DEVICE_EVENT_ENTRY, ListEntry);

        followLinks = TRUE;

    } else {

        followLinks = FALSE;
    }

    DumpDeviceEventEntry( deviceEvent, listHead, followLinks );

    return S_OK;
}

BOOLEAN
DumpDeviceEventEntry(
    ULONG64                 DeviceEvent,
    ULONG64                 ListHead,
    BOOL                    FollowLinks
    )
{
    BOOLEAN     continueDump = TRUE;
    ULONG64     flink=0, blink=0, argument=0, callerEvent=0, callback=0, context=0;
    ULONG64     vetoType=0, vetoName=0;
    ULONG       dataSize=0;
    ULONG       offset;
    ULONG64     dataAddress;

    dprintf("\nDumping DeviceEventEntry @ 0x%08p\n", DeviceEvent);

    if (GetFieldValue(DeviceEvent, "nt!_PNP_DEVICE_EVENT_ENTRY", "ListEntry.Flink", flink)) {
        dprintf("Error reading DeviceEvent->ListEntry.Flink (%#010p)\n", DeviceEvent);
        return FALSE;
    }

    if (GetFieldValue(DeviceEvent, "nt!_PNP_DEVICE_EVENT_ENTRY", "ListEntry.Blink", blink)) {
        dprintf("Error reading DeviceEvent->ListEntry.Blink (%#010p)\n", DeviceEvent);
        return FALSE;
    }

    if (GetFieldValue(DeviceEvent, "nt!_PNP_DEVICE_EVENT_ENTRY", "CallerEvent", callerEvent)) {
        dprintf("Error reading DeviceEvent->CallerEvent (%#010p)\n", DeviceEvent);
        return FALSE;
    }

    if (GetFieldValue(DeviceEvent, "nt!_PNP_DEVICE_EVENT_ENTRY", "Callback", callback)) {
        dprintf("Error reading DeviceEvent->Callback (%#010p)\n", DeviceEvent);
        return FALSE;
    }

    if (GetFieldValue(DeviceEvent, "nt!_PNP_DEVICE_EVENT_ENTRY", "Context", context)) {
        dprintf("Error reading DeviceEvent->Context (%#010p)\n", DeviceEvent);
        return FALSE;
    }

    if (GetFieldValue(DeviceEvent, "nt!_PNP_DEVICE_EVENT_ENTRY", "VetoType", vetoType)) {
        dprintf("Error reading DeviceEvent->VetoType (%#010p)\n", DeviceEvent);
        return FALSE;
    }

    if (GetFieldValue(DeviceEvent, "nt!_PNP_DEVICE_EVENT_ENTRY", "VetoName", vetoName)) {
        dprintf("Error reading DeviceEvent->VetoName (%#010p)\n", DeviceEvent);
        return FALSE;
    }

    dprintf("  ListEntry = 0x%08p, 0x%08p, Argument = 0x%08I64x\n",
            flink, blink, argument);

    dprintf("  CallerEvent = 0x%08p, Callback = 0x%08p, Context = 0x%08p\n",
            callerEvent, callback, context);

    dprintf("  VetoType = 0x%08p, VetoName = 0x%08p\n",
            vetoType, vetoName);

    if (GetFieldOffset("nt!_PNP_DEVICE_EVENT_ENTRY", "Data", &offset)) {
        dprintf("Cannot find offset of Data in _PNP_DEVICE_EVENT_ENTRY type.\n");
        return FALSE;
    }

    dataAddress = DeviceEvent + offset;

    if (GetFieldValue(DeviceEvent, "nt!_PNP_DEVICE_EVENT_ENTRY", "Data.TotalSize", dataSize)) {
        dprintf("Error reading DeviceEvent->Data.TotalSize (%#010p)\n", DeviceEvent);
        return FALSE;
    }

    DumpPlugPlayEventBlock( dataAddress, dataSize );

    if (FollowLinks && flink != ListHead) {
        if (CheckControlC()) {
            continueDump = FALSE;
        } else {

            if (GetFieldOffset("nt!_PNP_DEVICE_EVENT_ENTRY", "ListEntry", &offset)) {
                dprintf("Cannot find offset of ListEntry in _PNP_DEVICE_EVENT_ENTRY type.\n");
                return FALSE;
            }

            continueDump = DumpDeviceEventEntry(flink - offset,
                                                ListHead,
                                                TRUE);
        }
    }

    return continueDump;
}

PUCHAR  DevNodeStateNames[] =  {
    "DeviceNodeUnspecified",
    "DeviceNodeUninitialized",
    "DeviceNodeInitialized",
    "DeviceNodeDriversAdded",
    "DeviceNodeResourcesAssigned",
    "DeviceNodeStartPending",
    "DeviceNodeStartCompletion",
    "DeviceNodeStartPostWork",
    "DeviceNodeStarted",
    "DeviceNodeQueryStopped",
    "DeviceNodeStopped",
    "DeviceNodeRestartCompletion",
    "DeviceNodeEnumeratePending",
    "DeviceNodeEnumerateCompletion",
    "DeviceNodeAwaitingQueuedDeletion",
    "DeviceNodeAwaitingQueuedRemoval",
    "DeviceNodeQueryRemoved",
    "DeviceNodeRemovePendingCloses",
    "DeviceNodeRemoved",
    "DeviceNodeDeletePendingCloses",
    "DeviceNodeDeleted"
    };

#define DEVNODE_STATE_NAMES_SIZE   (sizeof(DevNodeStateNames) / sizeof(DevNodeStateNames[0]))


VOID
PrintDevNodeState(
    IN ULONG Depth,
    IN PUCHAR Field,
    IN ULONG State
    )
{
    UCHAR   *Description;
    ULONG   stateIndex;

    stateIndex = State - 0x300; //DeviceNodeUnspecified;

    if (stateIndex < DEVNODE_STATE_NAMES_SIZE) {

        Description = DevNodeStateNames[stateIndex];
    } else {
        Description = "Unknown State";
    }

    xdprintf(Depth, "%s = %s (0x%x)\n", Field, Description, State);
}

VOID
DumpMultiSz(
    IN PWCHAR MultiSz
    )
{
    PWCHAR  p = MultiSz;
    ULONG   length;

    while (*p) {
        length = wcslen(p);
        dprintf("        %S\n", p);
        p += length + 1;
    }
}
struct  {
    CONST GUID *Guid;
    PCHAR   Name;
}   EventGuidTable[] =  {
    // From wdmguid.h
    { &GUID_HWPROFILE_QUERY_CHANGE,         "GUID_HWPROFILE_QUERY_CHANGE" },
    { &GUID_HWPROFILE_CHANGE_CANCELLED,     "GUID_HWPROFILE_CHANGE_CANCELLED" },
    { &GUID_HWPROFILE_CHANGE_COMPLETE,      "GUID_HWPROFILE_CHANGE_COMPLETE" },
    { &GUID_DEVICE_INTERFACE_ARRIVAL,       "GUID_DEVICE_INTERFACE_ARRIVAL" },
    { &GUID_DEVICE_INTERFACE_REMOVAL,       "GUID_DEVICE_INTERFACE_REMOVAL" },
    { &GUID_TARGET_DEVICE_QUERY_REMOVE,     "GUID_TARGET_DEVICE_QUERY_REMOVE" },
    { &GUID_TARGET_DEVICE_REMOVE_CANCELLED, "GUID_TARGET_DEVICE_REMOVE_CANCELLED" },
    { &GUID_TARGET_DEVICE_REMOVE_COMPLETE,  "GUID_TARGET_DEVICE_REMOVE_COMPLETE" },
    { &GUID_PNP_CUSTOM_NOTIFICATION,        "GUID_PNP_CUSTOM_NOTIFICATION" },
    { &GUID_PNP_POWER_NOTIFICATION,         "GUID_PNP_POWER_NOTIFICATION" },
    // From pnpmgr.h
    { &GUID_DEVICE_ARRIVAL,                 "GUID_DEVICE_ARRIVAL" },
    { &GUID_DEVICE_ENUMERATED,              "GUID_DEVICE_ENUMERATED" },
    { &GUID_DEVICE_ENUMERATE_REQUEST,       "GUID_DEVICE_ENUMERATE_REQUEST" },
    { &GUID_DEVICE_START_REQUEST,           "GUID_DEVICE_START_REQUEST" },
    { &GUID_DEVICE_REMOVE_PENDING,          "GUID_DEVICE_REMOVE_PENDING" },
    { &GUID_DEVICE_QUERY_AND_REMOVE,        "GUID_DEVICE_QUERY_AND_REMOVE" },
    { &GUID_DEVICE_EJECT,                   "GUID_DEVICE_EJECT" },
    { &GUID_DEVICE_NOOP,                    "GUID_DEVICE_NOOP" },
    { &GUID_DEVICE_SURPRISE_REMOVAL,        "GUID_DEVICE_SURPRISE_REMOVAL" },
    { &GUID_DRIVER_BLOCKED,                 "GUID_DRIVER_BLOCKED" },
};
#define EVENT_GUID_TABLE_SIZE   (sizeof(EventGuidTable) / sizeof(EventGuidTable[0]))

VOID
LookupGuid(
    IN CONST GUID *Guid,
    IN OUT PCHAR String,
    IN ULONG StringLength
    )
{
    int    i;

    for (i = 0; i < EVENT_GUID_TABLE_SIZE; i++) {
        if (memcmp(Guid, EventGuidTable[i].Guid, sizeof(Guid)) == 0) {
            strncpy(String, EventGuidTable[i].Name, StringLength - 1);
            String[StringLength - 1] = '\0';
            return;
        }
    }

    _snprintf( String, StringLength, "%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
               Guid->Data1,
               Guid->Data2,
               Guid->Data3,
               Guid->Data4[0],
               Guid->Data4[1],
               Guid->Data4[2],
               Guid->Data4[3],
               Guid->Data4[4],
               Guid->Data4[5],
               Guid->Data4[6],
               Guid->Data4[7] );
}

PUCHAR  EventCategoryStrings[] =  {
    "HardwareProfileChangeEvent",
    "TargetDeviceChangeEvent",
    "DeviceClassChangeEvent",
    "CustomDeviceEvent",
    "DeviceInstallEvent",
    "DeviceArrivalEvent",
    "PowerEvent",
    "VetoEvent",
    "BlockedDriverEvent"
};

#define N_EVENT_CATEGORIES  (sizeof(EventCategoryStrings) / sizeof(EventCategoryStrings[0]))

VOID
DumpPlugPlayEventBlock(
    ULONG64   PlugPlayEventBlock,
    ULONG     Size
    )
{
    GUID    EventGuid;
    UCHAR   guidString[256];
    UCHAR   PnpEventTyp[] = "nt!PLUGPLAY_EVENT_BLOCK";
    char    categoryString[80];
    ULONG64 Result=0, DeviceObject=0;
    ULONG   EventCategory=0, TotalSize=0, Flags=0;
    ULONG64 PtrVal=0;
    ULONG   offset;
    PUCHAR  buffer;
    ULONG   powerData;

    dprintf("\n  Dumping PlugPlayEventBlock @ 0x%08X\n", PlugPlayEventBlock);

    if (GetFieldValue(PlugPlayEventBlock, PnpEventTyp, "EventGuid", EventGuid)) {
        dprintf("Error reading PlugPlayEventBlock (%#010p)\n", PlugPlayEventBlock);
        return;
    }

    LookupGuid(&EventGuid, guidString, sizeof(guidString));

    GetFieldValue(PlugPlayEventBlock, PnpEventTyp, "EventCategory", EventCategory);
    GetFieldValue(PlugPlayEventBlock, PnpEventTyp, "Result", Result       );
    GetFieldValue(PlugPlayEventBlock, PnpEventTyp, "Flags", Flags        );
    GetFieldValue(PlugPlayEventBlock, PnpEventTyp, "TotalSize", TotalSize    );
    GetFieldValue(PlugPlayEventBlock, PnpEventTyp, "DeviceObject", DeviceObject );

    if ( EventCategory > N_EVENT_CATEGORIES) {
        sprintf(categoryString, "Unknown category (%d)", EventCategory);
    } else {
        strcpy(categoryString, EventCategoryStrings[ EventCategory ]);
    }

    dprintf("    EventGuid = %s\n    Category = %s\n",
            guidString, categoryString);
    dprintf("    Result = 0x%08p, Flags = 0x%08X, TotalSize = %d\n",
            Result, Flags, TotalSize );

    dprintf("    DeviceObject = 0x%08p\n", DeviceObject);

    switch (EventCategory) {
    case HardwareProfileChangeEvent:
        GetFieldValue(PlugPlayEventBlock, PnpEventTyp, "u.ProfileNotification.Notification", PtrVal);
        dprintf( "      Notification = 0x%08p\n", PtrVal );
        break;

    case DeviceArrivalEvent:
        break;

    case TargetDeviceChangeEvent:
        dprintf( "      DeviceIds:\n");

        GetFieldOffset(PnpEventTyp, "u.TargetDevice.DeviceIds", &offset);
        buffer = LocalAlloc(LPTR, Size - offset);
        xReadMemory(PlugPlayEventBlock + offset, buffer, Size - offset);
        DumpMultiSz( (PWCHAR)buffer );
        LocalFree(buffer);
        break;

    case DeviceClassChangeEvent:
#if DEBUGGER_GETS_FIXED
        GetFieldValue(PlugPlayEventBlock, PnpEventTyp, "u.DeviceClass.ClassGuid", EventGuid);
#else
        GetFieldOffset(PnpEventTyp, "u.DeviceClass.ClassGuid", &offset);
        xReadMemory(PlugPlayEventBlock + offset, &EventGuid, sizeof(EventGuid));
#endif
        LookupGuid(&EventGuid, guidString, sizeof(guidString));
        dprintf( "      ClassGuid = %s\n", guidString );

        GetFieldOffset(PnpEventTyp, "u.DeviceClass.SymbolicLinkName", &offset);
        buffer = LocalAlloc(LPTR, Size - offset);
        xReadMemory(PlugPlayEventBlock + offset, buffer, Size - offset);
        dprintf( "      SymbolicLinkName = %S\n", buffer );
        LocalFree(buffer);

        break;

    case CustomDeviceEvent:
        GetFieldValue(PlugPlayEventBlock, PnpEventTyp, "u.CustomNotification.NotificationStructure", PtrVal);
        dprintf( "      NotificationStructure = 0x%08p\n      DeviceIds:\n",
                 PtrVal);

        GetFieldOffset(PnpEventTyp, "u.CustomNotification.DeviceIds", &offset);
        buffer = LocalAlloc(LPTR, Size - offset);
        xReadMemory(PlugPlayEventBlock + offset, buffer, Size - offset);
        DumpMultiSz( (PWCHAR) buffer );
        LocalFree(buffer);
        break;

    case DeviceInstallEvent:
        GetFieldOffset(PnpEventTyp, "u.InstallDevice.DeviceId", &offset);
        buffer = LocalAlloc(LPTR, Size - offset);
        xReadMemory(PlugPlayEventBlock + offset, buffer, Size - offset);
        dprintf( "      DeviceId = %S\n", buffer );
        LocalFree(buffer);
        break;

    case PowerEvent:
        GetFieldValue(PlugPlayEventBlock, PnpEventTyp, "u.PowerNotification.NotificationCode", powerData);
        dprintf( "      NotificationCode = 0x%08X\n", powerData );
        GetFieldValue(PlugPlayEventBlock, PnpEventTyp, "u.PowerNotification.NotificationData", powerData);
        dprintf( "      NotificationData = 0x%08X\n", powerData );
        break;

    case BlockedDriverEvent:
#if DEBUGGER_GETS_FIXED
        GetFieldValue(PlugPlayEventBlock, PnpEventTyp, "u.BlockedDriverNotification.BlockedDriverGuid", EventGuid);
#else
        GetFieldOffset(PnpEventTyp, "u.BlockedDriverNotification.BlockedDriverGuid", &offset);
        xReadMemory(PlugPlayEventBlock + offset, &EventGuid, sizeof(EventGuid));
#endif
        LookupGuid(&EventGuid, guidString, sizeof(guidString));
        dprintf( "      BlockedDriverGuid = %s\n", guidString );
        break;
    }


}

DECLARE_API( rellist )

/*++

Routine Description:

    Dump a device object.

Arguments:

    args - the location of the device object to dump.

Return Value:

    None

--*/

{
    ULONG64  relationList=0;
    ULONG           verbose=0;

    if (GetExpressionEx(args, &relationList, &args)) {
        verbose = (ULONG) GetExpression(args);
    }

    DumpRelationsList( relationList,
                       (BOOLEAN) (verbose & DUMP_CM_RES),
                       (BOOLEAN) (verbose & DUMP_CM_RES_REQ_LIST),
                       (BOOLEAN) (verbose & DUMP_CM_RES_TRANS)
                       );
    return S_OK;
}

DECLARE_API( lbt )

/*++

Routine Description:

    Dump the legacy bus information table.

Arguments:

    args - none.

Return Value:

    None

--*/

{
    CHAR            buffer[256];
    ULONG           size, deviceNodeOffset;
    ULONG64         deviceNode;
    ULONG64         listHeadAddr, legacyBusEntryAddr;
    ULONG64         head_Flink, head_Blink, link_Flink;
    USHORT          instancePath_Len, instancePath_Max;
    ULONG           busNumber;
    ULONG64         instancePath_Buff, interfaceType;
    CHAR            deviceNodeType[] ="nt!_DEVICE_NODE";
    CHAR            listEntryType[] = "nt!_LIST_ENTRY" ;
    INTERFACE_TYPE  Iface;

    if ((size = GetTypeSize(listEntryType)) == 0) {

        dprintf("Failed to get the size of %s\n", listEntryType);
        return E_INVALIDARG;
    }
    if (GetFieldOffset(deviceNodeType, "LegacyBusListEntry.Flink", &deviceNodeOffset)) {

        dprintf("Failed to get the offset of LegacyBusListEntry from %s\n", deviceNodeType);
        return E_INVALIDARG;
    }
    dprintf("Legacy Bus Information Table...\n");
    for (Iface = Internal; Iface < MaximumInterfaceType; Iface++) {

        sprintf(buffer, "nt!IopLegacyBusInformationTable + %x", Iface * size);
        if ((listHeadAddr = GetExpression(buffer)) == 0) {

            dprintf("Error retrieving address of bus number list for interface %d\n", Iface);
            continue;
        }
        if (GetFieldValue(listHeadAddr, listEntryType, "Flink", head_Flink) ||
            GetFieldValue(listHeadAddr, listEntryType, "Blink", head_Blink)) {

            dprintf("Error reading value of bus number list head (0x%08p) for interface %d\n", listHeadAddr, Iface);
            continue;
        }
        if (head_Flink == listHeadAddr) {

            continue;
        }
        for (   legacyBusEntryAddr = head_Flink;
                legacyBusEntryAddr != listHeadAddr;
                legacyBusEntryAddr = link_Flink) {

            deviceNode = legacyBusEntryAddr - deviceNodeOffset;
            if (GetFieldValue(deviceNode, deviceNodeType, "BusNumber", busNumber)) {

                dprintf("Error reading BusNumber from (0x%08p)\n", deviceNode);
                break;
            }
            if (GetFieldValue(deviceNode, deviceNodeType, "InstancePath.Length", instancePath_Len)) {

                dprintf("Error reading InstancePath.Length from (0x%08p)\n", deviceNode);
                break;
            }
            if (GetFieldValue(deviceNode, deviceNodeType, "InstancePath.MaximumLength", instancePath_Max)) {

                dprintf("Error reading InstancePath.MaximumLength from (0x%08p)\n", deviceNode);
                break;
            }
            if (GetFieldValue(deviceNode, deviceNodeType, "InstancePath.Buffer", instancePath_Buff)) {

                dprintf("Error reading InstancePath.Buffer from (0x%08p)\n", deviceNode);
                break;
            }
            if (instancePath_Buff != 0) {

                UNICODE_STRING64 v;

                switch (Iface) {

                case InterfaceTypeUndefined:    dprintf("InterfaceTypeUndefined"); break;
                case Internal:                  dprintf("Internal"); break;
                case Isa:                       dprintf("Isa"); break;
                case Eisa:                      dprintf("Eisa"); break;
                case MicroChannel:              dprintf("Micro Channel"); break;
                case TurboChannel:              dprintf("Turbo Channel"); break;
                case PCIBus:                    dprintf("PCI"); break;
                case VMEBus:                    dprintf("VME"); break;
                case NuBus:                     dprintf("NuBus"); break;
                case PCMCIABus:                 dprintf("PCMCIA"); break;
                case CBus:                      dprintf("CBus"); break;
                case MPIBus:                    dprintf("MPIBus"); break;
                case MPSABus:                   dprintf("MPSABus"); break;
                case ProcessorInternal:         dprintf("Processor Internal"); break;
                case InternalPowerBus:          dprintf("Internal Power Bus"); break;
                case PNPISABus:                 dprintf("PnP Isa"); break;
                case PNPBus:                    dprintf("PnP Bus"); break;
                default:                        dprintf("** Unknown Interface Type **"); break;

                }
                dprintf("%d - !devnode 0x%08p\n", busNumber, deviceNode);
                v.Buffer        = instancePath_Buff;
                v.Length        = instancePath_Len;
                v.MaximumLength = instancePath_Max;
                dprintf("\t\""); DumpUnicode64(v); dprintf("\"\n");
            }

            if (GetFieldValue(legacyBusEntryAddr, listEntryType, "Flink", link_Flink)) {

                dprintf("Error reading Flink from (0x%08p)\n", legacyBusEntryAddr);
                break;
            }
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\driver.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <time.h>

VOID
DumpImage(
    ULONG Base,
    BOOL DoHeaders,
    BOOL DoSections
    );

PUCHAR DispatchRoutineTable[]=
{
    "IRP_MJ_CREATE",
    "IRP_MJ_CREATE_NAMED_PIPE",
    "IRP_MJ_CLOSE",
    "IRP_MJ_READ",
    "IRP_MJ_WRITE",
    "IRP_MJ_QUERY_INFORMATION",
    "IRP_MJ_SET_INFORMATION",
    "IRP_MJ_QUERY_EA",
    "IRP_MJ_SET_EA",
    "IRP_MJ_FLUSH_BUFFERS",
    "IRP_MJ_QUERY_VOLUME_INFORMATION",
    "IRP_MJ_SET_VOLUME_INFORMATION",
    "IRP_MJ_DIRECTORY_CONTROL",
    "IRP_MJ_FILE_SYSTEM_CONTROL",
    "IRP_MJ_DEVICE_CONTROL",
    "IRP_MJ_INTERNAL_DEVICE_CONTROL",
    "IRP_MJ_SHUTDOWN",
    "IRP_MJ_LOCK_CONTROL",
    "IRP_MJ_CLEANUP",
    "IRP_MJ_CREATE_MAILSLOT",
    "IRP_MJ_QUERY_SECURITY",
    "IRP_MJ_SET_SECURITY",
    "IRP_MJ_POWER",
    "IRP_MJ_SYSTEM_CONTROL",
    "IRP_MJ_DEVICE_CHANGE",
    "IRP_MJ_QUERY_QUOTA",
    "IRP_MJ_SET_QUOTA",
    "IRP_MJ_PNP",
    NULL
} ;

PUCHAR FastIoDispatchTable[]=
{
    "FastIoCheckIfPossible",
    "FastIoRead",
    "FastIoWrite",
    "FastIoQueryBasicInfo",
    "FastIoQueryStandardInfo",
    "FastIoLock",
    "FastIoUnlockSingle",
    "FastIoUnlockAll",
    "FastIoUnlockAllByKey",
    "FastIoDeviceControl",
    "AcquireFileForNtCreateSection",
    "ReleaseFileForNtCreateSection",
    "FastIoDetachDevice",
    "FastIoQueryNetworkOpenInfo",
    "AcquireForModWrite",
    "MdlRead",
    "MdlReadComplete",
    "PrepareMdlWrite",
    "MdlWriteComplete",
    "FastIoReadCompressed",
    "FastIoWriteCompressed",
    "MdlReadCompleteCompressed",
    "MdlWriteCompleteCompressed",
    "FastIoQueryOpen",
    "ReleaseForModWrite",
    "AcquireForCcFlush",
    "ReleaseForCcFlush",
    NULL
} ;

BOOL
IsName(PSTR str)
{
    if (!((tolower(*str) >= 'a' && tolower(*str) <= 'z') || *str == '_')) {
        return FALSE;
    }
    ++str;
    while (*str) {
        if (!((*str >= '0' && *str <= '9' ) || 
              (tolower(*str) >= 'a' && tolower(*str) <= 'z') || 
              *str == '_')) {
            return FALSE;
        }
        ++str;
    }
    return TRUE;
}

//
// Change this value and update the above table if IRP_MJ_MAXIMUM_FUNCTION
// is increased.
//
#define IRP_MJ_MAXIMUM_FUNCTION_HANDLED 0x1b

DECLARE_API( drvobj )

/*++

Routine Description:

    Dump a driver object.

Arguments:

    args - the location of the driver object to dump.

Return Value:

    None

--*/

{
    ULONG64 driverToDump;
    ULONG Flags;
    char driverExprBuf[256] ;
    char *driverExpr ;

    //
    // !drvobj DriverAddress DumpLevel
    //    where DriverAddress can be an expression or driver name
    //    and DumpLevel is a hex mask
    //
    strcpy(driverExprBuf, "\\Driver\\") ;
    driverExpr = driverExprBuf+strlen(driverExprBuf) ;
    Flags = 1;
    driverToDump = 0 ;

    if (!sscanf(args, "%s %lx", driverExpr, &Flags)) {
        driverExpr[0] = 0;
    }

    //
    // The debugger will treat C0000000 as a symbol first, then a number if
    // no match comes up. We sanely reverse this ordering.
    //
    if (driverExpr[0] == '\\') {

        driverToDump = FindObjectByName( driverExpr, 0);

    } else {

        if (IsName(driverExpr)) {

            driverToDump = FindObjectByName((PUCHAR) driverExprBuf, 0);
        } else {
            driverToDump = GetExpression( driverExpr ) ;

            if (driverToDump == 0) {

                driverToDump = FindObjectByName((PUCHAR) driverExprBuf, 0);
            }
        }
        
    }

    if(driverToDump == 0) {
        dprintf("Driver object %s not found\n", args);
        return E_INVALIDARG;
    }

    dprintf("Driver object (%08p) is for:\n", driverToDump);
    DumpDriver( driverToDump, 0, Flags);
    return S_OK;
}

VOID
DumpDriver(
    ULONG64 DriverAddress,
    ULONG   FieldWidth,
    ULONG   Flags
    )

/*++

Routine Description:

    Displays the driver name and the list of device objects created by
    the driver.

Arguments:

    DriverAddress - addres of the driver object to dump.
    FieldWidth    - Width of printf field (eg %11s) for driver name.
                    Use 0 for full display.
    Flags         - Bit 0, Dump out device objects owned by driver
                    Bit 1, Dump out dispatch routines for driver

Return Value:

    None

--*/

{
    // DRIVER_OBJECT    driverObject;
    ULONG            result;
    ULONG            i,j;
    PUCHAR           buffer;
    ULONG64          deviceAddress;
    // DEVICE_OBJECT    deviceObject;
    UNICODE_STRING   unicodeString;
    ULONG64          displacement;
    UCHAR            component[512];
    PUCHAR           *dispatchTableText ;
    // FAST_IO_DISPATCH FastIoDispatch;
    ULONG64          *p;
    ULONG Type=0, Name_MaxLen=0, Name_Len=0, LongAddr, IoD_SizeOfFastIoDispatch=0;
    ULONG64 MajorFunction[IRP_MJ_MAXIMUM_FUNCTION_HANDLED+1]= {0}, IoD[27] = {0};
    ULONG64 Name_Buf=0, DriverExtension=0, Ext_ClientDriverExtension=0, DeviceObject=0,
        FastIoDispatch=0, IoD_FastIoCheckIfPossible=0;
    ULONG64 DriverEntry=0, DriverUnload=0, DriverStartIo=0;

    FIELD_INFO  DriverFields[] = {
        {"DriverExtension", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA |
            ((Flags & 1) ? DBG_DUMP_FIELD_RECUR_ON_THIS : 0), 0, (PVOID) &DriverExtension},
        {"DriverName", "", 0, DBG_DUMP_FIELD_RECUR_ON_THIS,   0, NULL},
        {"DriverName.MaximumLength", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Name_MaxLen},
        {"DriverName.Length", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Name_Len},
        {"DriverName.Buffer", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Name_Buf},
        {"DriverExtension.ClientDriverExtension", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Ext_ClientDriverExtension},
        {"DeviceObject", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &DeviceObject},
        {"DriverInit", "DriverEntry", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &DriverEntry},
        {"DriverStartIo", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &DriverStartIo},
        {"DriverUnload", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &DriverUnload},
        {"MajorFunction", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &MajorFunction[0]},
        {"FastIoDispatch","", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA |
            DBG_DUMP_FIELD_RECUR_ON_THIS, 0, (PVOID) &FastIoDispatch},
        {"FastIoDispatch.SizeOfFastIoDispatch", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD_SizeOfFastIoDispatch},
        {"FastIoDispatch.FastIoCheckIfPossible", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[0]},
        {"FastIoDispatch.FastIoRead", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[1]},
        {"FastIoDispatch.FastIoWrite", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[2]},
        {"FastIoDispatch.FastIoQueryBasicInfo", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[3]},
        {"FastIoDispatch.FastIoQueryStandardInfo", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[4]},
        {"FastIoDispatch.FastIoLock", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[5]},
        {"FastIoDispatch.FastIoUnlockSingle", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[6]},
        {"FastIoDispatch.FastIoUnlockAll", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[7]},
        {"FastIoDispatch.FastIoUnlockAllByKey", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[8]},
        {"FastIoDispatch.FastIoDeviceControl", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[9]},
        {"FastIoDispatch.AcquireFileForNtCreateSection", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[10]},
        {"FastIoDispatch.ReleaseFileForNtCreateSection", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[11]},
        {"FastIoDispatch.FastIoDetachDevice", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[12]},
        {"FastIoDispatch.FastIoQueryNetworkOpenInfo", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[13]},
        {"FastIoDispatch.AcquireForModWrite", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[14]},
        {"FastIoDispatch.MdlRead", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[15]},
        {"FastIoDispatch.MdlReadComplete", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[16]},
        {"FastIoDispatch.PrepareMdlWrite", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[17]},
        {"FastIoDispatch.MdlWriteComplete", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[18]},
        {"FastIoDispatch.FastIoReadCompressed", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[19]},
        {"FastIoDispatch.FastIoWriteCompressed", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[20]},
        {"FastIoDispatch.MdlReadCompleteCompressed", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[21]},
        {"FastIoDispatch.MdlWriteCompleteCompressed", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[22]},
        {"FastIoDispatch.FastIoQueryOpen", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[23]},
        {"FastIoDispatch.ReleaseForModWrite", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[24]},
        {"FastIoDispatch.AcquireForCcFlush", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[25]},
        {"FastIoDispatch.ReleaseForCcFlush", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &IoD[26]},
    };
    SYM_DUMP_PARAM DriverSym = {
        sizeof (SYM_DUMP_PARAM), "nt!_DRIVER_OBJECT", DBG_DUMP_NO_PRINT, (ULONG64) DriverAddress,
        NULL, NULL, NULL, sizeof (DriverFields) / sizeof(FIELD_INFO), &DriverFields[0]
    };


    if (GetFieldValue(DriverAddress, "nt!_DRIVER_OBJECT",
                      "Type", Type)) {
        dprintf("Cannot read _DRIVER_OBJECT at %p\n", DriverAddress);
        return;
    }

    LongAddr = IsPtr64();

    if (Type != IO_TYPE_DRIVER) {
        dprintf("%08p: is not a driver object\n", DriverAddress);
        return;
    }
    Ioctl(IG_DUMP_SYMBOL_INFO, &DriverSym, DriverSym.size);

    buffer = LocalAlloc(LPTR, Name_MaxLen);
    if (buffer == NULL) {
        dprintf("Could not allocate %d bytes\n",
                Name_MaxLen);
        return;
    }

    //
    // This memory may be paged out.
    //

    unicodeString.Buffer = (PWSTR)buffer;
    unicodeString.Length = (USHORT) Name_Len;
    unicodeString.MaximumLength = (USHORT) Name_MaxLen;
    if (!ReadMemory( Name_Buf,
                     buffer,
                     Name_MaxLen,
                     &result)) {
        dprintf(" Name paged out");
    } else {
        sprintf(component, " %wZ", &unicodeString);
        dprintf("%s", component) ;
        for(i = strlen(component); i<FieldWidth; i++) {
           dprintf(" ") ;
        }
    }
    LocalFree(buffer);

    if (Flags&1) {
        dprintf("\n");

        //
        // Dump the list of client extensions
        //

        if(DriverExtension) {
            ULONG sz = GetTypeSize("nt!_IO_CLIENT_EXTENSION");
            ULONG64 clientExtension = Ext_ClientDriverExtension;

            dprintf("Driver Extension List: (id , addr)\n");

            //
            // Check to see if there are any extensions.
            //

            while(clientExtension != 0) {
                ULONG64 ClientIdentificationAddress=0, NextExtension=0;
                FIELD_INFO IoCltFields[] = {
                    {"ClientIdentificationAddress", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA,
                         0, (PVOID) &ClientIdentificationAddress},
                    {"NextExtension", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA,
                         0, (PVOID) &NextExtension},
                };
                // IO_CLIENT_EXTENSION buffer;

                DriverSym.sName = "_IO_CLIENT_EXTENSION"; DriverSym.addr = clientExtension;
                DriverSym.nFields = 2; DriverSym.Fields = &IoCltFields[0];

                if (!Ioctl(IG_DUMP_SYMBOL_INFO, &DriverSym, DriverSym.size)) {
                   /* ReadMemory((DWORD) clientExtension,
                              &buffer,
                              sizeof(buffer),
                              &result)) {*/

                    dprintf("(%08p %08p)  ",
                            ClientIdentificationAddress,
                            clientExtension + sz);
                    clientExtension = NextExtension;

                } else {

                    dprintf("\nCouldn't read extension at %#08p\n", clientExtension);
                    clientExtension = 0;
                }
            }
            dprintf("\n");
        }

        dprintf("Device Object list:\n");

        deviceAddress = DeviceObject;

        for (i= 0; deviceAddress != 0; i++) {
            ULONG64 NextDevice=0;
            FIELD_INFO DevFields = {"NextDevice", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &NextDevice};

            DriverSym.sName = "_DEVICE_OBJECT"; DriverSym.addr = deviceAddress;
            DriverSym.nFields = 1; DriverSym.Fields = &DevFields;

            if (Ioctl(IG_DUMP_SYMBOL_INFO, &DriverSym, DriverSym.size)) {
                dprintf("%08p: Could not read device object\n", deviceAddress);
                break;
            }

            dprintf("%08p%s", deviceAddress, ((i & 0x03) == 0x03) ? "\n" : "  ");
            deviceAddress = NextDevice;
        }
        dprintf("\n");
    }

    if (Flags&0x2) {

        GetSymbol(DriverEntry, component, &displacement);
        dprintf("\nDriverEntry:   %8.8p\t%s\n", DriverEntry, component);

        GetSymbol(DriverStartIo, component, &displacement);
        dprintf("DriverStartIo: %8.8p\t%s\n", DriverStartIo, component);

        GetSymbol(DriverUnload, component, &displacement);
        dprintf("DriverUnload:  %8.8p\t%s\n", DriverUnload, component);

        dprintf ("\nDispatch routines:\n");
        dispatchTableText = DispatchRoutineTable ;
        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION_HANDLED; i++) {
            //
            // Get the read pointer values depending on 32 or 64 bit addresses
            //
            if (LongAddr) {
                GetSymbol(MajorFunction[i], component, &displacement);
            } else {
                GetSymbol((ULONG64) (LONG64) (LONG) (((PULONG) &MajorFunction[0])[i]), component, &displacement);
            }

            //
            // Forms are:
            // [1b] IRP_MJ_PNP            C0000000  DispatchHandler+30
            // [1b] IRP_MJ_PNP            C0000000  DispatchHandler
            // [1b] ???                   C0000000  <either of above>
            //
            if (*dispatchTableText) {
               dprintf("[%02x] %s", i, *dispatchTableText) ;
               j=strlen(*dispatchTableText) ;
            } else {
               dprintf("[%02x] ???") ;
               j=3 ;
            }

            while(j++<35) dprintf(" ") ;
            if (LongAddr) {
                dprintf("%8.8p\t%s", MajorFunction[i], component);
            } else {
                dprintf("%8.8x\t%s", (((PULONG) &MajorFunction[0])[i]), component);
            }
            // dprintf("%8.8x\t%s", driverObject.MajorFunction[i], component) ;

            if (displacement) {

                dprintf("+0x%1p\n", displacement) ;
            } else {

                dprintf("\n") ;
            }

            if (*dispatchTableText) {

                dispatchTableText++ ;
            }
        }

        if (FastIoDispatch) {

            dprintf("\nFast I/O routines:\n");
            dispatchTableText = FastIoDispatchTable ;

            for (i=0;i < ((IoD_SizeOfFastIoDispatch - 4)/ (LongAddr ? 8 : 4)); i++) {
               if (IoD[i]) {

                   GetSymbol(IoD[i], component, &displacement);

                   if (*dispatchTableText) {
                       dprintf("%s", *dispatchTableText) ;
                       j=strlen(*dispatchTableText) ;
                   } else {
                       dprintf("???") ;
                       j=3 ;
                   }

                   while(j++<40) dprintf(" ") ;
                   dprintf("%8.8p\t%s", IoD[i], component) ;

                   if (displacement) {

                       dprintf("+0x%1p", displacement) ;
                   }

                   dprintf("\n") ;
               }

               if (*dispatchTableText) {

                   dispatchTableText++ ;
               }
            }
        }
        dprintf("\n");
    }
}



UCHAR *PagedOut = {"Header Paged Out"};

DECLARE_API( drivers )

/*++

Routine Description:

    Displays physical memory usage by driver.

Arguments:

    None.

Return Value:

    None.

--*/

{
    return ExecuteCommand(Client, ".reload -l");

#if 0
    LIST_ENTRY64 List;
    ULONG64 Next;
    ULONG64 ListHead;
    NTSTATUS Status = 0;
    ULONG Result;
    ULONG64 DataTable;
    LDR_DATA_TABLE_ENTRY DataTableBuffer;
    WCHAR UnicodeBuffer[128];
    UNICODE_STRING BaseName;
    ULONG64 NtHeader;
    ULONG64 DosHeader;
    ULONG SizeOfData;
    ULONG SizeOfCode;
    ULONG SizeOfLocked;
    ULONG TotalCode = 0;
    ULONG TotalData = 0;
    ULONG TotalValid = 0;
    ULONG TotalTransition = 0;
    ULONG DosHeaderSize;
    ULONG TimeDateStamp;
    LONG_PTR TDStamp;
    ULONG InLoadOrderLinksOff;
    PUCHAR time;
    ULONG64 Flags;
    UCHAR LdrName[] = "_LDR_DATA_TABLE_ENTRY";

    Flags = GetExpression(args);

    ListHead = GetNtDebuggerData( PsLoadedModuleList );

    if (!ListHead) {
        dprintf("Unable to get value of PsLoadedModuleListHead\n");
        return E_INVALIDARG;
    }

    if (GetFieldValue(ListHead, "_LIST_ENTRY", "Flink", List.Flink)) {
        dprintf("Couldn't read _LIST_ENTRY @ %p\n", ListHead);
        return E_INVALIDARG;
    }

    Next = List.Flink;
    if (Next == 0) {
        dprintf("PsLoadedModuleList is NULL, trying loader block instead\n");

        ListHead = GetUlongValue ("KeLoaderBlock");

        if (ListHead == 0) {
            dprintf ("KeLoaderBlock is NULL\n");
            return E_INVALIDARG;
        }

        if (GetFieldValue(ListHead, "_LIST_ENTRY", "Flink", List.Flink)) {
            dprintf("Couldn't read _LIST_ENTRY1 @ %p\n", ListHead);
            return E_INVALIDARG;
        }

        if (GetFieldValue(List.Flink, "_LIST_ENTRY", "Flink", List.Flink)) {
            dprintf("Couldn't read _LIST_ENTRY2 @ %p\n", ListHead);
            return E_INVALIDARG;
        }

        if (!IsPtr64()) {
            ListHead = (ULONG64)(LONG64)(LONG)ListHead;
        }

        Next = List.Flink;
    }

    dprintf("Loaded System Driver Summary\n\n");
    if (Flags & 1) {
        dprintf("Base       Code Size       Data Size       Resident  Standby   Driver Name\n");
    } else if (Flags & 2) {
        dprintf("Base       Code  Data  Locked  Resident  Standby  Loader Entry  Driver Name\n");
    } else {
        dprintf("Base       Code Size       Data Size       Driver Name       Creation Time\n");
    }

    // Get The offset of InLoadOrderLinks
    if (GetFieldOffset("_LDR_DATA_TABLE_ENTRY", "InLoadOrderLinks", &InLoadOrderLinksOff)){
        dprintf("Cannot find _LDR_DATA_TABLE_ENTRY type\n");
        return E_INVALIDARG;
    }


    while (Next != ListHead) {
        ULONG64 BaseDllBuffer=0, DllBase=0;
        ULONG  BaseDllNameLen=0, SizeOfImage=0;

        if (CheckControlC()) {
            return E_INVALIDARG;
        }
        DataTable = Next - InLoadOrderLinksOff;

        if (GetFieldValue(DataTable, LdrName, "BaseDllName.Buffer", BaseDllBuffer)) {
            dprintf("Unable to read LDR_DATA_TABLE_ENTRY at %08lx - status %08p\n",
                    DataTable,
                    Status);
            return E_INVALIDARG;
        }

        GetFieldValue(DataTable, LdrName, "BaseDllName.Length", BaseDllNameLen);

        if (BaseDllNameLen > sizeof(UnicodeBuffer)) {
            BaseDllNameLen = sizeof(UnicodeBuffer);
        }
        //
        // Get the base DLL name.
        //
        if ((!ReadMemory(BaseDllBuffer,
                         UnicodeBuffer,
                         BaseDllNameLen,
                         &Result)) || (Result < BaseDllNameLen)) {
            dprintf("Unable to read name string at %08p - status %08lx\n",
                    DataTable,
                    Status);
            return E_INVALIDARG;
        }

        BaseName.Buffer = UnicodeBuffer;
        BaseName.Length = BaseName.MaximumLength = (USHORT)Result;

        GetFieldValue(DataTable, LdrName, "DllBase", DllBase);
        DosHeader = DllBase;

        DosHeaderSize=0;
        if (GetFieldValue(DosHeader, "_IMAGE_DOS_HEADER", "e_lfanew", DosHeaderSize)) {
            //dprintf("Unable to read DosHeader at %08lx - status %08lx\n",
            //        &DosHeader->e_lfanew,
            //        Status);

            SizeOfCode = 0;
            SizeOfData = 0;
            SizeOfLocked = -1;
            time = PagedOut;
        } else {

            NtHeader = DosHeader + DosHeaderSize;

            if (GetFieldValue(NtHeader, "_IMAGE_NT_HEADERS", "OptionalHeader.SizeOfCode", SizeOfCode)) {
                dprintf("Unable to read DosHeader at %08p - status %08lx\n",
                        NtHeader,
                        Status);
                goto getnext;
            }

            GetFieldValue(NtHeader, "_IMAGE_NT_HEADERS", "OptionalHeader.SizeOfInitializedData", SizeOfData);
            GetFieldValue(NtHeader, "_IMAGE_NT_HEADERS", "FileHeader.TimeDateStamp", TimeDateStamp);

            // TimeDateStamp is always a 32 bit quantity on the target, and we
            // need to sign extend for 64 bit host
            TDStamp = (LONG_PTR)(LONG)TimeDateStamp;
            time = ctime((time_t *)&TDStamp);
            if (time) {
                time[strlen(time)-1] = 0; // ctime always returns 26 char ending win \n\0
            }
        }

        GetFieldValue(DataTable, LdrName, "SizeOfImage", SizeOfImage);
        if (Flags & 1) {
            ULONG64 Va;
            ULONG64 EndVa;
            ULONG States[3] = {0,0,0};

            Va = DllBase;
            EndVa = Va + SizeOfImage;

            // PLATFORM SPECIFIC
            while (Va < EndVa) {
                States[GetAddressState(Va)] += _KB;
                Va += PageSize;
            }
            dprintf("%08p %6lx (%4ld kb) %6lx (%4ld kb) (%5ld kb %5ld kb) %12wZ\n",
                     DllBase,
                     SizeOfCode,
                     SizeOfCode / 1024,
                     SizeOfData,
                     SizeOfData / 1024,
                     States[ADDRESS_VALID],
                     States[ADDRESS_TRANSITION],
                     &BaseName);
            TotalValid += States[ADDRESS_VALID];
            TotalTransition += States[ADDRESS_TRANSITION];
        } else if (Flags & 2) {
            ULONG i;
            ULONG SizeToLock;
            ULONG64 PointerPte;
            ULONG64 LastPte;
            ULONG64 BaseAddress;
            ULONG64 Va;
            ULONG64 EndVa;
            ULONG States[3] = {0,0,0};
            ULONG64 NtSection;
            ULONG SizeOfOptionalHeader=0, NumberOfSections=0;

            Va = DllBase;
            EndVa = Va + SizeOfImage;

            while (Va < EndVa) {
                States[GetAddressState(Va)] += _KB;
                Va += PageSize;
            }

            SizeOfLocked = 0;

            //
            // Read the sections in the executable header to see which are
            // locked.  Don't bother looking for refcounted PFNs.
            //

            NtHeader = DosHeader + DosHeaderSize;

            if (GetFieldValue(NtHeader, "_IMAGE_NT_HEADERS", "FileHeader.SizeOfOptionalHeader", SizeOfOptionalHeader)) {
                dprintf("Unable to read FileHeader at %08lx - status %08lx\n",
                        NtHeader,
                        Status);
                goto getnext;
            }
            GetFieldValue(NtHeader, "_IMAGE_NT_HEADERS", "FileHeader.NumberOfSections", NumberOfSections);

            NtSection = NtHeader +
                GetTypeSize("ULONG") +
                GetTypeSize("_IMAGE_FILE_HEADER") +
                SizeOfOptionalHeader;

            for (i = 0; i < NumberOfSections; i += 1) {
                ULONG NumberOfLinenumbers=0, PointerToRelocations=0, SizeOfRawData=0;

                if (GetFieldValue(NtSection, "_IMAGE_SECTION_HEADER", "NumberOfLinenumbers", NumberOfLinenumbers)) {
                    dprintf("Unable to read NtSectionData at %08lx - status %08p\n",
                            NtSection,
                            Status);
                    goto getnext;
                }

                GetFieldValue(NtSection, "_IMAGE_SECTION_HEADER", "SizeOfRawData", SizeOfRawData);
                GetFieldValue(NtSection, "_IMAGE_SECTION_HEADER", "PointerToRelocations", PointerToRelocations);

                if ((NumberOfLinenumbers == 1) ||
                    (NumberOfLinenumbers == 2)) {

                    BaseAddress = PointerToRelocations;
                    SizeToLock  = SizeOfRawData;
                    PointerPte = DbgGetPteAddress( BaseAddress);
                    LastPte = DbgGetPteAddress(BaseAddress + SizeToLock - 1);
                    SizeOfLocked += (ULONG) (LastPte - PointerPte + 1);
                }

                NtSection += 1;
            }

#if 0
        dprintf("Base       Code  Data  Locked  Resident  Standby  Loader Entry  Driver Name\n");
#endif

            dprintf("%08p %6lx %6lx %6lx  %6lx   %6lx    %8lp      %12wZ\n",
                     DllBase,
                     SizeOfCode,
                     SizeOfData,
                     SizeOfLocked,
                     States[ADDRESS_VALID],
                     States[ADDRESS_TRANSITION],
                     DataTable,
                     &BaseName);
            TotalValid += States[ADDRESS_VALID];
            TotalTransition += States[ADDRESS_TRANSITION];
        } else {
             dprintf("%08p %6lx (%4ld kb) %5lx (%3ld kb) %12wZ  %s\n",
                      DllBase,
                      SizeOfCode,
                      SizeOfCode / 1024,
                      SizeOfData,
                      SizeOfData / 1024,
                      &BaseName,
                      time);
        }

        if (Flags & 4) {
            dprintf("Cannot dump Image.\n");
            /*DumpImage(DllBase,
                     (Flags & 2) == 2,
                     (Flags & 4) == 4
                     );*/
        }

        TotalCode += SizeOfCode;
        TotalData += SizeOfData;

getnext:

        GetFieldValue(DataTable, LdrName, "InLoadOrderLinks.Flink", Next);
    }

    dprintf("TOTAL:   %6lx (%4ld kb) %6lx (%4ld kb) (%5ld kb %5ld kb)\n",
            TotalCode,
            TotalCode / 1024,
            TotalData,
            TotalData / 1024,
            TotalValid,
            TotalTransition);


    return S_OK;
#endif

}


HRESULT
GetDrvObjInfo(
    IN ULONG64 DriverObject,
    OUT PDEBUG_DRIVER_OBJECT_INFO pDrvObjInfo)
{
    ZeroMemory(pDrvObjInfo, sizeof(DEBUG_DRIVER_OBJECT_INFO));
    pDrvObjInfo->SizeOfStruct = sizeof(DEBUG_DRIVER_OBJECT_INFO);
    pDrvObjInfo->DriverObjAddress = DriverObject;
    if (InitTypeRead(DriverObject, nt!_DRIVER_OBJECT)) {
        return E_INVALIDARG;
    }
    pDrvObjInfo->DeviceObject       = ReadField(DeviceObject);
    pDrvObjInfo->DriverExtension    = ReadField(DriverExtension);
    pDrvObjInfo->DriverSize         = (ULONG) ReadField(DriverSize);
    pDrvObjInfo->DriverStart        = ReadField(DriverStart);
    pDrvObjInfo->DriverName.MaximumLength = (USHORT) ReadField(DriverName.MaximumLength);
    pDrvObjInfo->DriverName.Length  = (USHORT) ReadField(DriverName.Length);
    pDrvObjInfo->DriverName.Buffer  = ReadField(DriverName.Buffer);
    return S_OK;
}

EXTENSION_API( GetDrvObjInfo )(
    IN PDEBUG_CLIENT Client,
    IN ULONG64 DriverObject,
    OUT PDEBUG_DRIVER_OBJECT_INFO pDrvObjInfo)
{
    HRESULT Hr = E_FAIL;

    INIT_API();

    if (pDrvObjInfo && (pDrvObjInfo->SizeOfStruct == sizeof(DEBUG_DRIVER_OBJECT_INFO))) {
        Hr = GetDrvObjInfo(DriverObject, pDrvObjInfo);
    }
    EXIT_API();
    return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\dma.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dma.c

Abstract:

    WinDbg Extension Api

Author:

    Eric Nelson (enelson) 05-April-2000

Environment:

    User Mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

typedef struct _DBG_LIST_ENTRY {
    ULONG64 Flink;
    ULONG64 Blink;
} DBG_LIST_ENTRY, *PDBG_LIST_ENTRY;

#define GetDbgListEntry(Address, DbgListEntry) \
    (GetFieldValue((Address), "LIST_ENTRY", "Blink", ((PDBG_LIST_ENTRY)(DbgListEntry))->Blink) || GetFieldValue((Address), "LIST_ENTRY", "Flink", ((PDBG_LIST_ENTRY)(DbgListEntry))->Flink))

#define RECUR DBG_DUMP_FIELD_RECUR_ON_THIS
#define COPY  DBG_DUMP_FIELD_COPY_FIELD_DATA
#define NOFF  DBG_DUMP_NO_OFFSET
#define NOIN  DBG_DUMP_NO_INDENT

#define MAP_REGISTER_FILE_SIGNATURE 0xACEFD00D

//
// Flags for specifying dump levels
//
#define DMA_DUMP_BASIC                  0x0
#define DMA_DUMP_ADAPTER_INFORMATION    0x1
#define DMA_DUMP_MAP_REGISTER           0x2
#define DMA_DUMP_COMMON_BUFFER          0x4
#define DMA_DUMP_TRANSFER_INFORMATION   0x8
#define DMA_DUMP_DEVICE_DESCRIPTION     0x10
#define DMA_DUMP_WCB                    0x20
#define DMA_DUMP_MAX 0x100


PUCHAR DbgInterfaceTypes[] = 
{
    "Internal",
    "Isa",
    "Eisa",
    "MicroChannel",
    "TurboChannel",
    "PCIBus",
    "VMEBus",
    "NuBus",
    "PCMCIABus",
    "CBus",
    "MPIBus",
    "MPSABus",
    "ProcessorInternal",
    "InternalPowerBus",
    "PNPISABus",
    "PNPBus"
};
#define MAX_INTERFACE 15

ULONG
DumpDmaAdapter(
    IN ULONG64 Adapter,
    IN ULONG   Flags
    );

ULONG
ValidateAdapter(    
    IN ULONG64 Address
    );

ULONG
DumpMasterAdapter(
    ULONG64 MasterAdapter
    );

ULONG
DumpWcb(
    IN ULONG64 CurrentWcb
    );

VOID DmaUsage(
    VOID
    );

ULONG64
GetVerifierAdapterInformation(
    ULONG64 Address
    );


VOID
DumpVerifiedMapRegisterFiles(
    IN ULONG64 MapRegisterFileListHead
    );

VOID
DumpVerifiedCommonBuffers(
    IN ULONG64 CommonBufferListHead
    );

VOID
DumpVerifiedScatterGatherLists(
    IN ULONG64 ScatterGatherListHead
    );

VOID 
DumpDeviceDescription(
    IN ULONG64 DeviceDescription
    );

VOID
DumpSymbolicAddress(
    ULONG64 Address,
    PUCHAR  Buffer,
    BOOL    AlwaysShowHex
    )
{
    ULONG64 displacement;
    PCHAR s;

    Buffer[0] = '!';
    GetSymbol((ULONG64)Address, Buffer, &displacement);
    s = (PCHAR) Buffer + strlen( (PCHAR) Buffer );
    if (s == (PCHAR) Buffer) {
        sprintf( s, "0x%08x", Address );
        }
    else {
        if (displacement != 0) {
            sprintf( s, "+0x%I64x", displacement );
            }
        if (AlwaysShowHex) {
            sprintf( s, " (0x%08x)", Address );
            }
        }

    return;
}


DECLARE_API( dma )
/*++

Routine Description:

    Dumps out 32-bit dma adapters

Arguments:

    address

Return Value:

    None

--*/
{    
    ULONG Offset;
    ULONG Flags = 0;
    
    ULONG64 Address = 0;
    ULONG64 StartAddress = 0;
    ULONG64 MasterAdapter = 0;

    ULONG64 CallersAddress = 0;
    ULONG64 AdapterInformation = 0;

    DBG_LIST_ENTRY AdapterList = {0,0};

    if (sscanf(args, "%lx %x", &Address, &Flags)) {
        Address = GetExpression(args);
    }

    if (Flags > DMA_DUMP_MAX)
    {
        DmaUsage();
        return  E_INVALIDARG;
    }

 
    //
    // Aha! Must not forget that we are in wierdo land and all 32 bit addresses
    // must be sign extended to 64 bits. By order of the emperor.
    //
    if (!IsPtr64()) {
        Address = (ULONG64)(LONG64)(LONG)Address;        
    }    
    
        
    if (Address)
    //
    // If we've been passed an adapter address, we are just printing out
    // the single adapter
    //
    {
        if (! ValidateAdapter(Address))
        {
            dprintf("\n%08p is not a valid adapter object\n",Address);
            DmaUsage();
                return E_INVALIDARG;
        }

        //
        // Dump out info about the adapter
        //
        if (! DumpDmaAdapter(Address, Flags | DMA_DUMP_ADAPTER_INFORMATION))
        {
            return S_FALSE;
        }

        return S_OK;
    }

    //
    // A specific adapter address wasn't passed in so we are going to print out
    // all adapters
    //

    //
    // Find the address of the dma adapter list head
    // This will also make sure that we are using the right 
    // version.
    //
    StartAddress = GetExpression("hal!HalpDmaAdapterList");
    
    if (StartAddress == 0) {
        dprintf("\nCould not find symbol hal!HalpDmaAdapterList.\n\n");
        return S_OK;
    }
 
    //
    // Determine the list entry offset we will use to calculate
    // adapter addresses
    //
    if (GetFieldOffset("hal!_ADAPTER_OBJECT", "AdapterList", &Offset)) {
        dprintf("\nError retrieving adapter list offset.\n\n");
        return S_FALSE;
    }

    //
    // Read the dma adapter list head
    //
    if (GetDbgListEntry(StartAddress, &AdapterList)) {
        dprintf("\nError reading dma adapter list head: 0x%08p\n\n",
                StartAddress);
        return S_FALSE;
    }
    
    //
    // Report the empty list case
    //
    if (AdapterList.Flink == StartAddress) {
        dprintf("\nThe dma adapter list is empty.\n\n");
        return S_OK;
    }
    

    //
    // Enumerate and dump all dma adapters that do not use channels
    //
    MasterAdapter = 0;
    
    
    dprintf("\nDumping all DMA adapters...\n\n");

    while (AdapterList.Flink != StartAddress) {
        
        Address = AdapterList.Flink - Offset;
               
        DumpDmaAdapter(Address, Flags);
        
        //
        // Read the next adapter list entry
        //
        Address = AdapterList.Flink;
        if (GetDbgListEntry(Address, &AdapterList)) {
            dprintf("\nError reading adapter list entry: 0x%08p\n", Address);
            break;
        }
        
        if (CheckControlC())        
            return S_OK;
    }


    //
    // Dump the master adapter
    //
    Address = GetExpression("hal!MasterAdapter32");
   
    if (Address) {

        if (Flags & DMA_DUMP_ADAPTER_INFORMATION) {

            DumpMasterAdapter(Address);

        } else {

            dprintf("Master adapter: %08p\n", Address);    
        }

    } else {

        dprintf("\nCould not find symbol hal!MasterAdapter32.\n");
    }


    dprintf("\n");

    return S_OK;
} // ! dma //

ULONG
DumpDmaAdapter(
    IN ULONG64 Adapter,
    IN ULONG Flags
    )
/*++

Routine Description:

    Given the address of a hal!_ADAPTER_OBJECT, this routine dumps
    out all the useful information to the debugger

Arguments:

    Adapter - Physical address of a hal!_ADAPTER_OBJECT in debuggee
    Flags   - What kind of information we want to print

Return Value:

    Returns 0 on SUCCESS

--*/
{    

    ULONG64 AdapterInformation = 0;

    ULONG64 AllocatedAdapterChannels = 0, FreedAdapterChannels = 0;
        
    AdapterInformation = GetVerifierAdapterInformation(Adapter);

    //
    // Print out: Adapter: <adapter>    [<module allocating adapter>!CallingFunction+0x<offset>]
    // (the part in brackets only shows up when we have dma verifier enabled for this adapter)
    //
    dprintf("Adapter: %08p ", Adapter);


    if (AdapterInformation)
    {
        ULONG64 CallingAddress = 0;
        CHAR CallerName[256];

        GetFieldValue(AdapterInformation, "nt!_ADAPTER_INFORMATION","CallingAddress", CallingAddress);

        if(CallingAddress)
        {            
            
            DumpSymbolicAddress(CallingAddress, CallerName, TRUE);
            dprintf("    Owner: %s",CallerName);
        }        

    }
    dprintf("\n");
       
         
    if (Flags & DMA_DUMP_ADAPTER_INFORMATION)
    {
        ULONG64 MasterAdapter = 0;
        ULONG64 MapRegistersPerChannel = 0;
        ULONG64 AdapterBaseVa = 0;
        ULONG64 MapRegisterBase = 0;
        ULONG64 CommittedMapRegisters = 0;
        ULONG64 NumberOfMapRegisters = 0;
        ULONG64 CurrentWcb = 0;        

        GetFieldValue(Adapter, "hal!_ADAPTER_OBJECT","MasterAdapter", MasterAdapter);        
        GetFieldValue(Adapter, "hal!_ADAPTER_OBJECT","MapRegistersPerChannel", MapRegistersPerChannel);
        GetFieldValue(Adapter, "hal!_ADAPTER_OBJECT","AdapterBaseVa", AdapterBaseVa);
        GetFieldValue(Adapter, "hal!_ADAPTER_OBJECT","MapRegisterBase", MapRegisterBase);
        GetFieldValue(Adapter, "hal!_ADAPTER_OBJECT","CommittedMapRegisters", CommittedMapRegisters);
        GetFieldValue(Adapter, "hal!_ADAPTER_OBJECT","NumberOfMapRegisters", NumberOfMapRegisters);
        GetFieldValue(Adapter, "hal!_ADAPTER_OBJECT","CurrentWcb", CurrentWcb);
        
                  
 
        dprintf("   MasterAdapter:       %08p\n", MasterAdapter);
        dprintf("   Adapter base Va      %08p\n", AdapterBaseVa);
        dprintf("   Map register base:   %08p\n", MapRegisterBase);
        dprintf("   WCB:                 %08p\n", CurrentWcb);
        dprintf("   Map registers: %08p mapped, %08p allocated, %08p max\n", 
            CommittedMapRegisters, NumberOfMapRegisters,  MapRegistersPerChannel);
    
  

        if (AdapterInformation) {
            //
            // Adapter is being verified
            //

            ULONG64 DeviceObject = 0;
            ULONG64 AllocatedMapRegisters = 0, ActiveMapRegisters = 0;
            ULONG64 AllocatedScatterGatherLists = 0, ActiveScatterGatherLists = 0;
            ULONG64 AllocatedCommonBuffers = 0, FreedCommonBuffers = 0;
            
            ULONG64 MappedTransferWithoutFlushing = 0;            
            BOOLEAN Inactive = 0;
            
            
            
            
            //
            // If this adapter is being verified, get the dma verifier info we need
            //    
            GetFieldValue(AdapterInformation, "nt!_ADAPTER_INFORMATION","DeviceObject", DeviceObject);        
            GetFieldValue(AdapterInformation, "nt!_ADAPTER_INFORMATION","AllocatedMapRegisters", AllocatedMapRegisters);
            GetFieldValue(AdapterInformation, "nt!_ADAPTER_INFORMATION","ActiveMapRegisters", ActiveMapRegisters);
            GetFieldValue(AdapterInformation, "nt!_ADAPTER_INFORMATION","AllocatedScatterGatherLists", AllocatedScatterGatherLists);
            GetFieldValue(AdapterInformation, "nt!_ADAPTER_INFORMATION","ActiveScatterGatherLists", ActiveScatterGatherLists);
            GetFieldValue(AdapterInformation, "nt!_ADAPTER_INFORMATION","AllocatedCommonBuffers", AllocatedCommonBuffers);
            GetFieldValue(AdapterInformation, "nt!_ADAPTER_INFORMATION","FreedCommonBuffers", FreedCommonBuffers);
            GetFieldValue(AdapterInformation, "nt!_ADAPTER_INFORMATION","AllocatedAdapterChannels", AllocatedAdapterChannels);
            GetFieldValue(AdapterInformation, "nt!_ADAPTER_INFORMATION","FreedAdapterChannels", FreedAdapterChannels);
            GetFieldValue(AdapterInformation, "nt!_ADAPTER_INFORMATION","MappedTransferWithoutFlushing", MappedTransferWithoutFlushing);
            GetFieldValue(AdapterInformation, "nt!_ADAPTER_INFORMATION","Inactive", Inactive);

            
            
            dprintf("\n   Dma verifier additional information:\n");
            
            if (Inactive)
                dprintf("\n   This adapter has been freed!\n\n");

            dprintf("   DeviceObject: %08p\n", DeviceObject);
            dprintf("   Map registers:        %08p allocated, %08p freed\n", AllocatedMapRegisters, 
                    AllocatedMapRegisters - ActiveMapRegisters);
            
            dprintf("   Scatter-gather lists: %08p allocated, %08p freed\n", AllocatedScatterGatherLists, 
                    AllocatedScatterGatherLists - ActiveScatterGatherLists);
            dprintf("   Common buffers:       %08p allocated, %08p freed\n", AllocatedCommonBuffers, FreedCommonBuffers);
            dprintf("   Adapter channels:     %08p allocated, %08p freed\n", AllocatedAdapterChannels, FreedAdapterChannels);
            dprintf("   Bytes mapped since last flush: %08p\n", MappedTransferWithoutFlushing);

            dprintf("\n");
            
        } // Dma verifier enabled for adapter //
        
    } // Flags & DMA_DUMP_ADAPTER_INFORMATION //

    
        
    if (CheckControlC())
        return TRUE;
    
    if (Flags & DMA_DUMP_MAP_REGISTER && AdapterInformation) {
        ULONG64 MapRegisterFileListHead = 0;        
        ULONG Offset;

        
        if ( ! GetFieldOffset("nt!_ADAPTER_INFORMATION",
            "MapRegisterFiles.ListEntry", 
            &Offset
            )) {
            
            
            MapRegisterFileListHead = AdapterInformation + Offset;
            
            DumpVerifiedMapRegisterFiles(MapRegisterFileListHead);
        }
    }
    
    if (CheckControlC())
        return TRUE;
    
    if (Flags & DMA_DUMP_COMMON_BUFFER && AdapterInformation) {
        ULONG64 CommonBufferListHead = 0;
        ULONG Offset;

        if ( ! GetFieldOffset("nt!_ADAPTER_INFORMATION",
            "CommonBuffers.ListEntry",
            &Offset
            )) {

            CommonBufferListHead = AdapterInformation + Offset;
        
            DumpVerifiedCommonBuffers(CommonBufferListHead);

        }
    }
    
    if (CheckControlC())
        return TRUE;

#if 0
    if (Flags & DMA_DUMP_SCATTER_GATHER && AdapterInformation) {
        ULONG64 ScatterGatherListHead = 0;
        ULONG Offset;

        if ( ! GetFieldOffset("nt!_ADAPTER_INFORMATION",
            "ScatterGatherLists.ListEntry",
            &Offset
            )) {

            ScatterGatherListHead = AdapterInformation + Offset;
        
            DumpVerifiedScatterGatherLists(ScatterGatherListHead);
        }
    }
#endif
    if (CheckControlC())
        return TRUE;


    if (Flags & DMA_DUMP_DEVICE_DESCRIPTION && AdapterInformation)
    {
        ULONG64 DeviceDescription;
        ULONG Offset;

        if ( ! GetFieldOffset("nt!_ADAPTER_INFORMATION",
            "DeviceDescription",
            &Offset
            )) {

            DeviceDescription = AdapterInformation + Offset;
            
            DumpDeviceDescription(DeviceDescription);
        }

    }
        

    if (CheckControlC())
        return TRUE;

 
    if (Flags & DMA_DUMP_WCB ) {

        if (! AdapterInformation) {
            ULONG64 CurrentWcb = 0;
            
            GetFieldValue(Adapter, "hal!_ADAPTER_OBJECT","CurrentWcb", CurrentWcb);
            
            if (CurrentWcb)
                DumpWcb(CurrentWcb);
        }
        else  if (AllocatedAdapterChannels > FreedAdapterChannels && Flags & DMA_DUMP_WCB )
        {
            
            //DumpVerifiedWcb(Wcb)
        }
    }

    return 0;
}

ULONG
DumpMasterAdapter(
    ULONG64 MasterAdapter
    )
/*++

Routine Description:

    Given the address of a hal!_MASTER_ADAPTER_OBJECT, this routine dumps
    out all the useful information to the debugger

Arguments:

    MasterAdapter - Physical address of a hal!_MASTER_ADAPTER_OBJECT
                    in debuggee

Return Value:

    Returns 0 on SUCCESS

--*/
{
    FIELD_INFO MasterAdapterFields[] = {
         { "AdapterObject",                     NULL, 0,     0, 0, 0 },
         { "MaxBufferPages",                    NULL, 0,     0, 0, 0 },
         { "MapBufferSize",                     NULL, 0,     0, 0, 0 },
         { "MapBufferPhysicalAddress",          NULL, RECUR, 0, 0, 0 },
         { "MapBufferPhysicalAddress.HighPart", NULL, 0,     0, 0, 0 },
         { "MapBufferPhysicalAddress.LowPart",  NULL, 0,     0, 0, 0 }
    };

    SYM_DUMP_PARAM MasterAdapterDumpParams = {
        sizeof(SYM_DUMP_PARAM), "hal!_MASTER_ADAPTER_OBJECT", NOFF,
        MasterAdapter, NULL, NULL, NULL,
        sizeof(MasterAdapterFields) / sizeof(FIELD_INFO),
        &MasterAdapterFields[0]
    };

    //
    // This is so gnarly, dump all the cool stuff for me!
    //
    dprintf("\nMaster DMA adapter: 0x%08p\n", MasterAdapter);
    if ((Ioctl(IG_DUMP_SYMBOL_INFO,
               &MasterAdapterDumpParams,
               MasterAdapterDumpParams.size))) {
        dprintf("\nError reading master adapter: 0x%08p\n", MasterAdapter);
        return 1;
    }
    
    return 0;
}

ULONG
DumpWcb(
    IN ULONG64 Wcb
    )
/*++

Routine Description:

    Given the address of a hal!_WAIT_CONTEXT_BLOCK, this routine dumps
    out all the useful information to the debugger

Arguments:

    Wcb - Physical address of a hal!_WAIT_CONTEXT_BLOCK in debuggee

Return Value:

    Returns 0 on SUCCESS

--*/
{
    FIELD_INFO WcbFields[] = {
         { "DeviceRoutine",        NULL, 0, 0, 0, 0 },
         { "NumberOfMapRegisters", NULL, 0, 0, 0, 0 }
    };

    SYM_DUMP_PARAM WcbDumpParams = {
       sizeof(SYM_DUMP_PARAM), "hal!_WAIT_CONTEXT_BLOCK", NOFF, Wcb, NULL,
       NULL, NULL, sizeof(WcbFields) / sizeof(FIELD_INFO), &WcbFields[0]
    };

    //
    // This is so gnarly, dump all the cool stuff for me!
    //
    dprintf("   Wait context block: 0x%08p (may be free)\n", Wcb);
    if ((Ioctl(IG_DUMP_SYMBOL_INFO,
               &WcbDumpParams,
               WcbDumpParams.size))) {
        dprintf("\nError reading wait context block: 0x%08p\n", Wcb);
        return 1;
    }
    
    return 0;
}



ULONG
ValidateAdapter(    
    IN ULONG64 Address
    )
/*++

Routine Description:
    
      Figures out whether this is a valid adapter.

Arguments:

    Address -- Address of what we think may be an adapter object.

Return Value:

    TRUE   -- Valid adapter.
    FALSE  -- Not a valid adapter.

--*/
{
    DBG_LIST_ENTRY AdapterList = {0,0};
    ULONG64 StartAddress   = 0;
    ULONG64 CurrentAddress = 0;
    
    ULONG Offset;

    if (! Address ) 
        return FALSE;
    
    
    //
    // Find the address of the dma adapter list head
    // This will also make sure that we are using the right 
    // version.
    //
    StartAddress = GetExpression("hal!HalpDmaAdapterList");
    
    if (StartAddress == 0) {
        dprintf("\nCould not find symbol hal!HalpDmaAdapterList.\n\n");
        return FALSE;
    }
    
    //
    // Determine the list entry offset we will use to calculate
    // adapter addresses
    //
    if (GetFieldOffset("hal!_ADAPTER_OBJECT", "AdapterList", &Offset)) {
        dprintf("\nError retrieving adapter list offset.\n\n");
        return FALSE;
    }

    
    //
    // Read the dma adapter list head
    //
    if (GetDbgListEntry(StartAddress, &AdapterList)) {
        dprintf("\nError reading dma adapter list head: 0x%08p\n\n",
            StartAddress);
        return FALSE;
    }        
    
    while (AdapterList.Flink != StartAddress) {
        
        
        CurrentAddress = AdapterList.Flink - Offset;
        
        if (Address == CurrentAddress) {        
            return TRUE;
        }
        
        
        //
        // Read the next adapter list entry
        //        
        CurrentAddress = AdapterList.Flink;
        if (GetDbgListEntry(CurrentAddress, &AdapterList)) {
            dprintf("\nError reading adapter list entry: 0x%08p\n", AdapterList);
            break;
        }
        

        if (CheckControlC())        
            break;
    }


    //
    // Check to see if we have the master adapter
    //
    CurrentAddress = GetExpression("hal!MasterAdapter32");
    if(CurrentAddress == Address)
        return TRUE;


    //
    // Check to see if it is on the verifier adapter list ...
    // we leave adapters that have been 'put' there so that
    // we can catch drivers that do dma after puting the adapter.
    //
    if (GetVerifierAdapterInformation(Address))    
        return TRUE;    
    
    return FALSE;
} // ValidateAdapter //


VOID DmaUsage(
    VOID
    )
/*++

Routine Description:
    
      Prints out correct usage for !dma

Arguments:

    NONE    

Return Value:

    NONE

--*/
{
    
    dprintf("\nUsage: !dma [adapter address] [flags]\n");
    dprintf("Where: [adapter address] is address of specific dma adapter\n");
    dprintf("             or 0x0 for all adapters\n");
    dprintf("       [flags] are:\n");
    dprintf("             0x1: Dump generic adapter information\n");
    dprintf("             0x2: Dump map register information\n");
    dprintf("             0x4: Dump common buffer information\n");
    dprintf("             0x8: Dump scatter-gather list information\n");
    dprintf("             0x10: Dump device description for device\n");
    dprintf("             0x20: Dump Wait-context-block information\n");
    dprintf("Note: flags {2,4,8,10} require dma verifier to be enabled for the adapter\n\n");


} // DmaUsage //

ULONG64
GetVerifierAdapterInformation(
    ULONG64 AdapterAddress
    )
/*++

Routine Description:
    
      Finds out whether the adapter at AdapterAddress is being verified. If it is, return a pointer
      to the ADAPTER_INFORMATION structure corresponding to the adapter.

Arguments:

    AdapterAddress -- Address of the adapter we are trying to find out if it is being verified

Return Value:

    ULONG64 -- Address of ADAPTER_INFORMATION struct for verified adapter
    0 -- Not verifying adapter;

--*/
{
    DBG_LIST_ENTRY AdapterInfoList = {0,0};
    ULONG64 StartAddress = 0;
    ULONG64 CurrentAdapter = 0;
    ULONG64 CurrentAdapterInfo = 0;

    ULONG64 VerifiedDmaAdapter = 0;    
    ULONG ListEntryOffset = 0;

    UINT64 VerifyingDma = 0;    
    
    if (! AdapterAddress ) 
        return 0;
            

    ReadPointer(GetExpression("nt!ViVerifyDma"), &VerifyingDma);
    if (0 == VerifyingDma)
    //
    // Not verifying dma ... 
    //
    {         
        return 0;
    }        
    //
    // Find the address of the dma adapter list head
    //
    
    StartAddress = GetExpression("nt!ViAdapterList");
    
    if (StartAddress == 0) {        
        return 0;
    }
    
    //
    // Determine the list entry offset we will use to calculate
    // adapter addresses
    //
    if (GetFieldOffset("nt!_ADAPTER_INFORMATION", "ListEntry", &ListEntryOffset)) {
        dprintf("\nError retrieving verifier adapter information list offset.\n\n");
        return 0;
    }

    //
    // Read the dma adapter list head
    //
    if (GetDbgListEntry(StartAddress, &AdapterInfoList)) {
        dprintf("\nError reading verifier adapter information list head: 0x%08p\n\n",
            StartAddress);
        return 0;
    }        
    
    if (AdapterInfoList.Flink == 0 || AdapterInfoList.Blink == 0)
        return 0;

    while (AdapterInfoList.Flink != StartAddress) {
        
        CurrentAdapterInfo = AdapterInfoList.Flink - ListEntryOffset;

        GetFieldValue(CurrentAdapterInfo, "nt!_ADAPTER_INFORMATION","DmaAdapter", VerifiedDmaAdapter);

        if (AdapterAddress == VerifiedDmaAdapter)            
        {            
            return CurrentAdapterInfo;
        }         
        //
        // Read the next adapter list entry
        //        
        if (GetDbgListEntry(AdapterInfoList.Flink, &AdapterInfoList)) {
            dprintf("\nError reading adapter info list entry: 0x%08p\n", AdapterInfoList);
            break;
        }
        

        if (CheckControlC())        
            break;
    }

               
    return 0;

} // GetVerifierAdapterInformation //



VOID
DumpVerifiedMapRegisterFiles(
    IN ULONG64 MapRegisterFileListHead
    )
/*++

Routine Description:

    Dump pertinent info pertaining to verified map registers. 
    NOTE: This may not be all map registers for the adapter -- just the ones 
        that are being verified. There is a limit to how many map registers
        we verify for each adapter -- since each time we use three pages
        of physical memory.

    NOTE ON TERMINOLOGY: Map register file: a single allocation of map registers
        recieved in the callback routine from IoAllocateAdapterChannel. Any number
        or combination of these registers can be mapped at one time.

Arguments:

    MapRegisterFileListHead -- head of list of map register files.

Return Value:

    NONE

--*/

{
    DBG_LIST_ENTRY MapRegisterFileListEntry = {0,0};
    ULONG64 MapRegisterFile = 0;
    
    ULONG ListEntryOffset = 0;
    
    ULONG64 Signature = 0;
    ULONG64 NumberOfMapRegisters = 0;
    ULONG64 NumberOfRegistersMapped = 0;
    ULONG64 MapRegisterMdl = 0;    
    
    ULONG64 MapRegister;
    
    ULONG64 MappedToAddress;
    ULONG64 BytesMapped;
    ULONG64 MapRegisterStart;
    
    ULONG SizeofMapRegister;
    ULONG CurrentMapRegister; 
    ULONG MapRegisterOffset;
    
    
    if (GetDbgListEntry(MapRegisterFileListHead, &MapRegisterFileListEntry))
    {
        return;
    }
           
    if (MapRegisterFileListEntry.Flink == MapRegisterFileListHead)
        //
        // Empty list
        //
    {
        dprintf("\n   No map register files\n\n");
        return;
    } 
    
    //
    // Determine the list entry offset we will use to calculate
    // the beginning of the map register file
    //
    if (GetFieldOffset("nt!_MAP_REGISTER_FILE", "ListEntry", &ListEntryOffset)) {
        dprintf("\nError retrieving list entry offset.\n\n");
        return;
    }
    
    SizeofMapRegister = GetTypeSize("nt!_MAP_REGISTER");
    if (! SizeofMapRegister )
    {
        dprintf("\n   Could not get size of nt!_MAP_REGISTER\n\n");
        return;
    }
    

    if (GetFieldOffset("nt!_MAP_REGISTER_FILE","MapRegisters", &MapRegisterOffset))
    {
        dprintf("\n   Couuld not get map register offset\n\n");
    }

    while (MapRegisterFileListEntry.Flink != MapRegisterFileListHead) {

        MapRegisterFile = MapRegisterFileListEntry.Flink - ListEntryOffset;
                
        GetFieldValue(MapRegisterFile, "nt!_MAP_REGISTER_FILE","Signature", Signature);

        if (((ULONG) Signature) != MAP_REGISTER_FILE_SIGNATURE)  {
            dprintf("\n   Invalid signature for map register file %08p\n\n", MapRegisterFile);
            return;
        }
        
        GetFieldValue(MapRegisterFile, "nt!_MAP_REGISTER_FILE","NumberOfMapRegisters", NumberOfMapRegisters);
        GetFieldValue(MapRegisterFile, "nt!_MAP_REGISTER_FILE","NumberOfRegistersMapped", NumberOfRegistersMapped);
        GetFieldValue(MapRegisterFile, "nt!_MAP_REGISTER_FILE","MapRegisterMdl", MapRegisterMdl);         

        
        
        
        dprintf("   Map register file %08p (%x/%x mapped)\n",
            MapRegisterFile, (ULONG) NumberOfRegistersMapped, (ULONG) NumberOfMapRegisters);
        dprintf("      Double buffer mdl: %08p\n", MapRegisterMdl);
        dprintf("      Map registers:\n");
        
        MapRegister = MapRegisterFile + MapRegisterOffset;
        for (CurrentMapRegister = 0; CurrentMapRegister < NumberOfMapRegisters; CurrentMapRegister++)  {        
            GetFieldValue(MapRegister, "nt!_MAP_REGISTER", "MappedToSa", MappedToAddress);
            GetFieldValue(MapRegister, "nt!_MAP_REGISTER", "BytesMapped", BytesMapped);            
            
             dprintf("         %08x: ",  MapRegister);
            //dprintf("         %03x: ", CurrentMapRegister);
            if (BytesMapped) {
                
                dprintf("%04x bytes mapped to %08p\n", (ULONG) BytesMapped,  MappedToAddress);

            } else {

                dprintf("Not mapped\n");
            }

            if (CheckControlC())
                return;
            //
            // Increment our map register pointer
            //
            MapRegister += SizeofMapRegister;            
        } // End dump of map registers //

        dprintf("\n");


        //
        // Advance to the next map register file
        //        
        if (GetDbgListEntry(MapRegisterFileListEntry.Flink , &MapRegisterFileListEntry)) {

            dprintf("\nError reading map register file list entry: 0x%08p\n", 
                MapRegisterFileListEntry.Flink);
            break;
        }
        
        if (CheckControlC())
            return;       
        
    } // End dump of map register files //
    
    
    return;
} // DumpVerifiedMapRegisterFiles //

VOID
DumpVerifiedCommonBuffers(
    IN ULONG64 CommonBufferListHead
    )
/*++

Routine Description:

    Dump pertinent info pertaining to verified common buffers
    
Arguments:

    CommonBufferListHead  -- head of list of common buffers for a single adapter

Return Value:

    NONE

--*/
{
    DBG_LIST_ENTRY CommonBufferListEntry = {0,0};

    ULONG64 CommonBuffer;
    ULONG AdvertisedLength;
	
    UINT64 AdvertisedStartAddress;
    UINT64 RealStartAddress;
	UINT64 RealLogicalStartAddress;
    UINT64 AdvertisedLogicalStartAddress;

	UINT64 AllocatorAddress;

    ULONG ListEntryOffset;
    CHAR AllocatorName[256];


    if (GetDbgListEntry(CommonBufferListHead, &CommonBufferListEntry))
    {
        return;
    }
           
    if (CommonBufferListEntry.Flink == CommonBufferListHead)
        //
        // Empty list
        //
    {
        dprintf("\n   No common buffers\n\n");
        return;
    } 
    
    //
    // Determine the list entry offset we will use to calculate
    // the beginning of the map register file
    //
    if (GetFieldOffset("nt!_HAL_VERIFIER_BUFFER", "ListEntry", &ListEntryOffset)) {
        dprintf("\n   Error retrieving list entry offset.\n\n");
        return;
    }        
    
    while (CommonBufferListEntry.Flink != CommonBufferListHead) {

        CommonBuffer = CommonBufferListEntry.Flink - ListEntryOffset;
                
        
        GetFieldValue(CommonBuffer, "nt!_HAL_VERIFIER_BUFFER","AdvertisedLength", AdvertisedLength);
        GetFieldValue(CommonBuffer, "nt!_HAL_VERIFIER_BUFFER","AdvertisedStartAddress", AdvertisedStartAddress);
        GetFieldValue(CommonBuffer, "nt!_HAL_VERIFIER_BUFFER","RealStartAddress", RealStartAddress);
        GetFieldValue(CommonBuffer, "nt!_HAL_VERIFIER_BUFFER","RealLogicalStartAddress", RealLogicalStartAddress);
        GetFieldValue(CommonBuffer, "nt!_HAL_VERIFIER_BUFFER","AllocatorAddress", AllocatorAddress);

        DumpSymbolicAddress(AllocatorAddress, AllocatorName, TRUE);

        dprintf("   Common buffer allocated by %s:\n", AllocatorName);
        
        dprintf("      Length:           %x\n", AdvertisedLength);
        dprintf("      Virtual address:  %08p\n", AdvertisedStartAddress);
        dprintf("      Physical address: %I64lx\n", 
            (AdvertisedStartAddress - RealStartAddress) + RealLogicalStartAddress);
        
        dprintf("\n");
        //
        // Advance to the next common buffer in the list 
        //        
        if (GetDbgListEntry(CommonBufferListEntry.Flink , &CommonBufferListEntry)) {

            dprintf("\nError reading common buffer list entry: 0x%08p\n", 
                CommonBufferListEntry.Flink);
            break;
        }
        
        if (CheckControlC())
            return;       
        
    } // End dump of common buffers //
        

   return;
} // DumpVerifiedCommonBuffers //

VOID
DumpVerifiedScatterGatherLists(
    IN ULONG64 ScatterGatherListHead
    )
/*++

Routine Description:

    Dump pertinent info pertaining to scatter gather lists in use by a single
    adapter.
    
Arguments:

    ScatterGatherListHead -- head of a list of ScatterGather lists.

Return Value:

    NONE

--*/
{
    UNREFERENCED_PARAMETER(ScatterGatherListHead);
   
    return;
} // DumpVerifiedScatterGatherLists //

VOID 
DumpDeviceDescription(
    IN ULONG64 DeviceDescription
    )
/*++

Routine Description:

    Dump pertinent info from a device description struct
    
Arguments:

    ScatterGatherListHead -- head of a list of ScatterGather lists.

Return Value:

    NONE

--*/
{
    ULONG Version;
    BOOLEAN Master;
    BOOLEAN ScatterGather;        
    BOOLEAN Dma32BitAddresses;     
    BOOLEAN Dma64BitAddresses;        
    ULONG InterfaceType;        
    ULONG MaximumLength;   
        
    
    GetFieldValue(DeviceDescription, "hal!_DEVICE_DESCRIPTION","Version", Version);

    if (Version > 2) {
        dprintf("\nBad device description version: %x\n\n", Version);
        return;
    }

    GetFieldValue(DeviceDescription, "hal!_DEVICE_DESCRIPTION","Master", Master);
    GetFieldValue(DeviceDescription, "hal!_DEVICE_DESCRIPTION","ScatterGather", ScatterGather);
    GetFieldValue(DeviceDescription, "hal!_DEVICE_DESCRIPTION","Dma32BitAddresses", Dma32BitAddresses);
    GetFieldValue(DeviceDescription, "hal!_DEVICE_DESCRIPTION","Dma64BitAddresses", Dma64BitAddresses);        
    GetFieldValue(DeviceDescription, "hal!_DEVICE_DESCRIPTION","InterfaceType", InterfaceType);

    dprintf("   Device Description Version %02x\n", Version);

    if (InterfaceType < MAX_INTERFACE) {

        dprintf("      Interface type %s\n", DbgInterfaceTypes[InterfaceType]);

    } else {

        dprintf("      Interface type unknown\n");

    }

    dprintf("      DMA Capabilities:\n");

    if(Master) {
        dprintf("         Busmaster\n");
    } else {
        dprintf("         Slave\n");
    }

    if (ScatterGather)    
        dprintf("         Scatter Gather\n");    
    
    if (Dma32BitAddresses)
        dprintf("         32-bit DMA\n");
    if (Dma64BitAddresses)
        dprintf("         64-bit DMA\n");
    if (! Dma32BitAddresses && ! Dma64BitAddresses)
        dprintf("         24-bit DMA only\n");

    dprintf("\n");

   


} // DumpDeviceDescription //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\exceptn.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    exceptn.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


DECLARE_API( exrlog )
{
    ULONG LogCount;
    ULONG64 Address;
    ULONG result;
    ULONG64 LogPointer;
    ULONG64 MaxLogRecord;
    LAST_EXCEPTION_LOG LogRecord;
    ULONG MaxExceptionLog;
    CHAR Buffer[256];
    ULONG64 displacement;
    PUCHAR s;
    ULONG64 Finally=0;
    ULONG64 Filter=0;
    ULONG64 Handler=0;
    ULONG   SizeOfLogRec;
    ULONG ContextRecordOffset;
    
    // Get the offset of ContextRecord in LAST_EXCEPTION_LOG
    if (GetFieldOffset("LAST_EXCEPTION_LOG", "ContextRecord", &ContextRecordOffset)){
        return E_INVALIDARG ;
    }
    
    Address = GetExpression( "nt!RtlpExceptionLogCount" );
    if (Address == 0) {
        dprintf("exrlog: No symbol for RtlpExceptionLogCount.\n");
        return E_INVALIDARG;
    }
    if ((!ReadMemory(Address,
                     (PVOID)&LogCount,
                     sizeof(ULONG),
                     &result)) || (result < sizeof(ULONG))) {
        dprintf("exrlog: Unable to read log\n");
        return E_INVALIDARG;
    }

    Address = GetExpression( "nt!RtlpExceptionLogSize" );
    if (Address == 0) {
        dprintf("exrlog: No symbol for RtlpExceptionSize.\n");
        return E_INVALIDARG;
    }
    if ((!ReadMemory(Address,
                     (PVOID)&MaxExceptionLog,
                     sizeof(ULONG),
                     &result)) || (result < sizeof(ULONG))) {
        dprintf("exrlog: Unable to read log\n");
        return E_INVALIDARG;
    }

    Address = GetExpression( "nt!RtlpExceptionLog" );
    if (Address == 0) {
        dprintf("exrlog: No symbol for RtlpExceptionLog.\n");
        return E_INVALIDARG;
    }
    if (!ReadPointer(Address,&LogPointer)) {
        dprintf("exrlog: Unable to read log pointer\n");
        return E_INVALIDARG;
    }

    if (LogPointer == 0 || MaxExceptionLog == 0) {
        dprintf("exrlog: Exception logging is not enabled.\n");
        return E_INVALIDARG;
    }

    MaxLogRecord = LogPointer + MaxExceptionLog;
    LogPointer += LogCount;
    
    if (!(SizeOfLogRec = GetTypeSize("LAST_EXCEPTION_LOG"))) {
        dprintf("Cannot find LAST_EXCEPTION_LOG type.\n");
        return E_INVALIDARG;
    }

    for (LogCount = 0; LogCount < MaxExceptionLog; LogCount++) {
        ULONG Disposition;

        if (GetFieldValue(LogPointer, 
                          "LAST_EXCEPTION_LOG", 
                          "Disposition",
                          Disposition)) {
            dprintf("exrlog: Unable to read log entry at %08p\n", LogPointer);
        }
        dprintf("\n% 2d: ----------------------------------\n", LogCount);

	sprintf(Buffer, ".exr %I64lx", LogPointer);
	ExecuteCommand(Client, Buffer); // Excveptionrecord is first field in log

        dprintf("\n");

        // Incomplete - exsup.c
//        InterpretExceptionData(&LogRecord, &Finally, &Filter, &Handler);

        GetSymbol(Filter, Buffer, &displacement);
        dprintf("Filter:  %08p", Filter);
        if (*Buffer) {
            dprintf(" (%s+0x%I64x)\n", Buffer, displacement);
        } else {
            dprintf("\n");
        }

        GetSymbol(Handler, Buffer, &displacement);
        dprintf("Handler: %08p", Handler);
        if (*Buffer) {
            dprintf(" (%s+0x%I64x)\n", Buffer, displacement);
        } else {
            dprintf("\n");
        }

        GetSymbol(Finally, Buffer, &displacement);
        dprintf("Finally: %08p", Finally);
        if (*Buffer) {
            dprintf(" (%s+0x%I64x)\n", Buffer, displacement);
        } else {
            dprintf("\n");
        }

        switch( Disposition ) {
            case ExceptionContinueExecution:
                s = "ExceptionContinueExecution";
                break;

            case ExceptionContinueSearch:
                s = "ExceptionContinueSearch";
                break;

            case ExceptionNestedException:
                s = "ExceptionNestedException";
                break;

            case 0xffffffff:
                s = "Executed Handler";
                break;
        }
        dprintf("Disposition: %d (%s)\n\n", Disposition, s);

        sprintf(Buffer, ".cxr %I64lx", ContextRecordOffset + LogPointer);
	ExecuteCommand(Client, Buffer);
	ExecuteCommand(Client, ".cxr");

        LogPointer += SizeOfLogRec;
        if (LogPointer >= MaxLogRecord) {
            LogPointer -= MaxExceptionLog;
        }

    }

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\errorlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    errorlog.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

DECLARE_API( errlog )

/*++

Routine Description:

    This routine dumps the contents of the error log list.  It uses a nasty
    hack to get started (i.e. a duplicate structure definition) because the
    error log list entries are not defined in a public header.

Arguments:

    args - not used

Return Value:

    None

--*/

{
    ULONG64         listAddress;
    ULONG           result;
    ULONG           i;
    ULONG64         next;
    ULONG64         entryAddress;
    ULONG64         HeadFlink;
    ULONG           ErrLogOff, DataOff;


    listAddress = GetNtDebuggerData( IopErrorLogListHead );

    if (!listAddress) {
        dprintf("Can't find error log list head\n");
        goto exit;
    }
    if (GetFieldValue(listAddress,
                     "nt!_LIST_ENTRY",
                      "Flink",
                      HeadFlink)) {
        dprintf("%08p: Could not read error log list head\n", listAddress);
        goto exit;
    }

    //
    // walk the list.
    //

    next = HeadFlink;

    if (next == 0) {
        dprintf("ErrorLog is empty\n");
        goto exit;
    }

    if (next == listAddress) {
        dprintf("errorlog is empty\n");
    } else {
        dprintf("PacketAdr  DeviceObj  DriverObj  Function  ErrorCode  UniqueVal  FinalStat\n");
    }

    GetFieldOffset("nt!ERROR_LOG_ENTRY", "ListEntry", &ErrLogOff);
    GetFieldOffset("nt!IO_ERROR_LOG_PACKET", "DumpData", &DataOff);
    while(next != listAddress) {
        ULONG64 DeviceObject, DriverObject;
        ULONG   DumpDataSize;

        if (next != 0) {
            entryAddress = next - ErrLogOff;
        } else {
            break;
        }

        //
        // Read the internal error log packet structure.
        //

        if (GetFieldValue(entryAddress,
                          "nt!ERROR_LOG_ENTRY",
                          "DeviceObject",
                          DeviceObject)) {
            dprintf("%08p: Cannot read entry\n", entryAddress);
            goto exit;
        }
        GetFieldValue(entryAddress,"ERROR_LOG_ENTRY","DriverObject", DriverObject);
        GetFieldValue(entryAddress,"ERROR_LOG_ENTRY","ListEntry.Flink", next);

        //
        // now calculate the address and read the io_error_log_packet
        //

        entryAddress = entryAddress + GetTypeSize("ERROR_LOG_ENTRY");

        if (GetFieldValue(entryAddress,
                          "nt!IO_ERROR_LOG_PACKET",
                          "DumpDataSize",
                          DumpDataSize)) {
            dprintf("%08p: Cannot read packet\n", entryAddress);
            goto exit;
        }

        //
        // read again to get the dumpdata if necessary.  This just rereads
        // the entire packet into a new buffer and hopes the cache is enabled
        // behind the DbgKdReadxx routine for performance.
        //
        InitTypeRead(entryAddress, nt!IO_ERROR_LOG_PACKET);
        dprintf("%08p   %08p   %08p   %2x        %08lx   %08lx   %08lx\n",
                entryAddress,
                DeviceObject,
                DriverObject,
                (UCHAR) ReadField(MajorFunctionCode),
                (ULONG) ReadField(ErrorCode),
                (ULONG) ReadField(UniqueErrorValue),
                (ULONG) ReadField(FinalStatus));

        dprintf("\t\t     ");
        DumpDriver(DriverObject, 0, 0);
        if (DumpDataSize) {
            PULONG dumpData;

            dumpData = LocalAlloc(LPTR, DumpDataSize);
            if (dumpData == NULL) {
                dprintf("%08lx: Cannot allocate memory for dumpData (%u)\n", DumpDataSize);
                goto exit;
            }

            if ((!ReadMemory(entryAddress + DataOff,
                             dumpData,
                             DumpDataSize,
                             &result)) || (result != DumpDataSize)) {
                LocalFree(dumpData);
                dprintf("%08p: Cannot read packet and dump data\n", entryAddress);
                goto exit;
            }
            dprintf("\n\t\t      DumpData:  ");
            for (i = 0; (i * sizeof(ULONG)) < DumpDataSize; i++) {
                dprintf("%08lx ", dumpData[i]);
                if ((i & 0x03) == 0x03) {
                    dprintf("\n\t\t                 ");
                }
                if (CheckControlC()) {
                    break;
                }
            }
            LocalFree(dumpData);
        }

        dprintf("\n");

        if (CheckControlC()) {
            goto exit;
        }
    }

exit:

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\extflags.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    extflags.h

Abstract:

    This header file (re)defines various flags used by extensions. These definitions
    are copied from different header files as stated.

--*/

#ifndef _EXTFLAGS_
#define _EXTFLAGS_



///////////////////////////////////////////////////////////////////////////////
//
// apic.inc
//
///////////////////////////////////////////////////////////////////////////////

//
//  Default Physical addresses of the APICs in a PC+MP system
//

#define IO_BASE_ADDRESS 0xFEC00000  // Default address of
                                    // 1st IO Apic
#define LU_BASE_ADDRESS 0xFEE00000  // Default address
                                    // of Local Apic

#define IO_REGISTER_SELECT      0x00000000 //
#define IO_REGISTER_WINDOW      0x00000010 //

#define IO_ID_REGISTER          0x00000000
#define IO_VERS_REGISTER        0x00000001
#define IO_ARB_ID_REGISTER      0x00000002
#define IO_REDIR_00_LOW         0x00000010
#define IO_REDIR_00_HIGH        0x00000011

#define IO_MAX_REDIR_MASK       0x00FF0000
#define IO_VERSION_MASK         0x000000FF

#define LU_ID_REGISTER          0x00000020 //
#define LU_VERS_REGISTER        0x00000030 //
#define LU_TPR                  0x00000080 //
#define LU_APR                  0x00000090 //
#define LU_PPR                  0x000000A0 //
#define LU_EOI                  0x000000B0 //
#define LU_REMOTE_REGISTER      0x000000C0 //

#define LU_LOGICAL_DEST         0x000000D0 //
#define LU_LOGICAL_DEST_MASK    0xFF000000

#define LU_DEST_FORMAT          0x000000E0 //
#define LU_DEST_FORMAT_MASK     0xF0000000
#define LU_DEST_FORMAT_FLAT     0xFFFFFFFF
#define LU_DEST_FORMAT_CLUSTER  0x0FFFFFFF

#define LU_SPURIOUS_VECTOR      0x000000F0 //
#define LU_FAULT_VECTOR         0x00000370 //
#define LU_UNIT_ENABLED         0x00000100
#define LU_UNIT_DISABLED        0x00000000

#define LU_ISR_0                0x00000100 //
#define LU_TMR_0                0x00000180 //
#define LU_IRR_0                0x00000200 //
#define LU_ERROR_STATUS         0x00000280 //
#define LU_INT_CMD_LOW          0x00000300 //
#define LU_INT_CMD_HIGH         0x00000310 //
#define LU_TIMER_VECTOR         0x00000320 //
#define LU_PERF_VECTOR          0x00000340
#define LU_INT_VECTOR_0         0x00000350 //    TEMPORARY - do not use
#define LU_INT_VECTOR_1         0x00000360 //    TEMPORARY - do not use
#define LU_INITIAL_COUNT        0x00000380 //
#define LU_CURRENT_COUNT        0x00000390 //
#define LU_DIVIDER_CONFIG       0x000003E0 //

#define APIC_ID_MASK            0xFF000000
#define APIC_ID_SHIFT           24

#define INT_VECTOR_MASK         0x000000FF
#define RESERVED_HIGH_INT       0x000000F8
#define DELIVERY_MODE_MASK      0x00000700
#define DELIVER_FIXED           0x00000000
#define DELIVER_LOW_PRIORITY    0x00000100
#define DELIVER_SMI             0x00000200
#define DELIVER_REMOTE_READ     0x00000300
#define DELIVER_NMI             0x00000400
#define DELIVER_INIT            0x00000500
#define DELIVER_STARTUP         0x00000600
#define DELIVER_EXTINT          0x00000700
#define PHYSICAL_DESTINATION    0x00000000
#define LOGICAL_DESTINATION     0x00000800
#define DELIVERY_PENDING        0x00001000
#define ACTIVE_LOW              0x00002000
#define ACTIVE_HIGH             0x00000000
#define REMOTE_IRR              0x00004000
#define LEVEL_TRIGGERED         0x00008000
#define EDGE_TRIGGERED          0x00000000
#define INTERRUPT_MASKED        0x00010000
#define INTERRUPT_MOT_MASKED    0x00000000
#define PERIODIC_TIMER          0x00020000

#define ICR_LEVEL_ASSERTED      0x00004000
#define ICR_LEVEL_DEASSERTED    0x00000000
#define ICR_RR_STATUS_MASK      0x00030000
#define ICR_RR_INVALID          0x00000000
#define ICR_RR_IN_PROGRESS      0x00010000
#define ICR_RR_VALID            0x00020000
#define ICR_SHORTHAND_MASK      0x000C0000
#define ICR_USE_DEST_FIELD      0x00000000
#define ICR_SELF                0x00040000
#define ICR_ALL_INCL_SELF       0x00080000
#define ICR_ALL_EXCL_SELF       0x000C0000


//
//  Io Apic Entry definitions
//
//  Interrupt Types Possible in the PC+MP Table
//  valid for both local and Io Apics
//
#define INT_TYPE_INTR           0x0
#define INT_TYPE_NMI            0x1
#define INT_TYPE_SMI            0x2
#define INT_TYPE_EXTINT         0x3



///////////////////////////////////////////////////////////////////////////////
//
// arbiter.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Attributes for the ranges
//

#define ARBITER_RANGE_BOOT_ALLOCATED            0x01
#define ARBITER_RANGE_SHARE_DRIVER_EXCLUSIVE    0x02

#define ARBITER_RANGE_ALIAS             0x10
#define ARBITER_RANGE_POSITIVE_DECODE   0x20

#define INITIAL_ALLOCATION_STATE_SIZE   PageSize

#define ARBITER_INSTANCE_SIGNATURE      'sbrA'



///////////////////////////////////////////////////////////////////////////////
//
// busp.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Flags definitions of DEVICE_INFORMATION and BUS_EXTENSION
//

#define DF_DELETED          0x00000001
#define DF_REMOVED          0X00000002
#define DF_NOT_FUNCTIONING  0x00000004
#define DF_ENUMERATED       0x00000008
#define DF_ACTIVATED        0x00000010
#define DF_QUERY_STOPPED    0x00000020
#define DF_SURPRISE_REMOVED 0x00000040
#define DF_PROCESSING_RDP   0x00000080
#define DF_STOPPED          0x00000100
#define DF_RESTARTED_MOVED  0x00000200
#define DF_RESTARTED_NOMOVE 0x00000400
#define DF_REQ_TRIMMED      0x00000800
#define DF_READ_DATA_PORT   0x40000000
#define DF_BUS              0x80000000


///////////////////////////////////////////////////////////////////////////////
//
// cache.h
//
///////////////////////////////////////////////////////////////////////////////

//  Define two constants describing the view size (and alignment)
//  that the Cache Manager uses to map files.
//

#define VACB_MAPPING_GRANULARITY         (0x40000)
#define VACB_OFFSET_SHIFT                (18)


///////////////////////////////////////////////////////////////////////////////
//
// cc.h
//
///////////////////////////////////////////////////////////////////////////////

//
//  Define our node type codes.
//

#define CACHE_NTC_SHARED_CACHE_MAP       (0x2FF)
#define CACHE_NTC_PRIVATE_CACHE_MAP      (0x2FE)
#define CACHE_NTC_BCB                    (0x2FD)
#define CACHE_NTC_DEFERRED_WRITE         (0x2FC)
#define CACHE_NTC_MBCB                   (0x2FB)
#define CACHE_NTC_OBCB                   (0x2FA)
#define CACHE_NTC_MBCB_GRANDE            (0x2F9)

//  There is a bit of a trick as we make the jump to the multilevel structure in that
//  we need a real fixed reference count.
//

#define VACB_LEVEL_SHIFT                  (7)

//
//  This is how many bytes of pointers are at each level.  This is the size for both
//  the Vacb array and (optional) Bcb listheads.  It does not include the reference
//  block.
//

// #define VACB_LEVEL_BLOCK_SIZE             ((1 << VACB_LEVEL_SHIFT) * sizeof(PVOID))

//
//  This is the last index for a level.
//

#define VACB_LAST_INDEX_FOR_LEVEL         ((1 << VACB_LEVEL_SHIFT) - 1)

//
//  This is the size of file which can be handled in a single level.
//

#define VACB_SIZE_OF_FIRST_LEVEL         (1 << (VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT))

//
//  This is the maximum number of levels it takes to support 63-bits.  It is
//  used for routines that must remember a path.
//

#define VACB_NUMBER_OF_LEVELS            (((63 - VACB_OFFSET_SHIFT)/VACB_LEVEL_SHIFT) + 1)

//
//  First some constants
//

#define PREALLOCATED_VACBS               (4)


///////////////////////////////////////////////////////////////////////////////
//
// ex.h
//
///////////////////////////////////////////////////////////////////////////////

#define CALL_HASH_TABLE_SIZE 64

//
// If high order bit in Pool tag is set, then must use ExFreePoolWithTag to free
//

#define PROTECTED_POOL 0x80000000

#define POOL_BACKTRACEINDEX_PRESENT 0x8000

#define ResourceNeverExclusive       0x10
#define ResourceReleaseByOtherThread 0x20
#define ResourceOwnedExclusive       0x80

#define RESOURCE_HASH_TABLE_SIZE 64

//
// The following two definitions control the raising of exceptions on quota
// and allocation failures.
//

#define POOL_QUOTA_FAIL_INSTEAD_OF_RAISE 8
#define POOL_RAISE_IF_ALLOCATION_FAILURE 16               // ntifs



///////////////////////////////////////////////////////////////////////////////
//
// cmdata.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Define the HINT Length used
//
#define CM_SUBKEY_HINT_LENGTH   4
#define CM_MAX_CACHE_HINT_SIZE 14

//
// Bits used in the ExtFlags in KCB.
//

#define CM_KCB_NO_SUBKEY        0x0001      // This key has no subkeys
#define CM_KCB_SUBKEY_ONE       0x0002      // This key has only one subkey and the
                                            // first 4 char
                                            //
#define CM_KCB_SUBKEY_HINT          0x0004
#define CM_KCB_SYM_LINK_FOUND       0x0008
#define CM_KCB_KEY_NON_EXIST        0x0010
#define CM_KCB_NO_DELAY_CLOSE       0x0020
#define CM_KCB_INVALID_CACHED_INFO  0x0040  // info stored in SubKeyCount is not valid, so we shouldn't rely on it

#define CM_KCB_CACHE_MASK (CM_KCB_NO_SUBKEY | \
                           CM_KCB_KEY_NON_EXIST | \
                           CM_KCB_SUBKEY_ONE | \
                           CM_KCB_SUBKEY_HINT)




//
// CM_KEY_BODY
//
#define KEY_BODY_TYPE           0x6b793032      // "ky02"

//
// ----- CM_KEY_VALUE -----
//

#define CM_KEY_VALUE_SIGNATURE      0x6b76                      // "kv"

#define VALUE_COMP_NAME             0x0001                      // The name for this value is stored in a

//
// ----- CM_KEY_NODE -----
//

#define CM_KEY_NODE_SIGNATURE      0x6b6e           // "kn"
#define CM_LINK_NODE_SIGNATURE     0x6b6c          // "kl"

#define KEY_VOLATILE        0x0001      // This key (and all its children)
                                        // is volatile.

#define KEY_HIVE_EXIT       0x0002      // This key marks a bounary to another
                                        // hive (sort of a link).  The null
                                        // value entry contains the hive
                                        // and hive index of the root of the
                                        // child hive.

#define KEY_HIVE_ENTRY      0x0004      // This key is the root of a particular
                                        // hive.

#define KEY_NO_DELETE       0x0008      // This key cannot be deleted, period.

#define KEY_SYM_LINK        0x0010      // This key is really a symbolic link.
#define KEY_COMP_NAME       0x0020      // The name for this key is stored in a
                                        // compressed form.
#define KEY_PREDEF_HANDLE   0x0040      // There is no real key backing this,
                                        // return the predefined handle.
                                        // Predefined handles are stashed in
                                        // ValueList.Count.

///////////////////////////////////////////////////////////////////////////////
//
// hivedata.h
//
///////////////////////////////////////////////////////////////////////////////
#define HFILE_TYPE_PRIMARY      0   // Base hive file
#define HFILE_TYPE_LOG          1   // Log (security.log)
#define HFILE_TYPE_EXTERNAL     2   // Target of savekey, etc.
#define HFILE_TYPE_MAX          3

#define HHIVE_SIGNATURE 0xBEE0BEE0

#define HBIN_SIGNATURE          0x6e696268      // "hbin"

#define HHIVE_LINEAR_INDEX      16  // All computed linear indices < HHIVE_LINEAR_INDEX are valid
#define HHIVE_EXPONENTIAL_INDEX 23  // All computed exponential indices < HHIVE_EXPONENTIAL_INDEX
                                    // and >= HHIVE_LINEAR_INDEX are valid.
#define HHIVE_FREE_DISPLAY_SIZE 24

#define HHIVE_FREE_DISPLAY_SHIFT 3  // This must be log2 of HCELL_PAD!
#define HHIVE_FREE_DISPLAY_BIAS  7  // Add to first set bit left of cell size to get exponential index

///////////////////////////////////////////////////////////////////////////////
//
// hardware.h
//
///////////////////////////////////////////////////////////////////////////////

typedef enum {
   WaveInDevice = 0,
   WaveOutDevice,
   MidiOutDevice,
   MidiInDevice,
   LineInDevice,
   CDInternal,
   MixerDevice,
   AuxDevice,
   NumberOfDevices
   } SOUND_DEVICES;

///////////////////////////////////////////////////////////////////////////////
//
// hcdi.h
//
///////////////////////////////////////////////////////////////////////////////

//
// values for DeviceExtension Flags
//
#define USBDFLAG_PDO_REMOVED                0x00000001
#define USBDFLAG_HCD_SHUTDOWN               0x00000002
#define USBDFLAG_HCD_STARTED                0x00000004
#define USBDFLAG_HCD_D0_COMPLETE_PENDING    0x00000008
#define USBDFLAG_RH_DELAY_SET_D0            0x00000010


#define HC_ENABLED_FOR_WAKEUP           0x01
#define HC_WAKE_PENDING                 0x02


// device hack flags, these flags alter the stacks default behavior
// in order to support certain broken "legacy" devices

#define USBD_DEVHACK_SLOW_ENUMERATION   0x00000001
#define USBD_DEVHACK_DISABLE_SN         0x00000002

//
// This macro returns the true device object for the HCD give
// either the true device_object or a PDO owned by the HCD/BUS
// driver.
//

//
// HCD specific URB commands
//

#define URB_FUNCTION_HCD_OPEN_ENDPOINT                0x1000
#define URB_FUNCTION_HCD_CLOSE_ENDPOINT               0x1001
#define URB_FUNCTION_HCD_GET_ENDPOINT_STATE           0x1002
#define URB_FUNCTION_HCD_SET_ENDPOINT_STATE           0x1003
#define URB_FUNCTION_HCD_ABORT_ENDPOINT               0x1004

// this bit is set for all functions that must be handled by HCD
#define HCD_URB_FUNCTION                              0x1000
// this bit is set in the function code by USBD to indicate that
// this is an internal call originating from USBD
#define HCD_NO_USBD_CALL                              0x2000

//
// values for HcdEndpointState
//

//
// set if the current state of the endpoint in the HCD is 'stalled'
//
#define HCD_ENDPOINT_HALTED_BIT            0
#define HCD_ENDPOINT_HALTED                (1<<HCD_ENDPOINT_HALTED_BIT)

//
// set if the HCD has any transfers queued for the endpoint
//
#define HCD_ENDPOINT_TRANSFERS_QUEUED_BIT  1
#define HCD_ENDPOINT_TRANSFERS_QUEUED      (1<<HCD_ENDPOINT_TRANSFERS_QUEUED_BIT)


//
// set if the HCD should reset the data toggle on the host side
//
#define HCD_ENDPOINT_RESET_DATA_TOGGLE_BIT 2
#define HCD_ENDPOINT_RESET_DATA_TOGGLE     (1<<HCD_ENDPOINT_RESET_DATA_TOGGLE_BIT )


//
// HCD specific URBs
//

#define USBD_EP_FLAG_LOWSPEED                0x0001
#define USBD_EP_FLAG_NEVERHALT               0x0002
#define USBD_EP_FLAG_DOUBLE_BUFFER           0x0004
#define USBD_EP_FLAG_FAST_ISO                0x0008


///////////////////////////////////////////////////////////////////////////////
//
// hidclass\local.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Valid values for HIDCLASS_DEVICE_EXTENSION.state
//
enum deviceState {
    DEVICE_STATE_INITIALIZED,
    DEVICE_STATE_STARTING,
    DEVICE_STATE_START_SUCCESS,
    DEVICE_STATE_START_FAILURE,
    DEVICE_STATE_STOPPED,
    DEVICE_STATE_REMOVING,
    DEVICE_STATE_REMOVED,
    DEVICE_STATE_SUSPENDED
};

enum collectionState {
    COLLECTION_STATE_UNINITIALIZED,
    COLLECTION_STATE_INITIALIZED,
    COLLECTION_STATE_RUNNING,
    COLLECTION_STATE_STOPPED,
    COLLECTION_STATE_REMOVING
};

#define             HID_DEVICE_EXTENSION_SIG 'EddH'

///////////////////////////////////////////////////////////////////////////////
//
// hidparse.h
//
///////////////////////////////////////////////////////////////////////////////

#define HIDP_PREPARSED_DATA_SIGNATURE1 'PdiH'
#define HIDP_PREPARSED_DATA_SIGNATURE2 'RDK '



///////////////////////////////////////////////////////////////////////////////
//
// hivedata.h
//
///////////////////////////////////////////////////////////////////////////////



//
// ===== Basic Structures and Definitions =====
//
// These are same whether on disk or in memory.
//

//
// NOTE:    Volatile == storage goes away at reboot
//          Stable == Persistent == Not Volatile
//
typedef enum {
    Stable = 0,
    Volatile = 1
} HSTORAGE_TYPE;

#define HTYPE_COUNT 2

// --- HBASE_BLOCK --- on disk description of the hive
//

//
// NOTE:    HBASE_BLOCK must be >= the size of physical sector,
//          or integrity assumptions will be violated, and crash
//          recovery may not work.
//

#define HBASE_BLOCK_SIGNATURE   0x66676572  // "regf"

#define HSYS_MAJOR          1               // Must match to read at all
#define HSYS_MINOR          3               // Must be <= to write, always
                                            // set up to writer's version.

#define HBASE_FORMAT_MEMORY 1               // Direct memory load case

#define HBASE_NAME_ALLOC    64              // 32 unicode chars

// #define HLOG_HEADER_SIZE  (FIELD_OFFSET(HBASE_BLOCK, Reserved2))
#define HLOG_DV_SIGNATURE   0x54524944      // "DIRT"


#define HCELL_TYPE_MASK         0x80000000
#define HCELL_TYPE_SHIFT        31

#define HCELL_TABLE_MASK        0x7fe00000
#define HCELL_TABLE_SHIFT       21

#define HCELL_BLOCK_MASK        0x001ff000
#define HCELL_BLOCK_SHIFT       12

#define HCELL_OFFSET_MASK       0x00000fff

#define HBLOCK_SIZE             0x1000      // LOGICAL block size
                                            // This is the size of one of
                                            // the registry's logical/virtual
                                            // pages.  It has no particular
                                            // relationship to page size
                                            // of the machine.

#define HSECTOR_SIZE            0x200       // LOGICAL sector size
#define HSECTOR_COUNT           8           // LOGICAL sectors / LOGICAL Block

#define HTABLE_SLOTS        512         // 9 bits of address
#define HDIRECTORY_SLOTS    1024        // 10 bits of address


///////////////////////////////////////////////////////////////////////////////
//
// io.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d


//
// Define the major function codes for IRPs.
//


#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the Device Object Extension Flags
//

#define DOE_UNLOAD_PENDING              0x00000001
#define DOE_DELETE_PENDING              0x00000002
#define DOE_REMOVE_PENDING              0x00000004
#define DOE_REMOVE_PROCESSED            0x00000008
#define DOE_START_PENDING               0x00000010

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400

#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000
#define IRP_HOLD_DEVICE_QUEUE           0x00002000
#define IRP_RETRY_IO_COMPLETION         0x00004000



#define DO_VERIFY_VOLUME                0x00000002      // ntddk nthal ntifs
#define DO_BUFFERED_IO                  0x00000004      // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE                    0x00000008      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000010      // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER                0x00000020      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000080      // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS           0x00000200      // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE            0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED          0x00000800      // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE                0x00002000      // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH                 0x00004000      // ntddk nthal ntifs wdm
#define DO_POWER_NOOP                   0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      // ntddk nthal ntifs
//
// Define Volume Parameter Block (VPB) flags.
//

#define VPB_MOUNTED                     0x00000001
#define VPB_LOCKED                      0x00000002
#define VPB_PERSISTENT                  0x00000004
#define VPB_REMOVE_PENDING              0x00000008
#define VPB_RAW_MOUNT                   0x00000010



///////////////////////////////////////////////////////////////////////////////
//
// ke.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Define I/O request packet (IRP) alternate flags for allocation control.
//

#define IRP_QUOTA_CHARGED               0x01
#define IRP_ALLOCATED_MUST_SUCCEED      0x02
#define IRP_ALLOCATED_FIXED_SIZE        0x04
#define IRP_LOOKASIDE_ALLOCATION        0x08

//
// Public (external) constant definitions.
//

#define BASE_PRIORITY_THRESHOLD NORMAL_BASE_PRIORITY // fast path base threshold

// begin_ntddk begin_wdm
#define THREAD_WAIT_OBJECTS 3           // Builtin usable wait blocks
// end_ntddk end_wdm

#define EVENT_WAIT_BLOCK 2              // Builtin event pair wait block
#define SEMAPHORE_WAIT_BLOCK 2          // Builtin semaphore wait block
#define TIMER_WAIT_BLOCK 3              // Builtin timer wait block

#if (EVENT_WAIT_BLOCK != SEMAPHORE_WAIT_BLOCK)
#error "wait event and wait semaphore must use same wait block"
#endif

//
// Define timer table size.
//

#define TIMER_TABLE_SIZE (unsigned)((BuildNo < 2251) ? 128 : 256)


typedef enum _KOBJECTS {
    EventNotificationObject = 0,
    EventSynchronizationObject = 1,
    MutantObject = 2,
    ProcessObject = 3,
    QueueObject = 4,
    SemaphoreObject = 5,
    ThreadObject = 6,
    Spare1Object = 7,
    TimerNotificationObject = 8,
    TimerSynchronizationObject = 9,
    Spare2Object = 10,
    Spare3Object = 11,
    Spare4Object = 12,
    Spare5Object = 13,
    Spare6Object = 14,
    Spare7Object = 15,
    Spare8Object = 16,
    Spare9Object = 17,
    ApcObject,
    DpcObject,
    DeviceQueueObject,
    EventPairObject,
    InterruptObject,
    ProfileObject
    } KOBJECTS;


typedef enum _KBUGCHECK_BUFFER_DUMP_STATE {
    BufferEmpty,
    BufferInserted,
    BufferStarted,
    BufferFinished,
    BufferIncomplete
} KBUGCHECK_BUFFER_DUMP_STATE;



///////////////////////////////////////////////////////////////////////////////
//
// local.h
//
///////////////////////////////////////////////////////////////////////////////
typedef enum {

    //
    // Device Object Extension Types
    //

    PciPdoExtensionType = 'icP0',
    PciFdoExtensionType,

    //
    // Arbitration Types.  (These are also secondary extensions).
    //

    PciArb_Io,
    PciArb_Memory,
    PciArb_Interrupt,
    PciArb_BusNumber,

    //
    // Translation Types.  (These are also secondary extensions).
    //

    PciTrans_Interrupt,

    //
    // Other exposed interfaces.
    //

    PciInterface_BusHandler,
    PciInterface_IntRouteHandler,
    PciInterface_PciCb,
    PciInterface_LegacyDeviceDetection,
    PciInterface_PmeHandler,
    PciInterface_DevicePresent

} PCI_SIGNATURE;

///////////////////////////////////////////////////////////////////////////////
//
// lpc.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Valid values for Flags field
//

#define PORT_TYPE                           0x0000000F
#define SERVER_CONNECTION_PORT              0x00000001
#define UNCONNECTED_COMMUNICATION_PORT      0x00000002
#define SERVER_COMMUNICATION_PORT           0x00000003
#define CLIENT_COMMUNICATION_PORT           0x00000004
#define PORT_WAITABLE                       0x20000000
#define PORT_NAME_DELETED                   0x40000000
#define PORT_DYNAMIC_SECURITY               0x80000000
#define PORT_DELETED                        0x10000000


///////////////////////////////////////////////////////////////////////////////
//
// mi.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Page protections
//

#define MM_ZERO_ACCESS         0  // this value is not used.
#define MM_READONLY            1
#define MM_EXECUTE             2
#define MM_EXECUTE_READ        3
#define MM_READWRITE           4  // bit 2 is set if this is writable.
#define MM_WRITECOPY           5
#define MM_EXECUTE_READWRITE   6
#define MM_EXECUTE_WRITECOPY   7

#define MM_NOCACHE            0x8
#define MM_GUARD_PAGE         0x10
#define MM_DECOMMIT           0x10   //NO_ACCESS, Guard page
#define MM_NOACCESS           0x18   //NO_ACCESS, Guard_page, nocache.
#define MM_UNKNOWN_PROTECTION 0x100  //bigger than 5 bits!
#define MM_LARGE_PAGES        0x111

#define PROTECT_KSTACKS       1

#define MM_KSTACK_OUTSWAPPED  0x1F   //Debug marking for kernel stacks

#define MM_PROTECTION_WRITE_MASK     4
#define MM_PROTECTION_COPY_MASK      1
#define MM_PROTECTION_OPERATION_MASK 7 // mask off guard page and nocache.
#define MM_PROTECTION_EXECUTE_MASK   2

#define MM_SECURE_DELETE_CHECK 0x55


//
// Special pool constants
//
#define MI_SPECIAL_POOL_PAGABLE         0x8000
#define MI_SPECIAL_POOL_VERIFIER        0x4000
#define MI_SPECIAL_POOL_PTE_PAGABLE     0x0002
#define MI_SPECIAL_POOL_PTE_NONPAGABLE  0x0004

#define VI_VERIFYING_DIRECTLY   0x1
#define VI_VERIFYING_INVERSELY  0x2


#define MM_SYS_PTE_TABLES_MAX 5



///////////////////////////////////////////////////////////////////////////////
//
// mm.h
//
///////////////////////////////////////////////////////////////////////////////


typedef enum _MMLISTS {
    ZeroedPageList,
    FreePageList,
    StandbyPageList,  //this list and before make up available pages.
    ModifiedPageList,
    ModifiedNoWritePageList,
    BadPageList,
    ActiveAndValid,
    TransitionPage
} MMLISTS;

#define MM_FREE_WSLE_SHIFT 4

#define WSLE_NULL_INDEX ((ULONG64)0xFFFFFFFFFFFFFFFUI64)

#define GRAN_BYTE   0
#define GRAN_PAGE   1

///////////////////////////////////////////////////////////////////////////////
//
// ob.h
//
///////////////////////////////////////////////////////////////////////////////
#define OB_FLAG_NEW_OBJECT              0x01
#define OB_FLAG_KERNEL_OBJECT           0x02
#define OB_FLAG_CREATOR_INFO            0x04
#define OB_FLAG_EXCLUSIVE_OBJECT        0x08
#define OB_FLAG_PERMANENT_OBJECT        0x10
#define OB_FLAG_DEFAULT_SECURITY_QUOTA  0x20
#define OB_FLAG_SINGLE_HANDLE_ENTRY     0x40


///////////////////////////////////////////////////////////////////////////////
//
// openhci.h
//
///////////////////////////////////////////////////////////////////////////////


//values for HcFlags
#define HC_FLAG_REMOTE_WAKEUP_CONNECTED     0x00000001
#define HC_FLAG_LEGACY_BIOS_DETECTED        0x00000002
#define HC_FLAG_SLOW_BULK_ENABLE            0x00000004
#define HC_FLAG_SHUTDOWN                    0x00000008  // not really used
#define HC_FLAG_MAP_SX_TO_D3                0x00000010
#define HC_FLAG_IDLE                        0x00000020
#define HC_FLAG_DISABLE_IDLE_CHECK          0x00000040
#define HC_FLAG_DEVICE_STARTED              0x00000080
#define HC_FLAG_LOST_POWER                  0x00000100
#define HC_FLAG_DISABLE_IDLE_MODE           0x00000200
#define HC_FLAG_USE_HYDRA_HACK              0x00000400
#define HC_FLAG_IN_DPC                      0x00000800
#define HC_FLAG_SUSPEND_NEXT_D3             0x00001000
#define HC_FLAG_LIST_FIX_ENABLE             0x00002000
#define HC_FLAG_HUNG_CHECK_ENABLE           0x00004000

#define PENDING_TD_LIST_SIZE                1000

#define HcCtrl_CBSR_MASK                     0x00000003L
#define HcCtrl_CBSR_1_to_1                   0x00000000L
#define HcCtrl_CBSR_2_to_1                   0x00000001L
#define HcCtrl_CBSR_3_to_1                   0x00000002L
#define HcCtrl_CBSR_4_to_1                   0x00000003L
#define HcCtrl_PeriodicListEnable            0x00000004L
#define HcCtrl_IsochronousEnable             0x00000008L
#define HcCtrl_ControlListEnable             0x00000010L
#define HcCtrl_BulkListEnable                0x00000020L
#define HcCtrl_ListEnableMask                0x00000038L

#define HcCtrl_HCFS_MASK                     0x000000C0L
#define HcCtrl_HCFS_USBReset                 0x00000000L
#define HcCtrl_HCFS_USBResume                0x00000040L
#define HcCtrl_HCFS_USBOperational           0x00000080L
#define HcCtrl_HCFS_USBSuspend               0x000000C0L

#define HcCtrl_InterruptRouting              0x00000100L
#define HcCtrl_RemoteWakeupConnected         0x00000200L
#define HcCtrl_RemoteWakeupEnable            0x00000400L

#define HcHCFS_USBReset                      0x00000000
#define HcHCFS_USBResume                     0x00000001
#define HcHCFS_USBOperational                0x00000002
#define HcHCFS_USBSuspend                    0x00000003

#define HcCmd_HostControllerReset            0x00000001
#define HcCmd_ControlListFilled              0x00000002
#define HcCmd_BulkListFilled                 0x00000004
#define HcCmd_OwnershipChangeRequest         0x00000008
#define HcCmd_SOC_Mask                       0x00030000
#define HcCmd_SOC_Offset                     16
#define HcCmd_SOC_Mask_LowBits               0x00000003

//
// Definitions for HC_ENDPOINT_CONTROL.Direction
//
#define HcEDDirection_Defer   0           // Defer direction to TD (Control Endpoints)
#define HcEDDirection_Out     1           // Direction from host to device
#define HcEDDirection_In      2           // Direction from device to host


//
// The different ED lists are as follows.
//
#define  ED_INTERRUPT_1ms        0
#define  ED_INTERRUPT_2ms        1
#define  ED_INTERRUPT_4ms        3
#define  ED_INTERRUPT_8ms        7
#define  ED_INTERRUPT_16ms       15
#define  ED_INTERRUPT_32ms       31
#define  ED_CONTROL              63
#define  ED_BULK                 64
#define  ED_ISOCHRONOUS          0     // same as 1ms interrupt queue
#define  NO_ED_LISTS             65
#define  ED_EOF                  0xff

//
// 7.1.4 HcInterrruptStatus Register
// 7.1.5 HcInterruptEnable  Register
// 7.1.6 HcInterruptDisable Register
//
#define HcInt_SchedulingOverrun              0x00000001L
#define HcInt_WritebackDoneHead              0x00000002L
#define HcInt_StartOfFrame                   0x00000004L
#define HcInt_ResumeDetected                 0x00000008L
#define HcInt_UnrecoverableError             0x00000010L
#define HcInt_FrameNumberOverflow            0x00000020L
#define HcInt_RootHubStatusChange            0x00000040L
#define HcInt_OwnershipChange                0x40000000L
#define HcInt_MasterInterruptEnable          0x80000000L

//
// 7.4.3 HcRhStatus Register
//
#define HcRhS_LocalPowerStatus                  0x00000001  // read only
#define HcRhS_OverCurrentIndicator              0x00000002  // read only
#define HcRhS_DeviceRemoteWakeupEnable          0x00008000  // read only
#define HcRhS_LocalPowerStatusChange            0x00010000  // read only
#define HcRhS_OverCurrentIndicatorChange        0x00020000  // read only

#define HcRhS_ClearGlobalPower                  0x00000001  // write only
#define HcRhS_SetRemoteWakeupEnable             0x00008000  // write only
#define HcRhS_SetGlobalPower                    0x00010000  // write only
#define HcRhS_ClearOverCurrentIndicatorChange   0x00020000  // write only
#define HcRhS_ClearRemoteWakeupEnable           0x80000000  // write only

//
// 7.4.4 HcRhPortStatus Register
//
#define HcRhPS_CurrentConnectStatus          0x00000001  // read only
#define HcRhPS_PortEnableStatus              0x00000002  // read only
#define HcRhPS_PortSuspendStatus             0x00000004  // read only
#define HcRhPS_PortOverCurrentIndicator      0x00000008  // read only
#define HcRhPS_PortResetStatus               0x00000010  // read only
#define HcRhPS_PortPowerStatus               0x00000100  // read only
#define HcRhPS_LowSpeedDeviceAttached        0x00000200  // read only
#define HcRhPS_ConnectStatusChange           0x00010000  // read only
#define HcRhPS_PortEnableStatusChange        0x00020000  // read only
#define HcRhPS_PortSuspendStatusChange       0x00040000  // read only
#define HcRhPS_OverCurrentIndicatorChange    0x00080000  // read only
#define HcRhPS_PortResetStatusChange         0x00100000  // read only

#define HcRhPS_ClearPortEnable               0x00000001  // write only
#define HcRhPS_SetPortEnable                 0x00000002  // write only
#define HcRhPS_SetPortSuspend                0x00000004  // write only
#define HcRhPS_ClearPortSuspend              0x00000008  // write only
#define HcRhPS_SetPortReset                  0x00000010  // write only
#define HcRhPS_SetPortPower                  0x00000100  // write only
#define HcRhPS_ClearPortPower                0x00000200  // write only
#define HcRhPS_ClearConnectStatusChange      0x00010000  // write only
#define HcRhPS_ClearPortEnableStatusChange   0x00020000  // write only
#define HcRhPS_ClearPortSuspendStatusChange  0x00040000  // write only
#define HcRhPS_ClearPortOverCurrentChange    0x00080000  // write only
#define HcRhPS_ClearPortResetStatusChange    0x00100000  // write only

#define HcRhPS_RESERVED     (~(HcRhPS_CurrentConnectStatus       | \
                               HcRhPS_PortEnableStatus           | \
                               HcRhPS_PortSuspendStatus          | \
                               HcRhPS_PortOverCurrentIndicator   | \
                               HcRhPS_PortResetStatus            | \
                               HcRhPS_PortPowerStatus            | \
                               HcRhPS_LowSpeedDeviceAttached     | \
                               HcRhPS_ConnectStatusChange        | \
                               HcRhPS_PortEnableStatusChange     | \
                               HcRhPS_PortSuspendStatusChange    | \
                               HcRhPS_OverCurrentIndicatorChange | \
                               HcRhPS_PortResetStatusChange        \
                            ))


//
// Definitions for HC_TRANSFER_CONTROL.Control
//
#define HcTDControl_STARTING_FRAME        0x0000FFFF  // mask for starting frame (Isochronous)
#define HcTDControl_ISOCHRONOUS           0x00010000  // 1 for Isoch TD, 0 for General TD
#define HcTDControl_SHORT_XFER_OK         0x00040000  // 0 if short transfers are errors
#define HcTDControl_DIR_MASK              0x00180000  // Transfer direction field
#define HcTDControl_DIR_SETUP             0x00000000  // direction is setup packet from host to device
#define HcTDControl_DIR_OUT               0x00080000  // direction is from host to device
#define HcTDControl_DIR_IN                0x00100000  // direction is from device to host
#define HcTDControl_INT_DELAY_MASK        0x00E00000  // Interrupt Delay field
#define HcTDControl_INT_DELAY_0_MS        0x00000000  // Interrupt at end of frame TD is completed
#define HcTDControl_INT_DELAY_1_MS        0x00200000  // Interrupt no later than end of 1st frame after TD is completed
#define HcTDControl_INT_DELAY_2_MS        0x00400000  // Interrupt no later than end of 2nd frame after TD is completed
#define HcTDControl_INT_DELAY_3_MS        0x00600000  // Interrupt no later than end of 3rd frame after TD is completed
#define HcTDControl_INT_DELAY_4_MS        0x00800000  // Interrupt no later than end of 4th frame after TD is completed
#define HcTDControl_INT_DELAY_5_MS        0x00A00000  // Interrupt no later than end of 5th frame after TD is completed
#define HcTDControl_INT_DELAY_6_MS        0x00C00000  // Interrupt no later than end of 6th frame after TD is completed

#ifdef NSC
#define HcTDControl_INT_DELAY_NO_INT      0x00C00000  // Almost infinity but not yet quite.
#elif DISABLE_INT_DELAY_NO_INT
#define   HcTDControl_INT_DELAY_NO_INT      0x00000000  // Interrupt at the completion of all packets.
#else
#define HcTDControl_INT_DELAY_NO_INT      0x00E00000  // Do not cause an interrupt for normal completion of this TD
#endif

#define HcTDControl_FRAME_COUNT_MASK      0x07000000  // mask for FrameCount field (Isochronous)
#define HcTDControl_FRAME_COUNT_SHIFT     24          // shift count for FrameCount (Isochronous)
#define HcTDControl_FRAME_COUNT_MAX       8           // Max number of for frame count per TD
#define HcTDControl_TOGGLE_MASK           0x03000000  // mask for Toggle control field
#define HcTDControl_TOGGLE_FROM_ED        0x00000000  // get data toggle from CARRY field of ED
#define HcTDControl_TOGGLE_DATA0          0x02000000  // use DATA0 for data PID
#define HcTDControl_TOGGLE_DATA1          0x03000000  // use DATA1 for data PID
#define HcTDControl_ERROR_COUNT           0x0C000000  // mask for Error Count field
#define HcTDControl_CONDITION_CODE_MASK   0xF0000000  // mask for ConditionCode field
#define HcTDControl_CONDITION_CODE_SHIFT  28          // shift count for ConditionCode

//
// Definitions for HC_TRANSFER_CONTROL.Direction
//
#define HcTDDirection_Setup               0           // setup packet from host to device
#define HcTDDirection_Out                 1           // direction from host to device
#define HcTDDirection_In                  2           // direction from device to host

//
// Definitions for Hc_TRANSFER_CONTROL.IntDelay
//
#define HcTDIntDelay_0ms                  0           // interrupt at end of frame TD is completed
#define HcTDIntDelay_1ms                  1           // Interrupt no later than end of 1st frame after TD is completed
#define HcTDIntDelay_2ms                  2           // Interrupt no later than end of 2nd frame after TD is completed
#define HcTDIntDelay_3ms                  3           // Interrupt no later than end of 3rd frame after TD is completed
#define HcTDIntDelay_4ms                  4           // Interrupt no later than end of 4th frame after TD is completed
#define HcTDIntDelay_5ms                  5           // Interrupt no later than end of 5th frame after TD is completed
#define HcTDIntDelay_6ms                  6           // Interrupt no later than end of 6th frame after TD is completed
#define HcTDIntDelay_NoInterrupt          7           // do not generate interrupt for normal completion of this TD

//
// Definitions for HC_TRANSFER_CONTROL.Toggle
//
#define HcTDToggle_FromEd                 0           // get toggle for Endpoint Descriptor toggle CARRY bit
#define HcTDToggle_Data0                  2           // use Data0 PID
#define HcTDToggle_Data1                  3           // use Data1 PID

//
// Definitions for HC_TRANSFER_CONTROL.ConditionCode and HC_OFFSET_PSW.ConditionCode
//
#define HcCC_NoError                      0x0UL
#define HcCC_CRC                          0x1UL
#define HcCC_BitStuffing                  0x2UL
#define HcCC_DataToggleMismatch           0x3UL
#define HcCC_Stall                        0x4UL
#define HcCC_DeviceNotResponding          0x5UL
#define HcCC_PIDCheckFailure              0x6UL
#define HcCC_UnexpectedPID                0x7UL
#define HcCC_DataOverrun                  0x8UL
#define HcCC_DataUnderrun                 0x9UL
      //                                  0xA         // reserved
      //                                  0xB         // reserved
#define HcCC_BufferOverrun                0xCUL
#define HcCC_BufferUnderrun               0xDUL
#define HcCC_NotAccessed                  0xEUL

///////////////////////////////////////////////////////////////////////////////
//
// pci.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Note - State.c depends on the order of these.
//
typedef enum {
    PciNotStarted = 0,
    PciStarted,
    PciDeleted,
    PciStopped,
    PciSurpriseRemoved,
    PciSynchronizedOperation,
    PciMaxObjectState
} PCI_OBJECT_STATE;

//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5


///////////////////////////////////////////////////////////////////////////////
//
// pcmcia.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Flags indicating card/controller state
//
#define PCMCIA_DEVICE_STARTED                  0x00000001
#define PCMCIA_DEVICE_LOGICALLY_REMOVED        0x00000002
#define PCMCIA_DEVICE_PHYSICALLY_REMOVED       0x00000004
#define PCMCIA_DEVICE_MULTIFUNCTION            0x00000008
#define PCMCIA_DEVICE_WAKE_PENDING             0x00000010
#define PCMCIA_DEVICE_LEGACY_DETECTED          0x00000020
#define PCMCIA_DEVICE_DELETED                  0x00000040
#define PCMCIA_DEVICE_CARDBUS                  0x00000080
#define PCMCIA_FILTER_ADDED_MEMORY             0x00000100
#define PCMCIA_MEMORY_24BIT                    0x00000200
#define PCMCIA_CARDBUS_NOT_SUPPORTED           0x00000400
#define PCMCIA_USE_POLLED_CSC                  0x00000800
#define PCMCIA_ATTRIBUTE_MEMORY_MAPPED         0x00001000
#define PCMCIA_SOCKET_REGISTER_BASE_MAPPED     0x00002000
#define PCMCIA_INTMODE_COMPAQ                  0x00004000
#define PCMCIA_POWER_WORKER_POWERUP            0x00008000
#define PCMCIA_SOCKET_POWER_REQUESTED          0x00010000
#define PCMCIA_CONFIG_STATUS_DEFERRED          0x00020000
#define PCMCIA_POWER_STATUS_DEFERRED           0x00040000
#define PCMCIA_INT_ROUTE_INTERFACE             0x00080000
#define PCMCIA_FDO_CONTEXT_SAVED               0x00100000
#define PCMCIA_FDO_DEFAULT_IRQ_MASK            0x00200000


//
// Socket flags
//
#define SOCKET_CARD_IN_SOCKET          0x00000001
#define SOCKET_CARD_INITIALIZED        0x00000002
#define SOCKET_CARD_POWERED_UP         0x00000004
#define SOCKET_CARD_CONFIGURED         0x00000008
#define SOCKET_CARD_MULTIFUNCTION      0x00000010
#define SOCKET_CARD_CARDBUS            0x00000020
#define SOCKET_CARD_MEMORY             0x00000040
#define SOCKET_CHANGE_INTERRUPT        0x00000080
#define SOCKET_CUSTOM_INTERFACE        0x00000100
#define SOCKET_INSERTED_SOUND_PENDING  0x00000200
#define SOCKET_REMOVED_SOUND_PENDING   0x00000400
#define SOCKET_SUPPORT_MESSAGE_SENT    0x00000800
#define SOCKET_MEMORY_WINDOW_ENABLED   0x00001000
#define SOCKET_CARD_STATUS_CHANGE      0x00002000
#define SOCKET_POWER_STATUS_DEFERRED   0x00004000

//
// Worker states for socket power operations
//
#define SPW_Stopped                 0
#define SPW_Exit                    1
#define SPW_RequestPower            2
#define SPW_ReleasePower            3
#define SPW_SetPowerOn              4
#define SPW_SetPowerOff             5
#define SPW_ParentPowerUp           6
#define SPW_ParentPowerUpComplete   7


//
// Controller classes returned in socket information structure.
//

typedef enum _PCMCIA_CONTROLLER_CLASS {
   PcmciaInvalidControllerClass = -1,
   PcmciaIntelCompatible,
   PcmciaCardBusCompatible,
   PcmciaElcController,
   PcmciaDatabook,
   PcmciaPciPcmciaBridge,
   PcmciaCirrusLogic,
   PcmciaTI,
   PcmciaTopic,
   PcmciaRicoh,
   PcmciaDatabookCB,
   PcmciaOpti,
   PcmciaTrid,
   PcmciaO2Micro,
   PcmciaNEC,
   PcmciaNEC_98
} PCMCIA_CONTROLLER_CLASS, *PPCMCIA_CONTROLLER_CLASS;
#define PcmciaInvalidControllerType 0xffffffff
#define PCMCIA_INVALID_CONFIGURATION    0x00000001
// Max length of device id
#define PCMCIA_MAXIMUM_DEVICE_ID_LENGTH   128


//
// states for PdoPowerWorker
//
#define PPW_Stopped           0
#define PPW_Exit              1
#define PPW_InitialState      2
#define PPW_PowerUp           3
#define PPW_PowerUpComplete   4
#define PPW_PowerDown         5
#define PPW_PowerDownComplete 6
#define PPW_SendIrpDown       7
#define PPW_16BitConfigure    8
#define PPW_Deconfigure       9
#define PPW_VerifyCard        10
#define PPW_CardBusRefresh    11
#define PPW_CardBusDelay      12
//
// phases for ConfigurationWorker
//
// Note that the ConfigurationPhase is simply incremented, these
// definitions are just for clarity.
//
#define CW_Stopped            0
#define CW_Phase1             1
#define CW_Phase2             2
#define CW_Phase3             3
#define CW_Exit               4


///////////////////////////////////////////////////////////////////////////////
//
// pcmp.inc
//
///////////////////////////////////////////////////////////////////////////////

//
//  IMCR (Interrupt Mode Control Register) access definitions
//
#define ImcrDisableApic         0x00
#define ImcrEnableApic          0x01
#define ImcrRegPortAddr         0x22
#if defined(NEC_98)
#define ImcrDataPortAddr        0x700
#else  // defined(NEC_98)
#define ImcrDataPortAddr        0x23
#endif // defined(NEC_98)
#define ImcrPort                0x70

// Physical location where the Extended BIOS Data Area segment adress is store
#define EBDA_SEGMENT_PTR    0x40e
#define BASE_MEM_PTR        0x413

//
//  The PC+MP configuration table Possible Entry Types
//
#define ENTRY_PROCESSOR     0
#define ENTRY_BUS           1
#define ENTRY_IOAPIC        2
#define ENTRY_INTI          3
#define ENTRY_LINTI         4

#define HEADER_SIZE     0x2c


// Number of default configurations for PC+MP version 1.1
#define NUM_DEFAULT_CONFIGS  7

//
// Bits used in the CpuFlags field of the Processor entry
//
#define CPU_DISABLED        0x0   // 1 Bit  - CPU Disabled
#define CPU_ENABLED         0x1   // 1 Bit  - CPU Enabled
#define BSP_CPU             0x2   // Bit #2 - CPU is BSP

//  APIC Versions used by PC+MP systems - this is used in the
//  Processor entries and the IoApic Entries
//
#define APIC_INTEGRATED     0x10  // 8 Bits-Apic Version Register
#define APIC_82489DX        0x0   // 8 Bits-Apic Version Register

//
//  Io Apic Entry definitions
//
//  Valid IoApicFlag values
//
#define IO_APIC_ENABLED         0x1
#define IO_APIC_DISABLED        0x0


//
// Default value for Io Apic ID.
//
#define IOUNIT_APIC_ID          0xE


//
//  PC+MP Signature used to verify the PC+MP table
//  as valid
//
//          "P"=50H,"C"=43H,"M"=4dH,"P"=50H
//
#define PCMP_SIGNATURE      0x504d4350

//
//  PC+MP Signature used to identify the floating pointer
//  structure (in extended BIOS data segment) that contains
//  a pointer to the PC+MP table.
//
//          "_"=5fH, "M"=4dH, "P"=50H, "_"=5fH
//
#define MP_PTR_SIGNATURE    0x5f504d5f


//
// Extension table definitions
//

#define EXTTYPE_BUS_ADDRESS_MAP           128
#define EXTTYPE_BUS_HIERARCHY             129
#define EXTTYPE_BUS_COMPATIBLE_MAP        130
#define EXTTYPE_PERSISTENT_STORE          131


#define MPS_ADDRESS_MAP_IO                  0
#define MPS_ADDRESS_MAP_MEMORY              1
#define MPS_ADDRESS_MAP_PREFETCH_MEMORY     2
#define MPS_ADDRESS_MAP_UNDEFINED           9

//
//  The System configuration table as used by a PC_MP system
//
//
// The offset is relative to the BIOS starting at f0000H
//
#define PTR_OFFSET          0x0000e6f5
#define BIOS_BASE           0x000f0000

#define PCMP_IMPLEMENTED    0x01    // In MpFeatureInfoByte1
#define PCMP_CONFIG_MASK    0x0e    // In MpFeatureInfoByte1
#define IMCR_MASK           0x80    // In MpFeatureInfoByte2
#define MULT_CLOCKS_MASK    0x40    // In MpFeatureInfoByte2


///////////////////////////////////////////////////////////////////////////////
//
// pnpiop.h
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _PNP_DEVNODE_STATE {
    DeviceNodeUnspecified       = 0x300, // 768
    DeviceNodeUninitialized,             // 769
    DeviceNodeInitialized,               // 770
    DeviceNodeDriversAdded,              // 771
    DeviceNodeResourcesAssigned,         // 772 - Operational state for Added
    DeviceNodeStartPending,              // 773 - Operational state for Added
    DeviceNodeStartCompletion,           // 774 - Operational state for Added
    DeviceNodeStartPostWork,             // 775 - Operational state for Added
    DeviceNodeStarted,                   // 776
    DeviceNodeQueryStopped,              // 777
    DeviceNodeStopped,                   // 778
    DeviceNodeRestartCompletion,         // 779 - Operational state for Stopped
    DeviceNodeEnumeratePending,          // 780 - Operational state for Started
    DeviceNodeEnumerateCompletion,       // 781 - Operational state for Started
    DeviceNodeAwaitingQueuedDeletion,    // 782
    DeviceNodeAwaitingQueuedRemoval,     // 783
    DeviceNodeQueryRemoved,              // 784
    DeviceNodeRemovePendingCloses,       // 785
    DeviceNodeRemoved,                   // 786
    DeviceNodeDeletePendingCloses,       // 787
    DeviceNodeDeleted                    // 788
}   PNP_DEVNODE_STATE, *PPNP_DEVNODE_STATE;

#define STATE_HISTORY_SIZE  20

//
// DNF_MAKEUP - this devnode's device is created and owned by PnP manager
//

#define DNF_MADEUP                                  0x00000001

//
// DNF_DUPLICATE - this devnode's device is a duplicate of another enumerate PDO
//

#define DNF_DUPLICATE                               0x00000002

//
// DNF_HAL_NODE - a flag to indicate which device node is the root node created by
// the hal
//

#define DNF_HAL_NODE                                0x00000004

//
// DNF_REENUMERATE - needs to be reenumerated
//

#define DNF_REENUMERATE                             0x00000008

//
// DNF_ENUMERATED - used to track enumeration in IopEnumerateDevice()
//

#define DNF_ENUMERATED                              0x00000010

//
// Singal that we need to send driver query id irps
//

#define DNF_IDS_QUERIED                             0x00000020

//
// DNF_HAS_BOOT_CONFIG - the device has resource assigned by BIOS.  It is considered
//    pseudo-started and need to participate in rebalance.
//

#define DNF_HAS_BOOT_CONFIG                         0x00000040

//
// DNF_BOOT_CONFIG_RESERVED - Indicates the BOOT resources of the device are reserved.
//

#define DNF_BOOT_CONFIG_RESERVED                    0x00000080

//
// DNF_NO_RESOURCE_REQUIRED - this devnode's device does not require resource.
//

#define DNF_NO_RESOURCE_REQUIRED                    0x00000100

//
// DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED - to distinguished the
//      DeviceNode->ResourceRequirements is a filtered list or not.
//

#define DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED     0x00000200

//
// DNF_RESOURCE_REQUIREMENTS_CHANGED - Indicates the device's resource
//      requirements list has been changed.
//

#define DNF_RESOURCE_REQUIREMENTS_CHANGED           0x00000400

//
// DNF_NON_STOPPED_REBALANC - indicates the device can be restarted with new
//      resources without being stopped.
//

#define DNF_NON_STOPPED_REBALANCE                   0x00000800

//
// The device's controlling driver is a legacy driver
//

#define DNF_LEGACY_DRIVER                           0x00001000

//
// This corresponds to the user-mode CM_PROB_WILL_BE_REMOVED problem value and
// the DN_WILL_BE_REMOVED status flag.
//

#define DNF_HAS_PROBLEM                             0x00002000

//
// DNF_HAS_PRIVATE_PROBLEM - indicates this device reported PNP_DEVICE_FAILED
//  to a IRP_MN_QUERY_PNP_DEVICE_STATE without also reporting
//  PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED.
//

#define DNF_HAS_PRIVATE_PROBLEM                     0x00004000

//
// DNF_HARDWARE_VERIFICATION is set on device nodes that have hardware
// verification (probably via WHQL applet).
//

#define DNF_HARDWARE_VERIFICATION                   0x00008000

//
// DNF_DEVICE_GONE is set when a pdo is no longer returned in a query bus
// relations.  It will then be processed as a surprise remove if started.
// This flag is used to better detect when a device is resurrected, and when
// processing surprise remove, to determine if the devnode should be removed
// from the tree.
//

#define DNF_DEVICE_GONE                             0x00010000

//
// DNF_LEGACY_RESOURCE_DEVICENODE is set for device nodes created for legacy
// resource allocation.
//

#define DNF_LEGACY_RESOURCE_DEVICENODE              0x00020000

//
// DNF_NEEDS_REBALANCE is set for device nodes that trigger rebalance.
//

#define DNF_NEEDS_REBALANCE                         0x00040000

//
// DNF_LOCKED_FOR_EJECT is set on device nodes that are being ejected or are
// related to a device being ejected.
//

#define DNF_LOCKED_FOR_EJECT                        0x00080000

//
// DNF_DRIVER_BLOCKED is set on device nodes that use one or more drivers that
// have been blocked from loading.
//

#define DNF_DRIVER_BLOCKED                          0x00100000

//
// This corresponds to the user-mode the DN_WILL_BE_REMOVED status flag.
//

#define DNUF_WILL_BE_REMOVED                        0x00000001

//
// This corresponds to the user-mode DN_NO_SHOW_IN_DM status flag.
//

#define DNUF_DONT_SHOW_IN_UI                        0x00000002

//
// This flag is set when user-mode lets us know that a reboot is required
// for this device.
//

#define DNUF_NEED_RESTART                           0x00000004

//
// This flag is set to let the user-mode know when a device can be disabled
// it is still possible for this to be TRUE, yet disable to fail, as it's
// a polled flag (see also PNP_DEVICE_NOT_DISABLEABLE)
//

#define DNUF_NOT_DISABLEABLE                        0x00000008

//
// Flags used during shutdown when the IO Verifier is trying to remove all
// PNP devices.
//
// DNUF_SHUTDOWN_QUERIED is set when we issue the QueryRemove to a devnode.
//
// DNUF_SHUTDOWN_SUBTREE_DONE is set once we've issued the QueryRemove to all
// a Devnodes descendants.
//
#define DNUF_SHUTDOWN_QUERIED                       0x00000010
#define DNUF_SHUTDOWN_SUBTREE_DONE                  0x00000020


//
// IOP_RESOURCE_REQUEST
//

#define QUERY_RESOURCE_LIST                0
#define QUERY_RESOURCE_REQUIREMENTS        1

#define REGISTRY_ALLOC_CONFIG              1
#define REGISTRY_FORCED_CONFIG             2
#define REGISTRY_BOOT_CONFIG               4
#define REGISTRY_OVERRIDE_CONFIGVECTOR     1
#define REGISTRY_BASIC_CONFIGVECTOR        2

///////////////////////////////////////////////////////////////////////////////
//
// pnpmgr.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Private device events
//
DEFINE_GUID( GUID_DEVICE_ARRIVAL,           0xcb3a4009L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_ENUMERATED,        0xcb3a400AL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_ENUMERATE_REQUEST, 0xcb3a400BL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_START_REQUEST,     0xcb3a400CL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_REMOVE_PENDING,    0xcb3a400DL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_QUERY_AND_REMOVE,  0xcb3a400EL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_EJECT,             0xcb3a400FL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_NOOP,              0xcb3a4010L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_SURPRISE_REMOVAL,  0xce5af000L, 0x80dd, 0x11d2, 0xa8, 0x8d, 0x00, 0xa0, 0xc9, 0x69, 0x6b, 0x4b);

//
// Private driver events
//
DEFINE_GUID( GUID_DRIVER_BLOCKED,           0x1bc87a21L, 0xa3ff, 0x47a6, 0x96, 0xaa, 0x6d, 0x01, 0x09, 0x06, 0x80, 0x5a);

//
// Standard interface device classes
//
DEFINE_GUID( GUID_CLASS_VOLUME,  0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x72);
DEFINE_GUID( GUID_CLASS_LPTPORT, 0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x74);
DEFINE_GUID( GUID_CLASS_NET,     0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x75);


///////////////////////////////////////////////////////////////////////////////
//
// po.h
//
///////////////////////////////////////////////////////////////////////////////


#define PO_ORDER_NOT_VIDEO          0x0001
#define PO_ORDER_ROOT_ENUM          0x0002
#define PO_ORDER_PAGABLE            0x0004
#define PO_ORDER_MAXIMUM            0x0007

// notify GDI before this order level
#define PO_ORDER_GDI_NOTIFICATION   (PO_ORDER_PAGABLE)


///////////////////////////////////////////////////////////////////////////////
//
// pop.h
//
///////////////////////////////////////////////////////////////////////////////

//
// constants
//
#define PO_IDLE_SCAN_INTERVAL  1       // scan interval in seconds

//
// Values for ios.Parameters.SystemContext
#define POP_NO_CONTEXT      0
#define POP_FLAG_CONTEXT    1                         // if true, it's flags
#define POP_DEVICE_REQUEST  (0x2 | POP_FLAG_CONTEXT)  // an irp sent by RequestPowerChange
#define POP_INRUSH_CONTEXT  (0x4 | POP_FLAG_CONTEXT)  // the active INRUSH irp
#define POP_COUNT_CONTEXT   0xff000000                // byte used for next counting
#define POP_COUNT_SHIFT     24


#define PO_ERROR            0x00000001
#define PO_WARN             0x00000002
#define PO_BATT             0x00000004
#define PO_PACT             0x00000008
#define PO_NOTIFY           0x00000010
#define PO_THERM            0x00000020
#define PO_THROTTLE         0x00000040
#define PO_HIBERNATE        0x00000080
#define PO_POCALL           0x00000200
#define PO_SYSDEV           0x00000400
#define PO_THERM_DETAIL     0x20000000
#define PO_SIDLE            0x40000000
#define PO_HIBER_MAP        0x80000000

#define POP_SIM_CAPABILITIES                0x00000001
#define POP_SIM_ALL_CAPABILITIES            0x00000002
#define POP_ALLOW_AC_THROTTLE               0x00000004
#define POP_IGNORE_S1                       0x00000008
#define POP_IGNORE_UNSUPPORTED_DRIVERS      0x00000010
#define POP_IGNORE_S3                       0x00000020
#define POP_IGNORE_S2                       0x00000040
#define POP_LOOP_ON_FAILED_DRIVERS          0x00000080
#define POP_CRC_MEMORY                      0x00000100
#define POP_IGNORE_CRC_FAILURES             0x00000200
#define POP_TEST_CRC_MEMORY                 0x00000400
#define POP_DEBUG_HIBER_FILE                0x00000800
#define POP_RESET_ON_HIBER                  0x00001000
#define POP_IGNORE_S4                       0x00002000
#define POP_USE_S4BIOS                      0x00004000
#define POP_IGNORE_HIBER_SYMBOL_UNLOAD      0x00008000
#define POP_ENABLE_HIBER_PERF               0x00010000

//
// Universal Power Data - stored in DeviceObject->DeviceObjectExtension->PowerFlags
//

#define POPF_SYSTEM_STATE       0xf         // 4 bits for S0 to S5
#define POPF_DEVICE_STATE       0xf0        // 4 bits to hold D0 to D3


#define POPF_SYSTEM_ACTIVE      0x100       // True if S irp active at this DO
#define POPF_SYSTEM_PENDING     0x200       // True if S irp pending (0x100 must be 1)
#define POPF_DEVICE_ACTIVE      0x400       // same as SYSTEM_ACTIVE but for DEVICE
#define POPF_DEVICE_PENDING     0x800       // same as SYSTEM_PENDING but for DEVICE


#define PO_PM_USER              0x01    // nice to inform user mode, but not needed
#define PO_PM_REISSUE           0x02    // sleep promotoed to shutdown
#define PO_PM_SETSTATE          0x04    // recomputed something to do with the viable state

#define PO_ACT_IDLE                 0
#define PO_ACT_NEW_REQUEST          1
#define PO_ACT_CALLOUT              2
#define PO_ACT_SET_SYSTEM_STATE     3


//
// Types for POP_ACTION_TRIGGER
//

typedef enum {
    PolicyDeviceSystemButton,
    PolicyDeviceThermalZone,
    PolicyDeviceBattery,
    PolicyInitiatePowerActionAPI,
    PolicySetPowerStateAPI,
    PolicyImmediateDozeS4,
    PolicySystemIdle
} POP_POLICY_DEVICE_TYPE;

#define PO_TRG_USER             0x01    // User action initiated
#define PO_TRG_SYSTEM           0x02    // System action initiated
#define PO_TRG_SYNC             0x20    // Trigger is synchronous
#define PO_TRG_SET              0x80    // Event enabled or disabled

// POP_THERMAL_ZONE.State
#define PO_TZ_NO_STATE      0
#define PO_TZ_READ_STATE    1
#define PO_TZ_SET_MODE      2
#define PO_TZ_SET_ACTIVE    3

// POP_THERMAL_ZONE.Flags
#define PO_TZ_THROTTLING    0x01
#define PO_TZ_CLEANUP       0x80

#define PO_TZ_THROTTLE_SCALE    10      // temp reported in 1/10ths kelin
#define PO_TZ_NO_THROTTLE   (100 * PO_TZ_THROTTLE_SCALE)

// PopCoolingMode
#define PO_TZ_ACTIVE        0
#define PO_TZ_PASSIVE       1
#define PO_TZ_INVALID_MODE  2

//
// Action timeouts
//

#define POP_ACTION_TIMEOUT              30
#define POP_ACTION_CANCEL_TIMEOUT       5


///////////////////////////////////////////////////////////////////////////////
//
// pool.h
//
///////////////////////////////////////////////////////////////////////////////


#define POOL_QUOTA_MASK 8

#define POOL_TYPE_MASK (3)

#define POOL_OVERHEAD ((LONG)GetTypeSize("POOL_HEADER"))


//
// Define pool tracking information.
//

#define POOL_BACKTRACEINDEX_PRESENT 0x8000

///////////////////////////////////////////////////////////////////////////////
//
// range.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Range list structures
//

#define RTLP_RANGE_LIST_ENTRY_MERGED         0x0001

///////////////////////////////////////////////////////////////////////////////
//
// srb.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Port driver error codes
//

#define SP_BUS_PARITY_ERROR         0x0001
#define SP_UNEXPECTED_DISCONNECT    0x0002
#define SP_INVALID_RESELECTION      0x0003
#define SP_BUS_TIME_OUT             0x0004
#define SP_PROTOCOL_ERROR           0x0005
#define SP_INTERNAL_ADAPTER_ERROR   0x0006
#define SP_REQUEST_TIMEOUT          0x0007
#define SP_IRQ_NOT_RESPONDING       0x0008
#define SP_BAD_FW_WARNING           0x0009
#define SP_BAD_FW_ERROR             0x000a
#define SP_LOST_WMI_MINIPORT_REQUEST 0x000b


//
// Return values for SCSI_HW_FIND_ADAPTER.
//

#define SP_RETURN_NOT_FOUND     0
#define SP_RETURN_FOUND         1
#define SP_RETURN_ERROR         2
#define SP_RETURN_BAD_CONFIG    3

//
// Notification Event Types
//

typedef enum _SCSI_NOTIFICATION_TYPE {
    RequestComplete,
    NextRequest,
    NextLuRequest,
    ResetDetected,
    CallDisableInterrupts,
    CallEnableInterrupts,
    RequestTimerCall,
    BusChangeDetected,     /* New */
    WMIEvent,
    WMIReregister
} SCSI_NOTIFICATION_TYPE, *PSCSI_NOTIFICATION_TYPE;

//
// SRB Functions
//

#define SRB_FUNCTION_EXECUTE_SCSI           0x00
#define SRB_FUNCTION_CLAIM_DEVICE           0x01
#define SRB_FUNCTION_IO_CONTROL             0x02
#define SRB_FUNCTION_RECEIVE_EVENT          0x03
#define SRB_FUNCTION_RELEASE_QUEUE          0x04
#define SRB_FUNCTION_ATTACH_DEVICE          0x05
#define SRB_FUNCTION_RELEASE_DEVICE         0x06
#define SRB_FUNCTION_SHUTDOWN               0x07
#define SRB_FUNCTION_FLUSH                  0x08
#define SRB_FUNCTION_ABORT_COMMAND          0x10
#define SRB_FUNCTION_RELEASE_RECOVERY       0x11
#define SRB_FUNCTION_RESET_BUS              0x12
#define SRB_FUNCTION_RESET_DEVICE           0x13
#define SRB_FUNCTION_TERMINATE_IO           0x14
#define SRB_FUNCTION_FLUSH_QUEUE            0x15
#define SRB_FUNCTION_REMOVE_DEVICE          0x16
#define SRB_FUNCTION_WMI                    0x17
#define SRB_FUNCTION_LOCK_QUEUE             0x18
#define SRB_FUNCTION_UNLOCK_QUEUE           0x19

//
// SRB Status Masks
//

#define SRB_STATUS_QUEUE_FROZEN             0x40
#define SRB_STATUS_AUTOSENSE_VALID          0x80

#define SRB_STATUS(Status) (Status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))

//
// SRB Flag Bits
//

#define SRB_FLAGS_QUEUE_ACTION_ENABLE       0x00000002
#define SRB_FLAGS_DISABLE_DISCONNECT        0x00000004
#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER    0x00000008
#define SRB_FLAGS_BYPASS_FROZEN_QUEUE       0x00000010
#define SRB_FLAGS_DISABLE_AUTOSENSE         0x00000020
#define SRB_FLAGS_DATA_IN                   0x00000040
#define SRB_FLAGS_DATA_OUT                  0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER          0x00000000
#define SRB_FLAGS_UNSPECIFIED_DIRECTION      (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)
#define SRB_FLAGS_NO_QUEUE_FREEZE           0x00000100
#define SRB_FLAGS_ADAPTER_CACHE_ENABLE      0x00000200
#define SRB_FLAGS_IS_ACTIVE                 0x00010000
#define SRB_FLAGS_ALLOCATED_FROM_ZONE       0x00020000
#define SRB_FLAGS_SGLIST_FROM_POOL          0x00040000
#define SRB_FLAGS_BYPASS_LOCKED_QUEUE       0x00080000

#define SRB_FLAGS_NO_KEEP_AWAKE             0x00100000

#define SRB_FLAGS_PORT_DRIVER_RESERVED      0x0F000000
#define SRB_FLAGS_CLASS_DRIVER_RESERVED     0xF0000000

//
// Queue Action
//

#define SRB_SIMPLE_TAG_REQUEST              0x20
#define SRB_HEAD_OF_QUEUE_TAG_REQUEST       0x21
#define SRB_ORDERED_QUEUE_TAG_REQUEST       0x22

#define SRB_WMI_FLAGS_ADAPTER_REQUEST       0x01


///////////////////////////////////////////////////////////////////////////////
//
// trackirp.h
//
///////////////////////////////////////////////////////////////////////////////

#define DOE_DESIGNATED_FDO             0x80000000
#define DOE_BOTTOM_OF_FDO_STACK        0x40000000
#define DOE_RAW_FDO                    0x20000000
#define DOE_EXAMINED                   0x10000000
#define DOE_TRACKED                    0x08000000


#define ASSERTFLAG_TRACKIRPS           0x00000001
#define ASSERTFLAG_MONITOR_ALLOCS      0x00000002
#define ASSERTFLAG_POLICEIRPS          0x00000004
#define ASSERTFLAG_MONITORMAJORS       0x00000008
#define ASSERTFLAG_SURROGATE           0x00000010
#define ASSERTFLAG_SMASH_SRBS          0x00000020
#define ASSERTFLAG_CONSUME_ALWAYS      0x00000040
#define ASSERTFLAG_FORCEPENDING        0x00000080
#define ASSERTFLAG_COMPLETEATDPC       0x00000100
#define ASSERTFLAG_COMPLETEATPASSIVE   0x00000200
#define ASSERTFLAG_DEFERCOMPLETION     0x00000800
#define ASSERTFLAG_ROTATE_STATUS       0x00001000
//                                     ----------
#define ASSERTMASK_COMPLETESTYLE       0x00000F80
#define ASSERTFLAG_SEEDSTACK           0x00010000

//
// Disabling HACKHACKS_ENABLED will remove support for all hack code. The
// hack code allows the machine to fully boot in checked builds. Note that
// those hacks can be individually disabled by setting the IovpHackFlags
// variable at boot time.
//
#define HACKHACKS_ENABLED
#define HACKFLAG_FOR_MUP               0x00000001
#define HACKFLAG_FOR_SCSIPORT          0x00000002
#define HACKFLAG_FOR_ACPI              0x00000004
#define HACKFLAG_FOR_BOGUSIRPS         0x00000008


///////////////////////////////////////////////////////////////////////////////
//
// uhcd.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Interrupt Mask register bits
//
#define UHCD_INT_MASK_SHORT_BIT         3
#define UHCD_INT_MASK_SHORT             (1<<UHCD_INT_MASK_SHORT_BIT)

#define UHCD_INT_MASK_IOC_BIT           2
#define UHCD_INT_MASK_IOC               (1<<UHCD_INT_MASK_IOC_BIT)

#define UHCD_INT_MASK_RESUME_BIT        1
#define UHCD_INT_MASK_RESUME            (1<<UHCD_INT_MASK_RESUME_BIT)

#define UHCD_INT_MASK_TIMEOUT_BIT       0
#define UHCD_INT_MASK_TIMEOUT           (1<<UHCD_INT_MASK_TIMEOUT_BIT)


//
// Port Register Bits
//

#define UHCD_PORT_ENABLE_BIT            2
#define UHCD_PORT_ENABLE                (1<<UHCD_PORT_ENABLE_BIT)


//
// Command Register Bits
//

#define UHCD_CMD_RUN_BIT                0
#define UHCD_CMD_RUN                    (USHORT)(1<<UHCD_CMD_RUN_BIT)

#define UHCD_CMD_RESET_BIT              1
#define UHCD_CMD_RESET                  (USHORT)(1<<UHCD_CMD_RESET_BIT)

#define UHCD_CMD_GLOBAL_RESET_BIT       2
#define UHCD_CMD_GLOBAL_RESET           (USHORT)(1<<UHCD_CMD_GLOBAL_RESET_BIT)

#define UHCD_CMD_SUSPEND_BIT            3
#define UHCD_CMD_SUSPEND                (USHORT)(1<<UHCD_CMD_SUSPEND_BIT)

#define UHCD_CMD_FORCE_RESUME_BIT       4
#define UHCD_CMD_FORCE_RESUME           (USHORT)(1<<UHCD_CMD_FORCE_RESUME_BIT)

#define UHCD_CMD_SW_DEBUG_BIT           5
#define UHCD_CMD_SW_DEBUG               (USHORT)(1<<UHCD_CMD_SW_DEBUG_BIT)

#define UHCD_CMD_SW_CONFIGURED_BIT      6
#define UHCD_CMD_SW_CONFIGURED          (USHORT)(1<<UHCD_CMD_SW_CONFIGURED_BIT)

#define UHCD_CMD_MAXPKT_64_BIT          7
#define UHCD_CMD_MAXPKT_64              (USHORT)(1<<UHCD_CMD_MAXPKT_64_BIT)



//
// Status Register Bits
//

#define UHCD_STATUS_USBINT_BIT          0
#define UHCD_STATUS_USBINT              (1<<UHCD_STATUS_USBINT_BIT)

#define UHCD_STATUS_USBERR_BIT          1
#define UHCD_STATUS_USBERR              (1<<UHCD_STATUS_USBERR_BIT)

#define UHCD_STATUS_RESUME_BIT          2
#define UHCD_STATUS_RESUME              (1<<UHCD_STATUS_RESUME_BIT)

#define UHCD_STATUS_PCIERR_BIT          3
#define UHCD_STATUS_PCIERR              (1<<UHCD_STATUS_PCIERR_BIT)

#define UHCD_STATUS_HCERR_BIT           4
#define UHCD_STATUS_HCERR               (1<<UHCD_STATUS_HCERR_BIT)

#define UHCD_STATUS_HCHALT_BIT          5
#define UHCD_STATUS_HCHALT              (1<<UHCD_STATUS_HCHALT_BIT)

// number of bit times in a USB frame based on a 12MHZ SOF clock
#define UHCD_12MHZ_SOF              11936
//
// values for HcFlags
//

// Set to indicate port resources were assigned
#define HCFLAG_GOT_IO                   0x00000001
// Set at initialization to indicate that the base register
// address must be unmapped when the driver is unloaded.
#define HCFLAG_UNMAP_REGISTERS          0x00000002
// Set if we have a USB BIOS on this system
#define HCFLAG_USBBIOS                  0x00000004
// Current state of BW reclimation
#define HCFLAG_BWRECLIMATION_ENABLED    0x00000008
// This flag indicates if the driver needs to cleanup resources
// allocated in start_device.
#define HCFLAG_NEED_CLEANUP             0x00000010
// HC is idle
#define HCFLAG_IDLE                     0x00000020
// set when the rollover int is disabled
#define HCFLAG_ROLLOVER_IDLE            0x00000040
// set when the controller is stopped
#define HCFLAG_HCD_STOPPED              0x00000080
// turn off idle check
#define HCFLAG_DISABLE_IDLE             0x00000100
// work item queued
#define HCFLAG_WORK_ITEM_QUEUED         0x00000200
// hcd has shut down
#define HCFLAG_HCD_SHUTDOWN             0x00000400
// indicates we need to restore HC from hibernate
#define HCFLAG_LOST_POWER               0x00000800
// set when root hub turns off the HC
#define HCFLAG_RH_OFF                   0x00001000

#define HCFLAG_MAP_SX_TO_D3             0x00002000
// set if we will be suspending in this D3
#define HCFLAG_SUSPEND_NEXT_D3          0x00004000

///////////////////////////////////////////////////////////////////////////////
//
// usbdi.h
//
///////////////////////////////////////////////////////////////////////////////

//
//  URB request codes
//

#define URB_FUNCTION_SELECT_CONFIGURATION            0x0000
#define URB_FUNCTION_SELECT_INTERFACE                0x0001
#define URB_FUNCTION_ABORT_PIPE                      0x0002
#define URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL       0x0003
#define URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL    0x0004
#define URB_FUNCTION_GET_FRAME_LENGTH                0x0005
#define URB_FUNCTION_SET_FRAME_LENGTH                0x0006
#define URB_FUNCTION_GET_CURRENT_FRAME_NUMBER        0x0007
#define URB_FUNCTION_CONTROL_TRANSFER                0x0008
#define URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER      0x0009
#define URB_FUNCTION_ISOCH_TRANSFER                  0x000A
#define URB_FUNCTION_RESET_PIPE                      0x001E

//
// These functions correspond
// to the standard commands on the default pipe
//
// direction is implied
//

#define URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE     0x000B
#define URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT   0x0024
#define URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE  0x0028

#define URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE       0x000C
#define URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT     0x0025
#define URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE    0x0029

#define URB_FUNCTION_SET_FEATURE_TO_DEVICE          0x000D
#define URB_FUNCTION_SET_FEATURE_TO_INTERFACE       0x000E
#define URB_FUNCTION_SET_FEATURE_TO_ENDPOINT        0x000F
#define URB_FUNCTION_SET_FEATURE_TO_OTHER           0x0023

#define URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE        0x0010
#define URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE     0x0011
#define URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT      0x0012
#define URB_FUNCTION_CLEAR_FEATURE_TO_OTHER         0x0022

#define URB_FUNCTION_GET_STATUS_FROM_DEVICE         0x0013
#define URB_FUNCTION_GET_STATUS_FROM_INTERFACE      0x0014
#define URB_FUNCTION_GET_STATUS_FROM_ENDPOINT       0x0015
#define URB_FUNCTION_GET_STATUS_FROM_OTHER          0x0021

// direction is specified in TransferFlags

#define URB_FUNCTION_RESERVED0                      0x0016

//
// These are for sending vendor and class commands
// on the default pipe
//
// direction is specified in TransferFlags
//

#define URB_FUNCTION_VENDOR_DEVICE                   0x0017
#define URB_FUNCTION_VENDOR_INTERFACE                0x0018
#define URB_FUNCTION_VENDOR_ENDPOINT                 0x0019
#define URB_FUNCTION_VENDOR_OTHER                    0x0020

#define URB_FUNCTION_CLASS_DEVICE                    0x001A
#define URB_FUNCTION_CLASS_INTERFACE                 0x001B
#define URB_FUNCTION_CLASS_ENDPOINT                  0x001C
#define URB_FUNCTION_CLASS_OTHER                     0x001F

//
// Reserved function codes
//
#define URB_FUNCTION_RESERVED                        0x001D

#define URB_FUNCTION_GET_CONFIGURATION               0x0026
#define URB_FUNCTION_GET_INTERFACE                   0x0027

#define URB_FUNCTION_LAST                            0x0029




///////////////////////////////////////////////////////////////////////////////
//
// usbhub.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Hub and Port status defined below also apply to StatusChnage bits
//
#define HUB_STATUS_LOCAL_POWER      0x01
#define HUB_STATUS_OVER_CURRENT     0x02

#define PORT_STATUS_CONNECT         0x001
#define PORT_STATUS_ENABLE          0x002
#define PORT_STATUS_SUSPEND         0x004
#define PORT_STATUS_OVER_CURRENT    0x008
#define PORT_STATUS_RESET           0x010
#define PORT_STATUS_POWER           0x100
#define PORT_STATUS_LOW_SPEED       0x200


#define HUBFLAG_NEED_CLEANUP        0x00000001
#define HUBFLAG_ENABLED_FOR_WAKEUP  0x00000002
#define HUBFLAG_DEVICE_STOPPING     0x00000004
#define HUBFLAG_HUB_FAILURE         0x00000008
#define HUBFLAG_SUPPORT_WAKEUP      0x00000010
#define HUBFLAG_HUB_STOPPED         0x00000020
#define HUBFLAG_HUB_BUSY            0x00000040
#define HUBFLAG_PENDING_WAKE_IRP    0x00000080
#define HUBFLAG_PENDING_PORT_RESET  0x00000100
#define HUBFLAG_HUB_HAS_LOST_BRAINS 0x00000200

#define USBH_MAX_ENUMERATION_ATTEMPTS   3

//
// Common fields for Pdo and Fdo extensions
//
#define EXTENSION_TYPE_PORT 0x54524f50      // "PORT"
#define EXTENSION_TYPE_HUB  0x20425548      // "HUB "
#define EXTENSION_TYPE_PARENT  0x50525400   // "PRT "
#define EXTENSION_TYPE_FUNCTION  0xfefefeff   // ""


//
// values for PortPdoFlags
//

#define PORTPDO_DEVICE_IS_HUB               0x00000001
#define PORTPDO_DEVICE_IS_PARENT            0x00000002
#define PORTPDO_DEVICE_ENUM_ERROR           0x00000004
#define PORTPDO_LOW_SPEED_DEVICE            0x00000008
#define PORTPDO_REMOTE_WAKEUP_SUPPORTED     0x00000010
#define PORTPDO_REMOTE_WAKEUP_ENABLED       0x00000020
#define PORTPDO_DELETED_PDO                 0x00000040
#define PORTPDO_DELETE_PENDING              0x00000080
#define PORTPDO_NEED_RESET                  0x00000100
#define PORTPDO_STARTED                     0x00000200
#define PORTPDO_WANT_POWER_FEATURE          0x00000400
#define PORTPDO_SYM_LINK                    0x00000800
#define PORTPDO_DEVICE_FAILED               0x00001000
#define PORTPDO_USB_SUSPEND                 0x00002000
#define PORTPDO_OVERCURRENT                 0x00004000
#define PORTPDO_DD_REMOVED                  0x00008000
#define PORTPDO_NOT_ENOUGH_POWER            0x00010000
#define PORTPDO_PDO_RETURNED                0x00020000
#define PORTPDO_NO_BANDWIDTH                0x00040000
#define PORTPDO_RESET_PENDING               0x00080000


///////////////////////////////////////////////////////////////////////////////
//
// wdm.h
//
///////////////////////////////////////////////////////////////////////////////


//
// POWER minor function codes
//
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03

//
// Device Control Request minor function codes for SCSI support. Note that
// user requests are assumed to be zero.
//

#define IRP_MN_SCSI_CLASS               0x01

//
// PNP minor function codes.
//

#define IRP_MN_START_DEVICE                 0x00
#define IRP_MN_QUERY_REMOVE_DEVICE          0x01
#define IRP_MN_REMOVE_DEVICE                0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE         0x03
#define IRP_MN_STOP_DEVICE                  0x04
#define IRP_MN_QUERY_STOP_DEVICE            0x05
#define IRP_MN_CANCEL_STOP_DEVICE           0x06

#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_QUERY_DEVICE_TEXT            0x0C
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D

#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
#define IRP_MN_QUERY_BUS_INFORMATION        0x15
#define IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
#define IRP_MN_SURPRISE_REMOVAL             0x17
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18

// begin_ntminiport
//
// WMI minor function codes under IRP_MJ_SYSTEM_CONTROL
//

#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09

//
// Define PNP/POWER types required by IRP_MJ_PNP/IRP_MJ_POWER.
//

typedef enum _DEVICE_RELATION_TYPE {
    BusRelations,
    EjectionRelations,
    PowerRelations,
    RemovalRelations,
    TargetDeviceRelation
} DEVICE_RELATION_TYPE, *PDEVICE_RELATION_TYPE;

typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined,
    DeviceUsageTypePaging,
    DeviceUsageTypeHibernation,
    DeviceUsageTypeDumpFile
} DEVICE_USAGE_NOTIFICATION_TYPE;

typedef enum {
    BusQueryDeviceID = 0,       // <Enumerator>\<Enumerator-specific device id>
    BusQueryHardwareIDs = 1,    // Hardware ids
    BusQueryCompatibleIDs = 2,  // compatible device ids
    BusQueryInstanceID = 3,     // persistent id for this instance of the device
    BusQueryDeviceSerialNumber = 4    // serial number for this device
} BUS_QUERY_ID_TYPE, *PBUS_QUERY_ID_TYPE;

typedef enum {
    DeviceTextDescription = 0,            // DeviceDesc property
    DeviceTextLocationInformation = 1     // DeviceLocation property
} DEVICE_TEXT_TYPE, *PDEVICE_TEXT_TYPE;


#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)


///////////////////////////////////////////////////////////////////////////////
//
// wdmaud.h
//
///////////////////////////////////////////////////////////////////////////////

#define WDMAUD_CTL_CODE CTL_CODE

#define IOCTL_SOUND_BASE    FILE_DEVICE_SOUND
#define IOCTL_WDMAUD_BASE   0x0000
#define IOCTL_WAVE_BASE     0x0040
#define IOCTL_MIDI_BASE     0x0080
#define IOCTL_MIXER_BASE    0x00C0

#define IOCTL_WDMAUD_INIT                      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_ADD_DEVNODE               WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_REMOVE_DEVNODE            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_CAPABILITIES          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_NUM_DEVS              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_OPEN_PIN                  WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_CLOSE_PIN                 WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_VOLUME                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0007, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_SET_VOLUME                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0008, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_EXIT                      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0009, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_SET_PREFERRED_DEVICE      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x000a, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_WAVE_OUT_PAUSE            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_PLAY             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_RESET            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP        WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_GET_POS          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN        WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0007, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_WAVE_IN_STOP              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0010, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_RECORD            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0011, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_RESET             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0012, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_GET_POS           WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0013, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_READ_PIN          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0014, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIDI_OUT_RESET            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIDI_IN_STOP              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0010, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_RECORD            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0011, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_RESET             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0012, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_READ_PIN          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0013, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIXER_OPEN                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_CLOSE               WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETLINEINFO         WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETLINECONTROLS     WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETHARDWAREEVENTDATA   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)


///////////////////////////////////////////////////////////////////////////////
//
// wdguid.h
//
///////////////////////////////////////////////////////////////////////////////
//
// Device events that can be broadcasted to drivers and user-mode apps.
//
DEFINE_GUID( GUID_HWPROFILE_QUERY_CHANGE,          0xcb3a4001L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_HWPROFILE_CHANGE_CANCELLED,      0xcb3a4002L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_HWPROFILE_CHANGE_COMPLETE,       0xcb3a4003L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_DEVICE_INTERFACE_ARRIVAL,        0xcb3a4004L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_DEVICE_INTERFACE_REMOVAL,        0xcb3a4005L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_QUERY_REMOVE,      0xcb3a4006L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_REMOVE_CANCELLED,  0xcb3a4007L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_REMOVE_COMPLETE,   0xcb3a4008L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_PNP_CUSTOM_NOTIFICATION,         0xACA73F8EL, 0x8D23, 0x11D1, 0xAC, 0x7D, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0 );
DEFINE_GUID( GUID_PNP_POWER_NOTIFICATION,          0xC2CF0660L, 0xEB7A, 0x11D1, 0xBD, 0x7F, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0 );


#endif // _EXTFLAGS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\faults.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    faults.c

Abstract:

    WinDbg Extension Api

Author:

    Forrest Foltz (forrestf)

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define DBGPRINT if(1) dprintf

#define MAX_IMAGE_NAME_CHARS 15

typedef struct _ALIGNMENT_FAULT_IMAGE_DB *PALIGNMENT_FAULT_IMAGE_DB;
typedef struct _ALIGNMENT_FAULT_LOCATION_DB *PALIGNMENT_FAULT_LOCATION_DB;

typedef struct _ALIGNMENT_FAULT_IMAGE_DB {

    //
    // Head of singly-linked list of fault locations associated with this image
    //

    PALIGNMENT_FAULT_LOCATION_DB LocationHead;

    //
    // Total number of alignment faults associated with this image.
    //

    ULONG   Count;

    //
    // Number of unique alignment fault locations found in this image
    //

    ULONG   Instances;

    //
    // Name of the image
    //

    CHAR    Name[ MAX_IMAGE_NAME_CHARS + 1 ];

} ALIGNMENT_FAULT_IMAGE_DB;

typedef struct _ALIGNMENT_FAULT_LOCATION_DB {

    //
    // Pointer to fault image associated with this location
    //

    PALIGNMENT_FAULT_IMAGE_DB Image;

    //
    // Linkage for singly-linked list of fault locations associated with the
    // same image.
    //

    PALIGNMENT_FAULT_LOCATION_DB Next;

    //
    // Offset of the PC address within the image.
    //

    ULONG64 OffsetFromBase;

    //
    // Number of alignment faults taken at this location.
    //

    ULONG Count;

} ALIGNMENT_FAULT_LOCATION_DB;

BOOLEAN
ReadAlignmentFaultData(
    OUT PALIGNMENT_FAULT_IMAGE_DB *ImageArray,
    OUT PALIGNMENT_FAULT_LOCATION_DB *LocationArray,
    OUT PULONG ImageArrayElements,
    OUT PULONG LocationArrayElements
    );

VOID
PrintLocation(
    IN PALIGNMENT_FAULT_LOCATION_DB FaultLocation
    );

ULONG
ReadUlong(
    ULONG64 Address
    );

int
__cdecl
sortByFrequency(
    const void *Elem1,
    const void *Elem2
    );

DECLARE_API( alignmentfaults )
{
    PALIGNMENT_FAULT_IMAGE_DB imageArray;
    PALIGNMENT_FAULT_LOCATION_DB locationArray, location;
    ULONG imageArrayElements;
    ULONG locationArrayElements;
    ULONG i;
    BOOLEAN result;

    PALIGNMENT_FAULT_LOCATION_DB *sortLocationArray;

    //
    // Read the alignment fault data arrays
    // 

    result = ReadAlignmentFaultData( &imageArray,
                                     &locationArray,
                                     &imageArrayElements,
                                     &locationArrayElements );
    if (result == FALSE) {
        return E_INVALIDARG;
    }

    sortLocationArray = LocalAlloc(LPTR, sizeof(PVOID) *
                                         locationArrayElements);

    if ( !sortLocationArray )   {
        dprintf("Unable to allocate sortLocationArray\n");
        return E_INVALIDARG;
    }

    for (i = 0; i < locationArrayElements; i++) {
        sortLocationArray[i] = &locationArray[i];
    }

    qsort( sortLocationArray,
           locationArrayElements,
           sizeof(PALIGNMENT_FAULT_LOCATION_DB),
           sortByFrequency );

    dprintf("%10s %s\n", "#faults","location");

    for (i = 0; i < locationArrayElements; i++) {
        location = sortLocationArray[i];
        PrintLocation(location);
    }

    LocalFree( sortLocationArray );

    return S_OK;
}

int
__cdecl
sortByFrequency(
    const void *Elem1,
    const void *Elem2
    )
{
    const ALIGNMENT_FAULT_LOCATION_DB *location1;
    const ALIGNMENT_FAULT_LOCATION_DB *location2;

    location1 = *((const ALIGNMENT_FAULT_LOCATION_DB **)Elem1);
    location2 = *((const ALIGNMENT_FAULT_LOCATION_DB **)Elem2);

    if (location1->Count < location2->Count) {
        return -1;
    }

    if (location1->Count > location2->Count) {
        return 1;
    }

    return 0;
}

VOID
PrintLocation(
    IN PALIGNMENT_FAULT_LOCATION_DB FaultLocation
    )
{
    PALIGNMENT_FAULT_IMAGE_DB image;
    CHAR symbol[256];
    ULONG64 displacement;

    image = FaultLocation->Image;

    dprintf("%10d %s+%x\n",
            FaultLocation->Count,
            image->Name,
            FaultLocation->OffsetFromBase);
}

BOOLEAN
ReadAlignmentFaultData(
    OUT PALIGNMENT_FAULT_IMAGE_DB *ImageArray,
    OUT PALIGNMENT_FAULT_LOCATION_DB *LocationArray,
    OUT PULONG ImageArrayElements,
    OUT PULONG LocationArrayElements
    )
{
    ULONG imageCount;
    ULONG locationCount;
    ULONG i;
    ULONG index;
    ULONG allocSize;
    ULONG result;

    ULONG64 locationRecordArray, locationRecord;
    ULONG64 imageRecordArray, imageRecord;
    ULONG64 locationCountAddr;
    ULONG64 imageCountAddr;

    ULONG locationRecordSize;
    ULONG imageRecordSize;

    PALIGNMENT_FAULT_LOCATION_DB location, locationArray;
    PALIGNMENT_FAULT_IMAGE_DB image, imageArray;

    //
    // Get the count of images and locations
    //

    locationCountAddr = GetExpression ("KiAlignmentFaultLocationCount");
    imageCountAddr = GetExpression ("KiAlignmentFaultImageCount");

    locationCount = ReadUlong( locationCountAddr );
    imageCount = ReadUlong( imageCountAddr );

    if (locationCount == 0 || imageCount == 0) {
        dprintf("No alignment faults encountered\n");
        return FALSE;
    }

    locationRecordArray = GetExpression ("KiAlignmentFaultLocations");
    imageRecordArray = GetExpression ("KiAlignmentFaultImages");
    if (locationRecordArray == 0 || imageRecordArray == 0) {
        return FALSE;
    }

    //
    // Get the sizes of the records as they exist on the target
    // machine
    //

    locationRecordSize = GetTypeSize("ALIGNMENT_FAULT_LOCATION");
    imageRecordSize = GetTypeSize("ALIGNMENT_FAULT_IMAGE");

    //
    // Allocate space for the location and image arrays
    // 

    allocSize = sizeof(ALIGNMENT_FAULT_LOCATION_DB) * locationCount +
                sizeof(ALIGNMENT_FAULT_IMAGE_DB) * imageCount;

    locationArray = LocalAlloc(LPTR, allocSize);
    if (locationArray == NULL) {
        dprintf("Unable to allocate %d bytes of memory\n", allocSize);
        return FALSE;
    }
    imageArray = (PALIGNMENT_FAULT_IMAGE_DB)(locationArray + locationCount);

    //
    // Load the location records
    //

    location = locationArray;
    locationRecord = locationRecordArray;
    for (i = 0; i < locationCount; i++) {

        InitTypeRead(locationRecord, ALIGNMENT_FAULT_LOCATION);

        index = (ULONG)((ReadField(Image) - imageRecordArray) / imageRecordSize);
        location->Image = &imageArray[ index ];

        index = (ULONG)((ReadField(Next) - locationRecordArray) / locationRecordSize);
        location->Next = &locationArray[ index ];

        location->OffsetFromBase = ReadField(OffsetFromBase);
        location->Count = (ULONG)ReadField(Count);

        locationRecord += locationRecordSize;
        location += 1;
    }

    image = imageArray;
    imageRecord = imageRecordArray;
    for (i = 0; i < imageCount; i++) {

        InitTypeRead(imageRecord, ALIGNMENT_FAULT_IMAGE);

        index = (ULONG)((ReadField(LocationHead) - locationRecordArray) / locationRecordSize);
        image->LocationHead = &locationArray[ index ];
        image->Count = (ULONG)ReadField(Count);
        image->Instances = (ULONG)ReadField(Instances);

        GetFieldOffset( "ALIGNMENT_FAULT_IMAGE", "Name", &index );

        ReadMemory( imageRecord + index,
                    &image->Name,
                    sizeof(image->Name),
                    &result );

        imageRecord += imageRecordSize;
        image += 1;
    }

    *ImageArray = imageArray;
    *LocationArray = locationArray;
    *ImageArrayElements = imageCount;
    *LocationArrayElements = locationCount;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\filecach.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    filecach.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

DECLARE_API( filecache )

/*++

Routine Description:

    Displays physical memory usage by drivers.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG result;
    ULONG NumberOfPtes;
    ULONG PteCount;
    ULONG ReadCount;
    ULONG64 SystemCacheWsLoc;
    ULONG64 SystemCacheStart;
    ULONG64 SystemCacheEnd;
    ULONG64 SystemCacheStartPte;
    ULONG64 SystemCacheEndPte;
    ULONG Transition = 0;
    ULONG Valid;
    ULONG ValidShift, ValidSize;
    ULONG64 PfnIndex;
    ULONG PteSize;
    ULONG PfnSize;
    ULONG HighPage;
    ULONG LowPage;
    ULONG64 Pte;
    ULONG64 PfnDb;
    ULONG64 Pfn;
    ULONG64 PfnStart;
    ULONG64 PfnArray;
    ULONG64 PfnArrayOffset;
    ULONG   NumberOfPteToRead;
    ULONG   WorkingSetSize, PeakWorkingSetSize;
    ULONG64 BufferedAddress=0;
    CHAR    Buffer[2048];

    INIT_API();
    
    dprintf("***** Dump file cache******\n");

    SystemCacheStart = GetNtDebuggerDataPtrValue( MmSystemCacheStart );
    if (!SystemCacheStart) {
        dprintf("unable to get SystemCacheStart\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    SystemCacheEnd = GetNtDebuggerDataPtrValue( MmSystemCacheEnd );
    if (!SystemCacheEnd) {
        dprintf("unable to get SystemCacheEnd\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    SystemCacheWsLoc = GetNtDebuggerData( MmSystemCacheWs );
    if (!SystemCacheWsLoc) {
        dprintf("unable to get MmSystemCacheWs\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    PfnDb = GetNtDebuggerData( MmPfnDatabase );
    if (!PfnDb) {
        dprintf("unable to get MmPfnDatabase\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    PteSize = GetTypeSize("nt!_MMPTE");
    NumberOfPteToRead = PageSize / PteSize - 16;

    if (GetFieldValue(SystemCacheWsLoc,
                      "nt!_MMSUPPORT",
                      "WorkingSetSize",
                       WorkingSetSize)) {
        dprintf("unable to get system cache list\n");
        EXIT_API();
        return E_INVALIDARG;
    }
    GetFieldValue(SystemCacheWsLoc,"nt!_MMSUPPORT","PeakWorkingSetSize",PeakWorkingSetSize);

    dprintf("File Cache Information\n");
    dprintf("  Current size %ld kb\n",WorkingSetSize*
                                            (PageSize / 1024));
    dprintf("  Peak size    %ld kb\n",PeakWorkingSetSize*
                                            (PageSize / 1024));


    if (!ReadPointer(PfnDb,&PfnStart)) {
        dprintf("unable to get PFN database address\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    SystemCacheStartPte = DbgGetPteAddress (SystemCacheStart);
    SystemCacheEndPte = DbgGetPteAddress (SystemCacheEnd);
    NumberOfPtes = (ULONG) ( 1 + (SystemCacheEndPte - SystemCacheStartPte) / PteSize);

    //
    // Read in all the PTEs mapping the system cache.
    //

    dprintf("  Loading file cache database (%u PTEs)\r", NumberOfPtes);
    GetBitFieldOffset("nt!_MMPTE", "u.Hard.Valid", &ValidShift, &ValidSize);

//    dprintf("Valid off %d, num %d ", ValidShift, ValidSize);
    Valid = 0;
    ZeroMemory(Buffer, sizeof(Buffer));
    for (PteCount = 0;
         PteCount < NumberOfPtes;
         PteCount += 1) {

        if (CheckControlC()) {
            EXIT_API();
            return E_INVALIDARG;
        }
        
        //
        // Read a chunk at a time
        //
        if ((SystemCacheStartPte + (PteCount+1)* PteSize) > BufferedAddress + sizeof(Buffer) ) {
            
            BufferedAddress = (SystemCacheStartPte + PteCount * PteSize);
            if (!ReadMemory(BufferedAddress,
                            Buffer,
                            sizeof(Buffer),
                            &result)) {
                dprintf("Unable to read memory at %p\n", BufferedAddress);
                PteCount += sizeof(Buffer) / PteSize;
                continue;
            }
        }

        Pte = (SystemCacheStartPte + PteCount * PteSize) - BufferedAddress;

        //
        // Too many ptes, so do the Valid checking directly instead of calling DbgGetValid
        //
        if ((*((PULONG) &Buffer[(ULONG) Pte]) >> ValidShift) & 1) {
            Valid += 1;
        }

        if (!(PteCount % (NumberOfPtes/100))) {
            dprintf("  Loading file cache database (%02d%% of %u PTEs)\r", PteCount*100/NumberOfPtes, NumberOfPtes);
        }

    }

    dprintf("\n");

    dprintf("  File cache PTEs loaded, loading PFNs...\n");


    HighPage = Valid;
    LowPage = 0;

    //
    // Allocate a local PFN array (only) large enough to hold data about
    // each valid PTE we've found.
    //

    dprintf("  File cache has %ld valid pages\n",Valid);

    PfnSize = GetTypeSize("nt!_MMPFN");

    Pte = SystemCacheStartPte;
    
    dprintf("  File cache PFN data extracted\n");

    MemoryUsage (PfnStart,LowPage,HighPage, 1);
    
    EXIT_API();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\help.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    .c

Abstract:

    WinDbg Extension Api

Revision History:

--*/

#include "precomp.h"


DECLARE_API( help )
{
    dprintf("acpiinf                      - Displays ACPI Information structure\n" );
    dprintf("acpiirqarb                   - Displays ACPI IRQ Arbiter data\n" );
    dprintf("arbiter [flags]              - Displays all arbiters and arbitrated ranges\n");
    dprintf("       flags: 1 - I/O arbiters\n");
    dprintf("              2 - Memory arbiters\n");
    dprintf("              4 - IRQ arbiters\n");
    dprintf("              8 - DMA arbiters\n");
    dprintf("             10 - Bus Number arbiters\n");
    dprintf("arblist <address> [flags]    - Dump set of resources being arbitrated\n");
    dprintf("       flags: 1 - Include Interface and Slot info per device\n");
    dprintf("blockeddrv                   - Dumps the list of blocked drivers in the system\n");
    dprintf("bpid <pid>                   - Tells winlogon to do a user-mode break into process <pid>\n");
    dprintf("bugdump                      - Display bug check dump data\n" );
    dprintf("bushnd [address]             - Dump a HAL \"BUS HANDLER\" structure [address] if\n");
    dprintf("                               specified is the handler to be dumped. If not\n");
    dprintf("                               specified, dumps the list of handlers (brief).\n");
    dprintf("ca <address> [flags]         - Dump the control area of a section\n");
    dprintf("calldata <table name>        - Dump call data hash table\n" );
    dprintf("cmreslist <CM Resource List> - Dump CM resource list\n" );
    dprintf("db <physical address>        - Display physical memory\n");
    dprintf("dd <physical address>        - Display physical memory\n");
    dprintf("dblink <address> [count] [bias] - Dumps a list via its blinks\n");
    dprintf("dflink <address> [count] [bias] - Dumps a list via its flinks\n");
    dprintf("       bias - a mask of bits to ignore in each pointer\n");
    dprintf("defwrites                    - Dumps the deferred write queue and\n");
    dprintf("                                and triages cached write throttles\n");
    dprintf("devext <address> <type>         - Dump device extension at\n");
    dprintf("                                  <address> of type <type>\n");
    dprintf("                                  <type> is on of the following: \n");
    dprintf("                                         PCI, PCMCIA, USBD, OpenHCI,\n");
    dprintf("                                         USBHUB, UHCD, HID\n");
    dprintf("devinst                      - dumps the device reference table\n");
    dprintf("devnode <device node> [flags] [service] - Dump the device node\n");
    dprintf("        device node: 0       - list main tree\n");
    dprintf("                     1       - list pending removals\n");
    dprintf("                     2       - list pending ejects\n");
    dprintf("                     address - list specified devnode\n");
    dprintf("        flags:       1       - dump children\n");
    dprintf("                     2       - dump CM Resource List\n");
    dprintf("                     4       - dump IO Resource List\n");
    dprintf("                     8       - dump translated CM Resource List\n");
    dprintf("                    10       - dump only devnodes that aren't started\n");
    dprintf("                    20       - dump only devnodes that have problems\n");
    dprintf("        service:    if present only devnodes driven\n");
    dprintf("                    by this service (and all their children if\n");
    dprintf("                    the flags indicate so) are dumped\n");
    dprintf("devobj <device>              - Dump the device object and Irp queue\n");
    dprintf("                   <device>  - device object address or name\n");
    dprintf("devstack <device>            - Dump device stack associated with device object\n");
    dprintf("drvobj <driver> [flags]      - Dump the driver object and related information\n");
    dprintf("                   <driver>  - driver object address or name\n");
    dprintf("                   flags:1   - Dump device object list\n");
    dprintf("                   flags:2   - Dump driver entry points\n");
    dprintf("drivers                      - Display information about loaded system modules\n");
    dprintf("e820reslist <List>           - Dump an ACPI_BIOS_MULTI_NODE resource list\n");
    dprintf("eb <physical address> <byte>  <byte, byte ,...> - modify physical memory\n");
    dprintf("ed <physical address> <dword> <dword,dword,...> - modify physical memory\n");
    dprintf("errlog                       - Dump the error log contents\n");
    dprintf("exqueue [flags]              - Dump the ExWorkerQueues\n");
    dprintf("        flags:     1/2/4     - same as !thread/!process\n");
    dprintf("                   10        - only critical work queue\n");
    dprintf("                   20        - only delayed work queue\n");
    dprintf("                   40        - only hypercritical work queue\n");
    dprintf("facs                         - Dumps the Firmware ACPI Control Structure\n");
    dprintf("fadt                         - Dumps the Fixed ACPI Description Table\n");
    dprintf("filecache                    - Dumps information about the file system cache\n");
    dprintf("filetime                     - Dumps a 64-bit FILETIME as a human-readable time\n");
    dprintf("filelock <address>           - Dump a file lock structure - address is either the filelock or a fileobject\n");
    dprintf("fpsearch <address>           - Find a freed special pool allocation\n");
    dprintf("frag [flags]                 - Kernel mode pool fragmentation\n");
    dprintf("     flags:  1 - List all fragment information\n");
    dprintf("             2 - List allocation information\n");
    dprintf("             3 - both\n");
    dprintf("gentable <address>           - Dumps the given rtl_generic_table\n");
    dprintf("gbl                          - Dumps the ACPI Global Lock\n");
    dprintf("handle <addr> <flags> <process> <TypeName> -  Dumps handle for a process\n");
    dprintf("       flags:  -2 Dump non-paged object\n");
    dprintf("heap <addr> [flags]          - Dumps heap for a process\n");
    dprintf("       flags:  -v Verbose\n");
    dprintf("               -f Free List entries\n");
    dprintf("               -a All entries\n");
    dprintf("               -s Summary\n");
    dprintf("               -x Force a dump even if the data is bad\n");
    dprintf("       address: desired heap to dump or 0 for all\n");
    dprintf("help                         - Displays this list\n" );
    dprintf("HidPpd <address> <flags>     - Dump Preparsed Data of HID device\n");
    dprintf("ib <port>                    - Read a byte from an I/O port\n");
    dprintf("id <port>                    - Read a double-word from an I/O port\n");
    dprintf("idt <vector>                 - Dump ISRs referenced by each IDT entry\n");
    dprintf("iw <port>                    - Read a word from an I/O port\n");
    dprintf("ioreslist <IO Resource List> - Dump IO resource requirements list\n" );
    dprintf("irp <address> <dumplevel>    - Dump Irp at specified address\n");
    dprintf("                 address == 0   Dump active IRPs (checked only)\n");
    dprintf("                 dumplevel: 0   Basic stack info\n");
    dprintf("                 dumplevel: 1   Full field dump\n");
    dprintf("                 dumplevel: 2   Include tracking information (checked only)\n");
    dprintf("irpfind [pooltype] [restart addr] [<irpsearch> <address>]- Search pool for active Irps\n");
    dprintf("     pooltype is 0 for nonpaged pool (default)\n");
    dprintf("     pooltype is 1 for paged pool\n");
    dprintf("     pooltype is 2 for special pool\n");
    dprintf("     restart addr - if specfied, scan will be restarted from \n");
    dprintf("                    this location in pool\n");
    dprintf("     <irpsearch> - specifies filter criteria to find a specific irp\n");
    dprintf("           'userevent' - finds IRPs where Irp.UserEvent == <address>\n");
    dprintf("           'device' - finds IRPs with a stack location where DeviceObject == <address>\n");
    dprintf("           'fileobject' - finds IRPs where Irp.Tail.Overlay.OriginalFileObject == <address>\n");
    dprintf("           'mdlprocess' - finds IRPs where Irp.MdlAddress.Process == <address>\n");
    dprintf("           'thread' - finds IRPs where Irp.Tail.Overlay.Thread == <address>\n");
    dprintf("           'arg' - finds IRPs with one of the args == <address>\n");
    dprintf("job <address> [<flags>]      - Dump JobObject at address, processes in job\n");
    dprintf("lbt                          - Dump legacy bus information table\n");
    dprintf("locks [-v] <address>         - Dump kernel mode resource locks\n");
    dprintf("lookaside <address> <options> <depth> - Dump lookaside lists\n");
    dprintf("       options - 1 Reset Counters\n");
    dprintf("       options - 2 <depth> Set depth\n");
    dprintf("lpc                          - Dump lpc ports and messages\n");
    dprintf("mapic                        - Dumps the ACPI Multiple APIC Table\n");
    dprintf("memusage                     - Dumps the page frame database table\n");
    dprintf("nsobj   <address>            - Dumps an ACPI Namespace Object\n");
    dprintf("nstree [<address>]           - Dumps an ACPI Namespace Object and its children\n");
    dprintf("ob <port>                    - Write a byte to an I/O port\n");
    dprintf("obja <TypeName>              - Dumps an object manager object's attributes\n");
    dprintf("object <-r | Path | address | 0 TypeName>  - Dumps an object manager object\n");
    dprintf("       -r   -  Force reload of cached object pointers\n");
    dprintf("od <port>                    - Write a double-word to an I/O port\n");
    dprintf("openmaps <shared cache map > - Dumps the active views for a given shared cache map\n");
    dprintf("ow <port>                    - Write a word to an I/O port\n");
    dprintf("patch                        - Enable and disable various driver flags\n");
    dprintf("pcitree                      - Dump the PCI tree structure (use)\n");
    dprintf("                              '!devext <addr> pci' for details\n");
    dprintf("                              on individual devices.\n");
    dprintf("pfn                          - Dumps the page frame database entry for the physical page\n");
    dprintf("pnpevent <event entry> - Dump PNP events\n");
    dprintf("       event entry: 0        - list all queued events\n");
    dprintf("                    address  - list specified event\n");
    dprintf("pocaps                       - Dumps System Power Capabilities.\n");
    dprintf("podev <devobj>               - Dumps power relevent data in device object\n");
    dprintf("polist [<devobj>]            - Dumps power Irp serial list entries\n");
    dprintf("ponode                       - Dumps power Device Node stack (devnodes in power order)\n");
    dprintf("popolicy                     - Dumps System Power Policy.\n");
    dprintf("poproc <Address>             - Dumps Processor Power State.\n");
    dprintf("poReqList [<devobj>]         - Dumps PoRequestedPowerIrp created Power Irps\n");
    dprintf("pool <address> [detail]      - Dump kernel mode heap\n");
    dprintf("        address: 0 or blank  - Only the process heap\n");
    dprintf("                         -1  - All heaps in the process\n");
    dprintf("              Otherwise for the heap address listed\n");
    dprintf("     detail:  0 - Summary Information\n");
    dprintf("              1 - Above + location/size of regions\n");
    dprintf("              2 - Print information only for address\n");
    dprintf("              3 - Above + allocated/free blocks in committed regions\n");
    dprintf("              4 - Above + free lists\n");
    dprintf("poolfind Tag [pooltype] -    - Finds occurrences of the specified Tag\n");
    dprintf("     Tag is 4 character tag, * and ? are wild cards\n");
    dprintf("     pooltype is 0 for nonpaged pool (default)\n");
    dprintf("     pooltype is 1 for paged pool\n");
    dprintf("     pooltype is 2 for special pool\n");
    dprintf("   NOTE - this can take a long time!\n");
    dprintf("poolused [flags [TAG]]       - Dump usage by pool tag\n");
    dprintf("       flags:  1 Verbose\n");
    dprintf("       flags:  2 Sort by NonPagedPool Usage\n");
    dprintf("       flags:  4 Sort by PagedPool Usage\n");
    dprintf("portcls <devobj> [flags]     - Dumps portcls data for portcls bound devobj\n");
    dprintf("       flags:  1 - Port Dump\n");
    dprintf("       flags:  2 - Filter Dump\n");
    dprintf("       flags:  4 - Pin Dump\n");
    dprintf("       flags:  8 - Device Context\n");
    dprintf("       flags: 10 - Power Info\n");
    dprintf("       flags:100 - Verbose\n");
    dprintf("       flags:200 - Really Verbose\n");
    dprintf("potrigger <address>          - Dumps POP_ACTION_TRIGGER.\n");
    dprintf("process [flags] [image name] - Dumps process at specified address\n");
    dprintf("                (dumps only the process with specified image name, if given)\n");
    dprintf("        flags:         1     - don't stop after cid/image information\n");
    dprintf("                       2     - dump thread wait states\n");
    dprintf("                       4     - dump only thread states, combine with 2 to get stack\n");
    if (TargetMachine==IMAGE_FILE_MACHINE_IA64) {
        dprintf("                       8     - dump return address and BSP in stacktrace\n");
    }
    dprintf("pte <address>                - Dump PDE and PTE for the entered address\n");
    dprintf("ptov PhysicalPageNumber      - Dump all valid physical<->virtual mappings\n");
    dprintf("                               for the given page directory\n");
    dprintf("qlocks                       - Dumps state of all queued spin locks\n");
    dprintf("range <RtlRangeList>         - Dump RTL_RANGE_LIST\n");
    dprintf("ready                        - Dumps state of all READY system threads\n");
    dprintf("reg <command> <params>       - Registry extensions\n");
    dprintf("    kcb        <Address>      - Dump registry key-control-blocks\n");
    dprintf("    knode      <Address>      - Dump registry key-node struct\n");
    dprintf("    kbody      <Address>      - Dump registry key-body struct\n");
    dprintf("    kvalue     <Address>      - Dump registry key-value struct\n");
    dprintf("    baseblock  <HiveAddr>     - Dump the baseblock for the specified hive\n");
    dprintf("    seccache   <HiveAddr>     - Dump the security cache for the specified hive\n");
    dprintf("    hashindex  <conv_key>     - Find the hash entry given a Kcb ConvKey\n");
    dprintf("    openkeys   <HiveAddr|0>   - Dump the keys opened inside the specified hive\n");
    dprintf("    findkcb    <FullKeyPath>  - Find the kcb for the corresponding path\n");
    dprintf("    hivelist                  - Displays the list of the hives in the system\n");
    dprintf("    viewlist   <HiveAddr>     - Dump the pinned/mapped view list for the specified hive\n");
    dprintf("    freebins   <HiveAddr>     - Dump the free bins for the specified hive\n");
    dprintf("    freeceells <BinAddr>      - Dump the free free cells in the specified bin\n");
    dprintf("    dirtyvector<HiveAddr>     - Dump the dirty vector for the specified hive\n");
    dprintf("    cellindex  <HiveAddr> <cellindex> - Finds the VA for a specified cell index\n");
    dprintf("    freehints  <HiveAddr> <Storage> <Display> - Dumps freehint info\n");
    dprintf("    dumppool   [s|r]          - Dump registry allocated paged pool\n");
    dprintf("       s - Save list of registry pages to temporary file\n");
    dprintf("       r - Restore list of registry pages from temp. file\n");
    dprintf("rellist <relation list> [flags] - Dump PNP relation lists\n");
    dprintf("        relation list: address - list specified relation list\n");
    dprintf("        flags:         1     - not used\n");
    dprintf("                       2     - dump CM Resource List\n");
    dprintf("                       4     - dump IO Resource List\n");
    dprintf("                       8     - dump translated CM Resource List\n");
    dprintf("remlock                      - Dump a remove lock structure\n");
    dprintf("rsdt                         - Finds and dumps the ACPI Root System Description Table\n");
    dprintf("session <Id> [flags] [image name] - Dumps sessions\n");
    dprintf("                     (dumps only the process with specified image name, if given)\n");
    dprintf("socket <address>             - Dump pcmcia socket structure\n");
    dprintf("srb <address>                - Dump Srb at specified address\n");
    dprintf("stacks <detail-level>        - Dump summary of current kernel stacks\n");
    dprintf("            detail-level: 0    Display stack summary\n");
    dprintf("            detail-level: 1    Display stacks, no parameters\n");
    dprintf("            detail-level: 2    Display stacks, full parameters\n");
    dprintf("sysptes                      - Dumps the system PTEs\n");
    dprintf("thread [flags]               - Dump current thread, or specified thread,\n");
    dprintf("                                  or with stack containing address\n");
    dprintf("        flags:         1       - not used\n");
    dprintf("                       2       - dump thread wait states\n");
    dprintf("                       4       - dump only thread states, combine with 2 to get stack\n");
    if (TargetMachine==IMAGE_FILE_MACHINE_IA64) {
        dprintf("                       8     - dump return address and BSP in stacktrace\n");
    }
    dprintf("time                         - Reports PerformanceCounterRate and TimerDifference\n");
    dprintf("timer                        - Dumps timer tree\n");
    dprintf("token [flags]                - Dump token at specified address\n");
    dprintf("tunnel <address>             - Dump a file property tunneling cache\n");
    dprintf("tz [<address> <flags>]       - Dumps Thermal Zones. No Args dumps All TZs\n");
    dprintf("tzinfo <address>             - Dumps Thermal Zone Information.\n");
    dprintf("urb <address> <flags>        - Dump a USB Request Block\n");
    dprintf("usblog <log> [addr] [flags]  - Prints out a USB log\n");
    dprintf("       <log>                 - {USBHUB | USBD | UHCD | OpenHCI}\n");
    dprintf("       [addr]                - address to begin dumping from in <log>\n");
    dprintf("       [-r]                  - reset the log to dump from most recent entry\n");
    dprintf("       [-s str]              - search for first instance of a particular tag\n");
    dprintf("                               from the current position; str should be a list\n");
    dprintf("                               of tags delimited by comma's with no whitespace\n");
    dprintf("       [-l n]                - set the number of lines to display at a time to n\n");
    dprintf("usbstruc <address> <type>    - Print out an USB HC descriptor of <type>\n");
    dprintf("                   <type>    - {OHCIReg | HCCA | OHCIHcdED | OHCIHcdTD |\n"
            "                               OHCIEndpoint | DevData | UHCDReg  }\n");
    dprintf("vad                          - Dumps VADs\n");
    dprintf("version                      - Version of extension dll\n");
    dprintf("vm                           - Dumps virtual management values\n");
    dprintf("vpb <address>                - Dumps volume parameter block\n");
    dprintf("vtop DirBase address         - Dumps physical page for virtual address\n");
    dprintf("wdmaud <address> <flags>     - Dumps wdmaud data for structures\n");
    dprintf("       flags:  1 - Ioctl History Dump given WdmaIoctlHistoryListHead\n");
    dprintf("       flags:  2 - Pending Irps given WdmaPendingIrpListHead\n");
    dprintf("       flags:  4 - Allocated MDLs given WdmaAllocatedMdlListHead\n");
    dprintf("       flags:  8 - pContext Dump given WdmaContextListHead\n");
    dprintf("       flags:100 - Verbose\n");
    dprintf("zombies                      - Find all zombie processes\n");


    switch (TargetMachine)
    {
    case IMAGE_FILE_MACHINE_I386:

        dprintf("\n");
        dprintf("X86-specific:\n\n");
        dprintf("apic [base]                    - Dump local apic\n");
        dprintf("callback <address> [num]       - Dump callback frames for specified thread\n");
        dprintf("cbreg <BaseAddr> | %%%%<PhyAddr> - Dump CardBus registers\n");
        dprintf("ioapic [base]                  - Dump io apic\n");
        dprintf("mps                            - Dumps MPS BIOS structures\n");
        dprintf("mtrr                           - Dumps MTTR\n");
        dprintf("npx [base]                     - Dumps NPX save area\n");
        dprintf("pcr                            - Dumps the PCR\n");
        dprintf("pciir                          - Dumps the Pci Irq Routing Table\n");
        dprintf("pic                            - Dumps PIC(8259) information\n");
        dprintf("sel [selector]                 - Examine selector values\n");
        dprintf("\n");
        break;

    case IMAGE_FILE_MACHINE_IA64:
        dprintf("\n");
        dprintf("IA64-specific:\n\n");
        dprintf("btb                              - Dump branch trace buffer  for current processor\n");
        dprintf("bth <processor>                  - Dump branch trace history for target  processor\n");
        dprintf("dcr <address> <dispmode>         - Dump dsr register at specified address\n");
        dprintf("ih  <processor>                  - Dump interrupt history for target processor\n");
        dprintf("ihs <processor>                  - Dump interrupt history for target processor with symbols\n");
        dprintf("isr <address> <dispmode>         - Dump isr register at specified address\n");
        dprintf("pars <address>                   - Dump application registers file at specified address\n");
        dprintf("pcrs <address>                   - Dump control     registers file at specified address\n");
        dprintf("pmc [-opt] <address> <dispmode>  - Dump pmc register at specified address\n");
        dprintf("pmssa <address>                  - Dump minstate save area at specified address\n");
        dprintf("psp <address> <dispmode>         - Dump psp register at specified address\n");
        dprintf("psr <address> <dispmode>         - Dump psr register at specified address\n");
        break;
    default:
        break;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\filelock.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    FileLock.c

Abstract:

    WinDbg Extension Api

Author:

    Dan Lovinger            12-Apr-96

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"

//
//  Common node type codes
// 

#define NTFS_NTC_SCB_DATA 0x705
#define FAT_NTC_FCB 0x502 

//
//  dprintf is really expensive to iteratively call to do the indenting,
//  so we just build up some avaliable spaces to mangle as required
//

#define MIN(a,b) ((a) > (b) ? (b) : (a))

#define MAXINDENT  128
#define INDENTSTEP 2
#define MakeSpace(I)       Space[MIN((I)*INDENTSTEP, MAXINDENT)] = '\0'
#define RestoreSpace(I)    Space[MIN((I)*INDENTSTEP, MAXINDENT)] = ' '

CHAR    Space[MAXINDENT*INDENTSTEP + 1];

__inline VOID CheckForBreak()
/*++

    Purpose:

        Encapsulate control c checking code

    Arguments:

        None

    Return:

        None, raises if break is needed
--*/
{
    if ( CheckControlC() ) {

        RaiseException(0, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }
}

//
//  Helper macros for printing 64bit quantities
//

#define SplitLI(LI) (LI).HighPart, (LI).LowPart

VOID
DumpFileLockInfo(
    ULONG64 pFileLockInfo,
    ULONG Indent
    )
/*++

    Purpose:

        Dump the local internal FILE_LOCK_INFO structure

    Arguments:

        pFileLock   - debugger address of FILE_LOCK_INFO to dump

    Return:

        None

--*/
{
    MakeSpace(Indent);

    InitTypeRead(pFileLockInfo, FILE_LOCK_INFO);
    dprintf("%sStart = %08I64x  Length = %08I64x  End    = %08I64x (%s)\n"
            "%sKey   = %08x   FileOb = %08p   ProcId = %08p\n",
            Space,
            ReadField(StartingByte),
            ReadField(Length),
            ReadField(EndingByte),
            (ReadField(ExclusiveLock) ? "Ex":"Sh"),
            Space,
            (ULONG) ReadField(Key),
            ReadField(FileObject),
            ReadField(ProcessId));

    RestoreSpace(Indent);
}

__inline
ULONG64
ExLockAddress(
    ULONG64 ExLockSplayLinks
    )
{
    static ULONG Off=0, GotOff=0;

    if (!GotOff) {
        if (!GetFieldOffset("nt!_EX_LOCK", "Links", &Off))
            GotOff = TRUE;
    }
    return ExLockSplayLinks ?
                ( ExLockSplayLinks - Off ) : 0;
}

VOID
DumpExclusiveNode(
    ULONG64 ExclusiveNodeSplayLinks,
    ULONG Indent
    )
/*++

    Purpose:

        Dump an exclusive lock node

    Arguments:

        ExclusiveNodeSplayLinks     - splay links of an exclusive node

        Indent                      - indent level to use

    Return:

        None

--*/
{
    ULONG64 Parent, pExLock;
    ULONG Off;

    pExLock = ExLockAddress(ExclusiveNodeSplayLinks);

    if (GetFieldValue(pExLock, "nt!_EX_LOCK", "Links.Parent", Parent)) {
        dprintf("Cannot read nt!_EX_LOCK at %p.\n", pExLock);
        return;
    }

    MakeSpace(Indent);

    InitTypeRead(pExLock, EX_LOCK);
    dprintf("%sLock @ %08x ("
            "P = %08x  R = %08x  L = %08x)\n",
            Space,
            pExLock,
            ExLockAddress(Parent),
            ExLockAddress(ReadField(Links.RightChild)),
            ExLockAddress(ReadField(Links.LeftChild)));

    RestoreSpace(Indent);

    GetFieldOffset("nt!_EX_LOCK", "LockInfo", &Off);
    DumpFileLockInfo(pExLock + Off, Indent);
}

__inline
ULONG64 
LockTreeAddress(
    ULONG64 LockTreeSplayLinks
    )
{
    static ULONG Off=0, GotOff=0;

    if (!GotOff) {
        if (GetFieldOffset("nt!_LOCKTREE_NODE", "Links", &Off))
            GotOff = TRUE;
    }
    return LockTreeSplayLinks ?
                ( LockTreeSplayLinks - Off ) : 0;
}

VOID
DumpSharedNode(
    ULONG64 SharedNodeSplayLinks,
    ULONG Indent
    )
/*++

    Purpose:

        Dump a shared lock node

    Arguments:

        SharedNodeSplayLinks        - splay links of an exclusive node

        Indent                      - indent level to use

    Return:

        None

--*/
{
    ULONG64 pLockTreeNode;
    ULONG64 pShLock;
    ULONG64 pLink, Next;
    ULONG   Off, LockInfoOff;

    pLockTreeNode = LockTreeAddress(SharedNodeSplayLinks);

    if (GetFieldValue(pLockTreeNode, "nt!_LOCKTREE_NODE", "Locks.Next", Next)) {
        dprintf("Cannot read nt!_LOCKTREE_NODE at %p\n", pLockTreeNode);
        return;
    }

    MakeSpace(Indent);

    InitTypeRead(pLockTreeNode, nt!_LOCKTREE_NODE);
    dprintf("%sLockTreeNode @ %08p ("
            "P = %08p  R = %08p  L = %08p)%s\n",
            Space,
            pLockTreeNode,
            LockTreeAddress(ReadField(Links.Parent)),
            LockTreeAddress(ReadField(Links.RightChild)),
            LockTreeAddress(ReadField(Links.LeftChild)),
            (ReadField(HoleyNode) ? " (Holey)" : ""));

    RestoreSpace(Indent);

    GetFieldOffset("nt!_SH_LOCK", "Link", &Off);
    GetFieldOffset("nt!_SH_LOCK", "LockInfo", &LockInfoOff);
    for (pLink = Next;
         pLink;
         pLink = Next) {

        CheckForBreak();

        pShLock = ( pLink - Off);

        if (GetFieldValue(pShLock, "nt!_SH_LOCK", "Link.Next", Next)) {
            dprintf("Cannot read nt!_SH_LOCK AT %p.\n", pShLock);
            return;
        }
    
        MakeSpace(Indent);

        dprintf("%sLock @ %08p\n", Space, pShLock);

        RestoreSpace(Indent);

        DumpFileLockInfo(pShLock + LockInfoOff, Indent);
    }
}

VOID
DumpFileLock(
    ULONG64 pFileLock
    )
/*++

    Purpose:

        Dump the fsrtl FILE_LOCK structure at debugee

    Arguments:

        pFileLock   - debugee address of FILE_LOCK

    Return:

        None

--*/
{
    ULONG64 pFileLockInfo;
    ULONG64 pLockInfo;
    ULONG Count;
    ULONG64 LastReturnedLock, LockInformation, LowestLockOffset;
    ULONG64 SharedLockTree, ExclusiveLockTree;

    if (GetFieldValue(pFileLock, "FILE_LOCK", "LastReturnedLock", LastReturnedLock)) {
        dprintf("Cannot read FILE_LOCK at %p\n", pFileLock);
        return;
    }

    InitTypeRead(pFileLock, FILE_LOCK);
    dprintf("FileLock @ %08p\n"
            "FastIoIsQuestionable = %c\n"
            "CompletionRoutine    = %08p\n"
            "UnlockRoutine        = %08p\n"
            "LastReturnedLock     = %08p\n",
            pFileLock,
            ReadField(FastIoIsQuestionable) ? 'T':'F',
            ReadField(CompleteLockIrpRoutine),
            ReadField(UnlockRoutine),
            LastReturnedLock);
    
    LockInformation = ReadField(LockInformation);

    if (LastReturnedLock != 0) {
        ULONG Off;

        //
        //  We never reset the enumeration info, so it can be out of date ...
        //

        GetFieldOffset("FILE_LOCK", "LastReturnedLockInfo", &Off);
        dprintf("LastReturnedLockInfo:\n");
        DumpFileLockInfo(pFileLock + Off, 0);
    }

    if (LockInformation == 0) {

        dprintf("No Locks\n");
        return;

    } else {

        if (GetFieldValue(LockInformation, "nt!_LOCK_INFO", "LowestLockOffset", LowestLockOffset)) {
            dprintf("Canot read nt!_LOCK_INFO at %p\n", LockInformation);
            return;
        }
    }

    dprintf("LowestLockOffset     = %08p\n\n", LowestLockOffset);

    GetFieldValue(LockInformation, "nt!_LOCK_INFO", "LockQueue.SharedLockTree", SharedLockTree);
    GetFieldValue(LockInformation, "nt!_LOCK_INFO", "LockQueue.ExclusiveLockTree", ExclusiveLockTree);
    
    Count = DumpSplayTree(SharedLockTree, DumpSharedNode);

    if (!Count) {

        dprintf("No Shared Locks\n");
    }

    dprintf("\n");

    Count = DumpSplayTree(ExclusiveLockTree, DumpExclusiveNode);

    if (!Count) {

        dprintf("No Exclusive Locks\n");
    }
}


DECLARE_API( filelock )
/*++

Routine Description:

    Dump file locks

Arguments:

    arg - <Address>

Return Value:

    None

--*/
{
    ULONG64 FileLock = 0;
    CSHORT NodeType = 0;
    CSHORT FileType = 0;
    ULONG64 FsContext = 0;
    ULONG Offset;

    RtlFillMemory(Space, sizeof(Space), ' ');


    if ((FileLock = GetExpression(args)) == 0) {

        //
        //  No args
        //

        return E_INVALIDARG;
    }

    //
    //  We raise out if the user whacketh control-c
    //

    __try {

        //
        //  Test for fileobject
        //  

        GetFieldValue( FileLock, "nt!_FILE_OBJECT", "Type", FileType );

        if (FileType == IO_TYPE_FILE) {

            //
            //  its really a fileobject so grab the fscontext
            // 

            if (!GetFieldValue( FileLock, "nt!_FILE_OBJECT", "FsContext", FsContext )) {
                GetFieldValue( FsContext, "nt!_FSRTL_COMMON_FCB_HEADER", "NodeTypeCode", NodeType );

                dprintf( "%x\n", NodeType );

                if (NodeType == NTFS_NTC_SCB_DATA) {
                    GetFieldValue( FsContext, "ntfs!_SCB", "ScbType.Data.FileLock", FileLock );
                } else if (NodeType == FAT_NTC_FCB) {
                    GetFieldOffset( "fastfat!_FCB",  "Specific", &Offset );
                    dprintf( "Offset: 0x%x\n", Offset );
                    FileLock = FsContext + Offset;
                } else {
                    dprintf( "Unknown fscontext - you'll have to find the filelock within the fileobject manually\n" );
                    return S_OK;
                }
            }

            if (FileLock == 0) {
                dprintf( "There is no filelock in this fileobject\n" );
                return S_OK;
            }
        }

        DumpFileLock(FileLock);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        NOTHING;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\gentable.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    GenTable.c

Abstract:

    WinDbg Extension Api for walking RtlGenericTable structures
    Contains no direct ! entry points, but has makes it possible to
    enumerate through generic tables.  The standard Rtl functions
    cannot be used by debugger extensions because they dereference
    pointers to data on the machine being debugged.  The function
    KdEnumerateGenericTableWithoutSplaying implemented in this
    module can be used within kernel debugger extensions.  The
    enumeration function RtlEnumerateGenericTable has no parallel
    in this module, since splaying the tree is an intrusive operation,
    and debuggers should try not to be intrusive.

Author:

    Keith Kaplan [KeithKa]    09-May-96

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop



ULONG64
KdParent (
    IN ULONG64 pLinks
    )

/*++

Routine Description:

    Analogous to RtlParent macro, but works in the kernel debugger.
    The description of RtlParent follows:

    The macro function Parent takes as input a pointer to a splay link in a
    tree and returns a pointer to the splay link of the parent of the input
    node.  If the input node is the root of the tree the return value is
    equal to the input value.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - Pointer to the splay link of the  parent of the input
                       node.  If the input node is the root of the tree the
                       return value is equal to the input value.

--*/

{
    ULONG64 Parent;

    if ( GetFieldValue( pLinks,
                        "RTL_SPLAY_LINKS",
                        "Parent",
                        Parent) ) {
        dprintf( "%08p: Unable to read pLinks\n", pLinks );
        return 0;
    }

    return Parent;
}



ULONG64
KdLeftChild (
    IN ULONG64 pLinks
    )

/*++

Routine Description:

    Analogous to RtlLeftChild macro, but works in the kernel debugger.
    The description of RtlLeftChild follows:

    The macro function LeftChild takes as input a pointer to a splay link in
    a tree and returns a pointer to the splay link of the left child of the
    input node.  If the left child does not exist, the return value is NULL.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    ULONG64 - Pointer to the splay link of the left child of the input node.
                       If the left child does not exist, the return value is NULL.

--*/

{
    ULONG64 LeftChild;

    if ( GetFieldValue( pLinks,
                        "RTL_SPLAY_LINKS",
                        "LeftChild",
                        LeftChild) ) {
        dprintf( "%08p: Unable to read pLinks\n", pLinks );
        return 0;
    }

    return LeftChild;
}



ULONG64
KdRightChild (
    IN ULONG64 pLinks
    )

/*++

Routine Description:

    Analogous to RtlRightChild macro, but works in the kernel debugger.
    The description of RtlRightChild follows:

    The macro function RightChild takes as input a pointer to a splay link
    in a tree and returns a pointer to the splay link of the right child of
    the input node.  If the right child does not exist, the return value is
    NULL.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - Pointer to the splay link of the right child of the input node.
                       If the right child does not exist, the return value is NULL.

--*/

{
    ULONG64 RightChild;

    if ( GetFieldValue( pLinks,
                        "RTL_SPLAY_LINKS",
                        "RightChild",
                        RightChild) ) {
        dprintf( "%08p: Unable to read pLinks\n", pLinks );
        return 0;
    }

    return RightChild;
}



BOOLEAN
KdIsLeftChild (
    IN ULONG64 Links
    )

/*++

Routine Description:

    Analogous to RtlIsLeftChild macro, but works in the kernel debugger.
    The description of RtlIsLeftChild follows:

    The macro function IsLeftChild takes as input a pointer to a splay link
    in a tree and returns TRUE if the input node is the left child of its
    parent, otherwise it returns FALSE.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    BOOLEAN - TRUE if the input node is the left child of its parent,
              otherwise it returns FALSE.

--*/
{

    return (KdLeftChild(KdParent(Links)) == (Links));

}



BOOLEAN
KdIsRightChild (
    IN ULONG64 Links
    )

/*++

Routine Description:

    Analogous to RtlIsRightChild macro, but works in the kernel debugger.
    The description of RtlIsRightChild follows:

    The macro function IsRightChild takes as input a pointer to a splay link
    in a tree and returns TRUE if the input node is the right child of its
    parent, otherwise it returns FALSE.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    BOOLEAN - TRUE if the input node is the right child of its parent,
              otherwise it returns FALSE.

--*/
{

    return (KdRightChild(KdParent(Links)) == (Links));

}



BOOLEAN
KdIsGenericTableEmpty (
    IN ULONG64 Table
    )

/*++

Routine Description:

    Analogous to RtlIsGenericTableEmpty, but works in the kernel debugger.
    The description of RtlIsGenericTableEmpty follows:

    The function IsGenericTableEmpty will return to the caller TRUE if
    the input table is empty (i.e., does not contain any elements) and
    FALSE otherwise.

Arguments:

    Table - Supplies a pointer to the Generic Table.

Return Value:

    BOOLEAN - if enabled the tree is empty.

--*/

{
    ULONG64 TableRoot;

    if (GetFieldValue(Table, "RTL_GENERIC_TABLE", "TableRoot", TableRoot)) {
        return TRUE;
    }

    //
    // Table is empty if the root pointer is null.
    //

    return ((TableRoot)?(FALSE):(TRUE));

}



ULONG64
KdRealSuccessor (
    IN ULONG64 Links
    )

/*++

Routine Description:

    Analogous to RtlRealSuccessor, but works in the kernel debugger.
    The description of RtlRealSuccessor follows:

    The RealSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node within
    the entire tree.  If there is not a successor, the return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the successor in the entire tree

--*/

{
    ULONG64 Ptr;

    /*
      first check to see if there is a right subtree to the input link
      if there is then the real successor is the left most node in
      the right subtree.  That is find and return P in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  P
                   \
    */

    if ((Ptr = KdRightChild(Links)) != 0) {

        while (KdLeftChild(Ptr) != 0) {
            Ptr = KdLeftChild(Ptr);
        }

        return Ptr;

    }

    /*
      we do not have a right child so check to see if have a parent and if
      so find the first ancestor that we are a left decendent of. That
      is find and return P in the following diagram

                       P
                      /
                     .
                      .
                       .
                      Links
    */

    Ptr = Links;
    while (KdIsRightChild(Ptr)) {
        Ptr = KdParent(Ptr);
    }

    if (KdIsLeftChild(Ptr)) {
        return KdParent(Ptr);
    }

    //
    //  otherwise we are do not have a real successor so we simply return
    //  NULL
    //

    return 0;

}



ULONG64
KdEnumerateGenericTableWithoutSplaying (
    IN ULONG64  pTable,
    IN PULONG64 RestartKey
    )

/*++

Routine Description:

    Analogous to RtlEnumerateGenericTableWithoutSplaying, but works in the
    kernel debugger.  The description of RtlEnumerateGenericTableWithoutSplaying
    follows:

    The function EnumerateGenericTableWithoutSplaying will return to the
    caller one-by-one the elements of of a table.  The return value is a
    pointer to the user defined structure associated with the element.
    The input parameter RestartKey indicates if the enumeration should
    start from the beginning or should return the next element.  If the
    are no more new elements to return the return value is NULL.  As an
    example of its use, to enumerate all of the elements in a table the
    user would write:

        *RestartKey = NULL;

        for (ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey);
             ptr != NULL;
             ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
                :
        }

Arguments:

    Table - Pointer to the generic table to enumerate.

    RestartKey - Pointer that indicates if we should restart or return the next
                element.  If the contents of RestartKey is NULL, the search
                will be started from the beginning.

Return Value:

    PVOID - Pointer to the user data.

--*/

{

    ULONG Result;
    ULONG64 TableRoot;

    RTL_GENERIC_TABLE Table;

    if ( GetFieldValue(pTable,
                       "RTL_GENERIC_TABLE",
                       "TableRoot",
                       TableRoot) ) {
        dprintf( "%08p: Unable to read pTable\n", pTable );
        return 0;
    }

    if (!TableRoot) {

        //
        // Nothing to do if the table is empty.
        //

        return 0;

    } else {

        //
        // Will be used as the "iteration" through the tree.
        //
        ULONG64 NodeToReturn;

        //
        // If the restart flag is true then go to the least element
        // in the tree.
        //

        if (*RestartKey == 0) {

            //
            // We just loop until we find the leftmost child of the root.
            //

            for (
                NodeToReturn = TableRoot;
                KdLeftChild(NodeToReturn);
                NodeToReturn = KdLeftChild(NodeToReturn)
                ) {
                ;
            }

            *RestartKey = NodeToReturn;

        } else {

            //
            // The caller has passed in the previous entry found
            // in the table to enable us to continue the search.  We call
            // KdRealSuccessor to step to the next element in the tree.
            //

            NodeToReturn = KdRealSuccessor(*RestartKey);

            if (NodeToReturn) {

                *RestartKey = NodeToReturn;

            }

        }

        //
        // If there actually is a next element in the enumeration
        // then the pointer to return is right after the list links.
        //

        return ((NodeToReturn)?
                   (NodeToReturn+GetTypeSize("RTL_GENERIC_TABLE")+DBG_PTR_SIZE)
                  :0);

    }

}


//+---------------------------------------------------------------------------
//
//  Function:   gentable 
//
//  Synopsis:   dump a generic splay table only showing ptrs
//
//  Arguments:  
//
//  Returns:    
//
//  History:    5-14-1999   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

DECLARE_API( gentable ) 
{
    ULONG64            RestartKey;
    ULONG64            Ptr;
    ULONG64            Table;
    ULONG              RowOfData[4];
    ULONG64            Address;
    ULONG              Result;

    Table = GetExpression(args);

    RestartKey = 0;

    dprintf( "node:               parent     left       right\n" );
//            0x12345678:         0x12345678 0x12345678 0x12345678
    for (Ptr = KdEnumerateGenericTableWithoutSplaying(Table, &RestartKey);
         Ptr != 0;
         Ptr = KdEnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
            
        if (Ptr) {
            Address = Ptr - GetTypeSize("RTL_SPLAY_LINKS") - GetTypeSize( "LIST_ENTRY" );

            if ( !ReadMemory( Address, &RowOfData, sizeof( RowOfData ), &Result) ) {
                dprintf( "%08p: Unable to read link\n", Address );
            } else {
                dprintf( "0x%p: 0x%08p 0x%08p 0x%08p\n", 
                         Address, KdParent(Address), KdLeftChild(Address), KdRightChild(Address));
            }

            if ( !ReadMemory(  Ptr, &RowOfData, sizeof( RowOfData ), &Result) ) {
                dprintf( "%08p: Unable to read userdata\n", Ptr );
            } else {
                Address = Ptr;
                dprintf( "0x%p: 0x%08p 0x%08p 0x%08p\n", 
                         Address, KdParent(Address), KdLeftChild(Address), KdRightChild(Address));
            }
        }

        if (CheckControlC() ) {
            return E_INVALIDARG;
        }

    }

    return S_OK;
} // DECLARE_API

DECLARE_API( devinst )
{
    ULONG64             table;
    ULONG64             restartKey;
    ULONG64             ptr;
    ULONG64             address;
    CHAR                deviceReferenceType[] = "nt!_DEVICE_REFERENCE";
    CHAR                unicodeStringType[] = "nt!_UNICODE_STRING";
    ULONG64             deviceObject;
    UNICODE_STRING64    u;
    ULONG64             instance;

    table = GetExpression("nt!PpDeviceReferenceTable");
    if (table) {

        dprintf("DeviceObject: InstancePath\n");
        restartKey = 0;
        while ((ptr = KdEnumerateGenericTableWithoutSplaying(table, &restartKey))) {

            address = ptr - GetTypeSize("RTL_SPLAY_LINKS") - GetTypeSize("LIST_ENTRY");

            if (GetFieldValue(address, deviceReferenceType, "DeviceObject", deviceObject)) {

                dprintf("Failed to get the value of DeviceObject from %s(0x%p)\n", deviceReferenceType, address);
                break;
            }
            if (GetFieldValue(address, deviceReferenceType, "DeviceInstance", instance)) {

                dprintf("Failed to get the value of DeviceInstance from %s(0x%p)\n", deviceReferenceType, address);
                break;
            }
            if (GetFieldValue(instance, unicodeStringType, "Length", u.Length)) {

                dprintf("Failed to get the value of Length from %s(0x%p)\n", unicodeStringType, instance);
                break;
            }
            if (GetFieldValue(instance, unicodeStringType, "MaximumLength", u.MaximumLength)) {

                dprintf("Failed to get the value of Length from %s(0x%p)\n", unicodeStringType, instance);
                break;
            }
            if (GetFieldValue(instance, unicodeStringType, "Buffer", u.Buffer)) {

                dprintf("Failed to get the value of Length from %s(0x%p)\n", unicodeStringType, instance);
                break;
            }
            dprintf("!devstack %p: ", deviceObject); DumpUnicode64(u); dprintf("\n");
        }
    } else {

        dprintf("Could not read address of nt!PpDeviceReferenceTable\n");
    }
    return S_OK;
}

DECLARE_API( blockeddrv )
{
    ULONG64             table;
    ULONG64             restartKey;
    ULONG64             ptr;
    ULONG64             address;
    CHAR                cacheEntryType[] = "nt!_DDBCACHE_ENTRY";
    CHAR                unicodeStringType[] = "nt!_UNICODE_STRING";
    UNICODE_STRING64    u;
    ULONG64             unicodeString;
    ULONG64             name;
    NTSTATUS            status;
    GUID                guid;

    table = GetExpression("nt!PiDDBCacheTable");
    if (table) {

        dprintf("Driver:\tStatus\tGUID\n");
        restartKey = 0;
        while ((ptr = KdEnumerateGenericTableWithoutSplaying(table, &restartKey))) {

            address = ptr - GetTypeSize("RTL_SPLAY_LINKS") - GetTypeSize("LIST_ENTRY");

            if (GetFieldValue(address, cacheEntryType, "Name", name)) {

                dprintf("Failed to get the value of Name from %s(0x%p)\n", cacheEntryType, address);
                break;
            }
            if (GetFieldValue(name, unicodeStringType, "Length", u.Length)) {

                dprintf("Failed to get the value of Length from %s(0x%p)\n", unicodeStringType, name);
                break;
            }
            if (GetFieldValue(name, unicodeStringType, "MaximumLength", u.MaximumLength)) {

                dprintf("Failed to get the value of Length from %s(0x%p)\n", unicodeStringType, name);
                break;
            }
            if (GetFieldValue(name, unicodeStringType, "Buffer", u.Buffer)) {

                dprintf("Failed to get the value of Length from %s(0x%p)\n", unicodeStringType, name);
                break;
            }

            if (GetFieldValue(address, cacheEntryType, "Status", status)) {

                dprintf("Failed to get the value of Name from %s(0x%p)\n", cacheEntryType, address);
                break;
            }

            if (GetFieldValue(address, cacheEntryType, "Guid", guid)) {

                dprintf("Failed to get the value of Name from %s(0x%p)\n", cacheEntryType, address);
                break;
            }

            DumpUnicode64(u); 
            dprintf("\t%x: ", status); 
            dprintf("\t{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\n",
                       guid.Data1,
                       guid.Data2,
                       guid.Data3,
                       guid.Data4[0],
                       guid.Data4[1],
                       guid.Data4[2],
                       guid.Data4[3],
                       guid.Data4[4],
                       guid.Data4[5],
                       guid.Data4[6],
                       guid.Data4[7] );
        }
    } else {

        dprintf("Could not read address of nt!PiDDBCacheTable\n");
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\gentable.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    GenTable.c

Abstract:

    WinDbg Extension Api for walking RtlGenericTable structures
    Contains no direct ! entry points, but has makes it possible to
    enumerate through generic tables.  The standard Rtl functions
    cannot be used by debugger extensions because they dereference
    pointers to data on the machine being debugged.  The function
    KdEnumerateGenericTableWithoutSplaying implemented in this
    module can be used within kernel debugger extensions.  The
    enumeration function RtlEnumerateGenericTable has no parallel
    in this module, since splaying the tree is an intrusive operation,
    and debuggers should try not to be intrusive.

Author:

    Keith Kaplan [KeithKa]    09-May-96

Environment:

    User Mode.

Revision History:

--*/


PRTL_SPLAY_LINKS
KdParent (
    IN PRTL_SPLAY_LINKS pLinks
    );

PRTL_SPLAY_LINKS
KdLeftChild (
    IN PRTL_SPLAY_LINKS pLinks
    );

PRTL_SPLAY_LINKS
KdRightChild (
    IN PRTL_SPLAY_LINKS pLinks
    );

BOOLEAN
KdIsLeftChild (
    IN PRTL_SPLAY_LINKS Links
    );

BOOLEAN
KdIsRightChild (
    IN PRTL_SPLAY_LINKS Links
    );

BOOLEAN
KdIsGenericTableEmpty (
    IN PRTL_GENERIC_TABLE Table
    );

PRTL_SPLAY_LINKS
KdRealSuccessor (
    IN PRTL_SPLAY_LINKS Links
    );

PVOID
KdEnumerateGenericTableWithoutSplaying (
    IN PRTL_GENERIC_TABLE pTable,
    IN PVOID *RestartKey
    );



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\handle.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    WinDbg Extension Api

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

BOOL
DumpHandles (
    IN ULONG64      RealProcessBase,
    IN ULONG64      HandleToDump,
    IN ULONG64      pObjectType,
    IN ULONG        Flags
    );

BOOLEAN
DumpHandle(
   IN ULONG64              pHandleTableEntry,
   IN ULONG64              Handle,
   IN ULONG64              pObjectType,
   IN ULONG                Flags
   );

DECLARE_API( handle  )

/*++

Routine Description:

    Dump the active handles

Arguments:

    args - [handle-to-dump [flags [process [TypeName]]]]
            if handle-to-dump is 0 dump all

Return Value:

    None

--*/

{

    ULONG64      ProcessToDump;
    ULONG64      HandleToDump;
    ULONG        Flags;
    ULONG        Result;
    ULONG        nArgs;
    ULONG64      Next;
    ULONG64      ProcessHead;
    ULONG64      Process;
    char         TypeName[ MAX_PATH ];
    ULONG64      pObjectType;
    ULONG64      UserProbeAddress;
    ULONG        ActiveProcessLinksOffset=0;
    ULONG64 UniqueProcessId=0, ActiveProcessLinks_Flink=0;
    FIELD_INFO procLink[] = {
        {"ActiveProcessLinks", "", 0, DBG_DUMP_FIELD_RETURN_ADDRESS,   0, NULL},
        {"UniqueProcessId",    "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &UniqueProcessId},
        {"ActiveProcessLinks.Flink","", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &ActiveProcessLinks_Flink},
    };
    SYM_DUMP_PARAM EProc = {
        sizeof (SYM_DUMP_PARAM), "nt!_EPROCESS", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 3, &procLink[0],
    };
    ULONG dwProcessor=0;
    CHAR  Addr1[100], Addr2[100];

    GetCurrentProcessor(Client, &dwProcessor, NULL);
    HandleToDump  = 0;
    Flags         = 0x3; //by default dump bodies and objects for in use entries
    ProcessToDump = -1;
    UserProbeAddress = GetNtDebuggerDataValue(MmUserProbeAddress);

    dprintf("processor number %d\n", dwProcessor);

    Addr1[0] = 0;
    Addr2[0] = 0;
    nArgs = 0;
    if (GetExpressionEx(args, &HandleToDump, &args)) {
        ULONG64 tmp;
        ++nArgs;
        if (GetExpressionEx(args, &tmp, &args)) {
            ULONG i;
            Flags = (ULONG) tmp;
            ++nArgs;
            while (args && (*args == ' ')) { 
                ++args;
            }

            // Do not use GetExpressionEx since it will search for TypeName
            // in symbols
            i=0;
            while (*args && (*args != ' ')) { 
                Addr1[i++] = *args++;
            }
            Addr1[i] = 0;
            if (Addr1[0]) {
                ProcessToDump = GetExpression(Addr1);
                ++nArgs;
                while (args && (*args == ' ')) { 
                    ++args;
                }
                strcpy(TypeName, args);

                if (TypeName[0]) ++nArgs;
            }
        }
    }

    if (ProcessToDump == -1) {
        GetCurrentProcessAddr( dwProcessor, 0, &ProcessToDump );
        if (ProcessToDump == 0) {
            dprintf("Unable to get current process pointer.\n");
            return E_INVALIDARG;
        }
    }

    pObjectType = 0;
    if (nArgs > 3 && FetchObjectManagerVariables(FALSE)) {
        pObjectType = FindObjectType( TypeName );
    }

    if (ProcessToDump == 0) {
        dprintf("**** NT ACTIVE PROCESS HANDLE DUMP ****\n");
        if (Flags == 0xFFFFFFFF) {
            Flags = 1;
        }
    }

    //
    // If a process id is specified, then search the active process list
    // for the specified process id.
    //

    if (ProcessToDump < UserProbeAddress) {
        ULONG64 List_Flink=0, List_Blink=0;
        FIELD_INFO listFields[] = {
            {"Flink", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &List_Flink},
            {"Blink", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &List_Blink},
        };
        SYM_DUMP_PARAM Lst = {
            sizeof (SYM_DUMP_PARAM), "nt!_LIST_ENTRY", DBG_DUMP_NO_PRINT,
            0, NULL, NULL, NULL, 2, &listFields[0]
        };
        
        ProcessHead = GetNtDebuggerData( PsActiveProcessHead );
        if ( !ProcessHead ) {
            dprintf("Unable to get value of PsActiveProcessHead\n");
            return E_INVALIDARG;
        }

        Lst.addr = ProcessHead;
        if (Ioctl(IG_DUMP_SYMBOL_INFO, &Lst, Lst.size)) {
            dprintf("Unable to find _LIST_ENTRY type, ProcessHead: %08I64x\n", ProcessHead);
            return E_INVALIDARG;
        }

        if (ProcessToDump != 0) {
            dprintf("Searching for Process with Cid == %I64lx\n", ProcessToDump);
        }

        Next = List_Flink;
        
        if (Next == 0) {
            dprintf("PsActiveProcessHead is NULL!\n");
            return E_INVALIDARG;
        }

    } else {
        Next = 0;
        ProcessHead = 1;
    }

    if (pObjectType != 0) {
        dprintf("Searching for handles of type %s\n", TypeName);
    }

    if (GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &ActiveProcessLinksOffset)) {
        dprintf("Unable to find _EPROCESS type\n");
        return E_INVALIDARG;
    }

    while(Next != ProcessHead) {


        if ( CheckControlC() ) {
            return E_INVALIDARG;
        }

        if (Next != 0) {
            Process = Next - ActiveProcessLinksOffset;

        } else {
            Process = ProcessToDump;
        }

        EProc.addr = Process;
        if (Ioctl(IG_DUMP_SYMBOL_INFO, &EProc, EProc.size)) {
           dprintf("_EPROCESS Ioctl failed at %p\n",Process);
           return E_INVALIDARG;
        } 
        
        if (ProcessToDump == 0 ||
            ProcessToDump < UserProbeAddress && ProcessToDump == UniqueProcessId ||
            ProcessToDump >= UserProbeAddress && ProcessToDump == Process
           ) {
            if (DumpProcess ("", Process, 0, NULL)) {
                if (!DumpHandles ( Process, HandleToDump, pObjectType, Flags)) {
                    break;
                }

            } else {
                break;
            }
        }

        if (Next == 0) {
            break;
        }
        Next = ActiveProcessLinks_Flink;
    }
    return S_OK;
}

#define KERNEL_HANDLE_MASK 0x80000000

//+---------------------------------------------------------------------------
//
//  Function:   DumpHandles
//
//  Synopsis:   Dump the handle table for the given process
//
//  Arguments:  [RealProcessBase] -- base address of the process
//              [HandleToDump]    -- handle to look for - if 0 dump all
//              [pObjectType]     -- object type to look for
//              [Flags]           -- flags passed thru to DumpHandle
//                                   if 0x10 is set dump the kernel handle table
//
//  Returns:    TRUE if successful
//
//  History:    1-12-1998   benl   Created
//
//  Notes: Each segment of table has 0xFF or 8 bits worth of entries
//         the handle number's lowest 2 bit are application defined
//         so the indexes are gotten from the 3 8 bits ranges after
//         the first 2 bits
//
//----------------------------------------------------------------------------

BOOL
DumpHandles (
    IN ULONG64      RealProcessBase,
    IN ULONG64      HandleToDump,
    IN ULONG64      pObjectType,
    IN ULONG        Flags
    )

{
    ULONG64             ObjectTable=0;
    ULONG               ulRead;
    ULONG64             ulTopLevel;
    ULONG64             ulMidLevel;
    ULONG               ulHandleNum = ((ULONG)(HandleToDump) >> 2);
    ULONG               iIndex1;
    ULONG               iIndex2;
    ULONG               iIndex3;
    ULONG               ptrSize, hTableEntrySize;
    ULONG64             tablePtr;
    ULONG64             HandleCount = 0;
    ULONG64             Table = 0;
    ULONG64             UniqueProcessId = 0;
    BOOL                KernelHandle = FALSE, CidHandle = FALSE;

    ULONG               LowLevelCounts = 256;
    ULONG               MidLevelCounts = 256;
    ULONG               HighLevelCounts = 256;
    ULONG               TableLevel = 2;
    BOOLEAN             NewStyle = FALSE;

    //
    //  Typeinfo parsing structures
    //  

    FIELD_INFO  procFields[] = {
        {"ObjectTable", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &ObjectTable},
    };
    
    FIELD_INFO handleTblFields[] = {
        {"HandleCount", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &HandleCount},
        {"UniqueProcessId", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &UniqueProcessId},
    };
    
    SYM_DUMP_PARAM handleSym = {
        sizeof (SYM_DUMP_PARAM), "nt!_EPROCESS", DBG_DUMP_NO_PRINT, RealProcessBase,
        NULL, NULL, NULL, 1, &procFields[0]
    };

    //
    //  Check for kernel handle table 
    // 

    if ((Flags & 0x10) || ((ulHandleNum != 0) && (((ULONG_PTR)HandleToDump & KERNEL_HANDLE_MASK) == KERNEL_HANDLE_MASK))) {

        ULONG64 KernelTableAddr;

        KernelHandle = TRUE;

        KernelTableAddr = GetExpression( "nt!ObpKernelHandleTable" );
        if (!KernelTableAddr) {
            dprintf( "Unable to find ObpKernelHandleTable\n" );
            return FALSE;
        }

        if (!ReadPointer(KernelTableAddr, &ObjectTable)) {
            dprintf( "Unable to find ObpKernelHandleTable at %p\n", KernelTableAddr );
            return FALSE;
        } 

    } else if (Flags & 0x20) {

        CidHandle = TRUE;
        ObjectTable = GetNtDebuggerDataValue(PspCidTable);
        if (!ObjectTable) {
            dprintf( "Unable to find PspCidTable\n" );
            return FALSE;
        }

    } else {
        
        if (Ioctl(IG_DUMP_SYMBOL_INFO, &handleSym, handleSym.size)) {
            dprintf("Unable to get ObjectTable address from process %I64x\n", RealProcessBase);
            return FALSE;
        }
    }
    
    ptrSize = DBG_PTR_SIZE;
    if (!ptrSize) {
        dprintf("Cannot get pointer size\n");
        return FALSE;
    }

    handleSym.sName = "nt!_HANDLE_TABLE"; handleSym.addr = ObjectTable;
    handleSym.nFields = sizeof (handleTblFields) / sizeof (FIELD_INFO);
    handleSym.Fields = &handleTblFields[0];

    if (!ObjectTable || 
        Ioctl(IG_DUMP_SYMBOL_INFO, &handleSym, handleSym.size)) {
        dprintf("%08p: Unable to read handle table\n",
                ObjectTable);
        return FALSE;
    }
    
    if (GetFieldValue(ObjectTable, "nt!_HANDLE_TABLE", "TableCode", Table)) {
        // Could be older build
    }

    if (Table != 0) {

        NewStyle = TRUE;
        LowLevelCounts = 512;
        MidLevelCounts = 1024;
        HighLevelCounts = 1024;

        TableLevel = (ULONG)(Table & 3);
        Table &= ~((ULONG64)3);

    } else if (GetFieldValue(ObjectTable, "nt!_HANDLE_TABLE", "Table", Table) ) {
        
        dprintf("%08p: Unable to read Table field from _HANDLE_TABLE\n",
                ObjectTable);
        return FALSE;
    }

    if (KernelHandle) {
        dprintf( "Kernel " );
    }
    else if (CidHandle) {
        dprintf( "Cid " );
    }

    dprintf("%s version of handle table  at %p with %I64d %s in use\n",
            (NewStyle ? "New" : "Old"),
            Table,
            HandleCount,
            ((HandleCount == 1) ? "Entry" : "Entries"));

    hTableEntrySize = GetTypeSize("nt!_HANDLE_TABLE_ENTRY");

    if (ulHandleNum != 0) {

        if (NewStyle) {
            
            ULONG64 CrtTable = Table;
            ULONG64 CrtHandleNum = ulHandleNum;

            if (TableLevel == 2) {

                ULONG64 HighLevelIndex = ulHandleNum / (LowLevelCounts * MidLevelCounts);

                CrtTable =  CrtTable + HighLevelIndex * ptrSize;

                if (!ReadPointer(CrtTable,
                             &CrtTable)) {
                    dprintf("%08p: Unable to read handle table level 3\n", CrtTable );
                    return FALSE;
                }

                CrtHandleNum = ulHandleNum - HighLevelIndex * (LowLevelCounts * MidLevelCounts);
            }

            if (TableLevel == 1) {
                
                CrtTable =  CrtTable + (CrtHandleNum / LowLevelCounts) * ptrSize;
                
                if (!ReadPointer(CrtTable,
                             &CrtTable)) {
                    dprintf("%08p: Unable to read handle table level 2\n", CrtTable );
                    return FALSE;
                }

                CrtHandleNum = CrtHandleNum % LowLevelCounts;
            }

            tablePtr = CrtTable + CrtHandleNum * hTableEntrySize;
            
        } else {

            //
            //  Read the 3 level table stage by stage to find the specific entry
            //
            
            tablePtr = Table + ((ulHandleNum & 0x00FF0000) >> 16) * ptrSize;
            ulTopLevel = 0;
            if (!ReadPointer(tablePtr,
                         &ulTopLevel)) {
                dprintf("%08p: Unable to read handle table level 3\n", tablePtr );
                return FALSE;
            }

            if (!ulTopLevel) {
                dprintf("Invalid handle: 0x%x\n", ulHandleNum);
                return FALSE;
            }

            tablePtr = ulTopLevel + ((ulHandleNum & 0x0000FF00) >> 8) * ptrSize;
            ulMidLevel = 0;
            if (!ReadPointer(tablePtr,
                         &ulMidLevel)) {
                dprintf("%08p: Unable to read handle table level 2\n", tablePtr);
                return FALSE;
            }

            if (!ulMidLevel) {
                dprintf("Invalid handle: 0x%x\n", ulHandleNum);
                return FALSE;
            }

            //
            //  Read the specific entry req. and dump it
            //  
            
            tablePtr = (ulMidLevel + (0x000000ff & ulHandleNum) * hTableEntrySize);
        }
        
        DumpHandle(tablePtr, HandleToDump, pObjectType, Flags);

    } else {
        
        //
        //  loop over all the possible parts of the table
        //

        for (iIndex1=0; iIndex1 < HighLevelCounts; iIndex1++) {
            
            //
            //  check for ctrl-c to abort
            //

            if (CheckControlC()) {
                return FALSE;
            }

            if (TableLevel < 2) {
            
                tablePtr = Table;
                ulTopLevel = tablePtr;

                //
                //  We break the loop second time if we don't have the table level 2
                //

                if (iIndex1 > 0) {
                    break;
                }
            
            } else {
                
                //
                //  Read the 3 level table stage by stage to find the specific entry
                // 
                
                tablePtr = Table + iIndex1 * ptrSize;
                ulTopLevel = 0;
                if (!ReadPointer(tablePtr,
                            &ulTopLevel)) {
                    dprintf("%08p: Unable to read handle table top level\n",
                            tablePtr);
                    return FALSE;
                }

                if (!ulTopLevel) {
                    continue;
                }
            }

            for (iIndex2=0; iIndex2 < MidLevelCounts; iIndex2++) {

                //
                //  check for ctrl-c to abort
                //

                if (CheckControlC()) {
                    return FALSE;
                }

                if (TableLevel < 1) {
                
                    tablePtr = Table;
                    ulMidLevel = tablePtr;
                    
                    //
                    //  We break the loop second time if we don't have the table level 1
                    //

                    if (iIndex2 > 0) {
                        break;
                    }
                
                } else {

                    tablePtr = ulTopLevel + iIndex2 * ptrSize;
                    ulMidLevel = 0;
                    if (!ReadPointer(tablePtr,
                                &ulMidLevel)) {
                        dprintf("%08p: Unable to read handle table middle level\n",
                                tablePtr);
                        return FALSE;
                    }

                    if (!ulMidLevel) {
                        continue;
                    }
                }

                //
                //  now read all the entries in this segment of the table and dump them
                //  Note: Handle Number = 6 unused bits + 8 bits high + 8 bits mid +
                //  8 bits low + 2 bits user defined
                //

                for (iIndex3 = 0; iIndex3 < LowLevelCounts; iIndex3++) {
                    
                    //
                    //  check for ctrl-c to abort
                    //

                    if (CheckControlC()) {
                        return FALSE;
                    }

                    DumpHandle(ulMidLevel + iIndex3*hTableEntrySize, 
                               (iIndex3 + (iIndex2 + iIndex1 * MidLevelCounts) * LowLevelCounts) * 4,
                               pObjectType, Flags);

                }
            }
        } //  end outermost for
    } //  endif on a specific handle

    return TRUE;
} // DumpHandles


//+---------------------------------------------------------------------------
//
//  Function:   DumpHandle
//
//  Synopsis:   Dump a particular Handle
//
//  Arguments:  [pHandleTableEntry] --  entry to dump
//              [Handle]            --  handle number of entry
//              [pObjectType]       --  only dump if object type matches this
//                                      if NULL dump everything
//              [Flags]             --  flags if 0x2 also dump the object
//                                            if 0x4 dump free entries
//
//  Returns:
//
//  History:    1-12-1998   benl   Created
//              1-12-1998   benl   modified
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOLEAN
DumpHandle(
    IN ULONG64              pHandleTableEntry,
    IN ULONG64              Handle,
    IN ULONG64              pObjectType,
    IN ULONG                Flags
    )
{
    ULONG64       ulObjectHeaderAddr;
    ULONG         Result;

    ULONG         HandleAttributes;
//    OBJECT_HEADER ObjectHeader;
    ULONG64       ObjectBody;
    ULONG         GrantedAccess=0;
    ULONG64       Object=0, ObjType=0;
    
    FIELD_INFO hTableEntryFields[] = {
        {"Object",        "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Object},
        {"GrantedAccess", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &GrantedAccess},
    };
    FIELD_INFO ObjHeaderFields[] = {
        {"Type", "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &ObjType},
        {"Body", "", 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL},
    };

    SYM_DUMP_PARAM ObjSym = {
        sizeof (SYM_DUMP_PARAM), "nt!_HANDLE_TABLE_ENTRY", DBG_DUMP_NO_PRINT, pHandleTableEntry,
        NULL, NULL, NULL, sizeof (hTableEntryFields) /sizeof (FIELD_INFO), &hTableEntryFields[0],
    };

    if (Ioctl (IG_DUMP_SYMBOL_INFO, &ObjSym, ObjSym.size)) {
        dprintf("Unable to get _HANDLE_TABLE_ENTRY : %p\n", pHandleTableEntry);
        return FALSE;
    }

    if (!(Object)) {
        //only print if flag is set to 4
        if (Flags & 4)
        {
            dprintf("%04lx: free handle\n", Handle);
        }
        return TRUE;
    }

    if (BuildNo > 2230) {
//    if (GetExpression( "nt!ObpAccessProtectCloseBit" )) {

        //
        //  we have a new handle table style
        //

        //actual hdr has the lowest 3 bits cancelled out
        //lower 3 bits mark auditing, inheritance and lock

        ulObjectHeaderAddr = (Object) & ~(0x7);

        //
        //  Apply the sign extension, if the highest bit is set
        //

        if ( !IsPtr64() && 
             (Object & 0x80000000)) {

            ulObjectHeaderAddr |= 0xFFFFFFFF00000000L;
        }

    } else {
        
        //actual hdr is sign extend value with the lowest 3 bits cancelled out
        //top bit marks whether entry is locked
        //lower 3 bits mark auditing, inheritance and protection

        if (!IsPtr64()) {
            ulObjectHeaderAddr = ((Object) & ~(0x7)) | 0xFFFFFFFF80000000L;
        } else {
            ulObjectHeaderAddr = ((Object) & ~(0x7)) | 0x8000000000000000L;
        }
    }

    ObjSym.sName = "nt!_OBJECT_HEADER"; ObjSym.addr = ulObjectHeaderAddr;
    ObjSym.nFields = sizeof (ObjHeaderFields) / sizeof (FIELD_INFO);
    ObjSym.Fields = &ObjHeaderFields[0];
    if (Ioctl ( IG_DUMP_SYMBOL_INFO, &ObjSym, ObjSym.size)) {
        dprintf("%08p: Unable to read nonpaged object header\n",
                ulObjectHeaderAddr);
        return FALSE;
    }

    if (pObjectType != 0 && ObjType != pObjectType) {
        return TRUE;
    }

    if (Flags & 0x20) {
        //
        // PspCidTable contains pointer to object, not object header
        // Compute header address based on object.
        //
        ObjectBody = ulObjectHeaderAddr;
        ulObjectHeaderAddr -= ObjHeaderFields[1].address-ulObjectHeaderAddr;
    }
    else {
        ObjectBody =  ObjHeaderFields[1].address;
    }
    
    dprintf("%04I64lx: Object: %08p  GrantedAccess: %08lx",
            Handle,
            ObjectBody,
            (GrantedAccess & ~MAXIMUM_ALLOWED));

    if (BuildNo > 2230) {
//      if (GetExpression( "nt!ObpAccessProtectCloseBit" )) {

        //
        //  New handle table style
        //
        
        if (((ULONG) Object & 1) == 0) {
            dprintf(" (Locked)");
        }

        if (GrantedAccess & MAXIMUM_ALLOWED) {
            dprintf(" (Protected)");
        }

    } else {
        
        if (IsPtr64()) {
            if (Object & 0x8000000000000000L) {
                dprintf(" (Locked)");
            }    
        } else if ((ULONG) Object & 0x80000000) {
            dprintf(" (Locked)");
        }

        if (Object & 1) {
            dprintf(" (Protected)");
        }
    }

    if (Object & 2) {
        dprintf(" (Inherit)");
    }

    if (Object & 4) {
        dprintf(" (Audit)");
    }

    dprintf("\n");
    if (Flags & 2) {
        DumpObject( "    ", ObjectBody, Flags );
    }

    EXPRLastDump = ObjectBody;
    dprintf("\n");
    return TRUE;
} // DumpHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\hid.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    HID.c

Abstract:

    WinDbg Extension Api

Author:

    Kenneth D. Ray (kenray) June 1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
typedef union _HID_PPD_FLAGS {
    struct {
        ULONG   InputChannels       : 1;
        ULONG   OutputChannels      : 1;
        ULONG   FeatureChannels     : 1;
        ULONG   LinkCollections     : 1;
        ULONG   FullChannelListing  : 1;
        ULONG   ReportLocation      : 1;
        ULONG   Reserved            : 25;
        ULONG   IgnoreSignature     : 1;
    };
    ULONG64 Flags;
} HID_PPD_FLAGS;

typedef union _HID_FLAGS {
    struct {
        ULONG   FullListing         : 1;
        ULONG   PowerListing        : 1;
        ULONG   HidPDeviceDesc      : 1;
        ULONG   FileListing         : 1;
        ULONG   Reserved            : 27;
    };
    ULONG64 Flags;
} HID_FLAGS;

#define PRINT_FLAGS(value, flag) \
    if ((value) & (flag)) { \
        dprintf (#flag " "); \
    }


//
// Local function declarations
//

VOID HID_DumpPpd (ULONG64 Ppd, HID_PPD_FLAGS Flags);
VOID HID_DumpFDOExt (ULONG64 Fdo);
VOID HID_DumpPDOExt (ULONG64 Pdo);


DECLARE_API( hidppd )

/*++

Routine Description:

   Dumps a HID Preparsed Data blob

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG64                 memLoc=0;
    ULONG                   result;
    ULONG                   size;
    HID_PPD_FLAGS           flags;
    ULONG                   InSize;

    flags.Flags = 0;

    if (!*args) {
        dprintf ("hidppd <address> [flags]\n");
    } else {
        if (GetExpressionEx(args, &memLoc, &args)) {
            GetExpressionEx(args, &(flags.Flags), &args);
        }
    }

    dprintf ("Dump Ppd %p %x \n", memLoc, (ULONG)flags.Flags);

    //
    // Get the preparsed data
    //

    if (GetFieldValue (memLoc, "hidparse!_HIDP_PREPARSED_DATA", "Input.Size", InSize)) {
        dprintf ("Could not read hidparse!_HIDP_PREPARSED_DATA @%p\n", memLoc);
        return E_INVALIDARG;
    }

    InitTypeRead(memLoc, hidparse!_HIDP_PREPARSED_DATA);
    
    size = GetTypeSize ("hidparse!_HIDP_PREPARSED_DATA")
         + (GetTypeSize ("hidparse!_HIDP_CHANNEL_DESC")
             * ((ULONG) ReadField(Input.Size) + (ULONG) ReadField(Output.Size) + (ULONG) ReadField(Feature.Size)))
         + (GetTypeSize ("hidparse!_HIDP_LINK_COLLECTION_NODE")
             * (ULONG) ReadField(LinkCollectionArrayLength));

    dprintf ("TOT Size: %x\n", size);

    HID_DumpPpd (memLoc, flags);

    return S_OK;
}

VOID
HID_DumpChannel (
    ULONG64             Channel,
    HID_PPD_FLAGS       Flags
    )
{
    InitTypeRead(Channel, hidparse!_HIDP_CHANNEL_DESC);

    dprintf ("-------CHANNEL---------\n");
    dprintf ("P %x ID %x Col %x Sz %x Cnt %x UMin %x UMax %x ",
                (ULONG) ReadField(UsagePage),
                (ULONG) ReadField(ReportID),
                (ULONG) ReadField(LinkCollection),
                (ULONG) ReadField(ReportSize),
                (ULONG) ReadField(ReportCount),
                (ULONG) ReadField(Range.UsageMin),
                (ULONG) ReadField(Range.UsageMax));

    if (ReadField(MoreChannels)) {
        dprintf ("MoreChannels ");
    }
    if (ReadField(IsConst)) {
        dprintf ("Const ");
    }
    if (ReadField(IsButton)) {
        dprintf ("Button ");
    } else {
        dprintf ("Value ");
    }
    if (ReadField(IsAbsolute)) {
        dprintf ("Absolute ");
    }
    if (ReadField(IsAlias)) {
        dprintf ("ALIAS! ");
    }

    dprintf ("\n");

    if (Flags.FullChannelListing) {
        dprintf ("LinkUP %x LinkU %x SMin %x SMax %x "
                    "DMin %x DMax %x IndexMin %x IndexMax %x\n",
                    (ULONG) ReadField(LinkUsagePage),
                    (ULONG) ReadField(LinkUsage),
                    (ULONG) ReadField(Range.StringMin),
                    (ULONG) ReadField(Range.StringMax),
                    (ULONG) ReadField(Range.DesignatorMin),
                    (ULONG) ReadField(Range.DesignatorMax),
                    (ULONG) ReadField(Range.DataIndexMin),
                    (ULONG) ReadField(Range.DataIndexMax));

        if (!ReadField(IsButton)) {
            if (ReadField(Data.HasNull)) {
                dprintf ("Has Null ");
            }
            dprintf ("LMin %x LMax %x PMin %x PMax %x \n",
                        (ULONG) ReadField(Data.LogicalMin),
                        (ULONG) ReadField(Data.LogicalMax),
                        (ULONG) ReadField(Data.PhysicalMin),
                        (ULONG) ReadField(Data.PhysicalMax));
        }
    }

    if (Flags.ReportLocation) {
        dprintf ("ByteOffset %x BitOffset %x BitLength %x ByteEnd %x\n",
                    (ULONG) ReadField(ByteOffset),
                    (ULONG) ReadField(BitOffset),
                    (ULONG) ReadField(BitLength),
                    (ULONG) ReadField(ByteEnd));
    }
}

VOID
HID_DumpLink (
    ULONG   LinkNo,
    ULONG64 Node
    )
{
    InitTypeRead(Node, hidparse!_HIDP_LINK_COLLECTION_NODE);

    dprintf ("Link %x: U %x P %x Par %p #C %x NxSib %p 1stC %p ",
                LinkNo,
                (ULONG) ReadField(LinkUsage),
                (ULONG) ReadField(LinkUsagePage),
                ReadField(Parent),
                (ULONG) ReadField(NumberOfChildren),
                ReadField(NextSibling),
                ReadField(FirstChild));

    if (ReadField(IsAlias)) {
        dprintf (" ALIAS\n");
    } else {
        dprintf ("\n");
    }
}

VOID
HID_DumpPpd (
    ULONG64                 Ppd,
    HID_PPD_FLAGS           Flags
    )
{
    ULONG    i;
    ULONG64  channel;
    ULONG64  node;
    ULONG    SizeOfChannels, DataOff;

    if (InitTypeRead(Ppd, hidparse!_HIDP_PREPARSED_DATA)) {
        dprintf("Cannot read type hidparse!_HIDP_PREPARSED_DATA at %p\n", Ppd);
        return;
    }

    if (!Flags.IgnoreSignature) {
        if ((HIDP_PREPARSED_DATA_SIGNATURE1 != (ULONG) ReadField(Signature1)) ||
            (HIDP_PREPARSED_DATA_SIGNATURE2 != (ULONG) ReadField(Signature2))) {

            dprintf("Preparsed Data signature does not match, probably aint\n");
            return;
        }
    }

    SizeOfChannels = GetTypeSize("hidparse!_HIDP_CHANNEL_DESC");
    GetFieldOffset("hidparse!_HIDP_CHANNEL_DESC", "Data", &DataOff);

    if (Flags.InputChannels) {
        dprintf ("\n========== Input Channels =========\n");
        for (i = (ULONG) ReadField(Input.Offset); i < (ULONG) ReadField(Input.Index); i++) {
            channel = Ppd + DataOff + SizeOfChannels * i;
            HID_DumpChannel (channel, Flags);
        }
    } else {
        dprintf ("Input channels: off %x sz %x indx %x bytelen %x\n",
                    (ULONG) ReadField(Input.Offset),
                    (ULONG) ReadField(Input.Size),
                    (ULONG) ReadField(Input.Index),
                    (ULONG) ReadField(Input.ByteLen));
    }

    if (Flags.OutputChannels) {
        dprintf ("\n========== Output Channels =========\n");
        for (i = (ULONG) ReadField(Output.Offset); i < (ULONG) ReadField(Output.Index); i++) {
            channel = Ppd + DataOff + SizeOfChannels * i;
            HID_DumpChannel (channel, Flags);
        }
    } else {
        dprintf ("Output channels: off %x sz %x indx %x bytelen %x\n",
                    (ULONG) ReadField(Output.Offset),
                    (ULONG) ReadField(Output.Size),
                    (ULONG) ReadField(Output.Index),
                    (ULONG) ReadField(Output.ByteLen));
    }

    if (Flags.FeatureChannels) {
        dprintf ("\n========== Feature Channels =========\n");
        for (i = (ULONG) ReadField(Feature.Offset); i < (ULONG) ReadField(Feature.Index); i++) {
            channel = Ppd + DataOff + SizeOfChannels * i;
            HID_DumpChannel (channel, Flags);
        }

    } else {
        dprintf ("Feature channels: off %x sz %x indx %x bytelen %x\n",
                    (ULONG) ReadField(Feature.Offset),
                    (ULONG) ReadField(Feature.Size),
                    (ULONG) ReadField(Feature.Index),
                    (ULONG) ReadField(Feature.ByteLen));
    }

    if (Flags.LinkCollections) {
        ULONG NodeSize;

        dprintf ("\n========== Link Collections =========\n");
        node = (ReadField(RawBytes) + ReadField(LinkCollectionArrayOffset));
        NodeSize = GetTypeSize("hidparse!_HIDP_LINK_COLLECTION_NODE");

        for (i = 0; i < (ULONG) ReadField(LinkCollectionArrayLength); i++, node+=NodeSize) {
            HID_DumpLink (i, node);
        }

    } else {
        dprintf ("Link Collections: %x \n",
                    (ULONG) ReadField(LinkCollectionArrayLength));
    }
    dprintf ("\n");
}

VOID
HID_DumpHidPDeviceDesc (
    ULONG64             Desc,
    HID_FLAGS           Flags
    )
{
    HID_PPD_FLAGS       ppdFlags;
    ULONG               result;
    ULONG               i;
    ULONG               size;
    PVOID               col;
    PVOID               rep;
    ULONG               CollectionDescLength, ReportIDsLength;
    ULONG64             ReportIDs, CollectionDesc;
    ULONG               SizeofDesc, SizeofRep;

    UNREFERENCED_PARAMETER (Flags);

    dprintf ("\n*** HID Device Descripton ***\n");

    InitTypeRead(Desc, hidparse!_HIDP_DEVICE_DESC);
    CollectionDesc = ReadField(CollectionDesc);
    ReportIDs      = ReadField(ReportIDs);
    CollectionDescLength = (ULONG) ReadField(CollectionDescLength);
    ReportIDsLength      = (ULONG) ReadField(ReportIDsLength);

    dprintf ("Col len: %x Report ID Len: %x\n",
             CollectionDescLength,
             ReportIDsLength);

    SizeofDesc = GetTypeSize("hidparse!_HIDP_COLLECTION_DESC");
    if (!SizeofDesc) {
        dprintf("Cannot find type hidparse!_HIDP_COLLECTION_DESC.\n");
        return;
    }

    SizeofRep  = GetTypeSize("hidparse!_HIDP_REPORT_IDS");
    if (!SizeofRep) {
        dprintf("Cannot find type hidparse!_HIDP_REPORT_IDS.\n");
        return;
    }

    size = CollectionDescLength * SizeofDesc;
    col = LocalAlloc (LPTR, size);
    if (NULL == col) {
        dprintf ("Could not allocate the memory\n");
        return;
    }

    if (!ReadMemory (CollectionDesc, col, size, &result)) {
        dprintf ("Could not read Ppd\n");
        LocalFree (col);
        return;
    }

    size = ReportIDsLength * SizeofRep;
    rep = LocalAlloc (LPTR, size);
    if (NULL == rep) {
        dprintf ("Could not allocate the memory\n");
        LocalFree (col);
        return;
    }

    if (!ReadMemory (ReportIDs, rep, size, &result)) {
        dprintf ("Could not read Ppd\n");
        LocalFree (col);
        LocalFree (rep);
        return;
    }
    LocalFree (col);
    LocalFree (rep);

    dprintf ("---  Top Collections -----\n");
    for (i=0; i < CollectionDescLength; i++) {
        InitTypeRead(CollectionDesc + i*SizeofDesc, hidparse!_HIDP_COLLECTION_DESC);

        dprintf ("%x: U %x UP %x ColNum %x In %x Out %x Fea %x Ppd %x\n",
                 i,
                 (ULONG) ReadField(.Usage),
                 (ULONG) ReadField(.UsagePage),
                 (ULONG) ReadField(.CollectionNumber),
                 (ULONG) ReadField(.InputLength),
                 (ULONG) ReadField(.OutputLength),
                 (ULONG) ReadField(.FeatureLength),
                 (ULONG) ReadField(.PreparsedData));
    }

    dprintf ("---  Report IDs  -----\n");
    for (i=0; i < ReportIDsLength; i++) {
        InitTypeRead(ReportIDs + i*SizeofRep, hidparse!_HIDP_REPORT_IDS);

        dprintf ("%x: ID %x ColNum %x In %x Out %x Fea %x\n",
                 i,
                 (ULONG) ReadField(.ReportID),
                 (ULONG) ReadField(.CollectionNumber),
                 (ULONG) ReadField(.InputLength),
                 (ULONG) ReadField(.OutputLength),
                 (ULONG) ReadField(.FeatureLength));
    }
    return;
}

VOID
HID_DumpPDOExt (
    ULONG64  Pdo
    )
{
    InitTypeRead(Pdo, hidparse!_HIDCLASS_DEVICE_EXTENSION);
    dprintf("\n");
    dprintf ("Collection Num %x Collection Index %x PDO %x Name %x \n"
             "Fdo Extension %x\n",
             (ULONG) ReadField(pdoExt.collectionNum),
             (ULONG) ReadField(pdoExt.collectionIndex),
             (ULONG) ReadField(pdoExt.pdo),
             (ULONG) ReadField(pdoExt.name),
             (ULONG) ReadField(pdoExt.deviceFdoExt));
    dprintf ("\n");
}

VOID
HID_DumpFDOExt (
    ULONG64 Fdo
    )
{
    ULONG64                 object;
    ULONG64                 fdoExt;
    ULONG                   size;
    ULONG                   i;
    ULONG                   result;
    ULONG64                 loc;
    ULONG64                 startLoc;
    HID_FLAGS               Flags;
    ULONG                   FdoExtOffset;
    PVOID                   collection;
    ULONG                   PtrSize;
    ULONG                   SizeOfClassColl;
    ULONG                   CollectionDescLength;
    ULONG64                 classCollectionArray, deviceRelations;
    ULONG                   fileExtListOff, fileListOff;
    ULONG                   devCapOff;

    InitTypeRead(Fdo, hidparse!_HIDCLASS_DEVICE_EXTENSION);

    dprintf("\n");
    dprintf("Fdo %p => PDO: %p NextDO %p \n"
            "MiniDeviceExt %p DriveExt %p\n",
            ReadField(fdoExt.fdo),
            ReadField(hidExt.PhysicalDeviceObject),
            ReadField(hidExt.NextDeviceObject),
            ReadField(hidExt.MiniDeviceExtension),
            ReadField(fdoExt.driverExt));

    switch ((ULONG) ReadField(fdoExt.state)) {
    case DEVICE_STATE_INITIALIZED:
        dprintf ("DEVICE_STATE_INITIALIZED: \n");
        break;
    case DEVICE_STATE_STARTING:
        dprintf ("DEVICE_STATE_STARTING: \n");
        break;
    case DEVICE_STATE_START_SUCCESS:
        dprintf ("DEVICE_STATE_START_SUCCESS: \n");
        break;
    case DEVICE_STATE_START_FAILURE:
        dprintf ("DEVICE_STATE_START_FAILURE: \n");
        break;
    case DEVICE_STATE_STOPPED:
        dprintf ("DEVICE_STATE_STOPPED: \n");
        break;
    case DEVICE_STATE_REMOVING:
        dprintf ("DEVICE_STATE_REMOVING: \n");
        break;
    case DEVICE_STATE_REMOVED:
        dprintf ("DEVICE_STATE_REMOVED: \n");
        break;
    case DEVICE_STATE_SUSPENDED:
        dprintf ("DEVICE_STATE_SUSPENDED: \n");
        break;
    }

    dprintf("\nHidDescriptor:: len %x bcd %x numDesc %x repleng %x \n",
             (ULONG) ReadField(fdoExt.hidDescriptor.bLength),
             (ULONG) ReadField(fdoExt.hidDescriptor.bcdHID),
             (ULONG) ReadField(fdoExt.hidDescriptor.bNumDescriptors),
             (ULONG) ReadField(fdoExt.hidDescriptor.DescriptorList[0].wReportLength));

    dprintf("Raw Desriptor: %x length: %x \n",
            (ULONG) ReadField(fdoExt.rawReportDescription),
            (ULONG) ReadField(fdoExt.rawReportDescriptionLength));

    dprintf("HIDP_DEVICE_DESC: %x\n", (ULONG) ReadField(fdoExt.deviceDesc));
    dprintf("Collections: %x Report IDs: %x\n",
            (CollectionDescLength = (ULONG) ReadField(fdoExt.deviceDesc.CollectionDescLength)),
            (ULONG) ReadField(fdoExt.deviceDesc.ReportIDsLength));

    dprintf("Device Relations Array: %p\n", (deviceRelations = ReadField(fdoExt.deviceRelations)));
    dprintf("Class Collection Array: %p\n", (classCollectionArray = ReadField(fdoExt.classCollectionArray)));

    Flags.Flags = 0x0F;

    HID_DumpHidPDeviceDesc (ReadField(fdoExt.deviceDesc), Flags);

    PtrSize = DBG_PTR_SIZE;
    SizeOfClassColl =  GetTypeSize ("HIDCLASS_COLLECTION");
    size = (CollectionDescLength) * SizeOfClassColl;

    collection = LocalAlloc (0, size);
    if (!collection) {
        dprintf ("Could not allocate the memory\n");
        return;
    }
    
    //
    // Read entire array so that its cached for each element
    //
    if (!ReadMemory (classCollectionArray,
                     collection,
                     size,
                     &result)) {
        dprintf ("Could not read Collection array\n");
        LocalFree (collection);
        return;
    }

    size = (CollectionDescLength + 1)* PtrSize;

    GetFieldOffset("HIDCLASS_COLLECTION", "FileExtensionList", &fileExtListOff);
    GetFieldOffset("HIDCLASS_FILE_EXTENSION", "FileList", &fileListOff);

    dprintf ("------ Children -----\n");
    for (i = 0; i < CollectionDescLength; i++) {
        ULONG64 objAddr;

        ReadPointer(deviceRelations + i* PtrSize, &objAddr);

        InitTypeRead(classCollectionArray + i*SizeOfClassColl, hidparse!_HIDCLASS_COLLECTION);

        dprintf ("DO: %p: ColNum %x ColIndx %x DevExt %x\n"
                 "    # Opens %x, FileExtList.Flink %p \n"
                 "    PollInterval ms %x, PolledDeviceReadQueue.Flink %p\n"
                 "    SymLinName %x Ppd %x PowerIrp %x\n",
                 objAddr,
                 (ULONG) ReadField(CollectionNumber),
                 (ULONG) ReadField(CollectionIndex),
                 (ULONG) ReadField(DeviceExtension),
                 (ULONG) ReadField(NumOpens),
                 ReadField(FileExtensionList.Flink),
                 (ULONG) ReadField(PollInterval_msec),
                 ReadField(polledDeviceReadQueue.Flink),
                 (ULONG) ReadField(SymbolicLinkName.Buffer),
                 (ULONG) ReadField(phidDescriptor),
                 (ULONG) ReadField(powerEventIrp));

        dprintf ("    DescSize %x polled %x VID %x PID %x Version %x\n",
                 (ULONG) ReadField(hidCollectionInfo.DescriptorSize),
                 (ULONG) ReadField(hidCollectionInfo.Polled),
                 (ULONG) ReadField(hidCollectionInfo.VendorID),
                 (ULONG) ReadField(hidCollectionInfo.ProductID),
                 (ULONG) ReadField(hidCollectionInfo.VersionNumber));

        loc = ReadField(FileExtensionList.Flink);
        startLoc = classCollectionArray + fileExtListOff;

        dprintf ("    File List %x\n", startLoc);

        i=0;
        while ((loc != startLoc) && (i++ < 100)) {
            ULONG64 Flink;

            loc = (loc - fileListOff);

            if (GetFieldValue(loc, "hidparse!_HIDCLASS_FILE_EXTENSION", "FileList.Flink", Flink)) {
                dprintf ("could not read hidparse!_HIDCLASS_FILE_EXTENSION at %p\n", loc);
                LocalFree (collection);
                return;
            }

            InitTypeRead(loc, hidparse!_HIDCLASS_COLLECTION);
            dprintf ("    FileExt %p ColNum %x fdoExt %x\n"
                     "        PendingIrp.Flink %x Reports.Flink %x\n"
                     "        FILE %x Closing? %x \n",
                     loc,
                     (ULONG) ReadField(CollectionNumber),
                     (ULONG) ReadField(fdoExt),
                     (ULONG) ReadField(PendingIrpList.Flink),
                     (ULONG) ReadField(ReportList.Flink),
                     (ULONG) ReadField(FileObject),
                     (ULONG) ReadField(Closing));

            loc = Flink;
        }
    }
    
    GetFieldOffset("hidparse!_HIDCLASS_DEVICE_EXTENSION", "fdoExt.deviceCapabilities", &devCapOff);
    DumpDeviceCapabilities (Fdo + devCapOff);

    LocalFree (collection);
    dprintf ("\n");

    return;
}

VOID
DevExtHID(
    ULONG64  MemLocPtr
    )
/*++

Routine Description:

    Dump a HID Device extension.

Arguments:

    Extension   Address of the extension to be dumped.

Return Value:

    None.

--*/
{
    ULONG                      isClientPdo, Signature;
    ULONG64                    MemLoc = MemLocPtr;

    dprintf ("Dump HID Extension: %p\n", MemLoc);

    if (GetFieldValue (MemLoc, "HIDCLASS_DEVICE_EXTENSION", "isClientPdo", isClientPdo)) {
        dprintf ("Could not read HID Extension\n");
    }

    GetFieldValue (MemLoc, "HIDCLASS_DEVICE_EXTENSION", "Signature", Signature);
    if (HID_DEVICE_EXTENSION_SIG != Signature) {

        dprintf("HID Extension Signature does not match, probably aint\n");
        return;
    }

    if (isClientPdo) 
    {
        HID_DumpPDOExt(MemLoc);
    }
    else 
    {
        HID_DumpFDOExt(MemLoc);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\i386.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    i386.h

Abstract:

    This file contains definitions which are specific to i386 platforms.
    
Author:

    Kshitiz K. Sharma (kksharma)

Revision History:

--*/


//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define MM_SESSION_SPACE_DEFAULT_X86        (0xA0000000)

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT_X86 12L

#define MM_KSEG0_BASE_X86 ((ULONG64)0xFFFFFFFF80000000UI64)

#define MM_KSEG2_BASE_X86 ((ULONG64)0xFFFFFFFFA0000000UI64)

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT_X86    22
#define PDI_SHIFT_X86PAE 21

#define PPI_SHIFT_X86 30

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT_X86 12

//
// Define page directory and page base addresses.
//

#define PDE_BASE_X86    ((ULONG64) (LONG64) (LONG) (PaeEnabled? 0xc0600000 : 0xc0300000))

#define PTE_BASE_X86 0xFFFFFFFFc0000000


#define MM_PTE_PROTECTION_MASK_X86    0x3e0
#define MM_PTE_PAGEFILE_MASK_X86      0x01e

#define PTE_TOP_PAE_X86             0xffffffffC07FFFFFUI64

#define PTE_TOP_X86 (PaeEnabled ? PTE_TOP_PAE_X86 : 0xFFFFFFFFC03FFFFFUI64)
#define PDE_TOP_X86 (PaeEnabled ? 0xFFFFFFFFC0603FFF : 0xFFFFFFFFC03FFFFFUI64)

#define MM_PTE_VALID_MASK_X86         0x1

#if defined(NT_UP)
#define MM_PTE_WRITE_MASK_X86         0x2
#else
#define MM_PTE_WRITE_MASK_X86         0x800
#endif

#define MM_PTE_OWNER_MASK_X86         0x4
#define MM_PTE_WRITE_THROUGH_MASK_X86 0x8
#define MM_PTE_CACHE_DISABLE_MASK_X86 0x10
#define MM_PTE_ACCESS_MASK_X86        0x20

#if defined(NT_UP)
#define MM_PTE_DIRTY_MASK_X86         0x40
#else
#define MM_PTE_DIRTY_MASK_X86         0x42
#endif

#define MM_PTE_LARGE_PAGE_MASK_X86    0x80
#define MM_PTE_GLOBAL_MASK_X86        0x100
#define MM_PTE_COPY_ON_WRITE_MASK_X86 0x200
#define MM_PTE_PROTOTYPE_MASK_X86     0x400
#define MM_PTE_TRANSITION_MASK_X86    0x800

#define MI_PTE_LOOKUP_NEEDED_X86      (PaeEnabled ? 0xFFFFFFFF : 0xFFFFF)

#define MODE_MASK_I386    1
#define RPL_MASK_I386     3

#define EFLAGS_DF_MASK_I386        0x00000400L
#define EFLAGS_INTERRUPT_MASK_I386 0x00000200L
#define EFLAGS_V86_MASK_I386       0x00020000L
#define EFLAGS_ALIGN_CHECK_I386    0x00040000L
#define EFLAGS_IOPL_MASK_I386      0x00003000L
#define EFLAGS_VIF_I386            0x00080000L
#define EFLAGS_VIP_I386            0x00100000L
#define EFLAGS_USER_SANITIZE_I386  0x003e0dd7L

#define KGDT_NULL_I386       0
#define KGDT_R0_CODE_I386    8
#define KGDT_R0_DATA_I386    16
#define KGDT_R3_CODE_I386    24
#define KGDT_R3_DATA_I386    32
#define KGDT_TSS_I386        40
#define KGDT_R0_PCR_I386     48
#define KGDT_R3_TEB_I386     56
#define KGDT_VDM_TILE_I386   64
#define KGDT_LDT_I386        72
#define KGDT_DF_TSS_I386     80
#define KGDT_NMI_TSS_I386    88

#define FRAME_EDITED_I386        0xfff8

//
// CR4 bits;  These only apply to Pentium
//
#define CR4_VME_X86 0x00000001          // V86 mode extensions
#define CR4_PVI_X86 0x00000002          // Protected mode virtual interrupts
#define CR4_TSD_X86 0x00000004          // Time stamp disable
#define CR4_DE_X86  0x00000008          // Debugging Extensions
#define CR4_PSE_X86 0x00000010          // Page size extensions
#define CR4_PAE_X86 0x00000020          // Physical address extensions
#define CR4_MCE_X86 0x00000040          // Machine check enable
#define CR4_PGE_X86 0x00000080          // Page global enable
#define CR4_FXSR_X86 0x00000200         // FXSR used by OS
#define CR4_XMMEXCPT_X86 0x00000400     // XMMI used by OS


//
// i386 Feature bit definitions
//

#define KF_V86_VIS_X86          0x00000001
#define KF_RDTSC_X86            0x00000002
#define KF_CR4_X86              0x00000004
#define KF_CMOV_X86             0x00000008
#define KF_GLOBAL_PAGE_X86      0x00000010
#define KF_LARGE_PAGE_X86       0x00000020
#define KF_MTRR_X86             0x00000040
#define KF_CMPXCHG8B_X86        0x00000080
#define KF_MMX_X86              0x00000100
#define KF_WORKING_PTE_X86      0x00000200
#define KF_PAT_X86              0x00000400
#define KF_FXSR_X86             0x00000800
#define KF_FAST_SYSCALL_X86     0x00001000
#define KF_XMMI_X86             0x00002000
#define KF_3DNOW_X86            0x00004000
#define KF_AMDK6MTRR_X86        0x00008000



#define CONTEXT_X86     0x00010000    // X86 have identical context records

#ifdef CONTEXT86_CONTROL
#undef CONTEXT86_CONTROL
#endif
#define CONTEXT86_CONTROL         (CONTEXT_X86 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP

#ifdef CONTEXT86_INTEGER
#undef CONTEXT86_INTEGER
#endif
#define CONTEXT86_INTEGER         (CONTEXT_X86 | 0x00000002L) // AX, BX, CX, DX, SI, DI

#ifdef CONTEXT86_SEGMENTS
#undef CONTEXT86_SEGMENTS
#endif
#define CONTEXT86_SEGMENTS        (CONTEXT_X86 | 0x00000004L) // DS, ES, FS, GS

#ifdef CONTEXT86_FLOATING_POINT
#undef CONTEXT86_FLOATING_POINT
#endif
#define CONTEXT86_FLOATING_POINT  (CONTEXT_X86 | 0x00000008L) // 387 state

#ifdef CONTEXT86_DEBUG_REGISTERS
#undef CONTEXT86_DEBUG_REGISTERS
#endif
#define CONTEXT86_DEBUG_REGISTERS (CONTEXT_X86 | 0x00000010L) // DB 0-3,6,7

#define CONTEXT86_FULL (CONTEXT86_CONTROL | CONTEXT86_INTEGER |\
                      CONTEXT86_SEGMENTS)    // context corresponding to set flags will be returned.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\iospace.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    kdapi.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
InternalReadIoSpace(
    ULONG InputSize,
    LPSTR args
    )

/*++

Routine Description:

    Input a byte froma port.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64  IoAddress;
    ULONG    InputValue;
    UCHAR    Format[] = "%08p: %01lx\n";
    ULONG    OriginalInputSize = InputSize;

    InputValue = 0;
    
    if (TargetIsDump) {
        dprintf("This is not supported on dump targets\n");
        return;
    }

    Format[9] = (UCHAR)('0' + (InputSize * 2));


    IoAddress = GetExpression( args );

    if (IoAddress == 0) {
        dprintf( "Could not evaluate address expresion (%s)\n", args );
        return;
    }

    ReadIoSpace64( IoAddress, &InputValue, &InputSize );

    if (InputSize) {
        dprintf(Format, IoAddress, InputValue);
    }
    else {
        dprintf(" %08p: \n", IoAddress);
        while (OriginalInputSize--) {
            dprintf("??");
        }
        dprintf("\n");
    }
}


DECLARE_API( ib )
{
    InternalReadIoSpace( 1, (PSTR)args );
    return S_OK;
}

DECLARE_API( iw )
{
    InternalReadIoSpace( 2, (PSTR)args );
    return S_OK;
}

DECLARE_API( id )
{
    InternalReadIoSpace( 4, (PSTR)args );
    return S_OK;
}


VOID
InternalWriteIoSpace(
    ULONG OutputSize,
    LPSTR args
    )

/*++

Routine Description:

    Input a byte froma port.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64  IoAddress = 0;
    ULONG    OutputValue = 0;
    LPSTR    p;


    p = strtok( args, " \t" );
    if (p) {
        IoAddress = GetExpression( p );
    }

    if (IoAddress == 0) {
        dprintf( "Could not evaluate address expresion (%s)\n", args );
        return;
    }

    p = strtok( NULL, " \t" );
    if (p) {
        OutputValue = (ULONG) GetExpression( p );
    }

    WriteIoSpace64( IoAddress, OutputValue, &OutputSize );
}


DECLARE_API( ob )
{
    InternalWriteIoSpace( 1, (PSTR)args );
    return S_OK;
}

DECLARE_API( ow )
{
    InternalWriteIoSpace( 2, (PSTR)args );
    return S_OK;
}

DECLARE_API( od )
{
    InternalWriteIoSpace( 4, (PSTR)args );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\irp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    irp.c

Abstract:

    WinDbg Extension Api

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
//#include "irpverif.h"
#pragma hdrstop

typedef
BOOLEAN
(WINAPI *IRP_FILTER_ROUTINE)(
                            ULONG64 Irp,
                            PVOID FilterContext
                            );

typedef struct _IRP_FILTER {
    IRP_FILTER_ROUTINE FilterRoutine;
    PVOID              FilterContext;
} IRP_FILTER, *PIRP_FILTER;

typedef struct _SEARCH_CONTEXT {
    ULONG FirstTime;
    IRP_FILTER Filter;
} SEARCH_CONTEXT, *PSEARCH_CONTEXT;

#define TAG 0
#define NONPAGED_ALLOC 1
#define NONPAGED_FREE 2
#define PAGED_ALLOC 3
#define PAGED_FREE 4
#define NONPAGED_USED 5
#define PAGED_USED 6

VOID
DumpIrp(
       ULONG64 IrpToDump,
       ULONG   DumpLevel
       );

BOOLEAN
IrpFilterUserEvent(
                  ULONG64 Irp,
                  PVOID FilterContext
                  );

BOOLEAN
IrpFilterDevice(
               ULONG64 Irp,
               PVOID FilterContext
               );

BOOLEAN
IrpFilterFileObject(
                   ULONG64 Irp,
                   PVOID FilterContext
                   );

BOOLEAN
IrpFilterThread(
               ULONG64 Irp,
               PVOID FilterContext
               );

BOOLEAN
IrpFilterMdlProcess(
                   ULONG64 Irp,
                   PVOID FilterContext
                   );

BOOLEAN
IrpFilterArg(
            ULONG64 Irp,
            PVOID FilterContext
            );

DECLARE_API( irp )

/*++

Routine Description:

   Dumps the specified Irp

Arguments:

    args - Address

Return Value:

    None

--*/

{
    ULONG64 irpToDump;
    ULONG dumpLevel = 0 ;
    char irpExprBuf[256] ;
    char dumpLevelBuf[256] ;

    if (!*args) {
        irpToDump = EXPRLastDump;
    } else {

        //
        // !Irp IrpAddress DumpLevel
        //    where IrpAddress can be an expression
        //    and DumpLevel is a decimal level of any non-decimal string for 1
        irpExprBuf[0] = '\0' ;
        dumpLevelBuf[0] = '\0' ;

        if (!sscanf(args, "%s %s", irpExprBuf, dumpLevelBuf)) {
            irpExprBuf[0] = '\0' ;
            dumpLevelBuf[0] = '\0' ;
        }

        if (irpExprBuf) {

            if (IsHexNumber(irpExprBuf)) {

                irpToDump = GetExpression( irpExprBuf ) ;
            } else {

                irpToDump = GetExpression( irpExprBuf ) ;
                if (irpToDump==0) {

                    dprintf("An error occured trying to evaluate the expression\n") ;
                    return E_INVALIDARG ;
                }
            }

            if (IsDecNumber(dumpLevelBuf)) {

                if (!sscanf(dumpLevelBuf, "%d", &dumpLevel) ) {
                    dumpLevel = 0;
                }
            } else if (dumpLevelBuf[0]) {

                dumpLevel = 1 ;
            } else {

                dumpLevel = 0 ;
            }
        }
    }

    if (irpToDump == 0) {

        dprintf("Free build - use !irpfind to scan memory for any active IRPs\n") ;

    } else {

        DumpIrp(irpToDump, (ULONG) dumpLevel);
    }
    return S_OK;
}


DECLARE_API( irpzone )

/*++

Routine Description:

    Dumps both the small irp zone and the large irp zone.  Only irps that
    are currently allocated are dumped.  "args" controls the type of dump.
    If "args" is present then the Irp is sent to the DumpIrp routine to be
    disected.  Otherwise, only the irp, its thread and the driver holding the
    irp (i.e. the driver of the last stack) is printed.

Arguments:

    args - a string pointer.  If anything is in the string it indicates full
           information (i.e. call DumpIrp).

Return Value:

    None.

--*/

{
    ULONG   listAddress;
    BOOLEAN fullOutput = FALSE;

    dprintf("irpzone is no longer supported.  Use irpfind to search "   \
            "nonpaged pool for active Irps\n");

    return S_OK;

}



VOID
DumpIrp(
       ULONG64 IrpToDump,
       ULONG   DumpLevel
       )

/*++

Routine Description:

    This routine dumps an Irp.  It does not check to see that the address
    supplied actually locates an Irp.  This is done to allow for dumping
    Irps post mortem, or after they have been freed or completed.

Arguments:

    IrpToDump - the address of the irp.
    DumpLevel - 0 Summary
                1 Extended information
                2 Debug tracking info iff available

Return Value:

    None

--*/

{
    PCHAR               buffer;
    ULONG64             irpStackAddress;
    ULONG64             result64=0;
    ULONG               result;
    // IRP                 irp;
    CCHAR               irpStackIndex;
    LARGE_INTEGER       runTime ;
#if DBG
//    PIOV_REQUEST_PACKET irpTrackingData ;
#endif
    BOOLEAN  delayed ;
    ULONG Type=0, StackCount=0, CurrentLocation=0, Flags=0, PendingReturned=0;
    ULONG Io_Status=0, Cancel=0, CancelIrql=0, ApcEnvironment=0,  Overlay_Alloc_High=0;
    ULONG Overlay_Alloc_Low=0, RequestorMode=0, IrpSize;
    ULONG64 Tail_Overlay_CurrStack=0, MdlAddress=0, Associated_MasterIrp=0;
    ULONG64 ThreadListEntry_Flink=0, ThreadListEntry_Blink=0, Io_Information=0;
    ULONG64 CancelRoutine=0, UserIosb=0, UserEvent=0, UserBuffer=0, Overlay_Async_UserApcRoutine=0;
    ULONG64 Overlay_Async_UserApcContext=0, Tail_Overlay_Thread=0, Tail_Overlay_AuxBuffer=0;
    ULONG64 Tail_Overlay_List_Flink=0, Tail_Overlay_List_Blink=0, Tail_Overlay_OrigFile=0;
    ULONG64 Tail_CompletionKey=0;
    BYTE Tail_Apc[100]={0};
    UCHAR IrpType[]= "nt!_IRP";

    if ( (GetFieldValue(IrpToDump, IrpType, "Type", Type)) ) {
        dprintf("%08p: Could not read Irp\n", IrpToDump);
        return;
    }

    GetFieldValue(IrpToDump, IrpType, "StackCount", StackCount);
    GetFieldValue(IrpToDump, IrpType, "CurrentLocation", CurrentLocation);
    GetFieldValue(IrpToDump, IrpType, "Tail.Overlay.CurrentStackLocation", Tail_Overlay_CurrStack);
    GetFieldValue(IrpToDump, IrpType, "MdlAddress", MdlAddress);
    GetFieldValue(IrpToDump, IrpType, "AssociatedIrp.MasterIrp", Associated_MasterIrp);
    GetFieldValue(IrpToDump, IrpType, "Flags", Flags);
    GetFieldValue(IrpToDump, IrpType, "RequestorMode", RequestorMode);
    GetFieldValue(IrpToDump, IrpType, "PendingReturned", PendingReturned);
    GetFieldValue(IrpToDump, IrpType, "ThreadListEntry.Flink", ThreadListEntry_Flink);
    GetFieldValue(IrpToDump, IrpType, "ThreadListEntry.Blink", ThreadListEntry_Blink);
    GetFieldValue(IrpToDump, IrpType, "IoStatus.Status", Io_Status);
    GetFieldValue(IrpToDump, IrpType, "IoStatus.Information", Io_Information);
    GetFieldValue(IrpToDump, IrpType, "Cancel", Cancel);
    GetFieldValue(IrpToDump, IrpType, "CancelIrql", CancelIrql);
    GetFieldValue(IrpToDump, IrpType, "CancelRoutine", CancelRoutine);
    GetFieldValue(IrpToDump, IrpType, "ApcEnvironment", ApcEnvironment);
    GetFieldValue(IrpToDump, IrpType, "UserIosb", UserIosb);
    GetFieldValue(IrpToDump, IrpType, "UserEvent", UserEvent);
    GetFieldValue(IrpToDump, IrpType, "UserBuffer", UserBuffer);
    GetFieldValue(IrpToDump, IrpType, "Overlay.AsynchronousParameters.UserApcRoutine", Overlay_Async_UserApcRoutine);
    GetFieldValue(IrpToDump, IrpType, "Overlay.AsynchronousParameters.UserApcContext", Overlay_Async_UserApcContext);
    GetFieldValue(IrpToDump, IrpType, "Overlay.AllocationSize.High", Overlay_Alloc_High);
    GetFieldValue(IrpToDump, IrpType, "Overlay.AllocationSize.Low", Overlay_Alloc_Low);
    GetFieldValue(IrpToDump, IrpType, "Tail.Overlay.Thread", Tail_Overlay_Thread);
    GetFieldValue(IrpToDump, IrpType, "Tail.Overlay.AuxiliaryBuffer", Tail_Overlay_AuxBuffer);
    GetFieldValue(IrpToDump, IrpType, "Tail.Overlay.ListEntry.Flink", Tail_Overlay_List_Flink);
    GetFieldValue(IrpToDump, IrpType, "Tail.Overlay.ListEntry.Blink", Tail_Overlay_List_Blink);
    GetFieldValue(IrpToDump, IrpType, "Tail.Overlay.OriginalFileObject", Tail_Overlay_OrigFile);
    GetFieldValue(IrpToDump, IrpType, "Tail.Apc", Tail_Apc);
    GetFieldValue(IrpToDump, IrpType, "Tail.CompletionKey", Tail_CompletionKey);
    IrpSize = GetTypeSize("nt!_IRP");

    if (Type != IO_TYPE_IRP) {
        dprintf("IRP signature does not match, probably not an IRP\n");
        return;
    }

    dprintf("Irp is active with %d stacks %d is current (= %#08p)\n",
            StackCount,
            CurrentLocation,
            Tail_Overlay_CurrStack);

    if ((MdlAddress != 0) && (Type == IO_TYPE_IRP)) {
        dprintf(" Mdl = %08p ", MdlAddress);
    } else {
        dprintf(" No Mdl ");
    }

    if (Associated_MasterIrp != 0) {
        dprintf("%s = %08p ",
                (Flags & IRP_ASSOCIATED_IRP) ? "Associated Irp" :
                (Flags & IRP_DEALLOCATE_BUFFER) ? "System buffer" :
                "Irp count",
                Associated_MasterIrp);
    }

    dprintf("Thread %08p:  ", Tail_Overlay_Thread);

    if (StackCount > 30) {
        dprintf("Too many Irp stacks to be believed (>30)!!\n");
        return;
    } else {
        if (CurrentLocation > StackCount) {
            dprintf("Irp is completed.  ");
        } else {
            dprintf("Irp stack trace.  ");
        }
    }

    if (PendingReturned) {
        dprintf("Pending has been returned\n");
    } else {
        dprintf("\n");
    }

    if (DumpLevel>0) {
        dprintf("Flags = %08lx\n", Flags);
        dprintf("ThreadListEntry.Flink = %08p\n", ThreadListEntry_Flink);
        dprintf("ThreadListEntry.Blink = %08p\n", ThreadListEntry_Blink);
        dprintf("IoStatus.Status = %08lx\n", Io_Status);
        dprintf("IoStatus.Information = %08p\n", Io_Information);
        dprintf("RequestorMode = %08lx\n", RequestorMode);
        dprintf("Cancel = %02lx\n", Cancel);
        dprintf("CancelIrql = %lx\n", CancelIrql);
        dprintf("ApcEnvironment = %02lx\n", ApcEnvironment);
        dprintf("UserIosb = %08p\n", UserIosb);
        dprintf("UserEvent = %08p\n", UserEvent);
        dprintf("Overlay.AsynchronousParameters.UserApcRoutine = %08p\n", Overlay_Async_UserApcRoutine);
        dprintf("Overlay.AsynchronousParameters.UserApcContext = %08p\n", Overlay_Async_UserApcContext);
        dprintf(
               "Overlay.AllocationSize = %08lx - %08lx\n",
               Overlay_Alloc_High,
               Overlay_Alloc_Low);
        dprintf("CancelRoutine = %08p\n", CancelRoutine);
        dprintf("UserBuffer = %08p\n", UserBuffer);
        dprintf("&Tail.Overlay.DeviceQueueEntry = %08p\n", 0);// &Tail_Overlay_DeviceQueueEntry);
        dprintf("Tail.Overlay.Thread = %08p\n", Tail_Overlay_Thread);
        dprintf("Tail.Overlay.AuxiliaryBuffer = %08p\n", Tail_Overlay_AuxBuffer);
        dprintf("Tail.Overlay.ListEntry.Flink = %08p\n", Tail_Overlay_List_Flink);
        dprintf("Tail.Overlay.ListEntry.Blink = %08p\n", Tail_Overlay_List_Blink);
        dprintf("Tail.Overlay.CurrentStackLocation = %08p\n", Tail_Overlay_CurrStack);
        dprintf("Tail.Overlay.OriginalFileObject = %08p\n", Tail_Overlay_OrigFile);
        dprintf("Tail.Apc = %08lx\n", *((PULONG) &Tail_Apc));
        dprintf("Tail.CompletionKey = %08p\n", Tail_CompletionKey);
    }

    irpStackAddress = (ULONG64) IrpToDump + GetTypeSize("nt!_IRP");

    buffer = LocalAlloc(LPTR, 256);
    if (buffer == NULL) {
        dprintf("Can't allocate 256 bytes\n");
        return;
    }

    dprintf("     cmd  flg cl Device   File     Completion-Context\n");
    for (irpStackIndex = 1; (ULONG) irpStackIndex <= StackCount; irpStackIndex++) {
        ULONG   MajorFunction=0, MinorFunction=0, Flags=0, Control=0, irpStackSize;
        ULONG64 DeviceObject=0, FileObject=0, CompletionRoutine=0, Context=0;
        ULONG64 Others_Argument1=0, Others_Argument2=0, Others_Argument3=0, Others_Argument4=0;
        UCHAR IOStack[] = "nt!_IO_STACK_LOCATION";

        if ( GetFieldValue(irpStackAddress, IOStack, "MajorFunction",     MajorFunction)) {
            dprintf("%p: Could not read IrpStack\n", irpStackAddress);
            goto exit;
        }

        irpStackSize = GetTypeSize(IOStack);
        GetFieldValue(irpStackAddress, IOStack, "MinorFunction",     MinorFunction);
        GetFieldValue(irpStackAddress, IOStack, "Flags",             Flags);
        GetFieldValue(irpStackAddress, IOStack, "DeviceObject",      DeviceObject);
        GetFieldValue(irpStackAddress, IOStack, "FileObject",        FileObject);
        GetFieldValue(irpStackAddress, IOStack, "CompletionRoutine", CompletionRoutine);
        GetFieldValue(irpStackAddress, IOStack, "Context",           Context);
        GetFieldValue(irpStackAddress, IOStack, "Control",           Control);
        GetFieldValue(irpStackAddress, IOStack, "Parameters.Others.Argument1",Others_Argument1);
        GetFieldValue(irpStackAddress, IOStack, "Parameters.Others.Argument2",Others_Argument2);
        GetFieldValue(irpStackAddress, IOStack, "Parameters.Others.Argument3",Others_Argument3);
        GetFieldValue(irpStackAddress, IOStack, "Parameters.Others.Argument4",Others_Argument4);


        dprintf("%c[%3x,%2x]  %2x %2x %08p %08p %08p-%08p %s %s %s %s\n",
                (ULONG) irpStackIndex == CurrentLocation ? '>' : ' ',
                MajorFunction,
                MinorFunction,
                Flags,
                Control,
                DeviceObject,
                FileObject,
                CompletionRoutine,
                Context,
                (Control & SL_INVOKE_ON_SUCCESS) ? "Success" : "",
                (Control & SL_INVOKE_ON_ERROR)   ? "Error"   : "",
                (Control & SL_INVOKE_ON_CANCEL)  ? "Cancel"  : "",
                (Control & SL_PENDING_RETURNED)  ? "pending"  : "");

        if (DeviceObject != 0) {
            dprintf("\t      ");
            DumpDevice(DeviceObject, 0, FALSE);
        }

        if (CompletionRoutine != 0) {

            GetSymbol(CompletionRoutine, buffer, &result64);
            dprintf("\t%s\n", buffer);
        } else {
            dprintf("\n"); 
        }

        dprintf("\t\t\tArgs: %08p %08p %08p %08p\n",
                Others_Argument1,
                Others_Argument2,
                Others_Argument3,
                Others_Argument4);
        irpStackAddress += irpStackSize;
        if (CheckControlC()) {
            goto exit;
        }
    }

    if (DumpLevel>=2) {

        dprintf("Extra information not available.\n") ;
    }

    exit:
    LocalFree(buffer);
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckForIrp
//
//  Synopsis:   Matches pool chunk against an irp
//
//  Arguments:  [Tag]            -- 
//              [Filter]         -- 
//              [Flags]          -- 0 nonpaged pool 1 paged pool 2 special pool 4 dump irp
//              [PoolTrackTable] -- 
//              [PoolHeader]     -- 
//              [BlockSize]      -- 
//              [Data]           -- 
//
//  Returns:    
//
//  History:    7-28-1999   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

BOOLEAN WINAPI CheckForIrp(
                          PCHAR Tag,
                          PCHAR Filter,
                          ULONG Flags,
                          ULONG64 PoolHeader,
                          ULONG BlockSize,
                          ULONG64 Data,
                          PVOID Context
                          )
{
    ULONG64 Irp = Data;
    ULONG Result;
    ULONG64 irpSp;
    // MDL Mdl;
    PSEARCH_CONTEXT SearchContext = (PSEARCH_CONTEXT)Context;
    ULONG PoolType, SizeOfIRP;

//    dprintf("Call Hdr %p, Data %p \n", PoolHeader, Data);
    if (PoolHeader) {
        if (GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolType", PoolType)) {
            dprintf("Unable to read nt!_POOL_HEADER type.\n");
        }
    }

    if (((PoolHeader == 0) || 
         (Flags & 0x2) || 
         (PoolType != 0)) &&
        (CheckSingleFilter (Tag, Filter))) {

        ULONG   Type=0, CurrentLocation, StackCount, MajorFunction, MinorFunction;
        ULONG64 Thread, DeviceObject, MdlAddress;

        if (!GetFieldValue(Irp, "nt!_IRP", "Type", Type)) {

            if (Type == IO_TYPE_IRP) {

                SizeOfIRP = GetTypeSize("nt!_IRP");

                if (Flags & 0x4) {
                    if (SearchContext->FirstTime) {

                        dprintf("  Irp    [ Thread ] irpStack: (Mj,Mn)   DevObj  [Driver]\n");
                        SearchContext->FirstTime = FALSE;
                    }
                    dprintf("%08p: ", Data);
                    DumpIrp(Data, 0);
                    dprintf("\n");
                } else {
                    if ((SearchContext->Filter.FilterRoutine == NULL) ||
                        (SearchContext->Filter.FilterRoutine(Irp, SearchContext->Filter.FilterContext))) {

                        if (SearchContext->FirstTime) {

                            dprintf("  Irp    [ Thread ] irpStack: (Mj,Mn)   DevObj  [Driver]\n");
                            SearchContext->FirstTime = FALSE;
                        }

                        GetFieldValue(Irp, "nt!_IRP", "CurrentLocation", CurrentLocation);
                        GetFieldValue(Irp, "nt!_IRP", "StackCount", StackCount);
                        GetFieldValue(Irp, "nt!_IRP", "MdlAddress", MdlAddress);
                        GetFieldValue(Irp, "nt!_IRP", "Tail.Overlay.Thread",
                                      Thread);

                        irpSp = Irp + SizeOfIRP + 
                                (CurrentLocation - 1)*GetTypeSize("nt!_IO_STACK_LOCATION");

                        dprintf("%08p [%08p] ", Data, Thread);


                        if (CurrentLocation > StackCount) {
                            dprintf("Irp is complete (CurrentLocation "
                                    "%d > StackCount %d)",
                                    CurrentLocation,
                                    StackCount);
                        } else {

                            GetFieldValue(irpSp, "nt!_IO_STACK_LOCATION", "MajorFunction", MajorFunction);
                            GetFieldValue(irpSp, "nt!_IO_STACK_LOCATION", "MinorFunction", MinorFunction);
                            GetFieldValue(irpSp, "nt!_IO_STACK_LOCATION", "DeviceObject",  DeviceObject);

                            dprintf("irpStack: (%2x,%2x)",
                                    MajorFunction,
                                    MinorFunction);

                            dprintf("  %08p [", DeviceObject);
                            DumpDevice(DeviceObject, 0, FALSE);
                            dprintf("]");
                        }

                        if (MdlAddress) {
                            ULONG64 Process;

                            if (!GetFieldValue(MdlAddress,
                                               "nt!_MDL",
                                               "Process",
                                               Process)) {
                                dprintf( " 0x%p", Process );
                            }
                        }


                        dprintf("\n");
                    }
                }
            } else {
                // dprintf("%08lx (size %04lx) uninitialized or overwritten IRP\n",
                //         irpAddress,
                //         PoolBlock.Header.BlockSize << POOL_BLOCK_SHIFT);
            }
        } else {
            dprintf("Possible IRP @ %p - unable to read addr/type\n", Data );
        }

        return TRUE;
    } else {
#ifdef SHOW_PROGRESS
        dprintf("%c", turnTable[turn]);
        turn = (turn + 1) % 4;
#endif
    }
    return FALSE;
} // CheckForIrp

DECLARE_API(irpfind)

/*++

Routine Description:

    finds Irps in non-paged pool

Arguments:

    args -

Return Value:

    None

--*/


{
    ULONG       Flags = 0;
    ULONG64     RestartAddr = 0;
    ULONG       TagName;
    UCHAR       Field[20];
    ULONG64     Match=0;
    SEARCH_CONTEXT Context;

    Context.FirstTime = TRUE;
    Context.Filter.FilterRoutine = NULL;
    Field[0] = '\0';
    if (args) {
        PCHAR pc;
        ULONG64 tmp;

        if (GetExpressionEx(args, &tmp, &args)) {
            Flags = (ULONG) tmp;
            if (GetExpressionEx(args, &RestartAddr, &args)) {
                if (!sscanf(args, "%19s %x", &Field, &Match)) {
                    Match = 0;
                }
            }
        }
    }

    //
    //  Sign extend the address if necc.
    // 

    if (RestartAddr != 0) {
        if (RestartAddr >= 0x80000000 && RestartAddr <= 0xFFFFFFFF) {
            RestartAddr += 0xFFFFFFFF00000000;
        }
    }

    if ((_stricmp(Field, "userevent") == 0) &&
        (Match != 0)) {
        Context.Filter.FilterRoutine = IrpFilterUserEvent;
        Context.Filter.FilterContext = (PVOID)&Match;
        dprintf("Looking for IRP with UserEvent == %08p\n",Match);
    } else if ((_stricmp(Field, "device") == 0) &&
               (Match != 0)) {
        Context.Filter.FilterRoutine = IrpFilterDevice;
        Context.Filter.FilterContext = (PVOID)&Match;
        dprintf("Looking for IRPs with device object == %08p\n",Match);
    } else if ((_stricmp(Field, "fileobject") == 0) &&
               (Match != 0)) {
        Context.Filter.FilterRoutine = IrpFilterFileObject;
        Context.Filter.FilterContext = (PVOID)&Match;
        dprintf("Looking for IRPs with file object == %08p\n",Match);
    } else if ((_stricmp(Field, "mdlprocess") == 0) &&
               (Match != 0)) {
        Context.Filter.FilterRoutine = IrpFilterMdlProcess;
        Context.Filter.FilterContext = (PVOID)&Match;
        dprintf("Looking for IRPs with mdl process == %08p\n",Match);
    } else if ((_stricmp(Field, "thread") == 0) &&
               (Match != 0)) {
        Context.Filter.FilterRoutine = IrpFilterThread;
        Context.Filter.FilterContext = (PVOID)&Match;
        dprintf("Looking for IRPs with thread == %08p\n",Match);
    } else if ((_stricmp(Field, "arg") == 0) &&
               (Match != 0)) {
        Context.Filter.FilterRoutine = IrpFilterArg;
        Context.Filter.FilterContext = (PVOID)&Match;
        dprintf("Looking for IRPs with arg == %08p\n",Match);
    }

    TagName = '?prI';

    SearchPool( TagName, Flags, RestartAddr, &CheckForIrp, &Context );
    return S_OK;
}



BOOLEAN
IrpFilterUserEvent(
                  IN ULONG64 Irp,
                  IN PVOID FilterContext
                  )
/*++

Routine Description:

    Checks to see if the userevent field of an IRP matches the supplied
    parameter

Arguments:

    Irp - Supplies the irp to filter

    FilterContext - supplies the user event

Return Value:

    TRUE if the specified irp has userevent == FilterContext
    FALSE otherwise

--*/

{
    ULONG64 pEvent = *((PULONG64) FilterContext);
    ULONG64 UserEvent;

    if (GetFieldValue(Irp, "nt!_IRP", "UserEvent", UserEvent)) {
        return FALSE;
    }

    if (UserEvent == pEvent) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOLEAN
IrpFilterDevice(
               IN ULONG64 Irp,
               IN PVOID FilterContext
               )
/*++

Routine Description:

    Checks to see if the specified IRP matches the supplied
    device object

Arguments:

    Irp - Supplies the irp to filter

    FilterContext - supplies the device object

Return Value:

    TRUE if the specified irp has a device == FilterContext
    FALSE otherwise

--*/

{
    ULONG64 IrpStack = (Irp+GetTypeSize("nt!_IRP"));
    ULONG StackCount, Stksize;
    ULONG64 DeviceObject;
    ULONG i;

    if (GetFieldValue(Irp, "nt!_IRP", "StackCount", StackCount)) {
        return FALSE;
    }
    if (StackCount > 30) {
        return(FALSE);
    }

    Stksize = GetTypeSize("nt!_IO_STACK_LOCATION");

    for (i=0; i<StackCount; i++) {
        if (!GetFieldValue(Irp + i*Stksize, 
                           "nt!_IO_STACK_LOCATION",
                           "DeviceObject",
                           DeviceObject)) {

            if (DeviceObject == *((PULONG64) FilterContext)) {
                return(TRUE);
            }
        }
    }
    return(FALSE);
}


BOOLEAN
IrpFilterFileObject(
                   IN ULONG64 Irp,
                   IN PVOID FilterContext
                   )
/*++

Routine Description:

    Checks to see if the Tail.Overlay.OriginalFileObject field of an IRP matches the 
    supplied parameter

Arguments:

    Irp - Supplies the irp to filter

    FilterContext - supplies the file object

Return Value:

    TRUE if the specified irp has userevent == FilterContext
    FALSE otherwise

--*/

{
    ULONG64 pFile = *((PULONG64) FilterContext);
    ULONG64 OriginalFileObject;

    if (GetFieldValue(Irp, "nt!_IRP",
                      "Tail.Overlay.OriginalFileObject", 
                      OriginalFileObject)) {
        return FALSE;
    }

    if (OriginalFileObject == pFile) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOLEAN
IrpFilterThread(
               IN ULONG64 Irp,
               IN PVOID FilterContext
               )
/*++

Routine Description:

    Checks to see if the Tail.Overlay.OriginalFileObject field of an IRP matches the 
    supplied parameter

Arguments:

    Irp - Supplies the irp to filter

    FilterContext - supplies the file object

Return Value:

    TRUE if the specified irp has userevent == FilterContext
    FALSE otherwise

--*/

{
    ULONG64 pThread = *((PULONG64) FilterContext);
    ULONG64 Thread;

    if (GetFieldValue(Irp, "nt!_IRP",
                      "Tail.Overlay.Thread", 
                      Thread)) {
        return FALSE;
    }

    if (Thread == pThread) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOLEAN
IrpFilterMdlProcess(
                   IN ULONG64 Irp,
                   IN PVOID FilterContext
                   )
/*++

Routine Description:

    Checks to see if the Tail.Overlay.OriginalFileObject field of an IRP matches the 
    supplied parameter

Arguments:

    Irp - Supplies the irp to filter

    FilterContext - supplies the file object

Return Value:

    TRUE if the specified irp has userevent == FilterContext
    FALSE otherwise

--*/

{
    ULONG64 pProcess = *((PULONG64) FilterContext);
    ULONG64 Process, MdlAddress;

    if (GetFieldValue(Irp, "nt!_IRP",
                      "MdlAddress", 
                      MdlAddress)) {
        return FALSE;
    }

    if (MdlAddress == 0) {
        return(FALSE);
    }

    if (GetFieldValue(MdlAddress, "nt!_MDL", "Process", Process)) {
        return FALSE;
    }
    if (Process == pProcess) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOLEAN
IrpFilterArg(
            IN ULONG64 Irp,
            IN PVOID FilterContext
            )
/*++

Routine Description:

    Checks to see if the specified IRP matches the supplied
    argument

Arguments:

    Irp - Supplies the irp to filter

    FilterContext - supplies the argument to match

Return Value:

    TRUE if the specified irp has argument == FilterContext
    FALSE otherwise

--*/

{
    ULONG64 IrpStack = (Irp+GetTypeSize("nt!_IRP"));
    ULONG StackCount, Stksize;
    ULONG i;

    if (GetFieldValue(Irp, "nt!_IRP", "StackCount", StackCount)) {
        return FALSE;
    }
    Stksize = GetTypeSize("nt!_IO_STACK_LOCATION");

    if (!Stksize || (StackCount > 30)) {
        return(FALSE);
    }


    for (i=0; i<StackCount; i++) {
        ULONG64 Argument1,Argument2,Argument3,Argument4;

        GetFieldValue(Irp + i*Stksize, "nt!_IO_STACK_LOCATION",
                      "Parameters.Others.Argument1",Argument1);
        GetFieldValue(Irp + i*Stksize, "nt!_IO_STACK_LOCATION",
                      "Parameters.Others.Argument2",Argument2);
        GetFieldValue(Irp + i*Stksize, "nt!_IO_STACK_LOCATION",
                      "Parameters.Others.Argument3",Argument3);
        GetFieldValue(Irp + i*Stksize, "nt!_IO_STACK_LOCATION",
                      "Parameters.Others.Argument4",Argument4);
        if ((Argument1 == *((PULONG64)FilterContext)) ||
            (Argument2 == *((PULONG64)FilterContext)) ||
            (Argument3 == *((PULONG64)FilterContext)) ||
            (Argument4 == *((PULONG64)FilterContext))) {
            return(TRUE);
        }
    }
    return(FALSE);
}


HRESULT
GetIrpInfo(
    ULONG64 Irp,
    PDEBUG_IRP_INFO pIrp
    )
{
    ULONG Type;
    UCHAR TypeName[]= "nt!_IRP";
    ULONG irpStackIndex;
    ULONG64 irpStackAddress;

    ZeroMemory(pIrp, sizeof(DEBUG_IRP_INFO));
    pIrp->SizeOfStruct = sizeof(DEBUG_IRP_INFO);
    pIrp->IrpAddress = Irp;
    if ( (GetFieldValue(Irp, TypeName, "Type", Type)) ) {
        //dprintf("%08p: Could not read Irp\n", IrpToDump);
        return E_INVALIDARG;
    }
    if (Type != IO_TYPE_IRP) {
        return E_INVALIDARG;
    }

    GetFieldValue(Irp, TypeName, "StackCount", pIrp->StackCount);
    GetFieldValue(Irp, TypeName, "CurrentLocation", pIrp->CurrentLocation);
    GetFieldValue(Irp, TypeName, "MdlAddress", pIrp->MdlAddress);
    GetFieldValue(Irp, TypeName, "CancelRoutine", pIrp->CancelRoutine);
    GetFieldValue(Irp, TypeName, "Tail.Overlay.Thread", pIrp->Thread);

    for (irpStackIndex = pIrp->StackCount, 
         irpStackAddress = Irp + GetTypeSize("nt!_IRP") + (pIrp->StackCount - 1)* GetTypeSize("nt!_IO_STACK_LOCATION");
         irpStackIndex >= 1;
         irpStackIndex++,   irpStackAddress -= GetTypeSize("nt!_IO_STACK_LOCATION")) {

        if ( InitTypeRead(irpStackAddress, nt!_IO_STACK_LOCATION)) {
            return E_INVALIDARG;
        }
        
        pIrp->CurrentStack.DeviceObject      = ReadField(DeviceObject);

        if (!pIrp->CurrentStack.DeviceObject) {
            // To be implemented later, we are only interested in current one now
            continue;
        }

        pIrp->CurrentStack.StackAddress      = irpStackAddress;
        pIrp->CurrentStack.CompletionRoutine = ReadField(CompletionRoutine);
        pIrp->CurrentStack.FileObject        = ReadField(FileObject);
        pIrp->CurrentStack.Major             = (UCHAR) ReadField(MajorFunction);
        pIrp->CurrentStack.Minor             = (UCHAR) ReadField(MinorFunction);
        break;
    }
    return S_OK;
}


EXTENSION_API( GetIrpInfo )(
    PDEBUG_CLIENT Client,
    ULONG64 Irp,
    PDEBUG_IRP_INFO pIrp
    )
{
    HRESULT Hr = E_FAIL;

    INIT_API();

    if (pIrp && (pIrp->SizeOfStruct == sizeof(DEBUG_IRP_INFO))) {
        Hr = GetIrpInfo(Irp, pIrp);
    }
    EXIT_API();
    return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\kdexts.cpp ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

--*/


#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>
#include <string.h>
//
// globals
//
WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG64                 STeip;
ULONG64                 STebp;
ULONG64                 STesp;

DBGKD_GET_VERSION64     KernelVersionPacket;
KDDEBUGGER_DATA64       KdDebuggerData;

ULONG64 EXPRLastDump = 0;

//
// Valid for the lifetime of the debug session.
//

ULONG   PageSize;
ULONG64 PaeEnabled;
ULONG   TargetMachine;
BOOL    Connected;
ULONG   BuildNo;
ULONG   PoolBlockShift;
ULONG   TargetIsDump;

//
// this string is for supporting both the old and the new way of getting
// data from the kernel.  Maybe it will go away soon.
//
char ___SillyString[200];

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL2       g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS2       g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl2),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols2),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

void
GetLabIdFromBuildString(
    PSTR BuildString,
    PULONG pLabId
    )
{
    PCHAR pstr;

    *pLabId = 0;
    _strlwr(BuildString);
    pstr = strstr(BuildString, "lab");
    if (pstr) {
        sscanf(pstr+3, "%ld", pLabId);
    }
}

extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL2 DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL2 DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the page size and PAE enable flag
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugDataSpaces),
                                       (void **)&DebugDataSpaces)) == S_OK)
            {
                if ((Hr = DebugDataSpaces->ReadDebuggerData(
                                            DEBUG_DATA_PaeEnabled, &PaeEnabled,
                                            sizeof(PaeEnabled), NULL)) == S_OK)
                {
                    if ((Hr = DebugDataSpaces->ReadDebuggerData(
                                                DEBUG_DATA_MmPageSize, &Page,
                                                sizeof(Page), NULL)) == S_OK)
                    {
                        PageSize = (ULONG)(ULONG_PTR)Page;
                    }
                }

                DebugDataSpaces->Release();
            }

            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                       (void **)&DebugControl)) == S_OK)
            {
                if (PageSize)
                {
                    ULONG Platform, MajorVer, MinorVer, SrvPack, StringUsed;
                    CHAR  BuildString[100];
                    if ((Hr = DebugControl->GetActualProcessorType(
                                                 &TargetMachine)) == S_OK)
                    {
                        Connected = TRUE;
                    }

                    if ((Hr = DebugControl->GetSystemVersion(&Platform, &MajorVer,
                                                             &MinorVer, NULL,
                                                             0, NULL,
                                                             &SrvPack, &BuildString[0],
                                                             sizeof(BuildString), &StringUsed)) == S_OK)
                    {
                        ULONG LabId;
                        BuildNo = MinorVer;
                        GetLabIdFromBuildString(BuildString, &LabId);
                        NewPool = ((BuildNo > 2407) || (LabId == 1 && BuildNo >= 2402));
                        PoolBlockShift = NewPool ? 
                            POOL_BLOCK_SHIFT_LAB1_2402 : POOL_BLOCK_SHIFT_OLD;
                    }

                }
                ULONG Class, Qual;
                if ((Hr = DebugControl->GetDebuggeeType(&Class, &Qual)) != S_OK) {
                    Class = Qual = 0;
                }
                if (Qual == DEBUG_DUMP_SMALL || Qual == DEBUG_DUMP_DEFAULT || Qual == DEBUG_DUMP_FULL) {
                    TargetIsDump = TRUE;
                }
                if (Class == DEBUG_CLASS_USER_WINDOWS) {
                    dprintf("\n**** WARNING loaded *kernel* extension dll for usermode\n\n");
                }
                DebugControl->Release();
            }

            DebugClient->Release();
        }
    }



    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        PageSize = 0;
        PaeEnabled = 0;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}

BOOL
HaveDebuggerData(
    VOID
    )
{
    static int havedata = 0;

    if (havedata == 0) {
        if (!Ioctl( IG_GET_KERNEL_VERSION, &KernelVersionPacket, sizeof(KernelVersionPacket))) {
            havedata = 2;
        } else if (KernelVersionPacket.MajorVersion == 0) {
            havedata = 2;
        } else {
            havedata = 1;
        }
    }

    return (havedata == 1) &&
           ((KernelVersionPacket.Flags & DBGKD_VERS_FLAG_DATA) != 0);
}

BOOL
GetCurrentProcessor(
    IN PDEBUG_CLIENT Client,
    OPTIONAL OUT PULONG pProcessor,
    OPTIONAL OUT PHANDLE phCurrentThread
    )
{
    PDEBUG_SYSTEM_OBJECTS DebugSystem;
    ULONG64 hCurrentThread;

    if (Client) {
        if (Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                   (void **)&DebugSystem) != S_OK) {
            return 0;
        }

        DebugSystem->GetCurrentThreadHandle(&hCurrentThread);
        if (phCurrentThread) { 
            *phCurrentThread = (HANDLE) hCurrentThread;
        }
        if (pProcessor) {
            *pProcessor = (ULONG) hCurrentThread - 1;
        }

        DebugSystem->Release();
        return TRUE;
    }
    if (phCurrentThread) { 
        *phCurrentThread = NULL;
    }
    if (pProcessor) {
        *pProcessor = 0;
    }
    return FALSE;

    
}


HRESULT 
ExecuteCommand(
    IN PDEBUG_CLIENT Client,
    IN PSTR Cmd
    )
{
    if (Client &&
        (ExtQuery(Client) == S_OK)) {
        g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT, 
                              Cmd, DEBUG_EXECUTE_DEFAULT );

        ExtRelease();
        return S_OK;
    }
    return E_INVALIDARG;
}


HRESULT 
GetExtensionFunction(
    IN PCSTR FunctionName,
    IN FARPROC *Function
    )
{
    if (g_ExtControl) {
        g_ExtControl->GetExtensionFunction(0, FunctionName, Function );

        return S_OK;
    }
    return E_INVALIDARG;
}

BOOLEAN
ReadMemoryUncached (
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    PULONG BytesRead
    )
{
    HRESULT result;

    result = g_ExtData->ReadVirtualUncached(Offset,
                                            Buffer,
                                            BufferSize,
                                            BytesRead);

    return (result == S_OK);
}

BOOLEAN
WriteMemoryUncached (
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    PULONG BytesWritten
    )
{
    HRESULT result;

    result = g_ExtData->WriteVirtualUncached(Offset,
                                             Buffer,
                                             BufferSize,
                                             BytesWritten);
    return (result == S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\ia64.h ===
#ifndef _KDEXTS_IA64_H_
#define _KDEXTS_IA64_H_

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ia64.h

Abstract:

    This file contains definitions which are specifice to ia64 platforms


Author:

    Kshitiz K. Sharma (kksharma)

Environment:

    User Mode.

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

//
// Define base address for kernel and user space
//

#define UREGION_INDEX_IA64 0

#define KREGION_INDEX_IA64 7

#define UADDRESS_BASE_IA64 ((ULONGLONG)UREGION_INDEX_IA64 << 61)


#define KADDRESS_BASE_IA64 ((ULONGLONG)KREGION_INDEX_IA64 << 61)

//
// user/kernel page table base and top addresses
//

#define SADDRESS_BASE_IA64 0x2000000000000000UI64  // session base address


//
// Define the number of bits to shift to left to produce page table offset
// from page table index.
//

#define PTE_SHIFT_IA64 3 // Intel-IA64-Filler

#define PAGE_SHIFT_IA64 13L

#define VRN_MASK_IA64   0xE000000000000000UI64    // Virtual Region Number mask

extern ULONG64 KiIA64VaSignedFill;
extern ULONG64 KiIA64PtaSign;

#define PTA_SIGN_IA64 KiIA64PtaSign
#define VA_FILL_IA64 KiIA64VaSignedFill

#define PTA_BASE_IA64 KiIA64PtaBase

#define PTE_UBASE_IA64  (UADDRESS_BASE_IA64|PTA_BASE_IA64)
#define PTE_KBASE_IA64  (KADDRESS_BASE_IA64|PTA_BASE_IA64)
#define PTE_SBASE_IA64  (SADDRESS_BASE_IA64|PTA_BASE_IA64)

#define PTE_UTOP_IA64 (PTE_UBASE_IA64|(((ULONG64)1 << PDI1_SHIFT_IA64) - 1)) // top level PDR address (user)
#define PTE_KTOP_IA64 (PTE_KBASE_IA64|(((ULONG64)1 << PDI1_SHIFT_IA64) - 1)) // top level PDR address (kernel)
#define PTE_STOP_IA64 (PTE_SBASE_IA64|(((ULONG64)1 << PDI1_SHIFT_IA64) - 1)) // top level PDR address (session)

//
// Second level user and kernel PDR address
//
#define PTI_SHIFT_IA64  PAGE_SHIFT_IA64 // Intel-IA64-Filler
#define PDI_SHIFT_IA64 (PTI_SHIFT_IA64 + PAGE_SHIFT_IA64 - PTE_SHIFT_IA64)  // Intel-IA64-Filler
#define PDI1_SHIFT_IA64 (PDI_SHIFT_IA64 + PAGE_SHIFT_IA64 - PTE_SHIFT_IA64) // Intel-IA64-Filler

#define PDE_UBASE_IA64  (PTE_UBASE_IA64|(PTE_UBASE_IA64>>(PTI_SHIFT_IA64-PTE_SHIFT_IA64)))
#define PDE_KBASE_IA64  (PTE_KBASE_IA64|(PTE_KBASE_IA64>>(PTI_SHIFT_IA64-PTE_SHIFT_IA64)))
#define PDE_SBASE_IA64  (PTE_SBASE_IA64|(PTE_SBASE_IA64>>(PTI_SHIFT_IA64-PTE_SHIFT_IA64)))

#define PDE_UTOP_IA64 (PDE_UBASE_IA64|(((ULONG64)1 << PDI_SHIFT_IA64) - 1)) // second level PDR address (user)
#define PDE_KTOP_IA64 (PDE_KBASE_IA64|(((ULONG64)1 << PDI_SHIFT_IA64) - 1)) // second level PDR address (kernel)
#define PDE_STOP_IA64 (PDE_SBASE_IA64|(((ULONG64)1 << PDI_SHIFT_IA64) - 1)) // second level PDR address (session)

//
// 8KB first level user and kernel PDR address
//

#define PDE_UTBASE_IA64 (PTE_UBASE_IA64|(PDE_UBASE_IA64>>(PTI_SHIFT_IA64-PTE_SHIFT_IA64)))
#define PDE_KTBASE_IA64 (PTE_KBASE_IA64|(PDE_KBASE_IA64>>(PTI_SHIFT_IA64-PTE_SHIFT_IA64)))
#define PDE_STBASE_IA64 (PTE_SBASE_IA64|(PDE_SBASE_IA64>>(PTI_SHIFT_IA64-PTE_SHIFT_IA64)))

#define PDE_USELFMAP_IA64 (PDE_UTBASE_IA64|(PAGE_SIZE_IA64 - (1<<PTE_SHIFT_IA64))) // self mapped PPE address (user)
#define PDE_KSELFMAP_IA64 (PDE_KTBASE_IA64|(PAGE_SIZE_IA64 - (1<<PTE_SHIFT_IA64))) // self mapped PPE address (kernel)
#define PDE_SSELFMAP_IA64 (PDE_STBASE_IA64|(PAGE_SIZE_IA64 - (1<<PTE_SHIFT_IA64))) // self mapped PPE address (kernel)

#define PTE_BASE_IA64    PTE_UBASE_IA64
#define PDE_BASE_IA64    PDE_UBASE_IA64
#define PDE_TBASE_IA64   PDE_UTBASE_IA64
#define PDE_SELFMAP_IA64 PDE_USELFMAP_IA64


#define KSEG3_BASE_IA64  0x8000000000000000UI64
#define KSEG3_LIMIT_IA64 0x8000100000000000UI64


#define KUSEG_BASE_IA64 (UADDRESS_BASE_IA64 + 0x0)                  // base of user segment
#define KSEG0_BASE_IA64 (KADDRESS_BASE_IA64 + 0x80000000)           // base of kernel
#define KSEG2_BASE_IA64 (KADDRESS_BASE_IA64 + 0xA0000000)           // end of kernel

#define PDE_TOP_IA64 PDE_UTOP_IA64


#define MI_IS_PHYSICAL_ADDRESS_IA64(Va) \
     ((((Va) >= KSEG3_BASE_IA64) && ((Va) < KSEG3_LIMIT_IA64)) || \
      ((Va >= KSEG0_BASE_IA64) && (Va < KSEG2_BASE_IA64)))

#define _MM_PAGING_FILE_LOW_SHIFT_IA64 28
#define _MM_PAGING_FILE_HIGH_SHIFT_IA64 32

#define MI_PTE_LOOKUP_NEEDED_IA64 ((ULONG64)0xffffffff)

#define PTE_TO_PAGEFILE_OFFSET_IA64(PTE_CONTENTS) ((ULONG64)(PTE_CONTENTS) >> 32)


#define PTI_MASK_IA64        0x00FFE000
//
// Define masks for fields within the PTE.
//

#define MM_PTE_OWNER_MASK_IA64         0x0180
#define MM_PTE_VALID_MASK_IA64         1
#define MM_PTE_ACCESS_MASK_IA64        0x0020
#define MM_PTE_DIRTY_MASK_IA64         0x0040
#define MM_PTE_EXECUTE_MASK_IA64       0x0200
#define MM_PTE_WRITE_MASK_IA64         0x0400
#define MM_PTE_LARGE_PAGE_MASK_IA64    0
#define MM_PTE_COPY_ON_WRITE_MASK_IA64 ((ULONG)1 << (PAGE_SHIFT_IA64-1))

#define MM_PTE_PROTOTYPE_MASK_IA64     0x0002
#define MM_PTE_TRANSITION_MASK_IA64    0x0080


#define MM_PTE_PROTECTION_MASK_IA64    0x7c
#define MM_PTE_PAGEFILE_MASK_IA64      0xf0000000

#define MM_SESSION_SPACE_DEFAULT_IA64 (0x2000000000000000UI64)  // make it the region 1 space

//
// Define Interruption Function State (IFS) Register
//
// IFS bit field positions
//

#define IFS_IFM_IA64  _IA64    0
#define IFS_IFM_LEN_IA64   38
#define IFS_MBZ0_IA64      38
#define IFS_MBZ0_V_IA64    0x1ffffffi64
#define IFS_V_IA64         63
#define IFS_V_LEN_IA64     1

//
// IFS is valid when IFS_V = IFS_VALID
//

#define IFS_VALID_IA64     1

//
// define the width of each size field in PFS/IFS
//

#define PFS_EC_SHIFT_IA64            52
#define PFS_EC_SIZE_IA64             6
#define PFS_EC_MASK_IA64             0x3F
#define PFS_SIZE_SHIFT_IA64          7
#define PFS_SIZE_MASK_IA64           0x7F
#define NAT_BITS_PER_RNAT_REG_IA64   63
#define RNAT_ALIGNMENT_IA64          (NAT_BITS_PER_RNAT_REG_IA64 << 3)

//
// Define Region Register (RR)
//
// RR bit field positions
//

#define RR_VE_IA64         0
#define RR_MBZ0_IA64       1
#define RR_PS_IA64         2
#define RR_PS_LEN_IA64     6
#define RR_RID_IA64        8
#define RR_RID_LEN_IA64    24
#define RR_MBZ1_IA64       32

//
// indirect mov index for loading RR
//

#define RR_INDEX_IA64      61
#define RR_INDEX_LEN_IA64  3

#ifndef CONTEXT_i386
#define CONTEXT_i386    0x00010000    // this assumes that i386 and
#endif


// Please contact INTEL to get IA64-specific information
// @@BEGIN_DDKSPLIT
#define CONTEXT_IA64                    0x00080000    // Intel-IA64-Filler

#define CONTEXTIA64_CONTROL                 (CONTEXT_IA64 | 0x00000001L) // Intel-IA64-Filler
#define CONTEXTIA64_LOWER_FLOATING_POINT    (CONTEXT_IA64 | 0x00000002L) // Intel-IA64-Filler
#define CONTEXTIA64_HIGHER_FLOATING_POINT   (CONTEXT_IA64 | 0x00000004L) // Intel-IA64-Filler
#define CONTEXTIA64_INTEGER                 (CONTEXT_IA64 | 0x00000008L) // Intel-IA64-Filler
#define CONTEXTIA64_DEBUG                   (CONTEXT_IA64 | 0x00000010L) // Intel-IA64-Filler

#define CONTEXTIA64_FLOATING_POINT          (CONTEXTIA64_LOWER_FLOATING_POINT | CONTEXTIA64_HIGHER_FLOATING_POINT) // Intel-IA64-Filler
#define CONTEXTIA64_FULL                    (CONTEXTIA64_CONTROL | CONTEXTIA64_FLOATING_POINT | CONTEXTIA64_INTEGER) // Intel-IA64-Filler

// User / System mask
#define IA64_PSR_MBZ4    0
#define IA64_PSR_BE      1
#define IA64_PSR_UP      2
#define IA64_PSR_AC      3
#define IA64_PSR_MFL     4
#define IA64_PSR_MFH     5
// PSR bits 6-12 reserved (must be zero)
#define IA64_PSR_MBZ0    6
#define IA64_PSR_MBZ0_V  0x1ffi64
// System only mask
#define IA64_PSR_IC      13
#define IA64_PSR_I       14
#define IA64_PSR_PK      15
#define IA64_PSR_MBZ1    16
#define IA64_PSR_MBZ1_V  0x1i64
#define IA64_PSR_DT      17
#define IA64_PSR_DFL     18
#define IA64_PSR_DFH     19
#define IA64_PSR_SP      20
#define IA64_PSR_PP      21
#define IA64_PSR_DI      22
#define IA64_PSR_SI      23
#define IA64_PSR_DB      24
#define IA64_PSR_LP      25
#define IA64_PSR_TB      26
#define IA64_PSR_RT      27
// PSR bits 28-31 reserved (must be zero)
#define IA64_PSR_MBZ2    28
#define IA64_PSR_MBZ2_V  0xfi64
// Neither mask
#define IA64_PSR_CPL     32
#define IA64_PSR_CPL_LEN 2
#define IA64_PSR_IS      34
#define IA64_PSR_MC      35
#define IA64_PSR_IT      36
#define IA64_PSR_ID      37
#define IA64_PSR_DA      38
#define IA64_PSR_DD      39
#define IA64_PSR_SS      40
#define IA64_PSR_RI      41
#define IA64_PSR_RI_LEN  2
#define IA64_PSR_ED      43
#define IA64_PSR_BN      44
// PSR bits 45-63 reserved (must be zero)
#define IA64_PSR_MBZ3    45
#define IA64_PSR_MBZ3_V  0xfffffi64

//
// Define IA64 specific read control space commands for the
// Kernel Debugger.
//

#define DEBUG_CONTROL_SPACE_PCR_IA64       1
#define DEBUG_CONTROL_SPACE_PRCB_IA64      2
#define DEBUG_CONTROL_SPACE_KSPECIAL_IA64  3
#define DEBUG_CONTROL_SPACE_THREAD_IA64    4

/////////////////////////////////////////////
//
//  Generic EM Registers definitions
//
/////////////////////////////////////////////

typedef unsigned __int64  EM_REG;
typedef EM_REG           *PEM_REG;
#define EM_REG_BITS       (sizeof(EM_REG) * 8)

__inline EM_REG
ULong64ToEMREG( 
    IN ULONG64 Val
    )
{
    return (*((PEM_REG)&Val));
} // ULong64ToEMREG()

__inline ULONG64
EMREGToULong64(
    IN EM_REG EmReg
    )
{
    return (*((PULONG64)&EmReg));
} // EMRegToULong64()

#define DEFINE_ULONG64_TO_EMREG(_EM_REG_TYPE) \
__inline _EM_REG_TYPE                         \
ULong64To##_EM_REG_TYPE(                      \
    IN ULONG64 Val                            \
    )                                         \
{                                             \
    return (*((P##_EM_REG_TYPE)&Val));        \
} // ULong64To##_EM_REG_TYPE() 

#define DEFINE_EMREG_TO_ULONG64(_EM_REG_TYPE) \
__inline ULONG64                              \
_EM_REG_TYPE##ToULong64(                      \
    IN _EM_REG_TYPE EmReg                     \
    )                                         \
    {                                         \
    return (*((PULONG64)&EmReg));             \
} // _EM_REG_TYPE##ToULong64()

typedef struct _EM_ISR {
    unsigned __int64    code:16;        //  0-15 : interruption Code
    unsigned __int64    vector:8;       // 16-23 : IA32 exception vector number
    unsigned __int64    reserved0: 8;   
    unsigned __int64    x:1;            //    32 : Execute exception
    unsigned __int64    w:1;            //    33 : Write exception
    unsigned __int64    r:1;            //    34 : Read exception
    unsigned __int64    na:1;           //    35 : Non-Access exception
    unsigned __int64    sp:1;           //    36 : Speculative load exception
    unsigned __int64    rs:1;           //    37 : Register Stack
    unsigned __int64    ir:1;           //    38 : Invalid Register frame
    unsigned __int64    ni:1;           //    39 : Nested interruption
    unsigned __int64    so:1;           //    40 : IA32 Supervisor Override
    unsigned __int64    ei:2;           // 41-42 : Excepting IA64 Instruction
    unsigned __int64    ed:1;           //    43 : Exception Differal
    unsigned __int64    reserved1:20;   // 44-63 
} EM_ISR, *PEM_ISR;

DEFINE_ULONG64_TO_EMREG(EM_ISR)

DEFINE_EMREG_TO_ULONG64(EM_ISR)

/////////////////////////////////////////////
//
//  Trap.c
//
/////////////////////////////////////////////

VOID
DisplayIsrIA64(
    IN const  PCHAR         Header,      // Header string displayed before psr.
    IN        EM_ISR        IsrValue,    // ISR value. Use ULong64ToEM_ISR() if needed.
    IN        DISPLAY_MODE  DisplayMode  // Display mode.
    );
  
/////////////////////////////////////////////
//
//  Psr.c
//
/////////////////////////////////////////////

typedef struct _EM_PSR {
   unsigned __int64 reserved0:1;  //     0 : reserved
   unsigned __int64 be:1;         //     1 : Big-Endian
   unsigned __int64 up:1;         //     2 : User Performance monitor enable
   unsigned __int64 ac:1;         //     3 : Alignment Check
   unsigned __int64 mfl:1;        //     4 : Lower (f2  ..  f31) floating-point registers written
   unsigned __int64 mfh:1;        //     5 : Upper (f32 .. f127) floating-point registers written
   unsigned __int64 reserved1:7;  //  6-12 : reserved
   unsigned __int64 ic:1;         //    13 : Interruption Collection
   unsigned __int64 i:1;          //    14 : Interrupt Bit
   unsigned __int64 pk:1;         //    15 : Protection Key enable
   unsigned __int64 reserved2:1;  //    16 : reserved
   unsigned __int64 dt:1;         //    17 : Data Address Translation
   unsigned __int64 dfl:1;        //    18 : Disabled Floating-point Low  register set
   unsigned __int64 dfh:1;        //    19 : Disabled Floating-point High register set
   unsigned __int64 sp:1;         //    20 : Secure Performance monitors
   unsigned __int64 pp:1;         //    21 : Privileged Performance monitor enable
   unsigned __int64 di:1;         //    22 : Disable Instruction set transition
   unsigned __int64 si:1;         //    23 : Secure Interval timer
   unsigned __int64 db:1;         //    24 : Debug Breakpoint fault
   unsigned __int64 lp:1;         //    25 : Lower Privilege transfer trap
   unsigned __int64 tb:1;         //    26 : Taken Branch trap
   unsigned __int64 rt:1;         //    27 : Register stack translation
   unsigned __int64 reserved3:4;  // 28-31 : reserved
   unsigned __int64 cpl:2;        // 32;33 : Current Privilege Level
   unsigned __int64 is:1;         //    34 : Instruction Set
   unsigned __int64 mc:1;         //    35 : Machine Abort Mask
   unsigned __int64 it:1;         //    36 : Instruction address Translation
   unsigned __int64 id:1;         //    37 : Instruction Debug fault disable
   unsigned __int64 da:1;         //    38 : Disable Data Access and Dirty-bit faults
   unsigned __int64 dd:1;         //    39 : Data Debug fault disable
   unsigned __int64 ss:1;         //    40 : Single Step enable
   unsigned __int64 ri:2;         // 41;42 : Restart Instruction
   unsigned __int64 ed:1;         //    43 : Exception Deferral
   unsigned __int64 bn:1;         //    44 : register Bank
   unsigned __int64 ia:1;         //    45 : Disable Instruction Access-bit faults 
   unsigned __int64 reserved4:18; // 46-63 : reserved
} EM_PSR, *PEM_PSR;

typedef EM_PSR   EM_IPSR;
typedef EM_IPSR *PEM_IPSR;

DEFINE_ULONG64_TO_EMREG(EM_PSR)

DEFINE_EMREG_TO_ULONG64(EM_PSR)
             
VOID
DisplayPsrIA64(
    IN const  PCHAR         Header,      // Header string displayed before psr.
    IN        EM_PSR        PsrValue,    // PSR value. Use ULong64ToEM_PSR() if needed.
    IN        DISPLAY_MODE  DisplayMode  // Display mode.
    );

typedef struct _EM_PSP {
   unsigned __int64 reserved0:2;  //   0-1 : reserved
   unsigned __int64 rz:1;         //     2 : Rendez-vous successful
   unsigned __int64 ra:1;         //     3 : Rendez-vous attempted
   unsigned __int64 me:1;         //     4 : Distinct Multiple errors
   unsigned __int64 mn:1;         //     5 : Min-state Save Area registered
   unsigned __int64 sy:1;         //     6 : Storage integrity synchronized
   unsigned __int64 co:1;         //     7 : Continuable
   unsigned __int64 ci:1;         //     8 : Machine Check isolated
   unsigned __int64 us:1;         //     9 : Uncontained Storage damage
   unsigned __int64 hd:1;         //    10 : Hardware damage
   unsigned __int64 tl:1;         //    11 : Trap lost
   unsigned __int64 mi:1;         //    12 : More Information
   unsigned __int64 pi:1;         //    13 : Precise Instruction pointer
   unsigned __int64 pm:1;         //    14 : Precise Min-state Save Area
   unsigned __int64 dy:1;         //    15 : Processor Dynamic State valid
   unsigned __int64 in:1;         //    16 : INIT interruption
   unsigned __int64 rs:1;         //    17 : RSE valid
   unsigned __int64 cm:1;         //    18 : Machine Check corrected
   unsigned __int64 ex:1;         //    19 : Machine Check expected
   unsigned __int64 cr:1;         //    20 : Control Registers valid
   unsigned __int64 pc:1;         //    21 : Performance Counters valid
   unsigned __int64 dr:1;         //    22 : Debug Registers valid
   unsigned __int64 tr:1;         //    23 : Translation Registers valid
   unsigned __int64 rr:1;         //    24 : Region Registers valid
   unsigned __int64 ar:1;         //    25 : Application Registers valid
   unsigned __int64 br:1;         //    26 : Branch Registers valid
   unsigned __int64 pr:1;         //    27 : Predicate Registers valid
   unsigned __int64 fp:1;         //    28 : Floating-Point Registers valid
   unsigned __int64 b1:1;         //    29 : Preserved Bank 1 General Registers valid
   unsigned __int64 b0:1;         //    30 : Preserved Bank 0 General Registers valid
   unsigned __int64 gr:1;         //    31 : General Registers valid
   unsigned __int64 dsize:16;     // 32-47 : Processor Dynamic State size
   unsigned __int64 reserved1:11; // 48-58 : reserved
   unsigned __int64 cc:1;         //    59 : Cache Check
   unsigned __int64 tc:1;         //    60 : TLB   Check
   unsigned __int64 bc:1;         //    61 : Bus   Check
   unsigned __int64 rc:1;         //    62 : Register File Check
   unsigned __int64 uc:1;         //    63 : Micro-Architectural Check
} EM_PSP, *PEM_PSP;

DEFINE_ULONG64_TO_EMREG(EM_PSP)

DEFINE_EMREG_TO_ULONG64(EM_PSP)

VOID
DisplayPspIA64(
    IN const  PCHAR         Header,      // Header string displayed before psr.
    IN        EM_PSP        PspValue,    // PSP value. Use ULong64ToEM_PSP() if needed.
    IN        DISPLAY_MODE  DisplayMode  // Display mode.
    );

/////////////////////////////////////////////
//
//  cpuinfo.cpp
//
/////////////////////////////////////////////

extern VOID
ExecCommand(
    IN PCSTR Cmd
    );

/////////////////////////////////////////////
//
//  Pmc.c
//
/////////////////////////////////////////////

VOID
DisplayPmcIA64(
    IN const  PCHAR         Header,      // Header string displayed before pmc.
    IN        ULONG64       PmcValue,    // PMC value. 
    IN        DISPLAY_MODE  DisplayMode  // Display mode.
    );

typedef struct _EM_PMC {         // Generic PMC register.
   unsigned __int64 plm:4;       //   0-3 : Privilege Level Mask
   unsigned __int64 ev:1;        //     4 : External Visibility
   unsigned __int64 oi:1;        //     5 : Overflow Interrupt
   unsigned __int64 pm:1;        //     6 : Privilege Mode
   unsigned __int64 ignored1:1;  //     7 : Ignored
   unsigned __int64 es:7;        //  8-14 : Event Selection
   unsigned __int64 ignored2:1;  //    15 : Ignored
   unsigned __int64 umask:4;     // 16-19 : Event Umask
   unsigned __int64 threshold:3; // 20-22 : Event Threshold (3 bits for PMC4-5, 2 for PMC6-7)
   unsigned __int64 ignored:1;   //    23 : Ignored
   unsigned __int64 ism:2;       // 24-25 : Instruction Set Mask
   unsigned __int64 ignored3:18; // 26-63 : Ignored
} EM_PMC, *PEM_PMC;

VOID
DisplayGenPmcIA64(
    IN const  PCHAR         Header,      // Header string displayed before pmc.
    IN        ULONG64       PmcValue,    // PMC value. 
    IN        DISPLAY_MODE  DisplayMode  // Display mode.
    );

DEFINE_ULONG64_TO_EMREG(EM_PMC)

DEFINE_EMREG_TO_ULONG64(EM_PMC)

typedef struct _EM_BTB_PMC {     // Branch Trace Buffer PMC register.
   unsigned __int64 plm:4;       //   0-3 : Privilege Level Mask
   unsigned __int64 ignored1:2;  //   4-5 : Ignored
   unsigned __int64 pm:1;        //     6 : Privilege Mode
   unsigned __int64 tar:1;       //     7 : Target Address Register
   unsigned __int64 tm:2;        //   8-9 : Taken Mask
   unsigned __int64 ptm:2;       // 10-11 : Predicted Target Address Mask
   unsigned __int64 ppm:2;       // 12-13 : Predicted Predicate Mask
   unsigned __int64 bpt:1;       //    14 : Branch Prediction Table
   unsigned __int64 bac:1;       //    15 : Branch Address Calculator
   unsigned __int64 ignored2:48; // 16-63 : Ignored
} EM_BTB_PMC, *PEM_BTB_PMC;

VOID
DisplayBtbPmcIA64(
    IN const  PCHAR         Header,      // Header string displayed before pmc.
    IN        ULONG64       PmcValue,    // PMC value. 
    IN        DISPLAY_MODE  DisplayMode  // Display mode.
    );

DEFINE_ULONG64_TO_EMREG(EM_BTB_PMC)

DEFINE_EMREG_TO_ULONG64(EM_BTB_PMC)

typedef struct _EM_BTB_PMD {     // Branch Trace Buffer PMD register.
   unsigned __int64 b:1;         //     0 : Branch Bit
   unsigned __int64 mp:1;        //     1 : Mispredict Bit
   unsigned __int64 slot:2;      //   2-3 : Slot
   unsigned __int64 address:60;  //  4-63 : Address
} EM_BTB_PMD, *PEM_BTB_PMD;

VOID
DisplayBtbPmdIA64(
    IN const  PCHAR         Header,      // Header string displayed before pmc.
    IN        ULONG64       PmdValue,    // PMD value. 
    IN        DISPLAY_MODE  DisplayMode  // Display mode.
    );

DEFINE_ULONG64_TO_EMREG(EM_BTB_PMD)

DEFINE_EMREG_TO_ULONG64(EM_BTB_PMD)

typedef struct _EM_BTB_INDEX_PMD {    // Branch Trace Buffer Index Format PMD register.
   unsigned __int64 bbi:3;       //   0-2 : Branch Buffer Index
   unsigned __int64 full:1;      //     3 : Full bit
   unsigned __int64 ignored:60;  //  4-63 : Ignored
} EM_BTB_INDEX_PMD, *PEM_BTB_INDEX_PMD;

VOID
DisplayBtbIndexPmdIA64(
    IN const  PCHAR         Header,      // Header string displayed before pmc.
    IN        ULONG64       PmdValue,    // PMD value.
    IN        DISPLAY_MODE  DisplayMode  // Display mode.
    );

DEFINE_ULONG64_TO_EMREG(EM_BTB_INDEX_PMD)

DEFINE_EMREG_TO_ULONG64(EM_BTB_INDEX_PMD)


/////////////////////////////////////////////
//
//  Dcr.c
//
/////////////////////////////////////////////

typedef struct _EM_DCR {
   unsigned __int64 pp:1;         //     0 : Privileged Performance Monitor Default
   unsigned __int64 be:1;         //     1 : Big-Endian Default
   unsigned __int64 lc:1;         //     2 : IA-32 Lock check Enable
   unsigned __int64 reserved1:5;  //   3-7 : Reserved      
   unsigned __int64 dm:1;         //     8 : Defer TLB Miss faults only
   unsigned __int64 dp:1;         //     9 : Defer Page Not Present faults only
   unsigned __int64 dk:1;         //    10 : Defer Key Miss faults only
   unsigned __int64 dx:1;         //    11 : Defer Key Permission faults only
   unsigned __int64 dr:1;         //    12 : Defer Access Rights faults only
   unsigned __int64 da:1;         //    13 : Defer Access Bit faults only
   unsigned __int64 dd:1;         //    14 : Defer Debug faults only
   unsigned __int64 reserved2:49; // 15-63 : Reserved
} EM_DCR, *PEM_DCR;

DEFINE_ULONG64_TO_EMREG(EM_DCR)

DEFINE_EMREG_TO_ULONG64(EM_DCR)

VOID
DisplayDcrIA64(
    IN const  PCHAR         Header,      // Header string displayed before dcr.
    IN        EM_DCR        DcrValue,    // DCR value. Use ULong64ToEM_DCR() if needed.
    IN        DISPLAY_MODE  DisplayMode  // Display mode.
    );


/////////////////////////////////////////////
//
//  Ih.c
//
/////////////////////////////////////////////

//
// Interruption history
//
// N.B. Currently the history records are saved in the 2nd half of the 8K
//      PCR page.  Therefore, we can only keep track of up to the latest
//      128 interruption records, each of 32 bytes in size.  Also, the PCR
//      structure cannot be greater than 4K.  In the future, the interruption
//      history records may become part of the KPCR structure.
//

typedef struct _IHISTORY_RECORD {
   ULONGLONG InterruptionType;
   ULONGLONG IIP;
   ULONGLONG IPSR;
   ULONGLONG Extra0;
} IHISTORY_RECORD;

#define MAX_NUMBER_OF_IHISTORY_RECORDS  128

//
// Branch Trace Buffer history
//
// FIXFIX: MAX_NUMBER_OF_BTB_RECORDS is micro-architecture dependent.
//         We should collect this from processor specific data structure.

#define MAX_NUMBER_OF_BTB_RECORDS        8
#define MAX_NUMBER_OF_BTBHISTORY_RECORDS (MAX_NUMBER_OF_BTB_RECORDS + 1 /* HBC */)

/////////////////////////////////////////////
//
//  Mca.c
//
//
/////////////////////////////////////////////

//
// Thierry - 10/04/2000: 
// Duplicating the following ntos\inc\hal [or ntos\inc\ia64.h] definitions is wrong.
// I expressed my view to the DBG team. We should not do this but we have to
// wait until they offer a way to build these extensions without these 
// unneeded and error prone duplications.
//
// However, these definitions should be temporarely because the *.pdb reads should
// be successful. After the HALIA64 MCA changes got propagated to all the builds, 
// we should definitively think about deleting these definitions from this file.
//

//
// IA64 ERRORS: ERROR_REVISION definitions
//

typedef union _ERROR_REVISION_IA64 {
    USHORT      Revision;           // Major and Minor revision number of the record:
    struct {
        UCHAR   Minor;              //  Byte0: Minor. 
        UCHAR   Major;              //  Byte1: Major.
    };
} ERROR_REVISION_IA64, *PERROR_REVISION_IA64;

//
// IA64 ERRORS: ERROR_SEVERITY definitions
//
// One day the MS compiler will support typed enums with type != int so this 
// type of enums (USHORT, __int64) could be defined...
//

#define ErrorRecoverable_IA64  ((USHORT)0)
#define ErrorFatal_IA64        ((USHORT)1)
#define ErrorCorrected_IA64    ((USHORT)2)
//      ErrorOthers     : Reserved

typedef UCHAR  ERROR_SEVERITY_IA64, *PERROR_SEVERITY_IA64;

//
// IA64 ERRORS: ERROR_RECORD_VALID definitions
//

typedef union _ERROR_RECORD_VALID_IA64   {
    UCHAR     Valid;
    struct {                        // Bits
        UCHAR OemPlatformID:1;      //    0: OEM Platform Id is present in the record header
        UCHAR Reserved:7;           //  1-7: Reserved
    };
} ERROR_RECORD_VALID_IA64, *PERROR_RECORD_VALID_IA64;

//
// IA64 ERRORS: ERROR_TIMESTAMP definitions
//

typedef union _ERROR_TIMESTAMP_IA64  {
    ULONGLONG   TimeStamp;
    struct  {
        UCHAR   Seconds;  // Byte0: Seconds
        UCHAR   Minutes;  // Byte1: Minutes
        UCHAR   Hours;    // Byte2: Hours  
        UCHAR   Reserved; // Byte3: Reserved
        UCHAR   Day;      // Byte4: Day     
        UCHAR   Month;    // Byte5: Month   
        UCHAR   Year;     // Byte6: Year    
        UCHAR   Century;  // Byte7: Century 
    };
} ERROR_TIMESTAMP_IA64, *PERROR_TIMESTAMP_IA64;

//
// IA64 ERRORS: ERROR_DEVICE_GUID definitions
//

typedef struct _ERROR_DEVICE_GUID_IA64   {
    ULONG   Data1;
    USHORT  Data2;
    USHORT  Data3;
    UCHAR   Data4[8];
} ERROR_DEVICE_GUID_IA64, *PERROR_DEVICE_GUID_IA64;

//
// IA64 ERRORS: ERROR_RECORD definitions
//

typedef struct _ERROR_RECORD_HEADER_IA64 { // Offsets:
    ULONGLONG               Id;             // Unique identifier
    ERROR_REVISION_IA64     Revision;       // Major and Minor revision number of the record
    ERROR_SEVERITY_IA64     ErrorSeverity;  // Error Severity
    ERROR_RECORD_VALID_IA64 Valid;          // Validation bits
    ULONG                   Length;         // Length of this record in bytes, including the header
    ERROR_TIMESTAMP_IA64    TimeStamp;      // Timestamp recorded when event occured
    UCHAR                   OemPlatformId[16]; // Unique platform identifier. OEM defined.
} ERROR_RECORD_HEADER_IA64, *PERROR_RECORD_HEADER_IA64;

//
// IA64 ERRORS: ERROR_SECTION_HEADER definitions
//

typedef union _ERROR_RECOVERY_INFO_IA64  {
    UCHAR RecoveryInfo;
    struct  {                 // Bits:
        UCHAR Corrected:1;    //    0: Corrected
        UCHAR NotContained:1; //    1: Containment Warning
        UCHAR Reset:1;        //    2: Reset
        UCHAR Reserved:4;     //  6-3: Reserved
        UCHAR Valid:1;        //    7: Valid Recovery Information
    };
} ERROR_RECOVERY_INFO_IA64, *PERROR_RECOVERY_INFO_IA64;

typedef struct _ERROR_SECTION_HEADER_IA64    {
    ERROR_DEVICE_GUID_IA64   Guid;         // Unique identifier
    ERROR_REVISION_IA64      Revision;     // Major and Minor revision number of the section
    ERROR_RECOVERY_INFO_IA64 RecoveryInfo; // Recovery Information
    UCHAR                    Reserved;
    ULONG                    Length;       // Length of this error device section in bytes,
                                           // including the header.
} ERROR_SECTION_HEADER_IA64, *PERROR_SECTION_HEADER_IA64;

//
// IA64 ERRORS: ERROR_PROCESSOR device definitions
//

typedef union _ERROR_MODINFO_VALID_IA64  {
    ULONGLONG     Valid;
    struct {                                // Bits  
        ULONGLONG CheckInfo: 1;             //       0: 
        ULONGLONG RequestorIdentifier: 1;   //       1: 
        ULONGLONG ResponderIdentifier: 1;   //       2: 
        ULONGLONG TargetIdentifier: 1;      //       3: 
        ULONGLONG PreciseIP: 1;             //       4: 
        ULONGLONG Reserved: 59;             //    5-63:
    };
} ERROR_MODINFO_VALID_IA64, *PERROR_MODINFO_VALID_IA64;

// SAL Specs July 2000: The size of _ERROR_MODINFO will always be 48 Bytes.

typedef struct _ERROR_MODINFO_IA64   {  
    ERROR_MODINFO_VALID_IA64 Valid;
    ULONGLONG           CheckInfo;
    ULONGLONG           RequestedId;
    ULONGLONG           ResponderId;
    ULONGLONG           TargetId;
    ULONGLONG           PreciseIP;
} ERROR_MODINFO_IA64, *PERROR_MODINFO_IA64;

#define ERROR_PROCESSOR_GUID_IA64 \
    { 0xe429faf1, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PROCESSOR_VALID_IA64    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG ErrorMap: 1;              //       0:
        ULONGLONG StateParameter: 1;        //       1:
        ULONGLONG CRLid: 1;                 //       2:
        ULONGLONG StaticStruct:1;           //       3: Processor Static Info error.
        ULONGLONG CacheCheckNum:4;          //     4-7: Cache errors.
        ULONGLONG TlbCheckNum:4;            //    8-11: Tlb errors.
        ULONGLONG BusCheckNum:4;            //   12-15: Bus errors.
        ULONGLONG RegFileCheckNum:4;        //   16-19: Registers file errors.
        ULONGLONG MsCheckNum:4;             //   20-23: Micro-Architecture errors.
        ULONGLONG CpuIdInfo:1;              //      24: CPUID Info.
        ULONGLONG Reserved:39;              //   25-63: Reserved.
    };
} ERROR_PROCESSOR_VALID_IA64, *PERROR_PROCESSOR_VALID_IA64;

typedef struct _ERROR_PROCESSOR_CACHE_IA64 {
    ERROR_MODINFO_IA64  CacheError[ /* Valid.CacheCheckNum   */ 1]; // 0 -> 15 cache error modinfo structs.
} ERROR_PROCESSOR_CACHE_IA64, *PERROR_PROCESSOR_CACHE_IA64;

typedef struct _ERROR_PROCESSOR_TLB_IA64 {
    ERROR_MODINFO_IA64  TlbError  [ /* Valid.TlbCheckNum     */ 1]; // 0 -> 15 tlb   error modinfo structs.
} ERROR_PROCESSOR_TLB_IA64, *PERROR_PROCESSOR_TLB_IA64;

typedef struct _ERROR_PROCESSOR_BUS_IA64 {
    ERROR_MODINFO_IA64  BusError  [ /* Valid.BusCheckNum     */ 1]; // 0 -> 15 bus   error modinfo structs.
} ERROR_PROCESSOR_BUS_IA64, *PERROR_PROCESSOR_BUS_IA64;

typedef struct _ERROR_PROCESSOR_REGFILE_IA64 {
    ULONGLONG      RegError  [ /* Valid.RegFileCheckNum */ 1]; // 0 -> 15 registers file errors.
} ERROR_PROCESSOR_REGFILE_IA64, *PERROR_PROCESSOR_REGFILE_IA64;

typedef struct _ERROR_PROCESSOR_MS_IA64 {
    ULONGLONG      MsError   [ /* Valid.MsCheckNum      */ 1]; // 0 -> 15 registers file errors.
} ERROR_PROCESSOR_MS_IA64, *PERROR_PROCESSOR_MS_IA64;

typedef struct _ERROR_PROCESSOR_CPUID_INFO_IA64 {   // Must be 48 bytes.
    ULONGLONG CpuId0;
    ULONGLONG CpuId1;
    ULONGLONG CpuId2;
    ULONGLONG CpuId3;
    ULONGLONG CpuId4;
    ULONGLONG Reserved;
} ERROR_PROCESSOR_CPUID_INFO_IA64, *PERROR_PROCESSOR_CPUID_INFO_IA64;

typedef union _ERROR_PROCESSOR_STATIC_INFO_VALID_IA64 {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG MinState: 1;              //       0: MinState              valid.
        ULONGLONG BRs: 1;                   //       1: Branch      Registers valid.
        ULONGLONG CRs: 1;                   //       2: Control     Registers valid.
        ULONGLONG ARs: 1;                   //       3: Application Registers valid.
        ULONGLONG RRs: 1;                   //       4:             Registers valid.
        ULONGLONG FRs: 1;                   //       5:             Registers valid.
        ULONGLONG Reserved: 58;             //    6-63: Reserved.
    };
} ERROR_PROCESSOR_STATIC_INFO_VALID_IA64, *PERROR_PROCESSOR_STATIC_INFO_VALID_IA64;

typedef struct _PROCESSOR_MINSTATE_SAVE_AREA_IA64    {
    ULONGLONG  GRNats;          // NaT bits for saved GRs
    ULONGLONG  GR1;   
    ULONGLONG  GR2;   
    ULONGLONG  GR3;   
    ULONGLONG  GR4;   
    ULONGLONG  GR5;   
    ULONGLONG  GR6;   
    ULONGLONG  GR7;   
    ULONGLONG  GR8;   
    ULONGLONG  GR9;   
    ULONGLONG  GR10;   
    ULONGLONG  GR11;   
    ULONGLONG  GR12;   
    ULONGLONG  GR13;   
    ULONGLONG  GR14;   
    ULONGLONG  GR15;   
    ULONGLONG  Bank0GR16;
    ULONGLONG  Bank0GR17;
    ULONGLONG  Bank0GR18;
    ULONGLONG  Bank0GR19;
    ULONGLONG  Bank0GR20;
    ULONGLONG  Bank0GR21;
    ULONGLONG  Bank0GR22;
    ULONGLONG  Bank0GR23;
    ULONGLONG  Bank0GR24;
    ULONGLONG  Bank0GR25;
    ULONGLONG  Bank0GR26;
    ULONGLONG  Bank0GR27;
    ULONGLONG  Bank0GR28;
    ULONGLONG  Bank0GR29;
    ULONGLONG  Bank0GR30;
    ULONGLONG  Bank0GR31;
    ULONGLONG  Bank1GR16;
    ULONGLONG  Bank1GR17;
    ULONGLONG  Bank1GR18;
    ULONGLONG  Bank1GR19;
    ULONGLONG  Bank1GR20;
    ULONGLONG  Bank1GR21;
    ULONGLONG  Bank1GR22;
    ULONGLONG  Bank1GR23;
    ULONGLONG  Bank1GR24;
    ULONGLONG  Bank1GR25;
    ULONGLONG  Bank1GR26;
    ULONGLONG  Bank1GR27;
    ULONGLONG  Bank1GR28;
    ULONGLONG  Bank1GR29;
    ULONGLONG  Bank1GR30;
    ULONGLONG  Bank1GR31;
    ULONGLONG  Preds;
    ULONGLONG  BR0;
    ULONGLONG  RSC;
    ULONGLONG  IIP;
    ULONGLONG  IPSR;
    ULONGLONG  IFS;
    ULONGLONG  XIP;
    ULONGLONG  XPSR;
    ULONGLONG  XFS;
} PROCESSOR_MINSTATE_SAVE_AREA_IA64, *PPROCESSOR_MINSTATE_SAVE_AREA_IA64;

typedef struct _PROCESSOR_CONTROL_REGISTERS_IA64  {
    ULONGLONG DCR;
    ULONGLONG ITM;
    ULONGLONG IVA;
    ULONGLONG CR3;
    ULONGLONG CR4;
    ULONGLONG CR5;
    ULONGLONG CR6;
    ULONGLONG CR7;
    ULONGLONG PTA;
    ULONGLONG GPTA;
    ULONGLONG CR10;
    ULONGLONG CR11;
    ULONGLONG CR12;
    ULONGLONG CR13;
    ULONGLONG CR14;
    ULONGLONG CR15;
    ULONGLONG IPSR;
    ULONGLONG ISR;
    ULONGLONG CR18;
    ULONGLONG IIP;
    ULONGLONG IFA;
    ULONGLONG ITIR;
    ULONGLONG IFS;
    ULONGLONG IIM;
    ULONGLONG IHA;
    ULONGLONG CR26;
    ULONGLONG CR27;
    ULONGLONG CR28;
    ULONGLONG CR29;
    ULONGLONG CR30;
    ULONGLONG CR31;
    ULONGLONG CR32;
    ULONGLONG CR33;
    ULONGLONG CR34;
    ULONGLONG CR35;
    ULONGLONG CR36;
    ULONGLONG CR37;
    ULONGLONG CR38;
    ULONGLONG CR39;
    ULONGLONG CR40;
    ULONGLONG CR41;
    ULONGLONG CR42;
    ULONGLONG CR43;
    ULONGLONG CR44;
    ULONGLONG CR45;
    ULONGLONG CR46;
    ULONGLONG CR47;
    ULONGLONG CR48;
    ULONGLONG CR49;
    ULONGLONG CR50;
    ULONGLONG CR51;
    ULONGLONG CR52;
    ULONGLONG CR53;
    ULONGLONG CR54;
    ULONGLONG CR55;
    ULONGLONG CR56;
    ULONGLONG CR57;
    ULONGLONG CR58;
    ULONGLONG CR59;
    ULONGLONG CR60;
    ULONGLONG CR61;
    ULONGLONG CR62;
    ULONGLONG CR63;
    ULONGLONG LID;
    ULONGLONG IVR;
    ULONGLONG TPR;
    ULONGLONG EOI;
    ULONGLONG IRR0;
    ULONGLONG IRR1;
    ULONGLONG IRR2;
    ULONGLONG IRR3;
    ULONGLONG ITV;
    ULONGLONG PMV;
    ULONGLONG CMCV;
    ULONGLONG CR75;
    ULONGLONG CR76;
    ULONGLONG CR77;
    ULONGLONG CR78;
    ULONGLONG CR79;
    ULONGLONG LRR0;
    ULONGLONG LRR1;
    ULONGLONG CR82;
    ULONGLONG CR83;
    ULONGLONG CR84;
    ULONGLONG CR85;
    ULONGLONG CR86;
    ULONGLONG CR87;
    ULONGLONG CR88;
    ULONGLONG CR89;
    ULONGLONG CR90;
    ULONGLONG CR91;
    ULONGLONG CR92;
    ULONGLONG CR93;
    ULONGLONG CR94;
    ULONGLONG CR95;
    ULONGLONG CR96;
    ULONGLONG CR97;
    ULONGLONG CR98;
    ULONGLONG CR99;
    ULONGLONG CR100;
    ULONGLONG CR101;
    ULONGLONG CR102;
    ULONGLONG CR103;
    ULONGLONG CR104;
    ULONGLONG CR105;
    ULONGLONG CR106;
    ULONGLONG CR107;
    ULONGLONG CR108;
    ULONGLONG CR109;
    ULONGLONG CR110;
    ULONGLONG CR111;
    ULONGLONG CR112;
    ULONGLONG CR113;
    ULONGLONG CR114;
    ULONGLONG CR115;
    ULONGLONG CR116;
    ULONGLONG CR117;
    ULONGLONG CR118;
    ULONGLONG CR119;
    ULONGLONG CR120;
    ULONGLONG CR121;
    ULONGLONG CR122;
    ULONGLONG CR123;
    ULONGLONG CR124;
    ULONGLONG CR125;
    ULONGLONG CR126;
    ULONGLONG CR127;
} PROCESSOR_CONTROL_REGISTERS_IA64, *PPROCESSOR_CONTROL_REGISTERS_IA64;

typedef struct _PROCESSOR_APPLICATION_REGISTERS_IA64  {
    ULONGLONG KR0;
    ULONGLONG KR1;
    ULONGLONG KR2;
    ULONGLONG KR3;
    ULONGLONG KR4;
    ULONGLONG KR5;
    ULONGLONG KR6;
    ULONGLONG KR7;
    ULONGLONG AR8;
    ULONGLONG AR9;
    ULONGLONG AR10;
    ULONGLONG AR11;
    ULONGLONG AR12;
    ULONGLONG AR13;
    ULONGLONG AR14;
    ULONGLONG AR15;
    ULONGLONG RSC;
    ULONGLONG BSP;
    ULONGLONG BSPSTORE;
    ULONGLONG RNAT;
    ULONGLONG AR20;
    ULONGLONG FCR;
    ULONGLONG AR22;
    ULONGLONG AR23;
    ULONGLONG EFLAG;
    ULONGLONG CSD;
    ULONGLONG SSD;
    ULONGLONG CFLG;
    ULONGLONG FSR;
    ULONGLONG FIR;
    ULONGLONG FDR;
    ULONGLONG AR31;
    ULONGLONG CCV;
    ULONGLONG AR33;
    ULONGLONG AR34;
    ULONGLONG AR35;
    ULONGLONG UNAT;
    ULONGLONG AR37;
    ULONGLONG AR38;
    ULONGLONG AR39;
    ULONGLONG FPSR;
    ULONGLONG AR41;
    ULONGLONG AR42;
    ULONGLONG AR43;
    ULONGLONG ITC;
    ULONGLONG AR45;
    ULONGLONG AR46;
    ULONGLONG AR47;
    ULONGLONG AR48;
    ULONGLONG AR49;
    ULONGLONG AR50;
    ULONGLONG AR51;
    ULONGLONG AR52;
    ULONGLONG AR53;
    ULONGLONG AR54;
    ULONGLONG AR55;
    ULONGLONG AR56;
    ULONGLONG AR57;
    ULONGLONG AR58;
    ULONGLONG AR59;
    ULONGLONG AR60;
    ULONGLONG AR61;
    ULONGLONG AR62;
    ULONGLONG AR63;
    ULONGLONG PFS;
    ULONGLONG LC;
    ULONGLONG EC;
    ULONGLONG AR67;
    ULONGLONG AR68;
    ULONGLONG AR69;
    ULONGLONG AR70;
    ULONGLONG AR71;
    ULONGLONG AR72;
    ULONGLONG AR73;
    ULONGLONG AR74;
    ULONGLONG AR75;
    ULONGLONG AR76;
    ULONGLONG AR77;
    ULONGLONG AR78;
    ULONGLONG AR79;
    ULONGLONG AR80;
    ULONGLONG AR81;
    ULONGLONG AR82;
    ULONGLONG AR83;
    ULONGLONG AR84;
    ULONGLONG AR85;
    ULONGLONG AR86;
    ULONGLONG AR87;
    ULONGLONG AR88;
    ULONGLONG AR89;
    ULONGLONG AR90;
    ULONGLONG AR91;
    ULONGLONG AR92;
    ULONGLONG AR93;
    ULONGLONG AR94;
    ULONGLONG AR95;
    ULONGLONG AR96;
    ULONGLONG AR97;
    ULONGLONG AR98;
    ULONGLONG AR99;
    ULONGLONG AR100;
    ULONGLONG AR101;
    ULONGLONG AR102;
    ULONGLONG AR103;
    ULONGLONG AR104;
    ULONGLONG AR105;
    ULONGLONG AR106;
    ULONGLONG AR107;
    ULONGLONG AR108;
    ULONGLONG AR109;
    ULONGLONG AR110;
    ULONGLONG AR111;
    ULONGLONG AR112;
    ULONGLONG AR113;
    ULONGLONG AR114;
    ULONGLONG AR115;
    ULONGLONG AR116;
    ULONGLONG AR117;
    ULONGLONG AR118;
    ULONGLONG AR119;
    ULONGLONG AR120;
    ULONGLONG AR121;
    ULONGLONG AR122;
    ULONGLONG AR123;
    ULONGLONG AR124;
    ULONGLONG AR125;
    ULONGLONG AR126;
    ULONGLONG AR127;
} PROCESSOR_APPLICATION_REGISTERS_IA64, *PPROCESSOR_APPLICATION_REGISTERS_IA64;

typedef struct _ERROR_PROCESSOR_STATIC_INFO_IA64  {
    ERROR_PROCESSOR_STATIC_INFO_VALID_IA64 Valid;
    UCHAR      MinState[ /* SAL Specs, July 2000 and Jan 2001 state approximatively: */ 1024];
    ULONGLONG  BR      [ 8 ];
    ULONGLONG  CR      [ /* SAL Specs, July 2000 states that it is processor dependent */ 128 ];
    ULONGLONG  AR      [ /* SAL Specs, July 2000 states that it is processor dependent */ 128 ];
    ULONGLONG  RR      [ 8 ];
    ULONGLONG  FR      [ 2 * 128 ];
} ERROR_PROCESSOR_STATIC_INFO_IA64, *PERROR_PROCESSOR_STATIC_INFO_IA64;

typedef union _ERROR_PROCESSOR_ERROR_MAP_IA64 {
    ULONGLONG   ErrorMap;
    struct  {
        ULONGLONG   Cid:4;                 // bits  0- 3: Processor Core Identifier
        ULONGLONG   Tid:4;                 //       4- 7: Logical Thread Identifier
        ULONGLONG   Eic:4;                 //       8-11: Instruction Caches Level Information
        ULONGLONG   Edc:4;                 //      12-15: Data        Caches Level Information
        ULONGLONG   Eit:4;                 //      16-19: Instruction TLB    Level Information
        ULONGLONG   Edt:4;                 //      20-23: Data        TLB    Level Information
        ULONGLONG   Ebh:4;                 //      24-27: Processor   Bus    Level Information
        ULONGLONG   Erf:4;                 //      28-31: Register    File   Level Information
        ULONGLONG   Ems:16;                //      32-47: MicroArchitecture  Level Information
        ULONGLONG   Reserved:16;
    };
} ERROR_PROCESSOR_ERROR_MAP_IA64, *PERROR_PROCESSOR_ERROR_MAP_IA64;

typedef struct _ERROR_PROCESSOR_IA64 {
    ERROR_SECTION_HEADER_IA64       Header;
    ERROR_PROCESSOR_VALID_IA64      Valid;
    ULONGLONG                  ErrorMap;
    ULONGLONG                  StateParameter;
    ULONGLONG                  CRLid; 
#if 0
// The presence of the following data depends on the valid bits
// from ERROR_PROCESSOR.Valid.
//
    ERROR_MODINFO               CacheErrorInfo   [ /* Valid.CacheCheckNum   */ ]; // 0->15 cache error modinfo structs.
    ERROR_MODINFO               TlbErrorInfo     [ /* Valid.TlbCheckNum     */ ]; // 0->15 tlb   error modinfo structs.
    ERROR_MODINFO               BusErrorInfo     [ /* Valid.BusCheckNum     */ ]; // 0->15 bus   error modinfo structs.
    ERROR_MODINFO               RegFileCheckInfo [ /* Valid.RegFileCheckNum */ ]; // 0->15 registers file errors.
    ERROR_MODINFO               MsCheckInfo      [ /* Valid.MsCheckNum      */ ]; // 0->15 registers file errors.
    ERROR_PROCESSOR_CPUID_INFO  CpuIdInfo;       // field will always be there but could be zero-padded.
    ERROR_PROCESSOR_STATIC_INFO StaticInfo;      // field will always be there but could be zero-padded.
#endif // 0
} ERROR_PROCESSOR_IA64, *PERROR_PROCESSOR_IA64;

//
// IA64 ERRORS: ERROR_STATUS definitions
//

typedef union _ERROR_STATUS_IA64 {
    ULONGLONG Status;
    struct  {                 //  Bits:
        ULONGLONG Reserved0:8;  //   7-0: Reserved
        ULONGLONG Type:8;       //  15-8: Error Type - See _ERR_TYPE definitions.
        ULONGLONG Address:1;    //    16: Error was detected on address signals or on address portion of transaction
        ULONGLONG Control:1;    //    17: Error was detected on control signals or in control portion of transaction
        ULONGLONG Data:1;       //    18: Error was detected on data signals or in data portion of transaction
        ULONGLONG Responder:1;  //    19: Error was detected by responder of transaction
        ULONGLONG Requestor:1;  //    20: Error was detected by requestor of transaction
        ULONGLONG FirstError:1; //    21: If multiple errors, this is the first error of the highestseverity that occurred
        ULONGLONG Overflow:1;   //    22: Additional errors occurred which were not logged because registers overflow
        ULONGLONG Reserved1:41; // 63-23: Reserved
    };
} ERROR_STATUS_IA64, *PERROR_STATUS_IA64;

//
// IA64 ERRORS: Platform OEM_DATA definitions
//

typedef struct _ERROR_OEM_DATA_IA64 {
    USHORT Length;
#if 0
    UCHAR  Data[/* ERROR_OEM_DATA.Length */];
#endif // 0
} ERROR_OEM_DATA_IA64, *PERROR_OEM_DATA_IA64;

//
// IA64 ERRORS: Platform BUS_SPECIFIC_DATA definitions
//

typedef union _ERROR_BUS_SPECIFIC_DATA_IA64 {
    ULONGLONG BusSpecificData;
    struct {                                         // Bits :
        ULONGLONG LockAsserted:1;                    //     0: LOCK# Asserted during request phase
        ULONGLONG DeferLogged:1;                     //     1: Defer phase is logged
        ULONGLONG IOQEmpty:1;                        //     2: IOQ is empty
        ULONGLONG DeferredTransaction:1;             //     3: Component interface deferred transaction
        ULONGLONG RetriedTransaction:1;              //     4: Component interface retried transaction
        ULONGLONG MemoryClaimedTransaction:1;        //     5: memory claimed the transaction
        ULONGLONG IOClaimedTransaction:1;            //     6: IO controller claimed the transaction
        ULONGLONG ResponseParitySignal:1;            //     7: Response parity signal
        ULONGLONG DeferSignal:1;                     //     8: DEFER# signal
        ULONGLONG HitMSignal:1;                      //     9: HITM# signal
        ULONGLONG HitSignal:1;                       //    10: HIT# signal
        ULONGLONG RequestBusFirstCycle:6;            // 16-11: First cycle of request bus
        ULONGLONG RequestBusSecondCycle:6;           // 22-17: Second cycle of request bus
        ULONGLONG AddressParityBusFirstCycle:2;      // 24-23: First cycle of address parity bus
        ULONGLONG AddressParityBusSecondCycle:2;     // 26-25: Second cycle of address parity
        ULONGLONG ResponseBus:3;                     // 29-27: Response bus
        ULONGLONG RequestParitySignalFirstCycle:1;   //    30: First cycle of request parity signal
        ULONGLONG RequestParitySignalSecondCycle:1;  //    31: Second cycle of request parity signal
        ULONGLONG Reserved:32;                       // 63-32: Reserved
    };
} ERROR_BUS_SPECIFIC_DATA_IA64, *PERROR_BUS_SPECIFIC_DATA_IA64;

#define ERROR_MEMORY_GUID_IA64 \
    { 0xe429faf2, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

#define ERROR_PCI_BUS_GUID_IA64 \
    { 0xe429faf4, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

#define ERROR_PCI_COMPONENT_GUID_IA64 \
    { 0xe429faf6, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

#define ERROR_SYSTEM_EVENT_LOG_GUID_IA64 \
    { 0xe429faf3, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

#define ERROR_SMBIOS_GUID_IA64 \
    { 0xe429faf5, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

#define ERROR_PLATFORM_SPECIFIC_GUID_IA64 \
    { 0xe429faf7, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PLATFORM_SPECIFIC_VALID_IA64   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_SPECIFIC_VALID_IA64, *PERROR_PLATFORM_SPECIFIC_VALID_IA64;

typedef struct _ERROR_PLATFORM_SPECIFIC_IA64  {
     ERROR_SECTION_HEADER_IA64           Header;
     ERROR_PLATFORM_SPECIFIC_VALID_IA64  Valid;
     ERROR_STATUS_IA64                ErrorStatus; // Platform Generic Error Status
     ULONGLONG                        RequestorId; // Bus Requestor ID at the time of the event
     ULONGLONG                        ResponderId; // Bus Responder ID at the time of the event
     ULONGLONG                        TargetId;    // Bus intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA_IA64     BusSpecificData; // OEM specific Bus dependent data
     UCHAR                            OemId[16];       // OEM specific data for bus identification
     ERROR_OEM_DATA_IA64              OemData;         // OEM specific data
#if 0
     UCHAR                            OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
 } ERROR_PLATFORM_SPECIFIC_IA64, *PERROR_PLATFORM_SPECIFIC_IA64;

#define ERROR_PLATFORM_BUS_GUID_IA64 \
    { 0xe429faf9, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

#define ERROR_PLATFORM_HOST_CONTROLLER_GUID_IA64 \
    { 0xe429faf8, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\kdlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    kdlog.c

Abstract:

    WinDbg Extension Api

Author:

    Neil Sandlin (neilsa) 31-Oct-2000

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

DECLARE_API( kdlog )

/*++

Routine Description:

    This routine dumps the KdLog buffer. This is logging data created
    by the KD client code (e.g. KD1394.DLL).

Arguments:

    args - not used

Return Value:

    None

--*/

{
    ULONG64 LogContext;
    ULONG64 Index, LastIndex, Count, EntryLength, TotalLogged;
    ULONG64 LogData;
    CHAR buffer[256];
    ULONG64 LogEntry;
    ULONG bytesRead;
    
    LogContext = GetExpression("kdcom!KdLogContext");    
    
    if (LogContext == 0) {
        LogContext = GetExpression("kd1394!KdLogContext");    
        if (LogContext == 0) {
            dprintf("Error resolving address of hal!KdDebuggerLogContext\n");
            return E_INVALIDARG;
        }            
    }    
    
    if (GetFieldValue(LogContext, "_KD_DBG_LOG_CONTEXT", "Index", Index)) {
        dprintf("Error resolving field 'Index'\n");
        return E_INVALIDARG;
    }
    if (GetFieldValue(LogContext, "_KD_DBG_LOG_CONTEXT", "LastIndex", LastIndex)) {
        dprintf("Error resolving field 'LastIndex'\n");
        return E_INVALIDARG;
    }
    if (GetFieldValue(LogContext, "_KD_DBG_LOG_CONTEXT", "Count", Count)) {
        dprintf("Error resolving field 'Count'\n");
        return E_INVALIDARG;
    }
    if (GetFieldValue(LogContext, "_KD_DBG_LOG_CONTEXT", "EntryLength", EntryLength)) {
        dprintf("Error resolving field 'EntryLength'\n");
        return E_INVALIDARG;
    }
    if (GetFieldValue(LogContext, "_KD_DBG_LOG_CONTEXT", "TotalLogged", TotalLogged)) {
        dprintf("Error resolving field 'TotalLogged'\n");
        return E_INVALIDARG;
    }
    if (GetFieldValue(LogContext, "_KD_DBG_LOG_CONTEXT", "LogData", LogData)) {
        dprintf("Error resolving field 'Index'\n");
        return E_INVALIDARG;
    }

            
    dprintf("Context Ptr %.8p TotalLogged %.8p EntryLength %.8p\n", LogContext, TotalLogged, EntryLength);
    dprintf("Index %.8p LastIndex %.8p Count %.8p LogData %.8p\n\n", Index, LastIndex, Count, LogData);
    
    if (EntryLength > 256) {
        dprintf("Entry length %d too long\n", EntryLength);
        return E_INVALIDARG;
    }        

    Index = ((Index - Count) + (LastIndex+1)) % (LastIndex+1);
            
    while(Count--) {
        if (CheckControlC()) {
            return S_OK;
        }       

        LogEntry = LogData + Index*EntryLength;
        
        if (!ReadMemory(LogEntry, buffer, (ULONG)EntryLength, &bytesRead)) {
            dprintf("ReadMemory error at %.8p\n", LogEntry);
            return E_INVALIDARG;
        }                
        
        dprintf("%s", buffer);

        Index++;
        if (Index == (LastIndex+1)) {
            Index = 0;
        }
    }
            
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\ioverifier.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ioverifier.c

Abstract:

    WinDbg Extension code for accessing I/O Verifier information

Author:

    Adrian J. Oney (adriao) 11-Oct-2000

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

BOOLEAN
GetTheSystemTime (
    OUT PLARGE_INTEGER Time
    );

VOID
PrintIrpStack(
    IN ULONG64 IrpSp
    );

typedef enum {

    IOV_EVENT_NONE = 0,
    IOV_EVENT_IO_ALLOCATE_IRP,
    IOV_EVENT_IO_CALL_DRIVER,
    IOV_EVENT_IO_CALL_DRIVER_UNWIND,
    IOV_EVENT_IO_COMPLETE_REQUEST,
    IOV_EVENT_IO_COMPLETION_ROUTINE,
    IOV_EVENT_IO_COMPLETION_ROUTINE_UNWIND,
    IOV_EVENT_IO_CANCEL_IRP,
    IOV_EVENT_IO_FREE_IRP

} IOV_LOG_EVENT;

#define VI_DATABASE_HASH_SIZE   256
#define VI_DATABASE_HASH_PRIME  131

#define VI_DATABASE_CALCULATE_HASH(Irp) \
    (((((UINT_PTR) Irp)/PageSize)*VI_DATABASE_HASH_PRIME) % VI_DATABASE_HASH_SIZE)

#define IRP_ALLOC_COUNT             8
#define IRP_LOG_ENTRIES             16

#define TRACKFLAG_SURROGATE            0x00000002
#define TRACKFLAG_HAS_SURROGATE        0x00000004
#define TRACKFLAG_PROTECTEDIRP         0x00000008

#define TRACKFLAG_QUEUED_INTERNALLY    0x00000010
#define TRACKFLAG_BOGUS                0x00000020
#define TRACKFLAG_RELEASED             0x00000040
#define TRACKFLAG_SRB_MUNGED           0x00000080
#define TRACKFLAG_SWAPPED_BACK         0x00000100
#define TRACKFLAG_DIRECT_BUFFERED      0x00000200
#define TRACKFLAG_WATERMARKED          0x00100000
#define TRACKFLAG_IO_ALLOCATED         0x00200000
#define TRACKFLAG_UNWOUND_BADLY        0x00400000
#define TRACKFLAG_PASSED_AT_BAD_IRQL   0x02000000
#define TRACKFLAG_IN_TRANSIT           0x40000000

ENUM_NAME LogEntryTypes[] = {
   ENUM_NAME(IOV_EVENT_NONE),
   ENUM_NAME(IOV_EVENT_IO_ALLOCATE_IRP),
   ENUM_NAME(IOV_EVENT_IO_CALL_DRIVER),
   ENUM_NAME(IOV_EVENT_IO_CALL_DRIVER_UNWIND),
   ENUM_NAME(IOV_EVENT_IO_COMPLETE_REQUEST),
   ENUM_NAME(IOV_EVENT_IO_COMPLETION_ROUTINE),
   ENUM_NAME(IOV_EVENT_IO_COMPLETION_ROUTINE_UNWIND),
   ENUM_NAME(IOV_EVENT_IO_CANCEL_IRP),
   ENUM_NAME(IOV_EVENT_IO_FREE_IRP),
   {0,0}
};

typedef enum {

    IOV_SYMBOL_PROBLEM,
    IOV_NO_DATABASE,
    IOV_ACCESS_PROBLEM,
    IOV_WALK_TERMINATED,
    IOV_ALL_PACKETS_WALKED,
    IOV_CTRL_C

} IOV_WALK_RESULT;

typedef BOOL (*PFN_IOVERIFIER_PACKET_ENUM)(ULONG64 Packet, PVOID Context);

IOV_WALK_RESULT
IoVerifierEnumIovPackets(
    IN  ULONG64                     TargetIrp           OPTIONAL,
    IN  PFN_IOVERIFIER_PACKET_ENUM  Callback,
    IN  PVOID                       Context,
    OUT ULONG                      *PacketsScanned
    );

typedef struct {

    ULONG64     IrpToStopOn;

} DUMP_CONTEXT, *PDUMP_CONTEXT;

BOOL
IoVerifierDumpIovPacketDetailed(
    IN  ULONG64     IovPacketReal,
    IN  PVOID       Context
    );

BOOL
IoVerifierDumpIovPacketSummary(
    IN  ULONG64     IovPacketReal,
    IN  PVOID       Context
    );


DECLARE_API( iovirp )
/*++

Routine Description:

    Temporary verifier irp data dumper until this is integrated into !irp itself

Arguments:

    args - the irp to dump

Return Value:

    None

--*/
{
    ULONG64 irpToDump = 0;
    IOV_WALK_RESULT walkResult;
    DUMP_CONTEXT dumpContext;
    ULONG packetsOutstanding;

    irpToDump = GetExpression(args);

    dumpContext.IrpToStopOn = irpToDump;

    if (irpToDump == 0) {

        dprintf("!Irp      Outstanding   !DevStack !DrvObj\n");
    }

    walkResult = IoVerifierEnumIovPackets(
        irpToDump,
        irpToDump ? IoVerifierDumpIovPacketDetailed :
                    IoVerifierDumpIovPacketSummary,
        &dumpContext,
        &packetsOutstanding
        );

    switch(walkResult) {

        case IOV_SYMBOL_PROBLEM:
            dprintf("No information available - check symbols\n");
            break;

        case IOV_NO_DATABASE:
            dprintf("No information available - the verifier is probably disabled\n");
            break;

        case IOV_ACCESS_PROBLEM:
            dprintf("A problem occured reading memory\n");
            break;

        case IOV_WALK_TERMINATED:
        case IOV_ALL_PACKETS_WALKED:
        case IOV_CTRL_C:
        default:
            break;
    }

    dprintf("Packets processed: 0x%x\n", packetsOutstanding);
    return S_OK;
}

IOV_WALK_RESULT
IoVerifierEnumIovPackets(
    IN  ULONG64                     TargetIrp       OPTIONAL,
    IN  PFN_IOVERIFIER_PACKET_ENUM  Callback,
    IN  PVOID                       Context,
    OUT ULONG                      *PacketsScanned
    )
{
    ULONG64 ViIrpDatabaseReal = 0;
    PVOID   ViIrpDatabaseLocal;
    ULONG   sizeofListEntry;
    ULONG   start, end, i, hashLinkOffset;
    ULONG64 listEntryHead, listEntryNext, iovPacketReal, currentIrp;

    *PacketsScanned = 0;

    sizeofListEntry = GetTypeSize("nt!_LIST_ENTRY");

    if (sizeofListEntry == 0) {

        return IOV_SYMBOL_PROBLEM;
    }

    ViIrpDatabaseReal = GetPointerValue("nt!ViIrpDatabase");

    if (ViIrpDatabaseReal == 0) {

        return IOV_NO_DATABASE;
    }

    GetFieldOffset("nt!IOV_REQUEST_PACKET", "HashLink.Flink", &hashLinkOffset);

    if (TargetIrp != 0) {

        start = end = (ULONG ) (VI_DATABASE_CALCULATE_HASH(TargetIrp));

    } else {

        start = 0;
        end = VI_DATABASE_HASH_SIZE-1;
    }

    for(i=start; i<=end; i++) {

        listEntryHead = ViIrpDatabaseReal + (i*sizeofListEntry);

        if (GetFieldValue(listEntryHead, "nt!_LIST_ENTRY", "Flink", listEntryNext)) {

            return IOV_ACCESS_PROBLEM;
        }

        while(listEntryNext != listEntryHead) {

            (*PacketsScanned)++;

            iovPacketReal = listEntryNext - hashLinkOffset;

            if (GetFieldValue(iovPacketReal, "nt!IOV_REQUEST_PACKET", "HashLink.Flink", listEntryNext)) {

                return IOV_ACCESS_PROBLEM;
            }

            if (TargetIrp) {

                if (GetFieldValue(iovPacketReal, "nt!IOV_REQUEST_PACKET", "TrackedIrp", currentIrp)) {

                    return IOV_ACCESS_PROBLEM;
                }

                if (TargetIrp != currentIrp) {

                    continue;
                }
            }

            if (CheckControlC()) {

                return IOV_CTRL_C;
            }

            if (Callback(iovPacketReal, Context) == FALSE) {

                return IOV_WALK_TERMINATED;
            }
        }

        if (CheckControlC()) {

            return IOV_CTRL_C;
        }
    }

    return IOV_ALL_PACKETS_WALKED;
}


BOOL
IoVerifierDumpIovPacketDetailed(
    IN  ULONG64     IovPacketReal,
    IN  PVOID       Context
    )
{
    ULONG i, j;
    UCHAR symBuffer[256];
    ULONG64 displacement, logBuffer, allocatorAddress, logBufferEntry;
    ULONG logBufferOffset, sizeofLogEntry, allocatorOffset;
    PDUMP_CONTEXT dumpContext;

    dumpContext = (PDUMP_CONTEXT) Context;

    InitTypeRead(IovPacketReal, nt!IOV_REQUEST_PACKET);

    dprintf("IovPacket\t%1p\n",      IovPacketReal);
    dprintf("TrackedIrp\t%1p\n",     ReadField(TrackedIrp));
    dprintf("HeaderLock\t%x\n",      ReadField(HeaderLock));
    dprintf("LockIrql\t%x\n",        ReadField(LockIrql));
    dprintf("ReferenceCount\t%x\n",  ReadField(ReferenceCount));
    dprintf("PointerCount\t%x\n",    ReadField(PointerCount));
    dprintf("HeaderFlags\t%08x\n",   ReadField(HeaderFlags));
    dprintf("ChainHead\t%1p\n",      ReadField(ChainHead));
    dprintf("Flags\t\t%08x\n",       ReadField(Flags));
    dprintf("DepartureIrql\t%x\n",   ReadField(DepartureIrql));
    dprintf("ArrivalIrql\t%x\n",     ReadField(ArrivalIrql));
    dprintf("StackCount\t%x\n",      ReadField(StackCount));
    dprintf("QuotaCharge\t%08x\n",   ReadField(QuotaCharge));
    dprintf("QuotaProcess\t%1p\n",   ReadField(QuotaProcess));
    dprintf("RealIrpCompletionRoutine\t%1p\n", ReadField(RealIrpCompletionRoutine));
    dprintf("RealIrpControl\t\t\t%x\n",        ReadField(RealIrpControl));
    dprintf("RealIrpContext\t\t\t%1p\n",       ReadField(RealIrpContext));

    dprintf("TopStackLocation\t%x\n", ReadField(TopStackLocation));
    dprintf("PriorityBoost\t\t%x\n",  ReadField(PriorityBoost));
    dprintf("LastLocation\t\t%x\n",   ReadField(LastLocation));
    dprintf("RefTrackingCount\t%x\n", ReadField(RefTrackingCount));

    dprintf("SystemDestVA\t\t%1p\n",    ReadField(SystemDestVA));
    dprintf("VerifierSettings\t%1p\n",  ReadField(VerifierSettings));
    dprintf("pIovSessionData\t\t%1p\n", ReadField(pIovSessionData));

    GetFieldOffset("nt!IOV_REQUEST_PACKET", "AllocatorStack", &allocatorOffset);

    dprintf("Allocation Stack:\n");
    for(i=0; i<IRP_ALLOC_COUNT; i++) {

        allocatorAddress = GetPointerFromAddress(IovPacketReal + allocatorOffset + i*DBG_PTR_SIZE);

        if (allocatorAddress) {

            symBuffer[0]='!';
            GetSymbol(allocatorAddress, symBuffer, &displacement);
            dprintf("  %s+%1p  (%1p)\n",symBuffer,displacement,allocatorAddress);
        }
    }
    dprintf("\n");

    //
    // If this was compiled free, these will both come back zero.
    //
    i = (ULONG) ReadField(LogEntryTail);
    j = (ULONG) ReadField(LogEntryHead);

    if (i == j) {

        dprintf("IRP log entries: none stored\n");
    } else {

        GetFieldOffset("nt!IOV_REQUEST_PACKET", "LogEntries", &logBufferOffset);
        sizeofLogEntry = GetTypeSize("nt!IOV_LOG_ENTRY");

        logBuffer = IovPacketReal + logBufferOffset;

        while(i != j) {

            logBufferEntry = logBuffer + i*sizeofLogEntry;

            InitTypeRead(logBufferEntry, nt!IOV_LOG_ENTRY);

            dprintf("%s\t", getEnumName((ULONG) ReadField(Event), LogEntryTypes));
            dprintf("by %1p (%p) ", ReadField(Address), ReadField(Data));
            dprintf("on .thread %1p\n", ReadField(Thread));

            i = (i+1) % IRP_LOG_ENTRIES;
        }
    }

    InitTypeRead(IovPacketReal, nt!IOV_REQUEST_PACKET);

    return (dumpContext->IrpToStopOn != ReadField(TrackedIrp));
}


BOOL
IoVerifierDumpIovPacketSummary(
    IN  ULONG64     IovPacketReal,
    IN  PVOID       Context
    )
{
    ULONG64 trackedIrp, iovSessionData, currentLocation, deviceObject;
    ULONG64 topStackLocation;
    ULONG64 iovCurStackLocation, iovNextStackLocation, currentIoStackLocation;
    PDUMP_CONTEXT dumpContext;
    ULONG pvoidSize, stackDataOffset;
    LARGE_INTEGER startTime, elapsedTime;
    TIME_FIELDS parsedTime;

    dumpContext = (PDUMP_CONTEXT) Context;

    pvoidSize = IsPtr64() ? 8 : 4;

    InitTypeRead(IovPacketReal, nt!IOV_REQUEST_PACKET);

    trackedIrp = ReadField(TrackedIrp);
    if (trackedIrp == 0) {

        //
        // If there's no IRP, it means we are tracking something that has
        // completed but hasn't unwound. Therefore we ignore it.
        //
        goto PrintSummaryExit;
    }

    if (ReadField(Flags) & TRACKFLAG_HAS_SURROGATE) {

        //
        // We only want to display the surrogate in this case.
        //
        goto PrintSummaryExit;
    }

    iovSessionData = ReadField(pIovSessionData);
    if (iovSessionData == 0) {

        //
        // We only want to display live IRPs
        //
        goto PrintSummaryExit;
    }

    topStackLocation = ReadField(TopStackLocation);

    InitTypeRead(trackedIrp, nt!IRP);

    currentLocation = ReadField(CurrentLocation);
    currentIoStackLocation = ReadField(Tail.Overlay.CurrentStackLocation);

    parsedTime.Minute = 0;

    if (currentLocation >= topStackLocation) {

        deviceObject = 0;

        dprintf("%1p                          [Completed]     ", trackedIrp);

    } else {

        GetFieldOffset("nt!IOV_SESSION_DATA", "StackData", &stackDataOffset);

        iovCurStackLocation =
            iovSessionData + stackDataOffset +
            (GetTypeSize("nt!IOV_STACK_LOCATION")*currentLocation);

        InitTypeRead(iovCurStackLocation, nt!IOV_STACK_LOCATION);

        if (ReadField(InUse)) {

            iovNextStackLocation =
                iovSessionData + stackDataOffset +
                (GetTypeSize("nt!IOV_STACK_LOCATION")*(currentLocation - 1));

            InitTypeRead(iovNextStackLocation, nt!IOV_STACK_LOCATION);

            //
            // Calculate the elasped time for this slot.
            //
            if (currentLocation && ReadField(InUse)) {

                startTime.QuadPart = ReadField(PerfDispatchStart.QuadPart);

            } else {

                GetTheSystemTime(&startTime);
            }

            InitTypeRead(iovCurStackLocation, nt!IOV_STACK_LOCATION);

            elapsedTime.QuadPart =
                startTime.QuadPart - ReadField(PerfDispatchStart.QuadPart);

            RtlTimeToElapsedTimeFields( &elapsedTime, &parsedTime );

            InitTypeRead(currentIoStackLocation, nt!IO_STACK_LOCATION);

            deviceObject = ReadField(DeviceObject);

            //
            // Alright, we got the goods. Let's print what we know...
            //
            dprintf("%1p  %ld:%02ld:%02ld.%04ld  %1p ",
                trackedIrp,
                parsedTime.Hour,
                parsedTime.Minute,
                parsedTime.Second,
                parsedTime.Milliseconds,
                deviceObject
                );

        } else {

            InitTypeRead(currentIoStackLocation, nt!IO_STACK_LOCATION);

            deviceObject = ReadField(DeviceObject);

            dprintf("%08lx                %08lx ", trackedIrp, deviceObject);
        }
    }

    if (deviceObject) {
        DumpDevice(deviceObject, 20, FALSE);
    }

    dprintf("  ");
    PrintIrpStack(currentIoStackLocation);
#if 0
   if (parsedTime.Minute && (irp.CancelRoutine == NULL)) {

       //
       // This IRP has been held over a minute with no cancel routine.
       // Take a free moment to flame the driver writer.
       //
       dprintf("*") ;
       *Delayed = TRUE ; // Should *not* be set to false otherwise.
   }
#endif
   dprintf("\n") ;
#if 0
    if (DumpLevel>0) {

        IovPacketPrintDetailed(
            IovPacket,
            &irp,
            RunTime
            );
    }
#endif

PrintSummaryExit:
    return TRUE;
}

/*
#include "precomp.h"
#include "irpverif.h"
#pragma hdrstop

VOID
IovPacketPrintSummary(
    IN   PIOV_REQUEST_PACKET IovPacket,
    IN   LARGE_INTEGER *RunTime,
    IN   ULONG DumpLevel,
    OUT  PBOOLEAN Delayed,
    OUT  PLIST_ENTRY NextListEntry
    );


BOOLEAN
GetTheSystemTime (
    OUT PLARGE_INTEGER Time
    );

VOID
DumpAllTrackedIrps(
   VOID
   )
{
    int i, j ;
    ULONG result;
    LIST_ENTRY iovPacketTable[IRP_TRACKING_HASH_SIZE] ;
    PLIST_ENTRY listHead, listEntry;
    LIST_ENTRY nextListEntry;
    PIOV_REQUEST_PACKET pIovPacket;
    LARGE_INTEGER RunTime ;
    ULONG_PTR tableAddress ;
    BOOLEAN delayed = FALSE ;

    tableAddress = GetExpression( "Nt!IovpIrpTrackingTable" ) ;
    if (tableAddress == 0) {

        goto DumpNoMore;
    }

    if (!ReadMemory(tableAddress, iovPacketTable,
       sizeof(LIST_ENTRY)*IRP_TRACKING_HASH_SIZE, &result)) {

        goto DumpNoMore;
    }

    dprintf("!Irp      Outstanding   !DevStack !DrvObj\n") ;

    GetTheSystemTime(&RunTime);
    for(i=j=0; i<IRP_TRACKING_HASH_SIZE; i++) {

        listEntry = &iovPacketTable[i];
        listHead = ((PLIST_ENTRY)tableAddress)+i;

        while(listEntry->Flink != listHead) {

            j++;

            pIovPacket = CONTAINING_RECORD(
                listEntry->Flink,
                IOV_REQUEST_PACKET,
                HashLink
                );

            dprintf("[%x.%x] = %x\n", i, j, pIovPacket) ;

            listEntry = &nextListEntry;

            IovPacketPrintSummary(
                pIovPacket,
                &RunTime,
                0,
                &delayed,
                listEntry
                );

            if (IsListEmpty(listEntry)) {
                break;
            }

            if (CheckControlC()) {

                goto DumpNoMore;
            }
        }
    }

    if (!j) {

        dprintf("\nIrp tracking does not appear to be enabled. Use \"!patch "
                "IrpTrack\" in the\nchecked build to enable this feature.\n") ;
    }

    if (delayed) {

        dprintf("* PROBABLE DRIVER BUG: An IRP has been sitting in the driver for more\n"
                "                       than a minute without a cancel routine\n") ;
    }

DumpNoMore:
    return ;
}

VOID
IovPacketPrintDetailed(
    PIOV_REQUEST_PACKET IovPacket,
    PIRP IrpData,
    LARGE_INTEGER *RunTime
    )
{
   CHAR buffer[80];
   ULONG displacement;
   IOV_REQUEST_PACKET iovPacketData;
   LARGE_INTEGER *startTime, elapsedTime ;
   TIME_FIELDS Times;
   IRP_ALLOC_DATA irpAllocData ;
   ULONG result;
   int i ;

   if (!ReadMemory((ULONG_PTR) IovPacket, &iovPacketData,
       sizeof(IOV_REQUEST_PACKET), &result)) {

       return;
   }

   dprintf("  TrackingData - 0x%08lx\n", IovPacket);

   dprintf("   TrackedIrp:0x%08lx\n", iovPacketData.TrackedIrp);

   dprintf("   Flags:0x%08lx\n", iovPacketData.Flags);

   if (iovPacketData.Flags&TRACKFLAG_ACTIVE) {
       dprintf("     TRACKFLAG_ACTIVE\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_SURROGATE) {
       dprintf("     TRACKFLAG_SURROGATE\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_HAS_SURROGATE) {
       dprintf("     TRACKFLAG_HAS_SURROGATE\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_PROTECTEDIRP) {
       dprintf("     TRACKFLAG_PROTECTEDIRP\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_QUEUED_INTERNALLY) {
       dprintf("     TRACKFLAG_QUEUED_INTERNALLY\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_BOGUS) {
       dprintf("     TRACKFLAG_BOGUS\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_RELEASED) {
       dprintf("     TRACKFLAG_RELEASED\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_SRB_MUNGED) {
       dprintf("     TRACKFLAG_SRB_MUNGED\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_SWAPPED_BACK) {
       dprintf("     TRACKFLAG_SWAPPED_BACK\n") ;
   }

   if (iovPacketData.Flags&TRACKFLAG_WATERMARKED) {
       dprintf("     TRACKFLAG_WATERMARKED\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_IO_ALLOCATED) {
       dprintf("     TRACKFLAG_IO_ALLOCATED\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_IGNORE_NONCOMPLETES) {
       dprintf("     TRACKFLAG_IGNORE_NONCOMPLETES\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_PASSED_FAILURE) {
       dprintf("     TRACKFLAG_PASSED_FAILURE\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_IN_TRANSIT) {
       dprintf("     TRACKFLAG_IN_TRANSIT\n");
   }

   if (iovPacketData.Flags&TRACKFLAG_REMOVED_FROM_TABLE) {
       dprintf("     TRACKFLAG_REMOVED_FROM_TABLE\n");
   }

   dprintf("   AssertFlags:0x%08lx\n", iovPacketData.AssertFlags);

   if (iovPacketData.AssertFlags&ASSERTFLAG_TRACKIRPS) {
       dprintf("     ASSERTFLAG_TRACKIRPS\n");
   }

   if (iovPacketData.AssertFlags&ASSERTFLAG_MONITOR_ALLOCS) {
       dprintf("     ASSERTFLAG_MONITOR_ALLOCS\n");
   }

   if (iovPacketData.AssertFlags&ASSERTFLAG_POLICEIRPS) {
       dprintf("     ASSERTFLAG_POLICEIRPS\n");
   }

   if (iovPacketData.AssertFlags&ASSERTFLAG_MONITORMAJORS) {
       dprintf("     ASSERTFLAG_MONITORMAJORS\n");
   }

   if (iovPacketData.AssertFlags&ASSERTFLAG_SURROGATE) {
       dprintf("     ASSERTFLAG_SURROGATE\n");
   }

   if (iovPacketData.AssertFlags&ASSERTFLAG_SMASH_SRBS) {
       dprintf("     ASSERTFLAG_SMASH_SRBS\n");
   }

   if (iovPacketData.AssertFlags&ASSERTFLAG_CONSUME_ALWAYS) {
       dprintf("     ASSERTFLAG_CONSUME_ALWAYS\n");
   }

   if (iovPacketData.AssertFlags&ASSERTFLAG_FORCEPENDING) {
       dprintf("     ASSERTFLAG_FORCEPENDING\n");
   }

   if (iovPacketData.AssertFlags&ASSERTFLAG_COMPLETEATDPC) {
       dprintf("     ASSERTFLAG_COMPLETEATDPC\n");
   }

   if (iovPacketData.AssertFlags&ASSERTFLAG_COMPLETEATPASSIVE) {
       dprintf("     ASSERTFLAG_COMPLETEATPASSIVE\n");
   }

   if (iovPacketData.AssertFlags&ASSERTFLAG_DEFERCOMPLETION) {
       dprintf("     ASSERTFLAG_DEFERCOMPLETION\n");
   }

   if (iovPacketData.AssertFlags&ASSERTFLAG_ROTATE_STATUS) {
       dprintf("     ASSERTFLAG_ROTATE_STATUS\n");
   }

   if (iovPacketData.AssertFlags&ASSERTFLAG_SEEDSTACK) {
       dprintf("     ASSERTFLAG_SEEDSTACK\n");
   }

   dprintf("   ReferenceCount:0x%x  PointerCount:0x%x\n",
       iovPacketData.ReferenceCount,
       iovPacketData.PointerCount
       ) ;

   dprintf("   RealIrpCompletionRoutine:0x%08lx\n",
       iovPacketData.RealIrpCompletionRoutine
       ) ;

   dprintf("   RealIrpControl:0x%02lx  RealIrpContext:0x%08lx\n",
       iovPacketData.RealIrpControl,
       iovPacketData.RealIrpContext
       ) ;

   dprintf("   TopStackLocation:0x%x  LastLocation:0x%x  StackCount:0x%x\n",
       iovPacketData.TopStackLocation,
       iovPacketData.LastLocation,
       iovPacketData.StackCount
       ) ;

   dprintf("\n   RefTrackingCount:0x%x\n",
       iovPacketData.RefTrackingCount
       ) ;

   //
   // Calculate the elasped time for the entire IRP
   //
   elapsedTime.QuadPart =
      RunTime->QuadPart - IrpTrackingEntry->PerfCounterStart.QuadPart;
   RtlTimeToElapsedTimeFields ( &elapsedTime, &Times);

   dprintf("   IrpElapsedTime (hms) - %ld:%02ld:%02ld.%04ld\n",
      Times.Hour,
      Times.Minute,
      Times.Second,
      Times.Milliseconds
      );

   //
   // Preload symbols...
   //
   for(i=0; i<=IrpTrackingEntry->StackCount; i++) {
      if (StackLocationData[i].InUse) {
         GetSymbol((LPVOID)StackLocationData[i].LastDispatch, buffer, &displacement);
      }
   }

   //
   // Preload symbols...
   //
   for(i=0; i<IRP_ALLOC_COUNT; i++) {
       GetSymbol((LPVOID)iovPacketData.AllocatorStack[i], buffer, &displacement);
   }

   dprintf("\n   Stack at time of IoAllocateIrp:\n") ;
   for(i=0; i<IRP_ALLOC_COUNT; i++) {
       buffer[0] = '!';
       GetSymbol((LPVOID)iovPacketData.AllocatorStack[i], buffer, &displacement);
       dprintf("     %s", buffer) ;
       if (displacement) {
           dprintf( "+0x%x", displacement );
       }
       dprintf("\n") ;
   }

   dprintf("\n   ## InUse Head Flags    IrpSp    ElaspedTime  Dispatch\n");

   for(i=0; i<=IrpTrackingEntry->StackCount; i++) {

      //
      // Show each stack location
      //
      if (StackLocationData[i].InUse) {

         if (i&&StackLocationData[i-1].InUse) {

            startTime = &StackLocationData[i-1].PerfCounterStart ;

         } else {

            startTime = RunTime ;
         }

         elapsedTime.QuadPart =
            startTime->QuadPart - StackLocationData[i].PerfCounterStart.QuadPart;

         RtlTimeToElapsedTimeFields ( &elapsedTime, &Times);

         buffer[0] = '!';
         GetSymbol((LPVOID)StackLocationData[i].LastDispatch, buffer, &displacement);

         dprintf(
            "  %c%02lx   Y    %02lx  %08lx %08lx %ld:%02ld:%02ld.%04ld %s",
            (IrpData->CurrentLocation == i) ? '>' : ' ',
            i,
            StackLocationData[i].OriginalRequestSLD - IrpTrackingPointer->StackData,
            StackLocationData[i].Flags,
            StackLocationData[i].IrpSp,
            Times.Hour,
            Times.Minute,
            Times.Second,
            Times.Milliseconds,
            buffer
            ) ;

         if (displacement) {
            dprintf( "+0x%x", displacement );
         }

      } else {

         dprintf(
            "  %c%02lx   N        %08lx",
            (IrpData->CurrentLocation == i) ? '>' : ' ',
            i,
            StackLocationData[i].Flags
            ) ;
      }
      dprintf("\n") ;
   }
   dprintf("\n") ;
}
#endif

*/

PCHAR IrpMajorNames[] = {
    "IRP_MJ_CREATE",                          // 0x00
    "IRP_MJ_CREATE_NAMED_PIPE",               // 0x01
    "IRP_MJ_CLOSE",                           // 0x02
    "IRP_MJ_READ",                            // 0x03
    "IRP_MJ_WRITE",                           // 0x04
    "IRP_MJ_QUERY_INFORMATION",               // 0x05
    "IRP_MJ_SET_INFORMATION",                 // 0x06
    "IRP_MJ_QUERY_EA",                        // 0x07
    "IRP_MJ_SET_EA",                          // 0x08
    "IRP_MJ_FLUSH_BUFFERS",                   // 0x09
    "IRP_MJ_QUERY_VOLUME_INFORMATION",        // 0x0a
    "IRP_MJ_SET_VOLUME_INFORMATION",          // 0x0b
    "IRP_MJ_DIRECTORY_CONTROL",               // 0x0c
    "IRP_MJ_FILE_SYSTEM_CONTROL",             // 0x0d
    "IRP_MJ_DEVICE_CONTROL",                  // 0x0e
    "IRP_MJ_INTERNAL_DEVICE_CONTROL",         // 0x0f
    "IRP_MJ_SHUTDOWN",                        // 0x10
    "IRP_MJ_LOCK_CONTROL",                    // 0x11
    "IRP_MJ_CLEANUP",                         // 0x12
    "IRP_MJ_CREATE_MAILSLOT",                 // 0x13
    "IRP_MJ_QUERY_SECURITY",                  // 0x14
    "IRP_MJ_SET_SECURITY",                    // 0x15
    "IRP_MJ_POWER",                           // 0x16
    "IRP_MJ_SYSTEM_CONTROL",                  // 0x17
    "IRP_MJ_DEVICE_CHANGE",                   // 0x18
    "IRP_MJ_QUERY_QUOTA",                     // 0x19
    "IRP_MJ_SET_QUOTA",                       // 0x1a
    "IRP_MJ_PNP",                             // 0x1b
    NULL
    } ;

#define MAX_NAMED_MAJOR_IRPS   0x1b


PCHAR PnPIrpNames[] = {
    "IRP_MN_START_DEVICE",                    // 0x00
    "IRP_MN_QUERY_REMOVE_DEVICE",             // 0x01
    "IRP_MN_REMOVE_DEVICE - ",                // 0x02
    "IRP_MN_CANCEL_REMOVE_DEVICE",            // 0x03
    "IRP_MN_STOP_DEVICE",                     // 0x04
    "IRP_MN_QUERY_STOP_DEVICE",               // 0x05
    "IRP_MN_CANCEL_STOP_DEVICE",              // 0x06
    "IRP_MN_QUERY_DEVICE_RELATIONS",          // 0x07
    "IRP_MN_QUERY_INTERFACE",                 // 0x08
    "IRP_MN_QUERY_CAPABILITIES",              // 0x09
    "IRP_MN_QUERY_RESOURCES",                 // 0x0A
    "IRP_MN_QUERY_RESOURCE_REQUIREMENTS",     // 0x0B
    "IRP_MN_QUERY_DEVICE_TEXT",               // 0x0C
    "IRP_MN_FILTER_RESOURCE_REQUIREMENTS",    // 0x0D
    "INVALID_IRP_CODE",                       //
    "IRP_MN_READ_CONFIG",                     // 0x0F
    "IRP_MN_WRITE_CONFIG",                    // 0x10
    "IRP_MN_EJECT",                           // 0x11
    "IRP_MN_SET_LOCK",                        // 0x12
    "IRP_MN_QUERY_ID",                        // 0x13
    "IRP_MN_QUERY_PNP_DEVICE_STATE",          // 0x14
    "IRP_MN_QUERY_BUS_INFORMATION",           // 0x15
    "IRP_MN_DEVICE_USAGE_NOTIFICATION",       // 0x16
    "IRP_MN_SURPRISE_REMOVAL",                // 0x17
    "IRP_MN_QUERY_LEGACY_BUS_INFORMATION",    // 0x18
    NULL
    } ;

#define MAX_NAMED_PNP_IRP   0x18

PCHAR WmiIrpNames[] = {
    "IRP_MN_QUERY_ALL_DATA",                  // 0x00
    "IRP_MN_QUERY_SINGLE_INSTANCE",           // 0x01
    "IRP_MN_CHANGE_SINGLE_INSTANCE",          // 0x02
    "IRP_MN_CHANGE_SINGLE_ITEM",              // 0x03
    "IRP_MN_ENABLE_EVENTS",                   // 0x04
    "IRP_MN_DISABLE_EVENTS",                  // 0x05
    "IRP_MN_ENABLE_COLLECTION",               // 0x06
    "IRP_MN_DISABLE_COLLECTION",              // 0x07
    "IRP_MN_REGINFO",                         // 0x08
    "IRP_MN_EXECUTE_METHOD",                  // 0x09
    NULL
    } ;

#define MAX_NAMED_WMI_IRP   0x9

PCHAR PowerIrpNames[] = {
    "IRP_MN_WAIT_WAKE",                       // 0x00
    "IRP_MN_POWER_SEQUENCE",                  // 0x01
    "IRP_MN_SET_POWER",                       // 0x02
    "IRP_MN_QUERY_POWER",                     // 0x03
    NULL
    } ;

#define MAX_NAMED_POWER_IRP 0x3


VOID
PrintIrpStack(
    IN ULONG64 IrpSp
    )
{
   ULONG majorFunction, minorFunction, type;

   InitTypeRead(IrpSp, nt!IO_STACK_LOCATION);

   majorFunction = (ULONG) ReadField(MajorFunction);
   minorFunction = (ULONG) ReadField(MinorFunction);

   if ((majorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
       (minorFunction == IRP_MN_SCSI_CLASS)) {

        dprintf("IRP_MJ_SCSI") ;

   } else if (majorFunction<=MAX_NAMED_MAJOR_IRPS) {

        dprintf(IrpMajorNames[majorFunction]) ;

   } else if (majorFunction==0xFF) {

        dprintf("IRP_MJ_BOGUS") ;

   } else {

        dprintf("IRP_MJ_??") ;
   }

   switch(majorFunction) {

        case IRP_MJ_SYSTEM_CONTROL:
            dprintf(".") ;
            if (minorFunction<=MAX_NAMED_WMI_IRP) {

                dprintf(WmiIrpNames[minorFunction]) ;
            } else if (minorFunction==0xFF) {

                dprintf("IRP_MN_BOGUS") ;
            } else {
                dprintf("(??)") ;
            }
            break ;
        case IRP_MJ_PNP:
            dprintf(".") ;
            if (minorFunction<=MAX_NAMED_PNP_IRP) {

                dprintf(PnPIrpNames[minorFunction]) ;
            } else if (minorFunction==0xFF) {

                dprintf("IRP_MN_BOGUS") ;
            } else {

                dprintf("(??)") ;
            }
            switch(minorFunction) {
                case IRP_MN_QUERY_DEVICE_RELATIONS:

                    type = (ULONG) ReadField(Parameters.QueryDeviceRelations.Type);
                    switch(type) {
                        case BusRelations:
                            dprintf("(BusRelations)") ;
                            break ;
                        case EjectionRelations:
                            dprintf("(EjectionRelations)") ;
                            break ;
                        case PowerRelations:
                            dprintf("(PowerRelations)") ;
                            break ;
                        case RemovalRelations:
                            dprintf("(RemovalRelations)") ;
                            break ;
                        case TargetDeviceRelation:
                            dprintf("(TargetDeviceRelation)") ;
                            break ;
                        default:
                            dprintf("(??)") ;
                            break ;
                    }
                    break ;
                case IRP_MN_QUERY_INTERFACE:
                    break ;
                case IRP_MN_QUERY_DEVICE_TEXT:
                    type = (ULONG) ReadField(Parameters.QueryId.Type);

                    switch(type) {
                        case DeviceTextDescription:
                            dprintf("(DeviceTextDescription)") ;
                            break ;
                        case DeviceTextLocationInformation:
                            dprintf("(DeviceTextLocationInformation)") ;
                            break ;
                        default:
                            dprintf("(??)") ;
                            break ;
                    }
                    break ;
                case IRP_MN_WRITE_CONFIG:
                case IRP_MN_READ_CONFIG:
                    dprintf("(WhichSpace=%x, Buffer=%x, Offset=%x, Length=%x)",
                        ReadField(Parameters.ReadWriteConfig.WhichSpace),
                        ReadField(Parameters.ReadWriteConfig.Buffer),
                        ReadField(Parameters.ReadWriteConfig.Offset),
                        ReadField(Parameters.ReadWriteConfig.Length)
                        );
                    break;
                case IRP_MN_SET_LOCK:
                    if (ReadField(Parameters.SetLock.Lock)) dprintf("(True)") ;
                    else dprintf("(False)") ;
                    break ;
                case IRP_MN_QUERY_ID:
                    type = (ULONG) ReadField(Parameters.QueryId.IdType);
                    switch(type) {
                        case BusQueryDeviceID:
                            dprintf("(BusQueryDeviceID)") ;
                            break ;
                        case BusQueryHardwareIDs:
                            dprintf("(BusQueryHardwareIDs)") ;
                            break ;
                        case BusQueryCompatibleIDs:
                            dprintf("(BusQueryCompatibleIDs)") ;
                            break ;
                        case BusQueryInstanceID:
                            dprintf("(BusQueryInstanceID)") ;
                            break ;
                        default:
                            dprintf("(??)") ;
                            break ;
                    }
                    break ;
                case IRP_MN_QUERY_BUS_INFORMATION:
                    // BUGBUG: Should print out
                    break ;
                case IRP_MN_DEVICE_USAGE_NOTIFICATION:
                    type = (ULONG) ReadField(Parameters.UsageNotification.Type);
                    switch(type) {
                        case DeviceUsageTypeUndefined:
                            dprintf("(DeviceUsageTypeUndefined") ;
                            break ;
                        case DeviceUsageTypePaging:
                            dprintf("(DeviceUsageTypePaging") ;
                            break ;
                        case DeviceUsageTypeHibernation:
                            dprintf("(DeviceUsageTypeHibernation") ;
                            break ;
                        case DeviceUsageTypeDumpFile:
                            dprintf("(DeviceUsageTypeDumpFile") ;
                            break ;
                        default:
                            dprintf("(??)") ;
                            break ;
                    }
                    if (ReadField(Parameters.UsageNotification.InPath)) {
                        dprintf(", InPath=TRUE)") ;
                    } else {
                        dprintf(", InPath=FALSE)") ;
                    }
                    break ;
                case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
                    // BUGBUG: Should print out
                    break ;
                default:
                    break ;
            }
            break ;

        case IRP_MJ_POWER:
            dprintf(".") ;
            if (minorFunction<=MAX_NAMED_POWER_IRP) {

                dprintf(PowerIrpNames[minorFunction]) ;
            } else if (minorFunction==0xFF) {

                dprintf("IRP_MN_BOGUS") ;
            } else {
                dprintf("(??)") ;
            }
            break ;

        default:
            break ;
    }
}

BOOLEAN
GetTheSystemTime (
    OUT PLARGE_INTEGER Time
    )
{
    BYTE               readTime[20]={0};
    PCHAR              SysTime;

    ZeroMemory( Time, sizeof(*Time) );

    SysTime = "SystemTime";

    if (GetFieldValue(MM_SHARED_USER_DATA_VA, "nt!_KUSER_SHARED_DATA", SysTime, readTime)) {
        dprintf( "unable to read memory @ %lx or _KUSER_SHARED_DATA not found\n",
                 MM_SHARED_USER_DATA_VA);
        return FALSE;
    }

    *Time = *(LARGE_INTEGER UNALIGNED *)&readTime[0];

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\isapnp.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    isapnp.c

Abstract:

    WinDbg Extension Api for ISAPNP

Author:

    Robert Nelson 4/99

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#define FLAG_NAME(flag)           {flag, #flag}

FLAG_NAME IsapnpExtensionFlags[] = {
    FLAG_NAME(DF_DELETED),                                  // 00000001
    FLAG_NAME(DF_REMOVED),                                  // 00000002
    FLAG_NAME(DF_NOT_FUNCTIONING),                          // 00000004
    FLAG_NAME(DF_ENUMERATED),                               // 00000008
    FLAG_NAME(DF_ACTIVATED),                                // 00000010
    FLAG_NAME(DF_QUERY_STOPPED),                            // 00000020
    FLAG_NAME(DF_SURPRISE_REMOVED),                         // 00000040
    FLAG_NAME(DF_PROCESSING_RDP),                           // 00000080
    FLAG_NAME(DF_STOPPED),                                  // 00000100
    FLAG_NAME(DF_RESTARTED_MOVED),                          // 00000200
    FLAG_NAME(DF_RESTARTED_NOMOVE),                         // 00000400
    FLAG_NAME(DF_REQ_TRIMMED),                              // 00000800
    FLAG_NAME(DF_READ_DATA_PORT),                           // 40000000
    FLAG_NAME(DF_BUS),                                      // 80000000
    {0,0}
};

PUCHAR DevExtIsapnpSystemPowerState[] = {
    "Unspecified",
    "Working",
    "Sleeping1",
    "Sleeping2",
    "Sleeping3",
    "Hibernate",
    "Shutdown"
};

PUCHAR DevExtIsapnpDevicePowerState[] = {
    "Unspecified",
    "D0",
    "D1",
    "D2",
    "D3"
};

PUCHAR IsapnpStates[] = {
    "Unknown",
    "WaitForKey",
    "Sleep",
    "Isolation",
    "Config"
};

extern
VOID
DevExtIsapnp(
    ULONG64 Extension
    );

BOOL
DumpIsaBusInfo(
    ULONG               Depth,
    ULONG64             BusInformation,
    BOOL                Verbose,
    BOOL                DumpCards,
    BOOL                DumpDevices
    );

BOOL
DumpIsaCardInfo(
    ULONG               Depth,
    ULONG64             CardInformation,
    BOOL                Verbose,
    BOOL                DumpCards,
    BOOL                DumpDevices
    );

BOOL
DumpIsaDeviceInfo(
    ULONG               Depth,
    ULONG64             DeviceInformation,
    BOOL                Verbose,
    BOOL                DumpDevices
    );

VOID
DevExtIsapnp(
    ULONG64 Extension
    )
/*++
Routine Description:

    Dump an ISAPNP Device extension.

Arguments:

    Extension   Address of the extension to be dumped.

Return Value:

    None.

--*/

{
    ULONG   flags, result;

    if (!ReadMemory(Extension, &flags, sizeof(flags), &result) ) {
        dprintf("Could not read Device Extension flags at 0x%08p\n", Extension);
        return;
    }

    if (flags & DF_BUS) {

        DumpIsaBusInfo( 0, Extension, TRUE, FALSE, FALSE );

    } else {

        DumpIsaDeviceInfo( 0, Extension, TRUE, FALSE );
    }
}

DECLARE_API( isainfo )

/*++

Routine Description:

    Dumps a CARD_INFORMATION structure.

Arguments:
    args     Address of the CARD_INFORMATION structure

Return Value:
    None.

--*/
{
    ULONG64             cardInfo = 0;
    ULONG64             addr, entry;
    BOOL                continueDump = TRUE;
    ULONG               flags = 0;

    if (GetExpressionEx(args, &cardInfo, &args)) {
        flags = (ULONG) GetExpression(args);
    }

    if (cardInfo == 0) {

        addr = GetExpression("isapnp!PipBusExtension");

        if (addr == 0) {
            dprintf("Error retrieving address of PipBusExtension\n");
            return E_INVALIDARG;
        }

        if (!ReadPointer(addr, &entry) ) {
            dprintf("Could not read PipBusExtension at 0x%08p\n", addr);
            return E_INVALIDARG;
        }

        while (continueDump && entry != 0) {

            if (CheckControlC()) {
                continueDump = FALSE;
                break;
            }

            if (InitTypeRead(entry, isapnp!_BUS_EXTENSION_LIST) ) {
                dprintf("Could not read isapnp!_BUS_EXTENSION_LIST at 0x%08p\n", entry);
                return E_INVALIDARG;
            }
            entry = ReadField(Next);

            continueDump = DumpIsaBusInfo( 0,
                                           ReadField(BusExtension),
                                           flags & 1,
                                           TRUE,
                                           TRUE);

        }

    } else {
        DumpIsaCardInfo(0, cardInfo, TRUE, FALSE, FALSE);
    }

    return S_OK;
} // isainfo

BOOL
DumpIsaBusInfo(
    ULONG               Depth,
    ULONG64             BusInformation,
    BOOL                Verbose,
    BOOL                DumpCards,
    BOOL                DumpDevices
    )
{
    ULONG64             cardInformation;
    ULONG64             addr;
    ULONG64             PipRDPNode;
    ULONG               Off;
    ULONG               state;
    BOOL                continueDump = TRUE;
    ULONG64             CardNext;


    //
    // device extension for ISAPNP FDO
    //

    if (CheckControlC()) {
        return FALSE;
    }

    if (InitTypeRead(BusInformation, isapnp!_PI_BUS_EXTENSION)) {
        dprintf("Could not read Card Information at 0x%08p\n", BusInformation);
        return FALSE;
    }

    xdprintf(Depth,"");
    dprintf(
        "ISA PnP FDO @ 0x%08p, DevExt @ 0x%08p, Bus # %d\n",
        ReadField(FunctionalBusDevice),
        BusInformation,
        (ULONG) ReadField(BusNumber));

    DumpFlags( Depth, "Flags", (ULONG) ReadField(Flags), IsapnpExtensionFlags);
    dprintf("\n");

    if (Verbose) {

        addr = GetExpression("isapnp!PipState");
        if (addr != 0) {
            if (state = GetUlongFromAddress(addr)) {// , "PNPISA_STATE", NULL, state)) {
                xdprintf(
                    Depth,
                    "State                - %s\n",
                    IsapnpStates[state]);
            }
        }

        xdprintf(Depth,"");
        dprintf( "NumberCSNs           - %d\n", (ULONG) ReadField(NumberCSNs));
        xdprintf(Depth,"");
        dprintf(
            "ReadDataPort         - 0x%08p (%smapped)\n",
            ReadField(ReadDataPort),
            ReadField(DataPortMapped) ? "" : "not ");

        xdprintf(Depth,"");
        dprintf(
            "AddressPort          - 0x%08p (%smapped)\n",
            ReadField(AddressPort),
            ReadField(AddrPortMapped) ? "" : "not ");

        xdprintf(Depth,"");
        dprintf(
            "CommandPort          - 0x%08p (%smapped)\n",
            ReadField(CommandPort),
            ReadField(CmdPortMapped) ? "" : "not ");

        xdprintf(Depth,"");dprintf( "DeviceList           - 0x%08p\n", ReadField(DeviceList));
        xdprintf(Depth,"");dprintf( "CardList             - 0x%08p\n", ReadField(CardList));
        xdprintf(Depth,"");dprintf( "PhysicalBusDevice    - 0x%08p\n", ReadField(PhysicalBusDevice));
        xdprintf(Depth,"");dprintf( "AttachedDevice       - 0x%08p\n", ReadField(AttachedDevice));
        xdprintf(Depth,"");dprintf( "SystemPowerState     - %s\n",     
                                    DevExtIsapnpSystemPowerState[(ULONG) ReadField(SystemPowerState)]);
        xdprintf(Depth,"");dprintf( "DevicePowerState     - %s\n\n",   
                                    DevExtIsapnpDevicePowerState[(ULONG) ReadField(DevicePowerState)]);
    }

    CardNext = ReadField(CardList.Next);
    if (DumpDevices && ReadField(BusNumber) == 0) {

        addr = GetExpression("isapnp!PipRDPNode");

        if (addr != 0) {
            if (!ReadPointer(addr, &PipRDPNode)) {
                dprintf("Could not read PipRDPNode at 0x%08p\n", addr);
                return FALSE;
            }

            continueDump = DumpIsaDeviceInfo( Depth + 1, PipRDPNode, Verbose, DumpDevices );
        } else {
            dprintf("Error retrieving address of PipBusExtension\n");
        }
    }

    GetFieldOffset("isapnp!_CARD_INFORMATION_", "CardList", &Off);
    if (DumpCards && CardNext != 0) {

        cardInformation = CardNext - Off;

        continueDump = DumpIsaCardInfo( Depth + 1, cardInformation, Verbose, DumpCards, DumpDevices );
    }

    return continueDump;
}

BOOL
DumpIsaCardInfo(
    ULONG               Depth,
    ULONG64             CardInformation,
    BOOL                Verbose,
    BOOL                DumpCards,
    BOOL                DumpDevices
    )
{
    ULONG64             deviceInformation;
    UCHAR               idString[8], *compressedID;
    BOOL                continueDump = TRUE;
    ULONG               VenderId;
    ULONG               DevOff, CardOff;
    
    static UCHAR        HexDigits[16] = "0123456789ABCDEF";

    GetFieldOffset("isapnp!_DEVICE_INFORMATION_", "LogicalDeviceList", &DevOff);
    GetFieldOffset("isapnp!_CARD_INFORMATION_", "CardList", &CardOff);
    do {
        ULONG64 CardData, CardNext, LogNext, CardList;

        if (CheckControlC()) {
            continueDump = FALSE;
            break;
        }

        if (InitTypeRead(CardInformation, _CARD_INFORMATION_) ) {
            dprintf("Could not read Card Information at 0x%08p\n", CardInformation);
            return FALSE;
        }

        CardData = ReadField(CardData);
        xdprintf(Depth,"");
        dprintf("ISA PnP Card Information @ 0x%08p, CSN = %d, ID ", CardInformation, (ULONG) ReadField(CardSelectNumber));

        if (ReadField(CardDataLength) >= GetTypeSize("isapnp!_SERIAL_IDENTIFIER_")) {
            ULONG SerialNumber;

            if (GetFieldValue(CardData, "_SERIAL_IDENTIFIER_", "VenderId", VenderId) ) {
                dprintf("\nCould not read CardData at 0x%08p\n", CardData);
                return FALSE;
            }

            compressedID = (PUCHAR)&VenderId;

            idString[0] = (compressedID[0] >> 2) + 0x40;
            idString[1] = (((compressedID[0] & 0x03) << 3) | (compressedID[1] >> 5)) + 0x40;
            idString[2] = (compressedID[1] & 0x1f) + 0x40;
            idString[3] = HexDigits[compressedID[2] >> 4];
            idString[4] = HexDigits[compressedID[2] & 0x0F];
            idString[5] = HexDigits[compressedID[3] >> 4];
            idString[6] = HexDigits[compressedID[3] & 0x0F];
            idString[7] = 0x00;
            

            if (GetFieldValue(CardData, "_SERIAL_IDENTIFIER_", "SerialNumber",SerialNumber)) {
                dprintf("\nCould not read CardData at 0x%08p\n", CardData);
                return FALSE;
            }
            dprintf("= %s\\%X\n\n", idString, SerialNumber);
        } else {
            dprintf("isn't present\n\n");
        }

        if (Verbose) {

            xdprintf(Depth,""); dprintf( "Next Card (CardList) - %08p\n", CardData);
            xdprintf(Depth,""); dprintf( "NumberLogicalDevices - %d\n", (ULONG) ReadField(NumberLogicalDevices));
            xdprintf(Depth,""); dprintf( "LogicalDeviceList    - 0x%08p\n", ReadField(LogicalDeviceList));
            xdprintf(Depth,""); dprintf( "CardData             - 0x%08p\n", ReadField(CardData));
            xdprintf(Depth,"CardDataLength       - %d\n", (ULONG) ReadField(CardDataLength));
            xdprintf(Depth,""); dprintf( "CardFlags            - 0x%08p\n\n", ReadField(CardFlags));
        }

        CardNext = ReadField(CardList.Next);
        LogNext = ReadField(LogicalDeviceList.Next);
        if (DumpDevices && LogNext != 0) {

            deviceInformation = LogNext - DevOff;

            continueDump = DumpIsaDeviceInfo( Depth + 1, deviceInformation, Verbose, DumpDevices );
        }

        if (CardNext != 0) {

            CardInformation = CardNext - CardOff;

        } else {

            break;
        }

    } while (DumpCards);

    return continueDump;
}

BOOL
DumpIsaDeviceInfo(
    ULONG    Depth,
    ULONG64  DeviceInformation,
    BOOL     Verbose,
    BOOL     DumpDevices
    )
{
    //
    // device extension for ISAPNP PDO
    //
    BOOL continueDump = TRUE;
    ULONG DevOff;
    ULONG64 Next;
    GetFieldOffset("isapnp!_DEVICE_INFORMATION_", "LogicalDeviceList", &DevOff);
    
    do {

        if (CheckControlC()) {
            continueDump = FALSE;
            break;
        }

        if (Next = InitTypeRead(DeviceInformation, _DEVICE_INFORMATION_)) {
            dprintf("Could not read Device Information at 0x%08p - %I64x\n", DeviceInformation, Next);
            return FALSE;
        }

        xdprintf(Depth,""); dprintf(
            "ISA PnP PDO @ 0x%08P, DevExt @ 0x%08P\n",
            ReadField(PhysicalDeviceObject),
            DeviceInformation);

        DumpFlags( Depth, "Flags", (ULONG) ReadField(Flags), IsapnpExtensionFlags);
        dprintf("\n");

        if (Verbose) {

            //xdprintf(Depth,""); dprintf( "SystemPowerState     - %s\n", DevExtIsapnpSystemPowerState[(ULONG) ReadField(SystemPowerState]));
            xdprintf(Depth,""); dprintf( "DevicePowerState     - %s\n",       DevExtIsapnpDevicePowerState[(ULONG) ReadField(DevicePowerState)]);
            xdprintf(Depth,""); dprintf( "ParentDevExt         - 0x%08P\n",   ReadField(ParentDeviceExtension));
            xdprintf(Depth,""); dprintf( "DeviceList           - 0x%08P\n",   ReadField(DeviceList));
            xdprintf(Depth,""); dprintf( "EnumerationMutex     - %sLocked\n", ReadField(EnumerationMutex.Header.SignalState) ? "Not " : "");
            xdprintf(Depth,""); dprintf( "ResourceRequirements - 0x%08P\n",   ReadField(ResourceRequirements));
            xdprintf(Depth,""); dprintf( "CardInformation      - 0x%08P\n",   ReadField(CardInformation));
            xdprintf(Depth,""); dprintf( "LogicalDeviceList    - 0x%08P\n",   ReadField(LogicalDeviceList));
            xdprintf(Depth,""); dprintf( "LogicalDeviceNumber  - %d\n",       (ULONG) ReadField(LogicalDeviceNumber));
            xdprintf(Depth,""); dprintf( "DeviceData           - 0x%08P\n",   ReadField(DeviceData));
            xdprintf(Depth,""); dprintf( "DeviceDataLength     - 0x%08P\n",   ReadField(DeviceDataLength));
            xdprintf(Depth,""); dprintf( "BootResourceList     - 0x%08P\n",   ReadField(BootResources));
            xdprintf(Depth,""); dprintf( "BootResourceLength   - 0x%08P\n",   ReadField(BootResourcesLength));
            xdprintf(Depth,""); dprintf( "AllocatedResList     - 0x%08P\n",   ReadField(AllocatedResources));
            xdprintf(Depth,""); dprintf( "LogConfHandle        - 0x%08P\n",   ReadField(LogConfHandle));
            xdprintf(Depth,""); dprintf( "Paging/Crash Path    - %d/%d\n\n",  (ULONG) ReadField(Paging),
                                         (ULONG) ReadField(CrashDump));
        }

        Next =  ReadField(LogicalDeviceList.Next);
        if (Next != 0) {

            DeviceInformation = Next - DevOff;

        } else {
            break;
        }

    } while (DumpDevices);

    return continueDump;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\lists.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Lists.c

Abstract:

    WinDbg Extension Api

Author:

    Gary Kimura [GaryKi]    25-Mar-96

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define ReadAtAddress(A,V,S,R)                                   \
    (ReadMemory( (A), &(V), (S), &R ) && (R >= (S)))

#define BIG_READ    (sizeof(ULONG) * 4)
#define SMALL_READ  (sizeof(ULONG) * 2)

VOID
DumpListByLinks (
    IN ULONG64 StartAddress,
    IN ULONG MaxCount,
    IN ULONG Bias,
    IN LOGICAL UseFlink
    )

/*++

Routine Description:

    Dump a list by its blinks.

Arguments:

    arg - [Address] [count] [bias]

Return Value:

    None

--*/

{
    ULONG64 Address;
    ULONG Buffer[4];
    ULONG ReadSize;
    ULONG BytesRead;
    ULONG Count;

    //
    //  set our starting address and then while the count is greater than zero
    //  and the starting address is not equal to the current dumping address
    //  we'll read in 4 ulongs, dump them, and then go through the flink&blink
    //  using the specified bias.
    //

    if (!IsPtr64()) {
        StartAddress = (ULONG64) (LONG64) (LONG) StartAddress;
    }
    Address = StartAddress;

    ReadSize = BIG_READ;

    for (Count = 0; Count < MaxCount; ) {

        if (ReadAtAddress( Address, Buffer, ReadSize, BytesRead ) == 0) {
            ReadSize = SMALL_READ;
            if (ReadAtAddress( Address, Buffer, ReadSize, BytesRead ) == 0) {
                dprintf("Can't Read Memory at %08lx\n", Address);
                break;
            }
        }

        if (ReadSize == BIG_READ) {
            dprintf("%08p  %08lx %08lx %08lx %08lx\n", Address, Buffer[0], Buffer[1], Buffer[2], Buffer[3]);
        }
        else {
            dprintf("%08p  %08lx %08lx\n", Address, Buffer[0], Buffer[1]);
        }

        Count += 1;

        //
        //  the bias tells us which bits to knock out of the pointer
        //

        if (UseFlink == TRUE) {
            GetFieldValue(Address, "LIST_ENTRY", "Flink", Address);
            Address &= ~((ULONG64)Bias);
        }
        else {
            GetFieldValue(Address, "LIST_ENTRY", "Blink", Address);
            Address &= ~((ULONG64)Bias);
        }

        if (Address == StartAddress) {
            break;
        }

        if (((Count & 0xf) == 0) && CheckControlC() ) {
            break;
        }
    }

    if (Count != 0) {
        dprintf("0x%x entries dumped\n", Count);
    }

    return;
}


DECLARE_API( dflink )

/*++

Routine Description:

    Dump a list by its flinks.

Arguments:

    arg - [Address] [count] [bias]

Return Value:

    None

--*/

{
    ULONG64 StartAddress;
    ULONG Count;
    ULONG Bias;

    StartAddress = 0;
    Count = 0x20;
    Bias = 0;

    //
    //  read in the parameters
    //

    if (GetExpressionEx(args,&StartAddress, &args)) {
        if (!sscanf(args, "%lx %lx", &Count, &Bias)) {
            Bias = 0;
        }
    }

    DumpListByLinks (StartAddress, Count, Bias, TRUE);

    return S_OK;
}


DECLARE_API( dblink )

/*++

Routine Description:

    Dump a list by its blinks.

Arguments:

    arg - [Address] [count] [bias]

Return Value:

    None

--*/

{
    ULONG64 StartAddress;
    ULONG Count;
    ULONG Bias;

    StartAddress = 0;
    Count = 0x20;
    Bias = 0;

    //
    //  read in the parameters
    //

    if (GetExpressionEx(args,&StartAddress, &args)) {
        if (!sscanf(args, "%lx %lx", &Count, &Bias)) {
            Bias = 0;
        }
    }

    DumpListByLinks (StartAddress, Count, Bias, FALSE);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\locks.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    locks.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

DECLARE_API( locks )

/*++

Routine Description:

    Dump kernel mode resource locks

Arguments:

    arg - [-V] [-P] [Address]

Return Value:

    None

--*/

{
    UCHAR       Buffer[256];
    LONG        ActiveCount;
    ULONG       ContentionCount;
    ULONG64     Displacement;
    BOOLEAN     DisplayZero;
    ULONG64     End;
    USHORT      Flag;
    ULONG       Index;
    USHORT      NumberOfExclusiveWaiters;
    USHORT      NumberOfSharedWaiters;
    BOOLEAN     Performance;
    ULONG64     PerformanceData;
    ULONG       TableSize;
    ULONG64     ResourceHead;
    ULONG64     Next;
    ULONG       Result;
    ULONG64     ResourceToDump;
    ULONG64     Resource;
    ULONG64     DdkResource;
    ULONG       i;
    ULONG       j;
    ULONG64     Thread;
    LONG        ThreadCount;
    UCHAR       DdkThreadCount;
    BOOLEAN     Verbose;
    PUCHAR      s;
    ULONG       TotalLocks;
    ULONG       TotalUsedLocks;
    ULONG       SkippedLocks;
    ULONG       SizeOfListEntry, SizeofOwnerEntry;
    ULONG       InitialOwnerThreadsOffset, OwnerThreadsOffset; 
    ULONG       dwProcessor=0;
    HRESULT     hr = S_OK;

    INIT_API();
    GetCurrentProcessor(Client, &dwProcessor, NULL);
    ResourceToDump = 0;

    DisplayZero = FALSE;
    Performance = FALSE;
    Verbose = FALSE;
    s       = (PSTR)args;
    while ( s != NULL && *s ) {
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch (*s) {
                    case 'D':
                    case 'd':
                        DisplayZero = TRUE;
                        break;

                    case 'P':
                    case 'p':
                        Performance = TRUE;
                        break;

                    case 'V':
                    case 'v':
                        Verbose = TRUE;
                        break;

                    case ' ':
                        goto gotBlank;

                    default:
                        dprintf( "KD: !locks invalid option flag '-%c'\n", *s );
                        break;
                }
            }
        } else if (*s != ' ') {
            ResourceToDump = GetExpression(s);
            s = strpbrk( s, " " );
        } else {
gotBlank:
            s++;
        }
    }

    //
    // Dump performance data if requested.
    //

    if (Performance != FALSE) {
        UCHAR ResPerf[]="nt!_RESOURCE_PERFORMANCE_DATA";
        ULONG TotalResourceCount, ActiveResourceCount, ExclusiveAcquire;
        ULONG SharedFirstLevel, SharedSecondLevel, StarveFirstLevel, StarveSecondLevel;
        ULONG WaitForExclusive, OwnerTableExpands, MaximumTableExpand;
        ULONG HashTableOffset;


        dprintf("**** Dump Resource Performance Data ****\n\n");
        PerformanceData = GetExpression("nt!ExpResourcePerformanceData");
        if ((PerformanceData == 0) ||
            GetFieldValue(PerformanceData, ResPerf,"TotalResourceCount",TotalResourceCount)) {

            //
            // The target build does not support resource performance data.
            //

            dprintf("%08p: No resource performance data available\n", PerformanceData);

        } else {
            
            GetFieldOffset(ResPerf, "HashTable", &HashTableOffset);
            
            GetFieldValue(PerformanceData, ResPerf, "ActiveResourceCount", ActiveResourceCount);
            GetFieldValue(PerformanceData, ResPerf,"ExclusiveAcquire", ExclusiveAcquire);
            GetFieldValue(PerformanceData, ResPerf, "SharedFirstLevel", SharedFirstLevel);
            GetFieldValue(PerformanceData, ResPerf,"SharedSecondLevel", SharedSecondLevel);
            GetFieldValue(PerformanceData, ResPerf, "StarveFirstLevel", StarveFirstLevel);
            GetFieldValue(PerformanceData, ResPerf, "StarveSecondLevel", StarveSecondLevel);
            GetFieldValue(PerformanceData, ResPerf, "WaitForExclusive", WaitForExclusive);
            GetFieldValue(PerformanceData, ResPerf, "OwnerTableExpands", OwnerTableExpands);
            GetFieldValue(PerformanceData, ResPerf, "MaximumTableExpand", MaximumTableExpand);

            //
            // Output the summary statistics.
            //

            dprintf("Total resources initialized   : %u\n",
                    TotalResourceCount);

            dprintf("Currently active resources    : %u\n",
                    ActiveResourceCount);

            dprintf("Exclusive resource acquires   : %u\n",
                    ExclusiveAcquire);

            dprintf("Shared resource acquires (fl) : %u\n",
                    SharedFirstLevel);

            dprintf("Shared resource acquires (sl) : %u\n",
                    SharedSecondLevel);

            dprintf("Starve resource acquires (fl) : %u\n",
                    StarveFirstLevel);

            dprintf("Starve resource acquires (sl) : %u\n",
                    StarveSecondLevel);

            dprintf("Shared wait resource acquires : %u\n",
                    WaitForExclusive);

            dprintf("Owner table expansions        : %u\n",
                    OwnerTableExpands);

            dprintf("Maximum table expansion       : %u\n\n",
                    MaximumTableExpand);

            //
            // Dump the inactive resource statistics.
            //

            dprintf("       Inactive Resource Statistics\n");
            dprintf("Contention  Number  Initialization Address\n\n");
            SizeOfListEntry = GetTypeSize("nt!_LIST_ENTRY");

            for (Index = 0; Index < RESOURCE_HASH_TABLE_SIZE; Index += 1) {
                End =  HashTableOffset + PerformanceData +  SizeOfListEntry * Index;

                GetFieldValue(End,"nt!_LIST_ENTRY","Flink",Next);
                while (Next != End) {
                    ULONG64 Address;
                    ULONG ContentionCount, Number;

                    if (CheckControlC()) {
                        break;
                    }
                    if (!GetFieldValue(Next,
                                      "nt!_RESOURCE_HASH_ENTRY",
                                      "Address",
                                      Address)) {

                        GetSymbol(Address, Buffer, &Displacement);

                        GetFieldValue(Next,"nt!_RESOURCE_HASH_ENTRY","Number",Number);
                        GetFieldValue(Next,"nt!_RESOURCE_HASH_ENTRY","ContentionCount",ContentionCount);
                        
                        dprintf("%10d  %6d  %s",
                                ContentionCount,
                                Number,
                                Buffer);

                        if (Displacement != 0) {
                            dprintf("+0x%x", Displacement);
                        }

                        dprintf("\n");
                    }

                    GetFieldValue(Next,"nt!_RESOURCE_HASH_ENTRY","ListEntry.Flink", Next);
                }
            }

            //
            // Dump the active resource statistics.
            //

            dprintf("\n        Active Resource Statistics\n");
            dprintf("Resource Contention  Initialization Address\n\n");

            //
            // Read the resource listhead and check if it is empty.
            //

            ResourceHead = GetNtDebuggerData( ExpSystemResourcesList );
            if ((ResourceHead == 0) ||
                (!GetFieldValue(ResourceHead,
                               "nt!_LIST_ENTRY",
                               "Flink",
                               Next) == FALSE)) {

                dprintf("%08p: Unable to get value of ExpSystemResourcesList\n", ResourceHead );
                hr = E_INVALIDARG;
                goto exitBangLocks;
            }

            if (Next == 0) {
                dprintf("ExpSystemResourcesList is NULL!\n");
                hr = E_INVALIDARG;
                goto exitBangLocks;
            }

            //
            // Scan the resource list and dump the resource information.
            //

            while(Next != ResourceHead) {
                ULONG64 Address;

                if (CheckControlC()) {
                    break;
                }
                Resource = Next; // SystemResourcesList is the first element in struct
                    // CONTAINING_RECORD(Next, ERESOURCE, SystemResourcesList);
                if (!GetFieldValue(Resource,
                                  "nt!_ERESOURCE",
                                  "ContentionCount",
                                  ContentionCount) == FALSE) {

                    dprintf("%08p: Unable to read _ERESOURCE\n", Resource);
                    continue;

                } else {
                    GetFieldValue(Resource,"nt!_ERESOURCE","Address",Address);
                    GetFieldValue(Resource,"nt!_ERESOURCE","ContentionCount",ContentionCount);

                    if ((ContentionCount != 0) ||
                        (DisplayZero != FALSE)) {
                        GetSymbol(Address,
                                  Buffer,
                                  &Displacement);

                        dprintf("%08p %10d  %s",
                                Resource,
                                ContentionCount,
                                Buffer);

                        if (Displacement != 0) {
                            dprintf("+0x%x", Displacement);
                        }

                        dprintf("\n");
                    }
                }

                GetFieldValue(Resource,"nt!_ERESOURCE","SystemResourcesList.Flink",Next);
            }

            dprintf("\n");

            //
            // Dump the active fast mutex statistics.
            //

            dprintf("\n        Active Fast Mutex Statistics\n");
            dprintf("Address  Contention  Fast Mutex Name\n\n");

            //
            // Dump statistics for static fast mutexes.
            //

            DumpStaticFastMutex("CmpKcbLock");
            DumpStaticFastMutex("FsRtlCreateLockInfo");
            DumpStaticFastMutex("MmPageFileCreationLock");
            DumpStaticFastMutex("MmSectionCommitMutex");
            DumpStaticFastMutex("MmSectionBasedMutex");
            DumpStaticFastMutex("ObpRootDirectoryMutex");
            DumpStaticFastMutex("PspActiveProcessMutex");
            DumpStaticFastMutex("PspProcessLockMutex");
            DumpStaticFastMutex("PspProcessSecurityLock");
            DumpStaticFastMutex("SepLsaQueueLock");
            dprintf("\n");
        }

        hr = E_INVALIDARG;
        goto exitBangLocks;
    }

    //
    // Dump remaining lock data.
    //

    if (ResourceToDump == 0) {
        dprintf("**** DUMP OF ALL RESOURCE OBJECTS ****\n");
        ResourceHead = GetNtDebuggerData( ExpSystemResourcesList );
        if ( !ResourceHead ||
             (GetFieldValue(ResourceHead,
                            "nt!_LIST_ENTRY",
                            "Flink",
                            Next) != FALSE)) {
            dprintf("%08p: Unable to get value of ExpSystemResourcesList\n", ResourceHead );
            hr = E_INVALIDARG;
            goto exitBangLocks;
        }

        if (Next == 0) {
            dprintf("ExpSystemResourcesList is NULL!\n");
            hr = E_INVALIDARG;
            goto exitBangLocks;
        }

    } else {
        Next = 0;
        ResourceHead = 1;
    }

    TotalLocks      = 0;
    TotalUsedLocks  = 0;
    SkippedLocks    = 0;

    // Get the offset of OwnerThreads in ERESOURCE
    if (GetFieldOffset("nt!_ERESOURCE", "OwnerThreads", &OwnerThreadsOffset)) {
        dprintf("Cannot get _ERESOURCE type\n");
        hr = E_INVALIDARG;
        goto exitBangLocks;
    }

    if (!(SizeofOwnerEntry = GetTypeSize("nt!_OWNER_ENTRY"))) {
        dprintf("Cannot get nt!_OWNER_ENTRY type\n");
        hr = E_INVALIDARG;
        goto exitBangLocks;
    }

    while(Next != ResourceHead) {
        ULONG64 OwnerThreads, OwnerCounts, OwnerTable;

        if (Next != 0) {
            Resource = Next;// SystemResourcesList is the first element of struct ERESOURCE
            // CONTAINING_RECORD(Next,ERESOURCE,SystemResourcesList);

        } else {
            Resource = ResourceToDump;
        }
        /*
        if ( GetFieldValue( Resource,
                            "NTDDK_ERESOURCE",
                            "OwnerThreads",
                            OwnerThreads) ) {
            dprintf("%08lx: Unable to read NTDDK_ERESOURCE\n", Resource );
            break;
        }*/

        //
        //  Detect here if this is an NtDdk resource, and behave
        //  appropriatelty.  If the OwnerThreads is a pointer to the initial
        //  owner threads array (this must take into account that the LOCAL
        //  data structure is a copy of what's in the remote machine in a
        //  different address)
        //

//        DdkResource = (PNTDDK_ERESOURCE)&ResourceContents;
         {
            
            DdkResource = 0;
            GetFieldValue( Resource,"nt!_ERESOURCE","ActiveCount", ActiveCount);
            GetFieldValue( Resource,"nt!_ERESOURCE","ContentionCount",ContentionCount);
            GetFieldValue( Resource,"nt!_ERESOURCE","NumberOfExclusiveWaiters",NumberOfExclusiveWaiters);
            GetFieldValue( Resource,"nt!_ERESOURCE","NumberOfSharedWaiters",NumberOfSharedWaiters);
            GetFieldValue( Resource,"nt!_ERESOURCE","Flag",Flag);
            GetFieldValue( Resource,"nt!_ERESOURCE","OwnerTable",OwnerTable);
            TableSize = 0;
            if (OwnerTable != 0) {
                if (GetFieldValue(OwnerTable,
                                   "nt!_OWNER_ENTRY",
                                   "TableSize",
                                   TableSize)) {
                    dprintf("\n%08p: Unable to read TableSize for resource\n", OwnerTable);
                    break;
                }

            }
        }

        TotalLocks++;
        if ((ResourceToDump != 0) || Verbose || (ActiveCount != 0)) {
            EXPRLastDump = Resource;
            if (SkippedLocks) {
                dprintf("\n");
                SkippedLocks = 0;
            }

            dprintf("\n");
            dumpSymbolicAddress(Resource, Buffer, TRUE);
            dprintf("Resource @ %s", Buffer );
            if (ActiveCount == 0) {
                dprintf("    Available\n");

            } else if (Flag & ResourceOwnedExclusive) {
                TotalUsedLocks++;
                dprintf("    Exclusively owned\n");

            } else {
                TotalUsedLocks++;
                dprintf("    Shared %u owning threads\n", ActiveCount);
            }

            if (ContentionCount != 0) {
                dprintf("    Contention Count = %u\n", ContentionCount);
            }

            if (NumberOfSharedWaiters != 0) {
                dprintf("    NumberOfSharedWaiters = %u\n", NumberOfSharedWaiters);
            }

            if (NumberOfExclusiveWaiters != 0) {
                dprintf("    NumberOfExclusiveWaiters = %u\n", NumberOfExclusiveWaiters);
            }

            if (ActiveCount != 0) {
                ULONG ThreadType;
                j = 0;

                dprintf("     Threads: ");

                if (DdkResource == 0) {

                    GetFieldValue( Resource + OwnerThreadsOffset, "nt!_OWNER_ENTRY","OwnerThread",Thread);
                    GetFieldValue( Resource + OwnerThreadsOffset, "nt!_OWNER_ENTRY","OwnerCount",ThreadCount);
                    if (Thread != 0) {
                        j++;
                        dprintf("%08p-%02x    ", Thread, ThreadCount);

                        if (Thread & 3) {
                            dprintf("*** Unknown owner, possibly FileSystem");
                            j=4;
                        } else if (GetFieldValue(Thread, "nt!_ETHREAD", "Tcb.Header.Type", ThreadType) ||
                            (ThreadType != ThreadObject)) {
                            dprintf("*** Invalid thread");
                            j=4;
                        
                        }
                        
                        if (Verbose) {
                            dprintf("\n\n");
                            DumpThread(dwProcessor, "     ",  Thread, 0xf );
                        }
                    }

                    GetFieldValue( Resource + OwnerThreadsOffset +SizeofOwnerEntry,
                                   "nt!_OWNER_ENTRY","OwnerThread",Thread);
                    GetFieldValue( Resource + OwnerThreadsOffset +SizeofOwnerEntry,
                                   "nt!_OWNER_ENTRY","OwnerCount",ThreadCount);
                    if (Thread != 0) {
                        j++;

                        dprintf("%08p-%02x    ", Thread, ThreadCount);
                        
                        if (Thread & 3) {
                            dprintf("*** Unknown owner, possibly FileSystem");
                            j=4;
                        } else if (GetFieldValue(Thread, "nt!_ETHREAD", "Tcb.Header.Type", ThreadType) ||
                            (ThreadType != ThreadObject)) {
                            dprintf("*** Invalid thread");
                            j=4;

                        }

                        if (Verbose) {

                            dprintf("\n\n");
                            DumpThread( dwProcessor, "     ",  Thread, 0xf );

                        }
                    }
                }

                for (i = DdkResource ? 0 : 1; i < TableSize; i++) {
                    {
                        GetFieldValue( OwnerTable + SizeofOwnerEntry*i,
                                       "nt!_OWNER_ENTRY","OwnerThread",Thread);
                        GetFieldValue( OwnerTable + SizeofOwnerEntry*i,
                                       "nt!_OWNER_ENTRY","OwnerCount",ThreadCount);
                        
                    }

                    if ((Thread == 0)  &&  (ThreadCount == 0)) {
                        continue;
                    }

                    if (j == 4) {
                        j = 0;
                        dprintf("\n              ");
                    }

                    dprintf("%08p-%02x    ", Thread, ThreadCount);
                    j++;

                    if (Thread & 3) {
                        dprintf("*** Unknown owner, possibly FileSystem");
                        j=4;
                    } else if (GetFieldValue(Thread, "nt!_ETHREAD", "Tcb.Header.Type", ThreadType) ||
                        (ThreadType != ThreadObject)) {
                        dprintf("*** Invalid thread");
                        j=4;

                    }

                    //
                    //  In verbose mode also dump the thread stacks
                    //

                    if (Verbose) {
                        dprintf("\n\n");
                        DumpThread( dwProcessor, "     ", Thread, 0xf );

                    }



                    if ( CheckControlC() ) {
                        hr = E_INVALIDARG;
                        goto exitBangLocks;
                    }
                }

                if (j) {
                    dprintf("\n");
                }

            }

        } else {
            if ((SkippedLocks++ % 32) == 0) {
                if (SkippedLocks == 1) {
                    dprintf("KD: Scanning for held locks." );

                } else {
                    dprintf("." );
                }
            }
        }

        if (ResourceToDump != 0) {
            break;
        }

        GetFieldValue( Resource,"nt!_ERESOURCE","SystemResourcesList.Flink", Next);
        if ( CheckControlC() ) {
            hr = E_INVALIDARG;
            goto exitBangLocks;
        }
    }

    if (SkippedLocks) {
        dprintf("\n");
    }

    dprintf( "%u total locks", TotalLocks );
    if (TotalUsedLocks) {
        dprintf( ", %u locks currently held", TotalUsedLocks );
    }

    dprintf("\n");

exitBangLocks:

    EXIT_API();
    return hr;
}

VOID
DumpStaticFastMutex (
    IN PCHAR Name
    )

/*++

Routine Description:

    This function dumps the contention statistics for a fast mutex.

Arguments:

    Name - Supplies a pointer to the symbol name for the fast mutex.

Return Value:

    None.

--*/

{

    ULONG64 FastMutex;
    ULONG   Contention;
    ULONG Result;

    //
    // Get the address of the fast mutex, read the fast mutex contents,
    // and dump the contention data.
    //

    FastMutex = GetExpression(Name);
    if ((FastMutex != 0) && 
        (!GetFieldValue(FastMutex,
                       "nt!_FAST_MUTEX",
                       "Contention",
                       Contention))) {

        dprintf("%08p %10u  %s\n",
                FastMutex,
                Contention,
                &Name[0]);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\lpc.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    lpc.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 8-Nov-1993

Environment:

    User Mode.

Revision History:

    Adrian Marinescu (adrmarin) 20-April-1999
        Change the most of the original code.

    To activate the previous extension define OLD_LPC_EXTENSION_IS_BETTER

--*/


#include "precomp.h"
#pragma hdrstop

//
// Nuke these definitions from kxmips.h as they conflict with
// LPC_MESSAGE structure in ntlpcapi.h
//

#undef s1
#undef s2

char *LpcpMessageTypeName[] = {
    "UNUSED_MSG_TYPE",
    "LPC_REQUEST",
    "LPC_REPLY",
    "LPC_DATAGRAM",
    "LPC_LOST_REPLY",
    "LPC_PORT_CLOSED",
    "LPC_CLIENT_DIED",
    "LPC_EXCEPTION",
    "LPC_DEBUG_EVENT",
    "LPC_ERROR_EVENT",
    "LPC_CONNECTION_REQUEST"
};


typedef BOOLEAN (*ENUM_TYPE_ROUTINE)(
    IN ULONG64 pObjectHeader,
    IN PVOID   Parameter
    );

VOID
DumpPortInfo (
    ULONG64 PortObject,
    BOOLEAN DisplayRelated
    );

BOOLEAN
LpcpDumpMessage(
    IN char         *Indent,
    IN ULONG64 pMsg,
    IN ULONG DisplayMessage
    );

VOID
LpcpGetProcessImageName (
    IN ULONG64  pProcess,
    IN OUT PUCHAR ImageFileName
    );

VOID
DumpMessagesInfo ();

VOID
SearchForMessage (
    ULONG Message
    );

VOID
DumpPortDataInfo (
    ULONG64 PortObject
    );

VOID
DumpRunDownQueue (
    ULONG64 PortObject
    );

VOID
SearchThreadsForMessage (
    ULONG Message
    );

BOOLEAN
SearchThreads (
    ULONG64 Thread
    );


//
// Global variables
//

static WCHAR                    ObjectNameBuffer[ MAX_PATH ];
static ULONG64             PortObjectFound = 0;
static ULONG64             LpcPortObjectType = 0;
static ULONG64             LpcWaitablePortObjectType = 0;

static ULONG64 LastSeverPortDisplayied = 0;
static int DoPoolSearch = 0;


ULONG GetValueAt(
    ULONG64 P
    )
{
    ULONG   Result;
    ULONG   Value;

    if (!ReadMemory( P,
                     &Value,
                     sizeof(Value),
                     &Result)) {

         dprintf( " Failed to read value at 0x%lx\n", P );
         return 0;
     }

     return Value;
}


BOOLEAN GetBooleanValueAt(
    ULONG64 P
    )
{
    ULONG   Result;
    BOOLEAN Value;

    if (!ReadMemory( P,
                &Value,
                sizeof(Value),
                &Result)) {

         dprintf( " Failed to read value at 0x%lx\n", P );
         return 0;
     }

     return Value;
}


VOID
LpcHelp ()
{
    dprintf("Usage:\n\
    !lpc                     - Display this help\n\
    !lpc message [MessageId] - Display the message with a given ID and all related information\n\
                               If MessageId is not specified, dump all messages\n\
    !lpc port [PortAddress]  - Display the port information\n\
    !lpc scan PortAddress    - Search this port and any connected port\n\
    !lpc thread [ThreadAddr] - Search the thread in rundown port queues and display the port info\n\
                               If ThreadAddr is missing, display all threads marked as doing some lpc operations\n\
    !lpc PoolSearch          - Toggle ON / OFF searching the current message in the kernel pool\n\
    \n");
}


ULONG64
LookupProcessUniqueId (
    HANDLE UniqueId
    )
{
    ULONG64 ProcessHead, Process;
    ULONG64 ProcessNext;
    ULONG   Off;

    //
    //  Get the process list head
    //

    ProcessHead = GetExpression( "nt!PsActiveProcessHead" );

    if (!ProcessHead) {

        return 0;
    }

    ReadPointer(ProcessHead, &ProcessNext);

    //
    //  Walk through the list and find the process with the desired Id
    //

    GetFieldOffset("nt!EPROCESS", "ActiveProcessLinks", &Off);
    while(ProcessNext != 0 && ProcessNext != ProcessHead) {
        ULONG64 Id;

        Process = ProcessNext - Off;

        if (GetFieldValue(Process, "nt!EPROCESS", "UniqueProcessId", Id)) {
            dprintf("Cannot read EPROCESS at %p\n", Process);
        }
        if (UniqueId == (HANDLE) Id) {

            return Process;
        }

        ReadPointer(ProcessNext, &ProcessNext);

        if (CheckControlC()) {

            return 0;
        }
    }

    return 0;
}


BOOLEAN
FetchGlobalVariables()
{
    //
    //  Save the LPC object type information
    //

    LpcPortObjectType = GetPointerValue("nt!LpcPortObjectType") ;

    if (!LpcPortObjectType) {
        dprintf("Reading LpcPortObjectType failed\n");
    }

    LpcWaitablePortObjectType = GetPointerValue("nt!LpcWaitablePortObjectType") ;

    if (!LpcWaitablePortObjectType) {
        dprintf("Reading LpcWaitablePortObjectType failed\n");
    }

    return TRUE;
}


BOOLEAN
LpcWalkObjectsByType(
                 IN ULONG64              pObjectType,
                 IN ENUM_TYPE_ROUTINE    EnumRoutine,
                 IN PVOID                Parameter
                 )
{
    ULONG               Result;
    ULONG64             Head,   Next;
    ULONG64             pObjectHeader;
    BOOLEAN             WalkingBackwards;
    ULONG64             pCreatorInfo, ObjBlink;
    ULONG               TotalNumberOfObjects, Off, CreatorOff, SizeOfCreat;

    if (pObjectType == 0) {
        return FALSE;
    }

    if ( GetFieldValue( pObjectType,"nt!OBJECT_TYPE",
                       "TotalNumberOfObjects", TotalNumberOfObjects) ) {

        dprintf( "%08p: Unable to read object type\n", pObjectType );
        return FALSE;
    }


    dprintf( "Scanning %u objects\n", TotalNumberOfObjects & 0x00FFFFFF);

    GetFieldOffset("nt!OBJECT_TYPE", "TypeList", &Off);
    GetFieldOffset("nt!OBJECT_HEADER_CREATOR_INFO", "TypeList", &CreatorOff);

    SizeOfCreat = GetTypeSize("OBJECT_HEADER_CREATOR_INFO");
    Head        = pObjectType + Off;

    GetFieldValue(Head, "nt!_LIST_ENTRY", "Flink", Next);
    GetFieldValue(Head, "nt!_LIST_ENTRY", "Blink", ObjBlink);
    WalkingBackwards = FALSE;

    if ((TotalNumberOfObjects & 0x00FFFFFF) != 0 && Next == Head) {

        dprintf( "*** objects of the same type are only linked together if the %x flag is set in NtGlobalFlags\n",
                 FLG_MAINTAIN_OBJECT_TYPELIST
               );
        return TRUE;
    }

    while (Next != Head) {
        ULONG64 Flink, Blink;

        if ( GetFieldValue(Next, "nt!_LIST_ENTRY", "Flink", Flink) ||
             GetFieldValue(Next, "nt!_LIST_ENTRY", "Blink", Blink)) {

            if (WalkingBackwards) {

                dprintf( "%08p: Unable to read object type list\n", Next );
                return FALSE;
            }

            //
            //  Switch to walk in reverse direction
            //

            WalkingBackwards = TRUE ;
            Next = ObjBlink;
            dprintf( "%08lx: Switch to walking backwards\n", Next );

            continue;
        }

        pCreatorInfo = ( Next - CreatorOff );
        pObjectHeader = (pCreatorInfo + SizeOfCreat);

        if ( GetFieldValue( pObjectHeader,"nt!OBJECT_HEADER","Flags", Result) ) {

            dprintf( "%08p: Not a valid object header\n", pObjectHeader );
            return FALSE;
        }

        if (!(EnumRoutine)( pObjectHeader, Parameter )) {

            return FALSE;
        }

        if ( CheckControlC() ) {

            return FALSE;
        }

        if (WalkingBackwards) {

            Next = Blink;

        } else {

            Next = Flink;
        }
    }

    return TRUE;
}


BOOLEAN
LpcCaptureObjectName(
                 IN ULONG64          pObjectHeader,
                 IN PWSTR            Buffer,
                 IN ULONG            BufferSize
                 )
{
    ULONG    Result;
    PWSTR s1 = L"*** unable to get object name";
    ULONG64  pNameInfo;
    UNICODE_STRING64            ObjectName;

    Buffer[ 0 ] = UNICODE_NULL;

    KD_OBJECT_HEADER_TO_NAME_INFO( pObjectHeader, &pNameInfo );

    if (pNameInfo == 0) {

        return TRUE;
    }

    if ( GetFieldValue( pNameInfo, "nt!OBJECT_HEADER_NAME_INFO",
                        "Name.Length", ObjectName.Length) ) {

        wcscpy( Buffer, s1 );
        return FALSE;
    }

     GetFieldValue( pNameInfo, "nt!OBJECT_HEADER_NAME_INFO","Name.Buffer", ObjectName.Buffer);
     ObjectName.MaximumLength = ObjectName.Length;

     if (ObjectName.Length >= BufferSize ) {

         ObjectName.Length = (unsigned short)BufferSize - sizeof( UNICODE_NULL );
     }

     if (ObjectName.Length != 0) {

         if (!ReadMemory( ObjectName.Buffer,
                          Buffer,
                          ObjectName.Length,
                          &Result
                          )) {

            wcscpy( Buffer, s1 );

         } else {

             Buffer[ ObjectName.Length / sizeof( WCHAR ) ] = UNICODE_NULL;
         }
     }

     return TRUE;
}



VOID
LpcpGetProcessImageName(
    IN ULONG64    pProcess,
    IN OUT PUCHAR ImageFileName
    )
{
    ULONG           Result;
    UCHAR           local[32];
    PUCHAR          s;
    int             i;

    if (pProcess != 0) {

        if (!GetFieldValue( pProcess,"nt!EPROCESS",
                            "ImageFileName", local)) {

            i = 16;
            s = local;

            while (i--) {

                if (*s == '\0') {

                    if (i == 15) {

                        i = 0;
                    }
                    break;
                }

                if (*s < ' ' || *s >= '|') {

                    i = 0;
                    break;
                }

                s += 1;
            }

            if (i != 0) {

                strcpy( ImageFileName, local );
                return;
            }
        }
    }

    sprintf( ImageFileName, "" );
    return;
}
#define LPCP_ZONE_MESSAGE_ALLOCATED (USHORT)0x8000


BOOLEAN
LpcpDumpMessage(
    IN char    *Indent,
    IN ULONG64 pMsg,
    IN ULONG DisplayMessage
    )
{
    ULONG           Result;
    ULONG           i;
    ULONG           cb;
    ULONG           MsgData[ 8 ];
    UCHAR           ImageFileName[ 32 ];
    ULONG           MessageId0, Off, SizeOfMsg, DataLength;
    BOOLEAN         MessageMatch = FALSE;

    if ( GetFieldValue( pMsg, "LPCP_MESSAGE",
                        "Request.MessageId", MessageId0) ) {

        dprintf( "%s*** unable to read LPC message at %08p\n", Indent, pMsg );
        return MessageMatch;
    }

    if (DisplayMessage != 0) {

        if (DisplayMessage == MessageId0) {

            MessageMatch = TRUE;

        } else {

            return FALSE;
        }
    }

    GetFieldOffset("LPCP_MESSAGE", "Entry", &Off);
    SizeOfMsg = GetTypeSize("LPCP_MESSAGE");

    InitTypeRead(pMsg, LPCP_MESSAGE);

    if (MessageId0 == 0) {

        dprintf( "%s%04x %08x - %s  Id=%04x  From: %04p.%04p\n",
                 Indent,
                 (ULONG) ReadField(ZoneIndex) & ~LPCP_ZONE_MESSAGE_ALLOCATED,
                 pMsg,
                 (ULONG) ReadField(Reserved0) != 0 ? "Busy" : "Free",
                 MessageId0,
                 ReadField(Request.ClientId.UniqueProcess),
                 ReadField(Request.ClientId.UniqueThread)
               );

        return MessageMatch;
    }

    //
    //  Getting the process image affect dramaticaly the performances
    //

    //    LpcpGetProcessImageName( LookupProcessUniqueId(Msg.Request.ClientId.UniqueProcess), ImageFileName );

    dprintf( "%s%s%04lx %p - %s  Id=%08lx  From: %04p.%04p  Context=%08p",
             Indent,
             MessageId0 == DisplayMessage ? "*" : "",
             (ULONG) ReadField(ZoneIndex) & ~LPCP_ZONE_MESSAGE_ALLOCATED,
             pMsg,
             (ULONG) ReadField(Reserved0) != 0 ? "Busy" : "Free",
             MessageId0,
             ReadField(Request.ClientId.UniqueProcess),
             ReadField(Request.ClientId.UniqueThread),
             ReadField(PortContext)
           );

    if (ReadField(Entry.Flink) != pMsg + Off) {

        dprintf( "  [%p . %p]", ReadField(Entry.Blink), ReadField(Entry.Flink) );
    }

    dprintf( "\n%s           Length=%08x  Type=%08x (%s)\n",
             Indent,
             (ULONG) ReadField(Request.u1.Length),
             (ULONG) ReadField(Request.u2.ZeroInit),
             (ULONG) ReadField(Request.u2.s2.Type) > LPC_CONNECTION_REQUEST ? LpcpMessageTypeName[ 0 ]
                                                              : LpcpMessageTypeName[ (ULONG) ReadField(Request.u2.s2.Type) ]
           );

    cb = (DataLength = (ULONG) ReadField(Request.u1.s1.DataLength)) > sizeof( MsgData ) ?
            sizeof( MsgData ) :
            DataLength;

    if ( !ReadMemory( (pMsg + SizeOfMsg),
                      MsgData,
                      cb,
                      &Result) ) {

        dprintf( "%s*** unable to read LPC message data at %08x\n", Indent, pMsg + 1 );
        return MessageMatch;
    }

    dprintf( "%s           Data:", Indent );

    for (i=0; i<(DataLength / sizeof( ULONG )); i++) {

        if (i > 5) {

            break;
        }

        dprintf( " %08x", MsgData[ i ] );
    }

    dprintf( "\n" );
    return MessageMatch;
}


BOOLEAN
FindPortCallback(
    IN ULONG64  pObjectHeader,
    IN PVOID    Parameter
    )
{
    ULONG                   Result;
    WCHAR                   CapturedName[MAX_PATH];
    ULONG64                 PortObject, ConnectionPort;
    ULONG64                 Addr=0;

    if (Parameter) Addr = *((PULONG64) Parameter);

    PortObject = KD_OBJECT_HEADER_TO_OBJECT(pObjectHeader);

    if ( GetFieldValue( PortObject,
                        "nt!LPCP_PORT_OBJECT",
                        "ConnectionPort",
                        ConnectionPort) ) {

        dprintf( "%08p: Unable to read port object\n", PortObject );
    }

    InitTypeRead(PortObject, LPCP_PORT_OBJECT);
    if ((Addr == 0)||
        (Addr == PortObject) ||
        (Addr == ConnectionPort) ||
        (Addr == ReadField(ConnectedPort))
        ) {

        LpcCaptureObjectName( pObjectHeader, ObjectNameBuffer, MAX_PATH );

        dprintf( "%8lx  Port: 0x%08p Connection: 0x%08p  Communication: 0x%08p  '%ws' \n",
            (ULONG) ReadField(Flags),
            PortObject,
            ConnectionPort,
            ReadField(ConnectedPort),
            ObjectNameBuffer
            );


        DumpRunDownQueue(PortObject);
    }

    return TRUE;
}


VOID
DumpServerPort(
    ULONG64 PortObject,
    ULONG64 PortInfo
    )
{
    ULONG SemaphoreBuffer[8];
    ULONG64 Head, Next;
    ULONG Result;
    ULONG64 Msg;
    ULONG MsgCount;
    ULONG64 pObjectHeader;
    UCHAR                   ImageFileName[ 32 ];
    ULONG HandleCount, PointerCount;

    if (LastSeverPortDisplayied == PortObject) {

        //
        //  This port was already displayied
        //

        return;
    }
    LastSeverPortDisplayied = PortObject;

    pObjectHeader = KD_OBJECT_TO_OBJECT_HEADER(PortObject);

    if ( GetFieldValue(pObjectHeader, "nt!OBJECT_HEADER", "HandleCount", HandleCount) ) {
        dprintf("        *** %08p: Unable to read object header\n", pObjectHeader );
    }

    GetFieldValue(pObjectHeader, "nt!OBJECT_HEADER", "PointerCount",PointerCount);
    LpcCaptureObjectName( pObjectHeader, ObjectNameBuffer, MAX_PATH );

    dprintf( "\n");

    dprintf( "Server connection port %08p  Name: %ws\n", PortObject , ObjectNameBuffer);
    dprintf( "    Handles: %ld   References: %ld\n", HandleCount, PointerCount);

    InitTypeRead(PortInfo, LPCP_PORT_OBJECT);

    LpcpGetProcessImageName( ReadField(ServerProcess), ImageFileName );

    dprintf( "    Server process  : %08p (%s)\n",  ReadField(ServerProcess), ImageFileName);
    dprintf( "    Queue semaphore : %08p\n", ReadField(MsgQueue.Semaphore) );

    if ( !ReadMemory( ReadField(MsgQueue.Semaphore),
                      &SemaphoreBuffer,
                      sizeof( SemaphoreBuffer ),
                      &Result) ) {
        dprintf("        *** %08p: Unable to read semaphore contents\n", ReadField(MsgQueue.Semaphore) );
    }
    else {
        ULONG Off;

        dprintf( "    Semaphore state %ld (0x%lx) \n", SemaphoreBuffer[1], SemaphoreBuffer[1] );

        //
        //  Walk list of messages queued to this port.  Remove each message from
        //  the list and free it.
        //

        GetFieldOffset("nt!LPCP_PORT_OBJECT", "MsgQueue.ReceiveHead", &Off);

        Head = PortObject + Off;

        if (Head) {

            if ( !ReadPointer( Head, &Next ) ) {
                 dprintf( " Failed to read  Head 0x%p\n", Head );
                 return;
            }

            MsgCount = 0;

            while ((Next != 0) && (Next != Head)) {

                if (MsgCount == 0) {

                    dprintf ("        Messages in queue:\n");
                }

                Msg  = Next;

                LpcpDumpMessage("        ", Msg, 0);

                if ( !ReadPointer( Next, &Next ) ) {

                    dprintf( " Error reading  0x%p\n", Next );
                    return;
                }

                MsgCount++;

                if ( CheckControlC() ) {

                    return;
                }
            }

            if (MsgCount) {

                dprintf( "    The message queue contains %ld messages\n", MsgCount );
            }
            else {

                dprintf( "    The message queue is empty\n");
            }
       }

       DumpPortDataInfo(PortObject);
       DumpRunDownQueue(PortObject);
    }
}


VOID
DumpPortDataInfo(
    ULONG64 PortObject
    )
{
    ULONG64 Head, Next;
    ULONG64 Msg;
    ULONG MsgCount, Off, EntryOff;

    GetFieldOffset("nt!LPCP_MESSAGE", "Entry", &EntryOff);
    GetFieldOffset("nt!LPCP_PORT_OBJECT", "LpcDataInfoChainHead.Flink", &Off);

    Head = PortObject + Off;

    if (Head) {

         ReadPointer( Head, &Next );

         MsgCount = 0;

         while ((Next != 0) && (Next != Head)) {

             if (MsgCount == 0) {

                 dprintf ("\n    Messages in LpcDataInfoChainHead:\n");
             }

             Msg  = ( Next - EntryOff );

             LpcpDumpMessage("        ", Msg, 0);

             ReadPointer( Next, &Next );

             MsgCount++;

             if ( CheckControlC() ) {

                 return;
             }
         }

         if (MsgCount) {

             dprintf( "    The LpcDataInfoChainHead queue contains %ld messages\n", MsgCount );
         }
         else {

             dprintf( "    The LpcDataInfoChainHead queue is empty\n");
         }
    }
}


VOID
DumpRunDownQueue(
    ULONG64 PortObject
    )
{
    ULONG64 Head, Next;
    ULONG64 Thread;
    ULONG Count;
    ULONG Off, ChainOff;

    GetFieldOffset("nt!ETHREAD", "LpcReplyChain", &ChainOff);
    GetFieldOffset("nt!LPCP_PORT_OBJECT", "LpcDataInfoChainHead.Flink", &Off);
    Head = PortObject + Off;

    ReadPointer( Head, &Next);

    Count = 0;

    while ((Next != 0) && (Next != Head)) {

        if (Count == 0) {

            dprintf ("    Threads in RunDown queue : ");
        }

        Thread  = ( Next - ChainOff);

        dprintf ("    0x%08p", Thread);

        ReadPointer( Next, &Next);

        Count++;

        if ( CheckControlC() ) {

            return;
        }
    }

    if (Count) {

        dprintf("\n");
    }
}


VOID
DumpCommunicationPort(
    ULONG64 PortObject,
    ULONG64 PortInfo,
    BOOLEAN DisplayRelated
    )
{
    ULONG SemaphoreBuffer[8];
    ULONG64 Head, Next;
    ULONG Result;
    ULONG64 Msg;

    ULONG64          pObjectHeader;
    ULONG HandleCount, PointerCount, Flags;

    pObjectHeader = KD_OBJECT_TO_OBJECT_HEADER(PortObject);

    if ( GetFieldValue(pObjectHeader, "nt!OBJECT_HEADER", "HandleCount", HandleCount) ) {
        dprintf("        *** %08p: Unable to read object header\n", pObjectHeader );
    }

    GetFieldValue(pObjectHeader, "nt!OBJECT_HEADER", "PointerCount",PointerCount);
    dprintf( "\n");

    if ( GetFieldValue(PortInfo, "nt!LPCP_PORT_OBJECT", "Flags", Flags) ) {
        dprintf("        *** %08p: Unable to read port object\n", PortInfo );
    }

    if ((Flags & PORT_TYPE) == SERVER_COMMUNICATION_PORT) {

        dprintf( "Server communication port 0x%08lx\n", PortObject);
    }
    else if ((Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

        dprintf( "Client communication port 0x%08p\n", PortObject);
    }
    else {
        dprintf( "Invalid port flags 0x%08p, 0x%08lx\n", PortObject, Flags);
        return;
    }

    dprintf( "    Handles: %ld   References: %ld\n", HandleCount, PointerCount);

    DumpPortDataInfo(PortObject);
    DumpRunDownQueue(PortObject);

    if (DisplayRelated) {
        ULONG64 ConnectedPort, ConnectionPort;

        InitTypeRead(PortInfo, LPCP_PORT_OBJECT);
        dprintf( "        Connected port: 0x%08p      Server connection port: 0x%08p\n",
            (ConnectedPort = ReadField( ConnectedPort)), (ConnectionPort =  ReadField(ConnectionPort)));

        if (ConnectedPort) {

            DumpPortInfo(ConnectedPort, FALSE);
        }
        if (ConnectionPort) {

            DumpPortInfo(ConnectionPort, FALSE);
        }
    }
}


VOID
DumpPortInfo (
    ULONG64 PortObject,
    BOOLEAN DisplayRelated
    )
{
    ULONG                   Result;

    if ( GetFieldValue(PortObject, "nt!LPCP_PORT_OBJECT", "Flags", Result) ) {
        dprintf( "%08p: Unable to read port object\n", PortObject );
    }

    if ((Result & PORT_TYPE) == SERVER_CONNECTION_PORT) {

        DumpServerPort(PortObject, PortObject);
    }
    else {

        DumpCommunicationPort(PortObject, PortObject, DisplayRelated);
    }
}

BOOLEAN WINAPI
CheckForMessages(
    IN PCHAR Tag,
    IN PCHAR Filter,
    IN ULONG Flags,
    IN ULONG64 PoolHeader,
    IN ULONG BlockSize,
    IN ULONG64 Data,
    IN PVOID Context
    )
{

    ULONG PoolIndex;

    if (!PoolHeader) {
        return FALSE;
    }

    if (GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolIndex", PoolIndex)) {

        return FALSE;
    }

    if ((PoolIndex & 0x80) == 0) {
        return FALSE;
    }

    if (!CheckSingleFilter (Tag, Filter)) {
        return FALSE;
    }

    if (LpcpDumpMessage("", Data, (ULONG)(ULONG_PTR)Context)) {

        ULONG64                 Head, Next;
        ULONG  EntryOff, ChainOff, RcvOff, HeaderOff;
        ULONG64                 PortToDump;
        ULONG64                 ObjectHeader;
        ULONG64                 ObjectType;

        GetFieldOffset("nt!LPCP_MESSAGE", "Entry", &EntryOff);
        GetFieldOffset("nt!LPCP_PORT_OBJECT", "LpcDataInfoChainHead", &ChainOff);
        GetFieldOffset("nt!LPCP_PORT_OBJECT", "MsgQueue.ReceiveHead", &RcvOff);


        Head = Data + EntryOff;
        ReadPointer(Head, &Next);

        GetFieldOffset("nt!_OBJECT_HEADER", "Body", &HeaderOff);

        while ((Next != 0) && (Next != Head)) {

             PortToDump = ( Next - ChainOff );

             ObjectHeader = PortToDump - HeaderOff;

             GetFieldValue(ObjectHeader, "nt!OBJECT_HEADER", "Type", ObjectType);

             if ( (ObjectType == (LpcPortObjectType)) ||
                  (ObjectType == (LpcWaitablePortObjectType))) {

                DumpPortInfo(PortToDump, TRUE);

             }
             else {

                 PortToDump =  Next - RcvOff;

                 ObjectHeader = PortToDump - HeaderOff;

                 GetFieldValue(ObjectHeader, "nt!OBJECT_HEADER", "Type", ObjectType);

                 if ( (ObjectType == (LpcPortObjectType)) ||
                      (ObjectType == (LpcWaitablePortObjectType))) {

                    DumpPortInfo(PortToDump, TRUE);

                 }
             }

             ReadPointer(Next, &Next);
        }
    }

    return TRUE;
}



VOID
DumpMessagesInfo ()
{
    SearchPool ('McpL', 1, 0, &CheckForMessages, NULL);

}


VOID
SearchForMessage (ULONG Message)
{
    SearchThreadsForMessage(Message);

    if (DoPoolSearch) {
        SearchPool ('McpL', 1, 0, &CheckForMessages, (PVOID)UIntToPtr(Message));
    }
}


VOID
SearchThreadsForMessage (
    ULONG Message
    )
{
    ULONG64 ProcessHead;
    ULONG64 ProcessNext;
    ULONG64 Process;

    ULONG64 ThreadHead;
    ULONG64 ThreadNext;
    ULONG64 Thread;
    ULONG MsgId;
    ULONG64 ClientThread;
    ULONG   ActOff, PcbThrdOff, ThrdListOff;

    ClientThread = 0;

    dprintf("Searching message %lx in threads ...\n", Message);

    ProcessHead = GetExpression( "nt!PsActiveProcessHead" );

    if (!ProcessHead) {
        dprintf("Unable to get value of PsActiveProcessHead\n");
        return;
    }

    ProcessNext = GetPointerFromAddress(ProcessHead);
    GetFieldOffset("nt!EPROCESS", "ActiveProcessLinks", &ActOff);
    GetFieldOffset("nt!EPROCESS", "Pcb.ThreadListHead.Flink", &PcbThrdOff);
    GetFieldOffset("nt!KTHREAD", "ThreadListEntry", &ThrdListOff);

    while(ProcessNext != 0 && ProcessNext != ProcessHead) {

        Process = ProcessNext - ActOff;

        ThreadHead = Process + PcbThrdOff;
        ThreadNext = GetPointerFromAddress(ThreadHead);

        while(ThreadNext != 0 && ThreadNext != ThreadHead) {

            Thread = ThreadNext - ThrdListOff;

            GetFieldValue(Thread, "nt!ETHREAD", "LpcReplyMessageId", MsgId);

            if ((MsgId != 0) &&
                ((Message == 0) || (Message == MsgId))) {

                dprintf("Client thread %08p waiting a reply from %lx\n", Thread, MsgId);

                ClientThread = Thread;
            }

            GetFieldValue(Thread, "nt!ETHREAD", "LpcReceivedMsgIdValid", MsgId);

            if (MsgId) {

                GetFieldValue(Thread, "nt!ETHREAD", "LpcReceivedMessageId", MsgId);

                if ((Message == 0) || (Message == MsgId)) {

                    dprintf("Server thread %08p is working on message %lx\n", Thread, MsgId);
                }
            }

            ThreadNext = GetPointerFromAddress(ThreadNext);

            if (CheckControlC()) {
                return;
            }
        }

        ProcessNext = GetPointerFromAddress(ProcessNext/*&Process->ActiveProcessLinks.Flink*/);

        if (CheckControlC()) {
            return;
        }
    }

    if (Message && ClientThread) {

        SearchThreads(ClientThread);
    }

    return;
}


BOOLEAN
SearchThreads (
    ULONG64 Thread
    )
{
    ULONG64       PortObject;
    ULONG64       ObjectHeader;
    ULONG64       ObjectType;
    ULONG64       Head, Next;
    ULONG         Count;
    ULONG         ChainOff, HeadOff;

    dprintf("Searching thread %08p in port rundown queues ...\n", Thread);

    GetFieldOffset("nt!ETHREAD", "LpcReplyChain.Flink", &ChainOff);
    GetFieldOffset("nt!LPCP_PORT_OBJECT", "LpcReplyChainHead", &HeadOff);
    Head = Thread + ChainOff;

    Next = GetPointerFromAddress(Head);

    while ((Next != 0) && (Next != Head)) {

        PortObject = Next - HeadOff ;

        ObjectHeader = KD_OBJECT_TO_OBJECT_HEADER(PortObject);

        GetFieldValue(ObjectHeader, "nt!OBJECT_HEADER", "Type", ObjectType);

        if ( (ObjectType == (LpcPortObjectType)) ||
             (ObjectType == (LpcWaitablePortObjectType))) {

           DumpPortInfo(PortObject, TRUE);

           return TRUE;

        }

        Next = GetPointerFromAddress( Next);

        if ( CheckControlC() ) {

            return FALSE;
        }
    }

    dprintf("Thread %08p not found in any reply chain queue\n", Thread);

    return FALSE;
}


DECLARE_API( lpc )

/*++

Routine Description:

    Dump lpc ports and messages

Arguments:

    args - [TypeName]

Return Value:

    None

--*/

{
    ULONG                   Result;
    LONG                    SegmentSize;
    ULONG64                 pMsg;
    ULONG64                 PortToDump;
    char                    Param1[ MAX_PATH ];
    char                    Param2[ MAX_PATH ];
    ULONG64                 object;
    ULONG64                 ThreadAddress;
    ULONG                   MessageId = 0;

    Param1[0] = 0;
    Param2[0] = 0;
    LastSeverPortDisplayied = 0;

    if (!sscanf(args,"%s %s",&Param1, &Param2)) {
        Param1[0] = 0;
        Param2[0] = 0;
    }

    FetchGlobalVariables();

    if ((LpcPortObjectType == 0) || (LpcWaitablePortObjectType == 0)) {

        dprintf("The values for LpcPortObjectType or LpcWaitablePortObjectType are invalid. Please ckeck the symbols.\n");

        return E_INVALIDARG;
    }

    if (!_stricmp(Param1, "port")) {

        PortToDump = 0;

        if (Param2[0]) {

            PortToDump = GetExpression(Param2);
        }

        if (!PortToDump) {

            LpcWalkObjectsByType( LpcPortObjectType, FindPortCallback, 0);

            LpcWalkObjectsByType( LpcWaitablePortObjectType, FindPortCallback, 0);

        }
        else {

            if ((PortToDump >> 32) == 0) {

                PortToDump = (ULONG64) (LONG64) (LONG)PortToDump;
            }

            DumpPortInfo(PortToDump, TRUE);
        }
    }
    else if (!_stricmp(Param1, "scan")) {

        PortToDump = 0;

        if (Param2[0]) {

            PortToDump = GetExpression(Param2);
        }

        if (PortToDump) {

            LpcWalkObjectsByType( LpcPortObjectType, FindPortCallback, &PortToDump);

            LpcWalkObjectsByType( LpcWaitablePortObjectType, FindPortCallback, &PortToDump);
        }
    }
    else if (!_stricmp(Param1, "message")) {

        if (Param2[0]) {

            if (!sscanf(Param2, "%lx",&MessageId)) {
                MessageId = 0;
            }
        }

        if (MessageId){

            SearchForMessage(MessageId);
        }
        else {

            DumpMessagesInfo();
        }
    }
    else if (!_stricmp(Param1, "PoolSearch")) {

        DoPoolSearch = !DoPoolSearch;

        if (DoPoolSearch) {

            dprintf( "LPC will search the message in the kernel pool\n");
        } else {

            dprintf( "LPC will not search the message in the kernel pool\n");
        }
    }
    else if (!_stricmp(Param1, "thread")) {

        ThreadAddress = 0;

        if (Param2[0]) {

            ThreadAddress = GetExpression(Param2);
        }

        if (ThreadAddress) {

            if ((ThreadAddress >> 32) == 0) {

                ThreadAddress = (ULONG64) (LONG64) (LONG)ThreadAddress;
            }

            SearchThreads(ThreadAddress);
        }
        else {
            SearchThreadsForMessage(0);
        }
    }
    else {

        LpcHelp();
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\lookasid.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    LookAsid.c

Abstract:

    WinDbg Extension Api

Author:

    Gary Kimura [GaryKi]    22-Feb-96

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  A quick macro to dump a lookaside list given its variable name
//

#define Dump(S,R) { ULONG64 _a;                       \
    if( (_a = GetExpression( S )) == 0) {             \
        dprintf("Failed GetExpression(\"%s\")\n", S); \
    } else if ((R)) {                                 \
        ResetLookaside( _a, S );                      \
    } else {                                          \
        DumpLookaside( _a, S );                       \
    }                                                 \
}

#define GetAddressFromName(A,N) {                     \
    if (((A) = GetExpression( (N) )) == 0) {          \
        dprintf("Failed GetExpression(\"%s\")\n", N); \
        return;                                       \
    }                                                 \
}

#define ReadAtAddress(A,V,S) { ULONG _r;                           \
    if (!ReadMemory((A), &(V), (S), &_r ) || (_r < (S))) {         \
        dprintf("Can't Read Memory at %08p\n", (A));               \
        return;                                                    \
    }                                                              \
}

#define WriteAtAddress(A,V,S) { ULONG _r;                           \
    if (!WriteMemory( (A), &(V), (S), &_r ) || (_r < (S))) {        \
        dprintf("Can't Write Memory at %08p\n", (A));               \
        return;                                                     \
    }                                                               \
}

ULONG TotalPagedPotential;
ULONG TotalPagedUsed;
ULONG TotalNPagedPotential;
ULONG TotalNPagedUsed;


VOID
DumpLookaside (
    IN ULONG64 Address,
    IN PUCHAR  Name
    )

/*++

Routine Description:

    Dump a specific lookaside list.

Arguments:

    Address - Gives the address of the lookaside list to dump

    Name - Gives an optional name of to print next to the lookaside list

Return Value:

    None

--*/

{
    ULONG Results;

    ULONG AllocationHitRate;
    ULONG FreeHitRate;

    UCHAR Str[64];
    ULONG TotalAllocates, Depth, TotalFrees, Type, Size, Tag;

    //
    //  Read the lookaside list from memory
    //

    if (GetFieldValue( Address, "NPAGED_LOOKASIDE_LIST", 
                       "L.TotalAllocates", TotalAllocates)) {

        dprintf("Can't read lookaside \"%s\" at 0x%08p\n", Name, Address);
    }

    //
    //  Dump it out.  Note that for purposes of dumping a paged and nonpaged lookaside are
    //  the same.  I.e., the fields we're interested are at identical offsets
    //
    InitTypeRead(Address, NPAGED_LOOKASIDE_LIST);

    //
    //  Compute the hit rate
    //

    TotalFrees = (ULONG) ReadField(L.TotalFrees);
    AllocationHitRate = (TotalAllocates > 0 ? (((TotalAllocates - (ULONG) ReadField(L.AllocateMisses))*100)/TotalAllocates) : 0);
    FreeHitRate = (TotalFrees > 0 ? (((TotalFrees - (ULONG) ReadField(L.FreeMisses))*100)/TotalFrees) : 0);

    //
    //  Decide what type of pool is behind the lookaside list
    //

    Type = (ULONG) ReadField(L.Type);
    switch (Type & 0x7) {
    case NonPagedPool:                  sprintf(Str, "NonPagedPool");                  break;
    case PagedPool:                     sprintf(Str, "PagedPool");                     break;
    case NonPagedPoolMustSucceed:       sprintf(Str, "NonPagedPoolMustSucceed");       break;
    case DontUseThisType:               sprintf(Str, "DontUseThisType");               break;
    case NonPagedPoolCacheAligned:      sprintf(Str, "NonPagedPoolCacheAligned");      break;
    case PagedPoolCacheAligned:         sprintf(Str, "PagedPoolCacheAligned");         break;
    case NonPagedPoolCacheAlignedMustS: sprintf(Str, "NonPagedPoolCacheAlignedMustS"); break;
    default:                            sprintf(Str, "Unknown pool type");             break;
    }

    //
    //  Add to the total usage and potential based on pool type
    //
    Depth = (ULONG) ReadField(L.Depth);
    Size  = (ULONG) ReadField(L.Size);
    if (Type & 0x1) {

        TotalPagedUsed += (ULONG) ReadField(L.ListHead.Depth) * Size;
        TotalPagedPotential += Depth * Size;

    } else {

        TotalNPagedUsed += (ULONG) ReadField(ListHead.Depth) * Size;
        TotalNPagedPotential += Depth * Size;
    }

    //
    //  Now print everything
    //
    Tag = (ULONG) ReadField(L.Tag);
    dprintf("\nLookaside \"%s\" @ %08p \"%c%c%c%c\"\n", Name, Address, ((PUCHAR)&Tag)[0],
                                                                       ((PUCHAR)&Tag)[1],
                                                                       ((PUCHAR)&Tag)[2],
                                                                       ((PUCHAR)&Tag)[3]);
    dprintf("    Type     =     %04x %s", Type, Str);
    if (Type & POOL_QUOTA_FAIL_INSTEAD_OF_RAISE) { dprintf(" QuotaFailInsteadOrRaise"); }
    if (Type & POOL_RAISE_IF_ALLOCATION_FAILURE) { dprintf(" RaiseIfAllocationFailure"); }
    dprintf("\n");
    dprintf("    Current Depth  = %8ld   Max Depth  = %8ld\n", (ULONG) ReadField(L.ListHead.Depth), Depth);
    dprintf("    Size           = %8ld   Max Alloc  = %8ld\n", Size, Depth * Size);
    dprintf("    AllocateMisses = %8ld   FreeMisses = %8ld\n", (ULONG) ReadField(L.AllocateMisses), (ULONG) ReadField(L.FreeMisses));
    dprintf("    TotalAllocates = %8ld   TotalFrees = %8ld\n", TotalAllocates, TotalFrees);
    dprintf("    Hit Rate       =      %3d%%  Hit Rate   =      %3d%%\n", AllocationHitRate, FreeHitRate);

    return;
}


VOID
ResetLookaside (
    IN ULONG64 Address,
    IN PUCHAR  Name
    )

/*++

Routine Description:

    Resets the counters in a specific lookaside list.

Arguments:

    Address - Gives the address of the lookaside list to reset

    Name - Gives an optional name of to print in case of errors

Return Value:

    None

--*/

{
  //  NPAGED_LOOKASIDE_LIST Lookaside;
    ULONG Results, Off=0, Zero=0;

    //
    //  Get offset
    //

    GetFieldOffset("NPAGED_LOOKASIDE_LIST", "L.TotalAllocates", &Off);
    //
    //  Zero out the counters
    //
    if (!WriteMemory( Address + Off, &Zero, sizeof(ULONG), &Results ) ||
        (Results < sizeof(ULONG))) {

        dprintf("Can't write lookaside \"%s\" at 0x%08p\n", Name, Address);
    }


    GetFieldOffset("NPAGED_LOOKASIDE_LIST", "L.AllocateMisses", &Off);
    if (!WriteMemory( Address + Off, &Zero, sizeof(ULONG), &Results ) ||
        (Results < sizeof(ULONG))) {
        dprintf("Can't write lookaside \"%s\" at 0x%08p\n", Name, Address);
    }

    GetFieldOffset("NPAGED_LOOKASIDE_LIST", "L.TotalFrees", &Off);
    if (!WriteMemory( Address + Off, &Zero, sizeof(ULONG), &Results ) ||
        (Results < sizeof(ULONG))) {
        dprintf("Can't write lookaside \"%s\" at 0x%08p\n", Name, Address);
    }

    GetFieldOffset("NPAGED_LOOKASIDE_LIST", "L.FreeMisses", &Off);
    if (!WriteMemory( Address + Off, &Zero, sizeof(ULONG), &Results ) ||
        (Results < sizeof(ULONG))) {
        dprintf("Can't write lookaside \"%s\" at 0x%08p\n", Name, Address);
    }



    return;
}


VOID
SetDepthLookaside (
    IN ULONG64 Address,
    IN PUCHAR  Name,
    IN ULONG   Depth
    )

/*++

Routine Description:

    Set the depth of a specific lookaside list.

Arguments:

    Address - Gives the address of the lookaside list to reset

    Name - Gives an optional name of to print in case of errors

    Depth - Supplies the depth to set the lookaside list to

Return Value:

    None

--*/

{
    ULONG Results, Off=0;

    //
    //  Get offset
    //

    GetFieldOffset("NPAGED_LOOKASIDE_LIST", "L.Depth", &Off);
    //
    //  Set the depth
    //
    if (!WriteMemory( Address + Off, &Depth, sizeof(USHORT), &Results ) ||
        (Results < sizeof(USHORT))) {

        dprintf("Can't write lookaside \"%s\" at 0x%08p\n", Name, Address);
    }
    return;
}


DECLARE_API( lookaside )

/*++

Routine Description:

    Dump lookaside lists

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    ULONG64 LookasideToDump;
    ULONG   Options;
    ULONG   Depth;

    //
    //  If the caller specified an address then that the the lookaside list we dump
    //

    LookasideToDump = 0;
    Options = 0;
    Depth = 0;

    if (GetExpressionEx(args,&LookasideToDump, &args)) {
        if (!sscanf(args, "%lx %lx",&Options, &Depth)) {
            Options = 0;
            Depth = 0;
        }
    }

    if (LookasideToDump != 0) {

        if (Options == 0) {

            DumpLookaside( LookasideToDump, "");

        } else if (Options == 1) {

            ResetLookaside( LookasideToDump, "");

        } else if (Options == 2) {

            SetDepthLookaside( LookasideToDump, "", Depth );
        }

        return E_INVALIDARG;
    }

    //
    //  Reset the counters we use to sum up the potential pool usage
    //

    TotalPagedPotential = 0;
    TotalPagedUsed = 0;
    TotalNPagedPotential = 0;
    TotalNPagedUsed = 0;

    //
    //  Otherwise we'll dump a built in set of lookaside lists
    //

    Dump("nt!CcTwilightLookasideList", Options == 1);

    Dump("nt!IopSmallIrpLookasideList", Options == 1);
    Dump("nt!IopLargeIrpLookasideList", Options == 1);
    Dump("nt!IopMdlLookasideList", Options == 1);

    Dump("nt!FsRtlFastMutexLookasideList", Options == 1);
    Dump("nt!TunnelLookasideList", Options == 1);

    Dump("nt!ObpCreateInfoLookasideList", Options == 1);
    Dump("nt!ObpNameBufferLookasideList", Options == 1);

    Dump("afd!AfdWorkQueueLookasideList", Options == 1);

    Dump("Fastfat!FatIrpContextLookasideList", Options == 1);

    Dump("Ntfs!NtfsIoContextLookasideList", Options == 1);
    Dump("Ntfs!NtfsIrpContextLookasideList", Options == 1);
    Dump("Ntfs!NtfsKeventLookasideList", Options == 1);
    Dump("Ntfs!NtfsScbNonpagedLookasideList", Options == 1);
    Dump("Ntfs!NtfsScbSnapshotLookasideList", Options == 1);

    Dump("Ntfs!NtfsCcbLookasideList", Options == 1);
    Dump("Ntfs!NtfsCcbDataLookasideList", Options == 1);
    Dump("Ntfs!NtfsDeallocatedRecordsLookasideList", Options == 1);
    Dump("Ntfs!NtfsFcbDataLookasideList", Options == 1);
    Dump("Ntfs!NtfsFcbIndexLookasideList", Options == 1);
    Dump("Ntfs!NtfsIndexContextLookasideList", Options == 1);
    Dump("Ntfs!NtfsLcbLookasideList", Options == 1);
    Dump("Ntfs!NtfsNukemLookasideList", Options == 1);
    Dump("Ntfs!NtfsScbDataLookasideList", Options == 1);

    if (Options != 1) {

        dprintf("\n");
        dprintf("Total NonPaged currently allocated for above lists = %8ld\n", TotalNPagedUsed);
        dprintf("Total NonPaged potential for above lists           = %8ld\n", TotalNPagedPotential);
        dprintf("Total Paged currently allocated for above lists    = %8ld\n", TotalPagedUsed);
        dprintf("Total Paged potential for above lists              = %8ld\n", TotalPagedPotential);

        TotalPagedPotential = 0;
        TotalPagedUsed = 0;
        TotalNPagedPotential = 0;
        TotalNPagedUsed = 0;
    }

/*

    //
    //  Now dump out the small pool lookaside lists or zero their
    //  counters.
    //

    if (Options == 1) {

        ULONG Address;
        ULONG Results;
        ULONG i;

        //
        //  Get the location of the nonpaged list
        //

        GetAddressFromName( Address, "ExpSmallNPagedPoolLookasideLists" );

        //
        //  Read in each list, zero out it counters and write it back out
        //

        for ( i = 0; i < POOL_SMALL_LISTS; i += 1) {

            ULONG Location;
            SMALL_POOL_LOOKASIDE LookasideList;

            Location = Address + i * sizeof(SMALL_POOL_LOOKASIDE);

            ReadAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );

            LookasideList.TotalAllocates = 0;
            LookasideList.AllocateHits = 0;
            LookasideList.TotalFrees = 0;
            LookasideList.FreeHits = 0;

            WriteAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );
        }

        //
        //  Get the location of the paged list
        //

#ifndef TARGET_PPC

        GetAddressFromName( Address, "ExpSmallPagedPoolLookasideLists" );

        //
        //  Read in each list, zero out it counters and write it back out
        //

        for ( i = 0; i < POOL_SMALL_LISTS; i += 1) {

            ULONG Location;
            SMALL_POOL_LOOKASIDE LookasideList;

            Location = Address + i * sizeof(SMALL_POOL_LOOKASIDE);

            ReadAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );

            LookasideList.TotalAllocates = 0;
            LookasideList.AllocateHits = 0;
            LookasideList.TotalFrees = 0;
            LookasideList.FreeHits = 0;

            WriteAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );
        }

#endif // TARGET_PPC

    } else {

        ULONG Address;
        ULONG Results;
        ULONG i;

        //
        //  Get the location of the nonpaged list
        //

        GetAddressFromName( Address, "ExpSmallNPagedPoolLookasideLists" );
        dprintf("\nExpSmallNPagedLookasideLists @ %08lx\n", Address);

        //
        //  Read in each list and dump it out
        //

        for ( i = 0; i < POOL_SMALL_LISTS; i += 1) {

            ULONG Location;
            SMALL_POOL_LOOKASIDE LookasideList;
            ULONG AllocationHitRate;
            ULONG FreeHitRate;

            Location = Address + i * sizeof(SMALL_POOL_LOOKASIDE);

            ReadAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );

            TotalNPagedUsed += LookasideList.SListHead.Depth * (i+1)*32;
            TotalNPagedPotential += LookasideList.Depth * (i+1)*32;

            AllocationHitRate = (LookasideList.TotalAllocates > 0 ? ((LookasideList.AllocateHits*100)/LookasideList.TotalAllocates) : 0);
            FreeHitRate = (LookasideList.TotalFrees > 0 ? ((LookasideList.FreeHits*100)/LookasideList.TotalFrees) : 0);

            dprintf("\n  Nonpaged %d bytes @ %08lx\n", (i+1)*32, Location);

            dprintf("    Current Depth  = %8ld   Max Depth  = %8ld\n", LookasideList.SListHead.Depth, LookasideList.Depth);
            dprintf("    Size           = %8ld   Max Alloc  = %8ld\n", (i+1)*32, LookasideList.Depth * (i+1)*32);
            dprintf("    AllocateHits   = %8ld   FreeHits   = %8ld\n", LookasideList.AllocateHits, LookasideList.FreeHits);
            dprintf("    TotalAllocates = %8ld   TotalFrees = %8ld\n", LookasideList.TotalAllocates, LookasideList.TotalFrees);
            dprintf("    Hit Rate       =      %3d%%  Hit Rate   =      %3d%%\n", AllocationHitRate, FreeHitRate);
        }

        //
        //  Get the location of the paged list
        //

#ifndef TARGET_PPC

        GetAddressFromName( Address, "ExpSmallPagedPoolLookasideLists" );
        dprintf("\nExpSmallPagedLookasideLists @ %08lx\n", Address);

        //
        //  Read in each list and dump it out
        //

        for ( i = 0; i < POOL_SMALL_LISTS; i += 1) {

            ULONG Location;
            SMALL_POOL_LOOKASIDE LookasideList;
            ULONG AllocationHitRate;
            ULONG FreeHitRate;

            Location = Address + i * sizeof(SMALL_POOL_LOOKASIDE);

            ReadAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );

            TotalPagedUsed += LookasideList.SListHead.Depth * (i+1)*32;
            TotalPagedPotential += LookasideList.Depth * (i+1)*32;

            AllocationHitRate = (LookasideList.TotalAllocates > 0 ? ((LookasideList.AllocateHits*100)/LookasideList.TotalAllocates) : 0);
            FreeHitRate = (LookasideList.TotalFrees > 0 ? ((LookasideList.FreeHits*100)/LookasideList.TotalFrees) : 0);

            dprintf("\n  Paged %d bytes @ %08lx\n", (i+1)*32, Location);

            dprintf("    Current Depth  = %8ld   Max Depth  = %8ld\n", LookasideList.SListHead.Depth, LookasideList.Depth);
            dprintf("    Size           = %8ld   Max Alloc  = %8ld\n", (i+1)*32, LookasideList.Depth * (i+1)*32);
            dprintf("    AllocateHits   = %8ld   FreeHits   = %8ld\n", LookasideList.AllocateHits, LookasideList.FreeHits);
            dprintf("    TotalAllocates = %8ld   TotalFrees = %8ld\n", LookasideList.TotalAllocates, LookasideList.TotalFrees);
            dprintf("    Hit Rate       =      %3d%%  Hit Rate   =      %3d%%\n", AllocationHitRate, FreeHitRate);
        }

#endif // TARGET_PPC

        dprintf("\n");
        dprintf("Total NonPaged currently allocated for pool lists = %8ld\n", TotalNPagedUsed);
        dprintf("Total NonPaged potential for pool lists           = %8ld\n", TotalNPagedPotential);
        dprintf("Total Paged currently allocated for pool lists    = %8ld\n", TotalPagedUsed);
        dprintf("Total Paged potential for pool lists              = %8ld\n", TotalPagedPotential);
    }

    {
        ULONG Address;
        ULONG Results;

        ULONG i;
        ULONG j;

        UCHAR KeNumberProcessors;
        ULONG KiProcessorBlock[32];

        //
        //  First find out how many processors there are and then read in the
        //  array of processor block pointers
        //

        GetAddressFromName( Address, "KeNumberProcessors" );
        ReadAtAddress( Address, Address, sizeof(ULONG) );

        //
        //  For some bizarre reason sometimes we do a indirect read to get the
        //  number of processors and at other times it is more direct
        //

        if (Address <= 32) {

            KeNumberProcessors = (UCHAR)Address;

        } else {

            ReadAtAddress( Address, KeNumberProcessors, sizeof(UCHAR) );
        }

        GetAddressFromName( Address, "KiProcessorBlock" );
        ReadAtAddress( Address, KiProcessorBlock, sizeof(ULONG)*KeNumberProcessors );

        //
        //  Check if we are to reset the counters
        //

        if (Options == 1) {

            KPRCB Kprcb;

            for (i = 0; i < KeNumberProcessors; i += 1) {


                ReadAtAddress( KiProcessorBlock[i], Kprcb, sizeof(KPRCB) );

                for (j = 0; j < POOL_SMALL_LISTS; j += 1) {

                    Kprcb.SmallNPagedPoolLookasideLists[j].AllocateHits = 0;
                    Kprcb.SmallNPagedPoolLookasideLists[j].TotalAllocates = 0;

#ifndef TARGET_PPC
                    Kprcb.SmallPagedPoolLookasideLists[j].AllocateHits = 0;
                    Kprcb.SmallPagedPoolLookasideLists[j].TotalAllocates = 0;
#endif // TARGET_PPC
                }

                WriteAtAddress( KiProcessorBlock[i], Kprcb, sizeof(KPRCB) );
            }


        } else {

            KPRCB Kprcb[32];
            ULONG Addr[32];
            ULONG Depth[32];
            ULONG Hits[32];
            ULONG Total[32];
            ULONG HitRate[32];
            ULONG MaxAlloc[32];

            dprintf("\nSmall Pool Lookaside lists\n\n");
            dprintf("Kprcb    =");
            for (i = 0; i < KeNumberProcessors; i += 1) {

                dprintf(" %08lx ", KiProcessorBlock[i]);
                ReadAtAddress( KiProcessorBlock[i], Kprcb[i], sizeof(KPRCB) );
            }
            dprintf("\n");

            for ( j = 0; j < POOL_SMALL_LISTS; j += 1) {

                dprintf("\nNonpaged %d bytes\n", (j+1)*32);
                for (i = 0; i < KeNumberProcessors; i += 1) {

                    Addr[i] = KiProcessorBlock[i] + FIELD_OFFSET(KPRCB, SmallNPagedPoolLookasideLists[j]);

                    Depth[i] = Kprcb[i].SmallNPagedPoolLookasideLists[j].Depth;
                    Hits[i] = Kprcb[i].SmallNPagedPoolLookasideLists[j].AllocateHits;
                    Total[i] = Kprcb[i].SmallNPagedPoolLookasideLists[j].TotalAllocates;

                    HitRate[i] = (Total[i] > 0 ? ((Hits[i]*100)/Total[i]) : 0);
                    MaxAlloc[i] = ((j+1)*32) * Depth[i];
                }

                dprintf("Address  ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %08lx ", Addr[i]); }   dprintf("\n");
                dprintf("Depth    ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Depth[i]); }   dprintf("\n");
                dprintf("MaxAlloc ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", MaxAlloc[i]); } dprintf("\n");
                dprintf("Hits     ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Hits[i]); }    dprintf("\n");
                dprintf("Total    ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Total[i]); }   dprintf("\n");
                dprintf("HitRate  ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d%%", HitRate[i]); } dprintf("\n");
            }

#ifndef TARGET_PPC
            for ( j = 0; j < POOL_SMALL_LISTS; j += 1) {

                dprintf("\nPaged %d bytes\n", (j+1)*32);
                for (i = 0; i < KeNumberProcessors; i += 1) {

                    Addr[i] = KiProcessorBlock[i] + FIELD_OFFSET(KPRCB, SmallPagedPoolLookasideLists[j]);

                    Depth[i] = Kprcb[i].SmallPagedPoolLookasideLists[j].Depth;
                    Hits[i] = Kprcb[i].SmallPagedPoolLookasideLists[j].AllocateHits;
                    Total[i] = Kprcb[i].SmallPagedPoolLookasideLists[j].TotalAllocates;

                    HitRate[i] = (Total[i] > 0 ? ((Hits[i]*100)/Total[i]) : 0);
                    MaxAlloc[i] = ((j+1)*32) * Depth[i];
                }

                dprintf("Address  ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %08lx ", Addr[i]); }   dprintf("\n");
                dprintf("Depth    ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Depth[i]); }   dprintf("\n");
                dprintf("MaxAlloc ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", MaxAlloc[i]); } dprintf("\n");
                dprintf("Hits     ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Hits[i]); }    dprintf("\n");
                dprintf("Total    ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Total[i]); }   dprintf("\n");
                dprintf("HitRate  ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d%%", HitRate[i]); } dprintf("\n");
            }
#endif // TARGET_PPC
        }
    }
*/

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\mps.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mps.c

Abstract:

    WinDbg Extension Api

Author:

    Peter Johnston (peterj) 30-September-1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// HACKHACK
//
// The debugger extensions are a little bit broken at the
// moment (6/6/00) and I can't read a bitfield.  So I'm
// including the type here.  And it doesn't matter
// because this code only runs on 32-bit machines.
//

typedef struct _CPUIDENTIFIER {
    ULONG Stepping : 4;
    ULONG Model : 4;
    ULONG Family : 4;
    ULONG Reserved : 20;
} CPUIDENTIFIER, *PCPUIDENTIFIER;

//
// xReadMemory is easier to use than ReadMemory and is
// defined in ..\devnode.c
//

BOOLEAN
xReadMemory(
    ULONG64 S,
    PVOID D,
    ULONG Len
    );

PUCHAR
mpsGetIntTypeDesc(
    UCHAR IntType
    )
{
    switch (IntType) {
    case INT_TYPE_INTR:
        return "intr  ";
    case INT_TYPE_NMI:
        return "nmi   ";
    case INT_TYPE_SMI:
        return "smi   ";
    case INT_TYPE_EXTINT:
        return "extint";
    default:
        return "unknwn";
    }
}

PUCHAR
mpsExtAddrTypeToText(
    UCHAR AddressType
    )
{
    switch (AddressType) {
    case MPS_ADDRESS_MAP_IO:
        return "io port     ";
    case MPS_ADDRESS_MAP_MEMORY:
        return "memory      ";
    case MPS_ADDRESS_MAP_PREFETCH_MEMORY:
        return "prefetch mem";
    case MPS_ADDRESS_MAP_UNDEFINED:
        return "mps undef   ";
    default:
        return "unknown type";
    }
}

PUCHAR
mpsExtCompatibleListToText(
    ULONG List
    )
{
    switch (List) {
    case 0:
        return "ISA";
    case 1:
        return "VGA";
    default:
        return "unknown predefined range";
    }
}


BOOLEAN
mpsBaseTable(
    ULONG64 BaseTableAddress,
    ULONG   EntryCount
    )

/*++

Routine Description:

    Dumps entries from the MPS BASE table.

Arguments:

    BaseTableAddress    Address (in local memory) of the Base Entry Table
    EntryCount          Number of entries in this table.

Return Value:

    TRUE    is all is well
    FALSE   if execution cannot continue (ie we encountered an unknown
            entry type.  Can't continue because we don't know how big
            it is.

--*/

{
    ULONG64 bp = BaseTableAddress;
    ULONG   offset;
    ULONG   featureFlags;
    ULONG64 cpuAddr;
    ULONG   Family, Model, Stepping;
    CHAR    busId[8] = {0};
    CPUIDENTIFIER cpuId;

    //dprintf("BaseTableAddress: %x%x\n", BaseTableAddress);

    while (EntryCount--) {
        ULONG64   CharAtAddress;

        GetFieldValue(bp, "UCHAR", NULL, CharAtAddress);
        //dprintf("CharAtAddress: %x%x %x\n", bp, CharAtAddress);
        dprintf("  ");
        switch ((UCHAR) CharAtAddress) {
        case ENTRY_PROCESSOR:
            {
                InitTypeRead(bp, hal!_PcMpProcessorEntry);

                dprintf(
                    "processor. %s%sL.APIC ID %02x Vers %02x\n",
                    (ULONG) ReadField(CpuFlags) & CPU_ENABLED ? "EN " : "",
                    (ULONG) ReadField(CpuFlags) & BSP_CPU     ? "BP " : "",
                    (ULONG) ReadField(LocalApicId),
                    (ULONG) ReadField(LocalApicVersion)
                    );

                featureFlags = (ULONG)ReadField(FeatureFlags);

                GetFieldOffset("hal!_PcMpProcessorEntry", "CpuIdentification", &offset);
                cpuAddr = (bp + offset);
                
                xReadMemory(cpuAddr, &cpuId, 4);

                dprintf(
                    "             Family %x, Model %x, Stepping %x, CPUID Flags %04x\n",
                    cpuId.Family,
                    cpuId.Model,
                    cpuId.Stepping,
                    featureFlags
                    );
                
                bp += GetTypeSize("hal!_PcMpProcessorEntry");
            }
            break;
        case ENTRY_BUS:
            {
                GetFieldOffset("hal!_PcMpBusEntry", "BusType", &offset);
                xReadMemory((bp + offset), busId, 6);
                
                InitTypeRead(bp, hal!_PcMpBusEntry);
                dprintf(
                    "bus.       id %02x, type %6.6s\n",
                    (ULONG) ReadField(BusId),
                    busId
                    );

                bp += GetTypeSize("hal!_PcMpBusEntry");
            }
            break;
        case ENTRY_IOAPIC:
            {
                InitTypeRead(bp, hal!_PcMpIoApicEntry);
                bp += GetTypeSize("hal!_PcMpIoApicEntry");

                dprintf(
                    "io apic.   %s id %02x vers %02x @ %08x\n",
                    (ULONG) ReadField(IoApicFlag) & IO_APIC_ENABLED ? "EN" : "DI",
                    (ULONG) ReadField(IoApicId),
                    (ULONG) ReadField(IoApicVersion),
                    (ULONG) ReadField(IoApicAddress)
                    );
            }
            break;
        case ENTRY_INTI:
            {
                InitTypeRead(bp, hal!_PcMpApicIntiEntry);
                bp += GetTypeSize("hal!_PcMpApicIntiEntry");

                dprintf(
                    "io int.    %s po=%x el=%x, srcbus %02x irq %02x dst apic %02x intin %02x\n",
                    mpsGetIntTypeDesc((UCHAR) ReadField(IntType)),
                    (ULONG) ReadField(Signal.Polarity),
                    (ULONG) ReadField(Signal.Level),
                    (ULONG) ReadField(SourceBusId),
                    (ULONG) ReadField(SourceBusIrq),
                    (ULONG) ReadField(IoApicId),
                    (ULONG) ReadField(IoApicInti)
                    );
            }
            break;
        case ENTRY_LINTI:
            {
                InitTypeRead(bp, hal!_PcMpLintiEntry);
                bp += GetTypeSize("hal!_PcMpLintiEntry");

                dprintf(
                    "lcl int.   %s po=%x el=%x, srcbus %02x irq %02x dst apic %02x intin %02x\n",
                    mpsGetIntTypeDesc((UCHAR) ReadField(IntType)),
                    (ULONG) ReadField(Signal.Polarity),
                    (ULONG) ReadField(Signal.Level),
                    (ULONG) ReadField(SourceBusId),
                    (ULONG) ReadField(SourceBusIrq),
                    (ULONG) ReadField(DestLocalApicId),
                    (ULONG) ReadField(DestLocalApicInti)
                    );
            }
            break;
        default:
            dprintf(
                "Unknown MPS base type 0x%02x, cannot continue.\n",
                CharAtAddress
                );
            return FALSE;
        }
    }
    return TRUE;
}


BOOLEAN
mpsExtendedTable(
    ULONG64 ExtendedTableAddress,
    ULONG64 ExtendedTableAddressEnd
    )

/*++

Routine Description:

    Dumps entries from the MPS Extended table.

Arguments:

    BaseTableAddress    Address (in local memory) of the Base Entry Table
    EntryCount          Number of entries in this table.

Return Value:

    TRUE    is all is well
    FALSE   if execution cannot continue (ie we encountered an unknown
            entry type.  Can't continue because we don't know how big
            it is.

--*/

{
    ULONG64 bp = ExtendedTableAddress;

    if (!bp) {
        return TRUE;
    }
    dprintf("  extended table entries\n");

    while (bp < ExtendedTableAddressEnd) {

        if (InitTypeRead(bp, hal!MPS_EXTENTRY)) {
            dprintf("Cannot get hal!MPS_EXTENTRY at %p\n", bp);
            return FALSE;
        }

        if (ReadField(Length) == 0) {
            dprintf("Malformed extended entry, length = 0, cannot continue.\n");
            return FALSE;
        }

        dprintf("  ");

        switch ((ULONG) ReadField(Type)) {
        case EXTTYPE_BUS_ADDRESS_MAP:
            dprintf(
                "address.   bus %02x %s % 16I64x len %16I64x\n",
                (ULONG) ReadField(u.AddressMap.BusId),
                mpsExtAddrTypeToText((UCHAR) ReadField(u.AddressMap.Type)),
                ReadField(u.AddressMap.Base),
                ReadField(u.AddressMap.Length)
                );
            break;
        case EXTTYPE_BUS_HIERARCHY:
            dprintf(
                "child bus. bus %02x is child of bus %02x%s\n",
                (ULONG) ReadField(u.BusHierarchy.BusId),
                (ULONG) ReadField(u.BusHierarchy.ParentBusId),
                (ULONG) ReadField(u.BusHierarchy.SubtractiveDecode) ? " subtractive" : ""
                );
            break;
        case EXTTYPE_BUS_COMPATIBLE_MAP:
            dprintf(
                "bus comp.  bus %02x %s %s ranges\n",
                (ULONG) ReadField(u.CompatibleMap.BusId),
                (ULONG) ReadField(u.CompatibleMap.Modifier) ? "exclude" : "include",
                mpsExtCompatibleListToText((ULONG) ReadField(u.CompatibleMap.List))
                );
            break;
        case EXTTYPE_PERSISTENT_STORE:
            dprintf(
                "persist.   % 16I64x len %16I64x\n",
                ReadField(u.PersistentStore.Address),
                ReadField(u.PersistentStore.Length)
                );
            break;
        default:
            dprintf(
                "Unknown MPS extended type 0x%02x, cannot continue.\n",
                (ULONG) ReadField(Type)
                );
            return FALSE;
        }

        //
        // Advance to the next entry.
        //

        bp += (ULONG) ReadField(Length);
    }
    return TRUE;
}


DECLARE_API( mps )

/*++

Routine Description:

    Dumps the MPS (Multi Processor Specification) BIOS Tables.

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG64 addr;
    UCHAR   halName[32];
    UCHAR   OemId[20]={0}, OemProductId[20]={0};
    ULONG64 PcMpTablePtr;
    ULONG entryCount;
    PUCHAR bp;
    UCHAR c;
    ULONG i, TableLength, ExtTableLength, Sz;
    UCHAR PcMpCfgTable[100];
    PUCHAR MpsBaseTable = NULL;
    PUCHAR MpsExtendedTable = NULL;
    PUCHAR MpsExtendedTableEnd;
    ULONG  OemOffset, SigOffset, Sig = 0;

    BOOLEAN halNameKnown = FALSE;

    if (TargetIsDump) {
        dprintf("!mps doesnt work on dump targets\n");
        return E_INVALIDARG;
    }
    //
    // Check to see if user entered the address of the MPS tables.
    // If not, try to obtain it using HAL symbols.
    //

    PcMpTablePtr = GetExpression(args);
    if (PcMpTablePtr == 0) {

        //
        // Get address of PC+MP structure from the HAL.
        // N.B. Should add code to allow hunting for the floating pointer.
        //

        addr = GetExpression("hal!HalName");

        if (addr == 0) {
            dprintf(
                "Unable to use HAL symbols (hal!HalName), please verify symbols.\n"
                );
            return E_INVALIDARG;
        }

        if (!xReadMemory(addr, &halName, sizeof(halName))) {
            dprintf(
                "Failed to read HalName from host memory, quitting.\n"
                );
            return E_INVALIDARG;
        }

        halName[sizeof(halName)-1] = '\0';
        if (strstr(halName, "MPS ") == NULL) {
            dprintf("HAL = \"%s\".\n", halName);
            dprintf("HAL does not appear to be an MPS HAL, quitting.\n");
            return E_INVALIDARG;
        }
        halNameKnown = TRUE;

        addr = GetExpression("hal!PcMpTablePtr");

        if (addr == 0) {
            dprintf(
                "Unable to get address of hal!PcMpTablePtr, cannot continue.\n"
                );
            return E_INVALIDARG;
        }

        if (!ReadPointer(addr, &PcMpTablePtr)) {
            dprintf(
                "Failed to read PcMpTablePtr from host memory, cannot continue.\n"
                );
            return E_INVALIDARG;
        }
    }

    if (InitTypeRead(PcMpTablePtr, hal!PcMpTable)) {
        dprintf(
            "Failed to read MP Configuration Table Header @%08p\n"
            "Cannot continue.\n",
            PcMpTablePtr
            );
        return E_INVALIDARG;
    }

    GetFieldOffset("hal!PcMpTable", "Signature", &SigOffset);
    xReadMemory(PcMpTablePtr + SigOffset, &Sig, sizeof(Sig));

    if (Sig != PCMP_SIGNATURE) {
        dprintf(
            "MP Config Table Signature doesn't match.  Cannot continue.\n"
            );
        return E_INVALIDARG;
    }

    dprintf("  BIOS Revision ");

    switch ((ULONG) ReadField(Revision)) {
    case 1:
        dprintf(
            "MPS 1.1 (WARNING: This BIOS might not support NT 5 depending\n"
            "                  upon system configuration.)\n"
            );
        break;
    case 4:
        dprintf(
            "MPS 1.4       "
            );
        break;
    default:
        dprintf(
            "Unknown MPS revision byte 0x%2x, dumped values\n"
            "  may be incorrect.\n"
            );
        break;
    }

    if (halNameKnown) {
        dprintf("  HAL = %s", halName);
    }
    dprintf("\n");

    GetFieldOffset("hal!PcMpTable", "OemId", &OemOffset);
    xReadMemory(PcMpTablePtr + OemOffset, &OemId, 8);
    
    dprintf(
        "  OEM ID         :%s\n",
        OemId
        );

    GetFieldOffset("hal!PcMpTable", "OemProductId", &OemOffset);
    xReadMemory(PcMpTablePtr + OemOffset, &OemProductId, 12);
    
    dprintf(
        "  OEM Product ID :%s\n",
        OemProductId
        );

    TableLength = (ULONG) ReadField(TableLength);
    Sz = GetTypeSize("hal!PcMpTable");
    if (TableLength <= Sz) {
        dprintf(
            "MPS Base Table length (%d) is too small to be reasonable,\n",
            TableLength
            );
        dprintf(
            "Must be >= sizeof(fixed table header) (%d bytes).  "
            "Cannot continue.\n",
            Sz
            );
        return E_INVALIDARG;
    }

    //
    // Get memory for the base and extended tables and read them from
    // memory.
    //

    MpsBaseTable = malloc( TableLength - Sz);
    if (!MpsBaseTable) {
        dprintf(
            "Could not allocate %d bytes local memory, quitting.\n",
            TableLength - Sz
            );
        return E_INVALIDARG;
    }

    if (!xReadMemory(PcMpTablePtr + Sz,
                     MpsBaseTable,
                     TableLength - Sz)) {
        dprintf("Failed to read MPS Base Table from host memory.  Quitting.\n");
        goto cleanup;
    }

    if (ExtTableLength = (ULONG) ReadField(ExtTableLength)) {
        MpsExtendedTable = malloc(ExtTableLength);
        if (!MpsExtendedTable) {
            dprintf(
                "Could not allocate %d bytes local memory for extended MPS Table, quitting.\n",
                ExtTableLength
            );
            goto cleanup;
        }

        if (!xReadMemory(PcMpTablePtr + TableLength,
                         MpsExtendedTable,
                         ExtTableLength)) {
            dprintf(
                "Could not read MPS Extended table from host memory.\n"
                "Will attempt to dump base structures.\n"
                );
            free(MpsExtendedTable);
            MpsExtendedTable = NULL;
        }
        MpsExtendedTableEnd = MpsExtendedTable + ExtTableLength;
    }

    //
    // Validate checksums.
    //
    // Base checksum is the sum of all bytes (inc checksum) in the
    // base table (including the fixed header).
    //

    c = 0;

    //
    // Sum fixed header.
    //

    if (Sz > sizeof(PcMpCfgTable)) {
        return E_INVALIDARG;
    }
    xReadMemory(PcMpTablePtr, PcMpCfgTable, Sz);
    bp = (PUCHAR)&PcMpCfgTable[0];
    for (i = 0; i < Sz; i++) {
        c += *bp++;
    }

    //
    // Add rest of base table.
    //

    bp = MpsBaseTable;
    for (i = 0; i < TableLength - Sz; i++) {
        c += *bp++;
    }

    //
    // The result should be zero.
    //

    if (c) {
        dprintf(
            "MPS Base Table checksum is in error.\n"
            "Found 0x%02x, Computed 0x%02x (Total 0x%02x).\n",
            (ULONG) ReadField(Checksum),
            (UCHAR)(c - (UCHAR) ReadField(Checksum)),
            c
            );
    }

    //
    // Now do the extended table checksum.  This one doesn't include
    // itself so we should just match (rather than end up with zero).
    //

    if (MpsExtendedTable) {
        c = 0;
        bp = MpsExtendedTable;
        for (i = 0; i < ExtTableLength; i++) {
            c += *bp++;
        }

        //
        // To sum to zero it needs to end up being it's opposite.
        //

        c = -c;

        if (c != (UCHAR) ReadField(ExtTableChecksum)) {
            dprintf(
                "MPS Extended Table checksum is in error.\n"
                "Found 0x%02x, Computed 0x%02x.\n",
                (ULONG) ReadField(ExtTableChecksum),
                c
                );
        }
    }

    //
    // Dump the base table.
    //

    if (!mpsBaseTable(PcMpTablePtr + Sz, (ULONG) ReadField(NumOfEntries))) {
        goto cleanup;
    }


    //
    // Dump the extended table.
    //

    if (!mpsExtendedTable(PcMpTablePtr + TableLength, PcMpTablePtr + TableLength + ExtTableLength )) {
        goto cleanup;
    }

cleanup:
    if (MpsBaseTable) {
        free(MpsBaseTable);
    }
    if (MpsExtendedTable) {
        free(MpsExtendedTable);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\memory.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    WinDbg Extension Api

Author:

    Lou Perazzoli (loup)

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define PACKET_MAX_SIZE 4000

#define USAGE_ALLOC_SIZE 256*1024

#ifdef _KB
#undef _KB
#endif
#define _KB (PageSize/1024)


typedef struct _PFN_INFO {
    ULONG64 Master;
    ULONG64 OriginalPte;
    ULONG ValidCount;
    ULONG StandbyCount;
    ULONG ModifiedCount;
    ULONG SharedCount;
    ULONG LockedCount;
    ULONG PageTableCount;
    struct _PFN_INFO *Next;
} PFN_INFO, *PPFN_INFO;

typedef struct _KERN_MAP1 {
    ULONG64 StartVa;
    ULONG64 EndVa;
    ULONG ValidCount;
    ULONG StandbyCount;
    ULONG ModifiedCount;
    ULONG SharedCount;
    ULONG LockedCount;
    ULONG PageTableCount;
    WCHAR Name[256];
} KERN_MAP1, *PKERN_MAP1;

typedef struct _KERN_MAP {
    ULONG Count;
    KERN_MAP1 Item[500];
} KERN_MAP, *PKERN_MAP;

typedef struct _MMPFNENTRY {
    ULONG Modified : 1;
    ULONG ReadInProgress : 1;
    ULONG WriteInProgress : 1;
    ULONG PrototypePte: 1;
    ULONG PageColor : 3;
    ULONG ParityError : 1;
    ULONG PageLocation : 3;
    ULONG RemovalRequested : 1;
    ULONG CacheAttribute : 2;
    ULONG Rom : 1;
    ULONG LockCharged : 1;
    ULONG DontUse : 16; //overlays USHORT for reference count field.
} MMPFNENTRY;

typedef struct _MMPFN_READ {
    MMPFNENTRY u3_e1;
    ULONG u3_e2_ReferenceCount;
    ULONG64   u1_Flink, u2_Blink, PteAddress, OriginalPte, PteFrame;
} MMPFN_READ, *PMMPFN_READ;

typedef struct _PFN_DUMP_CTXT {
    BOOL  PrintIndex;
    ULONG64 index;
    BOOL  ZeroAfterPrint;
    PMMPFN_READ pReadPfn;
} PFN_DUMP_CTXT, *PPFN_DUMP_CTXT;

UCHAR *PageLocationList[] = {
    (PUCHAR)"Zeroed  ",
    (PUCHAR)"Free    ",
    (PUCHAR)"Standby ",
    (PUCHAR)"Modified",
    (PUCHAR)"ModNoWrt",
    (PUCHAR)"Bad     ",
    (PUCHAR)"Active  ",
    (PUCHAR)"Trans   "
};

UCHAR *PageAttribute[] = {
    (PUCHAR)"NonCached",
    (PUCHAR)"Cached   ",
    (PUCHAR)"WriteComb",
    (PUCHAR)"NotMapped"
};


ULONG64 MmSubsectionBase;
ULONG64 MaxDirbase;
#define MAX_DIRBASEVECTOR 256
ULONG64 DirBases[MAX_DIRBASEVECTOR];
UCHAR Names[MAX_DIRBASEVECTOR][64];

VOID
PrintPfn64 (
    IN ULONG64 PfnAddress
    );

VOID
DumpMmThreads (
    VOID
    );

VOID DumpWholePfn(
    IN ULONG64 Address,
    IN ULONG   Flags
    );

PUCHAR
DirbaseToImage(
    IN ULONG64 DirBase
    );

NTSTATUS
BuildDirbaseList( VOID );

LOGICAL
BuildKernelMap (
    OUT PKERN_MAP KernelMap
    );

ULONG
DbgGetPfnSize(
    VOID
    )
{
    return GetTypeSize("nt!_MMPFN");
}

LOGICAL
PoolGetTag (
    IN PVOID PoolAddress,
    IN PULONG PoolTag
    );

ULONG64 SystemRangeStart;

DECLARE_API( memusage )

/*++

Routine Description:

    Dumps the page frame database table

Arguments:

    arg -

Return Value:

    None.

--*/

{
    ULONG   result;
    ULONG64 PfnDb;
    ULONG64 HighPageAddr;
    ULONG64 LowPageAddr;
    ULONG64 HighPage=0;
    ULONG64 LowPage=0;
    ULONG64 PageCount;
    ULONG64 ReadCount;
    ULONG   WasZeroedPage;
    ULONG   WasFreePage;
    ULONG   Total;
    ULONG   WasStandbyPage;
    ULONG   WasModifiedPage;
    ULONG   WasModifiedNoWritePage;
    ULONG   WasBadPage;
    ULONG   WasActiveAndValidPage;
    ULONG   WasTransitionPage;
    ULONG   WasUnknownPage;
    ULONG64 NPPoolStart;
    ULONG64 NPSystemStart;
    ULONG64 Pfn;
    ULONG64 PfnStart;
    PCHAR   PfnArray;
    ULONG   PfnSize;
    ULONG   NumberOfPfnToRead;
    ULONG CompleteSoFar = (ULONG) ~0;
    ULONG64 CacheSize;
    UNREFERENCED_PARAMETER (args);
    UNREFERENCED_PARAMETER (Client);

    LowPageAddr   = GetNtDebuggerData(MmLowestPhysicalPage);
    HighPageAddr  = GetNtDebuggerData(MmHighestPhysicalPage);
    PfnDb         = GetNtDebuggerData(MmPfnDatabase);
    NPPoolStart   = GetNtDebuggerData(MmNonPagedPoolStart);
    NPSystemStart = GetNtDebuggerData(MmNonPagedSystemStart);
    SystemRangeStart = GetNtDebuggerDataValue(MmSystemRangeStart);

    PfnSize = GetTypeSize("nt!_MMPFN");

    NumberOfPfnToRead = 300;

    if ( LowPageAddr   &&
         HighPageAddr  &&
         PfnDb         &&
         NPPoolStart   &&
         NPSystemStart ) {

        if ( !ReadPointer( LowPageAddr, &LowPage) ) {
            dprintf("%08p: Unable to get low physical page\n",LowPageAddr);
            return E_INVALIDARG;
        }

        if ( !ReadPointer( HighPageAddr,&HighPage) ) {
            dprintf("%08p: Unable to get high physical page\n",HighPageAddr);
            return E_INVALIDARG;
        }

        if ( !ReadPointer( PfnDb,&PfnStart) ) {
            dprintf("%08p: Unable to get PFN database address\n",PfnDb);
            return E_INVALIDARG;
        }

#ifdef IG_GET_CACHE_SIZE
    if (GetDebuggerCacheSize(&CacheSize)) {
        if (CacheSize < (HighPage - LowPage)*PfnSize) {
        dprintf("*** WARNING Cache size too low, !memusage might take long time to run\n"
            "            Increase Cache to %#lx kb for better performance.\n",
            (HighPage - LowPage)*PfnSize / 1024);
        }
    }
#endif
        dprintf(" loading PFN database\n");

        PfnArray = VirtualAlloc ( NULL,
                  (ULONG) ((HighPage-LowPage+1) * PfnSize),
                  MEM_RESERVE | MEM_COMMIT,
                  PAGE_READWRITE);

        if (!PfnArray) {
            dprintf("Unable to get allocate memory of %I64ld bytes\n",
                    (HighPage+1) * PfnSize);
        } else {

            for (PageCount = LowPage;
                 PageCount <= HighPage;
                 PageCount += NumberOfPfnToRead) {

                //dprintf("getting PFN table block - "
                //        "address %lx - count %lu - page %lu\n",
                //        Pfn, ReadCount, PageCount);

                if ( CheckControlC() ) {
                    VirtualFree (PfnArray,0,MEM_RELEASE);
                    return E_INVALIDARG;
                }

                ReadCount = HighPage - PageCount > NumberOfPfnToRead ?
                                NumberOfPfnToRead :
                                HighPage - PageCount + 1;

                ReadCount *= PfnSize;

                Pfn = (PfnStart + PageCount * PfnSize);

                if (CompleteSoFar != (ULONG) (((PageCount + LowPage) * 100)/ HighPage)) {
                    CompleteSoFar =  (ULONG) (((PageCount + LowPage) * 100)/ HighPage);
                    dprintf("loading (%d%% complete)\r", CompleteSoFar);
                }

                // Let KD cache the data - we won't be reading from the array.
                if ( !ReadMemory( Pfn,
                                  PfnArray + PageCount * PfnSize,
                                  (ULONG) ReadCount,
                                  &result) ) {
                    dprintf("Unable to get PFN table block - "
                            "address %p - count %lu - page %lu\n",
                            Pfn, ReadCount, PageCount);
                    VirtualFree (PfnArray,0,MEM_RELEASE);
                    return E_INVALIDARG;
                }
            }
            dprintf("\n");

            // Now we have a local copy: let's take a look

            WasZeroedPage           = 0;
            WasFreePage             = 0;
            WasStandbyPage          = 0;
            WasModifiedPage         = 0;
            WasModifiedNoWritePage  = 0;
            WasBadPage              = 0;
            WasActiveAndValidPage   = 0;
            WasTransitionPage       = 0;
            WasUnknownPage          = 0;

            CompleteSoFar = 0;
            for (PageCount = LowPage;
                 PageCount <= HighPage;
                 PageCount++) {
                ULONG PageLocation=0;
                ULONG64 Flink=0, Blink=0;

                if ( CheckControlC() ) {
                    VirtualFree (PfnArray,0,MEM_RELEASE);
                    return E_INVALIDARG;
                }

                if (CompleteSoFar < (ULONG) (((PageCount + LowPage) * 100)/ HighPage)) {
                    CompleteSoFar =  (ULONG) (((PageCount + LowPage) * 100)/ HighPage);
                    dprintf("Compiling memory usage data (%d%% Complete).\r", CompleteSoFar);
                }


                Pfn = (PfnStart + PageCount * PfnSize);

                GetFieldValue(Pfn, "nt!_MMPFN", "u3.e1.PageLocation", PageLocation);

                switch (PageLocation) {

                    case ZeroedPageList:
                        GetFieldValue(Pfn, "nt!_MMPFN", "u1.Flink", Flink);
                        GetFieldValue(Pfn, "nt!_MMPFN", "u2.Blink", Blink);
                        if ((Flink == 0) &&
                            (Blink == 0)) {
                            WasActiveAndValidPage++;
                        } else {
                            WasZeroedPage++;
                        }
                        break;

                    case FreePageList:
                        WasFreePage++;
                        break;

                    case StandbyPageList:
                        WasStandbyPage++;
                        break;

                    case ModifiedPageList:
                        WasModifiedPage++;
                        break;

                    case ModifiedNoWritePageList:
                        WasModifiedNoWritePage++;
                        break;

                    case BadPageList:
                        WasModifiedNoWritePage++;
                        break;

                    case ActiveAndValid:
                        WasActiveAndValidPage++;
                        break;

                    case TransitionPage:
                        WasTransitionPage++;
                        break;

                    default:
                        WasUnknownPage++;
                        break;
                }
            }
            dprintf("\n");

            dprintf( "             Zeroed: %6lu (%6lu kb)\n",
                    WasZeroedPage, WasZeroedPage * _KB);
            dprintf( "               Free: %6lu (%6lu kb)\n",
                    WasFreePage, WasFreePage * _KB);
            dprintf( "            Standby: %6lu (%6lu kb)\n",
                    WasStandbyPage, WasStandbyPage * _KB);
            dprintf( "           Modified: %6lu (%6lu kb)\n",
                    WasModifiedPage,
                    WasModifiedPage * _KB);
            dprintf( "    ModifiedNoWrite: %6lu (%6lu kb)\n",
                    WasModifiedNoWritePage,WasModifiedNoWritePage * _KB);
            dprintf( "       Active/Valid: %6lu (%6lu kb)\n",
                    WasActiveAndValidPage, WasActiveAndValidPage * _KB);
            dprintf( "         Transition: %6lu (%6lu kb)\n",
                    WasTransitionPage, WasTransitionPage * _KB);
            dprintf( "            Unknown: %6lu (%6lu kb)\n",
                    WasUnknownPage, WasUnknownPage * _KB);

            Total = WasZeroedPage +
                    WasFreePage +
                    WasStandbyPage +
                    WasModifiedPage +
                    WasModifiedNoWritePage +
                    WasActiveAndValidPage +
                    WasTransitionPage +
                    WasUnknownPage +
                    WasUnknownPage;
            dprintf( "              TOTAL: %6lu (%6lu kb)\n",
                    Total, Total * _KB);
        }
        MemoryUsage (PfnStart, LowPage, HighPage, 0);
        VirtualFree (PfnArray,0,MEM_RELEASE);
    }
    return S_OK;
}


DECLARE_API( lockedpages )

/*++

Routine Description:

    Displays the driver-locked pages.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64 LockHeader;
    ULONG64 LockTracker;
    ULONG64 NextEntry;
    ULONG   GlistOff;
    ULONG64 Count;
    CHAR    Buffer[256];
    ULONG64 displacement;

    UNREFERENCED_PARAMETER (args);
    UNREFERENCED_PARAMETER (Client);

    LockHeader = GetExpression ("nt!MmLockedPagesHead");

    if (GetFieldValue(LockHeader,
                      "nt!_LOCK_HEADER",
                      "Count",
                      Count)) {

        dprintf("%08p: Unable to get lock header data.\n", LockHeader);
        return E_INVALIDARG;
    }

    GetFieldValue(LockHeader,"nt!_LOCK_HEADER","ListHead.Flink", NextEntry);
    if (NextEntry == 0) {
        dprintf("Locked pages tracking not enabled\n");
        return E_INVALIDARG;
    }

    if (NextEntry == LockHeader) {
        dprintf("There are no pages currently locked.\n");
        return E_INVALIDARG;
    }

    dprintf("%I64d locked pages...\n", Count);
    dprintf("Tracker    MDL   PageCount  Caller/CallersCaller\n");


    GetFieldOffset("LOCK_TRACKER", "GlobalListEntry", &GlistOff);
    while (NextEntry != LockHeader) {

        LockTracker = (NextEntry - GlistOff);

        if (GetFieldValue(LockTracker, "nt!LOCK_TRACKER",
                          "GlobalListEntry.Flink", NextEntry)) {

            dprintf("%08p: Unable to get lock tracker data.\n", LockTracker);
            return E_INVALIDARG;
        }

        InitTypeRead(LockTracker, nt!LOCK_TRACKER);
        dprintf("Tracker %p : MDL @ %p, PageCount = %I64x, Caller = %p %p\n",
            LockTracker,
            ReadField(Mdl),
            ReadField(Count));

        Buffer[0] = '!';
        GetSymbol (ReadField(CallingAddress),
                   (PCHAR)Buffer,
                   &displacement);

        dprintf("%s", Buffer);
        if (displacement) {
            dprintf( "+0x%1p", displacement );
        }
        dprintf("/");

        Buffer[0] = '!';
        GetSymbol (ReadField(CallersCaller),
                   (PCHAR)Buffer,
                   &displacement);

        dprintf("%s", Buffer);
        if (displacement) {
            dprintf( "+0x%1p", displacement );
        }

        dprintf("\n");

        if (CheckControlC()) {
            break;
        }
    }
    return S_OK;
}

DECLARE_API( pfnperf )

/*++

Routine Description:

    Displays the PFN spinlock duration list.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64 PfnDuration;
    ULONG64 PfnEntry;
    ULONG64 displacement;
    ULONG64 AcquiredAddress;
    ULONG64 ReleasedAddress;
    CHAR SymbolBuffer[80];
    PCHAR SymPointer;
    ULONG EntrySize;
    ULONG result;
    ULONG64 ReadCount;
    ULONG64 i;
    PCHAR LocalData;
    PCHAR local;
    ULONG64 NumberOfPfnEntries;

    UNREFERENCED_PARAMETER (args);
    UNREFERENCED_PARAMETER (Client);

    PfnDuration = GetExpression ("nt!MiPfnSorted");

    if (PfnDuration == 0) {
        dprintf("%08p: Unable to get PFN duration data.\n", PfnDuration);
        return E_INVALIDARG;
    }

    PfnEntry = PfnDuration;
    EntrySize =  GetTypeSize("nt!_MMPFNTIMINGS");

    NumberOfPfnEntries = GetUlongValue ("MiMaxPfnTimings");

    dprintf("Top %ld PFN lock holders sorted by duration\n", NumberOfPfnEntries);

    LocalData = LocalAlloc(LPTR, (ULONG) (NumberOfPfnEntries * EntrySize));

    if (!LocalData) {
        dprintf("unable to get allocate %ld bytes of memory\n",
                NumberOfPfnEntries * EntrySize);
        return E_INVALIDARG;
    }

    ReadCount = NumberOfPfnEntries * EntrySize;

    if ((!ReadMemory(PfnDuration,
                     LocalData,
                     (ULONG) ReadCount,
                     &result)) || (result < (ULONG) ReadCount)) {
        dprintf("unable to get PFN duration table - "
                "address %p - count %I64u\n",
                LocalData, ReadCount);
    }
    else {

        dprintf("\nDuration        LockAcquirer       LockReleaser\n");

        local = LocalData;

        for (i = 0; i < NumberOfPfnEntries; i += 1) {

            ULONG64   HoldTime=0, Address = 0;

            GetFieldValue(PfnEntry, "nt!_MMPFNTIMINGS", "HoldTime", HoldTime);
            GetFieldValue(PfnEntry, "nt!_MMPFNTIMINGS", "AcquiredAddress", AcquiredAddress);
            GetFieldValue(PfnEntry, "nt!_MMPFNTIMINGS", "ReleasedAddress", ReleasedAddress);

            //
            // Sign extend if necessary.
            //

            if (!IsPtr64()) {
                AcquiredAddress = (ULONG64)(LONG64)(LONG)AcquiredAddress;
                ReleasedAddress = (ULONG64)(LONG64)(LONG)ReleasedAddress;
            }

            //
            // Output a '*' if the lock was contended for, '.' if not.
            //

            dprintf( "%3d%c %I64ld ", (ULONG)i, HoldTime & 0x1 ? '*' : '.', HoldTime );

            SymbolBuffer[0] = '!';
            GetSymbol(AcquiredAddress, (PCHAR)SymbolBuffer, &displacement);
            SymPointer = SymbolBuffer;
            while (*SymPointer != '!') {
                SymPointer += 1;
            }
            SymPointer += 1;
            dprintf ("%s", SymPointer);
            if (displacement) {
                dprintf( "+0x%x", displacement );
            }
            dprintf( ", ");

            SymbolBuffer[0] = '!';
            GetSymbol(ReleasedAddress, (PCHAR)SymbolBuffer, &displacement);
            SymPointer = SymbolBuffer;
            while (*SymPointer != '!') {
                SymPointer += 1;
            }
            SymPointer += 1;
            dprintf ("%s", SymPointer);
            if (displacement) {
                dprintf( "+0x%x", displacement );
            }

            dprintf( "\n");

            PfnEntry += EntrySize;
        }
    }

    if (LocalData) {
        LocalFree((void *)LocalData);
    }

    return S_OK;
}


DECLARE_API( pfn )

/*++

Routine Description:

    Displays the corresponding PDE and PTE.

Arguments:

    arg - Supplies the Page frame number in hex.

Return Value:

    None.

--*/

{
    ULONG64 Address;
    ULONG64 PfnDb;
    ULONG64 Pfn;
    ULONG64 PfnStart;
    ULONG Flags;
    ULONG PfnSize;

    PfnSize = GetTypeSize("nt!_MMPFN");

    if (!PfnSize) {
        dprintf("unable to _MMPFN type.\n");
        return E_INVALIDARG;
    }

    PfnDb = GetNtDebuggerData( MmPfnDatabase );

    if (!PfnDb) {
        dprintf("unable to get PFN0 database address\n");
        return E_INVALIDARG;
    }

    PfnStart = 0;
    if (!ReadPointer(PfnDb,&PfnStart)) {
        dprintf("unable to get PFN database address %p\n", PfnDb);
        return E_INVALIDARG;
    }

    Address = 0;
    Flags = 0;


    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }

    if (Flags != 0) {
        
        if (!TargetIsDump) {
            ULONG64 CacheSize;
            
            Ioctl(IG_GET_CACHE_SIZE, &CacheSize, sizeof(CacheSize));

            if (TargetMachine == IMAGE_FILE_MACHINE_IA64) {
                if (CacheSize < 0x10000000) {
                    dprintf("CacheSize too low - increasing to 10M\n");
                    ExecuteCommand(Client, ".cache 10000");
                }
            } else if (CacheSize < 0x1000000) {
                dprintf("CacheSize too low - increasing to 1M\n");
                ExecuteCommand(Client, ".cache 1000");
            }
        }
        DumpWholePfn ( Address, Flags);
        return E_INVALIDARG;
    }

    if (Address >= PfnStart) {
        //
        // Ensure any passed in address is offsetted correctly.
        //
        Address = (Address - PfnStart) / PfnSize;
    }

    Pfn = (PfnStart + Address * PfnSize);

    PrintPfn64(Pfn);
    return S_OK;
}


VOID
DumpTerminalServerMemory (
    VOID
    )
{
    ULONG64 Next;
    ULONG64 SessionListPointer;
    ULONG64 SessionData;
    ULONG   SessionId;
    ULONG   SessionWsListLinksOffset;
    ULONG64 NonPagedPoolBytes;
    ULONG64 PagedPoolBytes;
    ULONG64 CommittedPages;
    ULONG   Failures;
    ULONG   TotalFailures;
    ULONG64 SessionPoolSize;
    ULONG64 SessionViewSize;

    dprintf("\n\tTerminal Server Memory Usage By Session:\n\n");

    // Get the offset of ActiveProcessLinks in _EPROCESS
    if (GetFieldOffset("nt!_MM_SESSION_SPACE", "WsListEntry", &SessionWsListLinksOffset)) {
       return;
    }

    SessionListPointer = GetExpression ("nt!MiSessionWsList");

    if (!SessionListPointer) {
        dprintf("Unable to get value of SessionListPointer\n");
        return;
    }

    if (GetFieldValue( SessionListPointer, "nt!_LIST_ENTRY", "Flink", Next )) {
        dprintf("Unable to read _LIST_ENTRY @ %p\n", SessionListPointer);
        return;
    }

    SessionPoolSize = GetUlongValue ("MmSessionPoolSize");
    SessionViewSize = GetUlongValue ("MmSessionViewSize");

    dprintf("\tSession Paged Pool Maximum is %ldK\n", SessionPoolSize / 1024);
    dprintf("\tSession View Space Maximum is %ldK\n", SessionViewSize / 1024);

    while(Next != SessionListPointer) {

        SessionData = Next - SessionWsListLinksOffset;

        if (GetFieldValue( SessionData, "nt!_MM_SESSION_SPACE", "SessionId", SessionId )) {
            dprintf("Unable to read _MM_SESSION_SPACE at %p\n",SessionData);
            return;
        }

        TotalFailures = 0;

        dprintf("\n\tSession ID %x @ %p:\n",SessionId, SessionData);

        GetFieldValue( SessionData, "nt!_MM_SESSION_SPACE", "NonPagedPoolBytes",
                       NonPagedPoolBytes );

        GetFieldValue( SessionData, "nt!_MM_SESSION_SPACE", "PagedPoolBytes",
                       PagedPoolBytes );

        GetFieldValue( SessionData, "nt!_MM_SESSION_SPACE", "CommittedPages",
                       CommittedPages );

        GetFieldValue( SessionData, "nt!_MM_SESSION_SPACE", "SessionPoolAllocationFailures[0]",
                       Failures);
        TotalFailures += Failures;

        GetFieldValue( SessionData, "nt!_MM_SESSION_SPACE", "SessionPoolAllocationFailures[1]",
                       Failures);
        TotalFailures += Failures;

        GetFieldValue( SessionData, "nt!_MM_SESSION_SPACE", "SessionPoolAllocationFailures[2]",
                       Failures);
        TotalFailures += Failures;

        GetFieldValue( SessionData, "nt!_MM_SESSION_SPACE", "SessionPoolAllocationFailures[3]",
                       Failures);
        TotalFailures += Failures;

        dprintf("\tNonpaged Pool Usage: %8I64ldK\n",NonPagedPoolBytes / 1024);
        dprintf("\tPaged Pool Usage:    %8I64ldK\n",PagedPoolBytes / 1024);

        if (TotalFailures != 0) {
            dprintf("\n\t*** %ld Pool Allocation Failures ***\n\n",TotalFailures);
        }

        dprintf("\tCommit Usage:        %8I64ldK\n",CommittedPages * _KB);

        GetFieldValue(SessionData, "nt!_MM_SESSION_SPACE", "WsListEntry.Flink", Next);

        if (CheckControlC()) {
            return;
        }
    }

    return;
}

#if (_MSC_VER < 1200) && defined(_M_IX86)
#pragma optimize("g", off)
#endif
DECLARE_API( vm )

/*++

Routine Description:

    Displays physical memory usage by driver.

Arguments:

    arg - Flags : 0 (default) == systemwide vm & per-process output.
                  1 == just systemwide vm counts, no per-process output.
                  2 == systemwide vm, per-process & Mm thread output.
                  3 == systemwide vm & Mm thread display, no per-process output.

Return Value:

    None.

--*/

{
    ULONG           Flags;
    ULONG           Index;
    ULONG64         MemorySize;
    ULONG64         CommitLimit;
    ULONG64         CommitTotal;
    ULONG64         SharedCommit;
    ULONG64         SpecialPoolPages;
    ULONG64         ProcessCommit;
    ULONG64         PagedPoolCommit;
    ULONG64         DriverCommit;
    ULONG64         ZeroPages;
    ULONG64         FreePages;
    ULONG64         StandbyPages;
    ULONG64         ModifiedPages;
    ULONG64         ModifiedNoWrite;
    ULONG64         NumberOfPagedPools;
    ULONG64         NumberOfPagingFiles;
    ULONG64         AvailablePages;
    ULONG64         LockPagesCount;
    ULONG64         SpecialPagesNonPaged;
    ULONG64         SpecialPagesNonPagedMaximum;
    ULONG64         FreePtesPointer;
    ULONG64         FreeNonPagedPtes;
    ULONG64         ResidentAvailablePages;
    ULONG64         PoolLoc;
    ULONG64         PoolLocBase;
    ULONG           result;
    ULONG           TotalPages;
    ULONG           ExtendedCommit;
    ULONG64         TotalProcessCommit;
    PPROCESS_COMMIT_USAGE ProcessCommitUsage;
    ULONG           i;
    ULONG           NumberOfProcesses;
    ULONG64         PagedPoolBytesMax;
    ULONG64         PagedPoolBytes;
    ULONG64         NonPagedPoolBytesMax;
    ULONG64         NonPagedPoolBytes;
    ULONG64         PageFileBase;
    ULONG64         PageFilePointer;
    ULONG           PageFileFullExtendPages;
    ULONG           PageFileFullExtendCount;
    PUCHAR          tempbuffer;
    UNICODE_STRING  unicodeString;
    ULONG64         PagedPoolInfoPointer;
    ULONG64         FreeSystemPtes;
    UCHAR           PagedPoolType[] = "nt!_MM_PAGED_POOL_INFO";
    ULONG64         AllocatedPagedPool=0;
    ULONG           Desc_TotalPages=0, TotalBigPages=0, Desc_size;
    ULONG           PtrSize = DBG_PTR_SIZE;
    ULONG           NumberOfNonPagedPools;
    ULONG64         ExpNumberOfNonPagedPools;

    Flags = 0;
    Flags = (ULONG) GetExpression(args);

    dprintf("\n*** Virtual Memory Usage ***\n");
    MemorySize = GetNtDebuggerDataValue(MmNumberOfPhysicalPages);
    dprintf ("\tPhysical Memory:  %8I64ld   (%8I64ld Kb)\n",MemorySize,_KB*MemorySize);
    NumberOfPagingFiles = GetNtDebuggerDataValue(MmNumberOfPagingFiles);
    PageFilePointer = GetExpression ("nt!MmPagingFile");
    if (NumberOfPagingFiles == 0) {
        dprintf("\n************ NO PAGING FILE *********************\n\n");
    } else {
        for (i = 0; i < NumberOfPagingFiles; i++) {
            ULONG64 PageFileName_Buffer=0;

            if (!ReadPointer(PageFilePointer, &PageFileBase)) {

                dprintf("%08p: Unable to get page file\n",PageFilePointer);
                break;
            }

            if (GetFieldValue(PageFileBase,
                              "nt!_MMPAGING_FILE",
                              "PageFileName.Buffer",
                              PageFileName_Buffer)) {

                dprintf("%08p: Unable to get page file\n",PageFilePointer);
                break;
            }

            InitTypeRead(PageFileBase, nt!_MMPAGING_FILE);

            if (PageFileName_Buffer == 0) {
                dprintf("\tNo Name for Paging File\n\n");
            } else {

                unicodeString.Length = (USHORT) ReadField(PageFileName.Length);

                tempbuffer = LocalAlloc(LPTR, unicodeString.Length);

                unicodeString.Buffer = (PWSTR)tempbuffer;
                unicodeString.MaximumLength = unicodeString.Length;

                if (!ReadMemory ( PageFileName_Buffer,
                                  tempbuffer,
                                  unicodeString.Length,
                                  &result)) {
                    dprintf("\tPaging File Name paged out\n");
                } else {
                    dprintf("\tPage File: %wZ\n", &unicodeString);
                }

                LocalFree(tempbuffer);

            }

            dprintf("\t   Current: %9I64ldKb Free Space: %9I64ldKb\n",
                    ReadField(Size)*_KB,
                    ReadField(FreeSpace)*_KB);
            dprintf("\t   Minimum: %9I64ldKb Maximum:    %9I64ldKb\n",
                    ReadField(MinimumSize)*_KB,
                    ReadField(MaximumSize)*_KB);
            PageFilePointer += PtrSize;
        }
    }

    PagedPoolInfoPointer = GetExpression ("nt!MmPagedPoolInfo");

    if (GetFieldValue(PagedPoolInfoPointer,
                      PagedPoolType,
                      "AllocatedPagedPool",
                      AllocatedPagedPool)) {

        dprintf("%08p: Unable to get paged pool info %p\n",PagedPoolInfoPointer);
    }

    PagedPoolBytesMax       = GetNtDebuggerDataValue(MmSizeOfPagedPoolInBytes);
    PagedPoolBytes          = AllocatedPagedPool;
    PagedPoolBytes          *= PageSize;
    NonPagedPoolBytesMax    = GetNtDebuggerDataValue(MmMaximumNonPagedPoolInBytes);
    NonPagedPoolBytes       = GetUlongValue ("MmAllocatedNonPagedPool");
    NonPagedPoolBytes       *= PageSize;
    CommitLimit             = GetNtDebuggerDataValue(MmTotalCommitLimit);
    CommitTotal             = GetNtDebuggerDataValue(MmTotalCommittedPages);
    SharedCommit            = GetNtDebuggerDataValue(MmSharedCommit);
    DriverCommit            = GetNtDebuggerDataValue(MmDriverCommit);
    ProcessCommit           = GetNtDebuggerDataValue(MmProcessCommit);
    PagedPoolCommit         = GetNtDebuggerDataValue(MmPagedPoolCommit);
    ZeroPages               = GetNtDebuggerDataValue(MmZeroedPageListHead);
    FreePages               = GetNtDebuggerDataValue(MmFreePageListHead);
    StandbyPages            = GetNtDebuggerDataValue(MmStandbyPageListHead);
    ModifiedPages           = GetNtDebuggerDataValue(MmModifiedPageListHead);
    ModifiedNoWrite         = GetNtDebuggerDataValue(MmModifiedNoWritePageListHead);
    AvailablePages          = GetNtDebuggerDataValue(MmAvailablePages);
    ResidentAvailablePages  = GetNtDebuggerDataValue(MmResidentAvailablePages);

    if (BuildNo < 2257) {
        ExtendedCommit          = GetUlongValue("MmExtendedCommit");
        PageFileFullExtendPages = GetUlongValue("MmPageFileFullExtendPages");
        PageFileFullExtendCount = GetUlongValue("MmPageFileFullExtendCount");
    }
    FreeSystemPtes          = GetUlongValue("MmTotalFreeSystemPtes");
    LockPagesCount          = GetUlongValue("MmSystemLockPagesCount");
    SpecialPagesNonPaged    = GetUlongValue("MiSpecialPagesNonPaged");
    SpecialPagesNonPagedMaximum = GetUlongValue("MiSpecialPagesNonPagedMaximum");

    FreePtesPointer = GetExpression ("nt!MmTotalFreeSystemPtes");

    FreePtesPointer += sizeof(ULONG);
    FreeNonPagedPtes = 0;
    if (!ReadMemory (FreePtesPointer, &FreeNonPagedPtes, sizeof(ULONG), &result)) {
        dprintf("\tError reading free nonpaged PTEs %p\n", FreePtesPointer);
    }

    SpecialPoolPages        = GetUlongValue("nt!MmSpecialPagesInUse");

    dprintf("\tAvailable Pages:  %8I64ld   (%8I64ld Kb)\n",AvailablePages, AvailablePages*_KB);
    dprintf("\tResAvail Pages:   %8I64ld   (%8I64ld Kb)\n",ResidentAvailablePages, ResidentAvailablePages*_KB);

    if ((LONG64) (ResidentAvailablePages - LockPagesCount) < 100) {

        dprintf("\n\t********** Running out of physical memory **********\n\n");
    }
    dprintf("\tLocked IO Pages:  %8I64ld   (%8I64ld Kb)\n",LockPagesCount,_KB*LockPagesCount);
    dprintf("\tFree System PTEs: %8I64ld   (%8I64ld Kb)\n",FreeSystemPtes,_KB*FreeSystemPtes);
    dprintf("\tFree NP PTEs:     %8I64ld   (%8I64ld Kb)\n",FreeNonPagedPtes,_KB*FreeNonPagedPtes);
    dprintf("\tFree Special NP:  %8I64ld   (%8I64ld Kb)\n",
                (SpecialPagesNonPagedMaximum - SpecialPagesNonPaged),
                _KB*(SpecialPagesNonPagedMaximum - SpecialPagesNonPaged));

    dprintf("\tModified Pages:   %8I64ld   (%8I64ld Kb)\n",ModifiedPages,ModifiedPages*_KB);
    if ((AvailablePages < 50) && (ModifiedPages > 200)) {
        dprintf("\t********** High Number Of Modified Pages ********\n");
    }

    if (ModifiedNoWrite > ((MemorySize / 100) * 3)) {
        dprintf("\t********** High Number Of Modified No Write Pages ********\n");
        dprintf("\tModified No Write Pages: %I64ld   (%8I64ld Kb)\n",
                ModifiedNoWrite,_KB*ModifiedNoWrite);
    }

    //
    // Dump all the nonpaged pools.
    //

    PoolLoc = GetNtDebuggerData(NonPagedPoolDescriptor );
    Desc_TotalPages = 0; TotalBigPages=0;
    if ( !PoolLoc ||
         GetFieldValue(PoolLoc,
                       "nt!_POOL_DESCRIPTOR",
                       "TotalPages",
                       Desc_TotalPages)) {

        dprintf("%08p: Unable to get pool descriptor\n",PoolLoc);
        return E_INVALIDARG;
    }

    Desc_size = GetTypeSize("nt!_POOL_DESCRIPTOR");

    if (ExpNumberOfNonPagedPools = GetExpression("nt!ExpNumberOfNonPagedPools")) {
        NumberOfNonPagedPools = GetUlongFromAddress (ExpNumberOfNonPagedPools);
    } else {
        NumberOfNonPagedPools = 0;
    }

    if (NumberOfNonPagedPools > 1) {

        TotalPages = 0;

        PoolLocBase = GetExpression ("nt!ExpNonPagedPoolDescriptor");

        if (PoolLocBase != 0) {

            for (Index = 0; Index < NumberOfNonPagedPools; Index += 1) {

                if (!ReadPointer(PoolLocBase, &PoolLoc)) {

                    dprintf("%08p: Unable to get nonpaged pool info\n",PoolLocBase);
                    break;
                }

                if (GetFieldValue(PoolLoc,
                              "nt!_POOL_DESCRIPTOR",
                              "TotalPages",
                              Desc_TotalPages)) {

                    dprintf("%08p: Unable to get pool descriptor\n",PoolLoc);
                    return E_INVALIDARG;
                }
                GetFieldValue(PoolLoc,"_POOL_DESCRIPTOR","TotalBigPages",TotalBigPages);

                dprintf("\tNonPagedPool %1ld Used: %5ld   (%8ld Kb)\n",
                    Index,
                    Desc_TotalPages + TotalBigPages,
                    _KB*(Desc_TotalPages + TotalBigPages));

                TotalPages += Desc_TotalPages + TotalBigPages;
                PoolLocBase += PtrSize;
            }
        }
    }

    GetFieldValue(PoolLoc,"nt!_POOL_DESCRIPTOR","TotalBigPages",TotalBigPages);

    if (NumberOfNonPagedPools > 1) {
        dprintf("\tNonPagedPool Usage:  %5ld   (%8ld Kb)\n", TotalPages,_KB*TotalPages);
    }
    else {
        dprintf("\tNonPagedPool Usage:  %5ld   (%8ld Kb)\n", Desc_TotalPages + TotalBigPages,
                            _KB*(Desc_TotalPages + TotalBigPages));
    }

    dprintf("\tNonPagedPool Max:    %5I64ld   (%8I64ld Kb)\n", NonPagedPoolBytesMax/PageSize,_KB*(NonPagedPoolBytesMax/PageSize));

    if ((Desc_TotalPages + TotalBigPages) > 4 * ((NonPagedPoolBytesMax / PageSize) / 5)) {
        dprintf("\t********** Excessive NonPaged Pool Usage *****\n");
    }

    //
    // Dump all the paged pools.
    //

    NumberOfPagedPools = GetNtDebuggerDataValue(ExpNumberOfPagedPools);

    TotalPages = 0;

    PoolLocBase = GetExpression ("nt!ExpPagedPoolDescriptor");

    if ((PoolLocBase != 0) && (NumberOfPagedPools != 0)) {

        for (Index = 0; (Index < (NumberOfPagedPools + 1)) ; Index += 1) {

            if (Index && (BuildNo <= 2464)) {
                PoolLoc += Desc_size;
            } else {
                if (!ReadPointer(PoolLocBase, &PoolLoc)) {

                    dprintf("%08p: Unable to get paged pool info\n",PoolLocBase);
                    break;
                }

            }
            
            if (GetFieldValue(PoolLoc,
                              "nt!_POOL_DESCRIPTOR",
                              "TotalPages",
                              Desc_TotalPages)) {

                dprintf("%08p: Unable to get pool descriptor, PagedPool usage may be wrong\n",PoolLoc);
                break;
            }
            GetFieldValue(PoolLoc,"nt!_POOL_DESCRIPTOR","TotalBigPages",TotalBigPages);

            dprintf("\tPagedPool %1ld Usage:   %5ld   (%8ld Kb)\n",
                    Index,
                    Desc_TotalPages + TotalBigPages,
                    _KB*(Desc_TotalPages + TotalBigPages));
            
            TotalPages += Desc_TotalPages + TotalBigPages;
            PoolLocBase += PtrSize;
            
        }
    }

    if (PagedPoolBytes > 95 * (PagedPoolBytesMax/ 100)) {
        dprintf("\t********** Excessive Paged Pool Usage *****\n");
    }

    dprintf("\tPagedPool Usage:     %5ld   (%8ld Kb)\n", TotalPages,_KB*TotalPages);
    dprintf("\tPagedPool Maximum:   %5I64ld   (%8I64ld Kb)\n", PagedPoolBytesMax/PageSize,_KB*(PagedPoolBytesMax/PageSize));
    dprintf("\tShared Commit:    %8I64ld   (%8I64ld Kb)\n",SharedCommit,_KB*SharedCommit   );
    dprintf("\tSpecial Pool:     %8I64ld   (%8I64ld Kb)\n",SpecialPoolPages,_KB*SpecialPoolPages   );
    dprintf("\tShared Process:   %8I64ld   (%8I64ld Kb)\n",ProcessCommit,_KB*ProcessCommit  );

    dprintf("\tPagedPool Commit: %8I64ld   (%8I64ld Kb)\n",PagedPoolCommit,_KB*PagedPoolCommit);
    dprintf("\tDriver Commit:    %8I64ld   (%8I64ld Kb)\n",DriverCommit, _KB*DriverCommit   );
    dprintf("\tCommitted pages:  %8I64ld   (%8I64ld Kb)\n",CommitTotal,  _KB*CommitTotal    );
    dprintf("\tCommit limit:     %8I64ld   (%8I64ld Kb)\n",CommitLimit,  _KB*CommitLimit    );
    if ((CommitTotal + 100) > CommitLimit) {
        dprintf("\n\t********** Number of committed pages is near limit ********\n");
    }
    if (BuildNo < 2257) {
        if (ExtendedCommit != 0) {
            dprintf("\n\t********** Commit has been extended with VM popup ********\n");
            dprintf("\tExtended by:     %8ld   (%8ld Kb)\n", ExtendedCommit,_KB*ExtendedCommit);
        }

        if (PageFileFullExtendCount) {
            if (PageFileFullExtendCount == 1) {
                dprintf("\n\t****** ALL PAGING FILE BECAME FULL ONCE - COMMITMENT ADJUSTED ****\n", PageFileFullExtendCount);
            }
            else {
                dprintf("\n\t****** ALL PAGING FILE BECAME FULL (%u times) - COMMITMENT ADJUSTED ****\n", PageFileFullExtendCount);
            }
            dprintf("\tCurrent adjust:  %8ld   (%8ld Kb)\n",
                    PageFileFullExtendPages,
                    _KB*PageFileFullExtendPages);
        }
    }
    dprintf("\n");

    if ((Flags & 0x1) == 0) {

        ProcessCommitUsage = GetProcessCommit( &TotalProcessCommit, &NumberOfProcesses );
        if (ProcessCommitUsage == NULL)
        {
            dprintf("\nProcessCommitUsage could not be calculated\n");
        }
        else
        {
            if (TotalProcessCommit != 0) {
                dprintf("\tTotal Private:    %8I64ld   (%8I64ld Kb)\n",
                        TotalProcessCommit,_KB*TotalProcessCommit);
            }

            for (i=0; i<NumberOfProcesses; i++) {
                dprintf( "         %04I64lx %-15s %6I64d (%8I64ld Kb)\n",
                         ProcessCommitUsage[i].ClientId,
                         ProcessCommitUsage[i].ImageFileName,
                         ProcessCommitUsage[i].CommitCharge,
                         _KB*(ProcessCommitUsage[i].CommitCharge)
                         );
            }
            HeapFree(GetProcessHeap(), 0, ProcessCommitUsage);
        }
    }

    if (Flags & 0x2) {
        if (Client &&
            (ExtQuery(Client) == S_OK)) {

            dprintf("\n\tMemory Management Thread Stacks:\n");
            DumpMmThreads ();

            ExtRelease();
        }
    }

    if (Flags & 0x4) {
        if (Client &&
            (ExtQuery(Client) == S_OK)) {

            DumpTerminalServerMemory ();

            ExtRelease();
        }
    }

    return S_OK;
}

#if (_MSC_VER < 1200) && defined(_M_IX86)
#pragma optimize("", on)
#endif

VOID
DumpWholePfn(
    IN ULONG64 Address,
    IN ULONG Flags
    )

/*++

Routine Description:

    Dumps the PFN database

Arguments:

    Address - address to dump at
    Flags -

Return Value:

    None.

--*/

{
    ULONG result;
    ULONG64 HighPage;
    ULONG64 LowPage;
    ULONG64 PageCount;
    ULONG64 ReadCount;
    ULONG64 i;
    ULONG64 Pfn;
    ULONG64 PfnStart;
    PUCHAR  PfnArray;
    PUCHAR  PfnArrayPointer;
    ULONG64 VirtualAddress;
    ULONG   MatchLocation;
    BOOLEAN foundlink;
    BOOLEAN RandomAccessRequired;
    ULONG   PfnSize;
    ULONG   NumberOfPfnToRead;
    ULONG   sz;
    MMPFNENTRY u3_e1;
    CHAR    InPageError;

    LowPage  = GetNtDebuggerDataValue(MmLowestPhysicalPage);
    HighPage = GetNtDebuggerDataValue(MmHighestPhysicalPage);
    PfnStart = GetNtDebuggerDataPtrValue(MmPfnDatabase);

    PfnSize =  GetTypeSize("nt!_MMPFN");

    //
    // Read sufficient pages such that htere isn't lot of wait
    // before first page dump.
    //

    NumberOfPfnToRead =  2000;

    PfnArray = NULL;

    if (Flags == 7) {
        RandomAccessRequired = TRUE;
    }
    else {
        RandomAccessRequired = FALSE;
    }

    if (RandomAccessRequired == FALSE) {
        dprintf("\n Page    Flink  Blk/Shr Ref V    PTE   Address  SavedPTE Frame  State\n");
    }

    //
    // If asked to dump the whole database or we're going to need the ability
    // to look up random frames, then read in the whole database now.
    //

    if (Address == 0 || RandomAccessRequired == TRUE) {

        PfnArray = LocalAlloc(LPTR, (ULONG) (HighPage+1) * PfnSize);
        if (!PfnArray) {
            dprintf("unable to get allocate %ld bytes of memory\n",
                    (HighPage+1) * PfnSize);
            return;
        }

        for (PageCount = LowPage;
             PageCount <= HighPage;
             PageCount += NumberOfPfnToRead) {

            if (CheckControlC()) {
                goto alldone;
            }

            ReadCount = HighPage - PageCount > NumberOfPfnToRead ?
                            NumberOfPfnToRead :
                            HighPage - PageCount + 1;

            ReadCount *= PfnSize;

            Pfn = (PfnStart + PageCount * PfnSize);

            PfnArrayPointer = (PUCHAR)(PfnArray + (ULONG) PageCount * PfnSize);

            //
            // KD caches the Pfns
            //
            if ((!ReadMemory(Pfn,
                             PfnArrayPointer,
                             (ULONG) ReadCount,
                             &result)) || (result < (ULONG) ReadCount)) {
                dprintf("unable to get PFN table block - "
                        "address %p - count %I64u - page %I64lu\n",
                        Pfn, ReadCount, PageCount);
                goto alldone;
            }
            for (i = PageCount;
                 (i < PageCount + NumberOfPfnToRead) && (i < HighPage);
                 i += 1, Pfn = (Pfn + PfnSize)) {
                ULONG u3_e2_ReferenceCount=0;
                ULONG64   u1_Flink=0, u2_Blink=0, PteAddress=0, OriginalPte=0, PteFrame=0;

                if (RandomAccessRequired == TRUE) {
                    if ((i % 256 ) == 0) {
                        dprintf(".");       // every 256 pages, print a dot
                    }
                }
                else {
                    GetFieldValue(Pfn, "nt!_MMPFN", "u1.Flink",  u1_Flink);
                    GetFieldValue(Pfn, "nt!_MMPFN", "u2.Blink",  u2_Blink);
                    GetFieldValue(Pfn, "nt!_MMPFN", "PteAddress",PteAddress);
                    GetFieldValue(Pfn, "nt!_MMPFN", "OriginalPte",OriginalPte);
                    GetFieldValue(Pfn, "nt!_MMPFN", "u3.e2.ReferenceCount", u3_e2_ReferenceCount);
                    GetFieldValue(Pfn, "nt!_MMPFN", "u3.e1", u3_e1);

                    if (GetFieldValue(Pfn, "nt!_MMPFN", "u4.PteFrame", PteFrame) == FIELDS_DID_NOT_MATCH) {
                        GetFieldValue(Pfn, "nt!_MMPFN", "u3.e1.InPageError", InPageError);
                        GetFieldValue(Pfn, "nt!_MMPFN", "PteFrame", PteFrame);
                    } else {
                        GetFieldValue(Pfn, "nt!_MMPFN", "u4.InPageError", InPageError);
                    }

                    if (u3_e1.PrototypePte == 0) {
                        VirtualAddress = DbgGetVirtualAddressMappedByPte(PteAddress);
                    } else {
                        VirtualAddress = 0;
                    }

                    dprintf("%5I64lx %8p %8p%6x %8p %8p ",
                            i,
                            u1_Flink,
                            u2_Blink,
                            u3_e2_ReferenceCount,
                            PteAddress,
                            VirtualAddress);

                    dprintf("%8p ", OriginalPte);

                    dprintf("%6I64lx ", PteFrame);

                    dprintf("%s %c%c%c%c%c%c\n",
                        PageLocationList[u3_e1.PageLocation],
                        u3_e1.Modified ? 'M':' ',
                        u3_e1.PrototypePte ? 'P':' ',
                        u3_e1.ReadInProgress ? 'R':' ',
                        u3_e1.WriteInProgress ? 'W':' ',
                        InPageError ? 'E':' ',
                        u3_e1.ParityError ? 'X':' '
                        );
                }

                if (CheckControlC()) {
                    goto alldone;
                }
            }
        }

        if (RandomAccessRequired == TRUE) {
            dprintf("\n");
        }
        else {
            goto alldone;
        }
    }

    dprintf("\n Page    Flink  Blk/Shr Ref V    PTE   Address  SavedPTE Frame  State\n");

    Pfn = (PfnStart + Address * PfnSize);

    if (GetFieldValue(Pfn, "nt!_MMPFN", "u3.e1",  u3_e1)) {
        dprintf("unable to get PFN element\n");
        goto alldone;
    }
    MatchLocation = u3_e1.PageLocation;

    do {
        ULONG u3_e2_ReferenceCount=0;
        ULONG64   u1_Flink=0, u2_Blink=0, PteAddress=0, OriginalPte=0, PteFrame=0;

        if (CheckControlC()) {
            goto alldone;
        }

        Pfn = (PfnStart + Address * PfnSize);

        sz = sizeof (u3_e1);
        GetFieldValue(Pfn, "nt!_MMPFN", "u3.e1", u3_e1);

        if (u3_e1.PrototypePte == 0) {
            VirtualAddress = DbgGetVirtualAddressMappedByPte ( PteAddress);
        } else {
            VirtualAddress = 0;
        }
        if (u3_e1.PageLocation == MatchLocation) {
            GetFieldValue(Pfn, "nt!_MMPFN", "u1.Flink",   u1_Flink);
            GetFieldValue(Pfn, "nt!_MMPFN", "u2.Blink",   u2_Blink);
            GetFieldValue(Pfn, "nt!_MMPFN", "PteAddress", PteAddress);
            GetFieldValue(Pfn, "nt!_MMPFN", "OriginalPte",OriginalPte);
            GetFieldValue(Pfn, "nt!_MMPFN", "u3.e2.ReferenceCount", u3_e2_ReferenceCount);
            if(GetFieldValue(Pfn, "nt!_MMPFN", "u4.PteFrame",   PteFrame) == FIELDS_DID_NOT_MATCH) {
        GetFieldValue(Pfn, "nt!_MMPFN", "u3.e1.InPageError", InPageError);
        GetFieldValue(Pfn, "nt!_MMPFN", "PteFrame",   PteFrame);
        } else {
        GetFieldValue(Pfn, "nt!_MMPFN", "u4.InPageError", InPageError);
        }


            dprintf("%5I64lx %8p %8p%6x %8p %8p ",
                    Address,
                    u1_Flink,
                    u2_Blink,
                    u3_e2_ReferenceCount,
                    PteAddress,
                    VirtualAddress);

            dprintf("%8p ", OriginalPte);

            dprintf("%6I64lx ", PteFrame);

            dprintf("%s %c%c%c%c%c%c\n",
                PageLocationList[u3_e1.PageLocation],
                u3_e1.Modified ? 'M':' ',
                u3_e1.PrototypePte ? 'P':' ',
                u3_e1.ReadInProgress ? 'R':' ',
                u3_e1.WriteInProgress ? 'W':' ',
                InPageError ? 'E':' ',
                u3_e1.ParityError ? 'X':' '
                );

        }

        if (MatchLocation > 5) {
            Address += 1;
        } else {
            ULONG64 OriginalPte_u_Long=0;
            sz = sizeof (OriginalPte_u_Long);
            if (Flags == 7) {
                ULONG64 P;
                //
                // Search the whole database for an OriginalPte field that
                // points to this PFN - we must do this because this chain
                // is singly (not doubly) linked.
                //
                foundlink = FALSE;
                P = PfnStart;
                for (i = 0; i <= HighPage; i += 1, P += PfnSize) {
                    GetFieldValue(P, "nt!_MMPFN", "OriginalPte.u.Long", OriginalPte_u_Long);
                    if (OriginalPte_u_Long == Address) {
                        Address = i;
                        foundlink = TRUE;
                        break;
                    }
                }
                if (foundlink == FALSE) {
                    dprintf("No OriginalPte chain found for %lx\n", Address);
                    break;
                }
            } else if (Flags == 5) {
                GetFieldValue(Pfn, "nt!_MMPFN", "OriginalPte.u.Long", OriginalPte_u_Long);
                Address = OriginalPte_u_Long;
            } else if (Flags == 3) {
                Address = u2_Blink;
            } else {
                Address = u1_Flink;
            }
        }

        if (CheckControlC()) {
            goto alldone;
        }
    } while (Address < HighPage);

alldone:

    if (PfnArray) {
        LocalFree((void *)PfnArray);
    }
}

VOID
PrintPfn64 (
    IN ULONG64 PfnAddress
    )
{
    MMPFNENTRY u3_e1;
    ULONG64 PfnDb, PfnStart;
    ULONG   PfnSize;
    ULONG   CacheAttribute;
    CHAR    InPageError, VerifierAllocation;

    if ((PfnSize = GetTypeSize("nt!_MMPFN")) == 0) {
        dprintf("Type _MMPFN not found.\n");
        return;
    }


    PfnDb = GetNtDebuggerData(MmPfnDatabase);
    if (!ReadPointer(PfnDb, &PfnStart)) {
        dprintf("%08P: Unable to get PFN database start\n",PfnDb);
        return;
    }

    if (!IsPtr64()) {
        PfnAddress = (ULONG64) (LONG64) (LONG) PfnAddress;
    }

    dprintf("    PFN %08P at address %08P\n",
            (PfnAddress - PfnStart) / PfnSize,
            PfnAddress);

    InitTypeRead(PfnAddress, nt!_MMPFN);

    dprintf("    flink       %08P", ReadField(u1.Flink));
    dprintf("  blink / share count %08P", ReadField(u2.Blink));
    dprintf("  pteaddress %08P\n", ReadField(PteAddress));

    GetFieldValue(PfnAddress, "nt!_MMPFN", "u3.e1", u3_e1);

    switch (TargetMachine) {
        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_AMD64:
            dprintf("    reference count %04hX    used entry count  %04hX      %s color %01hX\n",
                (ULONG) ReadField(u3.e2.ReferenceCount),
                (ULONG) ReadField(UsedPageTableEntries),
                PageAttribute[u3_e1.CacheAttribute],
                u3_e1.PageColor);
            break;
        default:
            dprintf("    reference count %04hX   %s  color %01hX\n",
                (ULONG) ReadField(u3.e2.ReferenceCount),
                PageAttribute[u3_e1.CacheAttribute],
                u3_e1.PageColor);
            break;
    }

    dprintf("    restore pte %08I64X  ", ReadField(OriginalPte));

    if (BuildNo < 2440) {
        dprintf("containing page        %06P  ", ReadField(PteFrame));
        InPageError = (CHAR) ReadField(u3.e1.InPageError);
        VerifierAllocation = (CHAR) ReadField(u3.e1.VerifierAllocation);
    } else {
        dprintf("containing page        %06P  ", ReadField(u4.PteFrame));
        InPageError = (CHAR) ReadField(u4.InPageError);
        VerifierAllocation = (CHAR) ReadField(u4.VerifierAllocation);
    }

    dprintf("%s   %c%c%c%c%c%c\n",
                PageLocationList[u3_e1.PageLocation],
                u3_e1.Modified ? 'M':' ',
                u3_e1.PrototypePte ? 'P':' ',
                u3_e1.ReadInProgress ? 'R':' ',
                u3_e1.WriteInProgress ? 'W':' ',
                InPageError ? 'E':' ',
                u3_e1.ParityError ? 'X':' ',
                u3_e1.RemovalRequested ? 'Y':' ',
                VerifierAllocation ? 'V':' '
                );

    dprintf("    %s %s %s %s %s %s\n",
                u3_e1.Modified ? "Modified":" ",
                u3_e1.PrototypePte ? "Shared":" ",
                u3_e1.ReadInProgress ? "ReadInProgress":" ",
                u3_e1.WriteInProgress ? "WriteInProgress":" ",
                InPageError ? "InPageError":" ",
                u3_e1.ParityError ? "ParityError":" ",
                u3_e1.RemovalRequested ? "RemovalRequested":" ",
                VerifierAllocation ? "VerifierAllocation":" ");

    return;
}



VOID
MemoryUsage (
    IN ULONG64 PfnStart,
    IN ULONG64 LowPage,
    IN ULONG64 HighPage,
    IN ULONG IgnoreInvalidFrames
    )

/*++

Routine Description:

    This routine (debugging only) dumps the current memory usage by
    walking the PFN database.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG PfnSize;
    ULONG64 LastPfn;
    ULONG64 Pfn1;
    ULONG64 Pfn2;
    ULONG64 Subsection1;
    UNICODE_STRING NameString;
    PPFN_INFO Info;
    PPFN_INFO Info1;
    PPFN_INFO InfoStart;
    PPFN_INFO InfoEnd;
    ULONG InfoSize;
    PFN_INFO ProcessPfns;
    PFN_INFO PagedPoolBlock;
    PPFN_INFO LastProcessInfo = &ProcessPfns;
    ULONG64 Master;
    ULONG64 ControlArea1;
    BOOLEAN Found;
    ULONG result;
    ULONG i;
    ULONG64 PagedPoolStart;
    ULONG64 VirtualAddress;
    ULONG64 MmNonPagedPoolEnd;
    ULONG64 PteFrame;
    ULONG   OriginalPteOffset;
    ULONG   PercentComplete=0;
    PKERN_MAP pKernelMap;

    // Get the offset of OriginalPte in MMPFN
    if (GetFieldOffset("nt!_MMPFN", "OriginalPte", &OriginalPteOffset)) {
        dprintf("Cannot find _MMPFN type");
        return ;
    }

    ProcessPfns.Next = NULL;
    MmNonPagedPoolEnd = GetNtDebuggerDataPtrValue(MmNonPagedPoolEnd);

    NameString.MaximumLength = sizeof(WCHAR) * 1000;
    NameString.Buffer = calloc(1, NameString.MaximumLength);

    if (!NameString.Buffer) {
        return;
    }

    PagedPoolStart = GetNtDebuggerDataPtrValue(MmPagedPoolStart);
    pKernelMap = calloc(1, sizeof(*pKernelMap));
    if (!pKernelMap) {
        free(NameString.Buffer);
        return;
    }

    dprintf ("  Building kernel map\n");

    if (BuildKernelMap (pKernelMap) == FALSE) {
        free(pKernelMap);
        free(NameString.Buffer);
        return;
    }

    dprintf ("  Finished building kernel map\n");

    RtlZeroMemory (&PagedPoolBlock, sizeof (PFN_INFO));

    PfnSize = GetTypeSize("nt!_MMPFN");

    LastPfn = (PfnStart + HighPage * PfnSize);

    if (MmSubsectionBase == 0) {
        MmSubsectionBase = GetNtDebuggerDataValue(MmSubsectionBase);
    }

    //
    // Allocate a chunk of memory to hold PFN information.  This is resized
    // if it is later determined that the current size is not large enough.
    //

    InfoSize = USAGE_ALLOC_SIZE;

restart:

    InfoStart = VirtualAlloc (NULL,
                              InfoSize,
                              MEM_COMMIT,
                              PAGE_READWRITE);

    if (InfoStart == NULL) {
        dprintf ("heap allocation for %d bytes failed\n", InfoSize);
        free(pKernelMap);
        free(NameString.Buffer);
        return;
    }

    InfoEnd = InfoStart;

    Pfn1 = (PfnStart + LowPage * PfnSize);

    while (Pfn1 < LastPfn) {
        ULONG PageLocation=0, PrototypePte=0, ReferenceCount=0;
        ULONG Comp;
        ULONG64 ShareCount=0, PteFrame1=0, PteAddress;

        Comp = ((ULONG) (Pfn1  - (PfnStart + LowPage * PfnSize)))*100 /
                ((ULONG) (LastPfn -(PfnStart + LowPage * PfnSize)));
        if (Comp > PercentComplete) {
            PercentComplete = Comp;
            dprintf("Scanning PFN database - (%02d%% complete) \r", PercentComplete);
        }

        if (CheckControlC()) {
            VirtualFree (InfoStart,0,MEM_RELEASE);
            free(pKernelMap);
            free(NameString.Buffer);
            return;
        }

        GetFieldValue(Pfn1, "nt!_MMPFN", "u3.e1.PageLocation", PageLocation);

        if ((PageLocation != FreePageList) &&
            (PageLocation != ZeroedPageList) &&
            (PageLocation != BadPageList)) {

            GetFieldValue(Pfn1, "nt!_MMPFN", "u3.e1.PrototypePte", PrototypePte);
            GetFieldValue(Pfn1, "nt!_MMPFN", "u3.e2.ReferenceCount", ReferenceCount);
            GetFieldValue(Pfn1, "nt!_MMPFN", "u2.ShareCount", ShareCount);
            GetFieldValue(Pfn1, "nt!_MMPFN", "PteAddress", PteAddress);

        if (GetFieldValue(Pfn1, "nt!_MMPFN", "u4.PteFrame", PteFrame1) == FIELDS_DID_NOT_MATCH) {
        GetFieldValue(Pfn1, "nt!_MMPFN", "PteFrame", PteFrame1);
        }

            Subsection1 = 0;
            if (PrototypePte) {
                Subsection1 = DbgGetSubsectionAddress (Pfn1 + OriginalPteOffset);
            }

            if ((Subsection1) && (Subsection1 < 0xffffffffffbff000UI64)) {
                Master = Subsection1;
            } else {

                PteFrame = PteFrame1;
                if (IgnoreInvalidFrames) {
                    Master = PteFrame;
                } else {
//          dprintf("Pteaddr %p, PagedPoolStart %I64x ", PteAddress, PagedPoolStart);

                    if (PteAddress > PagedPoolStart) {
                        Master = PteFrame;
                    } else {
                        Master=0;

                        Pfn2 = PfnStart + PteFrame*PfnSize;

                        if (GetFieldValue(Pfn2, "nt!_MMPFN", "PteFrame", Master) == FIELDS_DID_NOT_MATCH) {
                GetFieldValue(Pfn2, "nt!_MMPFN", "u4.PteFrame", Master);
            }
//                        Master = MI_PFN_PTE   FRAME(Pfn2);

                        if ((Master == 0) || (Master > HighPage)) {
                            dprintf("Invalid PTE frame\n");
//                            PrintPfn((PVOID)(((PCHAR)Pfn1-(PCHAR)PfnStart)/PfnSize),Pfn1);
                            PrintPfn64(Pfn1);
                            PrintPfn64(Pfn2);
                            dprintf("  subsection address: %p\n",Subsection1);
                            goto NextPfn;
                        }
                    }
                }
            }

            //
            // Tally any pages which are not protos and have a valid PTE
            // address field.
            //

            if ((PteAddress < PagedPoolStart) && (PteAddress >= DbgGetPteAddress(SystemRangeStart) )) {

                for (i=0; i<pKernelMap->Count; i++) {

                    VirtualAddress = DbgGetVirtualAddressMappedByPte (PteAddress);
                    if ((VirtualAddress >= pKernelMap->Item[i].StartVa) &&
                        (VirtualAddress < pKernelMap->Item[i].EndVa)) {

                        if ((PageLocation == ModifiedPageList) ||
                            (PageLocation == ModifiedNoWritePageList)) {
                            pKernelMap->Item[i].ModifiedCount += _KB;
                            if (ReferenceCount > 0) {
                                pKernelMap->Item[i].LockedCount += _KB;
                            }
                        } else if ((PageLocation == StandbyPageList) ||
                                  (PageLocation == TransitionPage)) {

                            pKernelMap->Item[i].StandbyCount += _KB;
                            if (ReferenceCount > 0) {
                                pKernelMap->Item[i].LockedCount += _KB;
                            }
                        } else {
                            pKernelMap->Item[i].ValidCount += _KB;
                            if (ShareCount > 1) {
                                pKernelMap->Item[i].SharedCount += _KB;
                                if (ReferenceCount > 1) {
                                    pKernelMap->Item[i].LockedCount += _KB;
                                }
                            }
                        }
                        goto NextPfn;
                    }
                }
            }

            if (PteAddress >= 0xFFFFFFFFF0000000UI64) {

                //
                // This is paged pool, put it in the paged pool cell.
                //

                Info = &PagedPoolBlock;
                Found = TRUE;

            } else {

                //
                // See if there is already a master info block.
                //

                Info = InfoStart;
                Found = FALSE;
                while (Info < InfoEnd) {
                    if (Info->Master == Master) {
                        Found = TRUE;
                        break;
                    }
                    Info += 1;
                }
            }
            if (!Found) {

                Info = InfoEnd;
                InfoEnd += 1;
                if ((PUCHAR)Info >= ((PUCHAR)InfoStart + InfoSize) - sizeof(PFN_INFO)) {
                    //
                    // Don't bother copying the old array - free it instead to
                    // improve our chances of getting a bigger contiguous chunk.
                    //

                    VirtualFree (InfoStart,0,MEM_RELEASE);

                    InfoSize += USAGE_ALLOC_SIZE;

                    goto restart;
                }
                RtlZeroMemory (Info, sizeof (PFN_INFO));

                Info->Master = Master;
                GetFieldValue(Pfn1, "nt!_MMPFN", "OriginalPte.u.Long", Info->OriginalPte);
            }

            // dprintf("Pfn1 %p, PageLoc %x, Master %I64x\n", Pfn1, PageLocation, Master);

            if ((PageLocation == ModifiedPageList) ||
                (PageLocation == ModifiedNoWritePageList)) {
                Info->ModifiedCount += _KB;
                if (ReferenceCount > 0) {
                    Info->LockedCount += _KB;
                }
            } else if ((PageLocation == StandbyPageList) ||
                      (PageLocation == TransitionPage)) {

                Info->StandbyCount += _KB;
                if (ReferenceCount > 0) {
                    Info->LockedCount += _KB;
                }
            } else {

                Info->ValidCount += _KB;
                if (ShareCount > 1) {
                    Info->SharedCount += _KB;
                    if (ReferenceCount > 1) {
                        Info->LockedCount += _KB;
                    }
                }
            }
            if ((PteAddress >= DbgGetPdeAddress (0x0)) &&
                (PteAddress <= DbgGetPdeAddress (0xFFFFFFFFFFFFFFFF))) {
                Info->PageTableCount += _KB;
            }
        }
NextPfn:
        Pfn1 = (Pfn1 + PfnSize);
    }

    //
    // dump the results.
    //

#if 0
    dprintf("Physical Page Summary:\n");
    dprintf("         - number of physical pages: %ld\n",
                MmNumberOfPhysicalPages);
    dprintf("         - Zeroed Pages %ld\n", MmZeroedPageListHead.Total);
    dprintf("         - Free Pages %ld\n", MmFreePageListHead.Total);
    dprintf("         - Standby Pages %ld\n", MmStandbyPageListHead.Total);
    dprintf("         - Modfified Pages %ld\n", MmModifiedPageListHead.Total);
    dprintf("         - Modfified NoWrite Pages %ld\n", MmModifiedNoWritePageListHead.Total);
    dprintf("         - Bad Pages %ld\n", MmBadPageListHead.Total);
#endif //0

    dprintf("\n\n  Usage Summary (in Kb):\n");

    Info = InfoStart;
    while (Info < InfoEnd) {
        if (CheckControlC()) {
            VirtualFree (InfoStart,0,MEM_RELEASE);
            free(pKernelMap);
            free(NameString.Buffer);
            return;
        }

        if (Info->Master > 0x200000) {

            //
            // Get the control area from the subsection.
            //

            if (GetFieldValue(Info->Master,
                              "nt!_SUBSECTION",
                              "ControlArea",
                              ControlArea1)) {
                dprintf("unable to get subsection va %p %lx\n",Info->Master,Info->OriginalPte);
            }

//            ControlArea1 = Subsection.ControlArea;
            Info->Master = ControlArea1;

            //
            // Loop through the array so far for matching control areas
            //

            Info1 = InfoStart;
            while (Info1 < Info) {
                if (Info1->Master == ControlArea1) {
                    //
                    // Found a match, collapse these values.
                    //
                    Info1->ValidCount += Info->ValidCount;
                    Info1->StandbyCount += Info->StandbyCount;
                    Info1->ModifiedCount += Info->ModifiedCount;
                    Info1->SharedCount += Info->SharedCount;
                    Info1->LockedCount += Info->LockedCount;
                    Info1->PageTableCount += Info->PageTableCount;
                    Info->Master = 0;
                    break;
                }
                Info1++;
            }
        } else {
            LastProcessInfo->Next = Info;
            LastProcessInfo = Info;
        }
        Info++;
    }

    Info = InfoStart;
    dprintf("Control Valid Standby Dirty Shared Locked PageTables  name\n");
    while (Info < InfoEnd) {
    ULONG64 FilePointer;

        if (CheckControlC()) {
            VirtualFree (InfoStart,0,MEM_RELEASE);
            free(pKernelMap);
            free(NameString.Buffer);
            return;
        }

        if (Info->Master > 0x200000) {

            //
            // Get the control area.
            //

            if (GetFieldValue(Info->Master,
                              "nt!_CONTROL_AREA",
                              "FilePointer",
                              FilePointer)) {

                dprintf("%8p %5ld  %5ld %5ld %5ld %5ld %5ld    Bad Control Area\n",
                                    Info->Master,
                                    Info->ValidCount,
                                    Info->StandbyCount,
                                    Info->ModifiedCount,
                                    Info->SharedCount,
                                    Info->LockedCount,
                                    Info->PageTableCount
                                    );

            } else if (FilePointer == 0)  {

                dprintf("%8p %5ld  %5ld %5ld %5ld %5ld %5ld   Page File Section\n",
                                    Info->Master,
                                    Info->ValidCount,
                                    Info->StandbyCount,
                                    Info->ModifiedCount,
                                    Info->SharedCount,
                                    Info->LockedCount,
                                    Info->PageTableCount
                                    );

            } else {
                ULONG64 NameBuffer;

                //
                // Get the file pointer.
                //

                if (GetFieldValue(FilePointer,
                                  "nt!_FILE_OBJECT",
                                  "FileName.Length",
                                  NameString.Length)) {
                    dprintf("unable to get subsection %p\n",FilePointer);
                }

                if (NameString.Length != 0)  {

                    //
                    // Get the name string.
                    //

            if (NameString.Length > NameString.MaximumLength) {
            NameString.Length = NameString.MaximumLength-1;
            }

                    GetFieldValue(FilePointer,
                                  "nt!_FILE_OBJECT",
                                  "FileName.Buffer",
                                  NameBuffer);

                    if ((!ReadMemory(NameBuffer,
                                     NameString.Buffer,
                                     NameString.Length,
                                     &result)) || (result < NameString.Length)) {
                        dprintf("%8p %5ld  %5ld %5ld %5ld %5ld %5ld    Name Not Available\n",
                                    Info->Master,
                                    Info->ValidCount,
                                    Info->StandbyCount,
                                    Info->ModifiedCount,
                                    Info->SharedCount,
                                    Info->LockedCount,
                                    Info->PageTableCount
                                    );
                    } else {

                        {

                        WCHAR FileName[MAX_PATH];
                        WCHAR FullFileName[MAX_PATH];
                        WCHAR *FilePart;

                        ZeroMemory(FileName,sizeof(FileName));
            if (NameString.Length > sizeof(FileName)) {
                wcscpy(FileName, L"File name length too big - possibly corrupted");
            } else {
                CopyMemory(FileName,NameString.Buffer,NameString.Length);
            }
                        GetFullPathNameW(
                            FileName,
                            MAX_PATH,
                            FullFileName,
                            &FilePart
                            );

                        dprintf("%8p %5ld  %5ld %5ld %5ld %5ld %5ld  mapped_file( %ws )\n",
                                Info->Master,
                                Info->ValidCount,
                                Info->StandbyCount,
                                Info->ModifiedCount,
                                Info->SharedCount,
                                Info->LockedCount,
                                Info->PageTableCount,
                                FilePart);
                        }
                    }
                } else {
                    dprintf("%8p %5ld  %5ld %5ld %5ld %5ld %5ld    No Name for File\n",
                                Info->Master,
                                Info->ValidCount,
                                Info->StandbyCount,
                                Info->ModifiedCount,
                                Info->SharedCount,
                                Info->LockedCount,
                                Info->PageTableCount
                                );
                }
            }

        }
        Info += 1;
    }

    Info = &PagedPoolBlock;
    if ((Info->ValidCount != 0) ||
        (Info->StandbyCount != 0) ||
        (Info->ModifiedCount != 0)) {

        dprintf("00000000  %4ld  %5ld %5ld %5ld %5ld %5ld  PagedPool\n",
                        Info->ValidCount,
                        Info->StandbyCount,
                        Info->ModifiedCount,
                        Info->SharedCount,
                        Info->LockedCount,
                        Info->PageTableCount
                        );
    }

    //
    // dump the process information.
    //

    BuildDirbaseList();
    Info = ProcessPfns.Next;
    while (Info != NULL) {
        if (Info->Master != 0) {
            PUCHAR ImageName;

            ImageName = DirbaseToImage(Info->Master);

            if ( ImageName ) {
                dprintf("--------  %4ld  %5ld %5ld ----- ----- %5ld  process ( %s )\n",
                            Info->ValidCount,
                            Info->StandbyCount,
                            Info->ModifiedCount,
                            Info->PageTableCount,
                            ImageName
                            );
                }
            else {
                dprintf("--------  %4ld  %5ld %5ld ----- ----- %5ld  pagefile section (%lx)\n",
                            Info->ValidCount,
                            Info->StandbyCount,
                            Info->ModifiedCount,
                            Info->PageTableCount,
                            Info->Master
                            );
                }

        }
        Info = Info->Next;
    }

    if (!IgnoreInvalidFrames) {
        for (i=0;i<pKernelMap->Count ;i++) {
          dprintf("--------  %4ld  %5ld %5ld ----- %5ld -----  driver ( %ws )\n",
                    pKernelMap->Item[i].ValidCount,
                    pKernelMap->Item[i].StandbyCount,
                    pKernelMap->Item[i].ModifiedCount,
                    pKernelMap->Item[i].LockedCount,
                    pKernelMap->Item[i].Name
                    );
        }
    }

    VirtualFree (InfoStart,0,MEM_RELEASE);
    free(pKernelMap);
    free(NameString.Buffer);

    return;
}

NTSTATUS
BuildDirbaseList (
    VOID
    )
{
    ULONG64 Next;
    ULONG64 ProcessHead;
    ULONG64 Process;
    NTSTATUS status=0;
    ULONG ActiveProcessLinksOffset, DirectoryTableBaseOffset;
    FIELD_INFO offField[] = {
        {"ActiveProcessLinks", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL},
        {"Pcb.DirectoryTableBase", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL}
    };
    SYM_DUMP_PARAM TypeSym ={
        sizeof (SYM_DUMP_PARAM), "_EPROCESS", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 2, &offField[0]
    };

    // Get the offset of ActiveProcessLinks in EPROCESS
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
       return FALSE;
    }

    ActiveProcessLinksOffset = (ULONG) offField[0].address;
    DirectoryTableBaseOffset = (ULONG) offField[1].address;
    MaxDirbase = 0;

    ProcessHead = GetNtDebuggerData(PsActiveProcessHead );
    if (!ProcessHead) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if (GetFieldValue(ProcessHead, "nt!_LIST_ENTRY", "Flink", Next)) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //Next = List.Flink;
    if (Next == 0) {
        dprintf("PsActiveProcessHead is NULL!\n");
        return STATUS_INVALID_PARAMETER;
    }

    while(Next != ProcessHead) {
        ULONG64 PageFrameNumber=0;

        Process = Next - ActiveProcessLinksOffset;

        if (GetFieldValue(Process,
                          "nt!_EPROCESS",
                          "ImageFileName",
                          Names[MaxDirbase])) {
            dprintf("Unable to read _EPROCESS at %p\n",Process);
            MaxDirbase = 0;
            return status;
        }

        if ( (Names[ MaxDirbase ])[0] == '\0' ) {
            strcpy((PCHAR)&Names[MaxDirbase][0],(PCHAR)"SystemProcess");
        }

        GetFieldValue(Process,"_EPROCESS","ImageFileName",Names[MaxDirbase]);

        GetFieldValue(Process + DirectoryTableBaseOffset, "nt!HARDWARE_PTE", "PageFrameNumber", PageFrameNumber);

        DirBases[MaxDirbase++] = PageFrameNumber;

        GetFieldValue(Process, "_EPROCESS", "ActiveProcessLinks.Flink", Next);

        if (CheckControlC()) {
            MaxDirbase = 0;
            return STATUS_INVALID_PARAMETER;
        }
    }
    return STATUS_INVALID_PARAMETER;
}

PUCHAR
DirbaseToImage(
    IN ULONG64 DirBase
    )
{
    ULONG i;

    for(i=0;i<MaxDirbase;i++) {
        if ( DirBases[i] == DirBase ) {
            return &Names[i][0];
        }
    }
    return NULL;
}

LOGICAL
BuildKernelMap (
    OUT PKERN_MAP KernelMap
    )

{
    ULONG64 Next;
    ULONG64 ListHead;
    NTSTATUS Status = 0;
    ULONG Result;
    ULONG64 DataTable;
    ULONG i = 0;
    ULONG64 Flink;
    ULONG InLoadOrderLinksOffset;
    FIELD_INFO offField = {"InLoadOrderLinks", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={
        sizeof (SYM_DUMP_PARAM), "nt!_LDR_DATA_TABLE_ENTRY", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };

    // Get the offset of InLoadOrderLinks in LDR_DATA_TABLE_ENTRY
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
       return FALSE;
    }

    InLoadOrderLinksOffset = (ULONG) offField.address;

    ListHead = GetNtDebuggerData(PsLoadedModuleList );

    if (!ListHead) {
        dprintf("Couldn't get offset of PsLoadedModuleListHead\n");
        return FALSE;
    }

    if (GetFieldValue(ListHead, "nt!_LIST_ENTRY", "Flink", Flink)) {
        dprintf("Unable to get value of PsLoadedModuleListHead\n");
        return FALSE;
    }

    Next = Flink;
    if (Next == 0) {
        dprintf("PsLoadedModuleList is NULL!\n");
        return FALSE;
    }

    while (Next != ListHead) {
        ULONG64 BaseDllNameBuffer, DllBase;
        ULONG   BaseDllNameLength=0, SizeOfImage;

        if (CheckControlC()) {
            return FALSE;
        }
        DataTable = (Next - InLoadOrderLinksOffset);

        if (GetFieldValue(DataTable,
               "nt!_LDR_DATA_TABLE_ENTRY",
               "BaseDllName.Buffer",
               BaseDllNameBuffer)) {
            dprintf("Unable to read LDR_DATA_TABLE_ENTRY at %08p\n",
                    DataTable);
            return FALSE;
        }
        GetFieldValue(DataTable, "nt!_LDR_DATA_TABLE_ENTRY","BaseDllName.Length",BaseDllNameLength);
        GetFieldValue(DataTable, "nt!_LDR_DATA_TABLE_ENTRY","DllBase",DllBase);
        GetFieldValue(DataTable, "nt!_LDR_DATA_TABLE_ENTRY","SizeOfImage",SizeOfImage);

        //
        // Get the base DLL name.
        //

        if ((!ReadMemory(BaseDllNameBuffer,
                         &KernelMap->Item[i].Name[0],
                         BaseDllNameLength,
                         &Result)) || (Result < BaseDllNameLength)) {
            dprintf("Unable to read name string at %08p - status %08lx\n",
                    DataTable,
                    Status);
            return FALSE;
        }

        KernelMap->Item[i].Name[BaseDllNameLength/2] = L'\0';
        KernelMap->Item[i].StartVa = DllBase;
        KernelMap->Item[i].EndVa = KernelMap->Item[i].StartVa +
                                            (ULONG)SizeOfImage;
        i += 1;

        GetFieldValue(DataTable, "nt!_LDR_DATA_TABLE_ENTRY","InLoadOrderLinks.Flink", Next);
    }

    KernelMap->Item[i].StartVa = GetNtDebuggerDataPtrValue(MmPagedPoolStart);
    KernelMap->Item[i].EndVa = GetNtDebuggerDataPtrValue(MmPagedPoolEnd);
    wcscpy (&KernelMap->Item[i].Name[0], (PUSHORT) &L"Paged Pool");
    i+= 1;

#if 0
    KernelMap->Item[i].StartVa = DbgGetPteAddress (0xffffffff80000000UI64);
    KernelMap->Item[i].EndVa   = DbgGetPteAddress (0xffffffffffffffffUI64);
    wcscpy (&KernelMap->Item[i].Name[0], (PUSHORT) &L"System Page Tables");
    i+= 1;

    KernelMap->Item[i].StartVa = DbgGetPdeAddress (0x80000000);
    KernelMap->Item[i].EndVa =   DbgGetPdeAddress (0xffffffff);
    wcscpy (&KernelMap->Item[i].Name[0], (PUSHORT) &L"System Page Tables");
    i+= 1;
#endif 0

// LWFIX: Both PTEs and nonpaged pool can be in multiple virtually discontiguous
// areas.  Fix this.

    KernelMap->Item[i].StartVa = DbgGetVirtualAddressMappedByPte (
                                        GetNtDebuggerDataValue(MmSystemPtesStart));
    KernelMap->Item[i].EndVa =   DbgGetVirtualAddressMappedByPte (
                                        GetNtDebuggerDataValue(MmSystemPtesEnd)) + 1;
    wcscpy (&KernelMap->Item[i].Name[0], (PUSHORT) &L"Kernel Stacks");
    i+= 1;

    KernelMap->Item[i].StartVa = GetNtDebuggerDataValue(MmNonPagedPoolStart);
    KernelMap->Item[i].EndVa = GetNtDebuggerDataValue(MmNonPagedPoolEnd);
    wcscpy (&KernelMap->Item[i].Name[0], (PUSHORT) &L"NonPaged Pool");
    i+= 1;

    KernelMap->Count = i;

    return TRUE;
}

ULONG64 SpecialPoolStart;
ULONG64 SpecialPoolEnd;
#define VI_POOL_FREELIST_END  ((ULONG64)-1)

LOGICAL
VerifierDumpPool (
    IN ULONG64 Verifier
    )
{
    ULONG64 HashTableAddress;
    ULONG   PoolTag;
    ULONG   i;
    ULONG64 HashEntry;
    ULONG64 PoolHashSize;
    ULONG   SizeofEntry;
    LONG64 FreeListNext;

    //
    // Display the current and peak pool usage by allocation & bytes.
    //

#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')

    InitTypeRead(Verifier, nt!_MI_VERIFIER_DRIVER_ENTRY);

    dprintf("\n");

    dprintf("Current Pool Allocations  %08I64lx    %08I64lx\n",
        ReadField(CurrentPagedPoolAllocations),
        ReadField(CurrentNonPagedPoolAllocations));

    dprintf("Current Pool Bytes        %08I64lx    %08I64lx\n",
        ReadField(PagedBytes),
        ReadField(NonPagedBytes));

    dprintf("Peak Pool Allocations     %08I64lx    %08I64lx\n",
        ReadField(PeakPagedPoolAllocations),
        ReadField(PeakNonPagedPoolAllocations));

    dprintf("Peak Pool Bytes           %08I64lx    %08I64lx\n",
        ReadField(PeakPagedBytes),
        ReadField(PeakNonPagedBytes));

    //
    // If no current allocations then the dump is over.
    //

    if ((ReadField(CurrentPagedPoolAllocations) == 0) &&
        (ReadField(CurrentNonPagedPoolAllocations) == 0)) {
        dprintf("\n");
        return FALSE;
    }

    dprintf("\n");

    PoolHashSize     = ReadField(PoolHashSize);
    HashTableAddress = ReadField(PoolHash);

    dprintf("PoolAddress  SizeInBytes    Tag       CallersAddress\n");

    i = 0;
    HashEntry = HashTableAddress;
    SizeofEntry = GetTypeSize("nt!_VI_POOL_ENTRY");

    for (i = 0; i < PoolHashSize; i += 1, HashEntry += SizeofEntry) {

        if (GetFieldValue(HashEntry, "nt!_VI_POOL_ENTRY", "FreeListNext", FreeListNext)) {
            dprintf("%08p: Unable to get verifier hash page\n", HashEntry);
            return FALSE;
        }

        //
        // Sign extend if necessary.
        //

        if (!IsPtr64()) {
            FreeListNext = (ULONG64)(LONG64)(LONG)FreeListNext;
        }

        //
        // Skip freelist entries.
        //

        if ((FreeListNext == VI_POOL_FREELIST_END) ||
            ((FreeListNext & MINLONG64_PTR) == 0)) {
                continue;
        }

        InitTypeRead(HashEntry, nt!_VI_POOL_ENTRY);

        PoolTag = (ULONG) ReadField(InUse.Tag);

        dprintf("%p     0x%08p     %c%c%c%c      ",
            ReadField(InUse.VirtualAddress),
            ReadField(InUse.NumberOfBytes),
            (PP(PoolTag) & ~0x80),
            PP(PoolTag >> 8),
            PP(PoolTag >> 16),
            PP(PoolTag >> 24)
            );

        dprintf("%p\n", ReadField(InUse.CallingAddress));

        if (CheckControlC()) {
            return TRUE;
        }
    }

#undef PP
   dprintf("\n");

    return FALSE;
}

#if 0

typedef struct _COMMIT_INFO {
    LPSTR Name;
    ULONG Index;
} COMMIT_INFO, *PCOMMIT_INFO;

COMMIT_INFO CommitInfo[] = {
"MM_DBG_COMMIT_NONPAGED_POOL_EXPANSION",          0,
"MM_DBG_COMMIT_PAGED_POOL_PAGETABLE",             1,
"MM_DBG_COMMIT_PAGED_POOL_PAGES",                 2,
"MM_DBG_COMMIT_SESSION_POOL_PAGE_TABLES",         3,
"MM_DBG_COMMIT_ALLOCVM1",                         4,
"MM_DBG_COMMIT_ALLOCVM_SEGMENT",                  5,
"MM_DBG_COMMIT_IMAGE",                            6,
"MM_DBG_COMMIT_PAGEFILE_BACKED_SHMEM",            7,
"MM_DBG_COMMIT_INDEPENDENT_PAGES",                8,
"MM_DBG_COMMIT_CONTIGUOUS_PAGES",                 9,
"MM_DBG_COMMIT_MDL_PAGES",                        0xA,
"MM_DBG_COMMIT_NONCACHED_PAGES",                  0xB,
"MM_DBG_COMMIT_MAPVIEW_DATA",                     0xC,
"MM_DBG_COMMIT_FILL_SYSTEM_DIRECTORY",            0xD,
"MM_DBG_COMMIT_EXTRA_SYSTEM_PTES",                0xE,
"MM_DBG_COMMIT_DRIVER_PAGING_AT_INIT",            0xF,
"MM_DBG_COMMIT_PAGEFILE_FULL",                    0x10,
"MM_DBG_COMMIT_PROCESS_CREATE",                   0x11,
"MM_DBG_COMMIT_KERNEL_STACK_CREATE",              0x12,
"MM_DBG_COMMIT_SET_PROTECTION",                   0x13,
"MM_DBG_COMMIT_SESSION_CREATE",                   0x14,
"MM_DBG_COMMIT_SESSION_IMAGE_PAGES",              0x15,
"MM_DBG_COMMIT_SESSION_PAGETABLE_PAGES",          0x16,
"MM_DBG_COMMIT_SESSION_SHARED_IMAGE",             0x17,
"MM_DBG_COMMIT_DRIVER_PAGES",                     0x18,
"MM_DBG_COMMIT_INSERT_VAD",                       0x19,
"MM_DBG_COMMIT_SESSION_WS_INIT",                  0x1A,
"MM_DBG_COMMIT_SESSION_ADDITIONAL_WS_PAGES",      0x1B,
"MM_DBG_COMMIT_SESSION_ADDITIONAL_WS_HASHPAGES",  0x1C,
"MM_DBG_COMMIT_SPECIAL_POOL_PAGES",               0x1D,

"MM_DBG_COMMIT_SMALL",                            0x1F,
"MM_DBG_COMMIT_EXTRA_WS_PAGES",                   0x20,
"MM_DBG_COMMIT_EXTRA_INITIAL_SESSION_WS_PAGES",   0x21,
"MM_DBG_COMMIT_ALLOCVM_PROCESS",                  0x22,
"MM_DBG_COMMIT_INSERT_VAD_PT",                    0x23,
"MM_DBG_COMMIT_ALLOCVM_PROCESS2",                 0x24,
"MM_DBG_COMMIT_CHARGE_NORMAL",                    0x25,
"MM_DBG_COMMIT_CHARGE_CAUSE_POPUP",               0x26,
"MM_DBG_COMMIT_CHARGE_CANT_EXPAND",               0x27,

"MM_DBG_COMMIT_RETURN_NONPAGED_POOL_EXPANSION",   0x40,
"MM_DBG_COMMIT_RETURN_PAGED_POOL_PAGES",          0x41,
"MM_DBG_COMMIT_RETURN_SESSION_DATAPAGE",          0x42,
"MM_DBG_COMMIT_RETURN_ALLOCVM_SEGMENT",           0x43,
"MM_DBG_COMMIT_RETURN_ALLOCVM2",                  0x44,

"MM_DBG_COMMIT_RETURN_IMAGE_NO_LARGE_CA",         0x46,
"MM_DBG_COMMIT_RETURN_PTE_RANGE",                 0x47,
"MM_DBG_COMMIT_RETURN_NTFREEVM1",                 0x48,
"MM_DBG_COMMIT_RETURN_NTFREEVM2",                 0x49,
"MM_DBG_COMMIT_RETURN_INDEPENDENT_PAGES",         0x4A,
"MM_DBG_COMMIT_RETURN_AWE_EXCESS",                0x4B,
"MM_DBG_COMMIT_RETURN_MDL_PAGES",                 0x4C,
"MM_DBG_COMMIT_RETURN_NONCACHED_PAGES",           0x4D,
"MM_DBG_COMMIT_RETURN_SESSION_CREATE_FAILURE",    0x4E,
"MM_DBG_COMMIT_RETURN_PAGETABLES",                0x4F,
"MM_DBG_COMMIT_RETURN_PROTECTION",                0x50,
"MM_DBG_COMMIT_RETURN_SEGMENT_DELETE1",           0x51,
"MM_DBG_COMMIT_RETURN_SEGMENT_DELETE2",           0x52,
"MM_DBG_COMMIT_RETURN_PAGEFILE_FULL",             0x53,
"MM_DBG_COMMIT_RETURN_SESSION_DEREFERENCE",       0x54,
"MM_DBG_COMMIT_RETURN_VAD",                       0x55,
"MM_DBG_COMMIT_RETURN_PROCESS_CREATE_FAILURE1",   0x56,
"MM_DBG_COMMIT_RETURN_PROCESS_DELETE",            0x57,
"MM_DBG_COMMIT_RETURN_PROCESS_CLEAN_PAGETABLES",  0x58,
"MM_DBG_COMMIT_RETURN_KERNEL_STACK_DELETE",       0x59,
"MM_DBG_COMMIT_RETURN_SESSION_DRIVER_LOAD_FAILURE1",0x5A,
"MM_DBG_COMMIT_RETURN_DRIVER_INIT_CODE",          0x5B,
"MM_DBG_COMMIT_RETURN_DRIVER_UNLOAD",             0x5C,
"MM_DBG_COMMIT_RETURN_DRIVER_UNLOAD1",            0x5D,
"MM_DBG_COMMIT_RETURN_NORMAL",                    0x5E,
"MM_DBG_COMMIT_RETURN_PF_FULL_EXTEND",            0x5F,
"MM_DBG_COMMIT_RETURN_EXTENDED",                  0x60,
"MM_DBG_COMMIT_RETURN_SEGMENT_DELETE3",           0x61,
};

VOID
DumpCommitTracker ()
{
    ULONG64 MmTrackCommit;
    ULONG64 PfnEntry;
    ULONG64 displacement;
    ULONG64 AcquiredAddress;
    ULONG64 ReleasedAddress;
    CHAR SymbolBuffer[80];
    PCHAR SymPointer;
    ULONG EntrySize;
    ULONG result;
    ULONG64 ReadCount;
    ULONG64 i;
    ULONG64 j;
    PSIZE_T LocalData;
    PCHAR local;
    ULONG64 NumberOfCommitEntries;

    MmTrackCommit = GetExpression ("nt!MmTrackCommit");

    if (MmTrackCommit == 0) {
        dprintf("%08p: Unable to get commit track data.\n", MmTrackCommit);
        return;
    }

    PfnEntry = MmTrackCommit;

#if 0
    NumberOfCommitEntries = GetUlongValue ("MiMaxPfnTimings");
    EntrySize =  GetTypeSize("SIZE_T");
#else
    NumberOfCommitEntries = 128;
    EntrySize = 4;
#endif

    ReadCount = NumberOfCommitEntries * EntrySize;

    dprintf("Scanning %I64u %I64u commit points\n", NumberOfCommitEntries, ReadCount);

    LocalData = LocalAlloc(LPTR, (ULONG) (NumberOfCommitEntries * EntrySize));

    if (!LocalData) {
        dprintf("unable to get allocate %ld bytes of memory\n",
                (ULONG)(NumberOfCommitEntries * EntrySize));
        return;
    }

    if ((!ReadMemory(MmTrackCommit,
                     LocalData,
                     (ULONG) ReadCount,
                     &result)) || (result < (ULONG) ReadCount)) {
        dprintf("unable to get track commit table - "
                "address %p - count %I64u\n",
                LocalData, ReadCount);
    }
    else {

        dprintf("\n%-50s %s\n", "Instance", "HexCount");

        for (i = 0; i < NumberOfCommitEntries; i += 1) {

            if (LocalData[i] != 0) {
                for (j = 0; j < sizeof(CommitInfo) / sizeof (COMMIT_INFO); j += 1) {
                    if (CommitInfo[j].Index == i) {
                        dprintf ("%-50s %8x\n", CommitInfo[j].Name, LocalData[i]);
                        break;
                    }
                }
            }
        }
    }

    if (LocalData) {
        LocalFree((void *)LocalData);
    }

    return;
}

#endif

VOID
DumpFaultInjectionTraceLog (
    PCSTR Args
    );

VOID
DumpTrackIrqlLog (
    PCSTR args
    );

DECLARE_API( verifier )

/*++

Routine Description:

    Displays the current Driver Verifier data.

Arguments:

    arg - Supplies 7 for full listing

Return Value:

    None.

--*/

{
    ULONG result;
    ULONG Flags;
    ULONG VerifierFlags;
    ULONG64 VerifierDataPointer;
    ULONG64 SuspectPointer;
    ULONG64 NextEntry;
    ULONG64 VerifierDriverEntry;
    PUCHAR tempbuffer;
    UNICODE_STRING unicodeString;
    LOGICAL Interrupted;
    CHAR Buf[256];
    PCHAR ImageFileName;
    ANSI_STRING AnsiString;
    UNICODE_STRING InputDriverName;
    NTSTATUS st;
    ULONG Level;
    PCHAR state;
    ULONG64 tmp;

    UNREFERENCED_PARAMETER (Client);

    //
    // Display option usage.
    //

    if (strstr (args, "?") != NULL) {

        dprintf ("!verifier                                          \n");
        dprintf ("                                                   \n");
        dprintf ("    Dump verifier summary information.             \n");
        dprintf ("                                                   \n");
        dprintf ("!verifier [FLAGS [IMAGE]]                          \n");
        dprintf ("                                                   \n");
        dprintf ("    0x01 : Dump verified drivers pool statistics   \n");
        dprintf ("                                                   \n");
        dprintf ("    0x02 : not used                                \n");
        dprintf ("                                                   \n");
        dprintf ("    0x04 [N] : Dump N traces from fault injection trace log. \n");
        dprintf ("                                                   \n");
        dprintf ("    0x08 [N] : Dump N traces from track IRQL trace log\n");
        dprintf ("                                                   \n");
        dprintf ("To display everything use:                         \n");
        dprintf ("                                                   \n");
        dprintf ("    !verifier 0xf                                  \n");
        dprintf ("                                                   \n");

        return S_OK;
    }

    //
    // Read the Flags parameter.
    //

    Flags = 0;
    Flags = (ULONG) GetExpression (args);

    //
    // Display fault injection stacks.
    //

    if ((Flags == 0x04)) {
        DumpFaultInjectionTraceLog (args);
        return S_OK;
    }

    //
    // Display track irql stacks.
    //

    if ((Flags == 0x08)) {
        DumpTrackIrqlLog (args);
        return S_OK;
    }

    //
    // Continue with normal processing: !verifier [FLAGS [NAME]]
    //

    Flags = 0;
    RtlZeroMemory(Buf, 256);
    if (GetExpressionEx(args, &tmp, &args)) {
        Flags = (ULONG) tmp;
        while (args && (*args == ' ')) {
            ++args;
        }
        strcpy(Buf, args);
    }

    if (Buf[0] != '\0') {
        ImageFileName = Buf;
        RtlInitAnsiString(&AnsiString, ImageFileName);
        st = RtlAnsiStringToUnicodeString(&InputDriverName, &AnsiString, TRUE);
        if (!NT_SUCCESS(st)) {
            dprintf("%08lx: Unable to initialize unicode string\n", st);
            return E_INVALIDARG;
        }
    } else {
        ImageFileName = NULL;
    }

    VerifierDataPointer = GetExpression ("nt!MmVerifierData");

    if (GetFieldValue(VerifierDataPointer,
                      "nt!_MM_DRIVER_VERIFIER_DATA",
                      "Level",
                      Level)) {

        dprintf("%08p: Unable to get verifier list.\n",VerifierDataPointer);
        return E_INVALIDARG;
    }

    dprintf("\nVerify Level %x ... enabled options are:", Level);

    if (Level & DRIVER_VERIFIER_SPECIAL_POOLING) {
        dprintf("\n\tspecial pool");
    }
    if (Level & DRIVER_VERIFIER_FORCE_IRQL_CHECKING) {
        dprintf("\n\tspecial irql");
    }
    if (Level & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES) {
        dprintf("\n\tinject random low-resource API failures");
    }
    if (Level & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS) {
        dprintf("\n\tall pool allocations checked on unload");
    }
    if (Level & DRIVER_VERIFIER_IO_CHECKING) {
        dprintf("\n\tIo subsystem checking enabled");
    }
    if (Level & DRIVER_VERIFIER_DEADLOCK_DETECTION) {
        dprintf("\n\tDeadlock detection enabled");
    }
    if (Level & DRIVER_VERIFIER_ENHANCED_IO_CHECKING) {
        dprintf("\n\tEnhanced Io checking enabled");
    }
    if (Level & DRIVER_VERIFIER_DMA_VERIFIER) {
        dprintf("\n\tDMA checking enabled");
    }

    if (InitTypeRead(VerifierDataPointer, nt!MM_DRIVER_VERIFIER_DATA)) {
        dprintf("Unable to read type nt!MM_DRIVER_VERIFIER_DATA @ %p\n", VerifierDataPointer);
    }
    dprintf("\n\nSummary of All Verifier Statistics\n\n");

    dprintf("RaiseIrqls                             0x%x\n", (ULONG) ReadField(RaiseIrqls));
    dprintf("AcquireSpinLocks                       0x%x\n", (ULONG) ReadField(AcquireSpinLocks));
    dprintf("Synch Executions                       0x%x\n", (ULONG) ReadField(SynchronizeExecutions));
    dprintf("Trims                                  0x%x\n", (ULONG) ReadField(Trims));

    dprintf("\n");

    dprintf("Pool Allocations Attempted             0x%x\n", (ULONG) ReadField(AllocationsAttempted));
    dprintf("Pool Allocations Succeeded             0x%x\n", (ULONG) ReadField(AllocationsSucceeded));
    dprintf("Pool Allocations Succeeded SpecialPool 0x%x\n", (ULONG) ReadField(AllocationsSucceededSpecialPool));
    dprintf("Pool Allocations With NO TAG           0x%x\n", (ULONG) ReadField(AllocationsWithNoTag));

    dprintf("Pool Allocations Failed                0x%x\n", (ULONG) ReadField(AllocationsFailed));
    dprintf("Resource Allocations Failed Deliberately   0x%x\n", (ULONG) ReadField(AllocationsFailedDeliberately) + (ULONG) ReadField(BurstAllocationsFailedDeliberately));

    dprintf("\n");

    dprintf("Current paged pool allocations         0x%x for %08P bytes\n",
        (ULONG) ReadField(CurrentPagedPoolAllocations),
        ReadField(PagedBytes));

    dprintf("Peak paged pool allocations            0x%x for %08P bytes\n",
        (ULONG)ReadField(PeakPagedPoolAllocations),
        ReadField(PeakPagedBytes));

    dprintf("Current nonpaged pool allocations      0x%x for %08P bytes\n",
        (ULONG) ReadField(CurrentNonPagedPoolAllocations),
        ReadField(NonPagedBytes));

    dprintf("Peak nonpaged pool allocations         0x%x for %08P bytes\n",
        (ULONG)ReadField(PeakNonPagedPoolAllocations),
        ReadField(PeakNonPagedBytes));

    dprintf("\n");

    SpecialPoolStart = GetPointerValue("nt!MmSpecialPoolStart");
    SpecialPoolEnd =   GetPointerValue("nt!MmSpecialPoolEnd");

    if (Flags & 0x1) {
        ULONG Off;

        SuspectPointer = GetExpression ("nt!MiSuspectDriverList");

        GetFieldOffset("nt!_MI_VERIFIER_DRIVER_ENTRY", "Links", &Off);

        if (!ReadPointer(SuspectPointer,&NextEntry)) {

            dprintf("%08p: Unable to get verifier list %p\n",SuspectPointer);
            return E_INVALIDARG;
        }

        dprintf("Driver Verification List\n\n");

        dprintf("Entry     State           NonPagedPool   PagedPool   Module\n\n");
        while (NextEntry != SuspectPointer) {

            VerifierDriverEntry = NextEntry - Off;

            if (GetFieldValue( VerifierDriverEntry,
                              "nt!_MI_VERIFIER_DRIVER_ENTRY",
                               "Flags",
                               VerifierFlags)) {

                dprintf("%08p: Unable to get verifier data\n", VerifierDriverEntry);
                return E_INVALIDARG;
            }

            InitTypeRead(VerifierDriverEntry, nt!_MI_VERIFIER_DRIVER_ENTRY);
            if ((VerifierFlags & VI_VERIFYING_DIRECTLY) == 0) {
                NextEntry = ReadField(Links.Flink);
                continue;
            }

            unicodeString.Length = (USHORT) ReadField(BaseName.Length);
            tempbuffer = LocalAlloc(LPTR, unicodeString.Length);

            unicodeString.Buffer = (PWSTR)tempbuffer;
            unicodeString.MaximumLength = unicodeString.Length;

            if (!ReadMemory (ReadField(BaseName.Buffer),
                             tempbuffer,
                             unicodeString.Length,
                             &result)) {
                dprintf("%08p: Unable to get verifier driver name\n", ReadField(BaseName.Buffer));
            }

            if (ImageFileName != NULL) {
                if (RtlEqualUnicodeString(&InputDriverName, &unicodeString, TRUE) == 0) {
                    NextEntry = ReadField(Links.Flink);
                    continue;
                }
            }

            if (ReadField(Loads) == 0 && ReadField(Unloads) == 0) {
                state = "Hasn't loaded";
            }
            else if (ReadField(Loads) != ReadField(Unloads)) {
                if (ReadField(Unloads) != 0) {
                    state = "Loaded&Unloaded";
                }
                else {
                    state = "Loaded";
                }
            }
            else {
                state = "Unloaded";
            }

            dprintf("%p %-16s %08p       %08p    %wZ\n",
                VerifierDriverEntry,
                state,
                ReadField(NonPagedBytes),
                ReadField(PagedBytes),
                &unicodeString);

            Interrupted = FALSE;
            NextEntry = ReadField(Links.Flink);

            if ((Flags & 0x2) &&
                (Level & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS)) {

                Interrupted = VerifierDumpPool (VerifierDriverEntry);
            }

            LocalFree(tempbuffer);


            if ((Interrupted == TRUE) ||
                (ImageFileName != NULL) ||
                (CheckControlC())) {
                    break;
            }
        }
    }

    if ((Flags & 0x04)) {
        dprintf ("----------------------------------------------- \n");
        dprintf ("Fault injection trace log                       \n");
        dprintf ("----------------------------------------------- \n");

        DumpFaultInjectionTraceLog (NULL);
    }

    if ((Flags & 0x08)) {
        dprintf ("----------------------------------------------- \n");
        dprintf ("Track irql trace log                            \n");
        dprintf ("----------------------------------------------- \n");

        DumpTrackIrqlLog (NULL);
    }

    return S_OK;
}

DECLARE_API( fpsearch )

/*++

Routine Description:

    Free pool searcher.

Arguments:

    arg - Supplies virtual address to match.

Return Value:

    None.

--*/

{
    ULONG i;
    ULONG BufferSize;
    ULONG RawCount;
    PULONG RawPointer;
    ULONG Flags;
    ULONG ActualRead;
    ULONG64 PageFrameNumber;
    ULONG64 PAddress;
    ULONG64 Address;
    ULONG result;
    ULONG64 PfnDb;
    ULONG64 Pfn;
    ULONG64 PfnStart;
    ULONG PfnSize;
    ULONG64 ChainedBp;
    ULONG64 ValidBp;
    ULONG64 LastBp;
    ULONG64 ReturnAddress;
    PCHAR Buffer;
    ULONG64 MmFreePageListHeadAddress;
    CHAR SymbolBuffer[80];
    ULONG64 displacement;
    ULONG64 Total;
    ULONG StkOffset;
    ULONG PtrSize;
    ULONG PoolTag;
    ULONG StackBytes;
    ULONG64 StackPointer;
    ULONG64 ChainedBpVal;
    ULONG64 LastBpVal;
    ULONG64 Blink;

    PtrSize = IsPtr64() ? 8 : 4;
    PfnSize = GetTypeSize("nt!_MMPFN");

    BufferSize = GetTypeSize("nt!_MI_FREED_SPECIAL_POOL");

    if (BufferSize == 0) {
        dprintf("Type MI_FREED_SPECIAL_POOL not found.\n");
        return E_INVALIDARG;
    }

    PfnDb = GetNtDebuggerData(MmPfnDatabase );

    if (!PfnDb) {
        dprintf("unable to get PFN0 database address\n");
        return E_INVALIDARG;
    }

    result = !ReadPointer(PfnDb,&PfnStart);
    if (result != 0) {
        dprintf("unable to get PFN database address %p %x\n", PfnDb, result);
        return E_INVALIDARG;
    }

    Address = 0;
    Flags = 0;


    if (!sscanf(args,"%I64lx %lx",&Address, &Flags)) {
        Address = 0;
    }
    //  Do not use GetExpression here - the actual address to be searched is phy address
    //  and it can be >32bit for 32bit targets
    //    Address = GetExpression (args);

    if (Address == 0) {
        dprintf("Usage: fpsearch address\n");
        return E_INVALIDARG;
    }

    MmFreePageListHeadAddress = GetExpression ("nt!MmFreePageListHead");

    if (GetFieldValue(MmFreePageListHeadAddress,
                      "nt!_MMPFNLIST",
                      "Total",
                      Total)) {

        dprintf("%08p: Unable to get MmFreePageLocationList\n",MmFreePageListHeadAddress);
        return E_INVALIDARG;
    }


    if (Total == 0) {
        dprintf("No pages on free list to search\n");
        return E_INVALIDARG;
    }

    if (Address != (ULONG64)-1) {

        dprintf("Searching the free page list (%I64x entries) for VA %p\n\n",
            Total, Address);

        Address &= ~(ULONG64)(PageSize - 1);
    }
    else {
        dprintf("Searching the free page list (%x entries) for all freed special pool\n\n",
            Total);
    }

    GetFieldValue (MmFreePageListHeadAddress,
                   "nt!_MMPFNLIST",
                   "Blink",
                   PageFrameNumber);

    GetFieldOffset("_MI_FREED_SPECIAL_POOL", "StackData", &StkOffset);

    Buffer = LocalAlloc(LPTR, BufferSize);

    if (Buffer == NULL) {
        dprintf("Could not allocate a buffer for the search\n");
        return E_INVALIDARG;
    }

    while (PageFrameNumber != (ULONG64)-1) {

        PAddress = (ULONG64)PageFrameNumber * PageSize;

        ReadPhysical (PAddress, Buffer, BufferSize, &ActualRead);

        if (ActualRead != BufferSize) {
            dprintf("Physical memory read %I64X %x %x failed\n", PAddress, ActualRead, BufferSize);
            // break;
        }

        if (Flags & 0x1) {

            //
            // Print a preview of the raw buffer.
            //

#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')

            RawPointer = (PULONG)Buffer;
            RawCount = BufferSize / sizeof (ULONG);
            if (RawCount > 32) {
                RawCount = 32;
            }

            RawCount &= ~0x3;

            for (i = 0; i < RawCount; i += 4) {
                dprintf ("%I64X  %08x %08x %08x %08x %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n",
                    PageFrameNumber * PageSize,

                    *RawPointer,
                    *(RawPointer + 1),
                    *(RawPointer + 2),
                    *(RawPointer + 3),

                    PP(*RawPointer),
                    PP(*RawPointer >> 8),
                    PP(*RawPointer >> 16),
                    PP(*RawPointer >> 24),

                    PP(*(RawPointer + 1)),
                    PP(*(RawPointer + 1) >> 8),
                    PP(*(RawPointer + 1) >> 16),
                    PP(*(RawPointer + 1) >> 24),

                    PP(*(RawPointer + 2)),
                    PP(*(RawPointer + 2) >> 8),
                    PP(*(RawPointer + 2) >> 16),
                    PP(*(RawPointer + 2) >> 24),

                    PP(*(RawPointer + 3)),
                    PP(*(RawPointer + 3) >> 8),
                    PP(*(RawPointer + 3) >> 16),
                    PP(*(RawPointer + 3) >> 24));

                RawPointer += 4;
            }
            dprintf ("\n");
        }

        Pfn = (PfnStart + PageFrameNumber * PfnSize);

        if (GetFieldValue(Pfn,"nt!_MMPFN","u2.Blink", Blink)) {
            dprintf("%08p: unable to get PFN element %x\n", Pfn, PfnSize);
            break;
        }

        if ((ULONG)Blink == (ULONG)-1) {
            Blink = (ULONG64)-1;
        }

#define MI_FREED_SPECIAL_POOL_SIGNATURE 0x98764321

        InitTypeReadPhysical (PAddress, nt!MI_FREED_SPECIAL_POOL);

        if ((ULONG) ReadField(Signature) == MI_FREED_SPECIAL_POOL_SIGNATURE) {

            if ((Address == (ULONG64)-1) ||

                (((ULONG)(ReadField(VirtualAddress)) & ~(ULONG)(PageSize - 1)) == (ULONG)Address)) {


                PoolTag = (ULONG) ReadField(OverlaidPoolHeader.PoolTag);

                dprintf("VA          PFN     Tag     Size   Pagable     Thread    Tick\n");
                dprintf("%p %6p     %c%c%c%c %6x      %s     %08p    %x\n",
                    ReadField(VirtualAddress),
                    PageFrameNumber,
                #define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                                    PP(PoolTag),
                                    PP(PoolTag >> 8),
                                    PP(PoolTag >> 16),
                                    PP(PoolTag >> 24),
                #undef PP
                    (ULONG) ReadField(NumberOfBytesRequested),
                    ReadField(Pagable) ? "Yes" : "No ",
                    ReadField(Thread),
                    ReadField(TickCount));

                dprintf("\tCALL STACK AT TIME OF DEALLOCATION\n");

                //
                // Calculate the relative stack and print it here symbolically.
                //

                StackBytes = (ULONG) ReadField(StackBytes);

                StackPointer = ReadField(StackPointer);

                ValidBp = (StackPointer & ~(ULONG64)(PageSize - 1));
                ChainedBp = (PAddress + StkOffset);
                LastBp = (ChainedBp + (ULONG) ReadField(StackBytes));

                while (ChainedBp < LastBp) {

                    //
                    // Read directly from physical memory.
                    //

                    InitTypeReadPhysical(ChainedBp, nt!_LIST_ENTRY);
                    ChainedBpVal = ReadField(Flink);
                    InitTypeReadPhysical(LastBp, nt!_LIST_ENTRY);
                    LastBpVal = ReadField(Flink);

                    //
                    // Find a valid frame register chain.
                    //

                    if ((((ChainedBpVal) & ~(ULONG64)(PageSize - 1)) == ValidBp) &&
                        (ChainedBpVal > StackPointer) &&
                        ((ChainedBpVal - (StackPointer)) <= StackBytes)) {
                        ULONG64 ReturnAddressVal;

                        //
                        // Increment to the stacked return address.
                        //

                        ReturnAddress = ChainedBp + PtrSize;
                        InitTypeReadPhysical(ReturnAddress, nt!_LIST_ENTRY);
                        ReturnAddressVal = ReadField(Flink);

                        SymbolBuffer[0] = '!';
                        GetSymbol((ReturnAddressVal), (PUCHAR)SymbolBuffer, &displacement);

                        dprintf ("\t%s", SymbolBuffer);

                        if (displacement) {
                            dprintf( "+0x%x", displacement );
                        }

                        dprintf( "\n" );

#ifdef SLOW_BUT_THOROUGH
                        ChainedBp += PtrSize;
#else
                        if ((ReturnAddressVal & ~MAXLONG64_PTR) == 0) {
                            break;
                        }

                        //
                        // Subtract the stackpointer & add stackdata offset.
                        //

                        ChainedBp = (ChainedBpVal - StackPointer + StkOffset);

                        //
                        // Adjust for relative.
                        //

                        ChainedBp = (PAddress + ChainedBp);
#endif
                    }
                    else {
                        ChainedBp += PtrSize;
                    }
                }

                dprintf("\n");

                if (Address != (ULONG64)-1) {
                    break;
                }
            }
        }

        if (CheckControlC()) {
            break;
        }

        PageFrameNumber = Blink;
    }

    LocalFree(Buffer);

    return S_OK;
}


USHORT
GetPfnRefCount(
    IN ULONG64 PageFrameNumber
    )
{
    ULONG64 PfnDb;
    ULONG64 Pfn;
    ULONG64 PfnStart;
    ULONG PfnSize;
    ULONG ReferenceCount;

    PfnSize = GetTypeSize("nt!_MMPFN");

    PfnDb = GetNtDebuggerData(MmPfnDatabase );

    if (!PfnDb) {
        dprintf("unable to get PFN0 database address\n");
        return 0;
    }

    if (!ReadPointer(PfnDb,&PfnStart)) {
        dprintf("unable to get PFN database address %p\n", PfnDb);
        return 0;
    }

    Pfn = (PfnStart + PageFrameNumber * PfnSize);

    if (GetFieldValue(Pfn,"nt!_MMPFN","u3.e2.ReferenceCount", ReferenceCount)) {
        dprintf("%08p: unable to get PFN element %x\n", Pfn, PfnSize);
        return 0;
    }

    return (USHORT) ReferenceCount;
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////// Dump irql tracking log
/////////////////////////////////////////////////////////////////////

VOID
DumpTrackIrqlLog (
    PCSTR args
    )
{
    ULONG64 TrackIrqlQueueAddress;
    ULONG64 TrackIrqlIndexAddress;
    ULONG64 TrackIrqlQueueLengthAddress;
    ULONG64 TrackIrqlQueue;
    ULONG TrackIrqlIndex;
    ULONG TrackIrqlQueueLength;
    ULONG I, Index;
    ULONG64 Address;
    ULONG TrackIrqlTypeSize;
    UCHAR SymbolName[256];
    ULONG64 SymbolAddress;
    ULONG64 SymbolOffset;
    ULONG Result;
    ULONG ShowCount;
    ULONG Flags;

    //
    // Read how many traces we want to see.
    //

    ShowCount = 0;

    if (args) {
        ULONG64 tmp;

        if (GetExpressionEx(args, &tmp, &args)) {
            Flags = (ULONG) tmp;
            if (!sscanf (args, "%u", &ShowCount)) {
                ShowCount = 0;
            }
        }

        if (ShowCount == 0) {
            ShowCount = 4;
        }
    }
    else {
        ShowCount = 4;
    }

    //
    // Read track irql package data
    //

    TrackIrqlQueueAddress = GetExpression ("nt!ViTrackIrqlQueue");
    TrackIrqlIndexAddress = GetExpression ("nt!ViTrackIrqlIndex");
    TrackIrqlQueueLengthAddress = GetExpression ("nt!ViTrackIrqlQueueLength");

    if (TrackIrqlQueueAddress == 0
        || TrackIrqlIndexAddress == 0
        || TrackIrqlIndexAddress == 0) {

        dprintf ("Incorrect symbols. \n");
        return;
    }

    ReadPointer (TrackIrqlQueueAddress, &TrackIrqlQueue);

    if (TrackIrqlQueue == 0) {

        dprintf ("Irql tracking is not enabled. You need to enable driver verifier \n");
        dprintf ("for at least one driver to activate irql tracking.               \n");
        return;
    }

    ReadMemory (TrackIrqlIndexAddress, &TrackIrqlIndex, sizeof(ULONG), &Result);

    if (Result != sizeof(ULONG)) {
        dprintf ("Trackirql: read error \n");
        return;
    }

    ReadMemory (TrackIrqlQueueLengthAddress, &TrackIrqlQueueLength, sizeof(ULONG), &Result);

    if (Result != sizeof(ULONG)) {
        dprintf ("Trackirql: read error \n");
        return;
    }

    TrackIrqlTypeSize = GetTypeSize("nt!_VI_TRACK_IRQL");

    //
    // Dump information
    //

    dprintf ("\nSize of track irql queue is 0x%X \n", TrackIrqlQueueLength);

    for (I = 0, Index = TrackIrqlIndex; I < TrackIrqlQueueLength; I += 1) {

        if (I >= ShowCount) {
            break;
        }

        Index -= 1;
        Index &= (TrackIrqlQueueLength - 1);

        Address = TrackIrqlQueue + Index * TrackIrqlTypeSize;
        InitTypeRead (Address, nt!_VI_TRACK_IRQL);

        dprintf ("\n");
        dprintf ("Thread:             %I64X\n", ReadField (Thread));
        dprintf ("Old irql:           %I64X\n", ReadField (OldIrql));
        dprintf ("New irql:           %I64X\n", ReadField (NewIrql));
        dprintf ("Processor:          %I64X\n", ReadField (Processor));
        dprintf ("Time stamp:         %I64X\n", ReadField (TickCount));
        dprintf ("\n");

        SymbolAddress = ReadField(StackTrace[0]);
        if (SymbolAddress == 0) { continue; }
        GetSymbol(SymbolAddress, SymbolName, &SymbolOffset);
        dprintf ("    %I64X %s+0x%I64x\n", SymbolAddress, SymbolName, SymbolOffset);

        SymbolAddress = ReadField(StackTrace[1]);
        if (SymbolAddress == 0) { continue; }
        GetSymbol(SymbolAddress, SymbolName, &SymbolOffset);
        dprintf ("    %I64X %s+0x%I64x\n", SymbolAddress, SymbolName, SymbolOffset);

        SymbolAddress = ReadField(StackTrace[2]);
        if (SymbolAddress == 0) { continue; }
        GetSymbol(SymbolAddress, SymbolName, &SymbolOffset);
        dprintf ("    %I64X %s+0x%I64x\n", SymbolAddress, SymbolName, SymbolOffset);

        SymbolAddress = ReadField(StackTrace[3]);
        if (SymbolAddress == 0) { continue; }
        GetSymbol(SymbolAddress, SymbolName, &SymbolOffset);
        dprintf ("    %I64X %s+0x%I64x\n", SymbolAddress, SymbolName, SymbolOffset);

        SymbolAddress = ReadField(StackTrace[4]);
        if (SymbolAddress == 0) { continue; }
        GetSymbol(SymbolAddress, SymbolName, &SymbolOffset);
        dprintf ("    %I64X %s+0x%I64x\n", SymbolAddress, SymbolName, SymbolOffset);

        if (CheckControlC()) {
            dprintf ("Interrupted \n");
            break;
        }

    }
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////// Dump fault injection trace log
/////////////////////////////////////////////////////////////////////

ULONG64
ReadPvoid (
    ULONG64 Address
    )
{
    ULONG64 RemoteValue = 0;
    ReadPointer( Address, &RemoteValue);
    return RemoteValue;
}

ULONG
ReadUlong(
    ULONG64 Address
    )
{
    ULONG RemoteValue = 0;
    ReadMemory( Address, &RemoteValue, sizeof( ULONG ), NULL );
    return RemoteValue;
}

VOID
DumpFaultInjectionTrace (
    ULONG64 Address
    )
{
    ULONG64 ReturnAddress;
    CHAR  SymbolName[ 1024 ];
    ULONG64 Displacement;
    ULONG I;
    ULONG PvoidSize;

    PvoidSize = IsPtr64() ? 8 : 4;


    for (I = 0; I < 8; I += 1) {

        ReturnAddress = ReadPvoid (Address + I * PvoidSize);

        if (ReturnAddress == 0) {
            break;
        }

        GetSymbol (ReturnAddress, SymbolName, &Displacement);

        dprintf ("    %p %s+0x%p\n",
                 ReturnAddress,
                 SymbolName,
                 Displacement);
    }
}

VOID
DumpFaultInjectionTraceLog (
    PCSTR Args
    )
{
    ULONG TracesToDisplay = 0;
    ULONG64 TraceAddress;
    ULONG64 Trace;
    ULONG64 IndexAddress;
    ULONG Index;
    ULONG64 LengthAddress;
    ULONG Length;
    ULONG I;
    ULONG PvoidSize;
    ULONG64 TraceBlockAddress;
    ULONG64 FirstReturnAddress;
    ULONG TracesFound = 0;
    BOOLEAN Interrupted = FALSE;
    ULONG Flags;

    if (Args) {

        ULONG64 tmp;

        if (GetExpressionEx(Args, &tmp, &Args)) {
            Flags = (ULONG) tmp;
            if (!sscanf (Args, "%u", &TracesToDisplay)) {
                TracesToDisplay = 0;
            }
        }


        if (TracesToDisplay == 0) {
            TracesToDisplay = 4;
        }
    }
    else {
        TracesToDisplay = 4;
    }

    PvoidSize = IsPtr64() ? 8 : 4;

    TraceAddress = (ULONG64) GetExpression ("nt!ViFaultTraces");
    IndexAddress = (ULONG64) GetExpression ("nt!ViFaultTracesIndex");
    LengthAddress = (ULONG64) GetExpression ("nt!ViFaultTracesLength");

    Trace = ReadPvoid (TraceAddress);

    if (Trace == 0) {
        dprintf ("Driver fault injection is not enabled for this system. \n");
        return;
    }

    Index = ReadUlong (IndexAddress);
    Length = ReadUlong (LengthAddress);

    for (I = 0; I < Length; I += 1) {

        Index -= 1;
        Index &= (Length - 1);

        TraceBlockAddress = Trace + Index * PvoidSize * 8;
        FirstReturnAddress = ReadPvoid (TraceBlockAddress);

        if (FirstReturnAddress != 0) {
            TracesFound += 1;

            dprintf ("\n");
            DumpFaultInjectionTrace (TraceBlockAddress);

            if (TracesFound >= TracesToDisplay) {
                break;
            }
        }

        if (CheckControlC()) {
            Interrupted = TRUE;
            dprintf ("Interrupted \n");
            break;
        }
    }

    if (Interrupted == FALSE && TracesFound == 0) {

        dprintf ("No fault injection traces found. \n");
    }
}

PUCHAR MemoryDescriptorType[] = {
    "ExceptionBlock",
    "SystemBlock",
    "Free",
    "Bad",
    "LoadedProgram",
    "FirmwareTemporary",
    "FirmwarePermanent",
    "OsloaderHeap",
    "OsloaderStack",
    "SystemCode",
    "HalCode",
    "BootDriver",
    "ConsoleInDriver",
    "ConsoleOutDriver",
    "StartupDpcStack",
    "StartupKernelStack",
    "StartupPanicStack",
    "StartupPcrPage",
    "StartupPdrPage",
    "RegistryData",
    "MemoryData",
    "NlsData",
    "SpecialMemory",
    "BBTMemory",
    "LoaderReserve",
    "XIPRom",
    "HALCachedMemory"
    };

#define MAXIMUM_MEMORY_TYPE (sizeof(MemoryDescriptorType)/sizeof(UCHAR))

DECLARE_API( loadermemorylist )

/*++

Routine Description:

    Displays the memory allocation list.   This is the list
    handed to the OS by the OSLOADER that describes physical
    memory.
    Displays the corresponding PDE and PTE.

Arguments:

    list - points to the listheader

Return Value:

    None.

--*/

{
    ULONG64 ListHeaderAddress;
    ULONG64 EntryAddress;
    ULONG64 LengthInPages;
    ULONG64 TypeOfMemory;
    ULONG   Count[MAXIMUM_MEMORY_TYPE];
    ULONG   i;

    UNREFERENCED_PARAMETER (Client);

    ListHeaderAddress = 0;

    ListHeaderAddress = GetExpression(args);
    if (ListHeaderAddress == 0) {
        dprintf("Usage: !loadermemorylist <address_of_listhead>\n");
        return E_INVALIDARG;
    }

    if (!ReadPointer(ListHeaderAddress, &EntryAddress)) {
        dprintf("Unable to read list header at %p\n", ListHeaderAddress);
        return E_INVALIDARG;
    }

    if (EntryAddress == ListHeaderAddress) {
        dprintf("List at %p is empty\n", ListHeaderAddress);
        return S_OK;
    }

    dprintf("Base        Length      Type\n");

    RtlZeroMemory(Count, sizeof(Count));

    do {
        InitTypeRead(EntryAddress, nt!MEMORY_ALLOCATION_DESCRIPTOR);
        TypeOfMemory = ReadField(MemoryType);
        if (TypeOfMemory < MAXIMUM_MEMORY_TYPE) {
            LengthInPages = ReadField(PageCount);
            dprintf("%08x    %08x    %s\n",
                    (ULONG)ReadField(BasePage),
                    (ULONG)LengthInPages,
                    MemoryDescriptorType[TypeOfMemory]);
            Count[TypeOfMemory] += (ULONG)LengthInPages;
        } else {
            dprintf("Unrecognized Descriptor at %p\n", EntryAddress);
        }
        EntryAddress = ReadField(ListEntry.Flink);
    } while (EntryAddress != ListHeaderAddress);

    dprintf("\nSummary\nMemory Type         Pages\n");
    LengthInPages = 0;
    for (i = 0; i < MAXIMUM_MEMORY_TYPE; i++) {
        if (Count[i]) {
            dprintf("%-20s%08x   (%8d)\n",
                    MemoryDescriptorType[i],
                    Count[i],
                    Count[i]);
            LengthInPages += Count[i];
        }
    }
    dprintf("                    ========    ========\n");
    dprintf("Total               %08x   (%8d) = ~%dMB\n",
            (ULONG)LengthInPages,
            (ULONG)LengthInPages,
            (ULONG)LengthInPages / (1024 * 1024 / 4096));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\npx.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    trap.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

typedef struct {
    ULONG   Mask;
    PUCHAR  String;
} BITENCODING, *PBITENCODING;

typedef unsigned __int64 ULONGLONG;

void  DumpNpxULongLong (PUCHAR s, ULONGLONG  l);
void  DumpNpxExtended  (PUCHAR str, PUCHAR Value);
void  DumpNpxBits      (ULONG, PUCHAR, PBITENCODING);

PUCHAR NpxPrecisionControl[] = { "24Bits", "?1?", "53Bits", "64Bits" };
PUCHAR NpxRoundingControl[]  = { "Nearest", "Down", "Up", "Chop" };
PUCHAR NpxTagWord[]          = { "  ", "ZR", "SP", "  " };

BITENCODING NpxStatusBits[]  = {
        1 <<  8,    "C0",
        1 <<  9,    "C1",
        1 << 10,    "C2",
        1 << 14,    "C3",
        0x8000,     "Busy",
        0x0001,     "InvalidOp",
        0x0002,     "Denormal",
        0x0004,     "ZeroDivide",
        0x0008,     "Overflow",
        0x0010,     "Underflow",
        0x0020,     "Precision",
        0x0040,     "StackFault",
        0x0080,     "Summary",
        0,          0
        };

PUCHAR  NpxOpD8[] = {
        "fadd",  "fmul",  "fcom",  "fcomp",  "fsub",   "fsubr",  "fdiv",   "fdivr"
        };

PUCHAR  NpxOpD9[] = {
        "fld",   "??3",   "fst",   "fstp",   "fldenv", "fldcw",  "fstenv", "fstcw"
        };

PUCHAR  NpxOpDA[] = {
        "fiadd", "fimul", "ficom", "ficomp", "fisub",  "fisubr", "fidiv",  "fidivr"
        };

PUCHAR  NpxOpDB[] = {
        "fild",  "??4",   "fist",  "fistp",  "??5",    "fld",    "??6",    "fstp"
        };

PUCHAR  NpxOpDF[] = {
        "fild",  "??4",   "fist",  "fistp",  "fbld",   "fild",   "fbstp",  "fstp"
        };

PUCHAR *NpxSmOpTable[] = {
    NpxOpD8,
    NpxOpD9,
    NpxOpDA,
    NpxOpDB,
    NpxOpD8,    // DC
    NpxOpD9,    // DD
    NpxOpDA,    // DE
    NpxOpDF
    };






DECLARE_API( npx )

/*++

Routine Description:

    Dumps FNSAVE area format of NPX state

Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG64             Address;
    UCHAR               s[300], Reg[100];
    PUCHAR              Stack, p;
    ULONG               i, j, t, tos, Tag;
    ULONG               ControlWord, StatusWord;

    // X86_ONLY_API
    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("!npx is X86 Only API\n");
        return E_INVALIDARG;
    }

    Address = GetExpression(args);

    if ( InitTypeRead(
            Address,
            FLOATING_SAVE_AREA)) {

        dprintf("unable to read floating save area\n");
        return  E_INVALIDARG;
    }
    ControlWord = (ULONG) ReadField(ControlWord);
    dprintf ("EIP.......: %08x  ControlWord: %s-%s mask: %02x   Cr0NpxState: %08x\n",
        (ULONG) ReadField(ErrorOffset),
        NpxPrecisionControl [(ControlWord >> 8)  & 0x3],
        NpxRoundingControl  [(ControlWord >> 10) & 0x3],
        ControlWord & 0x3f,
        (ULONG) ReadField(Cr0NpxState)
        );

    DumpNpxBits ( StatusWord = (ULONG) ReadField(StatusWord), s, NpxStatusBits);
    tos = (StatusWord >> 11) & 7,

    dprintf ("StatusWord: %04x TOS:%x %s  (tagword: %04x)\n",
        StatusWord & 0xffff,
        tos,
        s,
        (ULONG) ReadField(TagWord) & 0xffff
        );

    GetFieldValue(Address, "FLOATING_SAVE_AREA", "RegisterArea", Reg);
    Stack = &Reg[0];

    Tag   = (ULONG) ReadField(TagWord);
    for (i=0; i < 8; i++) {
        j = (tos + i) & 7;
        t = (Tag >> (j*2)) & 3;

        if (t != 3) {
            sprintf (s, "%x%c%s",
                j,
                j == tos ? '>' : '.',
                NpxTagWord [t]
                );

            DumpNpxExtended (s, Stack);
        }

        Stack += 10;    // next stack location
    }

    dprintf ("\n");
    return S_OK;
}


void  DumpNpxBits (
        ULONG           Value,
        PUCHAR          Str,
        PBITENCODING    Bits
    )
{
    BOOLEAN     Flag;

    Flag = FALSE;
    *Str = 0;

    while (Bits->Mask) {
        if (Bits->Mask & Value) {
            if (Flag) {
                Str += sprintf (Str, ", %s", Bits->String);
            } else {
                Str += sprintf (Str, "%s", Bits->String);
                Flag = TRUE;
            }
        }

        Bits += 1;
    }
}


void
DumpNpxULongLong (
    PUCHAR      s,
    ULONGLONG   l
    )
{
    UCHAR   c;
    UCHAR   t[80], *p;

    if (l == 0) {
        *(s++)= '0';
    }

    p = t;
    while (l) {
        c = (UCHAR) ((ULONGLONG) l % 10);
        *(p++) = c + '0';
        l /= 10;
    }

    while (p != t) {
        *(s++) = *(--p);
    }
    *(s++) = 0;
}

void
DumpNpxExtended (
    PUCHAR  str,
    PUCHAR  Value
    )
{
    UCHAR       *p, *o, c, out[100], t[100], ssig[100], ExponSign, SigSign;
    ULONG       i, indent, mag, scale;
    LONG        expon, delta;
    ULONGLONG   sig;

    p = Value;
    c = 0;
    o = out+90;
    indent = strlen (str) + 1;

    dprintf ("%s ", str);

    //
    // Build string of bits
    //

    *(--o) = 0;
    while (c < 80) {
        *(--o) = (*p & 0x01) + '0';
        *p >>= 1;
        c += 1;
        if ((c % 8) == 0) {
            p += 1;
        }
    }
    p = o;


    //dprintf (" %s\n", o);
    //dprintf ("%*s", indent, "");


    //
    // print bit string seperated into fields
    //

    p = o;
    //dprintf ("%c %15.15s 1%c%s\n", p[0], p+1, '.', p+1+15);
    //dprintf ("%*s", indent, "");

    //
    // Pull out exponent
    //

    expon = 0;
    p = o + 1;
    for (i=0; i < 15; i++) {
        expon *= 2;
        if (p[i] == '1') {
            expon += 1;
        }
    }

    expon -= 16383;                     // take out exponent bias

    //
    // Build sig into big #
    //

    p = o + 1+15;
    scale = 0;
    for (i=0; p[i]; i++) {
        if (p[i] == '1') {
            scale = i+1;
        }
    }
    SigSign = p[i-1] == '0' ? '+' : '-';

    sig = 0;
    for (i=0; i < scale; i++) {
        sig <<= 1;
        if (p[i] == '1') {
            sig += 1;
        }
    }

    delta = expon - (scale - 1);
    //dprintf ("delta %d, expon %d, scale %d\n", delta, expon, scale);

    //
    // Print values of each field
    //

    DumpNpxULongLong (ssig, sig);

    p = o;
    ExponSign = p[0] == '0' ? '+' : '-';
    dprintf ("%c %15.15s (%+5d) %c%c%s\n",
        ExponSign,
        p + 1,
        expon,
        p[1+15], '.', p+1+15+1
        );
    dprintf ("%*s", indent, "");

    if (expon == -16383) {
        if (SigSign == '+') {
            dprintf ("Denormal\n\n");
        } else {
            dprintf ("Pseudodenormal\n\n");
        }
        return ;
    }

    if (expon == 1024) {
        if (scale == 1) {
            dprintf ("%c Infinity\n", ExponSign);
        } else {

            p = o + 1+15;
            c = 0;
            for (i=0; p[i]; i++) {
                if (p[i] == '1') {
                    c++;
                }
            }

            if (SigSign == '+') {
                dprintf ("Signaling NaN\n");
            } else {
                if (c == 1) {
                    dprintf ("Indefinite - quite NaN\n");
                } else {
                    dprintf ("Quite NaN\n");
                }
            }
        }

        dprintf ("%*s", indent, "");
    }


    //dprintf ("%*s%c %15d %s    (delta %d)\n",
    //    indent, "",                     // indent
    //    p[0]    == '0' ? '+' : '-',     // sign of exponent
    //    expon, ssig,
    //    delta
    //    );
    //dprintf ("%*s", indent, "");

    t[0] = 0;
    p = t;
    if (delta < 0) {
        p += sprintf (p, "/ ");
        delta = -delta;
    } else if (delta > 0) {
        p += sprintf (p, "* ");
    }

    if (delta) {
        if (delta < 31) {
            p += sprintf (p, "%d", 1 << delta);
        } else {
            p += sprintf (p, "2^%d", delta);
        }
    }

    dprintf ("%s %s\n",
        ssig,
        t
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\mtrr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mtrr.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris (kenr) 06-June-1994

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

ULONG
FindFirstSetRightBit (
    IN ULONGLONG    Set
    );

ULONGLONG
MaskToLength (
    IN ULONGLONG    Mask
    );

//
// MTRR MSR architecture definitions
//

#define MTRR_MSR_CAPABILITIES       0x0fe
#define MTRR_MSR_DEFAULT            0x2ff
#define MTRR_MSR_VARIABLE_BASE      0x200
#define MTRR_MSR_VARIABLE_MASK     (MTRR_MSR_VARIABLE_BASE+1)

#define MTRR_PAGE_SIZE              4096
#define MTRR_PAGE_MASK              (MTRR_PAGE_SIZE-1)

//
// Memory range types
//

#define MTRR_TYPE_UC            0
#define MTRR_TYPE_USWC          1
#define MTRR_TYPE_WT            4
#define MTRR_TYPE_WP            5
#define MTRR_TYPE_WB            6
#define MTRR_TYPE_MAX           7


// #include "pshpack1.h"

typedef struct _MTRR_CAPABILITIES {
    union {
        struct {
            ULONG VarCnt:8;
            ULONG FixSupported:1;
            ULONG Reserved_0:1;
            ULONG UswcSupported:1;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_CAPABILITIES;


typedef struct _MTRR_DEFAULT {
    union {
        struct {
            ULONG Type:8;
            ULONG Reserved_0:2;
            ULONG FixedEnabled:1;
            ULONG MtrrEnabled:1;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_DEFAULT;

typedef struct _MTRR_VARIABLE_BASE {
    union {
        struct {
            ULONGLONG   Type:8;
            ULONGLONG   Reserved_0:4;
            ULONGLONG   PhysBase:52;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_VARIABLE_BASE;

#define MTRR_MASK_BASE  (~0xfff)

typedef struct _MTRR_VARIABLE_MASK {
    union {
        struct {
            ULONGLONG   Reserved_0:11;
            ULONGLONG   Valid:1;
            ULONGLONG   PhysMask:52;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_VARIABLE_MASK;

#define MTRR_MASK_MASK  (~0xfff)

// Added support for Mask2Length conversion
#define MTRR_MAX_RANGE_SHIFT    36
#define MASK_OVERFLOW_MASK  (~0x1000000000)

CCHAR FindFirstSetRight[256] = {
        0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};


// #include "poppack.h"

//
// ----------------------------------------------------------------
//

PUCHAR
MtrrType (
    IN ULONG    Type
    )
{
    PUCHAR  p;
    static  UCHAR s[20];

    switch (Type) {
        case 0:     p = "UC";     break;
        case 1:     p = "USWC";     break;
        case 4:     p = "WT";     break;
        case 5:     p = "WP";     break;
        case 6:     p = "WB";     break;
        default:
            sprintf (s, "%02x??", Type & 0xff);
            p = s;
            break;
    }
    return p;
}

VOID
MtrrDumpFixed (
    IN ULONG    Base,
    IN ULONG    Size,
    IN ULONG    Msr
    )
{
    ULONG       x;
    ULONGLONG   li;

    ReadMsr(Msr, &li);

    for (x=0; x < 8; x++) {
        dprintf ("%s:%05x-%05x  ",
            MtrrType ( ((ULONG) li) & 0xff ),
            Base,
            Base + Size - 1
            );

        li >>= 8;
        Base += Size;

        if (x == 3) {
            dprintf ("\n");
        }
    }

    dprintf ("\n");
}


#define KF_MTRR             0x00000040

DECLARE_API( mtrr )

/*++

Routine Description:

    Dumps processors mtrr

Arguments:

    args - none

Return Value:

    None

--*/
{
    MTRR_CAPABILITIES   Capabilities;
    MTRR_DEFAULT        Default;
    MTRR_VARIABLE_BASE  Base;
    MTRR_VARIABLE_MASK  Mask;
    ULONG               Index;
    ULONG               i;
    PUCHAR              p;
    ULONG               fb;
    ULONG64             addr=0;
    ULONGLONG           Length, MtrrBase, MtrrMask;
    BOOL                ContiguousLength = TRUE;

    //
    // Quick sanity check
    //
    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("!mtrr is X86 only Api.\n");
        return E_INVALIDARG;
    }

    i = 0;
    addr = GetExpression(args);

    if (i != 1) {
        addr = GetExpression("KeFeatureBits");
        if (!addr) {
            dprintf ("KeFeatureBits not found\n");
            return E_INVALIDARG;
        }

        fb = 0;
        ReadMemory(addr, &fb, sizeof(i), &i);
        if (fb == -1  ||  !(fb & KF_MTRR)) {
            dprintf ("MTRR feature not present\n");
            return E_INVALIDARG;
        }
    }

    //
    // Dump MTRR
    //

    ReadMsr(MTRR_MSR_CAPABILITIES, &Capabilities.u.QuadPart);
    ReadMsr(MTRR_MSR_DEFAULT, &Default.u.QuadPart);

    dprintf ("MTTR: %s Var %d, Fixed-%s %s, USWC-%s, Default: %s\n",
        Default.u.hw.MtrrEnabled ? "" : "disabled",
        Capabilities.u.hw.VarCnt,
        Capabilities.u.hw.FixSupported ? "support" : "none",
        Default.u.hw.FixedEnabled ? "enabled" : "disabled",
        Capabilities.u.hw.UswcSupported ? "supported" : "none",
        MtrrType (Default.u.hw.Type)
        );

    MtrrDumpFixed (0x00000, 64*1024, 0x250);
    MtrrDumpFixed (0x80000, 16*1024, 0x258);
    MtrrDumpFixed (0xA0000, 16*1024, 0x259);
    MtrrDumpFixed (0xC0000,  4*1024, 0x268);
    MtrrDumpFixed (0xC8000,  4*1024, 0x269);
    MtrrDumpFixed (0xD0000,  4*1024, 0x26A);
    MtrrDumpFixed (0xD8000,  4*1024, 0x26B);
    MtrrDumpFixed (0xE0000,  4*1024, 0x26C);
    MtrrDumpFixed (0xE8000,  4*1024, 0x26D);
    MtrrDumpFixed (0xF0000,  4*1024, 0x26E);
    MtrrDumpFixed (0xE8000,  4*1024, 0x26F);

    dprintf ("Variable:                Base               Mask               Length\n");
    for (Index=0; Index < (ULONG) Capabilities.u.hw.VarCnt; Index++) {
        ReadMsr(MTRR_MSR_VARIABLE_BASE+2*Index, &Base.u.QuadPart);
        ReadMsr(MTRR_MSR_VARIABLE_MASK+2*Index, &Mask.u.QuadPart);
        dprintf (" %2d. ", Index);
        if (Mask.u.hw.Valid) {
            MtrrMask = Mask.u.QuadPart & MTRR_MASK_MASK;
            MtrrBase = Base.u.QuadPart & MTRR_MASK_BASE;
            Length = MaskToLength(MtrrMask);
                // Check for non-contiguous MTRR mask.
                if ((MtrrMask + Length) & MASK_OVERFLOW_MASK) {
                    ContiguousLength = FALSE;
                }

            dprintf ("%4s: %08x:%08x  %08x:%08x  %08x:%08x",
                MtrrType ((ULONG) Base.u.hw.Type),
                (ULONG) (Base.u.QuadPart >> 32), (ULONG) MtrrBase,
                (ULONG) (Mask.u.QuadPart >> 32), (ULONG) MtrrMask,
                (ULONG) (Length >> 32), (ULONG) Length);
            if (ContiguousLength == FALSE) {
                ContiguousLength = TRUE;
                dprintf("(non-contiguous)\n");
            }
            else {
                dprintf("\n");
            }

        } else {
            dprintf ("\n");
        }
    }
    return S_OK;
}


ULONGLONG
MaskToLength (
    IN ULONGLONG    Mask
    )
/*++

Routine Description:

    This function returns the length specified by a particular
    mtrr variable register mask.

--*/
{
    if (Mask == 0) {
        // Zero Mask signifies a length of      2**36
        return(((ULONGLONG) 1 << MTRR_MAX_RANGE_SHIFT));
    } else {
        return(((ULONGLONG) 1 << FindFirstSetRightBit(Mask)));
    }
}

ULONG
FindFirstSetRightBit (
    IN ULONGLONG    Set
    )
/*++

Routine Descrip