 && pfcsA->pszInfoTip && SUCCEEDED(hr))
            {
                hr = SHAllocAndThunkAnsiToTChar(pfcsA->pszInfoTip, &pszInfoTip, pfcsA->cchInfoTip);
            }

            if (pfcsA->dwMask & FCSM_ICONFILE && pfcsA->pszIconFile && SUCCEEDED(hr))
            {
                hr = SHAllocAndThunkAnsiToTChar(pfcsA->pszIconFile, &pszIconFile, pfcsA->cchIconFile);
            }

            if (pfcsA->dwMask & FCSM_LOGO && pfcsA->pszLogo && SUCCEEDED(hr))
            {
                hr = SHAllocAndThunkAnsiToTChar(pfcsA->pszLogo, &pszLogo, pfcsA->cchLogo);
            }
        }
        else if (dwReadWrite == FCS_READ)
        {
            if (pfcsA->dwMask & FCSM_WEBVIEWTEMPLATE && pfcsA->pszWebViewTemplate && pfcsA->cchWebViewTemplate > 0)
            {
                pszWebViewTemplate = (LPTSTR)LocalAlloc(LPTR, pfcsA->cchWebViewTemplate * sizeof(TCHAR));
                if (!pszWebViewTemplate)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszWebViewTemplate[0] = 0;
                    if (pfcsA->pszWebViewTemplateVersion)
                    {
                        hr = SHAllocAndThunkAnsiToTChar(pfcsA->pszWebViewTemplateVersion, &pszWebViewTemplateVersion, 0);
                    }
                }
            }
            if (pfcsA->dwMask & FCSM_INFOTIP && pfcsA->pszInfoTip && pfcsA->cchInfoTip > 0 && SUCCEEDED(hr))
            {
                pszInfoTip = (LPTSTR)LocalAlloc(LPTR, pfcsA->cchInfoTip * sizeof(TCHAR));
                if (!pszInfoTip)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszInfoTip[0] = 0;
                }
            }
            if (pfcsA->dwMask & FCSM_ICONFILE && pfcsA->pszIconFile && pfcsA->cchIconFile > 0 && SUCCEEDED(hr))
            {
                pszIconFile = (LPTSTR)LocalAlloc(LPTR, pfcsA->cchIconFile * sizeof(TCHAR));
                if (!pszIconFile)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszIconFile[0] = 0;
                }
            }
            if (pfcsA->dwMask & FCSM_LOGO && pfcsA->pszLogo && pfcsA->cchLogo > 0 && SUCCEEDED(hr))
            {
                pszLogo = (LPTSTR)LocalAlloc(LPTR, pfcsA->cchLogo * sizeof(TCHAR));
                if (!pszLogo)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszLogo[0] = 0;
                }
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
        
        if (SUCCEEDED(hr))
        {
            SHFOLDERCUSTOMSETTINGS fcs;
            fcs.dwSize = sizeof(LPSHFOLDERCUSTOMSETTINGS);
            fcs.dwMask = pfcsA->dwMask;
            fcs.pvid = pfcsA->pvid;
            fcs.pszWebViewTemplate = pszWebViewTemplate;
            fcs.cchWebViewTemplate = pfcsA->cchWebViewTemplate;
            fcs.pszWebViewTemplateVersion = pszWebViewTemplateVersion;
            fcs.pszInfoTip = pszInfoTip;
            fcs.cchInfoTip = pfcsA->cchInfoTip;
            fcs.pclsid = pfcsA->pclsid;
            fcs.dwFlags = pfcsA->dwFlags;
            fcs.pszIconFile = pszIconFile;
            fcs.cchIconFile = pfcsA->cchIconFile;
            fcs.iIconIndex = pfcsA->iIconIndex;
            fcs.pszLogo = pszLogo;
            fcs.cchLogo = pfcsA->cchLogo;

            hr = SHGetSetFCS(&fcs, szPath, dwReadWrite);
            if (SUCCEEDED(hr))
            {
                if (dwReadWrite == FCS_READ)
                {
                    if (fcs.dwMask & FCSM_WEBVIEWTEMPLATE && fcs.pszWebViewTemplate)
                    {
                        SHTCharToAnsi(fcs.pszWebViewTemplate, pfcsA->pszWebViewTemplate, pfcsA->cchWebViewTemplate);
                    }
                    if (fcs.dwMask & FCSM_INFOTIP && fcs.pszInfoTip)
                    {
                        SHTCharToAnsi(fcs.pszInfoTip, pfcsA->pszInfoTip, pfcsA->cchInfoTip);
                    }
                    if (fcs.dwMask & FCSM_ICONFILE && fcs.pszIconFile)
                    {
                        SHTCharToAnsi(fcs.pszIconFile, pfcsA->pszIconFile, pfcsA->cchIconFile);
                    }
                    if (fcs.dwMask & FCSM_LOGO && fcs.pszLogo)
                    {
                        SHTCharToAnsi(fcs.pszLogo, pfcsA->pszLogo, pfcsA->cchLogo);
                    }
                    pfcsA->dwFlags = fcs.dwFlags;
                    pfcsA->iIconIndex = fcs.iIconIndex;
                    pfcsA->dwMask = fcs.dwMask;
                }
            }
        }

        // Free allocated memory
        if (pszWebViewTemplate)
        {
            LocalFree(pszWebViewTemplate);
        }
        if (pszWebViewTemplateVersion)
        {
            LocalFree(pszWebViewTemplateVersion);
        }
        if (pszInfoTip)
        {
            LocalFree(pszInfoTip);
        }

        if (pszIconFile)
        {
            LocalFree(pszIconFile);
        }

        if (pszLogo)
        {
            LocalFree(pszLogo);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fldrcust.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "util.h"
#include "datautil.h"
#include "foldertypes.h"
#include "basefvcb.h"

#define PROPSTR_LOGO L"Logo"

typedef struct
{
    UINT    uIDFriendly;
    LPCTSTR pszFolderType;
    DWORD   dwFlags;
} WEBVIEWTEMPLATEINFO;

#define WVTI_SHOWIFOLDTEMPLATE 0x00000001

// documents must be first.
const WEBVIEWTEMPLATEINFO c_wvtiList[] =
{
    { IDS_CUSTOMIZE_USELEGACYHTT, STR_TYPE_USELEGACYHTT, WVTI_SHOWIFOLDTEMPLATE },
    { IDS_CUSTOMIZE_DOCUMENTS,    STR_TYPE_DOCUMENTS,    0 },
    { IDS_CUSTOMIZE_PICTURES,     STR_TYPE_PICTURES,     0 },
    { IDS_CUSTOMIZE_PHOTOALBUM,   STR_TYPE_PHOTOALBUM,   0 },
    { IDS_CUSTOMIZE_MUSIC,        STR_TYPE_MUSIC,        0 },
    { IDS_CUSTOMIZE_MUSICARTIST,  STR_TYPE_MUSICARTIST,  0 },
    { IDS_CUSTOMIZE_MUSICALBUM,   STR_TYPE_MUSICALBUM,   0 },
    { IDS_CUSTOMIZE_VIDEOS,       STR_TYPE_VIDEOS,       0 },
// note: are these gonna happen?
//    { IDS_CUSTOMIZE_VIDEOALBUM,   STR_TYPE_VIDEOALBUM,   0 },
//    { IDS_CUSTOMIZE_BOOKS,        STR_TYPE_BOOKS,        0 }
};

typedef enum
{
    FOLDERCUST_MODE_GENERATING,
    FOLDERCUST_MODE_ICON,
    FOLDERCUST_MODE_BITMAP
} FOLDERCUSTMODE;

class CFolderCustomize : public IShellExtInit,
                         public IShellPropSheetExt
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
        { return S_OK; };

    CFolderCustomize();

private:
    ~CFolderCustomize();
    static UINT CALLBACK _PrshtCallback(HWND hwnd, UINT uMsg, PROPSHEETPAGE *ppsp);
    void _SetRecurseBox(HWND hwnd);
    void _HideIconSection(HWND hwnd);
    void _InitDialog(HWND hwnd);
    BOOL _HandleWMCommand(HWND hwndDlg, WORD wNotify, WORD wID, HWND hwndCtrl);
    void _EnableApply(HWND hwnd);

    static DWORD WINAPI _ExtractThreadProc(void *pv);
    HRESULT _ExtractOnSeparateThread(IPropertyBag *ppb, HWND hwndDlg);
    HRESULT _CreateThumbnailBitmap(HWND hwndDlg);
    HRESULT _CreateFolderIcon(HWND hwndDlg);
    void _SetThumbnail(HWND hwnd);
    void _FreeDlgItems(HWND hwndDlg);
    void _SetPreviewToNewState(HWND hwndDlg, FOLDERCUSTMODE fcMode, HBITMAP hbitmap, HICON hicon);

    BOOL _ShouldEnableChangeOfIcon();
    void _ChangeFolderIcon(HWND hwndDlg);
    HRESULT _ProcessIconChange(LPCTSTR pszPickIconDialogCaption, HWND hwndDlg);

    void _DirTouch(LPITEMIDLIST pidl);
    void _DeleteCustomizationInBag(IPropertyBag *ppb);
    BOOL _NotifyAboutWebView(HWND hwnd);
    static BOOL CALLBACK _RefreshView(HWND hwnd, LPCITEMIDLIST pidl, LPARAM lParam);
    void _RefreshWindows(BOOL fTurnOnWebView, BOOL fApplyToChildren);
    HRESULT _ApplyChangesToBag(HWND hwndDlg, IPropertyBag *ppb);
    HRESULT _ApplyChanges(HWND hwndDlg);

    void _UpdateViewState(HWND hwndDlg, IPropertyBag *ppb, int iIndex);
    void _FillTemplateComboBox(HWND hwndTemplates);
    int _GetTemplateIndexFromType(LPCTSTR pszType);

    static BOOL_PTR CALLBACK _DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LONG _cRef;

    LPITEMIDLIST   _pidl;
    IPropertyBag  *_ppb;

    // used for background thread extraction
    HWND           _hwnd;
    IPropertyBag  *_ppbBackground;

    // cached info
    HBITMAP        _hbmDefault;
    HBITMAP        _hbmLogo;
    TCHAR          _szCachedLogoFile[MAX_PATH];

    BOOL           _fUsingThumb;

    ICustomIconManager *_pIconManager;
    TCHAR _szLogoFile[MAX_PATH];
    TCHAR _szIconPath[MAX_PATH];
    int _iIconIndex;
    HRESULT _hrFromIconChange;

};

CFolderCustomize::CFolderCustomize() : _cRef(1), _hrFromIconChange(E_FAIL)
{
}

CFolderCustomize::~CFolderCustomize() 
{
    ILFree(_pidl);
    if (_ppb)
        _ppb->Release();
    if (_pIconManager)
        _pIconManager->Release();
    if (_ppbBackground)
        _ppbBackground->Release();
    if (_hbmDefault)
        DeleteObject(_hbmDefault);
    if (_hbmLogo)
        DeleteObject(_hbmLogo);
}
    
STDAPI CFolderCustomize_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    // aggregation checking is handled in class factory
    
    HRESULT hr = E_OUTOFMEMORY;
    CFolderCustomize* pfc = new CFolderCustomize();
    if (pfc)
    {
        hr = pfc->QueryInterface(riid, ppvOut);
        pfc->Release();
    }
    
    return hr;
}

HRESULT CFolderCustomize::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CFolderCustomize, IShellExtInit),
        QITABENT(CFolderCustomize, IShellPropSheetExt),
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CFolderCustomize::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFolderCustomize::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

STDMETHODIMP CFolderCustomize::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    HRESULT hr;
    if (!pidlFolder)
    {
        hr = PidlFromDataObject(pdtobj, &_pidl);
    }
    else
    {
        hr = Pidl_Set(&_pidl, pidlFolder) ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = SHGetViewStatePropertyBag(_pidl, VS_BAGSTR_EXPLORER, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &_ppb));
    }
    return hr;
}

// from defview.cpp
BOOL IsCustomizable(LPCITEMIDLIST pidlFolder);

UINT CALLBACK CFolderCustomize::_PrshtCallback(HWND hwnd, UINT uMsg, PROPSHEETPAGE *ppsp)
{
    if (uMsg == PSPCB_RELEASE)
    {
        ((CFolderCustomize *)ppsp->lParam)->Release();
    }
    return 1;
}

STDMETHODIMP CFolderCustomize::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    HRESULT hr = E_FAIL;
    if (IsCustomizable(_pidl))
    {
        PROPSHEETPAGE psp = {0};
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_USECALLBACK;
        psp.hInstance   = HINST_THISDLL;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_FOLDER_CUSTOMIZE);
        psp.pfnDlgProc  = _DlgProc;
        psp.pfnCallback = _PrshtCallback;
        psp.lParam      = (LPARAM)this;

        HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);
        if (hpsp)
        {
            AddRef();   // HPROPSHEETPAGE holds ref, released on _PrshtCallback
            if (!pfnAddPage(hpsp, lParam))
            {
                DestroyPropertySheetPage(hpsp);
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    return hr;
}

#define IDH_FOLDER_TEMPLATES  10005
#define IDH_FOLDER_RECURSE    10006
#define IDH_FOLDER_PICKBROWSE 10007
#define IDH_FOLDER_DEFAULT    10008
#define IDH_FOLDER_CHANGEICON 10009

const static DWORD aPrshtHelpIDs[] = 
{
    IDC_FOLDER_TEMPLATES,       IDH_FOLDER_TEMPLATES,
    IDC_FOLDER_RECURSE,         IDH_FOLDER_RECURSE,
    IDC_FOLDER_PICKBROWSE,      IDH_FOLDER_PICKBROWSE,
    IDC_FOLDER_DEFAULT,         IDH_FOLDER_DEFAULT,
    IDC_FOLDER_CHANGEICON,      IDH_FOLDER_CHANGEICON,
    IDC_FOLDER_PREVIEW_ICON,    NO_HELP,
    IDC_FOLDER_PREVIEW_BITMAP,  NO_HELP,
    IDC_FOLDER_ICON,            NO_HELP,
    IDC_FOLDER_CHANGEICONTEXT,  NO_HELP,
    IDC_FOLDER_CHANGEICONGROUP, NO_HELP,
    IDC_NO_HELP_1,              NO_HELP,
    IDC_NO_HELP_2,              NO_HELP,
    0, 0
};

BOOL_PTR CALLBACK CFolderCustomize::_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    CFolderCustomize *pfc = (CFolderCustomize*)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pfc = (CFolderCustomize*)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pfc);
        pfc->_InitDialog(hwnd);
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, L"filefold.hlp", HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aPrshtHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, L"filefold.hlp", HELP_CONTEXTMENU, (ULONG_PTR)(void *)aPrshtHelpIDs);
        break;

    case WM_COMMAND:
        fRet = pfc->_HandleWMCommand(hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
        break;

    case WM_NOTIFY:
        if (((LPNMHDR)lParam)->code == PSN_APPLY)
        {
            pfc->_ApplyChanges(hwnd);
        }
        fRet = TRUE;
        break;

    case WM_DESTROY:
        pfc->_FreeDlgItems(hwnd);
        break;
    }
    return fRet;
}

void CFolderCustomize::_FreeDlgItems(HWND hwndDlg)
{
    HICON hicon = (HICON)SendDlgItemMessage(hwndDlg, IDC_FOLDER_PREVIEW_ICON, STM_SETICON, NULL, NULL);
    if (hicon)
        DestroyIcon(hicon);
    HBITMAP hbitmap = (HBITMAP)SendDlgItemMessage(hwndDlg, IDC_FOLDER_PREVIEW_BITMAP, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, NULL);
    if (hbitmap)
        DeleteObject(hbitmap);
    ReplaceDlgIcon(hwndDlg, IDC_FOLDER_ICON, NULL);
}

void CFolderCustomize::_SetPreviewToNewState(HWND hwndDlg, FOLDERCUSTMODE fcMode, HBITMAP hbitmap, HICON hicon)
{
    // if fcMode == FOLDERCUST_MODE_ICON, we need hicon and not hbitmap
    // if fcMode == FOLDERCUST_MODE_BITMAP, we need hbitmap and not hicon.
    // otherwise we dont want either.
    ASSERT((fcMode != FOLDERCUST_MODE_ICON) || (hicon && !hbitmap));
    ASSERT((fcMode != FOLDERCUST_MODE_BITMAP) || (!hicon && hbitmap));
    ASSERT((fcMode != FOLDERCUST_MODE_GENERATING) || (!hicon && !hbitmap));

    switch (fcMode)
    {
    case FOLDERCUST_MODE_GENERATING:
        {
            TCHAR szText[100];
            LoadString(HINST_THISDLL, IDS_CUSTOMIZE_GENERATING, szText, ARRAYSIZE(szText));
            SetWindowText(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_TEXT), szText);

            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_TEXT), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_ICON), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_BITMAP), SW_HIDE);
        }
        break;

    case FOLDERCUST_MODE_ICON:
        {
            HICON hiconOld = (HICON)SendDlgItemMessage(hwndDlg, IDC_FOLDER_PREVIEW_ICON, STM_SETICON, NULL, NULL);
            if (hiconOld)
                DestroyIcon(hiconOld);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_TEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_ICON), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_BITMAP), SW_HIDE);

            SendDlgItemMessage(hwndDlg, IDC_FOLDER_PREVIEW_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hicon);
        }
        break;
        
    case FOLDERCUST_MODE_BITMAP:
        {
            HBITMAP hbitmapOld = (HBITMAP)SendDlgItemMessage(hwndDlg, IDC_FOLDER_PREVIEW_BITMAP, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, NULL);
            if (hbitmapOld)
                DeleteObject(hbitmapOld);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_TEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_ICON), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_BITMAP), SW_SHOW);

            SendDlgItemMessage(hwndDlg, IDC_FOLDER_PREVIEW_BITMAP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hbitmap);
        }
        break;
    }
}

HRESULT CFolderCustomize::_CreateFolderIcon(HWND hwndDlg)
{
    IExtractIcon *peic;
    HRESULT hr = SHGetUIObjectFromFullPIDL(_pidl, NULL, IID_PPV_ARG(IExtractIcon, &peic));
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        INT iIndex;
        UINT wFlags;
        hr = peic->GetIconLocation(0, szPath, ARRAYSIZE(szPath), &iIndex, &wFlags);
        if (SUCCEEDED(hr))
        {
            UINT nIconSize = MAKELONG(32, 32); // 32 for both large and small
            HICON hiconLarge;
            hr = peic->Extract(szPath, iIndex, NULL, &hiconLarge, nIconSize);
            if (SUCCEEDED(hr))
            {
                ReplaceDlgIcon(hwndDlg, IDC_FOLDER_ICON, hiconLarge);
            }
        }
        peic->Release();
    }
    return hr;
}

DWORD WINAPI CFolderCustomize::_ExtractThreadProc(void *pv)
{
    CFolderCustomize *pfc = (CFolderCustomize*)pv;

    pfc->_SetPreviewToNewState(pfc->_hwnd, FOLDERCUST_MODE_GENERATING, NULL, NULL);

    IExtractImage *pei;
    HRESULT hr = SHGetUIObjectFromFullPIDL(pfc->_pidl, NULL, IID_PPV_ARG(IExtractImage, &pei));
    if (SUCCEEDED(hr))
    {
        hr = SHLoadFromPropertyBag(pei, pfc->_ppbBackground);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            SIZE sz = {96, 96};
            DWORD dwFlags = IEIFLAG_QUALITY;
            hr = pei->GetLocation(szPath, ARRAYSIZE(szPath), NULL, &sz, 24, &dwFlags);
            if (SUCCEEDED(hr))
            {
                HBITMAP hbitmap;
                hr = pei->Extract(&hbitmap);
                if (SUCCEEDED(hr))
                {
                    pfc->_SetPreviewToNewState(pfc->_hwnd, FOLDERCUST_MODE_BITMAP, hbitmap, NULL);

                    TCHAR szLogo[MAX_PATH];
                    if (SUCCEEDED(SHPropertyBag_ReadStr(pfc->_ppbBackground, PROPSTR_LOGO, szLogo, ARRAYSIZE(szLogo))))
                    {
                        HBITMAP *phbm = szLogo[0] ? &pfc->_hbmLogo : &pfc->_hbmDefault;
                        if (*phbm)
                            DeleteObject(*phbm);
                        *phbm = (HBITMAP)CopyImage(hbitmap, IMAGE_BITMAP, 0, 0, 0);

                        if (szLogo[0])
                        {
                            lstrcpyn(pfc->_szCachedLogoFile, szLogo, ARRAYSIZE(pfc->_szCachedLogoFile));
                        }
                    }
                }
            }
        }
        pei->Release();
    }

    if (FAILED(hr))
    {
        // IExtractImage on a folder without any jpegs inside will fail.
        // in that case we need IExtractIcon.
        IExtractIcon *peic;
        hr = SHGetUIObjectFromFullPIDL(pfc->_pidl, NULL, IID_PPV_ARG(IExtractIcon, &peic));
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            INT iIndex;
            UINT wFlags;
            hr = peic->GetIconLocation(0, szPath, ARRAYSIZE(szPath), &iIndex, &wFlags);
            if (SUCCEEDED(hr))
            {
                UINT nIconSize = MAKELONG(96, 96); // 96 for both large and small
                HICON hiconLarge;
                hr = peic->Extract(szPath, iIndex, NULL, &hiconLarge, nIconSize);
                if (SUCCEEDED(hr))
                {
                    pfc->_SetPreviewToNewState(pfc->_hwnd, FOLDERCUST_MODE_ICON, NULL, hiconLarge);
                }
            }
            peic->Release();
        }
    }

    pfc->Release(); // this thread holds a ref
    return 0;
}

HRESULT CFolderCustomize::_ExtractOnSeparateThread(IPropertyBag *ppb, HWND hwndDlg)
{
    HRESULT hr = E_OUTOFMEMORY;

    IUnknown_Set((IUnknown**)&_ppbBackground, ppb);
    _hwnd = hwndDlg;

    AddRef();
    if (SHCreateThread(_ExtractThreadProc, this, CTF_COINIT, NULL))
    {
        hr = S_OK;
    }
    else
    {
        Release();  // thread failed to take ref
    }

    return hr;
}

HRESULT CFolderCustomize::_CreateThumbnailBitmap(HWND hwndDlg)
{
    HRESULT hr = S_OK;
    // see if the bitmap is one we've already extracted.
    // can't use the thumbs.db cache for this kind of stuff, since the changes
    // havent been committed yet we really shouldnt be poking around in data.
    if (!_fUsingThumb && _hbmDefault)
    {
        _SetPreviewToNewState(hwndDlg, FOLDERCUST_MODE_BITMAP, (HBITMAP)CopyImage(_hbmDefault, IMAGE_BITMAP, 0, 0, 0), NULL);
    }
    else if (_fUsingThumb && _hbmLogo && (lstrcmpi(_szLogoFile, _szCachedLogoFile) == 0))
    {
        _SetPreviewToNewState(hwndDlg, FOLDERCUST_MODE_BITMAP, (HBITMAP)CopyImage(_hbmLogo, IMAGE_BITMAP, 0, 0, 0), NULL);
    }
    else
    {
        // cache miss, figure it out again.
        IPropertyBag *ppb;
        hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &ppb));
        if (SUCCEEDED(hr))
        {
            hr = SHPropertyBag_WriteStr(ppb, PROPSTR_LOGO, _fUsingThumb ? _szLogoFile : TEXT(""));
            if (SUCCEEDED(hr))
            {
                hr = _ExtractOnSeparateThread(ppb, hwndDlg);
            }
            ppb->Release();
        }
    }
    return hr;
}

// dont want OFN_NODEREFERENCELINKS so use the rundlg.cpp helper directly
STDAPI_(BOOL) _GetFileNameFromBrowse(HWND hwnd, LPTSTR szFilePath, UINT cbFilePath, LPCTSTR szWorkingDir, LPCTSTR szDefExt, LPCTSTR szFilters, LPCTSTR szTitle, DWORD dwFlags);
BOOL CFolderCustomize::_HandleWMCommand(HWND hwndDlg, WORD wNotify, WORD wID, HWND hwndCtrl)
{
    switch(wID)
    {
    case IDC_FOLDER_TEMPLATES:
        if (wNotify == LBN_SELCHANGE)
        {
            _EnableApply(hwndDlg);
        }
        break;

    case IDC_FOLDER_DEFAULT:
        _EnableApply(hwndDlg);
        _fUsingThumb = FALSE;
        _CreateThumbnailBitmap(hwndDlg);
        break;

    case IDC_FOLDER_CHANGEICON:
        _ChangeFolderIcon(hwndDlg);
        break;

    case IDC_FOLDER_PICKBROWSE:
        TCHAR szFilePath[MAX_PATH] = {0};
        TCHAR szInitialDir[MAX_PATH] = {0};

        // initial directory is current folder
        // todo: load supported file types at runtime
        if (SHGetPathFromIDList(_pidl, szInitialDir) &&
            _GetFileNameFromBrowse(hwndDlg, szFilePath, ARRAYSIZE(szFilePath), szInitialDir,
                                   MAKEINTRESOURCE(IDS_IMAGES), MAKEINTRESOURCE(IDS_IMAGESFILTER), MAKEINTRESOURCE(IDS_BROWSE),
                                   OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR))
        {
            _EnableApply(hwndDlg);
            _fUsingThumb = TRUE;
            lstrcpyn(_szLogoFile, szFilePath, ARRAYSIZE(_szLogoFile));
            _CreateThumbnailBitmap(hwndDlg);
        }
        break;
    }

    return FALSE;
}

BOOL CFolderCustomize::_NotifyAboutWebView(HWND hwnd)
{
    BOOL fRet = FALSE;

    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_WEBVIEW, FALSE);
    if (!ss.fWebView &&
        (IDYES == ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_CUSTOMIZE_TURNONWEBVIEW),
                                  MAKEINTRESOURCE(IDS_CUSTOMIZE), MB_YESNO | MB_ICONQUESTION)))
    {
        ss.fWebView = TRUE;
        SHGetSetSettings(&ss, SSF_WEBVIEW, TRUE);
        fRet = TRUE;
    }
    return fRet;
}

typedef struct
{
    LPCITEMIDLIST pidlChanged;
    BOOL fTurnOnWebView;
    BOOL fApplyToChildren;
} CUSTENUMSTRUCT;

BOOL CALLBACK CFolderCustomize::_RefreshView(HWND hwnd, LPCITEMIDLIST pidl, LPARAM lParam)
{
    CUSTENUMSTRUCT *pes = (CUSTENUMSTRUCT *)lParam;

    if (pes->fTurnOnWebView)
    {
        PostMessage(hwnd, WM_COMMAND, SFVIDM_MISC_SETWEBVIEW, TRUE);
    }
    if (ILIsEqual(pes->pidlChanged, pidl) || (pes->fApplyToChildren && ILIsParent(pes->pidlChanged, pidl, FALSE)))
    {
        PostMessage(hwnd, WM_COMMAND, SFVIDM_MISC_HARDREFRESH, 0L);
    }
    return TRUE;
}

void CFolderCustomize::_RefreshWindows(BOOL fTurnOnWebView, BOOL fApplyToChildren)
{
    CUSTENUMSTRUCT es = { _pidl, fTurnOnWebView, fApplyToChildren };
    EnumShellWindows(_RefreshView, (LPARAM)&es);
}

void CFolderCustomize::_UpdateViewState(HWND hwndDlg, IPropertyBag *ppb, int iIndex)
{
    TCHAR szOriginalType[25];
    szOriginalType[0] = 0;
    SHPropertyBag_ReadStr(ppb, PROPSTR_FOLDERTYPE, szOriginalType, ARRAYSIZE(szOriginalType));
    // only apply view state change if the folder type is changing.
    // also special case so that we dont apply a view state change if the folder has no
    // current folder type and the user didnt change the selection from "documents"
    // (i.e. they changed folder thumbnail but nothing else).
    if ((lstrcmpi(c_wvtiList[iIndex].pszFolderType, szOriginalType) != 0) &&
        (szOriginalType[0] || iIndex))
    {
        // knock out existing state, they don't want it any more.
        SHPropertyBag_Delete(ppb, VS_PROPSTR_MODE);
        SHPropertyBag_Delete(ppb, VS_PROPSTR_VID);

        SHPropertyBag_WriteStr(ppb, PROPSTR_FOLDERTYPE, c_wvtiList[iIndex].pszFolderType);

        _RefreshWindows(_NotifyAboutWebView(hwndDlg), Button_GetCheck(GetDlgItem(hwndDlg, IDC_FOLDER_RECURSE)) == BST_CHECKED);
    }
}

void CFolderCustomize::_DirTouch(LPITEMIDLIST pidl)
{
    FILETIME ftCurrent;
    GetSystemTimeAsFileTime(&ftCurrent);

    TCHAR szPath[MAX_PATH];
    if (SHGetPathFromIDList(pidl, szPath))
    {
        // woohoo yay for private flags
        // 0x100 lets us open a directory in write access
        HANDLE h = CreateFile(szPath, GENERIC_READ | 0x100,
                              FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
                              OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
        if (h != INVALID_HANDLE_VALUE)
        {
            SetFileTime(h, NULL, NULL, &ftCurrent);
            CloseHandle(h);
        }
    }
}

void CFolderCustomize::_DeleteCustomizationInBag(IPropertyBag *ppb)
{
    // this is only called when the inherit bag is getting written out.
    // so we need to scorch the existing non-inherit bag so it doesn't
    // override the inherit bag.
    SHPropertyBag_Delete(ppb, PROPSTR_FOLDERTYPE);
    SHPropertyBag_Delete(ppb, PROPSTR_LOGO);
    SHPropertyBag_Delete(ppb, VS_PROPSTR_MODE);
    SHPropertyBag_Delete(ppb, VS_PROPSTR_VID);
}

HRESULT CFolderCustomize::_ApplyChangesToBag(HWND hwndDlg, IPropertyBag *ppb)
{
    // handle webview template
    HWND hwndTemplates = GetDlgItem(hwndDlg, IDC_FOLDER_TEMPLATES);
    if (hwndTemplates)
    {
        int iIndex = ComboBox_GetCurSel(hwndTemplates);
        if (iIndex != CB_ERR)
        {
            int iViewIndex = (int)ComboBox_GetItemData(hwndTemplates, iIndex);
            _UpdateViewState(hwndDlg, ppb, iViewIndex);
        }
    }

    TCHAR szThumb[MAX_PATH];
    szThumb[0] = 0;
    if (_fUsingThumb)
    {
        lstrcpyn(szThumb, _szLogoFile, ARRAYSIZE(szThumb));
    }

    TCHAR szOriginalLogo[MAX_PATH];
    szOriginalLogo[0] = 0;
    SHPropertyBag_ReadStr(ppb, PROPSTR_LOGO, szOriginalLogo, ARRAYSIZE(szOriginalLogo));
    if (lstrcmpi(szThumb, szOriginalLogo) != 0)
    {
        SHPropertyBag_WriteStr(ppb, PROPSTR_LOGO, szThumb);
        _DirTouch(_pidl);
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, _pidl, NULL);
    }

    return S_OK;
}

HRESULT CFolderCustomize::_ApplyChanges(HWND hwndDlg)
{
    // handle icon change
    switch (_hrFromIconChange)
    {
        case S_OK:
            _pIconManager->SetIcon(_szIconPath, _iIconIndex);
            break;

        case S_FALSE:
            _pIconManager->SetDefaultIcon();
            break;
    }

    if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_FOLDER_RECURSE)) == BST_CHECKED)
    {
        IPropertyBag *ppbInherit;
        if (SUCCEEDED(SHGetViewStatePropertyBag(_pidl, VS_BAGSTR_EXPLORER, SHGVSPB_INHERIT, IID_PPV_ARG(IPropertyBag, &ppbInherit))))
        {
            _DeleteCustomizationInBag(_ppb);
            _ApplyChangesToBag(hwndDlg, ppbInherit);
            ppbInherit->Release();
        }
    }
    else
    {
        _ApplyChangesToBag(hwndDlg, _ppb);
    }

    return S_OK;
}

int CFolderCustomize::_GetTemplateIndexFromType(LPCTSTR pszType)
{
    // default to "documents"
    int iIndexFound = 0;
    for (int iIndex = 0; iIndex < ARRAYSIZE(c_wvtiList); iIndex++)
    {
        if (lstrcmpi(c_wvtiList[iIndex].pszFolderType, pszType) == 0)
        {
            iIndexFound = iIndex;
            break;
        }
    }
    return iIndexFound;
}

// Fill the combobox with templates' friendly names.
void CFolderCustomize::_FillTemplateComboBox(HWND hwndTemplates)
{
    // Disable redraws while we mess repeatedly with the contents.
    SendMessage(hwndTemplates, WM_SETREDRAW, FALSE, 0);

    TCHAR szType[25];
    szType[0] = 0;
    SHPropertyBag_ReadStr(_ppb, PROPSTR_FOLDERTYPE, szType, ARRAYSIZE(szType));

    int nFolderTypeIndex = _GetTemplateIndexFromType(szType); // store index into c_wvtiList
    int iIndex = 0; // index into combobox
    // Add each template to the listview.
    for (int nTemplate = 0; nTemplate < ARRAYSIZE(c_wvtiList); nTemplate++)
    {
        TCHAR szPath[MAX_PATH];
        SFVM_WEBVIEW_TEMPLATE_DATA wvData;
        if (!(c_wvtiList[nTemplate].dwFlags & WVTI_SHOWIFOLDTEMPLATE) ||
            (SHGetPathFromIDList(_pidl, szPath) && SUCCEEDED(DefaultGetWebViewTemplateFromPath(szPath, &wvData))))
        {
            TCHAR szFriendlyName[100];
            LoadString(HINST_THISDLL, c_wvtiList[nTemplate].uIDFriendly, szFriendlyName, ARRAYSIZE(szFriendlyName));

            int iIndexAdd = ComboBox_AddString(hwndTemplates, szFriendlyName);
            if (iIndexAdd != -1)
            {
                if (nTemplate == nFolderTypeIndex)
                {
                    iIndex = iIndexAdd;
                }
                ComboBox_SetItemData(hwndTemplates, iIndexAdd, nTemplate);
            }
        }
    }

    // pick default
    ComboBox_SetCurSel(hwndTemplates, iIndex);

    // Reenable redraws.
    SendMessage(hwndTemplates, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(hwndTemplates, NULL, TRUE);
}

void CFolderCustomize::_SetThumbnail(HWND hwnd)
{
    _szLogoFile[0] = 0;
    SHPropertyBag_ReadStr(_ppb, PROPSTR_LOGO, _szLogoFile, ARRAYSIZE(_szLogoFile));

    _fUsingThumb = _szLogoFile[0];

    _CreateThumbnailBitmap(hwnd);
}

void CFolderCustomize::_SetRecurseBox(HWND hwnd)
{
    IPropertyBag *ppbInherit;
    if (SUCCEEDED(SHGetViewStatePropertyBag(_pidl, VS_BAGSTR_EXPLORER, SHGVSPB_INHERIT, IID_PPV_ARG(IPropertyBag, &ppbInherit))))
    {
        TCHAR szTypeInherit[MAX_PATH];
        if (SUCCEEDED(SHPropertyBag_ReadStr(ppbInherit, PROPSTR_FOLDERTYPE, szTypeInherit, ARRAYSIZE(szTypeInherit))) && szTypeInherit[0])
        {
            TCHAR szType[MAX_PATH];
            if (SUCCEEDED(SHPropertyBag_ReadStr(_ppb, PROPSTR_FOLDERTYPE, szType, ARRAYSIZE(szType))) && 
                (lstrcmpi(szTypeInherit, szType) == 0))
            {
                Button_SetCheck(GetDlgItem(hwnd, IDC_FOLDER_RECURSE), TRUE);
            }
        }
        ppbInherit->Release();
    }
}

// since changing the icon isn't in the peruser property bag (yet [it was punted from whistler])
// we need to disable this section if we know it can't be modified.
void CFolderCustomize::_HideIconSection(HWND hwndDlg)
{
    ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_CHANGEICONGROUP), SW_HIDE);
    ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_CHANGEICON), SW_HIDE);
    ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_CHANGEICONTEXT), SW_HIDE);
    ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_ICON), SW_HIDE);
}

void CFolderCustomize::_InitDialog(HWND hwndDlg)
{
    HWND hwndTemplates = GetDlgItem(hwndDlg, IDC_FOLDER_TEMPLATES);
    if (hwndTemplates)
    {
        _FillTemplateComboBox(GetDlgItem(hwndDlg, IDC_FOLDER_TEMPLATES));
        EnableWindow(hwndTemplates, TRUE);

        _SetThumbnail(hwndDlg);

        // Disable the Icon Change button if we the IShellFolder doesn't support ICustomIconManager interface.
        if (_ShouldEnableChangeOfIcon())
        {
            _CreateFolderIcon(hwndDlg);
        }
        else
        {
            _HideIconSection(hwndDlg);
        }

        _SetRecurseBox(hwndDlg);
    }
}

// helpers moved from mulprsht

// How do we selectively disable for .exe
BOOL CFolderCustomize::_ShouldEnableChangeOfIcon()
{
    if (!_pIconManager)
    {   
        SHGetUIObjectFromFullPIDL(_pidl, NULL, IID_PPV_ARG(ICustomIconManager, &_pIconManager));
    }
    
    return BOOLIFY(_pIconManager);
}

void CFolderCustomize::_EnableApply(HWND hwnd)
{
    PropSheet_Changed(GetParent(hwnd), hwnd);
}

void CFolderCustomize::_ChangeFolderIcon(HWND hwndDlg)
{
    ASSERT(_pIconManager);

    TCHAR szDialogCaptionFmt[MAX_PATH];
    LoadString(HINST_THISDLL, IDS_FOLDER_PICKICONDLG_CAPTION, szDialogCaptionFmt, ARRAYSIZE(szDialogCaptionFmt));

    TCHAR szFileName[MAX_PATH], szDialogCaption[MAX_PATH];
    if (SUCCEEDED(SHGetNameAndFlags(_pidl, SHGDN_NORMAL, szFileName, ARRAYSIZE(szFileName), NULL)))
    {
        wnsprintf(szDialogCaption, ARRAYSIZE(szDialogCaption), szDialogCaptionFmt, PathFindFileName(szFileName));
    }

    if (SUCCEEDED(_ProcessIconChange(szDialogCaption, hwndDlg)))
    {
        _EnableApply(hwndDlg);
    }
}

HRESULT CFolderCustomize::_ProcessIconChange(LPCTSTR pszPickIconDialogCaption, HWND hwndDlg)
{
    int nIconIndex = -1;

    TCHAR szIconPath[MAX_PATH];
    szIconPath[0] = 0;
       
    HRESULT hr = PickIconDlgWithTitle(hwndDlg, pszPickIconDialogCaption, TRUE, szIconPath, ARRAYSIZE(szIconPath), &nIconIndex);
    _hrFromIconChange = hr;
    switch (hr)
    {
        case S_OK:
        {
            HICON hIcon = ExtractIcon(HINST_THISDLL, szIconPath, nIconIndex);
            if (hIcon != NULL)
            {
                ReplaceDlgIcon(hwndDlg, IDC_FOLDER_ICON, hIcon);
                StrCpyN(_szIconPath, szIconPath, ARRAYSIZE(_szIconPath));
                _iIconIndex = nIconIndex;
            }
            else
            {
                _hrFromIconChange = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
            break;
        }

        case S_FALSE:
        {
            HICON hIcon;
            if (SUCCEEDED(_pIconManager->GetDefaultIconHandle(&hIcon)))
            {
                ReplaceDlgIcon(hwndDlg, IDC_FOLDER_ICON, hIcon);
            }
            else
            {
                _hrFromIconChange = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
            break;
        }

        case HRESULT_FROM_WIN32(ERROR_CANCELLED):
        {
            break;
        }  
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\folderthumb.cpp ===
#include "shellprv.h"
#include "filefldr.h"
#include "ids.h"
#include "prop.h"
#include "copy.h"

// If these values are modified, the logic in Extract() must be modified too.
#define SMALLEST_THUMBNAIL_WITH_4_PREVIEWS 96
#define MAX_MINIPREVIEWS_COLLECT 8 // collect more than we're going to show, just in case one fails
#define MAX_MINIPREVIEWS 4

#define FOLDER_GUID TEXT("{A42CD7B6-E9B9-4D02-B7A6-288B71AD28BA}")

// Function in defview
void SHGetThumbnailSize(SIZE *psize);

typedef enum
{
    MINIPREVIEW_LAYOUT_1 = 0,
    MINIPREVIEW_LAYOUT_4 = 1,
} MINIPREVIEW_LAYOUT;

// The size of the mini-thumbnails for each thumbnail size. For each thumbnail
// size, there is a mini-thumbnail size for single layout and 2x2 layout.
LONG const alFolder120MinipreviewSize[] = {104, 48};
LONG const alFolder96MinipreviewSize[] = {82, 40};
LONG const alFolder80MinipreviewSize[] = {69, 32};

// These are the margins at which the mini-thumbnails appear within the main thumbnail.
// For thumbnails with only one large minipreview, we can just use x1,y1.
LONG const alFolder120MinipreviewOffsets[] = { 8, 64, 13, 67 }; // x1, x2, y1, y2
LONG const alFolder96MinipreviewOffsets[]  = { 7, 49, 11, 52 }; // x1, x2, y1, y2
LONG const alFolder80MinipreviewOffsets[]  = { 5, 42, 9,  45 }; // x1, x2, y1, y2


void FreeMiniPreviewPidls(LPITEMIDLIST apidlPreviews[], UINT cpidlPreviews);

// Helper functions
MINIPREVIEW_LAYOUT _GetMiniPreviewLayout(SIZE size);
void _GetMiniPreviewLocations(MINIPREVIEW_LAYOUT uLayout, SIZE sizeRequested, SIZE *psizeFolderBmp,
                                              POINT aptOrigins[], SIZE *psizeMiniPreview);
HRESULT _DrawMiniPreviewBackground(HDC hdc, SIZE sizeFolderBmp, BOOL fAlpha, BOOL* pIsAlpha, RGBQUAD *prgb);
HBITMAP _CreateDIBSection(HDC hdcBmp, int cx, int cy);
HRESULT _CreateMainRenderingDC(HDC* phdc, HBITMAP* phBmpThumbnail, HBITMAP* phbmpOld, int cx, int cy, RGBQUAD** pprgb);
void  _DestroyMainRenderingDC(HDC hdc, HBITMAP hbmpOld);
HRESULT _AddBitmap(HDC hdc, HBITMAP hbmpSub, POINT ptMargin, SIZE sizeDest, SIZE sizeSource, BOOL fAlphaSource, BOOL fAlphaDest, RGBQUAD *prgbDest, SIZE cxFolderSize);

// The files that can serve as thumbnails for folders:
const LPCWSTR c_szFolderThumbnailPaths[] = { L"folder.jpg", L"folder.gif" };

// We always have four now.
MINIPREVIEW_LAYOUT _GetMiniPreviewLayout(SIZE size)
{
    return MINIPREVIEW_LAYOUT_4;
}


void FreeMiniPreviewPidls(LPITEMIDLIST apidlPreviews[], UINT cpidlPreviews)
{
    for (UINT u = 0; u < cpidlPreviews; u++)
    {
        ILFree(apidlPreviews[u]);
    }
}


/**
 * In: uLayout - The layout (1 or 4 mini previews)
 *     sizeRequested - The size of the thumbnail we are trying to generate 
 *
 * Out:
 * -psizeFolderBmp is set to
 * the size of the bitmap.
 *
 * -aptOrigins array is filled in with the locations of the n minipreviews
 * (note, aptOrigins is assumed to have MAX_MINIPREVIEWS cells)
 * The size of the minipreviews (square) is returned in pSizeMinipreview;
 */
void _GetMiniPreviewLocations(MINIPREVIEW_LAYOUT uLayout, SIZE sizeRequested, SIZE *psizeFolderBmp, 
                                              POINT aptOrigins[], SIZE *psizeMiniPreview)
{

    const LONG *alOffsets;
    LONG lSize; // One of the standard sizes, that we have a folder bitmap for.
    LONG lSmallestDimension = min(sizeRequested.cx, sizeRequested.cy);

    if (lSmallestDimension > 96) // For stuff bigger than 96, we use the 120 size
    {
        lSize = 120;
        alOffsets = alFolder120MinipreviewOffsets;
        psizeMiniPreview->cx = psizeMiniPreview->cy = alFolder120MinipreviewSize[uLayout];
    }
    else if (lSmallestDimension > 80) // For stuff bigger than 80, but <= 96, we use the 96 size.
    {
        lSize = 96;
        alOffsets = alFolder96MinipreviewOffsets;
        psizeMiniPreview->cx = psizeMiniPreview->cy = alFolder96MinipreviewSize[uLayout];
    }
    else // For stuff <= 80, we use 80.
    {
        lSize = 80;
        alOffsets = alFolder80MinipreviewOffsets;
        psizeMiniPreview->cx = psizeMiniPreview->cy = alFolder80MinipreviewSize[uLayout];
    }

    psizeFolderBmp->cx = psizeFolderBmp->cy = lSize;

    COMPILETIME_ASSERT(4 == MAX_MINIPREVIEWS);

    aptOrigins[0].x = alOffsets[0];
    aptOrigins[0].y = alOffsets[2];
    aptOrigins[1].x = alOffsets[1];
    aptOrigins[1].y = alOffsets[2];
    aptOrigins[2].x = alOffsets[0];
    aptOrigins[2].y = alOffsets[3];
    aptOrigins[3].x = alOffsets[1];
    aptOrigins[3].y = alOffsets[3];
}

HBITMAP _CreateDIBSection(HDC h, int cx, int cy, RGBQUAD** pprgb)
{
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    return CreateDIBSection(h, &bi, DIB_RGB_COLORS, (void**)pprgb, NULL, 0);
}

// Pre multiplies alpha channel
void PreProcessDIB(int cx, int cy, RGBQUAD* pargb)
{
    int cTotal = cx * cy;
    for (int i = 0; i < cTotal; i++)
    {
        RGBQUAD* prgb = &pargb[i];
        if (prgb->rgbReserved != 0)
        {
            prgb->rgbRed      = ((prgb->rgbRed   * prgb->rgbReserved) + 128) / 255;
            prgb->rgbGreen    = ((prgb->rgbGreen * prgb->rgbReserved) + 128) / 255;
            prgb->rgbBlue     = ((prgb->rgbBlue  * prgb->rgbReserved) + 128) / 255;
        }
        else
        {
            *((DWORD*)prgb) = 0;
        }
    }
}

// Is there an alpha channel?  Check for a non-zero alpha byte.
BOOL _HasAlpha(RECT rc, int cx, RGBQUAD *pargb)
{
    for (int y = rc.top; y < rc.bottom; y++)
    {
        for (int x = rc.left; x < rc.right; x++)
        {
            int iOffset = y * cx;
            if (pargb[x + iOffset].rgbReserved != 0)
                return TRUE;
        }
    }

    return FALSE;
}


/** In:
 *   fAlpha: Do we want the folder background to have an alpha channel?
 *   sizeFolderBmp: size of the thumbnail
 *
 *  Out:
 *   pIsAlpha: Did we get what we wanted, if we wanted an alpha channel?
 *             (e.g. we won't get it if we're in < 24bit mode.)
 */
HRESULT _DrawMiniPreviewBackground(HDC hdc, SIZE sizeFolderBmp, BOOL fAlpha, BOOL* pfIsAlpha, RGBQUAD *prgb)
{
    HRESULT hr = E_FAIL;

    HICON hicon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_FOLDER), IMAGE_ICON, sizeFolderBmp.cx, sizeFolderBmp.cy, 0);

    if (hicon)
    {
        *pfIsAlpha = FALSE;
        if (fAlpha)
        {
            // Try to blt an alpha channel icon into the dc
            ICONINFO io;
            if (GetIconInfo(hicon, &io))
            {
                BITMAP bm;
                if (GetObject(io.hbmColor, sizeof(bm), &bm))
                {
                    if (bm.bmBitsPixel == 32)
                    {
                        HDC hdcSrc = CreateCompatibleDC(hdc);
                        if (hdcSrc)
                        {
                            HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcSrc, io.hbmColor);

                            BitBlt(hdc, 0, 0, sizeFolderBmp.cx, sizeFolderBmp.cy, hdcSrc, 0, 0, SRCCOPY);

                            // Preprocess the alpha
                            PreProcessDIB(sizeFolderBmp.cx, sizeFolderBmp.cy, prgb);

                            *pfIsAlpha = TRUE;
                            SelectObject(hdcSrc, hbmpOld);
                            DeleteDC(hdcSrc);
                        }   
                    }
                }

                DeleteObject(io.hbmColor);
                DeleteObject(io.hbmMask);
            }
        }

        if (!*pfIsAlpha)
        {
            // Didn't create an alpha bitmap
            // We're filling the background with background window color.
            RECT rc = { 0, 0, (long)sizeFolderBmp.cx + 1, (long)sizeFolderBmp.cy + 1};
            SHFillRectClr(hdc, &rc, GetSysColor(COLOR_WINDOW));

            // Then drawing the icon on top.
            DrawIconEx(hdc, 0, 0, hicon, sizeFolderBmp.cx, sizeFolderBmp.cy, 0, NULL, DI_NORMAL);

            // This may have resulted in an alpha channel - we need to know.  (If it
            // did, then when we add a nonalpha minibitmap to this main one, we need to restore
            // the nuked out alpha channel)
            // Check if we have alpha (prgb is the bits for the DIB of size sizeFolderBmp):
            rc.right = sizeFolderBmp.cx;
            rc.bottom = sizeFolderBmp.cy;
            *pfIsAlpha = _HasAlpha(rc, sizeFolderBmp.cx, prgb);
        }

        DestroyIcon(hicon);
        hr = S_OK;
    }

    return hr;
}

BOOL DoesFolderContainLogo(LPCITEMIDLIST pidlFull)
{
    BOOL bRet = FALSE;
    IPropertyBag * pPropBag;
    if (SUCCEEDED(SHGetViewStatePropertyBag(pidlFull, VS_BAGSTR_EXPLORER, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &pPropBag))))
    {
        TCHAR szLogo[MAX_PATH]; 
        szLogo[0] = 0; 
        if (SUCCEEDED(SHPropertyBag_ReadStr(pPropBag, TEXT("Logo"), szLogo, ARRAYSIZE(szLogo))) && szLogo[0])
        {
            bRet = TRUE;
        }
        pPropBag->Release();
    }
    return bRet;
}

BOOL DoesFolderContainFolderJPG(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    BOOL bRet = FALSE;
    // return false if there's not folder.jpg, or if folder.jpg is a folder (doh!)
    IShellFolder *psfSubfolder;

    // SHBTO can deal with NULL psf, he turns it into psfDesktop
    if (SUCCEEDED(SHBindToObject(psf, IID_X_PPV_ARG(IShellFolder, pidl, &psfSubfolder))))
    {
        for (int i = 0; i < ARRAYSIZE(c_szFolderThumbnailPaths); i++)
        {
            DWORD dwFlags = SFGAO_FILESYSTEM | SFGAO_FOLDER;
            LPITEMIDLIST pidlItem;
            if (SUCCEEDED(psfSubfolder->ParseDisplayName(NULL, NULL, (LPOLESTR)c_szFolderThumbnailPaths[i], NULL, &pidlItem, &dwFlags)))
            {
                ILFree(pidlItem);
                if ((dwFlags & (SFGAO_FILESYSTEM | SFGAO_FOLDER)) == SFGAO_FILESYSTEM)
                {
                    bRet = TRUE;
                    break;
                }
            }
        }
        psfSubfolder->Release();
    }

    return bRet;
}

BOOL _IsShortcutTargetACandidate(IShellFolder *psf, LPCITEMIDLIST pidlPreview, BOOL *pbTryCached)
{
    BOOL bRet = FALSE;
    *pbTryCached = TRUE;
    IShellLink *psl;
    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidlPreview, IID_PPV_ARG_NULL(IShellLink, &psl))))
    {
        LPITEMIDLIST pidlTarget = NULL;
        if (SUCCEEDED(psl->GetIDList(&pidlTarget)) && pidlTarget)
        {
            DWORD dwTargetFlags = SFGAO_FOLDER;
            if (SUCCEEDED(SHGetNameAndFlags(pidlTarget, 0, NULL, 0, &dwTargetFlags)))
            {
                // return true if its not a folder, or if the folder contains a logo
                // note that this is kinda like recursing into the below function again
                bRet = (0 == (dwTargetFlags & SFGAO_FOLDER));
                
                if (!bRet)
                {
                    bRet = (DoesFolderContainLogo(pidlTarget) || DoesFolderContainFolderJPG(NULL, pidlTarget));
                    if (bRet)
                    {
                        // It's a logo folder, don't try the cached image.
                        *pbTryCached = FALSE;
                    }
                }
            }

            ILFree(pidlTarget);
        }
        psl->Release();
    }
    return bRet;
}


BOOL _IsMiniPreviewCandidate(IShellFolder *psf, LPCITEMIDLIST pidl, BOOL *pbTryCached)
{
    BOOL bRet = FALSE;
    DWORD dwAttr = SHGetAttributes(psf, pidl, SFGAO_FOLDER | SFGAO_LINK | SFGAO_FILESYSANCESTOR);
    *pbTryCached = TRUE; 

    // if its a folder, check and see if its got a logo
    // note that folder shortcuts will have both folder and link, and since we check folder first, we won't recurse into folder shortcuts
    // dont do anything unless pidl is a folder on a real filesystem (i.e. dont walk into zip/cab)
    if ((dwAttr & (SFGAO_FOLDER | SFGAO_FILESYSANCESTOR)) == (SFGAO_FOLDER | SFGAO_FILESYSANCESTOR))
    {
        LPITEMIDLIST pidlParent;
        if (SUCCEEDED(SHGetIDListFromUnk(psf, &pidlParent)))
        {
            LPITEMIDLIST pidlFull;
            if (SUCCEEDED(SHILCombine(pidlParent, pidl, &pidlFull)))
            {
                bRet = DoesFolderContainLogo(pidlFull);
                ILFree(pidlFull);
            }
            ILFree(pidlParent);
        }

        if (!bRet)
        {
            // no logo image, check for a "folder.jpg"
            // if its not there, then don't display pidl as a mini-preview, as it would recurse and produce dumb-looking 1/16 scale previews 
            bRet = DoesFolderContainFolderJPG(psf, pidl);
        }

        if (bRet)
        {
            // For logo folders, we don't look for a cached image (cached image won't have alpha, which we want)
            *pbTryCached = FALSE;
        }
    }
    else 
    {
        // Only if its not a link, or if its a link to a valid candidate, then we can get its extractor
        if (0 == (dwAttr & SFGAO_LINK) || 
            _IsShortcutTargetACandidate(psf, pidl, pbTryCached))
        {
            IExtractImage *pei;
            if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IExtractImage, NULL, &pei))))
            {
                bRet = TRUE;
                pei->Release();
            }
        }
    }
    return bRet;
}


// We return the bits to the dibsection in the dc, if asked for.  We need this for preprocessing the alpha channel,
// if one exists.
HRESULT _CreateMainRenderingDC(HDC* phdc, HBITMAP* phbmp, HBITMAP* phbmpOld, int cx, int cy, RGBQUAD** pprgb)
{
    HRESULT hr = E_OUTOFMEMORY;
    HDC hdc = GetDC(NULL);

    if (hdc)
    {
        *phdc = CreateCompatibleDC(hdc);
        if (*phdc)
        {
            RGBQUAD *prgbDummy;
            *phbmp = _CreateDIBSection(*phdc, cx, cy, &prgbDummy); 
            if (*phbmp)
            {
                *phbmpOld = (HBITMAP) SelectObject(*phdc, *phbmp);
                if (pprgb)
                    *pprgb = prgbDummy;
                hr = S_OK;
            }
            else
            {
                DeleteDC(*phdc);
            }
        }
        ReleaseDC(NULL, hdc);
    }

    return hr;
}

void _DestroyMainRenderingDC(HDC hdc, HBITMAP hbmpOld)    // Unselects the bitmap, and deletes the Dc
{
    if (hbmpOld)
        SelectObject(hdc, hbmpOld);
    DeleteDC(hdc);
}



// We just blt'd a nonalpha guy into an alpha'd bitmap.  This nuked out the alpha channel.
// Repair it by setting alpha channel to 0xff (opaque).
void _SetAlpha(RECT rc, SIZE sizeBmp, RGBQUAD *pargb)
{
    for (int y = (sizeBmp.cy - rc.bottom); y < (sizeBmp.cy - rc.top); y++)  // Origin at bottom left.
    {
        int iOffset = y * sizeBmp.cx;
        for (int x = rc.left; x < rc.right; x++)
        {
            pargb[x + iOffset].rgbReserved = 0xff;
        }
    }
}

/**
 * In
 *  hbmpSub - little bitmap that we're adding to the thumbnail bitmap.
 *  ptMargin - where we're adding it on the destination thumbnail bitmap.
 *  sizeDest - how big it needs to be on the destination thumbnail bitmap.
 *  sizeSource - how bit it is.
 *  fAlphaSource - does the bitmap we're adding have an alpha channel?
 *  fAlphaDest - does what we're adding it to, have an alpha channel?
 *  prgbDest - the bits of the destination bitmap - needed if we add a non-alpha bitmap
 *             to an alpha background, so we can reset the alpha.
 *  sizeFolderBmp - the size of the destination bitmap - need this along with prgbDest.
 */
HRESULT _AddBitmap(HDC hdc, HBITMAP hbmpSub, POINT ptMargin, SIZE sizeDest, SIZE sizeSource, BOOL fAlphaSource, BOOL fAlphaDest, RGBQUAD *prgbDest, SIZE sizeFolderBmp)
{
    HRESULT hr = E_OUTOFMEMORY;

    HDC hdcFrom = CreateCompatibleDC(hdc);
    if (hdcFrom)
    {
        // Select the bitmap into the source hdc.
        HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcFrom, hbmpSub);
        if (hbmpOld)
        {
            // Adjust destination size to preserve aspect ratio
            SIZE sizeDestActual;
            if ((1000 * sizeDest.cx / sizeSource.cx) <      // 1000 -> float simulation
                (1000 * sizeDest.cy / sizeSource.cy))
            {
                // Keep destination width
                sizeDestActual.cy = sizeSource.cy * sizeDest.cx / sizeSource.cx;
                sizeDestActual.cx = sizeDest.cx;
                ptMargin.y += (sizeDest.cy - sizeDestActual.cy) / 2; // Center
            }
            else
            {
                // Keep destination height
                sizeDestActual.cx = sizeSource.cx * sizeDest.cy / sizeSource.cy;
                sizeDestActual.cy = sizeDest.cy;
                ptMargin.x += (sizeDest.cx - sizeDestActual.cx) / 2; // Center
            }

            // Now blt the image onto our folder background.
            // Three alpha possibilities:
            // Dest: no alpha, Src: no alpha -> the normal case
            // Dest: no alpha, Src: alpha -> one of the minipreviews is a logo-ized folder.
            // Dest: alpha, Src: no alpha -> we're a logoized folder being rendered as a minipreview in
            //                               the parent folder's thumbnail.

            // If we got back an alpha image, we need to alphablend it.
            if (fAlphaSource)
            {
                // We shouldn't have gotten back an alpha image, if we're alpha'd too.  That would imply we're
                // doing a minipreview of a minipreview (1/16 scale).
                //ASSERT(!fAlphaDest);
                BLENDFUNCTION bf;
                bf.BlendOp = AC_SRC_OVER;
                bf.SourceConstantAlpha = 255;
                bf.AlphaFormat = AC_SRC_ALPHA;
                bf.BlendFlags = 0;
                if (AlphaBlend(hdc, ptMargin.x, ptMargin.y, sizeDestActual.cx, sizeDestActual.cy, hdcFrom, 0 ,0, sizeSource.cx, sizeSource.cy, bf))
                    hr = S_OK;
            }
            else
            {
                // Otherwise, just blt it.
                int iModeSave = SetStretchBltMode(hdc, HALFTONE);
                if (StretchBlt(hdc, ptMargin.x, ptMargin.y, sizeDestActual.cx, sizeDestActual.cy, hdcFrom, 0 ,0, sizeSource.cx, sizeSource.cy, SRCCOPY))
                    hr = S_OK;
                SetStretchBltMode(hdc, iModeSave);

                // Are we alpha'd?  We didn't have an alpha source, so where we blt'd it, we've
                // lost the alpha channel.  Restore it.
                if (fAlphaDest)
                {
                    // Set the alpha channel over where we just blt'd.
                    RECT rc = {ptMargin.x, ptMargin.y, ptMargin.x + sizeDestActual.cx, ptMargin.y + sizeDestActual.cy};
                    _SetAlpha(rc, sizeFolderBmp, prgbDest);
                }
            }
            SelectObject(hdcFrom, hbmpOld);
        }
        DeleteDC(hdcFrom);
    }

    return hr;
}


class CFolderExtractImage : public IExtractImage2,
                            public IPersistPropertyBag,
                            public IAlphaThumbnailExtractor,
                            public IRunnableTask
{
public:
    CFolderExtractImage();
    
    STDMETHOD (QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    // IExtractImage/IExtractLogo
    STDMETHOD (GetLocation)(LPWSTR pszPath, DWORD cch, DWORD *pdwPriority, const SIZE *prgSize, DWORD dwRecClrDepth, DWORD *pdwFlags);
 
    STDMETHOD (Extract)(HBITMAP *phbm);

    // IExtractImage2
    STDMETHOD (GetDateStamp)(FILETIME *pftDateStamp);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistPropertyBag
    STDMETHOD(InitNew)();
    STDMETHOD(Load)(IPropertyBag *ppb, IErrorLog *pErr);
    STDMETHOD(Save)(IPropertyBag *ppb, BOOL fClearDirty, BOOL fSaveAll)
        { return E_NOTIMPL; }

    // IRunnableTask
    STDMETHOD (Run)(void);
    STDMETHOD (Kill)(BOOL fWait);
    STDMETHOD (Suspend)(void);
    STDMETHOD (Resume)(void);
    STDMETHOD_(ULONG, IsRunning)(void);

    // IAlphaThumbnailExtractor
    STDMETHOD (RequestAlphaThumbnail)(void);

    STDMETHOD(Init)(IShellFolder *psf, LPCITEMIDLIST pidl);
private:
    ~CFolderExtractImage();
    LPCTSTR _GetImagePath(UINT cx);
    HRESULT _CreateWithMiniPreviews(IShellFolder *psf, const LPCITEMIDLIST *apidlPreviews, BOOL *abTryCached, UINT cpidlPreviews, MINIPREVIEW_LAYOUT uLayout, IShellImageStore *pImageStore, HBITMAP *phBmpThumbnail);
    HRESULT _FindMiniPreviews(LPITEMIDLIST apidlPreviews[], BOOL abTryCached[], UINT *cpidlPreviews);
    HRESULT _CreateThumbnailFromIconResource(HBITMAP* phBmpThumbnail, int res);
    HRESULT _CheckThumbnailCache(HBITMAP *phbmp);
    void _CacheThumbnail(HBITMAP hbmp);

    IExtractImage  *_pExtract;
    IRunnableTask  *_pRun;
    long            _cRef;
    TCHAR           _szFolder[MAX_PATH];
    TCHAR           _szLogo[MAX_PATH];
    TCHAR           _szWideLogo[MAX_PATH];
    IShellFolder2  *_psf;
    SIZE            _size;
    LPITEMIDLIST    _pidl;
    IPropertyBag   *_ppb;
    LONG            _lState;
    BOOL            _fAlpha;

    DWORD _dwPriority;
    DWORD _dwRecClrDepth;
    
    DWORD _dwExtractFlags;
};

STDAPI CFolderExtractImage_Create(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFolderExtractImage *pfei = new CFolderExtractImage;
    if (pfei)
    {
        hr = pfei->Init(psf, pidl);
        if (SUCCEEDED(hr))
            hr = pfei->QueryInterface(riid, ppv);
        pfei->Release();
    }
    return hr;
}

CFolderExtractImage::CFolderExtractImage() : _cRef(1), _lState(IRTIR_TASK_NOT_RUNNING)
{
}

CFolderExtractImage::~CFolderExtractImage()
{
    ATOMICRELEASE(_pExtract);
    ATOMICRELEASE(_psf);
    ILFree(_pidl);
    ATOMICRELEASE(_ppb);
}

STDMETHODIMP CFolderExtractImage::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT      (CFolderExtractImage, IExtractImage2),
        QITABENTMULTI (CFolderExtractImage, IExtractImage,         IExtractImage2),
        QITABENTMULTI2(CFolderExtractImage, IID_IExtractLogo,      IExtractImage2),
        QITABENT      (CFolderExtractImage, IPersistPropertyBag),
        QITABENT      (CFolderExtractImage, IRunnableTask),
        QITABENT      (CFolderExtractImage, IAlphaThumbnailExtractor),
        QITABENTMULTI (CFolderExtractImage, IPersist,              IPersistPropertyBag),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFolderExtractImage::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFolderExtractImage::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CFolderExtractImage::GetDateStamp(FILETIME *pftDateStamp)
{
    HANDLE h = CreateFile(_szFolder, GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
                          OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    HRESULT hr = (h != INVALID_HANDLE_VALUE) ? S_OK : E_FAIL;
    if (SUCCEEDED(hr))
    {
        hr = GetFileTime(h, NULL, NULL, pftDateStamp) ? S_OK : E_FAIL;
        CloseHandle(h);
    }
    return hr;
}

HRESULT CFolderExtractImage::InitNew()
{
    IPropertyBag *ppb;
    // load up the default property bag for peruser perfolder
    // may have problems down the line with thumbs.db being alluser.
    if (SUCCEEDED(SHGetViewStatePropertyBag(_pidl, VS_BAGSTR_EXPLORER, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        IUnknown_Set((IUnknown**)&_ppb, ppb);
        ppb->Release();
    }
    // return success always -- SHGVSPB can fail if _pidl is on a removable drive,
    // but we still want to do our thing.
    return S_OK;
}

HRESULT CFolderExtractImage::Load(IPropertyBag *ppb, IErrorLog *pErr)
{
    IUnknown_Set((IUnknown**)&_ppb, ppb);
    return S_OK;
}

LPCTSTR CFolderExtractImage::_GetImagePath(UINT cx)
{
    if (!_szLogo[0])
    {
        if (_ppb && SUCCEEDED(SHPropertyBag_ReadStr(_ppb, TEXT("Logo"), _szLogo, ARRAYSIZE(_szLogo))) && _szLogo[0])
        {
            if (SUCCEEDED(SHPropertyBag_ReadStr(_ppb, TEXT("WideLogo"), _szWideLogo, ARRAYSIZE(_szWideLogo))) && _szWideLogo[0])
                PathCombine(_szWideLogo, _szFolder, _szWideLogo);   // relative path support

            PathCombine(_szLogo, _szFolder, _szLogo);   // relative path support
        }
        else
        {
            TCHAR szFind[MAX_PATH];

            for (int i = 0; i < ARRAYSIZE(c_szFolderThumbnailPaths); i++)
            {
                PathCombine(szFind, _szFolder, c_szFolderThumbnailPaths[i]);
                if (PathFileExists(szFind))
                {
                    lstrcpyn(_szLogo, szFind, ARRAYSIZE(_szLogo));
                    break;
                }
            }
        }
    }

    LPCTSTR psz = ((cx > 120) && _szWideLogo[0]) ? _szWideLogo : _szLogo;
    return *psz ? psz : NULL;
}

STDMETHODIMP CFolderExtractImage::RequestAlphaThumbnail()
{
    _fAlpha = TRUE;
    return S_OK;
}

STDMETHODIMP CFolderExtractImage::GetLocation(LPWSTR pszPath, DWORD cch,
                                              DWORD *pdwPriority, const SIZE *prgSize,
                                              DWORD dwRecClrDepth, DWORD *pdwFlags)
{
    lstrcpyn(pszPath, _szFolder, cch);

    HRESULT hr = S_OK;
    _size = *prgSize;
    _dwRecClrDepth = dwRecClrDepth;
    _dwExtractFlags = *pdwFlags;

    if (pdwFlags)
    {
        if (*pdwFlags & IEIFLAG_ASYNC)
            hr = E_PENDING;

        *pdwFlags &= ~IEIFLAG_CACHE; // We handle the caching of this thumbnail inside the folder
        *pdwFlags |= IEIFLAG_REFRESH; // We still want to handle the refresh verb
    }

    if (pdwPriority)
    {
        _dwPriority = *pdwPriority;
        *pdwPriority = 1;   // very low
    }

    return hr;
}

STDMETHODIMP CFolderExtractImage::Extract(HBITMAP *phbm)
{
    // Set it to running (only if we're in the not running state).
    LONG lResOld = InterlockedCompareExchange(&_lState, IRTIR_TASK_RUNNING, IRTIR_TASK_NOT_RUNNING);

    if (lResOld != IRTIR_TASK_NOT_RUNNING)
    {
        // If we weren't in the not running state, bail.
        return E_FAIL;
    }

    // If we have an extractor, use that.
    HRESULT hr = E_FAIL;
    hr = _CheckThumbnailCache(phbm);
    if (FAILED(hr))
    {    
        LPITEMIDLIST apidlPreviews[MAX_MINIPREVIEWS_COLLECT];
        BOOL abTryCached[MAX_MINIPREVIEWS_COLLECT];
        UINT cpidlPreviews = 0;

        LPCTSTR pszLogo = _GetImagePath(_size.cx);
        if (pszLogo)
        {
            // Don't do the standard mini-previews - we've got a special thumbnail
            ATOMICRELEASE(_pExtract);

            LPITEMIDLIST pidl;
            hr = SHILCreateFromPath(pszLogo, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidlChild;
                IShellFolder* psfLogo;
                hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psfLogo), &pidlChild);
                if (SUCCEEDED(hr))
                {
                    hr = _CreateWithMiniPreviews(psfLogo, &pidlChild, NULL, 1, MINIPREVIEW_LAYOUT_1, NULL, phbm);
                    psfLogo->Release();
                }
                ILFree(pidl);
            }
        }
        else
        {
            const struct 
            {
                int csidl;
                int res;
            } 
            thumblist[] = 
            {
                {CSIDL_PERSONAL,           IDI_MYDOCS},
                {CSIDL_MYMUSIC,            IDI_MYMUSIC},
                {CSIDL_MYPICTURES,         IDI_MYPICS},
                {CSIDL_MYVIDEO,            IDI_MYVIDEOS},
                {CSIDL_COMMON_DOCUMENTS,   IDI_MYDOCS},
                {CSIDL_COMMON_MUSIC,       IDI_MYMUSIC},
                {CSIDL_COMMON_PICTURES,    IDI_MYPICS},
                {CSIDL_COMMON_VIDEO,       IDI_MYVIDEOS}
            };
            BOOL bFound = FALSE;

            for (int i=0; i < ARRAYSIZE(thumblist) && !bFound; i++)
            {
                TCHAR szPath[MAX_PATH];
                SHGetFolderPath(NULL, thumblist[i].csidl, NULL, 0, szPath);
                if (!lstrcmp(_szFolder, szPath))
                {
                    // We return failure in this case so that the requestor can do
                    // the default action.
                    hr = E_FAIL;
                    bFound = TRUE;
                }
            }

            if (!bFound)
            {
                // Mini-previews.
                IShellImageStore *pDiskCache = NULL;

                // It's ok if this fails.
                if (!SHRestricted(REST_NOTHUMBNAILCACHE) && 
                    !SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("DisableThumbnailCache"), 0, FALSE) &&
                    !(_dwExtractFlags & IEIFLAG_QUALITY))
                {
                    LoadFromFile(CLSID_ShellThumbnailDiskCache, _szFolder, IID_PPV_ARG(IShellImageStore, &pDiskCache));
                }

                cpidlPreviews = ARRAYSIZE(apidlPreviews);
                hr = _FindMiniPreviews(apidlPreviews, abTryCached, &cpidlPreviews);
                if (SUCCEEDED(hr))
                {
                    if (cpidlPreviews)
                    {
                        hr = _CreateWithMiniPreviews(_psf, apidlPreviews, abTryCached, cpidlPreviews, _GetMiniPreviewLayout(_size), pDiskCache, phbm);
                        FreeMiniPreviewPidls(apidlPreviews, cpidlPreviews);
                    }
                    else
                    {
                        // We return failure in this case so that the requestor can do
                        // the default action
                        hr = E_FAIL; 
                    }
                }

                ATOMICRELEASE(pDiskCache);
            }
        }

        if (SUCCEEDED(hr) && *phbm)
        {
            _CacheThumbnail(*phbm);
        }
    }
    
    return hr;
}

STDMETHODIMP CFolderExtractImage::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFolderExtractImage::Init(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING, _szFolder, ARRAYSIZE(_szFolder));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlFolder;
        hr = SHGetIDListFromUnk(psf, &pidlFolder);
        if (SUCCEEDED(hr))
        {
            hr = SHILCombine(pidlFolder, pidl, &_pidl);
            if (SUCCEEDED(hr))
            {
                // hold the _psf for this guy so we can enum
                hr = psf->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder2, &_psf));
                if (SUCCEEDED(hr))
                {
                    hr = InitNew();
                }
            }
            ILFree(pidlFolder);
        }
    }
    return hr;
}

// Not necessary --- IExtractImage::Extract() starts us up.
STDMETHODIMP CFolderExtractImage::Run(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFolderExtractImage::Kill(BOOL fWait)
{
    // Try to kill the current subextraction task that's running, if any.
    if (_pRun != NULL)
    {
        _pRun->Kill(fWait);
        // If it didn't work, no big deal, we'll complete this subextraction task,
        // and bail before starting the next one.
    }

    // If we're running, set to pending.
    LONG lResOld = InterlockedCompareExchange(&_lState, IRTIR_TASK_PENDING, IRTIR_TASK_RUNNING);
    if (lResOld == IRTIR_TASK_RUNNING)
    {
        // We've now set it to pending - ready to die.
        return S_OK;
    }
    else if (lResOld == IRTIR_TASK_PENDING || lResOld == IRTIR_TASK_FINISHED)
    {
        // We've already been killed.
        return S_FALSE;
    }

    return E_FAIL;
}

STDMETHODIMP CFolderExtractImage::Suspend(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFolderExtractImage::Resume(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP_(ULONG) CFolderExtractImage::IsRunning(void)
{
    return _lState;
}

HRESULT CFolderExtractImage::_CreateWithMiniPreviews(IShellFolder *psf, const LPCITEMIDLIST *apidlPreviews, BOOL *abTryCached, UINT cpidlPreviews, MINIPREVIEW_LAYOUT uLayout, IShellImageStore *pImageStore, HBITMAP *phBmpThumbnail)
{
    *phBmpThumbnail = NULL;

    HBITMAP hbmpOld;
    HDC hdc;

    SIZE sizeOriginal;      // Size of the source bitmaps that go into the minipreview.
    SIZE sizeFolderBmp;     // Size of the folder bmp we use for the background.
    SIZE sizeMiniPreview;   // The size calculated for the minipreviews
    POINT aptOrigins[MAX_MINIPREVIEWS];
    RGBQUAD* prgb;          // the bits of the destination bitmap. 

    _GetMiniPreviewLocations(uLayout, _size, &sizeFolderBmp,
                             aptOrigins, &sizeMiniPreview);

    // sizeFolderBmp is the size of the folder background bitmap that we're working with,
    // not the size of the final thumbnail.
    HRESULT hr = _CreateMainRenderingDC(&hdc, phBmpThumbnail, &hbmpOld, sizeFolderBmp.cx, sizeFolderBmp.cy, &prgb);

    if (SUCCEEDED(hr))
    {
        BOOL fIsAlphaBackground;
        hr = _DrawMiniPreviewBackground(hdc, sizeFolderBmp, _fAlpha, &fIsAlphaBackground, prgb);

        if (SUCCEEDED(hr))
        {
            ULONG uPreviewLocation = 0;

            // Extract the images for the minipreviews
            for (ULONG i = 0 ; i < cpidlPreviews && uPreviewLocation < ARRAYSIZE(aptOrigins) ; i++)
            {
                BOOL bFoundAlphaImage = FALSE;

                // If we've been killed, stop the processing the minipreviews:
                // PENDING?, we're now FINISHED.
                InterlockedCompareExchange(&_lState, IRTIR_TASK_FINISHED, IRTIR_TASK_PENDING);

                if (_lState == IRTIR_TASK_FINISHED)
                {
                    // Get out.
                    hr = E_FAIL;
                    break;
                }

                HBITMAP hbmpSubs;
                BOOL bFoundImage = FALSE;

                // Try the image store first
                DWORD dwLock;
                HRESULT hr2 = (pImageStore && abTryCached[i]) ? pImageStore->Open(STGM_READ, &dwLock) : E_FAIL;
                if (SUCCEEDED(hr2))
                {
                    // Get the fullpidl of this guy.
                    TCHAR szSubPath[MAX_PATH];
                    if (SUCCEEDED(DisplayNameOf(psf, apidlPreviews[i], SHGDN_INFOLDER | SHGDN_FORPARSING, szSubPath, MAX_PATH)))
                    {
                        if (SUCCEEDED(pImageStore->GetEntry(szSubPath, STGM_READ, &hbmpSubs)))
                        {
                            bFoundImage = TRUE;
                        }
                    }
                    pImageStore->ReleaseLock(&dwLock);
                }

                // Resort to calling extractor if the image was not in the cache.
                if (!bFoundImage)
                {
                    IExtractImage *peiSub;
                    hr2 = psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&apidlPreviews[i], IID_X_PPV_ARG(IExtractImage, NULL, &peiSub));
                    if (SUCCEEDED(hr2))
                    {
                    
                        // Now extract the image.
                        DWORD dwPriority = 0;
                        DWORD dwFlags = IEIFLAG_ORIGSIZE | IEIFLAG_QUALITY;// ORIGSIZE -> preserve aspect ratio

                        WCHAR szPathBuffer[MAX_PATH];
                        hr2 = peiSub->GetLocation(szPathBuffer, ARRAYSIZE(szPathBuffer), &dwPriority, &sizeMiniPreview, 24, &dwFlags);

                        IAlphaThumbnailExtractor *pati;
                        if (SUCCEEDED(peiSub->QueryInterface(IID_PPV_ARG(IAlphaThumbnailExtractor, &pati))))
                        {
                            if (SUCCEEDED(pati->RequestAlphaThumbnail()))
                            {
                                bFoundAlphaImage = TRUE;
                            }
                            
                            pati->Release();
                        }

                        if (SUCCEEDED(hr2))
                        {
                            // After we check for IRTIR_TASK_PENDING, but before
                            // we call peiSub->Extract,  it is possible someone calls
                            // Kill on us.
                            // Since _pRun will be NULL, we will not kill
                            // the subtask, but will instead continue and call extract
                            // on it, and not bail until we try the next subthumbnail.
                            // Oh well.
                            // We could add another check here to reduce the window of
                            // opportunity in which this could happen.

                            // Try to get an IRunnableTask so that we can stop execution
                            // of this subtask if necessary.
                            peiSub->QueryInterface(IID_PPV_ARG(IRunnableTask, &_pRun));

                            if (SUCCEEDED(peiSub->Extract(&hbmpSubs)))
                            {
                                bFoundImage = TRUE;
                            }

                            ATOMICRELEASE(_pRun);
                        }

                        peiSub->Release();
                    }
                }

                // Add the extracted bitmap to the main one...
                if (bFoundImage)
                {
                    // The bitmap will of course need to be resized:
                    BITMAP rgBitmap;
                    if  (::GetObject((HGDIOBJ)hbmpSubs, sizeof(rgBitmap), &rgBitmap))
                    {
                        sizeOriginal.cx = rgBitmap.bmWidth;
                        sizeOriginal.cy = rgBitmap.bmHeight;

                        // We need to check if this is really an alpha bitmap.  It's possible that the
                        // extractor said it could generate one, but ended up not being able to.
                        if (bFoundAlphaImage)
                        {
                            RECT rc = {0, 0, rgBitmap.bmWidth, rgBitmap.bmHeight};
                            bFoundAlphaImage = (rgBitmap.bmBitsPixel == 32) &&
                                                _HasAlpha(rc, rgBitmap.bmWidth, (RGBQUAD*)rgBitmap.bmBits);
                        }
                    }
                    else
                    {
                        // Couldn't get the info, oh well, no resize.
                        // alpha may also be screwed up here, but oh well.
                        sizeOriginal = sizeMiniPreview;
                    }

                    if (SUCCEEDED(_AddBitmap(hdc, hbmpSubs, aptOrigins[uPreviewLocation], sizeMiniPreview, sizeOriginal, bFoundAlphaImage, fIsAlphaBackground, prgb, sizeFolderBmp)))
                    {
                        uPreviewLocation++;
                    }

                    DeleteObject(hbmpSubs);
                }
            }

            if (!uPreviewLocation)
            {
                // For whatever reason, we have no mini thumbnails to show, so fail this entire extraction.
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr))
        {
            // Is the requested size one of the sizes of the folder background bitmaps?
            // Test against smallest requested dimension, because we're square, and we'll fit into that rectangle
            int iSmallestDimension = min(_size.cx, _size.cy);
            if ((sizeFolderBmp.cx != iSmallestDimension) || (sizeFolderBmp.cy != iSmallestDimension))
            {
                // Nope - we need to do some scaling.
                // Create another dc and bitmap the size of the requested bitmap
                HBITMAP hBmpThumbnailFinal = NULL;
                HBITMAP hbmpOld2;
                HDC hdcFinal;
                RGBQUAD *prgbFinal;
                hr = _CreateMainRenderingDC(&hdcFinal, &hBmpThumbnailFinal, &hbmpOld2, iSmallestDimension, iSmallestDimension, &prgbFinal);
                if (SUCCEEDED(hr))
                {
                    // Now scale it.
                    if (fIsAlphaBackground)
                    {
                        BLENDFUNCTION bf;
                        bf.BlendOp = AC_SRC_OVER;
                        bf.SourceConstantAlpha = 255;
                        bf.AlphaFormat = AC_SRC_ALPHA;
                        bf.BlendFlags = 0;
                        if (AlphaBlend(hdcFinal, 0, 0, iSmallestDimension, iSmallestDimension, hdc, 0 ,0, sizeFolderBmp.cx, sizeFolderBmp.cy, bf))
                            hr = S_OK;
                    }
                    else
                    {
                        int iModeSave = SetStretchBltMode(hdcFinal, HALFTONE);

                        if (StretchBlt(hdcFinal, 0, 0, iSmallestDimension, iSmallestDimension, hdc, 0 ,0, sizeFolderBmp.cx, sizeFolderBmp.cy, SRCCOPY))
                            hr = S_OK;

                        SetStretchBltMode(hdcFinal, iModeSave);
                    }

                    // Destroy the dc.
                    _DestroyMainRenderingDC(hdcFinal, hbmpOld2);

                    // Now do a switcheroo
                    // Don't need to check for success here.  Down below, we'll delete *phBmpThumbnail
                    // if StretchBlt FAILED - and in that case, *pbBmpThumbnail will be hBmpThumbnailFinal.
                    DeleteObject(*phBmpThumbnail); // delete this, we don't need it.
                    *phBmpThumbnail = hBmpThumbnailFinal; // This is the one we want.
                }
            }
        }
        _DestroyMainRenderingDC(hdc, hbmpOld);
    }


    if (FAILED(hr) && *phBmpThumbnail) // Something didn't work? Make sure we delete our bmp
    {
        DeleteObject(*phBmpThumbnail);
    }

    return hr;
}


/**
 * In/Out: cpidlPreviews - the number of preview items we should look for. Returns the number found.
 * number of pidls returned is cpidlPreviews.
 * Out: apidlPreviews - array of pidls found.  The caller must free them.
 */
HRESULT CFolderExtractImage::_FindMiniPreviews(LPITEMIDLIST apidlPreviews[], BOOL abTryCached[], UINT *pcpidlPreviews)
{   
    UINT cMaxPreviews = *pcpidlPreviews;
    int uNumPreviewsSoFar = 0;
    BOOL bKilled = FALSE;

    // Make sure our aFileTimes array is the right size...
    ASSERT(MAX_MINIPREVIEWS_COLLECT == cMaxPreviews);

    *pcpidlPreviews = 0; // start with none in case of failure

    IEnumIDList *penum;
    if (S_OK == _psf->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penum))
    {
        FILETIME aFileTimes[MAX_MINIPREVIEWS_COLLECT] = {0};

        LPITEMIDLIST pidl;
        BOOL bTryCached;
        while (S_OK == penum->Next(1, &pidl, NULL))
        {
            // _IsMiniPreviewCandidate is a potentially expensive operation, so before
            // doing it, we'll check to see if anyone has killed us.

            // Are we PENDING? Then we're FINISHED.
            InterlockedCompareExchange(&_lState, IRTIR_TASK_FINISHED, IRTIR_TASK_PENDING);

            // Get out?
            bKilled = (_lState == IRTIR_TASK_FINISHED);

            if (!bKilled && _IsMiniPreviewCandidate(_psf, pidl, &bTryCached))
            {
                // Get file time of this guy.
                FILETIME ft;
                if (SUCCEEDED(GetDateProperty(_psf, pidl, &SCID_WRITETIME, &ft)))
                {
                    for (int i = 0; i < uNumPreviewsSoFar; i++)
                    {
                        if (CompareFileTime(&aFileTimes[i], &ft) < 0)
                        {
                            int j;
                            // Put it in this slot. First, move guys down by one.
                            // No need to copy last guy:
                            if (uNumPreviewsSoFar == (int)cMaxPreviews)
                            {   
                                j = (cMaxPreviews - 2);
                                // And we must free the pidl we're nuking.
                                ILFree(apidlPreviews[cMaxPreviews - 1]);
                                apidlPreviews[cMaxPreviews - 1] = NULL;
                            }
                            else
                            {
                                j = uNumPreviewsSoFar - 1;
                                uNumPreviewsSoFar++;
                            }

                            for (; j >= i; j--)
                            {
                                apidlPreviews[j+1] = apidlPreviews[j];
                                abTryCached[j+1] = abTryCached[j];
                                aFileTimes[j+1] = aFileTimes[j];
                            }

                            aFileTimes[i] = ft;
                            apidlPreviews[i] = pidl;
                            abTryCached[i] = bTryCached;
                            pidl = NULL;    // don't free
                            break;  // for loop
                        }
                    }

                    // Did we complete the loop?
                    if (i == uNumPreviewsSoFar)
                    {
                        if (i < (int)cMaxPreviews)
                        {
                            // We still have room for more previews, so tack this on at the end.
                            uNumPreviewsSoFar++;
                            aFileTimes[i] = ft;
                            apidlPreviews[i] = pidl;
                            abTryCached[i] = bTryCached;
                            pidl = NULL;    // don't free below
                        }
                    }

                    *pcpidlPreviews = uNumPreviewsSoFar;
                }
            }
            ILFree(pidl);   // NULL pidl OK

            if (bKilled)
            {
                break;
            }
        }
        penum->Release();
    }

    if (bKilled)
    {
        FreeMiniPreviewPidls(apidlPreviews, *pcpidlPreviews);
        *pcpidlPreviews = 0;
        return E_FAIL;
    }
    else
    {
        return (uNumPreviewsSoFar > 0) ? S_OK : S_FALSE;
    }
}

HRESULT CFolderExtractImage::_CreateThumbnailFromIconResource(HBITMAP* phBmpThumbnail, int res)
{
    *phBmpThumbnail = NULL;

    HBITMAP hbmpOld;
    HDC hdc;
    RGBQUAD* prgb;          // the bits of the destination bitmap. 
    
    HRESULT hr = _CreateMainRenderingDC(&hdc, phBmpThumbnail, &hbmpOld, _size.cx, _size.cy, &prgb);

    if (SUCCEEDED(hr))
    {
        HICON hicon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(res), IMAGE_ICON, _size.cx, _size.cy, 0);

        if (hicon)
        {
            RECT rc = { 0, 0, _size.cx + 1, _size.cy + 1};
            SHFillRectClr(hdc, &rc, GetSysColor(COLOR_WINDOW));

            DrawIconEx(hdc, 0, 0, hicon, _size.cx, _size.cy, 0, NULL, DI_NORMAL);
            
            DestroyIcon(hicon);
            hr = S_OK;
        }
        
        _DestroyMainRenderingDC(hdc, hbmpOld);
    }

    if (FAILED(hr) && *phBmpThumbnail)
    {
        DeleteObject(*phBmpThumbnail);
        *phBmpThumbnail = NULL;
    }

    return hr;
}

HRESULT CFolderExtractImage::_CheckThumbnailCache(HBITMAP* phbmp)
{
    HRESULT hr = E_FAIL;
    
    if (!SHRestricted(REST_NOTHUMBNAILCACHE) && 
        !SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("DisableThumbnailCache"), 0, FALSE) &&
        !(_dwExtractFlags & IEIFLAG_QUALITY))
    {
        IShellImageStore *pDiskCache = NULL;
    
        hr = LoadFromFile(CLSID_ShellThumbnailDiskCache, _szFolder, IID_PPV_ARG(IShellImageStore, &pDiskCache));
        if (SUCCEEDED(hr))
        {
            DWORD dwLock;
            
            hr = pDiskCache->Open(STGM_READ, &dwLock);
            if (SUCCEEDED(hr))
            {
                FILETIME ftTimeStamp = {0,0};

                hr = GetDateStamp(&ftTimeStamp);
                if (SUCCEEDED(hr))
                {
                    FILETIME ftTimeStampCache = {0,0};
                    hr = pDiskCache->IsEntryInStore(FOLDER_GUID, &ftTimeStampCache);
                    if (SUCCEEDED(hr))
                    {
                        if (hr == S_OK && (0 == CompareFileTime(&ftTimeStampCache, &ftTimeStamp)))
                        {
                            hr = pDiskCache->GetEntry(FOLDER_GUID, STGM_READ, phbmp);
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }
                }
                pDiskCache->ReleaseLock(&dwLock);
                pDiskCache->Close(NULL);
            }
            pDiskCache->Release();
        }
    }

    TraceMsg(TF_DEFVIEW, "CFolderExtractImage::_CheckThumbnailCache (%s, %x)", _szFolder, hr);
    return hr;
}

void CFolderExtractImage::_CacheThumbnail(HBITMAP hbmp)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (!SHRestricted(REST_NOTHUMBNAILCACHE) && 
        !SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("DisableThumbnailCache"), 0, FALSE))
    {
        SIZE sizeThumbnail;
        SHGetThumbnailSize(&sizeThumbnail);  // Don't cache the mini-thumbnail preview
        if (sizeThumbnail.cx == _size.cx && sizeThumbnail.cy == _size.cy)
        {
            IShellImageStore *pDiskCache = NULL;
            
            hr = LoadFromIDList(CLSID_ShellThumbnailDiskCache, _pidl, IID_PPV_ARG(IShellImageStore, &pDiskCache));
            if (SUCCEEDED(hr))
            {
                DWORD dwLock;
                
                hr = pDiskCache->Open(STGM_READWRITE, &dwLock);
                if (hr == STG_E_FILENOTFOUND)
                {
                    if (!IsCopyEngineRunning())
                    {
                        hr = pDiskCache->Create(STGM_WRITE, &dwLock);
                    }
                }
                
                if (SUCCEEDED(hr))
                {
                    FILETIME ftTimeStamp = {0,0};

                    hr = GetDateStamp(&ftTimeStamp);
                    if (SUCCEEDED(hr))
                    {
                        hr = pDiskCache->AddEntry(FOLDER_GUID, &ftTimeStamp, STGM_WRITE, hbmp);
                    }
                    pDiskCache->ReleaseLock(&dwLock);
                    pDiskCache->Close(NULL);
                }
                pDiskCache->Release();
            }
        }
    }
    TraceMsg(TF_DEFVIEW, "CFolderExtractImage::_CacheThumbnail (%s, %x)", _szFolder, hr);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\folder.cpp ===
#include "shellprv.h"

#include "apithk.h"
#include "folder.h"
#include "ids.h"
#include "deskfldr.h"
#include <winnls.h>
#include "shitemid.h"
#include "sddl.h"
#ifdef _WIN64
#include <wow64t.h>
#endif
#include "filefldr.h"
#include "lmcons.h"
#include "netview.h"

//---------------------------------------------------------------------------
// Get the path for the CSIDL_ folders  and optionally create it if it
// doesn't exist.
//
// Returns FALSE if the special folder given isn't one of those above or the
// directory couldn't be created.
// By default all the special folders are in the windows directory.
// This can be overidden by a [.Shell Folders] section in win.ini with
// entries like Desktop = c:\stuff\desktop
// This in turn can be overidden by a "per user" section in win.ini eg
// [Shell Folder Ianel] - the user name for this section is the current
// network user name, if this fails the default network user name is used
// and if this fails the name given at setup time is used.
//
// "Shell Folders" is the key that records all the absolute paths to the
// shell folders.  The values there are always supposed to be present.
//
// "User Shell Folders" is the key where the user's modifications from
// the defaults are stored.
//
// When we need to find the location of a path, we look in "User Shell Folders"
// first, and if that's not there, generate the default path.  In either
// case we then write the absolute path under "Shell Folders" for other
// apps to look at.  This is so that HKEY_CURRENT_USER can be propagated
// to a machine with Windows installed in a different directory, and as
// long as the user hasn't changed the setting, they won't have the other
// Windows directory hard-coded in the registry.
//   -- gregj, 11/10/94

typedef enum {
    SDIF_NONE                   = 0,
    SDIF_CREATE_IN_ROOT         = 0x00000001,   // create in root (not in profiles dir)
    SDIF_CREATE_IN_WINDIR       = 0x00000002,   // create in the windows dir (not in profiles dir)
    SDIF_CREATE_IN_ALLUSERS     = 0x00000003,   // create in "All Users" folder (not in profiles dir)
    SDIF_CREATE_IN_MYDOCUMENTS  = 0x00000004,   // create in CSIDL_PERSONAL folder
    SDIF_CREATE_IN_LOCALSET     = 0x00000005,   // create in <user>\Local Settings folder

    SDIF_CREATE_IN_MASK         = 0x0000000F,   // mask for above values

    SDIF_CAN_DELETE             = 0x00000010,
    SDIF_SHORTCUT_RELATIVE      = 0x00000020,   // make shortcuts relative to this folder
    SDIF_HIDE                   = 0x00000040,   // hide these when we create them
    SDIF_EMPTY_IF_NOT_IN_REG    = 0x00000080,   // does not exist if nothing in the registry
    SDIF_NOT_FILESYS            = 0x00000100,   // not a file system folder
    SDIF_NOT_TRACKED            = 0x00000200,   // don't track this, it can't change
    SDIF_CONST_IDLIST           = 0x00000400,   // don't alloc or free this
    SDIF_REMOVABLE              = 0x00000800,   // Can exist on removable media
    SDIF_CANT_MOVE_RENAME       = 0x00001000,   // can't move or rename this
    SDIF_WX86                   = 0x00002000,   // do Wx86 thunking
    SDIF_NETWORKABLE            = 0x00004000,   // Can be moved to the net
    SDIF_MAYBE_ALIASED          = 0x00008000,   // could have an alias representation
    SDIF_PERSONALIZED           = 0x00010000,   // resource name is to be personalized
    SDIF_POLICY_NO_MOVE         = 0x00020000,   // policy blocks move
} ;
typedef DWORD FOLDER_FLAGS;

typedef void (*FOLDER_CREATE_PROC)(int id, LPCTSTR pszPath);

void _InitMyPictures(int id, LPCTSTR pszPath);
void _InitMyMusic(int id, LPCTSTR pszPath);
void _InitMyVideos(int id, LPCTSTR pszPath);
void _InitPerUserMyMusic(int id, LPCTSTR pszPath);
void _InitPerUserMyPictures(int id, LPCTSTR pszPath);
void _InitRecentDocs(int id, LPCTSTR pszPath);
void _InitFavorites(int id, LPCTSTR pszPath);

typedef struct {
    int id;                     // CSIDL_ value
    int idsDefault;             // string id of default folder name name
    LPCTSTR pszValueName;       // reg key (not localized)
    HKEY hKey;                  // HKCU or HKLM (Current User or Local Machine)
    FOLDER_FLAGS dwFlags;
    FOLDER_CREATE_PROC pfnInit;
    INT idsLocalizedName;
} FOLDER_INFO;

//  typical entry
#define FOLDER(csidl, ids, value, key, ff)                    \
    { csidl, ids, value, key, ff, NULL, 0}

//  FIXEDFOLDER entries must have be marked SDIF_CONST_IDLIST
//  or have code in _GetFolderDefaultPath() to create their path
//  if they have a filesys path
#define FIXEDFOLDER(csidl, value, ff)                           \
    { csidl, 0, value, NULL, ff, NULL, 0}

//  PROCFOLDER's have a FOLDER_CREATE_PROC pfn that gets
//  run in _PostCreateStuff()
#define PROCFOLDER(csidl, ids, value, key, ff, proc, idsLocal)  \
    {csidl, ids, value, key, ff, proc, idsLocal}

//  folder that needs SHSetLocalizedName() in _PostCreateStuff()
#define LOCALFOLDER(csidl, ids, value, key, ff, idsLocal)  \
    {csidl, ids, value, key, ff, NULL, idsLocal}

const FOLDER_INFO c_rgFolderInfo[] = 
{
FOLDER(         CSIDL_DESKTOP,
                    IDS_CSIDL_DESKTOPDIRECTORY, 
                    TEXT("DesktopFolder"), 
                    NULL, 
                    SDIF_NOT_TRACKED | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_NETWORK,
                    TEXT("NetworkFolder"),
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_DRIVES,    
                    TEXT("DriveFolder"), 
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_INTERNET,  
                    TEXT("InternetFolder"), 
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_CONTROLS,  
                    TEXT("ControlPanelFolder"), 
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_PRINTERS,
                    TEXT("PrintersFolder"), 
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_BITBUCKET, 
                    TEXT("RecycleBinFolder"), 
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_CONNECTIONS, 
                    TEXT("ConnectionsFolder"), 
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FOLDER(         CSIDL_FONTS, 
                    0,
                    TEXT("Fonts"), 
                    HKEY_CURRENT_USER, 
                    SDIF_NOT_TRACKED | SDIF_CREATE_IN_WINDIR | SDIF_CANT_MOVE_RENAME),

FOLDER(         CSIDL_DESKTOPDIRECTORY, 
                    IDS_CSIDL_DESKTOPDIRECTORY, 
                    TEXT("Desktop"), 
                    HKEY_CURRENT_USER, SDIF_SHORTCUT_RELATIVE),

    // _STARTUP is a subfolder of _PROGRAMS is a subfolder of _STARTMENU -- keep that order
FOLDER(         CSIDL_STARTUP,    
                    IDS_CSIDL_STARTUP, 
                    TEXT("Startup"), 
                    HKEY_CURRENT_USER, SDIF_NONE),
                    
FOLDER(         CSIDL_PROGRAMS,   
                    IDS_CSIDL_PROGRAMS, 
                    TEXT("Programs"), 
                    HKEY_CURRENT_USER, 
                    SDIF_NONE),

FOLDER(         CSIDL_STARTMENU,  
                    IDS_CSIDL_STARTMENU, 
                    TEXT("Start Menu"), 
                    HKEY_CURRENT_USER, 
                    SDIF_SHORTCUT_RELATIVE),

PROCFOLDER(     CSIDL_RECENT,
                    IDS_CSIDL_RECENT, 
                    TEXT("Recent"), 
                    HKEY_CURRENT_USER, 
                    SDIF_HIDE | SDIF_CANT_MOVE_RENAME | SDIF_CAN_DELETE,
                    _InitRecentDocs, 
                    IDS_FOLDER_RECENTDOCS),

FOLDER(         CSIDL_SENDTO,     
                    IDS_CSIDL_SENDTO, 
                    TEXT("SendTo"), 
                    HKEY_CURRENT_USER, 
                    SDIF_HIDE),

FOLDER(         CSIDL_PERSONAL,   
                    IDS_CSIDL_PERSONAL, 
                    TEXT("Personal"), 
                    HKEY_CURRENT_USER, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_NETWORKABLE | SDIF_REMOVABLE | SDIF_CONST_IDLIST | SDIF_MAYBE_ALIASED | SDIF_PERSONALIZED | SDIF_POLICY_NO_MOVE),
                    
PROCFOLDER(     CSIDL_FAVORITES,  
                    IDS_CSIDL_FAVORITES, 
                    TEXT("Favorites"), 
                    HKEY_CURRENT_USER, 
                    SDIF_POLICY_NO_MOVE,
                    _InitFavorites,
                    IDS_FOLDER_FAVORITES),

FOLDER(         CSIDL_NETHOOD,    
                    IDS_CSIDL_NETHOOD, 
                    TEXT("NetHood"), 
                    HKEY_CURRENT_USER, 
                    SDIF_HIDE),

FOLDER(         CSIDL_PRINTHOOD,  
                    IDS_CSIDL_PRINTHOOD, 
                    TEXT("PrintHood"), 
                    HKEY_CURRENT_USER, 
                    SDIF_HIDE),
                    
FOLDER(         CSIDL_TEMPLATES,  
                    IDS_CSIDL_TEMPLATES, 
                    TEXT("Templates"), 
                    HKEY_CURRENT_USER, 
                    SDIF_HIDE),

    // Common special folders

    // _STARTUP is a subfolder of _PROGRAMS is a subfolder of _STARTMENU -- keep that order

FOLDER(         CSIDL_COMMON_STARTUP,  
                    IDS_CSIDL_STARTUP,    
                    TEXT("Common Startup"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_CREATE_IN_ALLUSERS | SDIF_CANT_MOVE_RENAME | SDIF_EMPTY_IF_NOT_IN_REG),
                    
FOLDER(         CSIDL_COMMON_PROGRAMS,  
                    IDS_CSIDL_PROGRAMS,  
                    TEXT("Common Programs"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_CREATE_IN_ALLUSERS | SDIF_EMPTY_IF_NOT_IN_REG),
                    
FOLDER(         CSIDL_COMMON_STARTMENU, 
                    IDS_CSIDL_STARTMENU, 
                    TEXT("Common Start Menu"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_CREATE_IN_ALLUSERS | SDIF_EMPTY_IF_NOT_IN_REG),
                    
FOLDER(         CSIDL_COMMON_DESKTOPDIRECTORY, 
                    IDS_CSIDL_DESKTOPDIRECTORY, 
                    TEXT("Common Desktop"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_CREATE_IN_ALLUSERS),
                    
FOLDER(         CSIDL_COMMON_FAVORITES, 
                    IDS_CSIDL_FAVORITES, 
                    TEXT("Common Favorites"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_CREATE_IN_ALLUSERS),

FOLDER(         CSIDL_COMMON_APPDATA,   
                    IDS_CSIDL_APPDATA,   
                    TEXT("Common AppData"),   
                    HKEY_LOCAL_MACHINE, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_CREATE_IN_ALLUSERS),

FOLDER(         CSIDL_COMMON_TEMPLATES, 
                    IDS_CSIDL_TEMPLATES, 
                    TEXT("Common Templates"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE | SDIF_CREATE_IN_ALLUSERS),
                    
LOCALFOLDER(    CSIDL_COMMON_DOCUMENTS, 
                    IDS_CSIDL_ALLUSERS_DOCUMENTS, 
                    TEXT("Common Documents"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_NOT_TRACKED | SDIF_CANT_MOVE_RENAME | SDIF_MAYBE_ALIASED | SDIF_CREATE_IN_ALLUSERS, 
                    IDS_LOCALGDN_FLD_SHARED_DOC),

    // Application Data special folder
FOLDER(         CSIDL_APPDATA, 
                    IDS_CSIDL_APPDATA, 
                    TEXT("AppData"), 
                    HKEY_CURRENT_USER, SDIF_SHORTCUT_RELATIVE),
                    
FOLDER(         CSIDL_LOCAL_APPDATA, 
                    IDS_CSIDL_APPDATA, 
                    TEXT("Local AppData"), 
                    HKEY_CURRENT_USER, SDIF_CREATE_IN_LOCALSET),

    // Non-localized startup folder (do not localize this folder name)
FOLDER(         CSIDL_ALTSTARTUP, 
                    IDS_CSIDL_ALTSTARTUP, 
                    TEXT("AltStartup"), 
                    HKEY_CURRENT_USER, 
                    SDIF_EMPTY_IF_NOT_IN_REG),

    // Non-localized Common StartUp group (do not localize this folde name)
FOLDER(         CSIDL_COMMON_ALTSTARTUP, 
                    IDS_CSIDL_ALTSTARTUP, 
                    TEXT("Common AltStartup"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_EMPTY_IF_NOT_IN_REG | SDIF_CREATE_IN_ALLUSERS),

    // Per-user Internet-related folders

FOLDER(         CSIDL_INTERNET_CACHE, 
                    IDS_CSIDL_CACHE, 
                    TEXT("Cache"), 
                    HKEY_CURRENT_USER, 
                    SDIF_CREATE_IN_LOCALSET),
                    
FOLDER(         CSIDL_COOKIES, 
                    IDS_CSIDL_COOKIES, 
                    TEXT("Cookies"), 
                    HKEY_CURRENT_USER, 
                    SDIF_NONE),

FOLDER(         CSIDL_HISTORY, 
                    IDS_CSIDL_HISTORY, 
                    TEXT("History"), 
                    HKEY_CURRENT_USER, 
                    SDIF_CREATE_IN_LOCALSET),

FIXEDFOLDER(    CSIDL_SYSTEM,
                    TEXT("System"), 
                    SDIF_NOT_TRACKED | SDIF_CANT_MOVE_RENAME | SDIF_SHORTCUT_RELATIVE),

FIXEDFOLDER(    CSIDL_SYSTEMX86, 
                    TEXT("SystemX86"), 
                    SDIF_NOT_TRACKED | SDIF_CANT_MOVE_RENAME | SDIF_WX86 | SDIF_SHORTCUT_RELATIVE),

FIXEDFOLDER(    CSIDL_WINDOWS,
                    TEXT("Windows"), 
                    SDIF_NOT_TRACKED | SDIF_SHORTCUT_RELATIVE | SDIF_CANT_MOVE_RENAME),

FIXEDFOLDER(    CSIDL_PROFILE,
                    TEXT("Profile"), 
                    SDIF_NOT_TRACKED | SDIF_CANT_MOVE_RENAME),
                    
PROCFOLDER(     CSIDL_MYPICTURES, 
                    IDS_CSIDL_MYPICTURES, 
                    TEXT("My Pictures"), 
                    HKEY_CURRENT_USER, 
                    SDIF_CAN_DELETE | SDIF_NETWORKABLE | SDIF_REMOVABLE | SDIF_CREATE_IN_MYDOCUMENTS | SDIF_SHORTCUT_RELATIVE | SDIF_MAYBE_ALIASED | SDIF_PERSONALIZED | SDIF_POLICY_NO_MOVE, 
                    _InitPerUserMyPictures, 
                    0),

//
// CSIDL_PROGRAM_FILES must come after CSIDL_PROGRAM_FILESX86 so that shell links for x86 apps
// work correctly on non-x86 platforms.
// Example:  On IA64 a 32-bit app creates a shortcut via IShellLink to the Program
// Files directory.  A WOW64 registry hive maps "Program Files" to "Program Files (x86)". The shell
// link code then tries to abstract the special folder part of the path by mapping to one of the
// entries in this table.  Since CSIDL_PROGRAM_FILES and CSIDL_PROGRAM_FILESX86 are the same it
// will map to the one that appears first in this table.  When the shortcut is accessed in
// 64-bit mode the cidls are no longer the same.  If CSIDL_PROGRAM_FILES was used instead of
// CSIDL_PROGRAM_FILESX86 the shortcut will be broken.
#ifdef WX86
FIXEDFOLDER(    CSIDL_PROGRAM_FILESX86,
                    TEXT("ProgramFilesX86"), 
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE | SDIF_SHORTCUT_RELATIVE|SDIF_WX86),

FIXEDFOLDER(    CSIDL_PROGRAM_FILES_COMMONX86,   
                    TEXT("CommonProgramFilesX86"), 
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE | SDIF_WX86),
#else
FIXEDFOLDER(    CSIDL_PROGRAM_FILESX86,
                    TEXT("ProgramFilesX86"), 
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE | SDIF_SHORTCUT_RELATIVE),

FIXEDFOLDER(    CSIDL_PROGRAM_FILES_COMMONX86,   
                    TEXT("CommonProgramFilesX86"), 
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE),
#endif

// CSIDL_PROGRAM_FILES must come after CSIDL_PROGRAM_FILESX86.  See comment above.
FIXEDFOLDER(    CSIDL_PROGRAM_FILES,
                    TEXT("ProgramFiles"), 
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE | SDIF_SHORTCUT_RELATIVE),

FIXEDFOLDER(    CSIDL_PROGRAM_FILES_COMMON,
                    TEXT("CommonProgramFiles"),     
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE),

FOLDER(         CSIDL_ADMINTOOLS,         
                    IDS_CSIDL_ADMINTOOLS, 
                    TEXT("Administrative Tools"), 
                    HKEY_CURRENT_USER, 
                    SDIF_NONE),

FOLDER(         CSIDL_COMMON_ADMINTOOLS,  
                    IDS_CSIDL_ADMINTOOLS, 
                    TEXT("Common Administrative Tools"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_CREATE_IN_ALLUSERS),

PROCFOLDER(     CSIDL_MYMUSIC, 
                    IDS_CSIDL_MYMUSIC, 
                    TEXT("My Music"), 
                    HKEY_CURRENT_USER, 
                    SDIF_CAN_DELETE | SDIF_NETWORKABLE | SDIF_REMOVABLE | SDIF_CREATE_IN_MYDOCUMENTS | SDIF_MAYBE_ALIASED | SDIF_PERSONALIZED | SDIF_POLICY_NO_MOVE,
                    _InitPerUserMyMusic,
                    0),

PROCFOLDER(     CSIDL_MYVIDEO, 
                    IDS_CSIDL_MYVIDEO, 
                    TEXT("My Video"), 
                    HKEY_CURRENT_USER, 
                    SDIF_CAN_DELETE | SDIF_NETWORKABLE | SDIF_REMOVABLE | SDIF_CREATE_IN_MYDOCUMENTS | SDIF_MAYBE_ALIASED | SDIF_PERSONALIZED | SDIF_POLICY_NO_MOVE,
                    _InitMyVideos,
                    0),

PROCFOLDER(     CSIDL_COMMON_PICTURES, 
                    IDS_CSIDL_ALLUSERS_PICTURES, 
                    TEXT("CommonPictures"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_CANT_MOVE_RENAME | SDIF_CAN_DELETE | SDIF_MAYBE_ALIASED | SDIF_CREATE_IN_ALLUSERS, 
                    _InitMyPictures, 
                    IDS_SHAREDPICTURES),

PROCFOLDER(     CSIDL_COMMON_MUSIC, 
                    IDS_CSIDL_ALLUSERS_MUSIC, 
                    TEXT("CommonMusic"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_CANT_MOVE_RENAME | SDIF_CAN_DELETE | SDIF_MAYBE_ALIASED | SDIF_CREATE_IN_ALLUSERS, 
                    _InitMyMusic,
                    IDS_SHAREDMUSIC),

PROCFOLDER(     CSIDL_COMMON_VIDEO, 

                    IDS_CSIDL_ALLUSERS_VIDEO, 
                    TEXT("CommonVideo"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_CANT_MOVE_RENAME | SDIF_CAN_DELETE | SDIF_MAYBE_ALIASED | SDIF_CREATE_IN_ALLUSERS, 
                    _InitMyVideos,
                    IDS_SHAREDVIDEO),

FIXEDFOLDER(    CSIDL_RESOURCES, 
                    TEXT("ResourceDir"), 
                    SDIF_NOT_TRACKED),

FIXEDFOLDER(    CSIDL_RESOURCES_LOCALIZED, 
                    TEXT("LocalizedResourcesDir"), 
                    SDIF_NOT_TRACKED),

FOLDER(         CSIDL_COMMON_OEM_LINKS, 
                    IDS_CSIDL_ALLUSERS_OEM_LINKS, 
                    TEXT("OEM Links"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_CAN_DELETE | SDIF_CREATE_IN_ALLUSERS | SDIF_EMPTY_IF_NOT_IN_REG),

FOLDER(         CSIDL_CDBURN_AREA, 
                    IDS_CSIDL_CDBURN_AREA, 
                    TEXT("CD Burning"), 
                    HKEY_CURRENT_USER, 
                    SDIF_CAN_DELETE | SDIF_CREATE_IN_LOCALSET),

FIXEDFOLDER(    CSIDL_COMPUTERSNEARME, 
                    TEXT("ComputersNearMe"), 
                    SDIF_NONE),

FIXEDFOLDER(-1, NULL, SDIF_NONE)
};


EXTERN_C const IDLREGITEM c_idlMyDocs =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_MYDOCS,
    { 0x450d8fba, 0xad25, 0x11d0, 0x98,0xa8,0x08,0x00,0x36,0x1b,0x11,0x03, },}, // CLSID_MyDocuments
    0,
} ;

EXTERN_C const IDREGITEM c_idlPrinters[] =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_DRIVES,
    { 0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_MyComputer
    {sizeof(IDREGITEM), SHID_COMPUTER_REGITEM, 0,
    { 0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_ControlPanel
    {sizeof(IDREGITEM), SHID_CONTROLPANEL_REGITEM, 0,
    { 0x2227A280, 0x3AEA, 0x1069, 0xA2, 0xDE, 0x08, 0x00, 0x2B, 0x30, 0x30, 0x9D, },}, // CLSID_Printers
    0,
} ;

EXTERN_C const IDREGITEM c_idlControls[] =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_DRIVES,
    { 0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_MyComputer
    {sizeof(IDREGITEM), SHID_COMPUTER_REGITEM, 0,
    { 0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_ControlPanel
    0,
} ;

EXTERN_C const IDLREGITEM c_idlBitBucket =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_RECYCLEBIN,
    { 0x645FF040, 0x5081, 0x101B, 0x9F, 0x08, 0x00, 0xAA, 0x00, 0x2F, 0x95, 0x4E, },}, // CLSID_RecycleBin
    0,
} ;

// this array holds a cache of the values of these folders. this cache can only
// be used in the hToken == NULL case otherwise we would need a per user version
// of this cache.

#define SFENTRY(x)  { (LPTSTR)-1, (LPITEMIDLIST)x , (LPITEMIDLIST)-1}

EXTERN_C const IDREGITEM c_aidlConnections[];

struct {
    LPTSTR       psz;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlNonAlias;
} g_aFolderCache[] = {
    SFENTRY(&c_idlDesktop),    // CSIDL_DESKTOP                   (0x0000)
    SFENTRY(&c_idlInetRoot),   // CSIDL_INTERNET                  (0x0001)
    SFENTRY(-1),               // CSIDL_PROGRAMS                  (0x0002)
    SFENTRY(&c_idlControls),   // CSIDL_CONTROLS                  (0x0003)
    SFENTRY(&c_idlPrinters),   // CSIDL_PRINTERS                  (0x0004)
    SFENTRY(&c_idlMyDocs),     // CSIDL_PERSONAL                  (0x0005)
    SFENTRY(-1),               // CSIDL_FAVORITES                 (0x0006)
    SFENTRY(-1),               // CSIDL_STARTUP                   (0x0007)
    SFENTRY(-1),               // CSIDL_RECENT                    (0x0008)
    SFENTRY(-1),               // CSIDL_SENDTO                    (0x0009)
    SFENTRY(&c_idlBitBucket),  // CSIDL_BITBUCKET                 (0x000a)
    SFENTRY(-1),               // CSIDL_STARTMENU                 (0x000b)
    SFENTRY(-1),               // CSIDL_MYDOCUMENTS               (0x000c)
    SFENTRY(-1),               // CSIDL_MYMUSIC                   (0x000d)
    SFENTRY(-1),               // CSIDL_MYVIDEO                   (0x000e)
    SFENTRY(-1),               // <unused>                        (0x000f)
    SFENTRY(-1),               // CSIDL_DESKTOPDIRECTORY          (0x0010)
    SFENTRY(&c_idlDrives),     // CSIDL_DRIVES                    (0x0011)
    SFENTRY(&c_idlNet),        // CSIDL_NETWORK                   (0x0012)
    SFENTRY(-1),               // CSIDL_NETHOOD                   (0x0013)
    SFENTRY(-1),               // CSIDL_FONTS                     (0x0014)
    SFENTRY(-1),               // CSIDL_TEMPLATES                 (0x0015)
    SFENTRY(-1),               // CSIDL_COMMON_STARTMENU          (0x0016)
    SFENTRY(-1),               // CSIDL_COMMON_PROGRAMS           (0X0017)
    SFENTRY(-1),               // CSIDL_COMMON_STARTUP            (0x0018)
    SFENTRY(-1),               // CSIDL_COMMON_DESKTOPDIRECTORY   (0x0019)
    SFENTRY(-1),               // CSIDL_APPDATA                   (0x001a)
    SFENTRY(-1),               // CSIDL_PRINTHOOD                 (0x001b)
    SFENTRY(-1),               // CSIDL_LOCAL_APPDATA             (0x001c)
    SFENTRY(-1),               // CSIDL_ALTSTARTUP                (0x001d)
    SFENTRY(-1),               // CSIDL_COMMON_ALTSTARTUP         (0x001e)
    SFENTRY(-1),               // CSIDL_COMMON_FAVORITES          (0x001f)
    SFENTRY(-1),               // CSIDL_INTERNET_CACHE            (0x0020)
    SFENTRY(-1),               // CSIDL_COOKIES                   (0x0021)
    SFENTRY(-1),               // CSIDL_HISTORY                   (0x0022)
    SFENTRY(-1),               // CSIDL_COMMON_APPDATA            (0x0023)
    SFENTRY(-1),               // CSIDL_WINDOWS                   (0x0024)
    SFENTRY(-1),               // CSIDL_SYSTEM                    (0x0025)
    SFENTRY(-1),               // CSIDL_PROGRAM_FILES             (0x0026)
    SFENTRY(-1),               // CSIDL_MYPICTURES                (0x0027)
    SFENTRY(-1),               // CSIDL_PROFILE                   (0x0028)
    SFENTRY(-1),               // CSIDL_SYSTEMX86                 (0x0029)
    SFENTRY(-1),               // CSIDL_PROGRAM_FILESX86          (0x002a)
    SFENTRY(-1),               // CSIDL_PROGRAM_FILES_COMMON      (0x002b)
    SFENTRY(-1),               // CSIDL_PROGRAM_FILES_COMMONX86   (0x002c)
    SFENTRY(-1),               // CSIDL_COMMON_TEMPLATES          (0x002d)
    SFENTRY(-1),               // CSIDL_COMMON_DOCUMENTS          (0x002e)
    SFENTRY(-1),               // CSIDL_COMMON_ADMINTOOLS         (0x002f)
    SFENTRY(-1),               // CSIDL_ADMINTOOLS                (0x0030)
    SFENTRY(c_aidlConnections), // CSIDL_CONNECTIONS              (0x0031)
    SFENTRY(-1),               //                                 (0x0032)
    SFENTRY(-1),               //                                 (0x0033)
    SFENTRY(-1),               //                                 (0x0034)
    SFENTRY(-1),               // CSIDL_COMMON_MUSIC              (0x0035)
    SFENTRY(-1),               // CSIDL_COMMON_PICTURES           (0x0036)
    SFENTRY(-1),               // CSIDL_COMMON_VIDEO              (0x0037)
    SFENTRY(-1),               // CSIDL_RESOURCES                 (0x0038)
    SFENTRY(-1),               // CSIDL_RESOURCES_LOCALIZED       (0x0039)
    SFENTRY(-1),               // CSIDL_COMMON_OEM_LINKS          (0x003a)
    SFENTRY(-1),               // CSIDL_CDBURN_AREA               (0x003b)
    SFENTRY(-1),               // <unused>                        (0x003c)
    SFENTRY(-1),               // CSIDL_COMPUTERSNEARME           (0x003d)
};

HRESULT _OpenKeyForFolder(const FOLDER_INFO *pfi, HANDLE hToken, LPCTSTR pszSubKey, HKEY *phkey);
void _UpdateShellFolderCache(void);
BOOL GetUserProfileDir(HANDLE hToken, TCHAR *pszPath);
HRESULT VerifyAndCreateFolder(HWND hwnd, const FOLDER_INFO *pfi, UINT uFlags, LPTSTR pszPath) ;


#define _IsDefaultUserToken(hToken)     ((HANDLE)-1 == hToken)


const FOLDER_INFO *_GetFolderInfo(int csidl)
{
    const FOLDER_INFO *pfi;

    // make sure g_aFolderCache can be indexed by the CSIDL values

    COMPILETIME_ASSERT((ARRAYSIZE(g_aFolderCache) - 1) == CSIDL_COMPUTERSNEARME);

    for (pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        if (pfi->id == csidl)
            return pfi;
    }
    return NULL;
}


// expand an individual enviornment variable
// in:
//      pszVar      "%USERPROFILE%
//      pszValue    "c:\winnt\profiles\user"
//
// in/out:
//      pszToExpand in: %USERPROFILE%\My Docs", out: c:\winnt\profiles\user\My Docs"

BOOL ExpandEnvVar(LPCTSTR pszVar, LPCTSTR pszValue, LPTSTR pszToExpand)
{
    TCHAR *pszStart = StrStrI(pszToExpand, pszVar);
    if (pszStart)
    {
        TCHAR szAfter[MAX_PATH];

        lstrcpy(szAfter, pszStart + lstrlen(pszVar));   // save the tail
        lstrcpyn(pszStart, pszValue, (int) (MAX_PATH - (pszStart - pszToExpand)));
        StrCatBuff(pszToExpand, szAfter, MAX_PATH);       // put the tail back on
        return TRUE;
    }
    return FALSE;
}

HANDLE GetCurrentUserToken()
{
    HANDLE hToken;
    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken) ||
        OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_IMPERSONATE, &hToken))
        return hToken;
    return NULL;
}


// like ExpandEnvironmentStrings but is robust to the enviornment variables
// not being set. this works on...
// %SYSTEMROOT%
// %SYSTEMDRIVE%
// %USERPROFILE%
// %ALLUSERSPROFILE%
//
// in the rare case (Winstone!) that there is a NULL enviornment block

DWORD ExpandEnvironmentStringsNoEnv(HANDLE hToken, LPCTSTR pszExpand, LPTSTR pszOut, UINT cchOut)
{
    TCHAR szPath[MAX_PATH];
    if (hToken && !_IsDefaultUserToken(hToken))
    {
        if (!ExpandEnvironmentStringsForUser(hToken, pszExpand, pszOut, cchOut))
            lstrcpyn(pszOut, pszExpand, cchOut);
    }
    else if (hToken == NULL)
    {
        // to debug env expansion failure...
        // lstrcpyn(pszOut, pszExpand, cchOut);
        SHExpandEnvironmentStrings(pszExpand, pszOut, cchOut);
    }

    // manually expand in this order since 
    //  %USERPROFILE% -> %SYSTEMDRIVE%\Docs & Settings

    if (StrChr(pszOut, TEXT('%')) && (hToken == NULL))
    {
        hToken = GetCurrentUserToken();
        if (hToken)
        {
            // this does %USERPROFILE% and other per user stuff
            ExpandEnvironmentStringsForUser(hToken, pszExpand, pszOut, cchOut);
            CloseHandle(hToken);
        }
    }
    else if (_IsDefaultUserToken(hToken) && StrChr(pszOut, TEXT('%')))
    {
        GetUserProfileDir(hToken, szPath);
        ExpandEnvVar(TEXT("%USERPROFILE%"), szPath, pszOut);
    }

    if (*pszOut == TEXT('%'))
    {
        GetAllUsersDirectory(szPath);
        ExpandEnvVar(TEXT("%ALLUSERSPROFILE%"), szPath, pszOut);
    }

    if (*pszOut == TEXT('%'))
    {
        GetSystemWindowsDirectory(szPath, ARRAYSIZE(szPath));
        ExpandEnvVar(TEXT("%SYSTEMROOT%"), szPath, pszOut);
    }

    if (*pszOut == TEXT('%'))
    {
        GetSystemWindowsDirectory(szPath, ARRAYSIZE(szPath));
        ASSERT(szPath[1] == TEXT(':')); // this better not be a UNC!
        szPath[2] = 0; // SYSTEMDRIVE = 'c:', not 'c:\'
        ExpandEnvVar(TEXT("%SYSTEMDRIVE%"), szPath, pszOut);
    }

    if (*pszOut == TEXT('%'))
        *pszOut = 0;

    return lstrlen(pszOut) + 1;    // +1 to cover the NULL
}

// get the user profile directory:
// uses the hToken as needed to determine the proper user profile

BOOL GetUserProfileDir(HANDLE hToken, TCHAR *pszPath)
{
    DWORD dwcch = MAX_PATH;
    HANDLE hClose = NULL;
    BOOL fRet;
    
    *pszPath = 0;       // in case of error

    if (!hToken)
    {
        hClose = hToken = GetCurrentUserToken();
    }
    if (_IsDefaultUserToken(hToken))
    {
        fRet = GetDefaultUserProfileDirectory(pszPath, &dwcch);
    }
    else
    {
        fRet = GetUserProfileDirectory(hToken, pszPath, &dwcch);
    }
    if (hClose)
    {
        CloseHandle(hClose);
    }
    return fRet;
}

#ifdef WX86
void SetUseKnownWx86Dll(const FOLDER_INFO *pfi, BOOL bValue)
{
    if (pfi->dwFlags & SDIF_WX86)
    {
        //  GetSystemDirectory() knows we're looking for the Wx86 system
        //  directory when this flag is set.
        NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = bValue ? TRUE : FALSE;
    }
}
#else
#define SetUseKnownWx86Dll(pfi, bValue)
#endif

// read from registry
BOOL GetProgramFiles(LPCTSTR pszValue, LPTSTR pszPath)
{
    DWORD cbPath = MAX_PATH * sizeof(*pszPath);

    *pszPath = 0;

    SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion"), 
        pszValue, NULL, pszPath, &cbPath);
    return (BOOL)*pszPath;
}

LPTSTR GetFontsDirectory(LPTSTR pszPath)
{
    if (GetWindowsDirectory(pszPath, MAX_PATH))
    {
        PathAppend(pszPath, TEXT("Fonts"));
    }

    return pszPath;
}

void LoadDefaultString(int idString, LPTSTR lpBuffer, int cchBufferMax)
{
    BOOL fSucceeded = FALSE;
    HRSRC hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;
    HMODULE hmod = GetModuleHandle(TEXT("SHELL32"));
    
    // Make sure the parms are valid.     
    if (lpBuffer == NULL || cchBufferMax == 0) 
    {
        return;
    }

    cch = 0;
    
    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.     
    if (hResInfo = FindResourceExW(hmod, (LPCWSTR)RT_STRING,
                                   (LPWSTR)((LONG_PTR)(((USHORT)idString >> 4) + 1)), GetSystemDefaultUILanguage())) 
    {        
        // Load that segment.        
        hStringSeg = LoadResource(hmod, hResInfo);
        
        // Lock the resource.        
        if (lpsz = (LPWSTR)LockResource(hStringSeg)) 
        {            
            // Move past the other strings in this segment.
            // (16 strings in a segment -> & 0x0F)             
            idString &= 0x0F;
            while (TRUE) 
            {
                cch = *((WORD *)lpsz++);   // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
                if (idString-- == 0) break;
                lpsz += cch;                // Step to start if next string
             }
            
                            
            // Account for the NULL                
            cchBufferMax--;
                
            // Don't copy more than the max allowed.                
            if (cch > cchBufferMax)
                cch = cchBufferMax;
                
            // Copy the string into the buffer.                
            CopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));

            // Attach Null terminator.
            lpBuffer[cch] = 0;

            fSucceeded = TRUE;

        }
    }

    if (!fSucceeded)
    {
        LoadString(HINST_THISDLL, idString, lpBuffer, cchBufferMax);
    }
}

BOOL GetLocalSettingsDir(HANDLE hToken, LPTSTR pszPath)
{
    *pszPath = 0;

    GetUserProfileDir(hToken, pszPath);

    if (*pszPath)
    {
        TCHAR szEntry[MAX_PATH];
        LoadDefaultString(IDS_LOCALSETTINGS, szEntry, ARRAYSIZE(szEntry));
        PathAppend(pszPath, szEntry);
    }
    return *pszPath ? TRUE : FALSE;
}


HRESULT GetResourcesDir(IN BOOL fLocalized, IN LPTSTR pszPath, IN DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    TCHAR szTemp[MAX_PATH];

    RIP(IS_VALID_WRITE_BUFFER(pszPath, TCHAR, cchSize));
    pszPath[0] = 0; // Terminate in case we fail.

    if (SHGetSystemWindowsDirectory(szTemp, ARRAYSIZE(szTemp)))
    {
        // It's now "%windir%\resources\".
        PathAppend(szTemp, TEXT("resources"));

        if (fLocalized)
        {
            LANGID  lidUI = GetUserDefaultUILanguage();
            TCHAR szSubDir[10];

            // Now make it "%windir%\resources\<LangID>\"
            wnsprintfW(szSubDir, ARRAYSIZE(szSubDir), TEXT("%04x"), lidUI);
            PathAppend(szTemp, szSubDir);
        }

        StrCpyN(pszPath, szTemp, cchSize);
        hr = S_OK;
    }

    return hr;
}


// out:
//      pszPath     fills in with the full path with no env gunk (MAX_PATH)

HRESULT _GetFolderDefaultPath(const FOLDER_INFO *pfi, HANDLE hToken, LPTSTR pszPath)
{
    ASSERT(!(pfi->dwFlags & SDIF_NOT_FILESYS)); // speical folders should not come here

    *pszPath = 0;

    TCHAR szEntry[MAX_PATH];

    switch (pfi->id)
    {
    case CSIDL_PROFILE:
        GetUserProfileDir(hToken, pszPath);
        break;

    case CSIDL_PROGRAM_FILES:
        GetProgramFiles(TEXT("ProgramFilesDir"), pszPath);
        break;

    case CSIDL_PROGRAM_FILES_COMMON:
        GetProgramFiles(TEXT("CommonFilesDir"), pszPath);
        break;

    case CSIDL_PROGRAM_FILESX86:
        GetProgramFiles(TEXT("ProgramFilesDir (x86)"), pszPath);
        break;

    case CSIDL_PROGRAM_FILES_COMMONX86:
        GetProgramFiles(TEXT("CommonFilesDir (x86)"), pszPath);
        break;
#ifdef _WIN64
    case CSIDL_SYSTEMX86:
        //
        // downlevel systems do not have GetSystemWindowsDirectory export,
        // but shell thunking layer handles this gracefully
        GetSystemWindowsDirectory(pszPath, MAX_PATH); 
        //
        // tack on subdirectory
        //
        PathCombine(pszPath, pszPath, TEXT(WOW64_SYSTEM_DIRECTORY));        
        break;
#else
    case CSIDL_SYSTEMX86:
#endif
    case CSIDL_SYSTEM:
        GetSystemDirectory(pszPath, MAX_PATH);
        break;

    case CSIDL_WINDOWS:
        GetWindowsDirectory(pszPath, MAX_PATH);
        break;

    case CSIDL_RESOURCES:
        GetResourcesDir(FALSE, pszPath, MAX_PATH);
        break;

    case CSIDL_RESOURCES_LOCALIZED:
        GetResourcesDir(TRUE, pszPath, MAX_PATH);
        break;

    case CSIDL_COMPUTERSNEARME:
        // no path for this
        break;

    case CSIDL_FONTS:
        GetFontsDirectory(pszPath);
        break;

    default:
        switch (pfi->dwFlags & SDIF_CREATE_IN_MASK)
        {
        case SDIF_CREATE_IN_ROOT:
            GetWindowsDirectory(pszPath, MAX_PATH);
            PathStripToRoot(pszPath);
            break;

        case SDIF_CREATE_IN_ALLUSERS:
            GetAllUsersDirectory(pszPath);
            break;

        case SDIF_CREATE_IN_WINDIR:
            GetWindowsDirectory(pszPath, MAX_PATH);
            break;

        case SDIF_CREATE_IN_MYDOCUMENTS:
            //  99/10/21 Mil#104600: When asking for folders in "My Documents" don't
            //  verify their existance. Just return the path. The caller will make
            //  the decision to create the folder or not.

            // on failure *pszPath will be empty

            SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY, hToken, SHGFP_TYPE_CURRENT, pszPath);
            break;

        case SDIF_CREATE_IN_LOCALSET:
            GetLocalSettingsDir(hToken, pszPath);
            break;

        default:
            GetUserProfileDir(hToken, pszPath);
            break;
        }

        if (*pszPath)
        {
            LoadDefaultString(pfi->idsDefault, szEntry, ARRAYSIZE(szEntry));
            PathAppend(pszPath, szEntry);
        }
        break;
    }
    return *pszPath ? S_OK : E_FAIL;
}

 
void RegSetFolderPath(const FOLDER_INFO *pfi, LPCTSTR pszSubKey, LPCTSTR pszPath)
{
    HKEY hk;
    if (SUCCEEDED(_OpenKeyForFolder(pfi, NULL, pszSubKey, &hk)))
    {
        if (pszPath)
            RegSetValueEx(hk, pfi->pszValueName, 0, REG_SZ, (LPBYTE)pszPath, (1 + lstrlen(pszPath)) * sizeof(TCHAR));
        else
            RegDeleteValue(hk, pfi->pszValueName);
        RegCloseKey(hk);
    }
}

BOOL RegQueryPath(HKEY hk, LPCTSTR pszValue, LPTSTR pszPath)
{
    DWORD cbPath = MAX_PATH * sizeof(TCHAR);

    *pszPath = 0;
    SHQueryValueEx(hk, pszValue, 0, NULL, pszPath, &cbPath);
    return (BOOL)*pszPath;
}


// More than 50 is silly
#define MAX_TEMP_FILE_TRIES         50

// returns:
//      S_OK        the path exists and it is a folder
//      FAILED()    result
HRESULT _IsFolderNotFile(LPCTSTR pszFolder)
{
    HRESULT hr;
    DWORD dwAttribs = GetFileAttributes(pszFolder);
    if (dwAttribs == -1)
    {
        DWORD err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
    }
    else
    {
        // see if it is a file, if so we need to rename that file
        if (dwAttribs & FILE_ATTRIBUTE_DIRECTORY)
        {
            hr = S_OK;
        }
        else
        {
            int iExt = 0;
            do
            {
                TCHAR szExt[32], szDst[MAX_PATH];

                wsprintf(szExt, TEXT(".%03d"), iExt);
                lstrcpy(szDst, pszFolder);
                lstrcat(szDst, szExt);
                if (MoveFile(pszFolder, szDst))
                    iExt = 0;
                else
                {
                    // Normally we fail because .00x already exists but that may not be true.
                    DWORD dwError = GetLastError();
                    if (ERROR_ALREADY_EXISTS == dwError)
                        iExt++;     // Try the next one...
                    else
                        iExt = 0;   // We have problems and need to give up. (No write access?)
                }

            } while (iExt && (iExt < MAX_TEMP_FILE_TRIES));

            hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
        }
    }
    return hr;
}

HRESULT _OpenKeyForFolder(const FOLDER_INFO *pfi, HANDLE hToken, LPCTSTR pszSubKey, HKEY *phkey)
{
    TCHAR szRegPath[255];
    LONG err;
    HKEY hkRoot, hkeyToFree = NULL;

    *phkey = NULL;

    lstrcpy(szRegPath, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\"));
    lstrcat(szRegPath, pszSubKey);

    if (_IsDefaultUserToken(hToken) && (pfi->hKey == HKEY_CURRENT_USER))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_USERS, TEXT(".Default"), 0, KEY_READ, &hkRoot))
            hkeyToFree = hkRoot;
        else
            return E_FAIL;
    }
    else if (hToken && (pfi->hKey == HKEY_CURRENT_USER))
    {
        if (GetUserProfileKey(hToken, &hkRoot))
            hkeyToFree = hkRoot;
        else
            return E_FAIL;
    }
    else
        hkRoot = pfi->hKey;

    err = RegCreateKeyEx(hkRoot, szRegPath, 0, NULL, REG_OPTION_NON_VOLATILE,
                MAXIMUM_ALLOWED, NULL, phkey, NULL);
    
    if (hkeyToFree)
        RegCloseKey(hkeyToFree);

    return HRESULT_FROM_WIN32(err);
}

//
//  Roaming Profiles can set up the environment variables and registry
//  keys like so:
//
//  HOMESHARE=\\server\share\user
//  HOMEPATH=\
//  My Music=%HOMESHARE%%HOMEPATH%\My Music
//
//  so you end up with "\\server\share\user\\My Music", which is an
//  invalid path.  Clean them up; otherwise SHGetSpecialFolderLocation will
//  fail.
//
void _CleanExpandedEnvironmentPath(LPTSTR szExpand)
{
    // Search for "\\" at a location other than the start of the string.
    // If found, collapse it.
    LPTSTR pszWhackWhack;
    while (lstrlen(szExpand) > 2 &&
           (pszWhackWhack = StrStr(szExpand+1, TEXT("\\\\"))))
    {
        StrCpy(pszWhackWhack+1, pszWhackWhack+2);
    }
}

// returns:
//      S_OK        found in registry, path well formed
//      S_FALSE     empty registry
//      FAILED()    failure result

HRESULT _GetFolderFromReg(const FOLDER_INFO *pfi, HANDLE hToken, LPTSTR pszPath)
{
    HKEY hkUSF;
    HRESULT hr;

    *pszPath = 0;

    hr = _OpenKeyForFolder(pfi, hToken, TEXT("User Shell Folders"), &hkUSF);
    if (SUCCEEDED(hr))
    {
        TCHAR szExpand[MAX_PATH];
        DWORD dwType, cbPath = sizeof(szExpand);

        if (RegQueryValueEx(hkUSF, pfi->pszValueName, 0, &dwType, (BYTE *)szExpand, &cbPath) == ERROR_SUCCESS)
        {
            if (REG_SZ == dwType)
            {
                lstrcpyn(pszPath, szExpand, MAX_PATH);
            }
            else if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStringsNoEnv(hToken, szExpand, pszPath, MAX_PATH);
                _CleanExpandedEnvironmentPath(pszPath);
            }
            TraceMsg(TF_PATH, "_CreateFolderPath 'User Shell Folders' %s = %s", pfi->pszValueName, pszPath);
        }

        if (*pszPath == 0)
        {
            hr = S_FALSE;     // empty registry, success but empty
        }
        else if ((PathGetDriveNumber(pszPath) != -1) || PathIsUNC(pszPath))
        {
            hr = S_OK;        // good reg path, fully qualified
        }
        else
        {
            *pszPath = 0;       // bad reg data
            hr = E_INVALIDARG;
        }

        RegCloseKey(hkUSF);
    }
    return hr;
}

HRESULT _GetFolderPath(HWND hwnd, const FOLDER_INFO *pfi, HANDLE hToken, UINT uFlags, LPTSTR pszPath)
{
    HRESULT hr;

    *pszPath = 0;       // assume failure

    if (pfi->hKey)
    {
        hr = _GetFolderFromReg(pfi, hToken, pszPath);
        if (SUCCEEDED(hr))
        {
            if (hr == S_FALSE)
            {
                // empty registry, SDIF_EMPTY_IF_NOT_IN_REG means they don't exist
                // if the registry is not populated with a value. this lets us disable
                // the common items on platforms that don't want them

                if (pfi->dwFlags & SDIF_EMPTY_IF_NOT_IN_REG)
                    return S_FALSE;     // success, but empty

                hr = _GetFolderDefaultPath(pfi, hToken, pszPath);
            }

            if (!(uFlags & CSIDL_FLAG_DONT_VERIFY))
            {
               hr = VerifyAndCreateFolder(hwnd, pfi, uFlags, pszPath) ;
            }

            if (hr != S_OK)
            {
                *pszPath = 0;
            }

            if (!(uFlags & CSIDL_FLAG_DONT_VERIFY))
            {
                HKEY hkey;
                // record value in "Shell Folders", even in the failure case

                // NOTE: we only do this for historical reasons. there may be some
                // apps that depend on these values being in the registry, but in general
                // the contetens here are unreliable as they are only written after someone
                // asks for the folder through this API.

                if (SUCCEEDED(_OpenKeyForFolder(pfi, hToken, TEXT("Shell Folders"), &hkey)))
                {
                    RegSetValueEx(hkey, pfi->pszValueName, 0, REG_SZ, (LPBYTE)pszPath, (1 + lstrlen(pszPath)) * sizeof(TCHAR));
                    RegCloseKey(hkey);
                }
            }
        }
    }
    else
    {
        hr = _GetFolderDefaultPath(pfi, hToken, pszPath);

        if ((S_OK == hr) && !(uFlags & CSIDL_FLAG_DONT_VERIFY))
        {
            hr = VerifyAndCreateFolder(hwnd, pfi, uFlags, pszPath);
        }
        
        if (hr != S_OK)
        {
            *pszPath = 0;
        }
    }

    ASSERT(hr == S_OK ? *pszPath != 0 : *pszPath == 0);
    return hr;
}

void _PostCreateStuff(const FOLDER_INFO *pfi, LPTSTR pszPath, BOOL fUpgrade)
{
    if (pfi->pfnInit || pfi->idsLocalizedName || (pfi->dwFlags & SDIF_PERSONALIZED))
    {
        if (fUpgrade)
        {
            //  if we are upgrading, torch all our previous meta data
            TCHAR sz[MAX_PATH];
            PathCombine(sz, pszPath, TEXT("desktop.ini"));

            if (PathFileExistsAndAttributes(sz, NULL))
            {
                WritePrivateProfileSection(TEXT(".ShellClassInfo"), NULL, sz);
                //  in the upgrade case, sometimes the desktop.ini
                //  file was there but the folder wasnt marked.
                //  insure that it is marked.
                PathMakeSystemFolder(pszPath);
            }
        }
    
        // now call the create proc if we have one
        if (pfi->pfnInit)
            pfi->pfnInit(pfi->id, pszPath);

        // does the table specify a localized resource name that we should be 
        // using for this object?
        if (pfi->idsLocalizedName)
            SHSetLocalizedName(pszPath, TEXT("shell32.dll"), pfi->idsLocalizedName);

        // do we need to store the user name for this folder?

        if (pfi->dwFlags & SDIF_PERSONALIZED)
        {
            TCHAR szName[UNLEN+1];
            DWORD dwName = ARRAYSIZE(szName);
            if (GetUserName(szName, &dwName))
            {
                // CSharedDocuments depends on a per system list of MyDocs folders
                // this is where we make sure that list is setup

                if (!IsOS(OS_DOMAINMEMBER) && (pfi->id == CSIDL_PERSONAL))
                {
                    SKSetValue(SHELLKEY_HKLM_EXPLORER, L"DocFolderPaths",
                               szName, REG_SZ, pszPath, (lstrlen(pszPath) + 1) * sizeof(TCHAR));
                }

                SetFolderString(TRUE, pszPath, NULL, L"DeleteOnCopy", SZ_CANBEUNICODE TEXT("Owner"), szName);
                wsprintf(szName, L"%d", pfi->id);
                SetFolderString(TRUE, pszPath, NULL, L"DeleteOnCopy", TEXT("Personalized"), szName);
                LoadDefaultString(pfi->idsDefault, szName, ARRAYSIZE(szName));
                SetFolderString(TRUE, pszPath, NULL, L"DeleteOnCopy", SZ_CANBEUNICODE TEXT("PersonalizedName"), szName);
            }
        }
    }
}

HRESULT VerifyAndCreateFolder(HWND hwnd, const FOLDER_INFO *pfi, UINT uFlags, LPTSTR pszPath)
{
    HRESULT hr = _IsFolderNotFile(pszPath);

    // this code supports a UI mode of this API. but generally this is not used
    // this code should be removed
    if ((hr != S_OK) && hwnd)
    {
        // we might be able to reconnect if this is a net path
        if (PathIsUNC(pszPath))
        {
            if (SHValidateUNC(hwnd, pszPath, 0))
                hr = _IsFolderNotFile(pszPath);
        }
        else if (IsDisconnectedNetDrive(DRIVEID(pszPath)))
        {
            TCHAR szDrive[3];
            PathBuildSimpleRoot(DRIVEID(pszPath), szDrive);

            if (WNetRestoreConnection(hwnd, szDrive) == WN_SUCCESS)
                hr = _IsFolderNotFile(pszPath);
         }
    }

    // to avoid a sequence of long net timeouts or calls we know won't
    // succeed test for these specific errors and don't try to create
    // the folder

    if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ||
        hr == HRESULT_FROM_WIN32(ERROR_BAD_NETPATH))
    {
        return hr;
    }

    if ((hr != S_OK) && (uFlags & CSIDL_FLAG_CREATE))
    {
        DWORD err = SHCreateDirectory(NULL, pszPath);
        hr = HRESULT_FROM_WIN32(err);
        if (hr == S_OK)
        {
            ASSERT(NULL == StrChr(pszPath, TEXT('%')));

            if (pfi->dwFlags & SDIF_HIDE)
                SetFileAttributes(pszPath, GetFileAttributes(pszPath) | FILE_ATTRIBUTE_HIDDEN);

            _PostCreateStuff(pfi, pszPath, FALSE);
        }   
    }
    else if (hr == S_OK)
    {
        if (uFlags & CSIDL_FLAG_PER_USER_INIT)
            _PostCreateStuff(pfi, pszPath, TRUE);
    }

    return hr;
}

void _SetPathCache(const FOLDER_INFO *pfi, LPCTSTR psz)
{
    LPTSTR pszOld = (LPTSTR)InterlockedExchangePointer((void **)&g_aFolderCache[pfi->id].psz, (void *)psz);
    if (pszOld && pszOld != (LPTSTR)-1)
    {
        // check for the concurent use... very rare case
        LocalFree(pszOld);
    }
}


HRESULT _GetFolderPathCached(HWND hwnd, const FOLDER_INFO *pfi, HANDLE hToken, UINT uFlags, LPTSTR pszPath)
{
    HRESULT hr;

    *pszPath = 0;

    // can only cache for the current user, hToken == NULL or per machine folders
    if (!hToken || (pfi->hKey != HKEY_CURRENT_USER))
    {
        _UpdateShellFolderCache();

        LPTSTR pszCache = (LPTSTR)InterlockedExchangePointer((void **)&g_aFolderCache[pfi->id].psz, (void *)-1);
        if ((pszCache == (LPTSTR)-1) || (pszCache == NULL))
        {
            // either not cached or cached failed state
            if ((pszCache == (LPTSTR)-1) || (uFlags & (CSIDL_FLAG_CREATE | CSIDL_FLAG_DONT_VERIFY)))
            {
                hr = _GetFolderPath(hwnd, pfi, hToken, uFlags, pszPath);

                // only set the cache value if CSIDL_FLAG_DONT_VERIFY was NOT passed
                if (!(uFlags & CSIDL_FLAG_DONT_VERIFY))
                {
                    if (hr == S_OK)
                    {
                        // dupe the string so we can add it to the cache
                        pszCache = StrDup(pszPath);
                    }
                    else
                    {
                        // we failed to get the folder path, null out the cache
                        ASSERT(*pszPath == 0);
                        pszCache = NULL;
                    }
                    _SetPathCache(pfi, pszCache);
                }
            }
            else
            {
                // cache was null and user didnt pass create flag so we just fail
                ASSERT(pszCache == NULL);
                ASSERT(*pszPath == 0);
                hr = E_FAIL;
            }
        }
        else
        {
            // cache hit case: copy the cached string and then restore the cached value back
            lstrcpyn(pszPath, pszCache, MAX_PATH);
            _SetPathCache(pfi, pszCache);
            hr = S_OK;
        }
    }
    else
    {
        hr = _GetFolderPath(hwnd, pfi, hToken, uFlags, pszPath);
    }

    return hr;
}

// NOTE: possibly we need a csidlSkip param to avoid recursion?
BOOL _ReparentAliases(HWND hwnd, HANDLE hToken, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlAlias, DWORD dwXlateAliases)
{
    static const struct {DWORD dwXlate; int idPath; int idAlias; BOOL fCommon;} s_rgidAliases[]= 
    {
        { XLATEALIAS_MYDOCS, CSIDL_PERSONAL | CSIDL_FLAG_NO_ALIAS, CSIDL_PERSONAL, FALSE},
        { XLATEALIAS_COMMONDOCS, CSIDL_COMMON_DOCUMENTS | CSIDL_FLAG_NO_ALIAS, CSIDL_COMMON_DOCUMENTS, FALSE},
        { XLATEALIAS_DESKTOP, CSIDL_DESKTOPDIRECTORY, CSIDL_DESKTOP, FALSE},
        { XLATEALIAS_DESKTOP, CSIDL_COMMON_DESKTOPDIRECTORY, CSIDL_DESKTOP, TRUE},
    };
    BOOL fContinue = TRUE;
    *ppidlAlias = NULL;
    
    for (int i = 0; fContinue && i < ARRAYSIZE(s_rgidAliases); i++)
    {
        LPITEMIDLIST pidlPath;
        if ((dwXlateAliases & s_rgidAliases[i].dwXlate) && 
            (S_OK == SHGetFolderLocation(hwnd, s_rgidAliases[i].idPath, hToken, 0, &pidlPath)))
        {
            LPCITEMIDLIST pidlChild = ILFindChild(pidlPath, pidl);
            if (pidlChild)
            {
                //  ok we need to use the alias instead of the path
                LPITEMIDLIST pidlAlias;
                if (S_OK == SHGetFolderLocation(hwnd, s_rgidAliases[i].idAlias, hToken, 0, &pidlAlias))
                {
                    if (SUCCEEDED(SHILCombine(pidlAlias, pidlChild, ppidlAlias)))
                    {
                        if (s_rgidAliases[i].fCommon && !ILIsEmpty(*ppidlAlias))
                        {
                            // find the size of the special part (subtacting for null pidl terminator)
                            UINT cbSize = ILGetSize(pidlAlias) - sizeof(pidlAlias->mkid.cb);
                            LPITEMIDLIST pidlChildFirst = _ILSkip(*ppidlAlias, cbSize);

                            // We set the first ID under the common path to have the SHID_FS_COMMONITEM so that when we bind we
                            // can hand this to the proper merged psf
                            pidlChildFirst->mkid.abID[0] |= SHID_FS_COMMONITEM;
                        }
                        ILFree(pidlAlias);
                    }
                    fContinue = FALSE;
                }
            }
            ILFree(pidlPath);
        }
    }

    return (*ppidlAlias != NULL);
}

STDAPI SHILAliasTranslate(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlAlias, DWORD dwXlateAliases)
{
    return _ReparentAliases(NULL, NULL, pidl, ppidlAlias, dwXlateAliases) ? S_OK : E_FAIL;
}
    
HRESULT _CreateFolderIDList(HWND hwnd, const FOLDER_INFO *pfi, HANDLE hToken, UINT uFlags, LPITEMIDLIST *ppidl)
{
    HRESULT hr = S_OK;

    *ppidl = NULL;      // assume failure or empty

    if (pfi->id == CSIDL_PRINTERS && (ACF_STAROFFICE5PRINTER & SHGetAppCompatFlags(ACF_STAROFFICE5PRINTER)))
    {
        // Star Office 5.0 relies on the fact that the printer pidl used to be like below.  They skip the 
        // first simple pidl (My Computer) and do not check if there is anything else, they assume that the
        // second simple pidl is the Printer folder one. (stephstm, 07/30/99)

        // CLSID_MyComputer, CLSID_Printers
        hr = ILCreateFromPathEx(TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{2227A280-3AEA-1069-A2DE-08002B30309D}"), NULL, ILCFP_FLAG_NO_MAP_ALIAS, ppidl, NULL);
    }
    else if (pfi->id == CSIDL_COMPUTERSNEARME)
    {
        if (IsOS(OS_DOMAINMEMBER))
        {
            // only if you are in a workgroup - fail otherwise
            hr = E_FAIL;
        }
        else
        {
            // we computer this IDLIST from the domain/workgroup you are a member of
            hr = SHGetDomainWorkgroupIDList(ppidl);
        }
    }
    else if ((pfi->id == CSIDL_COMMON_DOCUMENTS) 
         && !(uFlags & CSIDL_FLAG_NO_ALIAS))
    {
        // CLSID_MyComputer \ SharedDocumnets (canonical name)
        hr = ILCreateFromPathEx(TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{59031a47-3f72-44a7-89c5-5595fe6b30ee},SharedDocuments"), NULL, ILCFP_FLAG_NO_MAP_ALIAS, ppidl, NULL);
    }
    else if ((pfi->dwFlags & SDIF_CONST_IDLIST)
         && (!(uFlags & CSIDL_FLAG_NO_ALIAS) || !(pfi->dwFlags & SDIF_MAYBE_ALIASED)))
    {
        // these are CONST, never change
        hr = SHILClone(g_aFolderCache[pfi->id].pidl, ppidl);     
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        hr = _GetFolderPathCached(hwnd, pfi, hToken, uFlags, szPath);
        if (hr == S_OK)
        {
            HRESULT hrInit = SHCoInitialize();
            hr = ILCreateFromPathEx(szPath, NULL, ILCFP_FLAG_SKIPJUNCTIONS, ppidl, NULL);

            // attempt to reparent aliased pidls.
            if (SUCCEEDED(hr) 
            && (pfi->dwFlags & SDIF_MAYBE_ALIASED) 
            && !(uFlags & CSIDL_FLAG_NO_ALIAS))
            {
                LPITEMIDLIST pidlAlias;
                if (_ReparentAliases(hwnd, hToken, *ppidl, &pidlAlias, XLATEALIAS_ALL))
                {
                    ILFree(*ppidl);
                    *ppidl = pidlAlias;
                }
            }
            
            SHCoUninitialize(hrInit);
        }
    }
                   
    return hr;
}

void _SetIDListCache(const FOLDER_INFO *pfi, LPCITEMIDLIST pidl, BOOL fNonAlias)
{
    if (fNonAlias || !(pfi->dwFlags & SDIF_CONST_IDLIST))
    {
        void **ppv = (void **) (fNonAlias ? &g_aFolderCache[pfi->id].pidlNonAlias : &g_aFolderCache[pfi->id].pidl);
        LPITEMIDLIST pidlOld = (LPITEMIDLIST)InterlockedExchangePointer(ppv, (void *)pidl);
        if (pidlOld && pidlOld != (LPITEMIDLIST)-1)
        {
            // check for the concurent use... very rare case
            // ASSERT(pidl == (LPCITEMIDLIST)-1);   // should not really be ASSERT
            ILFree(pidlOld);
        }
    }
}

LPITEMIDLIST _GetIDListCache(const FOLDER_INFO *pfi, BOOL fNonAlias)
{
    void **ppv = (void **) (fNonAlias ? &g_aFolderCache[pfi->id].pidlNonAlias : &g_aFolderCache[pfi->id].pidl);
    ASSERT(fNonAlias || !(pfi->dwFlags & SDIF_CONST_IDLIST));
    return (LPITEMIDLIST)InterlockedExchangePointer(ppv, (void *)-1);
}

// hold this lock for the minimal amout of time possible to avoid other users
// of this resource requring them to re-create the pidl

HRESULT _GetFolderIDListCached(HWND hwnd, const FOLDER_INFO *pfi, UINT uFlags, LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    BOOL fNonAlias = uFlags & CSIDL_FLAG_NO_ALIAS;

    ASSERT(pfi->id < ARRAYSIZE(g_aFolderCache));

    if ((pfi->dwFlags & SDIF_CONST_IDLIST) && 
        (!fNonAlias || !(pfi->dwFlags & SDIF_MAYBE_ALIASED)))
    {
        // these are CONST, never change
        hr = SHILClone(g_aFolderCache[pfi->id].pidl, ppidl);     
    }
    else
    {
        LPITEMIDLIST pidlCache;

        _UpdateShellFolderCache();
        pidlCache = _GetIDListCache(pfi, fNonAlias);

        if ((pidlCache == (LPCITEMIDLIST)-1) || (pidlCache == NULL))
        {
            // either uninitalized cache state OR cached failure (NULL)
            if ((pidlCache == (LPCITEMIDLIST)-1) || (uFlags & CSIDL_FLAG_CREATE))
            {
                // not initialized (or concurent use) try creating it for this use
                hr = _CreateFolderIDList(hwnd, pfi, NULL, uFlags, ppidl);
                if (S_OK == hr)
                    hr = SHILClone(*ppidl, &pidlCache); // create cache copy
                else
                    pidlCache = NULL;
            }
            else
                hr = E_FAIL;            // return cached failure
        }
        else
        {
            hr = SHILClone(pidlCache, ppidl);   // cache hit
        }

        // store back the PIDL if it is non NULL or they specified CREATE
        // and we failed to create it (cache the not existant state). this is needed
        // so we don't cache a NULL if the first callers don't ask for create and
        // subsequent callers do
        if (pidlCache || (uFlags & CSIDL_FLAG_CREATE))
            _SetIDListCache(pfi, pidlCache, fNonAlias);
    }

    return hr;
}

void _ClearCacheEntry(const FOLDER_INFO *pfi)
{
    if (!(pfi->dwFlags & SDIF_CONST_IDLIST))
        _SetIDListCache(pfi, (LPCITEMIDLIST)-1, FALSE);

    if (pfi->dwFlags & SDIF_MAYBE_ALIASED)
        _SetIDListCache(pfi, (LPCITEMIDLIST)-1, TRUE);
        
    _SetPathCache(pfi, (LPCTSTR)-1);
}

void _ClearAllCacheEntrys()
{
    for (const FOLDER_INFO *pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        _ClearCacheEntry(pfi);
    }
}

void _ClearAllAliasCacheEntrys()
{
    for (const FOLDER_INFO *pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        if (pfi->dwFlags & SDIF_MAYBE_ALIASED)
        {
            _SetIDListCache(pfi, (LPCITEMIDLIST)-1, FALSE); // nuke the aliased pidl
        }
    }
}

// Per instance count of mods to Special Folder cache.
EXTERN_C HANDLE g_hCounter;
HANDLE g_hCounter = NULL;   // Global count of mods to Special Folder cache.
int g_lPerProcessCount = 0;

// Make sure the special folder cache is up to date.
void _UpdateShellFolderCache(void)
{
    HANDLE hCounter = SHGetCachedGlobalCounter(&g_hCounter, &GUID_SystemPidlChange);

    // Is the cache up to date?
    long lGlobalCount = SHGlobalCounterGetValue(hCounter);
    if (lGlobalCount != g_lPerProcessCount)
    {
        _ClearAllCacheEntrys();
        g_lPerProcessCount = lGlobalCount;
    }
}

STDAPI_(void) SHFlushSFCache(void)
{
    // Increment the shared variable;  the per-process versions will no
    // longer match, causing this and/or other processes to refresh their
    // pidl caches when they next need to access a folder.
    if (g_hCounter)
        SHGlobalCounterIncrement(g_hCounter);
}

// use SHGetFolderLocation() instead using CSIDL_FLAG_CREATE

STDAPI_(LPITEMIDLIST) SHCloneSpecialIDList(HWND hwnd, int csidl, BOOL fCreate)
{
    LPITEMIDLIST pidlReturn;

    if (fCreate)
        csidl |= CSIDL_FLAG_CREATE;

    SHGetSpecialFolderLocation(hwnd, csidl, &pidlReturn);
    return pidlReturn;
}

STDAPI SHGetSpecialFolderLocation(HWND hwnd, int csidl, LPITEMIDLIST *ppidl)
{
    HRESULT hr = SHGetFolderLocation(hwnd, csidl, NULL, 0, ppidl);
    if (hr == S_FALSE)
        hr = E_FAIL;        // mail empty case into failure for compat with this API
    return hr;
}

// return IDLIST for special folder
//      fCreate encoded in csidl with CSIDL_FLAG_CREATE (new for NT5)
//
//  in:
//      hwnd    should be NULL
//      csidl   CSIDL_ value with CSIDL_FLAG_ values ORed in as well
//      dwType  must be SHGFP_TYPE_CURRENT
//
//  out:
//      *ppild  NULL on failure or empty, PIDL to be freed by caller on success
//
//  returns:
//      S_OK        *ppidl is non NULL
//      S_FALISE    *ppidl is NULL, but valid csidl was passed (folder does not exist)
//      FAILED(hr)

STDAPI SHGetFolderLocation(HWND hwnd, int csidl, HANDLE hToken, DWORD dwType, LPITEMIDLIST *ppidl)
{
    const FOLDER_INFO *pfi;
    HRESULT hr;

    *ppidl = NULL;  // in case of error or empty

    // -1 is an invalid csidl
    if ((dwType != SHGFP_TYPE_CURRENT) || (-1 == csidl))
        return E_INVALIDARG;    // no flags used yet, validate this param

    pfi = _GetFolderInfo(csidl & ~CSIDL_FLAG_MASK);
    if (pfi)
    {
        HANDLE hTokenToFree = NULL;

        if ((hToken == NULL) && (pfi->hKey == HKEY_CURRENT_USER))
        {
            if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken))
                hTokenToFree = hToken;
        }
        if (hToken && (pfi->hKey == HKEY_CURRENT_USER))
        {
            // we don't cache PIDLs for other users, do all of the work
            hr = _CreateFolderIDList(hwnd, pfi, hToken, csidl & CSIDL_FLAG_MASK, (LPITEMIDLIST *)ppidl);
        }
        else
        {
            hr = _GetFolderIDListCached(hwnd, pfi, csidl & CSIDL_FLAG_MASK, ppidl);
        }

        if (hTokenToFree)
            CloseHandle(hTokenToFree);
    }
    else
        hr = E_INVALIDARG;    // bad CSIDL (apps can check to veryify our support)
    return hr;
}

STDAPI_(BOOL) SHGetSpecialFolderPath(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate)
{
    if (fCreate)
        csidl |= CSIDL_FLAG_CREATE;
    return SHGetFolderPath(hwnd, csidl, NULL, 0, pszPath) == S_OK;
}

//  in:
//      hwnd    should be NULL
//      csidl   CSIDL_ value with CSIDL_FLAG_ values ORed in as well
//      dwType  must be SHGFP_TYPE_CURRENT
//
//  out:
//      *pszPath    MAX_PATH buffer to get path name, zeroed on failure or empty case
//
//  returns:
//      S_OK        filled in pszPath with path value
//      S_FALSE     pszPath is NULL, valid CSIDL value, but this folder does not exist
//      E_FAIL

STDAPI SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwType, LPWSTR pszPath)
{
    HRESULT hr = E_INVALIDARG;
    const FOLDER_INFO *pfi;

    ASSERT(IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH));
    *pszPath = 0;

    pfi = _GetFolderInfo(csidl & ~CSIDL_FLAG_MASK);
    if (pfi && !(pfi->dwFlags & SDIF_NOT_FILESYS))
    {
        switch (dwType)
        {
        case SHGFP_TYPE_DEFAULT:
            ASSERT((csidl & CSIDL_FLAG_MASK) == 0); // meaningless for default
            hr = _GetFolderDefaultPath(pfi, hToken, pszPath);
            break;
    
        case SHGFP_TYPE_CURRENT:
            {
                HANDLE hTokenToFree = NULL;
                if ((hToken == NULL) && (pfi->hKey == HKEY_CURRENT_USER))
                {
                    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken))
                        hTokenToFree = hToken;
                }
                hr = _GetFolderPathCached(hwnd, pfi, hToken, csidl & CSIDL_FLAG_MASK, pszPath);

                if (hTokenToFree)
                    CloseHandle(hTokenToFree);
            }
            break;
        }
    }
    return hr;
}

STDAPI SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwType, LPSTR pszPath)
{
    WCHAR wsz[MAX_PATH];
    HRESULT hr = SHGetFolderPath(hwnd, csidl, hToken, dwType, wsz);

    ASSERT(IS_VALID_WRITE_BUFFER(pszPath, CHAR, MAX_PATH));

    SHUnicodeToAnsi(wsz, pszPath, MAX_PATH);
    return hr;
}

STDAPI_(BOOL) SHGetSpecialFolderPathA(HWND hwnd, LPSTR pszPath, int csidl, BOOL fCreate)
{
    if (fCreate)
        csidl |= CSIDL_FLAG_CREATE;
    return SHGetFolderPathA(hwnd, csidl, NULL, 0, pszPath) == S_OK;
}

//  Similar to SHGetFolderPath, but appends an optional subdirectory path after
//  the csidl folder path. Handles creating the subdirectories.

STDAPI SHGetFolderPathAndSubDir(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPCWSTR pszSubDir, LPWSTR pszPath)
{
    HRESULT hr = SHGetFolderPath(hwnd, csidl, hToken, dwFlags, pszPath);

    if (S_OK == hr && pszSubDir && *pszSubDir)
    {
        if (!PathAppend(pszPath, pszSubDir))
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
        }
        else if (csidl & CSIDL_FLAG_CREATE)
        {
            int err = SHCreateDirectoryEx(NULL, pszPath, NULL);

            if (ERROR_ALREADY_EXISTS == err)
            {
                err = ERROR_SUCCESS;
            }
            hr = HRESULT_FROM_WIN32(err);
        }
        else if (!(csidl & CSIDL_FLAG_DONT_VERIFY))
        {
            DWORD dwAttributes;

            if (PathFileExistsAndAttributes(pszPath, &dwAttributes))
            {
                if ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
            }
        }

        if (S_OK != hr)
        {
            *pszPath = 0;
        }
    }

    return hr;
}

STDAPI SHGetFolderPathAndSubDirA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPCSTR pszSubDir, LPSTR pszPath)
{
    WCHAR wsz[MAX_PATH];
    WCHAR wszSubDir[MAX_PATH];

    SHAnsiToUnicode(pszSubDir, wszSubDir, MAX_PATH);

    HRESULT hr = SHGetFolderPathAndSubDir(hwnd, csidl, hToken, dwFlags, wszSubDir, wsz);

    ASSERT(IS_VALID_WRITE_BUFFER(pszPath, CHAR, MAX_PATH));

    SHUnicodeToAnsi(wsz, pszPath, MAX_PATH);
    return hr;
}

//  HRESULT SHSetFolderPath (int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath)
//
//  in:
//      csidl       CSIDL_ value with CSIDL_FLAG_ values ORed in as well
//      dwFlags     reserved: should be 0x00000000
//      pszPath     path to change shell folder to (will optionally be unexpanded)
//
//  returns:
//      S_OK        function succeeded and flushed cache

STDAPI SHSetFolderPath(int csidl, HANDLE hToken, DWORD dwFlags, LPCTSTR pszPath)
{
    HRESULT hr = E_INVALIDARG;

    // Validate csidl and dwFlags. Add extra valid flags as needed.

    RIPMSG(((csidl & CSIDL_FLAG_MASK) & ~(CSIDL_FLAG_DONT_UNEXPAND | 0x00000000)) == 0, "SHSetFolderPath: CSIDL flag(s) invalid");
    RIPMSG(dwFlags == 0, "SHSetFolderPath: dwFlags parameter must be 0x00000000");

    // Exit with E_INVALIDARG if bad parameters.

    if ((((csidl & CSIDL_FLAG_MASK) & ~(CSIDL_FLAG_DONT_UNEXPAND | 0x00000000)) != 0) ||
        (dwFlags != 0) ||
        (pszPath == NULL) ||
        (pszPath[0] == 0))
    {
        return hr;
    }

    const FOLDER_INFO *pfi = _GetFolderInfo(csidl & ~CSIDL_FLAG_MASK);

    // Only allow setting for SDIF_NOT_FILESYS is clear
    //                        SDIF_NOT_TRACKED is clear
    //                        SDIF_CANT_MOVE_RENAME is clear
    // and for non-NULL value

    // If HKLM is used then rely on security or registry restrictions
    // to enforce whether the change can be made.

    if ((pfi != NULL) &&
        ((pfi->dwFlags & (SDIF_NOT_FILESYS | SDIF_NOT_TRACKED | SDIF_CANT_MOVE_RENAME)) == 0))
    {
        BOOL    fSuccessfulUnexpand, fSuccessfulExpand, fEmptyOrNullPath;
        LONG    lError;
        HANDLE  hTokenToFree;
        TCHAR   szPath[MAX_PATH];
        TCHAR   szExpandedPath[MAX_PATH];   // holds expanded path for "Shell Folder" compat key
        LPCTSTR pszWritePath;

        hTokenToFree = NULL;
        if ((hToken == NULL) && (pfi->hKey == HKEY_CURRENT_USER))
        {
            if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken))
            {
                hTokenToFree = hToken;
            }
        }

        fEmptyOrNullPath = ((pszPath == NULL) || (pszPath[0] == 0));
        if (fEmptyOrNullPath)
        {
            HKEY    hKeyDefaultUser;

            pszWritePath = NULL;
            if (SUCCEEDED(_OpenKeyForFolder(pfi, (HANDLE)-1, TEXT("User Shell Folders"), &hKeyDefaultUser)))
            {
                DWORD dwPathSize = sizeof(szPath);
                if (ERROR_SUCCESS == RegQueryValueEx(hKeyDefaultUser, pfi->pszValueName,
                                                     NULL, NULL, (LPBYTE)szPath, &dwPathSize))
                {
                    pszWritePath = szPath;
                }
                RegCloseKey(hKeyDefaultUser);
            }
            fSuccessfulUnexpand = TRUE;
        }
        else if (csidl & CSIDL_FLAG_DONT_UNEXPAND)
        {
            // Does the caller want to write the string as is? Leave
            // it alone if so.

            pszWritePath = pszPath;
            fSuccessfulUnexpand = TRUE;
        }
        else
        {
            if (pfi->hKey == HKEY_CURRENT_USER)
            {
                fSuccessfulUnexpand = (PathUnExpandEnvStringsForUser(hToken, pszPath, szPath, ARRAYSIZE(szPath)) != FALSE);
            }
            else
            {
                fSuccessfulUnexpand = FALSE;
            }

            // Choose the appropriate source if the unexpansion was successful or not.
            // Either way the unexpansion failure should be ignored.

            if (fSuccessfulUnexpand)
            {
                pszWritePath = szPath;
            }
            else
            {
                fSuccessfulUnexpand = TRUE;
                pszWritePath = pszPath;
            }
        }

        if (fSuccessfulUnexpand)
        {
            HKEY    hKeyUser, hKeyUSF, hKeyToFree;

            // we also get the fully expanded path so that we can write it out to the "Shell Folders" key for apps that depend on
            // the old registry values
            fSuccessfulExpand = (SHExpandEnvironmentStringsForUser(hToken, pszPath, szExpandedPath, ARRAYSIZE(szExpandedPath)) != 0);

            // Get either the current users HKCU or HKU\SID if a token
            // was specified and running in NT.

            if (hToken && GetUserProfileKey(hToken, &hKeyUser))
            {
                hKeyToFree = hKeyUser;
            }
            else
            {
                hKeyUser = pfi->hKey;
                hKeyToFree = NULL;
            }

            // Open the key to the User Shell Folders and write the string
            // there. Clear the shell folder cache.

            // NOTE: This functionality is duplicated in SetFolderPath but
            // that function deals with the USF key only. This function
            // requires HKU\SID so while there is identical functionality
            // from the point of view of settings the USF value that is
            // where it ends. To make this function simple it just writes
            // the value to registry itself.

            // Additional note: there is a threading issue here with
            // clearing the cache entry incrementing the counter. This
            // should be locked access.

            lError = RegOpenKeyEx(hKeyUser, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"),
                                  0, KEY_READ | KEY_WRITE, &hKeyUSF);
            if (lError == ERROR_SUCCESS)
            {
                if (pszWritePath)
                {
                    lError = RegSetValueEx(hKeyUSF, pfi->pszValueName, 0, REG_EXPAND_SZ,
                                           (LPBYTE)pszWritePath, (lstrlen(pszWritePath) + sizeof('\0')) * sizeof(TCHAR));
                }
                else
                {
                    lError = RegDeleteValue(hKeyUSF, pfi->pszValueName);
                }
                RegCloseKey(hKeyUSF);

                // nuke the cache state for this folder
                _ClearCacheEntry(pfi);

                // and all folders that might be aliased as those
                // could be related to this folder (under MyDocs for example)
                // and now their aliases forms my no longer be valid
                _ClearAllAliasCacheEntrys();

                g_lPerProcessCount = SHGlobalCounterIncrement(g_hCounter);
            }

            // update the old "Shell Folders" value for compat
            if ((lError == ERROR_SUCCESS) && fSuccessfulExpand)
            {
                HKEY hkeySF;

                if (RegOpenKeyEx(hKeyUser, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
                                 0, KEY_READ | KEY_WRITE, &hkeySF) == ERROR_SUCCESS)
                {
                    if (pszWritePath)
                    {
                        RegSetValueEx(hkeySF, pfi->pszValueName, 0, REG_SZ,
                                      (LPBYTE)szExpandedPath, (lstrlen(szExpandedPath) + sizeof('\0')) * sizeof(TCHAR));
                    }
                    else
                    {
                        RegDeleteValue(hkeySF, pfi->pszValueName);
                    }

                    RegCloseKey(hkeySF);
                }
            }

            if ((lError == ERROR_SUCCESS) && (pfi->hKey == HKEY_CURRENT_USER))
            {
                switch (csidl & ~CSIDL_FLAG_MASK)
                {
                case CSIDL_APPDATA:
                    {
                        HKEY    hKeyVolatileEnvironment;

                        // In the case of AppData there is a matching environment variable
                        // for this shell folder. Make sure the place in the registry where
                        // userenv.dll places this value is updated and correct so that when
                        // the user context is created by winlogon it will have the updated
                        // value.

                        // It's probably also a good thing to check for a %APPDATA% variable
                        // in the calling process' context but this would only be good for
                        // the life of the process. What is really required is a mechanism
                        // to change the environment variable for the entire logon session.

                        lError = RegOpenKeyEx(hKeyUser, TEXT("Volatile Environment"), 0,
                                              KEY_READ | KEY_WRITE, &hKeyVolatileEnvironment);
                        if (lError == ERROR_SUCCESS)
                        {
                            if (SUCCEEDED(SHGetFolderPath(NULL, csidl | CSIDL_FLAG_DONT_VERIFY,
                                                          hToken, SHGFP_TYPE_CURRENT, szPath)))
                            {
                                lError = RegSetValueEx(hKeyVolatileEnvironment, TEXT("APPDATA"),
                                                       0, REG_SZ, (LPBYTE)szPath, (lstrlen(szPath) + sizeof('\0')) * sizeof(TCHAR));
                            }
                            RegCloseKey(hKeyVolatileEnvironment);
                        }
                        break;
                    }
                }
            }

            if (hKeyToFree)
            {
                RegCloseKey(hKeyToFree);
            }

            if (lError == ERROR_SUCCESS)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lError);
            }
        }
        if (hTokenToFree)
        {
            CloseHandle(hTokenToFree);
        }

        SHChangeDWORDAsIDList dwidl = { sizeof(dwidl) - sizeof(dwidl.cbZero), SHCNEE_UPDATEFOLDERLOCATION, csidl & ~CSIDL_FLAG_MASK, 0};
        SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_ONLYNOTIFYINTERNALS | SHCNF_IDLIST, (LPCITEMIDLIST)&dwidl, NULL);
    }

    return hr;
}

STDAPI SHSetFolderPathA(int csidl, HANDLE hToken, DWORD dwType, LPCSTR pszPath)
{
    WCHAR wsz[MAX_PATH];

    SHAnsiToUnicode(pszPath, wsz, ARRAYSIZE(wsz));
    return SHSetFolderPath(csidl, hToken, dwType, wsz);
}

// NOTE: called from DllEntry

void SpecialFolderIDTerminate()
{
    ASSERTDLLENTRY      // does not require a critical section

    _ClearAllCacheEntrys();

    if (g_hCounter)
    {
        CloseHandle(g_hCounter);
        g_hCounter = NULL;
    }
}

// update our cache and the registry for pfi with pszPath. this also invalidates the
// cache in other processes so they stay in sync

void SetFolderPath(const FOLDER_INFO *pfi, LPCTSTR pszPath)
{
    _ClearCacheEntry(pfi);
    
    if (pszPath)
    {
        HKEY hk;
        if (SUCCEEDED(_OpenKeyForFolder(pfi, NULL, TEXT("User Shell Folders"), &hk)))
        {
            LONG err;
            TCHAR szDefaultPath[MAX_PATH];
            
            // Check for an existing path, and if the unexpanded version
            // of the existing path does not match the new path, then
            // write the new path to the registry.
            //
            // RegQueryPath expands the environment variables for us
            // so we can't just blindly set the new value to the registry.
            //
            
            RegQueryPath(hk, pfi->pszValueName, szDefaultPath);
            
            if (lstrcmpi(szDefaultPath, pszPath) != 0)
            {
                // The paths are different. Write to the registry as file
                // system path.

                err = SHRegSetPath(hk, NULL, pfi->pszValueName, pszPath, 0);
            } 
            else
            {
                err = ERROR_SUCCESS;
            }
            
            // clear out any temp paths
            RegSetFolderPath(pfi, TEXT("User Shell Folders\\New"), NULL);
            
            if (err == ERROR_SUCCESS)
            {
                // this will force a new creation (see TRUE as fCreate).
                // This will also copy the path from "User Shell Folders"
                // to "Shell Folders".
                LPITEMIDLIST pidl;
                if (S_OK == _GetFolderIDListCached(NULL, pfi, CSIDL_FLAG_CREATE, &pidl))
                {
                    ILFree(pidl);
                }
                else
                {
                    // failed!  null out the entry.  this will go back to our default
                    RegDeleteValue(hk, pfi->pszValueName);
                    _ClearCacheEntry(pfi);
                }
            }
            RegCloseKey(hk);
        }
    }
    else
    {
        RegSetFolderPath(pfi, TEXT("User Shell Folders"), NULL);
        // clear out any temp paths
        RegSetFolderPath(pfi, TEXT("User Shell Folders\\New"), NULL);
    }
    
    // set the global different from the per process variable
    // to signal an update needs to happen other processes
    g_lPerProcessCount = SHGlobalCounterIncrement(g_hCounter);
}


// file system change notifies come in here AFTER the folders have been moved/deleted
// we fix up the registry to match what occured in the file system
EXTERN_C void SFP_FSEvent(LONG lEvent, LPITEMIDLIST pidl, LPITEMIDLIST pidlExtra)
{
    const FOLDER_INFO *pfi;
    TCHAR szSrc[MAX_PATH];

    if (!(lEvent & (SHCNE_RENAMEFOLDER | SHCNE_RMDIR | SHCNE_MKDIR)) ||
        !SHGetPathFromIDList(pidl, szSrc)                            ||
        (pidlExtra && ILIsEqual(pidl, pidlExtra)))  // when volume label changes, pidl==pidlExtra so we detect this case and skip it for perf
    {
        return;
    }

    for (pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        if (0 == (pfi->dwFlags & (SDIF_NOT_TRACKED | SDIF_NOT_FILESYS)))
        {
            TCHAR szCurrent[MAX_PATH];
            if (S_OK == _GetFolderPathCached(NULL, pfi, NULL, CSIDL_FLAG_DONT_VERIFY, szCurrent) &&
                PathIsEqualOrSubFolder(szSrc, szCurrent))
            {
                TCHAR szDest[MAX_PATH];

                szDest[0] = 0;

                if (lEvent & SHCNE_RMDIR)
                {
                    // complete the "move accross volume" case
                    HKEY hk;
                    if (SUCCEEDED(_OpenKeyForFolder(pfi, NULL, TEXT("User Shell Folders\\New"), &hk)))
                    {
                        RegQueryPath(hk, pfi->pszValueName, szDest);
                        RegCloseKey(hk);
                    }
                }
                else if (pidlExtra)
                {
                    SHGetPathFromIDList(pidlExtra, szDest);
                }

                if (szDest[0])
                {
                    // rename the specal folder
                    UINT cch = PathCommonPrefix(szCurrent, szSrc, NULL);
                    ASSERT(cch != 0);
                    
                    if (szCurrent[cch])
                    {
                        PathAppend(szDest, szCurrent + cch);
                    }

                    SetFolderPath(pfi, szDest);
                }
            }
        }
    }
}

ULONG _ILGetChildOffset(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild)
{
    DWORD cbOff = 0;
    LPCITEMIDLIST pidlChildT = ILFindChild(pidlParent, pidlChild);
    if (pidlChildT)
    {
        cbOff = (ULONG)((LPBYTE)pidlChildT - (LPBYTE)pidlChild);
    }
    return cbOff;
}

// returns the first special folder CSIDL_ id that is a parent
// of the passed in pidl or 0 if not found. only CSIDL_ entries marked as
// SDIF_SHORTCUT_RELATIVE are considered for this.
//
// returns:
//      CSIDL_ values
//      *pcbOffset  offset into pidl

STDAPI_(int) GetSpecialFolderParentIDAndOffset(LPCITEMIDLIST pidl, ULONG *pcbOffset)
{
    int iRet = 0;  //  everything is desktop relative
    const FOLDER_INFO *pfi;

    *pcbOffset = 0;

    for (pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        if (pfi->dwFlags & SDIF_SHORTCUT_RELATIVE)
        {
            LPITEMIDLIST pidlFolder;
            if (S_OK == _GetFolderIDListCached(NULL, pfi, 0, &pidlFolder))
            {
                ULONG cbOff = _ILGetChildOffset(pidlFolder, pidl);
                if (cbOff > *pcbOffset)
                {
                    *pcbOffset = cbOff;
                    iRet = pfi->id;
                }
                ILFree(pidlFolder);
            }
        }
    }
    return iRet;
}

// note, only works for file system path (bummer, we would like others supported too)

STDAPI_(BOOL) MakeShellURLFromPath(LPCTSTR pszPathIn, LPTSTR pszUrl, DWORD dwCch)
{
    const FOLDER_INFO *pfi;

    for (pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        if ((pfi->dwFlags & SDIF_SHORTCUT_RELATIVE) &&
            !(pfi->dwFlags & SDIF_NOT_FILESYS))
        {
            TCHAR szCurrent[MAX_PATH];
            if (S_OK == _GetFolderPathCached(NULL, pfi, 0, CSIDL_FLAG_DONT_VERIFY, szCurrent))
            {
                if (PathIsPrefix(szCurrent, pszPathIn))
                {
                    StrCpy(pszUrl, TEXT("shell:"));
                    StrCat(pszUrl, pfi->pszValueName);
                    PathAppend(pszUrl, &pszPathIn[lstrlen(szCurrent)]);

                    return TRUE;
                }
            }
        }
    }
    return FALSE;
}

STDAPI_(BOOL) MakeShellURLFromPathA(LPCSTR pszPathIn, LPSTR pszUrl, DWORD dwCch)
{
    WCHAR szTmp1[MAX_PATH], szTmp2[MAX_PATH];
    SHAnsiToUnicode(pszPathIn, szTmp1, ARRAYSIZE(szTmp1));

    BOOL bRet = MakeShellURLFromPathW(szTmp1, szTmp2, ARRAYSIZE(szTmp2));

    SHUnicodeToAnsi(szTmp2, pszUrl, dwCch);
    return bRet;
}

BOOL MoveBlockedByPolicy(const FOLDER_INFO *pfi)
{
    BOOL bRet = FALSE;
    if (pfi->dwFlags & SDIF_POLICY_NO_MOVE)
    {
        // similar to code in mydocs.dll 
        TCHAR szValue[128];
        wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("Disable%sDirChange"), pfi->pszValueName);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER,
                                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"),
                                            szValue, NULL, NULL, NULL))
        {
            bRet = TRUE;
        }
    }
    return bRet;
}

// this is called from the copy engine (like all other copy hooks)
// this is where we put up UI blocking the delete/move of some special folders
EXTERN_C int PathCopyHookCallback(HWND hwnd, UINT wFunc, LPCTSTR pszSrc, LPCTSTR pszDest)
{
    int ret = IDYES;

    if ((wFunc == FO_DELETE) || (wFunc == FO_MOVE) || (wFunc == FO_RENAME))
    {
        const FOLDER_INFO *pfi;

        // is one of our system directories being affected?

        for (pfi = c_rgFolderInfo; ret == IDYES && pfi->id != -1; pfi++)
        {
            // even non tracked folders (windows, system) come through here
            if (0 == (pfi->dwFlags & SDIF_NOT_FILESYS))
            {
                TCHAR szCurrent[MAX_PATH];
                if (S_OK == _GetFolderPathCached(NULL, pfi, NULL, CSIDL_FLAG_DONT_VERIFY, szCurrent) &&
                    PathIsEqualOrSubFolder(pszSrc, szCurrent))
                {
                    // Yes
                    if (wFunc == FO_DELETE)
                    {
                        if (pfi->dwFlags & SDIF_CAN_DELETE)
                        {
                            SetFolderPath(pfi, NULL);  // Let them delete some folders
                        }
                        else
                        {
                            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_CANTDELETESPECIALDIR),
                                            MAKEINTRESOURCE(IDS_DELETE), MB_OK | MB_ICONINFORMATION, PathFindFileName(pszSrc));
                            ret = IDNO;
                        }
                    }
                    else
                    {
                        int idSrc = PathGetDriveNumber(pszSrc);
                        int idDest = PathGetDriveNumber(pszDest);

                        ASSERT((wFunc == FO_MOVE) || (wFunc == FO_RENAME));

                        if ((pfi->dwFlags & SDIF_CANT_MOVE_RENAME) || 
                            ((idSrc != -1) && (idDest == -1) && !(pfi->dwFlags & SDIF_NETWORKABLE)) ||
                            ((idSrc != idDest) && PathIsRemovable(pszDest) && !(pfi->dwFlags & SDIF_REMOVABLE)) ||
                            MoveBlockedByPolicy(pfi))
                        {
                            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_CANTMOVESPECIALDIRHERE),
                                wFunc == FO_MOVE ? MAKEINTRESOURCE(IDS_MOVE) : MAKEINTRESOURCE(IDS_RENAME), 
                                MB_ICONERROR, PathFindFileName(pszSrc));
                            ret = IDNO;
                        }
                        else
                        {
                            //
                            //  store this info here
                            //  if we need it we will use it.
                            //
                            //  we used to try to optimise in the case of same
                            //  volume renames.  we assumed that if it was the same
                            //  volume we would later get a SHCNE_RENAME.  but sometimes
                            //  we have to do a copy even on the same volume.  so
                            //  we need to always set this value.
                            //
                            RegSetFolderPath(pfi, TEXT("User Shell Folders\\New"), pszDest);
                        }
                    }
                }
            }
        }
    }
    return ret;
}

// Given a key name ("programs", "desktop", "start menu"), convert it to
// the corresponding CSIDL.

STDAPI_(int) SHGetSpecialFolderID(LPCWSTR pszName)
{
    // make sure g_aFolderCache can be indexed by the CSIDL values

    COMPILETIME_ASSERT((ARRAYSIZE(g_aFolderCache) - 1) == CSIDL_COMPUTERSNEARME);

    for (int i = 0; c_rgFolderInfo[i].id != -1; i++)
    {
        if (c_rgFolderInfo[i].pszValueName && 
            (0 == StrCmpI(pszName, c_rgFolderInfo[i].pszValueName)))
        {
            return c_rgFolderInfo[i].id;
        }
    }

    return -1;
}

// Given a CSIDL, returns the key name -- the opposite of
// SHGetSpecialFolderID

STDAPI_(LPCTSTR) SHGetSpecialFolderKey(int csidl)
{
    const FOLDER_INFO *pfi = _GetFolderInfo(csidl);
    return pfi ? pfi->pszValueName : NULL;
}


// Return the special folder ID, if this folder is one of them.
// At this point, we handle PROGRAMS folder only.

//
//  GetSpecialFolderID() 
//  this allows a list of CSIDLs to be passed in.
//  they will be searched in order for the specified csidl
//  and the path will be checked against it.
//  if -1 is specified as the csidl, then all of array entries should
//  be checked for a match with the folder.
//
int GetSpecialFolderID(LPCTSTR pszFolder, const int *rgcsidl, UINT count)
{
    for (UINT i = 0; i < count; i++)
    {
        int csidlSpecial = rgcsidl[i] & ~TEST_SUBFOLDER;
        TCHAR szPath[MAX_PATH];
        if (S_OK == SHGetFolderPath(NULL, csidlSpecial | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath))
        {
            if (((rgcsidl[i] & TEST_SUBFOLDER) && PathIsEqualOrSubFolder(szPath, pszFolder)) ||
                (lstrcmpi(szPath, pszFolder) == 0))
            {
                return csidlSpecial;
            }
        }
    }

    return -1;
}



/**
 *  Tacks a name onto a CSIDL, e.g. gets a pidl for
 *  CSIDL_COMMON_PICTURES\Sample Pictures
 *  if it exists.
 *  Called must free ppidlSampleMedia
 *  Note: The folder is *not* created if it does not exist.
 */
HRESULT _AppendPathToPIDL(int nAllUsersMediaFolder, LPCWSTR pszName, LPITEMIDLIST *ppidlSampleMedia)
{
    LPITEMIDLIST pidlAllUsersMedia;
    HRESULT hr = SHGetFolderLocation(NULL, nAllUsersMediaFolder, NULL, 0, &pidlAllUsersMedia);

    if (SUCCEEDED(hr))
    {
        // Get the shellfolder for this guy.
        IShellFolder *psf;
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlAllUsersMedia, &psf));
        if (SUCCEEDED(hr))
        {
            // And now the pidl for the sample folder
            LPITEMIDLIST pidlSampleMediaRel;
            ULONG dwAttributes = 0;
            hr = psf->ParseDisplayName(NULL, NULL, (LPOLESTR)pszName, NULL, &pidlSampleMediaRel, &dwAttributes);
            if (SUCCEEDED(hr))
            {
                // It exists!
                hr = SHILCombine(pidlAllUsersMedia, pidlSampleMediaRel, ppidlSampleMedia);
                ILFree(pidlSampleMediaRel);
            }
            psf->Release();
        }
        ILFree(pidlAllUsersMedia);
    }

    return hr;
}


/**
 * Returns a pidl to the samples folder under a particular CSIDL
 * Caller must free ppidlSampleMedia
 */
HRESULT _ParseSubfolderResource(int csidl, UINT ids, LPITEMIDLIST *ppidl)
{
    WCHAR szSub[MAX_PATH];
    LoadDefaultString(ids, szSub, ARRAYSIZE(szSub));

    return _AppendPathToPIDL(csidl, szSub, ppidl);
}

HRESULT SHGetSampleMediaFolder(int nAllUsersMediaFolder, LPITEMIDLIST *ppidlSampleMedia)
{
    UINT uID = -1;
    switch (nAllUsersMediaFolder)
    {
    case CSIDL_COMMON_PICTURES:
        uID = IDS_SAMPLEPICTURES;
        break;
    case CSIDL_COMMON_MUSIC:
        uID = IDS_SAMPLEMUSIC;
        break;
    default:
        ASSERT(FALSE);
        return E_INVALIDARG;
        break;
    }
    return _ParseSubfolderResource(nAllUsersMediaFolder, uID, ppidlSampleMedia);
}

void _CreateLinkToSampleMedia(LPCWSTR pszNewFolderPath, int nAllUsersMediaFolder, UINT uIDSampleFolderName)
{
    LPITEMIDLIST pidl;
    if (SUCCEEDED(SHGetSampleMediaFolder(nAllUsersMediaFolder, &pidl)))
    {
        // Check to make sure the link doesn't already exist.
        WCHAR szSampleFolderName[MAX_PATH];
        WCHAR szFullLnkPath[MAX_PATH];
        LoadString(HINST_THISDLL, uIDSampleFolderName, szSampleFolderName, ARRAYSIZE(szSampleFolderName));
        StrCatBuff(szSampleFolderName, L".lnk", ARRAYSIZE(szSampleFolderName));
        if (PathCombine(szFullLnkPath, pszNewFolderPath, szSampleFolderName))
        {
            if (!PathFileExists(szFullLnkPath))
            {
                //  MUI-WARNING - we are not doing a SHSetLocalizedName for this link - ZekeL - 15-MAY-2001
                //  this means that this link is always created in the default system UI language
                //  we should probably call SHSetLocalizedName() here but i am scared right now of perf implications.
                CreateLinkToPidl(pidl, pszNewFolderPath, NULL, 0);
            }
        }

        ILFree(pidl);
    }
}


void _InitFolder(LPCTSTR pszPath, UINT idsInfoTip, HINSTANCE hinstIcon, UINT idiIcon)
{
    // Set the default custom settings for the folder.
    SHFOLDERCUSTOMSETTINGS fcs = {sizeof(fcs), 0};
    TCHAR szInfoTip[128];
    TCHAR szPath[MAX_PATH];

    // Get the infotip for this folder
    if (idsInfoTip)
    {
        wnsprintf(szInfoTip,ARRAYSIZE(szInfoTip),TEXT("@Shell32.dll,-%u"),idsInfoTip);
        fcs.pszInfoTip = szInfoTip;
        fcs.cchInfoTip = ARRAYSIZE(szInfoTip);

        fcs.dwMask |= FCSM_INFOTIP;
    }

    // this will be encoded to the %SystemRoot% style path when setting the folder information.
    if (idiIcon)
    {
        GetModuleFileName(hinstIcon, szPath, ARRAYSIZE(szPath));

        fcs.pszIconFile = szPath;
        fcs.cchIconFile = ARRAYSIZE(szPath);
        fcs.iIconIndex = idiIcon;

        fcs.dwMask |= FCSM_ICONFILE;
    }

    // NOTE: we need FCS_FORCEWRITE because we didn't used to specify iIconIndex
    // and so "0" was written to the ini file.  When we upgrade, this API won't
    // fix the ini file unless we pass FCS_FORCEWRITE
    SHGetSetFolderCustomSettings(&fcs, pszPath, FCS_FORCEWRITE);
}

void _InitMyPictures(int id, LPCTSTR pszPath)
{
    // Get the path to the icon.   We reference MyDocs.dll for backwards compat.
    HINSTANCE hinstMyDocs = LoadLibrary(TEXT("mydocs.dll"));
    if (hinstMyDocs)
    {
        _InitFolder(pszPath, IDS_FOLDER_MYPICS_TT, hinstMyDocs, -101); // known index for IDI_MYPICS in mydocs.dll
        FreeLibrary(hinstMyDocs);
    }
}

void _InitMyMusic(int id, LPCTSTR pszPath)
{
    _InitFolder(pszPath, IDS_FOLDER_MYMUSIC_TT, HINST_THISDLL, -IDI_MYMUSIC);
}

void _InitPerUserMyPictures(int id, LPCTSTR pszPath)
{
    _InitMyPictures(id, pszPath);

    _CreateLinkToSampleMedia(pszPath, CSIDL_COMMON_PICTURES, IDS_SAMPLEPICTURES);
}

void _InitPerUserMyMusic(int id, LPCTSTR pszPath)
{
    _InitMyMusic(id, pszPath);

    _CreateLinkToSampleMedia(pszPath, CSIDL_COMMON_MUSIC, IDS_SAMPLEMUSIC);
}


void _InitMyVideos(int id, LPCTSTR pszPath)
{
    _InitFolder(pszPath, IDS_FOLDER_MYVIDEOS_TT, HINST_THISDLL, -IDI_MYVIDEOS);
}

void _InitRecentDocs(int id, LPCTSTR pszPath)
{
    _InitFolder(pszPath, IDS_FOLDER_RECENTDOCS_TT, HINST_THISDLL, -IDI_STDOCS); 
}

void _InitFavorites(int id, LPCTSTR pszPath)
{
    _InitFolder(pszPath, 0, HINST_THISDLL, -IDI_FAVORITES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\foldertip.cpp ===
#include "shellprv.h"
#include "ids.h"

class CFolderInfoTip : public IQueryInfo, public ICustomizeInfoTip, public IParentAndItem, public IShellTreeWalkerCallBack
{
public:
    CFolderInfoTip(IUnknown *punk, LPCTSTR pszFolder);
    
    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IQueryInfo methods.
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR** ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);

    // ICustomizeInfoTip
    STDMETHODIMP SetPrefixText(LPCWSTR pszPrefix);
    STDMETHODIMP SetExtraProperties(const SHCOLUMNID *pscid, UINT cscid);

    // IParentAndItem
    STDMETHODIMP SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf,  LPCITEMIDLIST pidlChild);
    STDMETHODIMP GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidlChild);

    // IShellTreeWalkerCallBack methods
    STDMETHODIMP FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP LeaveFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws);
    STDMETHODIMP HandleError(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, HRESULT hrError);

private:
    ~CFolderInfoTip();

    HRESULT _GetTreeWalkerData(TREEWALKERSTATS *ptws);
    HRESULT _BufferInsert(LPWSTR pszBuffer, int *puBufferUsed, int uBufferMaxSize, LPCWSTR pwszPath, int cBufferItems);
    HRESULT _WalkTree(LPWSTR pszTip, DWORD cchSize);
    HRESULT _BuildSizeBlurb(HRESULT hr, LPWSTR pszSizeBlurb, DWORD cchSize);
    HRESULT _BuildFolderBlurb(HRESULT hr, LPWSTR pszFolderBlurb, DWORD cchSize);
    HRESULT _BuildFileBlurb(HRESULT hr, LPWSTR pszSizeBlurb, DWORD cchSize);

    LONG _cRef;                             // Reference Counter
    LPWSTR _pszFolderName;                  // File name of the target folder
    IQueryInfo *_pqiOuter;                  // Outer info tip for folders (say, for comments)

    ULONGLONG _ulTotalSize;                 // Total size of encountered files
    UINT _nSubFolders;                      // Total number of subfolders of target
    UINT _nFiles;                           // Total number of subfiles of target folder
    DWORD _dwSearchStartTime;               // Time when search started

    WCHAR _szFileList[60];                  // List of files in target folder
    int _nFileListCharsUsed;                // Number of characters used in buffer

    WCHAR _szFolderList[60];                // List of subfolders of target
    int _nFolderListCharsUsed;              // Number of chars used in folder buffer
};


// Constructor and Destructor do nothing more than set everything to
// 0 and ping the dll
CFolderInfoTip::CFolderInfoTip(IUnknown *punkOutter, LPCTSTR pszFolder) : _cRef(1)
{   
    // Init everything to 0
    _pszFolderName = StrDup(pszFolder);
    _szFileList[0] = 0;
    _nFileListCharsUsed = 0;
    _szFolderList[0] = 0;
    _nFolderListCharsUsed = 0;
    _ulTotalSize = 0;
    _nSubFolders = 0;
    _nFiles = 0;

    punkOutter->QueryInterface(IID_PPV_ARG(IQueryInfo, &_pqiOuter));

    DllAddRef();
}

CFolderInfoTip::~CFolderInfoTip()
{
    LocalFree(_pszFolderName);
    if (_pqiOuter)
        _pqiOuter->Release();
    DllRelease();
}

HRESULT CFolderInfoTip::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFolderInfoTip, IQueryInfo),
        QITABENT(CFolderInfoTip, ICustomizeInfoTip),
        QITABENT(CFolderInfoTip, IParentAndItem),
        QITABENT(CFolderInfoTip, IShellTreeWalkerCallBack),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CFolderInfoTip::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFolderInfoTip::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// IQueryInfo functions
STDMETHODIMP CFolderInfoTip::GetInfoFlags(DWORD *pdwFlags)
{
    *pdwFlags = 0;
    return S_OK;
}

//
// Wrapper for FormatMessage.  Is this duplicated somewhere else?
DWORD _FormatMessageArg(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageID, DWORD dwLangID, LPWSTR pszBuffer, DWORD cchSize, ...)
{
    va_list vaParamList;

    va_start(vaParamList, cchSize);
    DWORD dwResult = FormatMessage(dwFlags, lpSource, dwMessageID, dwLangID, pszBuffer, cchSize, &vaParamList);
    va_end(vaParamList);

    return dwResult;
}

// This runs a TreeWalker that gets the info about files and file
// sizes, etc. and then takes those date and stuffs them into a infotip

STDMETHODIMP CFolderInfoTip::GetInfoTip(DWORD dwFlags, LPWSTR *ppwszTip)
{
    HRESULT hr = S_OK;
    *ppwszTip = NULL;

    if (_pszFolderName)
    {
        TCHAR szTip[INFOTIPSIZE]; // The info tip I build w/ folder contents
        szTip[0] = 0;

        // If we are to search, then search!
        if ((dwFlags & QITIPF_USESLOWTIP) &&
            SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("FolderContentsInfoTip"), 0, TRUE))
        {
            _WalkTree(szTip, ARRAYSIZE(szTip));
        }
        
        // Now that we've built or skipped our tip, get the outer tip's info.
        if (_pqiOuter)
        {
            if (szTip[0])
            {     
                LPWSTR pszOuterTip = NULL;
                _pqiOuter->GetInfoTip(dwFlags, &pszOuterTip);
                
                // Allocate and build the return tip, ommitting the outer tip if
                // it's  null, and putting a \n between them
                // if they both aren't.
                int cch = lstrlen(szTip) + (pszOuterTip ? lstrlen(pszOuterTip) + 1 : 0) + 1;
                
                *ppwszTip = (LPWSTR)CoTaskMemAlloc(cch * sizeof(szTip[0]));
                if (*ppwszTip)
                {
                    **ppwszTip = 0; // zero init string

                    if (pszOuterTip)
                    {
                        if (*pszOuterTip)
                        {
                            // outer tip first
                            StrCpyN(*ppwszTip, pszOuterTip, cch);
                            StrCatBuff(*ppwszTip, L"\n", cch);
                        }
                        SHFree(pszOuterTip);
                    }
                    StrCatBuff(*ppwszTip, szTip, cch);
                }
            }
            else
            {
                hr = _pqiOuter->GetInfoTip(dwFlags, ppwszTip);
            }
        }
    }
   
    return hr;
}

STDMETHODIMP CFolderInfoTip::SetPrefixText(LPCWSTR pszPrefix)
{
    ICustomizeInfoTip *pcit;
    if (_pqiOuter && SUCCEEDED(_pqiOuter->QueryInterface(IID_PPV_ARG(ICustomizeInfoTip, &pcit))))
    {
        pcit->SetPrefixText(pszPrefix);
        pcit->Release();
    }
    return S_OK;
}

STDMETHODIMP CFolderInfoTip::SetExtraProperties(const SHCOLUMNID *pscid, UINT cscid)
{
    ICustomizeInfoTip *pcit;
    if (_pqiOuter && SUCCEEDED(_pqiOuter->QueryInterface(IID_PPV_ARG(ICustomizeInfoTip, &pcit))))
    {
        pcit->SetExtraProperties(pscid, cscid);
        pcit->Release();
    }
    return S_OK;
}

// IParentAndItem

STDMETHODIMP CFolderInfoTip::SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    IParentAndItem *ppai;
    if (_pqiOuter && SUCCEEDED(_pqiOuter->QueryInterface(IID_PPV_ARG(IParentAndItem, &ppai))))
    {
        ppai->SetParentAndItem(pidlParent, psf, pidl);
        ppai->Release();
    }
    return S_OK;
}

STDMETHODIMP CFolderInfoTip::GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidl)
{
    IParentAndItem *ppai;
    if (_pqiOuter && SUCCEEDED(_pqiOuter->QueryInterface(IID_PPV_ARG(IParentAndItem, &ppai))))
    {
        ppai->GetParentAndItem(ppidlParent, ppsf, ppidl);
        ppai->Release();
    }
    return S_OK;
}


// Helper functions for GetInfoTip    
HRESULT CFolderInfoTip::_WalkTree(LPWSTR pszTip, DWORD cchSize)
{
    // Get a CShellTreeWalker object to run the search for us.
    IShellTreeWalker *pstw;
    HRESULT hr = ::CoCreateInstance(CLSID_CShellTreeWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellTreeWalker, &pstw));
    if (SUCCEEDED(hr)) 
    {
        TCHAR szFolderBlurb[128], szFileBlurb[128], szSizeBlurb[128];
        
        // Remember when we started so we know when to stop
        _dwSearchStartTime = GetTickCount();
        
        // Now, if hrTreeWalk is an error, it's not really an error; it just means
        // that the search was cut off early, so we don't bother to check 
        // it.  hrTreeWalk is passed to _BuildSizeBlurb so that it know whether or not
        // to add "greater than" to the string.
        HRESULT hrTreeWalk = pstw->WalkTree(WT_EXCLUDEWALKROOT | WT_NOTIFYFOLDERENTER,
            _pszFolderName, L"*.*", 32, SAFECAST(this, IShellTreeWalkerCallBack *));    
        
        // Create substrings for size, files, folders (may be empty if there's 
        // nothing to show)
        _BuildSizeBlurb(hrTreeWalk, szSizeBlurb, ARRAYSIZE(szSizeBlurb));
        _BuildFileBlurb(hrTreeWalk, szFileBlurb, ARRAYSIZE(szFileBlurb));
        _BuildFolderBlurb(hrTreeWalk, szFolderBlurb, ARRAYSIZE(szFolderBlurb));
        
        // Build our local tip
        TCHAR szFormatStr[64];
        LoadString(HINST_THISDLL, IDS_FIT_TipFormat, szFormatStr, ARRAYSIZE(szFormatStr));
        _FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, szFormatStr, 0, 0, pszTip, 
            cchSize, szSizeBlurb, szFolderBlurb, szFileBlurb);
        
        pstw->Release();
    }
    return hr;
}

HRESULT CFolderInfoTip::_BuildSizeBlurb(HRESULT hr, LPWSTR pszBlurb, DWORD cchSize)
{
    if (_ulTotalSize || (_nFiles || _nSubFolders)) 
    { 
        WCHAR szSizeString[20];  
        WCHAR szFormatStr[64];
        StrFormatByteSize(_ulTotalSize, szSizeString, ARRAYSIZE(szSizeString));
        
        if (SUCCEEDED(hr))
        {
            LoadString(HINST_THISDLL, IDS_FIT_Size, szFormatStr, ARRAYSIZE(szFormatStr));
        }
        else
        {
            LoadString(HINST_THISDLL, IDS_FIT_Size_LT, szFormatStr, ARRAYSIZE(szFormatStr));
        }

        _FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, szFormatStr, 0, 0, pszBlurb, cchSize, szSizeString);
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_FIT_Size_Empty, pszBlurb, cchSize);
    }
    
    return S_OK;
}            

HRESULT CFolderInfoTip::_BuildFileBlurb(HRESULT hr, LPWSTR pszBlurb, DWORD cchSize)
{
    if (_nFiles && _nFileListCharsUsed)
    {
        WCHAR szFormatStr[64];

        LoadString(HINST_THISDLL, IDS_FIT_Files, szFormatStr, ARRAYSIZE(szFormatStr));
        _FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, szFormatStr, 0, 0, pszBlurb, cchSize, _szFileList);
    }
    else 
    {
        _FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, L"", 0, 0, pszBlurb, cchSize);
    }
    
    return S_OK;
}

HRESULT CFolderInfoTip::_BuildFolderBlurb(HRESULT hr, LPWSTR pszBlurb, DWORD cchSize)
{
    if (_nSubFolders)
    {
        WCHAR szFormatStr[64];

        LoadString(HINST_THISDLL, IDS_FIT_Folders, szFormatStr, ARRAYSIZE(szFormatStr));
        _FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, szFormatStr, 0, 0, pszBlurb, cchSize, _szFolderList);
    }
    else 
    {
        _FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, L"", 0, 0, pszBlurb, cchSize);
    }
    
    return S_OK;
}

//
// A helper func that copies strings into a fixed size buffer,
// taking care of delimeters and everything.  Used by EnterFolder
// and FoundFile to build the file and folder lists.
HRESULT CFolderInfoTip::_BufferInsert(LPWSTR pszBuffer, int *pnBufferUsed,
                                      int nBufferMaxSize, LPCWSTR pszPath, int nBufferItems)
{
    TCHAR szDelimeter[100], szExtraItems[100];

    LoadString(HINST_THISDLL, IDS_FIT_Delimeter, szDelimeter, ARRAYSIZE(szDelimeter));
    LoadString(HINST_THISDLL, IDS_FIT_ExtraItems, szExtraItems, ARRAYSIZE(szExtraItems));

    // Check to see if the buffer is full, if not, proceed.
    if (*pnBufferUsed != nBufferMaxSize)
    {        
        // Holds the file name form the abs. path
        // Grab the file name
        LPWSTR pszFile = PathFindFileName(pszPath);
        if (pszFile)
        {
            // Calculates if the item will fit, remembering to leave room
            // not noly for the delimeter, but for for the extra item marker
            // that might be added in the future. 
            if (*pnBufferUsed + lstrlen(pszFile) + lstrlen(szDelimeter) * 2 + lstrlen(szExtraItems) + 1 < 
                nBufferMaxSize)
            {
                // Add the delimeter if this is not the 1st item
                if (nBufferItems > 1)
                {
                    StrCpyN(&(pszBuffer[*pnBufferUsed]), 
                        szDelimeter, (nBufferMaxSize - *pnBufferUsed));
                    *pnBufferUsed += lstrlen(szDelimeter);
                }
         
                // Add the item to the buffer
                StrCpyN(&(pszBuffer[*pnBufferUsed]), pszFile, (nBufferMaxSize - *pnBufferUsed));
                *pnBufferUsed += lstrlen(pszFile);
            }
            else 
            {
                // In this case, the item won't fit, so just add the extra
                // items marker and set the buffer to be full
                if (nBufferItems > 1)
                {
                    StrCpyN(&(pszBuffer[*pnBufferUsed]), szDelimeter, (nBufferMaxSize - *pnBufferUsed));
                    *pnBufferUsed += lstrlen(szDelimeter);
                }

                StrCpyN(&(pszBuffer[*pnBufferUsed]), szExtraItems, (nBufferMaxSize - *pnBufferUsed));
                *pnBufferUsed = nBufferMaxSize;
            }
        }
    }

    return S_OK;
}


// IShellTreeWalkerCallBack functions
//
// The TreeWalker calls these whenever it finds a file, etc.  We grab
// the data out of the passed TREEWALKERSTATS *and use it to build the
// tip.  We also take the filenames that are passed to FoundFile  and to
// to EnterFolder to build the file and folder listings
STDMETHODIMP CFolderInfoTip::FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    if (ptws->nDepth == 0)
    {
        if (!(pwfd->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
            _BufferInsert(_szFileList, &_nFileListCharsUsed, ARRAYSIZE(_szFileList), pwszPath, ptws->nFiles);
    }

    return _GetTreeWalkerData(ptws);
}

STDMETHODIMP CFolderInfoTip::EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    if (ptws->nDepth == 0) 
    {
        if (!(pwfd->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
            _BufferInsert(_szFolderList, &_nFolderListCharsUsed, ARRAYSIZE(_szFolderList), pwszPath, ptws->nFolders);
    }
    
    return _GetTreeWalkerData(ptws);
}

STDMETHODIMP CFolderInfoTip::LeaveFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws) 
{
    return _GetTreeWalkerData(ptws);
}

STDMETHODIMP CFolderInfoTip::HandleError(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, HRESULT hrError)
{
    // TODO: look for HRESULT_FROM_WIN32(ACCESS_DENIED) for folders we can't look into.
    return _GetTreeWalkerData(ptws);
}

// copies data from the treewalker callback into
// class vars so that they can be used to build the InfoTip.  This also cuts
// off the search if too much time has elapsed.
HRESULT CFolderInfoTip::_GetTreeWalkerData(TREEWALKERSTATS *ptws) 
{
    HRESULT hr = S_OK;
    
    _ulTotalSize = ptws->ulTotalSize;
    _nSubFolders = ptws->nFolders;
    _nFiles = ptws->nFiles;
    
    if ((GetTickCount() - _dwSearchStartTime) > 3000)   // 3 seconds
    {
        hr = E_UNEXPECTED;
    } 
    
    return hr;
}

STDAPI CFolderInfoTip_CreateInstance(IUnknown *punkOuter, LPCTSTR pszFolder, REFIID riid, void **ppv)
{
    HRESULT hr;
    CFolderInfoTip *pdocp = new CFolderInfoTip(punkOuter, pszFolder);
    if (pdocp)
    {
        hr = pdocp->QueryInterface(riid, ppv);
        pdocp->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\foldertypes.h ===
#ifndef __FOLDERTYPES_H__
#define __FOLDERTYPES_H__


// used in folder customization and sniffing

#define PROPSTR_FOLDERTYPE          L"FolderType"

#define STR_TYPE_DOCUMENTS          L"Documents"
#define STR_TYPE_MYDOCUMENTS        L"MyDocuments"
#define STR_TYPE_PICTURES           L"Pictures"
#define STR_TYPE_MYPICTURES         L"MyPictures"
#define STR_TYPE_PHOTOALBUM         L"PhotoAlbum"
#define STR_TYPE_MUSIC              L"Music"
#define STR_TYPE_MYMUSIC            L"MyMusic"
#define STR_TYPE_MUSICARTIST        L"MusicArtist"
#define STR_TYPE_MUSICALBUM         L"MusicAlbum"
#define STR_TYPE_VIDEOS             L"Videos"
#define STR_TYPE_MYVIDEOS           L"MyVideos"
#define STR_TYPE_VIDEOALBUM         L"VideoAlbum"
#define STR_TYPE_BOOKS              L"Books"
#define STR_TYPE_USELEGACYHTT       L"UseLegacyHTT"
#define STR_TYPE_COMMONDOCUMENTS    L"CommonDocuments"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\folderviewhost.cpp ===
#include "shellprv.h"
#include "cowsite.h"
#pragma hdrstop


// this is the comdlg frame that we will use to host the file picker object, it mostly is
// a stub that will forward accordingly
//
// the lifetime of this is handled by the DefView object we are attached to, which when
// the parent (CFolderViewHost) is destroyed will be taken down.

class CViewHostBrowser : public IShellBrowser, ICommDlgBrowser2, IServiceProvider
{
public:
    CViewHostBrowser(HWND hwndParent, IShellView *psvWeak, IUnknown *punkSiteWeak);
    ~CViewHostBrowser();
 
    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)(THIS);
    STDMETHOD_(ULONG,Release)(THIS);

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow)(HWND *lphwnd)
        { *lphwnd = _hwndParent; return S_OK; }
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode)
        { return S_OK; }

    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    STDMETHOD(InsertMenusSB)(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
        { return E_NOTIMPL; }
    STDMETHOD(SetMenuSB)(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
        { return S_OK; }
    STDMETHOD(RemoveMenusSB)(HMENU hmenuShared)
        { return E_NOTIMPL; }
    STDMETHOD(SetStatusTextSB)(LPCOLESTR lpszStatusText)
        { return S_OK; }
    STDMETHOD(EnableModelessSB)(BOOL fEnable)
        { return S_OK; }
    STDMETHOD(TranslateAcceleratorSB)(LPMSG lpmsg, WORD wID)
        { return S_FALSE; }

    // *** IShellBrowser methods ***
    STDMETHOD(BrowseObject)(LPCITEMIDLIST pidl, UINT wFlags)
        { return E_FAIL; }
    STDMETHOD(GetViewStateStream)(DWORD grfMode, LPSTREAM *pStrm)
        { return E_FAIL; }
    STDMETHOD(GetControlWindow)(UINT id, HWND *lphwnd)
        { return E_NOTIMPL; }
    STDMETHOD(SendControlMsg)(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHOD(QueryActiveShellView)(IShellView **ppshv);
    STDMETHOD(OnViewWindowActive)(IShellView *pshv)
        { return S_OK; }
    STDMETHOD(SetToolbarItems)(LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags)
        { return S_OK; }

    // *** ICommDlgBrowser methods ***
    STDMETHOD(OnDefaultCommand)(IShellView *ppshv)
        { return S_OK; }
    STDMETHOD(OnStateChange)(IShellView *ppshv, ULONG uChange);
    STDMETHOD(IncludeObject)(IShellView *ppshv, LPCITEMIDLIST lpItem);

    // *** ICommDlgBrowser2 methods ***
    STDMETHOD(Notify)(IShellView *ppshv, DWORD dwNotifyType)
        { return S_FALSE; }
    STDMETHOD(GetDefaultMenuText)(IShellView *ppshv, WCHAR *pszText, INT cchMax)
        { return S_FALSE; }
    STDMETHOD(GetViewFlags)(DWORD *pdwFlags)
        { *pdwFlags = 0; return S_OK; }

private:
    long _cRef;    
    HWND _hwndParent;

    IShellView *_psvWeak;
    IUnknown *_punkSiteWeak; // not addref'd.

    friend class CFolderViewHost;
};

CViewHostBrowser::CViewHostBrowser(HWND hwndParent, IShellView *psvWeak, IUnknown *punkSiteWeak) :
    _cRef(1), _hwndParent(hwndParent), _psvWeak(psvWeak), _punkSiteWeak(punkSiteWeak)
{
    // _psvWeak->AddRef();    // we hold a weak refernece to our parent, therefore don't AddRef()
    // _punkSiteWeak->AddRef(); // we hold a weak reference to our parent, therefore don't AddRef()!
}

CViewHostBrowser::~CViewHostBrowser()
{
    // _psvWeak->Release(); // this is scoped on the lifetime of our parent
    // _punkSiteWeak->Release(); // we hold a weak reference to our parent, therefore don't Release()!
}

HRESULT CViewHostBrowser::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CViewHostBrowser, IShellBrowser),                           // IID_IShellBrowser
        QITABENT(CViewHostBrowser, ICommDlgBrowser2),                        // IID_ICommDlgBrowser2
        QITABENTMULTI(CViewHostBrowser, ICommDlgBrowser, ICommDlgBrowser2),  // IID_ICommDlgBrowser
        QITABENT(CViewHostBrowser, IServiceProvider),                        // IID_IServiceProvider
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CViewHostBrowser::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CViewHostBrowser::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


// IShellBrowser

HRESULT CViewHostBrowser::SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret)
{
    if (pret)
        *pret = 0L;
    return S_OK;
}

HRESULT CViewHostBrowser::QueryActiveShellView(IShellView **ppshv)
{
    HRESULT hr = E_NOINTERFACE;
    if (_psvWeak)
    {
        hr = _psvWeak->QueryInterface(IID_PPV_ARG(IShellView, ppshv));
    }
    return hr;
}


// ICommDlgBrowser - these are forwarded to our site object

HRESULT CViewHostBrowser::OnStateChange(IShellView *ppshv, ULONG uChange)
{
    HRESULT hr = S_OK;
    ICommDlgBrowser *pcdb;
    if (SUCCEEDED(IUnknown_QueryService(_punkSiteWeak, SID_SCommDlgBrowser, IID_PPV_ARG(ICommDlgBrowser, &pcdb))))
    {
        hr = pcdb->OnStateChange(ppshv, uChange);
        pcdb->Release();
    }
    return hr;
}

HRESULT CViewHostBrowser::IncludeObject(IShellView *ppshv, LPCITEMIDLIST lpItem)
{
    HRESULT hr = S_OK;
    ICommDlgBrowser *pcdb;
    if (SUCCEEDED(IUnknown_QueryService(_punkSiteWeak, SID_SCommDlgBrowser, IID_PPV_ARG(ICommDlgBrowser, &pcdb))))
    {
        hr = pcdb->IncludeObject(ppshv, lpItem);
        pcdb->Release();
    }
    return hr;
}


// IServiceProvider

HRESULT CViewHostBrowser::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_FAIL;
    *ppvObj = NULL;
    
    if (IsEqualGUID(guidService, SID_SCommDlgBrowser))
    {
        hr = this->QueryInterface(riid, ppvObj);
    }

    return hr;
}



// this is the file picker object it creates an IShellView (which for us should result in 
// a defview implement).   from this we can then give the window to the caller and they 
// can place on their dialog as needed.

class CFolderViewHost : public IFolderViewHost, IServiceProvider, IOleWindow, IFolderView, CObjectWithSite
{
public:
    CFolderViewHost();
    ~CFolderViewHost();

    // *** IFolderViewHost ***
    STDMETHODIMP Initialize(HWND hwndParent, IDataObject *pdo, RECT *prc);

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)(THIS);
    STDMETHOD_(ULONG,Release)(THIS);

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow)(HWND *lphwnd)
        { *lphwnd = _hwndView; return S_OK; }
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode)
        { return S_OK; }

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv)
        { return IUnknown_QueryService(_punkSite, guidService, riid, ppv); }

    // IFolderView
    STDMETHODIMP GetCurrentViewMode(UINT *pViewMode)
        { return _pfv->GetCurrentViewMode(pViewMode); }
    STDMETHODIMP SetCurrentViewMode(UINT ViewMode)
        { return _pfv->SetCurrentViewMode(ViewMode); }
    STDMETHODIMP GetFolder(REFIID ridd, void **ppv)
        { return _pfv->GetFolder(ridd, ppv); }
    STDMETHODIMP Item(int iItemIndex, LPITEMIDLIST *ppidl)
        { return _pfv->Item(iItemIndex, ppidl); }
    STDMETHODIMP ItemCount(UINT uFlags, int *pcItems)
        { return _pfv->ItemCount(uFlags, pcItems); }
    STDMETHODIMP Items(UINT uFlags, REFIID riid, void **ppv)
        { return _pfv->Items(uFlags, riid, ppv); }
    STDMETHODIMP GetSelectionMarkedItem(int *piItem)
        { return _pfv->GetSelectionMarkedItem(piItem); }
    STDMETHODIMP GetFocusedItem(int *piItem)
        { return _pfv->GetFocusedItem(piItem); }
    STDMETHODIMP GetItemPosition(LPCITEMIDLIST pidl, POINT* ppt)
        { return _pfv->GetItemPosition(pidl, ppt); }
    STDMETHODIMP GetSpacing(POINT* ppt)
        { return _pfv->GetSpacing(ppt); }
    STDMETHODIMP GetDefaultSpacing(POINT* ppt)
        { return _pfv->GetDefaultSpacing(ppt); }
    STDMETHODIMP GetAutoArrange()
        { return _pfv->GetAutoArrange(); }
    STDMETHODIMP SelectItem(int iItem, DWORD dwFlags)
        { return _pfv->SelectItem(iItem, dwFlags); }
    STDMETHODIMP SelectAndPositionItems(UINT cidl, LPCITEMIDLIST* apidl, POINT* apt, DWORD dwFlags)
        { return _pfv->SelectAndPositionItems(cidl, apidl, apt, dwFlags); }

private:
    long _cRef;
    IFolderView *_pfv;                      // IFolderView
    HWND _hwndView;
};


CFolderViewHost::CFolderViewHost() :
    _cRef(1)
{
}

CFolderViewHost::~CFolderViewHost()
{
    if (_pfv)
        _pfv->Release();
}

HRESULT CFolderViewHost::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CFolderViewHost, IFolderViewHost),           // IID_IFolderViewHost
        QITABENT(CFolderViewHost, IOleWindow),                // IID_IOleWindow
        QITABENT(CFolderViewHost, IFolderView),               // IID_IFolderView
        QITABENT(CFolderViewHost, IServiceProvider),          // IID_IServiceProvider
        QITABENT(CFolderViewHost, IObjectWithSite),           // IID_IObjectWithSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CFolderViewHost::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFolderViewHost::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


// the initialize method handles the creation of the view object from the.

HRESULT CFolderViewHost::Initialize(HWND hwndParent, IDataObject *pdo, RECT *prc)
{
    // first we perform a namespace walk, this will retrieve our selection from the view
    // using this we can then create the view object.

    INamespaceWalk *pnsw;
    HRESULT hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(INamespaceWalk, &pnsw));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST *aItems = NULL;
        UINT cItems = 0;

        hr = pnsw->Walk(pdo, NSWF_NONE_IMPLIES_ALL, 0, NULL);
        if (SUCCEEDED(hr))
        {
            IShellFolder *psf = NULL;

            hr = pnsw->GetIDArrayResult(&cItems, &aItems);
            if (S_OK == hr)
            {
                hr = SHBindToIDListParent(aItems[0], IID_PPV_ARG(IShellFolder, &psf), NULL);
            }
            else if (S_FALSE == hr)
            {
                hr = E_FAIL;                    // fail unless we perform the bind.

                STGMEDIUM medium;
                LPIDA pida = DataObj_GetHIDA(pdo, &medium);
                if (pida)
                {
                    if (pida->cidl == 1)
                    {
                        LPITEMIDLIST pidl = IDA_ILClone(pida, 0);
                        if (pidl)
                        {
                            hr = SHBindToObjectEx(NULL, pidl, NULL, IID_PPV_ARG(IShellFolder, &psf));
                            ILFree(pidl);
                        }
                    }
                    HIDA_ReleaseStgMedium(pida, &medium);
                }                
            }
            else
            {
                hr = E_FAIL;
            }

            if (SUCCEEDED(hr))
            {    
                IShellView *psv;
                hr = psf->CreateViewObject(hwndParent, IID_PPV_ARG(IShellView, &psv));
                if (SUCCEEDED(hr))
                {
                    CViewHostBrowser *pvhb = new CViewHostBrowser(hwndParent, psv, SAFECAST(this, IServiceProvider*));
                    if (pvhb)
                    {
                        hr = psv->QueryInterface(IID_PPV_ARG(IFolderView, &_pfv));
                        if (SUCCEEDED(hr))
                        {
                            FOLDERSETTINGS fs = {0};
                            fs.ViewMode = FVM_THUMBNAIL;
                            fs.fFlags = FWF_AUTOARRANGE|FWF_NOWEBVIEW|FWF_HIDEFILENAMES|FWF_CHECKSELECT;

                            IFolderView *pfv;
                            if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv))))
                            {
                                pfv->GetCurrentViewMode(&fs.ViewMode);
                                pfv->Release();
                            }

                            hr = psv->CreateViewWindow(NULL, &fs, pvhb, prc, &_hwndView);
                            if (SUCCEEDED(hr))
                            {
                                hr = psv->UIActivate(SVUIA_INPLACEACTIVATE);
                            }
                        }

                        pvhb->Release();
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    psv->Release();
                }

                for (int i = 0; SUCCEEDED(hr) && (i != cItems); i++)
                {
                    LPCITEMIDLIST pidlChild = ILFindLastID(aItems[i]);
                    hr = _pfv->SelectAndPositionItems(1, &pidlChild, NULL, SVSI_CHECK);
                }

                psf->Release();
            }

            FreeIDListArray(aItems, cItems);
        }

        pnsw->Release();
    }

    return hr;
}


STDAPI CFolderViewHost_CreateInstance(IUnknown *punkOut, REFIID riid, void **ppv)
{
    CFolderViewHost *pfp = new CFolderViewHost();
    if (!pfp)
        return E_OUTOFMEMORY;

    HRESULT hr = pfp->QueryInterface(riid, ppv);
    pfp->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\format.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "mtpt.h"
#include "hwcmmn.h"
#pragma  hdrstop

#include "apithk.h"

const static DWORD FmtaIds[] = 
{
    IDOK,               IDH_FORMATDLG_START,
    IDCANCEL,           IDH_CANCEL,
    IDC_CAPCOMBO,       IDH_FORMATDLG_CAPACITY,
    IDC_FSCOMBO,        IDH_FORMATDLG_FILESYS,
    IDC_ASCOMBO,        IDH_FORMATDLG_ALLOCSIZE,
    IDC_VLABEL,         IDH_FORMATDLG_LABEL,
    IDC_GROUPBOX_1,     IDH_COMM_GROUPBOX,
    IDC_QFCHECK,        IDH_FORMATDLG_QUICKFULL,
    IDC_ECCHECK,        IDH_FORMATDLG_COMPRESS,
    IDC_FMTPROGRESS,    IDH_FORMATDLG_PROGRESS,
    0,0
};

const static DWORD ChkaIds[] = 
{
    IDOK,               IDH_CHKDSKDLG_START,
    IDCANCEL,           IDH_CHKDSKDLG_CANCEL,
    IDC_GROUPBOX_1,     IDH_COMM_GROUPBOX,
    IDC_FIXERRORS,      IDH_CHKDSKDLG_FIXERRORS,
    IDC_RECOVERY,       IDH_CHKDSKDLG_SCAN,
    IDC_CHKDSKPROGRESS, IDH_CHKDSKDLG_PROGRESS,
    IDC_PHASE,          -1,
    0,0
};

// The following structure encapsulates our calling into the FMIFS.DLL
typedef struct
{
    HINSTANCE                 hFMIFS_DLL;
    PFMIFS_FORMATEX_ROUTINE   FormatEx;
    PFMIFS_QSUPMEDIA_ROUTINE  QuerySupportedMedia;
    PFMIFS_ENABLECOMP_ROUTINE EnableVolumeCompression;
    PFMIFS_CHKDSKEX_ROUTINE   ChkDskEx;
    PFMIFS_QUERY_DEVICE_INFO_ROUTINE    QueryDeviceInformation;
} FMIFS;

typedef
HRESULT
(*PDISKCOPY_MAKEBOOTDISK_ROUTINE)(
    IN  HINSTANCE hInstance, 
    IN  UINT iDrive, 
    IN  BOOL* pfCancelled, 
    IN  FMIFS_CALLBACK pCallback
    );

// The following structure encapsulates our calling into the DISKCOPY.DLL
typedef struct
{
    HINSTANCE                        hDISKCOPY_DLL;
    PDISKCOPY_MAKEBOOTDISK_ROUTINE   MakeBootDisk;
} DISKCOPY;

// This structure described the current formatting session
typedef struct
{
    LONG    cRef;                  // reference count on this structure
    UINT    drive;                 // 0-based index of drive to format
    UINT    fmtID;                 // Last format ID
    UINT    options;               // options passed to us via the API
    FMIFS   fmifs;                 // above
    DISKCOPY diskcopy;             // above
    HWND    hDlg;                  // handle to the format dialog
    BOOL    fIsFloppy;             // TRUE -> its a floppy
    BOOL    fIs35HDFloppy;         // TRUE -> its a standard 3.5" High Density floppy
    BOOL    fIsMemoryStick;        // TRUE -> its a memory stick (special formatting only)
    BOOL    fIsNTFSBlocked;        // TRUE -> its a NTFS not-supported device
    BOOL    fEnableComp;           // Last "Enable Comp" choice from user
    BOOL    fCancelled;            // User cancelled the last format
    BOOL    fShouldCancel;         // User has clicked cancel; pending abort
    BOOL    fWasFAT;               // Was it FAT originally?
    BOOL    fFinishedOK;           // Did format complete sucessfully?
    BOOL    fErrorAlready;         // Did we put up an error dialog already?
    BOOL    fDisabled;             // Is rgfControlEnabled[] valid?
    DWORD   dwClusterSize;         // Orig NT cluster size, or last choice
    WCHAR   wszVolName[MAX_PATH];  // Volume Label
    WCHAR   wszDriveName[4];       // Root path to drive (eg: A:\)
    HANDLE  hThread;               // Handle of format thread

    // Array of media types supported by the device
    // for NT5, we have an expanded list that includes japanese types.
    FMIFS_MEDIA_TYPE rgMedia[IDS_FMT_MEDIA_J22-IDS_FMT_MEDIA_J0];

    // Used to cache the enabled/disabled state of the dialog controls
    BOOL    rgfControlEnabled[DLG_FORMATDISK_NUMCONTROLS];

    // should we create a boot disk rather than a traditional format
    BOOL    fMakeBootDisk;

} FORMATINFO;

//
// An enumeration to make the filesystem combo-box code more readble
//

typedef enum tagFILESYSENUM
{
    e_FAT = 0,
    e_NTFS,
    e_FAT32
} FILESYSENUM;

#define FS_STR_NTFS  TEXT("NTFS")
#define FS_STR_FAT32 TEXT("FAT32")
#define FS_STR_FAT   TEXT("FAT")

//
// Private WM_USER messages we will use.  For some unknown reason, USER sends
// us a WM_USER during initialization, so I start my private messages at
// WM_USER + 0x0100
//

typedef enum tagPRIVMSGS
{
    PWM_FORMATDONE = WM_USER + 0x0100,
    PWM_CHKDSKDONE
} PRIVMSGS;

//
//  Synopsis:   Loads FMIFS.DLL and sets up the function entry points for
//              the member functions we are interested in.
//
HRESULT LoadFMIFS(FMIFS *pFMIFS)
{
    HRESULT hr = S_OK;

    //
    // Load the FMIFS DLL and query for the entry points we need
    //

    // SECURITY: what non-relative path do we use that will work on ia64 too?
    if (NULL == (pFMIFS->hFMIFS_DLL = LoadLibrary(TEXT("FMIFS.DLL"))))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (NULL == (pFMIFS->FormatEx = (PFMIFS_FORMATEX_ROUTINE)
                GetProcAddress(pFMIFS->hFMIFS_DLL, "FormatEx")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (NULL == (pFMIFS->QuerySupportedMedia = (PFMIFS_QSUPMEDIA_ROUTINE)
                GetProcAddress(pFMIFS->hFMIFS_DLL, "QuerySupportedMedia")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (NULL == (pFMIFS->EnableVolumeCompression = (PFMIFS_ENABLECOMP_ROUTINE)
                GetProcAddress(pFMIFS->hFMIFS_DLL, "EnableVolumeCompression")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (NULL == (pFMIFS->ChkDskEx = (PFMIFS_CHKDSKEX_ROUTINE)
                GetProcAddress(pFMIFS->hFMIFS_DLL, "ChkdskEx")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (NULL == (pFMIFS->QueryDeviceInformation = (PFMIFS_QUERY_DEVICE_INFO_ROUTINE)
                GetProcAddress(pFMIFS->hFMIFS_DLL, "QueryDeviceInformation")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // If anything failed, and we've got the DLL loaded, release the DLL
    //

    if (hr != S_OK && pFMIFS->hFMIFS_DLL)
    {
       FreeLibrary(pFMIFS->hFMIFS_DLL);
    }
    return hr;
}

//
//  Synopsis:   Loads DISKCOPY.DLL and sets up the function entry points for
//              the member functions we are interested in.
//
HRESULT LoadDISKCOPY(DISKCOPY *pDISKCOPY)
{
    HRESULT hr = S_OK;

    //
    // Load the DISKCOPY DLL and query for the entry points we need
    //

    // SECURITY: what non-relative path do we use that will work on ia64 too?
    if (NULL == (pDISKCOPY->hDISKCOPY_DLL = LoadLibrary(TEXT("DISKCOPY.DLL"))))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (NULL == (pDISKCOPY->MakeBootDisk = (PDISKCOPY_MAKEBOOTDISK_ROUTINE)
                GetProcAddress(pDISKCOPY->hDISKCOPY_DLL, MAKEINTRESOURCEA(1)))) //MakeBootDisk is at ordinal 1 in diskcopy.dll
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // If anything failed, and we've got the DLL loaded, release the DLL
    //

    if (hr != S_OK && pDISKCOPY->hDISKCOPY_DLL)
    {
       FreeLibrary(pDISKCOPY->hDISKCOPY_DLL);
    }
    return hr;
}

void AddRefFormatInfo(FORMATINFO *pFormatInfo)
{
    InterlockedIncrement(&pFormatInfo->cRef);
}

void ReleaseFormatInfo(FORMATINFO *pFormatInfo)
{
    if (InterlockedDecrement(&pFormatInfo->cRef) == 0) 
    {
        if (pFormatInfo->fmifs.hFMIFS_DLL)
        {
            FreeLibrary(pFormatInfo->fmifs.hFMIFS_DLL);
        }

        if (pFormatInfo->diskcopy.hDISKCOPY_DLL)
        {
            FreeLibrary(pFormatInfo->diskcopy.hDISKCOPY_DLL);
        }

        if (pFormatInfo->hThread)
        {
            CloseHandle(pFormatInfo->hThread);
        }

        LocalFree(pFormatInfo);
    }
}

//
// Thread-Local Storage index for our FORMATINFO structure pointer
//
static DWORD g_iTLSFormatInfo = 0;
static LONG  g_cTLSFormatInfo = 0;  // Usage count

//  Synopsis:   Allocates a thread-local index slot for this thread's
//              FORMATINFO pointer, if the index doesn't already exist.
//              In any event, stores the FORMATINFO pointer in the slot
//              and increments the index's usage count.
//
//  Arguments:  [pFormatInfo] -- The pointer to store
//
//  Returns:    HRESULT
//
HRESULT StuffFormatInfoPtr(FORMATINFO *pFormatInfo)
{
    HRESULT hr = S_OK;

    // Allocate an index slot for our thread-local FORMATINFO pointer, if one
    // doesn't already exist, then stuff our FORMATINFO ptr at that index.
    ENTERCRITICAL;
    if (0 == g_iTLSFormatInfo)
    {
        if (0xFFFFFFFF == (g_iTLSFormatInfo = TlsAlloc()))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        g_cTLSFormatInfo = 0;
    }
    if (S_OK == hr)
    {
        if (TlsSetValue(g_iTLSFormatInfo, (void *) pFormatInfo))
        {
           g_cTLSFormatInfo++;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    LEAVECRITICAL;

    return hr;
}

//  Synopsis:   Decrements the usage count on our thread-local storage
//              index, and if it goes to zero the index is free'd
//
//  Arguments:  [none]
//
//  Returns:    none
//
void UnstuffFormatInfoPtr()
{
    ENTERCRITICAL;
    if (0 == --g_cTLSFormatInfo)
    {
        TlsFree(g_iTLSFormatInfo);
        g_iTLSFormatInfo = 0;
    }
    LEAVECRITICAL;
}

//  Synopsis:   Retrieves this threads FORMATINFO ptr by grabbing the
//              thread-local value previously stuff'd
//
//  Arguments:  [none]
//
//  Returns:    The pointer, of course
//
FORMATINFO *GetFormatInfoPtr()
{
    return (FORMATINFO*)TlsGetValue(g_iTLSFormatInfo);
}



//  Synopsis:   Ghosts all controls except "Cancel", saving their
//              previous state in the FORMATINFO structure
//
//  Arguments:  [pFormatInfo] -- Describes a format dialog session
//
//  Notes:      Also changes "Close" button text to read "Cancel"
//
void DisableControls(FORMATINFO *pFormatInfo)
{
    WCHAR wszCancel[64];

    // Do this only if we haven't disabled the controls yet, otherwise
    // we double-disable and our rgfControlEnabled[] array gets corrupted.
    if (!pFormatInfo->fDisabled)
    {
        int i;
        pFormatInfo->fDisabled = TRUE;
        for (i = 0; i < DLG_FORMATDISK_NUMCONTROLS; i++)
        {
            HWND hControl = GetDlgItem(pFormatInfo->hDlg, i + DLG_FORMATDISK_FIRSTCONTROL);
            pFormatInfo->rgfControlEnabled[i] = !EnableWindow(hControl, FALSE);
        }
    }

    EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDOK), FALSE);

    LoadString(HINST_THISDLL, IDS_FMT_CANCEL, wszCancel, ARRAYSIZE(wszCancel));
    SetWindowText(GetDlgItem(pFormatInfo->hDlg, IDCANCEL), wszCancel);
}

//  Synopsis:   Restores controls to the enabled/disabled state they were
//              before a previous call to DisableControls().
//
//  Arguments:  [pFormatInfo] -- Decribes a format dialog session
//              [fReady] - If TRUE, then enable everything
//                         If FALSE, then enable combo boxes but leave
//                         buttons in limbo because there is still a format
//                         pending
//
//  Notes:      Also changes "Cancel" button to say "Close"
//              Also sets focus to Cancel button instead of Start button
//
//--------------------------------------------------------------------------
void EnableControls(FORMATINFO *pFormatInfo, BOOL fReady)
{
    WCHAR wszClose[64];
    int i;
    HWND hwnd;

    // Do this only if we have valid info in rgfControlEnabled[].
    // This catches the case where we give up on a format because it is
    // unstuck, and then finally it unsticks itself and tells us,
    // so we go and re-enable a second time.
    if (pFormatInfo->fDisabled)
    {
        pFormatInfo->fDisabled = FALSE;

        for (i = 0; i < DLG_FORMATDISK_NUMCONTROLS; i++)
        {
            HWND hControl = GetDlgItem(pFormatInfo->hDlg, i + DLG_FORMATDISK_FIRSTCONTROL);
            EnableWindow(hControl, pFormatInfo->rgfControlEnabled[i]);
        }
    }

    hwnd = GetDlgItem(pFormatInfo->hDlg, IDOK);
    EnableWindow(hwnd, fReady);
    SendMessage(hwnd, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0));

    LoadString(HINST_THISDLL, IDS_FMT_CLOSE, wszClose, ARRAYSIZE(wszClose));
    hwnd = GetDlgItem(pFormatInfo->hDlg, IDCANCEL);
    SetWindowText(hwnd, wszClose);
    SendMessage(hwnd, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0));
    SendMessage(pFormatInfo->hDlg, DM_SETDEFID, IDCANCEL, 0);

    // Shove focus only if it's on the OK button.  Otherwise we end up
    // yanking focus away from a user who is busy dorking with the dialog,
    // or -- worse -- dorking with a completely unrelated dialog!

    if (GetFocus() == GetDlgItem(pFormatInfo->hDlg, IDOK))
        SetFocus(hwnd);
}

//  Sets the dialog's title to "Format Floppy (A:)" or
//  "Formatting Floppy (A:)" 
void SetDriveWindowTitle(HWND hdlg, LPCWSTR pszDrive, UINT ids)
{
    SHFILEINFO sfi;
    WCHAR wszWinTitle[MAX_PATH]; // Format dialog window title

    LoadString(HINST_THISDLL, ids, wszWinTitle, ARRAYSIZE(wszWinTitle));

    if (SHGetFileInfo(pszDrive, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi),
                      SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME))
    {
        lstrcat(wszWinTitle, sfi.szDisplayName);
    }

    SetWindowText(hdlg, wszWinTitle);
}

//
//  Synopsis:   Called when a user picks a filesystem in the dialog, this
//              sets the states of the other relevant controls, such as
//              Enable Compression, Allocation Size, etc.
//
//  Arguments:  [fsenum]      -- One of e_FAT, e_NTFS, or e_FAT32
//              [pFormatInfo] -- Current format dialog session
//
void FileSysChange(FILESYSENUM fsenum, FORMATINFO *pFormatInfo)
{
    WCHAR wszTmp[MAX_PATH];

    switch (fsenum)
    {
        case e_FAT:
        case e_FAT32:
        {
            // un-check & disable the "Enable Compression" checkbox
            CheckDlgButton(pFormatInfo->hDlg, IDC_ECCHECK, FALSE);
            EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_ECCHECK), FALSE);

            SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_RESETCONTENT, 0, 0);
            
            LoadString(HINST_THISDLL, IDS_FMT_ALLOC0, wszTmp, ARRAYSIZE(wszTmp));
            SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_ADDSTRING, 0, (LPARAM)wszTmp);
            SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_SETCURSEL, 0, 0);
        }
        break;
            
        case e_NTFS:
        {
            int i;

            // un-check & disable the "Enable Compression" checkbox
            EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_ECCHECK), TRUE);
            CheckDlgButton(pFormatInfo->hDlg, IDC_ECCHECK, pFormatInfo->fEnableComp);

            // Set up the NTFS Allocation choices, and select the current choice
            SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_RESETCONTENT, 0, 0);

            for (i = IDS_FMT_ALLOC0; i <= IDS_FMT_ALLOC4; i++)
            {
                LoadString(HINST_THISDLL, i, wszTmp, ARRAYSIZE(wszTmp));
                SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_ADDSTRING, 0, (LPARAM)wszTmp);
            }

            switch (pFormatInfo->dwClusterSize)
            {
                case 512:
                    SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_SETCURSEL, 1, 0);
                    break;

                case 1024:
                    SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_SETCURSEL, 2, 0);
                    break;

                case 2048:
                    SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_SETCURSEL, 3, 0);
                    break;

                case 4096:
                    SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_SETCURSEL, 4, 0);
                    break;

                default:
                    SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_SETCURSEL, 0, 0);
                    break;

            }
        }
        break;
    }
}

//
// Is this drive a GPT drive?
// GPT drive: Guid-Partition Table - a replacement for the Master Boot Record, used on some IA64 machines, can only use NTFS
BOOL IsGPTDrive(int iDrive)
{
    BOOL fRetVal = FALSE;
#ifdef _WIN64
    HANDLE hDrive;
    TCHAR szDrive[] = TEXT("\\\\.\\A:");

    ASSERT(iDrive < 26);
    szDrive[4] += (TCHAR)iDrive;
    
    hDrive = CreateFile(szDrive, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hDrive)
    {
        PARTITION_INFORMATION_EX partitionEx;
        DWORD cbReturned;
        if (DeviceIoControl(hDrive, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, (void*)&partitionEx, sizeof(PARTITION_INFORMATION_EX), &cbReturned, NULL))
        {
            if (partitionEx.PartitionStyle == PARTITION_STYLE_GPT) 
            {
                fRetVal = TRUE;
            }
        }
        CloseHandle(hDrive);
    }
#endif
    return fRetVal;
}

BOOL IsDVDRAMMedia(int iDrive)
{
    BOOL fRetVal = FALSE;
    CMountPoint *pmtpt = CMountPoint::GetMountPoint(iDrive);
    if (pmtpt)
    {
        DWORD dwMediaCap, dwDriveCap;
        if (SUCCEEDED(pmtpt->GetCDInfo(&dwDriveCap, &dwMediaCap)))
        {
            fRetVal = (dwMediaCap & HWDMC_DVDRAM);
        }
        pmtpt->Release();
    }

    return fRetVal;
}

#define GIG_INBYTES       (1024 * 1024 * 1024)

//
// FAT32 has some limit which prevents the number of clusters from being
// less than 65526.  And minimum cluster size is 512 bytes.  So minimum FAT32
// volume size is 65526*512.

#define FAT32_MIN           ((ULONGLONG)65526*512)

#define FMTAVAIL_MASK_MIN      0x1
#define FMTAVAIL_MASK_MAX      0x2
#define FMTAVAIL_MASK_REQUIRE  0x3
#define FMTAVAIL_MASK_FORBID   0x4

#define FMTAVAIL_TYPE_FLOPPY   0x1
#define FMTAVAIL_TYPE_DVDRAM   0x2
#define FMTAVAIL_TYPE_GPT      0x4
#define FMTAVAIL_TYPE_MEMSTICK 0x8
#define FMTAVAIL_TYPE_NTFS_BLOCKED 0x10

typedef struct _FMTAVAIL
{
    DWORD dwfs;
    DWORD dwMask;
    DWORD dwForbiddenTypes;
    ULONGLONG qMinSize;
    ULONGLONG qMaxSize;
} FMTAVAIL;

FMTAVAIL rgFmtAvail[] = {
    {e_FAT,   FMTAVAIL_MASK_MAX | FMTAVAIL_MASK_FORBID, FMTAVAIL_TYPE_DVDRAM | FMTAVAIL_TYPE_GPT, 0, ((ULONGLONG)2 * GIG_INBYTES) },
    {e_FAT32, FMTAVAIL_MASK_MIN | FMTAVAIL_MASK_MAX | FMTAVAIL_MASK_FORBID, FMTAVAIL_TYPE_GPT | FMTAVAIL_TYPE_FLOPPY | FMTAVAIL_TYPE_MEMSTICK, FAT32_MIN, ((ULONGLONG)32 * GIG_INBYTES) },
    {e_NTFS,  FMTAVAIL_MASK_FORBID, FMTAVAIL_TYPE_DVDRAM | FMTAVAIL_TYPE_FLOPPY | FMTAVAIL_TYPE_MEMSTICK | FMTAVAIL_TYPE_NTFS_BLOCKED, 0, 0 }
};

// is a particular disk format available for a drive with given parameters and capacity?
BOOL FormatAvailable (DWORD dwfs, FORMATINFO* pFormatInfo, ULONGLONG* pqwCapacity)
{
    BOOL fAvailable = TRUE;
    DWORD dwType = 0;

    if (pFormatInfo->fIsFloppy)
    {
        dwType |= FMTAVAIL_TYPE_FLOPPY;
    }
    if (IsDVDRAMMedia(pFormatInfo->drive))
    {
        dwType |= FMTAVAIL_TYPE_DVDRAM;
    }
    if (IsGPTDrive(pFormatInfo->drive)) 
    {
        dwType |= FMTAVAIL_TYPE_GPT;
    }
    if (pFormatInfo->fIsMemoryStick)
    {
        dwType |= FMTAVAIL_TYPE_MEMSTICK;
    }
    if (pFormatInfo->fIsNTFSBlocked)
    {
        dwType |= FMTAVAIL_TYPE_NTFS_BLOCKED;
    }

    for (int i = 0; i < ARRAYSIZE(rgFmtAvail); i++)
    {
        // check only entries that match the format we're looking for
        if (rgFmtAvail[i].dwfs == dwfs)
        {
            // if a failure conditions is true, then this format is unavailable
            if ((rgFmtAvail[i].dwMask & FMTAVAIL_MASK_FORBID) && (rgFmtAvail[i].dwForbiddenTypes & dwType))
            {
                fAvailable = FALSE;
                break;
            }

            if ((rgFmtAvail[i].dwMask & FMTAVAIL_MASK_MIN) && (*pqwCapacity < rgFmtAvail[i].qMinSize))
            {
                fAvailable = FALSE;
                break;
            }

            if ((rgFmtAvail[i].dwMask & FMTAVAIL_MASK_MAX) && (*pqwCapacity > rgFmtAvail[i].qMaxSize))
            {
                fAvailable = FALSE;
                break;
            }
        }
    }

    return fAvailable;
}

HRESULT GetPartitionSizeInBytes(int iDrive, ULONGLONG* pqwPartitionSize)
{
    HRESULT hr = E_FAIL;
    HANDLE hFile;
    TCHAR szDrive[] = TEXT("\\\\.\\A:");

    *pqwPartitionSize = 0;

    ASSERT(iDrive < 26);
    szDrive[4] += (TCHAR)iDrive;
    
    hFile = CreateFile(szDrive, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        GET_LENGTH_INFORMATION LengthInfo;
        DWORD cbReturned;

        if (DeviceIoControl(hFile, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, (void*)&LengthInfo, sizeof(LengthInfo), &cbReturned, NULL) &&
            LengthInfo.Length.QuadPart)
        {
            *pqwPartitionSize = LengthInfo.Length.QuadPart;
            hr = S_OK;
        }

        CloseHandle(hFile);
    }

    return hr;
}

// this helper function adds a string to a combo box with the associated dword (dwfs) as its itemdata
void _AddFSString(HWND hwndCB, WCHAR* pwsz, DWORD dwfs)
{
    int iIndex = ComboBox_AddString(hwndCB, pwsz);
    if (iIndex != CB_ERR)
    {
        ComboBox_SetItemData(hwndCB, iIndex, dwfs);
    }
}

// We only support formatting these types of devices
const FMIFS_MEDIA_TYPE rgFmtSupported[] = { FmMediaRemovable, FmMediaFixed, 
                                            FmMediaF3_1Pt44_512, FmMediaF3_120M_512, FmMediaF3_200Mb_512};

//
//  Synopsis:   Initializes the format dialog to a default state.  Examines
//              the disk/partition to obtain default values.
//
//  Arguments:  [hDlg]        -- Handle to the format dialog
//              [pFormatInfo] -- Describes current format session
//
//  Returns:    HRESULT
//
HRESULT InitializeFormatDlg(FORMATINFO *pFormatInfo)
{
    HRESULT          hr              = S_OK;
    ULONG            cMedia;
    HWND             hCapacityCombo;
    HWND             hFilesystemCombo;
    HWND             hDlg = pFormatInfo->hDlg;
    WCHAR            wszBuffer[256];
    ULONGLONG        qwCapacity = 0;

    // Set up some typical default values
    pFormatInfo->fEnableComp       = FALSE;
    pFormatInfo->dwClusterSize     = 0;
    pFormatInfo->fIsFloppy         = TRUE;
    pFormatInfo->fIsMemoryStick    = FALSE;
    pFormatInfo->fIsNTFSBlocked    = FALSE;
    pFormatInfo->fIs35HDFloppy     = TRUE;
    pFormatInfo->fWasFAT           = TRUE;
    pFormatInfo->fFinishedOK       = FALSE;
    pFormatInfo->fErrorAlready     = FALSE;
    pFormatInfo->wszVolName[0]     = L'\0';

    // Initialize the Quick Format checkbox based on option passed to the SHFormatDrive() API
    Button_SetCheck(GetDlgItem(hDlg, IDC_QFCHECK), pFormatInfo->options & SHFMT_OPT_FULL);

    // Set the dialog title to indicate which drive we are dealing with
    PathBuildRootW(pFormatInfo->wszDriveName, pFormatInfo->drive);
    SetDriveWindowTitle(pFormatInfo->hDlg, pFormatInfo->wszDriveName, IDS_FMT_FORMAT);

    // Query the supported media types for the drive in question
    if (!pFormatInfo->fmifs.QuerySupportedMedia(pFormatInfo->wszDriveName,
                                                pFormatInfo->rgMedia,
                                                ARRAYSIZE(pFormatInfo->rgMedia),
                                                &cMedia))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // For each of the formats that the drive can handle, add a selection
    // to the capcity combobox.
    if (S_OK == hr)
    {
        UINT olderror;
        ULONG i;
        ULONG j;

        hCapacityCombo = GetDlgItem(hDlg, IDC_CAPCOMBO);
        hFilesystemCombo = GetDlgItem(hDlg, IDC_FSCOMBO);

        ASSERT(hCapacityCombo && hFilesystemCombo);

        FMIFS_DEVICE_INFORMATION fmifsdeviceinformation;
        BOOL fOk = pFormatInfo->fmifs.QueryDeviceInformation(
                        pFormatInfo->wszDriveName,
                        &fmifsdeviceinformation,
                        sizeof(fmifsdeviceinformation));

        if (fOk)
        {
            if (fmifsdeviceinformation.Flags & FMIFS_SONY_MS)
            {
                pFormatInfo->fIsMemoryStick = TRUE;
            }

            if (fmifsdeviceinformation.Flags & FMIFS_NTFS_NOT_SUPPORTED)
            {
                pFormatInfo->fIsNTFSBlocked = TRUE;
            }
        }

        // Allow only certain media types
        j = 0;
        for (i = 0; i < cMedia; i++)
        {
            for (int k = 0; k < ARRAYSIZE(rgFmtSupported); k++)
            {
                if (pFormatInfo->rgMedia[i] ==  rgFmtSupported[k])
                {
                    pFormatInfo->rgMedia[j] = pFormatInfo->rgMedia[i];
                    j++;
                    break;
                }
            }
        }
        cMedia = j;

        if (0 == cMedia)
        {
            hr = ERROR_UNRECOGNIZED_MEDIA;
        }
        else
        {
            for (i = 0; i < cMedia; i++)
            {
                // If we find any non-floppy format, clear the fIsFloppy flag
                if (FmMediaFixed == pFormatInfo->rgMedia[i] || FmMediaRemovable == pFormatInfo->rgMedia[i])
                {
                    pFormatInfo->fIsFloppy = FALSE;
                }

                // if we find any non-3.5" HD floppy format, clear the fIs35HDFloppy flag
                if (FmMediaF3_1Pt44_512 != pFormatInfo->rgMedia[i])
                {
                    pFormatInfo->fIs35HDFloppy = FALSE;
                }
                
                // For fixed media we query the size, for floppys we present
                // a set of options supported by the drive
                if (FmMediaFixed == pFormatInfo->rgMedia[i] || (FmMediaRemovable == pFormatInfo->rgMedia[i]))
                {
                    DWORD dwSectorsPerCluster,
                          dwBytesPerSector,
                          dwFreeClusters,
                          dwClusters;

                    if (SUCCEEDED(GetPartitionSizeInBytes(pFormatInfo->drive, &qwCapacity)))
                    {
                        // Add a capacity desciption to the combobox
                        ShortSizeFormat64(qwCapacity, wszBuffer, ARRAYSIZE(wszBuffer));
                    }
                    else
                    {
                        // Couldn't get the free space... prob. not fatal
                        LoadString(HINST_THISDLL, IDS_FMT_CAPUNKNOWN, wszBuffer, sizeof(wszBuffer));
                    }
                    ComboBox_AddString(hCapacityCombo, wszBuffer);

                    if (GetDiskFreeSpace(pFormatInfo->wszDriveName,
                                         &dwSectorsPerCluster,
                                         &dwBytesPerSector,
                                         &dwFreeClusters,
                                         &dwClusters))
                    {
                        pFormatInfo->dwClusterSize = dwBytesPerSector * dwSectorsPerCluster;
                    }
                }
                else
                {
                    // removable media:
                    //
                    // add a capacity desciption to the combo baseed on the sequential list of 
                    // media format descriptors
                    LoadString(HINST_THISDLL, IDS_FMT_MEDIA0 + pFormatInfo->rgMedia[i], wszBuffer, ARRAYSIZE(wszBuffer));
                    ComboBox_AddString(hCapacityCombo, wszBuffer);
                }
            }


            // set capacity to default 
            ComboBox_SetCurSel(hCapacityCombo, 0);

            // Add the appropriate filesystem selections to the combobox
            // We now prioritize NTFS
            if (FormatAvailable(e_NTFS, pFormatInfo, &qwCapacity))
            {
                _AddFSString(hFilesystemCombo, FS_STR_NTFS, e_NTFS);
            }

            if (FormatAvailable(e_FAT32, pFormatInfo, &qwCapacity))
            {

                _AddFSString(hFilesystemCombo, FS_STR_FAT32, e_FAT32);
            }

            if (FormatAvailable(e_FAT, pFormatInfo, &qwCapacity))
            {
                _AddFSString(hFilesystemCombo, FS_STR_FAT, e_FAT);
            }

            // By default, pick the 0-th entry in the _nonsorted_ combobox.
            // NOTE: this can be overwritten below
            ComboBox_SetCurSel(hFilesystemCombo, 0);

            // If we can determine something other than FAT is being used,
            // select it as the default in the combobox
            olderror = SetErrorMode(SEM_FAILCRITICALERRORS);

            if (GetVolumeInformation(pFormatInfo->wszDriveName,
                                     pFormatInfo->wszVolName,
                                     ARRAYSIZE(pFormatInfo->wszVolName),
                                     NULL,
                                     NULL,
                                     NULL,
                                     wszBuffer,
                                     ARRAYSIZE(wszBuffer)))
            {
                // If we got a current volume label, stuff it in the edit control
                if (pFormatInfo->wszVolName[0] != L'\0')
                {
                    SetWindowText(GetDlgItem(pFormatInfo->hDlg, IDC_VLABEL), pFormatInfo->wszVolName);
                }

                // for non-floppies we default to keeping the FS the same as the current one
                if (!pFormatInfo->fIsFloppy)
                {
                    if (0 == lstrcmpi(FS_STR_NTFS, wszBuffer))
                    {
                        ComboBox_SelectString(hFilesystemCombo, -1, FS_STR_NTFS);
                        pFormatInfo->fWasFAT = FALSE;
                    }
                    else if (0 == lstrcmpi(FS_STR_FAT32, wszBuffer))
                    {
                        ComboBox_SelectString(hFilesystemCombo, -1, FS_STR_FAT32);
                        pFormatInfo->fWasFAT = TRUE;
                        pFormatInfo->dwClusterSize = 0;
                    }
                    else
                    {
                        ComboBox_SelectString(hFilesystemCombo, -1, FS_STR_FAT);
                        pFormatInfo->fWasFAT = TRUE;
                        pFormatInfo->dwClusterSize = 0;
                    }
                }
                // FEATURE - What about specialized file-systems?  Don't care for now.
            }

            
#ifndef _WIN64
            // if not WIN64, enable boot-disk creation if we are a 3.5" HD floppy
            EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_BTCHECK), pFormatInfo->fIs35HDFloppy);
#else
            // if WIN64, hide this option, since we can't use these boot floppies on WIN64
            ShowWindow(GetDlgItem(pFormatInfo->hDlg, IDC_BTCHECK), FALSE);
#endif


            // restore the old errormode
            SetErrorMode(olderror);

            // set the state of the chkboxes properly based on the FS chosen
            FileSysChange((FILESYSENUM)ComboBox_GetItemData(hFilesystemCombo, ComboBox_GetCurSel(hFilesystemCombo)), pFormatInfo);
        }
    }

    // If the above failed due to disk not in drive, notify the user
    if (FAILED(hr))
    {
        switch (HRESULT_CODE(hr))
        {
        case ERROR_UNRECOGNIZED_MEDIA:
            ShellMessageBox(HINST_THISDLL,
                            hDlg,
                            MAKEINTRESOURCE(IDS_UNFORMATTABLE_DISK),
                            NULL,
                            MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK,
                            NULL);

            break;

        case ERROR_NOT_READY:
            ShellMessageBox(HINST_THISDLL,
                            hDlg,
                            MAKEINTRESOURCE(IDS_DRIVENOTREADY),
                            NULL,
                            MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK,
                            pFormatInfo->wszDriveName[0]);
            break;

        case ERROR_ACCESS_DENIED:
            ShellMessageBox(HINST_THISDLL,
                            hDlg,
                            MAKEINTRESOURCE(IDS_ACCESSDENIED),
                            NULL,
                            MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK,
                            pFormatInfo->wszDriveName[0]);
            break;

        case ERROR_WRITE_PROTECT:
            ShellMessageBox(HINST_THISDLL,
                            hDlg,
                            MAKEINTRESOURCE(IDS_WRITEPROTECTED),
                            NULL,
                            MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK,
                            pFormatInfo->wszDriveName[0]);
            break;
        }
    }

    return hr;
}

//  Synopsis:   Called from within the FMIFS DLL's Format function, this
//              updates the format dialog's status bar and responds to
//              format completion/error notifications.
//
//  Arguments:  [PacketType]   -- Type of packet (ie: % complete, error, etc)
//              [PacketLength] -- Size, in bytes, of the packet
//              [pPacketData]  -- Pointer to the packet
//
//  Returns:    BOOLEAN continuation value
//
BOOLEAN FormatCallback(FMIFS_PACKET_TYPE PacketType, ULONG PacketLength, void *pPacketData)
{
    UINT iMessageID = IDS_FORMATFAILED;
    BOOL fFailed = FALSE;
    FORMATINFO* pFormatInfo = GetFormatInfoPtr();

    ASSERT(g_iTLSFormatInfo);

    // Grab the FORMATINFO structure for this thread
    if (pFormatInfo)
    {
        if (!pFormatInfo->fShouldCancel)
        {
            switch(PacketType)
            {
                case FmIfsIncompatibleFileSystem:
                    fFailed    = TRUE;
                    iMessageID = IDS_INCOMPATIBLEFS;
                    break;

                case FmIfsIncompatibleMedia:
                    fFailed    = TRUE;
                    iMessageID = IDS_INCOMPATIBLEMEDIA;
                    break;

                case FmIfsAccessDenied:
                    fFailed    = TRUE;
                    iMessageID = IDS_ACCESSDENIED;
                    break;

                case FmIfsMediaWriteProtected:
                    fFailed    = TRUE;
                    iMessageID = IDS_WRITEPROTECTED;
                    break;

                case FmIfsCantLock:
                    fFailed    = TRUE;
                    iMessageID = IDS_CANTLOCK;
                    break;

                case FmIfsCantQuickFormat:
                    fFailed    = TRUE;
                    iMessageID = IDS_CANTQUICKFORMAT;
                    break;

                case FmIfsIoError:
                    fFailed    = TRUE;
                    iMessageID = IDS_IOERROR;
                    // FUTURE Consider showing head/track etc where error was
                    break;

                case FmIfsBadLabel:
                    fFailed    = TRUE;
                    iMessageID = IDS_BADLABEL;
                    break;

                case FmIfsPercentCompleted:
                {
                    FMIFS_PERCENT_COMPLETE_INFORMATION * pPercent =
                      (FMIFS_PERCENT_COMPLETE_INFORMATION *) pPacketData;
            
                    SendDlgItemMessage(pFormatInfo->hDlg, IDC_FMTPROGRESS,
                                       PBM_SETPOS,
                                       pPercent->PercentCompleted, 0);
                }
                break;

                case FmIfsFinished:
                {
                    // Format is done; check for failure or success
                    FMIFS_FINISHED_INFORMATION* pFinishedInfo = (FMIFS_FINISHED_INFORMATION*)pPacketData;

                    pFormatInfo->fFinishedOK = pFinishedInfo->Success;

                    if (pFinishedInfo->Success)
                    {
                        // fmifs will "succeed" even if we already failed, so we need to double-check
                        // that we haven't already put up error UI
                        if (!pFormatInfo->fErrorAlready)
                        {
                            // If "Enable Compression" is checked, try to enable filesystem compression
                            if (IsDlgButtonChecked(pFormatInfo->hDlg, IDC_ECCHECK))
                            {
                                if (pFormatInfo->fmifs.EnableVolumeCompression(pFormatInfo->wszDriveName,
                                                                               COMPRESSION_FORMAT_DEFAULT) == FALSE)
                                {
                                    ShellMessageBox(HINST_THISDLL,
                                                    pFormatInfo->hDlg,
                                                    MAKEINTRESOURCE(IDS_CANTENABLECOMP),
                                                    NULL,
                                                    MB_SETFOREGROUND | MB_ICONINFORMATION | MB_OK);
                                }
                            }

                            // Even though its a quick format, the progress meter should
                            // show 100% when the "Format Complete" requester is up
                            SendDlgItemMessage(pFormatInfo->hDlg, IDC_FMTPROGRESS,
                                               PBM_SETPOS,
                                               100, // set %100 Complete
                                               0);

                            // FUTURE Consider showing format stats, ie: ser no, bytes, etc
                            ShellMessageBox(HINST_THISDLL,
                                            pFormatInfo->hDlg,
                                            MAKEINTRESOURCE(IDS_FORMATCOMPLETE),
                                            NULL,
                                            MB_SETFOREGROUND | MB_ICONINFORMATION | MB_OK);
                        }

                        // Restore the dialog title, reset progress and flags
                        SendDlgItemMessage(pFormatInfo->hDlg,
                                           IDC_FMTPROGRESS,
                                           PBM_SETPOS,
                                           0,   // Reset Percent Complete
                                           0);

                        // Set the focus onto the Close button
                        pFormatInfo->fCancelled = FALSE;
                    }
                    else
                    {
                        fFailed = TRUE;
                    }
                }
                break;
            }

            if (fFailed && !pFormatInfo->fErrorAlready)
            {
                // If we received any kind of failure information, put up a final
                // "Format Failed" message. UNLESS we've already put up some nice message
                ShellMessageBox(HINST_THISDLL,
                                pFormatInfo->hDlg,
                                MAKEINTRESOURCE(iMessageID),
                                NULL,
                                MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK);

                pFormatInfo->fErrorAlready = TRUE;
            }
        }
        else
        {
            // user hit cancel
            pFormatInfo->fCancelled = TRUE;
            fFailed = TRUE;
        }        
    }
    else
    {
        // no pFormatInfo? we're screwed
        fFailed = TRUE;
    }

    return (BOOLEAN) (fFailed == FALSE);
}

//
//  Synopsis:   Spun off as its own thread, this ghosts all controls in the
//              dialog except "Cancel", then does the actual format
//
//  Arguments:  [pIn] -- FORMATINFO structure pointer as a void *
//
//  Returns:    HRESULT thread exit code
//
DWORD WINAPI BeginFormat(void * pIn)
{
    FORMATINFO *pFormatInfo = (FORMATINFO*)pIn;
    HRESULT hr = S_OK;
    
    // Save the FORAMTINFO ptr for this thread, to be used in the format
    // callback function
    hr = StuffFormatInfoPtr(pFormatInfo);
    if (hr == S_OK)
    {
        HWND hwndFileSysCB = GetDlgItem(pFormatInfo->hDlg, IDC_FSCOMBO);
        int iCurSel;

        // Set the window title to indicate format in proress...
        SetDriveWindowTitle(pFormatInfo->hDlg, pFormatInfo->wszDriveName, IDS_FMT_FORMATTING);

        // Determine the user's choice of filesystem
        iCurSel = ComboBox_GetCurSel(hwndFileSysCB);
    
        if (iCurSel != CB_ERR)
        {
            LPCWSTR pwszFileSystemName;
            FMIFS_MEDIA_TYPE MediaType;
            LPITEMIDLIST pidlFormat;
            BOOLEAN fQuickFormat;

            FILESYSENUM fseType = (FILESYSENUM)ComboBox_GetItemData(hwndFileSysCB, iCurSel);

            switch (fseType)
            {
                case e_FAT:
                    pwszFileSystemName = FS_STR_FAT;
                    break;

                case e_FAT32:
                    pwszFileSystemName = FS_STR_FAT32;
                    break;

                case e_NTFS:
                    pwszFileSystemName = FS_STR_NTFS;
                    break;
            }

            // Determine the user's choice of media formats
            iCurSel = ComboBox_GetCurSel(GetDlgItem(pFormatInfo->hDlg, IDC_CAPCOMBO));
            if (iCurSel == CB_ERR)
            {
                iCurSel = 0;
            }
            MediaType = pFormatInfo->rgMedia[iCurSel];

            // Get the cluster size.  First selection ("Use Default") yields a zero,
            // while the next 4 select 512, 1024, 2048, or 4096
            iCurSel = ComboBox_GetCurSel(GetDlgItem(pFormatInfo->hDlg, IDC_ASCOMBO));
            if ((iCurSel == CB_ERR) || (iCurSel == 0))
            {
                pFormatInfo->dwClusterSize = 0;
            }
            else
            {
                pFormatInfo->dwClusterSize = 256 << iCurSel;
            }

            // Quickformatting?
            fQuickFormat = Button_GetCheck(GetDlgItem(pFormatInfo->hDlg, IDC_QFCHECK));

            // Clear the error state.
            pFormatInfo->fErrorAlready = FALSE;

            // Tell the shell to get ready...  Announce that the media is no
            // longer valid (so people who have active views on it will navigate
            // away) and tell the shell to close its FindFirstChangeNotifications.
            if (SUCCEEDED(SHILCreateFromPath(pFormatInfo->wszDriveName, &pidlFormat, NULL)))
            {
                SHChangeNotify(SHCNE_MEDIAREMOVED, SHCNF_IDLIST | SHCNF_FLUSH, pidlFormat, 0);
                SHChangeNotifySuspendResume(TRUE, pidlFormat, TRUE, 0);
            }
            else
            {
                pidlFormat = NULL;
            }

            if (!pFormatInfo->fMakeBootDisk)
            {
                // Do the format.
                pFormatInfo->fmifs.FormatEx(pFormatInfo->wszDriveName,
                                            MediaType,
                                            (PWSTR)pwszFileSystemName,
                                            pFormatInfo->wszVolName,
                                            fQuickFormat,
                                            pFormatInfo->dwClusterSize,
                                            FormatCallback);
            }
            else
            {
                pFormatInfo->diskcopy.MakeBootDisk(pFormatInfo->diskcopy.hDISKCOPY_DLL, pFormatInfo->drive, &pFormatInfo->fCancelled, FormatCallback);
            }

            //  Wake the shell back up.
            if (pidlFormat)
            {
                SHChangeNotifySuspendResume(FALSE, pidlFormat, TRUE, 0);
                ILFree(pidlFormat);
            }

            // Success or failure, we should fire a notification on the disk
            // since we don't really know the state after the format
            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATHW, (void *)pFormatInfo->wszDriveName, NULL);
        }
        else
        {
            // couldn't get the filesys CB selection
            hr = E_FAIL;
        }

        // Release the TLS index
        UnstuffFormatInfoPtr();
    }

    // Post a message back to the DialogProc thread to let it know
    // the format is done.  We post the message since otherwise the
    // DialogProc thread will be too busy waiting for this thread
    // to exit to be able to process the PWM_FORMATDONE message
    // immediately.
    PostMessage(pFormatInfo->hDlg, (UINT) PWM_FORMATDONE, 0, 0);

    ReleaseFormatInfo(pFormatInfo);

    return (DWORD)hr;
}

BOOL_PTR CALLBACK FormatDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr   = S_OK;
    int iID   = GET_WM_COMMAND_ID(wParam, lParam);
    int iCMD  = GET_WM_COMMAND_CMD(wParam, lParam);

    // Grab our previously cached pointer to the FORMATINFO struct (see WM_INITDIALOG)
    FORMATINFO *pFormatInfo = (FORMATINFO *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg)
    {
        case PWM_FORMATDONE:
            // Format is done.  Reset the window title and clear the progress meter
            SetDriveWindowTitle(pFormatInfo->hDlg, pFormatInfo->wszDriveName, IDS_FMT_FORMAT);
            SendDlgItemMessage(pFormatInfo->hDlg, IDC_FMTPROGRESS, PBM_SETPOS, 0 /* Reset Percent Complete */, 0);
            EnableControls(pFormatInfo, TRUE);

            if (pFormatInfo->fCancelled)
            {
                // Don't put up UI if the background thread finally finished
                // long after the user issued the cancel
                if (!pFormatInfo->fShouldCancel)
                {
                    ShellMessageBox(HINST_THISDLL,
                                    pFormatInfo->hDlg,
                                    MAKEINTRESOURCE(IDS_FORMATCANCELLED),
                                    NULL,
                                    MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK);
                }
                pFormatInfo->fCancelled = FALSE;
            }

            if (pFormatInfo->hThread)
            {
                CloseHandle(pFormatInfo->hThread);
                pFormatInfo->hThread = NULL;
            }
            break;

        case WM_INITDIALOG:
            // Initialize the dialog and cache the FORMATINFO structure's pointer
            // as our dialog's DWLP_USER data
            pFormatInfo = (FORMATINFO *) lParam;
            pFormatInfo->hDlg = hDlg;
            if (FAILED(InitializeFormatDlg(pFormatInfo)))
            {
                EndDialog(hDlg, 0);
                return -1;
            }
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            break;

        case WM_DESTROY:           
            if (pFormatInfo && pFormatInfo->hDlg)
            {
                pFormatInfo->hDlg = NULL;
            }
            break;

        case WM_COMMAND:
            if (iCMD == CBN_SELCHANGE)
            {
                // User made a selection in one of the combo boxes
                if (iID == IDC_FSCOMBO)
                {
                    // User selected a filesystem... update the rest of the dialog
                    // based on this choice
                    HWND hFilesystemCombo = (HWND)lParam;
                    int iCurSel = ComboBox_GetCurSel(hFilesystemCombo);

                    FileSysChange((FILESYSENUM)ComboBox_GetItemData(hFilesystemCombo, iCurSel), pFormatInfo);
                }
            }
            else
            {
                // Codepath for controls other than combo boxes...
                switch (iID)
                {
                case IDC_BTCHECK:
                        pFormatInfo->fMakeBootDisk = IsDlgButtonChecked(pFormatInfo->hDlg, IDC_BTCHECK);
                        EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_CAPCOMBO), !pFormatInfo->fMakeBootDisk);                        
                        EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_FSCOMBO), !pFormatInfo->fMakeBootDisk);
                        EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_ASCOMBO), !pFormatInfo->fMakeBootDisk);
                        EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_VLABEL), !pFormatInfo->fMakeBootDisk);
                        EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_QFCHECK), !pFormatInfo->fMakeBootDisk);
                        break;
                case IDC_ECCHECK:
                        pFormatInfo->fEnableComp = IsDlgButtonChecked(hDlg, IDC_ECCHECK);
                        break;

                    case IDOK:
                    {
                        // Get user verification for format, break out on CANCEL
                        if (IDCANCEL == ShellMessageBox(HINST_THISDLL,
                                                        hDlg,
                                                        MAKEINTRESOURCE(IDS_OKTOFORMAT),
                                                        NULL,
                                                        MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OKCANCEL))
                        {
                            break;
                        }

                        ASSERT(pFormatInfo->hThread == NULL);

                        DisableControls(pFormatInfo);
                        pFormatInfo->fCancelled = FALSE;
                        pFormatInfo->fShouldCancel = FALSE;
                        GetWindowText(GetDlgItem(pFormatInfo->hDlg, IDC_VLABEL), pFormatInfo->wszVolName, MAX_PATH);
                
                        AddRefFormatInfo(pFormatInfo);
                        pFormatInfo->hThread = CreateThread(NULL,
                                                            0,
                                                            BeginFormat,
                                                            (void *)pFormatInfo,
                                                            0,
                                                            NULL);
                        if (!pFormatInfo->hThread)
                        {
                            // ISSUE: we should probably do something...
                            ReleaseFormatInfo(pFormatInfo);
                        }
                    }
                    break;

                    case IDCANCEL:
                        // If the format thread is running, wait for it.  If not,
                        // exit the dialog
                        pFormatInfo->fShouldCancel = TRUE;
                        if (pFormatInfo->hThread)
                        {
                            DWORD dwWait;

                            do
                            {
                                dwWait =  WaitForSingleObject(pFormatInfo->hThread, 10000);
                            }
                            while ((WAIT_TIMEOUT == dwWait) &&
                                   (IDRETRY == ShellMessageBox(HINST_THISDLL,
                                                               hDlg,
                                                               MAKEINTRESOURCE(IDS_CANTCANCELFMT),
                                                               NULL,
                                                               MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_RETRYCANCEL)));

                            // If the format doesn't admit to having been killed, it didn't
                            // give up peacefully.  Just abandon it and let it clean up
                            // when it finally gets around to it, at which point we will
                            // enable the OK button to let the user take another stab.
                            //
                            // Careful:  The format may have cleaned up while the dialog box
                            // was up, so revalidate.
                            if (pFormatInfo->hThread)
                            {
                                CloseHandle(pFormatInfo->hThread);
                                pFormatInfo->hThread = NULL;
                                pFormatInfo->fCancelled = TRUE;
                                EnableControls(pFormatInfo, FALSE);
                            }
                        }
                        else
                        {
                            EndDialog(hDlg, IDCANCEL);
                        }
                        break;
                 }
            }
            break;

        case WM_HELP:
            WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR) (LPSTR) FmtaIds);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR) (LPSTR) FmtaIds);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//
//  Synopsis:   The SHFormatDrive API provides access to the Shell
//              format dialog. This allows apps which want to format disks
//              to bring up the same dialog that the Shell does to do it.
//
//              NOTE that the user can format as many diskettes in the
//              specified drive, or as many times, as he/she wishes to.
//
//  Arguments:  [hwnd]    -- Parent window (Must NOT be NULL)
//              [drive]   -- 0 = A:, 1 = B:, etc.
//              [fmtID]   -- see below
//              [options] -- SHFMT_OPT_FULL    overrised default quickformat
//                           SHFMT_OPT_SYSONLY not support for NT
//
//  Returns:    See Notes
//
DWORD WINAPI SHFormatDrive(HWND hwnd, UINT drive, UINT fmtID, UINT options)
{    
    INT_PTR ret;
    FORMATINFO *pFormatInfo = (FORMATINFO *)LocalAlloc(LPTR, sizeof(*pFormatInfo));
    ASSERT(drive < 26);

    if (!pFormatInfo)
        return SHFMT_ERROR;

    HRESULT hrCoInit = SHCoInitialize();

    pFormatInfo->cRef = 1;
    pFormatInfo->drive = drive;
    pFormatInfo->fmtID = fmtID;
    pFormatInfo->options = options;

    // It makes no sense for NT to "SYS" a disk
    if (pFormatInfo->options & SHFMT_OPT_SYSONLY)
    {
        ret = 0;
        goto done;
    }

    // Load FMIFS.DLL and DISKCOPY.DLL and open the Format dialog
    if (S_OK == LoadFMIFS(&pFormatInfo->fmifs) &&
        S_OK == LoadDISKCOPY(&pFormatInfo->diskcopy))
    {
        DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_FORMATDISK),
                             hwnd, FormatDlgProc, (LPARAM) pFormatInfo);
    }
    else
    {
        ASSERT(0 && "Can't load FMIFS.DLL");
        ret = SHFMT_ERROR;
        goto done;
    }

    // Since time immemorial it has been almost impossible to
    // get SHFMT_CANCEL as a return code.  Most of the time, you get
    // SHFMT_ERROR if the user cancels.
    if (pFormatInfo->fCancelled)
    {
        ret = SHFMT_CANCEL;
    }
    else if (pFormatInfo->fFinishedOK)
    {
        // APPCOMPAT: (stephstm) We used to say that we return the Serial
        //   Number but we never did.  So keep on returning 0 for success.
        //   Furthermore, Serial number values could conflict SHFMT_*
        //   error codes.
        ret = 0;
    }
    else
    {
        ret = SHFMT_ERROR;
    }

done:
    ReleaseFormatInfo(pFormatInfo);
    SHCoUninitialize(hrCoInit);
    return (DWORD)ret;
}

////////////////////////////////////////////////////////////////////////////
//
// CHKDSK
//
////////////////////////////////////////////////////////////////////////////

//
// This structure described the current chkdsk session
//
typedef struct
{
    UINT    lastpercent;           // last percentage complete received
    UINT    currentphase;          // current chkdsk phase
    FMIFS   fmifs;                // ptr to FMIFS structure, above
    BOOL    fRecovery;             // Attempt to recover bad sectors
    BOOL    fFixErrors;            // Fix filesystem errors as found
    BOOL    fCancelled;            // Was chkdsk terminated early?
    BOOL    fShouldCancel;         // User has clicked cancel; pending abort
    HWND    hDlg;                  // handle to the chkdsk dialog
    HANDLE  hThread;
    BOOL    fNoFinalMsg;           // Do not put up a final failure message
    WCHAR   wszDriveName[MAX_PATH]; // For example, "A:\", or "C:\folder\mountedvolume\"
    LONG    cRef;                  // reference count on this structure
} CHKDSKINFO;

void AddRefChkDskInfo(CHKDSKINFO *pChkDskInfo)
{
    InterlockedIncrement(&pChkDskInfo->cRef);
}

void ReleaseChkDskInfo(CHKDSKINFO *pChkDskInfo)
{
    if (InterlockedDecrement(&pChkDskInfo->cRef) == 0) 
    {
        if (pChkDskInfo->fmifs.hFMIFS_DLL)
        {
            FreeLibrary(pChkDskInfo->fmifs.hFMIFS_DLL);
        }

        if (pChkDskInfo->hThread)
        {
            CloseHandle(pChkDskInfo->hThread);
        }

        LocalFree(pChkDskInfo);
    }
}


static DWORD g_iTLSChkDskInfo = 0;
static LONG  g_cTLSChkDskInfo = 0;  // Usage count

//
//  Synopsis:   Allocates a thread-local index slot for this thread's
//              CHKDSKINFO pointer, if the index doesn't already exist.
//              In any event, stores the CHKDSKINFO pointer in the slot
//              and increments the index's usage count.
//
//  Arguments:  [pChkDskInfo] -- The pointer to store
//
//  Returns:    HRESULT
//
//
// Thread-Local Storage index for our CHKDSKINFO structure pointer
//
HRESULT StuffChkDskInfoPtr(CHKDSKINFO *pChkDskInfo)
{
    HRESULT hr = S_OK;

    // Allocate an index slot for our thread-local CHKDSKINFO pointer, if one
    // doesn't already exist, then stuff our CHKDSKINFO ptr at that index.
    
    ENTERCRITICAL;
    if (0 == g_iTLSChkDskInfo)
    {
        g_iTLSChkDskInfo = TlsAlloc();

        if (g_iTLSChkDskInfo == (DWORD)-1)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        g_cTLSChkDskInfo = 0;
    }

    if (S_OK == hr)
    {
        if (TlsSetValue(g_iTLSChkDskInfo, (void *)pChkDskInfo))
        {
           g_cTLSChkDskInfo++;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    LEAVECRITICAL;

    return hr;
}

//
//  Synopsis:   Decrements the usage count on our thread-local storage
//              index, and if it goes to zero the index is free'd
//
//  Arguments:  [none]
//
//  Returns:    none
//
void UnstuffChkDskInfoPtr()
{
    ENTERCRITICAL;
    g_cTLSChkDskInfo--;

    if (g_cTLSChkDskInfo == 0)
    {
        TlsFree(g_iTLSChkDskInfo);
        g_iTLSChkDskInfo = 0;
    }
    LEAVECRITICAL;
}

//
//  Synopsis:   Retrieves this threads CHKDSKINFO ptr by grabbing the
//              thread-local value previously stuff'd
//
//  Arguments:  [none]
//
//  Returns:    The pointer, of course
//
CHKDSKINFO *GetChkDskInfoPtr()
{
    return (CHKDSKINFO *)TlsGetValue(g_iTLSChkDskInfo);
}

//
//  Synopsis:   Ghosts all controls except "Cancel", saving their
//              previous state in the CHKDSKINFO structure
//
//  Arguments:  [pChkDskInfo] -- Describes a ChkDsk dialog session
//
//  Notes:      Also changes "Close" button text to read "Cancel"
//
void DisableChkDskControls(CHKDSKINFO *pChkDskInfo)
{
    // We disable CANCEL because CHKDSK does not
    // allow interruption at the filesystem level.
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDC_FIXERRORS), FALSE);
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDC_RECOVERY), FALSE);
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDOK), FALSE);
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDCANCEL), FALSE);
}

//
//  Synopsis:   Restores controls to the enabled/disabled state they were
//              before a previous call to DisableControls().
//
//  Arguments:  [pChkDskInfo] -- Decribes a chkdsk dialog session
//
void EnableChkDskControls(CHKDSKINFO *pChkDskInfo)
{
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDC_FIXERRORS), TRUE);
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDC_RECOVERY), TRUE);
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDOK), TRUE);
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDCANCEL), TRUE);

    // Erase the current phase text
    SetWindowText(GetDlgItem(pChkDskInfo->hDlg, IDC_PHASE), TEXT(""));
    pChkDskInfo->lastpercent = 101;
    pChkDskInfo->currentphase = 0;
}

//
//  Synopsis:   Called from within the FMIFS DLL's ChkDsk function, this
//              updates the ChkDsk dialog's status bar and responds to
//              chkdsk completion/error notifications.
//
//  Arguments:  [PacketType]   -- Type of packet (ie: % complete, error, etc)
//              [PacketLength] -- Size, in bytes, of the packet
//              [pPacketData]  -- Pointer to the packet
//
//  Returns:    BOOLEAN continuation value
//
BOOLEAN ChkDskCallback(FMIFS_PACKET_TYPE PacketType, ULONG PacketLength, void *pPacketData)
{
    UINT iMessageID = IDS_CHKDSKFAILED;
    BOOL fFailed = FALSE;
    CHKDSKINFO* pChkDskInfo = GetChkDskInfoPtr();

    ASSERT(g_iTLSChkDskInfo);

    // Grab the CHKDSKINFO structure for this thread
    if (pChkDskInfo)
    {
        if (!pChkDskInfo->fShouldCancel)
        {
            switch(PacketType)
            {
                case FmIfsAccessDenied:
                    fFailed    = TRUE;
                    iMessageID = IDS_CHKACCESSDENIED;
                    break;

                case FmIfsCheckOnReboot:
                {
                    FMIFS_CHECKONREBOOT_INFORMATION * pRebootInfo = (FMIFS_CHECKONREBOOT_INFORMATION *)pPacketData;

                    // Check to see whether or not the user wants to schedule this
                    // chkdsk for the next reboot, since the drive cannot be locked
                    // right now.
                    if (IDYES == ShellMessageBox(HINST_THISDLL,
                                                 pChkDskInfo->hDlg,
                                                 MAKEINTRESOURCE(IDS_CHKONREBOOT),
                                                 NULL,
                                                 MB_SETFOREGROUND | MB_ICONINFORMATION | MB_YESNO))
                    {
                        // Yes, have FMIFS schedule an autochk for us
                        pRebootInfo->QueryResult = TRUE;
                        pChkDskInfo->fNoFinalMsg = TRUE;
                    }
                    else
                    {
                        // Nope, just fail out with "cant lock drive"
                        fFailed = TRUE;
                        iMessageID = IDS_CHKDSKFAILED;
                    }
                }
                break;

                case FmIfsMediaWriteProtected:
                    fFailed    = TRUE;
                    iMessageID = IDS_WRITEPROTECTED;
                    break;

                case FmIfsIoError:
                    fFailed    = TRUE;
                    iMessageID = IDS_IOERROR;
                    // FUTURE Consider showing head/track etc where error was
                    break;

                case FmIfsPercentCompleted:
                {
                    FMIFS_PERCENT_COMPLETE_INFORMATION* pPercent = (FMIFS_PERCENT_COMPLETE_INFORMATION *)pPacketData;

                    SendMessage(GetDlgItem(pChkDskInfo->hDlg, IDC_CHKDSKPROGRESS),
                                PBM_SETPOS,
                                pPercent->PercentCompleted, // updatee % complete
                                0);

                    if (pPercent->PercentCompleted < pChkDskInfo->lastpercent)
                    {
                        WCHAR wszTmp[100];
                        WCHAR wszFormat[100];
                        
                        // If this % complete is less than the last one seen,
                        // we have completed a phase of the chkdsk and should
                        // advance to the next one.
                        LoadString(HINST_THISDLL, IDS_CHKPHASE, wszFormat, ARRAYSIZE(wszFormat));
                        wsprintf(wszTmp, wszFormat, ++(pChkDskInfo->currentphase));
                        SetDlgItemText(pChkDskInfo->hDlg, IDC_PHASE, wszTmp);
                    }

                    pChkDskInfo->lastpercent = pPercent->PercentCompleted;
                }
                break;

                case FmIfsFinished:
                {
                    // ChkDsk is done; check for failure or success
                    FMIFS_FINISHED_INFORMATION * pFinishedInfo = (FMIFS_FINISHED_INFORMATION *) pPacketData;

                    // ChkDskEx now return the proper success value
                    if (pFinishedInfo->Success)
                    {
                        // Since we're done, force the progress gauge to 100%, so we
                        // don't sit here if the chkdsk code misled us
                        SendMessage(GetDlgItem(pChkDskInfo->hDlg, IDC_CHKDSKPROGRESS),
                                    PBM_SETPOS,
                                    100,    // Percent Complete
                                    0);

                        ShellMessageBox(HINST_THISDLL,
                                        pChkDskInfo->hDlg,
                                        MAKEINTRESOURCE(IDS_CHKDSKCOMPLETE),
                                        NULL,
                                        MB_SETFOREGROUND | MB_ICONINFORMATION | MB_OK);

                        SetDlgItemText(pChkDskInfo->hDlg, IDC_PHASE, TEXT(""));

                        SendMessage(GetDlgItem(pChkDskInfo->hDlg, IDC_CHKDSKPROGRESS),
                                    PBM_SETPOS,
                                    0,  // reset Percent Complete
                                    0);
                    }
                    else
                    {
                        iMessageID = IDS_CHKDSKFAILED;
                        fFailed = TRUE;
                    }
                }
                break;
            }

            // If we received any kind of failure information, put up a final
            // "ChkDsk Failed" message.
            if (fFailed && (pChkDskInfo->fNoFinalMsg == FALSE))
            {
                pChkDskInfo->fNoFinalMsg = TRUE;

                ShellMessageBox(HINST_THISDLL,
                                pChkDskInfo->hDlg,
                                MAKEINTRESOURCE(iMessageID),
                                NULL,
                                MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK);

            }

        }
        else
        {
            // If the user has signalled to abort the ChkDsk, return
            // FALSE out of here right now
            pChkDskInfo->fCancelled = TRUE;
            fFailed = TRUE;
        }
    }
    else
    {
        fFailed = TRUE;
    }

    return (BOOLEAN) (fFailed == FALSE);
}

void DoChkDsk(CHKDSKINFO* pChkDskInfo, LPWSTR pwszFileSystem)
{
    TCHAR szVolumeGUID[50]; // 50: from doc
    FMIFS_CHKDSKEX_PARAM param = {0};

    param.Major = 1;
    param.Minor = 0;
    param.Flags = pChkDskInfo->fRecovery ? FMIFS_CHKDSK_RECOVER : 0;

    GetVolumeNameForVolumeMountPoint(pChkDskInfo->wszDriveName,
                                     szVolumeGUID,
                                     ARRAYSIZE(szVolumeGUID));

    // the backslash at the end means check for fragmentation.
    PathRemoveBackslash(szVolumeGUID);

    pChkDskInfo->fmifs.ChkDskEx(szVolumeGUID,
                                pwszFileSystem,
                                (BOOLEAN)pChkDskInfo->fFixErrors,
                                &param,
                                ChkDskCallback);
}


//
//  Synopsis:   Spun off as its own thread, this ghosts all controls in the
//              dialog except "Cancel", then does the actual ChkDsk
//
//  Arguments:  [pIn] -- CHKDSKINFO structure pointer as a void *
//
//  Returns:    HRESULT thread exit code
//
DWORD WINAPI BeginChkDsk(void * pIn)
{
    CHKDSKINFO *pChkDskInfo = (CHKDSKINFO *)pIn;
    HRESULT hr;

    // Save the CHKDSKINFO ptr for this thread, to be used in the ChkDsk
    // callback function
    hr = StuffChkDskInfoPtr(pChkDskInfo);
    if (hr == S_OK)
    {
        WCHAR swzFileSystem[MAX_PATH];

        // Get the filesystem in use on the device
        if (GetVolumeInformationW(pChkDskInfo->wszDriveName,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL,
                                  NULL,
                                  swzFileSystem,
                                  MAX_PATH))
        {
            // Set the window title to indicate ChkDsk in proress...
            SetDriveWindowTitle(pChkDskInfo->hDlg, pChkDskInfo->wszDriveName, IDS_CHKINPROGRESS);

            pChkDskInfo->fNoFinalMsg = FALSE;

            // Should we try data recovery?
            pChkDskInfo->fRecovery = IsDlgButtonChecked(pChkDskInfo->hDlg, IDC_RECOVERY);

            // Should we fix filesystem errors?
            pChkDskInfo->fFixErrors = IsDlgButtonChecked(pChkDskInfo->hDlg, IDC_FIXERRORS);

            // just do it!
            DoChkDsk(pChkDskInfo, swzFileSystem);

        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        
        // Release the TLS index
        UnstuffChkDskInfoPtr();
    }

    PostMessage(pChkDskInfo->hDlg, (UINT) PWM_CHKDSKDONE, 0, 0);
    ReleaseChkDskInfo(pChkDskInfo);

    return (DWORD)hr;
}

//
//  Synopsis:   DLGPROC for the chkdsk dialog
//
//  Arguments:  [hDlg]   -- Typical
//              [wMsg]   -- Typical
//              [wParam] -- Typical
//              [lParam] -- For WM_INIT, carries the CHKDSKINFO structure
//                          pointer passed to DialogBoxParam() when the
//                          dialog was created.
//
BOOL_PTR CALLBACK ChkDskDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{ 
    HRESULT hr   = S_OK;
    int iID = GET_WM_COMMAND_ID(wParam, lParam);   

    // Grab our previously cached pointer to the CHKDSKINFO struct (see WM_INITDIALOG)
    CHKDSKINFO *pChkDskInfo = (CHKDSKINFO *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg)
    {
        // done.  Reset the window title and clear the progress meter
        case PWM_CHKDSKDONE:
        {
            // chdsk is done.  Reset the window title and clear the progress meter
            SetDriveWindowTitle(pChkDskInfo->hDlg, pChkDskInfo->wszDriveName, IDS_CHKDISK);

            SendMessage(GetDlgItem(pChkDskInfo->hDlg,
                        IDC_CHKDSKPROGRESS),
                        PBM_SETPOS,
                        0,  // Reset Percent Complete
                        0);
            EnableChkDskControls(pChkDskInfo);

            if (pChkDskInfo->fCancelled)
            {
                ShellMessageBox(HINST_THISDLL,
                                pChkDskInfo->hDlg,
                                MAKEINTRESOURCE(IDS_CHKDSKCANCELLED),
                                NULL,
                                MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK);
            }

            if (pChkDskInfo->hThread)
            {
                CloseHandle(pChkDskInfo->hThread);
                pChkDskInfo->hThread = NULL;
            }

            EndDialog(hDlg, 0);
        }
        break;

        case WM_INITDIALOG:
            // Initialize the dialog and cache the CHKDSKINFO structure's pointer
            // as our dialog's DWLP_USER data
            pChkDskInfo = (CHKDSKINFO *) lParam;
            pChkDskInfo->hDlg = hDlg;
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            // Set the dialog title to indicate which drive we are dealing with
            SetDriveWindowTitle(pChkDskInfo->hDlg, pChkDskInfo->wszDriveName, IDS_CHKDISK);
            break;

        case WM_DESTROY:
            if (pChkDskInfo && pChkDskInfo->hDlg)
            {
                pChkDskInfo->hDlg = NULL;
            }
            break;

        case WM_COMMAND:
        {
            switch (iID)
            {
                case IDC_FIXERRORS:
                    pChkDskInfo->fFixErrors = Button_GetCheck((HWND)lParam);
                    break;

                case IDC_RECOVERY:
                    pChkDskInfo->fRecovery = Button_GetCheck((HWND)lParam);
                    break;

                case IDOK:
                {
                    // Get user verification for chkdsk, break out on CANCEL
                    DisableChkDskControls(pChkDskInfo);

                    pChkDskInfo->fShouldCancel = FALSE;
                    pChkDskInfo->fCancelled    = FALSE;
                
                    AddRefChkDskInfo(pChkDskInfo);
                    pChkDskInfo->hThread = CreateThread(NULL,
                                                        0,
                                                        BeginChkDsk,
                                                        (void *)pChkDskInfo,
                                                        0,
                                                        NULL);
                    if (!pChkDskInfo->hThread)
                    {
                        // ISSUE: we should probably do something here...
                        ReleaseChkDskInfo(pChkDskInfo);
                    }
                }
                break;

                case IDCANCEL:
                {
                    // If the chdsk thread is running, wait for it.  If not,
                    // exit the dialog
                    pChkDskInfo->fCancelled = TRUE;
                    pChkDskInfo->fShouldCancel = TRUE;

                    if (pChkDskInfo->hThread)
                    {
                        DWORD dwWait;

                        do
                        {
                            dwWait =  WaitForSingleObject(pChkDskInfo->hThread, 10000);
                        }
                        while ((WAIT_TIMEOUT == dwWait) &&
                               (IDRETRY == ShellMessageBox(HINST_THISDLL,
                                                           hDlg,
                                                           MAKEINTRESOURCE(IDS_CANTCANCELCHKDSK),
                                                           NULL,
                                                           MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_RETRYCANCEL)));

                        // If the chkdsk doesn't admit to having been killed, it didn't
                        // give up peacefully.  Just abandon it and let it clean up
                        // when it finally gets around to it, at which point we will
                        // enable the controls to let the user take another stab.
                        //
                        // Careful:  The chkdsk may have cleaned up while the dialog box
                        // was up, so revalidate.
                        if (pChkDskInfo->hThread)
                        {
                            CloseHandle(pChkDskInfo->hThread);
                            pChkDskInfo->hThread = NULL;
                            pChkDskInfo->fCancelled = TRUE;
                            EnableChkDskControls(pChkDskInfo);
                        }
                    }
                    else
                    {
                        EndDialog(hDlg, IDCANCEL);
                    }
                }
                break;
            }
        }
        break;
    
        case WM_HELP:
            WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPSTR)ChkaIds);
            break;
        
        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)ChkaIds);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


#define GET_INTRESOURCE(r) (LOWORD((UINT_PTR)(r)))

static HDPA hpdaChkdskActive = NULL;

//
//  Synopsis:   Same as SHChkDskDrive but takes a path rather than a drive int ID
//              Call this fct for both path and drive int ID to be protected
//              against chkdsk'ing the same drive simultaneously
//
//  Arguments:  [hwnd]     -- Parent window (Must NOT be NULL)
//              [pszDrive] -- INTRESOURCE: string if mounted on folder, drive
//                            number if mounted on drive letter (0 based)
//
STDAPI_(DWORD) SHChkDskDriveEx(HWND hwnd, LPWSTR pszDrive)
{
    HRESULT hr = SHFMT_ERROR;
    WCHAR szUniqueID[50]; // 50: size of VolumeGUID, which can fit "A:\\" too

    CHKDSKINFO *pChkDskInfo = (CHKDSKINFO *)LocalAlloc(LPTR, sizeof(*pChkDskInfo));

    if (pChkDskInfo)
    {
        hr = S_OK;

        // We use a last percentage-complete value of 101, to guarantee that the
        // next one received will be less, indicating next (first) phase
        pChkDskInfo->lastpercent = 101;
        pChkDskInfo->cRef = 1;

        lstrcpyn(pChkDskInfo->wszDriveName, pszDrive, ARRAYSIZE(pChkDskInfo->wszDriveName));
        PathAddBackslash(pChkDskInfo->wszDriveName);

        // Prevent multiple chkdsks of the same drive
        GetVolumeNameForVolumeMountPoint(pChkDskInfo->wszDriveName, szUniqueID, ARRAYSIZE(szUniqueID));        

        // scoping ENTERCRITICAL's var definitions to make it cooperate with other ENTERCRITICAL
        {
            ENTERCRITICAL;
            if (!hpdaChkdskActive)
            {
                hpdaChkdskActive = DPA_Create(1);
            }

            if (hpdaChkdskActive)
            {
                int i, n = DPA_GetPtrCount(hpdaChkdskActive);

                // Go through the DPA of currently chkdsk'ed volumes, and check if we're already
                // processing this volume
                for (i = 0; i < n; ++i)
                {
                    LPWSTR pszUniqueID = (LPWSTR)DPA_GetPtr(hpdaChkdskActive, i);

                    if (pszUniqueID)
                    {
                        if (!lstrcmpi(szUniqueID, pszUniqueID))
                        {
                            // we're already chkdsk'ing this drive
                            hr = E_FAIL;
                            break;
                        }
                    }
                }

                // Looks like we're currently not chkdsk'ing this volume, add it to the DPA of currently
                // chkdsk'ed volumes
                if (S_OK == hr)
                {
                    LPWSTR pszUniqueID = StrDup(szUniqueID);
                    if (pszUniqueID)
                    {
                        if (-1 == DPA_AppendPtr(hpdaChkdskActive, pszUniqueID))
                        {
                             LocalFree((HLOCAL)pszUniqueID);

                             // if can't allocate room to store a pointer, pretty useless to go on
                             hr = E_FAIL;
                        }
                    }
                }
            }
            LEAVECRITICAL;
        }

        // Load the FMIFS DLL and open the ChkDsk dialog
        if (S_OK == hr)
        {
            if (S_OK == LoadFMIFS(&(pChkDskInfo->fmifs)))
            {
                INT_PTR ret;
                INITCOMMONCONTROLSEX icc = {sizeof(icc), ICC_PROGRESS_CLASS};
                InitCommonControlsEx(&icc);

                ret = DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_CHKDSK),
                                     hwnd, ChkDskDlgProc, (LPARAM) pChkDskInfo);
                if (-1 == ret)
                {
                    hr = E_UNEXPECTED;
                }
                else
                {
                    if (IDCANCEL == ret)
                    {
                        hr = S_FALSE;
                    }
                }
            }
            else
            {
                ASSERT(0 && "Can't load FMIFS.DLL");
                hr = E_OUTOFMEMORY;
            }

            // We're finish for this volume, remove from the list of currently processed volumes
            ENTERCRITICAL;
            if (hpdaChkdskActive)
            {
                int i, n = DPA_GetPtrCount(hpdaChkdskActive);

                for (i = 0; i < n; ++i)
                {
                    LPWSTR pszUniqueID = (LPWSTR)DPA_GetPtr(hpdaChkdskActive, i);
                    if (pszUniqueID)
                    {
                        if (!lstrcmpi(szUniqueID, pszUniqueID))
                        {
                            LocalFree((HLOCAL)pszUniqueID);

                            DPA_DeletePtr(hpdaChkdskActive, i);
                            break;
                        }
                    }
                }
            }
            LEAVECRITICAL;
        }

        // If the DPA is empty delete it
        ENTERCRITICAL;
        if (hpdaChkdskActive && !DPA_GetPtrCount(hpdaChkdskActive))
        {
            DPA_Destroy(hpdaChkdskActive);
            hpdaChkdskActive = NULL;
        }
        LEAVECRITICAL;

        ReleaseChkDskInfo(pChkDskInfo);
    }

    return (DWORD) hr;
}

//****************************************************************************
//
//  Special hook for Win9x app compat
//
//  Some Win9x apps like to WinExec("DEFRAG") or WinExec("SCANDSKW")
//  even though those apps don't exist on Windows NT.  When such apps
//  are found, we can shim them to come here instead.
BOOL ScanDskW_OnInitDialog(HWND hdlg)
{
    HICON hico;
    HWND hwndList;
    SHFILEINFO sfi;
    HIMAGELIST himlSys;
    RECT rc;
    LVCOLUMN lvc;
    int iDrive;
    TCHAR szDrive[4];

    hico = (HICON)SendDlgItemMessage(hdlg, IDC_SCANDSKICON, STM_GETICON, 0, 0);
    SendMessage(hdlg, WM_SETICON, ICON_BIG, (LPARAM)hico);
    SendMessage(hdlg, WM_SETICON, ICON_SMALL, (LPARAM)hico);

    hwndList = GetDlgItem(hdlg, IDC_SCANDSKLV);

    if (Shell_GetImageLists(NULL, &himlSys))
    {
        ListView_SetImageList(hwndList, himlSys, LVSIL_SMALL);
    }

    GetClientRect(hwndList, &rc);

    lvc.mask = LVCF_WIDTH;
    lvc.cx = rc.right;
    lvc.iSubItem = 0;
    ListView_InsertColumn(hwndList, 0, &lvc);

    for (iDrive = 0; iDrive < 26; iDrive++)
    {
        PathBuildRoot(szDrive, iDrive);
        switch (GetDriveType(szDrive))
        {
        case DRIVE_UNKNOWN:
        case DRIVE_NO_ROOT_DIR:
        case DRIVE_REMOTE:
        case DRIVE_CDROM:
            break;          // Can't scan these drives

        default:
            if (SHGetFileInfo(szDrive, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi),
                              SHGFI_USEFILEATTRIBUTES |
                              SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_DISPLAYNAME))
            {
                LVITEM lvi;
                lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                lvi.iItem = MAXLONG;
                lvi.iSubItem = 0;
                lvi.pszText = sfi.szDisplayName;
                lvi.iImage = sfi.iIcon;
                lvi.lParam = iDrive;
                ListView_InsertItem(hwndList, &lvi);
            }
            break;
        }

    }

    return TRUE;
}

void ScanDskW_OnOk(HWND hdlg)
{
    HWND hwndList = GetDlgItem(hdlg, IDC_SCANDSKLV);

    LVITEM lvi;
    lvi.iItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    if (lvi.iItem >= 0)
    {
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM;
        if (ListView_GetItem(hwndList, &lvi))
        {
            TCHAR szDrive[4];
            PathBuildRoot(szDrive, (int)lvi.lParam);
            SHChkDskDriveEx(hdlg, szDrive);
        }
    }
}

INT_PTR CALLBACK
ScanDskW_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm)
    {
        case WM_INITDIALOG:
            return ScanDskW_OnInitDialog(hdlg);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    ScanDskW_OnOk(hdlg);
                    break;

                case IDCANCEL:
                    EndDialog(hdlg, 0);
                    break;
            }
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnm = (LPNMHDR)lParam;
            if (pnm->code == LVN_ITEMCHANGED)
            {
                EnableWindow(GetDlgItem(hdlg, IDOK), ListView_GetSelectedCount(GetDlgItem(hdlg, IDC_SCANDSKLV)));
            }
        }
        break;
    }

    return FALSE;
}

// Right now, we have only one app compat shim entry point (SCANDSKW)
// In the future we can add others to the command line.

STDAPI_(void) AppCompat_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    TCHAR szCmd[MAX_PATH];
    LPTSTR pszArgs;

    lstrcpyn(szCmd, lpwszCmdLine, ARRAYSIZE(szCmd));
    pszArgs = PathGetArgs(szCmd);
    PathRemoveArgs(szCmd);


    if (lstrcmpi(szCmd, L"SCANDSKW") == 0) {
        DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_SCANDSKW), NULL,
                       ScanDskW_DlgProc, (LPARAM)pszArgs);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fsdata.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "datautil.h"
#include "brfcase.h"
#include "views.h"
#include "fsdata.h"

//
// This function is called from CFSIDLData_GetData().
//
// Paramters:
//  this    -- Specifies the IDLData object (selected objects)
//  pmedium -- Pointer to STDMEDIUM to be filled; NULL if just querying.
//
HRESULT CFSIDLData::_GetNetResource(STGMEDIUM *pmedium)
{
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(this, &medium);
    if (pida)
    {
        BOOL bIsMyNet = IsIDListInNameSpace(IDA_GetIDListPtr(pida, (UINT)-1), &CLSID_NetworkPlaces);

        HIDA_ReleaseStgMedium(pida, &medium);

        if (!bIsMyNet)
            return DV_E_FORMATETC;

        if (!pmedium)
            return S_OK; // query, yes we have it

        return CNetData_GetNetResourceForFS(this, pmedium);
    }
    return E_FAIL;
}

HRESULT CFSIDLData::QueryGetData(FORMATETC *pformatetc)
{
    if (pformatetc->tymed & TYMED_HGLOBAL)
    {
        if (pformatetc->cfFormat == CF_HDROP)
        {
            return S_OK; 
        }
        else if (pformatetc->cfFormat == g_cfFileNameA)
        {
            return S_OK;
        }
        else if (pformatetc->cfFormat == g_cfFileNameW)
        {
            return S_OK;
        }
        else if (pformatetc->cfFormat == g_cfNetResource)
        {
            return _GetNetResource(NULL);
        }
    }

    return CIDLDataObj::QueryGetData(pformatetc);
}

HRESULT CFSIDLData::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    HRESULT hr = CIDLDataObj::SetData(pformatetc, pmedium, fRelease);

    // this enables:
    //      1) in the shell "cut" some files
    //      2) in an app "paste" to copy the data
    //      3) here we complete the "cut" by deleting the files

    if ((pformatetc->cfFormat == g_cfPasteSucceeded) &&
        (pformatetc->tymed == TYMED_HGLOBAL))
    {
        DWORD *pdw = (DWORD *)GlobalLock(pmedium->hGlobal);
        if (pdw)
        {
            // NOTE: the old code use g_cfPerformedDropEffect == DROPEFFECT_MOVE here
            // so to work on downlevel shells be sure to set the "Performed Effect" before
            // using "Paste Succeeded".

            // complete the "unoptimized move"
            if (DROPEFFECT_MOVE == *pdw)
            {
                DeleteFilesInDataObject(NULL, CMIC_MASK_FLAG_NO_UI, this, 0);
            }
            GlobalUnlock(pmedium->hGlobal);
        }
    }
    return hr;
}

// Creates CF_HDROP clipboard format block of memory (HDROP) from HIDA in data object

HRESULT CFSIDLData::CreateHDrop(STGMEDIUM *pmedium, BOOL fAltName)
{
    ZeroMemory(pmedium, sizeof(*pmedium));

    HRESULT hr;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(this, &medium);
    if (pida)
    {
        LPCITEMIDLIST pidlFolder = HIDA_GetPIDLFolder(pida);
        ASSERT(pidlFolder);

        IShellFolder *psf;
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf));
        if (SUCCEEDED(hr))
        {
            // Allocate too much to start out with, then re-alloc when we are done
            UINT cbAlloc = sizeof(DROPFILES) + sizeof(TCHAR);        // header + null terminator
            pmedium->hGlobal = GlobalAlloc(GPTR, cbAlloc + pida->cidl * MAX_PATH * sizeof(TCHAR));
            if (pmedium->hGlobal)
            {
                DROPFILES *pdf = (DROPFILES *)pmedium->hGlobal;
                LPTSTR pszFiles = (LPTSTR)(pdf + 1);
                pdf->pFiles = sizeof(DROPFILES);
                pdf->fWide = (sizeof(TCHAR) == sizeof(WCHAR));

                for (UINT i = 0; i < pida->cidl; i++)
                {
                    LPCITEMIDLIST pidlItem = HIDA_GetPIDLItem(pida, i);

                    // If we run across the Desktop pidl, then punt because it's
                    // not a file
                    if (ILIsEmpty(pidlItem) && ILIsEmpty(pidlFolder))
                    {
                        hr = DV_E_CLIPFORMAT; // No hdrop for you!
                        break;
                    }

                    ASSERT(ILIsEmpty(_ILNext(pidlItem)) || ILIsEmpty(pidlFolder)); // otherwise GDNO will fail

                    TCHAR szPath[MAX_PATH];
                    hr = DisplayNameOf(psf, pidlItem, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath));
                    if (FAILED(hr))
                        break;  // something bad happened

                    if (fAltName)
                        GetShortPathName(szPath, szPath, ARRAYSIZE(szPath));

                    int cch = lstrlen(szPath) + 1;

                    // prevent buffer overrun
                    if ((LPBYTE)(pszFiles + cch) > ((LPBYTE)pmedium->hGlobal) + cbAlloc + pida->cidl * MAX_PATH * sizeof(TCHAR))
                    {
                        TraceMsg(TF_WARNING, "hdrop:%d'th file caused us to exceed allocated memory, breaking", i);
                        break;
                    }
                    lstrcpy(pszFiles, szPath); // will write NULL terminator for us
                    pszFiles += cch;
                    cbAlloc += cch * sizeof(TCHAR);
                }

                if (SUCCEEDED(hr))
                {
                    *pszFiles = 0; // double NULL terminate
                    ASSERT((LPTSTR)((BYTE *)pdf + cbAlloc - sizeof(TCHAR)) == pszFiles);

                    // re-alloc down to the amount we actually need
                    // note that pdf and pszFiles are now both invalid (and not used anymore)
                    pmedium->hGlobal = GlobalReAlloc(pdf, cbAlloc, GMEM_MOVEABLE);

                    // If realloc failed, then just use the original buffer.  It's
                    // a bit wasteful of memory but it's all we've got.
                    if (!pmedium->hGlobal)
                        pmedium->hGlobal = (HGLOBAL)pdf;

                    pmedium->tymed = TYMED_HGLOBAL;
                }
                else
                {
                    GlobalFree(pmedium->hGlobal);
                    pmedium->hGlobal = NULL;
                }
            }
            else
                hr = E_OUTOFMEMORY;

            psf->Release();
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    else
        hr = E_FAIL;

    return hr;
}

// Attempt to get the HDrop format: Create one from the HIDA if necessary
HRESULT CFSIDLData::GetHDrop(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    STGMEDIUM tempmedium;
    HRESULT hr = CIDLDataObj::GetData(pformatetcIn, &tempmedium);
    if (FAILED(hr))
    {
        // Couldn't get HDROP format, create it
        // Set up a dummy formatetc to save in case multiple tymed's were specified
        FORMATETC fmtTemp = *pformatetcIn;
        fmtTemp.tymed = TYMED_HGLOBAL;

        hr = CreateHDrop(&tempmedium, pformatetcIn->dwAspect == DVASPECT_SHORTNAME);
        if (SUCCEEDED(hr))
        {
            // And we also want to cache this new format
            // .. Ensure that we actually free the memory associated with the HDROP
            //    when the data object destructs (pUnkForRelease = NULL)
            ASSERT(tempmedium.pUnkForRelease == NULL);

            if (SUCCEEDED(SetData(&fmtTemp, &tempmedium, TRUE)))
            {
                // Now the old medium that we just set is owned by the data object - call
                // GetData to get a medium that is safe to release when we're done.
                hr = CIDLDataObj::GetData(pformatetcIn, &tempmedium);
            }
            else
            {
                TraceMsg(TF_WARNING, "Couldn't save the HDrop format to the data object - returning private version");
            }
        }
    }

    // HACKHACK
    // Some context menu extensions just release the hGlobal instead of
    // calling ReleaseStgMedium. This causes a reference counted data
    // object to fail. Therefore, we always allocate a new HGLOBAL for
    // each request.  Unfortunately necessary because Quickview
    // Pro does this.
    //
    // Ideally we'd like to set the pUnkForRelease and not have to
    // dup the hGlobal each time, but alas Quickview has called our bluff
    // and GlobalFree()'s it.
    if (SUCCEEDED(hr))
    {
        if (pmedium)
        {
            *pmedium = tempmedium;
            pmedium->pUnkForRelease = NULL;

            // Make a copy of this hglobal to pass back
            SIZE_T cbhGlobal = GlobalSize(tempmedium.hGlobal);
            if (cbhGlobal)
            {
                pmedium->hGlobal = GlobalAlloc(0, (UINT) cbhGlobal);
                if (pmedium->hGlobal)
                {
                    CopyMemory(pmedium->hGlobal, tempmedium.hGlobal, cbhGlobal);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }

        ReleaseStgMedium(&tempmedium);
    }

    return hr;
}

// subclass member function to support CF_HDROP and CF_NETRESOURCE

HRESULT CFSIDLData::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    HRESULT hr = E_INVALIDARG;

    // If we don't zero out the pmedium then breifcase will fault on win9x.  Breifcase tries
    // to free this medium even if this function returns an error.  Not all paths below correctly
    // set the pmedium in all cases.
    ZeroMemory(pmedium, sizeof(*pmedium));

    if ((pformatetcIn->cfFormat == CF_HDROP) && (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        hr = GetHDrop(pformatetcIn, pmedium);
    }
    else if ((pformatetcIn->cfFormat == g_cfFileNameA || pformatetcIn->cfFormat == g_cfFileNameW) && 
             (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        FORMATETC format = *pformatetcIn;
        BOOL bUnicode = pformatetcIn->cfFormat == g_cfFileNameW;

        // assume g_cfFileNameA clients want short name
        if (pformatetcIn->cfFormat == g_cfFileNameA)
            format.dwAspect = DVASPECT_SHORTNAME;

        STGMEDIUM medium;
        hr = GetHDrop(&format, &medium);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            if (DragQueryFile((HDROP)medium.hGlobal, 0, szPath, ARRAYSIZE(szPath)))
            {
                UINT cch = lstrlen(szPath) + 1;
                UINT uSize = cch * (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));

                pmedium->hGlobal = GlobalAlloc(GPTR, uSize);
                if (pmedium->hGlobal)
                {
                    if (bUnicode)
                        SHTCharToUnicode(szPath, (LPWSTR)pmedium->hGlobal, cch);
                    else
                        SHTCharToAnsi(szPath, (LPSTR)pmedium->hGlobal, uSize);

                    pmedium->tymed = TYMED_HGLOBAL;
                    pmedium->pUnkForRelease = NULL;
                    hr = S_OK;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = E_UNEXPECTED;
            }
            ReleaseStgMedium(&medium);
        }
    }
    else if (pformatetcIn->cfFormat == g_cfNetResource && (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        hr = _GetNetResource(pmedium);
    }
    else
    {
        hr = CIDLDataObj::GetData(pformatetcIn, pmedium);
    }
    return hr;
}

STDAPI SHCreateFileDataObject(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl,
                              IDataObject *pdtInner, IDataObject **ppdtobj)
{
    *ppdtobj = new CFSIDLData(pidlFolder, cidl, apidl, pdtInner);
    return *ppdtobj ? S_OK : E_OUTOFMEMORY;
}

/*
Purpose: Gets the root path of the briefcase storage and copies
it into the buffer.

  This function obtains the briefcase storage root by
  binding to an IShellFolder (briefcase) instance of the
  pidl.  This parent is be an CFSBrfFolder *, so we can
  call the IBriefcaseStg::GetExtraInfo member function.
  
    Returns: standard result
    Cond:    --
*/
HRESULT GetBriefcaseRoot(LPCITEMIDLIST pidl, LPTSTR pszBuf, int cchBuf)
{
    IBriefcaseStg *pbrfstg;
    HRESULT hr = CreateBrfStgFromIDList(pidl, NULL, &pbrfstg);
    if (SUCCEEDED(hr))
    {
        hr = pbrfstg->GetExtraInfo(NULL, GEI_ROOT, (WPARAM)cchBuf, (LPARAM)pszBuf);
        pbrfstg->Release();
    }
    return hr;
}

// Packages a BriefObj struct into pmedium from a HIDA.

HRESULT CBriefcaseData_GetBriefObj(IDataObject *pdtobj, STGMEDIUM *pmedium)
{
    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST pidl = ILCreate();
    if (pidl)
    {
        STGMEDIUM medium;
        
        if (DataObj_GetHIDA(pdtobj, &medium))
        {
            UINT cFiles = HIDA_GetCount(medium.hGlobal);
            // "cFiles+1" includes the briefpath...
            UINT cbSize = sizeof(BriefObj) + MAX_PATH * sizeof(TCHAR) * (cFiles + 1)  + 1;
            
            PBRIEFOBJ pbo = (PBRIEFOBJ)GlobalAlloc(GPTR, cbSize);
            if (pbo)
            {
                LPITEMIDLIST pidlT;
                LPTSTR pszFiles = (LPTSTR)((LPBYTE)pbo + _IOffset(BriefObj, data));
                
                pbo->cbSize = cbSize;
                pbo->cItems = cFiles;
                pbo->cbListSize = MAX_PATH * sizeof(TCHAR) * cFiles + 1;
                pbo->ibFileList = _IOffset(BriefObj, data);
                
                for (UINT i = 0; i < cFiles; i++)
                {
                    pidlT = HIDA_FillIDList(medium.hGlobal, i, pidl);
                    if (NULL == pidlT)
                        break;      // out of memory
                    
                    pidl = pidlT;
                    SHGetPathFromIDList(pidl, pszFiles);
                    pszFiles += lstrlen(pszFiles)+1;
                }
                *pszFiles = TEXT('\0');
                
                if (i < cFiles)
                {
                    // Out of memory, fail
                    ASSERT(NULL == pidlT);
                }
                else
                {
                    // Make pszFiles point to beginning of szBriefPath buffer
                    pszFiles++;
                    pbo->ibBriefPath = (UINT) ((LPBYTE)pszFiles - (LPBYTE)pbo);
                    pidlT = HIDA_FillIDList(medium.hGlobal, 0, pidl);
                    if (pidlT)
                    {
                        pidl = pidlT;
                        hr = GetBriefcaseRoot(pidl, pszFiles, MAX_PATH);
                        
                        pmedium->tymed = TYMED_HGLOBAL;
                        pmedium->hGlobal = pbo;
                        
                        // Indicate that the caller should release hmem.
                        pmedium->pUnkForRelease = NULL;
                    }
                }
            }
            
            HIDA_ReleaseStgMedium(NULL, &medium);
        }
        ILFree(pidl);
    }
    return hr;
}

class CBriefcaseData : public CFSIDLData
{
public:
    CBriefcaseData(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[]): CFSIDLData(pidlFolder, cidl, apidl, NULL) { };

    // IDataObject
    STDMETHODIMP GetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
    STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);
};

STDMETHODIMP CBriefcaseData::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    HRESULT hr;
    
    if (pformatetcIn->cfFormat == g_cfBriefObj && (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        hr = CBriefcaseData_GetBriefObj(this, pmedium);
    }
    else
    {
        hr = CFSIDLData::GetData(pformatetcIn, pmedium);
    }
    
    return hr;
}

// IDataObject::QueryGetData

STDMETHODIMP CBriefcaseData::QueryGetData(FORMATETC *pformatetc)
{
    if (pformatetc->cfFormat == g_cfBriefObj && (pformatetc->tymed & TYMED_HGLOBAL))
        return S_OK;
    
    return CFSIDLData::QueryGetData(pformatetc);
}

STDAPI CBrfData_CreateDataObj(LPCITEMIDLIST pidl, UINT cidl, LPCITEMIDLIST *ppidl, IDataObject **ppdtobj)
{
    *ppdtobj = new CBriefcaseData(pidl, cidl, ppidl);
    return *ppdtobj ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fsdrptgt.cpp ===
#include "shellprv.h"
#include <cowsite.h>
#include "datautil.h"
#include "ids.h"
#include "defview.h"
#include "_security.h"
#include "shitemid.h"
#include "idlcomm.h"
#include "bitbuck.h"
#include "bookmk.h"
#include "filefldr.h"
#include "brfcase.h"
#include "copy.h"
#include "filetbl.h"

#define TF_DRAGDROP 0x04000000


typedef struct
{
    HWND    hwnd;
    DWORD   dwFlags;
    POINTL  pt;
    CHAR    szUrl[INTERNET_MAX_URL_LENGTH];
} ADDTODESKTOP;


DWORD CALLBACK AddToActiveDesktopThreadProc(void *pv)
{
    ADDTODESKTOP* pToAD = (ADDTODESKTOP*)pv;
    CHAR szFilePath[MAX_PATH];
    DWORD cchFilePath = SIZECHARS(szFilePath);
    BOOL fAddComp = TRUE;

    if (SUCCEEDED(PathCreateFromUrlA(pToAD->szUrl, szFilePath, &cchFilePath, 0)))
    {
        TCHAR szPath[MAX_PATH];

        SHAnsiToTChar(szFilePath, szPath, ARRAYSIZE(szPath));

        // If the Url is in the Temp directory
        if (PathIsTemporary(szPath))
        {
            if (IDYES == ShellMessageBox(g_hinst, pToAD->hwnd, MAKEINTRESOURCE(IDS_REASONS_URLINTEMPDIR),
                MAKEINTRESOURCE(IDS_AD_NAME), MB_YESNO | MB_ICONQUESTION))
            {
                TCHAR szFilter[64], szTitle[64];
                TCHAR szFilename[MAX_PATH];
                LPTSTR psz;
                OPENFILENAME ofn = { 0 };

                LoadString(g_hinst, IDS_ALLFILESFILTER, szFilter, ARRAYSIZE(szFilter));
                LoadString(g_hinst, IDS_SAVEAS, szTitle, ARRAYSIZE(szTitle));

                psz = szFilter;

                //Strip out the # and make them Nulls for SaveAs Dialog
                while (*psz)
                {
                    if (*psz == (WCHAR)('#'))
                        *psz = (WCHAR)('\0');
                    psz++;
                }

                lstrcpy(szFilename, PathFindFileName(szPath));

                ofn.lStructSize = sizeof(OPENFILENAME);
                ofn.hwndOwner = pToAD->hwnd;
                ofn.hInstance = g_hinst;
                ofn.lpstrFilter = szFilter;
                ofn.lpstrFile = szFilename;
                ofn.nMaxFile = ARRAYSIZE(szFilename);
                ofn.lpstrTitle = szTitle;
                ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

                if (GetSaveFileName(&ofn))
                {
                    SHFILEOPSTRUCT sfo = { 0 };

                    szPath[lstrlen(szPath) + 1] = 0;
                    ofn.lpstrFile[lstrlen(ofn.lpstrFile) + 1] = 0;

                    sfo.hwnd = pToAD->hwnd;
                    sfo.wFunc = FO_COPY;
                    sfo.pFrom = szPath;
                    sfo.pTo = ofn.lpstrFile;

                    cchFilePath = SIZECHARS(szPath);
                    if (SHFileOperation(&sfo) == 0 &&
                        SUCCEEDED(UrlCreateFromPath(szPath, szPath, &cchFilePath, 0)))
                    {
                        SHTCharToAnsi(szPath, pToAD->szUrl, ARRAYSIZE(pToAD->szUrl));
                    }
                    else
                        fAddComp = FALSE;
                }
                else
                    fAddComp = FALSE;
            }
            else
                fAddComp = FALSE;
        }
    }
    if (fAddComp)
        CreateDesktopComponents(pToAD->szUrl, NULL, pToAD->hwnd, pToAD->dwFlags, pToAD->pt.x, pToAD->pt.y);

    LocalFree((HLOCAL)pToAD);

    return 0;
}

typedef struct {
    DWORD        dwDefEffect;
    IDataObject *pdtobj;
    POINTL       pt;
    DWORD *      pdwEffect;
    HKEY         rghk[MAX_ASSOC_KEYS];
    DWORD        ck;
    HMENU        hmenu;
    UINT         idCmd;
    DWORD        grfKeyState;
} FSDRAGDROPMENUPARAM;

typedef struct
{
    HMENU   hMenu;
    UINT    uCopyPos;
    UINT    uMovePos;
    UINT    uLinkPos;
} FSMENUINFO;


class CFSDropTarget : CObjectWithSite, public IDropTarget
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject* pdtobj, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject* pdtobj, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

    CFSDropTarget(CFSFolder *pFolder, HWND hwnd);

protected:
    virtual ~CFSDropTarget();
    BOOL _IsBriefcaseTarget() { return IsEqualCLSID(_pFolder->_clsidBind, CLSID_BriefcaseFolder); };

    BOOL _IsDesktopFolder() { return _GetIDList() && ILIsEmpty(_GetIDList()); };
    
    HRESULT _FilterFileContents(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                   DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterFileContentsOLEHack(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                   DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterDeskCompHDROP(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                    DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterSneakernetBriefcase(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterBriefcase(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                        DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterHDROP(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                            DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterHIDA(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                           DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterDeskImage(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterDeskComp(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                               DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterOlePackage(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                 DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterOleObj(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                             DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterOleLink(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                              DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    
    DWORD _FilesystemAdjustedDefaultEffect(DWORD dwCurEffectAvail);
    HRESULT _GetPath(LPTSTR pszPath);
    LPCITEMIDLIST _GetIDList();
    DWORD _LimitDefaultEffect(DWORD dwDefEffect, DWORD dwEffectsAllowed);
    DWORD _GetDefaultEffect(DWORD grfKeyState, DWORD dwCurEffectAvail, DWORD dwAllEffectAvail, DWORD dwOrigDefEffect);
    DWORD _DetermineEffects(DWORD grfKeyState, DWORD *pdwEffectInOut, HMENU hmenu);
    DWORD _EffectFromFolder();

    typedef struct
    {
        CFSDropTarget *pThis;
        IStream *pstmDataObj;
        IStream *pstmFolderView;
    } DROPTHREADPARAMS;

    static void _FreeThreadParams(DROPTHREADPARAMS *pdtp);

    static DWORD CALLBACK _DoDropThreadProc(void *pv);
    void _DoDrop(IDataObject *pdtobj, IFolderView* pfv);
    static void _AddVerbs(DWORD* pdwEffects, DWORD dwEffectAvail, DWORD dwDefEffect,
                          UINT idCopy, UINT idMove, UINT idLink,
                          DWORD dwForceEffect, FSMENUINFO* pfsMenuInfo);
    void _FixUpDefaultItem(HMENU hmenu, DWORD dwDefEffect);
    HRESULT _DragDropMenu(FSDRAGDROPMENUPARAM *pddm);

    HRESULT _CreatePackage(IDataObject *pdtobj);
    HRESULT _CreateURLDeskComp(IDataObject *pdtobj, POINTL pt);
    HRESULT _CreateDeskCompImage(IDataObject *pdtobj, POINTL pt);
    void _GetStateFromSite();
    BOOL _IsFromSneakernetBriefcase();
    BOOL _IsFromSameBriefcase();
    void _MoveCopy(IDataObject *pdtobj, IFolderView* pfv, HDROP hDrop);
    void _MoveSelectIcons(IDataObject *pdtobj, IFolderView* pfv, void *hNameMap, LPCTSTR pszFiles, BOOL fMove, HDROP hDrop);

    LONG            _cRef;
    CFSFolder       *_pFolder;
    HWND            _hwnd;                  // EVIL: used as a site and UI host
    UINT            _idCmd;
    DWORD           _grfKeyStateLast;       // for previous DragOver/Enter
    IDataObject     *_pdtobj;               // used durring Dragover() and DoDrop(), don't use on background thread
    DWORD           _dwEffectLastReturned;  // stashed effect that's returned by base class's dragover
    DWORD           _dwEffect;
    DWORD           _dwData;                // DTID_*
    DWORD           _dwEffectPreferred;     // if dwData & DTID_PREFERREDEFFECT
    DWORD           _dwEffectFolder;        // folder desktop.ini preferred effect
    BOOL            _fSameHwnd;             // the drag source and target are the same folder
    BOOL            _fDragDrop;             // 
    BOOL            _fUseExactDropPoint;    // Don't transform the drop point. The target knows exactly where it wants things.
    BOOL            _fBkDropTarget;
    POINT           _ptDrop;
    IFolderView*    _pfv;

    typedef struct {
        FORMATETC fmte;
        HRESULT (CFSDropTarget::*pfnGetDragDropInfo)(
                                      IN FORMATETC* pfmte,
                                      IN DWORD grfKeyFlags,
                                      IN DWORD dwEffectsAvail,
                                      IN OUT DWORD* pdwEffectsUsed,
                                      OUT DWORD* pdwDefaultEffect,
                                      IN OUT FSMENUINFO* pfsMenuInfo);
        CLIPFORMAT *pcfInit;
    } _DATA_HANDLER;

    // HACKHACK:  C++ doesn't let you initialize statics inside a class
    //            definition, and also doesn't let you specify an empty
    //            size (i.e., rg_data_handlers[]) inside a class definition
    //            either, so we have to have this bogus NUM_DATA_HANDLERS
    //            symbol that must manually be kept in sync.

    enum { NUM_DATA_HANDLERS = 16 };
    static _DATA_HANDLER rg_data_handlers[NUM_DATA_HANDLERS];
    static void _Init_rg_data_handlers();

private:
    friend HRESULT CFSDropTarget_CreateInstance(CFSFolder* pFolder, HWND hwnd, IDropTarget** ppdt);
};

CFSDropTarget::CFSDropTarget(CFSFolder *pFolder, HWND hwnd) : _cRef(1), _hwnd(hwnd), _pFolder(pFolder), _dwEffectFolder(-1)
{
    ASSERT(0 == _grfKeyStateLast);
    ASSERT(NULL == _pdtobj);
    ASSERT(0 == _dwEffectLastReturned);
    ASSERT(0 == _dwData);
    ASSERT(0 == _dwEffectPreferred);
    _pFolder->AddRef();
}

CFSDropTarget::~CFSDropTarget()
{
    AssertMsg(_pdtobj == NULL, TEXT("didn't get matching DragLeave, fix that bug"));

    ATOMICRELEASE(_pdtobj);
    ATOMICRELEASE(_pfv);

    _pFolder->Release();
}

STDAPI CFSDropTarget_CreateInstance(CFSFolder* pFolder, HWND hwnd, IDropTarget** ppdt)
{
    *ppdt = new CFSDropTarget(pFolder, hwnd);
    return *ppdt ? S_OK : E_OUTOFMEMORY;
}

HRESULT CFSDropTarget::QueryInterface(REFIID riid, void** ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CFSDropTarget, IDropTarget),
        QITABENT(CFSDropTarget, IObjectWithSite),
        QITABENTMULTI2(CFSDropTarget, IID_IDropTargetWithDADSupport, IDropTarget),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CFSDropTarget::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFSDropTarget::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

void CFSDropTarget::_FreeThreadParams(DROPTHREADPARAMS *pdtp)
{
    pdtp->pThis->Release();
    ATOMICRELEASE(pdtp->pstmDataObj);
    ATOMICRELEASE(pdtp->pstmFolderView);
    LocalFree(pdtp);
}


// compute DTID_ bit flags from the data object to make format testing easier for
// DragOver() and Drop() code

STDAPI GetClipFormatFlags(IDataObject *pdtobj, DWORD *pdwData, DWORD *pdwEffectPreferred)
{
    *pdwData = 0;
    *pdwEffectPreferred = 0;

    if (pdtobj)
    {
        IEnumFORMATETC *penum;
        if (SUCCEEDED(pdtobj->EnumFormatEtc(DATADIR_GET, &penum)))
        {
            FORMATETC fmte;
            ULONG celt;
            while (S_OK == penum->Next(1, &fmte, &celt))
            {
                if (fmte.cfFormat == CF_HDROP && (fmte.tymed & TYMED_HGLOBAL))
                    *pdwData |= DTID_HDROP;

                if (fmte.cfFormat == g_cfHIDA && (fmte.tymed & TYMED_HGLOBAL))
                    *pdwData |= DTID_HIDA;

                if (fmte.cfFormat == g_cfNetResource && (fmte.tymed & TYMED_HGLOBAL))
                    *pdwData |= DTID_NETRES;

                if (fmte.cfFormat == g_cfEmbeddedObject && (fmte.tymed & TYMED_ISTORAGE))
                    *pdwData |= DTID_EMBEDDEDOBJECT;

                if (fmte.cfFormat == g_cfFileContents && (fmte.tymed & (TYMED_HGLOBAL | TYMED_ISTREAM | TYMED_ISTORAGE)))
                    *pdwData |= DTID_CONTENTS;
                
                if (fmte.cfFormat == g_cfFileGroupDescriptorA && (fmte.tymed & TYMED_HGLOBAL))
                    *pdwData |= DTID_FDESCA;

                if (fmte.cfFormat == g_cfFileGroupDescriptorW && (fmte.tymed & TYMED_HGLOBAL))
                    *pdwData |= DTID_FDESCW;

                if ((fmte.cfFormat == g_cfPreferredDropEffect) &&
                    (fmte.tymed & TYMED_HGLOBAL) &&
                    (DROPEFFECT_NONE != (*pdwEffectPreferred = DataObj_GetDWORD(pdtobj, g_cfPreferredDropEffect, DROPEFFECT_NONE))))
                {
                    *pdwData |= DTID_PREFERREDEFFECT;
                }
#ifdef DEBUG
                TCHAR szFormat[MAX_PATH];
                if (GetClipboardFormatName(fmte.cfFormat, szFormat, ARRAYSIZE(szFormat)))
                {
                    TraceMsg(TF_DRAGDROP, "CFSDropTarget - cf %s, tymed %d", szFormat, fmte.tymed);
                }
                else
                {
                    TraceMsg(TF_DRAGDROP, "CFSDropTarget - cf %d, tymed %d", fmte.cfFormat, fmte.tymed);
                }
#endif // DEBUG
                SHFree(fmte.ptd);
            }
            penum->Release();
        }

        //
        // HACK:
        // Win95 always did the GetData below which can be quite expensive if
        // the data is a directory structure on an ftp server etc.
        // dont check for FD_LINKUI if the data object has a preferred effect
        //
        if ((*pdwData & (DTID_PREFERREDEFFECT | DTID_CONTENTS)) == DTID_CONTENTS)
        {
            if (*pdwData & DTID_FDESCA)
            {
                FORMATETC fmteRead = {g_cfFileGroupDescriptorA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                STGMEDIUM medium = {0};
                if (S_OK == pdtobj->GetData(&fmteRead, &medium))
                {
                    FILEGROUPDESCRIPTORA * pfgd = (FILEGROUPDESCRIPTORA *)GlobalLock(medium.hGlobal);
                    if (pfgd)
                    {
                        if (pfgd->cItems >= 1)
                        {
                            if (pfgd->fgd[0].dwFlags & FD_LINKUI)
                                *pdwData |= DTID_FD_LINKUI;
                        }
                        GlobalUnlock(medium.hGlobal);
                    }
                    ReleaseStgMedium(&medium);
                }
            }
            else if (*pdwData & DTID_FDESCW)
            {
                FORMATETC fmteRead = {g_cfFileGroupDescriptorW, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                STGMEDIUM medium = {0};
                if (S_OK == pdtobj->GetData(&fmteRead, &medium))
                {
                    FILEGROUPDESCRIPTORW * pfgd = (FILEGROUPDESCRIPTORW *)GlobalLock(medium.hGlobal);
                    if (pfgd)
                    {
                        if (pfgd->cItems >= 1)
                        {
                            if (pfgd->fgd[0].dwFlags & FD_LINKUI)
                                *pdwData |= DTID_FD_LINKUI;
                        }
                        GlobalUnlock(medium.hGlobal);
                    }
                    ReleaseStgMedium(&medium);
                }
            }
        }

        if (S_OK == OleQueryCreateFromData(pdtobj))
            *pdwData |= DTID_OLEOBJ;

        if (S_OK == OleQueryLinkFromData(pdtobj))
            *pdwData |= DTID_OLELINK;
    }
    return S_OK;    // for now always succeeds
}

STDMETHODIMP CFSDropTarget::DragEnter(IDataObject* pdtobj, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    ASSERT(NULL == _pdtobj);    // req DragDrop protocol, someone forgot to call DragLeave

    // init our registerd data formats
    IDLData_InitializeClipboardFormats();

    _grfKeyStateLast = grfKeyState;
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);

    GetClipFormatFlags(_pdtobj, &_dwData, &_dwEffectPreferred);

    *pdwEffect = _dwEffectLastReturned = _DetermineEffects(grfKeyState, pdwEffect, NULL);
    return S_OK;
}

STDMETHODIMP CFSDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    if (_grfKeyStateLast != grfKeyState)
    {
        _grfKeyStateLast = grfKeyState;
        *pdwEffect = _dwEffectLastReturned = _DetermineEffects(grfKeyState, pdwEffect, NULL);
    }
    else
    {
        *pdwEffect = _dwEffectLastReturned;
    }
    return S_OK;
}

STDMETHODIMP CFSDropTarget::DragLeave()
{
    IUnknown_Set((IUnknown **)&_pdtobj, NULL);
    return S_OK;
}


// init data from our site that we will need in processing the drop

void CFSDropTarget::_GetStateFromSite()
{
    IShellFolderView* psfv;

    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IShellFolderView, &psfv))))
    {
        _fSameHwnd = S_OK == psfv->IsDropOnSource((IDropTarget*)this);
        _fDragDrop = S_OK == psfv->GetDropPoint(&_ptDrop);
        _fBkDropTarget = S_OK == psfv->IsBkDropTarget(NULL);

        psfv->QueryInterface(IID_PPV_ARG(IFolderView, &_pfv));

        psfv->Release();
    }
}

STDMETHODIMP CFSDropTarget::Drop(IDataObject* pdtobj, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    // OLE may give us a different data object (fully marshalled)
    // from the one we've got on DragEnter (this is not the case on Win2k, this is a nop)

    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);

    _GetStateFromSite();

    // note, that on the drop the mouse buttons are not down so the grfKeyState
    // is not what we saw on the DragOver/DragEnter, thus we need to cache
    // the grfKeyState to detect left vs right drag
    //
    // ASSERT(this->grfKeyStateLast == grfKeyState);

    HMENU hmenu = SHLoadPopupMenu(HINST_THISDLL, POPUP_TEMPLATEDD);
    DWORD dwDefEffect = _DetermineEffects(grfKeyState, pdwEffect, hmenu);
    if (DROPEFFECT_NONE == dwDefEffect)
    {
        *pdwEffect = DROPEFFECT_NONE;
        DAD_SetDragImage(NULL, NULL);
        IUnknown_Set((IUnknown **)&_pdtobj, NULL);
        return S_OK;
    }

    TCHAR szPath[MAX_PATH];
    _GetPath(szPath);

    // this doesn't actually do the menu if (grfKeyState MK_LBUTTON)

    FSDRAGDROPMENUPARAM ddm;
    ddm.dwDefEffect = dwDefEffect;
    ddm.pdtobj = pdtobj;
    ddm.pt = pt;
    ddm.pdwEffect = pdwEffect;
    ddm.ck = SHGetAssocKeysForIDList(_GetIDList(), ddm.rghk, ARRAYSIZE(ddm.rghk));
    ddm.hmenu = hmenu;
    ddm.grfKeyState = grfKeyState;

    HRESULT hr = _DragDropMenu(&ddm);

    SHRegCloseKeys(ddm.rghk, ddm.ck);

    DestroyMenu(hmenu);

    if (hr == S_FALSE)
    {
        // let callers know where this is about to go
        // SHScrap cares because it needs to close the file so we can copy/move it
        DataObj_SetDropTarget(pdtobj, &CLSID_ShellFSFolder);

        switch (ddm.idCmd)
        {
        case DDIDM_CONTENTS_DESKCOMP:
            hr = CreateDesktopComponents(NULL, pdtobj, _hwnd, 0, ddm.pt.x, ddm.pt.y);
            break;

        case DDIDM_CONTENTS_DESKURL:
            hr = _CreateURLDeskComp(pdtobj, ddm.pt);
            break;

        case DDIDM_CONTENTS_DESKIMG:
            hr = _CreateDeskCompImage(pdtobj, ddm.pt);
            break;

        case DDIDM_CONTENTS_COPY:
        case DDIDM_CONTENTS_MOVE:
        case DDIDM_CONTENTS_LINK:
            hr = CFSFolder_AsyncCreateFileFromClip(_hwnd, szPath, pdtobj, pt, pdwEffect, _fBkDropTarget);
            break;

        case DDIDM_SCRAP_COPY:
        case DDIDM_SCRAP_MOVE:
        case DDIDM_DOCLINK:
            hr = SHCreateBookMark(_hwnd, szPath, pdtobj, pt, pdwEffect);
            break;

        case DDIDM_OBJECT_COPY:
        case DDIDM_OBJECT_MOVE:
            hr = _CreatePackage(pdtobj);
            if (E_UNEXPECTED == hr)
            {
                // _CreatePackage() can only expand certain types of packages
                // back into files.  For example, it doesn't handle CMDLINK files.
                //
                // If _CreatePackage() didn't recognize the stream format, we fall
                // back to SHCreateBookMark(), which should create a scrap:
                hr = SHCreateBookMark(_hwnd, szPath, pdtobj, pt, pdwEffect);
            }
            break;

        case DDIDM_COPY:
        case DDIDM_SYNCCOPY:
        case DDIDM_SYNCCOPYTYPE:
        case DDIDM_MOVE:
        case DDIDM_LINK:

            _dwEffect = *pdwEffect;
            _idCmd = ddm.idCmd;

            if (DataObj_CanGoAsync(pdtobj) || DataObj_GoAsyncForCompat(pdtobj))
            {
                // create another thread to avoid blocking the source thread.
                DROPTHREADPARAMS *pdtp;
                hr = SHLocalAlloc(sizeof(*pdtp), &pdtp);
                if (SUCCEEDED(hr))
                {
                    pdtp->pThis = this;
                    pdtp->pThis->AddRef();

                    CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdtobj, &pdtp->pstmDataObj);
                    CoMarshalInterThreadInterfaceInStream(IID_IFolderView,   _pfv, &pdtp->pstmFolderView);

                    if (SHCreateThread(_DoDropThreadProc, pdtp, CTF_COINIT, NULL))
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        _FreeThreadParams(pdtp);
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            else
            {
                _DoDrop(pdtobj, _pfv);   // synchronously
            }


            // in these CF_HDROP cases "Move" is always an optimized move, we delete the
            // source. make sure we don't return DROPEFFECT_MOVE so the source does not 
            // try to do this too... 
            // even if we have not done anything yet since we may have 
            // kicked of a thread to do this
            
            DataObj_SetDWORD(pdtobj, g_cfLogicalPerformedDropEffect, *pdwEffect);            
            if (DROPEFFECT_MOVE == *pdwEffect)
                *pdwEffect = DROPEFFECT_NONE;
            break;
        }
    }

    IUnknown_Set((IUnknown **)&_pdtobj, NULL);  // don't use this any more

    if (FAILED(hr))
        *pdwEffect = DROPEFFECT_NONE;

    ASSERT(*pdwEffect==DROPEFFECT_COPY || 
           *pdwEffect==DROPEFFECT_LINK || 
           *pdwEffect==DROPEFFECT_MOVE || 
           *pdwEffect==DROPEFFECT_NONE);
    return hr;
}

void CFSDropTarget::_AddVerbs(DWORD* pdwEffects, DWORD dwEffectAvail, DWORD dwDefEffect,
                              UINT idCopy, UINT idMove, UINT idLink,
                              DWORD dwForceEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    MENUITEMINFO mii;
    TCHAR szCmd[MAX_PATH];
    if (NULL != pfsMenuInfo)
    {
        mii.cbSize = sizeof(mii);
        mii.dwTypeData = szCmd;
        mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE | MIIM_DATA;
        mii.fType = MFT_STRING;
    }
    if ((DROPEFFECT_COPY == (DROPEFFECT_COPY & dwEffectAvail)) &&
        ((0 == (*pdwEffects & DROPEFFECT_COPY)) || (dwForceEffect & DROPEFFECT_COPY)))
    {
        ASSERT(0 != idCopy);
        if (NULL != pfsMenuInfo)
        {
            LoadString(HINST_THISDLL, idCopy + IDS_DD_FIRST, szCmd, ARRAYSIZE(szCmd));
            mii.fState = MFS_ENABLED | ((DROPEFFECT_COPY == dwDefEffect) ? MFS_DEFAULT : 0);
            mii.wID = idCopy;
            mii.dwItemData = DROPEFFECT_COPY;
            InsertMenuItem(pfsMenuInfo->hMenu, pfsMenuInfo->uCopyPos, TRUE, &mii);
            pfsMenuInfo->uCopyPos++;
            pfsMenuInfo->uMovePos++;
            pfsMenuInfo->uLinkPos++;
        }
    }
    if ((DROPEFFECT_MOVE == (DROPEFFECT_MOVE & dwEffectAvail)) &&
        ((0 == (*pdwEffects & DROPEFFECT_MOVE)) || (dwForceEffect & DROPEFFECT_MOVE)))
    {
        ASSERT(0 != idMove);
        if (NULL != pfsMenuInfo)
        {
            LoadString(HINST_THISDLL, idMove + IDS_DD_FIRST, szCmd, ARRAYSIZE(szCmd));
            mii.fState = MFS_ENABLED | ((DROPEFFECT_MOVE == dwDefEffect) ? MFS_DEFAULT : 0);
            mii.wID = idMove;
            mii.dwItemData = DROPEFFECT_MOVE;
            InsertMenuItem(pfsMenuInfo->hMenu, pfsMenuInfo->uMovePos, TRUE, &mii);
            pfsMenuInfo->uMovePos++;
            pfsMenuInfo->uLinkPos++;
        }
    }
    if ((DROPEFFECT_LINK == (DROPEFFECT_LINK & dwEffectAvail)) &&
        ((0 == (*pdwEffects & DROPEFFECT_LINK)) || (dwForceEffect & DROPEFFECT_LINK)))
    {
        ASSERT(0 != idLink);
        if (NULL != pfsMenuInfo)
        {
            LoadString(HINST_THISDLL, idLink + IDS_DD_FIRST, szCmd, ARRAYSIZE(szCmd));
            mii.fState = MFS_ENABLED | ((DROPEFFECT_LINK == dwDefEffect) ? MFS_DEFAULT : 0);
            mii.wID = idLink;
            mii.dwItemData = DROPEFFECT_LINK;
            InsertMenuItem(pfsMenuInfo->hMenu, pfsMenuInfo->uLinkPos, TRUE, &mii);
            pfsMenuInfo->uLinkPos++;
        }
    }
    *pdwEffects |= dwEffectAvail;
}

// determine the default drop effect (move/copy/link) from the file type
//
// HKCR\.cda "DefaultDropEffect" = 4   // DROPEFFECT_LINK

DWORD EffectFromFileType(IDataObject *pdtobj)
{
    DWORD dwDefEffect = DROPEFFECT_NONE; // 0

    LPITEMIDLIST pidl;
    if (SUCCEEDED(PidlFromDataObject(pdtobj, &pidl)))
    {
        IQueryAssociations *pqa;
        if (SUCCEEDED(SHGetAssociations(pidl, (void **)&pqa)))
        {
            DWORD cb = sizeof(dwDefEffect);
            pqa->GetData(0, ASSOCDATA_VALUE, L"DefaultDropEffect", &dwDefEffect, &cb);
            pqa->Release();
        }
        ILFree(pidl);
    }

    return dwDefEffect;
}

// compute the default effect based on 
//      the allowed effects
//      the keyboard state, 
//      the preferred effect that might be in the data object
//      and previously computed default effect (if the above yields nothing)

DWORD CFSDropTarget::_GetDefaultEffect(DWORD grfKeyState, DWORD dwCurEffectAvail, DWORD dwAllEffectAvail, DWORD dwOrigDefEffect)
{
    DWORD dwDefEffect = 0;
    //
    // keyboard, (explicit user input) gets first crack
    //
    switch (grfKeyState & (MK_CONTROL | MK_SHIFT | MK_ALT))
    {
    case MK_CONTROL:
        dwDefEffect = DROPEFFECT_COPY;
        break;

    case MK_SHIFT:
        dwDefEffect = DROPEFFECT_MOVE;
        break;

    case MK_SHIFT | MK_CONTROL:
    case MK_ALT:
        dwDefEffect = DROPEFFECT_LINK;
        break;

    default: // no modifier keys case
        // if the data object contains a preferred drop effect, try to use it
        DWORD dwPreferred = DataObj_GetDWORD(_pdtobj, g_cfPreferredDropEffect, DROPEFFECT_NONE) & dwAllEffectAvail;

        if (DROPEFFECT_NONE == dwPreferred)
        {
            dwPreferred = EffectFromFileType(_pdtobj) & dwAllEffectAvail;
        }

        if (dwPreferred)
        {
            if (dwPreferred & DROPEFFECT_MOVE)
            {
                dwDefEffect = DROPEFFECT_MOVE;
            }
            else if (dwPreferred & DROPEFFECT_COPY)
            {
                dwDefEffect = DROPEFFECT_COPY;
            }
            else if (dwPreferred & DROPEFFECT_LINK)
            {
                dwDefEffect = DROPEFFECT_LINK;
            }
        }
        else
        {
            dwDefEffect = dwOrigDefEffect;
        }
        break;
    }
    return dwDefEffect & dwCurEffectAvail;
}

HRESULT CFSDropTarget::_FilterDeskCompHDROP(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                            DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    HRESULT hr = S_FALSE;
    
    if (!PolicyNoActiveDesktop() &&
        !SHRestricted(REST_NOADDDESKCOMP) &&
        _IsDesktopFolder())
    {
        hr = IsDeskCompHDrop(_pdtobj);
        if (S_OK == hr)
        {
            DWORD dwDefEffect = 0;
            DWORD dwEffectAdd = dwEffectsAvail & DROPEFFECT_LINK;
            if (pdwDefaultEffect)
            {
                dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_LINK);
                *pdwDefaultEffect = dwDefEffect;
            }
            
            _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, 0, 0, DDIDM_CONTENTS_DESKCOMP,
                      DROPEFFECT_LINK, // force add the DDIDM_CONTENTS_DESKCOMP verb
                      pfsMenuInfo);
        }
    }
    return hr;
}

// see if a PIDL is scoped by a briefcaes

BOOL IsBriefcaseOrChild(LPCITEMIDLIST pidlIn)
{
    BOOL bRet = FALSE;
    LPITEMIDLIST pidl = ILClone(pidlIn);
    if (pidl)
    {
        do
        {
            CLSID clsid;
            if (SUCCEEDED(GetCLSIDFromIDList(pidl, &clsid)) &&
                IsEqualCLSID(clsid, CLSID_Briefcase))
            {
                bRet = TRUE;    // it is a briefcase
                break;
            }
        } while (ILRemoveLastID(pidl));
        ILFree(pidl);
    }
    return bRet;
}

// returns true if the data object represents items in a sneakernet briefcase
// (briefcase on removable media)

BOOL CFSDropTarget::_IsFromSneakernetBriefcase()
{
    BOOL bRet = FALSE;  // assume no

    if (!_IsBriefcaseTarget())
    {
        STGMEDIUM medium = {0};
        LPIDA pida = DataObj_GetHIDA(_pdtobj, &medium);
        if (pida)
        {
            LPCITEMIDLIST pidlFolder = IDA_GetIDListPtr(pida, (UINT)-1);
            TCHAR szSource[MAX_PATH];
            if (SHGetPathFromIDList(pidlFolder, szSource))
            {
                // is source on removable device?
                if (!PathIsUNC(szSource) && IsRemovableDrive(DRIVEID(szSource)))
                {
                    TCHAR szTarget[MAX_PATH];
                    _GetPath(szTarget);

                    // is the target fixed media?
                    if (PathIsUNC(szTarget) || !IsRemovableDrive(DRIVEID(szTarget)))
                    {
                        bRet = IsBriefcaseOrChild(pidlFolder);
                    }
                }
            }
            HIDA_ReleaseStgMedium(pida, &medium);
        }
    }
    return bRet;
}

// TRUE if any folders are in hdrop

BOOL DroppingAnyFolders(HDROP hDrop)
{
    TCHAR szPath[MAX_PATH];
    
    for (UINT i = 0; DragQueryFile(hDrop, i, szPath, ARRAYSIZE(szPath)); i++)
    {
        if (PathIsDirectory(szPath))
            return TRUE;
    }
    return FALSE;
}

// sneakernet case:
//      dragging a file/folder from a briefcase on removable media. we special case this
//  and use this as a chance to connect up this target folder with the content of the briefcase

HRESULT CFSDropTarget::_FilterSneakernetBriefcase(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                                  DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);

    if (_IsFromSneakernetBriefcase())
    {
        // Yes; show the non-default briefcase cm
        STGMEDIUM medium = {0};
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        if (SUCCEEDED(_pdtobj->GetData(&fmte, &medium)))
        {
            DWORD dwDefEffect = 0;
            DWORD dwEffectAdd = DROPEFFECT_COPY & dwEffectsAvail;
            if (pdwDefaultEffect)
            {
                dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_COPY);
                *pdwDefaultEffect = dwDefEffect;
            }
            
            _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, DDIDM_SYNCCOPY, 0, 0, 0, pfsMenuInfo);

            // Call _AddVerbs() again to force "Sync Copy of Type" as a 2nd DROPEFFECT_COPY verb:
            if ((DROPEFFECT_COPY & dwEffectsAvail) && 
                DroppingAnyFolders((HDROP)medium.hGlobal))
            {
                _AddVerbs(pdwEffects, DROPEFFECT_COPY, 0,
                          DDIDM_SYNCCOPYTYPE, 0, 0, DROPEFFECT_COPY, pfsMenuInfo);
            }
            
            ReleaseStgMedium(&medium);
        }
    }
    return S_OK;
}

// returns true if the data object represents items from the same briefcase
// as this drop target
BOOL CFSDropTarget::_IsFromSameBriefcase()
{
    BOOL bRet = FALSE;

    STGMEDIUM medium;
    FORMATETC fmteBrief = {g_cfBriefObj, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    
    // Yes; are they from the same briefcase as the target?
    if (SUCCEEDED(_pdtobj->GetData(&fmteBrief, &medium)))
    {
        BriefObj *pbo = (BriefObj *)GlobalLock(medium.hGlobal);

        TCHAR szBriefPath[MAX_PATH], szPath[MAX_PATH];
        lstrcpy(szBriefPath, BOBriefcasePath(pbo));
        lstrcpy(szPath, BOFileList(pbo));   // first file in list

        TCHAR szPathTgt[MAX_PATH];
        _GetPath(szPathTgt);

        int cch = PathCommonPrefix(szPath, szPathTgt, NULL);
        bRet = (0 < cch) && (lstrlen(szBriefPath) <= cch);
        
        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);
    }
    return bRet;
}

// briefcase drop target specific handling gets computed here

HRESULT CFSDropTarget::_FilterBriefcase(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                        DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    if (_IsBriefcaseTarget() && !_IsFromSameBriefcase())
    {
        STGMEDIUM medium = {0};
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        if (SUCCEEDED(_pdtobj->GetData(&fmte, &medium)))
        {
            DWORD dwDefEffect = DROPEFFECT_COPY;
            DWORD dwEffectAdd = DROPEFFECT_COPY & dwEffectsAvail;
            if (pdwDefaultEffect)
            {
                dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_COPY);
                *pdwDefaultEffect = dwDefEffect;
            }
            
            _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, DDIDM_SYNCCOPY, 0, 0, 0, pfsMenuInfo);

            // Call _AddVerbs() again to force "Sync Copy of Type" as a 2nd DROPEFFECT_COPY verb:
            if ((DROPEFFECT_COPY & dwEffectsAvail) && 
                DroppingAnyFolders((HDROP)medium.hGlobal))
            {
                _AddVerbs(pdwEffects, DROPEFFECT_COPY, 0,
                          DDIDM_SYNCCOPYTYPE, 0, 0, DROPEFFECT_COPY, pfsMenuInfo);
            }
            
            ReleaseStgMedium(&medium);
        }
    }
    return S_OK;
}


HRESULT CFSDropTarget::_FilterHDROP(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                    DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);

    DWORD dwDefEffect = 0;
    DWORD dwEffectAdd = dwEffectsAvail & (DROPEFFECT_COPY | DROPEFFECT_MOVE);
    if (pdwDefaultEffect)
    {
        dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, _FilesystemAdjustedDefaultEffect(dwEffectAdd));
        *pdwDefaultEffect = dwDefEffect;
    }
    
    _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, DDIDM_COPY, DDIDM_MOVE, 0, 0, pfsMenuInfo);

    return S_OK;
}

HRESULT CFSDropTarget::_FilterFileContents(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                           DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    
    if ((_dwData & (DTID_CONTENTS | DTID_FDESCA)) == (DTID_CONTENTS | DTID_FDESCA) ||
        (_dwData & (DTID_CONTENTS | DTID_FDESCW)) == (DTID_CONTENTS | DTID_FDESCW))
    {
        DWORD dwEffectAdd, dwSuggestedEffect;
        //
        // HACK: if there is a preferred drop effect and no HIDA
        // then just take the preferred effect as the available effects
        // this is because we didn't actually check the FD_LINKUI bit
        // back when we assembled dwData! (performance)
        //
        if ((_dwData & (DTID_PREFERREDEFFECT | DTID_HIDA)) == DTID_PREFERREDEFFECT)
        {
            dwEffectAdd = _dwEffectPreferred;
            dwSuggestedEffect = _dwEffectPreferred;
        }
        else if (_dwData & DTID_FD_LINKUI)
        {
            dwEffectAdd = DROPEFFECT_LINK;
            dwSuggestedEffect = DROPEFFECT_LINK;
        }
        else
        {
            dwEffectAdd = DROPEFFECT_COPY | DROPEFFECT_MOVE;
            dwSuggestedEffect = DROPEFFECT_COPY;
        }
        dwEffectAdd &= dwEffectsAvail;

        DWORD dwDefEffect = 0;
        if (pdwDefaultEffect)
        {
            dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, dwSuggestedEffect);
            *pdwDefaultEffect = dwDefEffect;
        }

        _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect,
                  DDIDM_CONTENTS_COPY, DDIDM_CONTENTS_MOVE, DDIDM_CONTENTS_LINK,
                  0, pfsMenuInfo);
    }
    return S_OK;
}

//
//  Old versions of OLE have a bug where if two FORMATETCs use the same
//  CLIPFORMAT, then only the first one makes it to the IEnumFORMATETC,
//  even if the other parameters (such as DVASPECT) are different.
//
//  This causes us problems because those other DVASPECTs might be useful.
//  So if we see a FileContents with the wrong DVASPECT, sniff at the
//  object to see if maybe it also contains a copy with the correct DVASPECT.
//
//  This bug was fixed in 1996 on the NT side, but the Win9x side was
//  not fixed.  The Win9x OLE team was disbanded before the fix could
//  be propagated.  So we get to work around this OLE bug forever.
//
HRESULT CFSDropTarget::_FilterFileContentsOLEHack(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                                  DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    FORMATETC fmte = *pfmte;
    fmte.dwAspect = DVASPECT_CONTENT;

    //
    //  Whoa, this test is so (intentionally) backwards it isn't funny.
    //
    //  We want to see whether there is a DVASPECT_CONTENT available in
    //  the real object.  So we first ask the object if it has a
    //  DVASPECT_CONTENT format already.  If the answer is yes, then we
    //  **skip** this FORMATETC, because it will be found (or has already
    //  been found) by our big EnumFORMATETC loop.
    //
    //  If the answer is NO, then maybe we're hitting an OLE bug.
    //  (They cache the list of available formats, but the bug is that
    //  their cache is broken.)  Bypass the cache by actually getting the
    //  data.  If it works, then run with it.  Otherwise, I guess OLE wasn't
    //  kidding.
    //
    //  Note that we do not GetData() unconditionally -- bad for perf.
    //  Only call GetData() after all the easy tests have failed.
    //

    HRESULT hr = _pdtobj->QueryGetData(&fmte);
    if (hr == DV_E_FORMATETC)
    {
        // Maybe we are hitting the OLE bug.  Try harder.
        STGMEDIUM stgm = {0};
        if (SUCCEEDED(_pdtobj->GetData(&fmte, &stgm)))
        {
            // Yup.  OLE lied to us.
            ReleaseStgMedium(&stgm);

            hr = _FilterFileContents(&fmte, grfKeyFlags, dwEffectsAvail,
                                        pdwEffects, pdwDefaultEffect, pfsMenuInfo);
        }
        else
        {
            // Whaddya know, OLE was telling the truth.  Do nothing with this
            // format.
            hr = S_OK;
        }
    }
    else
    {
        // Either QueryGetData() failed in some bizarre way
        // (in which case we ignore the problem) or the QueryGetData
        // succeeded, in which case we ignore this FORMATETC since
        // the big enumeration will find (or has already found) the
        // DVASPECT_CONTENT.
        hr = S_OK;
    }

    return hr;
}

HRESULT CFSDropTarget::_FilterHIDA(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                   DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);

    DWORD dwDefEffect = 0;
    DWORD dwEffectAdd = DROPEFFECT_LINK & dwEffectsAvail;
    // NOTE: we only add a HIDA default effect if HDROP isn't going to add a default
    // effect.  This preserves shell behavior with file system data objects without
    // requiring us to change the enumerator order in CIDLDataObj.  When we do change
    // the enumerator order, we can remove this special case:
    if (pdwDefaultEffect &&
        ((0 == (_dwData & DTID_HDROP)) ||
         (0 == _GetDefaultEffect(grfKeyFlags,
                                dwEffectsAvail & (DROPEFFECT_COPY | DROPEFFECT_MOVE),
                                dwEffectsAvail,
                                _FilesystemAdjustedDefaultEffect(dwEffectsAvail & (DROPEFFECT_COPY | DROPEFFECT_MOVE))))))
    {
        dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_LINK);
        *pdwDefaultEffect = dwDefEffect;
    }
    
    _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, 0, 0, DDIDM_LINK, 0, pfsMenuInfo);

    return S_OK;
}

// {F20DA720-C02F-11CE-927B-0800095AE340}
const GUID CLSID_CPackage = {0xF20DA720L, 0xC02F, 0x11CE, 0x92, 0x7B, 0x08, 0x00, 0x09, 0x5A, 0xE3, 0x40};
// old packager guid...
// {0003000C-0000-0000-C000-000000000046}
const GUID CLSID_OldPackage = {0x0003000CL, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46};

HRESULT CFSDropTarget::_FilterOlePackage(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                            DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    HRESULT hr = S_FALSE;

    if (pdwDefaultEffect)
    {
        *pdwDefaultEffect = 0;
    }

    FORMATETC fmte = {g_cfObjectDescriptor, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {0};
    if (SUCCEEDED(_pdtobj->GetData(&fmte, &medium)))
    {
        // we've got an object descriptor
        OBJECTDESCRIPTOR* pOD = (OBJECTDESCRIPTOR*) GlobalLock(medium.hGlobal);
        if (pOD)
        {
            if (IsEqualCLSID(CLSID_OldPackage, pOD->clsid) ||
                IsEqualCLSID(CLSID_CPackage, pOD->clsid))
            {
                // This is a package - proceed
                DWORD dwDefEffect = 0;
                DWORD dwEffectAdd = (DROPEFFECT_COPY | DROPEFFECT_MOVE) & dwEffectsAvail;
                if (pdwDefaultEffect)
                {
                    dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_COPY);
                    *pdwDefaultEffect = dwDefEffect;
                }
                
                _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect,
                          DDIDM_OBJECT_COPY, DDIDM_OBJECT_MOVE, 0,
                          0, pfsMenuInfo);

                hr = S_OK;
            }
            GlobalUnlock(medium.hGlobal);
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}

// REARCHITECT:
//    This code has lots of problems.  We need to fix this the text time we touch this code
// outside of ship mode.  TO FIX:
// 1. Use SHAnsiToUnicode(CP_UTF8, ) to convert pszHTML to unicode.  This will allow international
//    paths to work.
// 2. Obey the selected range.
// 3. Use MSHTML to get the image.  You can have trident parse the HTML via IHTMLTxtRange::pasteHTML.
//    MS HTML has a special collection of images.  Ask for the first image in that collection, or
//    the first image in that collection within the selected range.  (#1 isn't needed with this)
BOOL ExtractImageURLFromCFHTML(IN LPSTR pszHTML, IN SIZE_T cbHTMLSize, OUT LPSTR szImg, IN DWORD dwSize)
{
    BOOL fSucceeded = FALSE;

    // To avoid going nuts, only look at the first 64K of the HTML.
    // (Important on Win64 because StrCpyNA doesn't support more than 4GB.)
    if (cbHTMLSize > 0xFFFF)
        cbHTMLSize = 0xFFFF;

    // NT #391669: pszHTML isn't terminated, so terminate it now.
    LPSTR pszCopiedHTML = (LPSTR) LocalAlloc(LPTR, cbHTMLSize + 1);
    if (pszCopiedHTML)
    {
        LPSTR szTemp;
        DWORD dwLen = dwSize;
        BOOL  bRet = TRUE;

        StrCpyNA(pszCopiedHTML, pszHTML, (int)(cbHTMLSize + 1));

        //DANGER WILL ROBINSON:
        // HTML is comming in as UFT-8 encoded. Neither Unicode or Ansi,
        // We've got to do something.... I'm going to party on it as if it were
        // Ansi. This code will choke on escape sequences.....

        //Find the base URL
        //Locate <!--StartFragment-->
        //Read the <IMG SRC="
        //From there to the "> should be the Image URL
        //Determine if it's an absolute or relative URL
        //If relative, append to BASE url. You may need to lop off from the
        // last delimiter to the end of the string.

        //Pull out the SourceURL

        LPSTR szBase = StrStrIA(pszCopiedHTML,"SourceURL:"); // Point to the char after :
        if (szBase)
        {
            szBase += sizeof("SourceURL:")-1;

            //Since each line can be terminated by a CR, CR/LF or LF check each case...
            szTemp = StrChrA(szBase,'\n');
            if (!szTemp)
                szTemp = StrChrA(szBase,'\r');

            if (szTemp)
                *szTemp = '\0';
            szTemp++;
        }
        else
            szTemp = pszCopiedHTML;


        //Pull out the Img Src
        LPSTR pszImgSrc = StrStrIA(szTemp,"IMG");
        if (pszImgSrc != NULL)
        {
            pszImgSrc = StrStrIA(pszImgSrc,"SRC");
            if (pszImgSrc != NULL)
            {
                LPSTR pszImgSrcOrig = pszImgSrc;
                pszImgSrc = StrChrA(pszImgSrc,'\"');
                if (pszImgSrc)
                {
                    pszImgSrc++;     // Skip over the quote at the beginning of the src path.
                    szTemp = StrChrA(pszImgSrc,'\"');    // Find the end of the path.
                }
                else
                {
                    LPSTR pszTemp1;
                    LPSTR pszTemp2;

                    pszImgSrc = StrChrA(pszImgSrcOrig,'=');
                    pszImgSrc++;     // Skip past the equals to the first char in the path.
                                    // Someday we may need to handle spaces between '=' and the path.

                    pszTemp1 = StrChrA(pszImgSrc,' ');   // Since the path doesn't have quotes around it, assume a space will terminate it.
                    pszTemp2 = StrChrA(pszImgSrc,'>');   // Since the path doesn't have quotes around it, assume a space will terminate it.

                    szTemp = pszTemp1;      // Assume quote terminates path.
                    if (!pszTemp1)
                        szTemp = pszTemp2;  // Use '>' if quote not found.

                    if (pszTemp1 && pszTemp2 && (pszTemp2 < pszTemp1))
                        szTemp = pszTemp2;  // Change to having '>' terminate path if both exist and it comes first.
                }

                *szTemp = '\0'; // Terminate path.

                //At this point, I've reduced the 2 important strings. Now see if I need to
                //Join them.

                //If this fails, then we don't have a full URL, Only a relative.
                if (!UrlIsA(pszImgSrc,URLIS_URL) && szBase)
                {
                    if (SUCCEEDED(UrlCombineA(szBase, pszImgSrc, szImg, &dwLen,0)))
                        fSucceeded = TRUE;
                }
                else
                {
                    if (lstrlenA(pszImgSrc) <= (int)dwSize)
                        lstrcpyA(szImg, pszImgSrc);

                    fSucceeded = TRUE;
                }
            }
        }

        LocalFree(pszCopiedHTML);
    }

    return fSucceeded;
}

HRESULT CFSDropTarget::_FilterDeskImage(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                        DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    HRESULT hr = S_FALSE;

    if (pdwDefaultEffect)
    {
        *pdwDefaultEffect = 0;
    }

    if (!PolicyNoActiveDesktop() &&
        !SHRestricted(REST_NOADDDESKCOMP) &&
        _IsDesktopFolder())
    {
        FORMATETC fmte = {g_cfHTML, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM medium = {0};
        if (SUCCEEDED(_pdtobj->GetData(&fmte, &medium)))
        {
            //DANGER WILL ROBINSON:
            //HTML is UTF-8, a mostly ANSI cross of ANSI and Unicode. Play with
            // it as is it were ANSI. Find a way to escape the sequences...
            CHAR *pszData = (CHAR*) GlobalLock(medium.hGlobal);
            if (pszData)
            {
                CHAR szUrl[MAX_URL_STRING];
                if (ExtractImageURLFromCFHTML(pszData, GlobalSize(medium.hGlobal), szUrl, ARRAYSIZE(szUrl)))
                {
                    // The HTML contains an image tag - carry on...
                    DWORD dwDefEffect = 0;
                    DWORD dwEffectAdd = DROPEFFECT_LINK; // NOTE: ignoring dwEffectsAvail!
                    if (pdwDefaultEffect)
                    {
                        dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd,
                                                        dwEffectsAvail | DROPEFFECT_LINK, DROPEFFECT_LINK);
                        *pdwDefaultEffect = dwDefEffect;
                    }
                    
                    _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect,
                              0, 0, DDIDM_CONTENTS_DESKIMG,
                              0, pfsMenuInfo);

                    hr = S_OK;
                }
                GlobalUnlock(medium.hGlobal);
            }
            ReleaseStgMedium(&medium);
        }
    }
    return hr;
}

HRESULT CFSDropTarget::_FilterDeskComp(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                       DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    HRESULT hr = S_FALSE;

    if (pdwDefaultEffect)
    {
        *pdwDefaultEffect = 0;
    }

    if (!PolicyNoActiveDesktop() &&
        !SHRestricted(REST_NOADDDESKCOMP) &&
        _IsDesktopFolder())
    {
        FORMATETC fmte = {g_cfShellURL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM medium = {0};
        if (SUCCEEDED(_pdtobj->GetData(&fmte, &medium)))
        {
            // DANGER WILL ROBINSON:
            // HTML is UTF-8, a mostly ANSI cross of ANSI and Unicode. Play with
            // it as is it were ANSI. Find a way to escape the sequences...
            CHAR *pszData = (CHAR*) GlobalLock(medium.hGlobal);
            if (pszData)
            {
                int nScheme = GetUrlSchemeA(pszData);
                if ((nScheme != URL_SCHEME_INVALID) && (nScheme != URL_SCHEME_FTP))
                {
                    // This is an internet scheme - carry on...
                    DWORD dwDefEffect = 0;
                    DWORD dwEffectAdd = DROPEFFECT_LINK & dwEffectsAvail;
                    if (pdwDefaultEffect)
                    {
                        dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_LINK);
                        *pdwDefaultEffect = dwDefEffect;
                    }
                    
                    _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect,
                              0, 0, DDIDM_CONTENTS_DESKURL,
                              DROPEFFECT_LINK, // force add this verb
                              pfsMenuInfo);

                    hr = S_OK;
                }
                GlobalUnlock(medium.hGlobal);
            }
            ReleaseStgMedium(&medium);
        }
    }
    return hr;
}

HRESULT CFSDropTarget::_FilterOleObj(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                        DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    HRESULT hr = S_FALSE;
    
    if (_dwData & DTID_OLEOBJ)
    {
        DWORD dwDefEffect = 0;
        DWORD dwEffectAdd = (DROPEFFECT_COPY | DROPEFFECT_MOVE) & dwEffectsAvail;
        if (pdwDefaultEffect)
        {
            dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_COPY);
            *pdwDefaultEffect = dwDefEffect;
        }
    
        _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, DDIDM_SCRAP_COPY, DDIDM_SCRAP_MOVE, 0, 0, pfsMenuInfo);

        hr = S_OK;
    }
    return hr;
}

HRESULT CFSDropTarget::_FilterOleLink(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                         DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    HRESULT hr = S_FALSE;
    
    if (_dwData & DTID_OLELINK)
    {
        DWORD dwDefEffect = 0;
        DWORD dwEffectAdd = DROPEFFECT_LINK & dwEffectsAvail;
        if (pdwDefaultEffect)
        {
            dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_LINK);
            *pdwDefaultEffect = dwDefEffect;
        }
    
        _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, 0, 0, DDIDM_DOCLINK, 0, pfsMenuInfo);

        hr = S_OK;
    }
    return hr;
}

HRESULT CFSDropTarget::_CreateURLDeskComp(IDataObject *pdtobj, POINTL pt)
{
    // This code should only be entered if DDIDM_CONTENTS_DESKURL was added to the menu,
    // and it has these checks:
    ASSERT(!PolicyNoActiveDesktop() &&
           !SHRestricted(REST_NOADDDESKCOMP) &&
           _IsDesktopFolder());
           
    STGMEDIUM medium = {0};
    FORMATETC fmte = {g_cfShellURL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        //DANGER WILL ROBINSON:
        //HTML is UTF-8, a mostly ANSI cross of ANSI and Unicode. Play with
        // it as is it were ANSI. Find a way to escape the sequences...
        CHAR *pszData = (CHAR*) GlobalLock(medium.hGlobal);
        if (pszData)
        {
            int nScheme = GetUrlSchemeA(pszData);
            if ((nScheme != URL_SCHEME_INVALID) && (nScheme != URL_SCHEME_FTP))
            {
                // This is an internet scheme - URL

                hr = CreateDesktopComponents(pszData, NULL, _hwnd, DESKCOMP_URL, pt.x, pt.y);
            }
            GlobalUnlock(medium.hGlobal);
        }
        else
        {
            hr = E_FAIL;
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}

HRESULT CFSDropTarget::_CreateDeskCompImage(IDataObject *pdtobj, POINTL pt)
{
    ASSERT(!PolicyNoActiveDesktop() &&
           !SHRestricted(REST_NOADDDESKCOMP) &&
           _IsDesktopFolder());
           
    FORMATETC fmte = {g_cfHTML, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {0};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        //DANGER WILL ROBINSON:
        //HTML is UTF-8, a mostly ANSI cross of ANSI and Unicode. Play with
        // it as is it were ANSI. Find a way to escape the sequences...
        CHAR *pszData = (CHAR*) GlobalLock(medium.hGlobal);
        if (pszData)
        {
            CHAR szUrl[MAX_URL_STRING];
            if (ExtractImageURLFromCFHTML(pszData, GlobalSize(medium.hGlobal), szUrl, ARRAYSIZE(szUrl)))
            {
                // The HTML contains an image tag - carry on...
                ADDTODESKTOP *pToAD;
                hr = SHLocalAlloc(sizeof(*pToAD), &pToAD);
                if (SUCCEEDED(hr))
                {
                    pToAD->hwnd = _hwnd;
                    lstrcpyA(pToAD->szUrl, szUrl);
                    pToAD->dwFlags = DESKCOMP_IMAGE;
                    pToAD->pt = pt;

                    if (SHCreateThread(AddToActiveDesktopThreadProc, pToAD, CTF_COINIT, NULL))
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        LocalFree(pToAD);
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }
            GlobalUnlock(medium.hGlobal);
        }
        else
            hr = E_FAIL;
        ReleaseStgMedium(&medium);
    }
    return hr;
}


//
// read byte by byte until we hit the null terminating char
// return: the number of bytes read
//
HRESULT StringReadFromStream(IStream* pstm, LPSTR pszBuf, UINT cchBuf)
{
    UINT cch = 0;
    
    do {
        pstm->Read(pszBuf, sizeof(CHAR), NULL);
        cch++;
    } while (*pszBuf++ && cch <= cchBuf);  
    return cch;
} 

HRESULT CopyStreamToFile(IStream* pstmSrc, LPCTSTR pszFile, ULONGLONG ullFileSize) 
{
    IStream *pstmFile;
    HRESULT hr = SHCreateStreamOnFile(pszFile, STGM_CREATE | STGM_WRITE | STGM_SHARE_DENY_WRITE, &pstmFile);
    if (SUCCEEDED(hr))
    {
        hr = CopyStreamUI(pstmSrc, pstmFile, NULL, ullFileSize);
        pstmFile->Release();
    }
    return hr;
}   

HRESULT CFSDropTarget::_CreatePackage(IDataObject *pdtobj)
{
    ILockBytes* pLockBytes;
    HRESULT hr = CreateILockBytesOnHGlobal(NULL, TRUE, &pLockBytes);
    if (SUCCEEDED(hr))
    {
        STGMEDIUM medium;
        medium.tymed = TYMED_ISTORAGE;
        hr = StgCreateDocfileOnILockBytes(pLockBytes,
                                        STGM_DIRECT | STGM_READWRITE | STGM_CREATE |
                                        STGM_SHARE_EXCLUSIVE, 0, &medium.pstg);
        if (SUCCEEDED(hr))
        {
            FORMATETC fmte = {g_cfEmbeddedObject, NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE};
            hr = pdtobj->GetDataHere(&fmte, &medium);
            if (SUCCEEDED(hr))
            {
                IStream* pstm;
#ifdef DEBUG
                STATSTG stat;
                if (SUCCEEDED(medium.pstg->Stat(&stat, STATFLAG_NONAME)))
                {
                    ASSERT(IsEqualCLSID(CLSID_OldPackage, stat.clsid) ||
                           IsEqualCLSID(CLSID_CPackage, stat.clsid));
                }
#endif // DEBUG                        
                #define PACKAGER_ICON           2
                #define PACKAGER_CONTENTS       L"\001Ole10Native"
                #define PACKAGER_EMBED_TYPE     3
                hr = medium.pstg->OpenStream(PACKAGER_CONTENTS, 0,
                                               STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                               0, &pstm);
                if (SUCCEEDED(hr))
                {
                    DWORD dw;
                    WORD w;
                    CHAR szName[MAX_PATH];
                    CHAR szTemp[MAX_PATH];
                    if (SUCCEEDED(pstm->Read(&dw, sizeof(dw), NULL)) && // pkg size
                        SUCCEEDED(pstm->Read(&w, sizeof(w), NULL)) &&   // pkg appearance
                        (PACKAGER_ICON == w) &&
                        SUCCEEDED(StringReadFromStream(pstm, szName, ARRAYSIZE(szName))) &&
                        SUCCEEDED(StringReadFromStream(pstm, szTemp, ARRAYSIZE(szTemp))) && // icon path
                        SUCCEEDED(pstm->Read(&w, sizeof(w), NULL)) &&   // icon index
                        SUCCEEDED(pstm->Read(&w, sizeof(w), NULL)) &&   // panetype
                        (PACKAGER_EMBED_TYPE == w) &&
                        SUCCEEDED(pstm->Read(&dw, sizeof(dw), NULL)) && // filename size
                        SUCCEEDED(pstm->Read(szTemp, dw, NULL)) &&      // filename
                        SUCCEEDED(pstm->Read(&dw, sizeof(dw), NULL)))   // get file size
                    {
                        // The rest of the stream is the file contents
                        TCHAR szPath[MAX_PATH], szBase[MAX_PATH], szDest[MAX_PATH];
                        _GetPath(szPath);

                        SHAnsiToTChar(szName, szBase, ARRAYSIZE(szBase));
                        PathAppend(szPath, szBase);
                        PathYetAnotherMakeUniqueName(szDest, szPath, NULL, szBase);
                        TraceMsg(TF_GENERAL, "CFSIDLDropTarget pkg: %s", szDest);

                        hr = CopyStreamToFile(pstm, szDest, dw);

                        if (SUCCEEDED(hr))
                        {
                            SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szDest, NULL);
                            if (_fBkDropTarget && _hwnd)
                            {
                                PositionFileFromDrop(_hwnd, szDest, NULL);
                            }
                        }
                    }
                    else
                    {
                        hr = E_UNEXPECTED;
                    }
                    pstm->Release();
                }
            }
            medium.pstg->Release();
        }
        pLockBytes->Release();
    }
    return hr;
}

HRESULT CFSDropTarget::_GetPath(LPTSTR pszPath)
{
    return _pFolder->_GetPath(pszPath);
}

LPCITEMIDLIST CFSDropTarget::_GetIDList()
{
    return _pFolder->_GetIDList();
}

DWORD CFSDropTarget::_EffectFromFolder()
{
    if (-1 == _dwEffectFolder)
    {
        _dwEffectFolder = DROPEFFECT_NONE;    // re-set to nothing (0)

        TCHAR szPath[MAX_PATH];
        // add a simple pathisroot check here to prevent it from hitting the disk (mostly floppy)
        // when we want the dropeffect probe to be fast (sendto, hovering over drives in view).
        // its not likely that we'll want to modify the root's drop effect, and this still allows
        // dropeffect modification on floppy subfolders.
        if (SUCCEEDED(_GetPath(szPath)) && !PathIsRoot(szPath) && PathAppend(szPath, TEXT("desktop.ini")))
        {
            _dwEffectFolder = GetPrivateProfileInt(STRINI_CLASSINFO, TEXT("DefaultDropEffect"), 0, szPath);
        }
    }
    return _dwEffectFolder;
}

BOOL AllRegisteredPrograms(HDROP hDrop)
{
    TCHAR szPath[MAX_PATH];

    for (UINT i = 0; DragQueryFile(hDrop, i, szPath, ARRAYSIZE(szPath)); i++)
    {
        if (!PathIsRegisteredProgram(szPath))
            return FALSE;
    }
    return TRUE;
}

BOOL IsBriefcaseRoot(IDataObject *pdtobj)
{
    BOOL bRet = FALSE;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        // Is there a briefcase root in this pdtobj?
        IShellFolder2 *psf;
        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, IDA_GetIDListPtr(pida, (UINT)-1), &psf))))
        {
            for (UINT i = 0; i < pida->cidl; i++) 
            {
                CLSID clsid;
                bRet = SUCCEEDED(GetItemCLSID(psf, IDA_GetIDListPtr(pida, i), &clsid)) &&
                        IsEqualCLSID(clsid, CLSID_Briefcase);
                if (bRet)
                    break;
            }
            psf->Release();
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return bRet;
}

//
// the "default effect" defines what will be choosen out of the allowed effects
//
//  If the data object does NOT contain HDROP -> "none"
//  else if the source data object has a default drop effect folder list (maybe based on sub folderness)
//  else if the source is root or registered progam -> "link"
//   else if this is within a volume   -> "move"
//   else if this is a briefcase       -> "move"
//   else                              -> "copy"
//
DWORD CFSDropTarget::_FilesystemAdjustedDefaultEffect(DWORD dwCurEffectAvail)
{
    DWORD dwDefEffect = DROPEFFECT_NONE;

    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {0};
    if (SUCCEEDED(_pdtobj->GetData(&fmte, &medium)))
    {
        TCHAR szPath[MAX_PATH];
        DragQueryFile((HDROP) medium.hGlobal, 0, szPath, ARRAYSIZE(szPath)); // focused item

        // DROPEFFECTFOLDERLIST allows the source of the data
        // to specify the desired drop effect for items under
        // certain parts of the name space.
        //
        // cd-burning does this to avoid the default move/copy computation
        // that would kick in for cross volume CD burning/staging area transfers

        FORMATETC fmteDropFolders = {g_cfDropEffectFolderList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM mediumDropFolders = {0};
        if (SUCCEEDED(_pdtobj->GetData(&fmteDropFolders, &mediumDropFolders)))
        {
            DROPEFFECTFOLDERLIST *pdefl = (DROPEFFECTFOLDERLIST*)GlobalLock(mediumDropFolders.hGlobal);
            if (pdefl)
            {
                // get the default effect from the list -- in the staging area case this is DROPEFFECT_COPY
                // so its a copy even if the staging area and source are on the same volume.
                dwDefEffect = pdefl->dwDefaultDropEffect;
                for (INT i = 0; i < pdefl->cFolders; i++)
                {
                    // some folders are excluded, for example if you move a file from one part of the staging
                    // area to another we override (to DROPEFFECT_MOVE in this case).
                    if (PathIsEqualOrSubFolder(pdefl->aFolders[i].wszPath, szPath))
                    {
                        dwDefEffect = pdefl->aFolders[i].dwDropEffect;
                        break;
                    }
                }
                GlobalUnlock(pdefl);          
            }
            ReleaseStgMedium(&mediumDropFolders);
        }

        if (DROPEFFECT_NONE == dwDefEffect)
        {
            dwDefEffect = _EffectFromFolder();
        }

        // If we didn't get a drop effect (==0) then lets fall back to the old checks
        if (DROPEFFECT_NONE == dwDefEffect)
        {
            TCHAR szFolder[MAX_PATH];
            _GetPath(szFolder);

            // drive/UNC roots and installed programs get link
            if (PathIsRoot(szPath) || AllRegisteredPrograms((HDROP)medium.hGlobal))
            {
                dwDefEffect = DROPEFFECT_LINK;
            }
            else if (PathIsSameRoot(szPath, szFolder))
            {
                dwDefEffect = DROPEFFECT_MOVE;
            }
            else if (IsBriefcaseRoot(_pdtobj))
            {
                // briefcase default to move even accross volumes
                dwDefEffect = DROPEFFECT_MOVE;
            }
            else
            {
                dwDefEffect = DROPEFFECT_COPY;
            }
        }
        ReleaseStgMedium(&medium);
    }
    else if (SUCCEEDED(_pdtobj->QueryGetData(&fmte)))
    {
        // but QueryGetData() succeeds!
        // this means this data object has HDROP but can't
        // provide it until it is dropped. Let's assume we are copying.
        dwDefEffect = DROPEFFECT_COPY;
    }

    // Switch default verb if the dwCurEffectAvail hint suggests that we picked an
    // unavailable effect (this code applies to MOVE and COPY only):
    dwCurEffectAvail &= (DROPEFFECT_MOVE | DROPEFFECT_COPY);
    if ((DROPEFFECT_MOVE == dwDefEffect) && (DROPEFFECT_COPY == dwCurEffectAvail))
    {
        // If we were going to return MOVE, and only COPY is available, return COPY:
        dwDefEffect = DROPEFFECT_COPY;
    }
    else if ((DROPEFFECT_COPY == dwDefEffect) && (DROPEFFECT_MOVE == dwCurEffectAvail))
    {
        // If we were going to return COPY, and only MOVE is available, return MOVE:
        dwDefEffect = DROPEFFECT_MOVE;
    }
    return dwDefEffect;
}

//
// make sure that the default effect is among the allowed effects
//
DWORD CFSDropTarget::_LimitDefaultEffect(DWORD dwDefEffect, DWORD dwEffectsAllowed)
{
    if (dwDefEffect & dwEffectsAllowed)
        return dwDefEffect;

    if (dwEffectsAllowed & DROPEFFECT_COPY)
        return DROPEFFECT_COPY;

    if (dwEffectsAllowed & DROPEFFECT_MOVE)
        return DROPEFFECT_MOVE;

    if (dwEffectsAllowed & DROPEFFECT_LINK)
        return DROPEFFECT_LINK;

    return DROPEFFECT_NONE;
}

// Handy abbreviation
#define TYMED_ALLCONTENT        (TYMED_HGLOBAL | TYMED_ISTREAM | TYMED_ISTORAGE)

// Use  FSDH for registered clipboard formats (anything of the form g_cf*)
// Use _FSDH for predefined clipboard formats (like CF_HDROP or 0)
// Generate the _DATA_HANDLER array
#define  FSDH(pfn, cf, dva, tymed) { {              0, NULL, dva, -1, tymed }, pfn, &cf  }
#define _FSDH(pfn, cf, dva, tymed) { { (CLIPFORMAT)cf, NULL, dva, -1, tymed }, pfn, NULL }

// NOTE: the order is important (particularly for multiple entries with the same FORMATETC)

CFSDropTarget::_DATA_HANDLER
CFSDropTarget::rg_data_handlers[NUM_DATA_HANDLERS] = {
    FSDH(_FilterFileContents,        g_cfFileGroupDescriptorW, DVASPECT_CONTENT, TYMED_HGLOBAL),
    FSDH(_FilterFileContentsOLEHack, g_cfFileGroupDescriptorW, DVASPECT_LINK,    TYMED_HGLOBAL),
    FSDH(_FilterFileContents,        g_cfFileGroupDescriptorA, DVASPECT_CONTENT, TYMED_HGLOBAL),
    FSDH(_FilterFileContentsOLEHack, g_cfFileGroupDescriptorA, DVASPECT_LINK,    TYMED_HGLOBAL),
    FSDH(_FilterFileContents,        g_cfFileContents,         DVASPECT_CONTENT, TYMED_ALLCONTENT),
    FSDH(_FilterFileContentsOLEHack, g_cfFileContents,         DVASPECT_LINK,    TYMED_ALLCONTENT),
   _FSDH(_FilterBriefcase,           CF_HDROP,                 DVASPECT_CONTENT, TYMED_HGLOBAL), 
   _FSDH(_FilterSneakernetBriefcase, CF_HDROP,                 DVASPECT_CONTENT, TYMED_HGLOBAL),
   _FSDH(_FilterHDROP,               CF_HDROP,                 DVASPECT_CONTENT, TYMED_HGLOBAL),
   _FSDH(_FilterDeskCompHDROP,       CF_HDROP,                 DVASPECT_CONTENT, TYMED_HGLOBAL),
    FSDH(_FilterHIDA,                g_cfHIDA,                 DVASPECT_CONTENT, TYMED_HGLOBAL),
    FSDH(_FilterOlePackage,          g_cfEmbeddedObject,       DVASPECT_CONTENT, TYMED_ISTORAGE),
    FSDH(_FilterDeskImage,           g_cfHTML,                 DVASPECT_CONTENT, TYMED_HGLOBAL),
    FSDH(_FilterDeskComp,            g_cfShellURL,             DVASPECT_CONTENT, TYMED_HGLOBAL),
   _FSDH(_FilterOleObj,              0,                        DVASPECT_CONTENT, TYMED_HGLOBAL),
   _FSDH(_FilterOleLink,             0,                        DVASPECT_CONTENT, TYMED_HGLOBAL),
};

// Note that it's safe to race with another thread in this code
// since the function is idemponent.  (Call it as many times as you
// like -- only the first time through actually does anything.)

void CFSDropTarget::_Init_rg_data_handlers()
{
    for (int i = 0; i < ARRAYSIZE(rg_data_handlers); i++)
    {
        // If this assertion fires, then you have to change the value of
        // NUM_DATA_HANDLERS to match the number of entries in the array
        // definition.
        ASSERT(rg_data_handlers[i].fmte.tymed);

        if (rg_data_handlers[i].pcfInit)
        {
            rg_data_handlers[i].fmte.cfFormat = *rg_data_handlers[i].pcfInit;
        }
    }
}

//
// returns the default effect.
// also modifies *pdwEffectInOut to indicate "available" operations.
//
DWORD CFSDropTarget::_DetermineEffects(DWORD grfKeyState, DWORD *pdwEffectInOut, HMENU hmenu)
{
    DWORD dwDefaultEffect = DROPEFFECT_NONE;
    DWORD dwEffectsUsed = DROPEFFECT_NONE;

    _Init_rg_data_handlers();

    // Loop through formats, factoring in both the order of the enumerator and
    // the order of our rg_data_handlers to determine the default effect
    // (and possibly, to create the drop context menu)
    FSMENUINFO fsmi = { hmenu, 0, 0, 0 };
    IEnumFORMATETC *penum;
    AssertMsg((NULL != _pdtobj), TEXT("CFSDropTarget::_DetermineEffects() _pdtobj is NULL but we need it.  this=%#08lx"), this);
    if (_pdtobj && SUCCEEDED(_pdtobj->EnumFormatEtc(DATADIR_GET, &penum)))
    {
        FORMATETC fmte;
        ULONG celt;
        while (penum->Next(1, &fmte, &celt) == S_OK)
        {
            for (int i = 0; i < ARRAYSIZE(rg_data_handlers); i++)
            {
                if (rg_data_handlers[i].fmte.cfFormat == fmte.cfFormat &&
                    rg_data_handlers[i].fmte.dwAspect == fmte.dwAspect &&
                    (rg_data_handlers[i].fmte.tymed & fmte.tymed))
                {
                    // keep passing dwDefaultEffect until someone computes one, this
                    // lets the first guy that figures out the default be the default
                    (this->*(rg_data_handlers[i].pfnGetDragDropInfo))(
                        &fmte, grfKeyState, *pdwEffectInOut, &dwEffectsUsed,
                        (DROPEFFECT_NONE == dwDefaultEffect) ? &dwDefaultEffect : NULL,
                        hmenu ? &fsmi : NULL);
                }
            }
            SHFree(fmte.ptd);
        }
        penum->Release();
    }
    // Loop through the rg_data_handlers that don't have an associated clipboard format last
    for (int i = 0; i < ARRAYSIZE(rg_data_handlers); i++)
    {
        if (0 == rg_data_handlers[i].fmte.cfFormat)
        {
            // if default effect is still not computed continue to pass that
            (this->*(rg_data_handlers[i].pfnGetDragDropInfo))(
               NULL, grfKeyState, *pdwEffectInOut, &dwEffectsUsed,
               (DROPEFFECT_NONE == dwDefaultEffect) ? &dwDefaultEffect : NULL,
               hmenu ? &fsmi : NULL);
        }
    }

    *pdwEffectInOut &= dwEffectsUsed;

    dwDefaultEffect = _LimitDefaultEffect(dwDefaultEffect, *pdwEffectInOut);

    DebugMsg(TF_FSTREE, TEXT("CFSDT::GetDefaultEffect dwDef=%x, dwEffUsed=%x, *pdw=%x"),
             dwDefaultEffect, dwEffectsUsed, *pdwEffectInOut);

    return dwDefaultEffect; // this is what we want to do
}

// This is used to map command id's back to dropeffect's:

const struct {
    UINT uID;
    DWORD dwEffect;
} c_IDFSEffects[] = {
    DDIDM_COPY,         DROPEFFECT_COPY,
    DDIDM_MOVE,         DROPEFFECT_MOVE,
    DDIDM_CONTENTS_DESKCOMP,     DROPEFFECT_LINK,
    DDIDM_LINK,         DROPEFFECT_LINK,
    DDIDM_SCRAP_COPY,   DROPEFFECT_COPY,
    DDIDM_SCRAP_MOVE,   DROPEFFECT_MOVE,
    DDIDM_DOCLINK,      DROPEFFECT_LINK,
    DDIDM_CONTENTS_COPY, DROPEFFECT_COPY,
    DDIDM_CONTENTS_MOVE, DROPEFFECT_MOVE,
    DDIDM_CONTENTS_LINK, DROPEFFECT_LINK,
    DDIDM_CONTENTS_DESKIMG,     DROPEFFECT_LINK,
    DDIDM_SYNCCOPYTYPE, DROPEFFECT_COPY,        // (order is important)
    DDIDM_SYNCCOPY,     DROPEFFECT_COPY,
    DDIDM_OBJECT_COPY,  DROPEFFECT_COPY,
    DDIDM_OBJECT_MOVE,  DROPEFFECT_MOVE,
    DDIDM_CONTENTS_DESKURL,  DROPEFFECT_LINK,
};

void CFSDropTarget::_FixUpDefaultItem(HMENU hmenu, DWORD dwDefEffect)
{
    // only do stuff if there is no default item already and we have a default effect
    if ((GetMenuDefaultItem(hmenu, MF_BYPOSITION, 0) == -1) && dwDefEffect)
    {
        for (int i = 0; i < GetMenuItemCount(hmenu); i++)
        {
            // for menu item matching default effect, make it the default.
            MENUITEMINFO mii = { 0 };
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_DATA | MIIM_STATE;
            if (GetMenuItemInfo(hmenu, i, MF_BYPOSITION, &mii) && (mii.dwItemData == dwDefEffect))
            {
                mii.fState |= MFS_DEFAULT;
                SetMenuItemInfo(hmenu, i, MF_BYPOSITION, &mii);
                break;
            }
        }
    }
}

HRESULT CFSDropTarget::_DragDropMenu(FSDRAGDROPMENUPARAM *pddm)
{
    HRESULT hr = E_OUTOFMEMORY;       // assume error
    DWORD dwEffectOut = 0;                              // assume no-ope.
    if (pddm->hmenu)
    {
        UINT idCmd;
        UINT idCmdFirst = DDIDM_EXTFIRST;
        HDXA hdxa = HDXA_Create();
        HDCA hdca = DCA_Create();
        if (hdxa && hdca)
        {
            // Enumerate the DD handlers and let them append menu items.
            for (DWORD i = 0; i < pddm->ck; i++)
            {
                DCA_AddItemsFromKey(hdca, pddm->rghk[i], STRREG_SHEX_DDHANDLER);
            }

            idCmdFirst = HDXA_AppendMenuItems(hdxa, pddm->pdtobj, pddm->ck,
                pddm->rghk, _GetIDList(), pddm->hmenu, 0,
                DDIDM_EXTFIRST, DDIDM_EXTLAST, 0, hdca);
        }

        // modifier keys held down to force operations that are not permitted (for example
        // alt to force a shortcut from the start menu, which does not have SFGAO_CANLINK)
        // can result in no default items on the context menu.  however in displaying the
        // cursor overlay in this case we fall back to DROPEFFECT_COPY.  a left drag then
        // tries to invoke the default menu item (user thinks its copy) but theres no default.

        // this function selects a default menu item to match the default effect if there
        // is no default item already.
        _FixUpDefaultItem(pddm->hmenu, pddm->dwDefEffect);

        // If this dragging is caused by the left button, simply choose
        // the default one, otherwise, pop up the context menu.  If there
        // is no key state info and the original effect is the same as the
        // current effect, choose the default one, otherwise pop up the
        // context menu.  
        if ((_grfKeyStateLast & MK_LBUTTON) ||
             (!_grfKeyStateLast && (*(pddm->pdwEffect) == pddm->dwDefEffect)))
        {
            idCmd = GetMenuDefaultItem(pddm->hmenu, MF_BYCOMMAND, 0);

            // This one MUST be called here. Please read its comment block.
            DAD_DragLeave();

            if (_hwnd)
                SetForegroundWindow(_hwnd);
        }
        else
        {
            // Note that SHTrackPopupMenu calls DAD_DragLeave().
            idCmd = SHTrackPopupMenu(pddm->hmenu, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                    pddm->pt.x, pddm->pt.y, 0, _hwnd, NULL);
        }

        //
        // We also need to call this here to release the dragged image.
        //
        DAD_SetDragImage(NULL, NULL);

        //
        // Check if the user selected one of add-in menu items.
        //
        if (idCmd == 0)
        {
            hr = S_OK;        // Canceled by the user, return S_OK
        }
        else if (InRange(idCmd, DDIDM_EXTFIRST, DDIDM_EXTLAST))
        {
            //
            // Yes. Let the context menu handler process it.
            //
            CMINVOKECOMMANDINFOEX ici = {
                sizeof(CMINVOKECOMMANDINFOEX),
                0L,
                _hwnd,
                (LPSTR)MAKEINTRESOURCE(idCmd - DDIDM_EXTFIRST),
                NULL, NULL,
                SW_NORMAL,
            };

            // record if the shift/control keys were down at the time of the drop
            if (_grfKeyStateLast & MK_SHIFT)
            {
                ici.fMask |= CMIC_MASK_SHIFT_DOWN;
            }

            if (_grfKeyStateLast & MK_CONTROL)
            {
                ici.fMask |= CMIC_MASK_CONTROL_DOWN;
            }

            // We may not want to ignore the error code. (Can happen when you use the context menu
            // to create new folders, but I don't know if that can happen here.).
            HDXA_LetHandlerProcessCommandEx(hdxa, &ici, NULL);
            hr = S_OK;
        }
        else
        {
            for (int nItem = 0; nItem < ARRAYSIZE(c_IDFSEffects); ++nItem)
            {
                if (idCmd == c_IDFSEffects[nItem].uID)
                {
                    dwEffectOut = c_IDFSEffects[nItem].dwEffect;
                    break;
                }
            }

            hr = S_FALSE;
        }

        if (hdca)
            DCA_Destroy(hdca);

        if (hdxa)
            HDXA_Destroy(hdxa);

        pddm->idCmd = idCmd;
    }

    *pddm->pdwEffect = dwEffectOut;

    return hr;
}

void _MapName(void *hNameMap, LPTSTR pszPath)
{
    if (hNameMap)
    {
        SHNAMEMAPPING *pNameMapping;
        for (int i = 0; (pNameMapping = SHGetNameMappingPtr((HDSA)hNameMap, i)) != NULL; i++)
        {
            if (lstrcmpi(pszPath, pNameMapping->pszOldPath) == 0)
            {
                lstrcpy(pszPath, pNameMapping->pszNewPath);
                break;
            }
        }
    }
}

// convert double null list of files to array of pidls

int FileListToIDArray(LPCTSTR pszFiles, void *hNameMap, LPITEMIDLIST **pppidl)
{
    int i = 0;
    int nItems = CountFiles(pszFiles);
    LPITEMIDLIST *ppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, nItems * sizeof(*ppidl));
    if (ppidl)
    {
        *pppidl = ppidl;

        while (*pszFiles)
        {
            TCHAR szPath[MAX_PATH];
            lstrcpy(szPath, pszFiles);

            _MapName(hNameMap, szPath);

            ppidl[i] = SHSimpleIDListFromPath(szPath);

            pszFiles += lstrlen(pszFiles) + 1;
            i++;
        }
    }
    return i;
}

// move items to the new drop location

void CFSDropTarget::_MoveSelectIcons(IDataObject *pdtobj, IFolderView* pfv, void *hNameMap, LPCTSTR pszFiles, BOOL fMove, HDROP hDrop)
{
    LPITEMIDLIST *ppidl = NULL;
    int cidl;

    if (pszFiles) 
    {
        cidl = FileListToIDArray(pszFiles, hNameMap, &ppidl);
    } 
    else 
    {
        cidl = CreateMoveCopyList(hDrop, hNameMap, &ppidl);
    }

    if (ppidl)
    {
        if (pfv)
            PositionItems(pfv, (LPCITEMIDLIST*)ppidl, cidl, pdtobj, fMove ? &_ptDrop : NULL);

        FreeIDListArray(ppidl, cidl);
    }
}

// this is the ILIsParent which matches up the desktop with the desktop directory.
BOOL AliasILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPITEMIDLIST pidlUse1 = SHLogILFromFSIL(pidl1);
    if (pidlUse1)
        pidl1 = pidlUse1;

    LPITEMIDLIST pidlUse2 = SHLogILFromFSIL(pidl2);
    if (pidlUse2)
        pidl2 = pidlUse2;

    BOOL fSame = ILIsParent(pidl1, pidl2, TRUE);

    ILFree(pidlUse1);   // NULL is OK here
    ILFree(pidlUse2);

    return fSame;
}

// in:
//      pszDestDir      destination dir for new file names
//      pszDestSpecs    double null list of destination specs
//
// returns:
//      double null list of fully qualified destination file names to be freed
//      with LocalFree()
//

LPTSTR RemapDestNamesW(LPCTSTR pszDestDir, LPCWSTR pszDestSpecs)
{
    UINT cbDestSpec = lstrlen(pszDestDir) * sizeof(TCHAR) + sizeof(TCHAR);
    LPCWSTR pszTemp;
    UINT cbAlloc = sizeof(TCHAR);       // for double NULL teriminaion of entire string

    // compute length of buffer to aloc
    for (pszTemp = pszDestSpecs; *pszTemp; pszTemp += lstrlenW(pszTemp) + 1)
    {
        // +1 for null teriminator
        cbAlloc += cbDestSpec + lstrlenW(pszTemp) * sizeof(TCHAR) + sizeof(TCHAR);
    }

    LPTSTR pszRet = (LPTSTR)LocalAlloc(LPTR, cbAlloc);
    if (pszRet)
    {
        LPTSTR pszDest = pszRet;

        for (pszTemp = pszDestSpecs; *pszTemp; pszTemp += lstrlenW(pszTemp) + 1)
        {
            // PathCombine requires dest buffer of MAX_PATH size or it'll rip in call
            // to PathCanonicalize (IsBadWritePtr)
            TCHAR szTempDest[MAX_PATH];
            PathCombine(szTempDest, pszDestDir, pszTemp);
            lstrcpy(pszDest, szTempDest);
            pszDest += lstrlen(pszDest) + 1;

            ASSERT((UINT)((BYTE *)pszDest - (BYTE *)pszRet) < cbAlloc);
            ASSERT(*pszDest == 0);      // zero init alloc
        }
        ASSERT((LPTSTR)((BYTE *)pszRet + cbAlloc - sizeof(TCHAR)) >= pszDest);
        ASSERT(*pszDest == 0);  // zero init alloc

    }
    return pszRet;
}

LPTSTR RemapDestNamesA(LPCTSTR pszDestDir, LPCSTR pszDestSpecs)
{
    UINT cbDestSpec = lstrlen(pszDestDir) * sizeof(TCHAR) + sizeof(TCHAR);
    LPCSTR pszTemp;
    LPTSTR pszRet;
    UINT cbAlloc = sizeof(TCHAR);       // for double NULL teriminaion of entire string

    // compute length of buffer to aloc
    for (pszTemp = pszDestSpecs; *pszTemp; pszTemp += lstrlenA(pszTemp) + 1)
    {
        // +1 for null teriminator
        cbAlloc += cbDestSpec + lstrlenA(pszTemp) * sizeof(TCHAR) + sizeof(TCHAR);
    }

    pszRet = (LPTSTR)LocalAlloc(LPTR, cbAlloc);
    if (pszRet)
    {
        LPTSTR pszDest = pszRet;

        for (pszTemp = pszDestSpecs; *pszTemp; pszTemp += lstrlenA(pszTemp) + 1)
        {
            // PathCombine requires dest buffer of MAX_PATH size or it'll rip in call
            // to PathCanonicalize (IsBadWritePtr)
            TCHAR szTempDest[MAX_PATH];
            WCHAR wszTemp[MAX_PATH];
            SHAnsiToUnicode(pszTemp, wszTemp, ARRAYSIZE(wszTemp));
            PathCombine(szTempDest, pszDestDir, wszTemp);
            lstrcpy(pszDest, szTempDest);
            pszDest += lstrlen(pszDest) + 1;

            ASSERT((UINT)((BYTE *)pszDest - (BYTE *)pszRet) < cbAlloc);
            ASSERT(*pszDest == 0);      // zero init alloc
        }
        ASSERT((LPTSTR)((BYTE *)pszRet + cbAlloc - sizeof(TCHAR)) >= pszDest);
        ASSERT(*pszDest == 0);  // zero init alloc

    }
    return pszRet;
}

LPTSTR _GetDestNames(IDataObject *pdtobj, LPCTSTR pszPath)
{
    LPTSTR pszDestNames = NULL;

    STGMEDIUM medium;
    FORMATETC fmte = {g_cfFileNameMapW, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (S_OK == pdtobj->GetData(&fmte, &medium))
    {
        pszDestNames = RemapDestNamesW(pszPath, (LPWSTR)GlobalLock(medium.hGlobal));
        ReleaseStgMediumHGLOBAL(medium.hGlobal, &medium);
    }
    else
    {
        fmte.cfFormat = g_cfFileNameMapA;
        if (S_OK == pdtobj->GetData(&fmte, &medium))
        {
            pszDestNames = RemapDestNamesA(pszPath, (LPSTR)GlobalLock(medium.hGlobal));
            ReleaseStgMediumHGLOBAL(medium.hGlobal, &medium);
        }
    }
    return pszDestNames;
}

BOOL _IsInSameFolder(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj)
{
    BOOL bRet = FALSE;
    STGMEDIUM medium = {0};
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        for (UINT i = 0; i < pida->cidl; i++) 
        {
            LPITEMIDLIST pidl = IDA_FullIDList(pida, i);
            if (pidl)
            {
                // if we're doing keyboard cut/copy/paste
                //  to and from the same directories
                // This is needed for common desktop support - BobDay/EricFlo
                if (AliasILIsParent(pidlFolder, pidl))
                {
                    bRet = TRUE;
                }
                ILFree(pidl);
            }
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return bRet;
}

LPCTSTR _RootSpecialCase(LPCTSTR pszFiles, LPTSTR pszSrc, LPTSTR pszDest)
{
    if ((1 == CountFiles(pszFiles)) &&
        PathIsRoot(pszFiles))
    {
        SHFILEINFO sfi;

        // NOTE: don't use SHGFI_USEFILEATTRIBUTES because the simple IDList
        // support for \\server\share produces the wrong name
        if (SHGetFileInfo(pszFiles, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME)) 
        {
            if (!(PCS_FATAL & PathCleanupSpec(pszDest, sfi.szDisplayName)))
            {
                PathAppend(pszDest, sfi.szDisplayName); // sub dir name based on source root path
                PathCombine(pszSrc, pszFiles, TEXT("*.*")); // all files on source
                pszFiles = pszSrc;
            }
        }
    }
    return pszFiles;
}

void CFSDropTarget::_MoveCopy(IDataObject *pdtobj, IFolderView* pfv, HDROP hDrop)
{
#ifdef DEBUG
    if (_hwnd == NULL)
    {
        TraceMsg(TF_GENERAL, "_MoveCopy() without an hwnd which will prevent displaying insert disk UI");
    }
#endif // DEBUG

    DRAGINFO di = { sizeof(di) };
    if (DragQueryInfo(hDrop, &di))
    {
        TCHAR szDest[MAX_PATH] = {0}; // zero init for dbl null termination

        _GetPath(szDest);

        switch (_idCmd) 
        {
        case DDIDM_MOVE:

            if (_fSameHwnd)
            {
                _MoveSelectIcons(pdtobj, pfv, NULL, NULL, TRUE, hDrop);
                break;
            }

            // fall through...

        case DDIDM_COPY:
            {
                TCHAR szAltSource[MAX_PATH] = {0};  // zero init for dbl null termination
                LPCTSTR pszSource = _RootSpecialCase(di.lpFileList, szAltSource, szDest);

                SHFILEOPSTRUCT fo = 
                {
                    _hwnd,
                    (DDIDM_COPY == _idCmd) ? FO_COPY : FO_MOVE,
                    pszSource,
                    szDest,
                    FOF_WANTMAPPINGHANDLE | FOF_ALLOWUNDO | FOF_NOCONFIRMMKDIR
                };
                if (fo.wFunc == FO_MOVE && IsFolderSecurityModeOn())
                {
                    fo.fFlags |= FOF_NOCOPYSECURITYATTRIBS;
                }

                // if they are in the same hwnd or to and from
                // the same directory, turn on the automatic rename on collision flag
                if (_fSameHwnd || 
                    ((DDIDM_COPY == _idCmd) && _IsInSameFolder(_GetIDList(), pdtobj)))
                {
                    // do rename on collision for copy;
                    fo.fFlags |=  FOF_RENAMEONCOLLISION;
                }

                // see if there is a rename mapping from recycle bin (or someone else)

                LPTSTR pszDestNames = _GetDestNames(pdtobj, szDest);
                if (pszDestNames)
                {
                    fo.pTo = pszDestNames;
                    fo.fFlags |= FOF_MULTIDESTFILES;
                    fo.fFlags &= ~FOF_ALLOWUNDO;    // HACK, this came from the recycle bin, don't allow undo
                }

                {
                    static UINT s_cfFileOpFlags = 0;
                    if (0 == s_cfFileOpFlags)
                        s_cfFileOpFlags = RegisterClipboardFormat(TEXT("FileOpFlags"));

                    fo.fFlags = (FILEOP_FLAGS)DataObj_GetDWORD(pdtobj, s_cfFileOpFlags, fo.fFlags);
                }

                // Check if there were any errors
                if (SHFileOperation(&fo) == 0 && !fo.fAnyOperationsAborted)
                {
                    if (_fBkDropTarget)
                        ShellFolderView_SetRedraw(_hwnd, 0);

                    SHChangeNotifyHandleEvents();   // force update now
                    if (_fBkDropTarget) 
                    {
                        _MoveSelectIcons(pdtobj, pfv, fo.hNameMappings, pszDestNames, _fDragDrop, hDrop);
                        ShellFolderView_SetRedraw(_hwnd, TRUE);
                    }
                }

                if (fo.hNameMappings)
                    SHFreeNameMappings(fo.hNameMappings);

                if (pszDestNames)
                {
                    LocalFree((HLOCAL)pszDestNames);

                    // HACK, this usually comes from the bitbucket
                    // but in our shell, we don't handle the moves from the source
                    if (DDIDM_MOVE == _idCmd)
                        BBCheckRestoredFiles(pszSource);
                }
            }

            break;
        }
        SHFree(di.lpFileList);
    }
}

const UINT c_rgFolderShortcutTargets[] = {
    CSIDL_STARTMENU,
    CSIDL_COMMON_STARTMENU,
    CSIDL_PROGRAMS,
    CSIDL_COMMON_PROGRAMS,
    CSIDL_NETHOOD,
};

BOOL _ShouldCreateFolderShortcut(LPCTSTR pszFolder)
{
    return PathIsEqualOrSubFolderOf(pszFolder, c_rgFolderShortcutTargets, ARRAYSIZE(c_rgFolderShortcutTargets));
}

void CFSDropTarget::_DoDrop(IDataObject *pdtobj, IFolderView* pfv)
{
    HRESULT hr = E_FAIL;

    // Sleep(10 * 1000);   // to debug async case

    TCHAR szPath[MAX_PATH];   
    _GetPath(szPath);
    SHCreateDirectory(NULL, szPath);      // if this fails we catch it later
    
    switch (_idCmd)
    {
    case DDIDM_SYNCCOPY:
    case DDIDM_SYNCCOPYTYPE:
        if (_IsBriefcaseTarget())
        {
            IBriefcaseStg *pbrfstg;
            if (SUCCEEDED(CreateBrfStgFromPath(szPath, _hwnd, &pbrfstg)))
            {
                hr = pbrfstg->AddObject(pdtobj, NULL,
                    (DDIDM_SYNCCOPYTYPE == _idCmd) ? AOF_FILTERPROMPT : AOF_DEFAULT,
                    _hwnd);
                pbrfstg->Release();
            }
        }
        else
        {
            // Perform a sneakernet addition to the briefcase
            STGMEDIUM medium;
            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                // Is there a briefcase root in this pdtobj?
                IBriefcaseStg *pbrfstg;
                if (SUCCEEDED(CreateBrfStgFromIDList(IDA_GetIDListPtr(pida, (UINT)-1), _hwnd, &pbrfstg)))
                {
                    hr = pbrfstg->AddObject(pdtobj, szPath,
                        (DDIDM_SYNCCOPYTYPE == _idCmd) ? AOF_FILTERPROMPT : AOF_DEFAULT,
                        _hwnd);
                    pbrfstg->Release();
                }

                HIDA_ReleaseStgMedium(pida, &medium);
            }
        }
        break;

    case DDIDM_COPY:
    case DDIDM_MOVE:
        {
            STGMEDIUM medium;
            FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            hr = pdtobj->GetData(&fmte, &medium);
            if (SUCCEEDED(hr))
            {
                _MoveCopy(pdtobj, pfv, (HDROP)medium.hGlobal);
                ReleaseStgMedium(&medium);
            }
        }
        break;

    case DDIDM_LINK:
        {
            int i = 0;
            LPITEMIDLIST *ppidl = NULL;

            if (_fBkDropTarget)
            {
                i = DataObj_GetHIDACount(pdtobj);
                ppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, sizeof(*ppidl) * i);
            }

            // _grfKeyStateLast of 0 means this was a simulated drop
            UINT uCreateFlags = _grfKeyStateLast && !(_dwEffectFolder & DROPEFFECT_LINK) ? SHCL_USETEMPLATE : 0;

            if (_ShouldCreateFolderShortcut(szPath))
                uCreateFlags |= SHCL_MAKEFOLDERSHORTCUT;

            ShellFolderView_SetRedraw(_hwnd, FALSE);
            // passing ppidl == NULL is correct in failure case
            hr = SHCreateLinks(_hwnd, szPath, pdtobj, uCreateFlags, ppidl);
            if (ppidl)
            {
                if (pfv)
                    PositionItems(pfv, (LPCITEMIDLIST*)ppidl, i, pdtobj, &_ptDrop);

                FreeIDListArray(ppidl, i);
            }
            ShellFolderView_SetRedraw(_hwnd, TRUE);
        }
        break;
    }

    if (SUCCEEDED(hr) && _dwEffect)
    {
        DataObj_SetDWORD(pdtobj, g_cfLogicalPerformedDropEffect, _dwEffect);
        DataObj_SetDWORD(pdtobj, g_cfPerformedDropEffect, _dwEffect);
    }

    SHChangeNotifyHandleEvents();       // force update now
}

DWORD CALLBACK CFSDropTarget::_DoDropThreadProc(void *pv)
{
    DROPTHREADPARAMS *pdtp = (DROPTHREADPARAMS *)pv;

    IDataObject *pdtobj;
    if (SUCCEEDED(CoGetInterfaceAndReleaseStream(pdtp->pstmDataObj, IID_PPV_ARG(IDataObject, &pdtobj))))
    {
        IFolderView* pfv;
        if (FAILED(CoGetInterfaceAndReleaseStream(pdtp->pstmFolderView, IID_PPV_ARG(IFolderView, &pfv))))
            pfv = NULL;

        pdtp->pThis->_DoDrop(pdtobj, pfv);

        if (pfv)
            pfv->Release();

        pdtp->pstmFolderView = NULL;  // stream now invalid; CoGetInterfaceAndReleaseStream already released it
        pdtobj->Release();
    }

    pdtp->pstmDataObj    = NULL;  // stream now invalid; CoGetInterfaceAndReleaseStream already released it
    _FreeThreadParams(pdtp);

    CoFreeUnusedLibraries();
    return 0;
}

// REARCHITECT: view and drop related helpers, these use the ugly old private defview messages
// we should replace the usage of this stuff with IShellFolderView programming


// create the pidl array that contains the destination file names. this is
// done by taking the source file names, and translating them through the
// name mapping returned by the copy engine.
//
//
// in:
//      hDrop           HDROP containing files recently moved/copied
//      hNameMap   used to translate names
//
// out:
//      *pppidl         id array of length return value
//      # of items in pppida

//
//  WARNING!  You must use the provided HDROP.  Do not attempt to ask the
//  data object for a HDROP or HIDA or WS_FTP will break!  They don't like
//  it if you ask them for HDROP/HIDA, move the files to a new location
//  (via the copy engine), and then ask them for HDROP/HIDA a second time.
//  They notice that "Hey, those files I downloaded last time are gone!"
//  and then get confused.
//
STDAPI_(int) CreateMoveCopyList(HDROP hDrop, void *hNameMap, LPITEMIDLIST **pppidl)
{
    int nItems = 0;

    if (hDrop)
    {
        nItems = DragQueryFile(hDrop, (UINT)-1, NULL, 0);
        *pppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, nItems * sizeof(*pppidl));
        if (*pppidl)
        {
            for (int i = nItems - 1; i >= 0; i--)
            {
                TCHAR szPath[MAX_PATH];
                DragQueryFile(hDrop, i, szPath, ARRAYSIZE(szPath));
                _MapName(hNameMap, szPath);
                (*pppidl)[i] = SHSimpleIDListFromPath(szPath);
            }
        }
    }
    return nItems;
}

// this is really not related to CFSFolder. it is generic over any view
// REARCHITECT: convert view hwnd programming to site pointer

STDAPI_(void) PositionFileFromDrop(HWND hwnd, LPCTSTR pszFile, DROPHISTORY *pdh)
{
    LPITEMIDLIST pidl = SHSimpleIDListFromPath(pszFile);
    if (pidl)
    {
        LPITEMIDLIST pidlNew = ILFindLastID(pidl);
        HWND hwndView = ShellFolderViewWindow(hwnd);
        SFM_SAP sap;
        
        SHChangeNotifyHandleEvents();
        
        // Fill in some easy SAP fields first.
        sap.uSelectFlags = SVSI_SELECT;
        sap.fMove = TRUE;
        sap.pidl = pidlNew;

        // Now compute the x,y coordinates.
        // If we have a drop history, use it to determine the
        // next point.

        if (pdh)
        {
            // fill in the anchor point first...
            if (!pdh->fInitialized)
            {
                ITEMSPACING is;
                
                ShellFolderView_GetDropPoint(hwnd, &pdh->ptOrigin);
                
                pdh->pt = pdh->ptOrigin;    // Compute the first point.
                
                // Compute the point deltas.
                if (ShellFolderView_GetItemSpacing(hwnd, &is))
                {
                    pdh->cxItem = is.cxSmall;
                    pdh->cyItem = is.cySmall;
                    pdh->xDiv = is.cxLarge;
                    pdh->yDiv = is.cyLarge;
                    pdh->xMul = is.cxSmall;
                    pdh->yMul = is.cySmall;
                }
                else
                {
                    pdh->cxItem = g_cxIcon;
                    pdh->cyItem = g_cyIcon;
                    pdh->xDiv = pdh->yDiv = pdh->xMul = pdh->yMul = 1;
                }
                
                // First point gets special flags.
                sap.uSelectFlags |= SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS | SVSI_FOCUSED;
                
                pdh->fInitialized = TRUE;   // We be initialized.
            }
            // if we have no list of offsets, then just inc by icon size..
            else if ( !pdh->pptOffset )
            {
                // Simple computation of the next point.
                pdh->pt.x += pdh->cxItem;
                pdh->pt.y += pdh->cyItem;
            }
            
            // do this after the above stuff so that we always get our position relative to the anchor
            // point, if we use the anchor point as the first one things get screwy...
            if (pdh->pptOffset)
            {
                // Transform the old offset to our coordinates.
                pdh->pt.x = ((pdh->pptOffset[pdh->iItem].x * pdh->xMul) / pdh->xDiv) + pdh->ptOrigin.x;
                pdh->pt.y = ((pdh->pptOffset[pdh->iItem].y * pdh->yMul) / pdh->yDiv) + pdh->ptOrigin.y;
            }
            
            sap.pt = pdh->pt;   // Copy the next point from the drop history.
        }
        else
        {
            // Preinitialize this puppy in case the folder view doesn't
            // know what the drop point is (e.g., if it didn't come from
            // a drag/drop but rather from a paste or a ChangeNotify.)
            sap.pt.x = 0x7FFFFFFF;      // "don't know"
            sap.pt.y = 0x7FFFFFFF;

            // Get the drop point, conveniently already in
            // defview's screen coordinates.
            //
            // pdv->bDropAnchor should be TRUE at this point,
            // see DefView's GetDropPoint() for details.

            ShellFolderView_GetDropPoint(hwnd, &sap.pt);

            // Only point gets special flags.
            sap.uSelectFlags |= SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS | SVSI_FOCUSED;
        }
        
        SendMessage(hwndView, SVM_SELECTANDPOSITIONITEM, 1, (LPARAM)&sap);
        
        ILFree(pidl);
    }
}

//
// Class used to scale and position items for drag and drops.  Handles
// scaling between different sized views.
//

//
// Bug 165413 (edwardp 8/16/00) Convert IShellFolderView usage in CItemPositioning to IFolderView
//

class CItemPositioning
{
    // Methods
public:
    CItemPositioning(IFolderView* pifv, LPCITEMIDLIST* apidl, UINT cidl, IDataObject* pdtobj, POINT* ppt);

    void DragSetPoints(void);
    void DropPositionItems(void);

private:

    typedef enum
    {
        DPIWP_AUTOARRANGE,
        DPIWP_DATAOBJ,
    } DPIWP;

    BOOL   _DragShouldPositionItems(void);
    BOOL   _DragGetPoints(POINT* apts);
    void   _DragPositionPoints(POINT* apts);
    void   _DragScalePoints(POINT* apts);

    POINT* _DropGetPoints(DPIWP dpiwp, STGMEDIUM* pMediam);
    void   _DropFreePoints(DPIWP dpiwp, POINT* apts, STGMEDIUM* pmedium);
    void   _DropPositionPoints(POINT* apts);
    void   _DropScalePoints(POINT* apts);
    void   _DropPositionItemsWithPoints(DPIWP dpiwp);
    void   _DropPositionItems(POINT* apts);

    void   _ScalePoints(POINT* apts, POINT ptFrom, POINT ptTo);
    POINT* _SkipAnchorPoint(POINT* apts);

    // Data
private:
    IFolderView*      _pfv;
    LPCITEMIDLIST*    _apidl;
    UINT              _cidl;
    IDataObject*      _pdtobj;
    POINT*            _ppt;
};

CItemPositioning::CItemPositioning(IFolderView* pifv, LPCITEMIDLIST* apidl, UINT cidl, IDataObject* pdtobj, POINT* ppt)
{
    ASSERT(pifv);
    ASSERT(apidl);
    ASSERT(cidl);
    ASSERT(pdtobj);

    _pfv    = pifv;    // No need to addref as long as CPostionItems is only used locally.
    _apidl  = apidl;
    _cidl   = cidl;
    _pdtobj = pdtobj;  // No need to addref as long as CPostionItems is only used locally.
    _ppt    = ppt;
}


void CItemPositioning::DragSetPoints(void)
{
    if (_DragShouldPositionItems())
    {
        POINT* apts = (POINT*) GlobalAlloc(GPTR, sizeof(POINT) * (_cidl + 1));

        if (apts)
        {
            if (_DragGetPoints(apts))
            {
                _DragPositionPoints(_SkipAnchorPoint(apts));
                _DragScalePoints(_SkipAnchorPoint(apts));

                if (FAILED(DataObj_SetGlobal(_pdtobj, g_cfOFFSETS, apts)))
                    GlobalFree((HGLOBAL)apts);
            }
            else
            {
                GlobalFree((HGLOBAL)apts);
            }
        }
    }
}

BOOL CItemPositioning::_DragShouldPositionItems()
{
    // Don't position multiple items if they come from a view that doesn't allow
    // positioning.  The position information is not likely to be usefull in this
    // case.
    // Always position single items so they show up at the drop point.
    // Don't bother with position data for 100 or more items.

    return ((S_OK == _pfv->GetSpacing(NULL)) || 1 == _cidl) && _cidl < 100;
}

BOOL CItemPositioning::_DragGetPoints(POINT* apts)
{
    BOOL fRet = TRUE;

    // The first point is the anchor.
    apts[0] = *_ppt;

    for (UINT i = 0; i < _cidl; i++)
    {
        if (FAILED(_pfv->GetItemPosition(_apidl[i], &apts[i + 1])))
        {
            if (1 == _cidl)
            {
                apts[i + 1].x = _ppt->x;
                apts[i + 1].y = _ppt->y;
            }
            else
            {
                fRet = FALSE;
            }
        }
    }

    return fRet;
}

void CItemPositioning::_DragPositionPoints(POINT* apts)
{
    for (UINT i = 0; i < _cidl; i++)
    {
        apts[i].x -= _ppt->x;
        apts[i].y -= _ppt->y;
    }
}

void CItemPositioning::_DragScalePoints(POINT* apts)
{
    POINT ptFrom;
    POINT ptTo;

    _pfv->GetSpacing(&ptFrom);
    _pfv->GetDefaultSpacing(&ptTo);

    if (ptFrom.x != ptTo.x || ptFrom.y != ptTo.y)
        _ScalePoints(apts, ptFrom, ptTo);
}

void CItemPositioning::DropPositionItems(void)
{
    if (S_OK == _pfv->GetAutoArrange())
    {
        _DropPositionItemsWithPoints(DPIWP_AUTOARRANGE);
    }
    else if (S_OK == _pfv->GetSpacing(NULL) && _ppt)
    {
        _DropPositionItemsWithPoints(DPIWP_DATAOBJ);
    }
    else
    {
        _DropPositionItems(NULL);
    }
}

void CItemPositioning::_DropPositionItemsWithPoints(DPIWP dpiwp)
{
    STGMEDIUM medium;
    POINT*    apts = _DropGetPoints(dpiwp, &medium);

    if (apts)
    {
        if (DPIWP_DATAOBJ == dpiwp)
        {
            _DropScalePoints(_SkipAnchorPoint(apts));
            _DropPositionPoints(_SkipAnchorPoint(apts));
        }

        _DropPositionItems(_SkipAnchorPoint(apts));

        _DropFreePoints(dpiwp, apts, &medium);
    }
    else if (_ppt)
    {
        POINT *ppts;

        ppts = (POINT *)LocalAlloc(LPTR, _cidl * sizeof(POINT));

        if (ppts)
        {
            POINT   pt;

            _pfv->GetDefaultSpacing(&pt);

            for (UINT i = 0; i < _cidl; i++)
            {
                ppts[i].x = (-g_cxIcon / 2) + (i * pt.x);
                ppts[i].y = (-g_cyIcon / 2) + (i * pt.y);
            }
            _DropScalePoints(ppts);
            _DropPositionPoints(ppts);
            _DropPositionItems(ppts);

            LocalFree(ppts);
        }
        else
        {
            _DropPositionItems(NULL);
        }
    }
    else
    {
        _DropPositionItems(NULL);
    }
}

void CItemPositioning::_DropPositionItems(POINT* apts)
{
    // Drop the first item with special selection flags.
    LPCITEMIDLIST pidl = ILFindLastID(_apidl[0]);
    _pfv->SelectAndPositionItems(1, &pidl, apts, SVSI_SELECT | SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS | SVSI_FOCUSED);

    // Drop the rest of the items.
    if (_cidl > 1)
    {
        LPCITEMIDLIST* apidl = (LPCITEMIDLIST*)LocalAlloc(GPTR, sizeof(LPCITEMIDLIST) * (_cidl - 1));

        if (apidl)
        {
            for (UINT i = 1; i < _cidl; i++)
                apidl[i - 1] = ILFindLastID(_apidl[i]);

            _pfv->SelectAndPositionItems(_cidl - 1, apidl, (apts) ? &apts[1] : NULL, SVSI_SELECT);

            LocalFree(apidl);
        }
    }
}

POINT* CItemPositioning::_DropGetPoints(DPIWP dpiwp, STGMEDIUM* pmedium)
{
    POINT* pptRet = NULL;

    if (DPIWP_DATAOBJ == dpiwp)
    {
        FORMATETC fmte = {g_cfOFFSETS, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

        if (SUCCEEDED(_pdtobj->GetData(&fmte, pmedium)))
        {
            if (pmedium->hGlobal)
            {
                POINT *pptSrc;

                pptSrc = (POINT *)GlobalLock(pmedium->hGlobal);

                if (pptSrc)
                {
                    pptRet = (POINT*)LocalAlloc(GPTR, (_cidl + 1) * sizeof(POINT));

                    if (pptRet)
                    {
                        for (UINT i = 0; i <= _cidl; i++)
                        {
                            pptRet[i] = pptSrc[i];
                        }
                    }

                    GlobalUnlock(pptSrc);
                }
            }

            ReleaseStgMedium(pmedium);
        }
    }
    else if (DPIWP_AUTOARRANGE == dpiwp)
    {
        if (_ppt)
        {
            pptRet = (POINT*)LocalAlloc(GPTR, (_cidl + 1) * sizeof(POINT));

            if (pptRet)
            {
                // skip first point to simulate data object use of first point

                for (UINT i = 1; i <= _cidl; i++)
                {
                    pptRet[i] = *_ppt;
                }
            }
        }
    }

    return pptRet;
}

void CItemPositioning::_DropFreePoints(DPIWP dpiwp, POINT* apts, STGMEDIUM* pmedium)
{
    LocalFree(apts);
}

void CItemPositioning::_DropScalePoints(POINT* apts)
{
    POINT ptFrom;
    POINT ptTo;

    _pfv->GetDefaultSpacing(&ptFrom);
    _pfv->GetSpacing(&ptTo);

    if (ptFrom.x != ptTo.x || ptFrom.y != ptTo.y)    
        _ScalePoints(apts, ptFrom, ptTo);
}

void CItemPositioning::_DropPositionPoints(POINT* apts)
{
    for (UINT i = 0; i < _cidl; i++)
    {
        apts[i].x += _ppt->x;
        apts[i].y += _ppt->y;
    }
}

void CItemPositioning::_ScalePoints(POINT* apts, POINT ptFrom, POINT ptTo)
{
    for (UINT i = 0; i < _cidl; i++)
    {
        apts[i].x = MulDiv(apts[i].x, ptTo.x, ptFrom.x);
        apts[i].y = MulDiv(apts[i].y, ptTo.y, ptFrom.y);
    }
}

POINT* CItemPositioning::_SkipAnchorPoint(POINT* apts)
{
    return &apts[1];
}



STDAPI_(void) SetPositionItemsPoints(IFolderView* pifv, LPCITEMIDLIST* apidl, UINT cidl, IDataObject* pdtobj, POINT* ptDrag)
{
    CItemPositioning cpi(pifv, apidl, cidl, pdtobj, ptDrag);
    cpi.DragSetPoints();
}

STDAPI_(void) PositionItems(IFolderView* pifv, LPCITEMIDLIST* apidl, UINT cidl, IDataObject* pdtobj, POINT* ptDrop)
{
    CItemPositioning cip(pifv, apidl, cidl, pdtobj, ptDrop);
    cip.DropPositionItems();
}

//
// Don't use PositionItems_DontUse.  Instead convert to PositionItems.
// PositionItems_DontUse will be removed.
//
// Bug#163533 (edwardp 8/15/00) Remove this code. 

STDAPI_(void) PositionItems_DontUse(HWND hwndOwner, UINT cidl, const LPITEMIDLIST *ppidl, IDataObject *pdtobj, POINT *pptOrigin, BOOL fMove, BOOL fUseExactOrigin)
{
    if (!ppidl || !IsWindow(hwndOwner))
        return;

    SFM_SAP *psap = (SFM_SAP *)GlobalAlloc(GPTR, sizeof(SFM_SAP) * cidl);
    if (psap) 
    {
        UINT i, cxItem, cyItem;
        int xMul, yMul, xDiv, yDiv;
        STGMEDIUM medium;
        POINT *pptItems = NULL;
        POINT pt;
        ITEMSPACING is;
        // select those objects;
        // this had better not fail
        HWND hwnd = ShellFolderViewWindow(hwndOwner);

        if (fMove)
        {
            FORMATETC fmte = {g_cfOFFSETS, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            if (SUCCEEDED(pdtobj->GetData(&fmte, &medium)) &&
                medium.hGlobal)
            {
                pptItems = (POINT *)GlobalLock(medium.hGlobal);
                pptItems++; // The first point is the anchor
            }
            else
            {
                // By default, drop at (-g_cxIcon/2, -g_cyIcon/2), and increase
                // x and y by icon dimension for each icon
                pt.x = ((-3 * g_cxIcon) / 2) + pptOrigin->x;
                pt.y = ((-3 * g_cyIcon) / 2) + pptOrigin->y;
                medium.hGlobal = NULL;
            }

            if (ShellFolderView_GetItemSpacing(hwndOwner, &is))
            {
                xDiv = is.cxLarge;
                yDiv = is.cyLarge;
                xMul = is.cxSmall;
                yMul = is.cySmall;
                cxItem = is.cxSmall;
                cyItem = is.cySmall;
            }
            else
            {
                xDiv = yDiv = xMul = yMul = 1;
                cxItem = g_cxIcon;
                cyItem = g_cyIcon;
            }
        }

        for (i = 0; i < cidl; i++)
        {
            if (ppidl[i])
            {
                psap[i].pidl = ILFindLastID(ppidl[i]);
                psap[i].fMove = fMove;
                if (fMove)
                {
                    if (fUseExactOrigin)
                    {
                        psap[i].pt = *pptOrigin;
                    }
                    else
                    {
                        if (pptItems)
                        {
                            psap[i].pt.x = ((pptItems[i].x * xMul) / xDiv) + pptOrigin->x;
                            psap[i].pt.y = ((pptItems[i].y * yMul) / yDiv) + pptOrigin->y;
                        }
                        else
                        {
                            pt.x += cxItem;
                            pt.y += cyItem;
                            psap[i].pt = pt;
                        }
                    }
                }

                // do regular selection from all of the rest of the items
                psap[i].uSelectFlags = SVSI_SELECT;
            }
        }

        // do this special one for the first only
        psap[0].uSelectFlags = SVSI_SELECT | SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS | SVSI_FOCUSED;

        SendMessage(hwnd, SVM_SELECTANDPOSITIONITEM, cidl, (LPARAM)psap);

        if (fMove && medium.hGlobal)
            ReleaseStgMediumHGLOBAL(NULL, &medium);

        GlobalFree(psap);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fsmenu.h ===
#ifndef _FSMENU_H
#define _FSMENU_H

#include <objbase.h>

// Message values for callback
#define FMM_ADD         0
#define FMM_SETLASTPIDL 1

typedef HRESULT (CALLBACK *PFNFMCALLBACK)(UINT fmm, LPARAM lParam, IShellFolder *psf, LPCITEMIDLIST pidl);

// Structure for composing a filemenu
typedef struct
{
    DWORD           dwMask;         // FMC_ flags
    UINT            idCmd;
    DWORD           grfFlags;       // SHCONTF_ flags
    IShellFolder    *psf;
    PFNFMCALLBACK   pfnCallback;    // Callback
    LPARAM          lParam;         // Callback's LPARAM
    OUT int         cItems;         // Returned
} FMCOMPOSE;

// Mask values for FMCOMPOSE.dwMask
#define FMC_NOEXPAND    0x00000001

// Method ordinals for FileMenu_Compose
#define FMCM_INSERT     0
#define FMCM_APPEND     1
#define FMCM_REPLACE    2

STDAPI            FileMenu_Compose(HMENU hmenu, UINT nMethod, FMCOMPOSE *pfmc);
STDAPI_(BOOL)     FileMenu_HandleNotify(HMENU hmenu, LPCITEMIDLIST * ppidl, LONG lEvent);
STDAPI_(BOOL)     FileMenu_IsUnexpanded(HMENU hmenu);
STDAPI_(void)     FileMenu_DelayedInvalidate(HMENU hmenu);
STDAPI_(BOOL)     FileMenu_IsDelayedInvalid(HMENU hmenu);
STDAPI            FileMenu_InitMenuPopup(HMENU hmenu);
STDAPI_(LRESULT)  FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT *lpdi);
STDAPI_(LRESULT)  FileMenu_MeasureItem(HWND hwnd, MEASUREITEMSTRUCT *lpmi);
STDAPI_(void)     FileMenu_DeleteAllItems(HMENU hmenu);
STDAPI_(LRESULT)  FileMenu_HandleMenuChar(HMENU hmenu, TCHAR ch);


#endif //_FSMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fsassoc.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <limits.h>
#include <shlwapi.h>
#include <objwindow.h>
#include "vdate.h"   
#include "ids.h"
#include "fassoc.h"

STDAPI InitFileFolderClassNames(void);

STDAPI OpenWithListRegister(DWORD dwFlags, LPCTSTR pszExt, LPCTSTR pszVerb, HKEY hkProgid);

#define AIF_TEMPKEY     0x1     // temp class key created for the selected exe
#define AIF_SHELLNEW    0x2     // class key with shellnew subkey

#define MAXKEYNAME    128



HRESULT _GetURL(BOOL fXMLLookup, LPCTSTR pszExt, LPTSTR pszURL, DWORD cchSize)
{
    TCHAR szUrlTemplate[MAX_URL_STRING];
    DWORD cbSize = sizeof(szUrlTemplate);
    DWORD dwType;
    LANGID nLangID = GetUserDefaultUILanguage();
    HRESULT hr = S_OK;
    LPCTSTR pszValue = (fXMLLookup ? TEXT("XMLLookup") : TEXT("Application"));

    if (0x0409 != nLangID)
    {
        // We redirect to a single web page on intl so we can handle any languages we don't support
        pszValue = TEXT("intl");
    }

    if ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Associations"), 
                pszValue, &dwType, (void *)szUrlTemplate, &cbSize)) &&
        (REG_SZ == dwType))
    {
        wnsprintf(pszURL, cchSize, szUrlTemplate, nLangID, CharNext(pszExt));
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


HRESULT _OpenDownloadURL(HWND hwnd, LPCTSTR pszExt)
{
    TCHAR szUrl[MAX_URL_STRING];
    HRESULT hr = _GetURL(FALSE, pszExt, szUrl, ARRAYSIZE(szUrl));

    if (SUCCEEDED(hr))
    {
        HINSTANCE hReturn = ShellExecute(hwnd, NULL, szUrl, NULL, NULL, SW_SHOWNORMAL);

        if (hReturn < (HINSTANCE)32)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return S_OK;
}



class CInternetOpenAs : public CObjectWindow
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    HRESULT DisplayDialog(HWND hwndParent, LPCTSTR pszFile);

    CInternetOpenAs(void);

private:
    virtual ~CInternetOpenAs(void);
    // Private Member Variables
    long                    m_cRef;

    LPTSTR                  _pszFilename;
    LPTSTR                  _pszExt;
    HWND                    _hwndParent;


    // Private Member Functions
    HRESULT _OnInitDlg(HWND hDlg);
    HRESULT _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnNotify(HWND hDlg, LPARAM lParam);

    // Download thread functions.
    DWORD _DownloadThreadProc(void);
    void _StartDownloadThread(void);
    HRESULT _SetUnknownInfo(void);
    HRESULT _ParseXML(BSTR bstrXML, LPTSTR pszFileType, DWORD cchSizeFileType, LPTSTR pszDescription, DWORD cchSizeDescription, LPTSTR pszUrl, DWORD cchSizeUrl, BOOL * pfUnknown);

    INT_PTR _InternetOpenDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK InternetOpenDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static DWORD CALLBACK DownloadThreadProc(void *pvThis) { return ((CInternetOpenAs *) pvThis)->_DownloadThreadProc(); };
};

#define WMUSER_CREATETOOLTIP        (WM_USER + 1)       // lParam is the hwndParent, wParam is the WSTR.
#define WMUSER_DESTROYTYPE          (WM_USER + 2)       // lParam wParam are 0


typedef CAppInfo APPINFO;

class COpenAs
{
public:
    ULONG AddRef();
    ULONG Release();

    friend BOOL_PTR CALLBACK OpenAsDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    friend BOOL_PTR CALLBACK NoOpenDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    friend HRESULT OpenAsDialog(HWND hwnd, POPENASINFO poainfo);

    void OnOk();

private:
    // params
    HWND _hwnd;                          // parent window
    POPENASINFO _poainfo;

    // local data
    long _cRef;
    int _idDlg;                          // open as dialog type: DLG_OPENAS_NOTYPE or DLG_OPENAS
    HWND _hDlg;                          // open as dialog window handle
    HWND _hwndList;                      // app list
    LPTSTR _pszExt;
    TCHAR _szNoOpenMsg[MAX_PATH];
    TCHAR _szDescription[CCH_KEYMAX];    // file type description
    HRESULT _hr;
    HTREEITEM _hItemRecommended;         // root items to group programs
    HTREEITEM _hItemOthers;

    // constructer
    COpenAs(HWND hwnd, POPENASINFO poainfo) : _hwnd(hwnd), _poainfo(poainfo), _cRef(1)
    {
        _pszExt = PathFindExtension(poainfo->pcszFile);
    }

    // other methods
    HTREEITEM _AddAppInfoItem(APPINFO *pai, HTREEITEM hParentItem);
    HTREEITEM _AddFromNewStorage(IAssocHandler *pah);
    HTREEITEM _AddRootItem(BOOL bRecommended);
    APPINFO *_TVFindAppInfo(HTREEITEM hItem);
    HTREEITEM _TVFindItemByHandler(HTREEITEM hParentItem, LPCTSTR pszHandler);
    UINT _FillListByEnumHandlers();
    UINT _FillListWithHandlers();
    void _InitOpenAsDlg();
    BOOL RunAs(APPINFO *pai);
    void OpenAsOther();
    BOOL OpenAsMakeAssociation(LPCWSTR pszDesc, LPCWSTR pszHandler, HKEY hkey);
    void _InitNoOpenDlg();
    HRESULT _OpenAsDialog();
    void _OnNotify(HWND hDlg, LPARAM lParam);
    HRESULT _InternetOpen(void);
};

ULONG COpenAs::AddRef()
{
    return ::InterlockedIncrement(&_cRef);
}

ULONG COpenAs::Release()
{
    if (::InterlockedDecrement(&_cRef) == 0)
    {
        delete this;
        return 0;
    }    
    return _cRef;
}

STDAPI SHCreateAssocHandler(LPCWSTR pszExt, LPCWSTR pszApp, IAssocHandler **ppah);
void COpenAs::OpenAsOther()
{
    TCHAR szApp[MAX_PATH];
    TCHAR szPath[MAX_PATH];

    *szApp = '\0';
    SHExpandEnvironmentStrings(TEXT("%ProgramFiles%"), szPath, ARRAYSIZE(szPath));
    // do a file open browse
    if (GetFileNameFromBrowse(_hDlg, szApp, ARRAYSIZE(szApp), szPath,
            MAKEINTRESOURCE(IDS_EXE), MAKEINTRESOURCE(IDS_PROGRAMSFILTER), MAKEINTRESOURCE(IDS_OPENAS)))
    {
        IAssocHandler *pah;        
        if (SUCCEEDED(SHCreateAssocHandler(_pszExt, szApp, &pah)))
        {
            CAppInfo *pai = new CAppInfo(pah);
            if (pai)
            {
                HTREEITEM hItem = NULL;
                if (pai->Init())
                {
                    hItem = _TVFindItemByHandler(_hItemRecommended, pai->Name());
                    if (!hItem && _hItemOthers)
                        hItem = _TVFindItemByHandler(_hItemOthers, pai->Name());

                    if (!hItem)
                    {
                        hItem = _AddAppInfoItem(pai, _hItemOthers);
                        if (hItem)
                            pai = NULL;
                    }
                            
                }
                // Select it
                if (hItem)
                {
                    TreeView_SelectItem(_hwndList, hItem);
                    SetFocus(_hwndList);
                }

                if (pai)
                    delete pai;
            }
            pah->Release();
        }
    }
}

HTREEITEM COpenAs::_AddAppInfoItem(APPINFO *pai, HTREEITEM hParentItem)
{
    TVINSERTSTRUCT tvins = {0}; 
 
    tvins.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM; 
    tvins.item.iSelectedImage = tvins.item.iImage = pai->IconIndex();        

    tvins.item.pszText = (LPWSTR) pai->UIName();
    tvins.item.cchTextMax = lstrlen(pai->UIName())+1; 
    
    tvins.item.lParam = (LPARAM) pai; 
    tvins.hInsertAfter = TVI_SORT;

    // If NULL, all programs are listed as root items
    tvins.hParent = hParentItem; 
    
    return TreeView_InsertItem(_hwndList, &tvins); 
}

HTREEITEM COpenAs::_AddFromNewStorage(IAssocHandler *pah)
{
    HTREEITEM hitem = NULL;
    CAppInfo *pai = new CAppInfo(pah);
    if (pai)
    {
        // Trim duplicate items before we add them for other programs
        if (pai->Init()
        && (!_hItemRecommended || !_TVFindItemByHandler(_hItemRecommended, pai->Name())))
        {
            hitem = _AddAppInfoItem(pai, S_OK == pah->IsRecommended() ? _hItemRecommended : _hItemOthers);
        }

        if (!hitem)
        {
            delete pai;
        }
    }
    return hitem;
}

HTREEITEM COpenAs::_AddRootItem(BOOL bRecommended)
{
    TCHAR sz[MAX_PATH];

    int iLen = LoadString(g_hinst, (bRecommended? IDS_OPENWITH_RECOMMENDED : IDS_OPENWITH_OTHERS), sz, ARRAYSIZE(sz));

    if (iLen)
    {
        TVINSERTSTRUCT tvins = {0}; 
 
        tvins.item.mask = TVIF_TEXT | TVIF_STATE |TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvins.item.pszText = sz;
        tvins.item.cchTextMax = iLen;
        tvins.item.stateMask = tvins.item.state = TVIS_EXPANDED; // Expand child items by default
        tvins.hInsertAfter = TVI_ROOT; 
        tvins.hParent = NULL;
        //
        // Currently, we use program icon.
        // Change it if PM/UI designer have more appropriate one.
        //
        tvins.item.iSelectedImage = tvins.item.iImage = Shell_GetCachedImageIndex(c_szShell32Dll, II_STPROGS, 0); 

        return TreeView_InsertItem(_hwndList, &tvins);
    }

    return NULL;
}

APPINFO *COpenAs::_TVFindAppInfo(HTREEITEM hItem)
{
    // if hItem not specified, use current selected item
    if (!hItem)
        hItem = TreeView_GetSelection(_hwndList);

    if (hItem)
    {
        TVITEM tvi = {0};

        tvi.mask = TVIF_HANDLE;
        tvi.hItem = hItem;

        if (TreeView_GetItem(_hwndList, &tvi))        
            return ((APPINFO *) tvi.lParam);
    }

    return NULL;
}


HTREEITEM COpenAs::_TVFindItemByHandler(HTREEITEM hParentItem, LPCTSTR pszHandler)
{
    // if we have parent item, search its children, otherwise search root items
    HTREEITEM hItem = TreeView_GetNextItem(_hwndList, hParentItem, hParentItem ? TVGN_CHILD : TVGN_ROOT );
    while (hItem)
    {
        APPINFO *pai = _TVFindAppInfo(hItem);

        if (pai && !StrCmpI(pai->Name(), pszHandler))
            return hItem;

        hItem = TreeView_GetNextItem(_hwndList, hItem, TVGN_NEXT);
    }

    return NULL;
}


UINT COpenAs::_FillListByEnumHandlers()
{
    IEnumAssocHandlers *penum;
    UINT cHandlers = 0;

    if (SUCCEEDED(SHAssocEnumHandlers(_pszExt, &penum)))
    {
        HTREEITEM hitemFocus = NULL;
        BOOL fFirst = TRUE;
        IAssocHandler *pah;
        while (S_OK == penum->Next(1, &pah, NULL))
        {
            if (fFirst)
            {
                //
                // Group programs to "recommended" and "others" only when we can get two different group of programs
                // Otherwise, all programs are listed as root items
                // Note: in our storage,  general handlers is always a superset of extension related handlers
                //
                //  if the first item is recommended,
                //  then we add the recommended node
                //
                if (S_OK == pah->IsRecommended())
                {
                    _hItemRecommended = _AddRootItem(TRUE);
                    _hItemOthers = _AddRootItem(FALSE);
                }
                fFirst = FALSE;
            }
                
            HTREEITEM hitem = _AddFromNewStorage(pah);
            if (!hitemFocus && hitem && S_OK == pah->IsRecommended())
            {
                //  we put focus on the first recommended item
                //  the enum starts with the best 
                hitemFocus = hitem;
            }

            cHandlers++;
        }

        if (cHandlers && _hItemRecommended)
        {
            if (!hitemFocus)
                hitemFocus = TreeView_GetNextItem(_hwndList, _hItemRecommended, TVGN_CHILD);
            TreeView_SelectItem(_hwndList, hitemFocus);
        }
        
        penum->Release();
    }

    return cHandlers;
}


UINT COpenAs::_FillListWithHandlers()
{
    UINT cHandlers = _FillListByEnumHandlers();

    //
    // Set focus on the first recommended program if we have program groups
    // Otherwise, all programs are root items, focus will be set to the first item by default
    //

    return cHandlers;
}

void COpenAs::_InitOpenAsDlg()
{
    TCHAR szFileName[MAX_PATH];
    BOOL fDisableAssociate;
    HIMAGELIST himl;
    RECT rc;

    // Don't let the file name go beyond the width of one line...
    lstrcpy(szFileName, PathFindFileName(_poainfo->pcszFile));
    GetClientRect(GetDlgItem(_hDlg, IDD_TEXT), &rc);

    PathCompactPath(NULL, szFileName, rc.right - 4 * GetSystemMetrics(SM_CXBORDER));

    SetDlgItemText(_hDlg, IDD_FILE_TEXT, szFileName);

    // AraBern 07/20/99, specific to TS on NT, but can be used on NT without TS
    //  this restriction doesnt apply to admins
    if (SHRestricted(REST_NOFILEASSOCIATE) && !IsUserAnAdmin())
    {
        CheckDlgButton(_hDlg, IDD_MAKEASSOC, FALSE);
        ShowWindow(GetDlgItem(_hDlg, IDD_MAKEASSOC), SW_HIDE);
    }
    else
    {
        // Don't allow associations to be made for things we consider exes...
        fDisableAssociate = (! (_poainfo->dwInFlags & OAIF_ALLOW_REGISTRATION) ||
                        PathIsExe(_poainfo->pcszFile));
                        
        // check IDD_MAKEASSOC only for unknown file type and those with OAIF_FORCE_REGISTRATION flag set
        if ((_poainfo->dwInFlags & OAIF_FORCE_REGISTRATION) ||
            (_idDlg != DLG_OPENAS && !fDisableAssociate))
        {
            CheckDlgButton(_hDlg, IDD_MAKEASSOC, TRUE);
        }

        if (fDisableAssociate)
            EnableWindow(GetDlgItem(_hDlg, IDD_MAKEASSOC), FALSE);
    }

    _hwndList = GetDlgItem(_hDlg, IDD_APPLIST);
    Shell_GetImageLists(NULL, &himl);
    TreeView_SetImageList(_hwndList, himl, TVSIL_NORMAL); 

    // Leave space between ICON images - SM_CXEDGE
    TreeView_SetItemHeight(_hwndList, TreeView_GetItemHeight(_hwndList) + GetSystemMetrics(SM_CXEDGE));

    if (!_FillListWithHandlers())
    {
        // lets force the expensive walk
        IRunnableTask *ptask;
        if (SUCCEEDED(CTaskEnumHKCR_Create(&ptask)))
        {
            ptask->Run();
            ptask->Release();
            _FillListWithHandlers();
        }
    }

    // initialize the OK button
    EnableWindow(GetDlgItem(_hDlg, IDOK), (TreeView_GetSelection(_hwndList) != NULL));

    InitFileFolderClassNames();
}


BOOL COpenAs::RunAs(APPINFO *pai)
{
    pai->Handler()->Exec(_hwnd, _poainfo->pcszFile);
    SHAddToRecentDocs(SHARD_PATH, _poainfo->pcszFile);
    return TRUE;
}

void COpenAs::_InitNoOpenDlg()
{
    SHFILEINFO sfi;
    HICON hIcon;
    TCHAR szFormat[MAX_PATH], szTemp[MAX_PATH];

    GetDlgItemText(_hDlg, IDD_TEXT1, szFormat, ARRAYSIZE(szFormat));
    wnsprintf(szTemp, ARRAYSIZE(szTemp), szFormat, _szDescription, _pszExt);
    SetDlgItemText(_hDlg, IDD_TEXT1, szTemp);

    if (*_szNoOpenMsg)
        SetDlgItemText(_hDlg, IDD_TEXT2, _szNoOpenMsg);

    if (SHGetFileInfo(_poainfo->pcszFile, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_LARGEICON)
        && NULL != sfi.hIcon)
    {
        hIcon = sfi.hIcon;
    }
    else
    {
        HIMAGELIST himl;
        Shell_GetImageLists(&himl, NULL);
        hIcon = ImageList_ExtractIcon(g_hinst, himl, II_DOCNOASSOC);
    }
    hIcon = (HICON)SendDlgItemMessage(_hDlg, IDD_ICON, STM_SETICON, (WPARAM)hIcon, 0);
    if ( hIcon )
    {
        DestroyIcon(hIcon);
    }
}


HRESULT COpenAs::_InternetOpen(void)
{
    HRESULT hr = E_OUTOFMEMORY;
    CInternetOpenAs * pInternetOpenAs = new CInternetOpenAs();

    if (pInternetOpenAs)
    {
        DWORD dwValue;
        DWORD cbSize = sizeof(dwValue);
        DWORD dwType;

        hr = S_OK;
        if ((ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"), TEXT("NoInternetOpenWith"), &dwType, (void *)&dwValue, &cbSize)) || (0 == dwValue))
        {
            // If the policy is not set, use the feature.
            hr = pInternetOpenAs->DisplayDialog(_hwnd, _poainfo->pcszFile);
        }

        pInternetOpenAs->Release();
    }

    return hr;
}

class COpenAsAssoc
{
public:
    COpenAsAssoc(PCWSTR pszExt);
    ~COpenAsAssoc() {ATOMICRELEASE(_pqa);}

    BOOL HasClassKey();
    BOOL HasCommand();
    BOOL GetDescription(PWSTR psz, DWORD cch);
    BOOL GetNoOpen(PWSTR psz, DWORD cch);

protected:
    IQueryAssociations *_pqa;        
    HRESULT _hrInit;
};

COpenAsAssoc::COpenAsAssoc(PCWSTR pszExt)
{
    AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &_pqa));
    if (FAILED(_pqa->Init(0, pszExt, NULL, NULL)))
        ATOMICRELEASE(_pqa);
}
    
BOOL COpenAsAssoc::HasClassKey()
{
    BOOL fRet = FALSE;
    if (_pqa)
    {
        HKEY hk;
        if (SUCCEEDED(_pqa->GetKey(0, ASSOCKEY_CLASS, NULL, &hk)))
        {
            RegCloseKey(hk);
            fRet = TRUE;
        }
    }
    return fRet;
}
    
BOOL COpenAsAssoc::HasCommand()
{
    DWORD cch;
    if (_pqa)
        return SUCCEEDED(_pqa->GetString(0, ASSOCSTR_COMMAND, NULL, NULL, &cch));
    return FALSE;
}
    
BOOL COpenAsAssoc::GetDescription(PWSTR psz, DWORD cch)
{
    if (_pqa)
        return SUCCEEDED(_pqa->GetString(0, ASSOCSTR_FRIENDLYDOCNAME, NULL, psz, &cch));
    return FALSE;
}

BOOL COpenAsAssoc::GetNoOpen(PWSTR psz, DWORD cch)
{
    if (_pqa)
        return SUCCEEDED(_pqa->GetString(0, ASSOCSTR_NOOPEN, NULL, psz, &cch));
    return FALSE;
}    

const PCWSTR s_rgImageExts[] = 
{
    { TEXT(".bmp")},
    { TEXT(".dib")},
    { TEXT(".emf")},
    { TEXT(".gif")},
    { TEXT(".jfif")},
    { TEXT(".jpg")},
    { TEXT(".jpe")},
    { TEXT(".jpeg")},
    { TEXT(".png")},
    { TEXT(".tif")},
    { TEXT(".tiff")},
    { TEXT(".wmf")},
    { NULL}
};

BOOL _IsImageExt(PCWSTR pszExt)
{
    for (int i = 0; s_rgImageExts[i] ; i++)
    {
        if (0 == StrCmpIW(pszExt, s_rgImageExts[i]))
            return TRUE;
    }
    return FALSE;
}

static const PCWSTR s_rgZipExts[] = 
{
    { TEXT(".zip")},
    { NULL}
};

static const struct 
{
    const PCWSTR *rgpszExts;
    PCWSTR pszDll;
} s_rgFixAssocs[] = {
    { s_rgImageExts, L"shimgvw.dll" },
    { s_rgZipExts, L"zipfldr.dll" },
    //     { s_rgWmpExts, L"wmp.dll" },
};


PCWSTR _WhichDll(PCWSTR pszExt)
{
    for (int i = 0; i < ARRAYSIZE(s_rgFixAssocs); i++)
    {
        for (int j = 0; s_rgFixAssocs[i].rgpszExts[j] ; j++)
        {
            if (0 == StrCmpIW(pszExt, s_rgFixAssocs[i].rgpszExts[j]))
                return s_rgFixAssocs[i].pszDll;
        }
    }
    return NULL;
}

BOOL _CreateProcessWithArgs(LPCTSTR pszApp, LPCTSTR pszArgs, LPCTSTR pszDirectory, PROCESS_INFORMATION *ppi)
{
    STARTUPINFO si = {0};
    si.cb = sizeof(si);
    TCHAR szCommandLine[MAX_PATH * 2];
    wnsprintf(szCommandLine, ARRAYSIZE(szCommandLine), L"\"%s\" %s", pszApp, pszArgs);
    return CreateProcess(pszApp, szCommandLine, NULL, NULL, FALSE, 0, NULL, pszDirectory, &si, ppi);
}


void _GetSystemPathItem(PCWSTR pszItem, PWSTR pszPath, DWORD cch)
{
    GetSystemDirectory(pszPath, cch);
    PathCombine(pszPath, pszPath, pszItem);
}
    
BOOL _Regsvr32Dll(PCWSTR pszDll)
{
    WCHAR szReg[MAX_PATH];
    WCHAR szDll[MAX_PATH + 3] = L"/s ";
    _GetSystemPathItem(L"regsvr32.exe", szReg, ARRAYSIZE(szReg));
    _GetSystemPathItem(pszDll, szDll + 3, ARRAYSIZE(szDll) - 3);
    
    PROCESS_INFORMATION pi = {0};
    if (_CreateProcessWithArgs(szReg, szDll, NULL, &pi))
    {
        WaitForSingleObject(pi.hProcess, INFINITE);

        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        return TRUE;
    }
    return FALSE;
}

BOOL _FixAssocs(PCWSTR pszExt)
{
    PCWSTR pszDll = _WhichDll(pszExt);
    if (pszDll)
    {
        _Regsvr32Dll(pszDll);
        COpenAsAssoc oac(pszExt);
        return oac.HasCommand();
    }
    return FALSE;
}

HRESULT COpenAs::_OpenAsDialog()
{
    BOOL fHasCommand = FALSE;
    int idDlg = DLG_OPENAS_NOTYPE;

    // Depending on policy, do not allow user to change file type association.
    if (SHRestricted(REST_NOFILEASSOCIATE))
    {
        _poainfo->dwInFlags &= ~OAIF_ALLOW_REGISTRATION & ~OAIF_REGISTER_EXT;
    }

    // We don't allow association for files without extension or with only "." as extension
    if (!_pszExt || !*_pszExt || !*(_pszExt+1))
    {
        idDlg = DLG_OPENAS;
        _poainfo->dwInFlags &= ~OAIF_ALLOW_REGISTRATION;
    }
    // Known file type(has verb): use DLG_OPENAS
    // NoOpen file type(has NoOpen value): use DLG_NOOPEN
    // Unknown file type(All others): use DLG_OPENAS_NOTYPE
    else
    {
        COpenAsAssoc oac(_pszExt);
        fHasCommand = oac.HasCommand();
        if (oac.HasClassKey())
        {
            idDlg = DLG_OPENAS;
            oac.GetDescription(_szDescription, ARRAYSIZE(_szDescription));
            if (oac.GetNoOpen(_szNoOpenMsg, ARRAYSIZE(_szNoOpenMsg))
            && !fHasCommand)
            {
                INITCOMMONCONTROLSEX initComctl32;

                initComctl32.dwSize = sizeof(initComctl32); 
                initComctl32.dwICC = (ICC_STANDARD_CLASSES | ICC_LINK_CLASS); 
                InitCommonControlsEx(&initComctl32);     // Register the comctl32 LinkWindow
                if ((-1 != DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_NOOPEN), _hwnd, NoOpenDlgProc, (LPARAM)this)) 
                    && _hr == S_FALSE)
                {
                    // user selected cancel
                    return _hr;
                }
            }                
        }

        //  if this is a busted file association, maybe we can fix it...
        if ((OAIF_REGISTER_EXT & _poainfo->dwInFlags) && !fHasCommand)
        {
            //  this feels like an unknown type
            if (_FixAssocs(_pszExt))
            {
                SHChangeNotify(SHCNE_ASSOCCHANGED, 0, NULL, NULL);

                // Exec if requested. 
                if (_poainfo->dwInFlags & OAIF_EXEC)
                {
                    IAssocHandler *pah;        
                    if (SUCCEEDED(SHCreateAssocHandler(_pszExt, NULL, &pah)))
                    {
                        CAppInfo *pai = new CAppInfo(pah);
                        if (pai)
                        {
                            if (pai->Init())
                            {
                                RunAs(pai);
                            }
                            delete pai;
                        }
                        pah->Release();
                    }
                }

                return S_OK;
            }
        }
    }
    
    _idDlg = idDlg;

    HRESULT hr = _hr;
    LinkWindow_RegisterClass();
    // If this is the dialog where we don't know the file type and the feature is turned on,
    // use the Internet Open As dialog.
    if ((FALSE == fHasCommand) &&
        SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("InternetOpenWith"), FALSE, TRUE))
    {
        hr = _InternetOpen();
    }

    // Display the old dialog if fUseInternetOpenAs is NOT set.  Or display it if the user
    // chooses "Choose..." in that dialog.
    if (SUCCEEDED(hr))
    {
        INITCOMMONCONTROLSEX initComctl32;

        initComctl32.dwSize = sizeof(initComctl32); 
        initComctl32.dwICC = (ICC_STANDARD_CLASSES | ICC_LINK_CLASS); 
        InitCommonControlsEx(&initComctl32);     // Register the comctl32 LinkWindow
        if (-1 == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(idDlg), _hwnd, OpenAsDlgProc, (LPARAM)this))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


BOOL_PTR CALLBACK NoOpenDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    COpenAs *pOpenAs = (COpenAs *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pOpenAs = (COpenAs *)lParam;
        pOpenAs->_hDlg = hDlg;
        pOpenAs->_InitNoOpenDlg();
        break;

    case WM_COMMAND:
        ASSERT(pOpenAs);
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDD_OPENWITH:
            //  this will cause the open with dialog
            //  to follow this dialog
            pOpenAs->_hr = S_OK;
            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            pOpenAs->_hr = S_FALSE;
            EndDialog(hDlg, TRUE);
            break;
        }
        break;

    default:
        return FALSE;
    }
    
    return TRUE;
}



const static DWORD aOpenAsHelpIDs[] = {  // Context Help IDs
    IDD_ICON,             IDH_FCAB_OPENAS_APPLIST,
    IDD_TEXT,             IDH_FCAB_OPENAS_APPLIST,
    IDD_FILE_TEXT,        (DWORD) -1,
    IDD_DESCRIPTIONTEXT,  IDH_FCAB_OPENAS_DESCRIPTION,
    IDD_DESCRIPTION,      IDH_FCAB_OPENAS_DESCRIPTION,
    IDD_APPLIST,          IDH_FCAB_OPENAS_APPLIST,
    IDD_MAKEASSOC,        IDH_FCAB_OPENAS_MAKEASSOC,
    IDD_OTHER,            IDH_FCAB_OPENAS_OTHER,
    IDD_OPENWITH_BROWSE,  IDH_FCAB_OPENAS_OTHER,
    IDD_OPENWITH_WEBSITE, IDH_FCAB_OPENWITH_LOOKONWEB,
    0, 0
};

const static DWORD aOpenAsDownloadHelpIDs[] = {  // Context Help IDs
    IDD_ICON,             (DWORD) -1,
    IDD_FILE_TEXT,        (DWORD) -1,
    // For DLG_OPENAS_DOWNALOAD
    IDD_WEBAUTOLOOKUP,    IDH_CANNOTOPEN_USEWEB,
    IDD_OPENWITHLIST,     IDH_CANNOTOPEN_SELECTLIST,

    0, 0
};

void COpenAs::_OnNotify(HWND hDlg, LPARAM lParam)
{
    switch (((NMHDR *)lParam)->code)
    {
    case TVN_DELETEITEM:
        if (lParam)
        {
            APPINFO *pai = (APPINFO *)(((LPNMTREEVIEW) lParam )->itemOld.lParam);
            if (pai)
            {
                delete pai;
            }
        }
        break;

    case TVN_SELCHANGED:            
        EnableWindow(GetDlgItem(hDlg, IDOK), (_TVFindAppInfo(TreeView_GetSelection(NULL)) != NULL));
        break;

    case NM_DBLCLK:
        if (IsWindowEnabled(GetDlgItem(hDlg, IDOK)))
            PostMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDOK, hDlg, 0));
        break;

    case NM_RETURN:
    case NM_CLICK:
        if (lParam)
        {
            PNMLINK pNMLink = (PNMLINK) lParam;

            if (!StrCmpW(pNMLink->item.szID, L"Browse"))
            {
                _OpenDownloadURL(_hwnd, _pszExt);
                EndDialog(hDlg, FALSE);
            }
        }
        break;
    }
}

void COpenAs::OnOk()
{
    APPINFO *pai = _TVFindAppInfo(NULL);

    if (pai)
    {
        // See if we should make an association or not...
        GetDlgItemText(_hDlg, IDD_DESCRIPTION, _szDescription, ARRAYSIZE(_szDescription));
    
        if ((_poainfo->dwInFlags & OAIF_REGISTER_EXT)
        && (IsDlgButtonChecked(_hDlg, IDD_MAKEASSOC)))
        {
            pai->Handler()->MakeDefault(_szDescription);
        }

        // Did we register the association? 
        _hr = IsDlgButtonChecked(_hDlg, IDD_MAKEASSOC) ? S_OK : S_FALSE;

        // Exec if requested. 
        if (_poainfo->dwInFlags & OAIF_EXEC)
        {
            RunAs(pai);
        }

        EndDialog(_hDlg, TRUE);
    }
}


BOOL_PTR CALLBACK OpenAsDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    COpenAs *pOpenAs = (COpenAs *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pOpenAs = (COpenAs *)lParam;
        if (pOpenAs)
        {
            pOpenAs->_hDlg = hDlg;
            pOpenAs->_InitOpenAsDlg();
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aOpenAsHelpIDs);
        break;

    case WM_CONTEXTMENU:
        if ((int)SendMessage(hDlg, WM_NCHITTEST, 0, lParam) != HTCLIENT)
            return FALSE;   // don't process it
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(void *)aOpenAsHelpIDs);
        break;

    case WM_NOTIFY:
        if (pOpenAs)
        {
            pOpenAs->_OnNotify(hDlg, lParam);
        }
        break;

    case WM_COMMAND:
        ASSERT(pOpenAs);
        if (pOpenAs)
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDD_OPENWITH_BROWSE:
                pOpenAs->OpenAsOther();
                break;

            case IDOK:
                {
                    pOpenAs->OnOk();
                }
                break;

            case IDCANCEL:
                pOpenAs->_hr = E_ABORT;            
                EndDialog(hDlg, FALSE);
                break;
            }
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

// external API version

HRESULT 
OpenAsDialog(
    HWND        hwnd, 
    POPENASINFO poainfo)
{
    HRESULT hr = E_OUTOFMEMORY;    

    COpenAs *pOpenAs = new COpenAs(hwnd, poainfo);
    DebugMsg(DM_TRACE, TEXT("Enter OpenAs for %s"), poainfo->pcszFile);
    if (pOpenAs)
    {
        hr = pOpenAs->_OpenAsDialog();
        pOpenAs->Release();
    }

    return hr;
}

void WINAPI OpenAs_RunDLL(HWND hwnd, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hrOle = SHCoInitialize();            // Needed for SysLink's IAccessability (LresultFromObject)
    OPENASINFO oainfo = { 0 };

    UINT iLen = lstrlenA(lpszCmdLine)+1;
    LPWSTR  lpwszCmdLine;

    lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR,iLen*sizeof(WCHAR));
    if (lpwszCmdLine)
    {
        MultiByteToWideChar(CP_ACP, 0,
                            lpszCmdLine, -1,
                            lpwszCmdLine, iLen);

        DebugMsg(DM_TRACE, TEXT("OpenAs_RunDLL is called with (%s)"), lpwszCmdLine);

        oainfo.pcszFile = lpwszCmdLine;
        oainfo.dwInFlags = (OAIF_ALLOW_REGISTRATION |
                            OAIF_REGISTER_EXT |
                            OAIF_EXEC);

        OpenAsDialog(hwnd, &oainfo);

        LocalFree(lpwszCmdLine);
    }

    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }
}


void WINAPI OpenAs_RunDLLW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    HRESULT hrOle = SHCoInitialize();            // Needed for SysLink's IAccessability (LresultFromObject)
    OPENASINFO oainfo = { 0 };

    DebugMsg(DM_TRACE, TEXT("OpenAs_RunDLL is called with (%s)"), lpwszCmdLine);

    oainfo.pcszFile = lpwszCmdLine;
    oainfo.dwInFlags = (OAIF_ALLOW_REGISTRATION |
                        OAIF_REGISTER_EXT |
                        OAIF_EXEC);

    OpenAsDialog(hwnd, &oainfo);

    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }
}





#ifdef DEBUG
//
// Type checking
//
const static RUNDLLPROCA lpfnRunDLL = OpenAs_RunDLL;
const static RUNDLLPROCW lpfnRunDLLW = OpenAs_RunDLLW;
#endif

//===========================
// *** Private Methods ***
//===========================
HRESULT CreateWindowTooltip(HWND hDlg, HWND hwndWindow, LPCTSTR pszText)
{
    HRESULT hr = E_OUTOFMEMORY;
    HWND hwndToolTipo = CreateWindow(TOOLTIPS_CLASS, c_szNULL, WS_POPUP | TTS_NOPREFIX, CW_USEDEFAULT, CW_USEDEFAULT,
                                    CW_USEDEFAULT, CW_USEDEFAULT, hDlg, NULL, HINST_THISDLL, NULL);

    if (hwndToolTipo)
    {
        TOOLINFO ti;

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
        ti.hwnd = hDlg;
        ti.uId = (UINT_PTR)hwndWindow;
        ti.lpszText = (LPTSTR)pszText;  // const -> non const
        ti.hinst = HINST_THISDLL;
        SendMessage(hwndToolTipo, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
        hr = S_OK;
    }

    return hr;
}


HRESULT CInternetOpenAs::_ParseXML(BSTR bstrXML, LPTSTR pszFileType, DWORD cchSizeFileType, LPTSTR pszDescription, DWORD cchSizeDescription, LPTSTR pszUrl, DWORD cchSizeUrl, BOOL * pfUnknown)
{
    IXMLDOMDocument * pXMLDoc;
    HRESULT hr = XMLDOMFromBStr(bstrXML, &pXMLDoc);

    *pfUnknown = FALSE;
    pszFileType[0] = pszDescription[0] = pszUrl[0] = 0;
    if (SUCCEEDED(hr))
    {
        IXMLDOMElement * pXMLElement = NULL;

        hr = pXMLDoc->get_documentElement(&pXMLElement);
        if (S_FALSE == hr)
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        else if (SUCCEEDED(hr))
        {
            // This is only valid XML if the root tag is "MSFILEASSOCIATIONS".
            // The case is not important.
            hr = XMLElem_VerifyTagName(pXMLElement, L"MSFILEASSOCIATIONS");
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrFileType;

                hr = XMLNode_GetChildTagTextValue(pXMLElement, L"FILETYPENAME", &bstrFileType);
                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrDesc;
                    CComBSTR bstrURL;

                    StrCpyN(pszFileType, bstrFileType, cchSizeFileType);
                    if (SUCCEEDED(XMLNode_GetChildTagTextValue(pXMLElement, L"DESCRIPTION", &bstrDesc)))
                    {
                        StrCpyN(pszDescription, bstrDesc, cchSizeDescription);
                    }
                    else
                    {
                        StrCpyN(pszDescription, L"", cchSizeDescription);
                    }

                    hr = XMLNode_GetChildTagTextValue(pXMLElement, L"URL", &bstrURL);
                    if (SUCCEEDED(hr))
                    {
                        CComBSTR bstrUnknown;

                        StrCpyN(pszUrl, bstrURL, cchSizeUrl);
                        if (SUCCEEDED(XMLNode_GetChildTagTextValue(pXMLElement, L"UNKNOWN", &bstrUnknown)) &&
                            !StrCmpIW(bstrUnknown, L"TRUE"))
                        {
                            *pfUnknown = TRUE;
                        }
                    }
                }
            }

            pXMLElement->Release();
        }

        pXMLDoc->Release();
    }

    return hr;
}


DWORD CInternetOpenAs::_DownloadThreadProc(void)
{
#ifdef FEATURE_DOWNLOAD_DESCRIPTION
    // 1. Create the URL
    TCHAR szUrl[MAX_PATH];

    if (SUCCEEDED(_GetURL(TRUE, _pszExt, szUrl, ARRAYSIZE(szUrl))))
    {
        // 2. Download the XML
        BSTR bstrXML;
        HRESULT hr = DownloadUrl(szUrl, &bstrXML);

        if (SUCCEEDED(hr))
        {
            TCHAR szFileType[MAX_PATH];
            TCHAR szDescription[2000];
            BOOL fUnknown = FALSE;

            // 3. Get the info from the XML to the UI
            hr = _ParseXML(bstrXML, szFileType, ARRAYSIZE(szFileType), szDescription, ARRAYSIZE(szDescription), szUrl, ARRAYSIZE(szUrl), &fUnknown);
            if (SUCCEEDED(hr) && IsWindow(_hwnd))
            {
                SetWindowText(GetDlgItem(_hwnd, IDD_FILETYPE_TEXT), szFileType);
                SendMessage(_hwnd, WMUSER_CREATETOOLTIP, (WPARAM)szDescription, (LPARAM)GetDlgItem(_hwnd, IDD_FILETYPE_TEXT));

                if (fUnknown)
                {
                    // Hide the "Type" control.
                    SendMessage(_hwnd, WMUSER_DESTROYTYPE, NULL, NULL);
                }
            }

            SysFreeString(bstrXML);
        }

        if (FAILED(hr))
        {
            _SetUnknownInfo();
        }
    }
#endif // FEATURE_DOWNLOAD_DESCRIPTION

    Release();
    return 0;
}



HRESULT CInternetOpenAs::_SetUnknownInfo(void)
{
    // Hide the "Type" control.
#ifdef FEATURE_DOWNLOAD_DESCRIPTION
    EnableWindow(GetDlgItem(_hwnd, IDD_FILETYPE_LABLE), FALSE);
    EnableWindow(GetDlgItem(_hwnd, IDD_FILETYPE_TEXT), FALSE);
    ShowWindow(GetDlgItem(_hwnd, IDD_FILETYPE_LABLE), SW_HIDE);
    ShowWindow(GetDlgItem(_hwnd, IDD_FILETYPE_TEXT), SW_HIDE);
#endif // FEATURE_DOWNLOAD_DESCRIPTION

    return S_OK;
}


void CInternetOpenAs::_StartDownloadThread(void)
{
#ifdef FEATURE_DOWNLOAD_DESCRIPTION
    AddRef();
    if (!SHCreateThread(CInternetOpenAs::DownloadThreadProc, this, (CTF_COINIT | CTF_PROCESS_REF | CTF_FREELIBANDEXIT), NULL))
    {
        // We failed so don't leave the background thread with a ref.
        Release();

        _SetUnknownInfo();
    }
#endif // FEATURE_DOWNLOAD_DESCRIPTION
}


HRESULT CInternetOpenAs::_OnInitDlg(HWND hDlg)
{
    _hwnd = hDlg;

    // Start the background thread to download the information.
    _StartDownloadThread();
    SetWindowText(GetDlgItem(_hwnd, IDD_FILE_TEXT), _pszFilename);
    CheckDlgButton(hDlg, IDD_WEBAUTOLOOKUP, BST_CHECKED);

    return S_OK;
}


HRESULT CInternetOpenAs::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UINT idCtrl = GET_WM_COMMAND_ID(wParam, lParam);
    UINT wEvent = GET_WM_COMMAND_CMD(wParam, lParam);

    switch (idCtrl)
    {
    case IDCANCEL:
        EndDialog(hDlg, E_FAIL);
        break;

    case IDOK:
        if (BST_UNCHECKED != IsDlgButtonChecked(hDlg, IDD_WEBAUTOLOOKUP))
        {
            _OpenDownloadURL(_hwnd, _pszExt);
            EndDialog(hDlg, E_FAIL);
        }
        else
        {
            EndDialog(hDlg, S_OK);      // return S_OK so it will open the next dialog.
        }
        break;
    }

    return S_OK;
}


HRESULT CInternetOpenAs::_OnNotify(HWND hDlg, LPARAM lParam)
{
    switch (((NMHDR *)lParam)->code)
    {
    case NM_CLICK:
        if (lParam)
        {
            PNMLINK pNMLink = (PNMLINK) lParam;

            if (!StrCmpW(pNMLink->item.szID, L"GoOnline"))
            {
                _OpenDownloadURL(_hwnd, _pszExt);
                EndDialog(hDlg, E_FAIL);
            }
            else if (!StrCmpW(pNMLink->item.szID, L"Choose"))
            {
                EndDialog(hDlg, S_OK);      // return S_OK so it will open the next dialog.
            }
        }
        break;
    }

    return S_OK;
}


INT_PTR CALLBACK CInternetOpenAs::InternetOpenDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CInternetOpenAs * pThis = (CInternetOpenAs *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CInternetOpenAs *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
        return pThis->_InternetOpenDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


// This Property Sheet appear in the top level of the "Display Control Panel".
INT_PTR CInternetOpenAs::_InternetOpenDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        _OnInitDlg(hDlg);
        break;

    case WM_COMMAND:
        _OnCommand(hDlg, message, wParam, lParam);
        break;

    case WM_NOTIFY:
        _OnNotify(hDlg, lParam);
        break;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (DWORD_PTR)  aOpenAsDownloadHelpIDs);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (DWORD_PTR) aOpenAsDownloadHelpIDs);
        break;

    case WMUSER_CREATETOOLTIP:
        CreateWindowTooltip(_hwnd, (HWND)lParam, (LPCWSTR)wParam);
        break;

    case WMUSER_DESTROYTYPE:
#ifdef FEATURE_DOWNLOAD_DESCRIPTION
        EnableWindow(GetDlgItem(_hwnd, IDD_FILETYPE_LABLE), FALSE);
        EnableWindow(GetDlgItem(_hwnd, IDD_FILETYPE_TEXT), FALSE);
        ShowWindow(GetDlgItem(_hwnd, IDD_FILETYPE_LABLE), SW_HIDE);
        ShowWindow(GetDlgItem(_hwnd, IDD_FILETYPE_TEXT), SW_HIDE);
#endif // FEATURE_DOWNLOAD_DESCRIPTION
        break;
    }

    return FALSE;
}

//===========================
// *** Public Methods ***
//===========================
HRESULT CInternetOpenAs::DisplayDialog(HWND hwnd, LPCTSTR pszFile)
{
    HRESULT hr = E_OUTOFMEMORY;
    INITCOMMONCONTROLSEX initComctl32;

    initComctl32.dwSize = sizeof(initComctl32); 
    initComctl32.dwICC = (ICC_STANDARD_CLASSES | ICC_LINK_CLASS); 
    InitCommonControlsEx(&initComctl32);     // Register the comctl32 LinkWindow

    Str_SetPtrW(&_pszFilename, (PathFindFileName(pszFile) ? PathFindFileName(pszFile) : pszFile));
    Str_SetPtrW(&_pszExt, PathFindExtension(_pszFilename));
    if (_pszExt)
    {
        _hwndParent = hwnd;

        hr = (HRESULT) DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_OPENAS_DOWNALOAD), _hwnd, CInternetOpenAs::InternetOpenDlgProc, (LPARAM)this);
    }

    return hr;
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CInternetOpenAs::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CInternetOpenAs::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CInternetOpenAs::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] =
    {
        QITABENT(CInternetOpenAs, IOleWindow),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CInternetOpenAs::CInternetOpenAs(void) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!_pszExt);
}


CInternetOpenAs::~CInternetOpenAs()
{
    Str_SetPtrW(&_pszExt, NULL);
    Str_SetPtrW(&_pszFilename, NULL);

    DllRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fsdata.h ===
#ifndef __FSDATA_H__
#define __FSDATA_H__

#include "idldata.h"

class CFSIDLData : public CIDLDataObj
{
public:
    CFSIDLData(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject *pdtInner): CIDLDataObj(pidlFolder, cidl, apidl, pdtInner) { };

    // IDataObject methods overwrite
    STDMETHODIMP GetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
    STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);
    STDMETHODIMP SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);

    STDMETHODIMP GetHDrop(LPFORMATETC pformatetcIn, STGMEDIUM *pmedium);
    STDMETHODIMP CreateHDrop(STGMEDIUM *pmedium, BOOL fAltName);

private:
    HRESULT _GetNetResource(STGMEDIUM *pmedium);
};

STDAPI CNetData_GetNetResourceForFS(IDataObject *pdtobj, STGMEDIUM *pmedium);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fsmenu.cpp ===
#include "shellprv.h"
#include "fsmenu.h"
#include "ids.h"
#include <limits.h>
#include "filetbl.h"
#include <oleacc.h>     // MSAAMENUINFO stuff

#define CXIMAGEGAP      6

typedef enum
{
    FMII_DEFAULT =      0x0000,
    FMII_BREAK =        0x0001
} FMIIFLAGS;

#define FMI_MARKER          0x00000001
#define FMI_EXPAND          0x00000004
#define FMI_EMPTY           0x00000008
#define FMI_ON_MENU         0x00000040

// One of these per file menu.
typedef struct
{
    HMENU           hmenu;                      // Menu.
    HDPA            hdpa;                       // List of items (see below).
    const struct _FILEMENUITEM *pfmiLastSel;
    UINT            idCmd;                      // Command.
    UINT            grfFlags;                   // enum filter
    DWORD           dwMask;                     // FMC_ flags
    PFNFMCALLBACK   pfnCallback;                // Callback function.
    LPARAM          lParam;                     // Parameter passed for callback handler
    int             cyMenuSizeSinceLastBreak;   // Size of menu (cy)
} FILEMENUHEADER;

// One of these for each file menu item.
//
//  !!! Note: the testers have a test utility which grabs
//      the first 7 fields of this structure.  If you change
//      the order or meaning of these fields, make sure they
//      are notified so they can update their automated tests.
//
typedef struct _FILEMENUITEM
{
    MSAAMENUINFO    msaa;               // accessibility must be first.
    FILEMENUHEADER *pfmh;               // The header.
    IShellFolder   *psf;                // Shell Folder.
    LPITEMIDLIST    pidl;               // IDlist for item.
    int             iImage;             // Image index to use.
    DWORD           dwFlags;            // Misc flags above.
    DWORD           dwAttributes;       // GetAttributesOf(), SFGAO_ bits (only some)
    LPTSTR          psz;                // Text when not using pidls.
    LPARAM          lParam;             // Application data
} FILEMENUITEM;

#if defined(DEBUG)

BOOL IsValidPFILEMENUHEADER(FILEMENUHEADER *pfmh)
{
    return (IS_VALID_WRITE_PTR(pfmh, FILEMENUHEADER) &&
            IS_VALID_HANDLE(pfmh->hmenu, MENU) &&
            IS_VALID_HANDLE(pfmh->hdpa, DPA));
}    

BOOL IsValidPFILEMENUITEM(FILEMENUITEM *pfmi)
{
    return (IS_VALID_WRITE_PTR(pfmi, FILEMENUITEM) &&
            IS_VALID_STRUCT_PTR(pfmi->pfmh, FILEMENUHEADER) &&
            (NULL == pfmi->pidl || IS_VALID_PIDL(pfmi->pidl)) &&
            (NULL == pfmi->psz || IS_VALID_STRING_PTR(pfmi->psz, -1)));
}    
#endif


DWORD GetItemTextExtent(HDC hdc, LPCTSTR lpsz)
{
    SIZE sz;

    GetTextExtentPoint(hdc, lpsz, lstrlen(lpsz), &sz);
    // NB This is OK as long as an item's extend doesn't get very big.
    return MAKELONG((WORD)sz.cx, (WORD)sz.cy);
}

void FileMenuItem_GetDisplayName(FILEMENUITEM *pfmi, LPTSTR pszName, UINT cchName)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

    // Is this a special empty item?
    if (pfmi->dwFlags & FMI_EMPTY)
    {
        // Yep, load the string from a resource.
        LoadString(HINST_THISDLL, IDS_NONE, pszName, cchName);
    }
    else
    {
        *pszName = 0;
        // If it's got a pidl use that, else just use the normal menu string.
        if (pfmi->psz)
        {
            lstrcpyn(pszName, pfmi->psz, cchName);
        }
        else if (pfmi->pidl && pfmi->psf && SUCCEEDED(DisplayNameOf(pfmi->psf, pfmi->pidl, SHGDN_NORMAL, pszName, cchName)))
        {
            pfmi->psz = StrDup(pszName);
        }
    }
}

// Create a menu item structure to be stored in the hdpa

BOOL FileMenuItem_Create(FILEMENUHEADER *pfmh, IShellFolder *psf, LPCITEMIDLIST pidl, DWORD dwFlags, FILEMENUITEM **ppfmi)
{
    FILEMENUITEM *pfmi = (FILEMENUITEM *)LocalAlloc(LPTR, sizeof(*pfmi));
    if (pfmi)
    {
        pfmi->pfmh = pfmh;
        pfmi->iImage = -1;
        pfmi->dwFlags = dwFlags;
        pfmi->pidl = pidl ? ILClone(pidl) : NULL;
        pfmi->psf = psf;
        if (pfmi->psf)
            pfmi->psf->AddRef();

        if (pfmi->psf && pfmi->pidl)
        {
            pfmi->dwAttributes = SFGAO_FOLDER;
            pfmi->psf->GetAttributesOf(1, &pidl, &pfmi->dwAttributes);
        }

        // fill in msaa stuff
        pfmi->msaa.dwMSAASignature = MSAA_MENU_SIG;

        // prep the pfmi->psz cached displayname
        WCHAR sz[MAX_PATH];
        FileMenuItem_GetDisplayName(pfmi, sz, ARRAYSIZE(sz));

        // just use the same string ref, so we dont dupe the allocation.
        pfmi->msaa.pszWText = pfmi->psz;
        pfmi->msaa.cchWText = pfmi->msaa.pszWText ? lstrlenW(pfmi->msaa.pszWText) : 0;
    }

    *ppfmi = pfmi;

    return (NULL != pfmi);
}

BOOL FileMenuItem_Destroy(FILEMENUITEM *pfmi)
{
    BOOL fRet = FALSE;
    if (pfmi)
    {
        ILFree(pfmi->pidl);
        LocalFree(pfmi->psz);
        ATOMICRELEASE(pfmi->psf);
        LocalFree(pfmi);
        fRet = TRUE;
    }
    return fRet;
}

// Enumerates the folder and adds the files to the DPA.
// Returns: count of items in the list
int FileList_Build(FILEMENUHEADER *pfmh, IShellFolder *psf, int cItems)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    
    if (pfmh->hdpa)
    {
        // special case the single empty item, and remove it.
        // this is because we expect to get called multiple times in FileList_Build on a single menu.
        if ((1 == cItems) && (1 == DPA_GetPtrCount(pfmh->hdpa)))
        {
            FILEMENUITEM *pfmiEmpty = (FILEMENUITEM*)DPA_GetPtr(pfmh->hdpa, 0);
            if (pfmiEmpty->dwFlags & FMI_EMPTY)
            {
                DeleteMenu(pfmh->hmenu, 0, MF_BYPOSITION);
                FileMenuItem_Destroy(pfmiEmpty);
                DPA_DeletePtr(pfmh->hdpa, 0);

                cItems = 0;
            }
        }

        // We now need to iterate over the children under this guy...
        IEnumIDList *penum;
        if (S_OK == psf->EnumObjects(NULL, pfmh->grfFlags, &penum))
        {
            LPITEMIDLIST pidl;
            while (S_OK == penum->Next(1, &pidl, NULL))
            {
                FILEMENUITEM *pfmi;
                
                if (FileMenuItem_Create(pfmh, psf, pidl, 0, &pfmi))
                {
                    int idpa = DPA_AppendPtr(pfmh->hdpa, pfmi);
                    ASSERTMSG(idpa != -1, "DPA_AppendPtr failed when adding file menu item");
                    
                    if (idpa != -1)
                    {
                        // if the caller returns S_FALSE then we will remove the item from the
                        // menu, otherwise we behave as before.
                        if (pfmh->pfnCallback(FMM_ADD, pfmh->lParam, psf, pidl) == S_FALSE)
                        {
                            FileMenuItem_Destroy(pfmi);
                            DPA_DeletePtr(pfmh->hdpa, idpa);
                        }
                        else
                        {
                            cItems++;
                        }
                    }
                }
                ILFree(pidl);
            }
            penum->Release();
        }
    }
    
    // Insert a special Empty item
    if (!cItems && pfmh->hdpa)
    {
        FILEMENUITEM *pfmi;
        
        if (FileMenuItem_Create(pfmh, NULL, NULL, FMI_EMPTY, &pfmi))
        {
            DPA_SetPtr(pfmh->hdpa, cItems, pfmi);
            cItems++;
        }
    }
    return cItems;
}

// Use the text extent of the given item and the size of the image to work
// what the full extent of the item will be.
DWORD GetItemExtent(HDC hdc, FILEMENUITEM *pfmi)
{
    TCHAR szName[MAX_PATH];

    szName[0] = 0;

    ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

    FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));

    FILEMENUHEADER *pfmh = pfmi->pfmh;
    ASSERT(pfmh);

    DWORD dwExtent = GetItemTextExtent(hdc, szName);

    UINT uHeight = HIWORD(dwExtent);

    // If no custom height - calc it.
    uHeight = max(uHeight, ((WORD)g_cySmIcon)) + 6;

    ASSERT(pfmi->pfmh);

    //    string, image, gap on either side of image, popup triangle
    //    and background bitmap if there is one.
    // FEATURE: popup triangle size needs to be real
    UINT uWidth = LOWORD(dwExtent) + GetSystemMetrics(SM_CXMENUCHECK);

    // Space for image if there is one.
    // NB We currently always allow room for the image even if there
    // isn't one so that imageless items line up properly.
    uWidth += g_cxSmIcon + (2 * CXIMAGEGAP);

    return MAKELONG(uWidth, uHeight);
}


// Get the FILEMENUITEM *of this menu item
FILEMENUITEM *FileMenu_GetItemData(HMENU hmenu, UINT iItem, BOOL bByPos)
{
    MENUITEMINFO mii = {0};

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA | MIIM_STATE;

    return GetMenuItemInfo(hmenu, iItem, bByPos, &mii) ? (FILEMENUITEM *)mii.dwItemData : NULL;
}

FILEMENUHEADER *FileMenu_GetHeader(HMENU hmenu)
{
    FILEMENUITEM *pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);

    if (pfmi && 
        EVAL(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM)) &&
        EVAL(IS_VALID_STRUCT_PTR(pfmi->pfmh, FILEMENUHEADER)))
    {
        return pfmi->pfmh;
    }

    return NULL;
}

// Create a file menu header.  This header is to be associated 
// with the given menu handle.
// If the menu handle already has header, simply return the
// existing header.

FILEMENUHEADER *FileMenuHeader_Create(HMENU hmenu, const FMCOMPOSE *pfmc)
{
    FILEMENUHEADER *pfmh;
    FILEMENUITEM *pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
    // Does this guy already have a header?
    if (pfmi)
    {
        // Yes; use it
        pfmh = pfmi->pfmh;
        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    }
    else
    {
        // Nope, create one now.
        pfmh = (FILEMENUHEADER *)LocalAlloc(LPTR, sizeof(*pfmh));
        if (pfmh)
        {
            pfmh->hdpa = DPA_Create(0);
            if (pfmh->hdpa == NULL)
            {
                LocalFree((HLOCAL)pfmh);
                pfmh = NULL;
            }
            else
            {
                pfmh->hmenu = hmenu;
            }
        }
    }

    if (pfmc && pfmh)
    {
        pfmh->idCmd = pfmc->idCmd;
        pfmh->grfFlags = pfmc->grfFlags;
        pfmh->dwMask = pfmc->dwMask;
        pfmh->pfnCallback = pfmc->pfnCallback;
        pfmh->lParam = pfmc->lParam;
    }
    return pfmh;
}

BOOL FileMenuHeader_InsertMarkerItem(FILEMENUHEADER *pfmh, IShellFolder *psf);

// This functions adds the given item (index into DPA) into the actual menu.
BOOL FileMenuHeader_InsertItem(FILEMENUHEADER *pfmh, UINT iItem, FMIIFLAGS fFlags)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    // Normal item.
    FILEMENUITEM *pfmi = (FILEMENUITEM *)DPA_GetPtr(pfmh->hdpa, iItem);
    if (!pfmi || (pfmi->dwFlags & FMI_ON_MENU))
        return FALSE;

    pfmi->dwFlags |= FMI_ON_MENU;

    // The normal stuff.
    UINT fMenu = MF_BYPOSITION | MF_OWNERDRAW;
    // Keep track of where it's going in the menu.

    // The special stuff...
    if (fFlags & FMII_BREAK)
    {
        fMenu |= MF_MENUBARBREAK;
    }

    // Is it a folder (that's not open yet)?
    if ((pfmi->dwAttributes & SFGAO_FOLDER) && !(pfmh->dwMask & FMC_NOEXPAND))
    {
        // Yep. Create a submenu item.
        HMENU hmenuSub = CreatePopupMenu();
        if (hmenuSub)
        {
            FMCOMPOSE fmc = {0};

            // Set the callback now so it can be called when adding items
            fmc.lParam      = pfmh->lParam;  
            fmc.pfnCallback = pfmh->pfnCallback;
            fmc.dwMask      = pfmh->dwMask;
            fmc.idCmd       = pfmh->idCmd;
            fmc.grfFlags    = pfmh->grfFlags;

            // Insert it into the parent menu.
            InsertMenu(pfmh->hmenu, iItem, fMenu | MF_POPUP, (UINT_PTR)hmenuSub, (LPTSTR)pfmi);

            // Set it's ID.
            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_ID;
            mii.wID = pfmh->idCmd;
            SetMenuItemInfo(pfmh->hmenu, iItem, TRUE, &mii);

            IShellFolder *psf;
            if (SUCCEEDED(pfmi->psf->BindToObject(pfmi->pidl, NULL, IID_PPV_ARG(IShellFolder, &psf))))
            {
                FILEMENUHEADER *pfmhSub = FileMenuHeader_Create(hmenuSub, &fmc);
                if (pfmhSub)
                {
                    // Build it a bit at a time.
                    FileMenuHeader_InsertMarkerItem(pfmhSub, psf);
                }
                psf->Release();
            }
        }
    }
    else
    {
        // Nope.
        if (pfmi->dwFlags & FMI_EMPTY)
            fMenu |= MF_DISABLED | MF_GRAYED;

        InsertMenu(pfmh->hmenu, iItem, fMenu, pfmh->idCmd, (LPTSTR)pfmi);
    }

    return TRUE;
}

// Give the submenu a marker item so we can check it's a filemenu item
// at initpopupmenu time.
BOOL FileMenuHeader_InsertMarkerItem(FILEMENUHEADER *pfmh, IShellFolder *psf)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    FILEMENUITEM *pfmi;
    if (FileMenuItem_Create(pfmh, psf, NULL, FMI_MARKER | FMI_EXPAND, &pfmi))
    {
        DPA_SetPtr(pfmh->hdpa, 0, pfmi);
        FileMenuHeader_InsertItem(pfmh, 0, FMII_DEFAULT);
        return TRUE;
    }
    return FALSE;
}

// Enumerates the DPA and adds each item into the
// menu.  Inserts vertical breaks if the menu becomes too long.
// Returns: count of items added to menu
int FileList_AddToMenu(FILEMENUHEADER *pfmh)
{
    int cItemMac = 0;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (pfmh->hdpa)
    {
        int cyItem = 0;
        int cyMenu = pfmh->cyMenuSizeSinceLastBreak;

        int cyMenuMax = GetSystemMetrics(SM_CYSCREEN);

        // Get the rough height of an item so we can work out when to break the
        // menu. User should really do this for us but that would be useful.
        HDC hdc = GetDC(NULL);
        if (hdc)
        {
            NONCLIENTMETRICS ncm;
            ncm.cbSize = sizeof(ncm);
            if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE))
            {
                HFONT hfont = CreateFontIndirect(&ncm.lfMenuFont);
                if (hfont)
                {
                    HFONT hfontOld = SelectFont(hdc, hfont);
                    cyItem = HIWORD(GetItemExtent(hdc, (FILEMENUITEM *)DPA_GetPtr(pfmh->hdpa, 0)));
                    SelectObject(hdc, hfontOld);
                    DeleteObject(hfont);
                }
            }
            ReleaseDC(NULL, hdc);
        }

        UINT cItems = DPA_GetPtrCount(pfmh->hdpa);

        for (UINT i = 0; i < cItems; i++)
        {
            // Keep a rough count of the height of the menu.
            cyMenu += cyItem;
            if (cyMenu > cyMenuMax)
            {
                // Add a vertical break?
                FileMenuHeader_InsertItem(pfmh, i, FMII_BREAK);
                cyMenu = cyItem;
            }
            else
            {
                FileMenuHeader_InsertItem(pfmh, i, FMII_DEFAULT);
                cItemMac++;
            }
        }

        // Save the current cy size so we can use this again
        // if more items are appended to this menu.

        pfmh->cyMenuSizeSinceLastBreak = cyMenu;
    }

    return cItemMac;
}


BOOL FileList_AddImages(FILEMENUHEADER *pfmh)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    int cItems = DPA_GetPtrCount(pfmh->hdpa);
    for (int i = 0; i < cItems; i++)
    {
        FILEMENUITEM *pfmi = (FILEMENUITEM *)DPA_GetPtr(pfmh->hdpa, i);
        if (pfmi && pfmi->pidl && (pfmi->iImage == -1))
        {
            pfmi->iImage = SHMapPIDLToSystemImageListIndex(pfmi->psf, pfmi->pidl, NULL);
        }
    }
    return TRUE;
}

// We create subemnu's with one marker item so we can check it's a file menu
// at init popup time but we need to delete it before adding new items.
BOOL FileMenuHeader_DeleteMarkerItem(FILEMENUHEADER *pfmh, IShellFolder **ppsf)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (GetMenuItemCount(pfmh->hmenu) == 1)
    {
        if (GetMenuItemID(pfmh->hmenu, 0) == pfmh->idCmd)
        {
            FILEMENUITEM *pfmi = FileMenu_GetItemData(pfmh->hmenu, 0, TRUE);
            if (pfmi && (pfmi->dwFlags & FMI_MARKER))
            {
                // Delete it.
                ASSERT(pfmh->hdpa);
                ASSERT(DPA_GetPtrCount(pfmh->hdpa) == 1);

                if (ppsf)
                {
                    *ppsf = pfmi->psf;  // transfer the ref
                    pfmi->psf = NULL;
                }
                ASSERT(NULL == pfmi->psf);
                // NB The marker shouldn't have a pidl.
                ASSERT(NULL == pfmi->pidl);

                LocalFree((HLOCAL)pfmi);

                DPA_DeletePtr(pfmh->hdpa, 0);
                DeleteMenu(pfmh->hmenu, 0, MF_BYPOSITION);
                // Cleanup OK.
                return TRUE;
            }
        }
    }
    return FALSE;
}

// Add files to a file menu header. This function goes thru
// the following steps:
// - enumerates the folder and fills the hdpa list with items
// (files and subfolders)
// - sorts the list
// - gets the images for the items in the list
// - adds the items from list into actual menu
// The last step also (optionally) caps the length of the
// menu to the specified height.  Ideally, this should
// happen at the enumeration time, except the required sort
// prevents this from happening.  So we end up adding a
// bunch of items to the list and then removing them if
// there are too many.
// returns: count of items added

HRESULT FileMenuHeader_AddFiles(FILEMENUHEADER *pfmh, IShellFolder *psf, int iPos, int *pcItems)
{
    HRESULT hr;
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    int cItems = FileList_Build(pfmh, psf, iPos);

    // If the build was aborted cleanup and early out.
    *pcItems = cItems;

    if (cItems != 0)
    {
        // Add the images *after* adding to the menu, since the menu
        // may be capped to a maximum height, and we can then prevent
        // adding images we won't need.
        *pcItems = FileList_AddToMenu(pfmh);
        FileList_AddImages(pfmh);
    }

    hr = (*pcItems < cItems) ? S_FALSE : S_OK;

    TraceMsg(TF_MENU, "FileMenuHeader_AddFiles: Added %d filemenu items.", cItems);
    return hr;
}

// Add files to this menu.
// Returns: number of items added
HRESULT FileMenu_AddFiles(HMENU hmenu, UINT iPos, FMCOMPOSE *pfmc)
{
    HRESULT hr = E_OUTOFMEMORY;
    BOOL fMarker = FALSE;

    // (FileMenuHeader_Create might return an existing header)
    FILEMENUHEADER *pfmh = FileMenuHeader_Create(hmenu, pfmc);
    if (pfmh)
    {
        FILEMENUITEM *pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
        if (pfmi)
        {
            // Clean up marker item if there is one.
            if ((FMI_MARKER | FMI_EXPAND) == (pfmi->dwFlags & (FMI_MARKER | FMI_EXPAND)))
            {
                // Nope, do it now.
                FileMenuHeader_DeleteMarkerItem(pfmh, NULL);
                fMarker = TRUE;
                if (iPos)
                    iPos--;
            }
        }

        hr = FileMenuHeader_AddFiles(pfmh, pfmc->psf, iPos, &pfmc->cItems);

        if ((0 == pfmc->cItems) && fMarker)
        {
            // Aborted or no items. Put the marker back (if there used
            // to be one).
            FileMenuHeader_InsertMarkerItem(pfmh, NULL);
        }
    }

    return hr;
}

// creator of the filemenu has to explicitly call to free
// up FileMenu items because USER doesn't send WM_DELETEITEM for ownerdraw
// menu. Great eh?
// Returns the number of items deleted.

void FileMenu_DeleteAllItems(HMENU hmenu)
{
    FILEMENUHEADER *pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        // Clean up the items.
        UINT cItems = DPA_GetPtrCount(pfmh->hdpa);
        // backwards stop things dont move as we delete
        for (int i = cItems - 1; i >= 0; i--)
        {
            FILEMENUITEM *pfmi = (FILEMENUITEM *)DPA_GetPtr(pfmh->hdpa, i);
            if (pfmi)
            {
                HMENU hmenuSub = GetSubMenu(pfmh->hmenu, i);    // cascade item?
                if (hmenuSub)
                {
                    // Yep. Get the submenu for this item, Delete all items.
                    FileMenu_DeleteAllItems(hmenuSub);
                }
                // Delete the item itself.
                DeleteMenu(pfmh->hmenu, i, MF_BYPOSITION);
                FileMenuItem_Destroy(pfmi);
                DPA_DeletePtr(pfmh->hdpa, i);
            }
        }

        // Clean up the header.
        DPA_Destroy(pfmh->hdpa);
        LocalFree((HLOCAL)pfmh);
    }
}

STDAPI FileMenu_Compose(HMENU hmenu, UINT nMethod, FMCOMPOSE *pfmc)
{
    HRESULT hr = E_INVALIDARG;

    switch (nMethod)
    {
    case FMCM_INSERT:
        hr = FileMenu_AddFiles(hmenu, 0, pfmc);
        break;

    case FMCM_APPEND:
        hr = FileMenu_AddFiles(hmenu, GetMenuItemCount(hmenu), pfmc);
        break;

    case FMCM_REPLACE:
        FileMenu_DeleteAllItems(hmenu);
        hr = FileMenu_AddFiles(hmenu, 0, pfmc);
        break;
    }
    return hr;
}

LPITEMIDLIST FileMenuItem_FullIDList(const FILEMENUITEM *pfmi)
{
    LPITEMIDLIST pidlFolder, pidl = NULL;
    if (SUCCEEDED(SHGetIDListFromUnk(pfmi->psf, &pidlFolder)))
    {
        pidl = ILCombine(pidlFolder, pfmi->pidl);
        ILFree(pidlFolder);
    }
    return pidl;
}

void FileMenuItem_SetItem(const FILEMENUITEM *pfmi, BOOL bClear)
{
    if (bClear)
    {
        pfmi->pfmh->pfmiLastSel = NULL;
        pfmi->pfmh->pfnCallback(FMM_SETLASTPIDL, pfmi->pfmh->lParam, NULL, NULL);
    }
    else
    {
        pfmi->pfmh->pfmiLastSel = pfmi;

        LPITEMIDLIST pidl = FileMenuItem_FullIDList(pfmi);
        if (pidl)
        {
            pfmi->pfmh->pfnCallback(FMM_SETLASTPIDL, pfmi->pfmh->lParam, NULL, pidl);
            ILFree(pidl);
        }
    }
}

LRESULT FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT *pdi)
{
    BOOL fFlatMenu = FALSE;
    BOOL fFrameRect = FALSE;

    SystemParametersInfo(SPI_GETFLATMENU, 0, (void *)&fFlatMenu, 0);

    if ((pdi->itemAction & ODA_SELECT) || (pdi->itemAction & ODA_DRAWENTIRE))
    {
        HBRUSH hbrOld = NULL;
        FILEMENUITEM *pfmi = (FILEMENUITEM *)pdi->itemData;

        ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));
       
        if (!pfmi)
        {
            TraceMsg(TF_ERROR, "FileMenu_DrawItem: Filemenu is invalid (no item data).");
            return FALSE;
        }

        FILEMENUHEADER *pfmh = pfmi->pfmh;
        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

        // Adjust for large/small icons.
        int cxIcon = g_cxSmIcon;
        int cyIcon = g_cxSmIcon;

        // Is the menu just starting to get drawn?
        if (pdi->itemAction & ODA_DRAWENTIRE)
        {
            if (pfmi == DPA_GetPtr(pfmh->hdpa, 0))
            {
                // Yes; reset the last selection item
                FileMenuItem_SetItem(pfmi, TRUE);
            }
        }

        if (pdi->itemState & ODS_SELECTED)
        {
            // Determine the selection colors
            //
            // Normal menu colors apply until we are in edit mode, in which
            // case the menu item is drawn unselected and an insertion caret 
            // is drawn above or below the current item.  The exception is 
            // if the item is a cascaded menu item, then we draw it 
            // normally, but also show the insertion caret.  (We do this
            // because Office does this, and also, USER draws the arrow
            // in the selected color always, so it looks kind of funny 
            // if we don't select the menu item.)
            //
            if (fFlatMenu)
            {
                SetBkColor(pdi->hDC, GetSysColor(COLOR_MENUHILIGHT));
                hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_MENUHILIGHT));
                fFrameRect = TRUE;
            }
            else
            {
                // No
                SetBkColor(pdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
                SetTextColor(pdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
                hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_HIGHLIGHTTEXT));
            }

            // inform callback of last item
            FileMenuItem_SetItem(pfmi, FALSE);
        }
        else
        {
            // dwRop = SRCAND;
            hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_MENUTEXT));
        }

        // Initial start pos.
        int x = pdi->rcItem.left + CXIMAGEGAP;

        // Get the name.
        TCHAR szName[MAX_PATH];
        FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));

        // NB Keep a plain copy of the name for testing and accessibility.
        if (!pfmi->psz)
            pfmi->psz = StrDup(szName);

        DWORD dwExtent = GetItemTextExtent(pdi->hDC, szName);
        int y = (pdi->rcItem.bottom+pdi->rcItem.top - HIWORD(dwExtent)) / 2;

        // Shrink the selection rect for small icons a bit.
        pdi->rcItem.top += 1;
        pdi->rcItem.bottom -= 1;

        // Draw the text.
        int fDSFlags;

        if ((pfmi->dwFlags & FMI_ON_MENU) == 0)
        {
            // Norton Desktop Navigator 95 replaces the Start->&Run
            // menu item with a &Run pidl.  Even though the text is
            // from a pidl, we still want to format the "&R" correctly.
            fDSFlags = DST_PREFIXTEXT;
        }
        else
        {
            // All other strings coming from pidls are displayed
            // as is to preserve any & in their display name.
            fDSFlags = DST_TEXT;
        }

        if (pfmi->dwFlags & FMI_EMPTY)
        {
            if (pdi->itemState & ODS_SELECTED)
            {
                if (GetSysColor(COLOR_GRAYTEXT) == GetSysColor(COLOR_HIGHLIGHTTEXT))
                {
                    fDSFlags |= DSS_UNION;
                }
                else
                {
                    SetTextColor(pdi->hDC, GetSysColor(COLOR_GRAYTEXT));
                }
            }
            else
            {
                fDSFlags |= DSS_DISABLED;
            }

            ExtTextOut(pdi->hDC, 0, 0, ETO_OPAQUE, &pdi->rcItem, NULL, 0, NULL);
            DrawState(pdi->hDC, NULL, NULL, (LONG_PTR)szName, lstrlen(szName), x + cxIcon + CXIMAGEGAP, y, 0, 0, fDSFlags);
        }
        else
        {
            ExtTextOut(pdi->hDC, x + cxIcon + CXIMAGEGAP, y, ETO_OPAQUE, &pdi->rcItem, NULL, 0, NULL);
            DrawState(pdi->hDC, NULL, NULL, (LONG_PTR)szName, lstrlen(szName), x + cxIcon + CXIMAGEGAP, y, 0, 0, fDSFlags);
        }

        if (fFrameRect)
        {
            HBRUSH hbrFill = (HBRUSH)GetSysColorBrush(COLOR_HIGHLIGHT);
            HBRUSH hbrSave = (HBRUSH)SelectObject(pdi->hDC, hbrFill);
            int x = pdi->rcItem.left;
            int y = pdi->rcItem.top;
            int cx = pdi->rcItem.right - x - 1;
            int cy = pdi->rcItem.bottom - y - 1;

            PatBlt(pdi->hDC, x, y, 1, cy, PATCOPY);
            PatBlt(pdi->hDC, x + 1, y, cx, 1, PATCOPY);
            PatBlt(pdi->hDC, x, y + cy, cx, 1, PATCOPY);
            PatBlt(pdi->hDC, x + cx, y + 1, 1, cy, PATCOPY);

            SelectObject(pdi->hDC, hbrSave);
        }

        // Get the image if it needs it,
        if ((pfmi->iImage == -1) && pfmi->pidl && pfmi->psf)
        {
            pfmi->iImage = SHMapPIDLToSystemImageListIndex(pfmi->psf, pfmi->pidl, NULL);
        }

        // Draw the image (if there is one).
        if (pfmi->iImage != -1)
        {
            // Try to center image.
            y = (pdi->rcItem.bottom + pdi->rcItem.top - cyIcon) / 2;

            HIMAGELIST himl;
            Shell_GetImageLists(NULL, &himl);

            ImageList_DrawEx(himl, pfmi->iImage, pdi->hDC, x, y, 0, 0,
                GetBkColor(pdi->hDC), CLR_NONE, ILD_NORMAL);
        }
        if (hbrOld)
            SelectObject(pdi->hDC, hbrOld);
    }
    return TRUE;
}


DWORD FileMenuItem_GetExtent(FILEMENUITEM *pfmi)
{
    DWORD dwExtent = 0;

    if (pfmi)
    {
        FILEMENUHEADER *pfmh = pfmi->pfmh;

        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

        HDC hdcMem = CreateCompatibleDC(NULL);
        if (hdcMem)
        {
            // Get the rough height of an item so we can work out when to break the
            // menu. User should really do this for us but that would be useful.
            NONCLIENTMETRICS ncm = {0};
            ncm.cbSize = sizeof(ncm);
            if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE))
            {
                HFONT hfont = CreateFontIndirect(&ncm.lfMenuFont);
                if (hfont)
                {
                    HFONT hfontOld = SelectFont(hdcMem, hfont);
                    dwExtent = GetItemExtent(hdcMem, pfmi);
                    SelectFont(hdcMem, hfontOld);
                    DeleteObject(hfont);
                }
            }
            DeleteDC(hdcMem);
        }
    }
    return dwExtent;
}

LRESULT FileMenu_MeasureItem(HWND hwnd, MEASUREITEMSTRUCT *pmi)
{
    DWORD dwExtent = FileMenuItem_GetExtent((FILEMENUITEM *)pmi->itemData);
    pmi->itemHeight = HIWORD(dwExtent);
    pmi->itemWidth = LOWORD(dwExtent);
    return TRUE;
}

// Fills the given filemenu with contents of the appropriate folder
//
// Returns: S_OK if all the files were added
//         error on something bad

STDAPI FileMenu_InitMenuPopup(HMENU hmenu)
{
    HRESULT hr = E_FAIL;

    FILEMENUITEM *pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
    if (pfmi)
    {
        FILEMENUHEADER *pfmh = pfmi->pfmh;
        if (pfmh)
        {
            hr = S_OK;

            // Have we already filled this thing out?
            if ((FMI_MARKER | FMI_EXPAND) == (pfmi->dwFlags & (FMI_MARKER | FMI_EXPAND)))
            {
                // No, do it now.  Get the previously init'ed header.
                IShellFolder *psf;
                if (FileMenuHeader_DeleteMarkerItem(pfmh, &psf))
                {
                    // Fill it full of stuff.
                    int cItems;
                    hr = FileMenuHeader_AddFiles(pfmh, psf, 0, &cItems);
                    psf->Release();
                }
            }
        }
    }

    return hr;
}

int FileMenuHeader_LastSelIndex(FILEMENUHEADER *pfmh)
{
    for (int i = GetMenuItemCount(pfmh->hmenu) - 1; i >= 0; i--)
    {
        FILEMENUITEM *pfmi = FileMenu_GetItemData(pfmh->hmenu, i, TRUE);
        if (pfmi && (pfmi == pfmh->pfmiLastSel))
            return i;
    }
    return -1;
}

// If the string contains &ch or begins with ch then return TRUE.
BOOL _MenuCharMatch(LPCTSTR lpsz, TCHAR ch, BOOL fIgnoreAmpersand)
{
    // Find the first ampersand.
    LPTSTR pchAS = StrChr(lpsz, TEXT('&'));
    if (pchAS && !fIgnoreAmpersand)
    {
        // Yep, is the next char the one we want.
        if (CharUpperChar(*CharNext(pchAS)) == CharUpperChar(ch))
        {
            // Yep.
            return TRUE;
        }
    }
    else if (CharUpperChar(*lpsz) == CharUpperChar(ch))
    {
        return TRUE;
    }

    return FALSE;
}

STDAPI_(LRESULT) FileMenu_HandleMenuChar(HMENU hmenu, TCHAR ch)
{
    FILEMENUITEM *pfmi;
    TCHAR szName[MAX_PATH];

    int iFoundOne = -1;
    UINT iStep = 0;
    UINT iItem = 0;
    UINT cItems = GetMenuItemCount(hmenu);

    // Start from the last place we looked from.
    FILEMENUHEADER *pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        iItem = FileMenuHeader_LastSelIndex(pfmh) + 1;
        if (iItem >= cItems)
            iItem = 0;
    }

    while (iStep < cItems)
    {
        pfmi = FileMenu_GetItemData(hmenu, iItem, TRUE);
        if (pfmi)
        {
            FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));
            if (_MenuCharMatch(szName, ch, pfmi->pidl ? TRUE : FALSE))
            {
                // Found (another) match.
                if (iFoundOne != -1)
                {
                    // More than one, select the first.
                    return MAKELRESULT(iFoundOne, MNC_SELECT);
                }
                else
                {
                    // Found at least one.
                    iFoundOne = iItem;
                }
            }

        }
        iItem++;
        iStep++;
        // Wrap.
        if (iItem >= cItems)
            iItem = 0;
    }

    // Did we find one?
    if (iFoundOne != -1)
    {
        // Just in case the user types ahead without the selection being drawn.
        pfmi = FileMenu_GetItemData(hmenu, iFoundOne, TRUE);
        FileMenuItem_SetItem(pfmi, FALSE);

        return MAKELRESULT(iFoundOne, MNC_EXECUTE);
    }
    else
    {
        // Didn't find it.
        return MAKELRESULT(0, MNC_IGNORE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fstree.cpp ===
#include "shellprv.h"
#include "filefldr.h"
#include <shellp.h>
#include <shguidp.h>
#include "idlcomm.h"
#include "pidl.h"
#include "views.h"
#include "ids.h"
#include "shitemid.h"
#include "datautil.h"
#include "prop.h"
#include "basefvcb.h"
#include "brutil.h"
#include "enumuicommand.h"
#include "enumidlist.h"
#include "wia.h"
#include "shimgvw.h"
#include "cdburn.h"
#include "foldertypes.h"
#include "htmlhelp.h"
#include "buytasks.h"
#include <crypto\md5.h>     // for MD5DIGESTLEN

const SHOP_INFO c_BuySampleMusic =    { L"BuyURL",      L"http://go.microsoft.com/fwlink/?LinkId=730&clcid={SUB_CLCID}", FALSE};
const SHOP_INFO c_BuyMusic          = { L"MusicBuyURL", L"http://go.microsoft.com/fwlink/?LinkId=493&clcid={SUB_CLCID}", TRUE};
const SHOP_INFO c_BuySamplePictures = { L"BuyURL",      L"http://go.microsoft.com/fwlink/?LinkId=625&clcid={SUB_CLCID}", TRUE};

class CFSFolderViewCB : public CBaseShellFolderViewCB
{
public:
    CFSFolderViewCB(CFSFolder *pfsf);
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    STDMETHODIMP SetSite(IUnknown* pUnkSite);

private:
    ~CFSFolderViewCB();

    HRESULT OnSize(DWORD pv, UINT cx, UINT cy);
    HRESULT OnGetPane(DWORD pv, LPARAM dwPaneID, DWORD *pdwPane);
    HRESULT OnGetCCHMax(DWORD pv, LPCITEMIDLIST pidlItem, UINT *pcchMax);
    HRESULT OnWindowCreated(DWORD pv, HWND wP);
    HRESULT OnInsertDeleteItem(int iMul, LPCITEMIDLIST wP);
    HRESULT OnSelChange(DWORD pv, UINT wPl, UINT wPh, SFVM_SELCHANGE_DATA*lP);
    HRESULT OnUpdateStatusBar(DWORD pv, BOOL wP);
    HRESULT OnRefresh(DWORD pv, BOOL fPreRefresh);
    HRESULT OnSelectAll(DWORD pv);
    HRESULT OnGetWorkingDir(DWORD pv, UINT wP, LPTSTR lP);
    HRESULT OnEnumeratedItems(DWORD pv, UINT celt, LPCITEMIDLIST* rgpidl);
    HRESULT OnGetViewData(DWORD pv, UINT uViewMode, SFVM_VIEW_DATA* pvi);
    HRESULT OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit);
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);
    HRESULT OnGetWebViewTheme(DWORD pv, SFVM_WEBVIEW_THEME_DATA* pTheme);
    HRESULT OnDefViewMode(DWORD pv, FOLDERVIEWMODE*lP);
    HRESULT OnGetCustomViewInfo(DWORD pv, SFVM_CUSTOMVIEWINFO_DATA* pData);
    HRESULT OnSupportsIdentity(DWORD pv);
    HRESULT OnQueryReuseExtView(DWORD pv, BOOL *pfReuseAllowed);
    HRESULT OnGetNotify(DWORD pv, LPITEMIDLIST*wP, LONG*lP);
    HRESULT OnGetDeferredViewSettings(DWORD pv, SFVM_DEFERRED_VIEW_SETTINGS* pSettings);

    BOOL _CollectDefaultFolderState();
    PERCEIVED _GetFolderPerceivedType(LPCIDFOLDER pidf);
    HRESULT _GetStringForFolderType(int iType, LPWSTR pszFolderType, UINT cchBuf);
    BOOL _IsBarricadedFolder();

    UINT _cItems;

    FSSELCHANGEINFO _fssci;
    CFSFolder* _pfsf;
    BOOL _fStatusInitialized;

    TRIBIT _fHasWIADevices;

    IPreview3 * _pPreview;
    HRESULT _GetPreview3(IPreview3** ppPreview3);

    HRESULT _GetShoppingBrowsePidl(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc, const SHOP_INFO *pShopInfo, LPITEMIDLIST *ppidl);
    HRESULT _GetShoppingURL(const SHOP_INFO *pShopInfo, LPTSTR pszURL, DWORD cchURL);


    HRESULT _DataObjectFromItemsOrFolder(IShellItemArray *psiItemArray, IDataObject **ppdto);

public:
    // webview task implementations:
    static HRESULT _HasWiaDevices(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _HasItems(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanOrderPrints(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanPrintPictures(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanBuyPictures(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanWallpaper(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanPlayMusic(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanPlayVideos(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanSendToAudioCD(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanSendToCD(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _OnCommonDocumentsHelp(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnPlayMusic(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnPlayVideos(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnShopForMusicOnline(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnShopForPicturesOnline(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnSendToAudioCD(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnGetFromCamera(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnSlideShow(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnWallpaper(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnOrderPrints(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnPrintPictures(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnSendToCD(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);

    static HRESULT _CanPlay(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState, int fDATAOBJCB);
    static HRESULT _OnPlay(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc, int fDATAOBJCB);
};

#define FS_EVENTS (SHCNE_DISKEVENTS | SHCNE_ASSOCCHANGED | SHCNE_NETSHARE | SHCNE_NETUNSHARE)

CFSFolderViewCB::CFSFolderViewCB(CFSFolder *pfsf) : CBaseShellFolderViewCB(pfsf->_pidl, FS_EVENTS), _pfsf(pfsf)
{ 
    _pfsf->AddRef();

    ZeroMemory(&_fssci, sizeof(_fssci));

    // _fssci.szDrive[0] == '\0' means "unknown" / "not available"
    _fssci.cbFree = -1;        // this field uses -1 to mean
                               // "unknown" / "not available"

    _pPreview = NULL;
    ASSERT(!_fStatusInitialized);
}

CFSFolderViewCB::~CFSFolderViewCB()
{
    if (_pPreview)
    {
        IUnknown_SetSite(_pPreview, NULL);
        _pPreview->Release();
    }

    _pfsf->Release();
}

STDMETHODIMP CFSFolderViewCB::SetSite(IUnknown* punkSite)
{
    if (_pPreview)
    {
        IUnknown_SetSite(_pPreview, punkSite);
    }
    return CBaseShellFolderViewCB::SetSite(punkSite);
}

HRESULT CFSFolderViewCB::OnSize(DWORD pv, UINT cx, UINT cy)
{
    ResizeStatus(_punkSite, cx);
    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetPane(DWORD pv, LPARAM dwPaneID, DWORD *pdwPane)
{
    if (PANE_ZONE == dwPaneID)
        *pdwPane = 2;
    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetCCHMax(DWORD pv, LPCITEMIDLIST pidlItem, UINT *pcchMax)
{
    TCHAR szName[MAX_PATH];
    if (SUCCEEDED(DisplayNameOf(_pfsf, pidlItem, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName))))
    {
        _pfsf->GetMaxLength(szName, (int *)pcchMax);
    }
    return S_OK;
}

HRESULT CFSFolderViewCB::OnWindowCreated(DWORD pv, HWND wP)
{
    if (SUCCEEDED(_pfsf->_GetPath(_fssci.szDrive)))
    {
        _fssci.cbFree = -1;                            // not known yet

        if (!_fStatusInitialized)
        {
            InitializeStatus(_punkSite);
            _fStatusInitialized = TRUE;
        }
        
        return S_OK;
    
    }
    return E_FAIL;
}

HRESULT CFSFolderViewCB::OnInsertDeleteItem(int iMul, LPCITEMIDLIST wP)
{
    ViewInsertDeleteItem(_pfsf, &_fssci, wP, iMul);

    // Tell the FSFolder that it needs to update the extended columns
    // when we get an insert item.  This will cause the next call to
    // IColumnProvider::GetItemData to flush it's row-wise cache.
    if (1 == iMul)
    {
        _pfsf->_bUpdateExtendedCols = TRUE;
    }
    return S_OK;
}

HRESULT CFSFolderViewCB::OnSelChange(DWORD pv, UINT wPl, UINT wPh, SFVM_SELCHANGE_DATA*lP)
{
    ViewSelChange(_pfsf, lP, &_fssci);
    return S_OK;
}

HRESULT CFSFolderViewCB::OnUpdateStatusBar(DWORD pv, BOOL wP)
{
    if (!_fStatusInitialized)
    {
        InitializeStatus(_punkSite);
        _fStatusInitialized = TRUE;
    }

    // if initializing, force refresh of disk free space
    if (wP)
        _fssci.cbFree = -1;
    return ViewUpdateStatusBar(_punkSite, _pidl, &_fssci);
}

HRESULT CFSFolderViewCB::OnRefresh(DWORD pv, BOOL fPreRefresh)
{
    // pre refresh...
    if (fPreRefresh)
    {
        _fHasWIADevices = TRIBIT_UNDEFINED; // so we re-query
    }
    else
    {
        _fssci.cHiddenFiles = _pfsf->_cHiddenFiles;
        _fssci.cbSize = _pfsf->_cbSize;
    }
    return S_OK;
}

HRESULT CFSFolderViewCB::OnSelectAll(DWORD pv)
{
    HRESULT hr = S_OK;

    if (_fssci.cHiddenFiles > 0) 
    {
        if (ShellMessageBox(HINST_THISDLL, _hwndMain, 
            MAKEINTRESOURCE(IDS_SELECTALLBUTHIDDEN), 
            MAKEINTRESOURCE(IDS_SELECTALL), MB_OKCANCEL | MB_SETFOREGROUND | MB_ICONWARNING, 
            _fssci.cHiddenFiles) == IDCANCEL)
        {
            hr = S_FALSE;
        }
    }
    return hr;
}

HRESULT CFSFolderViewCB::OnGetWorkingDir(DWORD pv, UINT wP, LPTSTR lP)
{
    return _pfsf->_GetPath(lP);
}

int GetSysDriveId()
{
    int idDriveSys = -1;
    
    TCHAR szSystemDir[MAX_PATH];
    if (SHGetSpecialFolderPath(NULL, szSystemDir, CSIDL_SYSTEM, 0))
    {
        idDriveSys = PathGetDriveNumber(szSystemDir);
    }
    return idDriveSys;
}


HRESULT CFSFolderViewCB::_HasWiaDevices(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    if (TRIBIT_UNDEFINED == pThis->_fHasWIADevices && fOkToBeSlow)
    {
        pThis->_fHasWIADevices = TRIBIT_FALSE;

        // strings stolen from stiregi.h
        // REGSTR_PATH_SOFT_STI, REGSTR_VAL_WIA_PRESEN

        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, 
            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\StillImage"), 
            TEXT("WIADevicePresent"), NULL, NULL, NULL))
        {
            IWiaDevMgr* pwia;
            if (SUCCEEDED(CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWiaDevMgr, &pwia))))
            {
                IEnumWIA_DEV_INFO* penum;
                if (S_OK == pwia->EnumDeviceInfo(0, &penum))
                {
                    ULONG cItems;
                    if ((S_OK == penum->GetCount(&cItems)) &&
                        cItems > 0)
                    {
                        pThis->_fHasWIADevices = TRIBIT_TRUE;
                    }
                    penum->Release();
                }
                pwia->Release();
            }
        }
    }

    *puisState = (TRIBIT_TRUE == pThis->_fHasWIADevices) ? UIS_ENABLED : UIS_HIDDEN;
    return TRIBIT_UNDEFINED == pThis->_fHasWIADevices ? E_PENDING : S_OK;
}

HRESULT CFSFolderViewCB::_HasItems(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    *puisState = UIS_ENABLED;

    if (!psiItemArray)
    {
        // empty folders don't want this task
        *puisState = UIS_DISABLED;

        IFolderView* pfv;
        IDataObject *pdo;

        if (pThis->_punkSite && SUCCEEDED(pThis->_punkSite->QueryInterface(IID_PPV_ARG(IFolderView, &pfv))))
        {
            if (SUCCEEDED(pfv->Items(SVGIO_ALLVIEW, IID_PPV_ARG(IDataObject, &pdo))))
            {
                *puisState = UIS_ENABLED;
                pdo->Release();
            }

            pfv->Release();
        }

    }

    return S_OK;
}

// Image options
#define IMAGEOPTION_CANROTATE    0x00000001
#define IMAGEOPTION_CANWALLPAPER 0x00000002

HRESULT CFSFolderViewCB::_CanWallpaper(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_DISABLED;
    IDataObject *pdo;

    if (psiItemArray && SUCCEEDED(psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo))))
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(PidlFromDataObject(pdo, &pidl))) // could get this dircetly from ShellItemArray
        {
            IAssociationArray *paa;
            if (SUCCEEDED(SHGetUIObjectOf(pidl, NULL, IID_PPV_ARG(IAssociationArray, &paa))))
            {
                DWORD dwFlags, cb = sizeof(dwFlags);
                if (SUCCEEDED(paa->QueryDword(ASSOCELEM_MASK_QUERYNORMAL, AQN_NAMED_VALUE, L"ImageOptionFlags", &dwFlags)) &&
                    (dwFlags & IMAGEOPTION_CANWALLPAPER))
                {
                    *puisState = UIS_ENABLED;
                }
                paa->Release();
            }
            ILFree(pidl);
        }

        pdo->Release();
    }

    return S_OK;
}

enum
{
    DATAOBJCB_IMAGE = 0x1,
    DATAOBJCB_MUSIC = 0x2,
    DATAOBJCB_VIDEO = 0x4,

    DATAOBJCB_ONLYCHECKEXISTENCE = 0x80000000
};
class CDataObjectCallback : public INamespaceWalkCB
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // INamespaceWalkCB
    STDMETHODIMP FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel);

    CDataObjectCallback(DWORD dwFlags);
    BOOL Found();

private:
    DWORD _dwFlags;
    BOOL _fAlreadyFound;
};

STDMETHODIMP_(ULONG) CDataObjectCallback::AddRef()
{
    return 3;
}

STDMETHODIMP_(ULONG) CDataObjectCallback::Release()
{
    return 2;
}

CDataObjectCallback::CDataObjectCallback(DWORD dwFlags)
{
    _dwFlags = dwFlags;
    _fAlreadyFound = FALSE;
}

BOOL CDataObjectCallback::Found()
{
    return _fAlreadyFound;
}

STDMETHODIMP CDataObjectCallback::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDataObjectCallback, INamespaceWalkCB),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP CDataObjectCallback::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    // a slight misuse of the walker -- we bail out early if we know we've already found
    // what we're looking for
    if ((_dwFlags & DATAOBJCB_ONLYCHECKEXISTENCE) && _fAlreadyFound)
        return E_FAIL;

    PERCEIVED gen = GetPerceivedType(psf, pidl);
    if ((_dwFlags & DATAOBJCB_IMAGE) && (gen == GEN_IMAGE) ||
        (_dwFlags & DATAOBJCB_MUSIC) && (gen == GEN_AUDIO) ||
        (_dwFlags & DATAOBJCB_VIDEO) && (gen == GEN_VIDEO))
    {
        if (_dwFlags & DATAOBJCB_ONLYCHECKEXISTENCE)
        {
            _fAlreadyFound = TRUE;
        }
        return S_OK;
    }

    return S_FALSE;
}

STDMETHODIMP CDataObjectCallback::EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    if ((_dwFlags & DATAOBJCB_ONLYCHECKEXISTENCE) && _fAlreadyFound)
        return E_FAIL;
    return S_OK;
}

STDMETHODIMP CDataObjectCallback::LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return S_OK;
}

STDMETHODIMP CDataObjectCallback::InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
{
    *ppszCancel = NULL; // use default

    TCHAR szMsg[128];
    LoadString(HINST_THISDLL, IDS_WALK_PROGRESS_TITLE, szMsg, ARRAYSIZE(szMsg));
    return SHStrDup(szMsg, ppszTitle);
}

HRESULT InvokeVerbsOnItems(HWND hwndOwner, const LPCSTR rgszVerbs[], UINT cVerbs, LPITEMIDLIST *ppidls, UINT cItems)
{
    IContextMenu *pcm;
    HRESULT hr = SHGetUIObjectFromFullPIDL(ppidls[0], NULL, IID_PPV_ARG(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        ITEMIDLIST id = {0};
        IDataObject *pdtobj;
        hr = SHCreateFileDataObject(&id, cItems, (LPCITEMIDLIST *)ppidls, NULL, &pdtobj);
        if (SUCCEEDED(hr))
        {
            IShellExtInit *psei;
            hr = pcm->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei));
            if (SUCCEEDED(hr))
            {
                psei->Initialize(NULL, pdtobj, NULL);
                psei->Release();
            }
            pdtobj->Release();
        }

        hr = SHInvokeCommandsOnContextMenu(hwndOwner, NULL, pcm, 0, rgszVerbs, cVerbs);
        pcm->Release();
    }
    return hr;
}

HRESULT PlayFromUnk(IUnknown *punk, HWND hwndOwner, int fDATAOBJCB)
{
    INamespaceWalk *pnsw;
    HRESULT hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
    if (SUCCEEDED(hr))
    {
        CDataObjectCallback cb(fDATAOBJCB);
        hr = pnsw->Walk(punk, NSWF_NONE_IMPLIES_ALL | NSWF_ONE_IMPLIES_ALL | NSWF_SHOW_PROGRESS | NSWF_FLAG_VIEWORDER, 10, &cb);
        if (SUCCEEDED(hr))
        {
            UINT cItems;
            LPITEMIDLIST *ppidls;
            hr = pnsw->GetIDArrayResult(&cItems, &ppidls);
            if (SUCCEEDED(hr))
            {
                if (cItems)
                {
                    const LPCSTR c_rgszVerbs[] = { "Play", "Open" };

                    hr = InvokeVerbsOnItems(hwndOwner, c_rgszVerbs, ARRAYSIZE(c_rgszVerbs), ppidls, cItems);
                }
                else
                {
                    ShellMessageBox(
                        HINST_THISDLL,
                        hwndOwner,
                        MAKEINTRESOURCE(IDS_PLAYABLEFILENOTFOUND),
                        NULL,
                        MB_OK | MB_ICONERROR);
                    hr = S_FALSE;
                }
                FreeIDListArray(ppidls, cItems);
            }
        }
        pnsw->Release();
    }
    return hr;
}

HRESULT CFSFolderViewCB::_OnCommonDocumentsHelp(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    SHELLEXECUTEINFO sei = { 0 };

    sei.cbSize = sizeof(sei);
    sei.fMask = 0;
    sei.hwnd = ((CFSFolderViewCB*)(void*)pv)->_hwndMain;
    sei.nShow = SW_SHOWNORMAL;
    sei.lpFile = L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/using_shared_documents_folder.htm&select=TopLevelBucket_2/Networking_and_the_Web/Sharing_files__printers__and_other_resources";

    return ShellExecuteEx(&sei) ? S_OK : E_FAIL;
}

HRESULT CFSFolderViewCB::_CanOrderPrints(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    // TODO:  Use fOkToBeSlow (with a return of E_PENDING) to allow walk to
    // occur on a background task thread (for performance reasons).  However,
    // it doesn't work at present because it's completely specialized for WIA
    // stuff, and it will not be trivial to adapt to the general case.  Thus,
    // we make assumptions as best we can in determining the state for now.

    *puisState = UIS_DISABLED;

    IDataObject *pdo = NULL;
    HRESULT hr = psiItemArray ? psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo)) : S_OK;
    if (SUCCEEDED(hr))
    {
        if (pThis->_fssci.nItems > 0)   // Files selected.  Determine if any images...
        {
            INamespaceWalk *pnsw;
            hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
            if (SUCCEEDED(hr))
            {
                CDataObjectCallback cb(DATAOBJCB_IMAGE | DATAOBJCB_ONLYCHECKEXISTENCE);
                pnsw->Walk(psiItemArray ? pdo : pThis->_punkSite, NSWF_NONE_IMPLIES_ALL | NSWF_DONT_ACCUMULATE_RESULT, 0, &cb);
                if (cb.Found())
                {
                    *puisState = UIS_ENABLED;
                }
                pnsw->Release();
            }
        }
        else
        {
            *puisState = UIS_ENABLED;   // No files selected.  Assume image files exist.
            hr = S_OK;                  // Note we "assume" for the TODO perf reason above.
        }

        ATOMICRELEASE(pdo);
    }

    return hr;
}

HRESULT CFSFolderViewCB::_CanPrintPictures(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    HRESULT hr;

    // TODO:  Use fOkToBeSlow (with a return of E_PENDING) to allow walk to
    // occur on a background task thread (for performance reasons).  However,
    // it doesn't work at present because it's completely specialized for WIA
    // stuff, and it will not be trivial to adapt to the general case.  Thus,
    // we make assumptions as best we can in determining the state for now.

    if (psiItemArray)
    {
        *puisState = UIS_DISABLED;

        IDataObject *pdo;
        hr = psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo));
        if (SUCCEEDED(hr))
        {
            INamespaceWalk *pnsw;
            hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
            if (SUCCEEDED(hr))
            {
                CDataObjectCallback cb(DATAOBJCB_IMAGE | DATAOBJCB_ONLYCHECKEXISTENCE);
                pnsw->Walk(pdo, NSWF_DONT_ACCUMULATE_RESULT, 0, &cb);
                if (cb.Found())
                {
                    *puisState = UIS_ENABLED;
                }
                pnsw->Release();
            }

            pdo->Release();
        }
    }
    else
    {
        *puisState = UIS_ENABLED;   // No files selected.  Assume image files exist.
        hr = S_OK;                  // Note we "assume" for the TODO perf reason above.
    }

    return hr;
}


HRESULT CFSFolderViewCB::_CanBuyPictures(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    *puisState = UIS_DISABLED;

    // If there is a BuyURL in the desktop.ini, then we'll show the buy pictures task.
    WCHAR szIniPath[MAX_PATH];
    if (pThis->_pfsf->_CheckDefaultIni(NULL, szIniPath) && PathFileExistsAndAttributes(szIniPath, NULL))
    {
        WCHAR szURLArguments[MAX_PATH];
        if (GetPrivateProfileString(L".ShellClassInfo", c_BuySamplePictures.szURLKey, L"", szURLArguments, ARRAYSIZE(szURLArguments), szIniPath))
        {
            // Yes - there's something.
            *puisState = UIS_ENABLED;
        }
    }

    return S_OK;
}


HRESULT CFSFolderViewCB::_CanPlayMusic(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    return _CanPlay(pv, psiItemArray, fOkToBeSlow, puisState, DATAOBJCB_MUSIC | DATAOBJCB_VIDEO);
}

HRESULT CFSFolderViewCB::_CanPlayVideos(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    return _CanPlay(pv, psiItemArray, fOkToBeSlow, puisState, DATAOBJCB_VIDEO);
}

HRESULT CFSFolderViewCB::_CanPlay(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState, int fDATAOBJCB)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    *puisState = UIS_DISABLED;

    // TODO:  Use fOkToBeSlow (with a return of E_PENDING) to allow walk to
    // occur on a background task thread (for performance reasons).  However,
    // it doesn't work at present because it's completely specialized for WIA
    // stuff, and it will not be trivial to adapt to the general case.  Thus,
    // we make assumptions as best we can in determining the state for now.

    IDataObject *pdo = NULL;
    HRESULT hr = psiItemArray ? psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo)) : S_OK;
    if (SUCCEEDED(hr))
    {
        RIPMSG(!psiItemArray || pdo, "CFSFolderViewCB::_CanPlay - BindToHandler returned S_OK but NULL pdo");
        RIPMSG(psiItemArray || pThis->_punkSite, "CFSFolderViewCB::_CanPlay - no _punkSite!");

        if (pThis->_fssci.cFiles > 0)
        {
            if (pThis->_fssci.nItems > 0)   // Files selected.  Determine if any playable...
            {
                INamespaceWalk *pnsw;
                hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
                if (SUCCEEDED(hr))
                {
                    CDataObjectCallback cb(fDATAOBJCB | DATAOBJCB_ONLYCHECKEXISTENCE);
                    pnsw->Walk(psiItemArray ? pdo : pThis->_punkSite, NSWF_DONT_ACCUMULATE_RESULT, 4, &cb);
                    if (cb.Found())
                    {
                        *puisState = UIS_ENABLED;
                    }
                    pnsw->Release();
                }
            }
            else
                *puisState = UIS_ENABLED;   // No files selected.  Assume playable files exist.
        }                                   // Note we "assume" for the TODO perf reason above.

        ATOMICRELEASE(pdo);
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnPlayMusic(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    return _OnPlay(pv, psiItemArray, pbc, DATAOBJCB_MUSIC | DATAOBJCB_VIDEO);
}

HRESULT CFSFolderViewCB::_OnPlayVideos(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    return _OnPlay(pv, psiItemArray, pbc, DATAOBJCB_VIDEO);
}

HRESULT CFSFolderViewCB::_OnPlay(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc, int fDATAOBJCB)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    HRESULT hr;

    if (psiItemArray)
    {
        IDataObject *pdo;
        hr = psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo));
        if (SUCCEEDED(hr))
        {
            hr = PlayFromUnk(pdo, pThis->_hwndMain, fDATAOBJCB);
            pdo->Release();
        }
    }
    else
    {
        hr = PlayFromUnk(pThis->_punkSite, pThis->_hwndMain, fDATAOBJCB);
    }

    return hr;
}

HRESULT CFSFolderViewCB::_GetShoppingURL(const SHOP_INFO *pShopInfo, LPTSTR pszURL, DWORD cchURL)
{
    HRESULT hr = URLSubstitution(pShopInfo->szURLPrefix, pszURL, cchURL, URLSUB_CLCID);

    if (SUCCEEDED(hr))
    {
        WCHAR szIniPath[MAX_PATH];

        // If we can't just use the fwlink with no arguments, then assume failure.
         hr = pShopInfo->bUseDefault ? S_OK : E_FAIL;

        if (_pfsf->_CheckDefaultIni(NULL, szIniPath) && PathFileExistsAndAttributes(szIniPath, NULL))
        {
            WCHAR szURLArguments[MAX_PATH];
            if (GetPrivateProfileString(L".ShellClassInfo", pShopInfo->szURLKey, L"", szURLArguments, ARRAYSIZE(szURLArguments), szIniPath))
            {
                StrCatBuff(pszURL, L"&", cchURL);
                StrCatBuff(pszURL, szURLArguments, cchURL);

                // Got some arguments - we're definitely ok.
                hr = S_OK;
            }
        }
    }
    return hr;
}

HRESULT CFSFolderViewCB::_GetShoppingBrowsePidl(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc, const SHOP_INFO *pShopInfo, LPITEMIDLIST *ppidl)
{
    WCHAR wszShoppingURL[MAX_URL_STRING];
    HRESULT hr = _GetShoppingURL(pShopInfo, wszShoppingURL, ARRAYSIZE(wszShoppingURL));
    if (SUCCEEDED(hr))
    {
        IShellFolder *psfDesktop;
        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            hr = IShellFolder_ParseDisplayName(psfDesktop, NULL, NULL, wszShoppingURL, NULL, ppidl, NULL);
            psfDesktop->Release();
        }
    }

    return hr;
}



HRESULT CFSFolderViewCB::_OnShopForMusicOnline(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    LPITEMIDLIST pidl;

    // See if there is a sample music BuyURL
    // (do this check first, because the regular music buy URL should always succeed)
    HRESULT hr = pThis->_GetShoppingBrowsePidl(pv, psiItemArray, pbc, &c_BuySampleMusic, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = pThis->_BrowseObject(pidl, SBSP_NEWBROWSER);
        ILFree(pidl);
    }
    else
    {
        // Nope - look for the regular music buy URL
        hr = pThis->_GetShoppingBrowsePidl(pv, psiItemArray, pbc, &c_BuyMusic, &pidl);
        if (SUCCEEDED(hr))
        {
            hr = pThis->_BrowseObject(pidl, SBSP_NEWBROWSER);           
            ILFree(pidl);
        }
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnShopForPicturesOnline(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    LPITEMIDLIST pidl;
    HRESULT hr = pThis->_GetShoppingBrowsePidl(pv, psiItemArray, pbc, &c_BuySamplePictures, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = pThis->_BrowseObject(pidl, SBSP_NEWBROWSER);
        ILFree(pidl);
    }

    return hr;
}


HRESULT CFSFolderViewCB::_DataObjectFromItemsOrFolder(IShellItemArray *psiItemArray, IDataObject **ppdto)
{
    *ppdto = NULL;

    HRESULT hr;
    if (psiItemArray)
    {
        // Something selected -- work with selected items.
        hr = psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, ppdto));
    }
    else
    {
        // Nothing selected -- imply folder selected.
        hr = SHGetUIObjectOf(_pidl, NULL, IID_PPV_ARG(IDataObject, ppdto));
    }
    return hr;
}

HRESULT CFSFolderViewCB::_CanSendToAudioCD(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    *puisState = UIS_DISABLED;

    IDataObject *pdo;
    HRESULT hr = pThis->_DataObjectFromItemsOrFolder(psiItemArray, &pdo);
    if (SUCCEEDED(hr))
    {
        // todo: use fOkToBeSlow to get off the UI thread -- right now it wont work because
        // its specialized just for the WIA stuff and things that have global state
        ICDBurn *pcdb;
        if (SUCCEEDED(CoCreateInstance(CLSID_CDBurn, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ICDBurn, &pcdb))))
        {
            // media player will get invoked, so we only worry about if the system has a
            // recordable drive at all -- whether the shell burning is enabled or not doesnt matter
            BOOL fHasRecorder;
            if (SUCCEEDED(pcdb->HasRecordableDrive(&fHasRecorder)) && fHasRecorder)
            {
                IUnknown *punk;
                // if this probe works, we can get something thats good to go and itll burn cds.
                if (SUCCEEDED(CDBurn_GetExtensionObject(CDBE_TYPE_MUSIC, pdo, IID_PPV_ARG(IUnknown, &punk))))
                {
                    *puisState = UIS_ENABLED;
                    punk->Release();
                }
            }
            pcdb->Release();
        }

        pdo->Release();
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnSendToAudioCD(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    IDataObject *pdo;
    HRESULT hr = pThis->_DataObjectFromItemsOrFolder(psiItemArray, &pdo);
    if (SUCCEEDED(hr))
    {
        IDropTarget *pdt;
        hr = CDBurn_GetExtensionObject(CDBE_TYPE_MUSIC, pdo, IID_PPV_ARG(IDropTarget, &pdt));
        if (SUCCEEDED(hr))
        {
            hr = SHSimulateDrop(pdt, pdo, 0, NULL, NULL);
            pdt->Release();
        }
        pdo->Release();
    }
    return hr;
}

HRESULT CFSFolderViewCB::_CanSendToCD(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_DISABLED;

    WCHAR szDrive[4];
    if (SUCCEEDED(CDBurn_GetRecorderDriveLetter(szDrive, ARRAYSIZE(szDrive))))
    {
        // if this succeeds, shell cd burning is enabled.
        *puisState = UIS_ENABLED;
    }

    return S_OK;
}

HRESULT CFSFolderViewCB::_OnSendToCD(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    IDataObject *pdo;
    HRESULT hr = pThis->_DataObjectFromItemsOrFolder(psiItemArray, &pdo);
    if (SUCCEEDED(hr))
    {
        WCHAR szDrive[4];
        hr = CDBurn_GetRecorderDriveLetter(szDrive, ARRAYSIZE(szDrive));
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            hr = SHILCreateFromPath(szDrive, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                IDropTarget *pdt;
                hr = SHGetUIObjectOf(pidl, NULL, IID_PPV_ARG(IDropTarget, &pdt));
                if (SUCCEEDED(hr))
                {
                    hr = SHSimulateDropWithSite(pdt, pdo, 0, NULL, NULL, pThis->_punkSite);
                    pdt->Release();
                }
                ILFree(pidl);
            }
        }
        pdo->Release();
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnGetFromCamera(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof(sei);
    sei.lpFile = TEXT("wiaacmgr.exe");
    sei.lpParameters = TEXT("/SelectDevice");
    sei.nShow = SW_SHOWNORMAL;

    return ShellExecuteEx(&sei) ? S_OK : E_FAIL;
}

HRESULT CFSFolderViewCB::_GetPreview3(IPreview3** ppPreview3)
{
    HRESULT hr = E_FAIL;
    *ppPreview3 = NULL;

    if (!_pPreview)
    {
        hr = CoCreateInstance(CLSID_Preview, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPreview3, &_pPreview));
        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(_pPreview, _punkSite);
        }
    }

    if (_pPreview)
    {
        *ppPreview3 = _pPreview;
        _pPreview->AddRef();
        hr = S_OK;
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnSlideShow(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    IPreview3* pPreview3;
    HRESULT hr = pThis->_GetPreview3(&pPreview3);
    if (SUCCEEDED(hr))
    {
        hr = pPreview3->SlideShow();
        pPreview3->Release();
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnWallpaper(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    HRESULT hr = E_FAIL;
    IDataObject *pdo;

    if (psiItemArray && SUCCEEDED(psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo))))
    {
        IPreview3* pPreview3;
        if (SUCCEEDED(pThis->_GetPreview3(&pPreview3)))
        {
            TCHAR szPath[MAX_PATH];
            if (SUCCEEDED(PathFromDataObject(pdo, szPath, ARRAYSIZE(szPath))))
            {
                hr = pPreview3->SetWallpaper(szPath);
            }
            pPreview3->Release();
        }

        pdo->Release();
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnOrderPrints(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    IDataObject *pdo;
    HRESULT hr = pThis->_DataObjectFromItemsOrFolder(psiItemArray, &pdo);
    if (SUCCEEDED(hr))
    {
        hr = SHSimulateDropOnClsid(CLSID_InternetPrintOrdering, pThis->_punkSite, pdo);
        pdo->Release();
    }   

    return hr;
}

HRESULT CFSFolderViewCB::_OnPrintPictures(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    IDataObject *pdo;
    HRESULT hr = pThis->_DataObjectFromItemsOrFolder(psiItemArray, &pdo);
    if (SUCCEEDED(hr))
    {
        hr = SHSimulateDropOnClsid(CLSID_PrintPhotosDropTarget, pThis->_punkSite, pdo);
        pdo->Release();
    }

    return hr;
}

const WVTASKITEM c_CommonDocumentsSpecialTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_COMMONDOCUMENTS, IDS_HEADER_COMMONDOCUMENTS_TT);
const WVTASKITEM c_CommonDocumentsSpecialTaskList[] =
{
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_COMMONDOCUMENTSHELP, IDS_TASK_COMMONDOCUMENTSHELP_TT, IDI_TASK_HELP, NULL, CFSFolderViewCB::_OnCommonDocumentsHelp),
};
const LPCTSTR c_DocumentsOtherPlaces[] = { MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_COMMON_DOCUMENTS), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };

const WVTASKITEM c_MusicSpecialTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_MUSIC, IDS_HEADER_MUSIC_TT);
const WVTASKITEM c_MusicSpecialTaskList[] =
{
    WVTI_ENTRY_ALL_TITLE(UICID_PlayMusic,    L"shell32.dll", IDS_TASK_PLAYALL,          IDS_TASK_PLAYALL,       IDS_TASK_PLAY,          IDS_TASK_PLAY,          IDS_TASK_PLAY_TT,               IDI_TASK_PLAY_MUSIC,    CFSFolderViewCB::_CanPlayMusic,     CFSFolderViewCB::_OnPlayMusic),
    WVTI_ENTRY_ALL(UICID_ShopForMusicOnline, L"shell32.dll", IDS_TASK_SHOPFORMUSICONLINE,                                                                       IDS_TASK_SHOPFORMUSICONLINE_TT, IDI_TASK_BUY_MUSIC,     NULL,                               CFSFolderViewCB::_OnShopForMusicOnline),
    WVTI_ENTRY_ALL_TITLE(GUID_NULL,          L"shell32.dll", IDS_TASK_COPYTOAUDIOCDALL, IDS_TASK_COPYTOAUDIOCD, IDS_TASK_COPYTOAUDIOCD, IDS_TASK_COPYTOAUDIOCD, IDS_TASK_COPYTOAUDIOCD_TT,      IDI_TASK_SENDTOAUDIOCD, CFSFolderViewCB::_CanSendToAudioCD, CFSFolderViewCB::_OnSendToAudioCD),
};
const LPCTSTR c_MusicOtherPlaces[]   = { MAKEINTRESOURCE(CSIDL_MYMUSIC), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };
const LPCTSTR c_MyMusicOtherPlaces[] = { MAKEINTRESOURCE(CSIDL_COMMON_MUSIC), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };

const WVTASKITEM c_PicturesSpecialTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_PICTURES, IDS_HEADER_PICTURES_TT);
const WVTASKITEM c_PicturesSpecialTaskList[] =
{
    WVTI_ENTRY_ALL(UICID_GetFromCamera, L"shell32.dll", IDS_TASK_GETFROMCAMERA,                                                                                             IDS_TASK_GETFROMCAMERA_TT,  IDI_TASK_GETFROMCAMERA, CFSFolderViewCB::_HasWiaDevices,    CFSFolderViewCB::_OnGetFromCamera),
    WVTI_ENTRY_ALL(UICID_SlideShow,     L"shell32.dll", IDS_TASK_SLIDESHOW,                                                                                                 IDS_TASK_SLIDESHOW_TT,      IDI_TASK_SLIDESHOW,     CFSFolderViewCB::_HasItems,         CFSFolderViewCB::_OnSlideShow),
    WVTI_ENTRY_ALL(CLSID_NULL,          L"shell32.dll", IDS_TASK_ORDERPRINTS,                                                                                               IDS_TASK_ORDERPRINTS_TT,    IDI_TASK_ORDERPRINTS,   CFSFolderViewCB::_CanOrderPrints,   CFSFolderViewCB::_OnOrderPrints),
    WVTI_ENTRY_ALL_TITLE(CLSID_NULL,    L"shell32.dll", IDS_TASK_PRINT_PICTURE_FOLDER,  IDS_TASK_PRINT_PICTURE, IDS_TASK_PRINT_PICTURE_FOLDER,  IDS_TASK_PRINT_PICTURES,    IDS_TASK_PRINT_PICTURES_TT, IDI_TASK_PRINTPICTURES, CFSFolderViewCB::_CanPrintPictures, CFSFolderViewCB::_OnPrintPictures),
    WVTI_ENTRY_FILE(UICID_SetAsWallpaper,L"shell32.dll",IDS_TASK_SETASWALLPAPER,                                                                                            IDS_TASK_SETASWALLPAPER_TT, IDI_TASK_SETASWALLPAPER,CFSFolderViewCB::_CanWallpaper,     CFSFolderViewCB::_OnWallpaper),
    WVTI_ENTRY_ALL_TITLE(CLSID_NULL,    L"shell32.dll", IDS_TASK_COPYTOCDALL,           IDS_TASK_COPYTOCD,      IDS_TASK_COPYTOCD,              IDS_TASK_COPYTOCD,          IDS_TASK_COPYTOCD_TT,       IDI_TASK_SENDTOCD,      CFSFolderViewCB::_CanSendToCD,      CFSFolderViewCB::_OnSendToCD),
    // Note: temporarily using IDI_ORDERPRINTS for the following task:
    WVTI_ENTRY_ALL(UICID_ShopForPicturesOnline, L"shell32.dll", IDS_TASK_SHOPFORPICTURESONLINE,                                                                             IDS_TASK_SHOPFORPICTURESONLINE_TT, IDI_TASK_ORDERPRINTS, CFSFolderViewCB::_CanBuyPictures, CFSFolderViewCB::_OnShopForPicturesOnline),
};
const LPCTSTR c_PicturesOtherPlaces[] = { MAKEINTRESOURCE(CSIDL_MYPICTURES), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };
const LPCTSTR c_MyPicturesOtherPlaces[] = { MAKEINTRESOURCE(CSIDL_COMMON_PICTURES), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };

const WVTASKITEM c_VideosSpecialTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_VIDEOS, IDS_HEADER_VIDEOS_TT);
const WVTASKITEM c_VideosSpecialTaskList[] =
{
    WVTI_ENTRY_ALL_TITLE(CLSID_NULL,    L"shell32.dll", IDS_TASK_PLAYALL,               IDS_TASK_PLAYALL,       IDS_TASK_PLAY,                  IDS_TASK_PLAY,              IDS_TASK_PLAY_VIDEOS_TT,    IDI_TASK_PLAY_MUSIC,    CFSFolderViewCB::_CanPlayVideos,    CFSFolderViewCB::_OnPlayVideos),
    WVTI_ENTRY_ALL(UICID_GetFromCamera, L"shell32.dll", IDS_TASK_GETFROMCAMERA,                                                                                             IDS_TASK_GETFROMCAMERA_TT,  IDI_TASK_GETFROMCAMERA, CFSFolderViewCB::_HasWiaDevices,    CFSFolderViewCB::_OnGetFromCamera),
    WVTI_ENTRY_ALL_TITLE(CLSID_NULL,    L"shell32.dll", IDS_TASK_COPYTOCDALL,           IDS_TASK_COPYTOCD,      IDS_TASK_COPYTOCD,              IDS_TASK_COPYTOCD,          IDS_TASK_COPYTOCD_TT,       IDI_TASK_SENDTOCD,      CFSFolderViewCB::_CanSendToCD,      CFSFolderViewCB::_OnSendToCD)
};
const LPCTSTR c_VideosOtherPlaces[] = { MAKEINTRESOURCE(CSIDL_MYVIDEO), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };
const LPCTSTR c_MyVideosOtherPlaces[] = { MAKEINTRESOURCE(CSIDL_COMMON_VIDEO), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };

typedef struct {
    const WVTASKITEM *pwvIntroText;
    const WVTASKITEM *pwvSpecialHeader;
    const WVTASKITEM *pwvSpecialTaskList;
    UINT              cSpecialTaskList;
    const WVTASKITEM *pwvFolderHeader;
    const WVTASKITEM *pwvFolderTaskList;
    UINT              cFolderTaskList;
    const LPCTSTR    *pdwOtherPlacesList;
    UINT              cOtherPlacesList;
    LPCWSTR           pszThemeInfo;
} WVCONTENT_DATA;

#define WVCONTENT_DEFVIEWDEFAULT(op) { NULL, NULL, NULL, 0, NULL, NULL, 0, (op), ARRAYSIZE(op), NULL }
#define WVCONTENT_FOLDER(fh, ft, op) { NULL, NULL, NULL, 0, &(fh), (ft), ARRAYSIZE(ft), (op), ARRAYSIZE(op), NULL }
#define WVCONTENT_SPECIAL(sh, st, op, th) { NULL, &(sh), (st), ARRAYSIZE(st), NULL, NULL, 0, (op), ARRAYSIZE(op), (th) }

const WVCONTENT_DATA c_wvContent[] =
{
    WVCONTENT_DEFVIEWDEFAULT(c_DocumentsOtherPlaces),                                                                                   // FVCBFT_DOCUMENTS
    WVCONTENT_DEFVIEWDEFAULT(c_DocumentsOtherPlaces),                                                                                   // FVCBFT_MYDOCUMENTS
    WVCONTENT_SPECIAL(c_PicturesSpecialTaskHeader,          c_PicturesSpecialTaskList,          c_PicturesOtherPlaces,      L"picture"),// FVCBFT_PICTURES
    WVCONTENT_SPECIAL(c_PicturesSpecialTaskHeader,          c_PicturesSpecialTaskList,          c_MyPicturesOtherPlaces,    L"picture"),// FVCBFT_MYPICTURES
    WVCONTENT_SPECIAL(c_PicturesSpecialTaskHeader,          c_PicturesSpecialTaskList,          c_PicturesOtherPlaces,      L"picture"),// FVCBFT_PHOTOALBUM
    WVCONTENT_SPECIAL(c_MusicSpecialTaskHeader,             c_MusicSpecialTaskList,             c_MusicOtherPlaces,         L"music"),  // FVCBFT_MUSIC
    WVCONTENT_SPECIAL(c_MusicSpecialTaskHeader,             c_MusicSpecialTaskList,             c_MyMusicOtherPlaces,       L"music"),  // FVCBFT_MYMUSIC
    WVCONTENT_SPECIAL(c_MusicSpecialTaskHeader,             c_MusicSpecialTaskList,             c_MusicOtherPlaces,         L"music"),  // FVCBFT_MUSICARTIST
    WVCONTENT_SPECIAL(c_MusicSpecialTaskHeader,             c_MusicSpecialTaskList,             c_MusicOtherPlaces,         L"music"),  // FVCBFT_MUSICALBUM
    WVCONTENT_SPECIAL(c_VideosSpecialTaskHeader,            c_VideosSpecialTaskList,            c_VideosOtherPlaces,        L"video"),  // FVCBFT_VIDEOS
    WVCONTENT_SPECIAL(c_VideosSpecialTaskHeader,            c_VideosSpecialTaskList,            c_MyVideosOtherPlaces,      L"video"),  // FVCBFT_MYVIDEOS
    WVCONTENT_SPECIAL(c_VideosSpecialTaskHeader,            c_VideosSpecialTaskList,            c_VideosOtherPlaces,        L"video"),  // FVCBFT_VIDEOALBUM
    WVCONTENT_DEFVIEWDEFAULT(c_DocumentsOtherPlaces),// stub, it should not be used as legacy htts wont have DUI view.                  // FVCBFT_USELEGACYHTT
    WVCONTENT_SPECIAL(c_CommonDocumentsSpecialTaskHeader,   c_CommonDocumentsSpecialTaskList,   c_DocumentsOtherPlaces,     NULL),      // FVCBFT_COMMONDOCUMENTS
};

// This structure describes what a Folder Type can control:
//
typedef struct {
    BOOL              fIncludeThumbstrip;
    FOLDERVIEWMODE    fvmFew;
    FOLDERVIEWMODE    fvmMid;
    FOLDERVIEWMODE    fvmMany;
    const SHCOLUMNID* pscidSort;
    int               iSortDirection;
} FVCBFOLDERTYPEDATA;

// Here are all the Folder Types we know about:
const FVCBFOLDERTYPEDATA c_rgFolderType[] =
{  // flmstrip  // <25         // 25..49      //50...        //sort by           //sort dir
    { FALSE,    FVM_TILE,      FVM_TILE,      FVM_ICON,      &SCID_NAME,         1},    // FVCBFT_DOCUMENTS
    { FALSE,    FVM_TILE,      FVM_TILE,      FVM_ICON,      &SCID_NAME,         1},    // FVCBFT_MYDOCUMENTS
    { TRUE,     FVM_THUMBNAIL, FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,         1},    // FVCBFT_PICTURES
    { TRUE,     FVM_THUMBNAIL, FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,         1},    // FVCBFT_MYPICTURES
    { TRUE,     FVM_THUMBSTRIP,FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,         1},    // FVCBFT_PHOTOALBUM
    { FALSE,    FVM_TILE,      FVM_TILE,      FVM_DETAILS,   &SCID_NAME,         1},    // FVCBFT_MUSIC
    { FALSE,    FVM_THUMBNAIL, FVM_TILE,      FVM_LIST,      &SCID_NAME,         1},    // FVCBFT_MYMUSIC
    { FALSE,    FVM_THUMBNAIL, FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,        -1},    // FVCBFT_MUSICARTIST
    { FALSE,    FVM_TILE,      FVM_TILE,      FVM_DETAILS,   &SCID_NAME,         1},    // FVCBFT_MUSICALBUM, SCID_MUSIC_Track is the same as SCID_NAME
    { FALSE,    FVM_THUMBNAIL, FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,         1},    // FVCBFT_VIDEOS
    { FALSE,    FVM_THUMBNAIL, FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,         1},    // FVCBFT_MYVIDEOS
    { FALSE,    FVM_THUMBNAIL, FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,         1},    // FVCBFT_VIDEOALBUM
    { FALSE,    FVM_TILE,      FVM_TILE,      FVM_ICON,      &SCID_NAME,         1},    // FVCBFT_USELEGACYHTT, only for listview state to look like FVCBFT_DOCUMENTS
    { FALSE,    FVM_TILE,      FVM_TILE,      FVM_ICON,      &SCID_NAME,         1},    // FVCBFT_COMMONDOCUMENTS
};

// This is used to sniff the Folder Type based on folder location:
typedef struct {
    UINT           csidl;
    FVCBFOLDERTYPE ft;
    DWORD          dwFlags;
} FVCBDATA;

#define FVCBDF_SUBFOLDERS_ONLY    1
#define FVCBDF_THISFOLDER_ONLY    2

const FVCBDATA c_rgFolderState[] =
{
    {CSIDL_COMMON_PICTURES, FVCBFT_PHOTOALBUM,      FVCBDF_SUBFOLDERS_ONLY},
    {CSIDL_MYPICTURES,      FVCBFT_PHOTOALBUM,      FVCBDF_SUBFOLDERS_ONLY},
    {CSIDL_COMMON_PICTURES, FVCBFT_PICTURES,        FVCBDF_THISFOLDER_ONLY},
    {CSIDL_MYPICTURES,      FVCBFT_MYPICTURES,      FVCBDF_THISFOLDER_ONLY},
    {CSIDL_COMMON_MUSIC,    FVCBFT_MUSIC,           FVCBDF_THISFOLDER_ONLY},
    {CSIDL_MYMUSIC,         FVCBFT_MYMUSIC,         FVCBDF_THISFOLDER_ONLY},
    {CSIDL_MYMUSIC,         FVCBFT_MUSICARTIST,     FVCBDF_SUBFOLDERS_ONLY},
    {CSIDL_COMMON_VIDEO,    FVCBFT_VIDEOS,          0},
    {CSIDL_MYVIDEO,         FVCBFT_MYVIDEOS,        0},
    {CSIDL_COMMON_DOCUMENTS,FVCBFT_COMMONDOCUMENTS, FVCBDF_THISFOLDER_ONLY},
    {CSIDL_PERSONAL,        FVCBFT_MYDOCUMENTS,     FVCBDF_THISFOLDER_ONLY},
};

// these are special folders that used to be web view folders.  we override the "support legacy" for this list:
const UINT c_rgFolderStateNoLegacy[] =
{
    CSIDL_WINDOWS,
    CSIDL_SYSTEM,
    CSIDL_PROGRAM_FILES,
};

// This is used to map desktop.ini's folder type into our Folder Type
const struct {
    LPCWSTR pszType;
    FVCBFOLDERTYPE ft;
} c_rgPropBagFolderType[] =
{
    {STR_TYPE_DOCUMENTS,        FVCBFT_DOCUMENTS},
    {STR_TYPE_MYDOCUMENTS,      FVCBFT_MYDOCUMENTS},
    {STR_TYPE_PICTURES,         FVCBFT_PICTURES},
    {STR_TYPE_MYPICTURES,       FVCBFT_MYPICTURES},
    {STR_TYPE_PHOTOALBUM,       FVCBFT_PHOTOALBUM},
    {STR_TYPE_MUSIC,            FVCBFT_MUSIC},
    {STR_TYPE_MYMUSIC,          FVCBFT_MYMUSIC},
    {STR_TYPE_MUSICARTIST,      FVCBFT_MUSICARTIST},
    {STR_TYPE_MUSICALBUM,       FVCBFT_MUSICALBUM},
    {STR_TYPE_VIDEOS,           FVCBFT_VIDEOS},
    {STR_TYPE_MYVIDEOS,         FVCBFT_MYVIDEOS},
    {STR_TYPE_VIDEOALBUM,       FVCBFT_VIDEOALBUM},
    {STR_TYPE_USELEGACYHTT,     FVCBFT_USELEGACYHTT},
    {STR_TYPE_COMMONDOCUMENTS,  FVCBFT_COMMONDOCUMENTS},
};

const struct 
{
    PERCEIVED gen;
    FVCBFOLDERTYPE ft;
} 
c_rgSniffType[] =
{
    {GEN_AUDIO,    FVCBFT_MUSIC},
    {GEN_IMAGE,    FVCBFT_PHOTOALBUM},
    {GEN_VIDEO,    FVCBFT_VIDEOS},
};

HRESULT _GetFolderTypeForString(LPCWSTR pszFolderType, FVCBFOLDERTYPE *piType)
{
    HRESULT hr = E_FAIL;
    for (int i = 0; i < ARRAYSIZE(c_rgPropBagFolderType); i++)
    {
        if (!StrCmpI(c_rgPropBagFolderType[i].pszType, pszFolderType))
        {
            *piType = c_rgPropBagFolderType[i].ft;
            hr = S_OK;
            break;
        }
    }
    return hr;
}

HRESULT CFSFolderViewCB::_GetStringForFolderType(int iType, LPWSTR pszFolderType, UINT cchBuf)
{
    HRESULT hr = E_FAIL;
    for (int i = 0; i < ARRAYSIZE(c_rgPropBagFolderType); i++)
    {
        if (c_rgPropBagFolderType[i].ft == iType)
        {
            StrCpyN(pszFolderType, c_rgPropBagFolderType[i].pszType, cchBuf);
            hr = S_OK;
            break;
        }
    }
    return hr;
}

extern HRESULT GetTemplateInfoFromHandle(HANDLE h, UCHAR * pKey, DWORD *pdwSize);

FVCBFOLDERTYPE _GetFolderType(LPCWSTR pszPath, LPCITEMIDLIST pidl, BOOL fIsSystemFolder)
{
    // Assume we don't find a match
    FVCBFOLDERTYPE nFolderType = FVCBFT_NOTSPECIFIED;
    WCHAR szFolderType[MAX_PATH];
    szFolderType[0] = 0;

    // peruser is first
    if (FVCBFT_NOTSPECIFIED == nFolderType)
    {
        IPropertyBag *ppb;
        if (SUCCEEDED(SHGetViewStatePropertyBag(pidl, VS_BAGSTR_EXPLORER, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
        {
            SHPropertyBag_ReadStr(ppb, L"FolderType", szFolderType, ARRAYSIZE(szFolderType));
            if (szFolderType[0])
                _GetFolderTypeForString(szFolderType, &nFolderType);

            ppb->Release();
        }
    }
    
    // next, alluser
    if ((FVCBFT_NOTSPECIFIED == nFolderType) && fIsSystemFolder)
    {
        GetFolderString(pszPath, NULL, szFolderType, ARRAYSIZE(szFolderType), TEXT("FolderType"));
        if (szFolderType[0])
        {
            _GetFolderTypeForString(szFolderType, &nFolderType);
        }
    }

    // Check the location of this folder is next
    //
    if (FVCBFT_NOTSPECIFIED == nFolderType)
    {
        for (int i = 0; i < ARRAYSIZE(c_rgFolderState); i++)
        {
            if (FVCBDF_THISFOLDER_ONLY & c_rgFolderState[i].dwFlags)
            {
                if (PathIsOneOf(pszPath, &(c_rgFolderState[i].csidl), 1))
                {
                    nFolderType = c_rgFolderState[i].ft;
                    break;
                }
            }
            else if (FVCBDF_SUBFOLDERS_ONLY & c_rgFolderState[i].dwFlags)
            {
                if (PathIsDirectChildOf(MAKEINTRESOURCE(c_rgFolderState[i].csidl), pszPath))
                {
                    nFolderType = c_rgFolderState[i].ft;
                    break;
                }
            }
            else if (PathIsEqualOrSubFolder(MAKEINTRESOURCE(c_rgFolderState[i].csidl), pszPath))
            {
                nFolderType = c_rgFolderState[i].ft;
                break;
            }
        }
    }

    // Upgrade old webviews to their DUI equivalents, if we can
    if (FVCBFT_NOTSPECIFIED == nFolderType && fIsSystemFolder  && SHRestricted(REST_ALLOWLEGACYWEBVIEW))
    {
        // Don't check for legacy webview on our special folders
        if (!PathIsOneOf(pszPath, c_rgFolderStateNoLegacy, ARRAYSIZE(c_rgFolderStateNoLegacy)))
        {        
            SFVM_WEBVIEW_TEMPLATE_DATA wvData;
            if (SUCCEEDED(DefaultGetWebViewTemplateFromPath(pszPath, &wvData)))
            {
                if (StrStrI(wvData.szWebView, L"ImgView.htt"))
                {
                    nFolderType = FVCBFT_PHOTOALBUM;
                }
                else if (StrStrI(wvData.szWebView, L"classic.htt")  ||
                         StrStrI(wvData.szWebView, L"default.htt")  ||
                         StrStrI(wvData.szWebView, L"standard.htt"))
                {
                    // map all of these to "documents", since DUI should take care
                    // of what the old templates did automatically
                    nFolderType = FVCBFT_DOCUMENTS;
                }
                else if (StrStrI(wvData.szWebView, L"folder.htt"))
                {
                    LPTSTR pszFilePrefix = StrStrI(wvData.szWebView, L"file://");
                    HANDLE hfile = CreateFileWrapW(
                        pszFilePrefix && (&pszFilePrefix[6] < &wvData.szWebView[MAX_PATH - 1]) ? &pszFilePrefix[7] : wvData.szWebView,
                        GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
                    if (INVALID_HANDLE_VALUE != hfile)
                    {
                        DWORD dwSize;
                        UCHAR pKey[MD5DIGESTLEN];
                        if (SUCCEEDED(GetTemplateInfoFromHandle(hfile, pKey, &dwSize)))
                        {
                            static const struct {
                                UCHAR pKey[MD5DIGESTLEN];
                                FVCBFOLDERTYPE nFolderType;
                            } c_paLegacyKeyMap[] = {
                                { { 0xf6, 0xad, 0x42, 0xbd, 0xfa, 0x92, 0xb6, 0x61, 0x08, 0x13, 0xd3, 0x71, 0x32, 0x18, 0x85, 0xc7 }, FVCBFT_DOCUMENTS },  // Win98 Gold Program Files
                                { { 0x80, 0xea, 0xcb, 0xc7, 0x85, 0x1e, 0xbb, 0x99, 0x12, 0x7b, 0x9d, 0xc7, 0x80, 0xa6, 0x55, 0x2f }, FVCBFT_DOCUMENTS },  // Win98 Gold System
                              //{ { 0x80, 0xea, 0xcb, 0xc7, 0x85, 0x1e, 0xbb, 0x99, 0x12, 0x7b, 0x9d, 0xc7, 0x80, 0xa6, 0x55, 0x2f }, FVCBFT_DOCUMENTS },  // Win98 Gold Windows
                                { { 0x13, 0x0b, 0xe7, 0xaa, 0x42, 0x6f, 0x9c, 0x2e, 0xab, 0x6b, 0x90, 0x77, 0xce, 0x2d, 0xd1, 0x04 }, FVCBFT_DOCUMENTS },  // Win98 Gold - folder.htt
                              //{ { 0xf6, 0xad, 0x42, 0xbd, 0xfa, 0x92, 0xb6, 0x61, 0x08, 0x13, 0xd3, 0x71, 0x32, 0x18, 0x85, 0xc7 }, FVCBFT_DOCUMENTS },  // Win98 SE Program Files
                                { { 0xc4, 0xab, 0x8f, 0x60, 0xf8, 0xfc, 0x5d, 0x07, 0x9e, 0x16, 0xd8, 0xea, 0x12, 0x2c, 0xad, 0x5c }, FVCBFT_DOCUMENTS },  // Win98 SE System
                              //{ { 0xc4, 0xab, 0x8f, 0x60, 0xf8, 0xfc, 0x5d, 0x07, 0x9e, 0x16, 0xd8, 0xea, 0x12, 0x2c, 0xad, 0x5c }, FVCBFT_DOCUMENTS },  // Win98 SE Windows
                              //{ { 0x13, 0x0b, 0xe7, 0xaa, 0x42, 0x6f, 0x9c, 0x2e, 0xab, 0x6b, 0x90, 0x77, 0xce, 0x2d, 0xd1, 0x04 }, FVCBFT_DOCUMENTS },  // Win98 SE - folder.htt
                                { { 0xef, 0xd0, 0x3e, 0x9e, 0xd8, 0x5e, 0xf3, 0xc5, 0x7e, 0x40, 0xbd, 0x8e, 0x52, 0xbc, 0x9c, 0x67 }, FVCBFT_DOCUMENTS },  // WinME Program Files
                                { { 0x49, 0xdb, 0x25, 0x79, 0x7a, 0x5c, 0xb2, 0x8a, 0xe2, 0x57, 0x59, 0xde, 0x2b, 0xd2, 0xa6, 0x70 }, FVCBFT_DOCUMENTS },  // WinME System
                              //{ { 0x49, 0xdb, 0x25, 0x79, 0x7a, 0x5c, 0xb2, 0x8a, 0xe2, 0x57, 0x59, 0xde, 0x2b, 0xd2, 0xa6, 0x70 }, FVCBFT_DOCUMENTS },  // WinME Windows
                                { { 0x2b, 0xcd, 0xc3, 0x11, 0x72, 0x28, 0x34, 0x46, 0xfa, 0x88, 0x31, 0x34, 0xfc, 0xee, 0x7a, 0x3b }, FVCBFT_DOCUMENTS },  // WinME - classic.htt
                                { { 0x68, 0x20, 0xa0, 0xa1, 0x6c, 0xba, 0xbf, 0x67, 0x80, 0xfe, 0x1e, 0x70, 0xdf, 0xcb, 0xd6, 0x34 }, FVCBFT_DOCUMENTS },  // WinME - folder.htt
                                { { 0x5e, 0x18, 0xaf, 0x48, 0xb1, 0x9f, 0xb8, 0x12, 0x58, 0x64, 0x4a, 0xa2, 0xf5, 0x12, 0x0f, 0x01 }, FVCBFT_PHOTOALBUM }, // WinME - imgview.htt
                                { { 0x33, 0x94, 0x21, 0x3b, 0x17, 0x31, 0x2b, 0xeb, 0xac, 0x93, 0x84, 0x13, 0xb8, 0x1f, 0x95, 0x24 }, FVCBFT_DOCUMENTS },  // WinME - standard.htt
                                { { 0x47, 0x03, 0x19, 0xf8, 0x0c, 0x20, 0xc4, 0x4f, 0x10, 0xfd, 0x63, 0xf1, 0x2d, 0x2d, 0x0a, 0xcb }, FVCBFT_DOCUMENTS },  // WinME - starter.htt
                                { { 0x60, 0x7d, 0xea, 0xa5, 0xaf, 0x5e, 0xbb, 0x9b, 0x10, 0x18, 0xf9, 0x59, 0x9e, 0x43, 0x89, 0x62 }, FVCBFT_DOCUMENTS },  // Win2k Program Files
                                { { 0x1c, 0xa6, 0x22, 0xd4, 0x4a, 0x31, 0x57, 0x93, 0xa7, 0x26, 0x68, 0x3c, 0x87, 0x95, 0x8c, 0xce }, FVCBFT_DOCUMENTS },  // Win2k System32
                              //{ { 0x1c, 0xa6, 0x22, 0xd4, 0x4a, 0x31, 0x57, 0x93, 0xa7, 0x26, 0x68, 0x3c, 0x87, 0x95, 0x8c, 0xce }, FVCBFT_DOCUMENTS },  // Win2k Windows (WinNT)
                                { { 0x03, 0x43, 0x48, 0xed, 0xe4, 0x9f, 0xd6, 0xc0, 0x58, 0xf7, 0x72, 0x3f, 0x1b, 0xd0, 0xa7, 0x10 }, FVCBFT_DOCUMENTS },  // Win2k - classic.htt
                                { { 0xa8, 0x84, 0xf9, 0x37, 0x84, 0x10, 0xde, 0x7c, 0x0b, 0x34, 0x90, 0x37, 0x23, 0x9e, 0x54, 0x35 }, FVCBFT_DOCUMENTS },  // Win2k - folder.htt
                                { { 0x75, 0x1f, 0xcf, 0xca, 0xdd, 0xc7, 0x1d, 0xc7, 0xe1, 0xaf, 0x0c, 0x3e, 0x1e, 0xae, 0x18, 0x51 }, FVCBFT_PHOTOALBUM }, // Win2k - imgview.htt
                                { { 0xcc, 0x3f, 0x15, 0xce, 0x4b, 0xfa, 0x36, 0xdf, 0x9b, 0xd8, 0x24, 0x82, 0x3a, 0x9c, 0x0b, 0xa7 }, FVCBFT_DOCUMENTS },  // Win2k - standard.htt
                                { { 0x6c, 0xd1, 0xbf, 0xcf, 0xf9, 0x24, 0x24, 0x24, 0x22, 0xfa, 0x1a, 0x8d, 0xd2, 0x1a, 0x41, 0x73 }, FVCBFT_DOCUMENTS },  // Win2k - starter.htt
                            };
                            static const size_t c_nLegacyKeys = ARRAYSIZE(c_paLegacyKeyMap);

                            for (size_t i = 0; i < c_nLegacyKeys; i++)
                            {
                                if (0 == memcmp(pKey, c_paLegacyKeyMap[i].pKey, sizeof(UCHAR) * MD5DIGESTLEN))
                                {
                                    // It's a known legacy folder.htt.
                                    nFolderType = c_paLegacyKeyMap[i].nFolderType;
                                    break;
                                }
                            }
                        }

                        CloseHandle(hfile);
                    }

                    // If we can't say it's a known legacy folder.htt...
                    if (FVCBFT_NOTSPECIFIED == nFolderType)
                    {
                        // ...don't map it to a DUI folder type (preserve customizations).
                        nFolderType = FVCBFT_USELEGACYHTT;
                    }
                }
                else
                {
                    nFolderType = FVCBFT_USELEGACYHTT;
                }
            }
        }
    }

    return nFolderType;
}

BOOL CFSFolderViewCB::_IsBarricadedFolder()
{
    BOOL bResult = FALSE;
    TCHAR szPath[MAX_PATH];

    if (SUCCEEDED(_pfsf->_GetPath(szPath)))
    {
        const UINT uiFolders[] = {CSIDL_PROGRAM_FILES, CSIDL_WINDOWS, CSIDL_SYSTEM};
        if (PathIsOneOf(szPath, uiFolders, ARRAYSIZE(uiFolders)))
            bResult = TRUE;
        else
        {
            TCHAR szSystemDrive[4];
            ExpandEnvironmentStrings(TEXT("%SystemDrive%\\"), szSystemDrive, ARRAYSIZE(szSystemDrive));
            if (!lstrcmpi(szPath, szSystemDrive))
                bResult = TRUE;
        }
    }

    return bResult;
}

static const struct { FVCBFOLDERTYPE type; PCWSTR pszClass; PERCEIVED gen;} c_rgDirectoryClasses[] = 
{
    {FVCBFT_PICTURES,    L"Directory.Image",    GEN_IMAGE},
    {FVCBFT_MYPICTURES,  L"Directory.Image",    GEN_IMAGE},
    {FVCBFT_PHOTOALBUM,  L"Directory.Image",    GEN_IMAGE},
    {FVCBFT_MUSIC,       L"Directory.Audio",    GEN_AUDIO},
    {FVCBFT_MYMUSIC,     L"Directory.Audio",    GEN_AUDIO},
    {FVCBFT_MUSICARTIST, L"Directory.Audio",    GEN_AUDIO},
    {FVCBFT_MUSICALBUM,  L"Directory.Audio",    GEN_AUDIO},
    {FVCBFT_VIDEOS,      L"Directory.Video",    GEN_VIDEO},
    {FVCBFT_MYVIDEOS,    L"Directory.Video",    GEN_VIDEO},
    {FVCBFT_VIDEOALBUM,  L"Directory.Video",    GEN_VIDEO},
};

LPCWSTR _GetDirectoryClass(LPCWSTR pszPath, LPCITEMIDLIST pidl, BOOL fIsSystemFolder)
{
    FVCBFOLDERTYPE type = _GetFolderType(pszPath, pidl, fIsSystemFolder);
    if (type != FVCBFT_NOTSPECIFIED)
    {
        for (int i = 0; i < ARRAYSIZE(c_rgDirectoryClasses); i++)
        {
            if (c_rgDirectoryClasses[i].type == type)
                return c_rgDirectoryClasses[i].pszClass;
        }
    }
    return NULL;
}

PERCEIVED CFSFolderViewCB::_GetFolderPerceivedType(LPCIDFOLDER pidf)
{
    PERCEIVED gen = GEN_FOLDER;
    WCHAR szPath[MAX_PATH];
    if (SUCCEEDED(_pfsf->_GetPathForItem(pidf, szPath)))
    {
        LPITEMIDLIST pidl = ILCombine(_pfsf->_GetIDList(), (LPCITEMIDLIST)pidf);
        if (pidl)
        {
            FVCBFOLDERTYPE type = _GetFolderType(szPath, pidl, CFSFolder::_IsSystemFolder(pidf));
            if (type != -1)
            {
                for (int i = 0; i < ARRAYSIZE(c_rgDirectoryClasses); i++)
                {
                    if (c_rgDirectoryClasses[i].type == type)
                    {
                        gen = c_rgDirectoryClasses[i].gen;
                        break;
                    }
                }
            }
            ILFree(pidl);
        }
    }
    return gen;
}


HRESULT CFSFolderViewCB::OnEnumeratedItems(DWORD pv, UINT celt, LPCITEMIDLIST* rgpidl)
{
    // Remember the count of items
    _cItems = celt;

    FVCBFOLDERTYPE nFolderType = FVCBFT_NOTSPECIFIED;
    WCHAR szHere[MAX_PATH];
    if (SUCCEEDED(_pfsf->_GetPath(szHere)))
    {
        nFolderType = _GetFolderType(szHere, _pfsf->_GetIDList(), _pfsf->_CheckDefaultIni(NULL, NULL));
    }

    if (FVCBFT_NOTSPECIFIED == nFolderType)
    {
        if (_IsBarricadedFolder())
        {
            nFolderType = FVCBFT_DOCUMENTS;
        }
    }

    // Our location didn't do the trick, so look at the enumerated contents
    if (FVCBFT_NOTSPECIFIED == nFolderType && celt > 0)
    {
        DWORD dwExtCount[ARRAYSIZE(c_rgSniffType)] = {0};

        // look at each pidl -> what type is it
        //
        // But don't look at too many pidls or we really slow down folder
        // creation time.  If we can't figure it out in the first 100, give up.
        //
        DWORD dwTotalCount = 0;
        for (UINT n = 0; n < celt && dwTotalCount < 100; n++)
        {
            LPCIDFOLDER pidf = CFSFolder_IsValidID(rgpidl[n]);
            ASSERT(pidf);
            CFileSysItemString fsi(pidf);
            PERCEIVED gen = fsi.PerceivedType();

            if (gen == GEN_FOLDER)
            {
                gen = _GetFolderPerceivedType(pidf);
            }
                
            for (int i = 0; i < ARRAYSIZE(c_rgSniffType); i++)
            {
                if (c_rgSniffType[i].gen == gen)
                {
                    dwExtCount[i]++;
                    break;
                }
            }

            if (gen != GEN_FOLDER)
                dwTotalCount++;
        }

        // if we found files we determine the overall folder type
        if (dwTotalCount > 0)
        {
            DWORD dwSixtyPercent = MulDiv(dwTotalCount, 3, 5);
            for (int i = 0; i < ARRAYSIZE(c_rgSniffType); i++)
            {
                if (dwExtCount[i] >= dwSixtyPercent)
                {
                    nFolderType = c_rgSniffType[i].ft;
                    break;
                }
            }
        }
    }

    // if at this point we've already decided on a folder type, then it either came from sniffing
    // or the folder location and we can safely persist that out.
    // if celt != 0 then we've sniffed it and we dont want to sniff again, so persist that out.
    // otherwise we're in a random folder with 0 elements and we'll sniff it next time.
    BOOL fCommit = (FVCBFT_NOTSPECIFIED != nFolderType) || (celt != 0);

    // Last resort, assume we're a document folder:
    if (FVCBFT_NOTSPECIFIED == nFolderType)
    {
        nFolderType = FVCBFT_DOCUMENTS;
    }

    // store what we found out back into the bag.
    IPropertyBag *ppb;
    if (fCommit && SUCCEEDED(SHGetViewStatePropertyBag(_pfsf->_GetIDList(), VS_BAGSTR_EXPLORER, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        WCHAR szFolderType[MAX_PATH];
        if (SUCCEEDED(_GetStringForFolderType(nFolderType, szFolderType, ARRAYSIZE(szFolderType))))
        {
            SHPropertyBag_WriteStr(ppb, PROPSTR_FOLDERTYPE, szFolderType);
        }
        ppb->Release();
    }

    _pfsf->_nFolderType = nFolderType;

    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetViewData(DWORD pv, UINT uViewMode, SFVM_VIEW_DATA* pvi)
{
    // Normally whatever defview wants is good for us
    pvi->dwOptions = SFVMQVI_NORMAL;

    // If our sniff type likes THUMBSTRIP, then override defview
    //
    if (FVM_THUMBSTRIP == uViewMode)
    {
        if (c_rgFolderType[_pfsf->_nFolderType].fIncludeThumbstrip)
        {
            pvi->dwOptions = SFVMQVI_INCLUDE;
        }
    }

    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    HRESULT hr = E_FAIL;

    if (FVCBFT_USELEGACYHTT == _pfsf->_nFolderType)
    {
        TCHAR szHere[MAX_PATH];
        if (SUCCEEDED(_pfsf->_GetPath(szHere)) && _pfsf->_CheckDefaultIni(NULL, NULL))
        {
            hr = DefaultGetWebViewTemplateFromPath(szHere, pvit);
        }
    }
    return hr;
}

// Note: defview provides this implementation, this is only for testing
// so the WIA guys can override defview's behavior (and as a way for us
// to force DUI in the presence of HTML content)
//
HRESULT CFSFolderViewCB::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    HRESULT hr = E_FAIL;

    if (FVCBFT_USELEGACYHTT != _pfsf->_nFolderType)
    {
        ZeroMemory(pData, sizeof(*pData));

        pData->dwLayout = SFVMWVL_NORMAL | SFVMWVL_FILES;

        if (FVM_THUMBSTRIP == uViewMode)
        {        
            pData->dwLayout = SFVMWVL_PREVIEW | SFVMWVL_FILES;
            // duiview will do a release on this pointer when the control is destroyed
            _GetPreview3((IPreview3 **)&pData->punkPreview);
        }

        // RAID 242382
        //  If we have an image folder, we want to unconditionally hide DefView's
        //  default "Print this file" folder task since we will supply a context
        //  appropriate "Print pictures" special task.
        //
        // RAID 359567
        //  If we have a music folder, we want to unconditionally hide DefView's
        //  default "Publish this file" folder task.  Not sure the rationale
        //  behind this, but perhaps they don't want us to be seen as a Napster.
        //
        // Note:
        //  This is a HACK added for Whistler, which should be removed in Blackcomb.
        //
        switch (_pfsf->_nFolderType)
        {
        case FVCBFT_PICTURES:
        case FVCBFT_MYPICTURES:
        case FVCBFT_PHOTOALBUM:
        case FVCBFT_VIDEOS:
        case FVCBFT_MYVIDEOS:
        case FVCBFT_VIDEOALBUM:
            pData->dwLayout |= SFVMWVL_NOPRINT;
            break;

        case FVCBFT_MUSIC:
        case FVCBFT_MYMUSIC:
        case FVCBFT_MUSICARTIST:
        case FVCBFT_MUSICALBUM:
            pData->dwLayout |= SFVMWVL_NOPUBLISH;
            break;
        }

        hr = S_OK;
    }

    return hr;
}


HRESULT CFSFolderViewCB::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    // Check if the folder we are currently over is one of the blockaded folders.
    if (_IsBarricadedFolder())
    {
        pData->dwFlags = SFVMWVF_BARRICADE;
    }

    if (c_wvContent[_pfsf->_nFolderType].pwvIntroText)
        Create_IUIElement(c_wvContent[_pfsf->_nFolderType].pwvIntroText, &(pData->pIntroText));

    if (c_wvContent[_pfsf->_nFolderType].pwvSpecialHeader && c_wvContent[_pfsf->_nFolderType].pwvSpecialTaskList)
        Create_IUIElement(c_wvContent[_pfsf->_nFolderType].pwvSpecialHeader, &(pData->pSpecialTaskHeader));

    if (c_wvContent[_pfsf->_nFolderType].pwvFolderHeader && c_wvContent[_pfsf->_nFolderType].pwvFolderTaskList)
        Create_IUIElement(c_wvContent[_pfsf->_nFolderType].pwvFolderHeader, &(pData->pFolderTaskHeader));

    if (c_wvContent[_pfsf->_nFolderType].pdwOtherPlacesList)
        CreateIEnumIDListOnCSIDLs(_pfsf->_pidl, (LPCTSTR *)c_wvContent[_pfsf->_nFolderType].pdwOtherPlacesList, c_wvContent[_pfsf->_nFolderType].cOtherPlacesList, &(pData->penumOtherPlaces));

    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    if (c_wvContent[_pfsf->_nFolderType].pwvSpecialHeader && c_wvContent[_pfsf->_nFolderType].pwvSpecialTaskList)
    {
        Create_IEnumUICommand((IUnknown*)(void*)this, c_wvContent[_pfsf->_nFolderType].pwvSpecialTaskList, c_wvContent[_pfsf->_nFolderType].cSpecialTaskList, &pTasks->penumSpecialTasks);
    }

    if (c_wvContent[_pfsf->_nFolderType].pwvFolderHeader && c_wvContent[_pfsf->_nFolderType].pwvFolderTaskList)
    {
        Create_IEnumUICommand((IUnknown*)(void*)this, c_wvContent[_pfsf->_nFolderType].pwvFolderTaskList, c_wvContent[_pfsf->_nFolderType].cFolderTaskList, &pTasks->penumFolderTasks);
    }

    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetWebViewTheme(DWORD pv, SFVM_WEBVIEW_THEME_DATA* pTheme)
{
    ZeroMemory(pTheme, sizeof(*pTheme));

    pTheme->pszThemeID = c_wvContent[_pfsf->_nFolderType].pszThemeInfo;
    
    return S_OK;
}

HRESULT CFSFolderViewCB::OnDefViewMode(DWORD pv, FOLDERVIEWMODE* pfvm)
{
    HRESULT hr = E_FAIL;

    IPropertyBag* pPB;
    if (SUCCEEDED(SHGetViewStatePropertyBag(_pfsf->_GetIDList(), VS_BAGSTR_EXPLORER, SHGVSPB_FOLDER, IID_PPV_ARG(IPropertyBag, &pPB))))
    {
        SHELLVIEWID vidDefault;
        if (SUCCEEDED(SHPropertyBag_ReadGUID(pPB, L"ExtShellFolderViews\\Default", &vidDefault)))
        {
            hr = ViewModeFromSVID(&vidDefault, pfvm);
        }
        pPB->Release();
    }

    if (FAILED(hr))
    {
        if (_cItems < DEFVIEW_FVM_FEW_CUTOFF)
            *pfvm = c_rgFolderType[_pfsf->_nFolderType].fvmFew;
        else if (_cItems < DEFVIEW_FVM_MANY_CUTOFF)
            *pfvm = c_rgFolderType[_pfsf->_nFolderType].fvmMid;
        else
            *pfvm = c_rgFolderType[_pfsf->_nFolderType].fvmMany;
        hr = S_OK;
    }

    return hr;
}

HRESULT CFSFolderViewCB::OnGetDeferredViewSettings(DWORD pv, SFVM_DEFERRED_VIEW_SETTINGS* pSettings)
{
    HRESULT hr = OnDefViewMode(pv, &pSettings->fvm);
    if (SUCCEEDED(hr))
    {
        pSettings->fGroupView     = (_cItems >= 100) && !IsEqualSCID(SCID_NAME, *c_rgFolderType[_pfsf->_nFolderType].pscidSort);
        pSettings->iSortDirection = c_rgFolderType[_pfsf->_nFolderType].iSortDirection;

        if (pSettings->fvm == FVM_THUMBNAIL || pSettings->fvm == FVM_THUMBSTRIP || pSettings->fvm == FVM_TILE)
            pSettings->fFlags = FWF_AUTOARRANGE;

        if (FAILED(_pfsf->_MapSCIDToColumn(c_rgFolderType[_pfsf->_nFolderType].pscidSort, &pSettings->uSortCol)))
            pSettings->uSortCol = 0;
    }

    return hr;
}


HRESULT CFSFolderViewCB::OnGetCustomViewInfo(DWORD pv, SFVM_CUSTOMVIEWINFO_DATA* pData)
{
    HRESULT hr = E_FAIL;

    TCHAR szIniFile[MAX_PATH];
    if (_pfsf->_CheckDefaultIni(NULL, szIniFile))
    {
        if (PathFileExistsAndAttributes(szIniFile, NULL))
        {
            // Read the custom colors
            //
            const LPCTSTR c_szCustomColors[CRID_COLORCOUNT] =
            {
                TEXT("IconArea_TextBackground"),
                TEXT("IconArea_Text")
            };
            for (int i = 0; i < CRID_COLORCOUNT; i++)
                pData->crCustomColors[i] = GetPrivateProfileInt(TEXT("{BE098140-A513-11D0-A3A4-00C04FD706EC}"),
                                               c_szCustomColors[i], CLR_MYINVALID, szIniFile);

            // Read the background image
            TCHAR szTemp[MAX_PATH];
            GetPrivateProfileString(TEXT("{BE098140-A513-11D0-A3A4-00C04FD706EC}"),  // VID_FolderState
                TEXT("IconArea_Image"), TEXT(""), szTemp, ARRAYSIZE(szTemp), szIniFile);
            if (szTemp[0])
            {
                SHExpandEnvironmentStrings(szTemp, pData->szIconAreaImage, ARRAYSIZE(pData->szIconAreaImage));   // Expand the env vars if any

                TCHAR szHere[MAX_PATH];
                if (SUCCEEDED(_pfsf->_GetPath(szHere)))
                {
                    PathCombine(pData->szIconAreaImage, szHere, pData->szIconAreaImage);
                }
            }

            // Success if we have any real data
            hr = (*(pData->szIconAreaImage) ||
                  pData->crCustomColors[0]!=CLR_MYINVALID ||
                  pData->crCustomColors[1]!=CLR_MYINVALID)
                 ? S_OK : E_FAIL;
        }
    }

    return hr;
}


const CLSID *c_rgFilePages[] = {
    &CLSID_FileTypes,
    &CLSID_OfflineFilesOptions
};

// add optional pages to Explore/Options.

HRESULT SFVCB_OnAddPropertyPages(DWORD pv, SFVM_PROPPAGE_DATA *ppagedata)
{
    for (int i = 0; i < ARRAYSIZE(c_rgFilePages); i++)
    {
        IShellPropSheetExt * pspse;

        HRESULT hr = SHCoCreateInstance(NULL, c_rgFilePages[i], NULL, IID_PPV_ARG(IShellPropSheetExt, &pspse));
        if (SUCCEEDED(hr))
        {
            pspse->AddPages(ppagedata->pfn, ppagedata->lParam);
            pspse->Release();
        }
    }

    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetNotify(DWORD pv, LPITEMIDLIST*wP, LONG*lP) 
{
    if (IsExplorerModeBrowser(_punkSite))
        _lEvents |= SHCNE_FREESPACE; // need free space info here too

    return E_FAIL;  // return failure to let base guy do the rest
}

STDMETHODIMP CFSFolderViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_GETCCHMAX, OnGetCCHMax);
    HANDLE_MSG(0, SFVM_WINDOWCREATED, OnWindowCreated);
    HANDLE_MSG(1 , SFVM_INSERTITEM, OnInsertDeleteItem);
    HANDLE_MSG(-1, SFVM_DELETEITEM, OnInsertDeleteItem);
    HANDLE_MSG(0, SFVM_SELCHANGE, OnSelChange);
    HANDLE_MSG(0, SFVM_UPDATESTATUSBAR, OnUpdateStatusBar);
    HANDLE_MSG(0, SFVM_REFRESH, OnRefresh);
    HANDLE_MSG(0, SFVM_SELECTALL, OnSelectAll);
    HANDLE_MSG(0, SFVM_GETWORKINGDIR, OnGetWorkingDir);
    HANDLE_MSG(0, SFVM_ENUMERATEDITEMS, OnEnumeratedItems);
    HANDLE_MSG(0, SFVM_GETVIEWDATA, OnGetViewData);
    HANDLE_MSG(0, SFVM_GETWEBVIEW_TEMPLATE, OnGetWebViewTemplate);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTHEME, OnGetWebViewTheme);
    HANDLE_MSG(0, SFVM_DEFVIEWMODE, OnDefViewMode);
    HANDLE_MSG(0, SFVM_GETCUSTOMVIEWINFO, OnGetCustomViewInfo);
    HANDLE_MSG(0, SFVM_ADDPROPERTYPAGES, SFVCB_OnAddPropertyPages);
    HANDLE_MSG(0, SFVM_SIZE, OnSize);
    HANDLE_MSG(0, SFVM_GETPANE, OnGetPane);
    HANDLE_MSG(0, SFVM_GETNOTIFY, OnGetNotify);
    HANDLE_MSG(0, SFVM_GETDEFERREDVIEWSETTINGS, OnGetDeferredViewSettings);

    default:
        return E_FAIL;
    }

    return S_OK;
}


STDAPI CFSFolderCallback_Create(CFSFolder *pfsf, IShellFolderViewCB **ppsfvcb)
{
    *ppsfvcb = new CFSFolderViewCB(pfsf);
    return *ppsfvcb ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fstreex.h ===
#ifndef _FSTREEX_INC
#define _FSTREEX_INC

#include "idlcomm.h"
#include <filetype.h>
#include "pidl.h"       // IDFOLDER
#include "shitemid.h"

STDAPI_(LPCIDFOLDER) CFSFolder_IsValidID(LPCITEMIDLIST pidl);
STDAPI_(BOOL)        CFSFolder_IsCommonItem(LPCITEMIDLIST pidl);
STDAPI_(BOOL)        CFSFolder_MakeCommonItem(LPITEMIDLIST pidl);

STDAPI CFSFolder_CompareNames(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
STDAPI_(DWORD) CFSFolder_PropertiesThread(void *pv);
STDAPI CFSFolder_CreateFolder(IUnknown *punkOuter, LPBC pbc, LPCITEMIDLIST pidl, 
                              const PERSIST_FOLDER_TARGET_INFO *pf, REFIID riid, void **ppv);

STDAPI_(void) SHGetTypeName(LPCTSTR pszFile, HKEY hkey, BOOL fFolder, LPTSTR pszName, int cchNameMax);

STDAPI_(BOOL) GetFolderString(LPCTSTR pszFolder, LPCTSTR pszProvider, LPTSTR  pszProfile, int cchMax, LPCTSTR pszKey);

STDAPI CFSFolder_CreateFileFromClip(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, POINTL pt, DWORD *pdwEffect, BOOL fIsBkDropTarget);
STDAPI CFSFolder_AsyncCreateFileFromClip(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, POINTL pt, DWORD *pdwEffect, BOOL fIsBkDropTarget);

STDAPI_(BOOL) SHGetClassKey(LPCITEMIDLIST pidl, HKEY *phkeyProgID, HKEY *phkeyBaseID);
STDAPI_(void) SHCloseClassKey(HKEY hkey);

// CFSFolder::_GetClassFlags
#define SHCF_ICON_INDEX             0x00000FFF
#define SHCF_ICON_PERINSTANCE       0x00001000
#define SHCF_ICON_DOCICON           0x00002000
#define SHCF_00004000               0x00004000
#define SHCF_00008000               0x00008000

#define SHCF_HAS_ICONHANDLER        0x00020000

#define SHCF_IS_DOCOBJECT           0x00100000

#define SHCF_IS_SHELLEXT            0x00400000
#define SHCF_00800000               0x00800000

#define SHCF_IS_LINK                0x01000000
#define SHCF_UNKNOWN                0x04000000
#define SHCF_ALWAYS_SHOW_EXT        0x08000000
#define SHCF_NEVER_SHOW_EXT         0x10000000
#define SHCF_20000000               0x20000000
#define SHCF_40000000               0x40000000
#define SHCF_80000000               0x80000000

STDAPI CFSFolder_CreateLinks(HWND hwnd, IShellFolder *psf, IDataObject *pdtobj, LPCTSTR pszDir, DWORD fMask);
STDAPI CreateLinkToPidl(LPCITEMIDLIST pidlAbs, LPCTSTR pszDir, LPITEMIDLIST* ppidl, UINT uFlags);

STDAPI GetIconOverlayManager(IShellIconOverlayManager **ppsiom);

typedef struct {
    BOOL fInitialized;
    POINT pt;
    POINT ptOrigin;
    UINT cxItem, cyItem;
    int xMul, yMul, xDiv, yDiv;
    POINT *pptOffset;
    UINT iItem;
} DROPHISTORY;

STDAPI_(void) PositionFileFromDrop(HWND hwnd, LPCTSTR pszFile, DROPHISTORY *pdh);
STDAPI_(int)  CreateMoveCopyList(HDROP hdrop, void *hNameMappings, LPITEMIDLIST **pppidl);
STDAPI_(void) PositionItems(IFolderView* pifv, LPCITEMIDLIST* apidl, UINT cidl, IDataObject* pdtobj, POINT* ptDrop);
STDAPI_(void) PositionItems_DontUse(HWND hwndOwner, UINT cidl, const LPITEMIDLIST *ppidl, IDataObject *pdtobj, POINT *pptOrigin, BOOL fMove, BOOL fUseExactOrigin);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftaction.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "ftadv.h"
#include "ftcmmn.h"
#include "ftaction.h"
#include "ftassoc.h"

const static DWORD cs_rgdwHelpIDsArray[] =
{  // Context Help IDs
    IDC_FT_CMD_ACTION,         IDH_FCAB_FT_CMD_ACTION,
    IDC_FT_CMD_EXETEXT,        IDH_FCAB_FT_CMD_EXE,
    IDC_FT_CMD_EXE,            IDH_FCAB_FT_CMD_EXE,
    IDC_FT_CMD_BROWSE,         IDH_FCAB_FT_CMD_BROWSE,
    IDC_FT_CMD_DDEGROUP,       IDH_FCAB_FT_CMD_USEDDE,
    IDC_FT_CMD_USEDDE,         IDH_FCAB_FT_CMD_USEDDE,
    IDC_FT_CMD_DDEMSG,         IDH_FCAB_FT_CMD_DDEMSG,
    IDC_FT_CMD_DDEAPP,         IDH_FCAB_FT_CMD_DDEAPP,
    IDC_FT_CMD_DDEAPPNOT,      IDH_FCAB_FT_CMD_DDEAPPNOT,
    IDC_FT_CMD_DDETOPIC,       IDH_FCAB_FT_CMD_DDETOPIC,
    0, 0
};

CFTActionDlg::CFTActionDlg(PROGIDACTION* pProgIDAction, LPTSTR pszProgIDDescr,
                BOOL fEdit) :
                CFTDlg((ULONG_PTR)cs_rgdwHelpIDsArray), 
                _pProgIDAction(pProgIDAction), _pszProgIDDescr(pszProgIDDescr),
                _fEdit(fEdit)
{
}

CFTActionDlg::~CFTActionDlg()
{
}

///////////////////////////////////////////////////////////////////////////////
// Logic specific to our problem
LRESULT CFTActionDlg::OnInitDialog(WPARAM wParam, LPARAM lParam)
{
    DECLAREWAITCURSOR;

    SetWaitCursor();

    if (_fEdit || _fShowAgain)
    {
        TCHAR szTitle[50 + MAX_PROGIDDESCR + 5];
        TCHAR szTitleTemplate[50];

        _fShowAgain = FALSE;

        if (LoadString(g_hinst, IDS_FT_EDITTITLE, szTitleTemplate, ARRAYSIZE(szTitleTemplate)))
        {
            wnsprintf(szTitle, ARRAYSIZE(szTitle), szTitleTemplate, _pszProgIDDescr);
            SetWindowText(_hwnd, szTitle);
        }

        SetDlgItemText(_hwnd, IDC_FT_CMD_ACTION, _pProgIDAction->szAction);
        SetDlgItemText(_hwnd, IDC_FT_CMD_EXE, _pProgIDAction->szCmdLine);
        SetDlgItemText(_hwnd, IDC_FT_CMD_DDEMSG, _pProgIDAction->szDDEMsg);
        SetDlgItemText(_hwnd, IDC_FT_CMD_DDEAPP, _pProgIDAction->szDDEApplication);
        SetDlgItemText(_hwnd, IDC_FT_CMD_DDEAPPNOT, _pProgIDAction->szDDEAppNotRunning);
        SetDlgItemText(_hwnd, IDC_FT_CMD_DDETOPIC, _pProgIDAction->szDDETopic);

        CheckDlgButton(_hwnd, IDC_FT_CMD_USEDDE, _pProgIDAction->fUseDDE);
        _ResizeDlgForDDE(_pProgIDAction->fUseDDE);
    }
    else
    {
        CheckDlgButton(_hwnd, IDC_FT_CMD_USEDDE, FALSE);
        _ResizeDlgForDDE(FALSE);
    }

    Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_CMD_ACTION), MAX_ACTION - 1);
    Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_CMD_EXE), MAX_ACTIONCMDLINE - 1);
    Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_CMD_DDEMSG), MAX_ACTIONDDEMSG - 1);
    Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_CMD_DDEAPP), MAX_ACTIONAPPL - 1);
    Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_CMD_DDEAPPNOT), MAX_ACTIONDDEAPPNOTRUN - 1);
    Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_CMD_DDETOPIC), MAX_ACTIONTOPIC - 1);

    ResetWaitCursor();

    // Return TRUE so that system set focus
    return TRUE;
}

BOOL CFTActionDlg::_Validate()
{
    BOOL bRet = TRUE;

    // Check the Action
    TCHAR szAction[MAX_ACTION];

    if (!GetDlgItemText(_hwnd, IDC_FT_CMD_ACTION, szAction, ARRAYSIZE(szAction)) ||
        !*szAction)
    {
        ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_NOACTION), 
            MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP);

        PostMessage(_hwnd, WM_CTRL_SETFOCUS, (WPARAM)0, 
            (LPARAM)GetDlgItem(_hwnd, IDC_FT_CMD_ACTION));

        bRet = FALSE;
    }

    if (bRet)
    {
        TCHAR szPath[MAX_PATH];
        LPTSTR pszFileName = NULL;
    
        // Check for valid exe
        GetDlgItemText(_hwnd, IDC_FT_CMD_EXE, szPath, ARRAYSIZE(szPath));
        PathRemoveArgs(szPath);
        PathUnquoteSpaces(szPath);

        pszFileName = PathFindFileName(szPath);

        if(!(*szPath) ||
            !(PathIsExe(szPath)) ||
            ((!(PathFileExists(szPath))) && (!(PathFindOnPath(pszFileName, NULL)))))
        {
            // Tell user that this exe is invalid
            ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_EXETEXT),
                MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP);

            PostMessage(_hwnd, WM_CTRL_SETFOCUS, (WPARAM)0,
                (LPARAM)GetDlgItem(_hwnd, IDC_FT_CMD_EXE));

            bRet = FALSE;
        }
    }

    return bRet;
}

void CFTActionDlg::SetShowAgain()
{
    _fShowAgain = TRUE;
}

BOOL _IsThereAnyPercentArgument(LPTSTR pszCommand)
{
    BOOL fRet = FALSE;
    LPTSTR pszArgs = PathGetArgs(pszCommand);

    if (pszArgs && *pszArgs)
    {
        if (StrStr(pszArgs, TEXT("%")))
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

LRESULT CFTActionDlg::OnOK(WORD wNotif)
{
    if (_Validate())
    {
        GetDlgItemText(_hwnd, IDC_FT_CMD_ACTION, _pProgIDAction->szAction, MAX_ACTION);

        // Is this a new action?
        if (!_fEdit)
        {
            // Yes, initialize the old action field
            StrCpyN(_pProgIDAction->szOldAction, _pProgIDAction->szAction,
                ARRAYSIZE(_pProgIDAction->szOldAction));

            // Build the ActionReg
            lstrcpy(_pProgIDAction->szActionReg, _pProgIDAction->szAction);

            // Replace spaces with underscores
            LPTSTR psz = _pProgIDAction->szActionReg;
    
            while (*psz)
            {
                if (TEXT(' ') == *psz)
                {
                    *psz = TEXT('_');
                }

                psz = CharNext(psz);
            }

            lstrcpy(_pProgIDAction->szOldActionReg, _pProgIDAction->szActionReg);
        }

        GetDlgItemText(_hwnd, IDC_FT_CMD_EXE, _pProgIDAction->szCmdLine, MAX_ACTIONCMDLINE);
        GetDlgItemText(_hwnd, IDC_FT_CMD_DDEMSG, _pProgIDAction->szDDEMsg, MAX_ACTIONDDEMSG);
        GetDlgItemText(_hwnd, IDC_FT_CMD_DDEAPP, _pProgIDAction->szDDEApplication, MAX_ACTIONAPPL);
        GetDlgItemText(_hwnd, IDC_FT_CMD_DDEAPPNOT, _pProgIDAction->szDDEAppNotRunning, MAX_ACTIONDDEAPPNOTRUN);
        GetDlgItemText(_hwnd, IDC_FT_CMD_DDETOPIC, _pProgIDAction->szDDETopic, MAX_ACTIONTOPIC);

        _pProgIDAction->fUseDDE = IsDlgButtonChecked(_hwnd, IDC_FT_CMD_USEDDE);

        // Append %1 to action field, if required
        if (!_IsThereAnyPercentArgument(_pProgIDAction->szCmdLine))
        {
            TCHAR* pszPercentToAppend;

            if (StrChr(_pProgIDAction->szCmdLine,TEXT('\\')))
            {
                if (App_IsLFNAware(_pProgIDAction->szCmdLine))
                    pszPercentToAppend = TEXT(" \"%1\"");
                else
                    pszPercentToAppend = TEXT(" %1");
            }
            else
            {
                TCHAR szFullPathFileName[MAX_PATH];
                //
                StrCpyN(szFullPathFileName, _pProgIDAction->szCmdLine,
                    ARRAYSIZE(szFullPathFileName));
                //PathFindOnPath: first param is the filename, if it is on the path
                //  then it returns fully qualified, if not return false.
                //Second param is optional directory to look in first
                if (PathFindOnPath(szFullPathFileName, NULL))
                {
                    if (App_IsLFNAware(szFullPathFileName))
                        pszPercentToAppend = TEXT(" \"%1\"");
                    else
                        pszPercentToAppend = TEXT(" %1");
                }
                else
                {//just in case, default to good old behavior.  Should not come here because
                    // ActionExeIsValid was done earlier
                    pszPercentToAppend = TEXT(" %1");
                }
            }
            //append...
            StrCatN(_pProgIDAction->szCmdLine, pszPercentToAppend, 
                ARRAYSIZE(_pProgIDAction->szCmdLine));
        }

        EndDialog(_hwnd, IDOK);
    }
    
    return FALSE;
}

LRESULT CFTActionDlg::OnCancel(WORD wNotif)
{
    EndDialog(_hwnd, IDCANCEL);

    return FALSE;
}

LRESULT CFTActionDlg::OnUseDDE(WORD wNotif)
{
    _ResizeDlgForDDE(IsDlgButtonChecked(_hwnd, IDC_FT_CMD_USEDDE));

    return FALSE;
}

LRESULT CFTActionDlg::OnBrowse(WORD wNotif)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szTitle[40];
    TCHAR szEXE[MAX_PATH];
    TCHAR szFilters[MAX_PATH];
    LPTSTR psz;
    
    szPath[0] = 0;
    
    EVAL(LoadString(g_hinst, IDS_CAP_OPENAS, szTitle, ARRAYSIZE(szTitle)));
    EVAL(LoadString(g_hinst, IDS_FT_EXE, szEXE, ARRAYSIZE(szEXE)));
    
    // And we need to convert #'s to \0's...
    EVAL(LoadString(g_hinst, IDS_PROGRAMSFILTER, szFilters, ARRAYSIZE(szFilters)));

    psz = szFilters;
    while (*psz)
    {
        if (*psz == TEXT('#'))
        {
            LPTSTR pszT = psz;
            psz = CharNext(psz);
            *pszT = TEXT('\0');
        }
        else
            psz = CharNext(psz);
    }
    
    if (GetFileNameFromBrowse(_hwnd, szPath, ARRAYSIZE(szPath), NULL, szEXE, szFilters, szTitle))
    {
        PathQuoteSpaces(szPath);
        SetDlgItemText(_hwnd, IDC_FT_CMD_EXE, szPath);
    }
    
    return FALSE;
}

void CFTActionDlg::_ResizeDlgForDDE(BOOL fShow)
{
    RECT rcDialog;
    RECT rcControl;
    
    GetWindowRect(_hwnd, &rcDialog);
    
    if(fShow)
        GetWindowRect(GetDlgItem(_hwnd, IDC_FT_CMD_DDEGROUP), &rcControl);
    else
        GetWindowRect(GetDlgItem(_hwnd, IDC_FT_CMD_USEDDE), &rcControl);
    
    // Hide/Show the windows to take care of the Tabbing.  If we don't hide them then
    // we tab through the "visible" window outside of the dialog.

    ShowWindow(GetDlgItem(_hwnd, IDC_FT_CMD_DDEMSG), fShow);
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_CMD_DDEAPP), fShow);
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_CMD_DDEAPPNOT), fShow);
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_CMD_DDETOPIC), fShow);

    ShowWindow(GetDlgItem(_hwnd, IDC_FT_CMD_DDEGROUP), fShow);
    SetWindowPos(GetDlgItem(_hwnd, IDC_FT_CMD_USEDDE), HWND_TOPMOST, 
        0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);
    
    MoveWindow(_hwnd, rcDialog.left, rcDialog.top, rcDialog.right - rcDialog.left,
        (rcControl.bottom - rcDialog.top) + 10, TRUE);
    
    SetFocus(GetDlgItem(_hwnd, IDC_FT_CMD_USEDDE));
}

LRESULT CFTActionDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    CFTDlg::OnDestroy(wParam, lParam);

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// Windows boiler plate code
LRESULT CFTActionDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_FT_CMD_USEDDE:
            // Resize Dialog to see/hide DDE controls
            lRes = OnUseDDE(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_CMD_BROWSE:
            lRes = OnBrowse(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        default:
            lRes = CFTDlg::OnCommand(wParam, lParam);
            break;
    }

    return lRes;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftadv.h ===
#ifndef FTADVDLG
#define FTADVDLG

#include "ftdlg.h"
#include "ftcmmn.h"

class CFTAdvDlg : public CFTDlg
{
public:
    CFTAdvDlg(LPTSTR pszProgID, LPTSTR pszExt = NULL);

protected:
    ~CFTAdvDlg();

///////////////////////////////////////////////////////////////////////////////
//  Implementation
private:

    LRESULT WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
// Message handlers
    // Dialog messages
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);

    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);
    LRESULT OnDrawItem(WPARAM wParam, LPARAM lParam);
    LRESULT OnMeasureItem(WPARAM wParam, LPARAM lParam);

    LRESULT OnOK(WORD wNotif);
    LRESULT OnCancel(WORD wNotif);

    // Control specific
    //
    //      Action buttons
    LRESULT OnNewButton(WORD wNotif);
    LRESULT OnEditButton(WORD wNotif);
    LRESULT OnChangeIcon(WORD wNotif);
    LRESULT OnSetDefault(WORD wNotif);
    LRESULT OnRemoveButton(WORD wNotif);
    //      ListView
    LRESULT OnNotifyListView(UINT uCode, LPNMHDR pNMHDR);
    LRESULT OnListViewSelItem(int iItem, LPARAM lParam);

private:
// Member variables
    TCHAR       _szProgID[MAX_PROGID];
    TCHAR       _szExt[MAX_EXT];
    

    HICON       _hIcon;

    HFONT       _hfontReg;
    HFONT       _hfontBold;
    int         _iDefaultAction;
    int         _iLVSel;

    HDPA        _hdpaActions;
    HDPA        _hdpaRemovedActions;

    TCHAR       _szIconLoc[MAX_ICONLOCATION];
    TCHAR       _szOldIconLoc[MAX_ICONLOCATION];
    int         _iOldIcon;

    HANDLE      _hHeapProgID;

///////////////////////////////////////////////////////////////////////////////
//  Helpers
    inline HWND _GetLVHWND();

    HRESULT _FillListView();
    HRESULT _FillProgIDDescrCombo();

    HRESULT _InitDefaultActionFont();
    HRESULT _InitListView();
    HRESULT _InitDefaultAction();
    HRESULT _InitChangeIconButton();
    HRESULT _InitDescription();

    HRESULT _SetDocIcon(int iIndex = -1);
    int _GetIconIndex();
    HRESULT _SelectListViewItem(int i);
    HRESULT _SetDefaultAction(int iIndex);
    void _SetDefaultActionHelper(int iIndex, BOOL fDefault);

    HRESULT _UpdateActionButtons();
    HRESULT _UpdateCheckBoxes();

    // PROGIDACTION helpers
    HRESULT _RemovePROGIDACTION(PROGIDACTION* pPIDA);
    HRESULT _CreatePROGIDACTION(PROGIDACTION** ppPIDA);
    HRESULT _CopyPROGIDACTION(PROGIDACTION* pPIDADest, PROGIDACTION* pPIDASrc);
    HRESULT _GetPROGIDACTION(LPTSTR pszAction, PROGIDACTION** ppPIDA);
    HRESULT _AppendPROGIDACTION(PROGIDACTION* pPIDA);
    HRESULT _FillPROGIDACTION(PROGIDACTION* pPIDA, LPTSTR pszActionReg,
                                     LPTSTR pszActionFN);
    void _DeletePROGIDACTION(PROGIDACTION* pPIDA);
    BOOL _IsNewPROGIDACTION(LPTSTR pszAction);
    BOOL _FindActionLVITEM(LPTSTR pszActionReg, LVITEM* plvItem);

    BOOL _GetListViewSelectedItem(UINT uMask, UINT uStateMask, LVITEM* plvItem);
    int _InsertListViewItem(int iItem, LPTSTR pszActionReg, LPTSTR pszActionFN);
    BOOL _IsDefaultAction(LPTSTR pszActionReg);
    BOOL _GetDefaultAction(LPTSTR pszActionReg, DWORD cchActionReg);
    void _CleanupProgIDs();
    LPTSTR _AddProgID(LPTSTR pszProgID);
    void _CheckDefaultAction();

    BOOL _CheckForDuplicateEditAction(LPTSTR pszActionRegOriginal, LPTSTR pszActionReg,
        LPTSTR pszActionFNOriginal, LPTSTR pszActionFN);
    BOOL _CheckForDuplicateNewAction(LPTSTR pszActionReg, LPTSTR pszActionFN);
};

#endif //FTADVDLG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftaction.h ===
#ifndef FTACTION_H
#define FTACTION_H

#include "ftdlg.h"

class CFTActionDlg : public CFTDlg
{
public:
    CFTActionDlg(PROGIDACTION* pProgIDAction, LPTSTR pszProgIDDescr, BOOL fEdit);

protected:
    ~CFTActionDlg();

public:
    void SetShowAgain();

///////////////////////////////////////////////////////////////////////////////
//  Implementation
private:
// Message handlers
    //Dialog messages
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);

    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);

    //Control specific
    LRESULT OnOK(WORD wNotif);
    LRESULT OnCancel(WORD wNotif);
    LRESULT OnUseDDE(WORD wNotif);
    LRESULT OnBrowse(WORD wNotif);

private:
// Member variables
    PROGIDACTION* _pProgIDAction;
    LPTSTR _pszProgIDDescr;

    BOOL _fEdit;
    // used when need to reshow dlg because user entered bad data
    BOOL _fShowAgain;
///////////////////////////////////////////////////////////////////////////////
//  Helpers
private:
    // AssocStore
    BOOL _Validate();
    void _ResizeDlgForDDE(BOOL fShow);
};

#endif //FTACTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftadv.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "help.h"

#include "apithk.h"
#include "ascstr.h"
#include "filetype.h"
#include "ftdlg.h"
#include "ftadv.h"
#include "ftaction.h"

const static DWORD cs_rgdwHelpIDsArray[] =
{  // Context Help IDs
    IDC_NO_HELP_1,              NO_HELP,
    IDC_FT_EDIT_DOCICON,        IDH_FCAB_FT_EDIT_DOCICON,
    IDC_FT_EDIT_DESC,           IDH_FCAB_FT_EDIT_DESC,
    IDC_FT_EDIT_CHANGEICON,     IDH_FCAB_FT_EDIT_CHANGEICON,
    IDC_FT_EDIT_LV_CMDSTEXT,    IDH_FCAB_FT_EDIT_LV_CMDS,
    IDC_FT_EDIT_LV_CMDS,        IDH_FCAB_FT_EDIT_LV_CMDS,
    IDC_FT_EDIT_NEW,            IDH_FCAB_FT_EDIT_NEW,
    IDC_FT_EDIT_EDIT,           IDH_FCAB_FT_EDIT_EDIT,
    IDC_FT_EDIT_REMOVE,         IDH_FCAB_FT_EDIT_REMOVE,
    IDC_FT_EDIT_DEFAULT,        IDH_FCAB_FT_EDIT_DEFAULT,
    IDC_FT_EDIT_CONFIRM_OPEN,   IDH_CONFIRM_OPEN,
    IDC_FT_EDIT_SHOWEXT,        IDH_FCAB_FT_EDIT_SHOWEXT,
    IDC_FT_EDIT_BROWSEINPLACE,  IDH_SAME_WINDOW,
    0, 0
};

struct LV_ADDDATA
{
    BOOL    fDefaultAction;
    TCHAR   szActionReg[MAX_ACTION];
};

#define ADDDATA_ACTIONREG(plvItem) (((LV_ADDDATA*)((plvItem)->lParam))->szActionReg)
#define ADDDATA_DEFAULTACTION(plvItem) (((LV_ADDDATA*)((plvItem)->lParam))->fDefaultAction)

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CFTAdvDlg::CFTAdvDlg(LPTSTR pszProgID, LPTSTR pszExt) :
    CFTDlg((ULONG_PTR)cs_rgdwHelpIDsArray),
    _iDefaultAction(-1), _iLVSel(-1)
{
    _szProgID[0] = NULL;
    if (pszProgID)
        StrCpyN(_szProgID, pszProgID, ARRAYSIZE(_szProgID));

    _szExt[0] = NULL;
    if (pszExt && (*pszExt != NULL))
    {
        wnsprintf(_szExt, ARRAYSIZE(_szExt), TEXT(".%s"), pszExt);        
    }

    _hdpaActions = DPA_Create(4);
    _hdpaRemovedActions = DPA_Create(1);
}

static int _DeleteLocalAllocCB(void *pItem, void *pData)
{
    LocalFree((HLOCAL)pItem);
    return 1;
}

CFTAdvDlg::~CFTAdvDlg()
{
    if (_hIcon)
        DeleteObject(_hIcon);

    if (_hfontReg)
        DeleteObject(_hfontReg);

    if (_hfontBold)
        DeleteObject(_hfontBold);

    if (_hdpaActions)
        DPA_DestroyCallback(_hdpaActions, _DeleteLocalAllocCB, NULL);

    if (_hdpaRemovedActions)
        DPA_DestroyCallback(_hdpaRemovedActions, _DeleteLocalAllocCB, NULL);
}

///////////////////////////////////////////////////////////////////////////////
// Logic specific to our problem
LRESULT CFTAdvDlg::OnInitDialog(WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = _InitAssocStore();
    DECLAREWAITCURSOR;

    SetWaitCursor();

    if (SUCCEEDED(hres))
    {
        _InitListView();

        _InitDefaultActionFont();

    // FTEdit_AreDefaultViewersInstalled ????

        if (*_szProgID)
        {
            _SetDocIcon();

            _InitDescription();

            _FillListView();

            _InitDefaultAction();

            _SelectListViewItem(0);

            _InitChangeIconButton();

            _UpdateCheckBoxes();
        }   
    }
    else
        EndDialog(_hwnd, -1);

    ResetWaitCursor();

    // Return TRUE so that system set focus
    return TRUE;
}

int CFTAdvDlg::_GetIconIndex()
{
    // check under the file progid
    int iImageIndex = -1;
    IAssocInfo* pAI = NULL;
    HRESULT hr = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);
    if (SUCCEEDED(hr))
    {
        hr = pAI->GetDWORD(AIDWORD_DOCLARGEICON, (DWORD*)&iImageIndex);
        pAI->Release();
    }
    return iImageIndex;
}

HRESULT CFTAdvDlg::_SetDocIcon(int iIndex)
{
    HRESULT hres = E_FAIL;

    if (-1 == iIndex)
    {
        iIndex = _GetIconIndex();
    }

    if (-1 != iIndex)
    {
        HIMAGELIST hIL = NULL;

        Shell_GetImageLists(&hIL, NULL);

        if (_hIcon)
        {
            DeleteObject(_hIcon);
            _hIcon = NULL;
        }

        if (hIL)
        {
            _hIcon = ImageList_ExtractIcon(g_hinst, hIL, iIndex);

            _hIcon = (HICON)CopyImage(_hIcon, IMAGE_ICON, 32, 32, LR_COPYDELETEORG);

            HICON hiOld = (HICON)SendDlgItemMessage(_hwnd, IDC_FT_EDIT_DOCICON, STM_SETIMAGE, IMAGE_ICON,
                (LPARAM)_hIcon);

            if (hiOld)
                DestroyIcon(hiOld);
        }
    }

    return hres;
}

LRESULT CFTAdvDlg::OnListViewSelItem(int iItem, LPARAM lParam)
{
    _UpdateActionButtons();

    return TRUE;
}

LRESULT CFTAdvDlg::OnMeasureItem(WPARAM wParam, LPARAM lParam)
{
    TEXTMETRIC tm = {0};
    RECT rect;
    LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT)lParam;

    HDC hdc = GetDC(NULL);
    HFONT hfontOld = (HFONT)SelectObject(hdc, _hfontBold);

    GetTextMetrics(hdc, &tm);

    GetClientRect(_GetLVHWND(), &rect);

    lpmis->itemWidth = rect.right;
    lpmis->itemHeight = tm.tmHeight;

    SelectObject(hdc, hfontOld);

    ReleaseDC(NULL, hdc);

    return TRUE;
}

LRESULT CFTAdvDlg::OnDrawItem(WPARAM wParam, LPARAM lParam)
{
    LPDRAWITEMSTRUCT lpDIS = (LPDRAWITEMSTRUCT)lParam;
    LRESULT lRet = FALSE;
    
    if (ODT_LISTVIEW == lpDIS->CtlType)
    {
        HWND hwndLV = _GetLVHWND();
        LVITEM lvItem = {0};
        HFONT hfontOld = NULL;
        BOOL fSel = FALSE;
        BOOL fListFocus = FALSE;
        TCHAR szAction[MAX_ACTION];
        COLORREF crBkgd = 0;
        COLORREF crOldText = 0;
        
        lvItem.mask = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
        lvItem.iItem = lpDIS->itemID;
        lvItem.stateMask = LVIS_SELECTED|LVIS_FOCUSED;
        lvItem.pszText = szAction;
        lvItem.cchTextMax = ARRAYSIZE(szAction);

        ListView_GetItem(hwndLV, &lvItem);

        fSel = (lvItem.state & LVIS_SELECTED);
        fListFocus = (GetFocus() == hwndLV);
        
        crBkgd = (fSel ? (fListFocus ? COLOR_HIGHLIGHT : COLOR_3DFACE) : COLOR_WINDOW);

        SetBkColor(lpDIS->hDC, GetSysColor(crBkgd));

        FillRect(lpDIS->hDC, &lpDIS->rcItem, (HBRUSH)IntToPtr(crBkgd + 1));

        crOldText = SetTextColor(lpDIS->hDC, 
            GetSysColor(fSel ? (fListFocus ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT) :
            COLOR_WINDOWTEXT));

        // Use Bold font for default action
        hfontOld = (HFONT)SelectObject(lpDIS->hDC, 
            _IsDefaultAction(ADDDATA_ACTIONREG(&lvItem)) ? _hfontBold : _hfontReg);
        
        int iOldBkMode = SetBkMode(lpDIS->hDC, OPAQUE);

        DrawText(lpDIS->hDC, szAction, lstrlen(szAction), &lpDIS->rcItem, 0);

        SetBkMode(lpDIS->hDC, iOldBkMode);

        SetTextColor(lpDIS->hDC, crOldText);

        SelectObject(lpDIS->hDC, hfontOld);
        
        if(fListFocus && (lvItem.state & LVIS_FOCUSED))
            DrawFocusRect(lpDIS->hDC, &lpDIS->rcItem);

        lRet = TRUE;
    }

    return lRet;
}

HRESULT CFTAdvDlg::_InitDefaultActionFont()
{
    HFONT hfontDlg = GetWindowFont(_hwnd);
    LOGFONT lf = {0};

    LOGFONT lfDlg = {0};
    GetObject(hfontDlg, sizeof(LOGFONT), &lfDlg);

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);

    // Normal font
    lf.lfWeight = FW_NORMAL;
    lf.lfHeight = lfDlg.lfHeight;    
    _hfontReg = CreateFontIndirect(&lf);

    // Bold font
    lf.lfWeight = FW_BOLD;
    _hfontBold = CreateFontIndirect(&lf);

    return (_hfontReg && _hfontBold) ? S_OK : E_FAIL;
}

HRESULT CFTAdvDlg::_SelectListViewItem(int i)
{
    LVITEM lvItem = {0};

    lvItem.iItem = i;
    lvItem.mask = LVIF_STATE;
    lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;

    ListView_SetItem(_GetLVHWND(), &lvItem);

    return S_OK;
}

// pszText and cchTextMax needs to be set
BOOL CFTAdvDlg::_FindActionLVITEM(LPTSTR pszActionReg, LVITEM* plvItem)
{
    HWND hwndLV = _GetLVHWND();
    int iCount = ListView_GetItemCount(hwndLV);
    BOOL fRet = FALSE;

    plvItem->mask = LVIF_TEXT | LVIF_PARAM;

    for (int i = 0; i < iCount; ++i)
    {
        plvItem->iItem = i;

        if (ListView_GetItem(hwndLV, plvItem))
        {
            if (!lstrcmpi(pszActionReg, ADDDATA_ACTIONREG(plvItem)))
            {
                fRet = TRUE;
                break;
            }
        }
    }

    return fRet;
}

HRESULT CFTAdvDlg::_InitDefaultAction()
{
    // Get it from the classstore
    IAssocInfo* pAI = NULL;
    HRESULT hres = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);
    if (SUCCEEDED(hres))
    {
        TCHAR szActionReg[MAX_ACTION];
        DWORD cchActionReg = ARRAYSIZE(szActionReg);
        HWND hwndLV = _GetLVHWND();
        int iIndex = -1;

        hres = pAI->GetString(AISTR_PROGIDDEFAULTACTION, szActionReg, &cchActionReg);

        if (SUCCEEDED(hres))
        {
            TCHAR szActionLVI[MAX_ACTION];
            LVITEM lvItem = {0};

            lvItem.pszText = szActionLVI;
            lvItem.cchTextMax = ARRAYSIZE(szActionLVI);

            if (_FindActionLVITEM(szActionReg, &lvItem))
                hres = _SetDefaultAction(lvItem.iItem);
            else
                hres = S_OK;
        }

        pAI->Release();
    }

    return hres;
}

BOOL CFTAdvDlg::_GetDefaultAction(LPTSTR pszActionReg, DWORD cchActionReg)
{
    BOOL fRet = FALSE;
    HWND hwndLV = _GetLVHWND();
    LVITEM lvItem = {0};
    int iCount = ListView_GetItemCount(hwndLV);
    TCHAR szActionRegLocal[MAX_ACTION];

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.pszText = szActionRegLocal;
    lvItem.cchTextMax = ARRAYSIZE(szActionRegLocal);

    for (int i = 0; i < iCount; ++i)
    {
        lvItem.iItem = i;

        if (ListView_GetItem(hwndLV, &lvItem))
        {
            if (ADDDATA_DEFAULTACTION(&lvItem))
            {
                StrCpyN(pszActionReg, ADDDATA_ACTIONREG(&lvItem), cchActionReg);
                fRet = TRUE;
                break;
            }
        }
    }

    return fRet;
}

BOOL CFTAdvDlg::_IsDefaultAction(LPTSTR pszActionReg)
{
    BOOL fRet = FALSE;
    TCHAR szActionReg[MAX_ACTION];

    if (_GetDefaultAction(szActionReg, ARRAYSIZE(szActionReg)))
    {
        if (!lstrcmpi(szActionReg, pszActionReg))
            fRet = TRUE;
    }

    return fRet;
}

void CFTAdvDlg::_CheckDefaultAction()
{
    HWND hwndLV = _GetLVHWND();
    // Is there only one elem?
    if (1 == ListView_GetItemCount(hwndLV))
    {
        _SetDefaultActionHelper(0, TRUE);
    }
}

HRESULT CFTAdvDlg::_SetDefaultAction(int iIndex)
{
    HWND hwndLV = _GetLVHWND();
    // Remove previous default if any

    if (-1 != _iDefaultAction)
    {
        _SetDefaultActionHelper(_iDefaultAction, FALSE);

        ListView_RedrawItems(hwndLV, _iDefaultAction, _iDefaultAction);
    }

    // Set new
    _iDefaultAction = iIndex;

    // iIndex == -1 means no default
    if (iIndex >= 0)    
    {
        _SetDefaultActionHelper(_iDefaultAction, TRUE);

        ListView_RedrawItems(hwndLV, _iDefaultAction, _iDefaultAction);
    }
    
    return S_OK;
}

void CFTAdvDlg::_SetDefaultActionHelper(int iIndex, BOOL fDefault)
{
    HWND hwndLV = _GetLVHWND();
    LVITEM lvItem = {0};
    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = iIndex;

    _iDefaultAction = -1;

    if (ListView_GetItem(hwndLV, &lvItem))
    {
        ADDDATA_DEFAULTACTION(&lvItem) = fDefault;
        _iDefaultAction = iIndex;
    }
}

HRESULT CFTAdvDlg::_InitListView()
{
    LVCOLUMN lvColumn = {0};
    HWND hwndLV = _GetLVHWND();
    RECT rc = {0};

    {
        // What's this?
        // We need to handle the WM_MEASUREITEM message from the listview.  This msg
        // is sent before we receive the WM_INITDIALOG and thus before we connect the
        // this C++ obj to the HWND.  By changing the style here we receive the msg
        // after the C++ obj and the HWND are connected.
        LONG lStyle = GetWindowLong(hwndLV, GWL_STYLE);

        lStyle &= ~LVS_LIST;

        SetWindowLong(hwndLV, GWL_STYLE, lStyle | LVS_REPORT);
    }

    //
    // Set the columns
    //
    GetClientRect(hwndLV, &rc);

    lvColumn.mask = LVCF_SUBITEM|LVCF_WIDTH;
    lvColumn.cx = rc.right - GetSystemMetrics(SM_CXBORDER);
    lvColumn.iSubItem = 0;

    ListView_InsertColumn(hwndLV, 0, &lvColumn);

    return S_OK;
}

HRESULT CFTAdvDlg::_UpdateActionButtons()
{
    HRESULT hres = E_FAIL;
    TCHAR szAction[MAX_ACTION];
    BOOL bRet = FALSE;

    LVITEM lvItem = {0};
    lvItem.pszText = szAction;
    lvItem.cchTextMax = ARRAYSIZE(szAction);

    bRet = _GetListViewSelectedItem(LVIF_TEXT | LVIF_PARAM, 0, &lvItem);

    // If we don't have a selected item Or we don't have any text for that item.
    if (!bRet || !(*(lvItem.pszText)))
    {
        EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_EDIT), FALSE);
        EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_REMOVE), FALSE);
        EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_DEFAULT), TRUE);        

        hres = S_OK;
    }
    else
    {
        if (_IsNewPROGIDACTION(lvItem.pszText))
        {
            EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_EDIT), TRUE);
            EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_REMOVE), TRUE);

            hres = S_OK;
        }
        else
        {
            IAssocInfo* pAI = NULL;

            hres = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);
            if (SUCCEEDED(hres))
            {
                DWORD dwAttributes;
                HWND hwndLV = _GetLVHWND();

                // REARCHITECT: This code should be in ftassoc.cpp, and we should have
                // more AIBOOL_ flags for this
                hres = pAI->GetDWORD(AIDWORD_PROGIDEDITFLAGS, &dwAttributes);

                if (FAILED(hres))
                {
                    // It failed, probably there is no EditFlags value for this progID, let's
                    // set some default value for dwAttributes
                    dwAttributes = 0;
                }
                // REARCHITECT (end)

                EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_EDIT),
                    !((dwAttributes & FTA_NoEditVerb) &&
                    !(dwAttributes & FTAV_UserDefVerb)));

                EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_REMOVE),
                    !((dwAttributes & FTA_NoRemoveVerb) &&
                    !(dwAttributes & FTAV_UserDefVerb)));

                EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_DEFAULT),
                    !(dwAttributes & FTA_NoEditDflt));  

                // Enable the default button only if the action is not already
                // the default action
                EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_DEFAULT),
                    !_IsDefaultAction(ADDDATA_ACTIONREG(&lvItem)));

                pAI->Release();
            }
        }
    }

    return hres;
}

HRESULT CFTAdvDlg::_UpdateCheckBoxes()
{
    BOOL fBool;

    IAssocInfo* pAI = NULL;

    HRESULT hres = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);
    if (SUCCEEDED(hres))
    {
        hres = pAI->GetBOOL(AIBOOL_CONFIRMOPEN, &fBool);

        if (SUCCEEDED(hres))
            CheckDlgButton(_hwnd, IDC_FT_EDIT_CONFIRM_OPEN, !fBool);

        hres = pAI->GetBOOL(AIBOOL_ALWAYSSHOWEXT, &fBool);

        if (SUCCEEDED(hres))
            CheckDlgButton(_hwnd, IDC_FT_EDIT_SHOWEXT, fBool);

        hres = pAI->GetBOOL(AIBOOL_BROWSEINPLACEENABLED, &fBool);

        if (SUCCEEDED(hres))
        {
            EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_BROWSEINPLACE), fBool);

            if (fBool)
            {
                hres = pAI->GetBOOL(AIBOOL_BROWSEINPLACE, &fBool);

                if (SUCCEEDED(hres))
                    CheckDlgButton(_hwnd, IDC_FT_EDIT_BROWSEINPLACE, fBool);
            }
            else
                CheckDlgButton(_hwnd, IDC_FT_EDIT_BROWSEINPLACE, FALSE);
        }
        pAI->Release();
    }

    return hres;
}

HRESULT CFTAdvDlg::_InitChangeIconButton()
{
    HRESULT hres = E_FAIL;
    BOOL fChangeIcon = TRUE;

    IAssocInfo* pAI = NULL;

    hres = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);

    if (SUCCEEDED(hres))
    {
        hres = pAI->GetBOOL(AIBOOL_EDITDOCICON, &fChangeIcon);
    
        if (SUCCEEDED(hres))
            EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_CHANGEICON), fChangeIcon);

        pAI->Release();
    }

    return hres;
}

HRESULT CFTAdvDlg::_InitDescription()
{
    HRESULT hres = E_FAIL;
    BOOL fEditDescr = TRUE;

    IAssocInfo* pAI = NULL;

    hres = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);

    if (SUCCEEDED(hres))
    {
        TCHAR szProgIDDescr[MAX_PROGIDDESCR];
        DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);

        hres = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr, &cchProgIDDescr);
    
        if (SUCCEEDED(hres))
            SetDlgItemText(_hwnd, IDC_FT_EDIT_DESC, szProgIDDescr);

        hres = pAI->GetBOOL(AIBOOL_EDITDESCR, &fEditDescr);

        EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_DESC), fEditDescr);

        pAI->Release();

        Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_EDIT_DESC), MAX_PROGIDDESCR - 1);
    }

    return hres;
}

HRESULT CFTAdvDlg::_FillListView()
{
    HRESULT hres = E_FAIL;

    IEnumAssocInfo* pEnum = NULL;

    hres = _pAssocStore->EnumAssocInfo(ASENUM_ACTION, _szProgID, AIINIT_PROGID, &pEnum);

    if (SUCCEEDED(hres))
    {
        int iItem = 0;
        IAssocInfo* pAI = NULL;

        while (S_OK == pEnum->Next(&pAI))
        {
            TCHAR szActionReg[MAX_ACTION];
            DWORD cchActionReg = ARRAYSIZE(szActionReg);

            hres = pAI->GetString(AISTR_ACTION, szActionReg, &cchActionReg);

            if (SUCCEEDED(hres))
            {
                TCHAR szActionFN[MAX_ACTION];
                DWORD cchActionFN = ARRAYSIZE(szActionFN);

                hres = pAI->GetString(AISTR_ACTIONFRIENDLY, szActionFN, &cchActionFN);

                if (SUCCEEDED(hres))
                {
                    if (S_FALSE == hres)
                    {
                        lstrcpy(szActionFN, szActionReg);
                    }

                    if (-1 != _InsertListViewItem(iItem, szActionReg, szActionFN))
                    {
                        ++iItem;
                    }
                }
            }

            pAI->Release();
        }

        pEnum->Release();
    }

    return hres;
}

LRESULT CFTAdvDlg::OnChangeIcon(WORD wNotif)
{
    IAssocInfo* pAI;
    HRESULT hr = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);
    if (SUCCEEDED(hr))
    {
        DWORD cchIconLoc = ARRAYSIZE(_szOldIconLoc);
        hr = pAI->GetString(AISTR_ICONLOCATION, _szOldIconLoc, &cchIconLoc);
        pAI->Release();

        _iOldIcon = PathParseIconLocation(_szOldIconLoc);
    }

    if (FAILED(hr))
    {
        StrCpyN(_szOldIconLoc, TEXT("shell32.dll"), ARRAYSIZE(_szOldIconLoc));
        _iOldIcon = -(IDI_SYSFILE);

        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        // setup the in params
        int iIcon = _iOldIcon;
        StrCpyN(_szIconLoc, _szOldIconLoc, ARRAYSIZE(_szIconLoc));

        if (PickIconDlg(_hwnd, _szIconLoc, ARRAYSIZE(_szIconLoc), &iIcon))
        {
            _SetDocIcon(Shell_GetCachedImageIndex(_szIconLoc, iIcon, 0));

            // Format the _szIconLoc
            int iLen = lstrlen(_szIconLoc);

            wnsprintf(_szIconLoc + iLen, ARRAYSIZE(_szIconLoc) - iLen, TEXT(",%d"), iIcon);
        }
        else
        {
            _szIconLoc[0] = 0;
        }
    }

    return FALSE;
}

// Return value: 
//  TRUE:  Check succeeded, everything is OK
//  FALSE: Check failed
BOOL CFTAdvDlg::_CheckForDuplicateNewAction(LPTSTR pszActionReg, LPTSTR pszActionFN)
{
    // we just go through the listview content
    HWND hwndLV = _GetLVHWND();
    int cItem = ListView_GetItemCount(hwndLV);
    BOOL fRet = TRUE;

    for (int i = 0; (i < cItem) && fRet; ++i)
    {
        TCHAR szActionFN[MAX_ACTION];
        LVITEM lvItem = {0};

        lvItem.mask = LVIF_PARAM | LVIF_TEXT;
        lvItem.iItem = i;
        lvItem.pszText = szActionFN;
        lvItem.cchTextMax = ARRAYSIZE(szActionFN);

        ListView_GetItem(hwndLV, &lvItem);

        if (!lstrcmpi(lvItem.pszText, pszActionFN))
        {
            fRet = FALSE;
        }
        else
        {
            if (!lstrcmpi(ADDDATA_ACTIONREG(&lvItem), pszActionReg))
            {
                fRet = FALSE;
            }
        }
    }

    return fRet;
}

// Return value: 
//  TRUE:  Check succeeded, everything is OK
//  FALSE: Check failed
BOOL CFTAdvDlg::_CheckForDuplicateEditAction(LPTSTR pszActionRegOriginal, LPTSTR pszActionReg,
                                             LPTSTR pszActionFNOriginal, LPTSTR pszActionFN)
{
    // we just go through the listview content
    HWND hwndLV = _GetLVHWND();
    int cItem = ListView_GetItemCount(hwndLV);
    BOOL fRet = TRUE;

    for (int i = 0; (i < cItem) && fRet; ++i)
    {
        TCHAR szActionFN[MAX_ACTION];
        LVITEM lvItem = {0};

        lvItem.mask = LVIF_PARAM | LVIF_TEXT;
        lvItem.iItem = i;
        lvItem.pszText = szActionFN;
        lvItem.cchTextMax = ARRAYSIZE(szActionFN);

        ListView_GetItem(hwndLV, &lvItem);

        if (!lstrcmpi(lvItem.pszText, pszActionFN))
        {
            // they are the same, this can happen if this is the Action we were editing
            // and we did not change the action name

            // Is this the original one we were editing?
            if (lstrcmpi(szActionFN, pszActionFNOriginal))
            {
                // No, it's not the original, we have a dup
                fRet = FALSE;
            }
        }
        else
        {
            if (!lstrcmpi(ADDDATA_ACTIONREG(&lvItem), pszActionReg))
            {
                // they are the same, this can happen if this is the Action we were editing
                // and we did not change the action name

                // Is this the original one we were editing?
                if (lstrcmpi(ADDDATA_ACTIONREG(&lvItem), pszActionRegOriginal))
                {
                    // No, it's not the original, we have a dup
                    fRet = FALSE;
                }
            }
        }
    }

    return fRet;
}

LRESULT CFTAdvDlg::OnNewButton(WORD wNotif)
{
    TCHAR szProgIDDescr[MAX_PROGIDDESCR];
    PROGIDACTION pida = {0};
    CFTActionDlg* pActionDlg = NULL;

    pida.fNew = TRUE;

    GetDlgItemText(_hwnd, IDC_FT_EDIT_DESC, szProgIDDescr, ARRAYSIZE(szProgIDDescr));

    // FALSE: New (not-Edit)
    pActionDlg = new CFTActionDlg(&pida, szProgIDDescr, FALSE);

    if (pActionDlg)
    {
        BOOL fShowAgain;

        do
        {
            fShowAgain = FALSE;

            if (IDOK == pActionDlg->DoModal(g_hinst, MAKEINTRESOURCE(DLG_FILETYPEOPTIONSCMD), _hwnd))
            {
                // Do we have duplicate actions?
                if (_CheckForDuplicateNewAction(pida.szActionReg, pida.szAction))
                {
                    // No
                    HRESULT hres = _AppendPROGIDACTION(&pida);

                    if (SUCCEEDED(hres))
                    {
                        int iItem = _InsertListViewItem(0, pida.szActionReg, pida.szAction);

                        hres = S_OK;

                        if (-1 != iItem)
                            _SelectListViewItem(iItem);
                    }
                }
                else
                {
                    // Yes
                    fShowAgain = TRUE;

                    pActionDlg->SetShowAgain();
                }
            }

            if (fShowAgain)
            {
                ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_EXISTINGACTION), 
                    MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP, pida.szAction);
            }

        } while (fShowAgain);

        pActionDlg->Release();
    }

    _CheckDefaultAction();

    return FALSE;
}

LRESULT CFTAdvDlg::OnEditButton(WORD wNotif)
{
    TCHAR szAction[MAX_ACTION];
    HRESULT hres = E_FAIL;
    LONG lRes = 0;

    LVITEM lvItem = {0};
    // lvItem.iSubItem = 0;
    lvItem.pszText = szAction;
    lvItem.cchTextMax = ARRAYSIZE(szAction);

    if (_GetListViewSelectedItem(LVIF_TEXT, 0, &lvItem))
    {
        TCHAR szProgIDDescr[MAX_PROGIDDESCR];
        PROGIDACTION* pPIDA = NULL;
        PROGIDACTION pida = {0};

        GetDlgItemText(_hwnd, IDC_FT_EDIT_DESC, szProgIDDescr, ARRAYSIZE(szProgIDDescr));

        BOOL fNewOrEdit = SUCCEEDED(_GetPROGIDACTION(lvItem.pszText, &pPIDA));

        if (!fNewOrEdit)
        {
            hres = _FillPROGIDACTION(&pida, ADDDATA_ACTIONREG(&lvItem), szAction);

            pPIDA = &pida;
        }
        else
        {
            hres = S_OK;
        }

        if (SUCCEEDED(hres))
        {
            // TRUE: Edit
            CFTActionDlg* pActionDlg = new CFTActionDlg(pPIDA, szProgIDDescr, TRUE);

            if (pActionDlg)
            {
                BOOL fShowAgain;

                do
                {
                    fShowAgain = FALSE;

                    if (IDOK == pActionDlg->DoModal(g_hinst, MAKEINTRESOURCE(DLG_FILETYPEOPTIONSCMD), _hwnd))
                    {
                        // Do we have duplicate actions?
                        if (_CheckForDuplicateEditAction(ADDDATA_ACTIONREG(&lvItem), pPIDA->szActionReg,
                            lvItem.pszText, pPIDA->szAction))
                        {
                            // No
                            if (!fNewOrEdit)
                            {
                                hres = _AppendPROGIDACTION(pPIDA);
                            }
                            else
                            {
                                hres = S_OK;
                            }

                            if (SUCCEEDED(hres))
                            {
                                // Replace the current item text
                                StrCpyN(lvItem.pszText, pPIDA->szAction, ARRAYSIZE(pPIDA->szAction));

                                ListView_SetItem(_GetLVHWND(), &lvItem);
                            }
                        }
                        else
                        {
                            // Yes
                            fShowAgain = TRUE;

                            pActionDlg->SetShowAgain();
                        }
                    }

                    if (fShowAgain)
                    {
                        ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_EXISTINGACTION), 
                            MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP, pPIDA->szAction);
                    }

                } while (fShowAgain);

                pActionDlg->Release();
            }
        }
    }

    return FALSE;
}

LRESULT CFTAdvDlg::OnSetDefault(WORD wNotif)
{
    BOOL bRet;
    LVITEM lvItem = {0};
    // lvItem.iSubItem = 0;

    bRet = _GetListViewSelectedItem(0, 0, &lvItem);

    if (bRet)
        _SetDefaultAction(lvItem.iItem);
    else
        _SetDefaultAction(-1);
        
    return FALSE;
}

LRESULT CFTAdvDlg::OnRemoveButton(WORD wNotif)
{
    TCHAR szExt[MAX_EXT];
    HRESULT hres = E_FAIL;
    LONG lRes = 0;

    LVITEM lvItem = {0};
    // lvItem.iSubItem = 0;
    lvItem.pszText = szExt;
    lvItem.cchTextMax = ARRAYSIZE(szExt);

    if (_GetListViewSelectedItem(LVIF_TEXT, 0, &lvItem))
    {
        if (IDYES == ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_REMOVEACTION),
            MAKEINTRESOURCE(IDS_FT), MB_YESNO | MB_ICONQUESTION))
        {
            //
            // First take care of data side
            //

            // Yes.  Is this a new Action?
            PROGIDACTION* pPIDA = NULL;
            if (SUCCEEDED(_GetPROGIDACTION(lvItem.pszText, &pPIDA)) && pPIDA->fNew)
            {
                // Yes, we'll just remove it from the DPA
                hres = _RemovePROGIDACTION(pPIDA);
            }
            else
            {
                // No, add its name to the list to delete if user press OK
                DWORD cchSize = ARRAYSIZE(ADDDATA_ACTIONREG(&lvItem));

                LPTSTR pszActionToRemove = (LPTSTR)LocalAlloc(LPTR, 
                    cchSize * sizeof(TCHAR));
                hres = E_OUTOFMEMORY;

                if (pszActionToRemove)
                {
                    StrCpyN(pszActionToRemove, ADDDATA_ACTIONREG(&lvItem), cchSize);

                    if (-1 != DPA_AppendPtr(_hdpaRemovedActions, pszActionToRemove))
                        hres = S_OK;
                    else
                        LocalFree((HLOCAL)pszActionToRemove);
                }

                if (E_OUTOFMEMORY == hres)
                {
                    //Out of memory
                    ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_ERROR + 
                        ERROR_NOT_ENOUGH_MEMORY), MAKEINTRESOURCE(IDS_FT), 
                        MB_OK | MB_ICONSTOP);
                }
            }

            //
            // Then update UI, I/A
            //
            if (SUCCEEDED(hres))
            {
                HWND hwndLV = _GetLVHWND();
                int iCount = ListView_GetItemCount(hwndLV);
                int iNextSel = -1;        
        
                ListView_DeleteItem(hwndLV, lvItem.iItem);
        
                if (iCount > lvItem.iItem)
                    iNextSel = lvItem.iItem;
                else
                    if (lvItem.iItem > 0)
                        iNextSel = lvItem.iItem - 1;

                if (-1 != iNextSel)
                    _SelectListViewItem(iNextSel);
            }
        }
        else
            hres = S_FALSE;
    }
    
    _CheckDefaultAction();

    return FALSE;
}

LRESULT CFTAdvDlg::OnOK(WORD wNotif)
{
    BOOL fChecksPassed = FALSE;

    // Yes, we need to:
    //  - remove "removed" items, modify "edited" ones,
    //    and add "New" ones
    //  - update checkboxes related stuff
    //  - set the default action
    //  - set the icon
    //  - set the description
    {
        int n = DPA_GetPtrCount(_hdpaRemovedActions);

        if (n)
        {
            IAssocInfo* pAI;
            HRESULT hres = E_FAIL;

            for (int i = 0; i < n; ++i)
            {
                LPTSTR pszActionToRemove = (LPTSTR)DPA_GetPtr(_hdpaRemovedActions, i);

                if (pszActionToRemove && *pszActionToRemove)
                {
                    hres = _pAssocStore->GetComplexAssocInfo(_szProgID, AIINIT_PROGID, 
                        pszActionToRemove, AIINIT_ACTION, &pAI);

                    if (SUCCEEDED(hres))
                    {
                        pAI->Delete(AIALL_NONE);
                        pAI->Release();
                    }

                    LocalFree((HLOCAL)pszActionToRemove);
                    DPA_DeletePtr(_hdpaRemovedActions, i);
                }
            }
        }
    }
    {
        int n = DPA_GetPtrCount(_hdpaActions);

        if (n)
        {
            IAssocInfo* pAI = NULL;
            HRESULT hres = E_FAIL;

            for (int i = n - 1; i >= 0; --i)
            {
                PROGIDACTION* pPIDAFromList = (PROGIDACTION*)DPA_GetPtr(_hdpaActions, i);

                if (pPIDAFromList)
                {   
                    // Is it an Edited one?
                    if (!pPIDAFromList->fNew)
                    {
                        // Yes, remove the old one first
                        hres = _pAssocStore->GetComplexAssocInfo(_szProgID, AIINIT_PROGID, 
                            pPIDAFromList->szOldActionReg, AIINIT_ACTION, &pAI);

                        if (SUCCEEDED(hres))
                        {
                            pAI->Delete(AIALL_NONE);                        
                            pAI->Release();
                        }
                    }

                    // Add new data
                    hres = _pAssocStore->GetComplexAssocInfo(_szProgID, AIINIT_PROGID, 
                        pPIDAFromList->szActionReg, AIINIT_ACTION, &pAI);

                    if (SUCCEEDED(hres))
                    {
                        hres = pAI->SetData(AIDATA_PROGIDACTION, (PBYTE)pPIDAFromList,
                            sizeof(*pPIDAFromList));

                        pAI->Release();
                    }

                    // Clean up DPA
                    _DeletePROGIDACTION(pPIDAFromList);

                    DPA_DeletePtr(_hdpaActions, i);
                }
            }
        }
    }
    {
        IAssocInfo* pAI = NULL;
        HWND hwndLV = _GetLVHWND();
        LVFINDINFO lvFindInfo = {0};
        int iIndex = -1;
        HRESULT hres = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);

        if (SUCCEEDED(hres))
        {
            TCHAR szActionReg[MAX_ACTION];

            hres = pAI->SetBOOL(AIBOOL_CONFIRMOPEN, 
                !IsDlgButtonChecked(_hwnd, IDC_FT_EDIT_CONFIRM_OPEN));

            hres = pAI->SetBOOL(AIBOOL_ALWAYSSHOWEXT, 
                IsDlgButtonChecked(_hwnd, IDC_FT_EDIT_SHOWEXT));

            hres = pAI->SetBOOL(AIBOOL_BROWSEINPLACE, 
                IsDlgButtonChecked(_hwnd, IDC_FT_EDIT_BROWSEINPLACE));

            // Set the default action, if any
            if (_GetDefaultAction(szActionReg, ARRAYSIZE(szActionReg)))
            {
                hres = pAI->SetString(AISTR_PROGIDDEFAULTACTION, szActionReg);
            }
            else
            {
                hres = pAI->SetString(AISTR_PROGIDDEFAULTACTION, TEXT(""));
            }

            // Set the icon, if changed
            if (_szIconLoc[0])
            {
                // Set it in the registry
                hres = pAI->SetString(AISTR_ICONLOCATION, _szIconLoc);
                if (_szOldIconLoc[0])
                {
                    int iIconIndex = Shell_GetCachedImageIndex(_szOldIconLoc, _iOldIcon, 0);

                    SHUpdateImage(_szOldIconLoc, _iOldIcon, 0, iIconIndex);
                }
            }

            // Set the description
            {
                TCHAR szProgIDDescr[MAX_PROGIDDESCR];

                GetDlgItemText(_hwnd, IDC_FT_EDIT_DESC, szProgIDDescr,
                    ARRAYSIZE(szProgIDDescr));

                hres = pAI->SetString(AISTR_PROGIDDESCR, szProgIDDescr);
            }

            pAI->Release();
        }
    }

    EndDialog(_hwnd, IDOK);

    return FALSE;
}

LRESULT CFTAdvDlg::OnNotifyListView(UINT uCode, LPNMHDR pNMHDR)
{
    HWND hwndLV = _GetLVHWND();
    LRESULT lres = FALSE;

    switch(uCode)
    {
        case NM_DBLCLK:
            if (IsWindowEnabled(GetDlgItem(_hwnd, IDC_FT_EDIT_EDIT)))
                PostMessage(_hwnd, WM_COMMAND, (WPARAM)IDC_FT_EDIT_EDIT, 0);

            break;
//review: do I really need to do this?
        case NM_SETFOCUS:
        case NM_KILLFOCUS:
            // update list view
            ListView_RedrawItems(hwndLV, 0, ListView_GetItemCount(hwndLV));
            UpdateWindow(hwndLV);
            break;

        case LVN_DELETEITEM:
        {
            NMLISTVIEW* pNMLV = (NMLISTVIEW*)pNMHDR;

            if (pNMLV->lParam)
            {
                LocalFree((HLOCAL)(pNMLV->lParam));
            }

            break;
        }

        case LVN_ITEMCHANGED:
        {
            NMLISTVIEW* pNMLV = (NMLISTVIEW*)pNMHDR;

            // Is a new item being selected/unselected? 
            if (pNMLV->uChanged & LVIF_STATE)
            {
                // Yes
                OnListViewSelItem(pNMLV->iItem, NULL);
            }
            break;
        }
    }

    return lres;
}

LRESULT CFTAdvDlg::OnCancel(WORD wNotif)
{
    EndDialog(_hwnd, IDCANCEL);

    return FALSE;
}

LRESULT CFTAdvDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    CFTDlg::OnDestroy(wParam, lParam);

    return FALSE;
}

BOOL CFTAdvDlg::_GetListViewSelectedItem(UINT uMask, UINT uStateMask, LVITEM* plvItem)
{
    BOOL fSel = FALSE;
    HWND hwndLV = _GetLVHWND();

    plvItem->mask = uMask | LVIF_STATE | LVIF_PARAM;
    plvItem->stateMask = uStateMask | LVIS_SELECTED;

    // Do we have the selection cached?
    if (-1 != _iLVSel)
    {
        // Yes, make sure it's valid
        plvItem->iItem = _iLVSel;

        ListView_GetItem(hwndLV, plvItem);

        if (plvItem->state & LVIS_SELECTED)
            fSel = TRUE;
    }
 
    // Cache was wrong
    if (!fSel)
    {
        int iCount = ListView_GetItemCount(hwndLV);

        for (int i=0; (i < iCount) && !fSel; ++i)
        {
            plvItem->iItem = i;
            ListView_GetItem(hwndLV, plvItem);

            if (plvItem->state & LVIS_SELECTED)
                fSel = TRUE;
        }

        if (fSel)
            _iLVSel = i;
    }

    return fSel;
}

int CFTAdvDlg::_InsertListViewItem(int iItem, LPTSTR pszActionReg, LPTSTR pszActionFN)
{
    int iRet = -1;
    HWND hwndLV = _GetLVHWND();
    LVITEM lvItem = {0};
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;

    // Extension
    lvItem.iItem = iItem;
    lvItem.pszText = pszActionFN;
    lvItem.cchTextMax = lstrlen(pszActionFN);

    LV_ADDDATA* plvadddata = (LV_ADDDATA*)LocalAlloc(LPTR, sizeof(LV_ADDDATA));

    if (plvadddata)
    {
        lvItem.lParam = (LPARAM)plvadddata;
        StrCpyN(ADDDATA_ACTIONREG(&lvItem), pszActionReg, ARRAYSIZE(ADDDATA_ACTIONREG(&lvItem)));
        ADDDATA_DEFAULTACTION(&lvItem) = 0;

        iRet = ListView_InsertItem(hwndLV, &lvItem);
    }
    
    return iRet;
}

HWND CFTAdvDlg::_GetLVHWND()
{
    return GetDlgItem(_hwnd, IDC_FT_EDIT_LV_CMDS);
}

void CFTAdvDlg::_DeletePROGIDACTION(PROGIDACTION* pPIDA)
{
    if (pPIDA)
        LocalFree((HLOCAL)pPIDA);
}

HRESULT CFTAdvDlg::_RemovePROGIDACTION(PROGIDACTION* pPIDA)
{
    HRESULT hres = E_FAIL;

    int n = DPA_GetPtrCount(_hdpaActions);

    for (int i = 0; (i < n) && FAILED(hres); ++i)
    {
        PROGIDACTION* pPIDAFromList = (PROGIDACTION*)DPA_GetPtr(_hdpaActions, i);

        if (pPIDAFromList == pPIDA)
        {
            _DeletePROGIDACTION(pPIDAFromList);

            DPA_DeletePtr(_hdpaActions, i);

            hres = S_OK;
        }
    }

    return hres;
}

HRESULT CFTAdvDlg::_CreatePROGIDACTION(PROGIDACTION** ppPIDA)
{
    HRESULT hres = E_OUTOFMEMORY;

    *ppPIDA = (PROGIDACTION*)LocalAlloc(LPTR, sizeof(PROGIDACTION));
    
    if (*ppPIDA)
        hres = S_OK;

    return hres;
}

HRESULT CFTAdvDlg::_CopyPROGIDACTION(PROGIDACTION* pPIDADest, PROGIDACTION* pPIDASrc)
{
    memcpy(pPIDADest, pPIDASrc, sizeof(PROGIDACTION));

    return S_OK;
}

HRESULT CFTAdvDlg::_GetPROGIDACTION(LPTSTR pszActionFN, PROGIDACTION** ppPIDA)
{
    HRESULT hres = E_FAIL;

    *ppPIDA = NULL;

    if (pszActionFN && *pszActionFN)
    {
        int n = DPA_GetPtrCount(_hdpaActions);

        for (int i = 0; (i < n) && FAILED(hres); ++i)
        {
            *ppPIDA = (PROGIDACTION*)DPA_GetPtr(_hdpaActions, i);

            if (!StrCmpN((*ppPIDA)->szAction, pszActionFN, ARRAYSIZE((*ppPIDA)->szAction)))
                hres = S_OK;
        }
    }

    if (FAILED(hres))
        *ppPIDA = NULL;

    return hres;
}

HRESULT CFTAdvDlg::_AppendPROGIDACTION(PROGIDACTION* pPIDA)
{
    PROGIDACTION* pPIDANew = NULL;

    HRESULT hres = _CreatePROGIDACTION(&pPIDANew);

    if (SUCCEEDED(hres))
    {
        _CopyPROGIDACTION(pPIDANew, pPIDA);

        if (-1 != DPA_AppendPtr(_hdpaActions, pPIDANew))
        {
            hres = S_OK;
        }
        else
        {
            _DeletePROGIDACTION(pPIDANew);

            hres = E_OUTOFMEMORY;
        }
    }

    if (E_OUTOFMEMORY == hres)
    {
        //Out of memory
        ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_ERROR + 
            ERROR_NOT_ENOUGH_MEMORY), MAKEINTRESOURCE(IDS_FT), 
            MB_OK | MB_ICONSTOP);
    }

    return hres;
}

BOOL CFTAdvDlg::_IsNewPROGIDACTION(LPTSTR pszActionFN)
{
    BOOL fRet = FALSE;
    PROGIDACTION* pPIDA = NULL;

    HRESULT hres = _GetPROGIDACTION(pszActionFN, &pPIDA);

    if (SUCCEEDED(hres))
        if (pPIDA->fNew)
            fRet = TRUE;

    return fRet;
}

HRESULT CFTAdvDlg::_FillPROGIDACTION(PROGIDACTION* pPIDA, LPTSTR pszActionReg,
                                     LPTSTR pszActionFN)
{
    PROGIDACTION* pPIDAList = NULL;
    HRESULT hres = _GetPROGIDACTION(pszActionFN, &pPIDAList);

    if (SUCCEEDED(hres))
    {
        _CopyPROGIDACTION(pPIDA, pPIDAList);
    }
    else
    {
        IAssocInfo* pAI = NULL;

        hres = _pAssocStore->GetComplexAssocInfo(_szProgID, AIINIT_PROGID, 
            pszActionReg, AIINIT_ACTION, &pAI);

        if (SUCCEEDED(hres))
        {
            DWORD cbPIDA = sizeof(*pPIDA);

            hres = pAI->GetData(AIDATA_PROGIDACTION, (PBYTE)pPIDA, &cbPIDA);

            pAI->Release();
        }
    }

    return hres;    
}

///////////////////////////////////////////////////////////////////////////////
// Windows boiler plate code
LRESULT CFTAdvDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_FT_EDIT_NEW:
            lRes = OnNewButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_EDIT_REMOVE:
            lRes = OnRemoveButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_EDIT_EDIT:
            lRes = OnEditButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_EDIT_CHANGEICON:
            lRes = OnChangeIcon(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_EDIT_DEFAULT:
            lRes = OnSetDefault(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        default:
            lRes = CFTDlg::OnCommand(wParam, lParam);
            break;
    }

    return lRes;    
}

LRESULT CFTAdvDlg::OnNotify(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    LPNMHDR pNMHDR = (LPNMHDR)lParam;
    UINT_PTR idFrom = pNMHDR->idFrom;
    UINT uCode = pNMHDR->code;

    //GET_WM_COMMAND_CMD
    switch(idFrom)
    {
        case IDC_FT_EDIT_LV_CMDS:
            OnNotifyListView(uCode, pNMHDR);
            lRes = CFTDlg::OnNotify(wParam, lParam);
            break;
        default:
            lRes = CFTDlg::OnNotify(wParam, lParam);
            break;
    }

    return lRes;    
}

LRESULT CFTAdvDlg::WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(uMsg)
    {
        case WM_DRAWITEM:
            lRes = OnDrawItem(wParam, lParam);
            break;

        case WM_MEASUREITEM:
            lRes = OnMeasureItem(wParam, lParam);
            break;

        default:
            lRes = CFTDlg::WndProc(uMsg, wParam, lParam);
            break;
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftascstr.h ===
#ifndef FTASCSTR_H
#define FTASCSTR_H

#include "ascstr.h"

class CFTAssocStore : public IAssocStore
{
public:
    CFTAssocStore();
    ~CFTAssocStore();
public:
	//IUnknown methods
	STDMETHOD(QueryInterface)(REFIID riid, PVOID* ppv);
	STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

	//IAssocStore methods
    //	Enum
    STDMETHOD(EnumAssocInfo)(ASENUM asenumFlags, LPTSTR pszStr, 
		AIINIT aiinitFlags, IEnumAssocInfo** ppEnum);
    //  Get/Set
    STDMETHOD(GetAssocInfo)(LPTSTR pszStr, AIINIT aiinitFlags, 
		IAssocInfo** ppAI);
    STDMETHOD(GetComplexAssocInfo)(LPTSTR pszStr1, AIINIT aiinitFlags1, 
		LPTSTR pszStr2, AIINIT aiinitFlags2, IAssocInfo** ppAI);

    // S_OK: We have create/delete access,
    // S_FALSE: we do not have create and/or delete access to HKCR
    STDMETHOD(CheckAccess)();

private:
	friend class CFTEnumAssocInfo;
	static HRESULT __GetProgIDDescr(LPTSTR pszProgID, LPTSTR pszProgIDdescr,
		                    DWORD cchProgIDdescr);
private:
    HRESULT                _hresCoInit;
    LONG                   _cRef;
    static HRESULT         _hresAccess;
};

#endif //FTASCSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftascstr.cpp ===
#include "shellprv.h"
#include "ftascstr.h"
#include "ftassoc.h" //for now, until use CoCreateInstance
#include "ftenum.h" //for now, until use CoCreateInstance

HRESULT CFTAssocStore::_hresAccess = -1;

HRESULT CFTAssocStore::EnumAssocInfo(ASENUM asenumFlags, LPTSTR pszStr, 
        AIINIT aiinitFlags, IEnumAssocInfo** ppEnum)
{
    //for now
    *ppEnum = new CFTEnumAssocInfo();

    if (*ppEnum)
    {
        (*ppEnum)->Init(asenumFlags, pszStr, aiinitFlags);
    }

    return (*ppEnum) ? S_OK : E_OUTOFMEMORY;
}

HRESULT CFTAssocStore::GetAssocInfo(LPTSTR pszStr, AIINIT aiinitFlags, IAssocInfo** ppAI)
{
    HRESULT hres = E_FAIL;

    *ppAI = new CFTAssocInfo();

    if (*ppAI)
        hres = (*ppAI)->Init(aiinitFlags, pszStr);
    else
        hres = E_OUTOFMEMORY;

    return hres;
}

HRESULT CFTAssocStore::GetComplexAssocInfo(LPTSTR pszStr1, AIINIT aiinitFlags1, 
    LPTSTR pszStr2, AIINIT aiinitFlags2, IAssocInfo** ppAI)
{
    HRESULT hres = E_FAIL;

    *ppAI = new CFTAssocInfo();

    if (*ppAI)
        hres = (*ppAI)->InitComplex(aiinitFlags1, pszStr1, aiinitFlags2, pszStr2);
    else
        hres = E_OUTOFMEMORY;

    return hres;
}

HRESULT CFTAssocStore::CheckAccess()
{
#if 0
    // Should be something like this but it does not work

    if (-1 == _hresAccess)
    {
        HKEY hkey;

        _hresAccess = S_FALSE;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, NULL, 0,
            KEY_CREATE_SUB_KEY | KEY_READ | KEY_SET_VALUE | KEY_QUERY_VALUE, &hkey))
        {
            _hresAccess = S_OK;

            RegCloseKey(hkey);
        }
    }
#endif

    if (-1 == _hresAccess)
    {
        TCHAR szGUID[] = TEXT("{A4BFEC7C-F821-11d2-86BE-0000F8757D7E}");
        DWORD dwDisp = 0;
        int cTry = 0;
        HKEY hkey;

        _hresAccess = S_FALSE;

        // we want to try this only two times
        while ((S_FALSE == _hresAccess) && (cTry <= 1))
        {
            ++cTry;

            // we try to write a GUID to HKCR and delete it
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, szGUID, 0, NULL, REG_OPTION_NON_VOLATILE,
                MAXIMUM_ALLOWED, NULL, &hkey, &dwDisp))
            {
                // Did we really created a new key?
                if (REG_CREATED_NEW_KEY == dwDisp)
                {
                    // yes
                    RegCloseKey(hkey);

                    if (ERROR_SUCCESS == RegDeleteKey(HKEY_CLASSES_ROOT, szGUID))
                    {
                        _hresAccess = S_OK;
                    }
                }
                else
                {
                    // No, there was already one, maybe we crashed right in the middle of this fct
                    // some other time in the past

                    // delete the key and try again
                    RegDeleteKey(HKEY_CLASSES_ROOT, szGUID);
                }
            }
        }
    }

    return _hresAccess;
}
///////////////////////////////////////////////////////////////////////////////
//
CFTAssocStore::CFTAssocStore()
{
    _hresCoInit = SHCoInitialize();

    //DLLAddRef();
}

CFTAssocStore::~CFTAssocStore()
{
    //DLLRelease();
    SHCoUninitialize(_hresCoInit);
}

//IUnknown methods
HRESULT CFTAssocStore::QueryInterface(REFIID riid, PVOID* ppv)
{
#if 0
    static const QITAB qit[] = {
      QITABENT(CFTAssocStore, IAssocStore),
      { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
#endif

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IUnknown*>(this);
    else
        *ppv = static_cast<IAssocStore*>(this);

    return S_OK;
}

ULONG CFTAssocStore::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFTAssocStore::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftassoc.h ===
#ifndef FTASSOC_H
#define FTASSOC_H

#include "ascstr.h"
#include "regsprtb.h"

class CFTAssocInfo : public IAssocInfo, private CRegSupportBuf
{
public:
    CFTAssocInfo();

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, PVOID* ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IAssocInfo methods
    //  Init
    STDMETHOD(Init)(AIINIT aiinitFlags, LPTSTR pszStr);
    STDMETHOD(InitComplex)(AIINIT aiinitFlags1, LPTSTR pszStr1,
        AIINIT aiinitFlags2, LPTSTR pszStr2);
    //  Get
    STDMETHOD(GetString)(AISTR aistrFlags, LPTSTR pszStr, DWORD* cchStr);
    STDMETHOD(GetDWORD)(AIDWORD aidwordFlags, DWORD* pdwdata);
    STDMETHOD(GetBOOL)(AIDWORD aidwordFlags, BOOL* pBool);
    STDMETHOD(GetData)(AIDWORD aidataFlags, PBYTE pbData, DWORD* pcbData);

    //  Set
    STDMETHOD(SetString)(AISTR aistrFlags, LPTSTR pszStr);
    STDMETHOD(SetDWORD)(AIDWORD aidwordFlags, DWORD dwData);
    STDMETHOD(SetBOOL)(AIDWORD aiboolFlags, BOOL fBool);
    STDMETHOD(SetData)(AIDWORD aidataFlags, PBYTE pbData, DWORD cbData);

    //  Create
    STDMETHOD(Create)();

    //  Delete
    STDMETHOD(DelString)(AISTR aistrFlags);
    STDMETHOD(Delete)(AIALL aiallFlags);

protected:
    HRESULT _IsBrowseInPlace(BOOL* pfBool);
    HRESULT _SetBrowseInPlace(BOOL fBool);
    HRESULT _IsBrowseInPlaceEnabled(BOOL* pfBool);

    HRESULT _IsEditFlagSet(DWORD dwMask, BOOL* pfBool);
    HRESULT _SetEditFlagSet(DWORD dwMask, BOOL fBool);

    HRESULT _CreateProgID();
    HRESULT _GetProgIDActionAttributes(DWORD* pdwAttributes);
    HRESULT _GetProgIDEditFlags(DWORD* pdwEditFlags);
    HRESULT _GetOpenWithInfo(LPTSTR pszStr, DWORD* pcchStr);
    HRESULT _ExtIsAssociated(BOOL* pfIsAssociated);
    HRESULT _GetExtDocIcon(LPTSTR pszExt, BOOL fSmall, int* piIcon);
    HRESULT _GetProgIDDocIcon(BOOL fSmall, int* piIcon);
    HRESULT _GetAppIcon(BOOL fSmall, int* piIcon);
    HRESULT _GetIconLocation(LPTSTR pszStr, DWORD* pcchStr);
    HRESULT _SetIconLocation(LPTSTR pszStr);

    HRESULT _GetProgIDDefaultAction(LPTSTR pszStr, DWORD* pcchStr);
    HRESULT _SetProgIDDefaultAction(LPTSTR pszStr);

    HRESULT _GetProgIDDescr(LPTSTR pszProgIDDescr, DWORD* pcchProgIDdescr);

    HRESULT __InitImageLists();

protected:
    HRESULT _OpenSubKey(LPTSTR pszSubKey, REGSAM samDesired, HKEY* phKey);

protected:
    TCHAR                   _szInitStr1[MAX_FTMAX];
    AIINIT                  _aiinitFlags1;
    TCHAR                   _szInitStr2[MAX_FTMAX];
    AIINIT                  _aiinitFlags2;

    static HIMAGELIST       _himlSysSmall;
    static HIMAGELIST       _himlSysLarge;
private:
    LONG                    _cRef;
};

#endif //FTASSOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftassoc.cpp ===
#include "shellprv.h"
#include "filetype.h"

#include "ftascstr.h" //for now, until CoCreateInstance
#include "ftassoc.h"
#include "fassoc.h"

HIMAGELIST CFTAssocInfo::_himlSysSmall = NULL;
HIMAGELIST CFTAssocInfo::_himlSysLarge = NULL;

CFTAssocInfo::CFTAssocInfo() : _cRef(1)
{
}

HRESULT CFTAssocInfo::Init(AIINIT aiinitFlags, LPTSTR pszStr)
{
    HRESULT hres = E_INVALIDARG;

    _aiinitFlags1 = aiinitFlags;
    *_szInitStr2 = 0;
    _aiinitFlags2 = AIINIT_NONE;

    if (!pszStr && (AIINIT_PROGID == aiinitFlags))
    {
        // This happens when we create a new ProgID
        hres = S_OK;
    }
    else
    {
        if (pszStr && *pszStr && (AIINIT_NONE != aiinitFlags))
        {
            if ((AIINIT_EXT == aiinitFlags) && (TEXT('.') != *pszStr))
            {
                *_szInitStr1 = TEXT('.');
                StrCpyN(_szInitStr1 + 1, pszStr, ARRAYSIZE(_szInitStr1) - 1);
            }
            else
                StrCpyN(_szInitStr1, pszStr, ARRAYSIZE(_szInitStr1));

            hres = S_OK;
        }
    }

    // set the info for the registry support
    RSInitRoot(HKEY_CLASSES_ROOT, _szInitStr1, NULL, REG_OPTION_NON_VOLATILE, 
        REG_OPTION_NON_VOLATILE);

    return hres;
}

HRESULT CFTAssocInfo::InitComplex(AIINIT aiinitFlags1, LPTSTR pszStr1,
        AIINIT aiinitFlags2, LPTSTR pszStr2)
{
    HRESULT hres = E_INVALIDARG;

    if ((pszStr1 && *pszStr1 && (AIINIT_NONE != aiinitFlags1)) &&
        (pszStr2 && *pszStr2&& (AIINIT_NONE != aiinitFlags2)))
    {
        TCHAR szSubKey[MAX_PROGID + 7 + MAX_ACTION];

        StrCpyN(_szInitStr1, pszStr1, ARRAYSIZE(_szInitStr1));
        _aiinitFlags1 = aiinitFlags1;
        StrCpyN(_szInitStr2, pszStr2, ARRAYSIZE(_szInitStr2));
        _aiinitFlags2 = aiinitFlags2;

        // set the info for the registry support
        StrCpyN(szSubKey, _szInitStr1, MAX_PROGID);
        lstrcat(szSubKey, TEXT("\\shell"));

        RSInitRoot(HKEY_CLASSES_ROOT, szSubKey, _szInitStr2, REG_OPTION_NON_VOLATILE, 
            REG_OPTION_NON_VOLATILE);

        hres = S_OK;
    }

    return hres;
}

HRESULT CFTAssocInfo::GetString(AISTR aistrFlags, LPTSTR pszStr, DWORD* pcchStr)
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_EXT:
        {
            switch(aistrFlags)
            {
                case AISTR_APPFRIENDLY:
                    hres = _GetOpenWithInfo(pszStr, pcchStr);
                    break;

                case AISTR_EXT:
                    StrCpyN(pszStr, _szInitStr1 + 1, *pcchStr);
                    hres = S_OK;
                    break;

                case AISTR_DOTEXT:
                    StrCpyN(pszStr, _szInitStr1, *pcchStr);
                    hres = S_OK;
                    break;

                case AISTR_PROGID:
                    hres = (RSGetTextValue(NULL, NULL, pszStr, pcchStr) ? S_OK : E_FAIL);
                    break;

		        // We fall back to using the progid for the AISTR_XXX's below
		        case AISTR_ICONLOCATION:
                case AISTR_PROGIDDESCR:
                {
                    TCHAR szProgID[MAX_PROGID];
                    DWORD cchProgID = ARRAYSIZE(szProgID);
                    IAssocInfo* pAI = NULL;
                    CFTAssocStore* pAssocStore = new CFTAssocStore();
                    if ( !pAssocStore )
                    {
                        hres = E_OUTOFMEMORY;
                        break;
                    }

                    hres = pAssocStore->GetAssocInfo(_szInitStr1, AIINIT_EXT, &pAI);

                    if (SUCCEEDED(hres))
                    {
                        hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                        pAI->Release();

                        if (SUCCEEDED(hres))
                        {
                            hres = pAssocStore->GetAssocInfo(szProgID, AIINIT_PROGID, &pAI);

                            if (SUCCEEDED(hres))
                            {
                                hres = pAI->GetString(aistrFlags, pszStr, pcchStr);

                                pAI->Release();
                            }
                        }
                    }

                    delete pAssocStore;

                    break;
                }

                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        case AIINIT_PROGID:
        {
            if (AIINIT_NONE == _aiinitFlags2)
            {
                switch(aistrFlags)
                {
                    case AISTR_PROGIDDEFAULTACTION:
                        hres = _GetProgIDDefaultAction(pszStr, pcchStr);
                        break;

                    case AISTR_ICONLOCATION:
                        hres = _GetIconLocation(pszStr, pcchStr);
                        break;

                    case AISTR_PROGID:
                        StrCpyN(pszStr, _szInitStr1, *pcchStr);
                        hres = S_OK;
                        break;

                    case AISTR_PROGIDDESCR:
                        hres = _GetProgIDDescr(pszStr, pcchStr);
                        break;

                    default:
                        hres = E_INVALIDARG;
                        break;
                }
            }
            else
            {
                if (AIINIT_ACTION == _aiinitFlags2)
                {
                    switch (aistrFlags)
                    {
                        case AISTR_ACTION:
                        {
                            StrCpyN(pszStr, _szInitStr2, *pcchStr);
                            hres = S_OK;
                            break;
                        }
                        case AISTR_ACTIONFRIENDLY:
                        {
                            if (RSGetTextValue(NULL, NULL, pszStr, pcchStr))
                            {
                                if (*pszStr)
                                {
                                    hres = S_OK;
                                }
                                else
                                {
                                    hres = S_FALSE;
                                }
                            }
                            else
                            {
                                hres = S_FALSE;
                            }
                            break;
                        }
                    }
                }
                else
                    hres = E_INVALIDARG;
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }

    return hres;
}

HRESULT CFTAssocInfo::GetDWORD(AIDWORD aidwordFlags, DWORD* pdwData)
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_EXT:
        {
            switch(aidwordFlags)
            {
                case AIDWORD_DOCSMALLICON:
                case AIDWORD_DOCLARGEICON:
                {
                    hres = _GetExtDocIcon(_szInitStr1, 
                        (AIDWORD_DOCSMALLICON == aidwordFlags), (int*)pdwData);

                    if (FAILED(hres))
                    {
                        TCHAR szProgID[MAX_PROGID];
                        DWORD cchProgID = ARRAYSIZE(szProgID);
                        IAssocInfo* pAI = NULL;
                        CFTAssocStore* pAssocStore = new CFTAssocStore();

                        if (pAssocStore)
                        {
                            hres = pAssocStore->GetAssocInfo(_szInitStr1, AIINIT_EXT, &pAI);

                            if (SUCCEEDED(hres))
                            {
                                hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                                pAI->Release();

                                if (SUCCEEDED(hres))
                                {
                                    hres = pAssocStore->GetAssocInfo(szProgID, AIINIT_PROGID, &pAI);

                                    if (SUCCEEDED(hres))
                                    {
                                        hres = pAI->GetDWORD(aidwordFlags, pdwData);

                                        pAI->Release();
                                    }
                                }
                            }

                            delete pAssocStore;
                        }
                    }
                    break;
                }

                case AIDWORD_DOCSMALLICON | AIALL_PERUSER:
                case AIDWORD_APPSMALLICON:
                    hres = _GetAppIcon(TRUE, (int*)pdwData);
                    break;

                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        case AIINIT_PROGID:
        {
            if (AIINIT_NONE == _aiinitFlags2)
            {
                switch(aidwordFlags)
                {
                    case AIDWORD_PROGIDEDITFLAGS:
                        hres = _GetProgIDEditFlags(pdwData);
                        break;
                    case AIDWORD_DOCSMALLICON:
                    case AIDWORD_DOCLARGEICON:
                        hres = _GetProgIDDocIcon((AIDWORD_DOCSMALLICON == aidwordFlags), 
                            (int*)pdwData);
                        break;
                    default:
                        hres = E_INVALIDARG;
                        break;
                }
            }
            else
            {
                hres = E_INVALIDARG;

                if (AIINIT_ACTION == _aiinitFlags2)
                    if (AIDWORD_ACTIONATTRIBUTES == aidwordFlags)
                        hres = _GetProgIDActionAttributes(pdwData);
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }

    return hres;    
}

HRESULT CFTAssocInfo::GetData(AIDWORD aidataFlags, PBYTE pbData, DWORD* pcbData)
{
    HRESULT hres = E_INVALIDARG;

    if ((AIINIT_PROGID == _aiinitFlags1) && (AIINIT_ACTION == _aiinitFlags2) &&
        (AIDATA_PROGIDACTION == aidataFlags))
    {
        LPTSTR pszProgID = _szInitStr1;
        PROGIDACTION* pPIDA = (PROGIDACTION*)pbData;
        LPTSTR pszActionReg = _szInitStr2;
        DWORD cchStr = 0;

        pPIDA->fUseDDE = FALSE;

        StrCpyN(pPIDA->szActionReg, pszActionReg, ARRAYSIZE(pPIDA->szActionReg));
        StrCpyN(pPIDA->szOldActionReg, pszActionReg, ARRAYSIZE(pPIDA->szOldActionReg));

        cchStr = ARRAYSIZE(pPIDA->szAction);

        if (!RSGetTextValue(NULL, NULL, pPIDA->szAction, &cchStr))
        {
            // By default the friendly name will be the same as the reg key name
            StrCpyN(pPIDA->szAction, pszActionReg, ARRAYSIZE(pPIDA->szAction));
        }

        StrCpyN(pPIDA->szOldAction, pPIDA->szAction, ARRAYSIZE(pPIDA->szOldAction));

        cchStr = ARRAYSIZE(pPIDA->szCmdLine);

        hres = AssocQueryString(0, ASSOCSTR_COMMAND, pszProgID, pszActionReg,
            pPIDA->szCmdLine, &cchStr);

        if (SUCCEEDED(hres))
        {
            HRESULT hresTmp = E_FAIL;

            cchStr = ARRAYSIZE(pPIDA->szDDEMsg);
            hresTmp = AssocQueryString(0, ASSOCSTR_DDECOMMAND, pszProgID, pszActionReg,
                pPIDA->szDDEMsg, &cchStr);

            if (SUCCEEDED(hresTmp))
                pPIDA->fUseDDE = TRUE;

            cchStr = ARRAYSIZE(pPIDA->szDDEApplication);
            hresTmp = AssocQueryString(0, ASSOCSTR_DDEAPPLICATION, pszProgID, pszActionReg,
                pPIDA->szDDEApplication, &cchStr);

            if (SUCCEEDED(hresTmp))
                pPIDA->fUseDDE = TRUE;

            cchStr = ARRAYSIZE(pPIDA->szDDEAppNotRunning);
            hresTmp = AssocQueryString(0, ASSOCSTR_DDEIFEXEC, pszProgID, pszActionReg,
                pPIDA->szDDEAppNotRunning, &cchStr);

            if (SUCCEEDED(hresTmp))
                pPIDA->fUseDDE = TRUE;

            cchStr = ARRAYSIZE(pPIDA->szDDETopic);
            hresTmp = AssocQueryString(0, ASSOCSTR_DDETOPIC, pszProgID, pszActionReg,
                pPIDA->szDDETopic, &cchStr);

            if (SUCCEEDED(hresTmp))
                pPIDA->fUseDDE = TRUE;
        }
    }
    return hres;    
}

HRESULT CFTAssocInfo::SetData(AIDWORD aidataFlags, PBYTE pbData, DWORD cbData)
{
    HRESULT hres = E_INVALIDARG;

    if ((AIINIT_PROGID == _aiinitFlags1) && (AIINIT_ACTION == _aiinitFlags2) &&
        (AIDATA_PROGIDACTION == aidataFlags))
    {
        HKEY hProgIDKey = NULL;
        LONG lRes = RegOpenKeyEx(HKEY_CLASSES_ROOT, _szInitStr1, 0,  KEY_WRITE, &hProgIDKey);

        hres = E_FAIL;

        // <ProgID>
        //  |_ shell
        //      |_ <action>
        //          |  (Default): Fr&iendly name (value) (optional) (no UI to set it)
        //          |  "EditFlags": 0x000.... (value) (optional) (no UI to set it)
        //          |_ Command
        //          |    (Default): e.g. c:\winnt\system32\notepad.exe "%1"
        //          |_ ddeexec
        //               |  (Default): DDE msg
        //               |_ Application
        //               |    (Default): Application
        //               |_ IfExec
        //               |    (Default): ifexec
        //               |_ Topic
        //                    (Default): topic
        if (ERROR_SUCCESS == lRes)
        {
            HKEY hShellKey = NULL;
            HKEY hActionKey = NULL;
            HKEY hCommandKey = NULL;
            HKEY hDDEKey = NULL;
            DWORD dwKey = 0;
            PROGIDACTION* pPIDA = (PROGIDACTION*)pbData;

            lRes = RegCreateKeyEx(hProgIDKey, TEXT("shell"), 0, NULL,
                REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hShellKey, &dwKey);

            RegCloseKey(hProgIDKey);

            if (ERROR_SUCCESS == lRes)
            {
                lRes = RegCreateKeyEx(hShellKey, _szInitStr2, 0, NULL,
                    REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hActionKey, &dwKey);

                RegCloseKey(hShellKey);
            }

            if (ERROR_SUCCESS == lRes)
            {
                // Set the friendly name, if different
                if (lstrcmp(pPIDA->szAction, pPIDA->szActionReg))
                {
                    lRes = RegSetValueEx(hActionKey, NULL, NULL, REG_SZ, (PBYTE)pPIDA->szAction,
                        lstrlen(pPIDA->szAction) * sizeof(TCHAR));
                }

                if (ERROR_SUCCESS == lRes)
                {
                    lRes = RegCreateKeyEx(hActionKey, TEXT("command"), 0, NULL,
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hCommandKey, &dwKey);
                }
            }

            if (ERROR_SUCCESS == lRes)
            {
                int iLen = lstrlen(pPIDA->szCmdLine);

                lRes = RegSetValueEx(hCommandKey, NULL, 0, REG_SZ, (PBYTE)(pPIDA->szCmdLine),
                            iLen * sizeof(TCHAR));
            }

            if (ERROR_SUCCESS == lRes)
            {
                if (pPIDA->fUseDDE)
                {
                    lRes = RegCreateKeyEx(hActionKey, TEXT("ddeexec"), 0, NULL,
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hDDEKey, &dwKey);

                    if (ERROR_SUCCESS == lRes)
                    {
                        HKEY hTmpKey = NULL;
                        int iLen = 0;

                        hres = S_OK;

                        if (*(pPIDA->szDDEMsg))
                        {
                            iLen = lstrlen(pPIDA->szDDEMsg);

                            lRes = RegSetValueEx(hDDEKey, NULL, 0, REG_SZ, (PBYTE)(pPIDA->szDDEMsg),
                                        iLen * sizeof(TCHAR));

                            if (ERROR_SUCCESS != lRes)
                                hres = E_FAIL;
                        }
                        if (*(pPIDA->szDDEApplication))
                        {
                            lRes = RegCreateKeyEx(hDDEKey, TEXT("Application"), 0, NULL,
                                REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hTmpKey, &dwKey);
                            
                            if (ERROR_SUCCESS == lRes)
                            {
                                iLen = lstrlen(pPIDA->szDDEApplication);

                                lRes = RegSetValueEx(hTmpKey, NULL, 0, REG_SZ, 
                                    (PBYTE)(pPIDA->szDDEApplication), iLen * sizeof(TCHAR));

                                if (ERROR_SUCCESS != lRes)
                                    hres = E_FAIL;

                                RegCloseKey(hTmpKey);
                            }
                        }
                        if (*(pPIDA->szDDEAppNotRunning))
                        {
                            lRes = RegCreateKeyEx(hDDEKey, TEXT("IfExec"), 0, NULL,
                                REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hTmpKey, &dwKey);
                            
                            if (ERROR_SUCCESS == lRes)
                            {
                                iLen = lstrlen(pPIDA->szDDEAppNotRunning);

                                lRes = RegSetValueEx(hTmpKey, NULL, 0, REG_SZ, 
                                    (PBYTE)(pPIDA->szDDEAppNotRunning), iLen * sizeof(TCHAR));

                                if (ERROR_SUCCESS != lRes)
                                    hres = E_FAIL;

                                RegCloseKey(hTmpKey);
                            }
                        }
                        if (*(pPIDA->szDDETopic))
                        {
                            lRes = RegCreateKeyEx(hDDEKey, TEXT("Topic"), 0, NULL,
                                REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hTmpKey, &dwKey);
                            
                            if (ERROR_SUCCESS == lRes)
                            {
                                iLen = lstrlen(pPIDA->szDDETopic);

                                lRes = RegSetValueEx(hTmpKey, NULL, 0, REG_SZ,
                                    (PBYTE)(pPIDA->szDDETopic), iLen * sizeof(TCHAR));

                                if (ERROR_SUCCESS != lRes)
                                    hres = E_FAIL;

                                RegCloseKey(hTmpKey);
                            }
                        }
                    }
                }
            }

            if (hActionKey)
                RegCloseKey(hActionKey);

            if (hCommandKey)
                RegCloseKey(hCommandKey);

            if (hDDEKey)
                RegCloseKey(hDDEKey);
        }
    }
    return hres;    
}

HRESULT CFTAssocInfo::SetDWORD(AIDWORD aidwordFlags, DWORD dwData)
{
    return E_NOTIMPL;
}

HRESULT CFTAssocInfo::SetString(AISTR aistrFlags, LPTSTR pszStr)
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_PROGID:
        {
            if (AIINIT_NONE == _aiinitFlags2)
            {
                switch(aistrFlags)
                {
                    case AISTR_PROGIDDEFAULTACTION:
                        hres = _SetProgIDDefaultAction(pszStr);
                        break;

                    case AISTR_PROGIDDESCR:
                        hres = (RSSetTextValue(NULL, NULL, pszStr) ? S_OK : E_FAIL);
                        break;

                    case AISTR_ICONLOCATION:
                        hres = _SetIconLocation(pszStr);
                        break;

                    default:
                        hres = E_INVALIDARG;
                        break;
                }
            }
            else
            {
                hres = E_INVALIDARG;
            }
            break;
        }
        case AIINIT_EXT:
        {
            switch(aistrFlags)
            {
                case AISTR_PROGID:
                    hres = (RSSetTextValue(NULL, NULL,pszStr) ? S_OK : E_FAIL);
                    break;

                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }

    return hres;
}

HRESULT CFTAssocInfo::GetBOOL(AIBOOL aiboolFlags, BOOL* pfBool)
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_EXT:
        {
            switch(aiboolFlags)
            {
                case AIBOOL_EXTEXIST:
                {
                    HKEY hKey = NULL;

                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, _szInitStr1,
                        0, KEY_READ, &hKey))
                    {
                        *pfBool = TRUE;
                        RegCloseKey(hKey);
                    }
                    else
                        *pfBool = FALSE;

                    hres = S_OK;

                    break;
                }
                case AIBOOL_EXTASSOCIATED:
                    hres = _ExtIsAssociated(pfBool);
                    break;

                case AIBOOL_PERUSERINFOAVAILABLE:
                {
                    IQueryAssociations *pQA;
                    WCHAR szwExt[MAX_EXT];

                    SHTCharToUnicode(_szInitStr1, szwExt, ARRAYSIZE(szwExt));

                    // This need to return FALSE on failure
                    *pfBool = FALSE;

                    if (SUCCEEDED(AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (void**)&pQA)))
                    {
                        pQA->Init(0, szwExt, NULL, NULL);

                        if (pQA->GetData(0, ASSOCDATA_HASPERUSERASSOC, NULL, NULL, NULL) == S_OK)
                            *pfBool = TRUE;

                        pQA->Release();

                        hres = S_OK;
                    }

                    break;
                }

                case AIBOOL_EXCLUDE:
                {
                    CFTAssocStore* pAssocStore = new CFTAssocStore();

                    if (pAssocStore)
                    {
                        IAssocInfo* pAI = NULL;

                        hres = pAssocStore->GetAssocInfo(_szInitStr1, AIINIT_EXT, &pAI);

                        if (SUCCEEDED(hres))
                        {
                            TCHAR szProgID[MAX_PROGID];
                            DWORD cchProgID = ARRAYSIZE(szProgID);

                            hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                            pAI->Release();

                            if (SUCCEEDED(hres))
                            {
                                hres = pAssocStore->GetAssocInfo(szProgID, AIINIT_PROGID, &pAI);

                                if (SUCCEEDED(hres))
                                {
                                    hres = pAI->GetBOOL(aiboolFlags, pfBool);

                                    pAI->Release();
                                }
                            }
                        }

                        delete pAssocStore;
                    }

                    break;
                }
                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        case AIINIT_PROGID:
        {
            switch(aiboolFlags)
            {
                case AIBOOL_CONFIRMOPEN:
                case AIBOOL_EDITDESCR:
                case AIBOOL_EDITDOCICON:
                case AIBOOL_EDIT:
                case AIBOOL_EDITREMOVE:
                case AIBOOL_EXCLUDE:
                case AIBOOL_SHOW:
                case AIBOOL_PROGIDHASNOEXT:
                {
                    hres = _IsEditFlagSet(aiboolFlags, pfBool);
                    break;
                }
                case AIBOOL_BROWSEINPLACE:
                {
                    hres = _IsBrowseInPlace(pfBool);
                    break;
                }
                case AIBOOL_BROWSEINPLACEENABLED:
                {
                    hres = _IsBrowseInPlaceEnabled(pfBool);
                    break;
                }
                case AIBOOL_ALWAYSSHOWEXT:
                {
                    *pfBool = RSValueExist(NULL, TEXT("AlwaysShowExt"));
                    hres = S_OK;
                        
                    break;
                }
                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }
    return hres;
}

HRESULT CFTAssocInfo::SetBOOL(AIBOOL aiboolFlags, BOOL fBool)
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_PROGID:
        {
            switch(aiboolFlags)
            {
                case AIBOOL_CONFIRMOPEN:
                {
                    hres = _SetEditFlagSet(aiboolFlags, fBool);
                    break;
                }
                case AIBOOL_BROWSEINPLACE:
                {
                    hres = _SetBrowseInPlace(fBool);
                    break;
                }
                case AIBOOL_ALWAYSSHOWEXT:
                {
                    if (fBool)
                    {
                        RSDeleteValue(NULL, TEXT("NeverShowExt"));
                        hres = (RSSetTextValue(NULL, TEXT("AlwaysShowExt"), TEXT("")) ? S_OK : E_FAIL);
                    }
                    else
                        hres = (RSDeleteValue(NULL, TEXT("AlwaysShowExt")) ? S_OK : E_FAIL);

                    break;
                }
                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }
    return hres;
}

HRESULT CFTAssocInfo::Create()
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_EXT:
        {
            HKEY hKey = NULL;
            DWORD dwKey = 0;
            
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, _szInitStr1,
                0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hKey, &dwKey))
            {
                RegCloseKey(hKey);
                hres = S_OK;
            }

            break;
        }
        case AIINIT_PROGID:
        {
            hres = _CreateProgID();
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }
    return hres;    
}

HRESULT CFTAssocInfo::DelString(AISTR aistrFlags)
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_EXT:
        {
            switch(aistrFlags)
            {
                case AISTR_PROGID:
                {
                    hres = (RSDeleteValue(NULL, NULL) ? S_OK : E_FAIL);

                    break;
                }
                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }
    return hres;
}

HRESULT CFTAssocInfo::Delete(AIALL aiallFlags)
{
    HRESULT hres = E_INVALIDARG;

    switch (aiallFlags)
    {
        case AIALL_NONE:
        {
            LONG lRes = -1;

            if ((AIINIT_PROGID == _aiinitFlags1) && (AIINIT_ACTION == _aiinitFlags2))
            {
                TCHAR szProgIDShell[MAX_PROGID + 1 + 5 + 1];
                HKEY hProgIDKey = NULL;

                StrCpyN(szProgIDShell, _szInitStr1, ARRAYSIZE(szProgIDShell));
                lstrcat(szProgIDShell, TEXT("\\shell"));

                lRes = RegOpenKeyEx(HKEY_CLASSES_ROOT, szProgIDShell, 0, KEY_ALL_ACCESS,
                                &hProgIDKey);

                if (ERROR_SUCCESS == lRes)
                {
                    lRes = SHDeleteKey(hProgIDKey, _szInitStr2);
                    RegCloseKey(hProgIDKey);
                }
            }
            else
            {
                if (AIINIT_EXT == _aiinitFlags1)
                    lRes = SHDeleteKey(HKEY_CLASSES_ROOT, _szInitStr1);
            }

            hres = (ERROR_SUCCESS == lRes) ? S_OK : E_FAIL;
            break;
        }
        case AIALL_PERUSER:
        {
            if (AIINIT_EXT == _aiinitFlags1)
            {
                UserAssocSet(UASET_CLEAR, _szInitStr1, NULL);

                hres = S_OK;
            }
            else
            {
                hres = E_NOTIMPL;
            }

            break;
        }
    }

    return hres;
}

HRESULT CFTAssocInfo::_CreateProgID()
{
    HRESULT hres = E_FAIL;
    LRESULT lRes = -1;
    DWORD dwKey = REG_OPENED_EXISTING_KEY;
    int i = 1;

    do
    {
        HKEY hKey = NULL;
        
        wnsprintf(_szInitStr1, ARRAYSIZE(_szInitStr1), TEXT("ft%06d"), i);

        lRes = RegCreateKeyEx(HKEY_CLASSES_ROOT, _szInitStr1,
            0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hKey, &dwKey);

        if (ERROR_SUCCESS == lRes)
            RegCloseKey(hKey);

        ++i;
    }
    while((ERROR_SUCCESS == lRes) && (REG_OPENED_EXISTING_KEY == dwKey));

    if (REG_OPENED_EXISTING_KEY != dwKey)
        hres = S_OK;

    return hres;
}

HRESULT CFTAssocInfo::_SetIconLocation(LPTSTR pszStr)
{
    HKEY hProgIDKey = NULL;
    LONG lRes = RegOpenKeyEx(HKEY_CLASSES_ROOT, _szInitStr1, 0,  KEY_WRITE, &hProgIDKey);

    // ProgID
    //  |_ DefaultIcon
    //      |_ (Default) "path\filename.ext, index"
    //
    if (ERROR_SUCCESS == lRes)
    {
        HKEY hDefaultIconKey = NULL;
        DWORD dwKey = NULL;

        lRes = RegCreateKeyEx(hProgIDKey, TEXT("DefaultIcon"), 0, NULL,
          REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hDefaultIconKey, &dwKey);

        if (ERROR_SUCCESS == lRes)
        {
            lRes = RegSetValueEx(hDefaultIconKey, NULL, 0, REG_SZ, (PBYTE)pszStr,
                lstrlen(pszStr) * sizeof(TCHAR));

            RegCloseKey(hDefaultIconKey);
        }
        RegCloseKey(hProgIDKey);
    }

    return ((ERROR_SUCCESS == lRes) ? S_OK : E_FAIL);
}

HRESULT CFTAssocInfo::_GetProgIDDefaultAction(LPTSTR pszStr, DWORD* pcchStr)
{
    return (RSGetTextValue(TEXT("shell"), NULL, pszStr, pcchStr) ? S_OK : E_FAIL);
}

HRESULT CFTAssocInfo::_SetProgIDDefaultAction(LPTSTR pszStr)
{
    return (RSSetTextValue(TEXT("shell"), NULL, pszStr) ? S_OK : E_FAIL);
}

HRESULT CFTAssocInfo::_IsBrowseInPlaceEnabled(BOOL* pfBool)
{
    HRESULT hres = (RSSubKeyExist(TEXT("DocObject")) ? S_OK : E_FAIL);

    if (SUCCEEDED(hres))
        *pfBool = TRUE;
    else
        *pfBool = FALSE;

    if (FAILED(hres))
        hres = S_FALSE;

    return hres;
}

HRESULT CFTAssocInfo::_IsBrowseInPlace(BOOL* pfBool)
{
    HRESULT hres = E_FAIL;
    LPTSTR pszProgID = _szInitStr1;
    
    ASSERT(_aiinitFlags1 == AIINIT_PROGID);

    *pfBool = FALSE;

    if (RSSubKeyExist(TEXT("DocObject")))
    {
        DWORD dwValue;

        hres = (RSGetDWORDValue(NULL, TEXT("BrowserFlags"), &dwValue) ? S_OK : E_FAIL);

        if (SUCCEEDED(hres))
        {
            *pfBool = IsFlagClear(dwValue, BROWSEHACK_DONTINPLACENAVIGATE);
        }
        else
        {
            *pfBool = TRUE;
        }
    }   

    if (FAILED(hres))
        hres = S_FALSE;

    return hres;
}

HRESULT CFTAssocInfo::_SetBrowseInPlace(BOOL fBool)
{
    DWORD dwValue;
    DWORD cbSize = sizeof(dwValue);
    LPTSTR pszProgID = _szInitStr1;

    if (RSGetDWORDValue(NULL, TEXT("BrowserFlags"), &dwValue))
    {
        // Watch out: Inverse of fBool
        if (fBool)
            ClearFlag(dwValue, BROWSEHACK_DONTINPLACENAVIGATE);
        else
            SetFlag(dwValue, BROWSEHACK_DONTINPLACENAVIGATE);
    }   
    else
    {
        dwValue = fBool ? 0 : BROWSEHACK_DONTINPLACENAVIGATE;
    }
    
    if (dwValue)
    {
        RSSetDWORDValue(NULL, TEXT("BrowserFlags"), dwValue);
    }
    else
    {
        RSDeleteValue(NULL, TEXT("BrowserFlags"));
    }

    return S_OK;
}

HRESULT CFTAssocInfo::_IsEditFlagSet(DWORD dwMask, BOOL* pfBool)
{
    DWORD dwEditFlags = 0;
    LPTSTR pszProgID = _szInitStr1;

    HRESULT hres = _GetProgIDEditFlags(&dwEditFlags);

    if (FAILED(hres))
    {
        hres = S_FALSE;

        // let's put a default value
        dwEditFlags = 0;
    }

    switch(dwMask)
    {
        case AIBOOL_CONFIRMOPEN:
            *pfBool = IsFlagSet(dwEditFlags, FTA_OpenIsSafe);
            break;
        case AIBOOL_EDITDESCR:
            *pfBool = !(IsFlagSet(dwEditFlags, FTA_NoEditDesc));
            break;
        case AIBOOL_EDITDOCICON:
            *pfBool = !(IsFlagSet(dwEditFlags, FTA_NoEditIcon));
            break;
        case AIBOOL_EDIT:
            *pfBool = !(IsFlagSet(dwEditFlags, FTA_NoEdit));
            break;
        case AIBOOL_EDITREMOVE:
            *pfBool = !(IsFlagSet(dwEditFlags, FTA_NoRemove));
            break;
        case AIBOOL_EXCLUDE:
            *pfBool = IsFlagSet(dwEditFlags, FTA_Exclude);
            break;
        case AIBOOL_SHOW:
            *pfBool = IsFlagSet(dwEditFlags, FTA_Show);
            break;
        case AIBOOL_PROGIDHASNOEXT:
            *pfBool = !IsFlagSet(dwEditFlags, FTA_HasExtension);
            break;
    }

    return hres;
}

HRESULT CFTAssocInfo::_SetEditFlagSet(DWORD dwMask, BOOL fBool)
{
    DWORD dwEditFlags = 0;
    DWORD dwToSet = 0;

    HRESULT hres = _GetProgIDEditFlags(&dwEditFlags);

    if (FAILED(hres))
        dwEditFlags = 0;

    switch(dwMask)
    {
        case AIBOOL_CONFIRMOPEN:
            dwToSet = FTA_OpenIsSafe;
            hres = S_OK;
            break;

        default:
            hres = E_FAIL;
            break;
    }

    if (SUCCEEDED(hres))
    {
        if (fBool)
            SetFlag(dwEditFlags, dwToSet);
        else
            ClearFlag(dwEditFlags, dwToSet);

        if (!RSSetDWORDValue(NULL, TEXT("EditFlags"), dwEditFlags))
        {
            hres = E_FAIL;
        }
    }

    return hres;
}

HRESULT CFTAssocInfo::_GetProgIDActionAttributes(DWORD* pdwAttributes)
{
    DWORD dwSize = sizeof(*pdwAttributes);
    HRESULT hres = E_FAIL;
    
    // Was there an EditFlags key?
    if (RSGetDWORDValue(NULL, TEXT("EditFlags"), pdwAttributes))
    {
        // Yes
        hres = S_OK;
    }
    else
    {
        // No default to attributes = 0
        *pdwAttributes = 0;
        hres = S_FALSE;
    }

    return hres;
}

HRESULT CFTAssocInfo::_GetProgIDEditFlags(DWORD* pdwEditFlags)
{
    DWORD dwSize = sizeof(*pdwEditFlags);
    LPTSTR pszProgID = _szInitStr1;

    return (RSGetDWORDValue(NULL, TEXT("EditFlags"), pdwEditFlags) ? S_OK : E_FAIL);
}

HRESULT CFTAssocInfo::_GetIconLocation(LPTSTR pszStr, DWORD* pcchStr)
{
    return (RSGetTextValue(TEXT("DefaultIcon"), NULL, pszStr, pcchStr) ? S_OK : E_FAIL);
}

HRESULT CFTAssocInfo::_GetOpenWithInfo(LPTSTR pszStr, DWORD* pcchStr)
{
    int iRet = -1;
    LPTSTR pszExt = _szInitStr1;

    IQueryAssociations* pQA = NULL;
    HRESULT hres = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations,
                            (LPVOID*)&pQA);

    if (SUCCEEDED(hres))
    {
        WCHAR szwExt[MAX_EXT];

        SHTCharToUnicode(pszExt, szwExt, ARRAYSIZE(szwExt));

        hres = pQA->Init(0, szwExt, NULL, NULL);

        if (SUCCEEDED(hres))
        {
            WCHAR szwAppFriendlyName[MAX_APPFRIENDLYNAME];
            DWORD cchAFName = ARRAYSIZE(szwAppFriendlyName);
            TCHAR szAppl[MAX_PATH];
    
            HRESULT hresFriendlyName = pQA->GetString(ASSOCF_VERIFY | ASSOCF_OPEN_BYEXENAME,
                ASSOCSTR_FRIENDLYAPPNAME, NULL, szwAppFriendlyName, &cchAFName);

            // Did we get a friendly name?
            if (SUCCEEDED(hresFriendlyName))
            {
                // Yes, use it
                SHUnicodeToTChar(szwAppFriendlyName, pszStr, *pcchStr);
            }

            // Reuse szwAppFriendlyName
            hres = pQA->GetString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, NULL,
                szwAppFriendlyName, &cchAFName);

            if (SUCCEEDED(hres))
            {
                SHUnicodeToTChar(szwAppFriendlyName, szAppl, ARRAYSIZE(szAppl));

                if (FAILED(hresFriendlyName))
                {
                    // We failed to get a friendly name, use the EXE name
                    StrCpyN(pszStr, szAppl, *pcchStr);
                }
            }
        }
        pQA->Release();
    }

    if (FAILED(hres))
        *(pszStr) = 0;
    
    return hres;
}

HRESULT CFTAssocInfo::_GetAppIcon(BOOL fSmall, int* piIcon)
{
    LPTSTR pszExt = _szInitStr1;

    IQueryAssociations* pQA = NULL;
    HRESULT hres = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations,
                            (LPVOID*)&pQA);

    if (SUCCEEDED(hres))
    {
        WCHAR szwExt[MAX_EXT];

        SHTCharToUnicode(pszExt, szwExt, ARRAYSIZE(szwExt));

        hres = pQA->Init(0, szwExt, NULL, NULL);

        if (SUCCEEDED(hres))
        {
            WCHAR szwExecutable[MAX_PATH];
            DWORD cchExecutable = ARRAYSIZE(szwExecutable);
    
            hres = pQA->GetString(ASSOCF_VERIFY,
                ASSOCSTR_EXECUTABLE, NULL, szwExecutable, &cchExecutable);

            if (SUCCEEDED(hres))
            {
                HIMAGELIST himl = fSmall ? _himlSysSmall : _himlSysLarge;
                int iImage = -1;
                TCHAR szExe[MAX_PATH];

                SHUnicodeToTChar(szwExecutable, szExe, ARRAYSIZE(szExe));

                SHFILEINFO sfi = {0};
                UINT uFlags = SHGFI_USEFILEATTRIBUTES;

                uFlags |= (fSmall ? (SHGFI_SMALLICON|SHGFI_ICON) : SHGFI_ICON);

                if (SHGetFileInfo(szExe, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(SHFILEINFO), uFlags))
                {
                    *piIcon = sfi.iIcon;
                    DestroyIcon(sfi.hIcon);                

                    hres = S_OK;
                }
            }
        }
        pQA->Release();
    }

    return hres;
}

HRESULT CFTAssocInfo::_ExtIsAssociated(BOOL* pfIsAssociated)
{
    TCHAR szProgID[MAX_PROGID];
    DWORD cchProgID = ARRAYSIZE(szProgID);
    LPTSTR pszExt = _szInitStr1;

    if (RSGetTextValue(NULL, NULL, szProgID, &cchProgID) && szProgID[0])
    {
        *pfIsAssociated = TRUE;
    }
    else
    {
        *pfIsAssociated = FALSE;
    }

    return S_OK;
}

HRESULT CFTAssocInfo::_GetExtDocIcon(LPTSTR pszExt, BOOL fSmall, int* piIcon)
{
    HRESULT hres = E_FAIL;
    SHFILEINFO sfi = {0};

    ASSERT(TEXT('.') == *pszExt);

    UINT uFlags = SHGFI_USEFILEATTRIBUTES;

    uFlags |= (fSmall ? (SHGFI_SMALLICON|SHGFI_ICON) : SHGFI_ICON);

    if (SHGetFileInfo(pszExt, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(SHFILEINFO), uFlags))
    {
        *piIcon = sfi.iIcon;
        DestroyIcon(sfi.hIcon);                

        hres = S_OK;
    }

    return hres;
}

HRESULT CFTAssocInfo::_GetProgIDDocIcon(BOOL fSmall, int* piIcon)
{
    HRESULT hres = E_FAIL;
    SHFILEINFO sfi = {0};
    LPTSTR pszProgID = _szInitStr1;
    HIMAGELIST himl = fSmall ? _himlSysSmall : _himlSysLarge;
    BOOL fHasNoExtension = FALSE;

    // Try the extension(s) first, unless this is a progID without extension

    IEnumAssocInfo* pEnum = NULL;

    if (AIINIT_PROGID == _aiinitFlags1)
        GetBOOL(AIBOOL_PROGIDHASNOEXT, &fHasNoExtension);

    if (!fHasNoExtension)
    {
        CFTAssocStore* pAssocStore = new CFTAssocStore();

        if (pAssocStore)
        {
            hres = pAssocStore->EnumAssocInfo(ASENUM_EXT, pszProgID, AIINIT_PROGID, &pEnum);

            delete pAssocStore;
        }

        if (SUCCEEDED(hres))
        {
            IAssocInfo* pAI = NULL;

            hres = E_FAIL;

            while (FAILED(hres) && (S_OK == pEnum->Next(&pAI)))
            {
                TCHAR szExt[MAX_EXT];
                DWORD cchExt = ARRAYSIZE(szExt);

                hres = pAI->GetString(AISTR_DOTEXT, szExt, &cchExt);

                if (SUCCEEDED(hres))
                    hres = _GetExtDocIcon(szExt, fSmall, piIcon);

                pAI->Release();
            }

            pEnum->Release();
        }
    }

    // Did it fail?
    if (FAILED(hres))
    {
        // Yes get it from the progID "DefaultIcon" key, if any
        hres = E_FAIL;
        TCHAR szDefaultIcon[MAX_ICONLOCATION];
        DWORD cchDefaultIcon = ARRAYSIZE(szDefaultIcon);

        __InitImageLists();

        if (RSGetTextValue(TEXT("DefaultIcon"), NULL, szDefaultIcon, &cchDefaultIcon) &&
            szDefaultIcon[0])
        {
            int iIndex = PathParseIconLocation(szDefaultIcon);

            *piIcon = Shell_GetCachedImageIndex(szDefaultIcon, iIndex, 0);

            hres = ((-1 == *piIcon) ? E_FAIL : S_OK);
        }
    }

    // Did it fail?
    if (FAILED(hres))
    {
        // Yes, get simulated doc icon if from exe name
        IQueryAssociations* pQA = NULL;
        hres = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations,
                                (LPVOID*)&pQA);

        if (SUCCEEDED(hres))
        {
            WCHAR szwProgID[MAX_PROGID];

            SHTCharToUnicode(pszProgID, szwProgID, ARRAYSIZE(szwProgID));

            hres = pQA->Init(0, szwProgID, NULL, NULL);

            if (SUCCEEDED(hres))
            {
                TCHAR szExeName[MAX_PATH];
                WCHAR szwExeName[MAX_PATH];
                DWORD dwExeName = ARRAYSIZE(szwExeName);
                
                hres = pQA->GetString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, NULL,
                    szwExeName, &dwExeName);

                if (SUCCEEDED(hres))
                {
                    int iImage = 0;

                    SHUnicodeToTChar(szwExeName, szExeName, ARRAYSIZE(szExeName));

                    *piIcon = Shell_GetCachedImageIndex(szExeName, 0, GIL_SIMULATEDOC);
                }
            }

            pQA->Release();
        }
    }

    // Did it fail?
    if (FAILED(hres))
    {
        // Yes, get the shell's default icon
        *piIcon = II_DOCNOASSOC;

        hres = S_OK;
    }

    return hres;
}

//static
HRESULT CFTAssocInfo::_GetProgIDDescr(LPTSTR pszProgIDDescr, DWORD* pcchProgIDdescr)
{
    HRESULT hres = E_FAIL;

    IQueryAssociations* pQA = NULL;
    hres = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations,
        (LPVOID*)&pQA);

    if (SUCCEEDED(hres))
    {
        WCHAR szwProgID[MAX_PROGID];

        SHTCharToUnicode(_szInitStr1, szwProgID, ARRAYSIZE(szwProgID));

        hres = pQA->Init(0, szwProgID, NULL, NULL);

        if (SUCCEEDED(hres))
        {
            WCHAR szwProgIDDescr[MAX_PROGIDDESCR];
            // Prepare progID description
            // Reuse szwProgID
            hres = pQA->GetString(0, ASSOCSTR_FRIENDLYDOCNAME, NULL, szwProgIDDescr,
                (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szwProgIDDescr)));

            if (SUCCEEDED(hres))
                SHUnicodeToTChar(szwProgIDDescr, pszProgIDDescr, *pcchProgIDdescr);
        }
        pQA->Release();
    }

    return hres;
}

HRESULT CFTAssocInfo::_OpenSubKey(LPTSTR pszSubKey, REGSAM samDesired, HKEY* phKey)
{
    HRESULT hres = E_FAIL;
    HKEY hkeyRoot = RSDuplicateRootKey();

    if (hkeyRoot)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyRoot, pszSubKey, 0, MAXIMUM_ALLOWED, phKey))
            hres = S_OK;
        else
            hres = E_FAIL;

        RegCloseKey(hkeyRoot);
    }

    return hres;
}

HRESULT CFTAssocInfo::__InitImageLists()
{
    if (!_himlSysLarge ||!_himlSysSmall)
        Shell_GetImageLists(&_himlSysLarge, &_himlSysSmall);

    return S_OK;
}

//IUnknown methods
HRESULT CFTAssocInfo::QueryInterface(REFIID riid, PVOID* ppv)
{
#if 0
    static const QITAB qit[] = {
      QITABENT(CFTAssocStore, IAssocStore),
      { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
#endif

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IUnknown*>(this);
    else
        *ppv = static_cast<IAssocInfo*>(this);

    return S_OK;
}

ULONG CFTAssocInfo::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFTAssocInfo::Release()
{
    if (InterlockedDecrement(&_cRef) > 0)
        return _cRef;

    delete this;
    return 0;
}

// for C callers
STDAPI_(BOOL) FT_GetIconLocationFromExt(LPTSTR pszExt, LPTSTR pszPath,
    DWORD cchPath, int* piIconIndex)
{
    BOOL fRet = FALSE;

    CFTAssocStore* pAssocStore = new CFTAssocStore();

    if (pAssocStore)
    {
        IAssocInfo* pAI = NULL;
        HRESULT hres = pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);

        if (SUCCEEDED(hres))
        {
            hres = pAI->GetString(AISTR_ICONLOCATION, pszPath, &cchPath);

            pAI->Release();

            if (SUCCEEDED(hres))
            {
                *piIconIndex = PathParseIconLocation(pszPath);

                fRet = TRUE;
            }
        }

        delete pAssocStore;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftdlg.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "ftcmmn.h"
#include "ftdlg.h"
#include "ftascstr.h" //there only for the new CFTAssocStore

CFTDlg::CFTDlg(ULONG_PTR ulpAHelpIDsArray) :
    CBaseDlg(ulpAHelpIDsArray), _pAssocStore(NULL)
{}

CFTDlg::~CFTDlg()
{
    if (_pAssocStore)
        delete _pAssocStore;
}

HRESULT CFTDlg::_InitAssocStore()
{
    ASSERT(!_pAssocStore);

    _pAssocStore = new CFTAssocStore();

    return _pAssocStore ? S_OK : E_OUTOFMEMORY;
}

///////////////////////////////////////////////////////////////////////////////
// Windows boiler plate code
LRESULT CFTDlg::WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(uMsg)
    {
        case WM_CTRL_SETFOCUS:
            lRes = OnCtrlSetFocus(wParam, lParam);
            break;

        default:
            lRes = CBaseDlg::WndProc(uMsg, wParam, lParam);
            break;
    }

    return lRes;
}

LRESULT CFTDlg::OnCtrlSetFocus(WPARAM wParam, LPARAM lParam)
{
    SetFocus((HWND)lParam);

    return TRUE;
}

//static
void CFTDlg::MakeDefaultProgIDDescrFromExt(LPTSTR pszProgIDDescr, DWORD cchProgIDDescr,
        LPTSTR pszExt)
{
    TCHAR szTemplate[25];
    TCHAR szExt[MAX_EXT];

    lstrcpyn(szExt, pszExt, ARRAYSIZE(szExt));

    LoadString(g_hinst, IDS_EXTTYPETEMPLATE, szTemplate, ARRAYSIZE(szTemplate));

    CharUpper(szExt);

    wnsprintf(pszProgIDDescr, cchProgIDDescr, szTemplate, szExt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftcmmn.h ===
#ifndef FTCMMN_H
#define FTCMMN_H

#define WM_CTRL_SETFOCUS WM_USER + 1

#define MAX_EXT                 MAX_PATH
#define MAX_PROGID              MAX_PATH
#define MAX_PROGIDDESCR         200 //no reason
#define MAX_APPFRIENDLYNAME     260
#define MAX_ACTION	    		63
#define MAX_ACTIONDESCR			200 //no reason
#define MAX_ACTIONCMDLINE       (MAX_PATH * 2) //no reason
#define MAX_ACTIONAPPL			MAX_PATH
#define MAX_ACTIONDDEAPPNOTRUN	MAX_PATH
#define MAX_ACTIONDDEMSG		200 //no reason
#define MAX_ACTIONTOPIC			200 //no reason
#define MAX_MIME				50 //no reason
#define MAX_FTMAX				MAX_EXT

#define BROWSEHACK_DONTINPLACENAVIGATE     0x00000008

// ...Reg: the Reg key name

typedef struct tagPROGIDACTION
{
    BOOL  fNew;
    BOOL  fUseDDE;
    TCHAR szAction[MAX_ACTION];
    TCHAR szActionReg[MAX_ACTION];
    TCHAR szOldAction[MAX_ACTION];
    TCHAR szOldActionReg[MAX_ACTION];
    TCHAR szCmdLine[MAX_ACTIONCMDLINE];
    TCHAR szDDEMsg[MAX_ACTIONDDEMSG];
    TCHAR szDDEApplication[MAX_ACTIONAPPL];
    TCHAR szDDEAppNotRunning[MAX_ACTIONDDEAPPNOTRUN];
    TCHAR szDDETopic[MAX_ACTIONTOPIC];
}PROGIDACTION;

#endif //FTCMMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftdlg.h ===
#ifndef FTDLG_H
#define FTDLG_H

#include "basedlg.h"

class IAssocStore;

class CFTDlg : public CBaseDlg
{
public:
    CFTDlg(ULONG_PTR ulpAHelpIDsArray);

protected:
    virtual ~CFTDlg();

    LRESULT OnCtrlSetFocus(WPARAM wParam, LPARAM lParam);
    virtual LRESULT WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT _InitAssocStore();

    static void MakeDefaultProgIDDescrFromExt(LPTSTR pszProgIDDescr, DWORD dwProgIDDescr,
        LPTSTR pszExt);

protected:
    // Our connection to the data
    IAssocStore*    _pAssocStore;
};

#endif //FTDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftenum.h ===
#ifndef FTENUM_H
#define FTENUM_H

#include "ascstr.h"

class CFTEnumAssocInfo : public IEnumAssocInfo
{
public:
    CFTEnumAssocInfo();
    ~CFTEnumAssocInfo();

public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, PVOID* ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IEnumAssocInfo methods
    //  Initialization
    STDMETHOD(Init)(ASENUM asenumFlags, LPTSTR pszStr,
        AIINIT aiinitFlags);

    //  Standard IEnum methods
    STDMETHOD(Next)(IAssocInfo** ppAI);
    STDMETHOD(Skip)(DWORD dwSkip);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumAssocInfo* pEnum);

protected:
    STDMETHOD(_EnumHKCR)(ASENUM asenumFlags, LPTSTR pszStr, 
                                        DWORD* pcchStr);
    STDMETHOD(_EnumProgIDActions)(LPTSTR pszStr, DWORD* pcchStr);
    STDMETHOD_(BOOL, _EnumKCRSkip)(DWORD asenumFlags, LPTSTR pszExt);
    STDMETHOD_(BOOL, _EnumKCRStop)(DWORD asenumFlags, LPTSTR pszExt);

protected:
    LONG                    _cRef;

    ASENUM                  _asenumFlags;
    TCHAR                   _szInitStr[MAX_FTMAX];
    AIINIT                  _aiinitFlags;

    BOOL                    _fFirstExtFound;

    DWORD                   _dwIndex;
};

#endif //FTENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftedit.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "help.h"

#include "ascstr.h"
#include "ftdlg.h"
#include "ftedit.h"
#include "ftcmmn.h"

#define ID_TIMER 2222

const static DWORD cs_rgdwHelpIDsArray[] =
{  // Context Help IDs
    IDC_FT_EDIT_EXT_EDIT_TEXT,  IDH_FCAB_FT_NE_FILEEXT,
    IDC_FT_EDIT_EXT_EDIT,       IDH_FCAB_FT_NE_FILEEXT,
    IDC_FT_EDIT_PID_COMBO_TEXT, IDH_FCAB_FT_NE_FILETYPE,
    IDC_FT_EDIT_PID_COMBO,      IDH_FCAB_FT_NE_FILETYPE,
    IDC_FT_EDIT_ADVANCED,       IDH_FCAB_FT_NE_ADV_BUT,
    IDC_NO_HELP_1,              NO_HELP,
    0, 0
};

CFTEditDlg::CFTEditDlg(FTEDITPARAM* pftEditParam) :
    CFTDlg((ULONG_PTR)cs_rgdwHelpIDsArray), _pftEditParam(pftEditParam),
    _iLVSel(-1)
{
}

CFTEditDlg::~CFTEditDlg()
{
}
///////////////////////////////////////////////////////////////////////////////
// Logic specific to our problem
LRESULT CFTEditDlg::OnInitDialog(WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = E_FAIL;  

    if (_pftEditParam)
    {
        hres = _InitAssocStore();

        if (SUCCEEDED(hres))
        {
            _hHeapProgID = HeapCreate(0, 8 * 1024, 0);

            if (!_hHeapProgID)
                hres = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hres))
            SetDlgItemText(_hwnd, IDC_FT_EDIT_EXT_EDIT, TEXT(""));
    }

    if (FAILED(hres))
        EndDialog(_hwnd, -1);
    else
        Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_EDIT_EXT_EDIT), MAX_EXT - 1);

    // Return TRUE so that system set focus
    return TRUE;
}

LRESULT CFTEditDlg::OnEdit(WORD wNotif)
{
    if (_fAdvanced)
    {
        if (EN_CHANGE == wNotif)
        {
            if (_nTimer)
            {
                KillTimer(_hwnd, _nTimer);
                _nTimer = 0;
            }

            _nTimer = SetTimer(_hwnd, ID_TIMER, 400, NULL);
        }
    }

    return FALSE;
}

LRESULT CFTEditDlg::OnTimer(UINT nTimer)
{
    // Kill the timer
    KillTimer(_hwnd, _nTimer);
    _nTimer = 0;

    _ProgIDComboHelper();

    return TRUE;
}

HRESULT CFTEditDlg::_ProgIDComboHelper()
{
    TCHAR szExt[MAX_EXT];
    TCHAR szProgIDDescr[MAX_PROGIDDESCR];
    DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);
    HRESULT hres = E_FAIL;

    GetDlgItemText(_hwnd, IDC_FT_EDIT_EXT_EDIT, szExt, ARRAYSIZE(szExt));

    hres = _GetProgIDDescrFromExt(szExt, szProgIDDescr, &cchProgIDDescr);
    
    if (SUCCEEDED(hres))
        _SelectProgIDDescr(szProgIDDescr);

    return hres;
}

HRESULT CFTEditDlg::_GetProgIDDescrFromExt(LPTSTR pszExt, LPTSTR pszProgIDDescr,
        DWORD* pcchProgIDDescr)
{
    IAssocInfo* pAI = NULL;
    HRESULT hres = _pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);

    if (SUCCEEDED(hres))
    {
        hres = pAI->GetString(AISTR_PROGIDDESCR, pszProgIDDescr, pcchProgIDDescr);
        pAI->Release();
    }
    return hres;
}

LRESULT CFTEditDlg::OnAdvancedButton(WORD wNotif)
{
    DECLAREWAITCURSOR;
    TCHAR szAdvBtnText[50];

    SetWaitCursor();

    _fAdvanced = !_fAdvanced;

    LoadString(g_hinst, _fAdvanced ? IDS_FT_ADVBTNTEXTEXPAND : IDS_FT_ADVBTNTEXTCOLLAPS,
        szAdvBtnText, ARRAYSIZE(szAdvBtnText));

    SetWindowText(GetDlgItem(_hwnd, IDC_FT_EDIT_ADVANCED), szAdvBtnText);

    _ConfigureDlg();

    UpdateWindow(_hwnd);

    if (_fAdvanced)
    {
        HWND hwndCombo = GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO);

        // Is the combobox filled yet?
        if (!ComboBox_GetCount(hwndCombo))
        {
            _FillProgIDDescrCombo();

            // Select the <New> item

            if (FAILED(_ProgIDComboHelper()))
            {
                TCHAR szNew[20];

                if (LoadString(g_hinst, IDS_FT_NEW, szNew, ARRAYSIZE(szNew)))
                {
                    int iIndex = ComboBox_FindStringExact(hwndCombo, -1, szNew);

                    if (CB_ERR != iIndex)
                        ComboBox_SetCurSel(hwndCombo, iIndex);
                }
            }
        }
    }

    ResetWaitCursor();

    return FALSE;
}

void CFTEditDlg::_ConfigureDlg()
{
    // Need to:
    //  - position OK and Cancel
    //  - resize dlg
    //  - Show/hide Combo and its text

    RECT rcControl;
    RECT rcDialog;
    RECT rcCancel;
    RECT rcOK;

    int iStdMargins = 0;
    int iStdSpaceBetweenControls = 0;

    GetWindowRect(_hwnd, &rcDialog);

    GetWindowRect(GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO_TEXT), 
        &rcControl);

    // Calculate the folowing (cannot be fixed, varies with dialog font)

    // [msadek]; screen coordinates. need to consider the mirrored case
    if(IS_WINDOW_RTL_MIRRORED(_hwnd))
    {
        iStdMargins = rcDialog.right - rcControl.right;
    }
    else
    {
        iStdMargins = rcControl.left - rcDialog.left;    
    }
    iStdSpaceBetweenControls = MulDiv(4, iStdMargins, 7);

    // Move Cancel and OK button
    GetWindowRect(GetDlgItem(_hwnd, 
        _fAdvanced ? IDC_FT_EDIT_PID_COMBO : IDC_FT_EDIT_EXT_EDIT), 
        &rcControl);

    MapWindowRect(HWND_DESKTOP, _hwnd, &rcControl);

    GetWindowRect(GetDlgItem(_hwnd, IDCANCEL), &rcCancel);
    MapWindowRect(HWND_DESKTOP, _hwnd, &rcCancel);

    OffsetRect(&rcCancel, 0, -rcCancel.top);

    GetWindowRect(GetDlgItem(_hwnd, IDOK), &rcOK);
    MapWindowRect(HWND_DESKTOP, _hwnd, &rcOK); 
    OffsetRect(&rcOK, 0, -rcOK.top);

    OffsetRect(&rcCancel, 0, rcControl.bottom + iStdSpaceBetweenControls);
    OffsetRect(&rcOK, 0, rcControl.bottom + iStdSpaceBetweenControls);

    SetWindowPos(GetDlgItem(_hwnd, IDOK), NULL, 
            rcOK.left, rcOK.top, 0, 0, SWP_NOSIZE|SWP_SHOWWINDOW|SWP_NOZORDER);
    SetWindowPos(GetDlgItem(_hwnd, IDCANCEL), NULL, 
            rcCancel.left, rcCancel.top, 0, 0, SWP_NOSIZE|SWP_SHOWWINDOW|SWP_NOZORDER);

    // Resize Dlg
    ClientToScreen(_hwnd, ((POINT*)&rcCancel) + 1);

    rcDialog.bottom = rcCancel.bottom + iStdMargins;
    SetWindowPos(_hwnd, NULL, 
            0, 0, rcDialog.right - rcDialog.left, rcDialog.bottom - rcDialog.top,
            SWP_NOMOVE|SWP_SHOWWINDOW|SWP_NOZORDER);

    // Show/Hide Combo and its text
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO_TEXT), _fAdvanced);
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO), _fAdvanced);

    // Set focus to combo
    SetFocus(GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO));
}

LRESULT CFTEditDlg::OnOK(WORD wNotif)
{
    HRESULT hres = S_FALSE;

    // Pick up the extension
    GetDlgItemText(_hwnd, IDC_FT_EDIT_EXT_EDIT, _pftEditParam->szExt,
        _pftEditParam->dwExt);

    // Is it empty?
    if (0 != (*_pftEditParam->szExt))
    {
        // No, that's good

        // FEATURE: do some check for valid extension name

        IAssocInfo* pAI = NULL;

        hres = _pAssocStore->GetAssocInfo(_pftEditParam->szExt, 
                            AIINIT_EXT, &pAI);

        if (SUCCEEDED(hres))
        {
            BOOL fExist = FALSE;

            hres = pAI->GetBOOL(AIBOOL_EXTEXIST, &fExist);

            // Is this extension already existing?
            if (SUCCEEDED(hres) && !fExist)
            {
                // No, create it
                // Check for spaces in the ext name
                LPTSTR pszExt = _pftEditParam->szExt;

                while (*pszExt && (S_FALSE != hres))
                {
                    if (TEXT(' ') == *pszExt)
                    {
                        hres = S_FALSE;

                        ShellMessageBox(g_hinst, _hwnd,
                            MAKEINTRESOURCE(IDS_FT_MB_NOSPACEINEXT),
                            MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP);

                        // Set focus to Ext combo
                        PostMessage(_hwnd, WM_CTRL_SETFOCUS, (WPARAM)0,
                            (LPARAM)GetDlgItem(_hwnd, IDC_FT_EDIT_EXT_EDIT));
                    }

                    ++pszExt;
                }

                if (S_OK==hres)
                    hres = pAI->Create();
            }

            if (S_OK==hres)
                hres = _HandleProgIDAssoc(pAI, _pftEditParam->szExt, fExist);

            pAI->Release();
        }
    }
    else
    {
        ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_NOEXT),
            MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP);

        // Set focus to Ext combo
        PostMessage(_hwnd, WM_CTRL_SETFOCUS, (WPARAM)0,
            (LPARAM)GetDlgItem(_hwnd, IDC_FT_EDIT_EXT_EDIT));
    }
    
    // If we fail, we are in serious trouble, so we just close the dialog
    ASSERT(SUCCEEDED(hres));

    if (S_FALSE != hres)
        EndDialog(_hwnd, IDOK);

    return FALSE;
}

HRESULT CFTEditDlg::_GetProgIDInfo(IAssocInfo* pAI, LPTSTR pszProgID,
    DWORD* pcchProgID, BOOL* pfNewProgID, BOOL* pfExplicitNew)
{
    HWND hwndCombo = GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO);

    *pfNewProgID = FALSE;
    *pfExplicitNew = FALSE;

    if (ComboBox_GetCount(hwndCombo))
    {
        int iSel = ComboBox_GetCurSel(hwndCombo);

        if (CB_ERR != iSel)
        {
            LPTSTR pszTmpProgID = (LPTSTR)ComboBox_GetItemData(hwndCombo, iSel);

            // Is this the "<New>" item (the only one with a ProgID == NULL)?
            if (!pszTmpProgID)
            {
                // Yes
                *pfNewProgID = TRUE;
                *pfExplicitNew = TRUE;
            }
            else
            {
                // No
                StrCpyN(pszProgID, pszTmpProgID, *pcchProgID);
            }
        }        
    }
    else
    {
        *pfNewProgID = TRUE;
    }

    return S_OK;
}

HRESULT CFTEditDlg::_HandleProgIDAssoc(IAssocInfo* pAI, LPTSTR pszExt, BOOL fExtExist)
{
    TCHAR szProgID[MAX_PROGID];
    DWORD cchProgID = ARRAYSIZE(szProgID);
    BOOL fNewProgID = FALSE;
    BOOL fExplicitNew = FALSE;

    *szProgID = 0;
    HRESULT hres = _GetProgIDInfo(pAI, szProgID, &cchProgID, &fNewProgID, &fExplicitNew);

    if (SUCCEEDED(hres))
    {
        // Is this Extension already existing?
        if (fExtExist)
        {
            //
            // First make sure it's not the exact same ext - progID assoc
            //
            TCHAR szTmpProgID[MAX_PROGID];
            DWORD cchTmpProgID = ARRAYSIZE(szTmpProgID);

            hres = pAI->GetString(AISTR_PROGID, szTmpProgID, &cchTmpProgID);

            // Did we got a progID?
            if (SUCCEEDED(hres))
            { 
                // Yes
                // Are they the same?
                if (0 == lstrcmpi(szTmpProgID, szProgID))
                {
                    // Yes, fail, nothing more to do
                    hres = E_FAIL;
                }
                else
                {
                    // No, go on
                    hres = S_OK;
                }
            }
            else
            {
                // No, there probably is no ProgID, go on
                hres = S_OK;
            }
            //
            // Unless the user chose <New> explicitly ask if he wants to break the assoc
            //
            // Did the user explicitly chose <New> (and we did not failed already)?
            if (!fExplicitNew && SUCCEEDED(hres))
            {
                // We need to warn user that he will break existing assoc
                TCHAR szProgIDDescr[MAX_PROGIDDESCR];
                DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);

                hres = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr, &cchProgIDDescr);

                if (SUCCEEDED(hres))
                {
                    if (IDNO == ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_EDIT_ALREADYASSOC),
                        MAKEINTRESOURCE(IDS_FT_EDIT_ALRASSOCTITLE), MB_YESNO | MB_ICONEXCLAMATION,
                        pszExt, szProgIDDescr, pszExt, szProgIDDescr))
                    {
                        // S_FALSE means user does not want to go on
                        hres = S_FALSE;
                    }
                }
                else
                {
                    // no progIDDescr...  Check if we have a progID
                    TCHAR szProgID[MAX_PROGID];
                    DWORD cchProgID = ARRAYSIZE(szProgID);

                    hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                    if (FAILED(hres))
                    {
                        // no progID, set hres to S_OK so that we go on and create one
                        hres = S_OK;
                    }
                }
            }
        }

        // Should we go on and create new progID?
        if (S_OK==hres && fNewProgID)
        {
            // Yes, create it
            IAssocInfo* pAIProgID = NULL;

            hres = _pAssocStore->GetAssocInfo(NULL, AIINIT_PROGID, &pAIProgID);

            if (SUCCEEDED(hres))
            {
                hres = pAIProgID->Create();

                if (SUCCEEDED(hres))
                {
                    TCHAR szExt[MAX_EXT];
                    DWORD cchExt = ARRAYSIZE(szExt);
                    TCHAR szProgIDDescr[MAX_PROGIDDESCR];

                    HRESULT hresTmp = pAI->GetString(AISTR_EXT, szExt, &cchExt);

                    if (SUCCEEDED(hresTmp) && *szExt)
                    {
                        MakeDefaultProgIDDescrFromExt(szProgIDDescr, ARRAYSIZE(szProgIDDescr), szExt);

                        hresTmp = pAIProgID->SetString(AISTR_PROGIDDESCR, szProgIDDescr);
                    }

                    // Get the ProgID for later use
                    pAIProgID->GetString(AISTR_PROGID, szProgID, &cchProgID);
                }

                pAIProgID->Release();
            }
        }

        if (S_OK==hres)
        {
            // Set the new extension progID
            hres = pAI->SetString(AISTR_PROGID, szProgID);

            if (SUCCEEDED(hres))
            {
                // Get the description
                pAI->GetString(AISTR_PROGIDDESCR, _pftEditParam->szProgIDDescr,
                    &(_pftEditParam->dwProgIDDescr));
            }
        }
    }

    return hres;
}

LRESULT CFTEditDlg::OnCancel(WORD wNotif)
{
    EndDialog(_hwnd, IDCANCEL);

    return FALSE;
}

HRESULT CFTEditDlg::_FillProgIDDescrCombo()
{
    HWND hwndCombo = GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO);

    // Data stuff
    IEnumAssocInfo* pEnum = NULL;
    HRESULT hres = _pAssocStore->EnumAssocInfo(
        ASENUM_PROGID | ASENUM_ASSOC_ALL, NULL, AIINIT_NONE, &pEnum);

    if (SUCCEEDED(hres))
    {
        IAssocInfo* pAI = NULL;

        while ((E_OUTOFMEMORY != hres) && (S_OK == pEnum->Next(&pAI)))
        {
            TCHAR szProgIDDescr[MAX_PROGIDDESCR];
            DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);

            hres = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr, &cchProgIDDescr);

            if (SUCCEEDED(hres))
            {
                int iIndex = CB_ERR;
                
                if (*szProgIDDescr)
                {
                    if (CB_ERR == ComboBox_FindStringExact(hwndCombo, -1, szProgIDDescr))
                        iIndex = ComboBox_AddString(hwndCombo, szProgIDDescr);
                }

                if ((CB_ERR != iIndex) && (CB_ERRSPACE != iIndex))
                {
                    TCHAR szProgID[MAX_PROGID];
                    DWORD cchProgID = ARRAYSIZE(szProgID);

                    hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                    if (SUCCEEDED(hres))
                    {
                        LPTSTR pszProgID = _AddProgID(szProgID);

                        if (pszProgID)
                        {
                            lstrcpy(pszProgID, szProgID);
                            ComboBox_SetItemData(hwndCombo, iIndex, pszProgID);
                        }
                        else
                        {
                            // Out of memory
                            hres = E_OUTOFMEMORY;

                            ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_ERROR + 
                                ERROR_NOT_ENOUGH_MEMORY), MAKEINTRESOURCE(IDS_FT), 
                                MB_OK | MB_ICONSTOP);

                            // Already allocated mem will be cleaned-up in OnDestroy
                        }
                    }
                }
            }

            pAI->Release();
        }
        pEnum->Release();

        if (SUCCEEDED(hres))
        {
            TCHAR szNew[20];

            if (LoadString(g_hinst, IDS_FT_NEW, szNew, ARRAYSIZE(szNew)))
            {
                int iIndex = ComboBox_InsertString(hwndCombo, 0, szNew);

                if (CB_ERR != iIndex)
                    ComboBox_SetItemData(hwndCombo, iIndex, NULL);
            }
        }
    }

    return hres;
}

BOOL CFTEditDlg::_SelectProgIDDescr(LPTSTR pszProgIDDescr)
{
    int iIndex = ComboBox_SelectString(GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO),
        -1, pszProgIDDescr);

    return ((CB_ERR != iIndex) ? TRUE : FALSE);
}

LRESULT CFTEditDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    _CleanupProgIDs();

    CFTDlg::OnDestroy(wParam, lParam);

    return FALSE;
}

LPTSTR CFTEditDlg::_AddProgID(LPTSTR pszProgID)
{
    ASSERT(_hHeapProgID);

    return (LPTSTR)HeapAlloc(_hHeapProgID, 0, (lstrlen(pszProgID) + 1) * sizeof(TCHAR));
}

void CFTEditDlg::_CleanupProgIDs()
{
    if (_hHeapProgID)
        HeapDestroy(_hHeapProgID);
}

///////////////////////////////////////////////////////////////////////////////
// Windows boiler plate code
LRESULT CFTEditDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_FT_EDIT_ADVANCED:
            lRes = OnAdvancedButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_EDIT_EXT_EDIT:
            lRes = OnEdit(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        default:
            lRes = CFTDlg::OnCommand(wParam, lParam);
            break;
    }

    return lRes;    
}

LRESULT CFTEditDlg::WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(uMsg)
    {
        case WM_TIMER:
            if (ID_TIMER == wParam)
                lRes = OnTimer((UINT)wParam);
            else
                lRes = CFTDlg::WndProc(uMsg, wParam, lParam);
            break;

        default:
            lRes = CFTDlg::WndProc(uMsg, wParam, lParam);
            break;
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftprop.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "help.h"

#include "ascstr.h"
#include "ftcmmn.h"

#include "ftprop.h"
#include "ftedit.h"
#include "ftadv.h"

#define SUBITEM_EXT         0
#define SUBITEM_PROGIDDESCR 1

#define WM_FINISHFILLLISTVIEW (WM_USER + 1)

static DWORD s_rgdwHelpIDsArray[] =
{  // Context Help IDs
    IDC_NO_HELP_1,                NO_HELP,
    IDC_FT_PROP_LV_FILETYPES,     IDH_FCAB_FT_PROP_LV_FILETYPES,
    IDC_FT_PROP_ANIM,             IDH_FCAB_FT_PROP_LV_FILETYPES,
    IDC_FT_PROP_NEW,              IDH_FCAB_FT_PROP_NEW,
    IDC_FT_PROP_OPENEXE_TXT,      IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_OPENICON,         IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_OPENEXE,          IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_CHANGEOPENSWITH,  IDH_FPROP_GEN_CHANGE,
    IDC_FT_PROP_TYPEOFFILE_TXT,   IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_EDITTYPEOFFILE,   IDH_FCAB_FT_PROP_EDIT,
    IDC_FT_PROP_GROUPBOX,         IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_REMOVE,           IDH_FCAB_FT_PROP_REMOVE,
    0, 0
};

CFTPropDlg::CFTPropDlg() :
    CFTDlg((ULONG_PTR)s_rgdwHelpIDsArray), _iLVSel(-1), _fStopThread(FALSE)
{}


LRESULT CFTPropDlg::OnInitDialog(WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = _InitAssocStore();

    if (SUCCEEDED(hres))
        hres = _InitListView();

    if (SUCCEEDED(hres))
        _InitPreFillListView();
    
    if (SUCCEEDED(hres))
        SHCreateThread(_FillListViewWrapper, (LPVOID)this,  0, _ThreadAddRefCallBack);

    return TRUE;
}

LRESULT CFTPropDlg::OnFinishInitDialog()
{
    HRESULT hres;
    
    _InitPostFillListView();
    hres = _SelectListViewItem(0);


    if (FAILED(hres))
    {
        if (E_OUTOFMEMORY == hres)
        {
            ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_ERROR + 
                ERROR_NOT_ENOUGH_MEMORY), MAKEINTRESOURCE(IDS_FT), 
                MB_OK | MB_ICONSTOP);
        }

        EndDialog(_hwnd, -1);
    }
    else
        SHCreateThread(_UpdateAllListViewItemImagesWrapper, (LPVOID)this,  0, _ThreadAddRefCallBack);

    return TRUE;
}

LRESULT CFTPropDlg::OnCtlColorStatic(WPARAM wParam, LPARAM lParam)
{
    LRESULT fRet = FALSE;
    // This is to set the color of the background of the animate control
    // see doc on ACS_TRANSPARENT and WM_CTLCOLORSTATIC
    if ((HWND)lParam == GetDlgItem(_hwnd, IDC_FT_PROP_ANIM))
    {
        SetBkColor(GET_WM_CTLCOLOR_HDC(wParam, lParam, WM_CTLCOLORSTATIC), GetSysColor(COLOR_WINDOW));
        fRet = (LRESULT)GetSysColorBrush(COLOR_WINDOW);
    }

    return fRet;
}

//static
DWORD WINAPI CFTPropDlg::_FillListViewWrapper(LPVOID lpParameter)
{
    ((CFTPropDlg*)lpParameter)->_FillListView();
    ((CFTPropDlg*)lpParameter)->Release();
    return 0;
}

//static
DWORD WINAPI CFTPropDlg::_UpdateAllListViewItemImagesWrapper(LPVOID lpParameter)
{
    ((CFTPropDlg*)lpParameter)->_UpdateAllListViewItemImages();
    ((CFTPropDlg*)lpParameter)->Release();
    return 0;
}

//static
DWORD WINAPI CFTPropDlg::_ThreadAddRefCallBack(LPVOID lpParameter)
{
    return ((CFTPropDlg*)lpParameter)->AddRef();
}


LRESULT CFTPropDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    DWORD dwRet = FALSE;
    int iCount = 0;
    LVITEM lvItem = {0};
    HWND hwndLV = _GetLVHWND();

    _fStopThread = TRUE;
    
    HICON hIconOld = (HICON)SendDlgItemMessage(_hwnd, IDC_FT_PROP_OPENICON, STM_GETIMAGE, IMAGE_ICON,
        (LPARAM)0);

    if (hIconOld)
        DeleteObject(hIconOld);

    // go through all the items in the listview and delete the strings dynamically
    // allocated for progIDs
    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = SUBITEM_EXT;

    iCount = ListView_GetItemCount(hwndLV);

    for (lvItem.iItem = 0; lvItem.iItem < iCount; ++lvItem.iItem)
    {
        ListView_GetItem(hwndLV, &lvItem);

        if (lvItem.lParam)
        {
            LocalFree((HLOCAL)lvItem.lParam);
        }
    }

    CFTDlg::OnDestroy(wParam, lParam);

    return TRUE;
}

struct LVCOMPAREINFO
{
    HWND    hwndLV;
    int     iCol;
};

int CALLBACK AlphaCompareItem(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    struct LVCOMPAREINFO   *plvci = (struct LVCOMPAREINFO *)lParamSort;
    TCHAR   sz1[MAX_PATH];
    TCHAR   sz2[MAX_PATH];

    ListView_GetItemText(plvci->hwndLV, lParam1, plvci->iCol, sz1, ARRAYSIZE(sz1));
    ListView_GetItemText(plvci->hwndLV, lParam2, plvci->iCol, sz2, ARRAYSIZE(sz2));

    return lstrcmpi(sz1, sz2);
}

LRESULT CFTPropDlg::OnListViewColumnClick(int iCol)
{
    struct LVCOMPAREINFO lvci;
    
    lvci.hwndLV = _GetLVHWND();
    lvci.iCol = iCol;

    _fUpdateImageAgain = TRUE;

    return SendMessage(_GetLVHWND(), LVM_SORTITEMSEX, (WPARAM)&lvci, (LPARAM)AlphaCompareItem);    
}

LRESULT CFTPropDlg::OnListViewSelItem(int iItem, LPARAM lParam)
{
    //
    // Need to update the lower pane of the dialog
    //
    // Get the extension
    TCHAR szExt[MAX_EXT];
    TCHAR szProgIDDescr[MAX_PROGIDDESCR];
    LVITEM lvItem = {0};

    _iLVSel = iItem;

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.iItem = iItem;
    lvItem.iSubItem = SUBITEM_EXT;
    lvItem.pszText = szExt;
    lvItem.cchTextMax = ARRAYSIZE(szExt);

    ListView_GetItem(_GetLVHWND(), &lvItem);

    ListView_GetItemText(_GetLVHWND(), iItem, SUBITEM_PROGIDDESCR, szProgIDDescr,
        ARRAYSIZE(szProgIDDescr));

    _EnableLowerPane(TRUE);

    if (!lvItem.lParam)
    {
        _UpdateGroupBox(szExt, TRUE);
    }
    else
    {
        _UpdateGroupBox(szProgIDDescr, FALSE);
    }

    _UpdateProgIDButtons(szExt, (LPTSTR)lvItem.lParam);

    // We rely on this being after _UpdateProgIDButtons (see _fPerUserAdvButton)
    _UpdateDeleteButton(lvItem.lParam ? FALSE : TRUE);
    _UpdateAdvancedText(szExt, szProgIDDescr, lvItem.lParam ? FALSE : TRUE);

    _UpdateOpensWith(szExt, (LPTSTR)lvItem.lParam);

    return FALSE;
}

HRESULT CFTPropDlg::_UpdateDeleteButton(BOOL fExt)
{
    BOOL fTrue = _ShouldEnableButtons();

    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_REMOVE),
        (_fPerUserAdvButton || !fExt) ? FALSE : fTrue);

    return S_OK;
}

HRESULT CFTPropDlg::_UpdateProgIDButtons(LPTSTR pszExt, LPTSTR pszProgID)
{
    HRESULT hres = E_FAIL;

    if (pszExt && *pszExt)
    {
        TCHAR szButtonText[50];
        HWND hwndAdvButton = GetDlgItem(_hwnd, IDC_FT_PROP_EDITTYPEOFFILE);

        _SetAdvancedRestoreButtonHelpID(IDH_FCAB_FT_PROP_EDIT);

        // Is this a progID only association?
        if (!pszProgID)
        {
            // No
            IAssocInfo* pAI;

            hres = _pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);

            if (SUCCEEDED(hres))
            {
                hres = pAI->GetBOOL(AIBOOL_PERUSERINFOAVAILABLE, &_fPerUserAdvButton);

                ASSERT(SUCCEEDED(hres) || (FAILED(hres) && (FALSE == _fPerUserAdvButton)));

                if (_fPerUserAdvButton)
                {
                    // Restore mode
                    LoadString(g_hinst, IDS_FT_PROP_BTN_RESTORE, szButtonText, ARRAYSIZE(szButtonText));

                    _SetAdvancedRestoreButtonHelpID(IDH_FCAB_FT_PROP_EDIT_RESTORE);
                }
                else
                {
                    TCHAR szProgID[MAX_PROGID];
                    DWORD cchProgID = ARRAYSIZE(szProgID);

                    hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                    LoadString(g_hinst, IDS_FT_PROP_BTN_ADVANCED, szButtonText, ARRAYSIZE(szButtonText));

                    if (SUCCEEDED(hres))
                    {
                        IAssocInfo * pAIProgID;

                        hres = _pAssocStore->GetAssocInfo(szProgID, AIINIT_PROGID, &pAIProgID);

                        if (SUCCEEDED(hres))
                        {
                            BOOL fEdit = _ShouldEnableButtons();

                            if (fEdit)
                            {
                                pAIProgID->GetBOOL(AIBOOL_EDIT, &fEdit);
                            }

                            EnableWindow(hwndAdvButton, fEdit);

                            pAIProgID->Release();
                        }
                    }
                }

                pAI->Release();
            }
        }
        else
        {
            // Yes
            IAssocInfo* pAIProgID;

            LoadString(g_hinst, IDS_FT_PROP_BTN_ADVANCED, szButtonText, ARRAYSIZE(szButtonText));

            hres = _pAssocStore->GetAssocInfo(pszProgID, AIINIT_PROGID, &pAIProgID);

            if (SUCCEEDED(hres))
            {
                BOOL fEdit = _ShouldEnableButtons();

                if (fEdit)
                {
                    pAIProgID->GetBOOL(AIBOOL_EDIT, &fEdit);
                }

                EnableWindow(hwndAdvButton, fEdit);

                pAIProgID->Release();
            }

            EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_CHANGEOPENSWITH), FALSE);
        }

        SetWindowText(hwndAdvButton, szButtonText);
    }

    return hres;
}

LRESULT CFTPropDlg::OnDeleteButton(WORD wNotif)
{
    // Warn user about the evil consequences of his act
    if (ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_REMOVETYPE),
        MAKEINTRESOURCE(IDS_FT), MB_YESNO | MB_ICONQUESTION) == IDYES)
    {
        LVITEM lvItem = {0};
        TCHAR szExt[MAX_EXT];

        // Set stuff
        lvItem.iSubItem = SUBITEM_EXT;
        lvItem.pszText = szExt;
        lvItem.cchTextMax = ARRAYSIZE(szExt);

        if (_GetListViewSelectedItem(LVIF_TEXT | LVIF_IMAGE, 0, &lvItem))
        {
            HRESULT hres;
            IAssocInfo* pAI;

            hres = _pAssocStore->GetAssocInfo(szExt, AIINIT_EXT, &pAI);

            if (SUCCEEDED(hres))
            {
                hres = pAI->Delete(AIALL_NONE);

                if (SUCCEEDED(hres))
                {
                    _DeleteListViewItem(lvItem.iItem);

                    PropSheet_CancelToClose(GetParent(_hwnd));
                }

                pAI->Release();
            }
        }
    }

    return FALSE;
}

LRESULT CFTPropDlg::OnNewButton(WORD wNotif)
{
    FTEDITPARAM ftEditParam;
    CFTEditDlg* pEditDlg = NULL;

    // Fill structure
    ftEditParam.dwExt = ARRAYSIZE(ftEditParam.szExt);
    ftEditParam.dwProgIDDescr = ARRAYSIZE(ftEditParam.szProgIDDescr);

    // This one should be one way, it will come back with a value
    *ftEditParam.szProgID = 0;
    ftEditParam.dwProgID = ARRAYSIZE(ftEditParam.szProgID);

    pEditDlg = new CFTEditDlg(&ftEditParam);

    if (pEditDlg)
    {
        if (IDOK == pEditDlg->DoModal(g_hinst, MAKEINTRESOURCE(DLG_FILETYPEOPTIONSEDITNEW),
                        _hwnd))
        {
            HWND hwndLV = _GetLVHWND();
            LRESULT lRes = 0;
            int iIndex = -1;
            HRESULT hres = E_FAIL;
            IAssocInfo* pAI = NULL;
            LVFINDINFO lvFindInfo = {0};
            LPTSTR pszExtNoDot = NULL;
            LVITEM lvItem = {0};
            TCHAR szExt[MAX_EXT];

            lvItem.pszText = szExt;
            lvItem.cchTextMax = ARRAYSIZE(szExt);

            pszExtNoDot = (TEXT('.') != *(ftEditParam.szExt)) ? ftEditParam.szExt :
                ftEditParam.szExt + 1;

            lvFindInfo.flags = LVFI_STRING;
            lvFindInfo.psz = pszExtNoDot;

            iIndex = ListView_FindItem(hwndLV, -1, &lvFindInfo);

            // Is this a brand new Ext-ProgID association?
            if (-1 == iIndex)
            {
                // Yes, Insert a new item
                SetWindowRedraw(hwndLV, FALSE);
            
                // Add new ext-progID association
                hres = _pAssocStore->GetAssocInfo(ftEditParam.szExt, AIINIT_EXT, &pAI);

                if (SUCCEEDED(hres))
                {
                    TCHAR szProgIDDescr[MAX_PROGIDDESCR];
                    DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);

                    hres = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr, &cchProgIDDescr);

                    if (FAILED(hres) || !*szProgIDDescr)
                    {
                        MakeDefaultProgIDDescrFromExt(szProgIDDescr, ARRAYSIZE(szProgIDDescr), pszExtNoDot);
                    }

                    // Add to the listview
                    iIndex = _InsertListViewItem(0, pszExtNoDot, szProgIDDescr);
                    pAI->Release();
                }

                // Select newly inserted item
                if (-1 != iIndex)
                {
                    _SelectListViewItem(iIndex);
                }

                // Redraw our list
                SetWindowRedraw(hwndLV, TRUE);

                _GetListViewSelectedItem(LVIF_PARAM | LVIF_TEXT, 0, &lvItem);

                lvItem.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
            }
            else
            {
                // No just update the item
                lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                lvItem.iItem = iIndex;

                ListView_GetItem(hwndLV, &lvItem);
            }

            _UpdateListViewItem(&lvItem);

            PropSheet_CancelToClose(GetParent(_hwnd));
        }

        pEditDlg->Release();
    }

    return FALSE;
}

LRESULT CFTPropDlg::OnAdvancedButton(WORD wNotif)
{
    LVITEM lvItem = {0};
    TCHAR szExt[MAX_EXT];

    // Set stuff
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvItem.iSubItem = SUBITEM_EXT;
    lvItem.pszText = szExt;
    lvItem.cchTextMax = ARRAYSIZE(szExt);

    if (_GetListViewSelectedItem(LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM, 0, &lvItem))
    {
        HRESULT hres;
        IAssocInfo* pAI;

        if (_fPerUserAdvButton)
        {
            // Restore mode
            hres = _pAssocStore->GetAssocInfo(szExt, AIINIT_EXT, &pAI);

            if (SUCCEEDED(hres))
            {
                hres = pAI->Delete(AIALL_PERUSER);

                _UpdateListViewItem(&lvItem);

                OnListViewSelItem(lvItem.iItem, (LPARAM)NULL);

                pAI->Release();

                PropSheet_CancelToClose(GetParent(_hwnd));
            }
        }
        else
        {
            // we might deal with an ext-progid assoc or only a progID
            TCHAR szProgID[MAX_PROGID];

            // Is this a progID only?
            if (lvItem.lParam)
            {
                // Yes
                StrCpyN(szProgID, (LPTSTR)lvItem.lParam, ARRAYSIZE(szProgID));

                hres = S_OK;
            }
            else
            {
                // No
                DWORD cchProgID = ARRAYSIZE(szProgID);

                hres = _pAssocStore->GetAssocInfo(szExt, AIINIT_EXT, &pAI);

                if (SUCCEEDED(hres))
                {
                    hres = THR(pAI->GetString(AISTR_PROGID, szProgID, &cchProgID));

                    pAI->Release();
                }
            }

            if (SUCCEEDED(hres))
            {
                CFTAdvDlg* pAdvDlg = new CFTAdvDlg(szProgID, szExt);

                if (pAdvDlg)
                {
                    if (IDOK == pAdvDlg->DoModal(g_hinst, MAKEINTRESOURCE(DLG_FILETYPEOPTIONSEDIT), _hwnd))
                    {
                        _UpdateListViewItem(&lvItem);

                        OnListViewSelItem(lvItem.iItem, (LPARAM)NULL);

                        PropSheet_CancelToClose(GetParent(_hwnd));
                    }

                    pAdvDlg->Release();
                }
            }
        }
    }

    return FALSE;
}

LRESULT CFTPropDlg::OnChangeButton(WORD wNotif)
{
    // Bring up the "Open With" dialog
    LVITEM lvItem = {0};
    TCHAR szExt[MAX_EXT];

    // Set stuff
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvItem.iSubItem = SUBITEM_EXT;
    lvItem.pszText = szExt;
    lvItem.cchTextMax = ARRAYSIZE(szExt);

    if (_GetListViewSelectedItem(LVIF_TEXT, 0, &lvItem))
    {
        TCHAR szDotExt[MAX_EXT];
        OPENASINFO oai;

        *szDotExt = TEXT('.');
        StrCpyN(szDotExt + 1, szExt, ARRAYSIZE(szDotExt) - 1);

        oai.pcszFile = szDotExt;
        oai.pcszClass = NULL;
        oai.dwInFlags = (OAIF_REGISTER_EXT | OAIF_FORCE_REGISTRATION); // we want the association to be made

        if (SUCCEEDED(OpenAsDialog(GetParent(_hwnd), &oai)))
        {
            // we changed the association so update the "Opens with:" text
            _UpdateOpensWith(szExt, NULL);

            // we don't need LVIF_PARAM since we enable the Change button only for Ext-ProgID asssoc
            lvItem.mask = LVIF_TEXT | LVIF_IMAGE;

            _UpdateListViewItem(&lvItem);

            OnListViewSelItem(lvItem.iItem, (LPARAM)NULL);

            PropSheet_CancelToClose(GetParent(_hwnd));
        }
    }

    return FALSE;
}

HRESULT CFTPropDlg::_UpdateGroupBox(LPTSTR pszText, BOOL fExt)
{
    HRESULT hres = E_OUTOFMEMORY;
    LPTSTR psz = NULL;

    if (fExt)
    {
        psz = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_FT_PROP_DETAILSFOR), pszText);
    }
    else
    {
        psz = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_FT_PROP_DETAILSFORPROGID), pszText);
    }

    if (psz)
    {
        SetDlgItemText(_hwnd, IDC_FT_PROP_GROUPBOX, psz);
        LocalFree(psz);
        hres = S_OK;
    }

    return hres;
}

HRESULT CFTPropDlg::_UpdateOpensWith(LPTSTR pszExt, LPTSTR pszProgID)
{
    HICON hIconOld = NULL;

    if (!pszProgID)
    {
        IAssocInfo* pAI = NULL;

        HRESULT hres = _pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);

        if (SUCCEEDED(hres))
        {
            TCHAR szAppFriendlyName[MAX_APPFRIENDLYNAME];
            DWORD dwAppFriendlyName = ARRAYSIZE(szAppFriendlyName);

            hres = pAI->GetString(AISTR_APPFRIENDLY, szAppFriendlyName, &dwAppFriendlyName);

            if (SUCCEEDED(hres))
            {
                HICON hIcon = NULL;
                int iIcon;
                SetDlgItemText(_hwnd, IDC_FT_PROP_OPENEXE, szAppFriendlyName);

                hres = pAI->GetDWORD(AIDWORD_APPSMALLICON, (DWORD*)&iIcon);

                HIMAGELIST hIL = NULL;

                // PERF: Why don't we just use _hImageList?  Or ListView_GetImageList()?
                Shell_GetImageLists(NULL, &hIL);

                if (hIL && SUCCEEDED(hres))
                {
                    hIcon = ImageList_ExtractIcon(g_hinst, hIL, iIcon);
                }

                hIconOld = (HICON)SendDlgItemMessage(_hwnd, IDC_FT_PROP_OPENICON, STM_SETIMAGE, IMAGE_ICON,
                    (LPARAM)hIcon);

                if (hIconOld)
                    DestroyIcon(hIconOld);
            }
            else
            {
                SetDlgItemText(_hwnd, IDC_FT_PROP_OPENEXE, TEXT(" "));

                hIconOld = (HICON)SendDlgItemMessage(_hwnd, IDC_FT_PROP_OPENICON, STM_SETIMAGE, IMAGE_ICON,
                    (LPARAM)NULL);

                if (hIconOld)
                    DestroyIcon(hIconOld);
            }

            pAI->Release();
        }
    }
    else
    {
        SetDlgItemText(_hwnd, IDC_FT_PROP_OPENEXE, TEXT(" "));

        hIconOld = (HICON)SendDlgItemMessage(_hwnd, IDC_FT_PROP_OPENICON, STM_SETIMAGE, IMAGE_ICON,
            (LPARAM)NULL);

        if (hIconOld)
            DestroyIcon(hIconOld);
    }
    
    return S_OK;
}

HRESULT CFTPropDlg::_UpdateAdvancedText(LPTSTR pszExt, LPTSTR pszFileType, BOOL fExt)
{
    HRESULT hres = S_OK;
    LPTSTR psz = NULL;

    if (_fPerUserAdvButton)
    {
        TCHAR szProgIDDescr[MAX_PROGIDDESCR];
        DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);
        IAssocInfo* pAI = NULL;

        // we need to show the previous progIDDescr
        hres = _pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);

        if (SUCCEEDED(hres))
        {
            hres = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr,
                    &cchProgIDDescr);

            if (SUCCEEDED(hres))
            {
                // Restore mode
                psz = ShellConstructMessageString(HINST_THISDLL,
                    MAKEINTRESOURCE(IDS_FT_PROP_RESTORE),
                    pszExt, szProgIDDescr);
            }

            pAI->Release();
        }
    }
    else
    {
        if (fExt)
        {
            psz = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_FT_PROP_ADVANCED),
                        pszExt, pszFileType, pszFileType);
        }
        else
        {
            psz = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_FT_PROP_ADVANCED_PROGID),
                        pszFileType);
        }
    }

    if (SUCCEEDED(hres))
    {
        if (psz)
        {
            SetDlgItemText(_hwnd, IDC_FT_PROP_TYPEOFFILE_TXT, psz);
            LocalFree(psz);
        }
        else
            hres = E_OUTOFMEMORY;
    }

    return hres;
}

HRESULT CFTPropDlg::_EnableLowerPane(BOOL fEnable)
{
    BOOL fTrue = _ShouldEnableButtons();

    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_OPENEXE_TXT), fEnable);
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_OPENEXE), fEnable);
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_TYPEOFFILE_TXT), fEnable);
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_GROUPBOX ), fEnable);

    // if user is locked down then we do not enable the buttons
    if (!fTrue)
        fEnable = FALSE;

    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_CHANGEOPENSWITH), fEnable);
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_EDITTYPEOFFILE), fEnable);

    return S_OK;
}

HRESULT CFTPropDlg::_InitPreFillListView()
{
    // Disable New and Delete
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_NEW), FALSE);
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_REMOVE), FALSE);

    _EnableLowerPane(FALSE);
    _UpdateGroupBox(TEXT(""), TRUE);

    // Hide the advanced text
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_PROP_TYPEOFFILE_TXT), SW_HIDE);

    return S_OK;
}

HRESULT CFTPropDlg::_InitPostFillListView()
{
    BOOL fTrue = _ShouldEnableButtons();

    // Enable New and Delete
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_NEW),  fTrue);
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_REMOVE), fTrue);

    // Show the advanced text
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_PROP_TYPEOFFILE_TXT), SW_SHOW);

    Animate_Stop(GetDlgItem(_hwnd, IDC_FT_PROP_ANIM));
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_PROP_ANIM), SW_HIDE);
    ShowWindow(_GetLVHWND(), SW_SHOW);

    SetFocus(_GetLVHWND());

    return S_OK;
}

HRESULT CFTPropDlg::_InitListView()
{
    HRESULT hres = S_OK;
    LVCOLUMN lvColumn = {0};
    HWND hwndLV = _GetLVHWND();
    TCHAR szColumnTitle[40];
    RECT rc = {0};
    int iWidth = 80;
    HWND hwndAni;

    //
    // Styles
    //
    ListView_SetExtendedListViewStyleEx(hwndLV, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

    //
    // Set the columns
    //
    lvColumn.mask = LVCF_TEXT|LVCF_SUBITEM|LVCF_WIDTH;

    // Extensions column
    LoadString(g_hinst, IDS_FT_PROP_EXTENSIONS, szColumnTitle, ARRAYSIZE(szColumnTitle));

    lvColumn.cx = 60;
    lvColumn.pszText = szColumnTitle;
    lvColumn.cchTextMax = lstrlen(szColumnTitle);
    lvColumn.iSubItem = SUBITEM_EXT;

    ListView_InsertColumn(hwndLV, SUBITEM_EXT, &lvColumn);

    // ProgIDs column
    LoadString(g_hinst, IDS_FT, szColumnTitle, ARRAYSIZE(szColumnTitle));

    lvColumn.cchTextMax = lstrlen(szColumnTitle);
    lvColumn.iSubItem = SUBITEM_PROGIDDESCR;
    ListView_InsertColumn(hwndLV, SUBITEM_PROGIDDESCR, &lvColumn);

    // Adjust columns width
    // we need to do it after inserting both col, cause the last column resizing 
    // is special cased in list view code.

    // Ext column
    ListView_SetColumnWidth(hwndLV, SUBITEM_EXT, LVSCW_AUTOSIZE_USEHEADER);
    iWidth = ListView_GetColumnWidth(hwndLV, SUBITEM_EXT);

    // File type column
    GetClientRect(hwndLV, &rc);
    ListView_SetColumnWidth(hwndLV, SUBITEM_PROGIDDESCR,
        rc.right - iWidth - GetSystemMetrics(SM_CXBORDER) - GetSystemMetrics(SM_CXVSCROLL));

    //
    // ImageList
    //
    Shell_GetImageLists(NULL, &_hImageList);

    if (_hImageList)
        ListView_SetImageList(hwndLV, _hImageList, LVSIL_SMALL);

    GetWindowRect(hwndLV, &rc);
    MapWindowPoints(NULL, _hwnd, (POINT*)&rc, 2);

    hwndAni = GetDlgItem(_hwnd, IDC_FT_PROP_ANIM);

    Animate_Open(hwndAni, MAKEINTRESOURCE(IDA_SEARCH)); // open the resource
    Animate_Play(hwndAni, 0, -1, -1);     // play from start to finish and repeat

    MoveWindow(hwndAni, rc.left, rc.top,
        rc.right - rc.left, rc.bottom - rc.top, TRUE);

    ShowWindow(hwndLV, SW_HIDE);

    ShowWindow(hwndAni, SW_SHOW);

    return hres;
}

HRESULT CFTPropDlg::_FillListView()
{
    // Data stuff
    IEnumAssocInfo* pEnum = NULL;
    HRESULT hres = E_FAIL;
    int iFirstNAItem = -1;
    HWND hwndLV = NULL;
    int iItem = 0;
    TCHAR szNA[50];

    ASSERT(_pAssocStore);

    // Do the extension first
    if (!_fStopThread)
    {
        hwndLV = _GetLVHWND();
        SetWindowRedraw(hwndLV, FALSE);
    }

    if (!_fStopThread)
    {
        LoadString(g_hinst, IDS_FT_NA, szNA, ARRAYSIZE(szNA));
        hres = _pAssocStore->EnumAssocInfo(ASENUM_EXT |
            ASENUM_ASSOC_YES | ASENUM_NOEXCLUDED | ASENUM_NOEXPLORERSHELLACTION |
            ASENUM_NOEXE, NULL, AIINIT_NONE, &pEnum);
    }
    else
        hres = E_FAIL;

    
    if (SUCCEEDED(hres))
    {
        IAssocInfo* pAI = NULL;
    
        while (!_fStopThread && (S_OK == pEnum->Next(&pAI)))
        {
            TCHAR szExt[MAX_EXT];
            DWORD cchExt = ARRAYSIZE(szExt);

            hres = pAI->GetString(AISTR_EXT, szExt, &cchExt);

            if (SUCCEEDED(hres))
            {
                BOOL fPerUser = FALSE;
                TCHAR szProgIDDescr[MAX_PROGIDDESCR];
                DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);
                HRESULT hresTmp = E_FAIL;

                hresTmp = pAI->GetBOOL(AIBOOL_PERUSERINFOAVAILABLE, &fPerUser);

                ASSERT(SUCCEEDED(hresTmp) || (FAILED(hresTmp) && (FALSE == fPerUser)));

                if (!fPerUser)
                {
                    hresTmp = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr,
                            &cchProgIDDescr);
                }
            
                if (fPerUser || FAILED(hresTmp) || !*szProgIDDescr)
                    MakeDefaultProgIDDescrFromExt(szProgIDDescr, ARRAYSIZE(szProgIDDescr), szExt);
                    
                if (!_fStopThread)
                    _InsertListViewItem(iItem, szExt, szProgIDDescr);

                // See comment in ftenum.cpp, CFTEnumAssocInfo::_EnumKCRStop about sorting
                // Check if this is where we need to insert the N/A item later
                if ((-1 == iFirstNAItem) && (lstrcmpi(szExt, szNA) > 0))
                {
                    iFirstNAItem = iItem;
                }
                ++iItem;
            }

            pAI->Release();

            hres = S_OK;
        }

        pEnum->Release();
        pEnum = NULL;
    }

    // Then do the ProgIDs
    if (!_fStopThread)    
        hres = _pAssocStore->EnumAssocInfo(ASENUM_PROGID | ASENUM_SHOWONLY, NULL, AIINIT_NONE, &pEnum);
    else
        hres = E_FAIL;
        
    if (SUCCEEDED(hres))
    {
        IAssocInfo* pAI = NULL;
        int cNAItem = 0;

        while (!_fStopThread && (S_OK == pEnum->Next(&pAI)))
        {
            TCHAR szProgIDDescr[MAX_PROGIDDESCR];
            DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);

            hres = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr, &cchProgIDDescr);

            if (SUCCEEDED(hres))
            {
                TCHAR szProgID[MAX_PROGID];
                DWORD cchProgID = ARRAYSIZE(szProgID);

                hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                if (SUCCEEDED(hres))
                {
                    // we need to sort the N/A items by the description since they all begin with "N/A"
                    int iNAItem;

                    if (!cNAItem)
                    {
                        iNAItem = iFirstNAItem;
                    }
                    else
                    {
                        if (!_fStopThread)
                            iNAItem = _GetNextNAItemPos(iFirstNAItem, cNAItem, szProgIDDescr);
                    }

                    if (!_fStopThread)
                    {
                        _InsertListViewItem(iNAItem, szNA, szProgIDDescr, szProgID);
                        ++cNAItem;
                    }
                }
            }

            pAI->Release();

            hres = S_OK;
        }

        pEnum->Release();
    }

    if (!_fStopThread)
    {
        SetWindowRedraw(hwndLV, TRUE);
        PostMessage(_hwnd, WM_FINISHFILLLISTVIEW, 0, 0);
    }
    
    return hres;
}

int CFTPropDlg::_GetNextNAItemPos(int iFirstNAItem, int cNAItem, LPTSTR pszProgIDDescr)
{
    LVITEM lvItem = {0};
    TCHAR szProgIDDescr[MAX_PROGIDDESCR];
    int iItem = iFirstNAItem;
    HWND hwndLV = _GetLVHWND();

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItem;
    lvItem.iSubItem = SUBITEM_PROGIDDESCR;
    lvItem.pszText = szProgIDDescr;
    lvItem.cchTextMax = ARRAYSIZE(szProgIDDescr);

    while (iItem < (iFirstNAItem + cNAItem))
    {
        if (ListView_GetItem(hwndLV, &lvItem))
        {
            if (lstrcmpi(pszProgIDDescr, lvItem.pszText) >= 0)
            {
                ++iItem;
                lvItem.iItem = iItem;
            }
            else
            {
                break;
            }
        }
        else
        {
            // This happens when the listview is destroyed (on another thread),
            // but this thread is still doing some work.  The call above fails,
            // we break here or else we'll never go out of the loop.
            break;
        }
    }

    return iItem;
}

DWORD CFTPropDlg::_UpdateAllListViewItemImages()
{
    HWND hwndLV = NULL;
    int iCount = 0;
    LVITEM lvItem = {0};
    TCHAR szExt[MAX_EXT];
    HRESULT hres = E_FAIL;


    HRESULT hrInit = SHCoInitialize();
 
    lvItem.iSubItem = SUBITEM_EXT;
    lvItem.pszText = szExt;
    lvItem.cchTextMax = ARRAYSIZE(szExt);

    if (!_fStopThread)
        hwndLV = _GetLVHWND();

    do
    {
        _fUpdateImageAgain = FALSE;
        
        if (!_fStopThread)
            iCount = ListView_GetItemCount(hwndLV);
        
        for (lvItem.iItem = 0; !_fStopThread && (lvItem.iItem < iCount);
            ++lvItem.iItem)
        {
            IAssocInfo* pAI = NULL;

            lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            
            if (!_fStopThread)
                ListView_GetItem(hwndLV, &lvItem);
            
            if (!_fStopThread && !lvItem.lParam)
            {
                hres = _pAssocStore->GetAssocInfo(szExt, AIINIT_EXT, &pAI);

                if (SUCCEEDED(hres))
                {
                    BOOL fPerUser = FALSE;

                    hres = pAI->GetBOOL(AIBOOL_PERUSERINFOAVAILABLE, &fPerUser);

                    ASSERT(SUCCEEDED(hres) || (FAILED(hres) && (FALSE == fPerUser)));

                    if (fPerUser)
                        hres = pAI->GetDWORD(AIDWORD_DOCSMALLICON | AIALL_PERUSER, (DWORD*)&lvItem.iImage);
                    else
                        hres = pAI->GetDWORD(AIDWORD_DOCSMALLICON, (DWORD*)&lvItem.iImage);
                }
            }
            else
            {
                hres = _pAssocStore->GetAssocInfo((LPTSTR)lvItem.lParam, AIINIT_PROGID, &pAI);

                if (SUCCEEDED(hres))
                {
                    hres = pAI->GetDWORD(AIDWORD_DOCSMALLICON, (DWORD*)&lvItem.iImage);
                }
            }

            if (SUCCEEDED(hres))
            {
                lvItem.mask = LVIF_IMAGE;
                
                if (!_fStopThread)
                    ListView_SetItem(hwndLV, &lvItem);
            }

            if (pAI)
                pAI->Release();
        }
    }
    while (_fUpdateImageAgain && !_fStopThread);

    SHCoUninitialize(hrInit);

    return (DWORD)_fStopThread;
}

void CFTPropDlg::_UpdateListViewItem(LVITEM* plvItem)
{
    HWND hwndLV = _GetLVHWND();
    LVITEM lvItem = *plvItem;

    // Need to:
    //  - update image
    //  - update progIDDescr

    if (!lvItem.lParam)
    {
        IAssocInfo* pAI = NULL;

        HRESULT hres = _pAssocStore->GetAssocInfo(lvItem.pszText, AIINIT_EXT, &pAI);

        if (SUCCEEDED(hres))
        {
            TCHAR szProgIDDescr[MAX_PROGIDDESCR];
            DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);
            HRESULT hresTmp = E_FAIL;

            SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);
        
            // Icon
            BOOL fPerUser = FALSE;

            hres = pAI->GetBOOL(AIBOOL_PERUSERINFOAVAILABLE, &fPerUser);

            ASSERT(SUCCEEDED(hres) || (FAILED(hres) && (FALSE == fPerUser)));

            if (fPerUser)
                hres = pAI->GetDWORD(AIDWORD_DOCSMALLICON | AIALL_PERUSER, (DWORD*)&lvItem.iImage);
            else
                hres = pAI->GetDWORD(AIDWORD_DOCSMALLICON, (DWORD*)&lvItem.iImage);

            if (SUCCEEDED(hres))
            {
                lvItem.mask = LVIF_IMAGE;
                ListView_SetItem(hwndLV, &lvItem);
            }

            // ProgID Description
            if (!fPerUser)
            {
                hresTmp = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr,
                        &cchProgIDDescr);
            }
    
            if (fPerUser || FAILED(hresTmp) || !*szProgIDDescr)
                MakeDefaultProgIDDescrFromExt(szProgIDDescr, ARRAYSIZE(szProgIDDescr), lvItem.pszText);

            if (SUCCEEDED(hres))
            {
                lvItem.mask = LVIF_TEXT;
                lvItem.iSubItem = SUBITEM_PROGIDDESCR;
                lvItem.pszText = szProgIDDescr;
                lvItem.cchTextMax = lstrlen(szProgIDDescr);

                ListView_SetItem(hwndLV, &lvItem);
            }

            ListView_RedrawItems(hwndLV, lvItem.iItem, lvItem.iItem);

            pAI->Release();
        }
    }
    else
    {
        IAssocInfo* pAI = NULL;

        HRESULT hres = _pAssocStore->GetAssocInfo((LPTSTR)lvItem.lParam, AIINIT_PROGID, &pAI);

        if (SUCCEEDED(hres))
        {
            TCHAR szProgIDDescr[MAX_PROGIDDESCR];
            DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);
            HRESULT hresTmp = E_FAIL;

            SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);
        
            // Icon
            hres = pAI->GetDWORD(AIDWORD_DOCSMALLICON, (DWORD*)&lvItem.iImage);

            if (SUCCEEDED(hres))
            {
                lvItem.mask = LVIF_IMAGE;
                ListView_SetItem(hwndLV, &lvItem);
            }

            // ProgID Description
            pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr,
                    &cchProgIDDescr);

            if (SUCCEEDED(hres))
            {
                lvItem.mask = LVIF_TEXT;
                lvItem.iSubItem = SUBITEM_PROGIDDESCR;
                lvItem.pszText = szProgIDDescr;
                lvItem.cchTextMax = lstrlen(szProgIDDescr);

                ListView_SetItem(hwndLV, &lvItem);
            }
            ListView_RedrawItems(hwndLV, lvItem.iItem, lvItem.iItem);

            pAI->Release();
        }
    }
}

int CFTPropDlg::_InsertListViewItem(int iItem, LPTSTR pszExt, LPTSTR pszProgIDDescr,
                                    LPTSTR pszProgID)
{
    HWND hwndLV = _GetLVHWND();
    LVITEM lvItem = {0};
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;

    // Put generic icon

    lvItem.iImage = Shell_GetCachedImageIndex(TEXT("shell32.dll"), II_DOCNOASSOC, 0);

    CharUpper(pszExt);

    // Extension
    if (pszProgID)
    {
        lvItem.lParam = (LPARAM)LocalAlloc(LPTR, (lstrlen(pszProgID) + 1) * sizeof(TCHAR));

        if (lvItem.lParam)
            lstrcpy((LPTSTR)lvItem.lParam, pszProgID);
    }
    else
    {
        lvItem.lParam = NULL;
    }

    lvItem.iItem = iItem;
    lvItem.iSubItem = SUBITEM_EXT;
    lvItem.pszText = pszExt;
    lvItem.cchTextMax = lstrlen(pszExt);

    lvItem.iItem = ListView_InsertItem(hwndLV, &lvItem);

    if (-1 != lvItem.iItem)
    {
        // ProgID Description
        lvItem.mask = LVIF_TEXT;
        lvItem.iSubItem = SUBITEM_PROGIDDESCR;
        lvItem.pszText = pszProgIDDescr;
        lvItem.cchTextMax = lstrlen(pszProgIDDescr);

        ListView_SetItem(hwndLV, &lvItem);
    }
    else
    {
        // LocalFree checks for NULL
        LocalFree((HLOCAL)lvItem.lParam);
    }

    return lvItem.iItem;
}

HRESULT CFTPropDlg::_SelectListViewItem(int i)
{
    LVITEM lvItem = {0};

    lvItem.iItem = i;
    lvItem.mask = LVIF_STATE;
    lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;

    ListView_SetItem(_GetLVHWND(), &lvItem);
    ListView_EnsureVisible(_GetLVHWND(), i, FALSE);

    return S_OK;
}

HRESULT CFTPropDlg::_DeleteListViewItem(int i)
{
    HWND hwndLV = _GetLVHWND();
    int iCount = ListView_GetItemCount(hwndLV);
    int iNextSel = -1;        
    LVITEM lvItem = {0};

    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = i;
    lvItem.iSubItem = SUBITEM_EXT;

    ListView_GetItem(hwndLV, &lvItem);

    if (lvItem.lParam)
    {
        LocalFree((HLOCAL)lvItem.lParam);
    }

    ListView_DeleteItem(hwndLV, i);

    if (iCount > i)
        iNextSel = i;
    else
        if (i > 0)
            iNextSel = i - 1;

    if (-1 != iNextSel)
        _SelectListViewItem(iNextSel);

    return S_OK;
}

BOOL CFTPropDlg::_ShouldEnableButtons()
{
    // if we have a locked down user, then we never enable the buttons
    BOOL fRet = TRUE;

    if (S_FALSE == _pAssocStore->CheckAccess())
    {
        fRet = FALSE;
    }

    // If the REST_NOFILEASSOCIATE is set (TRUE), 
    // then we want to NOT enable buttons.
    fRet &= !SHRestricted(REST_NOFILEASSOCIATE);

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
// Misc
BOOL CFTPropDlg::_GetListViewSelectedItem(UINT uMask, UINT uStateMask, LVITEM* plvItem)
{
    BOOL fSel = FALSE;
    HWND hwndLV = _GetLVHWND();

    plvItem->mask = uMask | LVIF_STATE;
    plvItem->stateMask = uStateMask | LVIS_SELECTED;

    // Do we have the selection cached?
    if (-1 != _iLVSel)
    {
        // Yes, make sure it's valid
        plvItem->iItem = _iLVSel;

        ListView_GetItem(hwndLV, plvItem);

        if (plvItem->state & LVIS_SELECTED)
            fSel = TRUE;
    }
 
    // Cache was wrong
    if (!fSel)
    {
        int iCount = ListView_GetItemCount(hwndLV);

        for (int i=0; (i < iCount) && !fSel; ++i)
        {
            plvItem->iItem = i;
            ListView_GetItem(hwndLV, plvItem);

            if (plvItem->state & LVIS_SELECTED)
                fSel = TRUE;
        }

        if (fSel)
            _iLVSel = i;
    }

    return fSel;
}

HWND CFTPropDlg::_GetLVHWND()
{
    return GetDlgItem(_hwnd, IDC_FT_PROP_LV_FILETYPES);
}

void CFTPropDlg::_SetAdvancedRestoreButtonHelpID(DWORD dwID)
{
    for (int i = 0; i < ARRAYSIZE(s_rgdwHelpIDsArray); i += 2)
    {
        if (IDC_FT_PROP_EDITTYPEOFFILE == s_rgdwHelpIDsArray[i])
        {
            if (i + 1 < ARRAYSIZE(s_rgdwHelpIDsArray))
                s_rgdwHelpIDsArray[i + 1] = dwID;

            break;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// Windows boiler plate code
LRESULT CFTPropDlg::OnNotifyListView(UINT uCode, LPNMHDR pNMHDR)
{
    LRESULT lRes = FALSE;

    switch(uCode)
    {
        case LVN_GETINFOTIP:
        {
            NMLVGETINFOTIP* plvn = (NMLVGETINFOTIP*)pNMHDR;

            break;
        }
        case LVN_ITEMCHANGED:
        {
            NMLISTVIEW* pNMLV = (NMLISTVIEW*)pNMHDR;

            // Is a new item being selected?
            if ((pNMLV->uChanged & LVIF_STATE) &&
                (pNMLV->uNewState & (LVIS_SELECTED | LVIS_FOCUSED)))
            {
                // Yes
                OnListViewSelItem(pNMLV->iItem, pNMLV->lParam);
            }
            break;
        }

        case LVN_COLUMNCLICK:
        {
            NMLISTVIEW* pNMLV = (NMLISTVIEW*)pNMHDR;

            OnListViewColumnClick(pNMLV->iSubItem);
            break;
        }

        case NM_DBLCLK:
            if (IsWindowEnabled(GetDlgItem(_hwnd, IDC_FT_PROP_EDIT)))
                PostMessage(_hwnd, WM_COMMAND, (WPARAM)IDC_FT_PROP_EDIT, 0);
            break;
    }

    return lRes;
}

LRESULT CFTPropDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_FT_PROP_NEW:
            lRes = OnNewButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_PROP_REMOVE:
            lRes = OnDeleteButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_PROP_EDITTYPEOFFILE:
            lRes = OnAdvancedButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_PROP_CHANGEOPENSWITH:
            lRes = OnChangeButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        default:
            lRes = CFTDlg::OnCommand(wParam, lParam);
            break;
    }

    return lRes;    
}

LRESULT CFTPropDlg::OnNotify(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    LPNMHDR pNMHDR = (LPNMHDR)lParam;
    UINT_PTR idFrom = pNMHDR->idFrom;
    UINT uCode = pNMHDR->code;

    //GET_WM_COMMAND_CMD
    switch(idFrom)
    {
        case IDC_FT_PROP_LV_FILETYPES:
            lRes = OnNotifyListView(uCode, pNMHDR);
            break;
        default:
            lRes = CFTDlg::OnNotify(wParam, lParam);
            break;
    }

    return lRes;    
}

LRESULT CFTPropDlg::WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(uMsg)
    {
        case WM_CTLCOLORSTATIC:
            lRes = OnCtlColorStatic(wParam, lParam);
            break;

        case WM_FINISHFILLLISTVIEW:
            lRes = OnFinishInitDialog();
            break;

        default:
            lRes = CFTDlg::WndProc(uMsg, wParam, lParam);
            break;
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftedit.h ===
#ifndef FTEDIT_H
#define FTEDIT_H

#include "ftdlg.h"

typedef struct tagFTEDITPARAM
{
    TCHAR   szExt[MAX_EXT];
    DWORD   dwExt;
    TCHAR   szProgIDDescr[MAX_PROGIDDESCR];
    DWORD   dwProgIDDescr;
    TCHAR   szProgID[MAX_PROGID];
    DWORD   dwProgID;
} FTEDITPARAM;

class CFTEditDlg : public CFTDlg
{
public:
    CFTEditDlg(FTEDITPARAM* pftEditParam);
protected:
    ~CFTEditDlg();

///////////////////////////////////////////////////////////////////////////////
//  Implementation
private:
// Message handlers
    //Dialog messages
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnOK(WORD wNotif);
    LRESULT OnCancel(WORD wNotif);
    LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);

    //Control specific
    LRESULT OnAdvancedButton(WORD wNotif);
    LRESULT OnEdit(WORD wNotif);

    LRESULT OnTimer(UINT nTimer);

// Misc
    LRESULT WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

// Member variables
private:
    int             _iLVSel;

    BOOL            _fAdvanced;

    UINT_PTR        _nTimer;

    HANDLE          _hHeapProgID;
    FTEDITPARAM*    _pftEditParam;
///////////////////////////////////////////////////////////////////////////////
//  Helpers
private:
    HRESULT _GetProgIDDescrFromExt(LPTSTR pszExt, LPTSTR pszProgIDDescr,
        DWORD* pcchProgIDDescr);
    HRESULT _GetProgIDInfo(IAssocInfo* pAI, LPTSTR pszProgID, DWORD* pcchProgID,
        BOOL* pfNewProgID, BOOL* pfExplicitNew);
    HRESULT _HandleProgIDAssoc(IAssocInfo* pAI, LPTSTR pszExt, BOOL fExtExist);
    HRESULT _ProgIDComboHelper();
    void _ResizeDlg();
    HRESULT _FillProgIDDescrCombo();
    BOOL _SelectProgIDDescr(LPTSTR pszProgIDDescr);
    void _ConfigureDlg();
    LPTSTR _AddProgID(LPTSTR pszProgID);
    void _CleanupProgIDs();
};

#endif //FTEDIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftprop.h ===
#ifndef FTPROP_H
#define FTPROP_H

#include "ftdlg.h"

class CFTPropDlg : public CFTDlg
{
public:
    CFTPropDlg();
   
///////////////////////////////////////////////////////////////////////////////
//  Implementation
private:
// Message handlers
    LRESULT WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Dialog messages
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnFinishInitDialog();
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);

    // Misc
    LRESULT OnCtlColorStatic(WPARAM wParam, LPARAM lParam);

    // Control specific
        // ListView
    LRESULT OnNotifyListView(UINT uCode, LPNMHDR pNMHDR);
    LRESULT OnListViewSelItem(int iItem, LPARAM lParam);
    LRESULT OnListViewColumnClick(int iCol);
        // New, Remove, Edit buttons    
    LRESULT OnNewButton(WORD wNotif);
    LRESULT OnDeleteButton(WORD wNotif);
    LRESULT OnRemoveButton(WORD wNotif);
    LRESULT OnEditButton(WORD wNotif);
    LRESULT OnAdvancedButton(WORD wNotif);
    LRESULT OnChangeButton(WORD wNotif);


// Misc
    BOOL _GetListViewSelectedItem(UINT uMask, UINT uStateMask, LVITEM* plvItem);
// Member variables
private:
    HIMAGELIST          _hImageList;
    BOOL                _fPerUserAdvButton;
    BOOL                _fStopThread;
    BOOL                _fUpdateImageAgain;

    // Optimization
    int                 _iLVSel;
///////////////////////////////////////////////////////////////////////////////
//  Helpers
private:
    // General
    inline HWND _GetLVHWND();
    // Lower pane
    HRESULT _UpdateProgIDButtons(LPTSTR pszExt, LPTSTR pszProgID);
    HRESULT _UpdateGroupBox(LPTSTR pszExt, BOOL fExt);
    HRESULT _UpdateDeleteButton(BOOL fExt);
    HRESULT _UpdateOpensWith(LPTSTR pszExt, LPTSTR pszProgID);
    HRESULT _UpdateAdvancedText(LPTSTR pszExt, LPTSTR pszFileType, BOOL fExt);
    HRESULT _EnableLowerPane(BOOL fEnable = TRUE);
    // ListView
    HRESULT _InitListView();
    HRESULT _FillListView();
    HRESULT _SelectListViewItem(int i);
    HRESULT _DeleteListViewItem(int i);
    void _UpdateListViewItem(LVITEM* plvItem);

    HRESULT _InitPreFillListView();
    HRESULT _InitPostFillListView();

    DWORD _UpdateAllListViewItemImages();

    void _SetAdvancedRestoreButtonHelpID(DWORD dwID);

    int _GetNextNAItemPos(int iFirstNAItem, int cNAItem, LPTSTR pszProgIDDescr);

    static DWORD WINAPI _UpdateAllListViewItemImagesWrapper(LPVOID lpParameter);
    static DWORD WINAPI _FillListViewWrapper(LPVOID lpParameter);
    static DWORD WINAPI _ThreadAddRefCallBack(LPVOID lpParameter);

    int _InsertListViewItem(int iItem, LPTSTR pszExt, LPTSTR pszProgIDDescr, LPTSTR pszProgID = NULL);

    BOOL _ShouldEnableButtons();
};

#endif //FTPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\guids.h ===
#ifndef _GUIDS_H
#define _GUIDS_H

DEFINE_GUID(IID_IThumbnailMaker, 0x7aaa28d2, 0x3bf2, 0x11cf, 0xb6, 0xe6, 0x0, 0xaa, 0x0, 0xbb, 0xba, 0x9e);

// {2D09F2E0-6846-11d0-B811-00C04FD706EC}
DEFINE_GUID( TOID_DiskCacheTask, 0x2d09f2e0, 0x6846, 0x11d0, 0xb8, 0x11, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {1728D630-69E3-11d0-B815-00C04FD706EC}
DEFINE_GUID( TOID_ImgCacheTidyup, 0x1728d630, 0x69e3, 0x11d0, 0xb8, 0x15, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {78212180-BF15-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(TOID_ExtractImageTask, 0x78212180, 0xbf15, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {6DFD582C-92E3-11d1-98A3-00C04FB687DA}
DEFINE_GUID(TOID_DiskCacheCleanup, 0x6dfd582c, 0x92e3, 0x11d1, 0x98, 0xa3, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {EFC5437C-9847-11d1-98A4-00C04FB687DA}
DEFINE_GUID(TOID_UpdateDirHandler, 0xefc5437c, 0x9847, 0x11d1, 0x98, 0xa4, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {e7b2e826-7d5a-4011-8c88-9abb7dac6746}
DEFINE_GUID(TOID_ReadAheadHandler, 0xe7b2e826, 0x7d5a, 0x4011, 0x8c, 0x88, 0x9a, 0xbb, 0x7d, 0xac, 0x67, 0x46);

// {c87f14ef-b7f4-4a80-a406-2ed3c7ba8bd1}
DEFINE_GUID(TOID_WriteCacheHandler, 0xc87f14ef, 0xb7f4, 0x4a80, 0xa4, 0x06, 0x2e, 0xd3, 0xc7, 0xba, 0x8b, 0xd1);  

// {7EC9321A-0E09-11d2-81F8-00C04FB687DA}
DEFINE_GUID(TOID_CheckCacheTask, 0x7ec9321a, 0xe09, 0x11d2, 0x81, 0xf8, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {09F75242-D1A3-4969-A4DB-2298518D381D}
DEFINE_GUID(TOID_FolderImageTask, 0x9f75242, 0xd1a3, 0x4969, 0xa4, 0xdb, 0x22, 0x98, 0x51, 0x8d, 0x38, 0x1d);

// {4EF59929-6C53-4934-B4F4-AF65EC42AAB4}
DEFINE_GUID(IID_IPrintersBindInfo, 0x4ef59929, 0x6c53, 0x4934, 0xb4, 0xf4, 0xaf, 0x65, 0xec, 0x42, 0xaa, 0xb4);
#define PRINTER_BIND_INFO TEXT("PrintersBindInfo")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\futil.c ===
#include "shellprv.h"
#pragma  hdrstop
#include "netview.h"

// drivesx.c
DWORD PathGetClusterSize(LPCTSTR pszPath);

// get connection information including disconnected drives
//
// in:
//     pszDev   device name "A:" "LPT1:", etc.
//     bConvertClosed
//              if FALSE closed or error drives will be converted to
//              WN_SUCCESS return codes.  if TRUE return not connected
//              and error state values (ie, the caller knows about not
//              connected and error state drives)
//
// out:
//     lpPath   filled with net name if return is WN_SUCCESS (or not connected/error)
// returns:
//     WN_*     error code

DWORD GetConnection(LPCTSTR pszDev, LPTSTR pszPath, UINT cchPath, BOOL bConvertClosed)
{
    DWORD err;
    int iType = DriveType(DRIVEID(pszDev));
    if (DRIVE_REMOVABLE == iType || DRIVE_FIXED == iType || DRIVE_CDROM == iType || DRIVE_RAMDISK == iType)
        err = WN_NOT_CONNECTED;
    else
    {
        err = SHWNetGetConnection((LPTSTR)pszDev, pszPath, &cchPath);

        if (!bConvertClosed)
            if (err == WN_CONNECTION_CLOSED || err == WN_DEVICE_ERROR)
                err = WN_SUCCESS;
    }
    return err;
}

// this is called for every drive at init time so it must
// be sure to not trigget things like the phantom B: drive support
//
// in:
//      iDrive  zero based drive number (0 = A, 1 = B)
//
// returns:
//      0       not a net drive
//      1       is a net drive, properly connected
//      2       disconnected/error state connection

STDAPI_(int) IsNetDrive(int iDrive)
{
    if ((iDrive >= 0) && (iDrive < 26))
    {
        DWORD err;
        TCHAR szDrive[4], szConn[MAX_PATH];     // this really should be WNBD_MAX_LENGTH

        PathBuildRoot(szDrive, iDrive);

        err = GetConnection(szDrive, szConn, ARRAYSIZE(szConn), TRUE);

        if (err == WN_SUCCESS)
            return 1;

        if (err == WN_CONNECTION_CLOSED || err == WN_DEVICE_ERROR)
            if ((GetLogicalDrives() & (1 << iDrive)) == 0)
                return 2;
    }
    
    return 0;
}

typedef BOOL (WINAPI* PFNISPATHSHARED)(LPCTSTR pszPath, BOOL fRefresh);

HMODULE g_hmodShare = (HMODULE)-1;
PFNISPATHSHARED g_pfnIsPathShared = NULL;

// ask the share provider if this path is shared

BOOL IsShared(LPNCTSTR pszPath, BOOL fUpdateCache)
{
    TCHAR szPath[MAX_PATH];

    // See if we have already tried to load this in this context
    if (g_hmodShare == (HMODULE)-1)
    {
        LONG cb = sizeof(szPath);

        g_hmodShare = NULL;     // asume failure

        SHRegQueryValue(HKEY_CLASSES_ROOT, TEXT("Network\\SharingHandler"), szPath, &cb);
        if (szPath[0]) 
        {
            g_hmodShare = LoadLibrary(szPath);
            if (g_hmodShare)
                g_pfnIsPathShared = (PFNISPATHSHARED)GetProcAddress(g_hmodShare, "IsPathSharedW");
        }
    }

    if (g_pfnIsPathShared)
    {
#ifdef ALIGNMENT_SCENARIO
        ualstrcpyn(szPath, pszPath, ARRAYSIZE(szPath));
        return g_pfnIsPathShared(szPath, fUpdateCache);
#else        
        return g_pfnIsPathShared(pszPath, fUpdateCache);
#endif
    }

    return FALSE;
}

// invalidate the DriveType cache for one entry, or all
STDAPI_(void) InvalidateDriveType(int iDrive)
{}

#define ROUND_TO_CLUSER(qw, dwCluster)  ((((qw) + (dwCluster) - 1) / dwCluster) * dwCluster)

//
// GetCompresedFileSize is NT only, so we only implement the SHGetCompressedFileSizeW
// version. This will return the size of the file on disk rounded to the cluster size.
//
STDAPI_(DWORD) SHGetCompressedFileSizeW(LPCWSTR pszFileName, LPDWORD pFileSizeHigh)
{
    DWORD dwClusterSize;
    ULARGE_INTEGER ulSizeOnDisk;

    if (!pszFileName || !pszFileName[0])
    {
        ASSERT(FALSE);
        *pFileSizeHigh = 0;
        return 0;
    }

    dwClusterSize = PathGetClusterSize(pszFileName);

    ulSizeOnDisk.LowPart = GetCompressedFileSizeW(pszFileName, &ulSizeOnDisk.HighPart);

    if ((ulSizeOnDisk.LowPart == (DWORD)-1) && (GetLastError() != NO_ERROR))
    {
        WIN32_FILE_ATTRIBUTE_DATA fad;

        TraceMsg(TF_WARNING, "GetCompressedFileSize failed on %s (lasterror = %x)", pszFileName, GetLastError());

        if (GetFileAttributesExW(pszFileName, GetFileExInfoStandard, &fad))
        {
            // use the normal size, but round it to the cluster size
            ulSizeOnDisk.LowPart = fad.nFileSizeLow;
            ulSizeOnDisk.HighPart = fad.nFileSizeHigh;
            
            ROUND_TO_CLUSER(ulSizeOnDisk.QuadPart, dwClusterSize);
        }
        else
        {
            // since both GetCompressedFileSize and GetFileAttributesEx failed, we
            // just return zero
            ulSizeOnDisk.QuadPart = 0;
        }
    }

    // for files < one cluster, GetCompressedFileSize returns real size so we need
    // to round it up to one cluster
    if (ulSizeOnDisk.QuadPart < dwClusterSize)
    {
        ulSizeOnDisk.QuadPart = dwClusterSize;
    }

    *pFileSizeHigh = ulSizeOnDisk.HighPart;
    return ulSizeOnDisk.LowPart;
}

STDAPI_(BOOL) SHGetDiskFreeSpaceEx(LPCTSTR pszDirectoryName,
                                   PULARGE_INTEGER pulFreeBytesAvailableToCaller,
                                   PULARGE_INTEGER pulTotalNumberOfBytes,
                                   PULARGE_INTEGER pulTotalNumberOfFreeBytes)
{
    BOOL bRet = GetDiskFreeSpaceEx(pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
    if (bRet)
    {
#ifdef DEBUG
        if (pulTotalNumberOfFreeBytes)
        {
            DWORD dw, dwSize = sizeof(dw);
            if (ERROR_SUCCESS == SHRegGetUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DiskSpace"),
                                                 pszDirectoryName, NULL, &dw, &dwSize, TRUE, NULL, 0))
            {
                pulTotalNumberOfFreeBytes->QuadPart = dw * (ULONGLONG)0x100000; // convert to MB
            }
        }
#endif
    }
    return bRet;
}

#ifdef UNICODE
BOOL SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName,
                           PULARGE_INTEGER pulFreeBytesAvailableToCaller,
                           PULARGE_INTEGER pulTotalNumberOfBytes,
                           PULARGE_INTEGER pulTotalNumberOfFreeBytes)
{
    TCHAR szName[MAX_PATH];

    SHAnsiToTChar(pszDirectoryName, szName, SIZECHARS(szName));
    return SHGetDiskFreeSpaceEx(szName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
}
#else

BOOL SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName,
                           PULARGE_INTEGER pulFreeBytesAvailableToCaller,
                           PULARGE_INTEGER pulTotalNumberOfBytes,
                           PULARGE_INTEGER pulTotalNumberOfFreeBytes)
{
    TCHAR szName[MAX_PATH];

    SHUnicodeToTChar(pszDirectoryName, szName, SIZECHARS(szName));
    return SHGetDiskFreeSpaceEx(szName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes); 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ftenum.cpp ===
#include "shellprv.h"

#include "ftascstr.h" //for now, until CoCreateInstance
#include "ftassoc.h" //for now, until CoCreate IAssocInfo
#include "ftenum.h"

#define EHKCR_NONE      0
#define EHKCR_EXT       1
#define EHKCR_PROGID    2

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//  CFTEnumAssocInfo

///////////////////////////////////////////////////////////////////////////////
// Contructor / Destructor

CFTEnumAssocInfo::CFTEnumAssocInfo() : _cRef(1)
{
    //DLLAddRef();
}

CFTEnumAssocInfo::~CFTEnumAssocInfo()
{
    //DLLRelease();
}

///////////////////////////////////////////////////////////////////////////////
// IUnknown methods

HRESULT CFTEnumAssocInfo::QueryInterface(REFIID riid, PVOID* ppv)
{
    //nothing for now
    return E_NOTIMPL;
}

ULONG CFTEnumAssocInfo::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFTEnumAssocInfo::Release()
{
    if (InterlockedDecrement(&_cRef) > 0)
        return _cRef;
    delete this;
    return 0;
}
///////////////////////////////////////////////////////////////////////////////
// IEnum methods

HRESULT CFTEnumAssocInfo::Init(ASENUM asenumFlags, LPTSTR pszStr, 
                               AIINIT aiinitFlags)
{
    HRESULT hres = E_INVALIDARG;

    if (((ASENUM_PROGID & asenumFlags) && !(ASENUM_EXT & asenumFlags)) ||
        (!(ASENUM_PROGID & asenumFlags) && (ASENUM_EXT & asenumFlags)) ||
        (ASENUM_ACTION & asenumFlags) )
    {
        hres = S_OK;

        _asenumFlags = asenumFlags;
        _aiinitFlags = aiinitFlags;

        if (pszStr)
            StrCpyN(_szInitStr, pszStr, ARRAYSIZE(_szInitStr));
        else
            _szInitStr[0] = 0;
    }

    return hres;
}

HRESULT CFTEnumAssocInfo::Next(IAssocInfo** ppAI)
{
    HRESULT hres = E_FAIL;
    TCHAR szStr[MAX_FTMAX];
    DWORD cchStr = ARRAYSIZE(szStr);
    AIINIT aiinitFlags = 0;

    *szStr = 0;

    switch(_aiinitFlags)
    {
        // We go through the registry
        case AIINIT_NONE:
        {
            switch(_asenumFlags & ASENUM_MAINMASK)
            {
                case ASENUM_EXT:
                    hres = _EnumHKCR(_asenumFlags, szStr, &cchStr);
                    aiinitFlags = AIINIT_EXT;
                    break;

                case ASENUM_PROGID:
                    hres = _EnumHKCR(_asenumFlags, szStr, &cchStr);
                    aiinitFlags = AIINIT_PROGID;
                    break;

                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        // In theory, we go through the value linked to a progID
        case AIINIT_PROGID:
        {
            switch(_asenumFlags & ASENUM_MAINMASK)
            {
                case ASENUM_EXT:
                    hres = _EnumHKCR(_asenumFlags, szStr, &cchStr);
                    aiinitFlags = AIINIT_EXT;
                    break;

                case ASENUM_ACTION:
                    hres = _EnumProgIDActions(szStr, &cchStr);
                    break;

                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }

    if (S_OK==hres)
    {
        if (*szStr)
        {
            *ppAI = new CFTAssocInfo();

            if (*ppAI)
            {
                if (ASENUM_ACTION != (_asenumFlags & ASENUM_MAINMASK))
                    hres = (*ppAI)->Init(aiinitFlags, szStr);
                else
                    hres = (*ppAI)->InitComplex(AIINIT_PROGID, _szInitStr, AIINIT_ACTION, szStr);
            }
            else
                hres = E_OUTOFMEMORY;
        }
        else
            hres = E_FAIL;
    }

    return hres;
}

// This beast goes through the HKCR reg key and check that the
// key meets the criteria of dwFlags (mostly extension vs progID)
HRESULT CFTEnumAssocInfo::_EnumHKCR(ASENUM asenumFlags, LPTSTR pszStr, 
                                    DWORD* pcchStr)
{
    HRESULT hres = E_FAIL;
    BOOL fNext = TRUE;

    while (fNext)
    {
        // This will mean "no more item"
        hres = S_FALSE;

        DWORD cchStr = *pcchStr;

        LONG lRes = RegEnumKeyEx(HKEY_CLASSES_ROOT, _dwIndex, pszStr, &cchStr, NULL, NULL,
            NULL, NULL);

        ++_dwIndex;

        if (lRes != ERROR_NO_MORE_ITEMS)
        {
            if (TEXT('*') != *pszStr)
            {
                if (!_EnumKCRStop(asenumFlags, pszStr))
                {
                    if (!_EnumKCRSkip(asenumFlags, pszStr))
                    {
                        hres = S_OK;
                        fNext = FALSE;
                    }
                }
                else
                {
                    hres = S_FALSE;
                    fNext = FALSE;
                }
            }
        }
        else
        {
            fNext = FALSE;
        }
    }

    // Did we found the first ext?
    if (!_fFirstExtFound && S_OK==hres && (TEXT('.') == *pszStr))
    {
        // Yes
        _fFirstExtFound = TRUE;
    }

    return hres;
}

HRESULT CFTEnumAssocInfo::_EnumProgIDActions(LPTSTR pszStr, DWORD* pcchStr)
{
    // 5 for "shell"
    TCHAR szSubKey[MAX_PROGID + 5 + 1];
    HRESULT hres = S_OK;
    HKEY hKey = NULL;

    StrCpyN(szSubKey, _szInitStr, MAX_PROGID);
    StrCat(szSubKey, TEXT("\\shell"));

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szSubKey, 0, KEY_READ, &hKey))
    {
        LONG lRes = RegEnumKeyEx(hKey, _dwIndex, pszStr, pcchStr, NULL,
            NULL, NULL, NULL);

        if (ERROR_SUCCESS !=lRes)
        {
            if (ERROR_NO_MORE_ITEMS == lRes)
                hres = S_FALSE;
            else
                hres = E_FAIL;
        }
#if 0
        else
        {
            TCHAR szNiceText[MAX_ACTIONDESCR];
            LONG lNiceText = ARRAYSIZE(szNiceText);
#endif
            ++_dwIndex;

#if 0
            // Check if there is nice text for the action
            if ((ERROR_SUCCESS == SHRegQueryValue(hKey, pszStr, szNiceText, 
                &lNiceText)) && (lNiceText > SIZEOF(TCHAR)))
            {
                StrCpyN(pszStr, szNiceText, ARRAYSIZE(pszStr));
            }
        }
#endif

        RegCloseKey(hKey);
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// Helpers

BOOL CFTEnumAssocInfo::_EnumKCRSkip(DWORD asenumFlags, LPTSTR pszExt)
{
    BOOL fRet = FALSE;

    if (AIINIT_NONE == _aiinitFlags)
    {
        CFTAssocStore* pAssocStore = NULL;

        // Do we want the Exts?
        if (!(ASENUM_EXT & asenumFlags))
        {
            // No
            // Is the first char a '.'?
            if (TEXT('.') == *pszExt)
            {
                // Yes, skip this one
                fRet = TRUE;
            }
        }
        else
        {
            // Yes
            // Is the first char a '.'?
            if (TEXT('.') != *pszExt)
            {
                // No, skip it
                fRet = TRUE;
            }
        }

        // we want to skip all the ext having explorer.exe as the executable for
        // their default verb.
        if ((ASENUM_NOEXPLORERSHELLACTION & asenumFlags) && !fRet)
        {
            IQueryAssociations* pQA = NULL;

            ASSERT(ASENUM_EXT & asenumFlags);

            HRESULT hres = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations,
                (LPVOID*)&pQA);

            if (SUCCEEDED(hres))
            {
                WCHAR szwExt[MAX_EXT];
                DWORD cchExt = ARRAYSIZE(szwExt);

                SHTCharToUnicode(pszExt, szwExt, ARRAYSIZE(szwExt));

                hres = pQA->Init(0, szwExt, NULL, NULL);
        
                if (SUCCEEDED(hres))
                {
                    WCHAR szwExec[MAX_APPFRIENDLYNAME];
                    DWORD cchExec = ARRAYSIZE(szwExec);

                    hres = pQA->GetString(ASSOCF_VERIFY,
                        ASSOCSTR_EXECUTABLE, NULL, szwExec, &cchExec);

                    if (!StrCmpIW(PathFindFileNameW(szwExec), L"explorer.exe"))
                    {
                        fRet = TRUE;
                    }
                }
                pQA->Release();
            }
        }

        if ((ASENUM_NOEXCLUDED & asenumFlags) && !fRet)
        {
            IAssocInfo* pAI = NULL;
            HRESULT hres = E_FAIL;

            if (!pAssocStore)
                pAssocStore = new CFTAssocStore();

            ASSERT(ASENUM_EXT & asenumFlags);

            if (pAssocStore)
                hres = pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);
            
            if (SUCCEEDED(hres))
            {
                hres = pAI->GetBOOL(AIBOOL_EXCLUDE, &fRet);

                pAI->Release();
            }
        }

        if ((ASENUM_NOEXE & asenumFlags) && !fRet)
        {
            ASSERT(ASENUM_EXT & asenumFlags);

            fRet = PathIsExe(pszExt);
        }

        if ((ASENUM_ASSOC_YES & asenumFlags) &&
            (ASENUM_ASSOC_ALL != (ASENUM_ASSOC_ALL & asenumFlags)) && !fRet)
        {
            IAssocInfo* pAI = NULL;
            HRESULT hres = E_FAIL;

            if (!pAssocStore)
                pAssocStore = new CFTAssocStore();
            
            ASSERT(ASENUM_EXT & asenumFlags);

            if (pAssocStore)
                hres = pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);
            
            if (SUCCEEDED(hres))
            {
                BOOL fExtAssociated = FALSE;
                hres = pAI->GetBOOL(AIBOOL_EXTASSOCIATED, &fExtAssociated);

                fRet = (fExtAssociated ? FALSE : TRUE);

                pAI->Release();
            }
        }

        if ((ASENUM_ASSOC_NO & asenumFlags) &&
            (ASENUM_ASSOC_ALL != (ASENUM_ASSOC_ALL & asenumFlags)) && !fRet)
        {
            IAssocInfo* pAI = NULL;
            HRESULT hres = E_FAIL;

            if (!pAssocStore)
                pAssocStore = new CFTAssocStore();
            
            ASSERT(ASENUM_EXT & asenumFlags);

            if (pAssocStore)
                hres = pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);
            
            if (SUCCEEDED(hres))
            {
                hres = pAI->GetBOOL(AIBOOL_EXTASSOCIATED, &fRet);

                pAI->Release();
            }
        }

        if ((ASENUM_SHOWONLY & asenumFlags) && !fRet)
        {
            IAssocInfo* pAI = NULL;
            HRESULT hres = E_FAIL;

            if (!pAssocStore)
                pAssocStore = new CFTAssocStore();

            ASSERT(ASENUM_PROGID & asenumFlags);

            // I know pszExt is not an Extension but a progID...
            if (pAssocStore)
                hres = pAssocStore->GetAssocInfo(pszExt, AIINIT_PROGID, &pAI);
            
            if (SUCCEEDED(hres))
            {
                BOOL fTmpRet = FALSE;

                hres = pAI->GetBOOL(AIBOOL_SHOW, &fTmpRet);

                // If it has the show flag (FTA_Show), we don't skip it, so
                // invert the fTmpRet
                fRet = fTmpRet ? FALSE : TRUE;

                pAI->Release();
            }
        }

        if (pAssocStore)
            delete pAssocStore;
    }
    else
    {
        if (AIINIT_PROGID == _aiinitFlags)
        {
            fRet = TRUE;
            // Do we want the Exts?
            if (ASENUM_EXT & asenumFlags)
            {
                DWORD dwType = 0;
                TCHAR szProgID[MAX_PROGID];
                DWORD cbProgID = ARRAYSIZE(szProgID) * sizeof(TCHAR);

                LONG lRes = SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL,
                    &dwType, szProgID, &cbProgID);

                if (ERROR_SUCCESS == lRes)
                {
                    // Does it have the same progID?
                    if (!lstrcmpi(szProgID, _szInitStr))
                    {
                        // Yes, don't skip
                        fRet = FALSE;
                    }
                }
            }
        }
    }
    
    return fRet;
}

BOOL CFTEnumAssocInfo::_EnumKCRStop(DWORD asenumFlags, LPTSTR pszExt)
{
    BOOL fRet = FALSE;

    // NT returns the extension in alphabetical order, not Win9X
    // If we want only the extensions, and the first char is not a '.', then stop
    if (ASENUM_EXT & asenumFlags)
    {
        // Don't go out if we haven't found the first extension
        if ((TEXT('.') != *pszExt) && _fFirstExtFound)
            fRet = TRUE;
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
// Non-implemented IEnum methods

HRESULT CFTEnumAssocInfo::Clone(IEnumAssocInfo* pEnum)
{
    // Will never be implemented
    return E_FAIL;
}

HRESULT CFTEnumAssocInfo::Skip(DWORD dwSkip)
{
    return E_NOTIMPL;
}

HRESULT CFTEnumAssocInfo::Reset()
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\hwctprmp.h ===
#ifndef HWCTPRMP_H
#define HWCTPRMP_H

#include "hwprompt.h"

#define MAX_DEVICENAME      50

class CHWContentPromptDlg : public CHWPromptDlg
{
public:
    CHWContentPromptDlg();

protected:
    virtual ~CHWContentPromptDlg();
    LRESULT OnOK(WORD wNotif);

    HRESULT _FillListView();
    HRESULT _InitStatics();
    HRESULT _InitSelections();
    HRESULT _InitExistingSettings();
    HRESULT _SaveSettings();

private:
    LPWSTR              _pszContentTypeHandler;
};

#endif //HWCTPRMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\hash.c ===
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: Hash.c
//
// Comments:
//      This file contains functions that are roughly equivelent to the
//      kernel atom function.  There are two main differences.  The first
//      is that in 32 bit land the tables are maintined in our shared heap,
//      which makes it shared between all of our apps.  The second is that
//      we can assocate a long pointer with each of the items, which in many
//      cases allows us to keep from having to do a secondary lookup from
//      a different table
//
// History:
//  09/08/93 - Created                                      KurtE
//  ??/??/94 - ported for unicode                           (anonymous)
//  10/26/95 - rearranged hashitems for perf, alignment     FrancisH
//
//---------------------------------------------------------------------------

#include "shellprv.h"
#pragma  hdrstop

#include "fstreex.h"    // for SHCF_ICON_INDEX

#define DM_PERF     0           // perf stats

//--------------------------------------------------------------------------
// First define a data structure to use to maintain the list

#define DEF_HASH_BUCKET_COUNT   71

// NOTE a PHASHITEM is defined as a LPCSTR externaly (for old code to work)
#undef PHASHITEM
typedef struct _HashItem * PHASHITEM;

//-----------------------------------------------------------------------------
//
// Hash item layout:
//
//  [extra data][_HashItem struct][item text]
//
//-----------------------------------------------------------------------------

typedef struct _HashItem
{
    //
    // this part of the struct is aligned
    //
    PHASHITEM   phiNext;        //
    WORD        wCount;         // Usage count
    WORD        cchLen;          // Length of name in characters.

    //
    // this member is just a placeholder
    //
    TCHAR        szName[1];      // name

} HASHITEM;

#pragma warning(disable:4200)   // Zero-sized array in struct

typedef struct _HashTable
{
    UINT    uBuckets;           // Number of buckets
    UINT    uItems;             // Number of items
    UINT    cbExtra;            // Extra bytes per item
    LPCTSTR pszHTCache;         // MRU ptr for last lookup/add/etc.
    PHASHITEM ahiBuckets[0];    // Set of buckets for the table
} HASHTABLE, * PHASHTABLE;

#define HIFROMSZ(sz)            ((PHASHITEM)((BYTE*)(sz) - FIELD_OFFSET(HASHITEM, szName)))
#define HIDATAPTR(pht, sz)      ((void *)(((BYTE *)HIFROMSZ(sz)) - (pht? pht->cbExtra : 0)))
#define HIDATAARRAY(pht, sz)    ((DWORD_PTR *)HIDATAPTR(pht, sz))

#define  LOOKUPHASHITEM     0
#define  ADDHASHITEM        1
#define  DELETEHASHITEM     2
#define  PURGEHASHITEM      3   // DANGER: EVIL!

static HHASHTABLE g_hHashTable = NULL;

HHASHTABLE GetGlobalHashTable();
PHASHTABLE _CreateHashTable(UINT uBuckets, UINT cbExtra);

//--------------------------------------------------------------------------
// This function allocs a hashitem.
//
PHASHITEM _AllocHashItem(PHASHTABLE pht, DWORD cchName)
{
    BYTE *mem;

    ASSERT(pht);

    mem = (BYTE *)LocalAlloc(LPTR, SIZEOF(HASHITEM) + (cchName * SIZEOF(TCHAR)) + pht->cbExtra);

    if (mem)
        mem += pht->cbExtra;

    return (PHASHITEM)mem;
}

//--------------------------------------------------------------------------
// This function frees a hashitem.
//
__inline void _FreeHashItem(PHASHTABLE pht, PHASHITEM phi)
{
    ASSERT(pht && phi);
    LocalFree((BYTE *)phi - pht->cbExtra);
}

// PERF_CACHE
//***   c_szHTNil -- 1-element MRU for hashtable
// DESCRIPTION
//  it turns out we have long runs of duplicate lookups (e.g. "Directory"
// and ".lnk").  a 1-element MRU is a v. cheap way of speeding things up.

// rather than check for the (rare) special case of NULL each time we
// check our cache, we pt at at this guy.  then iff we think it's a
// cache hit, we make sure it's not pting at this special guy.
const TCHAR c_szHTNil[] = TEXT("");     // arbitrary value, unique-&

#ifdef DEBUG
int g_cHTTot, g_cHTHit;
int g_cHTMod = 100;
#endif

// --------------------------------------------------------
// Compute a hash value from an input string of any type, i.e.
// the input is just treated as a sequence of bytes.
// Based on a hash function originally proposed by J. Zobel.
// Author: Paul Larson, 1999, palarson@microsoft.com
// -------------------------------------------------------- 
ULONG _CalculateHashKey(LPCTSTR pszName, WORD *pcch)
{
  // initialize HashKey to a reasonably large constant so very
  // short keys won't get mapped to small values. Virtually any
  // large odd constant will do. 
  unsigned int   HashKey  = 314159269 ; 
  TUCHAR *pC       = (TUCHAR *)pszName;

  for(; *pC; pC++){
    HashKey ^= (HashKey<<11) + (HashKey<<5) + (HashKey>>2) + (unsigned int) *pC  ;
  }

  if (pcch)
      *pcch = (WORD)(pC - pszName);

  return (HashKey & 0x7FFFFFFF) ;
}

void _GrowTable(HHASHTABLE hht)
{
    // hht can't be NULL here
    PHASHTABLE pht = *hht;
    PHASHTABLE phtNew = _CreateHashTable((pht->uBuckets * 2) -1, pht->cbExtra);

    if (phtNew)
    {
        int i;
        for (i=0; i<(int)pht->uBuckets; i++) 
        {
            PHASHITEM phi;
            PHASHITEM phiNext;
            for (phi=pht->ahiBuckets[i]; phi; phi=phiNext) 
            {
                // We always use case sensitive hash here since the case has already been fixed when adding the key.
                ULONG uBucket = _CalculateHashKey(phi->szName, NULL) % phtNew->uBuckets;

                phiNext = phi->phiNext;

                // And link it in to the right bucket
                phi->phiNext = phtNew->ahiBuckets[uBucket];
                phtNew->ahiBuckets[uBucket] = phi;
                phtNew->uItems++; // One more item in the table
            }
        }
        ASSERT(phtNew->uItems == pht->uItems);

        // Now switch the 2 tables
        LocalFree(pht);
        *hht = phtNew;
    }
}

//--------------------------------------------------------------------------
// This function looks up the name in the hash table and optionally does
// things like add it, or delete it.
//
LPCTSTR LookupItemInHashTable(HHASHTABLE hht, LPCTSTR pszName, int iOp)
{
    // First thing to do is calculate the hash value for the item
    UINT    uBucket;
    WORD    cchName;
    PHASHITEM phi, phiPrev;
    PHASHTABLE pht;

    ENTERCRITICAL;

    pht = hht ? *hht : NULL;

    ASSERT(!hht || pht); // If hht is not NULL, then pht can't be NULL either

    if (pht == NULL) 
    {
        hht = GetGlobalHashTable();
        if (hht)
        {
            pht = *hht;
        }

        if (pht == NULL) {
            TraceMsg(TF_WARNING, "LookupItemInHashTable() - Can't get global hash table!");
            LEAVECRITICAL;
            return NULL;
        }
    }

#ifdef DEBUG
    if ((g_cHTTot % g_cHTMod) == 0)
        TraceMsg(DM_PERF, "ht: tot=%d hit=%d", g_cHTTot, g_cHTHit);
#endif
    DBEXEC(TRUE, g_cHTTot++);
    if (*pszName == *pht->pszHTCache && iOp == LOOKUPHASHITEM) {
        // StrCmpC is a fast ansi strcmp, good enough for a quick/approx check
        if (StrCmpC(pszName, pht->pszHTCache) == 0 && pht->pszHTCache != c_szHTNil) {
            DBEXEC(TRUE, g_cHTHit++);

            LEAVECRITICAL;          // see 'semi-race' comment below
            return (LPCTSTR)pht->pszHTCache;

#if 0 // currently not worth it (very few ADDHASHITEMs of existing)
            // careful!  this is o.k. for ADDHASHITEM but not for (e.g.)
            // DELETEHASHITEM (which needs phiPrev)
            phi = HIFROMSZ(pht->pszHTCache);
            goto Ldoop;     // warning: pending ENTERCRITICAL
#endif
        }
    }

    uBucket = _CalculateHashKey(pszName, &cchName) % pht->uBuckets;

    // now search for the item in the buckets.
    phiPrev = NULL;
    phi = pht->ahiBuckets[uBucket];

    while (phi)
    {
        if (phi->cchLen == cchName)
        {
            if (!lstrcmp(pszName, phi->szName))
                break;      // Found match
        }
        phiPrev = phi;      // Keep the previous item
        phi = phi->phiNext;
    }

    //
    // Sortof gross, but do the work here
    //
    switch (iOp)
    {
    case ADDHASHITEM:
        if (phi)
        {
            // Simply increment the reference count
            DebugMsg(TF_HASH, TEXT("Add Hit on '%s'"), pszName);

            phi->wCount++;
        }
        else
        {
            DebugMsg(TF_HASH, TEXT("Add MISS on '%s'"), pszName);

            // Not Found, try to allocate it out of the heap
            if ((phi = _AllocHashItem(pht, cchName)) != NULL)
            {
                // Initialize it
                phi->wCount = 1;        // One use of it
                phi->cchLen = cchName;        // The length of it;
                lstrcpy(phi->szName, pszName);

                // And link it in to the right bucket
                phi->phiNext = pht->ahiBuckets[uBucket];
                pht->ahiBuckets[uBucket] = phi;
                pht->uItems++; // One more item in the table

                if (pht->uItems > pht->uBuckets)
                {
                    _GrowTable(hht);
                    pht = *hht;
                }

                TraceMsg(TF_HASH, "Added new hash item %x(phiNext=%x,szName=\"%s\") for hash table %x at bucket %x",
                    phi, phi->phiNext, phi->szName, pht, uBucket);
            }
        }
        break;

    case PURGEHASHITEM:
    case DELETEHASHITEM:
        if (phi && ((iOp == PURGEHASHITEM) || (!--phi->wCount)))
        {
            // Useage count went to zero so unlink it and delete it
            if (phiPrev != NULL)
                phiPrev->phiNext = phi->phiNext;
            else
                pht->ahiBuckets[uBucket] = phi->phiNext;

            // And delete it
            TraceMsg(TF_HASH, "Free hash item %x(szName=\"%s\") from hash table %x at bucket %x",
                phi, phi->szName, pht, uBucket);

            _FreeHashItem(pht, phi);
            phi = NULL;
            pht->uItems--; // One less item in the table
        }
    }

    // kill cache if this was a PURGE/DELETEHASHITEM, o.w. cache it.
    // note that there's a semi-race on pht->pszHTCache ops, viz. that
    // we LEAVECRITICAL but then return a ptr into our table.  however
    // it's 'no worse' than the existing races.  so i guess the caller
    // is supposed to avoid a concurrent lookup/delete.
    pht->pszHTCache = phi ? phi->szName : c_szHTNil;

    LEAVECRITICAL;

    // If find was passed in simply return it.
    if (phi)
        return (LPCTSTR)phi->szName;
    else
        return NULL;
}

//--------------------------------------------------------------------------

LPCTSTR WINAPI FindHashItem(HHASHTABLE hht, LPCTSTR lpszStr)
{
    return LookupItemInHashTable(hht, lpszStr, LOOKUPHASHITEM);
}

//--------------------------------------------------------------------------

LPCTSTR WINAPI AddHashItem(HHASHTABLE hht, LPCTSTR lpszStr)
{
    return LookupItemInHashTable(hht, lpszStr, ADDHASHITEM);
}

//--------------------------------------------------------------------------

LPCTSTR WINAPI DeleteHashItem(HHASHTABLE hht, LPCTSTR lpszStr)
{
    return LookupItemInHashTable(hht, lpszStr, DELETEHASHITEM);
}

//--------------------------------------------------------------------------

LPCTSTR WINAPI PurgeHashItem(HHASHTABLE hht, LPCTSTR lpszStr)
{
    return LookupItemInHashTable(hht, lpszStr, PURGEHASHITEM);
}

//--------------------------------------------------------------------------
// this sets the extra data in an HashItem

void WINAPI SetHashItemData(HHASHTABLE hht, LPCTSTR sz, int n, DWORD_PTR dwData)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    ASSERT(!hht || pht); // If hht is not NULL, then pht can't be NULL either
    // string must be from the hash table
    ASSERT(FindHashItem(hht, sz) == sz);

    // the default hash table does not have extra data!
    if ((pht != NULL) && (n >= 0) && (n < (int)(pht->cbExtra/SIZEOF(DWORD_PTR))))
        HIDATAARRAY(pht, sz)[n] = dwData;

    LEAVECRITICAL;
}

//======================================================================
// this is like SetHashItemData, except it gets the HashItem data...

DWORD_PTR WINAPI GetHashItemData(HHASHTABLE hht, LPCTSTR sz, int n)
{
    DWORD_PTR dwpRet;
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    ASSERT(!hht || pht); // If hht is not NULL, then pht can't be NULL either
    // string must be from the hash table
    ASSERT(FindHashItem(hht, sz) == sz);

    // the default hash table does not have extra data!
    if (pht != NULL && n <= (int)(pht->cbExtra/SIZEOF(DWORD_PTR)))
        dwpRet = HIDATAARRAY(pht, sz)[n];
    else
        dwpRet = 0;

    LEAVECRITICAL;
    return dwpRet;
}

//======================================================================
// like GetHashItemData, except it just gets a pointer to the buffer...

void * WINAPI GetHashItemDataPtr(HHASHTABLE hht, LPCTSTR sz)
{
    void *pvRet;
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    ASSERT(!hht || pht); // If hht is not NULL, then pht can't be NULL either
    // string must be from the hash table
    ASSERT(FindHashItem(hht, sz) == sz);

    // the default hash table does not have extra data!
    pvRet = (pht? HIDATAPTR(pht, sz) : NULL);

    LEAVECRITICAL;
    return pvRet;
}

//======================================================================

PHASHTABLE _CreateHashTable(UINT uBuckets, UINT cbExtra)
{
    PHASHTABLE pht;

    if (uBuckets == 0)
        uBuckets = DEF_HASH_BUCKET_COUNT;

    pht = (PHASHTABLE)LocalAlloc(LPTR, SIZEOF(HASHTABLE) + uBuckets * SIZEOF(PHASHITEM));

    if (pht) 
    {
        pht->uBuckets = uBuckets;
        pht->cbExtra = (cbExtra + sizeof(DWORD_PTR) - 1) & ~(sizeof(DWORD_PTR)-1);  // rounding to the next DWORD_PTR size
        pht->pszHTCache = c_szHTNil;
    }
    return pht;
}


HHASHTABLE WINAPI CreateHashItemTable(UINT uBuckets, UINT cbExtra)
{
    PHASHTABLE *hht = NULL;
    PHASHTABLE pht;

    pht = _CreateHashTable(uBuckets, cbExtra);

    if (pht) 
    {
        hht = (PHASHTABLE *)LocalAlloc(LPTR, sizeof(PHASHTABLE));
        if (hht)
        {
            *hht = pht;
        }
        else
        {
            LocalFree(pht);
        }
    }

    TraceMsg(TF_HASH, "Created hash table %x(uBuckets=%x, cbExtra=%x)",
        pht, pht->uBuckets, pht->cbExtra);

    return hht;
}

//======================================================================

void WINAPI EnumHashItems(HHASHTABLE hht, HASHITEMCALLBACK callback, DWORD_PTR dwParam)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    ASSERT(!hht || pht); // If hht is not NULL, then pht can't be NULL either

    if (!pht && g_hHashTable)
        pht = *g_hHashTable;

    if (pht) 
    {
        int i;
        PHASHITEM phi;
        PHASHITEM phiNext;
#ifdef DEBUG
        ULONG uCount = 0;
#endif

        for (i=0; i<(int)pht->uBuckets; i++) 
        {
            for (phi=pht->ahiBuckets[i]; phi; phi=phiNext) 
            {
                phiNext = phi->phiNext;
                (*callback)(hht, phi->szName, phi->wCount, dwParam);
#ifdef DEBUG
                uCount++;
#endif
            }
        }
        ASSERT(uCount == pht->uItems);
    }

    LEAVECRITICAL;
} 

//======================================================================

void _DeleteHashItem(HHASHTABLE hht, LPCTSTR sz, UINT usage, DWORD_PTR param)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    _FreeHashItem(pht, HIFROMSZ(sz));
    LEAVECRITICAL;
} 

//======================================================================

void WINAPI DestroyHashItemTable(HHASHTABLE hht)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    ASSERT(!hht || pht); // If hht is not NULL, then pht can't be NULL either

    TraceMsg(TF_HASH, "DestroyHashItemTable(pht=%x)", pht);

    if (pht == NULL) 
    {
        if (g_hHashTable)
        {
            pht = *g_hHashTable;
            hht = g_hHashTable;
            g_hHashTable = NULL;
        }
    }

    if (pht) 
    {
        EnumHashItems(hht, _DeleteHashItem, 0);
        LocalFree(pht);
    }

    if (hht)
    {
        LocalFree(hht);
    }

    LEAVECRITICAL;
} 


//======================================================================

HHASHTABLE GetGlobalHashTable()
{
    if (!g_hHashTable)
    {
        ENTERCRITICAL;

        g_hHashTable = CreateHashItemTable(0, 0);

        LEAVECRITICAL;
    }

    return g_hHashTable;
}

//======================================================================

#ifdef DEBUG

static int TotalBytes;

void CALLBACK _DumpHashItem(HHASHTABLE hht, LPCTSTR sz, UINT usage, DWORD_PTR param)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    DebugMsg(TF_ALWAYS, TEXT("    %08x %5ld \"%s\""), HIFROMSZ(sz), usage, sz);
    TotalBytes += (HIFROMSZ(sz)->cchLen * SIZEOF(TCHAR)) + SIZEOF(HASHITEM);
    LEAVECRITICAL;
}

void CALLBACK _DumpHashItemWithData(HHASHTABLE hht, LPCTSTR sz, UINT usage, DWORD_PTR param)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    DebugMsg(TF_ALWAYS, TEXT("    %08x %5ld %08x \"%s\""), HIFROMSZ(sz), usage, HIDATAARRAY(pht, sz)[0], sz);
    TotalBytes += (HIFROMSZ(sz)->cchLen * SIZEOF(TCHAR)) + SIZEOF(HASHITEM) + (pht? pht->cbExtra : 0);

    LEAVECRITICAL;
}

void WINAPI DumpHashItemTable(HHASHTABLE hht)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    TotalBytes = 0;

    if (IsFlagSet(g_dwDumpFlags, DF_HASH))
    {
        DebugMsg(TF_ALWAYS, TEXT("Hash Table: %08x"), pht);

        if (pht && (pht->cbExtra > 0)) {
            DebugMsg(TF_ALWAYS, TEXT("    Hash     Usage dwEx[0]  String"));
            DebugMsg(TF_ALWAYS, TEXT("    -------- ----- -------- ------------------------------"));
            EnumHashItems(hht, _DumpHashItemWithData, 0);
        }
        else {
            DebugMsg(TF_ALWAYS, TEXT("    Hash     Usage String"));
            DebugMsg(TF_ALWAYS, TEXT("    -------- ----- --------------------------------"));
            EnumHashItems(hht, _DumpHashItem, 0);
        }

        DebugMsg(TF_ALWAYS, TEXT("Total Bytes: %d"), TotalBytes);
    }
    LEAVECRITICAL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\hwcmmn.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "hwcmmn.h"
#include "mtptl.h"

HRESULT _GetAutoplayHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventType,    
    LPCWSTR pszContentTypeHandler, IAutoplayHandler** ppiah)
{
    HRESULT hr = CoCreateInstance(CLSID_HWEventSettings, NULL,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, IID_PPV_ARG(IAutoplayHandler, ppiah));

    if (SUCCEEDED(hr))
    {
        hr = (*ppiah)->InitWithContent(pszDeviceID, pszEventType,
            pszContentTypeHandler);

        if (SUCCEEDED(hr))
        {
            hr = CoSetProxyBlanket((*ppiah),
               RPC_C_AUTHN_WINNT,
               RPC_C_AUTHZ_NONE,
               NULL,
               RPC_C_AUTHN_LEVEL_CALL,
               RPC_C_IMP_LEVEL_IMPERSONATE,
               NULL,
               EOAC_NONE
            );
        }

        if (FAILED(hr))
        {
            (*ppiah)->Release();

            *ppiah = NULL;
        }
    }

    return hr;
}

HRESULT _GetAutoplayHandlerNoContent(LPCWSTR pszDeviceID, LPCWSTR pszEventType,    
    IAutoplayHandler** ppiah)
{
    HRESULT hr = CoCreateInstance(CLSID_HWEventSettings, NULL,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, IID_PPV_ARG(IAutoplayHandler, ppiah));

    if (SUCCEEDED(hr))
    {
        hr = (*ppiah)->Init(pszDeviceID, pszEventType);

        if (SUCCEEDED(hr))
        {
            hr = CoSetProxyBlanket((*ppiah),
               RPC_C_AUTHN_WINNT,
               RPC_C_AUTHZ_NONE,
               NULL,
               RPC_C_AUTHN_LEVEL_CALL,
               RPC_C_IMP_LEVEL_IMPERSONATE,
               NULL,
               EOAC_NONE
            );
        }

        if (FAILED(hr))
        {
            (*ppiah)->Release();

            *ppiah = NULL;
        }
    }

    return hr;
}

HRESULT _GetHWDevice(LPCWSTR pszDeviceID, IHWDevice** ppihwdevice)
{
    HRESULT hr = CoCreateInstance(CLSID_HWDevice, NULL,
            CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, IID_PPV_ARG(IHWDevice, ppihwdevice));

    if (SUCCEEDED(hr))
    {
        hr = (*ppihwdevice)->Init(pszDeviceID);

        if (FAILED(hr))
        {
            (*ppihwdevice)->Release();
            *ppihwdevice = NULL;
        }
    }

    return hr;
}

HICON _GetIconFromIconLocation(LPCWSTR pszIconLocation, BOOL fBigIcon)
{
    WCHAR szIconLocation[MAX_PATH + 12];
    HIMAGELIST himagelist;
    int iImage;

    Shell_GetImageLists(fBigIcon ? &himagelist : NULL, fBigIcon ? NULL : &himagelist);

    lstrcpyn(szIconLocation, pszIconLocation, ARRAYSIZE(szIconLocation));

    iImage = Shell_GetCachedImageIndex(szIconLocation,
        PathParseIconLocation(szIconLocation), 0);
    
    return ImageList_GetIcon(himagelist, iImage, ILD_TRANSPARENT);
}

HRESULT _GetHardwareDevices(IHardwareDevices** ppihwdevices)
{
    return CoCreateInstance(CLSID_HardwareDevices, NULL,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, IID_PPV_ARG(IHardwareDevices, ppihwdevices));
}

BOOL IsShellServiceRunning()
{
    BOOL fRunning = FALSE;
    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if (hSCM)
    {
        SC_HANDLE hService = OpenService(hSCM, TEXT("ShellHWDetection"),
            SERVICE_INTERROGATE);

        if (hService)
        {
            SERVICE_STATUS ss;

            if (ControlService(hService, SERVICE_CONTROL_INTERROGATE, &ss))
            {
                if (SERVICE_RUNNING == ss.dwCurrentState)
                {
                    fRunning = TRUE;
                }
            }

            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hSCM);
    }

    return fRunning;
}

STDAPI GetDeviceProperties(LPCWSTR pszDeviceID, IHWDeviceCustomProperties **ppdcp)
{
    HRESULT hr = CoCreateInstance(CLSID_HWDeviceCustomProperties, NULL,
            CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, IID_PPV_ARG(IHWDeviceCustomProperties, ppdcp));
    if (SUCCEEDED(hr))
    {
        BOOL fVolumeFlag = TRUE;
        const TCHAR cszDeviceHeader[] = TEXT("\\\\?\\");
        if (!StrCmpN(cszDeviceHeader, pszDeviceID, ARRAYSIZE(cszDeviceHeader) - 1))
        {
            fVolumeFlag = CMtPtLocal::IsVolume(pszDeviceID);
        }

        hr = (*ppdcp)->InitFromDeviceID(pszDeviceID, fVolumeFlag ? HWDEVCUSTOMPROP_USEVOLUMEPROCESSING : 0);
        if (FAILED(hr))
        {
            (*ppdcp)->Release();
            *ppdcp = NULL;
        }
    }

    return hr;
}

struct CONTENTTYPEINFO
{
    DWORD       dwContentType;
    LPCWSTR     pszContentTypeHandler;
    int         iContentTypeFriendlyName;
    LPCWSTR     pszContentTypeIconLocation;
};

static const CONTENTTYPEINFO contenttypeinfo[] =
{
    { CT_CDAUDIO         , TEXT("CDAudioContentHandler"), IDS_AP_CDAUDIOCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-228") },
    { CT_DVDMOVIE        , TEXT("DVDMovieContentHandler"), IDS_AP_DVDMOVIECONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-222") },
    { CT_BLANKCDRW       , TEXT("BlankCDContentHandler"), IDS_AP_BLANKCDCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-260") },
    { CT_BLANKCDR        , TEXT("BlankCDContentHandler"), IDS_AP_BLANKCDCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-260") },
    { CT_AUTOPLAYMUSIC   , TEXT("MusicFilesContentHandler"), IDS_AP_MUSICFILESCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-225") },
    { CT_AUTOPLAYPIX     , TEXT("PicturesContentHandler"), IDS_AP_PICTURESCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shimgvw.dll,3") },
    { CT_AUTOPLAYMOVIE   , TEXT("VideoFilesContentHandler"), IDS_AP_VIDEOFILESCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-224") },

    { CT_AUTOPLAYMIXEDCONTENT, TEXT("MixedContentHandler"), IDS_AP_MIXEDCONTENTCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-227") },
        
    { CT_AUTORUNINF      , NULL, 0, NULL },
    { CT_UNKNOWNCONTENT  , NULL, 0, NULL },
    { CT_BLANKDVDR       , NULL, 0, NULL },
    { CT_BLANKDVDRW      , NULL, 0, NULL },
};

HRESULT _GetContentTypeInfo(DWORD dwContentType, LPWSTR pszContentTypeFriendlyName,
    DWORD cchContentTypeFriendlyName, LPWSTR pszContentTypeIconLocation,
    DWORD cchContentTypeIconLocation)
{
    HRESULT hr = E_FAIL;

    for (DWORD dw = 0; dw < ARRAYSIZE(contenttypeinfo); ++dw)
    {
        //
        //  First matching entry wins.
        //

        if (contenttypeinfo[dw].dwContentType & dwContentType)
        {
            ASSERT(contenttypeinfo[dw].pszContentTypeHandler);

            if (!LoadString(g_hinst, contenttypeinfo[dw].iContentTypeFriendlyName,
                pszContentTypeFriendlyName, cchContentTypeFriendlyName))
            {
                *pszContentTypeFriendlyName = 0;
            }

            StrCpyN(pszContentTypeIconLocation, contenttypeinfo[dw].pszContentTypeIconLocation,
                cchContentTypeIconLocation);

            hr = S_OK;

            break;
        }
    }

    return hr;
}

BOOL IsMixedContent(DWORD dwContentType)
{
    BOOL fRet;

    switch (CT_ANYAUTOPLAYCONTENT & dwContentType)
    {
        case 0:
        case CT_AUTOPLAYMUSIC:
        case CT_AUTOPLAYPIX:
        case CT_AUTOPLAYMOVIE:
            fRet = FALSE;
            break;

        default:
            fRet = TRUE;
            break;
    }

    return fRet;
}

HRESULT _GetContentTypeHandler(DWORD dwContentType, LPWSTR pszContentTypeHandler,
    DWORD cchContentTypeHandler)
{
    HRESULT hr = E_FAIL;

    if (IsMixedContent(dwContentType))
    {
        StrCpyN(pszContentTypeHandler, TEXT("MixedContentHandler"), cchContentTypeHandler);

        hr = S_OK;
    }
    else
    {
        for (DWORD dw = 0; dw < ARRAYSIZE(contenttypeinfo); ++dw)
        {
            //
            //  First matching entry wins.
            //

            if (contenttypeinfo[dw].dwContentType & dwContentType)
            {
                StrCpyN(pszContentTypeHandler, contenttypeinfo[dw].pszContentTypeHandler,
                    cchContentTypeHandler);

                hr = S_OK;

                break;
            }
        }
    }

    return hr;
}

HRESULT _GetHandlerInvokeProgIDAndVerb(LPCWSTR pszHandler, LPWSTR pszInvokeProgID,
    DWORD cchInvokeProgID, LPWSTR pszInvokeVerb, DWORD cchInvokeVerb)
{
    IAutoplayHandlerProperties* pahp;
    HRESULT hr = CoCreateInstance(CLSID_AutoplayHandlerProperties, NULL,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG,
        IID_PPV_ARG(IAutoplayHandlerProperties, &pahp));

    if (SUCCEEDED(hr))
    {
        hr = pahp->Init(pszHandler);

        if (SUCCEEDED(hr))
        {
            LPWSTR pszInvokeProgIDLocal;
            LPWSTR pszInvokeVerbLocal;

            hr = pahp->GetInvokeProgIDAndVerb(&pszInvokeProgIDLocal, &pszInvokeVerbLocal);

            if (SUCCEEDED(hr))
            {
                lstrcpyn(pszInvokeProgID, pszInvokeProgIDLocal, cchInvokeProgID);
                lstrcpyn(pszInvokeVerb, pszInvokeVerbLocal, cchInvokeVerb);

                CoTaskMemFree(pszInvokeProgIDLocal);
                CoTaskMemFree(pszInvokeVerbLocal);
            }
        }

        pahp->Release();
    }

    return hr;
}

//
CCrossThreadFlag::~CCrossThreadFlag()
{
    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: CCrossThreadFlag::~CCrossThreadFlag called");

    if (_hEvent)
    {
        CloseHandle(_hEvent);
    }
}

BOOL CCrossThreadFlag::Init()
{
    ASSERT(!_fInited);

    _hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

#ifdef DEBUG
    if (_hEvent)
    {
        _fInited = TRUE;
    }
#endif

    return !!_hEvent;
}

BOOL CCrossThreadFlag::Signal()
{
    ASSERT(_fInited);

    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: CCrossThreadFlag::Signal called");

    return SetEvent(_hEvent);
}

BOOL CCrossThreadFlag::IsSignaled()
{
    ASSERT(_fInited);
    BOOL fRet = (WAIT_OBJECT_0 == WaitForSingleObject(_hEvent, 0));

    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: CCrossThreadFlag::IsSignaled called: %d", fRet);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\hwprompt.h ===
#ifndef HWPROMPT_H
#define HWPROMPT_H

#include "basedlg.h"

#define MAX_DEVICENAME      50

class CHWPromptDlg : public CBaseDlg
{
public:
    CHWPromptDlg();

    HRESULT Init(LPCWSTR pszDeviceID);

protected:
    virtual ~CHWPromptDlg();
    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnOK(WORD wNotif);
    LRESULT OnCancel(WORD wNotif);

protected:
    virtual HRESULT _FillListView() = 0;
    virtual HRESULT _InitStatics() = 0;
    virtual HRESULT _InitSelections() = 0;

protected:
    HRESULT _InitStaticsCommon();
    HRESULT _SelectListItem(int i);
    HRESULT _SelectRadio(int i);
    HRESULT _GetSelection(int* pi);

private:
    HRESULT _InitListView();
    HRESULT _SetDeviceName();
    HRESULT _SetTitle();
    HRESULT _OnListSelChange();
    HRESULT _OnRadio(int iButton);

protected:
    virtual LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);

private:
    BOOL                _fTriedDeviceName;
    HICON               _hiconInfo;

protected:
    WCHAR               _szDeviceName[MAX_DEVICENAME];
    HICON               _hiconTop;

public:
    LPWSTR              _pszDeviceID;
    BOOL                _fOpenFolder;
    WCHAR               _szContentTypeHandler[256];
    BOOL                _fHandler;
};

#endif //HWPROMPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\help.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1992
//
// File: help.c
//
// History:
//  6 Apr 94    MikeSh  Created
//
//---------------------------------------------------------------------------

#include "shellprv.h"
#pragma  hdrstop
#include "printer.h"
#include "drives.h" // for ShowMountedVolumeProperties

//
// (internal) entry point for Help "Shortcuts".
//
STDAPI_(void) SHHelpShortcuts_RunDLL_Common(HWND hwndStub, HINSTANCE hAppInstance, LPCTSTR pszCmdLine, int nCmdShow)
{
    if (!lstrcmp(pszCmdLine, TEXT("AddPrinter")))
    {
        // install a new printer

        LPITEMIDLIST pidl = Printers_PrinterSetup(hwndStub, MSP_NEWPRINTER, (LPTSTR)c_szNewObject, NULL);
        ILFree(pidl);
    }
    else if (!lstrcmp(pszCmdLine, TEXT("PrintersFolder")))
    {
        // bring up the printers folder
        InvokeFolderPidl(MAKEINTIDLIST(CSIDL_PRINTERS), SW_SHOWNORMAL);
    }
    else if (!lstrcmp(pszCmdLine, TEXT("FontsFolder")))
    {
        // bring up the printers folder
        InvokeFolderPidl(MAKEINTIDLIST(CSIDL_FONTS), SW_SHOWNORMAL);
    }
    else if (!lstrcmp(pszCmdLine, TEXT("Connect")))
    {
        SHNetConnectionDialog(hwndStub, NULL, RESOURCETYPE_DISK);
        goto FlushDisconnect;
    }
    else if (!lstrcmp(pszCmdLine, TEXT("Disconnect")))
    {
        WNetDisconnectDialog(hwndStub, RESOURCETYPE_DISK);
FlushDisconnect:
        SHChangeNotifyHandleEvents();   // flush any drive notifications
    }
#ifdef DEBUG
    else if (!StrCmpN(pszCmdLine, TEXT("PrtProp "), 8))
    {
        SHObjectProperties(hwndStub, SHOP_PRINTERNAME, &(pszCmdLine[8]), TEXT("Sharing"));
    }
    else if (!StrCmpN(pszCmdLine, TEXT("FileProp "), 9))
    {
        SHObjectProperties(hwndStub, SHOP_FILEPATH, &(pszCmdLine[9]), TEXT("Sharing"));
    }
#endif
}

VOID WINAPI SHHelpShortcuts_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPCSTR lpszCmdLine, int nCmdShow)
{
    UINT iLen = lstrlenA(lpszCmdLine)+1;
    LPWSTR  lpwszCmdLine;

    lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR,iLen*sizeof(WCHAR));
    if (lpwszCmdLine)
    {
        MultiByteToWideChar(CP_ACP, 0,
                            lpszCmdLine, -1,
                            lpwszCmdLine, iLen);
        SHHelpShortcuts_RunDLL_Common( hwndStub,
                                       hAppInstance,
                                       lpwszCmdLine,
                                       nCmdShow );
        LocalFree(lpwszCmdLine);
    }
}

VOID WINAPI SHHelpShortcuts_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPCWSTR lpwszCmdLine, int nCmdShow)
{
    SHHelpShortcuts_RunDLL_Common(hwndStub,hAppInstance,lpwszCmdLine,nCmdShow);
}

//
// SHObjectProperties is an easy way to call the verb "properties" on an object.
// It's easy because the caller doesn't have to deal with LPITEMIDLISTs.
// Note: SHExecuteEx(SEE_MASK_INVOKEIDLIST) works for the SHOP_FILEPATH case,
// but msshrui needs an easy way to do this for printers. Bummer.
//
STDAPI_(BOOL) SHObjectProperties(HWND hwndOwner, DWORD dwType, LPCTSTR pszItem, LPCTSTR pszPage)
{
    LPITEMIDLIST pidl = NULL;

    switch (dwType & SHOP_TYPEMASK)
    {
    case SHOP_PRINTERNAME:
        ParsePrinterName(pszItem, &pidl);
        break;

    case SHOP_FILEPATH:
        //
        // NTRAID#NTBUG9-271529-2001/02/08-jeffreys
        //
        // Existing callers rely on ILCFP_FLAG_NO_MAP_ALIAS behavior.
        //
        ILCreateFromPathEx(pszItem, NULL, ILCFP_FLAG_NO_MAP_ALIAS, &pidl, NULL);
        break;

    case SHOP_VOLUMEGUID:
        return ShowMountedVolumeProperties(pszItem, hwndOwner);
    }

    if (pidl)
    {
        SHELLEXECUTEINFO sei =
        {
            sizeof(sei),
            SEE_MASK_INVOKEIDLIST,      // fMask
            hwndOwner,                  // hwnd
            c_szProperties,             // lpVerb
            NULL,                       // lpFile
            pszPage,                    // lpParameters
            NULL,                       // lpDirectory
            SW_SHOWNORMAL,              // nShow
            NULL,                       // hInstApp
            pidl,                       // lpIDList
            NULL,                       // lpClass
            0,                          // hkeyClass
            0,                          // dwHotKey
            NULL                        // hIcon
        };

        BOOL bRet = ShellExecuteEx(&sei);

        ILFree(pidl);

        return bRet;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\idlcomm.h ===
#ifndef _IDLCOMM_H_
#define _IDLCOMM_H_

#ifndef _SHELLP_H_
#include <shellp.h>
#endif

//===========================================================================
// HIDA -- IDList Array handle
//===========================================================================

STDAPI_(void) IDLData_InitializeClipboardFormats(void);

STDAPI_(LPITEMIDLIST) HIDA_ILClone(HIDA hida, UINT i);
STDAPI_(LPITEMIDLIST) HIDA_FillIDList(HIDA hida, UINT i, LPITEMIDLIST pidl);

#define DTID_HDROP              0x00000001L
#define DTID_HIDA               0x00000002L
#define DTID_NETRES             0x00000004L
#define DTID_CONTENTS           0x00000008L
#define DTID_FDESCA             0x00000010L
#define DTID_OLEOBJ             0x00000020L
#define DTID_OLELINK            0x00000040L
#define DTID_FD_LINKUI          0x00000080L
#define DTID_FDESCW             0x00000100L
#define DTID_PREFERREDEFFECT    0x00000200L
#define DTID_EMBEDDEDOBJECT     0x00000400L

//
// This macro checks if pdtgt is a subclass of CIDLDropTarget.
// (HACK: We assume nobody overrides QueryInterface).
//
STDAPI_(BOOL) DoesDropTargetSupportDAD(IDropTarget *pdtgt);

//
// IDs for non-default drag & drop menu
//
#define DDIDM_COPY              1
#define DDIDM_MOVE              2
#define DDIDM_LINK              3
#define DDIDM_SCRAP_COPY        4
#define DDIDM_SCRAP_MOVE        5
#define DDIDM_DOCLINK           6
#define DDIDM_CONTENTS_COPY     7
#define DDIDM_CONTENTS_MOVE     8
#define DDIDM_SYNCCOPY          9
#define DDIDM_SYNCCOPYTYPE      10
#define DDIDM_CONTENTS_LINK     11
#define DDIDM_CONTENTS_DESKCOMP 12
#define DDIDM_CONTENTS_DESKIMG  13
#define DDIDM_OBJECT_COPY       14
#define DDIDM_OBJECT_MOVE       15
#define DDIDM_CONTENTS_DESKURL  16
#define DDIDM_EXTFIRST          0x1000
#define DDIDM_EXTLAST           0x7fff

#define MK_FAKEDROP 0x8000      // Real keys being held down?

//===========================================================================
// HDKA
//===========================================================================
//
// Struct:  ContextMenuInfo:
//
//  This data structure is used by FileView_DoContextMenu (and its private
// function, _AppendMenuItems) to handler multiple context menu handlers.
//
// History:
//  02-25-93 SatoNa     Created
//
typedef struct { // cmi
    IContextMenu  *pcm;
    UINT        idCmdFirst;
    UINT        idCmdMax;
    DWORD       dwCompat;
    CLSID       clsid;
} ContextMenuInfo;


//------------------------------------------------------------------------
// Dynamic class array
//

STDAPI_(int) DCA_AppendClassSheetInfo(HDCA hdca, HKEY hkeyProgID, LPPROPSHEETHEADER ppsh, IDataObject * pdtobj);

//===========================================================================
// HDXA
//===========================================================================
typedef HDSA    HDXA;   // hdma

#define HDXA_Create()   ((HDXA)DSA_Create(SIZEOF(ContextMenuInfo), 4))

STDAPI_(UINT) HDXA_AppendMenuItems(
                        HDXA hdxa, IDataObject * pdtobj,
                        UINT nKeys, HKEY *ahkeyClsKeys,
                        LPCITEMIDLIST pidlFolder,
                        HMENU hmenu, UINT uInsert,
                        UINT idCmdFirst,  UINT idCmdLast,
                        UINT fFlags,
                        HDCA hdca);
STDAPI_(UINT) HDXA_AppendMenuItems2(HDXA hdxa, IDataObject *pdtobj,
                        UINT nKeys, HKEY *ahkeyClsKeys,
                        LPCITEMIDLIST pidlFolder,
                        QCMINFO* pqcm,
                        UINT fFlags,
                        HDCA hdca,
                        IUnknown* pSite);

STDAPI HDXA_LetHandlerProcessCommandEx(HDXA hdxa, LPCMINVOKECOMMANDINFOEX pici, UINT_PTR * pidCmd);
STDAPI HDXA_GetCommandString(HDXA hdxa, UINT_PTR idCmd, UINT wFlags, UINT * pwReserved, LPSTR pszName, UINT cchMax);
STDAPI_(void) HDXA_DeleteAll(HDXA hdxa);
STDAPI_(void) HDXA_Destroy(HDXA hdxa);

//
// Clipboard Format for IDLData object.
//
#define ICFHDROP                         0
#define ICFFILENAME                      1
#define ICFNETRESOURCE                   2
#define ICFFILECONTENTS                  3
#define ICFFILEGROUPDESCRIPTORA          4
#define ICFFILENAMEMAPW                  5
#define ICFFILENAMEMAP                   6
#define ICFHIDA                          7
#define ICFOFFSETS                       8
#define ICFPRINTERFRIENDLYNAME           9
#define ICFPRIVATESHELLDATA             10
#define ICFHTML                         11
#define ICFFILENAMEW                    12
#define ICFFILEGROUPDESCRIPTORW         13
#define ICFPREFERREDDROPEFFECT          14
#define ICFPERFORMEDDROPEFFECT          15
#define ICFPASTESUCCEEDED               16
#define ICFSHELLURL                     17
#define ICFINDRAGLOOP                   18
#define ICF_DRAGCONTEXT                 19
#define ICF_TARGETCLSID                 20
#define ICF_EMBEDDEDOBJECT              21
#define ICF_OBJECTDESCRIPTOR            22
#define ICF_NOTRECYCLABLE               23
#define ICFLOGICALPERFORMEDDROPEFFECT   24
#define ICF_BRIEFCASE                   25
#define ICF_UNICODETEXT                 26
#define ICF_TEXT                        27
#define ICF_DROPEFFECTFOLDERLIST        28
#define ICF_AUTOPLAYHIDA                29
#define ICF_MAX                         30

EXTERN_C CLIPFORMAT g_acfIDLData[];

#define g_cfNetResource                 g_acfIDLData[ICFNETRESOURCE]
#define g_cfHIDA                        g_acfIDLData[ICFHIDA]
#define g_cfOFFSETS                     g_acfIDLData[ICFOFFSETS]
#define g_cfPrinterFriendlyName         g_acfIDLData[ICFPRINTERFRIENDLYNAME]
#define g_cfFileNameA                   g_acfIDLData[ICFFILENAME]
#define g_cfFileContents                g_acfIDLData[ICFFILECONTENTS]
#define g_cfFileGroupDescriptorA        g_acfIDLData[ICFFILEGROUPDESCRIPTORA]
#define g_cfFileGroupDescriptorW        g_acfIDLData[ICFFILEGROUPDESCRIPTORW]
#define g_cfFileNameMapW                g_acfIDLData[ICFFILENAMEMAPW]
#define g_cfFileNameMapA                g_acfIDLData[ICFFILENAMEMAP]
#define g_cfPrivateShellData            g_acfIDLData[ICFPRIVATESHELLDATA]
#define g_cfHTML                        g_acfIDLData[ICFHTML]
#define g_cfFileNameW                   g_acfIDLData[ICFFILENAMEW]
#define g_cfPreferredDropEffect         g_acfIDLData[ICFPREFERREDDROPEFFECT]
#define g_cfPerformedDropEffect         g_acfIDLData[ICFPERFORMEDDROPEFFECT]
#define g_cfLogicalPerformedDropEffect  g_acfIDLData[ICFLOGICALPERFORMEDDROPEFFECT]
#define g_cfPasteSucceeded              g_acfIDLData[ICFPASTESUCCEEDED]
#define g_cfShellURL                    g_acfIDLData[ICFSHELLURL]
#define g_cfInDragLoop                  g_acfIDLData[ICFINDRAGLOOP]
#define g_cfDragContext                 g_acfIDLData[ICF_DRAGCONTEXT]
#define g_cfTargetCLSID                 g_acfIDLData[ICF_TARGETCLSID]
#define g_cfEmbeddedObject              g_acfIDLData[ICF_EMBEDDEDOBJECT]
#define g_cfObjectDescriptor            g_acfIDLData[ICF_OBJECTDESCRIPTOR]
#define g_cfNotRecyclable               g_acfIDLData[ICF_NOTRECYCLABLE]
#define g_cfBriefObj                    g_acfIDLData[ICF_BRIEFCASE]    
#define g_cfText                        g_acfIDLData[ICF_TEXT]
#define g_cfUnicodeText                 g_acfIDLData[ICF_UNICODETEXT]
#define g_cfDropEffectFolderList        g_acfIDLData[ICF_DROPEFFECTFOLDERLIST]
#define g_cfAutoPlayHIDA                g_acfIDLData[ICF_AUTOPLAYHIDA]

EXTERN_C CLIPFORMAT g_cfMountedVolume;

// Most places will only generate one so minimize the number of changes in the code (bad idea!)
#ifdef UNICODE
#define g_cfFileNameMap         g_cfFileNameMapW
#define g_cfFileName            g_cfFileNameW
#else
#define g_cfFileNameMap         g_cfFileNameMapA
#define g_cfFileName            g_cfFileNameA
#endif

STDAPI_(LPCITEMIDLIST) IDA_GetIDListPtr(LPIDA pida, UINT i);
STDAPI_(LPITEMIDLIST)  IDA_FullIDList(LPIDA pida, UINT i);

#endif // _IDLCOMM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\hwcmmn.h ===
#ifndef _HWCMMN_H
#define _HWCMMN_H

#define CT_AUTORUNINF                  0x00000001
#define CT_CDAUDIO                     0x00000002
#define CT_DVDMOVIE                    0x00000004
#define CT_UNKNOWNCONTENT              0x00000008
#define CT_BLANKCDR                    0x00000010
#define CT_BLANKCDRW                   0x00000020
#define CT_BLANKDVDR                   0x00000040
#define CT_BLANKDVDRW                  0x00000080
#define CT_AUTOPLAYMUSIC               0x00000100
#define CT_AUTOPLAYPIX                 0x00000200
#define CT_AUTOPLAYMOVIE               0x00000400

// Will not be returned by CMountPoint::GetContentType
#define CT_AUTOPLAYMIXEDCONTENT        0x00000800

#define CT_ANYCONTENT                  0x00000FFF

#define CT_ANYAUTOPLAYCONTENT          (   CT_AUTOPLAYMUSIC | \
                                                        CT_AUTOPLAYPIX | \
                                                        CT_AUTOPLAYMOVIE)

#define CT_BLANKCDWRITABLE             (   CT_BLANKCDR | \
                                                        CT_BLANKCDRW )

#define CT_BLANKDVDWRITABLE            (   CT_BLANKDVDR | \
                                                        CT_BLANKDVDRW )

BOOL IsShellServiceRunning();

HRESULT _GetAutoplayHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPCWSTR pszContentTypeHandler, IAutoplayHandler** ppiah);

HRESULT _GetAutoplayHandlerNoContent(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    IAutoplayHandler** ppiah);

HRESULT _GetHWDevice(LPCWSTR pszDeviceID, IHWDevice** ppihwdevice);

STDAPI GetDeviceProperties(LPCWSTR pszDeviceID, IHWDeviceCustomProperties** ppihwdevcp);

HICON _GetIconFromIconLocation(LPCWSTR pszIconLocation, BOOL fBigIcon);

HRESULT _GetDeviceEventFriendlyName(LPCWSTR pszDeviceID, LPWSTR* ppsz);

HRESULT _GetHardwareDevices(IHardwareDevices** ppihwdevices);

HRESULT _GetContentTypeInfo(DWORD dwContentType, LPWSTR pszContentTypeFriendlyName,
    DWORD cchContentTypeFriendlyName, LPWSTR pszContentTypeIconLocation,
    DWORD cchContentTypeIconLocation);

HRESULT _GetContentTypeHandler(DWORD dwContentType, LPWSTR pszContentTypeHandler,
    DWORD cchContentTypeHandler);

HRESULT _GetHandlerInvokeProgIDAndVerb(LPCWSTR pszHandler, LPWSTR pszInvokeProgID,
    DWORD cchInvokeProgID, LPWSTR pszInvokeVerb, DWORD cchInvokeVerb);

struct AUTOPLAYPROMPT
{
    WCHAR                       szDriveOrDeviceID[MAX_PATH];
    BOOL                        fDlgWillBeShown;
    HWND                        hwndDlg;
    class CCrossThreadFlag*     pDeviceGoneFlag;
};

HRESULT DoDeviceNotification(LPCTSTR pszDevice, LPCTSTR pszEventType, CCrossThreadFlag* pDeviceGoneFlag);

BOOL GetGoneFlagForDevice(LPCWSTR pszAltDeviceID, CCrossThreadFlag** ppDeviceGoneFlag);
void AttachGoneFlagForDevice(LPCWSTR pszAltDeviceID, CCrossThreadFlag* pDeviceGoneFlag);

BOOL IsMixedContent(DWORD dwContentType);

class CRefCounted
{
public:
    CRefCounted() : _cRCRef(1) {}
    virtual ~CRefCounted() {}

    ULONG AddRef() { return ::InterlockedIncrement((LONG*)&_cRCRef); }
    ULONG Release()
    {
        ULONG cRef = ::InterlockedDecrement((LONG*)&_cRCRef);

        if (!cRef)
        {
            delete this;
        }

        return cRef;
    }

private:
    ULONG _cRCRef; // RC: to avoid name colision
};

// The event is created in the NON-signaled state
// Since it's cross-thread it should always be created on the heap
class CCrossThreadFlag : public CRefCounted
{
public:
    BOOL Init();
    BOOL Signal();
    BOOL IsSignaled();

private:
    ~CCrossThreadFlag();

    HANDLE _hEvent;
#ifdef DEBUG
    BOOL _fInited;
#endif
};

#endif //_HWCMMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\hwshlexc.cpp ===
#include "shellprv.h"
#include "clsobj.h"

#include "shobjidl.h"


HRESULT CoMarshallToCmdLine(REFIID riid, IUnknown *punk, LPTSTR pszCmdLine, UINT cch);
HRESULT CoUnmarshalFromCmdLine(LPCTSTR pszCmdLine, REFIID riid, void **ppv);

class CHWShellExecute : public IHWEventHandler
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IHWEventHandler methods
    STDMETHODIMP Initialize(LPCWSTR pszParams);
    STDMETHODIMP HandleEvent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, LPCWSTR pszEventType);
    STDMETHODIMP HandleEventWithContent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, LPCWSTR pszEventType,
        LPCWSTR pszContentTypeHandler, IDataObject* pdtobj);

protected:
    CHWShellExecute();
    ~CHWShellExecute();

    friend HRESULT CHWShellExecute_CreateInstance(IUnknown* pUnkOuter,
        REFIID riid, void **ppv);

private:
    LONG            _cRef;
    LPWSTR          _pszParams;
};

CHWShellExecute::CHWShellExecute() : _cRef(1)
{
    DllAddRef();
}

CHWShellExecute::~CHWShellExecute()
{
    CoTaskMemFree(_pszParams);
    DllRelease();
}

STDAPI CHWShellExecute_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;
    
    // aggregation checking is handled in class factory
    CHWShellExecute* pHWShellExecute = new CHWShellExecute();

    if (pHWShellExecute)
    {
        hr = pHWShellExecute->QueryInterface(riid, ppv);
        pHWShellExecute->Release();
    }

    return hr;
}

// IUnknown
STDMETHODIMP CHWShellExecute::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CHWShellExecute, IHWEventHandler),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CHWShellExecute::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CHWShellExecute::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// IHWEventHandler
STDMETHODIMP CHWShellExecute::Initialize(LPCWSTR pszParams)
{
        ASSERT(NULL == _pszParams);
    return SHStrDup(pszParams, &_pszParams);
}

STDMETHODIMP CHWShellExecute::HandleEvent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, LPCWSTR pszEventType)
{
    return HandleEventWithContent(pszDeviceID, pszAltDeviceID, pszEventType, NULL, NULL);
}

void ExpandArg(LPCTSTR pszArg, LPCTSTR pszName, LPTSTR pszArgs, UINT cch)
{
    if (pszArg)
    {
        LPTSTR pszFiles = StrStrI(pszArgs, pszName);
        if (pszFiles)
        {
            StrCpyN(pszFiles, pszArg, cch - (int)(pszFiles - pszArgs));
        }
    }
}

// pszDeviceID == \\?\STORAGE#RemoveableMedia#9&16...
// pszAltDeviceID == "F:\" (if the device is storage)

STDMETHODIMP CHWShellExecute::HandleEventWithContent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, 
                                                     LPCWSTR pszEventType, LPCWSTR pszContentTypeHandler, 
                                                     IDataObject* pdtobj)
{
    HRESULT hr;

    if (_pszParams)
    {
        // make copy of _pszParams to make sure we don't mess up our state
        // when we parse the params into the parts

        TCHAR szApp[MAX_PATH + MAX_PATH], szArgs[INTERNET_MAX_URL_LENGTH];
        StrCpyN(szApp, _pszParams, ARRAYSIZE(szApp));

        // this code is a generic dispatcher of the data object to apps
        // those that need to work over a potentially large set of file names

        PathSeperateArgs(szApp, szArgs);

        if (pdtobj)
        {
#if DEBUG
            TCHAR szText[1024];
            if (SUCCEEDED(CoMarshallToCmdLine(IID_IDataObject, pdtobj, szText, ARRAYSIZE(szText))))
            {
                IDataObject *pdtobjNew;
                if (SUCCEEDED(CoUnmarshalFromCmdLine(szText, IID_PPV_ARG(IDataObject, &pdtobjNew))))
                {
                    pdtobjNew->Release();
                }
            }
#endif
            // here we convert the data object into a cmd line form
            // there are 2 ways we do that now...
            //
            //  %Files%         - gives all of the data object files expanded on the cmd line
            //  %DataObject%    - marshaled data object on cmd line

            LPTSTR pszFiles = StrStrI(szArgs, TEXT("%Files%"));
            if (NULL == pszFiles)
                pszFiles = StrStrI(szArgs, TEXT("%F:"));    // old syntax support

            if (pszFiles)
            {
                *pszFiles = 0;  // start empty
                UINT cch = (UINT)(ARRAYSIZE(szArgs) - (pszFiles - szArgs));

                // this expands all of the file names into a cmd line
                // lets hope we don't have too many files as this has a fixed
                // length buffer

                STGMEDIUM medium = {0};
                FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                hr = pdtobj->GetData(&fmte, &medium);
                if (SUCCEEDED(hr))
                {
                    TCHAR szPath[MAX_PATH];

                    for (int i = 0; DragQueryFile((HDROP)medium.hGlobal, i, szPath, ARRAYSIZE(szPath)); i++)
                    {
                        StrCatBuff(pszFiles, TEXT("\""), cch);
                        StrCatBuff(pszFiles, szPath, cch);
                        StrCatBuff(pszFiles, TEXT("\" "), cch);
                    }
                    ReleaseStgMedium(&medium);
                }
            }
            else
            {
                // prefered way to do this, this convert the data object into a
                // marshaled cmd line that we can pass all of the files through

                pszFiles = StrStrI(szArgs, TEXT("%DataObject%"));
                if (pszFiles)
                {
                    CoMarshallToCmdLine(IID_IDataObject, pdtobj, pszFiles, (UINT)(ARRAYSIZE(szArgs) - (pszFiles - szArgs)));
                }
            }
        }

#if 0
        ExpandArg(pszDeviceID,              TEXT("%DeviceID%"), szArgs, ARRAYSIZE(szArgs));
        ExpandArg(pszEventType,             TEXT("%EventType%"), szArgs, ARRAYSIZE(szArgs));
        ExpandArg(pszContentTypeHandler,    TEXT("%ContentTypeHandler%"), szArgs, ARRAYSIZE(szArgs));
        ExpandArg(pszAltDeviceID,           TEXT("%AltDeviceID%"), szArgs, ARRAYSIZE(szArgs));
#endif

        // special case if app is empty and there is a "alt device" (file system root)
        // this must be "Open Folder" mode

        if ((0 == szApp[0]) && pszAltDeviceID)
        {
            StrCpyN(szApp, pszAltDeviceID, ARRAYSIZE(szApp));  // "F:\"
        }

        if (szApp[0])
        {
            SHELLEXECUTEINFO ei = {0};
            ei.cbSize = sizeof(ei);

            ei.lpFile = szApp;          // we have an app name
            ei.lpParameters = szArgs;   // and maybe some args
            ei.nShow = SW_SHOW;
            ei.fMask = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_DOENVSUBST;

            hr = ShellExecuteEx(&ei) ? S_OK : E_FAIL;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT CoMarshallToCmdLine(REFIID riid, IUnknown *punk, LPTSTR pszCmdLine, UINT cch)
{
    *pszCmdLine = 0;

    IStream *pstm;
    HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
    if (SUCCEEDED(hr)) 
    {
        hr = CoMarshalInterface(pstm, riid, punk, MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
        if (SUCCEEDED(hr))
        {
            IStream_Reset(pstm);

            char buf[255]; // big enough for a standard marshall record
            ULONG cb;
            hr = pstm->Read(buf, sizeof(buf), &cb);
            if (SUCCEEDED(hr))
            {
                StrCatBuff(pszCmdLine, TEXT("/DataObject:"), cch);
                pszCmdLine += lstrlen(pszCmdLine);
                // convert binary buffer to hex
                for (ULONG i = 0; i < cb; i++)
                {
                    *pszCmdLine++ = 'A' +  (0x0F & buf[i]);
                    *pszCmdLine++ = 'A' + ((0xF0 & buf[i]) >> 4);
                }
                *pszCmdLine = 0;
            }
        }
        pstm->Release();
    }
    return hr;
}

HRESULT CoUnmarshalFromCmdLine(LPCTSTR pszCmdLine, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;

    pszCmdLine = StrStr(pszCmdLine, TEXT("/DataObject:"));
    if (pszCmdLine)
    {
        pszCmdLine += lstrlen(TEXT("/DataObject:"));

        char buf[255]; // big enough for standard marshall buffer (which is 68 bytes)
        for (ULONG cb = 0; *pszCmdLine && (cb < sizeof(buf)); cb++)
        {
            buf[cb] = (*pszCmdLine - 'A') + ((*(pszCmdLine + 1) - 'A') << 4);
            if (*(pszCmdLine + 1))
                pszCmdLine += 2;
            else
                break;  // odd # of chars in cmd line, error
        }

        if (cb < sizeof(buf))
        {
            IStream *pstm;
            hr = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
            if (SUCCEEDED(hr)) 
            {
                // fill the marshall stream
                pstm->Write(buf, cb, NULL);

                // move back to start of stream
                IStream_Reset(pstm);

                hr = CoUnmarshalInterface(pstm, riid, ppv);

                pstm->Release();
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\idlist.cpp ===
#include "shellprv.h"
#pragma  hdrstop
#include "idlcomm.h"
#include "datautil.h"

#ifdef DEBUG
// Dugging aids for making sure we dont use free pidls
#define VALIDATE_PIDL(pidl) ASSERT(IS_VALID_PIDL(pidl))
#else
#define VALIDATE_PIDL(pidl)
#endif


STDAPI_(BOOL) SHIsValidPidl(LPCITEMIDLIST pidl)
{
    __try
    {
        LPCITEMIDLIST pidlIterate = pidl;

        // I use my own while loop instead of ILGetSize to avoid extra debug spew,
        // including asserts, that would result from the VALIDATE_PIDL call.  We are
        // testing for validity so an invalid pidl is an OK condition.
        while (pidlIterate->mkid.cb)
        {
            pidlIterate = _ILNext(pidlIterate);
        }
        
        return IsValidPIDL(pidl);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }
}


STDAPI_(LPITEMIDLIST) ILGetNext(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlRet = NULL;
    if (pidl && pidl->mkid.cb)
    {
        VALIDATE_PIDL(pidl);
        pidlRet = _ILNext(pidl);
    }

    return pidlRet;
}

STDAPI_(UINT) ILGetSizeAndDepth(LPCITEMIDLIST pidl, DWORD *pdwDepth)
{
    DWORD dwDepth = 0;
    UINT cbTotal = 0;
    if (pidl)
    {
        VALIDATE_PIDL(pidl);
        cbTotal += sizeof(pidl->mkid.cb);       // Null terminator
        while (pidl->mkid.cb)
        {
            cbTotal += pidl->mkid.cb;
            pidl = _ILNext(pidl);
            dwDepth++;
        }
    }

    if (pdwDepth)
        *pdwDepth = dwDepth;
        
    return cbTotal;
}

STDAPI_(UINT) ILGetSize(LPCITEMIDLIST pidl)
{
    return ILGetSizeAndDepth(pidl, NULL);
}

#define CBIDL_MIN       256
#define CBIDL_INCL      256

STDAPI_(LPITEMIDLIST) ILCreate()
{
    return _ILCreate(CBIDL_MIN);
}

// cbExtra is the amount to add to cbRequired if the block needs to grow,
// or it is 0 if we want to resize to the exact size

STDAPI_(LPITEMIDLIST) ILResize(LPITEMIDLIST pidl, UINT cbRequired, UINT cbExtra)
{
    if (pidl == NULL)
    {
        pidl = _ILCreate(cbRequired + cbExtra);
    }
    else if (!cbExtra || SHGetSize(pidl) < cbRequired)
    {
        pidl = (LPITEMIDLIST)SHRealloc(pidl, cbRequired + cbExtra);
    }
    return pidl;
}

STDAPI_(LPITEMIDLIST) ILAppendID(LPITEMIDLIST pidl, LPCSHITEMID pmkid, BOOL fAppend)
{
    // Create the ID list, if it is not given.
    if (!pidl)
    {
        pidl = ILCreate();
        if (!pidl)
            return NULL;        // memory overflow
    }

    UINT cbUsed = ILGetSize(pidl);
    UINT cbRequired = cbUsed + pmkid->cb;

    pidl = ILResize(pidl, cbRequired, CBIDL_INCL);
    if (!pidl)
        return NULL;    // memory overflow

    if (fAppend)
    {
        // Append it.
        MoveMemory(_ILSkip(pidl, cbUsed - sizeof(pidl->mkid.cb)), pmkid, pmkid->cb);
    }
    else
    {
        // Put it at the top
        MoveMemory(_ILSkip(pidl, pmkid->cb), pidl, cbUsed);
        MoveMemory(pidl, pmkid, pmkid->cb);

        ASSERT((ILGetSize(_ILNext(pidl))==cbUsed) ||
               (pmkid->cb == 0)); // if we're prepending the empty pidl, nothing changed
    }

    // We must put zero-terminator because of LMEM_ZEROINIT.
    _ILSkip(pidl, cbRequired - sizeof(pidl->mkid.cb))->mkid.cb = 0;
    ASSERT(ILGetSize(pidl) == cbRequired);

    return pidl;
}


STDAPI_(LPITEMIDLIST) ILFindLastID(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = pidl;
    LPCITEMIDLIST pidlNext = pidl;

    if (pidl == NULL)
        return NULL;

    VALIDATE_PIDL(pidl);

    // Find the last one
    while (pidlNext->mkid.cb)
    {
        pidlLast = pidlNext;
        pidlNext = _ILNext(pidlLast);
    }

    return (LPITEMIDLIST)pidlLast;
}


STDAPI_(BOOL) ILRemoveLastID(LPITEMIDLIST pidl)
{
    BOOL fRemoved = FALSE;

    if (pidl == NULL)
        return FALSE;

    if (pidl->mkid.cb)
    {
        LPITEMIDLIST pidlLast = (LPITEMIDLIST)ILFindLastID(pidl);

        ASSERT(pidlLast->mkid.cb);
        ASSERT(_ILNext(pidlLast)->mkid.cb==0);

        // Remove the last one
        pidlLast->mkid.cb = 0; // null-terminator
        fRemoved = TRUE;
    }

    return fRemoved;
}

STDAPI_(LPITEMIDLIST) ILClone(LPCITEMIDLIST pidl)
{
    if (pidl)
    {
        UINT cb = ILGetSize(pidl);
        LPITEMIDLIST pidlRet = (LPITEMIDLIST)SHAlloc(cb);
        if (pidlRet)
            memcpy(pidlRet, pidl, cb);

        return pidlRet;
    }
    return NULL;
}


STDAPI_(LPITEMIDLIST) ILCloneCB(LPCITEMIDLIST pidl, UINT cbPidl)
{
    UINT cb = cbPidl + sizeof(pidl->mkid.cb);
    LPITEMIDLIST pidlRet = (LPITEMIDLIST)SHAlloc(cb);
    if (pidlRet)
    {
        memcpy(pidlRet, pidl, cbPidl);
        // cbPidl can be odd, must use UNALIGNED
        *((UNALIGNED WORD *)((BYTE *)pidlRet + cbPidl)) = 0;  // NULL terminate
    }
    return pidlRet;
}

STDAPI_(LPITEMIDLIST) ILCloneUpTo(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlUpTo)
{
    return ILCloneCB(pidl, (UINT)((BYTE *)pidlUpTo - (BYTE *)pidl));
}

STDAPI_(LPITEMIDLIST) ILCloneFirst(LPCITEMIDLIST pidl)
{
    return ILCloneCB(pidl, pidl->mkid.cb);
}

STDAPI_(BOOL) ILIsEqualEx(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fMatchDepth, LPARAM lParam)
{
    BOOL fRet = FALSE;
    VALIDATE_PIDL(pidl1);
    VALIDATE_PIDL(pidl2);

    if (pidl1 == pidl2)
        fRet = TRUE;
    else
    {
        DWORD dw1;
        UINT cb1 = ILGetSizeAndDepth(pidl1, &dw1);
        DWORD dw2;
        UINT cb2 = ILGetSizeAndDepth(pidl2, &dw2);
        if (!fMatchDepth || dw1 == dw2)
        {
            if (cb1 == cb2 && memcmp(pidl1, pidl2, cb1) == 0)
                fRet = TRUE;
            else
            {
                IShellFolder *psfDesktop;
                if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
                {
                    if (psfDesktop->CompareIDs(lParam, pidl1, pidl2) == 0)
                        fRet = TRUE;
                    psfDesktop->Release();
                }
            }
        }
    }
    return fRet;
}

//  the only case where this wouldnt be effective is if we were using 
//  an old Simple pidl of a UNC and trying to compare with the actual
//  pidl.  because the depth wasnt maintained correctly before.
//  ILIsParent() has always had this problem.
STDAPI_(BOOL) ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    return ILIsEqualEx(pidl1, pidl2, TRUE, SHCIDS_CANONICALONLY);
}

// test if
//      pidlParent is a parent of pidlBelow
//      fImmediate requires that pidlBelow be a direct child of pidlParent.
//      Otherwise, self and grandchildren are okay too.
//
// example:
//      pidlParent: [my comp] [c:\] [windows]
//      pidlBelow:  [my comp] [c:\] [windows] [system32] [vmm.vxd]
//      fImmediate == FALSE result: TRUE
//      fImmediate == TRUE  result: FALSE

STDAPI_(BOOL) ILIsParent(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlBelow, BOOL fImmediate)
{
    LPCITEMIDLIST pidlParentT;
    LPCITEMIDLIST pidlBelowT;

    VALIDATE_PIDL(pidlParent);
    VALIDATE_PIDL(pidlBelow);

    if (!pidlParent || !pidlBelow)
        return FALSE;

    /* This code will not work correctly when comparing simple NET id lists
    /  against, real net ID lists.  Simple ID lists DO NOT contain network provider
    /  information therefore cannot pass the initial check of is pidlBelow longer than pidlParent.
    /  daviddv (2/19/1996) */

    for (pidlParentT = pidlParent, pidlBelowT = pidlBelow; !ILIsEmpty(pidlParentT);
         pidlParentT = _ILNext(pidlParentT), pidlBelowT = _ILNext(pidlBelowT))
    {
        // if pidlBelow is shorter than pidlParent, pidlParent can't be its parent.
        if (ILIsEmpty(pidlBelowT))
            return FALSE;
    }

    if (fImmediate)
    {
        // If fImmediate is TRUE, pidlBelowT should contain exactly one ID.
        if (ILIsEmpty(pidlBelowT) || !ILIsEmpty(_ILNext(pidlBelowT)))
            return FALSE;
    }

    //
    // Create a new IDList from a portion of pidlBelow, which contains the
    // same number of IDs as pidlParent.
    //
    BOOL fRet = FALSE;
    UINT cb = (UINT)((UINT_PTR)pidlBelowT - (UINT_PTR)pidlBelow);
    LPITEMIDLIST pidlBelowPrefix = _ILCreate(cb + sizeof(pidlBelow->mkid.cb));
    if (pidlBelowPrefix)
    {
        IShellFolder *psfDesktop;
        if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
        {
            CopyMemory(pidlBelowPrefix, pidlBelow, cb);

            ASSERT(ILGetSize(pidlBelowPrefix) == cb + sizeof(pidlBelow->mkid.cb));

            fRet = psfDesktop->CompareIDs(SHCIDS_CANONICALONLY, pidlParent, pidlBelowPrefix) == ResultFromShort(0);
            psfDesktop->Release();
        }
        ILFree(pidlBelowPrefix);
    }
    return fRet;
}

// this returns a pointer to the child id ie:
// given 
//  pidlParent = [my comp] [c] [windows] [desktop]
//  pidlChild  = [my comp] [c] [windows] [desktop] [dir] [bar.txt]
// return pointer to:
//  [dir] [bar.txt]
// NULL is returned if pidlParent is not a parent of pidlChild
STDAPI_(LPITEMIDLIST) ILFindChild(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild)
{
    if (ILIsParent(pidlParent, pidlChild, FALSE))
    {
        while (!ILIsEmpty(pidlParent))
        {
            pidlChild = _ILNext(pidlChild);
            pidlParent = _ILNext(pidlParent);
        }
        return (LPITEMIDLIST)pidlChild;
    }
    return NULL;
}

STDAPI_(LPITEMIDLIST) ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // Let me pass in NULL pointers
    if (!pidl1)
    {
        if (!pidl2)
        {
            return NULL;
        }
        return ILClone(pidl2);
    }
    else if (!pidl2)
    {
        return ILClone(pidl1);
    }

    UINT cb1 = ILGetSize(pidl1) - sizeof(pidl1->mkid.cb);
    UINT cb2 = ILGetSize(pidl2);

    VALIDATE_PIDL(pidl1);
    VALIDATE_PIDL(pidl2);
    LPITEMIDLIST pidlNew = _ILCreate(cb1 + cb2);
    if (pidlNew)
    {
        CopyMemory(pidlNew, pidl1, cb1);
        CopyMemory((LPTSTR)(((LPBYTE)pidlNew) + cb1), pidl2, cb2);
        ASSERT(ILGetSize(pidlNew) == cb1+cb2);
    }

    return pidlNew;
}

STDAPI_(void) ILFree(LPITEMIDLIST pidl)
{
    if (pidl)
    {
        ASSERT(IS_VALID_PIDL(pidl));
        SHFree(pidl);
    }
}

// back on Win9x this did global global data, no longer
STDAPI_(LPITEMIDLIST) ILGlobalClone(LPCITEMIDLIST pidl)
{
    return ILClone(pidl);
}

STDAPI_(void) ILGlobalFree(LPITEMIDLIST pidl)
{
    ILFree(pidl);
}

SHSTDAPI SHParseDisplayName(PCWSTR pszName, IBindCtx *pbc, LPITEMIDLIST *ppidl, SFGAOF sfgaoIn, SFGAOF *psfgaoOut)
{
    *ppidl = 0;
    if (psfgaoOut)
        *psfgaoOut = 0;
    
    // since ISF::PDN() takes a non-const pointer
    PWSTR pszParse = StrDupW(pszName);
    HRESULT hr = pszParse ? S_OK : E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        CComPtr<IShellFolder> spsfDesktop;
        hr = SHGetDesktopFolder(&spsfDesktop);
        if (SUCCEEDED(hr))
        {
            CComPtr<IBindCtx> spbcLocal;
            //  if they pass their own pbc, then they are responsible for
            //  adding in the translate param, else we default to using it
            if (!pbc)
            {
                hr = BindCtx_RegisterObjectParam(NULL, STR_PARSE_TRANSLATE_ALIASES, NULL, &spbcLocal);
                pbc = spbcLocal;
            }
            
            if (SUCCEEDED(hr))
            {
                ULONG cchEaten;
                SFGAOF sfgaoInOut = sfgaoIn;
                hr = spsfDesktop->ParseDisplayName(BindCtx_GetUIWindow(pbc), pbc, pszParse, &cchEaten, ppidl, psfgaoOut ? &sfgaoInOut : NULL);
                
                if (SUCCEEDED(hr) && psfgaoOut)
                {
                    *psfgaoOut = (sfgaoInOut & sfgaoIn);  // only return attributes passed in
                }
            }
        }
        LocalFree(pszParse);
    }
    
    return hr;
}

HRESULT _CFPBindCtx(IUnknown *punkToSkip, ILCFP_FLAGS dwFlags, IBindCtx **ppbc)
{
    HRESULT hr = S_FALSE;
    if (punkToSkip || (dwFlags & ILCFP_FLAG_SKIPJUNCTIONS))
        hr = SHCreateSkipBindCtx(punkToSkip, ppbc);
    else if (dwFlags & ILCFP_FLAG_NO_MAP_ALIAS)
    {
        //  we need to create a bindctx to block alias mapping.
        //  this will keep SHParseDisplayName() from adding the STR_PARSE_TRANSLATE_ALIASES
        hr = CreateBindCtx(0, ppbc);
    }
    return hr;
}

STDAPI ILCreateFromPathEx(LPCTSTR pszPath, IUnknown *punkToSkip, ILCFP_FLAGS dwFlags, LPITEMIDLIST *ppidl, DWORD *rgfInOut)
{
    CComPtr<IBindCtx> spbc;
    HRESULT hr = _CFPBindCtx(punkToSkip, dwFlags, &spbc);
    if (SUCCEEDED(hr))
    {
        hr = SHParseDisplayName(pszPath, spbc, ppidl, rgfInOut ? *rgfInOut : 0, rgfInOut);
    }
    return hr;
}

STDAPI ILCreateFromCLSID(REFCLSID clsid, LPITEMIDLIST *ppidl)
{
    TCHAR szCLSID[GUIDSTR_MAX + 3];
    szCLSID[0] = TEXT(':');
    szCLSID[1] = TEXT(':');
    SHStringFromGUID(clsid, szCLSID + 2, ARRAYSIZE(szCLSID) - 2);

    return SHILCreateFromPath(szCLSID, ppidl, NULL);
}

STDAPI SHILCreateFromPath(LPCTSTR pszPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut)
{
    return ILCreateFromPathEx(pszPath, NULL, ILCFP_FLAG_NO_MAP_ALIAS, ppidl, rgfInOut);
}

STDAPI_(LPITEMIDLIST) ILCreateFromPath(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl = NULL;
    HRESULT hr = SHILCreateFromPath(pszPath, &pidl, NULL);

    ASSERT(SUCCEEDED(hr) ? pidl != NULL : pidl == NULL);

    return pidl;
}


LPITEMIDLIST ILCreateFromPathA(IN LPCSTR pszPath)
{
    TCHAR szPath[MAX_PATH];

    SHAnsiToUnicode(pszPath, szPath, SIZECHARS(szPath));
    return ILCreateFromPath(szPath);
}

STDAPI_(BOOL) ILGetDisplayNameExA(IShellFolder *psf, LPCITEMIDLIST pidl, LPSTR pszName, DWORD cchSize, int fType)
{
    TCHAR szPath[MAX_PATH];
    if (ILGetDisplayNameEx(psf, pidl, szPath, fType))
    {
        SHTCharToAnsi(szPath, pszName, cchSize);
        return TRUE;
    }
    return FALSE;
}

STDAPI_(BOOL) ILGetDisplayNameEx(IShellFolder *psf, LPCITEMIDLIST pidl, LPTSTR pszName, int fType)
{
    TraceMsg(TF_WARNING, "WARNING: ILGetDisplayNameEx() has been deprecated, should use SHGetNameAndFlags() instead!!!");

    RIPMSG(pszName && IS_VALID_WRITE_BUFFER(pszName, TCHAR, MAX_PATH), "ILGetDisplayNameEx: caller passed bad pszName");

    if (!pszName)
        return FALSE;

    DEBUGWhackPathBuffer(pszName, MAX_PATH);
    *pszName = 0;

    if (!pidl)
        return FALSE;

    HRESULT hr;
    if (psf)
    {
        hr = S_OK;
        psf->AddRef();
    }
    else
    {
        hr = SHGetDesktopFolder(&psf);
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwGDNFlags;

        switch (fType)
        {
        case ILGDN_FULLNAME:
            dwGDNFlags = SHGDN_FORPARSING | SHGDN_FORADDRESSBAR;
            hr = DisplayNameOf(psf, pidl, dwGDNFlags, pszName, MAX_PATH);
            break;

        case ILGDN_INFOLDER:
        case ILGDN_ITEMONLY:
            dwGDNFlags = fType == ILGDN_INFOLDER ? SHGDN_INFOLDER : SHGDN_NORMAL;

            if (!ILIsEmpty(pidl))
            {
                hr = SHGetNameAndFlags(pidl, dwGDNFlags, pszName, MAX_PATH, NULL);
            }
            else
            {
                hr = DisplayNameOf(psf, pidl, dwGDNFlags, pszName, MAX_PATH);
            }
            break;
        }
        psf->Release();
    }

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

STDAPI_(BOOL) ILGetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszPath)
{
    return ILGetDisplayNameEx(NULL, pidl, pszPath, ILGDN_FULLNAME);
}

//***   ILGetPseudoName -- encode pidl relative to base
// Not used any more
//
STDAPI_(BOOL) ILGetPseudoNameW(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlSpec, WCHAR *pszBuf, int fType)
{
    *pszBuf = TEXT('\0');
    return FALSE;
}


STDAPI ILLoadFromStream(IStream *pstm, LPITEMIDLIST * ppidl)
{
    ASSERT(ppidl);

    // Delete the old one if any.
    if (*ppidl)
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }

    // Read the size of the IDLIST
    ULONG cb = 0;             // WARNING: We need to fill its HIWORD!
    HRESULT hr = pstm->Read(&cb, sizeof(USHORT), NULL); // Yes, USHORT
    if (SUCCEEDED(hr) && cb)
    {
        // Create a IDLIST
        LPITEMIDLIST pidl = _ILCreate(cb);
        if (pidl)
        {
            // Read its contents
            hr = pstm->Read(pidl, cb, NULL);
            if (SUCCEEDED(hr))
            {
                // Some pidls may be invalid.  We know they are invalid
                // if their size claims to be larger than the memory we
                // allocated.
                if (SHIsValidPidl(pidl) && (cb >= ILGetSize(pidl)))
                {
                    *ppidl = pidl;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            
            if (FAILED(hr))
            {
                ILFree(pidl);
            }
        }
        else
        {
           hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

STDAPI ILSaveToStream(IStream *pstm, LPCITEMIDLIST pidl)
{
    ULONG cb = ILGetSize(pidl);
    ASSERT(HIWORD(cb) == 0);
    HRESULT hr = pstm->Write(&cb, sizeof(USHORT), NULL); // Yes, USHORT
    if (SUCCEEDED(hr) && cb)
    {
        hr = pstm->Write(pidl, cb, NULL);
    }

    return hr;
}

//
// This one reallocated pidl if necessary. NULL is valid to pass in as pidl.
//
STDAPI_(LPITEMIDLIST) HIDA_FillIDList(HIDA hida, UINT i, LPITEMIDLIST pidl)
{
    UINT cbRequired = HIDA_GetIDList(hida, i, NULL, 0);
    pidl = ILResize(pidl, cbRequired, 32); // extra 32-byte if we realloc
    if (pidl)
    {
        HIDA_GetIDList(hida, i, pidl, cbRequired);
    }

    return pidl;
}


STDAPI_(LPITEMIDLIST) IDA_FullIDList(LPIDA pida, UINT i)
{
    LPITEMIDLIST pidl = NULL;
    LPCITEMIDLIST pidlParent = IDA_GetIDListPtr(pida, (UINT)-1);
    if (pidlParent)
    {
        LPCITEMIDLIST pidlRel = IDA_GetIDListPtr(pida, i);
        if (pidlRel)
        {
            pidl = ILCombine(pidlParent, pidlRel);
        }
    }
    return pidl;
}

LPITEMIDLIST HIDA_ILClone(HIDA hida, UINT i)
{
    LPIDA pida = (LPIDA)GlobalLock(hida);
    if (pida)
    {
        LPITEMIDLIST pidl = IDA_ILClone(pida, i);
        GlobalUnlock(hida);
        return pidl;
    }
    return NULL;
}

//
//  This is a helper function to be called from within IShellFolder::CompareIDs.
// When the first IDs of pidl1 and pidl2 are the (logically) same.
//
// Required:
//  psf && pidl1 && pidl2 && !ILEmpty(pidl1) && !ILEmpty(pidl2)
//
HRESULT ILCompareRelIDs(IShellFolder *psfParent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPARAM lParam)
{
    HRESULT hr;
    LPCITEMIDLIST pidlRel1 = _ILNext(pidl1);
    LPCITEMIDLIST pidlRel2 = _ILNext(pidl2);
    if (ILIsEmpty(pidlRel1))
    {
        if (ILIsEmpty(pidlRel2))
            hr = ResultFromShort(0);
        else
            hr = ResultFromShort(-1);
    }
    else
    {
        if (ILIsEmpty(pidlRel2))
        {
            hr = ResultFromShort(1);
        }
        else
        {
            //
            // pidlRel1 and pidlRel2 point to something
            //  (1) Bind to the next level of the IShellFolder
            //  (2) Call its CompareIDs to let it compare the rest of IDs.
            //
            LPITEMIDLIST pidlNext = ILCloneFirst(pidl1);    // pidl2 would work as well
            if (pidlNext)
            {
                IShellFolder *psfNext;
                hr = psfParent->BindToObject(pidlNext, NULL, IID_PPV_ARG(IShellFolder, &psfNext));
                if (SUCCEEDED(hr))
                {
                    IShellFolder2 *psf2;
                    if (SUCCEEDED(psfNext->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
                    {
                        //  we can use the lParam
                        psf2->Release();
                    }
                    else    //  cant use the lParam
                        lParam = 0;

                    //  columns arent valid to pass down
                    //  we just care about the flags param
                    hr = psfNext->CompareIDs((lParam & ~SHCIDS_COLUMNMASK), pidlRel1, pidlRel2);
                    psfNext->Release();
                }
                ILFree(pidlNext);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

// in:
//      pszLeft
//      pidl
//
// in/out:
//      psr

STDAPI StrRetCatLeft(LPCTSTR pszLeft, STRRET *psr, LPCITEMIDLIST pidl)
{
    HRESULT hr;
    TCHAR szRight[MAX_PATH];
    UINT cchRight, cchLeft = ualstrlen(pszLeft);

    switch (psr->uType)
    {
    case STRRET_CSTR:
        cchRight = lstrlenA(psr->cStr);
        break;
    case STRRET_OFFSET:
        cchRight = lstrlenA(STRRET_OFFPTR(pidl, psr));
        break;
    case STRRET_WSTR:
        cchRight = lstrlenW(psr->pOleStr);
        break;
    }

    if (cchLeft + cchRight < MAX_PATH) 
    {
        hr = StrRetToBuf(psr, pidl, szRight, ARRAYSIZE(szRight)); // will free psr for us
        if (SUCCEEDED(hr))
        {
            psr->pOleStr = (LPOLESTR)SHAlloc((lstrlen(pszLeft) + 1 + cchRight) * sizeof(TCHAR));
            if (psr->pOleStr == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                psr->uType = STRRET_WSTR;
                lstrcpy(psr->pOleStr, pszLeft);
                lstrcat(psr->pOleStr, szRight);
                hr = S_OK;
            }
        }
    } 
    else 
    {
        hr = E_NOTIMPL;
    }
    return hr;
}

STDAPI_(void) StrRetFormat(STRRET *psr, LPCITEMIDLIST pidlRel, LPCTSTR pszTemplate, LPCTSTR pszAppend)
{
     TCHAR szT[MAX_PATH];

     StrRetToBuf(psr, pidlRel, szT, ARRAYSIZE(szT));
     LPTSTR pszRet = ShellConstructMessageString(HINST_THISDLL, pszTemplate, pszAppend, szT);
     if (pszRet)
     {
         StringToStrRet(pszRet, psr);
         LocalFree(pszRet);
     }
}

//
// Notes: This one passes SHGDN_FORPARSING to ISF::GetDisplayNameOf.
//
HRESULT ILGetRelDisplayName(IShellFolder *psf, STRRET *psr,
    LPCITEMIDLIST pidlRel, LPCTSTR pszName, LPCTSTR pszTemplate, DWORD dwFlags)
{
    HRESULT hr;
    LPITEMIDLIST pidlLeft = ILCloneFirst(pidlRel);
    if (pidlLeft)
    {
        IShellFolder *psfNext;
        hr = psf->BindToObject(pidlLeft, NULL, IID_PPV_ARG(IShellFolder, &psfNext));
        if (SUCCEEDED(hr))
        {
            LPCITEMIDLIST pidlRight = _ILNext(pidlRel);
            hr = psfNext->GetDisplayNameOf(pidlRight, dwFlags, psr);
            if (SUCCEEDED(hr))
            {
                if (pszTemplate)
                {
                    StrRetFormat(psr, pidlRight, pszTemplate, pszName);
                }
                else
                {
                    hr = StrRetCatLeft(pszName, psr, pidlRight);
                }
            }
            psfNext->Release();
        }

        ILFree(pidlLeft);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

#undef ILCreateFromPath
STDAPI_(LPITEMIDLIST) ILCreateFromPath(LPCTSTR pszPath)
{
    return ILCreateFromPathW(pszPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\idldata.h ===
#ifndef __IDLDATA_H__
#define __IDLDATA_H__

#include "idlcomm.h"

#define MAX_FORMATS     ICF_MAX

STDAPI CIDLData_CreateInstance(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject *pdtInner, IDataObject **ppdtobj);

class CIDLDataObj : public IDataObject, public IAsyncOperation
{
friend HRESULT CIDLData_CreateInstance(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject *pdtInner, IDataObject **ppdtobj);
protected:
    CIDLDataObj(IDataObject *pdtInner);
    CIDLDataObj(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[]);
    CIDLDataObj(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject *pdtInner);
    virtual ~CIDLDataObj(void);

public:
    void InitIDLData1(IDataObject *pdtInner);
    void InitIDLData2(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[]);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDataObject
    STDMETHODIMP GetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
    STDMETHODIMP GetDataHere(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
    STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pFmtEtcIn, FORMATETC *pFmtEtcOut);
    STDMETHODIMP SetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
    STDMETHODIMP DAdvise(FORMATETC *pFmtEtc, DWORD grfAdv, LPADVISESINK pAdvSink, DWORD *pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppEnum);

    // IAsyncOperation
    STDMETHODIMP SetAsyncMode(BOOL fDoOpAsync);
    STDMETHODIMP GetAsyncMode(BOOL *pfIsOpAsync);
    STDMETHODIMP StartOperation(IBindCtx * pbc);
    STDMETHODIMP InOperation(BOOL * pfInAsyncOp);
    STDMETHODIMP EndOperation(HRESULT hResult, IBindCtx * pbc, DWORD dwEffects);

private:
    LONG _cRef;
    IDataObject *_pdtInner;
    IUnknown *_punkThread;
    BOOL _fEnumFormatCalled;    // TRUE once called.
    BOOL _fDidAsynchStart;
    FORMATETC _fmte[MAX_FORMATS];
    STGMEDIUM _medium[MAX_FORMATS];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\idldrop.h ===
#ifndef __IDLDROP_H__
#define __IDLDROP_H__


typedef struct {
    DWORD        dwDefEffect;
    IDataObject *pdtobj;
    POINTL       pt;
    DWORD *      pdwEffect;
    HKEY         hkeyProgID;
    HKEY         hkeyBase;
    UINT         idMenu;
    UINT         idCmd;
    DWORD        grfKeyState;
} DRAGDROPMENUPARAM;

class CIDLDropTarget: public IDropTarget
{
public:
    CIDLDropTarget(HWND hwnd);
    HRESULT _Init(LPCITEMIDLIST pidl);
    HWND _GetWindow();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDropTarget methods.
    STDMETHODIMP DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

protected:
    virtual ~CIDLDropTarget();
    HRESULT DragDropMenu(DWORD dwDefaultEffect, IDataObject *pdtobj, POINTL pt, DWORD *pdwEffect, HKEY hkeyProgID, HKEY hkeyBase, UINT idMenu, DWORD grfKeyState);
    HRESULT DragDropMenuEx(DRAGDROPMENUPARAM *pddm);

private:
    LONG m_cRef;

protected:
    HWND                m_hwnd;
    LPITEMIDLIST        m_pidl;                 // IDList to the target folder
    DWORD               m_grfKeyStateLast;      // for previous DragOver/Enter
    IDataObject        *m_pdtobj;
    DWORD               m_dwEffectLastReturned; // stashed effect that's returned by base class's dragover
    DWORD               m_dwData;               // DTID_*
    DWORD               m_dwEffectPreferred;    // if dwData & DTID_PREFERREDEFFECT
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\idltree.h ===
#include <linklistt.h>

//  put some notes here about how we do things for perf reasons.
//  so our behavior is pathological to our client usage
//  and is not totall generic.

enum 
{
    IDLDATAF_MATCH_EXACT            = 0x00000001,    //  self only
    IDLDATAF_MATCH_IMMEDIATE        = 0x00000003,    //  includes self and immediate children
    IDLDATAF_MATCH_RECURSIVE        = 0x00000007,    //  includes self and all children
//    IDLDATAF_IUNKNOWN               = 0x80000000,
//    IDLDATAF_SINGLETON              = 0x10000000,
};
typedef DWORD IDLDATAF;

class CIDLData
{
public: // basically a struct
    BOOL Init(IDLDATAF flags, INT_PTR data);
//    ~CIDLData()  { if (_flags & IDLDATAF_IUNKNOWN) ((IUnknown *)_data)->Release(); }
    HRESULT GetData(IDLDATAF flags, INT_PTR *pdata);

    IDLDATAF _flags;
    INT_PTR _data;
};

class CIDLMatchMany;
class CIDLTree;
class CIDLNode
{
public: // methods
    ~CIDLNode();

protected:  // methods
    HRESULT GetNode(BOOL fCreate, LPCITEMIDLIST pidlChild, CIDLNode **ppin, IDLDATAF *pflagsFound = NULL);
    HRESULT IDList(LPITEMIDLIST *ppidl);
    BOOL Init(LPCITEMIDLIST pidl, CIDLNode *pinParent);

    BOOL _InitSF();
    HRESULT _BindToFolder(LPCITEMIDLIST pidl, IShellFolder **ppsf);
    BOOL _IsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    CLinkedNode<CIDLNode> *_GetKid(LPCITEMIDLIST pidl);
    HRESULT _AddData(IDLDATAF flags, INT_PTR data);
    HRESULT _RemoveData(INT_PTR data);
    void _FreshenKids(void);
    BOOL _IsEmpty(void) { return _listKids.IsEmpty() && _listDatas.IsEmpty();}

protected:  // members
    LONG _cUsage;
    LPITEMIDLIST _pidl;
    IShellFolder *_psf;
    CIDLNode *_pinParent;

    //  lists
    CLinkedList<CIDLNode> _listKids;
    CLinkedList<CIDLData> _listDatas;

    friend class CIDLTree;
    friend class CIDLMatchMany;
};

typedef DWORD IDLMATCHF;

class CIDLMatchMany 
{
public:
    HRESULT Next(INT_PTR *pdata, LPITEMIDLIST *ppidl);
    CIDLMatchMany(IDLDATAF flags, CIDLNode *pin) 
        : _flags(flags), _pin(pin) { if (pin) _lw.Init(&pin->_listDatas);}
        
protected:  // members
    IDLDATAF _flags;
    CIDLNode *_pin;
    CLinkedWalk<CIDLData> _lw;
};

class CIDLTree : CIDLNode
{
public:
    HRESULT AddData(IDLDATAF flags, LPCITEMIDLIST pidlIndex, INT_PTR data);
    HRESULT RemoveData(LPCITEMIDLIST pidlIndex, INT_PTR data);
    HRESULT MatchOne(IDLDATAF flags, LPCITEMIDLIST pidlMatch, INT_PTR *pdata, LPITEMIDLIST *ppidl);
    HRESULT MatchMany(IDLDATAF flags, LPCITEMIDLIST pidlMatch, CIDLMatchMany **ppmatch);
    HRESULT Freshen(void);
    
    static HRESULT Create(CIDLTree **pptree);
protected:  // methods
    CIDLNode *_MatchNode(LPCITEMIDLIST pidlMatch, IDLMATCHF *pflags);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\idldata.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "bookmk.h"

#include "idldata.h"
#include "datautil.h"
#include <brfcasep.h>

// External prototypes

CLIPFORMAT g_acfIDLData[ICF_MAX] = { CF_HDROP, 0 };

#define RCF(x)  (CLIPFORMAT) RegisterClipboardFormat(x)

STDAPI_(void) IDLData_InitializeClipboardFormats(void)
{
    if (g_cfBriefObj == 0)
    {
        g_cfHIDA                       = RCF(CFSTR_SHELLIDLIST);
        g_cfOFFSETS                    = RCF(CFSTR_SHELLIDLISTOFFSET);
        g_cfNetResource                = RCF(CFSTR_NETRESOURCES);
        g_cfFileContents               = RCF(CFSTR_FILECONTENTS);         // "FileContents"
        g_cfFileGroupDescriptorA       = RCF(CFSTR_FILEDESCRIPTORA);      // "FileGroupDescriptor"
        g_cfFileGroupDescriptorW       = RCF(CFSTR_FILEDESCRIPTORW);      // "FileGroupDescriptor"
        g_cfPrivateShellData           = RCF(CFSTR_SHELLIDLISTP);
        g_cfFileNameA                  = RCF(CFSTR_FILENAMEA);            // "FileName"
        g_cfFileNameW                  = RCF(CFSTR_FILENAMEW);            // "FileNameW"
        g_cfFileNameMapA               = RCF(CFSTR_FILENAMEMAP);          // "FileNameMap"
        g_cfFileNameMapW               = RCF(CFSTR_FILENAMEMAPW);         // "FileNameMapW"
        g_cfPrinterFriendlyName        = RCF(CFSTR_PRINTERGROUP);
        g_cfHTML                       = RCF(TEXT("HTML Format"));
        g_cfPreferredDropEffect        = RCF(CFSTR_PREFERREDDROPEFFECT);  // "Preferred DropEffect"
        g_cfPerformedDropEffect        = RCF(CFSTR_PERFORMEDDROPEFFECT);  // "Performed DropEffect"
        g_cfLogicalPerformedDropEffect = RCF(CFSTR_LOGICALPERFORMEDDROPEFFECT); // "Logical Performed DropEffect"
        g_cfPasteSucceeded             = RCF(CFSTR_PASTESUCCEEDED);       // "Paste Succeeded"
        g_cfShellURL                   = RCF(CFSTR_SHELLURL);             // "Uniform Resource Locator"
        g_cfInDragLoop                 = RCF(CFSTR_INDRAGLOOP);           // "InShellDragLoop"
        g_cfDragContext                = RCF(CFSTR_DRAGCONTEXT);          // "DragContext"
        g_cfTargetCLSID                = RCF(CFSTR_TARGETCLSID);          // "TargetCLSID", who the drag drop went to
        g_cfEmbeddedObject             = RCF(TEXT("Embedded Object"));
        g_cfObjectDescriptor           = RCF(TEXT("Object Descriptor"));
        g_cfNotRecyclable              = RCF(TEXT("NotRecyclable"));      // This object is not recyclable in the recycle bin.
        g_cfBriefObj                   = RCF(CFSTR_BRIEFOBJECT);
        g_cfText                       = CF_TEXT;
        g_cfUnicodeText                = CF_UNICODETEXT;
        g_cfDropEffectFolderList       = RCF(CFSTR_DROPEFFECTFOLDERLIST);
        g_cfAutoPlayHIDA               = RCF(CFSTR_AUTOPLAY_SHELLIDLISTS);
    }
}

STDMETHODIMP CIDLDataObj::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CIDLDataObj, IDataObject),  
        QITABENT(CIDLDataObj, IAsyncOperation),     
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CIDLDataObj::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CIDLDataObj::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CIDLDataObj::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    HRESULT hr = E_INVALIDARG;

    pmedium->hGlobal = NULL;
    pmedium->pUnkForRelease = NULL;

    for (int i = 0; i < MAX_FORMATS; i++)
    {
        if ((_fmte[i].cfFormat == pformatetcIn->cfFormat) &&
            (_fmte[i].tymed & pformatetcIn->tymed) &&
            (_fmte[i].dwAspect == pformatetcIn->dwAspect))
        {
            *pmedium = _medium[i];

            if (pmedium->hGlobal)
            {
                // Indicate that the caller should not release hmem.
                if (pmedium->tymed == TYMED_HGLOBAL)
                {
                    InterlockedIncrement(&_cRef);
                    pmedium->pUnkForRelease = SAFECAST(this, IDataObject *);
                    return S_OK;
                }

                // if the type is stream  then clone the stream.
                if (pmedium->tymed == TYMED_ISTREAM)
                {
                    hr = CreateStreamOnHGlobal(NULL, TRUE, &pmedium->pstm);
                    if (SUCCEEDED(hr))
                    {
                        STATSTG stat;

                         // Get the Current Stream size
                         hr = _medium[i].pstm->Stat(&stat, STATFLAG_NONAME);
                         if (SUCCEEDED(hr))
                         {
                            // Seek the source stream to  the beginning.
                            _medium[i].pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);

                            // Copy the entire source into the destination. Since the destination stream is created using 
                            // CreateStreamOnHGlobal, it seek pointer is at the beginning.
                            hr = _medium[i].pstm->CopyTo(pmedium->pstm, stat.cbSize, NULL,NULL );
                            
                            // Before returning Set the destination seek pointer back at the beginning.
                            pmedium->pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);

                            // If this medium has a punk for release, make sure to add ref that...
                            pmedium->pUnkForRelease = _medium[i].pUnkForRelease;
                            if (pmedium->pUnkForRelease)
                                pmedium->pUnkForRelease->AddRef();

                            //Hoooh its done. 
                            return hr;

                         }
                         else
                         {
                             hr = E_OUTOFMEMORY;
                         }
                    }
                }
                
            }
        }
    }

    if (hr == E_INVALIDARG && _pdtInner) 
        hr = _pdtInner->GetData(pformatetcIn, pmedium);

    return hr;
}

STDMETHODIMP CIDLDataObj::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
#ifdef DEBUG
    if (pformatetc->cfFormat<CF_MAX) 
    {
        TraceMsg(TF_IDLIST, "CIDLDataObj::GetDataHere called with %x,%x,%x",
                 pformatetc->cfFormat, pformatetc->tymed, pmedium->tymed);
    }
    else 
    {
        TCHAR szName[256];

        GetClipboardFormatName(pformatetc->cfFormat, szName, ARRAYSIZE(szName));
        TraceMsg(TF_IDLIST, "CIDLDataObj::GetDataHere called with %s,%x,%x",
                 szName, pformatetc->tymed, pmedium->tymed);
    }
#endif

    return _pdtInner ? _pdtInner->GetDataHere(pformatetc, pmedium) : E_NOTIMPL;
}

STDMETHODIMP CIDLDataObj::QueryGetData(FORMATETC *pformatetcIn)
{
#ifdef DEBUG
    if (pformatetcIn->cfFormat<CF_MAX) 
    {
        TraceMsg(TF_IDLIST, "CIDLDataObj::QueryGetData called with %x,%x",
                             pformatetcIn->cfFormat, pformatetcIn->tymed);
    }
    else 
    {
        TCHAR szName[256];
        GetClipboardFormatName(pformatetcIn->cfFormat, szName, ARRAYSIZE(szName));
        TraceMsg(TF_IDLIST, "CIDLDataObj::QueryGetData called with %s,%x",
                             szName, pformatetcIn->tymed);
    }
#endif

    for (int i = 0; i < MAX_FORMATS; i++)
    {
        if ((_fmte[i].cfFormat == pformatetcIn->cfFormat) &&
            (_fmte[i].tymed & pformatetcIn->tymed) &&
            (_fmte[i].dwAspect == pformatetcIn->dwAspect))
            return S_OK;
    }

    HRESULT hr = S_FALSE;
    if (_pdtInner)
        hr = _pdtInner->QueryGetData(pformatetcIn);
    return hr;
}

STDMETHODIMP CIDLDataObj::GetCanonicalFormatEtc(FORMATETC *pformatetc, FORMATETC *pformatetcOut)
{
    // This is the simplest implemtation. It means we always return
    // the data in the format requested.
    return DATA_S_SAMEFORMATETC;
}

STDMETHODIMP CIDLDataObj::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    HRESULT hr;

    ASSERT(pformatetc->tymed == pmedium->tymed);

    if (fRelease)
    {
        // first add it if that format is already present
        // on a NULL medium (render on demand)
        for (int i = 0; i < MAX_FORMATS; i++)
        {
            if ((_fmte[i].cfFormat == pformatetc->cfFormat) &&
                (_fmte[i].tymed    == pformatetc->tymed) &&
                (_fmte[i].dwAspect == pformatetc->dwAspect))
            {
                //
                // We are simply adding a format, ignore.
                //
                if (pmedium->hGlobal == NULL)
                    return S_OK;

                // if we are set twice on the same object
                if (_medium[i].hGlobal)
                    ReleaseStgMedium(&_medium[i]);

                _medium[i] = *pmedium;
                return S_OK;
            }
        }

        //
        //  This is a new clipboard format.  Give the inner a chance first.
        //  This is important for formats like "Performed DropEffect" and
        //  "TargetCLSID", which are used by us to communicate information
        //  into the data object.
        //
        if (_pdtInner == NULL ||
            FAILED(hr = _pdtInner->SetData(pformatetc, pmedium, fRelease)))
        {
            // Inner object doesn't want it; let's keep it ourselves
            // now look for a free slot
            for (i = 0; i < MAX_FORMATS; i++)
            {
                if (_fmte[i].cfFormat == 0)
                {
                    // found a free slot
                    _medium[i] = *pmedium;
                    _fmte[i] = *pformatetc;
                    return S_OK;
                }
            }
            // fixed size table
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        if (_pdtInner)
            hr = _pdtInner->SetData(pformatetc, pmedium, fRelease);
        else
            hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CIDLDataObj::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
{
    // If this is the first time, build the format list by calling
    // QueryGetData with each clipboard format.
    if (!_fEnumFormatCalled)
    {
        UINT ifmt;
        FORMATETC fmte = { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        STGMEDIUM medium = { TYMED_HGLOBAL, NULL, NULL };
        for (ifmt = 0; ifmt < ICF_MAX; ifmt++)
        {
            fmte.cfFormat = g_acfIDLData[ifmt];
            if (QueryGetData(&fmte) == S_OK) 
            {
                SetData(&fmte, &medium, TRUE);
            }
        }
        _fEnumFormatCalled = TRUE;
    }

    // Get the number of formatetc
    for (UINT cfmt = 0; cfmt < MAX_FORMATS; cfmt++)
    {
        if (_fmte[cfmt].cfFormat == 0)
            break;
    }

    return SHCreateStdEnumFmtEtcEx(cfmt, _fmte, _pdtInner, ppenumFormatEtc);
}

STDMETHODIMP CIDLDataObj::DAdvise(FORMATETC * pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD *pdwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CIDLDataObj::DUnadvise(DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CIDLDataObj::EnumDAdvise(LPENUMSTATDATA *ppenumAdvise)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

// *** IAsyncOperation methods ***

HRESULT CIDLDataObj::SetAsyncMode(BOOL fDoOpAsync)
{ 
    return E_NOTIMPL;
}

HRESULT CIDLDataObj::GetAsyncMode(BOOL *pfIsOpAsync)
{
    if (_punkThread || IsMainShellProcess())
    {
        *pfIsOpAsync = TRUE;
    }
    else
    {
        *pfIsOpAsync = FALSE;
    }
    return S_OK;
}
  
HRESULT CIDLDataObj::StartOperation(IBindCtx * pbc)
{
    _fDidAsynchStart = TRUE;
    return S_OK;
}
  
HRESULT CIDLDataObj::InOperation(BOOL * pfInAsyncOp)
{
    if (_fDidAsynchStart)
    {
        *pfInAsyncOp = TRUE;
    }
    else
    {
        *pfInAsyncOp = FALSE;
    }
    return S_OK;
}
  
HRESULT CIDLDataObj::EndOperation(HRESULT hResult, IBindCtx * pbc, DWORD dwEffects)
{
    _fDidAsynchStart = FALSE;
    return S_OK;
}

void CIDLDataObj::InitIDLData1(IDataObject *pdtInner)
{
    _cRef = 1;
    _pdtInner = pdtInner;
    if (pdtInner)
        pdtInner->AddRef();
    SHGetThreadRef(&_punkThread);
}

void CIDLDataObj::InitIDLData2(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[])
{
    if (apidl)
    {
        HIDA hida = HIDA_Create(pidlFolder, cidl, apidl);
        if (hida)
        {
#if 0 // not yet
            // QueryGetData/SetData on HDROP before calling DataObj_SetGlobal with
            // HIDA to insure that CF_HDROP will come first in the enumerator
            FORMATETC fmte = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
            STGMEDIUM medium = { TYMED_HGLOBAL, NULL, NULL };
            if (QueryGetData(&fmte) == S_OK) 
            {
                SetData(&fmte, &medium, TRUE);
            }
#endif // 0                
            IDLData_InitializeClipboardFormats(); // init our registerd formats

            DataObj_SetGlobal(this, g_cfHIDA, hida);
        }
    }
}

CIDLDataObj::CIDLDataObj(IDataObject *pdtInner)
{
    InitIDLData1(pdtInner);
}

CIDLDataObj::CIDLDataObj(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject *pdtInner)
{
    InitIDLData1(pdtInner);
    InitIDLData2(pidlFolder, cidl, apidl);
}

CIDLDataObj::CIDLDataObj(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[])
{
    InitIDLData1(NULL);
    InitIDLData2(pidlFolder, cidl, apidl);
}

CIDLDataObj::~CIDLDataObj()
{
    for (int i = 0; i < MAX_FORMATS; i++)
    {
        if (_medium[i].hGlobal)
            ReleaseStgMedium(&_medium[i]);
    }

    if (_pdtInner)
        _pdtInner->Release();

    if (_punkThread)
        _punkThread->Release();
}

//
// Create an instance of CIDLDataObj with default Vtable pointer.
//
STDAPI CIDLData_CreateFromIDArray(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject **ppdtobj)
{
    return CIDLData_CreateInstance(pidlFolder, cidl, apidl, NULL, ppdtobj);
}

HRESULT CIDLData_CreateInstance(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject *pdtInner, IDataObject **ppdtobj)
{
    *ppdtobj = new CIDLDataObj(pidlFolder, cidl, apidl, pdtInner);
    return *ppdtobj ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\idldrop.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "datautil.h"
#include "idlcomm.h"
#include "idldrop.h"

STDAPI_(BOOL) DoesDropTargetSupportDAD(IDropTarget *pdtgt)
{
    IDropTargetWithDADSupport* pdt;
    if (pdtgt && SUCCEEDED(pdtgt->QueryInterface(IID_IDropTargetWithDADSupport, (void**)&pdt)))
    {
        pdt->Release();
        return TRUE;
    }
    return FALSE;
}

CIDLDropTarget::CIDLDropTarget(HWND hwnd) : m_cRef(1), m_hwnd(hwnd)
{
}

CIDLDropTarget::~CIDLDropTarget()
{
    // if we hit this a lot maybe we should just release it
    AssertMsg(m_pdtobj == NULL, TEXT("didn't get matching DragLeave."));

    if (m_pidl)
        ILFree(m_pidl);
}

HRESULT CIDLDropTarget::_Init(LPCITEMIDLIST pidl)
{
    ASSERT(m_pidl == NULL);
    return pidl ? SHILClone(pidl, &m_pidl) : S_OK;
}

HWND CIDLDropTarget::_GetWindow()
{
    return m_hwnd;
}

STDMETHODIMP CIDLDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CIDLDropTarget, IUnknown),  
        QITABENT(CIDLDropTarget, IDropTarget),  
        QITABENT(CIDLDropTarget, IDropTargetWithDADSupport),     
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CIDLDropTarget::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CIDLDropTarget::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}

STDAPI GetClipFormatFlags(IDataObject *pdtobj, DWORD *pdwData, DWORD *pdwEffectPreferred);

STDMETHODIMP CIDLDropTarget::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    ASSERT(m_pdtobj == NULL);               // DragDrop protocol requires DragLeave, this should be empty

    // init our registerd data formats
    IDLData_InitializeClipboardFormats();

    m_grfKeyStateLast = grfKeyState;
    m_dwEffectLastReturned = *pdwEffect;

    IUnknown_Set((IUnknown **)&m_pdtobj, (IUnknown *)pDataObj);

    GetClipFormatFlags(m_pdtobj, &m_dwData, &m_dwEffectPreferred);

    return S_OK;
}

// subclasses can prevetn us from assigning in the dwEffect by not passing in pdwEffect
STDMETHODIMP CIDLDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    m_grfKeyStateLast = grfKeyState;
    if (pdwEffect)
        *pdwEffect = m_dwEffectLastReturned;
    return S_OK;
}

STDMETHODIMP CIDLDropTarget::DragLeave()
{
    IUnknown_Set((IUnknown **)&m_pdtobj, NULL);
    return S_OK;
}

STDMETHODIMP CIDLDropTarget::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return E_NOTIMPL;
}

struct {
    UINT uID;
    DWORD dwEffect;
} const c_IDEffects[] = {
    DDIDM_COPY,         DROPEFFECT_COPY,
    DDIDM_MOVE,         DROPEFFECT_MOVE,
    DDIDM_CONTENTS_DESKCOMP,     DROPEFFECT_LINK,
    DDIDM_LINK,         DROPEFFECT_LINK,
    DDIDM_SCRAP_COPY,   DROPEFFECT_COPY,
    DDIDM_SCRAP_MOVE,   DROPEFFECT_MOVE,
    DDIDM_DOCLINK,      DROPEFFECT_LINK,
    DDIDM_CONTENTS_COPY, DROPEFFECT_COPY,
    DDIDM_CONTENTS_MOVE, DROPEFFECT_MOVE,
    DDIDM_CONTENTS_LINK, DROPEFFECT_LINK,
    DDIDM_CONTENTS_DESKIMG,     DROPEFFECT_LINK,
    DDIDM_SYNCCOPYTYPE, DROPEFFECT_COPY,        // (order is important)
    DDIDM_SYNCCOPY,     DROPEFFECT_COPY,
    DDIDM_OBJECT_COPY,  DROPEFFECT_COPY,
    DDIDM_OBJECT_MOVE,  DROPEFFECT_MOVE,
};

//
// Pops up the "Copy, Link, Move" context menu, so that the user can
// choose one of them.
//
// in:
//      pdwEffect               drop effects allowed
//      dwDefaultEffect         default drop effect
//      hkeyBase/hkeyProgID     extension hkeys
//      hmenuReplace            replaces POPUP_NONDEFAULTDD.  Can only contain:
//                                  DDIDM_MOVE, DDIDM_COPY, DDIDM_LINK menu ids
//      pt                      in screen
// Returns:
//      S_OK    -- Menu item is processed by one of extensions or canceled
//      S_FALSE -- Menu item is selected
//
HRESULT CIDLDropTarget::DragDropMenu(DWORD dwDefaultEffect,
                                    IDataObject *pdtobj,
                                    POINTL pt, DWORD *pdwEffect,
                                    HKEY hkeyProgID, HKEY hkeyBase,
                                    UINT idMenu, DWORD grfKeyState)
{
    DRAGDROPMENUPARAM ddm = { dwDefaultEffect, pdtobj, { pt.x, pt.y},
                              pdwEffect,
                              hkeyProgID, hkeyBase, idMenu, 0, grfKeyState };
    return DragDropMenuEx(&ddm);
}

HRESULT CIDLDropTarget::DragDropMenuEx(DRAGDROPMENUPARAM *pddm)
{
    HRESULT hr = E_OUTOFMEMORY;       // assume error
    DWORD dwEffectOut = 0;                              // assume no-ope.
    HMENU hmenu = SHLoadPopupMenu(HINST_THISDLL, pddm->idMenu);
    if (hmenu)
    {
        UINT idCmd;
        UINT idCmdFirst = DDIDM_EXTFIRST;
        HDXA hdxa = HDXA_Create();
        HDCA hdca = DCA_Create();
        if (hdxa && hdca)
        {
            // PERF (toddb): Even though pddm->hkeyBase does not have the same value as
            // pddm->hkeyProgID they can both be the same registry key (HKCR\FOLDER, for example).
            // As a result we sometimes enumerate this key twice looking for the same data.  As
            // this is sometimes a slow operation we should avoid this.  The comparision
            // done below was never valid on NT and might not be valid on win9x.

            //
            // Add extended menu for "Base" class.
            //
            if (pddm->hkeyBase && pddm->hkeyBase != pddm->hkeyProgID)
                DCA_AddItemsFromKey(hdca, pddm->hkeyBase, STRREG_SHEX_DDHANDLER);

            //
            // Enumerate the DD handlers and let them append menu items.
            //
            if (pddm->hkeyProgID)
                DCA_AddItemsFromKey(hdca, pddm->hkeyProgID, STRREG_SHEX_DDHANDLER);

            idCmdFirst = HDXA_AppendMenuItems(hdxa, pddm->pdtobj, 1,
                &pddm->hkeyProgID, m_pidl, hmenu, 0,
                DDIDM_EXTFIRST, DDIDM_EXTLAST, 0, hdca);
        }

        // eliminate menu options that are not allowed by dwEffect

        for (int nItem = 0; nItem < ARRAYSIZE(c_IDEffects); ++nItem)
        {
            if (GetMenuState(hmenu, c_IDEffects[nItem].uID, MF_BYCOMMAND)!=(UINT)-1)
            {
                if (!(c_IDEffects[nItem].dwEffect & *(pddm->pdwEffect)))
                {
                    RemoveMenu(hmenu, c_IDEffects[nItem].uID, MF_BYCOMMAND);
                }
                else if (c_IDEffects[nItem].dwEffect == pddm->dwDefEffect)
                {
                    SetMenuDefaultItem(hmenu, c_IDEffects[nItem].uID, MF_BYCOMMAND);
                }
            }
        }

        //
        // If this dragging is caused by the left button, simply choose
        // the default one, otherwise, pop up the context menu.  If there
        // is no key state info and the original effect is the same as the
        // current effect, choose the default one, otherwise pop up the
        // context menu.  
        //
        if ((m_grfKeyStateLast & MK_LBUTTON) ||
            (!m_grfKeyStateLast && (*(pddm->pdwEffect) == pddm->dwDefEffect)) )
        {
            idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0);
            // This one MUST be called here. Please read its comment block.
            DAD_DragLeave();

            if (m_hwnd)
                SetForegroundWindow(m_hwnd);
        }
        else
        {
            // Note that SHTrackPopupMenu calls DAD_DragLeave().
            idCmd = SHTrackPopupMenu(hmenu, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                    pddm->pt.x, pddm->pt.y, 0, m_hwnd, NULL);
        }

        // We also need to call this here to release the dragged image.
        DAD_SetDragImage(NULL, NULL);

        // Check if the user selected one of add-in menu items.
        if (idCmd == 0)
        {
            hr = S_OK;        // Canceled by the user, return S_OK
        }
        else if (InRange(idCmd, DDIDM_EXTFIRST, DDIDM_EXTLAST))
        {
            // Yes. Let the context menu handler process it.
            CMINVOKECOMMANDINFOEX ici = {
                SIZEOF(CMINVOKECOMMANDINFOEX),
                0L,
                m_hwnd,
                (LPSTR)MAKEINTRESOURCE(idCmd - DDIDM_EXTFIRST),
                NULL, NULL,
                SW_NORMAL,
            };

            // record if shift or control was being held down
            SetICIKeyModifiers(&ici.fMask);

            // We may not want to ignore the error code. (Can happen when you use the context menu
            // to create new folders, but I don't know if that can happen here.).
            HDXA_LetHandlerProcessCommandEx(hdxa, &ici, NULL);
            hr = S_OK;
        }
        else
        {
            for (nItem = 0; nItem < ARRAYSIZE(c_IDEffects); ++nItem)
            {
                if (idCmd == c_IDEffects[nItem].uID)
                {
                    dwEffectOut = c_IDEffects[nItem].dwEffect;
                    break;
                }
            }

            // if hmenuReplace had menu commands other than DDIDM_COPY,
            // DDIDM_MOVE, DDIDM_LINK, and that item was selected,
            // this assert will catch it.  (dwEffectOut is 0 in this case)
            ASSERT(nItem < ARRAYSIZE(c_IDEffects));

            hr = S_FALSE;
        }

        if (hdca)
            DCA_Destroy(hdca);

        if (hdxa)
            HDXA_Destroy(hdxa);

        DestroyMenu(hmenu);
        pddm->idCmd = idCmd;
    }

    *(pddm->pdwEffect) = dwEffectOut;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\idltree.cpp ===
#include "shellprv.h"
#include "idltree.h"

BOOL CIDLData::Init(IDLDATAF flags, INT_PTR data) 
{ 
    _flags = flags;
    _data = data;

    return TRUE;
}

HRESULT CIDLData::GetData(IDLDATAF flags, INT_PTR *pdata)
{
    if (flags & _flags)
    {
        //  we have a match
        *pdata = _data;
        return S_OK;
    }
    return E_FAIL;
}

BOOL CIDLNode::Init(LPCITEMIDLIST pidl, CIDLNode *pinParent) 
{ 
    _pidl = ILCloneFirst(pidl);
    _pinParent = pinParent;
    return _pidl != NULL;
}

CIDLNode::~CIDLNode()
{
    ILFree(_pidl);
        
    if (_psf)
        _psf->Release();
}

BOOL CIDLNode::_InitSF()
{
    //  TODO MAYBE LATER - add per thread cacheing instead.
    //  this way we can insure nonviolation of apartments
    if (!_psf)
    {
        if (_pinParent)
            _pinParent->_BindToFolder(_pidl, &_psf);
        else
            SHGetDesktopFolder(&_psf);

        _cUsage++;
    }

    return (_psf != NULL);
}

HRESULT CIDLNode::_BindToFolder(LPCITEMIDLIST pidl, IShellFolder **ppsf)
{
    if (_InitSF())
    {
        _cUsage++;
        return _psf->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder, ppsf));
    }
    return E_UNEXPECTED;
}

BOOL CIDLNode::_IsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet = ShortFromResult(IShellFolder_CompareIDs(_psf, SHCIDS_CANONICALONLY, pidl1, pidl2));
    return (iRet == 0);
}

CLinkedNode<CIDLNode> *CIDLNode::_GetKid(LPCITEMIDLIST pidl)
{
    CLinkedWalk<CIDLNode> lw(&_listKids);
    //  WARNING - need to avoid a real allocation - ZekeL - 27-SEP-2000
    //  when we are just doing a seek
    //  it creates weird state problems
    LPITEMIDLIST pidlStack = (LPITEMIDLIST)alloca(pidl->mkid.cb + sizeof(pidl->mkid.cb));
    memcpy(pidlStack, pidl, pidl->mkid.cb);
    (_ILNext(pidlStack))->mkid.cb = 0;

    while (lw.Step())
    {
        if (_IsEqual(lw.That()->_pidl, pidlStack))
        {
            return lw.Node();
        }
    }
    return NULL;
}

#define IsValidIDLNODE(pin) IS_VALID_WRITE_BUFFER(pin, BYTE, SIZEOF(CIDLNode))

#define _IsEmptyNode(pin)       (!(pin)->_pinKids && !(pin)->_pidDatas)

void CIDLNode::_FreshenKids(void)
{
    CLinkedWalk<CIDLNode> lw(&_listKids);
    LONG cMostUsage = 0;

    while (lw.Step())
    {
        CIDLNode *pin = lw.That();
        LONG cUsage = pin->_cUsage;
        pin->_cUsage = 0;

        ASSERT(IsValidIDLNODE(pin));
        pin->_FreshenKids();
        ASSERT(IsValidIDLNODE(pin));

        if (!cUsage && pin->_IsEmpty())
        {
            lw.Delete();
        }
        if (cUsage > cMostUsage && !lw.IsFirst())
        {
            // simple sorting algorithm
            // we just want most used at the top
            //  move it from its current spot
            //  to the beginning of the list
            CLinkedNode<CIDLNode> *p = lw.Remove();
            _listKids.Insert(p);
        }

        cMostUsage = max(cUsage, cMostUsage);
    }
}

HRESULT CIDLNode::GetNode(BOOL fCreate, LPCITEMIDLIST pidlChild, CIDLNode **ppin, IDLDATAF *pflagsFound)
{
    HRESULT hr = E_FAIL;
    if (ILIsEmpty(pidlChild))
    {
        //  this is just a request for self
        *ppin = this;
        if (pflagsFound)
            *pflagsFound = IDLDATAF_MATCH_RECURSIVE;
        hr = S_OK;
    }
    else
    {
        //  search through kids looking for this child
        *ppin = NULL;
        CLinkedNode<CIDLNode> *pKid = _GetKid(pidlChild);

        if (!pKid && fCreate)
        {
            //  we need to allocations during fCreate
            //  so that memory failures dont affect Remove
            if (_InitSF())
            {
                //  we dont have it, and they want it anyway
                pKid = new CLinkedNode<CIDLNode>;

                //  we give our pidl ref away to avoid allocations
                if (pKid)
                {
                    if (pKid->that.Init(pidlChild, this))
                        _listKids.Insert(pKid);
                    else
                    {
                        delete pKid;
                        pKid = NULL;
                    }
                }
            }
        }

        //  let the child take care of setting
        if (pKid)
        {
            pKid->that._cUsage++;
            pidlChild = _ILNext(pidlChild);
            hr = pKid->that.GetNode(fCreate, pidlChild, ppin, pflagsFound);
        }

        if (FAILED(hr) && !fCreate && pflagsFound)
        {
            //  just return this as second best
            *ppin = this;
            ASSERT(!ILIsEmpty(pidlChild));

            if (ILIsEmpty(_ILNext(pidlChild)))
                *pflagsFound = IDLDATAF_MATCH_RECURSIVE & ~IDLDATAF_MATCH_EXACT;
            else
                *pflagsFound = IDLDATAF_MATCH_RECURSIVE & ~IDLDATAF_MATCH_IMMEDIATE;
            
            hr = S_FALSE;
        }
    }
    
    return hr;
}

HRESULT CIDLNode::IDList(LPITEMIDLIST *ppidl)
{
    CIDLNode *pin = this;
    *ppidl = NULL;
    while (pin && pin->_pidl)
    {
        *ppidl = ILAppendID(*ppidl, &pin->_pidl->mkid, FALSE);
        pin = pin->_pinParent;
    }

    return *ppidl ? S_OK : E_FAIL;
}

HRESULT CIDLNode::_AddData(IDLDATAF flags, INT_PTR data)
{
    //  assuming unique/no collisions of Datas
    CLinkedNode<CIDLData> *p = new CLinkedNode<CIDLData>;

    if (p)
    {
        p->that.Init(flags, data);
        _listDatas.Insert(p);
    }

    return p ? S_OK : E_FAIL;
}
    
HRESULT CIDLNode::_RemoveData(INT_PTR data)
{
    HRESULT hr = E_FAIL;
    CLinkedWalk<CIDLData> lw(&_listDatas);

    while (lw.Step())
    {
        if (lw.That()->_data == data)
        {
            lw.Delete();
            hr = S_OK;
            break;
        }
    }

    return hr;
}

HRESULT CIDLTree::Create(CIDLTree **pptree)
{
    HRESULT hr = E_OUTOFMEMORY;
    *pptree = new CIDLTree();
    if (*pptree)
    {
         hr = SHILClone(&c_idlDesktop, &((*pptree)->_pidl));

         if (FAILED(hr))
         {
            delete *pptree;
            *pptree = NULL;
        }
    }
    return hr;
}

HRESULT CIDLTree::AddData(IDLDATAF flags, LPCITEMIDLIST pidlIndex, INT_PTR data)
{
    CIDLNode *pin;
    if (SUCCEEDED(GetNode(TRUE, pidlIndex, &pin)))
    {
        return pin->_AddData(flags, data);
    }
    return E_UNEXPECTED;
}

HRESULT CIDLTree::RemoveData(LPCITEMIDLIST pidlIndex, INT_PTR data)
{
    CIDLNode *pin;
    if (SUCCEEDED(GetNode(FALSE, pidlIndex, &pin)))
    {
        return pin->_RemoveData(data);
    }
    return E_UNEXPECTED;
}

CIDLNode *CIDLTree::_MatchNode(LPCITEMIDLIST pidlMatch, IDLMATCHF *pflags)
{
    CIDLNode *pin;
    IDLMATCHF flagsFound;
    HRESULT hr = GetNode(FALSE, pidlMatch, &pin, &flagsFound);

    if (SUCCEEDED(hr) && (flagsFound & (*pflags)))
    {
        *pflags &= flagsFound;
    }
    else
        pin = NULL;

    return pin;
}

HRESULT CIDLTree::MatchOne(IDLMATCHF flags, LPCITEMIDLIST pidlMatch, INT_PTR *pdata, LPITEMIDLIST *ppidl)
{
    CIDLNode *pin = _MatchNode(pidlMatch, &flags);

    if (pin)
    {
        CIDLMatchMany mm(flags, pin);

        return mm.Next(pdata, ppidl);
    }
    return E_FAIL;
}
                
HRESULT CIDLTree::MatchMany(IDLMATCHF flags, LPCITEMIDLIST pidlMatch, CIDLMatchMany **ppmatch)
{
    CIDLNode *pin = _MatchNode(pidlMatch, &flags);
    if (pin)
    {
        *ppmatch = new CIDLMatchMany(flags, pin);

        return *ppmatch ? S_OK : E_FAIL;
    }

    *ppmatch = NULL;
    return E_FAIL;
}

HRESULT CIDLTree::Freshen(void)
{
    _FreshenKids();
    return S_OK;
}

HRESULT CIDLMatchMany::Next(INT_PTR *pdata, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_FAIL;
    while (_pin && (_flags & IDLDATAF_MATCH_RECURSIVE))
    {
        if (_lw.Step())
        {
            hr = _lw.That()->GetData(_flags, pdata);
            if (SUCCEEDED(hr) && ppidl)
            {
                hr = _pin->IDList(ppidl);
            }
            if (SUCCEEDED(hr))
                break;
        }
        else
        {
            _pin = _pin->_pinParent;
            if (_pin)
            {
                _lw.Init(&_pin->_listDatas);
                // adjust the flags as you go up the parent chain.
                if (_flags & IDLDATAF_MATCH_EXACT)
                    _flags &= ~IDLDATAF_MATCH_EXACT;
                else if (_flags & IDLDATAF_MATCH_IMMEDIATE)
                    _flags &= ~IDLDATAF_MATCH_IMMEDIATE;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ids.h ===
#ifndef _IDS_H_
#define _IDS_H_
// IDs for common UI resources (note that these MUST BE decimal numbers)
// More IDs are in unicpp\resource.h

// Folder Display Name IDs
#include <winfoldr.h>

// menuband ids
#include "menuband\mnbandid.h"

// Cursor resources
#define IDC_HELPCOLD    1001
#define IDC_HELPHOT     1002
#define IDC_SCOPY       1003
#define IDC_MCOPY       1004
#define IDC_NULL        1005

// IDs of Overlay Images
// These are here for compatibility reasons only, so don't change and add
// new values!!! (dli)
#define IDOI_SHARE      1
#define IDOI_LINK       2

#define ACCEL_DEFVIEW   1
#define ACCEL_PRN_QUEUE 2

// matches stuff in winuser.h
#define IDIGNOREALL             10


// This feature is turned off for now.  We do not want to automatically submit the
// file extension of the user's file to the server without first asking for permission
// for personal privacy reasons.  We can either remove this feature entirely or
// add the user prompt.  I'm removing it for now for Whistler Beta 2. -BryanSt
//#define FEATURE_DOWNLOAD_DESCRIPTION

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// NOTE: If you are adding new icons, give them #defines at the END, do not use "unused"
// slots in the middle or you will mess up all of the shell32.dll icon indexes that
// are hardcoded and persisted in vaious places.
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Icon id's
#define IDI_DOCUMENT            1      // generic document (blank page)
#define IDI_DOCASSOC            2      // generic associated document (with stuff on the page)
#define IDI_APP                 3      // application (exe)
#define IDI_FOLDER              4      // folder
#define IDI_FOLDEROPEN          5      // open folder
#define IDI_DRIVE525            6      // 5.25 floppy
#define IDI_DRIVE35             7      // 3.5  floppy
#define IDI_DRIVEREMOVE         8      // Removeable drive
#define IDI_DRIVEFIXED          9      // fix disk, regular hard drive
#define IDI_DRIVENET            10     // Remote drive
#define IDI_DRIVENETDISABLED    11     // Remote drive icon (disconnected)
#define IDI_DRIVECD             12     // CD-ROM drive
#define IDI_DRIVERAM            13     // RAM drive
#define IDI_WORLD               14     // World
#define IDI_NETWORK             15     // Network
#define IDI_SERVER              16     // Server
#define IDI_PRINTER             17     // Printer
#define IDI_MYNETWORK           18     // The My Network icon
#define IDI_GROUP               19     // Group
#define IDI_STPROGS             20     // Startmenu images.
#define IDI_STDOCS              21
#define IDI_STSETNGS            22
#define IDI_STFIND              23
#define IDI_STHELP              24
#define IDI_STRUN               25
#define IDI_STSUSPEND           26
#define IDI_STEJECT             27
#define IDI_STSHUTD             28     // Overlays.
#define IDI_SHARE               29     // shared thing (overlap)
#define IDI_LINK                30     // link icon (overlap)
#define IDI_SLOWFILE            31     // slow file icon (overlap)
#define IDI_RECYCLER            32
#define IDI_RECYCLERFULL        33
#define IDI_RNA                 34     // Remote Network Services
#define IDI_DESKTOP             35     // Desktop icon
#define IDI_STCPANEL            36     // More Startmenu images.
#define IDI_STSPROGS            37
#define IDI_STPRNTRS            38
#define IDI_STFONTS             39
#define IDI_STTASKBR            40      // WARNING! Explorer.exe hard-codes this value
#define IDI_CDAUDIO             41      // CD Audio Disc
#define IDI_TREE                42      // Network Directory Tree
#define IDI_STCPROGS            43
#define IDI_STFAV               44      // Start menu's favorite icon
#define IDI_STLOGOFF            45
#define IDI_STFLDRPROP          46
#define IDI_WINUPDATE           47
#define IDI_MU_SECURITY         48
#define IDI_MU_DISCONN          49
#define IDI_TB_DOCFIND_CLR      50
#define IDI_TB_DOCFIND_GRAY     51
#define IDI_TB_COMPFIND_CLR     52
#define IDI_TB_COMPFIND_GRAY    53
#define IDI_DRIVEUNKNOWN        54
#define IDI_MULDOC              133     // multiple documents
#define IDI_DOCFIND             134     // Used for document find window...
#define IDI_COMPFIND            135     // Used For find Computer window...
#define IDI_CPLFLD              137      // Control panel folder icon
#define IDI_PRNFLD              138      // Printers folder icon
#define IDI_NEWPRN              139      // New printer icon
#define IDI_PRINTER_NET         140      // Network printer icon
#define IDI_PRINTER_FILE        141      // File printer icon
#define IDI_DELETE_FILE         142      // delete file confirm icon
#define IDI_DELETE_FOLDER       143      // delete folder confirm icon
#define IDI_DELETE_MULTIPLE     144      // delete files and folders
#define IDI_REPLACE_FILE        145      // replace file icon
#define IDI_REPLACE_FOLDER      146      // replace folder
#define IDI_RENAME              147      // rename file/folder
#define IDI_MOVE                148      // move file/folder
#define IDI_INIFILE             151      // .ini file
#define IDI_TXTFILE             152      // .txt file
#define IDI_BATFILE             153      // .bat file
#define IDI_SYSFILE             154      // system file (.54, .vxd, ...)
#define IDI_FONFILE             155      // .fon
#define IDI_TTFFILE             156      // .ttf
#define IDI_PFMFILE             157      // .pfm (Type 1 font)
#define IDI_RUNDLG              160      // Icon in the Run dialog
#define IDI_NUKEFILE            161
#define IDI_BACKUP              165
#define IDI_CHKDSK              166
#define IDI_DEFRAG              167
#define IDI_DEF_PRINTER         168
#define IDI_DEF_PRINTER_NET     169
#define IDI_DEF_PRINTER_FILE    170
#define IDI_NDSCONTAINER        171      // Novell NDS Container
#define IDI_SERVERSHARE         172      // \\server\share icon
#define IDI_FAVORITES           173
#define IDI_ATTRIBS             174      // "Advanced" file/folder attribs icon
#define IDI_NETCONNECT          175
#define IDI_ADDNETPLACE         176      // Network Places Wizard
#define IDI_FOLDERVIEW          177
#define IDI_HTTFILE             178
#define IDI_CSC                 179     // ClientSideCaching
#define IDI_ACTIVEDESK_ON       180     // Warning: Do not change the order and sequence of the following IDI_* values.
#define IDI_ACTIVEDESK_OFF      181     // The code assumes and asserts if the order changes.
#define IDI_WEBVIEW_ON          182     
#define IDI_WEBVIEW_OFF         183     
#define IDI_SAME_WINDOW         184
#define IDI_SEPARATE_WINDOW     185
#define IDI_SINGLE_CLICK        186
#define IDI_DOUBLE_CLICK        187     // End of warning: Do not change the order of the above IDI_ values.
#define IDI_OLD_RECYCLER        191
#define IDI_OLD_RECYCLER_FULL   192
#define IDI_OLD_MYNETWORK       193
#define IDI_PASSWORD            194
#define IDI_PSEARCH             195     // Printers search icon
#define IDI_FAX_PRINTER         196     // new icons for the fax printer
#define IDI_FAX_PRINTER_DEF     197
#define IDI_FAX_PRINTER_DEF_NET 198
#define IDI_FAX_PRINTER_NET     199
#define IDI_STFRIENDLYLOGOFF    220
#define IDI_STFRIENDLYPOWEROFF  221
#define IDI_AP_VIDEO            222
#define IDI_AP_ITEM             223
#define IDI_AP_FILMSTRP         224
#define IDI_AP_DMIDI            225
#define IDI_AP_PICS             226
#define IDI_AP_MULTI            227
#define IDI_AP_CDAUDIO          228
#define IDI_AP_SANDISK          229
#define IDI_AP_ZIPDRIVE         230
#define IDI_CDSTAGED            231      // cd burn
#define IDI_CDWILLOVERWRITE     232
#define IDI_AP_MEMSTICKW        233
#define IDI_AP_ZIPNOMEDIA       234
#define IDI_MYDOCS              235
#define IDI_MYPICS              236
#define IDI_MYMUSIC             237
#define IDI_MYVIDEOS            238
#define IDI_MSN                 239
#define IDI_TASK_DELETE             240
#define IDI_TASK_MOVE               241
#define IDI_TASK_RENAME             242
#define IDI_TASK_COPY               243
#define IDI_TASK_PUBLISH            244
#define IDI_TASK_PRINT              245
#define IDI_TASK_PLAY_MUSIC         246
#define IDI_TASK_BUY_MUSIC          247
#define IDI_TASK_GETFROMCAMERA      248
#define IDI_TASK_SLIDESHOW          249
#define IDI_TASK_SETASWALLPAPER     250
#define IDI_TASK_ORDERPRINTS        251
#define IDI_TASK_PRINTPICTURES      252
#define IDI_TASK_PROPERTIES         253
#define IDI_TASK_EMPTYRECYCLEBIN    254
#define IDI_TASK_RESTOREITEMS       255
#define IDI_TASK_UPDATEITEMS        256
#define IDI_TASK_VIEWNETCONNECTIONS 257
#define IDI_TASK_ADDNETWORKPLACE    258
#define IDI_TASK_HOMENETWORKWIZARD  259
#define IDI_TASK_BURNCD             260
#define IDI_TASK_CLEARBURNAREA      261
#define IDI_TASK_ERASECDFILES       262
#define IDI_TASK_CDBURN_HELP        263
#define IDI_TASK_OPENCONTAININGFOLDER 264
#define IDI_TASK_EMAILFILE          265
#define IDI_TASK_SENDTOAUDIOCD      266
#define IDI_TASK_SHARE              267
#define IDI_TASK_HELP               IDI_STHELP
//
// Control Panel view icons
//
#define IDI_CPCAT_ACCESSIBILITY     268  // Category icons
#define IDI_CPCAT_ACCOUNTS          269  //      .
#define IDI_CPCAT_APPEARANCE        270  //      .
#define IDI_CPCAT_ARP               271  //      .
#define IDI_CPCAT_HARDWARE          272  //      .
#define IDI_CPCAT_NETWORK           273  //      .
#define IDI_CPCAT_OTHERCPLS         274  //      .
#define IDI_CPCAT_PERFMAINT         275  //      .
#define IDI_CPCAT_REGIONAL          276  //      .
#define IDI_CPCAT_SOUNDS            277  // Category icons
#define IDI_CPTASK_ACCESSUTILITYMGR 278
#define IDI_CPTASK_ACCOUNTSPICT     279
#define IDI_CPTASK_DISPLAYCPL       280
#define IDI_CPTASK_MAGNIFIER        281
#define IDI_CPTASK_NARRATOR         282
#define IDI_CPTASK_ONSCREENKBD      283
#define IDI_CPTASK_HIGHCONTRAST     284
// unused                           285
// unused                           286
// unused                           287
// unused                           288
#define IDI_CPTASK_ASSISTANCE       289
#define IDI_CP_CATEGORYTASK         290  // Category task.

#define IDI_DVDDRIVE                291
#define IDI_MEDIACDAUDIOPLUS        292
#define IDI_MEDIACDEMPTY            293
#define IDI_MEDIACDROM              294
#define IDI_MEDIACDR                295
#define IDI_MEDIACDRW               296
#define IDI_MEDIADVDRAM             297
#define IDI_MEDIADVDR               298
#define IDI_AUDIOPLAYER             299
#define IDI_DEVICETAPEDRIVE         300
#define IDI_DEVICEOPTICALDRIVE      301
#define IDI_MEDIABLANKCD            302
#define IDI_MEDIACOMPFLASH          303
#define IDI_MEDIADVDROM             304
#define IDI_MEDIAMEMSTICK           305
#define IDI_MEDIAPCMCIA             306
#define IDI_MEDIASECUREDIGITALMEDIA 307
#define IDI_MEDIASMARTMEDIA         308
#define IDI_DEVICECAMERA            309
#define IDI_DEVICECELLPHONE         310
#define IDI_DEVICEHTTPPRINT         311
#define IDI_DEVICEJAZDRIVE          312
#define IDI_DEVICEZIPDRIVE          313
#define IDI_DEVICEPOCKETPC          314
#define IDI_DEVICESCANNER           315
#define IDI_DEVICESTI               316
#define IDI_DEVICEVIDEOCAM          317
#define IDI_MEDIADVDRW              318
#define IDI_TASK_NEWFOLDER          319
#define IDI_TASK_SENDTOCD           320
#define IDI_CPTASK_32CPLS           321
#define IDI_CLASSICSM_FAVORITES     322
#define IDI_CLASSICSM_FIND          323
#define IDI_CLASSICSM_HELP          324
#define IDI_CLASSICSM_LOGOFF        325
#define IDI_CLASSICSM_PROGS         326
#define IDI_CLASSICSM_RECENTDOCS    327
#define IDI_CLASSICSM_RUN           328
#define IDI_CLASSICSM_SHUTDOWN      329
#define IDI_CLASSICSM_SETTINGS      330
#define IDI_CLASSICSM_UNDOCK        331
#define IDI_TASK_SEARCHDS           337
#define IDI_NONE                    338

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// ADD NEW ICONS ABOVE THIS LINE 
// (see comment at the top of of the list of IDI_xxx defines)
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// unicpp\resource.h defines more icons starting at 200

// Add new icons here, and update ..\inc\shellp.h with the image index


// Bitmap id's

#define IDB_ABOUT16             130
#define IDB_ABOUT256            131

#define IDB_SORT_UP             133
#define IDB_SORT_DN             134

#define IDB_FSEARCHTB_HOT       135
#define IDB_FSEARCHTB_DEFAULT   136

#define IDB_ABOUTBAND16         137
#define IDB_ABOUTBAND256        138

#define IDB_BRF_TB_SMALL        140
#define IDB_BRF_TB_LARGE        141
#define IDB_LINK_MERGE          142
#define IDB_PLUS_MERGE          143
#define IDB_TTBITMAP            145

#define IDB_ABOUTPERSONAL16     146
#define IDB_ABOUTPERSONAL256    147

#ifndef _WIN64
#define IDB_ABOUTEMBEDDED16     148
#define IDB_ABOUTEMBEDDED256    149
#endif // !_WIN64

// The toolbar ids are shared with browseui and shdocvw.  The defines
// can be found in shell\inc\tb_ids.h.  200 - 250 is reserved for toolbar
// bitmap strips.

#include <tb_ids.h>

#define IDB_BURNWIZ_WATERMARK   369

#define IDB_BURNWIZ_HEADER      390

// unicpp\resource.h defines more values starting at 256

#define IDA_SEARCH              150     // animation
#define IDA_FINDFILE            151     // animation
#define IDA_FINDCOMP            152     // animation for finding computers..

#define IDA_FILEMOVE            160     // animation file mode
#define IDA_FILECOPY            161     // animation file copy
#define IDA_FILEDEL             162     // animation move to waste basket
#define IDA_FILENUKE            163     // animation empty waste basket.
#define IDA_FILEDELREAL         164     // animation true delete bypass recycle bin
#define IDA_APPLYATTRIBS        165     // animation for applying file attributes
#define IDA_ISEARCH             166     // animation for finding URLs on the internet
#define IDA_CDBURN_TOSTAGING    167     // animation for adding files to the cdburn staging area
#define IDA_CDBURN_TOCD         168     // animation for burning files from the staging area to the cd
#define IDA_CDBURN_ERASE        169     // animation for erasing files from a CD-RW
#define IDA_DOWNLOAD            170     // animation: downloading files from the Internet (for web wizard host)

// RCDATA IDs

#define RCDATA_FONTSHORTCUT      0x4000
#define RCDATA_ADMINTOOLSHORTCUT 0x4001
// Dialog box IDs (note that these MUST BE decimal numbers)

#define DLG_BROWSE              1001
#define DLG_RESTART             1002
#define DLG_RUN                 1003
#define DLG_LINK_SEARCH         1004

#define DLG_RUNUSERLOGON        1007
#define DLG_DEADSHORTCUT_MATCH  1008
#define DLG_DEADSHORTCUT        1009

#define DLG_LFNTOFAT            1010
#define DLG_DELETE_FILE         1011
#define DLG_DELETE_FOLDER       1012
#define DLG_DELETE_MULTIPLE     1013
#define DLG_REPLACE_FILE        1014
#define DLG_REPLACE_FOLDER      1015
#define DLG_MOVE_FILE           1016
#define DLG_MOVE_FOLDER         1017
#define DLG_RENAME_FILE         1018
#define DLG_RENAME_FOLDER       1019
#define DLG_MOVECOPYPROGRESS    1020
#define DLG_WONT_RECYCLE_FOLDER 1021
#define DLG_WONT_RECYCLE_FILE   1022
#define DLG_STREAMLOSS_ON_COPY  1023
#define DLG_RETRYFOLDERENUM     1024
#define DLG_DELETE_FILE_ARP     1025
#define DLG_PATH_TOO_LONG       1026
#define DLG_FAILED_ENCRYPT      1027
#define DLG_WONT_RECYCLE_OFFLINE 1028
#define DLG_DELETE_STAGING      1029
#define DLG_LOST_ENCRYPT_FILE   1030
#define DLG_LOST_ENCRYPT_FOLDER 1031

#define DLG_LINKPROP            1040
#define DLG_FILEPROP            1041
#define DLG_FILEMULTPROP        1042
#define DLG_VERSION             1043
#define DLG_FOLDERPROP          1044
#define DLG_BITBUCKET_GENCONFIG 1045
#define DLG_BITBUCKET_CONFIG    1046
#define DLG_DELETEDFILEPROP     1047
#define DLG_FOLDERSHORTCUTPROP  1048
#define DLG_LINKPROP_ADVANCED   1049

#define DLG_BROWSEFORDIR        1050
#define DLG_FINDEXE             1051
// these are still in shell.dll
// #define DLG_ABOUT            1052

#define DLG_RUNSETUPLOGON       1053
#define DLG_FILEATTRIBS         1054
#define DLG_FOLDERATTRIBS       1055
#define DLG_ATTRIBS_RECURSIVE   1056
#define DLG_APPLYATTRIBSPROGRESS 1057
#define DLG_ATTRIBS_ERROR       1058

#define DLG_PICKICON            1060
#define DLG_ASSOCIATE           1061
#define DLG_FIND                1062
#define DLG_OPENAS              1063
#define DLG_TSINSTALLFAILURE    1064
#define DLG_FIND_BROWSE         1065
#define DLG_DFNAMELOC           1066
#define DLG_DFDETAILS           1067
#define DLG_DFDATE              1068
#define DLG_NFNAMELOC           1069
#define DLG_OPENAS_NOTYPE       1070
#define DLG_LOGOFFWINDOWS       1071

#define DLG_BROWSEFORFOLDER     1079  // Browse for folders for doc and net finds

#define DLG_DRV_GENERAL         1080
#define DLG_DISKTOOLS           1081

#define DLG_APPCOMPAT           1082

#ifdef MEMMON
#define DLG_MEMMON              1083
#endif

#define DLG_CPL_FILLCACHE       1084

#define DLG_APPCOMPATWARN       1085
#define DLG_DISKCOPYPROGRESS    1086

#define DLG_BROWSEFORFOLDER2    1087  // New UI

#define DLG_DRV_HWTAB           1088

#define DLG_SWITCHUSER          1089
#define DLG_DISCONNECTWINDOWS   1090
#define DLG_OPENAS_DOWNALOAD    1091

#define DLG_DISKERR             1095
#define DLG_COLUMN_SETTINGS     1096
#define DLG_MOUNTEDDRV_GENERAL  1098

#define DLG_FILETYPEOPTIONS     1099
#define DLG_FILETYPEOPTIONSEDIT 1100
#define DLG_FILETYPEOPTIONSCMD  1101

#define DLG_NOOPEN              1103

#define DLG_ENCRYPTWARNING      1104

#define DLG_FSEARCH_MAIN        1105
#define DLG_FSEARCH_DATE        1106
#define DLG_FSEARCH_TYPE        1107
#define DLG_FSEARCH_SIZE        1108
#define DLG_FSEARCH_ADVANCED    1109

#define DLG_INDEXSERVER         1110

#define DLG_FILETYPEOPTIONSEDITNEW          1111

#define DLG_PSEARCH             1112
#define DLG_CSEARCH             1113
#define DLG_FSEARCH_OPTIONS     1114

#define DLG_RENAME_MESSAGEBOXCHECK  1115
#define IDC_MBC_TEXT                0x2000
#define IDC_MBC_ICON                0x2001

#define DLG_FSEARCH_SCOPEMISMATCH    1116
#define DLG_FSEARCH_INDEXNOTCOMPLETE 1117

#define DLG_DRV_RECORDINGTAB         1118

#define DLG_AUTOPLAY                 1119
#define DLG_APMIXEDCONTENT           1120
#define DLG_APPROMPTUSER             1121
#define DLG_APNOCONTENT              1122

#define DLG_FOLDER_CUSTOMIZE         1124

#define DLG_WEBWIZARD                1125

#define DLG_BURNWIZ_WELCOME          1126
#define DLG_BURNWIZ_BURN_SUCCESS     1127
#define DLG_BURNWIZ_MUSIC            1128
#define DLG_BURNWIZ_EJECT            1129
#define DLG_BURNWIZ_PROGRESS         1130
#define DLG_BURNWIZ_BURN_FAILURE     1131
#define DLG_BURNWIZ_WAITFORMEDIA     1132
#define DLG_BURNWIZ_STARTERASE       1133
#define DLG_BURNWIZ_ERASE_SUCCESS    1134
#define DLG_BURNWIZ_ERASE_FAILURE    1135
#define DLG_BURNWIZ_DISCFULL         1136
#define DLG_BURNWIZ_HDFULL           1137
#define DLG_BURNWIZ_NOFILES          1138

// for Dead shortcut dialogs
#define IDC_DEADTEXT1 0x100
#define IDC_DEADTEXT2 0x101
#define IDC_DELETE    0x105

// menuband\mnbandid.h defines more DLG_ values starting at 0x2000
// unicpp\resource.h defines more DLG_ values starting at 0x7500

// String IDs (these are hex so that groups of 16 are easily distinguished)

#define IDS_VERSIONMSG        60
#define IDS_DEBUG             61
#define IDS_LDK               62
#define IDS_DATESIZELINE      64
#define IDS_FILEDELETEWARNING 65
#define IDS_FOLDERDELETEWARNING 66
#define IDS_FILERECYCLEWARNING 67
#define IDS_FOLDERRECYCLEWARNING 68
#define IDS_LICENCEINFOKEY      69
#define IDS_REGUSER             70
#define IDS_REGORGANIZATION     71
#define IDS_CURRENTVERSION      72
#define IDS_PRODUCTID           73
#define IDS_OEMID               74
#define IDS_PROCESSORINFOKEY    75
#define IDS_PROCESSORIDENTIFIER 76

// all commands that can have help in the status bar or tool tips
// need to be put before IDS_LAST_COMMAND
#define IDS_LAST_COMMAND        0x2FFF

#define IDS_FIRST               0x1000

#define IDS_REPLACING           0x1000
#define IDS_UNFORMATTED         0x1001
#define IDS_LOCATION            0x1002
#define IDS_DESTFULL            0x1003
#define IDS_WRITEPROTECTFILE    0x1004
#define IDS_NETERR              0x1005
#define IDS_DRIVENOTREADY       0x1006
#define IDS_CREATELONGDIR       0x1007
#define IDS_CREATELONGDIRTITLE  0x1008
#define IDS_FMTERROR            0x1009
#define IDS_NOFMT               0x100a
#define IDS_CANTSHUTDOWN        0x100b
#define IDS_INVALIDFN           0x100d
#define IDS_INVALIDFNFAT        0x100e
#define IDS_ENUMABORTED         0x100f
#define IDS_WARNCHANGEEXT       0x1010

#define IDS_BYTES               0x1011
#define IDS_FORMAT_TITLE        0x1012
#define IDS_MVUNFORMATTED       0x1013
#define IDS_UNFORMATTABLE_DISK  0x1014
#define IDS_UNRECOGNIZED_DISK   0x1015
#define IDS_SIZEANDBYTES        0x1016
#define IDS_SIZE                0x1017

#define IDS_NOWINDISK           0x1018
#define IDS_VERBHELP            0x1019

#define IDS_DRIVELETTER         0x101A
#define IDS_NONULLNAME          0x101B

#define IDS_FINDNOTFINDABLE     0x101C
#define IDS_FINDMAXFILESFOUND   0x101D
#define IDS_FINDMONITORNEWITEMS 0x101E
#define IDS_FINDNOTHINGFOUND    0x101F
#define IDS_PATHNOTTHERE        0x1020
#define IDS_FINDVIEWEMPTY       0x1021
#define IDS_FILETYPENAME        0x1022
#define IDS_FOLDERTYPENAME      0x1023
#define IDS_FILEWONTFIT         0x1024
#define IDS_FILE                0x1025
#define IDS_FINDFILES           0x1026
#define IDS_FINDWRONGPATH       0x1027
#define IDS_FINDDATAREQUIRED    0x1028
#define IDS_FINDINVALIDNUMBER   0x1029
#define IDS_FINDINVALIDDATE     0x102a
#define IDS_FINDGT              0x102b
#define IDS_FINDLT              0x102c
#define IDS_FINDRESET           0x102d
#define IDS_FINDALLFILETYPES    0x102e
#define IDS_FINDOUTOFMEM        0x102f

#define IDS_UNDO_FILEOP         0x102f
#define IDS_MOVE                (IDS_UNDO_FILEOP + FO_MOVE)
#define IDS_COPY                (IDS_UNDO_FILEOP + FO_COPY)
#define IDS_DELETE              (IDS_UNDO_FILEOP + FO_DELETE)
#define IDS_RENAME              (IDS_UNDO_FILEOP + FO_RENAME)

#define IDS_RUN_NORMAL          0x1034
#define IDS_RUN_MINIMIZED       0x1035
#define IDS_RUN_MAXIMIZED       0x1036

#define IDS_LINKTITLE           0x1037
#define IDS_LINKTO              0x1038
#define IDS_MULTIINVOKEPROMPT_TITLE     0x1039
#define IDS_MULTIINVOKEPROMPT_MESSAGE   0x103a
#define IDS_NONE                0x103b
#define IDS_NEW                 0x103c
#define IDS_CLOSE               0x103d
#define IDS_LINKEXTENSION       0x103e
#define IDS_ANOTHER             0x103f
#define IDS_YETANOTHER          0x1040

// This definition is hard coded in \nt\private\windows\shell\cpls\powercfg,
// if you change it here, change it there.
#define IDS_CONTROLPANEL        0x1041
#define IDS_DESKTOP             0x1042
#define IDS_UNDO                0x1043
#define IDS_UNDOACCEL           0x1044
#define IDS_UNDOMENU            0x1045
#define IDS_DOCUMENTFOLDERS     0x1046

#define IDS_SELECTALLBUTHIDDEN  0x104a
#define IDS_SELECTALL           0x104b
#define IDS_ACTIVEDESKTOP       0x104d
#define IDS_COMPSETTINGS        0x104e
#define IDS_BACKSETTINGS        0x104f
#define IDS_APPEARANCESETTINGS  0x1050
// unused
#define IDS_COPYLONGPLATE       0x1052
#define IDS_BRIEFTEMPLATE       0x1053
#define IDS_BRIEFEXT            0x1054
#define IDS_BRIEFLONGPLATE      0x1055
#define IDS_BOOKMARK_S          0x1056
#define IDS_BOOKMARK_L          0x1057
#define IDS_FINDINVALIDFILENAME 0x1058
#define IDS_SCRAP_S             0x105a
#define IDS_SCRAP_L             0x105b
//reuse aaah theres no space around here    0x105c
#define IDS_TURNOFFSTARTPAGE    0x105d
#define IDS_TURNONSTARTPAGE     0x105e

#define IDS_UNDO_FILEOPHELP     0x105f
#define IDS_MOVEHELP            (IDS_UNDO_FILEOPHELP + FO_MOVE)
#define IDS_COPYHELP            (IDS_UNDO_FILEOPHELP + FO_COPY)
#define IDS_DELETEHELP          (IDS_UNDO_FILEOPHELP + FO_DELETE)
#define IDS_RENAMEHELP          (IDS_UNDO_FILEOPHELP + FO_RENAME)

#define IDS_HTML_FILE_RENAME    0x1068
#define IDS_HTML_FOLDER_RENAME  0x1069

#define IDS_THUMBNAILVIEW       0x106d
#define IDS_THUMBHELPTEXT       0x106e
//#define IDS_CANNOTENABLETHUMBS  0x106f

#define IDS_LINKERROR           0x1070
#define IDS_LINKBADWORKDIR      0x1071
#define IDS_LINKBADPATH         0x1072
#define IDS_LINKNOTFOUND        0x1073
#define IDS_LINKCHANGED         0x1074
#define IDS_SPACEANDSPACE       0x1075
#define IDS_COMMASPACE          0x1076
#define IDS_LINKUNAVAILABLE     0x1077
#define IDS_LINKNOTLINK         0x1078
#define IDS_LINKCANTSAVE        0x1079
#define IDS_LINKTOLINK          0x107A

//#define IDS_CANNOTDISABLETHUMBS 0x107B

#define IDS_VOLUMELABEL                 0x107C
#define IDS_MOUNTEDVOLUME               0x107D
#define IDS_UNLABELEDVOLUME             0x107E
#define IDS_WALK_PROGRESS_TITLE         0x107F

#define IDS_ENUMERR_NETTEMPLATE1        0x1080
#define IDS_ENUMERR_NETTEMPLATE2        0x1081
#define IDS_ENUMERR_FSTEMPLATE          0x1082
#define IDS_ENUMERR_NETGENERIC          0x1083
#define IDS_ENUMERR_FSGENERIC           0x1084
#define IDS_ENUMERR_PATHNOTFOUND        0x1085
#define IDS_SHLEXEC_ERROR               0x1086
#define IDS_SHLEXEC_ERROR2              0x1087
#define IDS_ENUMERR_PATHTOOLONG         0x1088

#define IDS_APP_FAULTED_IN              0x1089
#define IDS_APP_NOT_FAULTED_IN          0x108a

#define IDS_CSC_STATUS                  0x108b
#define IDS_CSC_STATUS_ONLINE           0x108c
#define IDS_CSC_STATUS_OFFLINE          0x108d

#define IDS_ERR_VOLUMELABELBAD          0x1091
#define IDS_TITLE_VOLUMELABELBAD        0x1092
#define IDS_ERR_VOLUMEUNFORMATTED       0x1093

#define IDS_CANT_FIND_MYDOCS_NET        0x1094
#define IDS_CANT_FIND_MYDOCS            0x1095

#define IDS_COL_CM_MORE                 0x1099

#define IDS_DSPTEMPLATE_WITH_BACKSLASH  0x10a0
#define IDS_DSPTEMPLATE_WITH_ON         0x10a1

#define IDS_ARRANGEBY_HELPTEXT          0x10a3
#define IDS_GROUPBY_HELPTEXT            0x10a4
#define IDS_GROUPBYITEM_HELPTEXT        0x10a5

// Network Location possible value
#define IDS_NETLOC_INTERNET             0x10a6
#define IDS_NETLOC_LOCALNETWORK         0x10a7


//
// RestartDialog Text Strings
//
#define IDS_RSDLG_TITLE             0x10b0
#define IDS_RSDLG_SHUTDOWN          0x10b1
#define IDS_RSDLG_RESTART           0x10b2
#define IDS_RSDLG_PIFFILENAME       0x10b3
#define IDS_RSDLG_PIFSHORTFILENAME  0x10b4

// CopyDisk text strings
#define IDS_INSERTDEST                  0x10C0
#define IDS_INSERTSRC                   0x10C1
#define IDS_INSERTSRCDEST               0x10C2
#define IDS_FORMATTINGDEST              0x10C3
#define IDS_COPYSRCDESTINCOMPAT         0x10C4


//
// Reserve a range for DefView MenuHelp
//
#define IDS_MH_SFVIDM_FIRST     0x1100
#define IDS_MH_SFVIDM_LAST      0x11ff

//
// Reserve a range for DefView client MenuHelp
//
#define IDS_MH_FSIDM_FIRST      0x1200
#define IDS_MH_FSIDM_LAST       0x12ff

//
// Reserve a range for DefView ToolTips
//
#define IDS_TT_SFVIDM_FIRST     0x1300
#define IDS_TT_SFVIDM_LAST      0x13ff

//
// Reserve a range for DefView client ToolTips
//
#define IDS_TT_FSIDM_FIRST      0x1400
#define IDS_TT_FSIDM_LAST       0x14ff

//
// IDS for Open With Context Menu
//
#define IDS_OPENWITH            0x1500
#define IDS_OPENWITHNEW         0x1501
#define IDS_OPENWITHBROWSE      0x1502
#define IDS_OPENWITHHELP        0x1503
#define IDS_OPENWITHAPPHELP     0x1504


//
// IDS for CStartMenuPin
//
#define IDS_STARTPIN_PINME              0x1505
#define IDS_STARTPIN_UNPINME            0x1506
#define IDS_STARTPIN_PINME_HELP         0x1507
#define IDS_STARTPIN_UNPINME_HELP       0x1508

// IDS for stream loss copy information

#define IDS_DOCSUMINFOSTREAM    0x1510
#define IDS_SUMINFOSTREAM       0x1511
#define IDS_MACINFOSTREAM       0x1512
#define IDS_MACRESSTREAM        0x1513
#define IDS_UNKNOWNPROPSET      0x1514
#define IDS_GLOBALINFOSTREAM    0x1516
#define IDS_IMAGECONTENTS       0x1517
#define IDS_IMAGEINFO           0x1518
#define IDS_USERDEFPROP         0x1519
#define IDC_STREAMSLOST         0x151a
#define IDS_AUDIOSUMINFO        0x151b
#define IDS_VIDEOSUMINFO        0x151c
#define IDS_MEDIASUMINFO        0x151d

#define IDS_FILEERROR           0x1700
#define IDS_FILEERRORCOPY       (IDS_FILEERROR + FO_COPY)
#define IDS_FILEERRORMOVE       (IDS_FILEERROR + FO_MOVE)
#define IDS_FILEERRORDEL        (IDS_FILEERROR + FO_DELETE)
#define IDS_FILEERRORREN        (IDS_FILEERROR + FO_RENAME)
// space needed

#define IDS_ACTIONTITLE         0x1740
#define IDS_ACTIONTITLECOPY     (IDS_ACTIONTITLE + FO_COPY)
#define IDS_ACTIONTITLEMOVE     (IDS_ACTIONTITLE + FO_MOVE)
#define IDS_ACTIONTITLEDEL      (IDS_ACTIONTITLE + FO_DELETE)
#define IDS_ACTIONTITLEREN      (IDS_ACTIONTITLE + FO_RENAME)

#define IDS_FROMTO              0x1750
#define IDS_FROM                0x1751
#define IDS_PREPARINGTO         0x1752
#define IDS_COPYTO              0x1753
#define IDS_COPYERROR           0x1754

#define IDS_COPYING             0x1756
#define IDS_MOVEERROR           0x1757
#define IDS_MOVING              0x1758
#define IDS_CALCMOVETIME        0x1759
#define IDS_CALCCOPYTIME        0x175A

// space needed

#define IDS_VERBS               0x1780
#define IDS_VERBSCOPY           (IDS_VERBS + FO_COPY)
#define IDS_VERBSMOVE           (IDS_VERBS + FO_MOVE)
#define IDS_VERBSDEL            (IDS_VERBS + FO_DELETE)
#define IDS_VERBSREN            (IDS_VERBS + FO_RENAME)
// space needed

#define IDS_ACTIONS             0x17c0
#define IDS_ACTIONS1            (IDS_ACTIONS + 1)
#define IDS_ACTIONS2            (IDS_ACTIONS + 2)
// space needed

#define IDS_REASONS             0x1800

#define IDS_REASONS_INVFUNCTION (IDS_REASONS + ERROR_INVALID_FUNCTION)
#define IDS_REASONS_INVHANDLE   (IDS_REASONS + ERROR_INVALID_HANDLE)
#define IDS_REASONS_INVFILEACC  (IDS_REASONS + ERROR_INVALID_ACCESS)
#define IDS_REASONS_NOTSAMEDEV  (IDS_REASONS + ERROR_NOT_SAME_DEVICE)
#define IDS_REASONS_DELCURDIR   (IDS_REASONS + ERROR_CURRENT_DIRECTORY)
#define IDS_REASONS_NOHANDLES   (IDS_REASONS + ERROR_TOO_MANY_OPEN_FILES)
#define IDS_REASONS_FILENOFOUND (IDS_REASONS + ERROR_FILE_NOT_FOUND)
#define IDS_REASONS_PATHNOFOUND (IDS_REASONS + ERROR_PATH_NOT_FOUND)
#define IDS_REASONS_ACCDENIED   (IDS_REASONS + ERROR_ACCESS_DENIED)
#define IDS_REASONS_INSMEM      (IDS_REASONS + ERROR_NOT_ENOUGH_MEMORY)
#define IDS_REASONS_NODIRENTRY  (IDS_REASONS + ERROR_NO_MORE_FILES)
#define IDS_REASONS_WRITEPROT   (IDS_REASONS + ERROR_WRITE_PROTECT)
#define IDS_REASONS_NETACCDEN   (IDS_REASONS + ERROR_NETWORK_ACCESS_DENIED)
#define IDS_REASONS_BADNETNAME  (IDS_REASONS + ERROR_BAD_NET_NAME)
#define IDS_REASONS_SHAREVIOLA  (IDS_REASONS + ERROR_SHARING_VIOLATION)
#define IDS_REASONS_WRITEFAULT  (IDS_REASONS + ERROR_WRITE_FAULT)
#define IDS_REASONS_GENFAILURE  (IDS_REASONS + ERROR_GEN_FAILURE)
#define IDS_REASONS_NODISKSPACE (IDS_REASONS + ERROR_DISK_FULL)
#define IDS_REASONS_RENREPLACE  (IDS_REASONS + ERROR_ALREADY_EXISTS)
// our internal errors
#define IDS_REASONS_PATHTODEEP       (IDS_REASONS + DE_PATHTODEEP)
#define IDS_REASONS_SAMEFILE         (IDS_REASONS + DE_SAMEFILE)
#define IDS_REASONS_MANYSRC1DST      (IDS_REASONS + DE_MANYSRC1DEST)
#define IDS_REASONS_DIFFDIR          (IDS_REASONS + DE_DIFFDIR)
#define IDS_REASONS_ROOTDIR          (IDS_REASONS + DE_ROOTDIR)
#define IDS_REASONS_DESTSUBTREE      (IDS_REASONS + DE_DESTSUBTREE)
#define IDS_REASONS_WINDOWSFILE      (IDS_REASONS + DE_WINDOWSFILE)
#define IDS_REASONS_ACCDENYSRC       (IDS_REASONS + DE_ACCESSDENIEDSRC)
#define IDS_REASONS_MANYDEST         (IDS_REASONS + DE_MANYDEST)
#define IDS_REASONS_INVFILES         (IDS_REASONS + DE_INVALIDFILES)
#define IDS_REASONS_DESTSAMETREE     (IDS_REASONS + DE_DESTSAMETREE)
#define IDS_REASONS_FLDDESTISFILE    (IDS_REASONS + DE_FLDDESTISFILE)
#define IDS_REASONS_COMPRESSEDVOLUME (IDS_REASONS + DE_COMPRESSEDVOLUME)
#define IDS_REASONS_FILEDESTISFLD    (IDS_REASONS + DE_FILEDESTISFLD)
#define IDS_REASONS_FILENAMETOOLONG  (IDS_REASONS + DE_FILENAMETOOLONG)
#define IDS_REASONS_DEST_IS_CDROM    (IDS_REASONS + DE_DEST_IS_CDROM)
#define IDS_REASONS_DEST_IS_DVD      (IDS_REASONS + DE_DEST_IS_DVD)
#define IDS_REASONS_DEST_IS_CDRECORD (IDS_REASONS + DE_DEST_IS_CDRECORD)

// space needed

#define IDS_STILLNOTFOUND       0x191d
#define IDS_PROGFOUND           0x191e
#define IDS_PROGNOTFOUND        0x191f
#define IDS_NOCOMMDLG           0x1920

#define IDS_CANTDELETESPECIALDIR   0x1922
#define IDS_CANTMOVESPECIALDIRHERE 0x1923
#define IDS_WNETOPENENUMERR     0x1924
#define IDS_NEWFOLDER_NOT_HERE  0x1925
#define IDS_NEWFOLDER_NOT_HERE_TITLE 0x1926
#define IDS_SHAREVIOLATION_HINT 0x1927

#define IDS_CANTLOGON           0x192A

#define IDS_AD_NAME             0x1930

#define IDS_SHARINGERROR        0x1933
#define IDS_COULDNOTSHARE       0x1934

#define IDS_CREATIONERROR       0x1935
#define IDS_COULDNOTCREATE      0x1936
#define IDS_ALLUSER_WARNING     0x1937
#define IDS_CANTFINDORIGINAL    0x1938
// #define 0x1939

#define IDS_FOLDERDOESNTEXIST  0x193A
#define IDS_CREATEFOLDERPROMPT 0x193B
#define IDS_CREATEFOLDERFAILED 0x193C
#define IDS_DIRCREATEFAILED_TITLE 0x193D
#define IDS_FOLDER_NOT_ALLOWED_TITLE 0x193E
#define IDS_FOLDER_NOT_ALLOWED 0x193F

#define IDS_FINDORIGINAL       0x1940


// WARNING!  These must be in exactly the order below because the message
// number is computed.
#define DIDS_FSHIDDEN          1
#define DIDS_FSSPACE           2
#define IDS_FSSTATUSBASE        0x1942
#define IDS_FSSTATUSHIDDEN      0x1943  // IDS_FSSTATUSBASE + DIDS_FSHIDDEN
#define IDS_FSSTATUSSPACE       0x1944  // IDS_FSSTATUSBASE + DIDS_FSSPACE
#define IDS_FSSTATUSHIDDENSPACE 0x1945  // IDS_FSSTATUSBASE + DIDS_FSHIDDEN + DIDS_FSSPACE

// #define IDS_DRIVESSTATUSTEMPLATE     0x1946 (unused)
#define IDS_DETAILSUNKNOWN              0x1947
#define IDS_MOVEBRIEFCASE               0x1948
#define IDS_DELETEBRIEFCASE             0x1949
#define IDS_NOTCUSTOMIZABLE             0x194A
#define IDS_HTMLFILE_NOTFOUND           0x194B
#define IDS_CUSTOMIZE_THIS_FOLDER       0x194C

#define IDS_FSSTATUSSELECTED    0x194D
#define IDS_FSSTATUSSEARCHING   0x194E

#define IDS_FILECREATEFAILED_TITLE 0x194F

/* These defines are used by setup to modify the user and company name which
   the about box will display.  The location of the user and company name
   are determined by looking for a search tag in the string resource table
   just before the user and company name.  This is why it is very important
   that the following 3 IDS's always be consecutive and within the same
   resource segment.  The same resource segment can be guaranteed by ensuring
   that the IDS's all be within a 16-aligned page (i.e. (n*16) to (n*16 + 15).
 */
#define IDS_SEARCH_TAG          0x1980
#define IDS_USER_NAME           0x1981
#define IDS_ORG_NAME            0x1982


// shutdown dialog #defines - 0x2000 - 0x20FF
// strings
#define IDS_SHUTDOWN_NAME       0x2000
#define IDS_SHUTDOWN_DESC       0x2001
#define IDS_RESTART_NAME        0x2002
#define IDS_RESTART_DESC        0x2003
#define IDS_SLEEP_NAME          0x2004
#define IDS_SLEEP_DESC          0x2005
#define IDS_SLEEP2_NAME         0x2006
#define IDS_SLEEP2_DESC         0x2007
#define IDS_HIBERNATE_NAME      0x2008
#define IDS_HIBERNATE_DESC      0x2009
#define IDS_LOGOFF_NAME         0x200A
#define IDS_LOGOFF_DESC         0x200B
#define IDS_RESTARTDOS_NAME     0x200C
#define IDS_RESTARTDOS_DESC     0x200D

// dialog and controls
#define IDC_EXITOPTIONS_COMBO   0x2020
#define IDC_EXITOPTIONS_DESCRIPTION 0x2021
#define IDD_EXITWINDOWS_DIALOG  0x2022

// icon
#define IDI_SHUTDOWN            0x2030


#ifdef UNICODE
#define IDS_PathNotFound         IDS_PathNotFoundW
#else // UNICODE
#define IDS_PathNotFound         IDS_PathNotFoundA
#endif // UNICODE

// these are bogus

#define IDS_LowMemError          0x2100
#define IDS_RunFileNotFound      0x2101
#define IDS_PathNotFoundA        0x2102
#define IDS_TooManyOpenFiles     0x2103
#define IDS_RunAccessDenied      0x2104
#define IDS_OldWindowsVer        0x2105
#define IDS_OS2AppError          0x2106
#define IDS_MultipleDS           0x2107
#define IDS_InvalidDLL           0x2108
#define IDS_ShareError           0x2109
#define IDS_AssocIncomplete      0x210a
#define IDS_DDEFailError         0x210b
#define IDS_NoAssocError         0x210c
#define IDS_BadFormat            0x210d
#define IDS_RModeApp             0x210e
#define IDS_PathNotFoundW        0x210f

#define IDS_MENUOPEN            0x2130
#define IDS_MENUPRINT           0x2131
#define IDS_MENUEXPLORE         0x2136
#define IDS_MENUFIND            0x2137
#define IDS_MENUAUTORUN         0x2138
#define IDS_MENURUNAS           0x2139
#define IDS_HELPOPEN            0x2140
#define IDS_HELPPRINT           0x2141
#define IDS_HELPPRINTTO         0x2142
#define IDS_HELPOPENAS          0x2143
#define IDS_MENUEDIT            0x2144

#define IDS_EXITHELP                    0x2150
#define IDS_WINDOWS_HLP                 0x2151
#define IDS_WINDOWS                     0x2152
#define IDS_MNEMONIC_EXCOL_FORMAT       0x2153
#define IDS_MNEMONIC_EXCOL_DATARATE     0x2154
#define IDS_MNEMONIC_EXCOL_FRAMERATE    0x2155
#define IDS_MNEMONIC_EXCOL_VSAMPLESIZE  0x2156
#define IDS_EXCOL_VCOMPRESSION          0x2157
#define IDS_MNEMONIC_EXCOL_VCOMPRESSION 0x2158
#define IDS_EXCOL_STREAMNAME            0x2159
#define IDS_MNEMONIC_EXCOL_STREAMNAME   0x215A
#define IDS_MNEMONIC_EXCOL_GENRE        0x215B
#define IDS_EXCOL_FAXENDTIME            0x215C
#define IDS_MNEMONIC_EXCOL_FAXENDTIME   0x215D
#define IDS_EXCOL_FAXSENDERNAME         0x215F

#define IDS_MNEMONIC_EXCOL_FAXSENDERNAME    0x2160
#define IDS_EXCOL_FAXTSID                   0x2161
#define IDS_MNEMONIC_EXCOL_FAXTSID          0x2162
#define IDS_EXCOL_FAXCALLERID               0x2163
#define IDS_MNEMONIC_EXCOL_FAXCALLERID      0x2164
#define IDS_EXCOL_FAXRECIPNAME              0x2165
#define IDS_MNEMONIC_EXCOL_FAXRECIPNAME     0x2166
#define IDS_EXCOL_FAXRECIPNUMBER            0x2167
#define IDS_MNEMONIC_EXCOL_FAXRECIPNUMBER   0x2168
#define IDS_EXCOL_FAXCSID                   0x2169
#define IDS_MNEMONIC_EXCOL_FAXCSID          0x216A
#define IDS_EXCOL_FAXROUTING                0x216B
#define IDS_MNEMONIC_EXCOL_FAXROUTING       0x216C
#define IDS_EXCOL_TAGEQUIPMAKE              0x216D
#define IDS_MNEMONIC_EXCOL_TAGEQUIPMAKE     0x216E
#define IDS_EXCOL_SEQUENCENUMBER            0x216F

#define IDS_MNEMONIC_EXCOL_SEQUENCENUMBER   0x2170
#define IDS_EXCOL_EDITOR                    0x2171
#define IDS_MNEMONIC_EXCOL_EDITOR           0x2172
#define IDS_EXCOL_SUPPLIER                  0x2173
#define IDS_MNEMONIC_EXCOL_SUPPLIER         0x2174
#define IDS_EXCOL_SOURCE                    0x2175
#define IDS_MNEMONIC_EXCOL_SOURCE           0x2176
#define IDS_EXCOL_PROJECT                   0x2177
#define IDS_MNEMONIC_EXCOL_PROJECT          0x2178
#define IDS_EXCOL_STATUS                    0x2179
#define IDS_MNEMONIC_EXCOL_STATUS           0x217A
#define IDS_EXCOL_PRODUCTION                0x217B
#define IDS_MNEMONIC_EXCOL_PRODUCTION       0x217C
#define IDS_EXCOL_MANAGER                   0x217D
#define IDS_MNEMONIC_EXCOL_MANAGER          0x217E
#define IDS_EXCOL_PRESFORMAT                0x217F

#define IDS_MNEMONIC_EXCOL_PRESFORMAT       0x2180
#define IDS_EXCOL_RESOLUTIONX               0x2181
#define IDS_EXCOL_RESOLUTIONY               0x2182
#define IDS_EXCOL_BITDEPTH                  0x2183
#define IDS_EXCOL_TRANSPARENCY              0x2184
#define IDS_MNEMONIC_EXCOL_RESOLUTIONX      0x2185
#define IDS_MNEMONIC_EXCOL_RESOLUTIONY      0x2186
#define IDS_MNEMONIC_EXCOL_BITDEPTH         0x2187
#define IDS_MNEMONIC_EXCOL_TRANSPARENCY     0x2188
#define IDS_BOOLVAL_YES                     0x2189
#define IDS_BOOLVAL_NO                      0x218A
#define IDS_STATUSVAL_NEW                   0x218B
#define IDS_STATUSVAL_PRELIM                0x218C
#define IDS_STATUSVAL_DRAFT                 0x218D
#define IDS_STATUSVAL_INPROGRESS            0x218E
#define IDS_STATUSVAL_EDIT                  0x218F

#define IDS_STATUSVAL_REVIEW                0x2190
#define IDS_STATUSVAL_PROOF                 0x2191
#define IDS_STATUSVAL_FINAL                 0x2192
#define IDS_STATUSVAL_NORMAL                0x2193
#define IDS_STATUSVAL_OTHER                 0x2194
#define IDS_EXCOL_BRIGHTNESS                0x2195

// string ids for shpsht.c
#define IDS_NOPAGE              0x21f0

// string ids for mulprsht.c
#define IDS_MULTIPLEFILES       0x2200
#define IDS_MULTIPLETYPES       0x2201
#define IDS_ALLIN               0x2202
#define IDS_ALLOFTYPE           0x2203
#define IDS_MULTIPLEOBJECTS     0x2204
#define IDS_VARFOLDERS          0x2205
#define IDS_FOLDERSIZE          0x2206
#define IDS_NUMFILES            0x2207
#define IDS_ONEFILEPROP         0x2208
#define IDS_MANYFILEPROP        0x2209

// string ids for pickicon.c
#define IDS_BADPATHMSG          0x2210
#define IDS_NOICONSMSG1         0x2211
#define IDS_NOICONSMSG          0x2212

//#define IDS_CANNOTSETATTRIBUTES 0x2213
#define IDS_MAKINGDESKTOPLINK   0x2214
#define IDS_TRYDESKTOPLINK      0x2215
#define IDS_CANNOTCREATEFILE    0x2218
#define IDS_CANNOTCREATELINK    0x2219
#define IDS_CANNOTCREATEFOLDER  0x221A

#define IDS_NFILES              0x2220
#define IDS_SELECTEDFILES       0x2221

// string ids for copy.c
// #define unused               0x2222
#define IDS_TIMEEST_MINUTES     0x2223
#define IDS_TIMEEST_SECONDS     0x2224

// string ids for version.c

#define IDS_VN_COMMENTS         0x2230
#define IDS_VN_COMPANYNAME      0x2231
#define IDS_VN_FILEDESCRIPTION  0x2232
#define IDS_VN_INTERNALNAME     0x2233
#define IDS_VN_LEGALTRADEMARKS  0x2234
#define IDS_VN_ORIGINALFILENAME 0x2235
#define IDS_VN_PRIVATEBUILD     0x2236
#define IDS_VN_PRODUCTNAME      0x2237
#define IDS_VN_PRODUCTVERSION   0x2238
#define IDS_VN_SPECIALBUILD     0x2239
#define IDS_VN_FILEVERSIONKEY   0x223A
#define IDS_VN_LANGUAGE         0x223B
#define IDS_VN_LANGUAGES        0x223C
#define IDS_VN_FILEVERSION      0x223D

// string ids for attribute descriptions
#define IDS_ATTRIBUTE_READONLY      0x2240
#define IDS_ATTRIBUTE_HIDDEN        0x2241
#define IDS_ATTRIBUTE_SYSTEM        0x2242
#define IDS_ATTRIBUTE_COMPRESSED    0x2243
#define IDS_ATTRIBUTE_ENCRYPTED     0x2244
#define IDS_ATTRIBUTE_OFFLINE       0x2245

// String ids for Associate dialog
//#define IDS_ASSOCIATE           0x2300
//#define IDS_ASSOCNONE           0x2301
//#define IDS_ASSOCNOTEXE         0x2302
//#define IDS_NOEXEASSOC          0x2303
#define IDS_WASTEBASKET         0x2304

#define IDS_NOFILESTOEMAIL          0x2305
#define IDS_PLAYABLEFILENOTFOUND    0x2306
#define IDS_RENAMEFILESINREG        0x2307
#define IDS_RECYCLEBININVALIDFORMAT 0x2308

#define IDS_BUILTIN_DOMAIN      0x230D

// column headers for various listviews
#define IDS_EXCOL_LASTAUTHOR    0x230E
#define IDS_EXCOL_REVNUMBER     0x230F

#define IDS_NAME_COL            0x2310
#define IDS_PATH_COL            0x2311
#define IDS_SIZE_COL            0x2312
#define IDS_TYPE_COL            0x2313
#define IDS_MODIFIED_COL        0x2314
#define IDS_STATUS_COL          0x2315
#define IDS_SYNCCOPYIN_COL      0x2316

#define IDS_WORKGROUP_COL       0x2318
#define IDS_DELETEDFROM_COL     0x2319
#define IDS_DATEDELETED_COL     0x231A
#define IDS_ATTRIB_COL          0x231B
#define IDS_ATTRIB_CHARS        0x231C
#define IDS_RANK_COL            0x231D
#define IDS_DESCRIPTION_COL     0x231E
#define IDS_WHICHFOLDER_COL     0x231F       

#define IDS_EXCOL_TITLE         0x2320
#define IDS_EXCOL_AUTHOR        0x2321
#define IDS_EXCOL_PAGECOUNT     0x2322
#define IDS_EXCOL_COMMENT       0x2323
#define IDS_EXCOL_CREATE        0x2324
#define IDS_EXCOL_ACCESSTIME    0x2325
#define IDS_EXCOL_OWNER         0x2326
#define IDS_EXCOL_SUBJECT       0x2327
#define IDS_EXCOL_TEMPLATE      0x2328
#define IDS_EXCOL_CAMERAMODEL   0x2329
#define IDS_EXCOL_HIDDENCOUNT   0x232A
#define IDS_EXCOL_MMCLIPCOUNT   0x232B
#define IDS_EXCOL_WHENTAKEN     0x232C
#define IDS_EXCOL_DIMENSIONS    0x232D
#define IDS_IMAGES              0x232E
#define IDS_IMAGESFILTER        0x232F

#define IDS_FILEFOUND           0x2330
#define IDS_FILENOTFOUND        0x2331
#define IDS_FINDASSEXEBROWSETITLE 0x2332
#define IDS_DRIVETSHOOT         0x2333
#define IDS_SYSDMCPL            0x2334
#define IDS_EXE                 0x2335
#define IDS_PROGRAMSFILTER      0x2336
#define IDS_BROWSE              0x2337
#define IDS_OPENAS              0x2338
#define IDS_CLP                 0x2339
#define IDS_SEPARATORFILTER     0x233A
#define IDS_ICO                 0x233B
#define IDS_ICONSFILTER         0x233C
#define IDS_ALLFILESFILTER      0x233D
#define IDS_SAVEAS              0x233E
#define IDS_REASONS_URLINTEMPDIR 0x233F

// wastebasket strings
#define IDS_BB_RESTORINGFILES               0x2340
#define IDS_BB_EMPTYINGWASTEBASKET          0x2341
#define IDS_BB_DELETINGWASTEBASKETFILES     0x2342
#define IDS_BB_CANNOTCHANGESETTINGS         0x2343

#define IDS_APPWIZCPL           0x2344

#define IDS_NO_BACKUP_APP                   0x2350
#define IDS_NO_OPTIMISE_APP                 0x2351
#define IDS_NO_DISKCHECK_APP                0x2352
#define IDS_NO_CLEANMGR_APP                 0x2353

// Drives Hardware tab string
#define IDS_THESEDRIVES         0x2354

//  Some more extended columns:
#define IDS_EXCOL_CATEGORY      0x2355
#define IDS_EXCOL_COPYRIGHT     0x2356
#define IDS_EXCOL_ARTIST        0x2357
#define IDS_EXCOL_ALBUM         0x2358
#define IDS_EXCOL_YEAR          0x2359
#define IDS_EXCOL_TRACK         0x235A
#define IDS_EXCOL_DURATION      0x235B
#define IDS_EXCOL_BITRATE       0x235C
#define IDS_EXCOL_PROTECTED     0x235D
#define IDS_EXCOL_LYRICS        0x235F

#define IDS_EXCOL_KEYWORDS      0x2360
#define IDS_EXCOL_RATING        0x2361
#define IDS_EXCOL_WORDCOUNT     0x2363
#define IDS_EXCOL_APPNAME       0x2364
#define IDS_EXCOL_SCALE         0x2365
#define IDS_EXCOL_TEMPLATEPROP  0x2366
#define IDS_EXCOL_CHARCOUNT     0x2367
#define IDS_EXCOL_LASTSAVEDTM   0x2368
#define IDS_EXCOL_LASTPRINTED   0x2369
#define IDS_EXCOL_EDITTIME      0x236A
#define IDS_EXCOL_BYTECOUNT     0x236B
#define IDS_EXCOL_LINECOUNT     0x236C
#define IDS_EXCOL_PARCOUNT      0x236D
#define IDS_EXCOL_SLIDECOUNT    0x236E
#define IDS_EXCOL_NOTECOUNT     0x236F


// String ids for names of special ID Lists
#define IDS_CSIDL_HISTORY                   0x2370
#define IDS_CSIDL_COOKIES                   0x2371
#define IDS_CSIDL_CACHE                     0x2372
#define IDS_CSIDL_PRINTHOOD                 0x2373
#define IDS_CSIDL_MYPICTURES                0x2374
#define IDS_CSIDL_TEMPLATES                 0x2376
#define IDS_CSIDL_PROGRAM_FILES             0x2378
#define IDS_CSIDL_ALLUSERS_OEM_LINKS        0x2379
#define IDS_EXCOL_LINKSDIRTY                0x237A
#define IDS_EXCOL_SAMPLERATE                0x237B
#define IDS_EXCOL_ASAMPLESIZE               0x237C
#define IDS_EXCOL_CHANNELS                  0x237D
#define IDS_EXCOL_FORMAT                    0x237E
#define IDS_EXCOL_DATARATE                  0x237F

#define IDS_CSIDL_ALTSTARTUP                0x2380
#define IDS_LOCALSETTINGS                   0x2381
#define IDS_CSIDL_APPDATA                   0x2382
#define IDS_ALL_USERS                       0x2383
#define IDS_CSIDL_DESKTOPDIRECTORY          0x2384
#define IDS_CSIDL_CDBURN_AREA               0x2385
#define IDS_CSIDL_PROGRAMS                  0x2386
#define IDS_EXCOL_FRAMERATE                 0x2387
#define IDS_CSIDL_RECENT                    0x2388
#define IDS_EXCOL_VSAMPLESIZE               0x2389
#define IDS_CSIDL_SENDTO                    0x238a
#define IDS_EXCOL_GENRE                     0x238b
#define IDS_CSIDL_PERSONAL                  0x238c
#define IDS_EXCOL_SOFTWARE                  0x238d
#define IDS_CSIDL_STARTUP                   0x238e
#define IDS_EXCOL_IMAGECX                   0x238f

#define IDS_CSIDL_STARTMENU                 0x2390
#define IDS_CSIDL_MYMUSIC                   0x2391
#define IDS_CSIDL_FAVORITES                 0x2392
#define IDS_CSIDL_MYVIDEO                   0x2393
#define IDS_CSIDL_NETHOOD                   0x2394
#define IDS_EXCOL_IMAGECY                   0x2395
#define IDS_EXCOL_FLASH                     0x2396
#define IDS_EXCOL_COLORSPACE                0x2397
#define IDS_CSIDL_ALLUSERS_DOCUMENTS        0x2398
#define IDS_EXCOL_SHUTTERSPEED              0x2399
#define IDS_EXCOL_APERTURE                  0x239A
#define IDS_WINHELPERROR                    0x239B
#define IDS_WINHELPTITLE                    0x239C
#define IDS_CSIDL_ADMINTOOLS                0x239D
#define IDS_CSIDL_COMMON_ADMINTOOLS         0x239E
#define IDS_QUICKLAUNCH                     0x239F

#define IDS_EXCOL_DISTANCE                  0x23A0
#define IDS_CSIDL_ALLUSERS_MUSIC            0x23A1
#define IDS_CSIDL_ALLUSERS_VIDEO            0x23A2
#define IDS_CSIDL_ALLUSERS_PICTURES         0x23A3
#define IDS_MNEMONIC_NAME_COL               0x23A4
#define IDS_MNEMONIC_SIZE_COL               0x23A5
#define IDS_MNEMONIC_TYPE_COL               0x23A6
#define IDS_MNEMONIC_MODIFIED_COL           0x23A7
#define IDS_MNEMONIC_ATTRIB_COL             0x23A8
#define IDS_MNEMONIC_EXCOL_OWNER            0x23A9
#define IDS_MNEMONIC_EXCOL_CREATE           0x23AA
#define IDS_MNEMONIC_EXCOL_ACCESSTIME       0x23AB
#define IDS_MNEMONIC_CSC_STATUS             0x23AC
#define IDS_EXCOL_FILETYPE                  0x23AD
#define IDS_EXCOL_FOCALLENGTH               0x23AE
#define IDS_MNEMONIC_EXCOL_SCALE            0x23AF

#define IDS_MNEMONIC_EXCOL_TITLE            0x23B0
#define IDS_MNEMONIC_EXCOL_SUBJECT          0x23B1
#define IDS_MNEMONIC_EXCOL_AUTHOR           0x23B2
#define IDS_MNEMONIC_EXCOL_PAGECOUNT        0x23B3
#define IDS_MNEMONIC_EXCOL_COMMENT          0x23B4
#define IDS_MNEMONIC_EXCOL_COPYRIGHT        0x23B5
#define IDS_MNEMONIC_EXCOL_CATEGORY         0x23B6
#define IDS_MNEMONIC_EXCOL_KEYWORDS         0x23B7
#define IDS_MNEMONIC_EXCOL_LINKSDIRTY       0x23B8
#define IDS_MNEMONIC_EXCOL_SOFTWARE         0x23B9
#define IDS_MNEMONIC_EXCOL_CAMERAMODEL      0x23BA
#define IDS_MNEMONIC_EXCOL_WHENTAKEN        0x23BB
#define IDS_MNEMONIC_EXCOL_DIMENSIONS       0x23BC
#define IDS_EXCOL_GAMMAVALUE                0x23BD
#define IDS_MNEMONIC_EXCOL_GAMMAVALUE       0x23BE
#define IDS_EXCOL_FRAMECOUNT                0x23BF

#define IDS_MNEMONIC_EXCOL_ARTIST           0x23C0
#define IDS_MNEMONIC_EXCOL_ALBUM            0x23C1
#define IDS_MNEMONIC_EXCOL_YEAR             0x23C2
#define IDS_MNEMONIC_EXCOL_TRACK            0x23C3
#define IDS_MNEMONIC_EXCOL_DURATION         0x23C4
#define IDS_MNEMONIC_EXCOL_BITRATE          0x23C5
#define IDS_MNEMONIC_EXCOL_PROTECTED        0x23C6
#define IDS_MNEMONIC_EXCOL_FRAMECOUNT       0x23C7
#define IDS_EXCOL_ACOMPRESSION              0x23C8
#define IDS_MNEMONIC_EXCOL_ACOMPRESSION     0x23C9
#define IDS_MNEMONIC_VN_COMPANYNAME         0x23CA
#define IDS_MNEMONIC_VN_FILEDESCRIPTION     0x23CB
#define IDS_MNEMONIC_VN_FILEVERSION         0x23CC
#define IDS_MNEMONIC_VN_PRODUCTNAME         0x23CD
#define IDS_MNEMONIC_VN_PRODUCTVERSION      0x23CE
#define IDS_MNEMONIC_EXCOL_IMAGECX          0x23CF

#define IDS_MNEMONIC_PSD_QUEUESIZE          0x23D0
#define IDS_MNEMONIC_PSD_LOCATION           0x23D1
#define IDS_MNEMONIC_PSD_MODEL              0x23D2
#define IDS_MNEMONIC_PRQ_STATUS             0x23D3
#define IDS_MNEMONIC_EXCOL_IMAGECY          0x23D4
#define IDS_MNEMONIC_EXCOL_FLASH            0x23D5
#define IDS_MNEMONIC_EXCOL_COLORSPACE       0x23D6
#define IDS_NMEMONIC_EXCOL_SHUTTERSPEED     0x23D7
#define IDS_NMEMONIC_EXCOL_APERTURE         0x23D8
#define IDS_NMEMONIC_EXCOL_BRIGHTNESS       0x23D9
#define IDS_MNEMONIC_DELETEDFROM_COL        0x23DA
#define IDS_MNEMONIC_DATEDELETED_COL        0x23DB
#define IDS_NMEMONIC_EXCOL_DISTANCE         0x23DC
#define IDS_MNEMONIC_EXCOL_FILETYPE         0x23DD
#define IDS_MNEMONIC_EXCOL_FOCALLENGTH      0x23DE
#define IDS_EXCOL_FNUMBER                   0x23DF

#define IDS_MNEMONIC_SYNCCOPYIN_COL         0x23E0
#define IDS_MNEMONIC_STATUS_COL             0x23E1
#define IDS_MNEMONIC_EXCOL_FNUMBER          0x23E2
#define IDS_EXCOL_EXPOSURETIME              0x23E3
#define IDS_MNEMONIC_EXCOL_EXPOSURETIME     0x23E4
#define IDS_MNEMONIC_DRIVES_FREE            0x23E5
#define IDS_MNEMONIC_DRIVES_CAPACITY        0x23E6
#define IDS_MNEMONIC_DRIVES_FILESYSTEM      0x23E7
#define IDS_MNEMONIC_EXCOL_SAMPLERATE       0x23E8
#define IDS_MNEMONIC_EXCOL_ASAMPLESIZE      0x23E9
#define IDS_MNEMONIC_PATH_COL               0x23EA
#define IDS_MNEMONIC_RANK_COL               0x23EB
#define IDS_MNEMONIC_EXCOL_TEMPLATE         0x23EC
#define IDS_MNEMONIC_EXCOL_LASTAUTHOR       0x23ED
#define IDS_MNEMONIC_EXCOL_REVNUMBER        0x23EE
#define IDS_MNEMONIC_EXCOL_APPNAME          0x23EF

#define IDS_MNEMONIC_WHICHFOLDER_COL        0x23F0
#define IDS_MNEMONIC_EXCOL_WORDCOUNT        0x23F1
#define IDS_MNEMONIC_EXCOL_CHARCOUNT        0x23F2
#define IDS_MNEMONIC_EXCOL_LASTSAVEDTM      0x23F3
#define IDS_MNEMONIC_EXCOL_LASTPRINTED      0x23F4
#define IDS_MNEMONIC_EXCOL_EDITTIME         0x23F5
#define IDS_MNEMONIC_EXCOL_BYTECOUNT        0x23F6
#define IDS_MNEMONIC_EXCOL_LINECOUNT        0x23F7
#define IDS_MNEMONIC_EXCOL_PARCOUNT         0x23F9
#define IDS_MNEMONIC_EXCOL_SLIDECOUNT       0x23FA
#define IDS_MNEMONIC_EXCOL_NOTECOUNT        0x23FB
#define IDS_MNEMONIC_EXCOL_HIDDENCOUNT      0x23FC
#define IDS_MNEMONIC_EXCOL_MMCLIPCOUNT      0x23FD
#define IDS_MNEMONIC_EXCOL_RATING           0x23FE
#define IDS_MNEMONIC_EXCOL_CHANNELS         0x23FF

// String ids for the Root of All Evil (ultroot.c)
#define IDS_ROOTNAMES                   0x2400
#define IDS_DRIVEROOT                   (IDS_ROOTNAMES+0x00)
#define IDS_NETWORKROOT                 (IDS_ROOTNAMES+0x01)
#define IDS_RESTOFNET                   (IDS_ROOTNAMES+0x02)

// These are not roots, but save number of string tables...
#define IDS_525_FLOPPY_DRIVE            (IDS_ROOTNAMES+0x03)
#define IDS_35_FLOPPY_DRIVE             (IDS_ROOTNAMES+0x04)
#define IDS_UNK_FLOPPY_DRIVE            (IDS_ROOTNAMES+0x05)

// Okay, so this is a root...
#define IDS_INETROOT                    (IDS_ROOTNAMES+0x06)

// More that are not roots...
#define IDS_UNC_FORMAT                  (IDS_ROOTNAMES+0x07)
#define IDS_VOL_FORMAT                  (IDS_ROOTNAMES+0x08)

#define IDS_525_FLOPPY_DRIVE_UGLY       (IDS_ROOTNAMES+0x09)
#define IDS_35_FLOPPY_DRIVE_UGLY        (IDS_ROOTNAMES+0x0a)

#define IDS_MYDOCUMENTS                 (IDS_ROOTNAMES+0x0b)

#define IDS_VOL_FORMAT_LETTER_1ST       (IDS_ROOTNAMES+0x0c)

#define IDS_NECUNK_FLOPPY_DRIVE         (IDS_ROOTNAMES+0x0f)

// String ids for the Find dialog
#define IDS_FINDDLG                 0x2410
#define IDS_FILESFOUND                  (IDS_FINDDLG + 0x00)
#define IDS_COMPUTERSFOUND              (IDS_FINDDLG + 0x01)
#define IDS_SEARCHING                   (IDS_FINDDLG + 0x02)
#define IDS_FIND_SELECT_PATH            (IDS_FINDDLG + 0x03)
#define IDS_FIND_TITLE_NAME             (IDS_FINDDLG + 0x04)
#define IDS_FIND_TITLE_TYPE             (IDS_FINDDLG + 0x05)
#define IDS_FIND_TITLE_TYPE_NAME        (IDS_FINDDLG + 0x06)
#define IDS_FIND_TITLE_TEXT             (IDS_FINDDLG + 0x07)
#define IDS_FIND_TITLE_NAME_TEXT        (IDS_FINDDLG + 0x08)
#define IDS_FIND_TITLE_TYPE_TEXT        (IDS_FINDDLG + 0x09)
#define IDS_FIND_TITLE_TYPE_NAME_TEXT   (IDS_FINDDLG + 0x0a)
#define IDS_FIND_TITLE_ALL              (IDS_FINDDLG + 0x0b)
#define IDS_FIND_TITLE_COMPUTER         (IDS_FINDDLG + 0x0c)
#define IDS_FIND_SHORT_NAME             (IDS_FINDDLG + 0x0d)
#define IDS_FIND_TITLE_FIND             (IDS_FINDDLG + 0x0e)
#define IDS_FINDSEARCHTITLE             (IDS_FINDDLG + 0x0f)
#define IDS_FINDSEARCH_COMPUTER         (IDS_FINDDLG + 0x10)
#define IDS_FINDSEARCH_PRINTER          (IDS_FINDDLG + 0x11)
#define IDS_FINDSEARCH_ALLDRIVES        (IDS_FINDDLG + 0x12)
#define IDS_FINDFILESFILTER             (IDS_FINDDLG + 0x13)
#define IDS_FINDSAVERESULTSTITLE        (IDS_FINDDLG + 0x14)
#define IDS_SEARCHINGASYNC              (IDS_FINDDLG + 0x15)
#define IDS_FIND_CUEBANNER_FILE         (IDS_FINDDLG + 0x16)
#define IDS_FIND_CUEBANNER_GREP         (IDS_FINDDLG + 0x17)
#define IDS_FIND_AND                    (IDS_FINDDLG + 0x18)
#define IDS_FIND_OR                     (IDS_FINDDLG + 0x19)

// For menu help, must match IDM_xxx numbers
#define IDS_FIND_STATUS_FIRST       0x2430
#define IDS_FIND_STATUS_OPENCONT        (IDS_FIND_STATUS_FIRST + 0)
#define IDS_FIND_STATUS_CASESENSITIVE   (IDS_FIND_STATUS_FIRST + 1)
#define IDS_FIND_STATUS_SAVESRCH        (IDS_FIND_STATUS_FIRST + 3)
#define IDS_FIND_STATUS_CLOSE           (IDS_FIND_STATUS_FIRST + 4)
#define IDS_FIND_STATUS_SAVERESULTS     (IDS_FIND_STATUS_FIRST + 5)
#define IDS_FIND_STATUS_WHATSTHIS       (IDS_FIND_STATUS_FIRST + 7)


// Control Panel stuff
#define IDS_CONTROL_START           0x2450
//#define IDS_LOADING                     (IDS_CONTROL_START+0x00)
//#define IDS_NAME                        (IDS_CONTROL_START+0x01)
#define IDS_CPL_EXCEPTION               (IDS_CONTROL_START+0x02)
//#define IDS_CPLINFO                     (IDS_CONTROL_START+0x03)

// Printer stuff
#define IDS_PRINTER_START           (IDS_CPL_EXCEPTION+2)
#define IDS_NEWPRN                      (IDS_PRINTER_START+0x00)
#define IDS_PRINTERS                    (IDS_PRINTER_START+0x01)
#define IDS_CHANGEDEFAULTPRINTER        (IDS_PRINTER_START+0x02)
//#define IDS_CHANGEPRINTPROCESSOR        (IDS_PRINTER_START+0x03)
//#define IDS_NETAVAIL_ALWAYS             (IDS_PRINTER_START+0x04)
//#define IDS_NETAVAIL_FMT                (IDS_PRINTER_START+0x05)
#define IDS_CANTVIEW_FILEPRN            (IDS_PRINTER_START+0x06)
#define IDS_PRINTERNAME_CHANGED         (IDS_PRINTER_START+0x07)
//#define IDS_PRINTERSINFOLDER            (IDS_PRINTER_START+0x08)
#define IDS_PRINTER_NOTCONNECTED        (IDS_PRINTER_START+0x0b)
#define IDS_MULTIPLEPRINTFILE           (IDS_PRINTER_START+0x0d)
#define IDS_CANTOPENMODALPROP           (IDS_PRINTER_START+0x0f)
#define IDS_CANTOPENDRIVERPROP          (IDS_PRINTER_START+0x10)
#define IDS_CANTPRINT                   (IDS_PRINTER_START+0x11)
#define IDS_ADDPRINTERTRYRUNAS          (IDS_PRINTER_START+0x12)
#define IDS_PRNANDFAXFOLDER             (IDS_PRINTER_START+0x13)
#define IDS_WORKONLINE                  (IDS_PRINTER_START+0x14)
#define IDS_RESUMEPRINTER               (IDS_PRINTER_START+0x15)

#define IDS_MUSTCOMPLETE                (IDS_PRINTER_START+0x17)
#define IDS_NETPRN_START                (IDS_MUSTCOMPLETE+1)
#define IDS_CANTINSTALLRESOURCE         (IDS_NETPRN_START+0x02)

#define IDS_PSD_START                   (IDS_CANTINSTALLRESOURCE+1)
#define IDS_PSD_QUEUESIZE               (IDS_PSD_START+0x01)

#define IDS_PRQ_START                   (IDS_PSD_QUEUESIZE+0x02)
#define IDS_PRQ_STATUS                  (IDS_PRQ_START+0x00)
#define IDS_PRQ_DOCNAME                 (IDS_PRQ_START+0x01)
#define IDS_PRQ_OWNER                   (IDS_PRQ_START+0x02)
#define IDS_PRQ_TIME                    (IDS_PRQ_START+0x03)
#define IDS_PRQ_PROGRESS                (IDS_PRQ_START+0x04)
#define IDS_PRQ_PAGES                   (IDS_PRQ_START+0x05)
#define IDS_PRQ_PAGESPRINTED            (IDS_PRQ_START+0x06)
#define IDS_PRQ_BYTESPRINTED            (IDS_PRQ_START+0x07)
#define IDS_PRQ_JOBSINQUEUE             (IDS_PRQ_START+0x08)

#define IDS_PRQSTATUS_START             (IDS_PRQ_JOBSINQUEUE+1)
#define IDS_PRQSTATUS_SEPARATOR         (IDS_PRQSTATUS_START+0x00)
#define IDS_PRQSTATUS_PAUSED            (IDS_PRQSTATUS_START+0x01)
#define IDS_PRQSTATUS_ERROR             (IDS_PRQSTATUS_START+0x02)
#define IDS_PRQSTATUS_PENDING_DELETION  (IDS_PRQSTATUS_START+0x03)
#define IDS_PRQSTATUS_PAPER_JAM         (IDS_PRQSTATUS_START+0x04)
#define IDS_PRQSTATUS_PAPER_OUT         (IDS_PRQSTATUS_START+0x05)
#define IDS_PRQSTATUS_MANUAL_FEED       (IDS_PRQSTATUS_START+0x06)
#define IDS_PRQSTATUS_PAPER_PROBLEM     (IDS_PRQSTATUS_START+0x07)
#define IDS_PRQSTATUS_OFFLINE           (IDS_PRQSTATUS_START+0x08)
#define IDS_PRQSTATUS_IO_ACTIVE         (IDS_PRQSTATUS_START+0x09)
#define IDS_PRQSTATUS_BUSY              (IDS_PRQSTATUS_START+0x0a)
#define IDS_PRQSTATUS_PRINTING          (IDS_PRQSTATUS_START+0x0b)
#define IDS_PRQSTATUS_OUTPUT_BIN_FULL   (IDS_PRQSTATUS_START+0x0c)
#define IDS_PRQSTATUS_NOT_AVAILABLE     (IDS_PRQSTATUS_START+0x0d)
#define IDS_PRQSTATUS_WAITING           (IDS_PRQSTATUS_START+0x0e)
#define IDS_PRQSTATUS_PROCESSING        (IDS_PRQSTATUS_START+0x0f)
#define IDS_PRQSTATUS_INITIALIZING      (IDS_PRQSTATUS_START+0x10)
#define IDS_PRQSTATUS_WARMING_UP        (IDS_PRQSTATUS_START+0x11)
#define IDS_PRQSTATUS_TONER_LOW         (IDS_PRQSTATUS_START+0x12)
#define IDS_PRQSTATUS_NO_TONER          (IDS_PRQSTATUS_START+0x13)
#define IDS_PRQSTATUS_PAGE_PUNT         (IDS_PRQSTATUS_START+0x14)
#define IDS_PRQSTATUS_USER_INTERVENTION (IDS_PRQSTATUS_START+0x15)
#define IDS_PRQSTATUS_OUT_OF_MEMORY     (IDS_PRQSTATUS_START+0x16)
#define IDS_PRQSTATUS_DOOR_OPEN         (IDS_PRQSTATUS_START+0x17)
#define IDS_PRQSTATUS_UNAVAILABLE       (IDS_PRQSTATUS_START+0x18)
#define IDS_PRQSTATUS_PRINTED           (IDS_PRQSTATUS_START+0x19)
#define IDS_PRQSTATUS_SPOOLING          (IDS_PRQSTATUS_START+0x1a)
#define IDS_PRQSTATUS_WORK_OFFLINE      (IDS_PRQSTATUS_START+0x1b)

#define IDS_PRTPROP_START           (IDS_PRQSTATUS_WORK_OFFLINE+1)
#define IDS_PRTPROP_DRIVER_WARN         (IDS_PRTPROP_START+0x00)
#define IDS_PRTPROP_RENAME_ERROR        (IDS_PRTPROP_START+0x01)
#define IDS_PRTPROP_RENAME_NULL         (IDS_PRTPROP_START+0x02)
#define IDS_PRTPROP_RENAME_BADCHARS     (IDS_PRTPROP_START+0x03)
#define IDS_PRTPROP_RENAME_TOO_LONG     (IDS_PRTPROP_START+0x04)
#define IDS_PRTPROP_PORT_ERROR          (IDS_PRTPROP_START+0x05)
#define IDS_PRTPROP_SEP_ERROR           (IDS_PRTPROP_START+0x06)
#define IDS_PRTPROP_UNKNOWN_ERROR       (IDS_PRTPROP_START+0x07)
#define IDS_PRTPROP_CANNOT_OPEN         (IDS_PRTPROP_START+0x08)
#define IDS_PRTPROP_PORT_FORMAT         (IDS_PRTPROP_START+0x09)
#define IDS_PRTPROP_TESTPAGE_WARN       (IDS_PRTPROP_START+0x0A)
#define IDS_PRTPROP_ADDPORT_CANTDEL_BUSY  (IDS_PRTPROP_START+0x0B)
#define IDS_PRTPROP_ADDPORT_CANTDEL_LOCAL (IDS_PRTPROP_START+0x0C)
#define IDS_PRTPROP_UNIQUE_FORMAT       (IDS_PRTPROP_START+0x0D)
#define IDS_PRTPROP_UNKNOWNERROR        (IDS_PRTPROP_START+0x0E)

#define IDS_PRNSEP_START            (IDS_PRTPROP_UNKNOWNERROR+1)
#define IDS_PRNSEP_NONE                 (IDS_PRNSEP_START+0x00)
#define IDS_PRNSEP_SIMPLE               (IDS_PRNSEP_START+0x01)
#define IDS_PRNSEP_FULL                 (IDS_PRNSEP_START+0x02)

#define IDS_DELETE_START            (IDS_PRNSEP_FULL+1)
#define IDS_SUREDELETE                  (IDS_DELETE_START+0x00)
#define IDS_SUREDELETEREMOTE            (IDS_DELETE_START+0x01)
#define IDS_SUREDELETECONNECTION        (IDS_DELETE_START+0x02)
#define IDS_DELNEWDEFAULT               (IDS_DELETE_START+0x03)
#define IDS_DELNODEFAULT                (IDS_DELETE_START+0x04)
#define IDS_SUREDELETEMULTIPLE          (IDS_DELETE_START+0x05)
#define IDS_DELETE_END              IDS_SUREDELETEMULTIPLE

#define IDS_DRIVES_START            (IDS_DELETE_END+1)
#define IDS_DRIVES_CAPACITY             (IDS_DRIVES_START+0x02)
#define IDS_DRIVES_FREE                 (IDS_DRIVES_START+0x03)

#define IDS_DRIVES_NETUNAVAIL           (IDS_DRIVES_START+0x04)
#define IDS_DRIVES_REMOVABLE            (IDS_DRIVES_START+0x05)
#define IDS_DRIVES_DRIVE525             (IDS_DRIVES_START+0x06)
#define IDS_DRIVES_DRIVE35              (IDS_DRIVES_START+0x07)
#define IDS_DRIVES_DRIVE525_UGLY        (IDS_DRIVES_START+0x08)
#define IDS_DRIVES_DRIVE35_UGLY         (IDS_DRIVES_START+0x09)
#define IDS_DRIVES_UGLY_TEST            (IDS_DRIVES_START+0x0a)

#define IDS_DRIVES_FIXED                (IDS_DRIVES_START+0x0b)
#define IDS_DRIVES_DVD                  (IDS_DRIVES_START+0x0c)
#define IDS_DRIVES_CDROM                (IDS_DRIVES_START+0x0d)
#define IDS_DRIVES_RAMDISK              (IDS_DRIVES_START+0x0e)
#define IDS_DRIVES_NETDRIVE             (IDS_DRIVES_START+0x0f)
#define IDS_DRIVES_REGITEM              (IDS_DRIVES_START+0x10)

//#define IDS_DRIVES_COMPRESS             (IDS_DRIVES_START+0x11)
#define IDS_DRIVES_NOOPTINSTALLED       (IDS_DRIVES_START+0x12)
//#define IDS_DRIVES_ENCRYPT              (IDS_DRIVES_START+0x13)

#define IDS_DRIVES_LASTCHECKDAYS        (IDS_DRIVES_START+0x16)
#define IDS_DRIVES_LASTBACKUPDAYS       (IDS_DRIVES_START+0x17)
#define IDS_DRIVES_LASTOPTIMIZEDAYS     (IDS_DRIVES_START+0x18)

#define IDS_DRIVES_LASTCHECKUNK         (IDS_DRIVES_START+0x19)
#define IDS_DRIVES_LASTBACKUPUNK        (IDS_DRIVES_START+0x20)
#define IDS_DRIVES_LASTOPTIMIZEUNK      (IDS_DRIVES_START+0x21)

#define IDS_DRIVES_SHAREDDOCS_GROUP     (IDS_DRIVES_START+0x22)
#define IDS_DRIVES_FIXED_GROUP          (IDS_DRIVES_START+0x23)
#define IDS_DRIVES_REMOVABLE_GROUP      (IDS_DRIVES_START+0x24)
#define IDS_DRIVES_NETDRIVE_GROUP       (IDS_DRIVES_START+0x25)
#define IDS_DRIVES_OTHER_GROUP          (IDS_DRIVES_START+0x26)
#define IDS_DRIVES_IMAGING_GROUP        (IDS_DRIVES_START+0x27)
#define IDS_DRIVES_AUDIO_GROUP          (IDS_DRIVES_START+0x28)

#define IDS_DRIVES_DVDRAM               (IDS_DRIVES_START+0x29)
#define IDS_DRIVES_DVDR                 (IDS_DRIVES_START+0x2a)
#define IDS_DRIVES_DVDRW                (IDS_DRIVES_START+0x2b)
#define IDS_DRIVES_DVDCDRW              (IDS_DRIVES_START+0x2c)
#define IDS_DRIVES_DVDCDR               (IDS_DRIVES_START+0x2d)
#define IDS_DRIVES_CDRW                 (IDS_DRIVES_START+0x2e)
#define IDS_DRIVES_CDR                  (IDS_DRIVES_START+0x2f)

#define IDS_DRIVES_FILESYSTEM           (IDS_DRIVES_START+0x30)

#define IDS_DRIVES_END                  IDS_DRIVES_FILESYSTEM

//#define IDS_LOADERR                     0x2500
//#define IDS_LOADERROR_UNKNOWN           (IDS_LOADERR-1)
//#define IDS_LOADERROR_MEMORY            (IDS_LOADERR+0)
//#define IDS_LOADERROR_CANTOPEN          (IDS_LOADERR+2)
//#define IDS_LOADERROR_CANTRUN           (IDS_LOADERR+6)
//#define IDS_LOADERROR_VERPROB           (IDS_LOADERR+10)
//#define IDS_LOADERROR_RMODE             (IDS_LOADERR+15)
//#define IDS_LOADERROR_SINGLEINST        (IDS_LOADERR+16)
//#define IDS_LOADERROR_SHARE             (IDS_LOADERR+SE_ERR_SHARE)
//#define IDS_LOADERROR_ASSOC             (IDS_LOADERR+SE_ERR_ASSOCINCOMPLETE)
//#define IDS_LOADERROR_DDETIMEOUT        (IDS_LOADERR+SE_ERR_DDETIMEOUT)
//#define IDS_LOADERROR_NOASSOC           (IDS_LOADERR+SE_ERR_NOASSOC)

#define IDS_APPCOMPATMSG                0x25A0
#define IDS_APPCOMPATWIN95              0x25A0
#define IDS_APPCOMPATWIN95L             0x25A1
#define IDS_APPCOMPATWIN95H             0x25A2
//#define IDS_APPCOMPATMEMPHIS            0x25A2
//#define IDS_APPCOMPATMEMPHISL           0x25A3
//#define IDS_APPCOMPATIE4                0x25A4
//#define IDS_APPCOMPATIE4L               0x25A5

#define IDS_PSD_LOCATION                0x25A6
#define IDS_PSD_MODEL                   0x25A7
#define IDS_PRN_INFOTIP_START           0x25A8
#define IDS_PRN_INFOTIP_NAME_FMT        0x25A9
#define IDS_PRN_INFOTIP_STATUS_FMT      0x25AA
#define IDS_PRN_INFOTIP_QUEUESIZE_FMT   0x25AB
#define IDS_PRN_INFOTIP_COMMENT_FMT     0x25AC
#define IDS_PRN_INFOTIP_LOCATION_FMT    0x25AD
#define IDS_PRN_INFOTIP_READY           0x25AE
#define IDS_SUREPURGE                   0x25B0
#define IDS_SUREDELETECONNECTIONNOSERVERNAME 0x25B1
#define IDS_SUREPURGEMULTIPLE           0x25B2
#define IDS_ERRORPRINTING               0x25B3

#define IDS_RESTRICTIONSTITLE           0x2600
#define IDS_RESTRICTIONS                0x2601

#define IDS_RESTOFNETTIP                0x2602

#define IDS_DISK_FULL_TEXT              0x2603
#define IDS_DISK_FULL_TITLE             0x2604
#define IDS_DISK_FULL_TEXT_SERIOUS      0x2605

// Strings for pifmgr code

#define IDS_PIFPAGE_FIRST       0x2650
#define IDS_PIF_NONE            (IDS_PIFPAGE_FIRST+0x00)
//#define IDS_NONE_ABOVE          (IDS_PIFPAGE_FIRST+0x01)
#define IDS_AUTO                (IDS_PIFPAGE_FIRST+0x02)
#define IDS_AUTONORMAL          (IDS_PIFPAGE_FIRST+0x03)
#define IDS_PREVIEWTEXT         (IDS_PIFPAGE_FIRST+0x04)
#define IDS_NO_ICONS            (IDS_PIFPAGE_FIRST+0x05)
#define IDS_QUERY_ERROR         (IDS_PIFPAGE_FIRST+0x06)
#define IDS_UPDATE_ERROR        (IDS_PIFPAGE_FIRST+0x07)
#define IDS_PREVIEWTEXT_BILNG   (IDS_PIFPAGE_FIRST+0x08)

#define IDS_BAD_HOTKEY          (IDS_PIFPAGE_FIRST+0x0A)
#define IDS_BAD_MEMLOW          (IDS_PIFPAGE_FIRST+0x0B)
#define IDS_BAD_MEMEMS          (IDS_PIFPAGE_FIRST+0x0C)
#define IDS_BAD_MEMXMS          (IDS_PIFPAGE_FIRST+0x0D)
#define IDS_BAD_ENVIRONMENT     (IDS_PIFPAGE_FIRST+0x0E)
#define IDS_BAD_MEMDPMI         (IDS_PIFPAGE_FIRST+0x0F)
#define IDS_MEMORY_RELAUNCH     (IDS_PIFPAGE_FIRST+0x10)
#define IDS_ADVANCED_RELAUNCH   (IDS_PIFPAGE_FIRST+0x11)

#define IDS_PROGRAMDEFEXT       (IDS_PIFPAGE_FIRST+0x12)
#define IDS_PROGRAMFILTER       (IDS_PIFPAGE_FIRST+0x13)
#define IDS_PROGRAMBROWSE       (IDS_PIFPAGE_FIRST+0x14)

/*
 *  Careful!  pifvid.c assumes that these are in order.
 */
#define IDS_PIFVID_FIRST        0x2665
#define IDS_DEFAULTLINES        (IDS_PIFVID_FIRST+0x00)
#define IDS_25LINES             (IDS_PIFVID_FIRST+0x01)
#define IDS_43LINES             (IDS_PIFVID_FIRST+0x02)
#define IDS_50LINES             (IDS_PIFVID_FIRST+0x03)

#define IDS_PIFCONVERT          (IDS_PIFVID_FIRST+0x04)
#define IDS_PIFCONVERTEXE       (IDS_PIFVID_FIRST+0x05)
#define IDS_AUTOEXECTOP         (IDS_PIFVID_FIRST+0x06)
#define IDS_AUTOEXECBOTTOM      (IDS_PIFVID_FIRST+0x07)
#define IDS_DISKINSERT          (IDS_PIFVID_FIRST+0x08)
#define IDS_DISKREMOVE          (IDS_PIFVID_FIRST+0x09)

#define IDS_NORMALWINDOW        (IDS_PIFVID_FIRST+0x0A)
#define IDS_MINIMIZED           (IDS_PIFVID_FIRST+0x0B)
#define IDS_MAXIMIZED           (IDS_PIFVID_FIRST+0x0C)

#define IDS_APPSINF             (IDS_PIFVID_FIRST+0x0D)
#define IDS_NOAPPSINF           (IDS_PIFVID_FIRST+0x0E)
#define IDS_CANTOPENAPPSINF     (IDS_PIFVID_FIRST+0x0F)
#define IDS_APPSINFERROR        (IDS_PIFVID_FIRST+0x10)
#define IDS_CREATEPIF           (IDS_PIFVID_FIRST+0x11)
#define IDS_UNKNOWNAPP          (IDS_PIFVID_FIRST+0x12)
#define IDS_UNKNOWNAPPDEF       (IDS_PIFVID_FIRST+0x13)

#define IDS_EMM386_NOEMS        (IDS_PIFVID_FIRST+0x15)
//      IDS_EMM386_NOEMS+1      (IDS_PIFVID_FIRST+0x16)
#define IDS_QEMM_NOEMS          (IDS_PIFVID_FIRST+0x17)
//      IDS_QEMM_NOEMS+1        (IDS_PIFVID_FIRST+0x18)
#define IDS_RING0_NOEMS         (IDS_PIFVID_FIRST+0x19)
//      IDS_RING0_NOEMS+1       (IDS_PIFVID_FIRST+0x1A)
#define IDS_SYSINI_NOEMS        (IDS_PIFVID_FIRST+0x1B)
//      IDS_SYSINI_NOEMS+1      (IDS_PIFVID_FIRST+0x1C)

#define IDS_NUKECONFIGMSG       (IDS_PIFVID_FIRST+0x1E)


#define IDS_ERROR               (IDS_PIFVID_FIRST+0x1F)  /* Not a string ID */
        /* Error messages go at IDS_ERROR + ERROR_WHATEVER */
    /* Right now, there is only one error string */


#define IDS_PIFFONT_FIRST       0x26a0
#define IDS_TTFACENAME_SBCS     (IDS_PIFFONT_FIRST+0x01)
#define IDS_TTFACENAME_DBCS     (IDS_PIFFONT_FIRST+0x02)
#define IDS_TTCACHESEC_SBCS     (IDS_PIFFONT_FIRST+0x03)
#define IDS_TTCACHESEC_DBCS     (IDS_PIFFONT_FIRST+0x04)


#define IDS_CANTRECYCLEREGITEMS_NAME        0x2700
#define IDS_CANTRECYCLEREGITEMS_INCL_NAME   0x2701
#define IDS_CANTRECYCLEREGITEMS_ALL         0x2702
#define IDS_CANTRECYCLEREGITEMS_SOME        0x2703
#define IDS_CONFIRMDELETEDESKTOPREGITEM     0x2704
#define IDS_CONFIRMDELETEDESKTOPREGITEMS    0x2705
#define IDS_CONFIRMDELETE_CAPTION           0x2706
#define IDS_CONFIRMNOTRECYCLABLE            0x2707
#define IDS_CONFIRMDELETEREGITEM            0x2708
#define IDS_CONFIRMDELETEREGITEMS           0x2709

#define IDS_CANTRECYLE_FOLDER               0x2720
// ---- UNUSED ---------------------------- 0x2721
#define IDS_CANTRECYLE_GENERAL              0x2722

#define IDS_EXCOL_DRMDESCRIPTION            0x2723
#define IDS_EXCOL_PLAYCOUNT                 0x2724
#define IDS_EXCOL_PLAYSTARTS                0x2725
#define IDS_EXCOL_PLAYEXPIRES               0x2726
#define IDS_MNEMONIC_EXCOL_DRMDESCRIPTION   0x2727
#define IDS_MNEMONIC_EXCOL_PLAYCOUNT        0x2728
#define IDS_MNEMONIC_EXCOL_PLAYSTARTS       0x2729
#define IDS_MNEMONIC_EXCOL_PLAYEXPIRES      0x272A
#define IDS_NETWORKLOCATION                 0x272B
#define IDS_MNEMONIC_NETWORKLOCATION        0x272C
#define IDS_EXCOL_COMPUTER                  0x272D
#define IDS_MNEMONIC_COMPUTER               0x272E

#define IDS_EXCOL_ISOSPEED                  0x272F
#define IDS_EXCOL_METERINGMODE              0x2730
#define IDS_EXCOL_LIGHTSOURCE               0x2731
#define IDS_EXCOL_EXPOSUREPROG              0x2732
#define IDS_EXCOL_FLASHENERGY               0x2733
#define IDS_EXCOL_EXPOSUREBIAS              0x2734
#define IDS_MNEMONIC_EXCOL_ISOSPEED         0x2735
#define IDS_MNEMONIC_EXCOL_METERINGMODE     0x2736
#define IDS_MNEMONIC_EXCOL_LIGHTSOURCE      0x2737
#define IDS_MNEMONIC_EXCOL_EXPOSUREPROG     0x2738
#define IDS_MNEMONIC_EXCOL_FLASHENERGY      0x2739
#define IDS_MNEMONIC_EXCOL_EXPOSUREBIAS     0x273A

// File Type strings
#define IDS_FT                              0x2760
#define IDS_ADDNEWFILETYPE                  0x2761
#define IDS_FT_EDITTITLE                    0x2762
#define IDS_FT_CLOSE                        0x2763
#define IDS_FT_EXEFILE                      0x2764
#define IDS_FT_MB_EXTTEXT                   0x2765
#define IDS_FT_MB_NOEXT                     0x2766
#define IDS_FT_MB_NOACTION                  0x2767
#define IDS_FT_MB_EXETEXT                   0x2768
#define IDS_FT_MB_REMOVETYPE                0x2769
#define IDS_FT_MB_REMOVEACTION              0x276A
#define IDS_CAP_OPENAS                      0x276B
#define IDS_FT_EXE                          0x276C
#define IDS_PROGRAMSFILTER_NT               0x276D
#define IDS_PROGRAMSFILTER_WIN95            0x276E
#define IDS_FT_NA                           0x276F
#define IDS_FT_MB_REPLEXTTEXT               0x2770
#define IDS_FT_PROP_ADVANCED                0x2771
#define IDS_FT_PROP_EXTENSIONS              0x2772
#define IDS_FT_PROP_DETAILSFOR              0x2773
#define IDS_FT_EDIT_ALREADYASSOC            0x2774
#define IDS_FT_EDIT_ALRASSOCTITLE           0x2775
#define IDS_FT_EDIT_STATIC2A                0x2776
#define IDS_FT_EDIT_STATIC2B                0x2777
#define IDS_FT_EDIT_STATIC2C                0x2778

#define IDS_FT_NEW                          0x2779
#define IDS_FT_NODESCR                      0x277A
#define IDS_FT_FTTEMPLATE                   0x277B
#define IDS_FT_MB_NOSPACEINEXT              0x277C

#define IDS_FT_ADVBTNTEXTEXPAND             0x277D
#define IDS_FT_ADVBTNTEXTCOLLAPS            0x277E
#define IDS_FT_EXTALREADYUSE                0x277F

#define IDS_EXTTYPETEMPLATE                 0x2780
// unused                                   0x2781
// unused                                   0x2782
#define IDS_FT_PROP_DETAILSFORPROGID        0x2783
#define IDS_FT_PROP_ADVANCED_PROGID         0x2784

#define IDS_FT_PROP_BTN_ADVANCED            0x279a
#define IDS_FT_PROP_BTN_RESTORE             0x279b
#define IDS_FT_PROP_RESTORE                 0x279c

#define IDS_FT_MB_EXISTINGACTION            0x279d

// Items in the "Search Name Space"
#define IDS_SNS_DOCUMENTFOLDERS             0x2800
#define IDS_SNS_LOCALHARDDRIVES             0x2801
#define IDS_SNS_MYNETWORKPLACES             0x2802
#define IDS_SNS_ALL_FILE_TYPES              0x2803
#define IDS_SNS_BROWSER_FOR_DIR             0x2804
#define IDS_SNS_BROWSERFORDIR_TITLE         0x2805

//String id used in mdprsht.c
#define IDS_CONTENTS                        0x2830

#define IDS_ACCESSINGMONIKER                0x2832

// used in recclean.c:
#define IDS_RECCLEAN_NAMETEXT               0x2833
#define IDS_RECCLEAN_DESCTEXT               0x2834
#define IDS_RECCLEAN_BTNTEXT                0x2835

#define IDS_FIT_Delimeter                   0x2921
#define IDS_FIT_ExtraItems                  0x2922
#define IDS_FIT_TipFormat                   0x2923
#define IDS_FIT_Size                        0x2924
#define IDS_FIT_Size_LT                     0x2925
#define IDS_FIT_Size_Empty                  0x2926
#define IDS_FIT_Files                       0x2927
#define IDS_FIT_Folders                     0x2928

#define IDS_WARNING                         0x2955

// Encryption context menu
#define IDS_ECM_ENCRYPT                     0x2951
#define IDS_ECM_DECRYPT                     0x2952
#define IDS_ECM_ENCRYPT_HELP                0x2953
#define IDS_ECM_DECRYPT_HELP                0x2954

// Folder shortcut
#define IDS_BROWSEFORFS                     0x2929
#define IDS_FOLDERSHORTCUT_ERR_TITLE        0x292A
#define IDS_FOLDERSHORTCUT_ERR              0x292B

// Time Categorizer
#define IDS_BEGIN_TIME                      0x3000
#define IDS_TODAY                           0x3000
#define IDS_YESTERDAY                       0x3001
#define IDS_EARLIERTHISWEEK                 0x3002
#define IDS_LASTWEEK                        0x3003
#define IDS_TWOWEEKSAGO                     0x3004
#define IDS_EARLIERTHISMONTH                0x3005
#define IDS_LASTMONTH                       0x3006
#define IDS_TWOMONTHSAGO                    0x3007
#define IDS_EARLIERTHISYEAR                 0x3008
#define IDS_LASTYEAR                        0x3009
#define IDS_TWOYEARSAGO                     0x300A
#define IDS_LONGTIMEAGO                     0x300B
#define IDS_TOMORROW                        0x300C
#define IDS_TWODAYSFROMNOW                  0x300D
#define IDS_LATERTHISWEEK                   0x300E
#define IDS_NEXTWEEK                        0x300F
#define IDS_LATERTHISMONTH                  0x3010
#define IDS_NEXTMONTH                       0x3011
#define IDS_LATERTHISYEAR                   0x3012
#define IDS_NEXTYEAR                        0x3013
#define IDS_SOMETIMETHISMILLENNIA           0x3014
#define IDS_SOMEFUTUREDATE                  0x3015
#define IDS_END_TIME                        0x301F

// Size Categorizer
#define IDS_BEGIN_SIZE                      0x3020
#define IDS_ZERO                            0x3020
#define IDS_TINY                            0x3021
#define IDS_SMALL                           0x3022
#define IDS_MEDIUM                          0x3023
#define IDS_LARGE                           0x3024
#define IDS_HUGE                            0x3025
#define IDS_GIGANTIC                        0x3026
#define IDS_UNSPECIFIED                     0x3027
#define IDS_FOLDERS                         0x3028
#define IDS_END_SIZE                        0x302F

// FreeSpace categorizer
#define IDS_FREESPACEPERCENT                0x3030

// Groups
#define IDS_GROUPBYTIME                     0x3100
#define IDS_GROUPBYSIZE                     0x3101
#define IDS_GROUPALPHABETICALLY             0x3102
#define IDS_GROUPOTHERCHAR                  0x3103
#define IDS_GROUPBYFREESPACE                0x3104
#define IDS_GROUPBYDRIVETYPE                0x3105
#define IDS_GROUPFOLDERS                    0x3106
#define IDS_UNKNOWNGROUP                    0x3107
#define IDS_THISCOMPUTERGROUP               0x3108


// CD Burn
#define IDS_BURN                            0x3110
#define IDS_BURN_PREPARINGBURN              0x3111
#define IDS_BURN_CLOSINGDISC                0x3112
#define IDS_BURN_COMPLETE                   0x3113
#define IDS_BURN_INITIALIZESTASH            0x3114
#define IDS_BURN_ADDDATA                    0x3115
#define IDS_BURN_RECORDING                  0x3116
#define IDS_BURN_WIZTITLE                   0x3117
#define IDS_BURN_CANTWRITEMEDIACDRW         0x3118
#define IDS_BURN_NOTIFY                     0x3119
#define IDS_TIMEEST_SECONDS2                0x311A
#define IDS_TIMEEST_MINUTES2                0x311B
#define IDS_BURN_INSERTDISC                 0x311C
#define IDS_BURN_NOTIFY_TITLE               0x311D
#define IDS_BURN_CANTSHUTDOWN               0x311E
#define IDS_BURN_DISCFULL                   0x311F
#define IDS_BURN_CANTBURN                   0x3120
#define IDS_BURN_HDFULL1                    0x3121
#define IDS_BURN_HDFULL2                    0x3122
#define IDS_BURN_ERASEDISC                  0x3123
#define IDS_BURN_FAILURE_MEDIUM_NOTPRESENT  0x3124
#define IDS_BURN_FAILURE_MEDIUM_INVALIDTYPE 0x3125
#define IDS_BURN_USERBLOCK                  0x3126
#define IDS_BURN_CONFIRM_DISABLE            0x3127
#define IDS_BURN_CANTWRITEMEDIACDR          0x3128
#define IDS_BURN_INSERTDISCFULL             0x3129
#define IDS_BURN_CANTWRITETOMEDIA           0x312A
// reuse                0x312B
// reuse                0x312C
#define IDS_BURN_LOCATION_CD                0x312D
#define IDS_BURN_LOCATION_STAGED            0x312E
// reuse           0x312F
// reuse     0x3130
#define IDS_BURN_CONFIRM_ERASE              0x3131
// reuse  0x3132
#define IDS_BURNWIZ_MUSIC_HEAD              0x3133
#define IDS_BURNWIZ_MUSIC_SUB               0x3134
#define IDS_BURNWIZ_TITLEFONTNAME           0x3135
#define IDS_BURNWIZ_TITLEFONTSIZE           0x3136
#define IDS_BURNWIZ_PROGRESS_BURN_HEAD      0x3137
#define IDS_BURNWIZ_PROGRESS_BURN_SUB       0x3138
#define IDS_BURN_FORMAT_DISCLABEL           0x3139
#define IDS_BURN_CONFIRM_CANCEL             0x313A
#define IDS_BURNWIZ_WAIT_HEAD               0x313B
#define IDS_BURNWIZ_WAIT_SUB                0x313C
#define IDS_BURNWIZ_PROGRESS_ERASE_HEAD     0x313D
#define IDS_BURNWIZ_PROGRESS_ERASE_SUB      0x313E
#define IDS_BURN_DISCFULLTEXT               0x313F
#define IDS_BURN_WRITESPEED_NX              0x3140
#define IDS_BURN_WRITESPEED_FASTEST         0x3141

#define IDS_CHARSINVALID                    0x3170
#define IDS_CHARSVALID                      0x3171

// My Pictures
#define IDS_FOLDER_MYPICS_TT                0x3190
#define IDS_FOLDER_MYMUSIC_TT               0x3191
#define IDS_FOLDER_MYVIDEOS_TT              0x3192
#define IDS_FOLDER_RECENTDOCS               0x3193
#define IDS_FOLDER_RECENTDOCS_TT            0x3194
#define IDS_FOLDER_FAVORITES                0x3195
#define IDS_FOLDER_DESKTOP_TT               0x3196
#define IDS_FOLDER_SHAREDDOCS_TT            0x3197
#define IDS_FOLDER_PRINTERS_TT              0x3198

// Personal Start Menu
#define IDS_AUTOCM_PROPERTIESMENU           0x31A0
#define IDS_AUTOCM_BROWSEINTERNET           0x31A1
#define IDS_AUTOCM_READEMAIL                0x31A2
#define IDS_AUTOCM_WINSECURITY              0x31A3
#define IDS_AUTOCM_SEARCH                   0x31A4
#define IDS_AUTOCM_HELP                     0x31A5
#define IDS_AUTOCM_FILERUN                  0x31A6


// Thumbview
#define IDS_THUMBNAILVIEW_DESC              0x4000
#define IDS_RENAME_TITLE                    0x4001
#define IDS_CREATETHUMBNAIL                 0x4002
#define IDS_CREATETHUMBNAILHELP             0x4003
#define IDS_HTMLTHUMBEXTRACT_DESC           0x4004
#define IDS_BMPTHUMBEXTRACT_DESC            0x4005
#define IDS_OFCTHUMBEXTRACT_DESC            0x4006
#define IDS_DOCTHUMBEXTRACT_DESC            0x4007
#define IDS_TASKSCHEDULER_DESC              0x4008
#define IDS_LNKTHUMBEXTRACT_DESC            0x4009
#define IDS_EXTRACTING                      0x400A
#define IDS_THUMBNAILGEN_DESC               0x400B
#define IDS_GDITHUMBEXTRACT_DESC            0x400D

// Storage Processor
#define ID_CONFIRM_SINGLE_ICON          0x4101
#define ID_CONFIRM_SINGLE_MAIN_TEXT     0x4104
#define IDS_PROJNAME                    0x4100
#define IDS_STORAGEPROCESSOR_DESC       0x4101
#define IDR_StorageProcessor            0x4102
#define IDS_PREPARINGTOCOPY             0x4102
#define IDS_PREPARINGTOMOVE             0x4103
#define IDS_PREPARINGTOREMOVE           0x4104
#define IDS_PREPARINGTOSYNC             0x4105
#define IDS_SCANNING                    0x4108
#define IDS_GATHERINGSTATS              0x4109
#define IDS_DEFAULTTITLE                0x4112
#define IDR_VIRTUALSTORAGE              0x4113
#define IDR_VIRTUALSTORAGEENUM          0x4114
#define IDC_CHECK1                      0x4116
#define IDD_REPEAT                      0x4117
#define IDS_CONFIRM_FILE_DELETE         0x4118
#define ID_IMAGE_ITEM_1                 0x411A
#define IDS_CONFIRM_FILE_RENAME         0x411B
#define ID_IMAGE_ITEM_2                 0x411D
#define IDS_CONFIRM_FILE_MOVE           0x411E
#define DLG_CONFIRM_SINGLE              0x411F
#define IDS_CONFIRM_FOLDER_DELETE       0x4122
#define IDC_BUTTON4                     0x4123
#define IDS_CONFIRM_FOLDER_RENAME       0x4125
#define IDC_BUTTON3                     0x4126
#define IDS_CONFIRM_FOLDER_MOVE         0x4128
#define IDC_BUTTON2                     0x4129
#define IDS_CONFIRM_COMPRESSION_LOSS    0x4130
#define IDS_CONFIRM_STREAM_LOSS         0x4132
#define IDC_BUTTON1                     0x4133
#define IDS_CONFIRM_ENCRYPTION_LOSS     0x4135
#define IDS_CONFIRM_METADATA_LOSS       0x4137
#define IDS_CONFIRM_ACL_LOSS            0x4139
#define IDS_SELECT_FILE_NAME            0x413B
#define IDS_SELECT_FOLDER_NAME          0x413D
#define IDS_CONFIRM_FILE_REPLACE        0x413F
#define IDS_CONFIRM_FOLDER_REPLACE      0x4141
#define IDI_NUKE                        0x4146
#define IDI_NUKE_FILE                   0x4148
#define IDI_NUKE_FOLDER                 0x414B
#define IDI_ATTRIBS_FOLDER              0x414D
#define IDI_ATTRIBS_FILE                0x414E
#define IDI_DEFAULTICON                 0x4151
#define IDS_DELETE_FILE                 0x4152
#define IDS_DELETE_FOLDER               0x4153
#define IDS_NUKE_FILE                   0x4154
#define IDS_NUKE_FOLDER                 0x4155
#define IDS_DELETE_READONLY_FILE        0x4156
#define IDS_DELETE_READONLY_FOLDER      0x4157
#define IDS_DELETE_SYSTEM_FILE          0x4158
#define IDS_DELETE_SYSTEM_FOLDER        0x4159
#define IDS_DELETE_TOOBIG_FILE          0x4160
#define IDS_DELETE_TOOBIG_FOLDER        0x4161
#define IDS_DELETE_PROGRAM_FILE         0x4162
#define IDS_MOVE_READONLY_FILE          0x4163
#define IDS_MOVE_READONLY_FOLDER        0x4164
#define IDS_MOVE_SYSTEM_FILE            0x4165
#define IDS_MOVE_SYSTEM_FOLDER          0x4166
#define IDS_RENAME_READONLY_FILE        0x4167
#define IDS_RENAME_READONLY_FOLDER      0x4168
#define IDS_RENAME_SYSTEM_FILE          0x4169
#define IDS_RENAME_SYSTEM_FOLDER        0x416A
#define IDS_STREAM_LOSS_COPY_FILE       0x416B
#define IDS_STREAM_LOSS_COPY_FOLDER     0x416C
#define IDS_STREAM_LOSS_MOVE_FILE       0x416D
#define IDS_STREAM_LOSS_MOVE_FOLDER     0x416E
#define IDS_METADATA_LOSS_COPY_FILE     0x416F
#define IDS_METADATA_LOSS_COPY_FOLDER   0x4170
#define IDS_METADATA_LOSS_MOVE_FILE     0x4171
#define IDS_METADATA_LOSS_MOVE_FOLDER   0x4172
#define IDS_COMPRESSION_LOSS_COPY_FILE  0x4173
#define IDS_COMPRESSION_LOSS_COPY_FOLDER 0x4174
#define IDS_COMPRESSION_LOSS_MOVE_FILE  0x4175
#define IDS_COMPRESSION_LOSS_MOVE_FOLDER 0x4176
#define IDS_SPARSE_LOSS_COPY_FILE       0x4177
#define IDS_SPARSE_LOSS_MOVE_FILE       0x4178
#define IDS_ENCRYPTION_LOSS_COPY_FILE   0x4179
#define IDS_ENCRYPTION_LOSS_COPY_FOLDER 0x4180
#define IDS_ENCRYPTION_LOSS_MOVE_FILE   0x4181
#define IDS_ENCRYPTION_LOSS_MOVE_FOLDER 0x4182
#define IDS_DEFAULTDESC                 0x4183
#define IDS_REPLACE_FILE                0x4184
#define IDS_REPLACEEXISTING_FILE        0x4185
#define IDS_WITHTHIS                    0x4186
#define IDS_REPLACE_FOLDER              0x4187
#define IDS_REPLACEEXISTING_FOLDER      0x4188
#define IDS_INTOTHIS                    0x4189
#define ID_CONDITION_TEXT               0x418B
#define ID_DETAILS_ITEM_1               0x418C
#define ID_DETAILS_ITEM_2               0x418D
#define IDD_CONFIRM_TEXT                0x418E
#define IDS_PROPFORMAT                  0x418F
#define IDS_UNKNOWN_COPY_FILE           0x4190
#define IDS_UNKNOWN_COPY_FOLDER         0x4191
#define IDS_UNKNOWN_MOVE_FILE           0x4192
#define IDS_UNKNOWN_MOVE_FOLDER         0x4193
#define IDS_UNKNOWN_COPY_TITLE          0x4194
#define IDS_UNKNOWN_MOVE_TITLE          0x4195
#define IDS_NO_STORAGE_MOVE             0x4196
#define IDS_NO_STORAGE_COPY             0x4197

#define IDD_CONFIRM_RETRYSKIPCANCEL     0x4200
#define IDD_CONFIRM_RETRYCANCEL         0x4201
#define IDD_CONFIRM_YESSKIPCANCEL       0x4202
#define IDD_CONFIRM_YESCANCEL           0x4203
#define IDD_CONFIRM_RENAMESKIPCANCEL    0x4204
#define IDD_CONFIRM_RENAMECANCEL        0x4205
#define IDD_CONFIRM_YESSKIPRENAMECANCEL 0x4206
#define IDD_CONFIRM_YESRENAMECANCEL     0x4207
#define IDD_CONFIRM_SKIPCANCEL          0x4208
#define IDD_CONFIRM_CANCEL              0x4209
#define IDD_CONFIRM_OK                  0x420A

// more string ids for pickicon.c
#define IDS_FILETYPE_PICKICONDLG_CAPTION    0x4300
#define IDS_FOLDER_PICKICONDLG_CAPTION      0x4301

// Autoplay dialogs strings
#define IDS_AP_OPENFOLDER                 0x4302
#define IDS_AP_OPENFOLDER_PROVIDER        0x4303
#define IDS_AP_SLIDESHOW                  0x4304
#define IDS_AP_SLIDESHOW_PROVIDER         0x4305
#define IDS_AP_PRINTPICTURE               0x4306
#define IDS_AP_PRINTPICTURE_PROVIDER      0x4307
#define IDS_AP_USING                      0x4308
#define IDS_AP_PICTURESCONTENTHANDLER     0x4309
#define IDS_AP_MUSICFILESCONTENTHANDLER   0x430A
#define IDS_AP_VIDEOFILESCONTENTHANDLER   0x430B
#define IDS_AP_CDAUDIOCONTENTHANDLER      0x430C
#define IDS_AP_DVDMOVIECONTENTHANDLER     0x430D
#define IDS_AP_BLANKCDCONTENTHANDLER      0x430E
#define IDS_AP_MIXEDCONTENTCONTENTHANDLER 0x430F
#define IDS_AP_TAKENOACTION               0x4310
#define IDS_AP_CDBURNING                  0x4311
#define IDS_AP_CDBURNING_PROVIDER         0x4312
#define IDS_AP_PLAYAUDIOCD_LEGACY         0x4313
#define IDS_AP_PLAYDVDMOVIE_LEGACY        0x4314
#define IDS_AP_SNIFFPROGRESSDIALOG        0x4315

// string ids for IPropertyUI::FormatForDisplay

#define IDS_PROPERTYUI_MUSIC_BITRATE        0x4331
#define IDS_PROPERTYUI_IMAGE_FLASHFIRED     0x4332
#define IDS_PROPERTYUI_IMAGE_NOFLASH        0x4333
#define IDS_PROPERTYUI_IMAGE_NOSTROBERETURN 0x4334
#define IDS_PROPERTYUI_IMAGE_STROBERETURN   0x4335
#define IDS_PROPERTYUI_IMAGE_SRGB           0x4336
#define IDS_PROPERTYUI_IMAGE_UNCALIBRATED   0x4337
#define IDS_PROPERTYUI_YES                  0x4338
#define IDS_PROPERTYUI_NO                   0x4339
#define IDS_PROPERTYUI_AUDIO_SAMPLERATE     0x433A
#define IDS_PROPERTYUI_AUDIO_CHANNELCOUNT1  0x433B
#define IDS_PROPERTYUI_AUDIO_CHANNELCOUNT2  0x433C
#define IDS_PROPERTYUI_VIDEO_FRAMERATE      0x433D
#define IDS_PROPERTYUI_AV_SAMPLESIZE        0x433E
#define IDS_PROPERTYUI_IMAGE_PIXELS         0x433F

#define IDS_PROPERTYUI_IMAGE_UNKNOWN        0x4340
#define IDS_PROPERTYUI_IMAGE_AVERAGE        0x4341
#define IDS_PROPERTYUI_IMAGE_CWA            0x4342
#define IDS_PROPERTYUI_IMAGE_SPOT           0x4343
#define IDS_PROPERTYUI_IMAGE_MULTISPOT      0x4344
#define IDS_PROPERTYUI_IMAGE_PATTERN        0x4345
#define IDS_PROPERTYUI_IMAGE_PARTIAL        0x4346
#define IDS_PROPERTYUI_IMAGE_DAYLIGHT       0x4347
#define IDS_PROPERTYUI_IMAGE_FLOURESCENT    0x4348
#define IDS_PROPERTYUI_IMAGE_TUNGSTEN       0x4349
#define IDS_PROPERTYUI_IMAGE_STANDARDA      0x434A
#define IDS_PROPERTYUI_IMAGE_STANDARDB      0x434B
#define IDS_PROPERTYUI_IMAGE_STANDARDC      0x434c
#define IDS_PROPERTYUI_IMAGE_D55            0x434D
#define IDS_PROPERTYUI_IMAGE_D65            0x434E
#define IDS_PROPERTYUI_IMAGE_D75            0x434F
#define IDS_PROPERTYUI_IMAGE_MANUAL         0x4350
#define IDS_PROPERTYUI_IMAGE_NORMAL         0x4351
#define IDS_PROPERTYUI_IMAGE_APERTUREPRI    0x4352
#define IDS_PROPERTYUI_IMAGE_SHUTTERPRI     0x4353
#define IDS_PROPERTYUI_IMAGE_CREATIVE       0x4354
#define IDS_PROPERTYUI_IMAGE_ACTION         0x4355
#define IDS_PROPERTYUI_IMAGE_PORTRAIT       0x4356
#define IDS_PROPERTYUI_IMAGE_LANDSCAPE      0x4357
// string ids dor DUI tasks (below) fit here
#define IDS_PROPERTYUI_IMAGE_DPI            0x435A
#define IDS_PROPERTYUI_IMAGE_SEC            0x435B
#define IDS_PROPERTYUI_IMAGE_SEC_FRAC       0x435C
#define IDS_PROPERTYUI_IMAGE_F              0x435D
#define IDS_PROPERTYUI_IMAGE_M              0x435E
#define IDS_PROPERTYUI_IMAGE_MM             0x435F
#define IDS_PROPERTYUI_IMAGE_ISO            0x4360
#define IDS_PROPERTYUI_IMAGE_BCPS           0x4361
#define IDS_PROPERTYUI_IMAGE_STEP           0x4362

// string ids for DUI tasks
#define IDS_BLOCKADETITLE                   0x4358
#define IDS_BLOCKADEMESSAGE                 0x4359

// ids for sdspatch
#define IDR_MIGWIZAUTO                      0x4400

#define IDS_EXPLORERMANIFEST                0x5000

// printer's folder DUI webview strings

// unused                                       0x5100

// bkgnd menu (common) commands
#define IDS_PRINTERS_WV_ADDPRINTER              0x5101
#define IDS_PRINTERS_WV_ADDPRINTER_TT           0x5102
#define IDS_PRINTERS_WV_SRVPROPS                0x5103
#define IDS_PRINTERS_WV_SRVPROPS_TT             0x5104
#define IDS_PRINTERS_WV_SENDFAX                 0x5105
#define IDS_PRINTERS_WV_SENDFAX_TT              0x5106
#define IDS_PRINTERS_WV_TROUBLESHOOTER          0x5107
#define IDS_PRINTERS_WV_TROUBLESHOOTER_TT       0x5108
#define IDS_PRINTERS_WV_GOTOSUPPORT             0x5109
#define IDS_PRINTERS_WV_GOTOSUPPORT_TT          0x510a
#define IDS_PRINTERS_WV_SETUPFAXING             0x510b
#define IDS_PRINTERS_WV_SETUPFAXING_TT          0x510c
#define IDS_PRINTERS_WV_CREATEFAXPRN            0x510d
#define IDS_PRINTERS_WV_CREATEFAXPRN_TT         0x510e

// commands single selection
#define IDS_PRINTERS_WV_FLD_RENAME              0x511a
#define IDS_PRINTERS_WV_FLD_RENAME_TT           0x511b
#define IDS_PRINTERS_WV_FLD_DELETE              0x511c
#define IDS_PRINTERS_WV_FLD_DELETE_TT           0x511d
#define IDS_PRINTERS_WV_FLD_PROPERTIES          0x511e
#define IDS_PRINTERS_WV_FLD_PROPERTIES_TT       0x511f

#define IDS_PRINTERS_WV_PRN_RENAME              0x512c
#define IDS_PRINTERS_WV_PRN_RENAME_TT           0x512d
#define IDS_PRINTERS_WV_PRN_DELETE              0x512e
#define IDS_PRINTERS_WV_PRN_DELETE_TT           0x512f
#define IDS_PRINTERS_WV_PRN_PROPERTIES          0x5130
#define IDS_PRINTERS_WV_PRN_PROPERTIES_TT       0x5131

#define IDS_PRINTERS_WV_PRN_OPENQUEUE           0x513e
#define IDS_PRINTERS_WV_PRN_OPENQUEUE_TT        0x513f
#define IDS_PRINTERS_WV_PRN_PREFERENCES         0x5140
#define IDS_PRINTERS_WV_PRN_PREFERENCES_TT      0x5141
#define IDS_PRINTERS_WV_PRN_PAUSE               0x5142
#define IDS_PRINTERS_WV_PRN_PAUSE_TT            0x5143
#define IDS_PRINTERS_WV_PRN_RESUME              0x5144
#define IDS_PRINTERS_WV_PRN_RESUME_TT           0x5145
#define IDS_PRINTERS_WV_PRN_SHARE               0x5146
#define IDS_PRINTERS_WV_PRN_SHARE_TT            0x5147
#define IDS_PRINTERS_WV_PRN_VENDORURL           0x5148
#define IDS_PRINTERS_WV_PRN_VENDORURL_TT        0x5149
#define IDS_PRINTERS_WV_PRN_PRINTERURL          0x514a
#define IDS_PRINTERS_WV_PRN_PRINTERURL_TT       0x514b

// commands for multiple selection 
#define IDS_PRINTERS_WV_ANYMUL_DELETE           0x515a
#define IDS_PRINTERS_WV_ANYMUL_DELETE_TT        0x515b
#define IDS_PRINTERS_WV_ANYMUL_PROPERTIES       0x515c
#define IDS_PRINTERS_WV_ANYMUL_PROPERTIES_TT    0x515d

#define IDS_PRINTERS_WV_FLDMUL_DELETE           0x515e
#define IDS_PRINTERS_WV_FLDMUL_DELETE_TT        0x515f
#define IDS_PRINTERS_WV_FLDMUL_PROPERTIES       0x5160
#define IDS_PRINTERS_WV_FLDMUL_PROPERTIES_TT    0x5161

#define IDS_PRINTERS_WV_MUL_DELETE              0x5165
#define IDS_PRINTERS_WV_MUL_DELETE_TT           0x5166
#define IDS_PRINTERS_WV_MUL_PROPERTIES          0x5167
#define IDS_PRINTERS_WV_MUL_PROPERTIES_TT       0x5168

// headers
#define IDS_PRINTERS_WV_HEADER_TASKS            0x5182
#define IDS_PRINTERS_WV_HEADER_TASKS_TT         0x5183
#define IDS_PRINTERS_WV_HEADER_SEEALSO          0x5184
#define IDS_PRINTERS_WV_HEADER_SEEALSO_TT       0x5185

///////////////////////////////////////////////////////////////////////
// printer's web view ICONS:
//
// (alias the icon IDs to IDI_PRINTERS_WV_DEFAULT 
//  until we get real ones)
//
#define IDI_PRINTERS_WV_DEFAULT                 IDI_TASK_COPY
#define IDI_PRINTERS_WV_URLLIKE                 IDI_TASK_PUBLISH
#define IDI_PRINTERS_WV_FIRST                   1000

#define IDI_PRINTERS_WV_INFO                    1001 // IDI_PRINTERS_WV_FIRST+1
#define IDI_PRINTERS_WV_PROPERTIES              1002 // IDI_PRINTERS_WV_FIRST+2
#define IDI_PRINTERS_WV_SRVPROPS                1003 // IDI_PRINTERS_WV_FIRST+3
#define IDI_PRINTERS_WV_TROUBLESHOOTER          1004 // IDI_PRINTERS_WV_FIRST+4
#define IDI_PRINTERS_WV_SENDFAX                 1005 // IDI_PRINTERS_WV_FIRST+5
#define IDI_PRINTERS_WV_OPENQUEUE               1006 // IDI_PRINTERS_WV_FIRST+6
#define IDI_PRINTERS_WV_PREFERENCES             1007 // IDI_PRINTERS_WV_FIRST+7
#define IDI_PRINTERS_WV_PAUSE                   1008 // IDI_PRINTERS_WV_FIRST+8
#define IDI_PRINTERS_WV_RESUME                  1009 // IDI_PRINTERS_WV_FIRST+9
#define IDI_PRINTERS_WV_SHARE                   1010 // IDI_PRINTERS_WV_FIRST+10
#define IDI_PRINTERS_WV_FAXING                  1011 // IDI_PRINTERS_WV_FIRST+11

// borrowed icons (remaped)
#define IDI_PRINTERS_WV_ADDPRINTER              IDI_NEWPRN
#define IDI_PRINTERS_WV_RENAME                  IDI_TASK_RENAME
#define IDI_PRINTERS_WV_DELETE                  IDI_TASK_DELETE
#define IDI_PRINTERS_WV_GOTOSUPPORT             IDI_STHELP
#define IDI_PRINTERS_WV_VENDORURL               IDI_PRINTERS_WV_URLLIKE
#define IDI_PRINTERS_WV_PRINTERURL              IDI_PRINTERS_WV_URLLIKE

// dialog IDs of caller's dialog if FILEOP_CREATEPROGRESSDLG is not set

#define IDD_STATUS          100
#define IDD_TOSTATUS        101
#define IDD_NAME            102
#define IDD_TONAME          103
#define IDD_PROBAR          104
#define IDD_TIMEEST         105
#define IDD_ANIMATE         106

// numbers 0x3000 - 0x3FFF are taken up in Control IDs (buttons, etc)
// maybe?

#define IDD_BROWSE              0x3000
#define IDD_PROMPT              0x3001
#define IDD_PATH                0x3002
#define IDD_TEXT                0x3003
#define IDD_TEXT1               0x3004
#define IDD_TEXT2               0x3005
#define IDD_TEXT3               0x3006
#define IDD_TEXT4               0x3007
#define IDD_ARPWARNINGTEXT      0x3008 // NOTE: This is only supposed to be used by DLG_DELETE_FILE_ARP
#define IDD_ICON                0x3009
#define IDD_COMMAND             0x300A
#define IDD_STATE               0x300B
#define IDD_ICON_OLD            0x300C
#define IDD_ICON_NEW            0x300D
#define IDD_FILEINFO_OLD        0x300E
#define IDD_FILEINFO_NEW        0x300F
#define IDD_ICON_WASTEBASKET    0x3010
#define IDD_RUNDLGOPENPROMPT    0x3011
#define IDD_RUNINSEPARATE       0x3012
#define IDD_RUNWITHSHIMLAYER    0x3013

#define IDD_PAGELIST            0x3020
#define IDD_APPLYNOW            0x3021
#define IDD_DLGFRAME            0x3022

#define IDD_RESTORE             0x3023
#define IDD_SPOOL_TXT           0x3024
#define IDD_ARPLINKWINDOW       0x3025
// #define unused, use me!      0x3026

// Leave some room here just in case.

#define IDD_REFERENCE           0x3100
#define IDD_WORKDIR             0x3101

// these are for the confirmation dialogs
#define IDD_DIR                 0x3201
#define IDD_FROM                0x3202
#define IDD_TO                  0x3203
#define IDD_DATE1               0x3205
#define IDD_DATE2               0x3206
#define IDD_YESTOALL            0x3207
#define IDD_NOTOALL             0x3208
#define IDD_FLAGS               0x3209
#define IDD_STATIC              0x320a


// userlogon dialog
// needs only to be unique within itself
#define IDD_CURRENTUSER         0x100
#define IDC_USERNAME            0x101
#define IDC_PASSWORD            0x102
#define IDC_USECURRENTACCOUNT   0x103
#define IDC_USEOTHERACCOUNT     0x104
#define IDC_CREDCTL             0x105
#define IDC_SANDBOX             0x106

#define IDD_OPEN                0x3210
#define IDD_EMPTY               0x3211

// for general file dialog page
#define IDD_ITEMICON            0x3301
#define IDD_FILENAME            0x3302
#define IDD_FILETYPE            0x3303
#define IDD_NUMFILES            0x3304
#define IDD_ACTNAMES            0x3305
#define IDD_ACTKEYS             0x3306
#define IDD_FILESIZE            0x3308
#define IDD_LOCATION            0x3309
#define IDD_CREATED             0x3310
#define IDD_LASTMODIFIED        0x3311
#define IDD_LASTACCESSED        0x3312
#define IDD_READONLY            0x3313
#define IDD_HIDDEN              0x3314
#define IDD_ARCHIVE             0x3315
#define IDD_DELETED             0x3317
#define IDD_FILETYPE_TXT        0x3318
#define IDD_FILESIZE_TXT        0x3319
#define IDD_CONTAINS_TXT        0x3320
#define IDD_LOCATION_TXT        0x3321
#define IDD_FILENAME_TXT        0x3322
#define IDD_ATTR_GROUPBOX       0x3323
#define IDD_CREATED_TXT         0x3324
#define IDD_LASTMODIFIED_TXT    0x3325
#define IDD_LASTACCESSED_TXT    0x3326
#define IDD_LINE_1              0x3327
#define IDD_LINE_2              0x3328
#define IDD_LINE_3              0x3329
#define IDD_DELETED_TXT         0x3330

#define IDD_COMPRESS                0x3331 // "Compress" check box.
#define IDD_FILESIZE_COMPRESSED     0x3332 // Compressed size value text.
#define IDD_FILESIZE_COMPRESSED_TXT 0x3333 // "Compressed Size" text.
#define IDD_TYPEICON            0x3334

#define IDD_LINE_4              0x3335
#define IDD_OPENSWITH_NOCHANGE  0x3336

#define IDD_FILETYPE_TARGET     0x3337  // "Target:" text on mounted volume page

// for version dialog page

#define IDD_VERSION_FRAME           0x3350
#define IDD_VERSION_KEY             0x3351
#define IDD_VERSION_VALUE           0x3352
#define IDD_VERSION_FILEVERSION     0x3353
#define IDD_VERSION_DESCRIPTION     0x3354
#define IDD_VERSION_COPYRIGHT       0x3355

// new stuff on the file/folder properties
#define IDD_OPENSWITH_TXT       0x3360
#define IDD_OPENSWITH           0x3361
#define IDC_ADVANCED            0x3362
#define IDC_CHANGEFILETYPE      0x3363
#define IDD_NAMEEDIT            0x3364
#define IDC_MANAGEFILES_TXT     0x3365
#define IDD_INDEX               0x3366
#define IDD_ENCRYPT             0x3367
#define IDC_ENCRYPTDETAILS      0x3368
#define IDC_MANAGEFOLDERS_TXT   0x3369
#define IDD_ATTRIBSTOAPPLY      0x336a
#define IDD_NOTRECURSIVE        0x336b
#define IDD_RECURSIVE_TXT       0x336c
#define IDD_RECURSIVE           0x336d
#define IDD_MANAGEFOLDERS_TXT   0x336e
#define IDD_EJECT               0x336f
#define IDD_ERROR_TXT           0x3370

#define IDD_OPENWITH            0x3371

// Folder shortcut general dialog
#define IDD_TARGET              0x3380
#define IDD_TARGET_TXT          0x3381
#define IDD_COMMENT_TXT         0x3382


// unicpp\resource.h defines more values starting at 0x8500

////////////////////////////////
// fileview stuff

//------------------------------
// Menu IDs

#define POPUP_NONDEFAULTDD              200
#define POPUP_MOVEONLYDD                201
#define POPUP_BRIEFCASE_NONDEFAULTDD    202
#define POPUP_DRIVES_NONDEFAULTDD       203
#define POPUP_BOOKMARK_NONDEFAULTDD     204
#define POPUP_SCRAP                     205
#define POPUP_FILECONTENTS              206
#define POPUP_BRIEFCASE_FOLDER_NONDEFAULTDD 207
#define POPUP_DROPONEXE                 208
#define POPUP_BRIEFCASE_FILECONTENTS    209
#define POPUP_DESKTOPCONTENTS           199
#define POPUP_DESKTOPCONTENTS_IMG       198
#define POPUP_EMBEDDEDOBJECT            197
#define POPUP_TEMPLATEDD                196
//--------------------------------------------------------------------------
// Menu items for views (210-299 are reserved)
//

#define POPUP_DCM_ITEM          210
#define POPUP_DCM_ITEM2         211

#define POPUP_SFV_BACKGROUND    215
#define POPUP_SFV_MAINMERGE     216
#define POPUP_SFV_MAINMERGENF   217
#define POPUP_SFV_BACKGROUND_AD 218

#define POPUP_PROPERTIES_BG     220
#define POPUP_FSVIEW_ITEM_COREL7_HACK 223 //win95 send to menu for corel suite 7

#define POPUP_DESKTOP_ITEM      225
#define POPUP_BITBUCKET_ITEM    226
#define POPUP_BITBUCKET_POPUPMERGE  227

#define POPUP_FINDEXT_POPUPMERGE   229

#define POPUP_NETWORK_ITEM      232
#define POPUP_NETWORK_PRINTER   233

#define POPUP_CONTROLS_POPUPMERGE 240

#define POPUP_DRIVES_ITEM       247
#define POPUP_DRIVES_PRINTERS   248

#define POPUP_BRIEFCASE         250

#define POPUP_FIND              255
#define POPUP_DOCFIND_MERGE        258
#define POPUP_DOCFIND_ITEM_MERGE   259

#define POPUP_COMMDLG_POPUPMERGE   260

#define POPUP_BURN_POPUPMERGE      261

#define MENU_FINDDLG                303
#define MENU_FINDCOMPDLG            304

#define MENU_SM_CONTEXTMENU         305

#define MENU_GENERIC_OPEN_VERBS     351

#define MENU_PRINTOBJ_NEWPRN        352
#define MENU_PRINTOBJ_VERBS         353

#define MENU_PRINTOBJ_NEWPRN_DD     355
#define MENU_PRINTOBJ_DD            356

#define MENU_PRINTERQUEUE           357
#define MENU_FAV_ITEMCONTEXT        358
#define MENU_STARTMENUSTATICITEMS   359

#define MENU_GENERIC_CONTROLPANEL_VERBS 360

#ifdef NEPTUNE
#define MENU_SHUTDOWNMENUITEMS      361
#endif

#define MENU_ADDPRINTER_OPEN_VERBS  362

// unicpp\resource.h defines more IDs starting at 400
// menuband\mnbandid.h defines more IDs starting at 500

//------------------------------
#define IDM_NOOP                    855

#define IDM_OPENCONTAINING          0xa000
#define IDM_CASESENSITIVE           0xa001
#define IDM_REGULAREXP              0xa002
#define IDM_SAVESEARCH              0xa003
#define IDM_CLOSE                   0xa004
#define IDM_SAVERESULTS             0xa005
#define IDM_HELP_FIND               0xa006
#define IDM_HELP_WHATSTHIS          0xa007
#define IDM_MENU_OPTIONS            0xa010
#define IDM_FIND_MENU_FIRST         IDM_OPENCONTAINING
#define IDM_FIND_MENU_LAST          IDM_HELP_WHATSTHIS

// more menu item IDs in unicpp\resource.h starting at 0xa100

// for link dialog pages
#define IDD_LINK_DESCRIPTION        0X3401
#define IDD_LINK_COMMAND            0X3402
#define IDD_LINK_WORKINGDIR         0X3403
#define IDD_LINK_HOTKEY             0X3404
#define IDD_LINK_HELP               0X3405
#define IDD_FINDORIGINAL            0X3406
#define IDD_LINKDETAILS             0X3407
#define IDD_LINK_SHOWCMD            0x3408
#define IDD_LINK_RUNASUSER          0x3409

// Old SHELL.DLL control IDs (oldshell.dlg)
#define IDD_APPNAME                 0x3500
#define IDD_CONFIG                  0x3501
#define IDD_CONVTITLE               0x3502
#define IDD_CONVENTIONAL            0x3503
#define IDD_EMSFREE                 0x3504
#define IDD_SDTEXT                  0x3505
#define IDD_SDUSING                 0x3506
#define IDD_USERNAME                0x3507
#define IDD_COMPANYNAME             0x3508
#define IDD_SERIALNUM               0x3509
#define IDD_COPYRIGHTSTRING         0x350a
#define IDD_VERSION                 0x350b
#define IDD_EMSTEXT                 0x350c
#define IDD_OTHERSTUFF              0x350d
#define IDD_DOSVER                  0x350e
#define IDD_PROCESSOR               0x350f
#define IDD_PRODUCTID               0x3510
#define IDD_OEMID                   0x3511
#define IDD_EULA                    0x3512

#define IDD_APPLIST             0x3605
#define IDD_DESCRIPTION         0x3506
#define IDD_OTHER               0x3507
#define IDD_DESCRIPTIONTEXT     0x3508
#define IDD_MAKEASSOC           0x3509

#define IDD_WEBAUTOLOOKUP       0x350a
#define IDD_OPENWITHLIST        0x350b

#define IDD_DOWNLOADLINK        0x350c
#define IDD_OPENWITH_BROWSE     0x350d
#define IDD_FILE_TEXT           0x350e
#define IDD_OPENWITH_WEBSITE    0x3511


#ifdef FEATURE_DOWNLOAD_DESCRIPTION
#define IDD_FILETYPE_LABLE      0x350f
#define IDD_FILETYPE_TEXT       0x3510
#endif // FEATURE_DOWNLOAD_DESCRIPTION

// For find dialog
#define IDD_START                   0x3700
#define IDD_STOP                    0x3701
#define IDD_FILELIST                0x3702
#define IDD_NEWSEARCH               0x3703

//#define IDD_PATH                  (already defined)
//#define IDD_BROWSE                (already defined)
#define IDD_FILESPEC                0x3710
#define IDD_TOPLEVELONLY            0x3711
#define IDD_TEXTCASESEN             0x3712
#define IDD_TEXTREG                 0x3713
#define IDD_SEARCHSLOWFILES         0x3714
#define IDD_SEARCHSYSTEMDIRS        0x3715
#define IDD_SEARCHHIDDEN            0x3716

#define IDD_TYPECOMBO               0x3720
#define IDD_CONTAINS                0x3721
#define IDD_SIZECOMP                0x3722
#define IDD_SIZEVALUE               0x3723
#define IDD_SIZEUPDOWN              0x3724
#define IDD_SIZELBL                 0x3725

#define IDD_MDATE_ALL               0x3730
#define IDD_MDATE_PARTIAL           0x3731
#define IDD_MDATE_DAYS              0x3732
#define IDD_MDATE_MONTHS            0x3733
#define IDD_MDATE_BETWEEN           0x3734
#define IDD_MDATE_NUMDAYS           0x3735
#define IDD_MDATE_DAYSUPDOWN        0x3736
#define IDD_MDATE_NUMMONTHS         0x3737
#define IDD_MDATE_MONTHSUPDOWN      0x3738
#define IDD_MDATE_FROM              0x3739
#define IDD_MDATE_TO                0x373a
#define IDD_MDATE_TYPE              0x373b
#define IDD_MDATE_AND               0x373c
#define IDD_MDATE_MONTHLBL          0x373d
#define IDD_MDATE_DAYLBL            0x373e

#define IDD_COMMENT                 0x3740
#define IDD_FOLDERLIST              0x3741
#define IDD_BROWSETITLE             0x3742
#define IDD_BROWSESTATUS            0x3743
#define IDD_BROWSEEDIT              0x3744
#define IDD_SAVERESULTS             0x3745
#define IDD_NEWFOLDER_BUTTON        0x3746
#define IDD_BFF_RESIZE_TAB          0x3747
#define IDD_FOLDERLABLE             0x3748
#define IDD_BROWSEINSTRUCTION       0x3749

// for encryption warning dialog
#define IDC_ENCRYPT_FILE            0x3750
#define IDC_ENCRYPT_PARENTFOLDER    0x3751

// for folder customization tab
#define IDC_FOLDER_TEMPLATES        0x3760
#define IDC_FOLDER_RECURSE          0x3761
#define IDC_FOLDER_DEFAULT          0x3763
#define IDC_FOLDER_PREVIEW_ICON     0x3764
#define IDC_FOLDER_PREVIEW_BITMAP   0x3765
#define IDC_FOLDER_PICKBROWSE       0x3766
#define IDC_FOLDER_CHANGEICON       0x3767
#define IDC_FOLDER_ICON             0x3768
#define IDC_FOLDER_PREVIEW_TEXT     0x3769
#define IDC_FOLDER_CHANGEICONGROUP  0x376A
#define IDC_FOLDER_CHANGEICONTEXT   0x376B

#define IDC_TITLE_FLAG                          0x3800
#define IDC_TITLE_SWITCHUSER                    0x3801
#define IDC_BUTTON_SWITCHUSER                   0x3802
#define IDC_BUTTON_LOGOFF                       0x3803
#define IDC_TEXT_SWITCHUSER                     0x3804
#define IDC_TEXT_LOGOFF                         0x3805

#define IDS_SWITCHUSER_TITLE_FACENAME           0x3806
#define IDS_SWITCHUSER_TITLE_FACESIZE           0x3807
//  0x3808 used below
#define IDS_SWITCHUSER_BUTTON_FACENAME          0x3809
//  0x380a/0x380b used below
#define IDS_SWITCHUSER_BUTTON_FACESIZE          0x380c

#define IDS_SWITCHUSER_TOOLTIP_TEXT_SWITCHUSER  0x380d
#define IDS_SWITCHUSER_TOOLTIP_TEXT_LOGOFF      0x380e

#define IDB_BACKGROUND_8                        0x380f
//  0x3810 used below
#define IDB_FLAG_8                              0x3811
#define IDB_BACKGROUND_24                       0x3812
#define IDB_FLAG_24                             0x3813

#define IDB_BUTTONS                             0x3814
//  0x3815 to 0x381f free

// for logoff dialog
#define IDD_LOGOFFICON              0x3808
// for disconnect dialog
#define IDD_DISCONNECTICON          0x380a

// for legacy scandisk (app compat shim)
#define IDD_SCANDSKW                0x380b

    #define IDC_SCANDSKICON         100
    #define IDC_SCANDSKLV           101

#define DLG_ABOUT                   0x3810

// global ids
#define IDC_STATIC                  -1
#define IDC_GROUPBOX                300
#define IDC_GROUPBOX_2              301
#define IDC_GROUPBOX_3              302

//
// ids to disable context Help
//
#define IDC_NO_HELP_1               650
#define IDC_NO_HELP_2               651
#define IDC_NO_HELP_3               652
#define IDC_NO_HELP_4               653

// for pifmgr pages
#define IDD_PROGRAM                 0x3820
#define IDD_PIFNTTEMPLT             0x3821
#define IDD_MEMORY                  0x3822
#define IDD_SCREEN                  0x3823
#define IDD_FONT                    0x3824
#define IDD_ADVFONT                 0x3825
#define IDD_MISC                    0x3826

// cd recording page
#define IDC_RECORD_FIRST                0x3830
#define IDC_RECORD_ICON                 (IDC_RECORD_FIRST+0x00)
#define IDC_RECORD_ENABLE               (IDC_RECORD_FIRST+0x01)
#define IDC_RECORD_IMAGELOC             (IDC_RECORD_FIRST+0x02)
#define IDC_RECORD_WRITESPEED           (IDC_RECORD_FIRST+0x03)
#define IDC_RECORD_TEXTIMAGE            (IDC_RECORD_FIRST+0x04)
#define IDC_RECORD_TEXTWRITE            (IDC_RECORD_FIRST+0x05)
#define IDC_RECORD_EJECT                (IDC_RECORD_FIRST+0x06)

// disk general page
#define IDC_DRV_FIRST                   0x3840
#define IDC_DRV_ICON                    (IDC_DRV_FIRST+0x00)
#define IDC_DRV_LABEL                   (IDC_DRV_FIRST+0x01)
#define IDC_DRV_TYPE                    (IDC_DRV_FIRST+0x02)
#define IDC_DRV_USEDCOLOR               (IDC_DRV_FIRST+0x03)
#define IDC_DRV_FREECOLOR               (IDC_DRV_FIRST+0x04)
#define IDC_DRV_USEDMB                  (IDC_DRV_FIRST+0x05)
#define IDC_DRV_USEDBYTES               (IDC_DRV_FIRST+0x06)
#define IDC_DRV_FREEBYTES               (IDC_DRV_FIRST+0x07)
#define IDC_DRV_FREEMB                  (IDC_DRV_FIRST+0x08)
#define IDC_DRV_TOTBYTES                (IDC_DRV_FIRST+0x09)
#define IDC_DRV_TOTMB                   (IDC_DRV_FIRST+0x0a)
#define IDC_DRV_PIE                     (IDC_DRV_FIRST+0x0b)
#define IDC_DRV_LETTER                  (IDC_DRV_FIRST+0x0c)
#define IDC_DRV_TOTSEP                  (IDC_DRV_FIRST+0x0d)
#define IDC_DRV_TYPE_TXT                (IDC_DRV_FIRST+0x0e)
#define IDC_DRV_TOTBYTES_TXT            (IDC_DRV_FIRST+0x0f)
#define IDC_DRV_USEDBYTES_TXT           (IDC_DRV_FIRST+0x10)
#define IDC_DRV_FREEBYTES_TXT           (IDC_DRV_FIRST+0x11)

//These ids are used in the mounted drive general page for the
//new controls not defined in the general drive page
#define IDC_DRV_LOCATION                (IDC_DRV_FIRST+0x16)
#define IDC_DRV_TARGET                  (IDC_DRV_FIRST+0x17)
#define IDC_DRV_CREATED                 (IDC_DRV_FIRST+0x18)
#define IDC_DRV_PROPERTIES              (IDC_DRV_FIRST+0x19)
#define IDC_DRV_FS_TXT                  (IDC_DRV_FIRST+0x1a)
#define IDC_DRV_FS                      (IDC_DRV_FIRST+0x1b)
#define IDC_DRV_CLEANUP                 (IDC_DRV_FIRST+0x1c)
#define IDC_DRV_TOTSEP2                 (IDC_DRV_FIRST+0x1d)

#define IDC_DISKTOOLS_FIRST             0x3850
#define IDC_DISKTOOLS_CHKNOW            (IDC_DISKTOOLS_FIRST+0x00)
#define IDC_DISKTOOLS_TRLIGHT           (IDC_DISKTOOLS_FIRST+0x01)
#define IDC_DISKTOOLS_BKPNOW            (IDC_DISKTOOLS_FIRST+0x02)
#define IDC_DISKTOOLS_CHKDAYS           (IDC_DISKTOOLS_FIRST+0x03)
#define IDC_DISKTOOLS_OPTNOW            (IDC_DISKTOOLS_FIRST+0x04)
#define IDC_DISKTOOLS_BKPDAYS           (IDC_DISKTOOLS_FIRST+0x05)
#define IDC_DISKTOOLS_OPTDAYS           (IDC_DISKTOOLS_FIRST+0x06)
#define IDC_DISKTOOLS_BKPTXT            (IDC_DISKTOOLS_FIRST+0x07)
#define IDC_DISKTOOLS_BKPICON           (IDC_DISKTOOLS_FIRST+0x08)

// The order of these is significant (see pifsub.c:EnableEnumProc),
// The range points are IDC_ICONBMP, IDC_PIF_STATIC and
// IDC_REALMODEDISABLE.  The "safe" range (no enable/disable funny
// stuff is IDC_PIF_STATIC to IDC_REALMODE_DISABLE
#define IDC_PIFPAGES_FIRST              0x3860
#define IDC_CONVMEMGRP                  (IDC_PIFPAGES_FIRST+0x00)
#define IDC_LOCALENVLBL                 (IDC_PIFPAGES_FIRST+0x01)
#define IDC_ENVMEM                      (IDC_PIFPAGES_FIRST+0x02)
#define IDC_CONVMEMLBL                  (IDC_PIFPAGES_FIRST+0x03)
#define IDC_LOWMEM                      (IDC_PIFPAGES_FIRST+0x04)
#define IDC_LOWLOCKED                   (IDC_PIFPAGES_FIRST+0x05)
#define IDC_LOCALUMBS                   (IDC_PIFPAGES_FIRST+0x06)
#define IDC_GLOBALPROTECT               (IDC_PIFPAGES_FIRST+0x07)
#define IDC_EXPMEMGRP                   (IDC_PIFPAGES_FIRST+0x08)
#define IDC_EXPMEMLBL                   (IDC_PIFPAGES_FIRST+0x09)
#define IDC_EMSMEM                      (IDC_PIFPAGES_FIRST+0x0A)
#define IDC_EXTMEMGRP                   (IDC_PIFPAGES_FIRST+0x0C)
#define IDC_EXTMEMLBL                   (IDC_PIFPAGES_FIRST+0x0D)
#define IDC_XMSMEM                      (IDC_PIFPAGES_FIRST+0x0E)
#define IDC_HMA                         (IDC_PIFPAGES_FIRST+0x10)
#define IDC_FGNDGRP                     (IDC_PIFPAGES_FIRST+0x11)
#define IDC_FGNDEXCLUSIVE               (IDC_PIFPAGES_FIRST+0x12)
#define IDC_FGNDSCRNSAVER               (IDC_PIFPAGES_FIRST+0x13)
#define IDC_BGNDGRP                     (IDC_PIFPAGES_FIRST+0x14)
#define IDC_BGNDSUSPEND                 (IDC_PIFPAGES_FIRST+0x15)
#define IDC_IDLEGRP                     (IDC_PIFPAGES_FIRST+0x16)
#define IDC_IDLELOWLBL                  (IDC_PIFPAGES_FIRST+0x17)
#define IDC_IDLEHIGHLBL                 (IDC_PIFPAGES_FIRST+0x18)
#define IDC_IDLESENSE                   (IDC_PIFPAGES_FIRST+0x19)
#define IDC_TERMGRP                     (IDC_PIFPAGES_FIRST+0x1A)
#define IDC_WARNTERMINATE               (IDC_PIFPAGES_FIRST+0x1B)
#define IDC_TERMINATE                   (IDC_PIFPAGES_FIRST+0x1C)
#define IDC_SCREENUSAGEGRP              (IDC_PIFPAGES_FIRST+0x1D)
#define IDC_WINDOWED                    (IDC_PIFPAGES_FIRST+0x1E)
#define IDC_FULLSCREEN                  (IDC_PIFPAGES_FIRST+0x1F)
#define IDC_AUTOCONVERTFS               (IDC_PIFPAGES_FIRST+0x20)
#define IDC_SCREENLINESLBL              (IDC_PIFPAGES_FIRST+0x21)
#define IDC_SCREENLINES                 (IDC_PIFPAGES_FIRST+0x22)
#define IDC_WINDOWUSAGEGRP              (IDC_PIFPAGES_FIRST+0x23)
#define IDC_TOOLBAR                     (IDC_PIFPAGES_FIRST+0x24)
#define IDC_WINRESTORE                  (IDC_PIFPAGES_FIRST+0x25)
#define IDC_SCREENPERFGRP               (IDC_PIFPAGES_FIRST+0x26)
#define IDC_TEXTEMULATE                 (IDC_PIFPAGES_FIRST+0x27)
#define IDC_DYNAMICVIDMEM               (IDC_PIFPAGES_FIRST+0x28)
#define IDC_FONTSIZELBL                 (IDC_PIFPAGES_FIRST+0x29)
#define IDC_FONTSIZE                    (IDC_PIFPAGES_FIRST+0x2A)
#define IDC_FONTGRP                     (IDC_PIFPAGES_FIRST+0x2B)
#define IDC_RASTERFONTS                 (IDC_PIFPAGES_FIRST+0x2C)
#define IDC_TTFONTS                     (IDC_PIFPAGES_FIRST+0x2D)
#define IDC_BOTHFONTS                   (IDC_PIFPAGES_FIRST+0x2E)
#define IDC_WNDPREVIEWLBL               (IDC_PIFPAGES_FIRST+0x2F)
#define IDC_FONTPREVIEWLBL              (IDC_PIFPAGES_FIRST+0x30)
#define IDC_WNDPREVIEW                  (IDC_PIFPAGES_FIRST+0x31)
#define IDC_FONTPREVIEW                 (IDC_PIFPAGES_FIRST+0x32)
#define IDC_Unused1064                  (IDC_PIFPAGES_FIRST+0x33)
#define IDC_Unused1065                  (IDC_PIFPAGES_FIRST+0x34)
#define IDC_Unused1066                  (IDC_PIFPAGES_FIRST+0x35)
#define IDC_Unused1067                  (IDC_PIFPAGES_FIRST+0x36)
#define IDC_Unused1068                  (IDC_PIFPAGES_FIRST+0x37)
#define IDC_MISCKBDGRP                  (IDC_PIFPAGES_FIRST+0x38)
#define IDC_ALTESC                      (IDC_PIFPAGES_FIRST+0x39)
#define IDC_ALTTAB                      (IDC_PIFPAGES_FIRST+0x3A)
#define IDC_CTRLESC                     (IDC_PIFPAGES_FIRST+0x3B)
#define IDC_PRTSC                       (IDC_PIFPAGES_FIRST+0x3C)
#define IDC_ALTPRTSC                    (IDC_PIFPAGES_FIRST+0x3D)
#define IDC_ALTSPACE                    (IDC_PIFPAGES_FIRST+0x3E)
#define IDC_ALTENTER                    (IDC_PIFPAGES_FIRST+0x3F)
#define IDC_MISCMOUSEGRP                (IDC_PIFPAGES_FIRST+0x40)
#define IDC_QUICKEDIT                   (IDC_PIFPAGES_FIRST+0x41)
#define IDC_EXCLMOUSE                   (IDC_PIFPAGES_FIRST+0x42)
#define IDC_MISCOTHERGRP                (IDC_PIFPAGES_FIRST+0x43)
#define IDC_FASTPASTE                   (IDC_PIFPAGES_FIRST+0x44)
#define IDC_INSTRUCTIONS                (IDC_PIFPAGES_FIRST+0x45)
#define IDC_NOEMS                       (IDC_PIFPAGES_FIRST+0x47)
#define IDC_NOEMSDETAILS                (IDC_PIFPAGES_FIRST+0x48)
#define IDC_DPMIMEMGRP                  (IDC_PIFPAGES_FIRST+0x49)
#define IDC_DPMIMEMLBL                  (IDC_PIFPAGES_FIRST+0x4A)
#define IDC_DPMIMEM                     (IDC_PIFPAGES_FIRST+0x4B)
#define IDC_ICONBMP                     (IDC_PIFPAGES_FIRST+0x4C)
#define IDC_HOTKEYLBL                   (IDC_PIFPAGES_FIRST+0x4D)
#define IDC_HOTKEY                      (IDC_PIFPAGES_FIRST+0x4E)
#define IDC_WINDOWSTATELBL              (IDC_PIFPAGES_FIRST+0x4F)
#define IDC_WINDOWSTATE                 (IDC_PIFPAGES_FIRST+0x50)
#define IDC_WINLIE                      (IDC_PIFPAGES_FIRST+0x51)
#define IDC_SUGGESTMSDOS                (IDC_PIFPAGES_FIRST+0x52)
#define IDC_PIF_STATIC                  (IDC_PIFPAGES_FIRST+0x53)
#define IDC_TITLE                       (IDC_PIFPAGES_FIRST+0x54)
#define IDC_CMDLINE                     (IDC_PIFPAGES_FIRST+0x55)
#define IDC_CMDLINELBL                  (IDC_PIFPAGES_FIRST+0x56)
#define IDC_WORKDIRLBL                  (IDC_PIFPAGES_FIRST+0x57)
#define IDC_WORKDIR                     (IDC_PIFPAGES_FIRST+0x58)
#define IDC_BATCHFILELBL                (IDC_PIFPAGES_FIRST+0x59)
#define IDC_BATCHFILE                   (IDC_PIFPAGES_FIRST+0x5A)
#define IDC_ADVPROG                     (IDC_PIFPAGES_FIRST+0x5B)
#define IDC_REALMODE                    (IDC_PIFPAGES_FIRST+0x5C)
#define IDC_OK                          (IDC_PIFPAGES_FIRST+0x5D)
#define IDC_PIFNAMELBL                  (IDC_PIFPAGES_FIRST+0x5E)
#define IDC_PIFNAME                     (IDC_PIFPAGES_FIRST+0x5F)
#define IDC_CHANGEICON                  (IDC_PIFPAGES_FIRST+0x60)
#define IDC_CANCEL                      (IDC_PIFPAGES_FIRST+0x61)
#define IDC_CLOSEONEXIT                 (IDC_PIFPAGES_FIRST+0x62)
#ifdef NEW_UNICODE
#define IDC_SCREENXBUFLBL               (IDC_PIFPAGES_FIRST+0x63)
#define IDC_SCREENXBUF                  (IDC_PIFPAGES_FIRST+0x64)
#define IDC_SCREENYBUFLBL               (IDC_PIFPAGES_FIRST+0x65)
#define IDC_SCREENYBUF                  (IDC_PIFPAGES_FIRST+0x66)
#define IDC_WINXSIZELBL                 (IDC_PIFPAGES_FIRST+0x67)
#define IDC_WINXSIZE                    (IDC_PIFPAGES_FIRST+0x68)
#define IDC_WINYSIZELBL                 (IDC_PIFPAGES_FIRST+0x69)
#define IDC_WINYSIZE                    (IDC_PIFPAGES_FIRST+0x6A)
#else
#define IDC_Unused38CD                  (IDC_PIFPAGES_FIRST+0x63)
#define IDC_Unused38CE                  (IDC_PIFPAGES_FIRST+0x64)
#define IDC_Unused38CF                  (IDC_PIFPAGES_FIRST+0x65)
#define IDC_Unused38D0                  (IDC_PIFPAGES_FIRST+0x66)
#define IDC_Unused38D1                  (IDC_PIFPAGES_FIRST+0x67)
#define IDC_Unused38D2                  (IDC_PIFPAGES_FIRST+0x68)
#define IDC_Unused38D3                  (IDC_PIFPAGES_FIRST+0x69)
#define IDC_Unused38D4                  (IDC_PIFPAGES_FIRST+0x6A)
#endif
#define IDC_REALMODEDISABLE             (IDC_PIFPAGES_FIRST+0x80)
#define IDC_CONFIGLBL                   (IDC_PIFPAGES_FIRST+0x81)
#define IDC_CONFIG                      (IDC_PIFPAGES_FIRST+0x82)
#define IDC_AUTOEXECLBL                 (IDC_PIFPAGES_FIRST+0x83)
#define IDC_AUTOEXEC                    (IDC_PIFPAGES_FIRST+0x84)
#define IDC_REALMODEWIZARD              (IDC_PIFPAGES_FIRST+0x86)
#define IDC_WARNMSDOS                   (IDC_PIFPAGES_FIRST+0x87)
#define IDC_CURCONFIG                   (IDC_PIFPAGES_FIRST+0x88)
#define IDC_CLEANCONFIG                 (IDC_PIFPAGES_FIRST+0x89)
#define IDC_DOS                         (IDC_PIFPAGES_FIRST+0x8A)
#define IDC_AUTOEXECNT                  (IDC_PIFPAGES_FIRST+0x8B)
#define IDC_CONFIGNT                    (IDC_PIFPAGES_FIRST+0x8C)
#define IDC_NTTIMER                     (IDC_PIFPAGES_FIRST+0x8D)

// cd burning wizard
#define IDC_BURNWIZ_FIRST               0x3950
#define IDC_BURNWIZ_DISCLABEL           (IDC_BURNWIZ_FIRST+0x00)
#define IDC_BURNWIZ_BURNAGAIN           (IDC_BURNWIZ_FIRST+0x01)
#define IDC_BURNWIZ_AUTOCLOSEWIZ        (IDC_BURNWIZ_FIRST+0x02)
#define IDC_BURNWIZ_BURNAUDIO           (IDC_BURNWIZ_FIRST+0x03)
#define IDC_BURNWIZ_BURNDATA            (IDC_BURNWIZ_FIRST+0x04)
#define IDC_BURNWIZ_TITLE               (IDC_BURNWIZ_FIRST+0x05)
#define IDC_BURNWIZ_EJECT               (IDC_BURNWIZ_FIRST+0x06)
#define IDC_BURNWIZ_CLEAR               (IDC_BURNWIZ_FIRST+0x07)
#define IDC_BURNWIZ_STATUSTEXT          (IDC_BURNWIZ_FIRST+0x08)
#define IDC_BURNWIZ_ESTTIME             (IDC_BURNWIZ_FIRST+0x09)
#define IDC_BURNWIZ_EXIT                (IDC_BURNWIZ_FIRST+0x0A)
#define IDC_BURNWIZ_PROGRESS            (IDC_BURNWIZ_FIRST+0x0B)
#define IDC_BURNWIZ_PLEASEINSERT        (IDC_BURNWIZ_FIRST+0x0C)
#define IDC_BURNWIZ_LOWERED             (IDC_BURNWIZ_FIRST+0x0D)
#define IDC_BURNWIZ_STATUSTEXT2         (IDC_BURNWIZ_FIRST+0x0E)
#define IDC_BURNWIZ_ATTRIB              (IDC_BURNWIZ_FIRST+0x0F)

//--------------------------------------------------------------------------
// For Defview options page
#define IDC_SHOWALL          0x3720
#define IDC_SHOWEXTENSIONS   0x3721

#define IDC_STATIC              -1

//--------------------------------------------------------------------------
//  for DLG_FSEARCH_xxx dialogs
#define IDC_NOSCOPEWARNING          1001
#define IDC_FILESPEC                1001
#define IDC_GREPTEXT                1002
#define IDC_NAMESPACE               1003
#define IDC_SEARCH_START            1004
#define IDC_SEARCH_STOP             1005
#define IDC_USE_DATE                1007
#define IDC_USE_TYPE                1008
#define IDC_USE_SIZE                1009
#define IDC_USE_ADVANCED            1010
#define IDC_WHICH_DATE              1011
#define IDC_USE_RECENT_MONTHS       1012
#define IDC_RECENT_MONTHS           1013
#define IDC_RECENT_MONTHS_SPIN      1014
#define IDC_USE_RECENT_DAYS         1015
#define IDC_RECENT_DAYS             1016
#define IDC_RECENT_DAYS_SPIN        1017
#define IDC_USE_DATE_RANGE          1018
#define IDC_DATERANGE_BEGIN         1019
#define IDC_DATERANGE_END           1020
#define IDC_FILE_TYPE               1021
#define IDC_WHICH_SIZE              1022
#define IDC_FILESIZE                1023
#define IDC_FILESIZE_SPIN           1024
#define IDC_USE_SUBFOLDERS          1025
#define IDC_USE_CASE                1026
#define IDC_USE_SLOW_FILES          1028
#define IDC_FSEARCH_CAPTION         1029
#define IDC_FSEARCH_ICON            1030
#define IDC_INDEX_SERVER            1031
#define IDC_SEARCHLINK_FILES        1032
#define IDC_SEARCHLINK_COMPUTERS    1033
#define IDC_SEARCHLINK_PRINTERS     1034
#define IDC_SEARCHLINK_PEOPLE       1035
#define IDC_SEARCHLINK_INTERNET     1036
#define IDC_PSEARCH_ICON            1037
#define IDC_PSEARCH_CAPTION         1039
#define IDC_PSEARCH_NAME            1040
#define IDC_PSEARCH_LOCATION        1041
#define IDC_PSEARCH_MODEL           1042
#define IDC_CSEARCH_ICON            1043
#define IDC_CSEARCH_CAPTION         1044
#define IDC_CSEARCH_NAME            1045
#define IDC_SEARCHLINK_OPTIONS      1046
#define IDC_SEARCHLINK_PREVIOUS     1047
#define IDC_SEARCHLINK_CAPTION      1048
#define IDC_GROUPBTN_OPTIONS        1049
#define IDC_FSEARCH_DIV1            1050
#define IDC_FSEARCH_DIV2            1051
#define IDC_FSEARCH_DIV3            1052
#define IDC_USE_SYSTEMDIRS          1053
#define IDC_SEARCH_HIDDEN           1054

//  for DLG_INDEXSERVER
#define IDC_CI_STATUS               1000
#define IDC_CI_PROMPT               1001
#define IDC_CI_HELP                 1002
#define IDC_ENABLE_CI               1003
#define IDC_BLOWOFF_CI              1004
#define IDC_CI_ADVANCED             1005

// for bitbucket prop pages
#define IDC_DISKSIZE            1000
#define IDC_BYTESIZE            1001
#define IDC_USEDSIZE            1002
#define IDC_DISKSIZEDATA        1003
#define IDC_BYTESIZEDATA        1004
#define IDC_USEDSIZEDATA        1005
#define IDC_NUKEONDELETE        1006
#define IDC_BBSIZE              1007
#define IDC_BBSIZETEXT          1008
#define IDC_INDEPENDENT         1009
#define IDC_GLOBAL              1010
#define IDC_TEXT                1011
#define IDC_CONFIRMDELETE       1012

// for cdburn eject confirmation
#define IDC_EJECT_ICON          1000
#define IDC_EJECT_BURN          1001
#define IDC_EJECT_DISCARD       1002

// unicpp\resource.h defines more IDs starting at 0x8500

// Autoplay Dialog
#define IDC_AP_TOPTEXT                  1000
#define IDC_AP_LIST                     1001
#define IDC_AP_LIST_ACTIONS             1002
#define IDC_AP_SEL_ICON                 1003
#define IDC_AP_SEL_TEXT                 1004

#define IDC_AP_DEFAULTHANDLER           1005
#define IDC_AP_PROMPTEACHTIME           1006
#define IDC_AP_NOACTION                 1007

#define IDC_AP_RESTOREDEFAULTS          1008

// Autoplay Mixed Content Dialog
// Two following must remain in this order and have consecutive values
#define IDC_AP_MXCT_TOPICON             1000
#define IDC_AP_MXCT_TOPTEXT             1001
#define IDC_AP_MXCT_TOPTEXT2            1002
#define IDC_AP_MXCT_LIST                1003
#define IDC_AP_MXCT_CHECKBOX            1004
#define IDC_AP_MXCT_CONTENTICON         1005
#define IDC_AP_MXCT_CONTENTTYPE         1006

// File Type dialogs
// Note: Don't duplicate IDS between these dialogs
// as code is in place to know which help file is
// used...
#define IDC_FT_PROP_LV_FILETYPES        1000
#define IDC_FT_PROP_NEW                 1001
#define IDC_FT_PROP_REMOVE              1002
#define IDC_FT_PROP_EDIT                1003
#define IDC_FT_PROP_DOCICON             1004
#define IDC_FT_PROP_DOCEXTRO_TXT        1005
#define IDC_FT_PROP_DOCEXTRO            1006
#define IDC_FT_PROP_OPENICON            1007
#define IDC_FT_PROP_CONTTYPERO_TXT      1011
#define IDC_FT_PROP_CONTTYPERO          1012
#define IDC_FT_PROP_COMBO               1013
#define IDC_FT_PROP_FINDEXT_TXT         1014
#define IDC_FT_PROP_TYPEOFFILE          1015
#define IDC_FT_PROP_MODIFY              1016

#define IDC_FT_PROP_OPENEXE_TXT         1017
#define IDC_FT_PROP_OPENEXE             IDC_FT_PROP_OPENEXE_TXT + 1
#define IDC_FT_PROP_CHANGEOPENSWITH     IDC_FT_PROP_OPENEXE_TXT + 2
#define IDC_FT_PROP_TYPEOFFILE_TXT      IDC_FT_PROP_OPENEXE_TXT + 3
#define IDC_FT_PROP_EDITTYPEOFFILE      IDC_FT_PROP_OPENEXE_TXT + 4
#define IDC_FT_PROP_GROUPBOX            IDC_FT_PROP_OPENEXE_TXT + 5

#define IDC_FT_EDIT_EXT_EDIT            1023
#define IDC_FT_EDIT_ADVANCED            1024
#define IDC_FT_EDIT_PID_COMBO           1025
#define IDC_FT_EDIT_PID_COMBO_TEXT      1026
#define IDC_FT_EDIT_EXT_EDIT_TEXT       1027

#define IDC_FT_PROP_ANIM                1028

#define IDS_FOLDEROPTIONS               1030

#define IDC_FT_EDIT_DOCICON             1100
#define IDC_FT_EDIT_CHANGEICON          1101
#define IDC_FT_EDIT_DESC                1103
#define IDC_FT_EDIT_EXTTEXT             1104
#define IDC_FT_EDIT_EXT                 1105
#define IDC_FT_EDIT_LV_CMDSTEXT         1106
#define IDC_FT_EDIT_LV_CMDS             1107
#define IDC_FT_EDIT_NEW                 1108
#define IDC_FT_EDIT_EDIT                1109
#define IDC_FT_EDIT_REMOVE              1110
#define IDC_FT_EDIT_DEFAULT             1111
#define IDC_FT_EDIT_SHOWEXT             1113
#define IDC_FT_EDIT_DESCTEXT            1114
#define IDC_FT_COMBO_CONTTYPETEXT       1115
#define IDC_FT_COMBO_CONTTYPE           1116
#define IDC_FT_COMBO_DEFEXTTEXT         1117
#define IDC_FT_COMBO_DEFEXT             1118
#define IDC_FT_EDIT_CONFIRM_OPEN        1119
#define IDC_FT_EDIT_BROWSEINPLACE       1120

#define IDC_FT_CMD_ACTION               1200
#define IDC_FT_CMD_EXETEXT              1201
#define IDC_FT_CMD_EXE                  1202
#define IDC_FT_CMD_BROWSE               1203
#define IDC_FT_CMD_DDEGROUP             1204
#define IDC_FT_CMD_USEDDE               1205
#define IDC_FT_CMD_DDEMSG               1206
#define IDC_FT_CMD_DDEAPPNOT            1207
#define IDC_FT_CMD_DDETOPIC             1208
#define IDC_FT_CMD_DDEAPP               1209


//--------------------------------------------------------------------------
// For control panels & printer folder:

// RC IDs

#define IDC_PRINTER_ICON        1000
#define IDC_PRINTER_NAME        1001
#define IDDC_PRINTTO            1002
#define IDDB_ADD_PORT           1003
#define IDDB_DEL_PORT           1004
#define IDDC_DRIVER             1005
#define IDDB_NEWDRIVER          1006
#define IDC_TIMEOUTSETTING      1007
#define IDC_TIMEOUT_NOTSELECTED 1008
#define IDC_TIMEOUT_TRANSRETRY  1009
#define IDDB_SPOOL              1010
#define IDDB_PORT               1011
#define IDDB_SETUP              1012
#define IDGS_TYPE               1013
#define IDGS_LOCATION           1014
#define IDGE_COMMENT            1015
#define IDDB_TESTPAGE           1017
#define IDDC_SEPARATOR          1018
#define IDDB_CHANGESEPARATOR    1019
#define IDGS_TYPE_TXT           1020
#define IDGS_LOCATION_TXT       1021
#define IDGE_COMMENT_TXT        1022
#define IDGE_WHERE_TXT          1023
#define IDDC_SEPARATOR_TXT      1024
#define IDD_ADDPORT_NETWORK     1025
#define IDD_ADDPORT_PORTMON     1026
#define IDD_ADDPORT_NETPATH     1027
#define IDD_ADDPORT_BROWSE      1028
#define IDD_ADDPORT_LB          1029
#define IDD_DELPORT_LB          1030
#define IDD_DELPORT_TEXT_1      1031
#define IDC_TIMEOUTTEXT_1       1032
#define IDC_TIMEOUTTEXT_2       1033
#define IDC_TIMEOUTTEXT_3       1034
#define IDC_TIMEOUTTEXT_4       1035
#define IDDB_CAPTURE_PORT       1036
#define IDDB_RELEASE_PORT       1037
#define IDD_ENABLE_BIDI         1038
#define IDD_DISABLE_BIDI        1039

// Control IDs
//#define ID_LISTVIEW           200
#define ID_SETUP                210

// Commands for top level menu
#define ID_PRINTER_NEW                 111

// Menu items in the view queue dialog
#define ID_PRINTER_START               120
// DFM_CMD_PROPERTIES is -5
#define ID_PRINTER_PROPERTIES          (ID_PRINTER_START-5)

#define ID_DOCUMENT_PAUSE              130
#define ID_DOCUMENT_RESUME             131
#define ID_DOCUMENT_DELETE             132

#define ID_VIEW_STATUSBAR              140
#define ID_VIEW_TOOLBAR                141
#define ID_VIEW_REFRESH                142

#define ID_HELP_CONTENTS               150
#define ID_HELP_ABOUT                  151

// Help string ID's for printer/control folder
#define IDS_MH_PRINTOBJ_OPEN            (IDS_MH_PRINTFIRST+ID_PRINTOBJ_OPEN)
#define IDS_MH_PRINTOBJ_RESUME          (IDS_MH_PRINTFIRST+ID_PRINTOBJ_RESUME)
#define IDS_MH_PRINTOBJ_PAUSE           (IDS_MH_PRINTFIRST+ID_PRINTOBJ_PAUSE)
#define IDS_MH_PRINTOBJ_PURGE           (IDS_MH_PRINTFIRST+ID_PRINTOBJ_PURGE)
#define IDS_MH_PRINTOBJ_SETDEFAULT      (IDS_MH_PRINTFIRST+ID_PRINTOBJ_SETDEFAULT)

// Resources for the WinNT Format & Chkdsk Dialogs

#define IDC_GROUPBOX_1                  0x1202

#define DLG_FORMATDISK                  0x7000

#define IDC_CAPCOMBO                    (DLG_FORMATDISK + 1)
#define IDC_QFCHECK                     (DLG_FORMATDISK + 2)
#define IDC_ECCHECK                     (DLG_FORMATDISK + 3)
#define IDC_BLOCKSIZE                   (DLG_FORMATDISK + 4)
#define IDC_FSCOMBO                     (DLG_FORMATDISK + 5)
#define IDC_FMTPROGRESS                 (DLG_FORMATDISK + 6)
#define IDC_VLABEL                      (DLG_FORMATDISK + 7)
#define IDC_ASCOMBO                     (DLG_FORMATDISK + 8)
#define IDC_BTCHECK                     (DLG_FORMATDISK + 9)

#define DLG_FORMATDISK_FIRSTCONTROL     (DLG_FORMATDISK + 1)
#define DLG_FORMATDISK_NUMCONTROLS      (9)

#define IDS_FORMATFAILED                (DLG_FORMATDISK + 10)
#define IDS_INCOMPATIBLEFS              (DLG_FORMATDISK + 11)
#define IDS_ACCESSDENIED                (DLG_FORMATDISK + 12)
#define IDS_WRITEPROTECTED              (DLG_FORMATDISK + 13)
#define IDS_CANTLOCK                    (DLG_FORMATDISK + 14)
#define IDS_CANTQUICKFORMAT             (DLG_FORMATDISK + 15)
#define IDS_IOERROR                     (DLG_FORMATDISK + 16)
#define IDS_BADLABEL                    (DLG_FORMATDISK + 17)
#define IDS_INCOMPATIBLEMEDIA           (DLG_FORMATDISK + 18)
#define IDS_FORMATCOMPLETE              (DLG_FORMATDISK + 19)
#define IDS_CANTCANCELFMT               (DLG_FORMATDISK + 20)
#define IDS_FORMATCANCELLED             (DLG_FORMATDISK + 21)
#define IDS_OKTOFORMAT                  (DLG_FORMATDISK + 22)
#define IDS_CANTENABLECOMP              (DLG_FORMATDISK + 23)

// these are required for uncode\format.c

// These must be in sequence
#define IDS_FMT_MEDIA0                  (DLG_FORMATDISK + 32)
#define IDS_FMT_MEDIA1                  (DLG_FORMATDISK + 33)
#define IDS_FMT_MEDIA2                  (DLG_FORMATDISK + 34)
#define IDS_FMT_MEDIA3                  (DLG_FORMATDISK + 35)
#define IDS_FMT_MEDIA4                  (DLG_FORMATDISK + 36)
#define IDS_FMT_MEDIA5                  (DLG_FORMATDISK + 37)
#define IDS_FMT_MEDIA6                  (DLG_FORMATDISK + 38)
#define IDS_FMT_MEDIA7                  (DLG_FORMATDISK + 39)
#define IDS_FMT_MEDIA8                  (DLG_FORMATDISK + 40)
#define IDS_FMT_MEDIA9                  (DLG_FORMATDISK + 41)
#define IDS_FMT_MEDIA10                 (DLG_FORMATDISK + 42)
#define IDS_FMT_MEDIA11                 (DLG_FORMATDISK + 43)
#define IDS_FMT_UNUSED                  (DLG_FORMATDISK + 44)
#define IDS_FMT_MEDIA13                 (DLG_FORMATDISK + 45)
#define IDS_FMT_MEDIA14                 (DLG_FORMATDISK + 46)
#define IDS_FMT_MEDIA15                 (DLG_FORMATDISK + 47)
#define IDS_FMT_MEDIA16                 (DLG_FORMATDISK + 48)
#define IDS_FMT_MEDIA17                 (DLG_FORMATDISK + 49)
#define IDS_FMT_MEDIA18                 (DLG_FORMATDISK + 50)
#define IDS_FMT_MEDIA19                 (DLG_FORMATDISK + 51)
#define IDS_FMT_MEDIA20                 (DLG_FORMATDISK + 52)
#define IDS_FMT_MEDIA21                 (DLG_FORMATDISK + 53)
#define IDS_FMT_MEDIA22                 (DLG_FORMATDISK + 54)

// Japanese specific device types. These also must be in sequence.
#define IDS_FMT_MEDIA_J0                (DLG_FORMATDISK + 80)
#define IDS_FMT_MEDIA_J1                (DLG_FORMATDISK + 81)
#define IDS_FMT_MEDIA_J2                (DLG_FORMATDISK + 82)
#define IDS_FMT_MEDIA_J3                (DLG_FORMATDISK + 83)
#define IDS_FMT_MEDIA_J4                (DLG_FORMATDISK + 84)
#define IDS_FMT_MEDIA_J5                (DLG_FORMATDISK + 85)
#define IDS_FMT_MEDIA_J6                (DLG_FORMATDISK + 86)
#define IDS_FMT_MEDIA_J7                (DLG_FORMATDISK + 87)
#define IDS_FMT_MEDIA_J8                (DLG_FORMATDISK + 88)
#define IDS_FMT_MEDIA_J9                (DLG_FORMATDISK + 89)
#define IDS_FMT_MEDIA_J10               (DLG_FORMATDISK + 90)
#define IDS_FMT_MEDIA_J11               (DLG_FORMATDISK + 91)
#define IDS_FMT_UNUSED_J                (DLG_FORMATDISK + 92)
#define IDS_FMT_MEDIA_J13               (DLG_FORMATDISK + 93)
#define IDS_FMT_MEDIA_J14               (DLG_FORMATDISK + 94)
#define IDS_FMT_MEDIA_J15               (DLG_FORMATDISK + 95)
#define IDS_FMT_MEDIA_J16               (DLG_FORMATDISK + 96)
#define IDS_FMT_MEDIA_J17               (DLG_FORMATDISK + 97)
#define IDS_FMT_MEDIA_J18               (DLG_FORMATDISK + 98)
#define IDS_FMT_MEDIA_J19               (DLG_FORMATDISK + 99)
#define IDS_FMT_MEDIA_J20               (DLG_FORMATDISK + 100)
#define IDS_FMT_MEDIA_J21               (DLG_FORMATDISK + 101)
#define IDS_FMT_MEDIA_J22               (DLG_FORMATDISK + 102)

#ifdef DBCS
// Following definitions were just re-defined,
// because some media types were added. See above IDS_FMT_MEDIA*.
#define IDS_FMT_ALLOC0                  (DLG_FORMATDISK + 60)
#define IDS_FMT_ALLOC1                  (DLG_FORMATDISK + 61)
#define IDS_FMT_ALLOC2                  (DLG_FORMATDISK + 62)
#define IDS_FMT_ALLOC3                  (DLG_FORMATDISK + 63)
#define IDS_FMT_ALLOC4                  (DLG_FORMATDISK + 64)

#define IDS_FMT_CAPUNKNOWN              (DLG_FORMATDISK + 65)
#define IDS_FMT_KB                      (DLG_FORMATDISK + 66)
#define IDS_FMT_MB                      (DLG_FORMATDISK + 67)
#define IDS_FMT_GB                      (DLG_FORMATDISK + 68)
#define IDS_FMT_FORMATTING              (DLG_FORMATDISK + 69)
#define IDS_FMT_FORMAT                  (DLG_FORMATDISK + 70)
#define IDS_FMT_CANCEL                  (DLG_FORMATDISK + 71)
#define IDS_FMT_CLOSE                   (DLG_FORMATDISK + 72)
#else // DBCS
#define IDS_FMT_ALLOC0                  (DLG_FORMATDISK + 60)
#define IDS_FMT_ALLOC1                  (DLG_FORMATDISK + 61)
#define IDS_FMT_ALLOC2                  (DLG_FORMATDISK + 62)
#define IDS_FMT_ALLOC3                  (DLG_FORMATDISK + 63)
#define IDS_FMT_ALLOC4                  (DLG_FORMATDISK + 64)

#define IDS_FMT_CAPUNKNOWN              (DLG_FORMATDISK + 65)
#define IDS_FMT_KB                      (DLG_FORMATDISK + 66)
#define IDS_FMT_MB                      (DLG_FORMATDISK + 67)
#define IDS_FMT_GB                      (DLG_FORMATDISK + 68)
#define IDS_FMT_FORMATTING              (DLG_FORMATDISK + 69)
#define IDS_FMT_FORMAT                  (DLG_FORMATDISK + 70)
#define IDS_FMT_CANCEL                  (DLG_FORMATDISK + 71)
#define IDS_FMT_CLOSE                   (DLG_FORMATDISK + 72)
#endif // DBCS

#define DLG_CHKDSK                      0x7080

#define IDC_FIXERRORS                   (DLG_CHKDSK + 1)
#define IDC_RECOVERY                    (DLG_CHKDSK + 2)
#define IDC_CHKDSKPROGRESS              (DLG_CHKDSK + 3)

#define IDS_CHKDSKCOMPLETE              (DLG_CHKDSK + 4)
#define IDS_CHKDSKFAILED                (DLG_CHKDSK + 5)
#define IDS_CHKDSKCANCELLED             (DLG_CHKDSK + 6)
#define IDS_CANTCANCELCHKDSK            (DLG_CHKDSK + 7)

#define IDC_PHASE                       (DLG_CHKDSK + 8)

#define IDS_CHKACCESSDENIED             (DLG_CHKDSK + 9)
#define IDS_CHKONREBOOT                 (DLG_CHKDSK + 10)

#define IDS_CHKINPROGRESS               (DLG_CHKDSK + 11)
#define IDS_CHKDISK                     (DLG_CHKDSK + 12)
#define IDS_CHKPHASE                    (DLG_CHKDSK + 13)

// Resources for common program groups/items
#define IDS_CSIDL_CSTARTMENU_L          0x7100
#define IDS_CSIDL_CSTARTMENU_S          0x7101
#define IDS_CSIDL_CPROGRAMS_L           0x7102
#define IDS_CSIDL_CPROGRAMS_S           0x7103
#define IDS_CSIDL_CSTARTUP_L            0x7104
#define IDS_CSIDL_CSTARTUP_S            0x7105
#define IDS_CSIDL_CDESKTOPDIRECTORY_L   0x7106
#define IDS_CSIDL_CDESKTOPDIRECTORY_S   0x7107
#define IDS_CSIDL_CFAVORITES_L          0x7108
#define IDS_CSIDL_CFAVORITES_S          0x7109
#define IDS_CSIDL_CAPPDATA_L            0x710a
#define IDS_CSIDL_CAPPDATA_S            0x710b

// strings for file/folder property sheet
#define IDS_READONLY                    0x7110
#define IDS_NOTREADONLY                 0x7111
#define IDS_HIDE                        0x7112
#define IDS_UNHIDE                      0x7113
#define IDS_ARCHIVE                     0x7114
#define IDS_UNARCHIVE                   0x7115
#define IDS_INDEX                       0x7116
#define IDS_DISABLEINDEX                0x7117
#define IDS_COMPRESS                    0x7118
#define IDS_UNCOMPRESS                  0x7119
#define IDS_ENCRYPT                     0x711a
#define IDS_DECRYPT                     0x711b

#define IDS_UNKNOWNAPPLICATION          0x711c
#define IDS_DESCRIPTION                 0x711d

#define IDS_APPLYINGATTRIBS             0x711e
#define IDS_CALCULATINGSIZE             0x711f
#define IDS_APPLYINGATTRIBSTO           0x7120
#define IDS_THISFOLDER                  0x7121
#define IDS_THESELECTEDITEMS            0x7122
#define IDS_OPENSWITH                   0x7123
#define IDS_SUPERHIDDENWARNING          0x7124
#define IDS_THISVOLUME                  0x7125

// shared documents
#define IDS_SHAREDMUSIC                 0x7143
#define IDS_SHAREDVIDEO                 0x7144
#define IDS_SHAREDPICTURES              0x7145

#define IDS_USERSPICTURES               0x7146
#define IDS_USERSMUSIC                  0x7147
#define IDS_USERSVIDEO                  0x7148
#define IDS_USERSDOCUMENTS              0x7149

#define IDS_SAMPLEPICTURES              0x714A
#define IDS_SAMPLEMUSIC                 0x714B

#define IDS_MYWEBDOCUMENTS              0x7150

#define IDS_NETCONNECTFAILED_TITLE      0x7200
#define IDS_NETCONNECTFAILED_MESSAGE    0x7201

// string for find computer stuff (used by netviewx.c)
#define IDS_FC_NAME                     0x7203

// string for find computer (from my net places context menu)
#define IDS_NETWORKROOT_FIND            0x7204

#define IDS_LINEBREAK_REMOVE            0x72A0
#define IDS_LINEBREAK_PRESERVE          0x72A1

//  Strings used in DLG_FSEARCH_xxx, DLG_PSEARCH and DLG_CSEARCH dialogs
#define IDS_FSEARCH_FIRST               0x7300
#define IDS_FSEARCH_CAPTION             (IDS_FSEARCH_FIRST+0)
#define IDS_FSEARCH_TBLABELS            (IDS_FSEARCH_FIRST+1)
#define IDS_FSEARCH_MODIFIED_DATE       (IDS_FSEARCH_FIRST+2)
#define IDS_FSEARCH_CREATION_DATE       (IDS_FSEARCH_FIRST+3)
#define IDS_FSEARCH_ACCESSED_DATE       (IDS_FSEARCH_FIRST+4)
#define IDS_FSEARCH_SIZE_EQUAL          (IDS_FSEARCH_FIRST+5)
#define IDS_FSEARCH_SIZE_GREATEREQUAL   (IDS_FSEARCH_FIRST+6)
#define IDS_FSEARCH_SIZE_LESSEREQUAL    (IDS_FSEARCH_FIRST+7)

#define IDS_FSEARCH_CI_READY            (IDS_FSEARCH_FIRST+12)  // CI status text
#define IDS_FSEARCH_CI_READY_LINK       (IDS_FSEARCH_FIRST+13)  // CI link caption
#define IDS_FSEARCH_CI_BUSY             (IDS_FSEARCH_FIRST+14)  // CI status text
#define IDS_FSEARCH_CI_BUSY_LINK        (IDS_FSEARCH_FIRST+15)  // CI link caption
#define IDS_FSEARCH_CI_DISABLED         (IDS_FSEARCH_FIRST+16)  // status text
#define IDS_FSEARCH_CI_DISABLED_LINK    (IDS_FSEARCH_FIRST+17)  // link caption
#define IDS_FSEARCH_CI_STATUSFMT        (IDS_FSEARCH_FIRST+18)  // CI status formatting template
#define IDS_FSEARCH_INVALIDFOLDER_FMT   (IDS_FSEARCH_FIRST+19)  // '%s' is an invalid folder name
#define IDS_FSEARCH_EMPTYFOLDER         (IDS_FSEARCH_FIRST+20)  // You must enter a valid folder name.
#define IDS_FSEARCH_CI_DISABLED_WARNING (IDS_FSEARCH_FIRST+21)  // Can't do the query; CI is disabled.
#define IDS_FSEARCH_SEARCHLINK_FILES    (IDS_FSEARCH_FIRST+22)
#define IDS_FSEARCH_SEARCHLINK_COMPUTERS (IDS_FSEARCH_FIRST+23)
#define IDS_FSEARCH_SEARCHLINK_PRINTERS (IDS_FSEARCH_FIRST+24)
#define IDS_FSEARCH_SEARCHLINK_PEOPLE   (IDS_FSEARCH_FIRST+25)
#define IDS_FSEARCH_SEARCHLINK_INTERNET (IDS_FSEARCH_FIRST+26)
#define IDS_FSEARCH_SEARCHLINK_OPTIONS  (IDS_FSEARCH_FIRST+27)
#define IDS_FSEARCH_SEARCHLINK_PREVIOUS (IDS_FSEARCH_FIRST+28)
#define IDS_FSEARCH_GROUPBTN_OPTIONS    (IDS_FSEARCH_FIRST+29)
#define IDS_FINDVIEWEMPTYINIT           (IDS_FSEARCH_FIRST+30)
#define IDS_FINDVIEWEMPTYBUSY           (IDS_FSEARCH_FIRST+31)
#define IDS_FSEARCH_NEWINFOTIP          (IDS_FSEARCH_FIRST+32)
#define IDS_FSEARCH_HELPINFOTIP         (IDS_FSEARCH_FIRST+33)
#define IDS_CSEARCH_NEWINFOTIP          (IDS_FSEARCH_FIRST+34)
#define IDS_CSEARCH_HELPINFOTIP         (IDS_FSEARCH_FIRST+35)
#define IDS_FSEARCH_BANDCAPTION         (IDS_FSEARCH_FIRST+36)
#define IDS_FSEARCH_BANDWIDTH           (IDS_FSEARCH_FIRST+37)
#define IDS_DOCFIND_CONSTRAINT          (IDS_FSEARCH_FIRST+38)
#define IDS_DOCFIND_SCOPEERROR          (IDS_FSEARCH_FIRST+39)
#define IDS_DOCFIND_PATHNOTFOUND        (IDS_FSEARCH_FIRST+41)
#define IDS_FSEARCH_CI_ENABLED          (IDS_FSEARCH_FIRST+42)  // status text
#define IDS_FSEARCH_CI_ENABLED_LINK     (IDS_FSEARCH_FIRST+43)  // link caption
#define IDS_FSEARCH_STARTSTOPWIDTH      (IDS_FSEARCH_FIRST+44)  // width, in DBU, of start, stop buttons.
#define IDS_DOCFIND_CI_NOT_CASE_SEN     (IDS_FSEARCH_FIRST+45)  // ci is not case sensitive

#define IDS_LINKWINDOW_DEFAULTACTION    0x73FE
#define IDS_GROUPBTN_DEFAULTACTION      0x73FF

#define IDS_DD_FIRST                    0x7400
#define IDS_DD_COPY                     (IDS_DD_FIRST + DDIDM_COPY)
#define IDS_DD_MOVE                     (IDS_DD_FIRST + DDIDM_MOVE)
#define IDS_DD_LINK                     (IDS_DD_FIRST + DDIDM_LINK)
#define IDS_DD_SCRAP_COPY               (IDS_DD_FIRST + DDIDM_SCRAP_COPY)
#define IDS_DD_SCRAP_MOVE               (IDS_DD_FIRST + DDIDM_SCRAP_MOVE)
#define IDS_DD_DOCLINK                  (IDS_DD_FIRST + DDIDM_DOCLINK)
#define IDS_DD_CONTENTS_COPY            (IDS_DD_FIRST + DDIDM_CONTENTS_COPY)
#define IDS_DD_CONTENTS_MOVE            (IDS_DD_FIRST + DDIDM_CONTENTS_MOVE)
#define IDS_DD_SYNCCOPY                 (IDS_DD_FIRST + DDIDM_SYNCCOPY)
#define IDS_DD_SYNCCOPYTYPE             (IDS_DD_FIRST + DDIDM_SYNCCOPYTYPE)
#define IDS_DD_CONTENTS_LINK            (IDS_DD_FIRST + DDIDM_CONTENTS_LINK)
#define IDS_DD_CONTENTS_DESKCOMP        (IDS_DD_FIRST + DDIDM_CONTENTS_DESKCOMP)
#define IDS_DD_CONTENTS_DESKIMG         (IDS_DD_FIRST + DDIDM_CONTENTS_DESKIMG)
#define IDS_DD_OBJECT_COPY              (IDS_DD_FIRST + DDIDM_OBJECT_COPY)
#define IDS_DD_OBJECT_MOVE              (IDS_DD_FIRST + DDIDM_OBJECT_MOVE)
#define IDS_DD_CONTENTS_DESKURL         (IDS_DD_FIRST + DDIDM_CONTENTS_DESKURL)

// Strings for openwith dialog
#define IDS_OPENWITH_RECOMMENDED        0x7500
#define IDS_OPENWITH_OTHERS             0x7501

// strings for folder customization tab
#define IDS_CUSTOMIZE_DOCUMENTS         0x7520
#define IDS_CUSTOMIZE_PICTURES          0x7521
#define IDS_CUSTOMIZE_PHOTOALBUM        0x7522
#define IDS_CUSTOMIZE_MUSIC             0x7523
#define IDS_CUSTOMIZE_MUSICARTIST       0x7524
#define IDS_CUSTOMIZE_MUSICALBUM        0x7525
#define IDS_CUSTOMIZE_VIDEOS            0x7526
#define IDS_CUSTOMIZE_VIDEOALBUM        0x7527
#define IDS_CUSTOMIZE_BOOKS             0x7528
#define IDS_CUSTOMIZE                   0x7529
#define IDS_CUSTOMIZE_GENERATING        0x752A
#define IDS_CUSTOMIZE_USELEGACYHTT      0x752B
#define IDS_CUSTOMIZE_TURNONWEBVIEW     0x752C

// IDS_ strings defined in unicpp\resource.h use range 0x7600-0x76FF

// Strings for StartMenu.Settings.TaskbarAndStartMenu.Advanced options
#define IDS_ADV_STARTMENU_StartMenuSettings     30464 // 0x7700
#define IDS_ADV_STARTMENU_StartMenuIntelli      30465
#define IDS_ADV_STARTMENU_StartMenuFavorites    30466
#define IDS_ADV_STARTMENU_StartMenuLogoff       30467
#define IDS_ADV_STARTMENU_CascadeControlPanel   30468
#define IDS_ADV_STARTMENU_CascadeMyDocuments    30469
#define IDS_ADV_STARTMENU_CascadePrinters       30470
#define IDS_ADV_STARTMENU_StartMenuScrollPrograms 30471
#define IDS_ADV_STARTMENU_CascadeMyPictures     30472
#define IDS_ADV_STARTMENU_CascadeNetConnect     30473
#define IDS_ADV_STARTMENU_StartMenuRun          30474
#define IDS_ADV_STARTMENU_StartMenuChange       30475
#define IDS_ADV_STARTMENU_StartMenuAdminTools   30476 // 0x770C
#define IDS_ADV_STARTMENU_StartMenuSmallIcons   30477 // 0x770D
#define IDS_ADV_STARTMENU_StartPanelATBoth      30478
#define IDS_ADV_STARTMENU_StartPanelATMenu      30479
#define IDS_ADV_STARTMENU_StartPanelShowMyComp  30480 
#define IDS_ADV_STARTMENU_StartPanelShowNetPlaces 30481
#define IDS_ADV_STARTMENU_StartPanelShowNetConn 30482
#define IDS_ADV_STARTMENU_StartPanelShowRun     30483
#define IDS_ADV_STARTMENU_StartPanelFavorites   30484
#define IDS_ADV_STARTMENU_StartPanelShowMyDocs  30485
#define IDS_ADV_STARTMENU_StartPanelShowMyPics  30486  
#define IDS_ADV_STARTMENU_StartPanelShowMyMusic 30487
#define IDS_ADV_STARTMENU_StartPanelShowControlPanel 30488
#define IDS_ADV_STARTMENU_StartPanelShowHelp    30489
#define IDS_ADV_STARTMENU_StartPanelOpen        30490
#define IDS_ADV_STARTMENU_StartPanelMenu        30491    
#define IDS_ADV_STARTMENU_StartPanelHide        30492 // 0x771C
#define IDS_ADV_STARTMENU_StartPanelShowPrinters 30493 // 0x771D
#define IDS_ADV_STARTMENU_StartPanelNetConOpen  30494
#define IDS_ADV_STARTMENU_StartPanelNetConMenu  30495
#define IDS_ADV_STARTMENU_StartPanelShowSearch  30496

// Strings for Folder.Options.Advanced options
#define IDS_ADV_FOLDER_SHOWCONTROLPANEL         30497
#define IDS_ADV_FOLDER_FileFolder               30498
#define IDS_ADV_FOLDER_HiddenFiles              30499
#define IDS_ADV_FOLDER_ShowAll                  30500
#define IDS_ADV_FOLDER_NoHidden                 30501
#define IDS_ADV_FOLDER_ShowInfoTip              30502
#define IDS_ADV_FOLDER_HideFileExt              30503
#define IDS_ADV_FOLDER_DESC_ShowFullPath        30504
#define IDS_ADV_FOLDER_ShowFullPathAddress      30505
#define IDS_ADV_FOLDER_ClassicViewState         30506
#define IDS_ADV_FOLDER_DesktopProcess           30507
#define IDS_ADV_FOLDER_SuperHidden              30508
#define IDS_ADV_FOLDER_NetCrawl                 30509
#define IDS_ADV_FOLDER_WebViewBarricade         30510
#define IDS_ADV_FOLDER_FriendlyTree             30511
#define IDS_ADV_FOLDER_ShowCompColor            30512 // 0x7730
#define IDS_ADV_FOLDER_PersistBrowsers          30513
#define IDS_ADV_FOLDER_FolderSizeTip            30514

#define IDS_ADV_STARTMENU_StartPanelAdminTools  30515
#define IDS_ADV_STARTMENU_StartPanelOEMLink     30516
#define IDS_ADV_FOLDER_ThumbnailCache           30517
#define IDS_ADV_FOLDER_SimpleSharing            30518

#define IDS_SEARCH_RESULTS                      30520
#define IDS_SEARCH_RESULTS_COMPTUER             30521
//#define unused                                30522
//#define unused                                30523
//#define unused                                30524

#define IDS_VFX_TaskbarAnimations               30530
#define IDS_VFX_CursorShadow                    30531
#define IDS_VFX_DropShadow                      30532
#define IDS_VFX_DragFullWindows                 30533
#define IDS_VFX_AnimateMinMax                   30534
#define IDS_VFX_FontSmoothing                   30535
#define IDS_VFX_MenuAnimation                   30536
#define IDS_VFX_WebView                         30537
#define IDS_VFX_Themes                          30538
#define IDS_VFX_ComboBoxAnimation               30539
#define IDS_VFX_ListviewAlphaSelect             30540
#define IDS_VFX_ListviewShadowText              30541
//#define unused                                30542
#define IDS_VFX_ListviewFolderwatermarks        30543
#define IDS_VFX_ListBoxSmoothScrolling          30544

#define IDS_VFX_SelectionFade                   30546
#define IDS_VFX_TooltipAnimation                30547
//#define unused                                30548
//#define unused                                30549
#define IDS_VFX_TaskbarFade                     30550

// The following are the StartMenu Prepopulated links and their targets.
//
// Note #1:This list has only items provided by MSFT; Oem provided items will be merged 
// by setup manager when Factory.exe is run.
//
#define IDS_MSFT_LINK_0                         31150
#define IDS_MSFT_LINK_1                         31151
#define IDS_MSFT_LINK_2                         31152
#define IDS_MSFT_LINK_3                         31153
#define IDS_MSFT_LINK_4                         31154
#define IDS_MSFT_LINK_5                         31155
#define IDS_MSFT_LINK_6                         31156
#define IDS_MSFT_LINK_7                         31157
#define IDS_MSFT_LINK_8                         31158

#define IDS_MSFT_SRV_0                          31159
#define IDS_MSFT_SRV_1                          31160
#define IDS_MSFT_SRV_2                          31161
#define IDS_MSFT_SRV_3                          31162
#define IDS_MSFT_SRV_4                          31163
#define IDS_MSFT_SRV_5                          31164
#define IDS_MSFT_SRV_6                          31165
#define IDS_MSFT_SRV_7                          31166
#define IDS_MSFT_SRV_8                          31167

// Web View sizing string.  This allows the task area to be sized larger
// by 0 to 30%

#define IDS_SIZE_INCREASE_PERCENTAGE            31227

// Web View default action strings

#define IDS_EXPANDO_DEFAULT_ACTION_COLLAPSE     31228
#define IDS_EXPANDO_DEFAULT_ACTION_EXPAND       31229

// Web View Task strings

#define IDS_HEADER_MYCOMPUTER           0x7a00
#define IDS_HEADER_FILEFOLDER           0x7a01
#define IDS_HEADER_FILEFOLDER_TT        0x7a02
#define IDS_HEADER_ITEMFOLDER           0x7a03
#define IDS_TASK_CURFOLDER_NEWFOLDER    0x7A04
#define IDS_TASK_CURFOLDER_NEWFOLDER_TT 0x7A05
//#define IDS_TASK_CURFOLDER_COPY         0x7A06
#define IDS_TASK_CURFOLDER_COPY_TT      0x7A07
//#define IDS_TASK_CURFOLDER_PUBLISH      0x7A08
#define IDS_TASK_CURFOLDER_PUBLISH_TT   0x7A09
#define IDS_TASK_RENAME_FILE            0x7A0a
#define IDS_TASK_RENAME_FILE_TT         0x7A0b
#define IDS_TASK_MOVE_FILE              0x7A0c
#define IDS_TASK_MOVE_TT                0x7A0d
#define IDS_TASK_COPY_FILE              0x7A0e
#define IDS_TASK_COPY_TT                0x7A0f
#define IDS_TASK_PUBLISH_FILE           0x7A10
#define IDS_TASK_PUBLISH_TT             0x7A11
#define IDS_TASK_PRINT_FILE             0x7A12
#define IDS_TASK_PRINT_TT               0x7A13
#define IDS_TASK_DELETE_FILE            0x7A14
#define IDS_TASK_DELETE_TT              0x7A15
#define IDS_TASK_RENAME_FOLDER          0x7A16
#define IDS_TASK_MOVE_FOLDER            0x7A18
#define IDS_TASK_COPY_FOLDER            0x7A1a
#define IDS_TASK_PUBLISH_FOLDER         0x7A1c
#define IDS_TASK_DELETE_FOLDER          0x7A1e
#define IDS_TASK_MOVE_ITEMS             0x7A20
#define IDS_TASK_COPY_ITEMS             0x7A22
#define IDS_TASK_PUBLISH_ITEMS          0x7A24
#define IDS_TASK_DELETE_ITEMS           0x7A26
#define IDS_HEADER_OTHER_PLACES         0x7A28
#define IDS_HEADER_OTHER_PLACES_TT      0x7A29
#define IDS_HEADER_DETAILS              0x7A2a
#define IDS_HEADER_DETAILS_TT           0x7A2b
#define IDS_HEADER_MUSIC                0x7A2c
#define IDS_HEADER_MUSIC_TT             0x7A2d
#define IDS_TASK_PLAYALL                0x7A2e
#define IDS_TASK_PLAY                   0x7A2f
#define IDS_TASK_PLAY_TT                0x7A30
#define IDS_TASK_SHOPFORMUSICONLINE     0x7A31
#define IDS_TASK_SHOPFORMUSICONLINE_TT  0x7A32
#define IDS_HEADER_PICTURES             0x7A33
#define IDS_HEADER_PICTURES_TT          0x7A34
#define IDS_TASK_GETFROMCAMERA          0x7A35
#define IDS_TASK_GETFROMCAMERA_TT       0x7A36
#define IDS_TASK_SLIDESHOW              0x7A37
#define IDS_TASK_SLIDESHOW_TT           0x7A38
#define IDS_TASK_SETASWALLPAPER         0x7A39
#define IDS_TASK_SETASWALLPAPER_TT      0x7A3a
#define IDS_HEADER_MYCOMPUTER_TT        0x7A3b
#define IDS_TASK_SEARCHFORFILES         0x7A3c
#define IDS_TASK_SEARCHFORFILES_TT      0x7A3d
#define IDS_TASK_MYCOMPUTER_SYSTEMPROPERTIES    0x7A3e
#define IDS_TASK_MYCOMPUTER_SYSTEMPROPERTIES_TT 0x7A3f

// Web wizard host strings - really shouldn't have been here but went in while the above and below went in. oops
#define IDS_WEBDLG_TITLE                0x7A40
#define IDS_WEBDLG_SUBTITLE             0x7A41
#define IDS_WEBDLG_ERRTITLE             0x7A42
#define IDS_WEBDLG_ERRSUBTITLE          0x7A43

// Web View Task Strings
#define IDS_TASK_CHANGESETTINGS         0x7A50
#define IDS_TASK_ORDERPRINTS            0x7A51
#define IDS_TASK_ORDERPRINTS_TT         0x7A52
#define IDS_TASK_PRINT_PICTURES         0x7A53
#define IDS_TASK_PRINT_PICTURES_TT      0x7A54
#define IDS_HEADER_DEFVIEW_BLOCKADE     0x7A55
#define IDS_HEADER_DEFVIEW_BLOCKADE_TT  0x7A56
#define IDS_TASK_DEFVIEW_VIEWCONTENTS_DRIVE     0x7A57
#define IDS_TASK_DEFVIEW_VIEWCONTENTS_DRIVE_TT  0x7A58
#define IDS_TASK_DEFVIEW_HIDECONTENTS_DRIVE     0x7A59
#define IDS_TASK_DEFVIEW_HIDECONTENTS_DRIVE_TT  0x7A5a
#define IDS_TASK_DEFVIEW_VIEWCONTENTS_FOLDER    0x7A5b
#define IDS_TASK_DEFVIEW_VIEWCONTENTS_FOLDER_TT 0x7A5c
#define IDS_TASK_DEFVIEW_HIDECONTENTS_FOLDER    0x7A5d
#define IDS_TASK_DEFVIEW_HIDECONTENTS_FOLDER_TT 0x7A5e
#define IDS_TASK_ARP                    0x7A5f
#define IDS_TASK_ARP_TT                 0x7A60
#define IDS_HEADER_BITBUCKET            0x7A61
#define IDS_HEADER_BITBUCKET_TT         0x7A62
#define IDS_TASK_EMPTYRECYCLEBIN        0x7A63
#define IDS_TASK_EMPTYRECYCLEBIN_TT     0x7A64
#define IDS_TASK_RESTORE_ALL            0x7A65
#define IDS_TASK_RESTORE_ITEM           0x7A66
#define IDS_TASK_RESTORE_ITEMS          0x7A67
#define IDS_TASK_RESTORE_TT             0x7A68
#define IDS_HEADER_BRIEFCASE            0x7A69
#define IDS_HEADER_BRIEFCASE_TT         0x7A6a
#define IDS_TASK_UPDATE_ALL             0x7A6b
#define IDS_TASK_UPDATE_ITEM            0x7A6c
#define IDS_TASK_UPDATE_ITEMS           0x7A6d
#define IDS_TASK_UPDATE_ITEM_TT         0x7A6e
#define IDS_HEADER_MYNETPLACES          0x7A6f
#define IDS_HEADER_MYNETPLACES_TT       0x7A70
#define IDS_TASK_VIEWNETCONNECTIONS     0x7A71
#define IDS_TASK_VIEWNETCONNECTIONS_TT  0x7A72
#define IDS_TASK_ADDNETWORKPLACE        0x7A73
#define IDS_TASK_ADDNETWORKPLACE_TT     0x7A74
#define IDS_TASK_HOMENETWORKWIZARD      0x7A75
#define IDS_TASK_HOMENETWORKWIZARD_TT   0x7A76
#define IDS_TASK_COMPUTERSNEARME        0x7A77
#define IDS_TASK_COPYTOCD               0x7A78
#define IDS_HEADER_CDBURN               0x7A79
#define IDS_HEADER_CDBURN_TT            0x7A7a
#define IDS_TASK_BURNCD                 0x7A7b
#define IDS_TASK_BURNCD_TT              0x7A7c
#define IDS_TASK_CLEARBURNAREA          0x7A7d
#define IDS_TASK_CLEARBURNAREA_TT       0x7A7e
#define IDS_TASK_ERASECDFILES           0x7A7f
#define IDS_TASK_ERASECDFILES_TT        0x7A80
#define IDS_TASK_CHANGESETTINGS_TT      0x7A81
#define IDS_TASK_EMAIL_ITEMS            0x7A82
#define IDS_COLONSEPERATED              0x7A83
#define IDS_NSELECTED                   0x7A84
#define IDS_TOTALFILESIZE               0x7A85
#define IDS_HEADER_SEARCH               0x7A86
#define IDS_HEADER_FIND_TT              0x7A87
#define IDS_TASK_OPENCONTAININGFOLDER   0x7A88
#define IDS_TASK_OPENCONTAININGFOLDER_TT 0x7A89
#define IDS_TASK_EMAIL_FILE             0x7A8a
#define IDS_TASK_EMAIL_TT               0x7A8b
#define IDS_TASK_COPYTOAUDIOCD          0x7A8c
#define IDS_TASK_COPYTOAUDIOCD_TT       0x7A8d
#define IDS_TASK_SHARE_FOLDER           0x7A8e
#define IDS_TASK_SHARE_TT               0x7A8f
#define IDS_TASK_EJECTDISK_TT           0x7A90
#define IDS_TASK_COMPUTERSNEARME_TT     0x7A91
#define IDS_TASK_COPYTOAUDIOCDALL       0x7A92
#define IDS_TASK_COPYTOCDALL            0x7A93
#define IDS_TASK_EMAIL_FOLDER           0x7A94
// unused                               0x7A95
#define IDS_TASK_EJECTDISK              0x7A96
#define IDS_TASK_COPYTOCD_TT            0x7A97
#define IDS_TASK_RENAME_ITEM            0x7A98
#define IDS_TASK_MOVE_ITEM              0x7A99
#define IDS_TASK_COPY_ITEM              0x7A9A
#define IDS_TASK_DELETE_ITEM            0x7A9B
#define IDS_TASK_RENAME_ITEM_TT         0x7A9C
#define IDS_HEADER_ITEMFOLDER_TT        0x7A9D
#define IDS_TASK_PRINT_PICTURE          0x7A9E
#define IDS_TASK_PRINT_PICTURE_FOLDER   0x7A9F
#define IDS_HEADER_COMMONDOCUMENTS      0x7AA0
#define IDS_HEADER_COMMONDOCUMENTS_TT   0x7AA1
#define IDS_TASK_COMMONDOCUMENTSHELP    0x7AA2
#define IDS_TASK_COMMONDOCUMENTSHELP_TT 0x7AA3
#define IDS_HEADER_VIDEOS               0x7AA4
#define IDS_HEADER_VIDEOS_TT            0x7AA5
#define IDS_TASK_PLAY_VIDEOS_TT         0x7AA6
#define IDS_TASK_SHOPFORPICTURESONLINE  0x7AA7
#define IDS_TASK_SHOPFORPICTURESONLINE_TT 0x7AA8
#define IDS_TASK_SEARCHDS               0x7AA9
#define IDS_TASK_SEARCHDS_TT            0x7AAA

// Put more Web View Task Strings above - please reserve space out to 0x7C00


// WebView static intro strings
#define IDS_INTRO_SHAREDDOCS            0x7C00
#define IDS_INTRO_SHAREDPICTURES        0x7C01
#define IDS_INTRO_SHAREDMUSIC           0x7C02
// unused                               0x7C03
// unused                               0x7C04
// unused                               0x7C05
// unused                               0x7C06
// unused                               0x7C07
#define IDS_INTRO_BARRICADED            0x7C08
// unused                               0x7C09
// unused                               0x7C0a
// unused                               0x7C0b
// unused                               0x7C0c
// unused                               0x7C0d
#define IDS_INTRO_STARTMENU             0x7C0e


#define IDS_CPCAT_ACCESSIBILITY_TITLE           0x7D00
#define IDS_CPCAT_ACCESSIBILITY_INFOTIP         0x7D01
#define IDS_CPCAT_ACCOUNTS_TITLE                0x7D02
#define IDS_CPCAT_ACCOUNTS_INFOTIP              0x7D03
#define IDS_CPCAT_APPEARANCE_TITLE              0x7D04
#define IDS_CPCAT_APPEARANCE_INFOTIP            0x7D05
#define IDS_CPCAT_ARP_TITLE                     0x7D06
#define IDS_CPCAT_ARP_INFOTIP                   0x7D07
#define IDS_CPCAT_HARDWARE_TITLE                0x7D08
#define IDS_CPCAT_HARDWARE_INFOTIP              0x7D09
#define IDS_CPCAT_NETWORK_TITLE                 0x7D0A
#define IDS_CPCAT_NETWORK_INFOTIP               0x7D0B
#define IDS_CPCAT_OTHERCPLS_TITLE               0x7D0C
#define IDS_CPCAT_OTHERCPLS_INFOTIP             0x7D0D
#define IDS_CPCAT_PERFMAINT_TITLE               0x7D0E
#define IDS_CPCAT_PERFMAINT_INFOTIP             0x7D0F
#define IDS_CPCAT_REGIONAL_TITLE                0x7D10
#define IDS_CPCAT_REGIONAL_INFOTIP              0x7D11
#define IDS_CPCAT_SOUNDS_TITLE                  0x7D12
#define IDS_CPCAT_SOUNDS_INFOTIP                0x7D13
#define IDS_CPCAT_ACCOUNTS_INFOTIP2             0x7D14

//
// Reserved for future categories   0x7D14 - 0x7D1F
//
#define IDS_CPTASK_SEEALSO_TITLE                0x7D20
#define IDS_CPTASK_SEEALSO_INFOTIP              0x7D21
#define IDS_CPTASK_TROUBLESHOOTER_TITLE         0x7D22
#define IDS_CPTASK_TROUBLESHOOTER_INFOTIP       0x7D23
#define IDS_CPTASK_HELPANDSUPPORT_TITLE         0x7D24
#define IDS_CPTASK_HELPANDSUPPORT_INFOTIP       0x7D25
#define IDS_CPTASK_WINDOWSUPDATE_TITLE          0x7D26
#define IDS_CPTASK_WINDOWSUPDATE_INFOTIP        0x7D27
#define IDS_CPTASK_THEME_TITLE                  0X7D28
#define IDS_CPTASK_THEME_INFOTIP                0X7D29
#define IDS_CPTASK_SCREENSAVER_TITLE            0X7D2A
#define IDS_CPTASK_SCREENSAVER_INFOTIP          0X7D2B
#define IDS_CPTASK_WALLPAPER_TITLE              0X7D2C
#define IDS_CPTASK_WALLPAPER_INFOTIP            0X7D2D
#define IDS_CPTASK_RESOLUTION_TITLE             0X7D2E
#define IDS_CPTASK_RESOLUTION_INFOTIP           0X7D2F
#define IDS_CPTASK_FONTS_TITLE                  0X7D30
#define IDS_CPTASK_FONTS_INFOTIP                0X7D31
#define IDS_CPTASK_FOLDEROPTIONS_TITLE          0X7D32
#define IDS_CPTASK_FOLDEROPTIONS_INFOTIP        0X7D33
#define IDS_CPTASK_MOUSEPOINTERS_TITLE          0X7D34
#define IDS_CPTASK_MOUSEPOINTERS_INFOTIP        0X7D35
#define IDS_CPTASK_HIGHCONTRAST_TITLE           0X7D36
#define IDS_CPTASK_HIGHCONTRAST_INFOTIP         0X7D37
#define IDS_CPTASK_ACCOUNTSPICT_TITLE           0X7D38
#define IDS_CPTASK_ACCOUNTSPICT_INFOTIP         0X7D39
#define IDS_CPTASK_TSDISPLAY_TITLE              0X7D3A
#define IDS_CPTASK_TSDISPLAY_INFOTIP            0X7D3B
#define IDS_CPTASK_ADDPRINTER_TITLE             0X7D3C
#define IDS_CPTASK_ADDPRINTER_INFOTIP           0X7D3D
#define IDS_CPTASK_HARDWAREWIZ_TITLE            0X7D3E
#define IDS_CPTASK_HARDWAREWIZ_INFOTIP          0X7D3F
#define IDS_CPTASK_DISPLAYCPL_TITLE             0X7D40
#define IDS_CPTASK_DISPLAYCPL_INFOTIP           0X7D41
#define IDS_CPTASK_SOUNDSCPL_TITLE              0X7D42
#define IDS_CPTASK_SOUNDSCPL_INFOTIP            0X7D43
#define IDS_CPTASK_POWERCPL_TITLE               0X7D44
#define IDS_CPTASK_POWERCPL_INFOTIP             0X7D45
#define IDS_CPTASK_MYCOMPUTER_INFOTIP           0X7D46
#define IDS_CPTASK_MYCOMPUTER_TITLE             0X7D47
#define IDS_CPTASK_TSHARDWARE_TITLE             0X7D48
#define IDS_CPTASK_TSHARDWARE_INFOTIP           0X7D49
#define IDS_CPTASK_NETCONNECTION_TITLE          0X7D4A
#define IDS_CPTASK_NETCONNECTION_INFOTIP        0X7D4B
#define IDS_CPTASK_VPNCONNECTION_TITLE          0X7D4C
#define IDS_CPTASK_VPNCONNECTION_INFOTIP        0X7D4D
#define IDS_CPTASK_HOMENETWORK_TITLE            0X7D4E
#define IDS_CPTASK_HOMENETWORK_INFOTIP          0X7D4F
#define IDS_CPTASK_MYNETPLACES_TITLE            0X7D50
#define IDS_CPTASK_MYNETPLACES_INFOTIP          0X7D51
#define IDS_CPTASK_PRINTERSHARDWARE_TITLE       0X7D52
#define IDS_CPTASK_PRINTERSHARDWARE_INFOTIP     0X7D53
#define IDS_CPTASK_REMOTEDESKTOP_TITLE          0X7D54
#define IDS_CPTASK_REMOTEDESKTOP_INFOTIP        0X7D55
#define IDS_CPTASK_TSINETEXPLORER_TITLE         0X7D56
#define IDS_CPTASK_TSINETEXPLORER_INFOTIP       0X7D57
#define IDS_CPTASK_TSNETWORK_TITLE              0X7D58
#define IDS_CPTASK_TSNETWORK_INFOTIP            0X7D59
#define IDS_CPTASK_TSHOMENETWORKING_TITLE       0X7D5A
#define IDS_CPTASK_CONTROLPANEL_INFOTIP         0x7D5B
#define IDS_CPTASK_TSMODEM_TITLE                0X7D5C
#define IDS_CPTASK_TSMODEM_INFOTIP              0X7D5D
#define IDS_CPTASK_TSFILESHARING_TITLE          0X7D5E
#define IDS_CPTASK_TSFILESHARING_INFOTIP        0X7D5F
#define IDS_CPTASK_TSNETDIAGS_TITLE             0X7D60
#define IDS_CPTASK_TSNETDIAGS_INFOTIP           0X7D61
#define IDS_CPTASK_SOUNDVOLUME_TITLE            0X7D62
#define IDS_CPTASK_SOUNDVOLUME_INFOTIP          0X7D63
#define IDS_CPTASK_SPEAKERSETTINGS_TITLE        0X7D64
#define IDS_CPTASK_SPEAKERSETTINGS_INFOTIP      0X7D65
#define IDS_CPTASK_SOUNDSCHEMES_TITLE           0X7D66
#define IDS_CPTASK_SOUNDSCHEMES_INFOTIP         0X7D67
#define IDS_CPTASK_SOUNDACCESSIBILITY_TITLE     0X7D68
#define IDS_CPTASK_SOUNDACCESSIBILITY_INFOTIP   0X7D69
#define IDS_CPTASK_TSSOUND_TITLE                0X7D6A
#define IDS_CPTASK_TSSOUND_INFOTIP              0X7D6B
#define IDS_CPTASK_TSDVD_TITLE                  0X7D6C
#define IDS_CPTASK_TSDVD_INFOTIP                0X7D6D
#define IDS_CPTASK_CLEANUPDISK_TITLE            0X7D6E
#define IDS_CPTASK_CLEANUPDISK_INFOTIP          0X7D6F
#define IDS_CPTASK_BACKUPDATA_TITLE             0X7D70
#define IDS_CPTASK_BACKUPDATA_INFOTIP           0X7D71
#define IDS_CPTASK_DEFRAG_TITLE                 0X7D72
#define IDS_CPTASK_DEFRAG_INFOTIP               0X7D73
// unused                                         0X7D74
// unused                                         0X7D75
#define IDS_CPTASK_TSSTARTUP_TITLE              0X7D76
#define IDS_CPTASK_TSSTARTUP_INFOTIP            0X7D77
#define IDS_CPTASK_DATETIME_TITLE               0X7D78
#define IDS_CPTASK_DATETIME_INFOTIP             0X7D79
#define IDS_CPTASK_CHANGEREGION_TITLE           0X7D7A
#define IDS_CPTASK_CHANGEREGION_INFOTIP         0X7D7B
#define IDS_CPTASK_LANGUAGE_TITLE               0X7D7C
#define IDS_CPTASK_LANGUAGE_INFOTIP             0X7D7D
#define IDS_CPTASK_SCHEDULEDTASKS_TITLE         0X7D7E
#define IDS_CPTASK_SCHEDULEDTASKS_INFOTIP       0X7D7F
#define IDS_CPTASK_TURNONHIGHCONTRAST_TITLE     0X7D80
#define IDS_CPTASK_TURNONHIGHCONTRAST_INFOTIP   0X7D81
#define IDS_CPTASK_ACCESSWIZARD_TITLE           0X7D82
#define IDS_CPTASK_ACCESSWIZARD_INFOTIP         0X7D83
#define IDS_CPTASK_MAGNIFIER_TITLE              0X7D84
#define IDS_CPTASK_MAGNIFIER_INFOTIP            0X7D85
// unused                                         0X7D86
// unused                                         0X7D87
#define IDS_CPTASK_ONSCREENKBD_TITLE            0X7D88
#define IDS_CPTASK_ONSCREENKBD_INFOTIP          0X7D89
#define IDS_CPTASK_ACCESSUTILITYMGR_TITLE       0X7D8A
#define IDS_CPTASK_ACCESSUTILITYMGR_INFOTIP     0X7D8B
#define IDS_CPTASK_TSPRINTING_TITLE             0X7D8C
#define IDS_CPTASK_TSPRINTING_INFOTIP           0X7D8D
#define IDS_CPTASK_TSSAFEMODE_TITLE             0X7D8E
#define IDS_CPTASK_TSSAFEMODE_INFOTIP           0X7D8F
#define IDS_CPTASK_TSSYSTEMSETUP_TITLE          0X7D90
#define IDS_CPTASK_TSSYSTEMSETUP_INFOTIP        0X7D91
#define IDS_CPTASK_TSFIX_TITLE                  0X7D92
#define IDS_CPTASK_TSFIX_INFOTIP                0X7D93
#define IDS_CPTASK_VISUALPERF_TITLE             0X7D94
#define IDS_CPTASK_VISUALPERF_INFOTIP           0X7D95
#define IDS_CPTASK_SWITCHTOCLASSICVIEW_TITLE    0x7D96
#define IDS_CPTASK_SWITCHTOCLASSICVIEW_INFOTIP  0x7D97
#define IDS_CPTASK_SWITCHTOCATEGORYVIEW_TITLE   0x7D98
#define IDS_CPTASK_SWITCHTOCATEGORYVIEW_INFOTIP 0x7D99
#define IDS_CPTASK_SYSTEMRESTORE_TITLE          0x7D9A
#define IDS_CPTASK_SYSTEMRESTORE_INFOTIP        0x7D9B
#define IDS_CPTASK_ACCOUNTSMANAGE_TITLE         0x7D9C
#define IDS_CPTASK_ACCOUNTSMANAGE_INFOTIP       0x7D9D
#define IDS_CPTASK_ACCOUNTSMANAGE_INFOTIP2      0x7D9E
#define IDS_CPTASK_ACCOUNTSCREATE_TITLE         0x7D9F
#define IDS_CPTASK_ACCOUNTSCREATE_INFOTIP       0x7DA0
#define IDS_CPTASK_ACCOUNTSPICT2_TITLE          0x7DA1
#define IDS_CPTASK_ACCOUNTSPICT2_INFOTIP        0x7DA2
#define IDS_CPTASK_LEARNABOUT_TITLE             0x7DA3
#define IDS_CPTASK_LEARNABOUT_INFOTIP           0x7DA4
#define IDS_CPTASK_AUTOUPDATE_TITLE             0x7DA5
#define IDS_CPTASK_AUTOUPDATE_INFOTIP           0x7DA6
#define IDS_CPTASK_ADDPROGRAM_TITLE             0x7DA7
#define IDS_CPTASK_ADDPROGRAM_INFOTIP           0x7DA8
#define IDS_CPTASK_REMOVEPROGRAM_TITLE          0x7DA9
#define IDS_CPTASK_REMOVEPROGRAM_INFOTIP        0x7DAA
#define IDS_CPTASK_SOUNDVOLUMEADV_TITLE         0x7DAB
#define IDS_CPTASK_SOUNDVOLUMEADV_INFOTIP       0x7DAC
#define IDS_CPTASK_SYSTEMCPL_TITLE              0x7DAD
#define IDS_CPTASK_SYSTEMCPL_INFOTIP            0x7DAE
#define IDS_CPTASK_PHONEMODEMCPL_TITLE          0x7DAF
#define IDS_CPTASK_PHONEMODEMCPL_INFOTIP        0x7DB0
#define IDS_CPTASK_SYSTEMCPL_TITLE2             0x7DB1
#define IDS_CPTASK_SYSTEMCPL_INFOTIP2           0x7DB2
#define IDS_CPTASK_FILETYPES_TITLE              0x7DB3
#define IDS_CPTASK_FILETYPES_INFOTIP            0x7DB4
#define IDS_CPTASK_VIEWPRINTERS_TITLE           0x7DB5
#define IDS_CPTASK_VIEWPRINTERS_INFOTIP         0x7DB6
#define IDS_CPTASK_LEARNACCOUNTS_TITLE          0x7DB7
#define IDS_CPTASK_LEARNACCOUNTSTYPES_TITLE     0x7DB8
#define IDS_CPTASK_LEARNACCOUNTSCHANGENAME_TITLE 0x7DB9
#define IDS_CPTASK_LEARNACCOUNTSCREATE_TITLE    0x7DBA
#define IDS_CPTASK_LEARNSWITCHUSERS_TITLE       0x7DBB
#define IDS_CPTASK_32CPLS_TITLE                 0x7DBC
#define IDS_CPTASK_32CPLS_INFOTIP               0x7DBD

//
// This range through 0x7F01 reserved for Control Panel.
//
#define IDS_CP_PICKCATEGORY                     0x7F01
#define IDS_CP_PICKTASK                         0x7F02
#define IDS_CP_PICKICON                         0x7F03
#define IDS_CP_ORPICKICON                       0x7F04
#define IDS_CP_TASKBARANDSTARTMENU              0x7F05
#define IDS_CP_LINK_ACCDEFACTION                0x7F06
#define IDS_CP_CATEGORY_BARRICADE_TITLE         0x7F07
#define IDS_CP_CATEGORY_BARRICADE_MSG           0x7F08
#define IDS_CPL_ACCESSIBILITYOPTIONS            0x7F09
#define IDS_CPL_DATETIME                        0x7F0A
#define IDS_CPL_ADDREMOVEPROGRAMS               0x7F0B
#define IDS_CPL_REGIONALOPTIONS                 0x7F0C
#define IDS_CPL_MOUSE                           0x7F0D
#define IDS_CPL_INTERNETOPTIONS                 0x7F0E
#define IDS_CPL_PHONEANDMODEMOPTIONS            0x7F0F
#define IDS_CPL_POWEROPTIONS                    0x7F10
#define IDS_CPL_SCANNERSANDCAMERAS              0x7F11
#define IDS_CPL_SYSTEM                          0x7F12
#define IDS_CPL_SOUNDSANDAUDIO                  0x7F13
#define IDS_CPL_USERACCOUNTS                    0x7F14
#define IDS_CPL_ADDHARDWARE                     0x7F15
#define IDS_CPL_DISPLAY                         0x7F16


// Resources for NT Console property sheets in links

#define IDD_CONSOLE_SETTINGS            0x8000
#define IDC_CNSL_WINDOWED               (IDD_CONSOLE_SETTINGS +  1)
#define IDC_CNSL_FULLSCREEN             (IDD_CONSOLE_SETTINGS +  2)
#define IDC_CNSL_QUICKEDIT              (IDD_CONSOLE_SETTINGS +  3)
#define IDC_CNSL_INSERT                 (IDD_CONSOLE_SETTINGS +  4)
#define IDC_CNSL_CURSOR_SMALL           (IDD_CONSOLE_SETTINGS +  5)
#define IDC_CNSL_CURSOR_MEDIUM          (IDD_CONSOLE_SETTINGS +  6)
#define IDC_CNSL_CURSOR_LARGE           (IDD_CONSOLE_SETTINGS +  7)
#define IDC_CNSL_HISTORY_SIZE_LBL       (IDD_CONSOLE_SETTINGS +  8)
#define IDC_CNSL_HISTORY_SIZE           (IDD_CONSOLE_SETTINGS +  9)
#define IDC_CNSL_HISTORY_SIZESCROLL     (IDD_CONSOLE_SETTINGS + 10)
#define IDC_CNSL_HISTORY_NUM_LBL        (IDD_CONSOLE_SETTINGS + 11)
#define IDC_CNSL_HISTORY_NUM            (IDD_CONSOLE_SETTINGS + 12)
#define IDC_CNSL_HISTORY_NUMSCROLL      (IDD_CONSOLE_SETTINGS + 13)
#define IDC_CNSL_HISTORY_NODUP          (IDD_CONSOLE_SETTINGS + 14)
#define IDC_CNSL_LANGUAGELIST           (IDD_CONSOLE_SETTINGS + 15)

#define IDD_CONSOLE_FONTDLG             0x8025
#define IDC_CNSL_STATIC                 (IDD_CONSOLE_FONTDLG +  1)
#define IDC_CNSL_FACENAME               (IDD_CONSOLE_FONTDLG +  2)
#define IDC_CNSL_BOLDFONT               (IDD_CONSOLE_FONTDLG +  3)
#define IDC_CNSL_STATIC2                (IDD_CONSOLE_FONTDLG +  4)
#define IDC_CNSL_TEXTDIMENSIONS         (IDD_CONSOLE_FONTDLG +  5)
#define IDC_CNSL_PREVIEWLABEL           (IDD_CONSOLE_FONTDLG +  6)
#define IDC_CNSL_GROUP                  (IDD_CONSOLE_FONTDLG +  7)
#define IDC_CNSL_STATIC3                (IDD_CONSOLE_FONTDLG +  8)
#define IDC_CNSL_STATIC4                (IDD_CONSOLE_FONTDLG +  9)
#define IDC_CNSL_FONTWIDTH              (IDD_CONSOLE_FONTDLG + 10)
#define IDC_CNSL_FONTHEIGHT             (IDD_CONSOLE_FONTDLG + 11)
#define IDC_CNSL_FONTSIZE               (IDD_CONSOLE_FONTDLG + 12)
#define IDC_CNSL_POINTSLIST             (IDD_CONSOLE_FONTDLG + 13)
#define IDC_CNSL_PIXELSLIST             (IDD_CONSOLE_FONTDLG + 14)
#define IDC_CNSL_PREVIEWWINDOW          (IDD_CONSOLE_FONTDLG + 15)
#define IDC_CNSL_FONTWINDOW             (IDD_CONSOLE_FONTDLG + 16)

#define IDD_CONSOLE_SCRBUFSIZE          0x8050
#define IDC_CNSL_SCRBUF_WIDTH_LBL       (IDD_CONSOLE_SCRBUFSIZE +  1)
#define IDC_CNSL_SCRBUF_WIDTH           (IDD_CONSOLE_SCRBUFSIZE +  2)
#define IDC_CNSL_SCRBUF_WIDTHSCROLL     (IDD_CONSOLE_SCRBUFSIZE +  3)
#define IDC_CNSL_SCRBUF_HEIGHT_LBL      (IDD_CONSOLE_SCRBUFSIZE +  4)
#define IDC_CNSL_SCRBUF_HEIGHT          (IDD_CONSOLE_SCRBUFSIZE +  5)
#define IDC_CNSL_SCRBUF_HEIGHTSCROLL    (IDD_CONSOLE_SCRBUFSIZE +  6)
#define IDC_CNSL_WINDOW_WIDTH_LBL       (IDD_CONSOLE_SCRBUFSIZE +  7)
#define IDC_CNSL_WINDOW_WIDTH           (IDD_CONSOLE_SCRBUFSIZE +  8)
#define IDC_CNSL_WINDOW_WIDTHSCROLL     (IDD_CONSOLE_SCRBUFSIZE +  9)
#define IDC_CNSL_WINDOW_HEIGHT_LBL      (IDD_CONSOLE_SCRBUFSIZE + 10)
#define IDC_CNSL_WINDOW_HEIGHT          (IDD_CONSOLE_SCRBUFSIZE + 11)
#define IDC_CNSL_WINDOW_HEIGHTSCROLL    (IDD_CONSOLE_SCRBUFSIZE + 12)
#define IDC_CNSL_WINDOW_POSX_LBL        (IDD_CONSOLE_SCRBUFSIZE + 13)
#define IDC_CNSL_WINDOW_POSX            (IDD_CONSOLE_SCRBUFSIZE + 14)
#define IDC_CNSL_WINDOW_POSXSCROLL      (IDD_CONSOLE_SCRBUFSIZE + 15)
#define IDC_CNSL_WINDOW_POSY_LBL        (IDD_CONSOLE_SCRBUFSIZE + 16)
#define IDC_CNSL_WINDOW_POSY            (IDD_CONSOLE_SCRBUFSIZE + 17)
#define IDC_CNSL_WINDOW_POSYSCROLL      (IDD_CONSOLE_SCRBUFSIZE + 18)
#define IDC_CNSL_AUTO_POSITION          (IDD_CONSOLE_SCRBUFSIZE + 19)

#define IDD_CONSOLE_COLOR               0x8075
#define IDC_CNSL_COLOR_SCREEN_TEXT      (IDD_CONSOLE_COLOR +  1)
#define IDC_CNSL_COLOR_SCREEN_BKGND     (IDD_CONSOLE_COLOR +  2)
#define IDC_CNSL_COLOR_POPUP_TEXT       (IDD_CONSOLE_COLOR +  3)
#define IDC_CNSL_COLOR_POPUP_BKGND      (IDD_CONSOLE_COLOR +  4)
#define IDC_CNSL_COLOR_1                (IDD_CONSOLE_COLOR +  5)
#define IDC_CNSL_COLOR_2                (IDD_CONSOLE_COLOR +  6)
#define IDC_CNSL_COLOR_3                (IDD_CONSOLE_COLOR +  7)
#define IDC_CNSL_COLOR_4                (IDD_CONSOLE_COLOR +  8)
#define IDC_CNSL_COLOR_5                (IDD_CONSOLE_COLOR +  9)
#define IDC_CNSL_COLOR_6                (IDD_CONSOLE_COLOR + 10)
#define IDC_CNSL_COLOR_7                (IDD_CONSOLE_COLOR + 11)
#define IDC_CNSL_COLOR_8                (IDD_CONSOLE_COLOR + 12)
#define IDC_CNSL_COLOR_9                (IDD_CONSOLE_COLOR + 13)
#define IDC_CNSL_COLOR_10               (IDD_CONSOLE_COLOR + 14)
#define IDC_CNSL_COLOR_11               (IDD_CONSOLE_COLOR + 15)
#define IDC_CNSL_COLOR_12               (IDD_CONSOLE_COLOR + 16)
#define IDC_CNSL_COLOR_13               (IDD_CONSOLE_COLOR + 17)
#define IDC_CNSL_COLOR_14               (IDD_CONSOLE_COLOR + 18)
#define IDC_CNSL_COLOR_15               (IDD_CONSOLE_COLOR + 19)
#define IDC_CNSL_COLOR_16               (IDD_CONSOLE_COLOR + 20)
#define IDC_CNSL_COLOR_SCREEN_COLORS_LBL (IDD_CONSOLE_COLOR+ 21)
#define IDC_CNSL_COLOR_SCREEN_COLORS    (IDD_CONSOLE_COLOR + 22)
#define IDC_CNSL_COLOR_POPUP_COLORS_LBL (IDD_CONSOLE_COLOR + 23)
#define IDC_CNSL_COLOR_POPUP_COLORS     (IDD_CONSOLE_COLOR + 24)
#define IDC_CNSL_COLOR_RED_LBL          (IDD_CONSOLE_COLOR + 25)
#define IDC_CNSL_COLOR_RED              (IDD_CONSOLE_COLOR + 26)
#define IDC_CNSL_COLOR_REDSCROLL        (IDD_CONSOLE_COLOR + 27)
#define IDC_CNSL_COLOR_GREEN_LBL        (IDD_CONSOLE_COLOR + 28)
#define IDC_CNSL_COLOR_GREEN            (IDD_CONSOLE_COLOR + 29)
#define IDC_CNSL_COLOR_GREENSCROLL      (IDD_CONSOLE_COLOR + 30)
#define IDC_CNSL_COLOR_BLUE_LBL         (IDD_CONSOLE_COLOR + 31)
#define IDC_CNSL_COLOR_BLUE             (IDD_CONSOLE_COLOR + 32)
#define IDC_CNSL_COLOR_BLUESCROLL       (IDD_CONSOLE_COLOR + 33)

#define IDD_CONSOLE_ADVANCED            0x8100
#define IDC_CNSL_ADVANCED_LABEL         (IDD_CONSOLE_ADVANCED +  1)
#define IDC_CNSL_ADVANCED_LISTVIEW      (IDD_CONSOLE_ADVANCED +  2)

#define IDC_CNSL_GROUP0                 0x8120
#define IDC_CNSL_GROUP1                 (IDC_CNSL_GROUP0 +  1)
#define IDC_CNSL_GROUP2                 (IDC_CNSL_GROUP0 +  2)
#define IDC_CNSL_GROUP3                 (IDC_CNSL_GROUP0 +  3)
#define IDC_CNSL_GROUP4                 (IDC_CNSL_GROUP0 +  4)
#define IDC_CNSL_GROUP5                 (IDC_CNSL_GROUP0 +  5)


// string table constants
#define IDS_CNSL_NAME            0x8125
#define IDS_CNSL_INFO            (IDS_CNSL_NAME+1)
#define IDS_CNSL_TITLE           (IDS_CNSL_NAME+2)
#define IDS_CNSL_RASTERFONT      (IDS_CNSL_NAME+3)
#define IDS_CNSL_FONTSIZE        (IDS_CNSL_NAME+4)
#define IDS_CNSL_SELECTEDFONT    (IDS_CNSL_NAME+5)
#define IDS_CNSL_SAVE            (IDS_CNSL_NAME+6)

#define IDS_SHUTDOWN                0x8200
#define IDS_RESTART                 (IDS_SHUTDOWN+1)
#define IDS_NO_PERMISSION_SHUTDOWN  (IDS_SHUTDOWN+2)
#define IDS_NO_PERMISSION_RESTART   (IDS_SHUTDOWN+3)

#define IDS_UNMOUNT_TITLE           0x8225
#define IDS_UNMOUNT_TEXT            (IDS_UNMOUNT_TITLE+1)
#define IDS_EJECT_TITLE             (IDS_UNMOUNT_TITLE+2)
#define IDS_EJECT_TEXT              (IDS_UNMOUNT_TITLE+3)
#define IDS_RETRY_UNMOUNT_TITLE     (IDS_UNMOUNT_TITLE+4)
#define IDS_RETRY_UNMOUNT_TEXT      (IDS_UNMOUNT_TITLE+5)

// unicpp\resource.h defines more IDs starting at 0x8600
// menuband\mnbandid.h defines more IDs starting at 0x8700

// Active desktop prop page
#define IDC_TICKERINTERVAL              1000
#define IDC_TICKERINTERVAL_SPIN         1001
#define IDC_NEWSINTERVAL                1002
#define IDC_NEWSINTERVAL_SPIN           1003
#define IDC_NEWSUPDATE                  1004
#define IDC_NEWSUPDATE_SPIN             1005
#define IDC_TICKERDISPLAY               1006
#define IDC_NEWSDISPLAY                 1007
#define IDC_NEWSSPEED                   1008
#define IDC_TICKERSPEED                 1009

// for column arrange dialog
#define IDC_COL_LVALL         1001
#define IDC_COL_WIDTH_TEXT    1002
#define IDC_COL_UP            1003
#define IDC_COL_DOWN          1004
#define IDC_COL_WIDTH         1005
#define IDC_COL_SHOW          1006
#define IDC_COL_HIDE          1007

// Column Specifiers dialog
#define IDC_DESKTOPINI        1008

// Disk space error dialog
#define IDC_DISKERR_EXPLAIN             1000
#define IDC_DISKERR_LAUNCHCLEANUP       1001
#define IDC_DISKERR_STOPICON            1002

// Web wizard host page (DLG_WEBWIZARD)
#define IDC_PROGRESS                    1000
#define IDC_PROGTEXT1                   1001
#define IDC_PROGTEXT2                   1002


#define CLASS_NSC           TEXT(CLASS_NSCA)
#define CLASS_NSCA          "SHBrowseForFolder ShellNameSpace Control"


#define SMCM_STARTMENU_FIRST        0x5000
#define SMCM_OPEN                   (SMCM_STARTMENU_FIRST + 0)
#define SMCM_EXPLORE                (SMCM_STARTMENU_FIRST + 1)
#define SMCM_OPEN_ALLUSERS          (SMCM_STARTMENU_FIRST + 2)
#define SMCM_EXPLORE_ALLUSERS       (SMCM_STARTMENU_FIRST + 3)

#ifdef NEPTUNE
#define SMCM_SHUTDOWNMENU_FIRST     0x5100
#define SMCM_POWEROFF               (SMCM_SHUTDOWNMENU_FIRST + 0)
#define SMCM_RESTART                (SMCM_SHUTDOWNMENU_FIRST + 1)
#define SMCM_STANDBY                (SMCM_SHUTDOWNMENU_FIRST + 2)
#endif


// start menu's merged context menu ids
#define SMIDM_OPEN               0x0001
#define SMIDM_EXPLORE            0x0002
#define SMIDM_OPENCOMMON         0x0003
#define SMIDM_EXPLORECOMMON      0x0004
#define SMIDM_DELETE             0x0005
#define SMIDM_RENAME             0x0006
#define SMIDM_PROPERTIES         0x0007


// UI file ids

#define IDR_DUI_FOLDER                3
#define IDR_DUI_CPVIEW                4

///////////////////////////////

#include "unicpp\resource.h"

#endif // _IDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\infotip.h ===
#ifndef _INFOTIP_H_
#define _INFOTIP_H_

STDAPI CreateInfoTipFromText(LPCTSTR pszText, REFIID riid, void **ppv);
STDAPI CreateInfoTipFromItem(IShellFolder2 *psf, LPCITEMIDLIST pidl, LPCWSTR pszProps, REFIID riid, void **ppv);

#endif // _INFOTIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\infotip.cpp ===
#include "shellprv.h"
#include "infotip.h"
#include "ids.h"
#include "prop.h"

#include <mluisupp.h>

// generic info tip object

class CInfoTip : public IQueryInfo, public ICustomizeInfoTip, public IParentAndItem
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IQueryInfo methods.
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR** ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);

    // ICustomizeInfoTip
    STDMETHODIMP SetPrefixText(LPCWSTR pszPrefix);
    STDMETHODIMP SetExtraProperties(const SHCOLUMNID *pscid, UINT cscid);

    // IParentAndItem
    STDMETHODIMP SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf,  LPCITEMIDLIST pidlChild);
    STDMETHODIMP GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidlChild);

    CInfoTip(IShellFolder2 *psf, LPCITEMIDLIST pidl, LPCWSTR pszProp);

private:
    ~CInfoTip();
    HRESULT _GetInfoTipFromItem(WCHAR **ppszText);
    BOOL _InExtraList(const SHCOLUMNID *pscid);

    LONG _cRef;

    IShellFolder2 *_psf;
    LPITEMIDLIST _pidl;
    TCHAR _szText[INFOTIPSIZE];
    LPWSTR _pszPrefix;
    SHCOLUMNID _rgcols[8];
    UINT _cscid;
};

#define PROP_PREFIX         TEXT("prop:")
#define PROP_PREFIX_LEN     (ARRAYSIZE(PROP_PREFIX) - 1)

CInfoTip::CInfoTip(IShellFolder2 *psf, LPCITEMIDLIST pidl, LPCWSTR pszText) : _cRef(1)
{
    if (IS_INTRESOURCE(pszText))
        LoadString(HINST_THISDLL, LOWORD((UINT_PTR)pszText), _szText, ARRAYSIZE(_szText));
    else
        SHUnicodeToTChar(pszText, _szText, ARRAYSIZE(_szText));

    if (psf && pidl && (StrCmpNI(_szText, PROP_PREFIX, PROP_PREFIX_LEN) == 0))
    {
        // list of properties, we need the psf and pidl for this
        psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &_psf));
        _pidl = ILClone(pidl);
    }
}

CInfoTip::~CInfoTip()
{
    if (_psf)
        _psf->Release();

    ILFree(_pidl);

    Str_SetPtr(&_pszPrefix, NULL);
}

HRESULT CInfoTip::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CInfoTip, IQueryInfo),
        QITABENT(CInfoTip, ICustomizeInfoTip),
        QITABENT(CInfoTip, IParentAndItem),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CInfoTip::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CInfoTip::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

BOOL CInfoTip::_InExtraList(const SHCOLUMNID *pscid)
{
    for (UINT i = 0; i < _cscid; i++)
    {
        if (IsEqualSCID(*pscid, _rgcols[i]))
            return TRUE;
    }
    return FALSE;
}

void _AppendTipText(LPTSTR pszBuf, int cch, LPCTSTR pszCRLF, LPCTSTR pszPropName, LPCTSTR pszValue)
{
    TCHAR szFmt[64], szProp[128];

    if (*pszPropName)
        LoadString(g_hinst, IDS_EXCOL_TEMPLATE, szFmt, SIZECHARS(szFmt));
    else
        lstrcpy(szFmt, TEXT("%s%s%s"));

    wnsprintf(szProp, ARRAYSIZE(szProp), szFmt, pszCRLF, pszPropName, pszValue);
    StrCatBuff(pszBuf, szProp, cch);
}

HRESULT CInfoTip::_GetInfoTipFromItem(WCHAR **ppszText)
{
    TCHAR szTip[INFOTIPSIZE];
    szTip[0] = 0;

    IPropertyUI *ppui;
    if (SUCCEEDED(CoCreateInstance(CLSID_PropertiesUI, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPropertyUI, &ppui))))
    {
        LPCTSTR pszCRLF = TEXT("");

        if (_pszPrefix)
        {
            _AppendTipText(szTip, ARRAYSIZE(szTip), pszCRLF, TEXT(""), _pszPrefix);
            pszCRLF = TEXT("\n");
        }

        UINT iCurrentExtra = 0;

        BOOL bContinue = TRUE;
        ULONG chEaten = 0;  // gets incremented by ParsePropertyName
        while (bContinue)
        {
            SHCOLUMNID scid;
            BOOL bDoThisOne = TRUE;

            if (iCurrentExtra < _cscid)
            {
                scid = _rgcols[iCurrentExtra++];
            }
            else
            {
                if (SUCCEEDED(ppui->ParsePropertyName(_szText, &scid.fmtid, &scid.pid, &chEaten)))
                {
                    bDoThisOne = !_InExtraList(&scid);
                }
                else
                {
                    bContinue = FALSE;
                }
            }

            if (bContinue)
            {
                VARIANT v = {0};

                if (bDoThisOne && (S_OK == _psf->GetDetailsEx(_pidl, &scid, &v)))
                {
                    TCHAR szPropName[128], szValue[128];

                    ppui->FormatForDisplay(scid.fmtid, scid.pid, (PROPVARIANT*)&v, PUIFFDF_DEFAULT, szValue, ARRAYSIZE(szValue));

                    if (IsEqualSCID(scid, SCID_Comment))
                    {
                        szPropName[0] = 0;  // comment property, don't use the label 
                    }
                    else
                    {
                        ppui->GetDisplayName(scid.fmtid, scid.pid, PUIFNF_DEFAULT, szPropName, ARRAYSIZE(szPropName));
                    }

                    // if we got a value, and that value is different from
                    // the prefix of the current tip string we append it.
                    // that is don't dupe the same string where the comment == name

                    if (szValue[0] && (0 != StrCmpNI(szTip, szValue, lstrlen(szValue))))
                    {
                        _AppendTipText(szTip, ARRAYSIZE(szTip), pszCRLF, szPropName, szValue);
                        pszCRLF = TEXT("\n");
                    }

                    VariantClear(&v);
                }
            }
        }
        ppui->Release();
    }
    return SHStrDup(szTip, ppszText);
}

STDMETHODIMP CInfoTip::GetInfoTip(DWORD dwFlags, WCHAR** ppszText)
{
    HRESULT hr;
    if (_psf && _pidl)
        hr = _GetInfoTipFromItem(ppszText);
    else if (_szText[0])
        hr = SHStrDup(_szText, ppszText);
    else
        hr = E_FAIL;
    return hr;
}

STDMETHODIMP CInfoTip::GetInfoFlags(DWORD *pdwFlags)
{
    *pdwFlags = 0;
    return E_NOTIMPL;
}

// ICustomizeInfoTip

STDMETHODIMP CInfoTip::SetPrefixText(LPCWSTR pszPrefix)
{
    Str_SetPtr(&_pszPrefix, pszPrefix);
    return S_OK;
}

// IParentAndItem

STDMETHODIMP CInfoTip::SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf, LPCITEMIDLIST pidl) 
{
    if (psf)
    {
        ATOMICRELEASE(_psf);
        psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &_psf));
    }

    if (pidl)
        Pidl_Set(&_pidl, pidl);
    return _psf && _pidl ? S_OK : E_FAIL;
}

STDMETHODIMP CInfoTip::GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidl)
{
    return E_NOTIMPL;
}

STDMETHODIMP CInfoTip::SetExtraProperties(const SHCOLUMNID *pscid, UINT cscid)
{
    _cscid = min(cscid, ARRAYSIZE(_rgcols));
    CopyMemory(_rgcols, pscid, _cscid * sizeof(_rgcols[0]));
    return S_OK;
}

// in:
//      pszText - description of info tip. either
//          1) a semi separated list of property names, "Author;Size" or "{fmtid},pid;{fmtid},pid"
//          2) if no semis the tip to create
//          MAKEINTRESOURCE(id) of a resource ID

STDAPI CreateInfoTipFromItem(IShellFolder2 *psf, LPCITEMIDLIST pidl, LPCWSTR pszText, REFIID riid, void **ppv)
{
    HRESULT hr;
    CInfoTip* pit = new CInfoTip(psf, pidl, pszText);
    if (pit)
    {
        hr = pit->QueryInterface(riid, ppv);
        pit->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppv = NULL;
    }
    return hr;
}

STDAPI CreateInfoTipFromText(LPCTSTR pszText, REFIID riid, void **ppv)
{
    if (IS_INTRESOURCE(pszText))
        return CreateInfoTipFromItem(NULL, NULL, (LPCWSTR)pszText, riid, ppv);
    else
    {
        WCHAR szBuf[INFOTIPSIZE];
        SHTCharToUnicode(pszText, szBuf, ARRAYSIZE(szBuf));
        return CreateInfoTipFromItem(NULL, NULL, szBuf, riid, ppv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\init.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "copy.h"
#include "filetbl.h"

#include "ovrlaymn.h"
#include "drives.h"

#include "mixctnt.h"

#include "unicpp\admovr2.h"

void FreeExtractIconInfo(int);
void DAD_ThreadDetach(void);
void DAD_ProcessDetach(void);
void TaskMem_MakeInvalid(void);
void UltRoot_Term(void);
void FlushRunDlgMRU(void);

STDAPI_(BOOL) ATL_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);

// from mtpt.cpp
STDAPI_(void) CMtPt_FinalCleanUp();
STDAPI_(void) CMtPt_Initialize();
STDAPI_(void) CMtPt_FakeVolatileKeys();
// from rgsprtc.cpp
STDAPI_(void) CRegSupportCached_RSEnableKeyCaching(BOOL fEnable);

// Global data

BOOL g_bMirroredOS = FALSE;         // Is Mirroring enabled 
BOOL g_bBiDiPlatform = FALSE;       // Is DATE_LTRREADING flag supported by GetDateFormat() API?   
HINSTANCE g_hinst = NULL;
extern HANDLE g_hCounter;   // Global count of mods to Special Folder cache.
extern HANDLE g_hRestrictions ; // Global count of mods to restriction cache.
extern HANDLE g_hSettings;  // global count of mods to shellsettings cache
DWORD g_dwThreadBindCtx = (DWORD) -1;

#ifdef DEBUG
BOOL  g_bInDllEntry = FALSE;
#endif

CRITICAL_SECTION g_csDll = {0};
extern CRITICAL_SECTION g_csSCN;

extern CRITICAL_SECTION g_csTNGEN;
extern CRITICAL_SECTION g_csDarwinAds;

// these will always be zero
const LARGE_INTEGER g_li0 = {0};
const ULARGE_INTEGER g_uli0 = {0};

#ifdef DEBUG
// Undefine what shlwapi.h defined so our ordinal asserts map correctly
#undef PathAddBackslash 
WINSHELLAPI LPTSTR WINAPI PathAddBackslash(LPTSTR lpszPath);
#undef PathMatchSpec
WINSHELLAPI BOOL  WINAPI PathMatchSpec(LPCTSTR pszFile, LPCTSTR pszSpec);
#endif

void LoadCCv5()
{
    HANDLE hComctl32;
    ULONG_PTR ul = 0;

    // Rundll does not have a manifest. However, it will activate a context for a
    // dll, if it has an embedded manifest at 123. This will cause Shell32.dll
    // to be loaded inside of a v6 context. This means this comctl32 load would be v6.
    // In order to work in the Rundll cases, we need to activate NULL. This verifies that
    // we load v5 and not v6 in this case.
    // other cases are not affected.
    ActivateActCtx(NULL, &ul);

    hComctl32 = LoadLibrary(TEXT("comctl32.dll"));   // Needs to add ref the DLL.
    if (hComctl32)
    {
        typedef BOOL (*PFNICOMCTL32)(LPINITCOMMONCONTROLSEX);
        PFNICOMCTL32 pfn = (PFNICOMCTL32)GetProcAddress(hComctl32, "InitCommonControlsEx");
        if (pfn)
        {
            INITCOMMONCONTROLSEX icce;
            icce.dwICC = 0x00003FFF;
            icce.dwSize = sizeof(icce);
            pfn(&icce);
        }
    }

    if (ul != 0)
        DeactivateActCtx(0, ul);
}

#ifdef DEBUG

void _ValidateExport(FARPROC fp, LPCSTR pszExport, MEMORY_BASIC_INFORMATION *pmbi)
{
    FARPROC fpExport;

    // If not yet computed, calculate the size of our code segment.
    if (pmbi->BaseAddress == NULL)
    {
        VirtualQuery(_ValidateExport, pmbi, sizeof(*pmbi));
    }

    fpExport = GetProcAddress(g_hinst, pszExport);

    // Sometimes our import table is patched.  So if fpExport does not
    // reside inside our DLL, then ignore it.
    // (But complain if fpExport==NULL.)
    if (fpExport == NULL ||
        ((SIZE_T)fpExport - (SIZE_T)pmbi->BaseAddress) < pmbi->RegionSize)
    {
        ASSERT(fp == fpExport);
    }
}

#endif

STDAPI_(BOOL) IsProcessWinlogon()
{
    return BOOLFROMPTR(GetModuleHandle(TEXT("winlogon.EXE")));
}

BOOL _ProcessAttach(HINSTANCE hDll)
{
    BOOL fIgnoreFusionCall = FALSE;

    ASSERTMSG(g_hinst < ((HINSTANCE)1), "Shell32.dll DLL_POCESS_ATTACH is being called for the second time.");

    g_hinst = hDll;

    g_uCodePage = GetACP();

    // Got Fusion?
    // 
    // not get fusion if (1) the current exe is winlogon.exe; (2) in GUI mode setup ; xiaoyuw@03/12/2001
    //
#if 0 
    if (IsGuimodeSetupRunning())
    {
        WCHAR winlogon_fullpath[MAX_PATH];
        PWSTR pszImagePath = NULL, p = NULL;

        if (SHGetSystemWindowsDirectory(winlogon_fullpath, ARRAYSIZE(winlogon_fullpath)))
        {
            PathAppend(winlogon_fullpath, TEXT("\\system32\\winlogon.exe"));
            
            if (NtCurrentPeb()->ProcessParameters != NULL) 
                pszImagePath = NtCurrentPeb()->ProcessParameters->ImagePathName.Buffer;
            
            p = pszImagePath; 
            if (_wcsicmp(p, TEXT("\\??\\")))   // convert nt path to win32 path
                p += 4;
            
            if (_wcsicmp(p, winlogon_fullpath) == 0)
                fIgnoreFusionCall = TRUE;
        }
    }
#else
    if ((IsGuimodeSetupRunning()) && (IsProcessWinlogon()))
        fIgnoreFusionCall = TRUE;

#endif
    if ( ! fIgnoreFusionCall)
        SHFusionInitializeFromModuleID(hDll, 124);

    // For app Compat Reasons we need to have the old window classes in memory as well 
    // as the new fusionized ones. This is because bad applications such as WinAmp don't 
    // follow instructions can call into ComCtl32 by themselves. They expect that shell32
    // will do it for them.
    LoadCCv5();

    InitializeCriticalSection(&g_csDll);
    InitializeCriticalSection(&g_csSCN);
    InitializeCriticalSection(&g_csTNGEN);
    InitializeCriticalSection(&g_csDarwinAds);

    // Initialize the MountPoint stuff
    CMtPt_Initialize();

    // Initialize a Crit Sect for the Autoplay prompts
    InitializeCriticalSection(&g_csAutoplayPrompt);

    //  perthread BindCtx
    g_dwThreadBindCtx = TlsAlloc();

    // We need to disable HKEY caching for classes using CRegSupportCached in
    // winlogon since it does not get unloaded.  This must also apply to the other
    // services loading shell32.dllNot being unloaded the _ProcessDetach
    // never gets called for shell32, and we never release the cached HKEYs.  This
    // prevents the user hives from being unloaded.  SO we'll enable caching only
    // for Explorer.exe.  (stephstm, 08/20/99)
    //
    CRegSupportCached_RSEnableKeyCaching(IsProcessAnExplorer());

    // Check if the mirroring APIs exist on the current platform.
    g_bMirroredOS = IS_MIRRORING_ENABLED();

    g_bBiDiPlatform = BOOLFROMPTR(GetModuleHandle(TEXT("LPK.DLL")));

#ifdef DEBUG
  {
      MEMORY_BASIC_INFORMATION mbi = {0};

#define DEREFMACRO(x) x
#define ValidateORD(_name) _ValidateExport((FARPROC)_name, (LPSTR)MAKEINTRESOURCE(DEREFMACRO(_name##ORD)), &mbi)
    ValidateORD(SHValidateUNC);
    ValidateORD(SHChangeNotifyRegister);
    ValidateORD(SHChangeNotifyDeregister);
    ValidateORD(OleStrToStrN);
    ValidateORD(SHCloneSpecialIDList);
    _ValidateExport((FARPROC)DllGetClassObject, (LPSTR)MAKEINTRESOURCE(SHDllGetClassObjectORD), &mbi);
    ValidateORD(SHLogILFromFSIL);
    ValidateORD(SHMapPIDLToSystemImageListIndex);
    ValidateORD(SHShellFolderView_Message);
    ValidateORD(Shell_GetImageLists);
    ValidateORD(SHGetSpecialFolderPath);
    ValidateORD(StrToOleStrN);

    ValidateORD(ILClone);
    ValidateORD(ILCloneFirst);
    ValidateORD(ILCombine);
    ValidateORD(ILFindChild);
    ValidateORD(ILFree);
    ValidateORD(ILGetNext);
    ValidateORD(ILGetSize);
    ValidateORD(ILIsEqual);
    ValidateORD(ILRemoveLastID);
    ValidateORD(PathAddBackslash);
    ValidateORD(PathIsExe);
    ValidateORD(PathMatchSpec);
    ValidateORD(SHGetSetSettings);
    ValidateORD(SHILCreateFromPath);
    ValidateORD(SHFree);

    ValidateORD(SHAddFromPropSheetExtArray);
    ValidateORD(SHCreatePropSheetExtArray);
    ValidateORD(SHDestroyPropSheetExtArray);
    ValidateORD(SHReplaceFromPropSheetExtArray);
    ValidateORD(SHCreateDefClassObject);
    ValidateORD(SHGetNetResource);
  }

#endif  // DEBUG

#ifdef DEBUG
    {
        extern LPMALLOC g_pmemTask;
        AssertMsg(g_pmemTask == NULL, TEXT("Somebody called SHAlloc in DllEntry!"));
    }

    // Make sure ShellDispatch has the right flags for shell settings
    {
        STDAPI_(void) _VerifyDispatchGetSetting();
        _VerifyDispatchGetSetting();
    }
#endif

    return TRUE;
}

//  Table of all window classes we register so we can unregister them
//  at DLL unload.
//
extern const TCHAR c_szBackgroundPreview2[];
extern const TCHAR c_szComponentPreview[];
extern const TCHAR c_szUserEventWindow[];

const LPCTSTR c_rgszClasses[] = {
    TEXT("SHELLDLL_DefView"),               // defview.cpp
    TEXT("WOACnslWinPreview"),              // lnkcon.c
    TEXT("WOACnslFontPreview"),             // lnkcon.c
    TEXT("cpColor"),                        // lnkcon.c
    TEXT("cpShowColor"),                    // lnkcon.c
    c_szStubWindowClass,                    // rundll32.c
    c_szBackgroundPreview2,                 // unicpp\dbackp.cpp
    c_szComponentPreview,                   // unicpp\dcompp.cpp
    TEXT(STR_DESKTOPCLASS),                 // unicpp\desktop.cpp
    TEXT("MSGlobalFolderOptionsStub"),      // unicpp\options.cpp
    TEXT("DivWindow"),                      // fsrchdlg.h
    TEXT("ATL Shell Embedding"),            // unicpp\dvoc.h
    TEXT("ShellFileSearchControl"),         // fsearch.h
    TEXT("GroupButton"),                    // fsearch
    TEXT("ATL:STATIC"),                     // unicpp\deskmovr.cpp
    TEXT("DeskMover"),                      // unicpp\deskmovr.cpp
    TEXT("SysFader"),                       // menuband\fadetsk.cpp
    c_szUserEventWindow,                    // uevttmr.cpp
    LINKWINDOW_CLASS,                       // linkwnd.cpp
    TEXT("DUIViewWndClassName"),            // duiview.cpp
    TEXT("DUIMiniPreviewer"),               // duiinfo.cpp
};

void _ProcessDetach(BOOL bProcessShutdown)
{
#ifdef DEBUG
    if (bProcessShutdown)
    {
        // to catch bugs where people use the task allocator at process
        // detatch time (this is a problem becuase OLE32.DLL could be unloaded)
        TaskMem_MakeInvalid(); 
    }

    g_hinst = (HINSTANCE)1;
#endif

    FlushRunDlgMRU();

    FlushFileClass();

    if (!bProcessShutdown)
    {
        // some of these may use the task allocator. we can only do
        // this when we our DLL is being unloaded in a process, not
        // at process term since OLE32 might not be around to be called
        // at process shutdown time this memory will be freed as a result
        // of the process address space going away.

        SpecialFolderIDTerminate();
        BitBucket_Terminate();

        UltRoot_Term();
        RLTerminate();          // close our use of the Registry list...
        DAD_ProcessDetach();

        CopyHooksTerminate();
        IconOverlayManagerTerminate();

        // being unloaded via FreeLibrary, then do some more stuff.
        // Don't need to do this on process terminate.
        SHUnregisterClasses(HINST_THISDLL, c_rgszClasses, ARRAYSIZE(c_rgszClasses));
        FreeExtractIconInfo(-1);

        FreeUndoList();
        DestroyHashItemTable(NULL);
        FileIconTerm();
    }

    SHChangeNotifyTerminate(TRUE, bProcessShutdown);

    if (!bProcessShutdown)
    {
        // this line was moved from the above !bProcessShutdown block because
        // it needs to happen after SHChangeNotifyTerminate b/c the SCHNE code has 
        // a thread running that uses the CDrivesFolder global psf. 

        // NOTE: this needs to be in a !bProcessShutdown block since it calls the 
        // task allocator and we blow this off at shutdown since OLE might already
        // be gone.
        CDrives_Terminate();
    }

    // global resources that we need to free in all cases
    CMtPt_FinalCleanUp();

    // Delete the Crit Sect for the Autoplay prompts
    DeleteCriticalSection(&g_csAutoplayPrompt);

    if ((DWORD) -1 != g_dwThreadBindCtx)
        TlsFree(g_dwThreadBindCtx);
    
    SHDestroyCachedGlobalCounter(&g_hCounter);
    SHDestroyCachedGlobalCounter(&g_hRestrictions);
    SHDestroyCachedGlobalCounter(&g_hSettings);

    if (g_hklmApprovedExt && g_hklmApprovedExt != INVALID_HANDLE_VALUE)
        RegCloseKey(g_hklmApprovedExt);

    UnInitializeDirectUI();
    DeleteCriticalSection(&g_csDll);
    DeleteCriticalSection(&g_csSCN);
    DeleteCriticalSection(&g_csTNGEN);
    DeleteCriticalSection(&g_csDarwinAds);

    SHFusionUninitialize();
}

BOOL _ThreadDetach()
{
    ASSERTNONCRITICAL           // Thread shouldn't term while holding CS
    DAD_ThreadDetach();
    return TRUE;
}

STDAPI_(BOOL) DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fRet = TRUE;
#ifdef DEBUG
    g_bInDllEntry = TRUE;
#endif

    switch(dwReason) 
    {
    case DLL_PROCESS_ATTACH:
        if (fRet)
        {
            CcshellGetDebugFlags();     // Don't put this line under #ifdef
            fRet = _ProcessAttach(hDll);
        }

        break;

    case DLL_PROCESS_DETACH:
        _ProcessDetach(lpReserved != NULL);
        break;

    case DLL_THREAD_DETACH:
        _ThreadDetach();
        break;

    default:
        break;
    }

    if (fRet)
        ATL_DllMain(hDll, dwReason, lpReserved);

#ifdef DEBUG
    g_bInDllEntry = FALSE;
#endif

    return fRet;
}

#ifdef DEBUG
LRESULT WINAPI SendMessageD( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    ASSERTNONCRITICAL;
#ifdef UNICODE
    return SendMessageW(hWnd, Msg, wParam, lParam);
#else
    return SendMessageA(hWnd, Msg, wParam, lParam);
#endif
}

//
//  In DEBUG, make sure every class we register lives in the c_rgszClasses
//  table so we can clean up properly at DLL unload.  NT does not automatically
//  unregister classes when a DLL unloads, so we have to do it manually.
//
ATOM WINAPI RegisterClassD(CONST WNDCLASS *pwc)
{
    int i;
    for (i = 0; i < ARRAYSIZE(c_rgszClasses); i++) 
    {
        if (lstrcmpi(c_rgszClasses[i], pwc->lpszClassName) == 0) 
        {
            return RealRegisterClass(pwc);
        }
    }
    AssertMsg(0, TEXT("Class %s needs to be added to the c_rgszClasses list"), pwc->lpszClassName);
    return 0;
}

ATOM WINAPI RegisterClassExD(CONST WNDCLASSEX *pwc)
{
    int i;
    for (i = 0; i < ARRAYSIZE(c_rgszClasses); i++) 
    {
        if (lstrcmpi(c_rgszClasses[i], pwc->lpszClassName) == 0) 
        {
            return RealRegisterClassEx(pwc);
        }
    }
    AssertMsg(0, TEXT("Class %s needs to be added to the c_rgszClasses list"), pwc->lpszClassName);
    return 0;
}

//
//  In DEBUG, send FindWindow through a wrapper that ensures that the
//  critical section is not taken.  FindWindow'ing for a window title
//  sends inter-thread WM_GETTEXT messages, which is not obvious.
//
STDAPI_(HWND) FindWindowD(LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    return FindWindowExD(NULL, NULL, lpClassName, lpWindowName);
}

STDAPI_(HWND) FindWindowExD(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    if (lpWindowName) 
    {
        ASSERTNONCRITICAL;
    }
    return RealFindWindowEx(hwndParent, hwndChildAfter, lpClassName, lpWindowName);
}

#endif // DEBUG

STDAPI DllCanUnloadNow()
{
    // shell32 won't be able to be unloaded since there are lots of APIs and
    // other non COM things that will need to keep it loaded
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\inistg.cpp ===
#include "shellprv.h"
#pragma  hdrstop

class CPropertySetStg;

class CPropertyStg : public IPropertyStorage
{
public:
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // IPropertyStorage
    STDMETHODIMP ReadMultiple(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgpropvar[]);
    STDMETHODIMP WriteMultiple(ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgpropvar[], PROPID propidNameFirst);
    STDMETHODIMP DeleteMultiple(ULONG cpspec, const PROPSPEC rgpspec[]);
    STDMETHODIMP ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[]);
    STDMETHODIMP WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[]);
    STDMETHODIMP DeletePropertyNames(ULONG cpropid, const PROPID rgpropid[]);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert(void);
    STDMETHODIMP Enum(IEnumSTATPROPSTG **ppenum);
    STDMETHODIMP SetTimes(const FILETIME *pctime, const FILETIME *patime,const FILETIME *pmtime);
    STDMETHODIMP SetClass(REFCLSID clsid);
    STDMETHODIMP Stat(STATPROPSETSTG *pstatpsstg);

    CPropertyStg(CPropertySetStg *ppss, REFFMTID fmtid, DWORD grfMode);
    void FMTIDPIDToSectionProp(REFFMTID fmtid, PROPID pid, LPTSTR pszSection, LPTSTR pszValueName);

private:
    ~CPropertyStg();
    BOOL _SectionValueName(const PROPSPEC *ppspec, 
                           LPTSTR pszSection, UINT cchSection, LPTSTR pszValueName, UINT cchValueName);
    HRESULT _ReadProp(const PROPSPEC *ppspec, PROPVARIANT *ppropvar);

    LONG            _cRef;
    CPropertySetStg *_ppss;     // back ptr to parent
    REFFMTID        _fmtid;
    DWORD           _grfMode;
};

class CPropertySetStg : public IPropertySetStorage
{
    friend CPropertyStg;
public:
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // IPropertySetStorage
    STDMETHODIMP Create(REFFMTID fmtid, const CLSID * pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Delete(REFFMTID fmtid);
    STDMETHODIMP Enum(IEnumSTATPROPSETSTG** ppenum);

    CPropertySetStg(LPCTSTR pszFolder, DWORD grfMode);

    LPCTSTR IniFile() { return _szIniFile; }

private:
    ~CPropertySetStg();
    HRESULT _LoadPropHandler();

    LONG        _cRef;
    DWORD       _grfMode;               // The mode that we opened the file in.
    TCHAR       _szIniFile[MAX_PATH];   // desktop.ini path
};


CPropertySetStg::CPropertySetStg(LPCTSTR pszFolder, DWORD grfMode) : _cRef(1), _grfMode(grfMode)
{
    PathCombine(_szIniFile, pszFolder, TEXT("desktop.ini"));
}

CPropertySetStg::~CPropertySetStg()
{
}

STDMETHODIMP CPropertySetStg::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPropertySetStg, IPropertySetStorage),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CPropertySetStg::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CPropertySetStg::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CPropertySetStg::_LoadPropHandler()
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertySetStg::Create(REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags, 
                                     DWORD grfMode, IPropertyStorage **pppropstg)
{
    *pppropstg = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CPropertySetStg::Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage **pppropstg)
{
    *pppropstg = new CPropertyStg(this, fmtid, grfMode);
    return *pppropstg ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CPropertySetStg::Delete(REFFMTID fmtid)
{
    return STG_E_ACCESSDENIED;
}

STDMETHODIMP CPropertySetStg::Enum(IEnumSTATPROPSETSTG **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}


CPropertyStg::CPropertyStg(CPropertySetStg *ppss, REFFMTID fmtid, DWORD grfMode) : _ppss(ppss), _fmtid(fmtid), _grfMode(grfMode)
{
    _ppss->AddRef();
}

CPropertyStg::~CPropertyStg()
{
    _ppss->Release();
}

STDMETHODIMP CPropertyStg::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPropertyStg, IPropertyStorage),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CPropertyStg::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CPropertyStg::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

BOOL CPropertyStg::_SectionValueName(const PROPSPEC *ppspec, 
                                     LPTSTR pszSection, UINT cchSection,
                                     LPTSTR pszValueName, UINT cchValueName)
{
    *pszSection = *pszValueName = 0;

    if (_fmtid == FMTID_SummaryInformation)
    {
        if (PIDSI_COMMENTS == ppspec->propid)
        {
            lstrcpyn(pszSection, TEXT(".ShellClassInfo"), cchSection);
            lstrcpyn(pszValueName, TEXT("InfoTip"), cchValueName);
        }
    }

    if (!*pszSection || !*pszValueName)
    {
        if (PID_CODEPAGE < ppspec->propid)
        {
            SHStringFromGUID(_fmtid, pszSection, cchSection);
            if (PRSPEC_LPWSTR == ppspec->ulKind)
            {
                SHUnicodeToTChar(ppspec->lpwstr, pszValueName, cchValueName);
            }
            else if (PRSPEC_PROPID == ppspec->ulKind)
            {
                wnsprintf(pszValueName, cchValueName, TEXT("Prop%d"), ppspec->propid);
            }
        }
    }
    return (*pszSection && *pszValueName) ? TRUE : FALSE;
}

HRESULT CPropertyStg::_ReadProp(const PROPSPEC *ppspec, PROPVARIANT *ppropvar)
{
    PropVariantInit(ppropvar);  // init out param to VT_EMPTY
    HRESULT hr = S_FALSE;

    TCHAR szSection[128], szPropName[128];
    if (_SectionValueName(ppspec, szSection, ARRAYSIZE(szSection), szPropName, ARRAYSIZE(szPropName)))
    {
        TCHAR szValue[128];
        UINT cch = GetPrivateProfileString(szSection, szPropName, TEXT(""), szValue, ARRAYSIZE(szValue), _ppss->IniFile());
        if (cch)
        {
            hr = SHStrDup(szValue, &ppropvar->pwszVal);
            if (SUCCEEDED(hr))
                ppropvar->vt = VT_LPWSTR;
        }
    }
    return hr;
}

STDMETHODIMP CPropertyStg::ReadMultiple(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgpropvar[])
{
    HRESULT hr = S_FALSE;
    UINT cRead = 0;
    for (UINT i = 0; i < cpspec; i++)
    {
        hr = _ReadProp(&rgpspec[i], &rgpropvar[i]);
        if (S_OK == hr)
        {
            cRead++;
        }

        if (FAILED(hr))
        {
            FreePropVariantArray(i, rgpropvar);
            cRead = 0;
            break;
        }
    }

    if (cRead)
        hr = S_OK;  // at least one non VT_EMPTY property read

    return hr;
}

STDMETHODIMP CPropertyStg::WriteMultiple(ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgpropvar[], PROPID propidNameFirst)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::DeleteMultiple(ULONG cpspec, const PROPSPEC rgpspec[])
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[])
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[])
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::DeletePropertyNames(ULONG cpropid, const PROPID rgpropid[])
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::Commit(DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::Revert(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::Enum(IEnumSTATPROPSTG **ppenum)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::SetTimes(const FILETIME *pctime, const FILETIME *patime,const FILETIME *pmtime)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::SetClass(REFCLSID clsid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::Stat(STATPROPSETSTG *pstatpsstg)
{
    return E_NOTIMPL;
}

STDAPI SHCreatePropStgOnFolder(LPCTSTR pszFolder, DWORD grfMode, IPropertySetStorage **ppss)
{
    *ppss = (IPropertySetStorage *)new CPropertySetStg(pszFolder, grfMode);
    return *ppss ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\isproc.h ===
//  Contents: CStorageProcessor class def'n

#pragma once
#include "resource.h"       // main symbols
#include <dpa.h>

//
// Map of storage operations -> string resources
// 

typedef struct tagSTC_CR_PAIR
{ 
    STGTRANSCONFIRMATION stc; 
    CONFIRMATIONRESPONSE cr; 

    bool operator==(const STGTRANSCONFIRMATION & r_stc) const { return TRUE==IsEqualIID(stc, r_stc); }
    tagSTC_CR_PAIR(STGTRANSCONFIRMATION o_stc, CONFIRMATIONRESPONSE o_cr) { stc=o_stc; cr=o_cr; }
} STC_CR_PAIR;

typedef struct tagSTGOP_DETAIL
{
    STGOP stgop; 
    UINT  idTitle; 
    UINT  idPrep; 
    SPACTION spa;
} STGOP_DETAIL;


// Maximum number of advise sinks that can be registered with us at any one time

const DWORD MAX_SINK_COUNT = 32;

class CStorageProcessor : 
    public IStorageProcessor,
    public ITransferAdviseSink,
    public ISupportErrorInfo,
    public IOleWindow,
    public CComObjectRoot,
    public CComCoClass<CStorageProcessor,&CLSID_StorageProcessor>
{
public:
    CStorageProcessor();
    virtual ~CStorageProcessor();
    
    BEGIN_COM_MAP(CStorageProcessor)
        COM_INTERFACE_ENTRY(IStorageProcessor)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IOleWindow)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_StorageProcessor)

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // IStorageProcessor
    STDMETHOD(SetProgress)(IActionProgress *pap);
    STDMETHOD(Run)(IEnumShellItems *penum, IShellItem *psiDest, STGOP dwOperation, DWORD dwOptions);
    STDMETHOD(SetLinkFactory)(REFCLSID clsid);
    STDMETHOD(Advise)(ITransferAdviseSink *pAdvise, DWORD *dwCookie);
    STDMETHOD(Unadvise)(DWORD dwCookie);

    // IStorageAdciseSink
    STDMETHOD(PreOperation)(const STGOP op, IShellItem *psiItem, IShellItem *psiDest);
    STDMETHOD(ConfirmOperation)(IShellItem *psiSource, IShellItem *psiDest, STGTRANSCONFIRMATION stc, LPCUSTOMCONFIRMATION pcc);
    STDMETHOD(OperationProgress)(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, ULONGLONG ullTotal, ULONGLONG ullComplete);
    STDMETHOD(PostOperation)(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, HRESULT hrResult);
    STDMETHOD(QueryContinue)();

    // IOleWindow
    STDMETHOD(GetWindow) (HWND * lphwnd);
    STDMETHOD(ContextSensitiveHelp) (BOOL fEnterMode) {  return E_NOTIMPL; };

private:
    // The operation and options originally passed in

    STGOP _dwOperation;
    DWORD _dwOptions;

    CComPtr<ITransferAdviseSink> _aspSinks[MAX_SINK_COUNT];

    STDMETHOD(_Run)(IEnumShellItems *penum, IShellItem *psiDest, ITransferDest *ptdDest, STGOP dwOperation, DWORD dwOptions);

    // Walks the storage(s) performing whatever main operation has been requested
    HRESULT _WalkStorage(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest);
    HRESULT _WalkStorage(IEnumShellItems *penum, IShellItem *psiDest, ITransferDest *ptdDest);

    // Worker functions that perform the bulk of the actual storage work.  The
    // storage operations are recursive (ie: DoRemoveStorage will prune an entire branch).

    HRESULT _DoStats(IShellItem *psi);
    HRESULT _DoCopy(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest, DWORD dwStgXFlags);
    HRESULT _DoMove(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest);
    HRESULT _DoRemove(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest);

    // Based on the user's answers to previous confirmations, returns the
    // appropriate CreateStorage() or OpenStorage() flags

    DWORD _GetCreateStorageFlags();
    DWORD _GetOpenStorageFlags();

    HRESULT _GetDefaultResponse(STGTRANSCONFIRMATION    stc, LPCONFIRMATIONRESPONSE  pcrResponse);

    // Takes the current error code and massages it based on the result of
    // a current or previous user response to a confirmation dialog

    HRESULT _DoConfirmations(STGTRANSCONFIRMATION  stc, CUSTOMCONFIRMATION  *pcc, IShellItem *psiSource, IShellItem *psiDest);

    BOOL _IsStream(IShellItem *psi);
    BOOL _ShouldWalk(IShellItem *psi);
    ULONGLONG _GetSize(IShellItem *psi);
    HRESULT _BindToHandlerWithMode(IShellItem *psi, STGXMODE grfMode, REFIID riid, void **ppv);

    // Updates the time estimate, and if the dialog is being used, it as well
    void _UpdateProgress(ULONGLONG ullCurrentComplete, ULONGLONG ullCurrentTotal);

    // Starts the progress dialog

    HRESULT _StartProgressDialog(const STGOP_DETAIL *popid);

    // CStgStatistics
    //
    // Wrapper for STGSTATS that provides some accounting helper functions

    class CStgStatistics
    {
    public:                
        CStgStatistics()
        {
        }

        ULONGLONG Bytes()     const { return _cbSize; }
        DWORD     Streams()   const { return _cStreams; }
        DWORD     Storages()  const { return _cStorages; }
        ULONGLONG Cost(DWORD, ULONGLONG cbExtra) const;
        DWORD AddStream(ULONGLONG cbSize);
        DWORD AddStorage();

    private:
        ULONGLONG _cbSize;
        DWORD _cStreams;
        DWORD _cStorages;
    };

    CStgStatistics _statsTodo;
    CStgStatistics _statsDone;
    DWORD          _msTicksLast;       // Tick count at last point update
    DWORD          _msStarted;         // When we started tracking points
    ULONGLONG _cbCurrentSize;

    DWORD _StreamsToDo() const  { return _statsTodo.Streams();  }
    DWORD _StoragesToDo() const { return _statsTodo.Storages();  }

    // Progress dialog.  Pointer will be NULL if no progress is requrested.

    CComPtr<IActionProgress> _spProgress;    
    CComPtr<IActionProgressDialog> _spShellProgress;    

    CComPtr<ITransferDest>      _spSrc;
    CComPtr<ITransferDest>      _spDest;
    ITransferConfirmation    *_ptc;
    const STATSTG          *_pstatSrc;
    CLSID                    _clsidLinkFactory;
    // A tree (map) of responses given to various previous confirmations
    CDSA<STC_CR_PAIR> _dsaConfirmationResponses;
};


STDAPI CreateStg2StgExWrapper(IShellItem *psi, IStorageProcessor *pEngine, ITransferDest **pptd);
HRESULT AutoCreateName(IShellItem *psiDest, IShellItem *psi, LPWSTR *ppszName);
HRESULT TransferDataObject(IDataObject *pdoSource, IShellItem *psiDest, STGOP dwOperation, DWORD dwOptions, ITransferAdviseSink *ptas);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\isproc.cpp ===
#include "shellprv.h"
#include "ids.h"
#pragma hdrstop

#include "isproc.h"
#include "ConfirmationUI.h"
#include "clsobj.h"
#include "datautil.h"
#include "prop.h" // SCID_SIZE

BOOL _HasAttributes(IShellItem *psi, SFGAOF flags);

STDAPI CStorageProcessor_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    CComObject<CStorageProcessor> *pObj = NULL;
    HRESULT hr = CComObject<CStorageProcessor>::CreateInstance(&pObj);
    if (SUCCEEDED(hr))
    {
        // ATL creates the object with no refcount, but this initial QI will give it one
        hr = pObj->QueryInterface(riid, ppv);
        if (SUCCEEDED(hr))
            return hr;
        else
            delete pObj;
    }

    *ppv = NULL;
    return hr;
}

//
// These operators allow me to mix int64 types with the old LARGE_INTEGER
// unions without messing with the QuadPart members in the code.
//

inline ULONGLONG operator + (const ULARGE_INTEGER i, const ULARGE_INTEGER j)
{
    return i.QuadPart + j.QuadPart;
}

inline ULONGLONG operator + (const ULONGLONG i, const ULARGE_INTEGER j)
{
    return i + j.QuadPart;
}

bool operator<(const GUID & lh, const GUID & rh)
{
    return (memcmp(&lh, &rh, sizeof(GUID))<0)?TRUE:FALSE;
}

//
// Progress dialog text while gathering stats.  Unordered, unsorted lookup table.
//

#define OPDETAIL(op, title, prep, action)   {op, title, prep, action}
const STGOP_DETAIL s_opdetail[] = 
{
    OPDETAIL(STGOP_STATS,               IDS_GATHERINGSTATS,  IDS_SCANNING,        SPACTION_CALCULATING),
    OPDETAIL(STGOP_COPY,                IDS_ACTIONTITLECOPY, IDS_PREPARINGTOCOPY, SPACTION_COPYING),
    OPDETAIL(STGOP_COPY_PREFERHARDLINK, IDS_ACTIONTITLECOPY, IDS_PREPARINGTOCOPY, SPACTION_COPYING),
    OPDETAIL(STGOP_MOVE,                IDS_ACTIONTITLEMOVE, IDS_PREPARINGTOMOVE, SPACTION_MOVING),
};

CStorageProcessor::CStorageProcessor() : _clsidLinkFactory(CLSID_ShellLink)
{
    ASSERT(!_msTicksLast);
    ASSERT(!_msStarted);
    ASSERT(!_pstatSrc);
    ASSERT(!_ptc);
}

CStorageProcessor::~CStorageProcessor()
{
    ATOMICRELEASE(_ptc);
    if (_dsaConfirmationResponses)
        _dsaConfirmationResponses.Destroy();
}

HRESULT CStorageProcessor::GetWindow(HWND * phwnd)
{
    return IUnknown_GetWindow(_spProgress, phwnd);
}

// Placeholder.  If I move to an exception model, I'll add errorinfo support,
// but not in the current implementation

STDMETHODIMP CStorageProcessor::InterfaceSupportsErrorInfo(REFIID riid)
{
    return S_FALSE;
}

// Allows clients to register an advise sink

STDMETHODIMP CStorageProcessor::Advise(ITransferAdviseSink *pAdvise, DWORD *pdwCookie)
{
    *pdwCookie = 0;

    for (DWORD i = 0; i < ARRAYSIZE(_aspSinks); i++)
    {
        if (!_aspSinks[i])    
        {
            _aspSinks[i] = pAdvise; // smart pointer, do not call pAdvise->AddRef();
            *pdwCookie = i+1;    // Make it 1-based so 0 is not valid
            return S_OK;
        }
    }
    
    return E_OUTOFMEMORY;       // No empty slots
}

// Allows clients to register an advise sink

STDMETHODIMP CStorageProcessor::Unadvise(DWORD dwCookie)
{
    // Remember dwCookie == slot + 1, to be 1-based

    if (!dwCookie || dwCookie > ARRAYSIZE(_aspSinks))
        return E_INVALIDARG;
                    
    if (!_aspSinks[dwCookie-1])
        return E_INVALIDARG;

    _aspSinks[dwCookie-1] = NULL; // smart pointer, no need to release

    return S_OK;
}

// Computes stats (if requested) and launches the actual storage operation

STDMETHODIMP CStorageProcessor::Run(IEnumShellItems *penum, IShellItem *psiDest, STGOP dwOperation, DWORD dwOptions)
{
    if (!penum || !psiDest)
        return E_INVALIDARG;

    ITransferDest *ptdDest;
    HRESULT hr = _BindToHandlerWithMode(psiDest, STGX_MODE_READWRITE, IID_PPV_ARG(ITransferDest, &ptdDest));
    if (SUCCEEDED(hr))
    {
        hr = _Run(penum, psiDest, ptdDest, dwOperation, dwOptions);
        ptdDest->Release();
    }

    return hr;
}

// defined in copy.c
EXTERN_C void DisplayFileOperationError(HWND hParent, int idVerb, int wFunc, int nError, LPCTSTR szReason, LPCTSTR szPath, LPCTSTR szDest); 

STDMETHODIMP CStorageProcessor::_Run(IEnumShellItems *penum, IShellItem *psiDest, ITransferDest *ptdDest, STGOP dwOperation, DWORD dwOptions)
{
    switch (dwOperation)
    {
    case STGOP_MOVE:
    case STGOP_COPY:
    case STGOP_STATS:
    case STGOP_REMOVE:
    case STGOP_COPY_PREFERHARDLINK:
        // parameter validation done in ::Run
        break;

        // not yet implemented
    case STGOP_RENAME:
    case STGOP_DIFF:
    case STGOP_SYNC:
        return E_NOTIMPL;

        // any other value is an invalid operation
    default:
        return E_INVALIDARG;
    }

    const STGOP_DETAIL *popd = NULL;
    for (int i=0; i < ARRAYSIZE(s_opdetail); i++)
    {
        if (s_opdetail[i].stgop == dwOperation)
        {
            popd = &s_opdetail[i];
            break;
        }
    }

    if (!_dsaConfirmationResponses)
    {
        // If we don't have a confirmation array yet, make one
        _dsaConfirmationResponses.Create(4);
    }
    else
    {
        // well, no one currently reuses the engine for multiple operations
        // but, move operation reenters the engine (for recursive move)
        // so we need to preserve the answers, so comment this out
        
        // If we do have one then it's got left over confirmations from the previous call
        // to run so we should delete all those.
        //_dsaConfirmationResponses.DeleteAllItems();
    }

    if (popd)
    {
        PreOperation(dwOperation, NULL, NULL);

        HRESULT hr = S_FALSE;
        
        if (IsFlagClear(dwOptions, STOPT_NOSTATS))
        {
            if (IsFlagClear(dwOptions, STOPT_NOPROGRESSUI))
                _StartProgressDialog(popd);

            if (_spProgress)
            {
                // Put the "Preparing to Whatever" text in the dialog
                WCHAR szText[MAX_PATH];
                LoadStringW(_Module.GetModuleInstance(), popd->idPrep, szText, ARRAYSIZE(szText));
                _spProgress->UpdateText(SPTEXT_ACTIONDETAIL, szText, TRUE);
            }
            
            // Compute the stats we need
            _dwOperation = STGOP_STATS;
            _dwOptions   = STOPT_NOCONFIRMATIONS;
            HRESULT hrProgressBegin;
            if (_spProgress)
                hrProgressBegin = _spProgress->Begin(SPACTION_SEARCHING_FILES, SPBEGINF_MARQUEEPROGRESS);

            penum->Reset();
            hr = _WalkStorage(penum, psiDest, ptdDest);
            if (_spProgress && SUCCEEDED(hrProgressBegin))
            {
                _spProgress->End();
                // Remove the "Preparing to Whatever" text from the dialog
                _spProgress->UpdateText(SPTEXT_ACTIONDETAIL, L"", FALSE);
            }
        }

        if (SUCCEEDED(hr))
        {
            _dwOperation = (STGOP) dwOperation;
            _dwOptions   = dwOptions;

            HRESULT hrProgressBegin;
            if (_spProgress)
                hrProgressBegin = _spProgress->Begin(popd->spa, SPBEGINF_AUTOTIME);

            penum->Reset();
            hr = _WalkStorage(penum, psiDest, ptdDest);
            if (_spProgress && SUCCEEDED(hrProgressBegin))
                _spProgress->End();
        }

        if (IsFlagClear(dwOptions, STOPT_NOSTATS) && _spProgress)
        {
            // this should only be called if we called the matching FlagClear-NOSTATS above.
            //  smartpointers NULL on .Release();
            _spProgress.Release();
            if (_spShellProgress)
            {
                _spShellProgress->Stop();
                _spShellProgress.Release();
            }
        }

        SHChangeNotifyHandleEvents();

        PostOperation(dwOperation, NULL, NULL, hr);

        return hr;
    }
    else
    {
        AssertMsg(0, TEXT("A valid operation is missing from the s_opdetail array, was a new operation added? (%d)"), dwOperation);
    }
    
    return E_INVALIDARG;
}

// Does a depth-first walk of the storage performing the requested
// operation.

HRESULT CStorageProcessor::_WalkStorage(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest)
{
    HRESULT hr = S_FALSE;
    
    if (_ShouldWalk(psi))
    {
        IEnumShellItems *penum;
        hr = psi->BindToHandler(NULL, BHID_StorageEnum, IID_PPV_ARG(IEnumShellItems, &penum));
        if (SUCCEEDED(hr))
        {
            hr = _WalkStorage(penum, psiDest, ptdDest);
            penum->Release();
        }
    }
    return hr;
}

HRESULT CStorageProcessor::_WalkStorage(IEnumShellItems *penum, IShellItem *psiDest, ITransferDest *ptdDest)
{
    DWORD dwCookie;
    if (ptdDest)
        ptdDest->Advise(static_cast<ITransferAdviseSink*>(this), &dwCookie);

    HRESULT hr;
    IShellItem *psi;
    while (S_OK == (hr = penum->Next(1, &psi, NULL)))
    {
        // skip anything we can't work with
        if (_HasAttributes(psi, SFGAO_STORAGE | SFGAO_STREAM))
        {    
            if (_spProgress)
            {
                // We don't show filenames while collecting stats
                if (_dwOperation != STGOP_STATS)
                {
                    LPWSTR pszName;
                    if (SUCCEEDED(psi->GetDisplayName(SIGDN_PARENTRELATIVEFORADDRESSBAR, &pszName)))
                    {
                        _spProgress->UpdateText(SPTEXT_ACTIONDETAIL, pszName, TRUE);
                        CoTaskMemFree(pszName);
                    }
                }
            }

            if (_dwOperation != STGOP_STATS)
                _UpdateProgress(0, 0);

            DWORD dwFlagsExtra = 0;
            switch (_dwOperation)
            {
                case STGOP_STATS:
                    hr = _DoStats(psi);
                    break;

                case STGOP_COPY_PREFERHARDLINK:
                    dwFlagsExtra = STGX_MOVE_PREFERHARDLINK;
                    // fall through
                case STGOP_COPY:
                    hr = _DoCopy(psi, psiDest, ptdDest, dwFlagsExtra);
                    break;

                case STGOP_MOVE:
                    hr = _DoMove(psi, psiDest, ptdDest);
                    break;

                case STGOP_REMOVE:
                    hr = _DoRemove(psi, psiDest, ptdDest);
                    break;

                case STGOP_RENAME:
                case STGOP_DIFF:
                case STGOP_SYNC:
                    hr = E_NOTIMPL;
                    break;

                default:
                    hr = E_UNEXPECTED;
                    break;
            }

            if (S_OK != QueryContinue())
                hr = STRESPONSE_CANCEL;
        }
        else if (STGOP_COPY_PREFERHARDLINK == _dwOperation || STGOP_COPY == _dwOperation || STGOP_MOVE == _dwOperation)
        {
            CUSTOMCONFIRMATION cc = {sizeof(cc)};
            cc.dwButtons = CCB_OK;
            cc.dwFlags = CCF_SHOW_SOURCE_INFO | CCF_USE_DEFAULT_ICON;
            UINT idDesc = (STGOP_MOVE == _dwOperation ? IDS_NO_STORAGE_MOVE : IDS_NO_STORAGE_COPY);
            cc.pwszDescription = ResourceCStrToStr(g_hinst, (LPCWSTR)(UINT_PTR)idDesc);
            if (cc.pwszDescription)
            {
                UINT idTitle = (STGOP_MOVE == _dwOperation ? IDS_UNKNOWN_MOVE_TITLE : IDS_UNKNOWN_COPY_TITLE);
                cc.pwszTitle = ResourceCStrToStr(g_hinst, (LPCWSTR)(UINT_PTR)idTitle);
                if (cc.pwszTitle)
                {
                    ConfirmOperation(psi, NULL, GUID_NULL, &cc);
                    LocalFree(cc.pwszTitle);
                }
                LocalFree(cc.pwszDescription);
            }
        }

        psi->Release();
        
        if (FAILED(hr) && STRESPONSE_SKIP != hr)
            break;
    }
    
    // We'll always get to the "no more Streams" stage, so this is meaningless

    if (S_FALSE == hr)
        hr = S_OK;

    if (ptdDest)
        ptdDest->Unadvise(dwCookie);

    return hr;
}

HRESULT CStorageProcessor::_DoConfirmations(STGTRANSCONFIRMATION stc, CUSTOMCONFIRMATION *pcc, IShellItem *psiItem, IShellItem *psiDest)
{
    CONFIRMATIONRESPONSE crResponse = (CONFIRMATIONRESPONSE)E_FAIL;
    HRESULT hr = _GetDefaultResponse(stc, &crResponse);
    if (FAILED(hr))
    {
        // If we don't have a default answer, then call the confirmation UI, it will return the repsonse
        hr = S_OK;
        // should be able to supply the CLSID of an alternate implementation and we should CoCreate the object.
        if (!_ptc)
            hr = CTransferConfirmation_CreateInstance(NULL, IID_PPV_ARG(ITransferConfirmation, &_ptc));
        
        if (SUCCEEDED(hr))
        {
            BOOL bAll;
            CONFIRMOP cop;
            cop.dwOperation = _dwOperation;
            cop.stc = stc;
            cop.pcc = pcc;
            cop.cRemaining = _StreamsToDo() + _StoragesToDo();
            cop.psiItem = psiItem;
            cop.psiDest = psiDest;
            cop.pwszRenameTo = NULL;
            cop.punkSite = SAFECAST(this, IStorageProcessor*);

            hr = _ptc->Confirm(&cop, &crResponse, &bAll);
            if (SUCCEEDED(hr))
            {
                if (bAll)
                {
                    // if the confirmation UI says "do for all" then add hrResponse to the default response map.
                    STC_CR_PAIR scp(stc, crResponse);
                    _dsaConfirmationResponses.AppendItem(&scp);
                }
            }
            else
            {
                // TODO: What do we do if we fail to ask for confirmation?
            }
        }
    }

    // TODO: Get rid of CONFIRMATIONRESPONSE and make these the same
    if (SUCCEEDED(hr))
    {
        switch (crResponse)
        {
        case CONFRES_CONTINUE:
            hr = STRESPONSE_CONTINUE;
            break;

        case CONFRES_SKIP:   
            hr = STRESPONSE_SKIP;
            break;

        case CONFRES_RETRY:
            hr = STRESPONSE_RETRY;
            break;

        case CONFRES_RENAME:
            hr = STRESPONSE_RENAME;
            break;

        case CONFRES_CANCEL:
        case CONFRES_UNDO:
            hr = STRESPONSE_CANCEL;
            break;
        }   
    }

    return hr;    
}

// Based on how the user has responded to previous confirmations figure
// out what flags we should be passing to CreateStorage

DWORD CStorageProcessor::_GetCreateStorageFlags()
{
    // Check to see if the user has ok'd all storage overwrites
    CONFIRMATIONRESPONSE hrResponse;
    if (SUCCEEDED(_GetDefaultResponse(STCONFIRM_REPLACE_STORAGE, &hrResponse) && (CONFRES_CONTINUE == hrResponse)))
        return STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT;
    else
        return STGM_FAILIFTHERE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT;
}

// Based on how the user has responded to previous confirmations figure
// out what flags we should be passing to Open

DWORD CStorageProcessor::_GetOpenStorageFlags()
{
    return STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE;
}

HRESULT CStorageProcessor::_GetDefaultResponse(STGTRANSCONFIRMATION stc,  LPCONFIRMATIONRESPONSE pcrResponse)
{
    // Look in our map to see if there's already been a default response
    // set for this condition

    for (int i=0; i<_dsaConfirmationResponses.GetItemCount(); i++)
    {
        STC_CR_PAIR *pscp = _dsaConfirmationResponses.GetItemPtr(i);
        if (*pscp == stc)
        {
            *pcrResponse = pscp->cr;
            return S_OK;
        }
    }

    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
}

HRESULT CStorageProcessor::_BindToHandlerWithMode(IShellItem *psi, STGXMODE grfMode, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;
    IBindCtx *pbc = NULL;
    if (grfMode)
        hr = BindCtx_CreateWithMode(grfMode, &pbc); // need to translate mode flags?
        
    if (SUCCEEDED(hr))
    {
        GUID bhid;

        if (IsEqualGUID(riid, IID_IStorage))
            bhid = BHID_Storage;
        else if (IsEqualGUID(riid, IID_IStream))
            bhid = BHID_Stream;
        else
            bhid = BHID_SFObject;

        hr = psi->BindToHandler(pbc, bhid, riid, ppv);
        if (FAILED(hr) && IsEqualGUID(riid, IID_ITransferDest))
            hr = CreateStg2StgExWrapper(psi, this, (ITransferDest **)ppv);

        if (pbc)
            pbc->Release();
    }

    return hr;
}

BOOL _HasAttributes(IShellItem *psi, SFGAOF flags)
{
    BOOL fReturn = FALSE;
    SFGAOF flagsOut;
    if (SUCCEEDED(psi->GetAttributes(flags, &flagsOut)) && (flags & flagsOut))
        fReturn = TRUE;

    return fReturn;
}

BOOL CStorageProcessor::_IsStream(IShellItem *psi)
{
    return _HasAttributes(psi, SFGAO_STREAM);
}

BOOL CStorageProcessor::_ShouldWalk(IShellItem *psi)
{
    return _HasAttributes(psi, SFGAO_STORAGE);
}

ULONGLONG CStorageProcessor::_GetSize(IShellItem *psi)
{
    ULONGLONG ullReturn = 0;

    // first, try to get size from the pidl, so we don't hit the disk
    IParentAndItem *ppai;
    HRESULT hr = psi->QueryInterface(IID_PPV_ARG(IParentAndItem, &ppai));
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        LPITEMIDLIST pidlChild;
        hr = ppai->GetParentAndItem(NULL, &psf, &pidlChild);
        if (SUCCEEDED(hr))
        {
            IShellFolder2 *psf2;
            hr = psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2));
            if (SUCCEEDED(hr))
            {
                hr = GetLongProperty(psf2, pidlChild, &SCID_SIZE, &ullReturn);
                psf2->Release();
            }
            psf->Release();
            ILFree(pidlChild);
        }
        ppai->Release();
    }

    // if it failed, try the stream
    if (FAILED(hr))
    {   
        //this should ask for IPropertySetStorage instead of stream...
        IStream *pstrm;
        if (SUCCEEDED(_BindToHandlerWithMode(psi, STGX_MODE_READ, IID_PPV_ARG(IStream, &pstrm))))
        {
            STATSTG stat;
            if (SUCCEEDED(pstrm->Stat(&stat, STATFLAG_NONAME)))
                ullReturn = stat.cbSize.QuadPart;

            pstrm->Release();
        }
    }

    return ullReturn;
}

HRESULT CStorageProcessor::_DoStats(IShellItem *psi)
{
    HRESULT hr = PreOperation(STGOP_STATS, psi, NULL);
    if (FAILED(hr))
        return hr;

    if (!_IsStream(psi))
    {
        _statsTodo.AddStorage();
        hr = _WalkStorage(psi, NULL, NULL);
    }
    else
    {
        _statsTodo.AddStream(_GetSize(psi));
    }

    PostOperation(STGOP_STATS, psi, NULL, hr);

    return hr;
}

HRESULT CStorageProcessor::_DoCopy(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest, DWORD dwStgXFlags)
{
    HRESULT hr = PreOperation(STGOP_COPY, psi, psiDest);
    if (FAILED(hr))
        return hr;

    LPWSTR pszNewName;
    hr = AutoCreateName(psiDest, psi, &pszNewName);
    if (SUCCEEDED(hr))
    {
        do
        {
            hr = ptdDest->MoveElement(psi, pszNewName, STGX_MOVE_COPY | STGX_MOVE_NORECURSION | dwStgXFlags);
        } 
        while (STRESPONSE_RETRY == hr);

        if (SUCCEEDED(hr))
        {
            if (!_IsStream(psi))
            {
                _statsDone.AddStorage();

                // Open the source
                IShellItem *psiNewDest;
                hr = SHCreateShellItemFromParent(psiDest, pszNewName, &psiNewDest);
                if (SUCCEEDED(hr))
                {
                    ITransferDest *ptdNewDest;
                    hr = _BindToHandlerWithMode(psiNewDest, STGX_MODE_READWRITE, IID_PPV_ARG(ITransferDest, &ptdNewDest));
                    if (SUCCEEDED(hr))
                    {
                        // And copy everything underneath
                        hr = _WalkStorage(psi, psiNewDest, ptdNewDest);
                        ptdNewDest->Release();
                    }
                    psiNewDest->Release();
                }
            }
            else
            {
                _statsDone.AddStream(_GetSize(psi));
            }
        }
        CoTaskMemFree(pszNewName);
    }
    
    PostOperation(STGOP_COPY, psi, psiDest, hr);

    return hr;
}

HRESULT CStorageProcessor::_DoMove(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest)
{
    HRESULT hr = PreOperation(STGOP_MOVE, psi, psiDest);
    if (FAILED(hr))
        return hr;

    LPWSTR pszNewName;
    hr = AutoCreateName(psiDest, psi, &pszNewName);
    if (SUCCEEDED(hr))
    {
        do 
        {
            hr = ptdDest->MoveElement(psi, pszNewName, STGX_MOVE_MOVE);
        } 
        while (STRESPONSE_RETRY == hr);

        if (SUCCEEDED(hr))
        {
            if (!_IsStream(psi))
            {
                _statsDone.AddStorage();
            }
            else
            {
                _statsDone.AddStream(_GetSize(psi));
            }
        }
        CoTaskMemFree(pszNewName);
    }

    PostOperation(STGOP_MOVE, psi, psiDest, hr);

    return hr;
}

HRESULT CStorageProcessor::_DoRemove(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest)
{
    HRESULT hr = PreOperation(STGOP_REMOVE, psi, NULL);
    if (FAILED(hr))
        return hr;

    LPWSTR pszName;
    hr = psi->GetDisplayName(SIGDN_PARENTRELATIVEFORADDRESSBAR, &pszName);
    if (SUCCEEDED(hr))
    {
        BOOL fStorage = !_IsStream(psi);
        ULONGLONG ullSize;

        if (!fStorage)
            ullSize = _GetSize(psi);
        
        // try to delete the entire storage in one operation
        do 
        {
            hr = ptdDest->DestroyElement(pszName, 0);
        } 
        while (STRESPONSE_RETRY == hr);

        if (FAILED(hr) && STRESPONSE_SKIP != hr && fStorage)
        {
            // if we fail then walk down deleting the contents
            hr = _WalkStorage(psi, psiDest, ptdDest);
            if (SUCCEEDED(hr))
            {
                // see if we can delete the storage now that it's empty
                do 
                {
                    hr = ptdDest->DestroyElement(pszName, 0);
                } 
                while (STRESPONSE_RETRY == hr);
            }
        }

        if (SUCCEEDED(hr))
        {
            if (fStorage)
            {
                _statsDone.AddStorage();
            }
            else
            {
                _statsDone.AddStream(ullSize);
            }
        }
        CoTaskMemFree(pszName);
    }

    PostOperation(STGOP_REMOVE, psi, NULL, hr);

    return hr;
}

// Recomputes the amount of estimated time remaining, and if progress
// is being displayed, updates the dialog as well

// TODO: This doesn't take into account any items that are skipped.  Skipped items
// will still be considered undone which means the operation will finish before the
// progress bar reaches the end.  To accurately remove the skipped items we would need
// to either:
// 1.) Walk a storage if it is skipped, counting the bytes
// 2.) Remember the counts in a tree when we first walked the storage
//
// Of these options I like #1 better since its simpler and #2 would waste memory to hold
// a bunch of information we can recalculate (we're already doing a sloooow operation anyway).

#define MINIMUM_UPDATE_INTERVAL         1000
#define HISTORICAL_POINT_WEIGHTING      50
#define TIME_BEFORE_SHOWING_ESTIMATE    5000

void CStorageProcessor::_UpdateProgress(ULONGLONG ullCurrentComplete, ULONGLONG ullCurrentTotal)
{
    // Ensure at least N ms has elapsed since last update
    DWORD msNow = GetTickCount();
    if ((msNow - _msTicksLast) >= MINIMUM_UPDATE_INTERVAL)
    {
        // Calc the estimated total cost to finish and work done so far

        ULONGLONG ullTotal = _statsTodo.Cost(_dwOperation, 0);
        if (ullTotal)
        {
            ULONGLONG cbExtra = ullCurrentTotal ? (_cbCurrentSize / ullCurrentTotal) * ullCurrentComplete : 0;
            ULONGLONG ullDone = _statsDone.Cost(_dwOperation, cbExtra);

            // Regardless of whether we update the text, update the status bar
            if (_spProgress)
                _spProgress->UpdateProgress(ullDone, ullTotal);

            for (int i = 0; i < ARRAYSIZE(_aspSinks); i++)
            {
                if (_aspSinks[i])
                {
                    HRESULT hr = _aspSinks[i]->OperationProgress(_dwOperation, NULL, NULL, ullTotal, ullDone);
                    if (FAILED(hr))
                        break;
                }
            }
        }
        _msTicksLast = msNow;
    }
}

DWORD CStorageProcessor::CStgStatistics::AddStream(ULONGLONG cbSize)
{
    _cbSize += cbSize;
    return ++_cStreams;
}

DWORD CStorageProcessor::CStgStatistics::AddStorage()
{
    return ++_cStorages;
}

// Computes the total time cost of performing the storage operation
// after the stats have been collected

#define COST_PER_DELETE     1
#define COST_PER_CREATE     1

ULONGLONG CStorageProcessor::CStgStatistics::Cost(DWORD op, ULONGLONG cbExtra) const
{
    ULONGLONG ullTotalCost = 0;

    // Copy and Move both need to create the target and move the bits
    if (op == STGOP_COPY || op == STGOP_MOVE || op == STGOP_COPY_PREFERHARDLINK)
    {   
        ullTotalCost += Bytes() + cbExtra;
        ullTotalCost += (Streams() + Storages()) * COST_PER_CREATE;
    }

    // Move and Remove need to delete the originals
    if (op == STGOP_MOVE || op == STGOP_REMOVE)
    {
        ullTotalCost += (Streams() + Storages()) * COST_PER_DELETE;
    }

    return ullTotalCost;
}

// Figures out what animation and title text should be displayed in
// the progress UI, and starts it

HRESULT CStorageProcessor::_StartProgressDialog(const STGOP_DETAIL *popd)
{
    HRESULT hr = S_OK;

    if (!_spProgress)
    {
        hr = CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActionProgressDialog, &_spShellProgress));
        if (SUCCEEDED(hr))
        {
            //
            // Map the requested action to the appropriate strings (like "Preparing to Copy")
            //
            ASSERT(popd);
        
            WCHAR szText[MAX_PATH];
            LoadStringW(_Module.GetModuleInstance(), popd->idTitle, szText, ARRAYSIZE(szText));

            hr = _spShellProgress->Initialize(SPINITF_MODAL, szText, NULL);
            if (SUCCEEDED(hr))
                hr = _spShellProgress->QueryInterface(IID_PPV_ARG(IActionProgress, &_spProgress));
        }
    }

    return hr;
}

HRESULT CStorageProcessor::SetProgress(IActionProgress *pspaProgress)
{
    HRESULT hr = E_FAIL;

    if (!_spProgress)
    {
        hr = E_INVALIDARG;
        if (pspaProgress)
        {
            _spProgress = pspaProgress;
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP CStorageProcessor::SetLinkFactory(REFCLSID clsid)
{
    _clsidLinkFactory = clsid;
    return S_OK;
}

// Runs through the list of registered sinks and gives each of them a shot
// at cancelling or skipping this operation

STDMETHODIMP CStorageProcessor::PreOperation(const STGOP op, IShellItem *psiItem, IShellItem *psiDest)
{
    if (psiItem)
    {
        _cbCurrentSize = _IsStream(psiItem) ? _GetSize(psiItem) : 0;
    }
    
    for (int i = 0; i < ARRAYSIZE(_aspSinks); i++)
    {
        if (_aspSinks[i])
        {
            HRESULT hr = _aspSinks[i]->PreOperation(op, psiItem, psiDest);
            if (FAILED(hr))
                return hr;
        }
    }

    return S_OK;
}

// Allow each of the sinks to confirm the operation if they'd like

STDMETHODIMP CStorageProcessor::ConfirmOperation(IShellItem *psiSource, IShellItem *psiDest, STGTRANSCONFIRMATION stc, LPCUSTOMCONFIRMATION pcc)
{
    // TODO: map the confirmation (stc) based on _dwOperation memeber varaible

    HRESULT hr = STRESPONSE_CONTINUE;
    for (int i = 0; i < ARRAYSIZE(_aspSinks); i++)
    {
        if (_aspSinks[i])
        {
            hr = _aspSinks[i]->ConfirmOperation(psiSource, psiDest, stc, pcc);
            if (FAILED(hr) || hr == STRESPONSE_RENAME)
                break;
        }
    }

    // Question:  How do we know if one of the above handlers displayed UI already?  If the
    // hr is anything other than STRESPONSE_CONTINUE then obviously the confirmation has been
    // handled already, but one of the handlers might have diplayed UI and then returned
    // STRESPONSE_CONTINUE as the users response.

    if (STRESPONSE_CONTINUE == hr)
    {
        // show default UI
        hr = _DoConfirmations(stc, pcc, psiSource, psiDest);
    }

    return hr;
}

// Apprise each of the sinks as to our current progress

STDMETHODIMP CStorageProcessor::OperationProgress(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, ULONGLONG ullTotal, ULONGLONG ullComplete)
{
    for (int i = 0; i < ARRAYSIZE(_aspSinks); i++)
    {
        if (_aspSinks[i])
        {
            HRESULT hr = _aspSinks[i]->OperationProgress(op, psiItem, psiDest, ullTotal, ullComplete);
            if (FAILED(hr))
                return hr;
        }
    }
    
    _UpdateProgress(ullComplete, ullTotal);

    return S_OK;
}

// When the operation is successfully complete, let the advises know

STDMETHODIMP CStorageProcessor::PostOperation(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, HRESULT hrResult)
{
    _cbCurrentSize = 0;
    
    HRESULT hr = S_OK;
    for (int i = 0; (S_OK == hr) && (i < ARRAYSIZE(_aspSinks)); i++)
    {
        if (_aspSinks[i])
        {
            hr = _aspSinks[i]->PostOperation(op, psiItem, psiDest, hrResult);
        }
    }
    return hr;
}

HRESULT CStorageProcessor::QueryContinue()
{
    HRESULT hr = S_OK;
    
    for (int i = 0; S_OK == hr && i < ARRAYSIZE(_aspSinks); i++)
    {
        if (_aspSinks[i])
            hr = _aspSinks[i]->QueryContinue();
    }

    if (S_OK == hr && _spProgress)
    {
        BOOL fCanceled;
        if (SUCCEEDED(_spProgress->QueryCancel(&fCanceled)) && fCanceled)
            hr = S_FALSE;
    }

    return hr;
}

HRESULT EnumShellItemsFromHIDADataObject(IDataObject *pdtobj, IEnumShellItems **ppenum)
{
    *ppenum = NULL;
    
    HRESULT hr = E_FAIL;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        LPCITEMIDLIST pidlSource = IDA_GetIDListPtr(pida, -1);
        if (pidlSource)
        {
            IDynamicStorage *pdstg;
            hr = CoCreateInstance(CLSID_DynamicStorage, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDynamicStorage, &pdstg));
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidl;
                for (UINT i = 0; SUCCEEDED(hr) && (pidl = IDA_GetIDListPtr(pida, i)); i++)
                {
                    LPITEMIDLIST pidlFull;
                    hr = SHILCombine(pidlSource, pidl, &pidlFull);
                    if (SUCCEEDED(hr))
                    {
                        hr = pdstg->AddIDList(1, &pidlFull, DSTGF_ALLOWDUP);
                        ILFree(pidlFull);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    hr = pdstg->EnumItems(ppenum);
                }
                pdstg->Release();
            }
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }

    return hr;
}

HRESULT TransferDataObject(IDataObject *pdoSource, IShellItem *psiDest, STGOP dwOperation, DWORD dwOptions, ITransferAdviseSink *ptas)
{
    IEnumShellItems *penum;
    HRESULT hr = EnumShellItemsFromHIDADataObject(pdoSource, &penum);
    if (SUCCEEDED(hr))
    {
        IStorageProcessor *psp;
        hr = CStorageProcessor_CreateInstance(NULL, IID_PPV_ARG(IStorageProcessor, &psp));
        if (SUCCEEDED(hr))
        {
            DWORD dwCookie;
            HRESULT hrAdvise;
            if (ptas)
            {
                hrAdvise = psp->Advise(ptas, &dwCookie);
            }

            hr = psp->Run(penum, psiDest, dwOperation, dwOptions);

            if (ptas && SUCCEEDED(hrAdvise))
            {
                psp->Unadvise(dwCookie);
            }
            psp->Release();
        }
        penum->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\item.cpp ===
#include "shellprv.h"
#include "cowsite.h"
#include "enumidlist.h"

typedef enum
{
    MAYBEBOOL_MAYBE = 0,
    MAYBEBOOL_TRUE,
    MAYBEBOOL_FALSE,
} MAYBEBOOL;

#define _GetBindWindow(p) NULL


class CShellItem    : public IShellItem 
                    , public IPersistIDList
                    , public IParentAndItem
{
public:
    CShellItem();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellItem
    STDMETHODIMP BindToHandler(IBindCtx *pbc, REFGUID rguidHandler, REFIID riid, void **ppv);
    STDMETHODIMP GetParent(IShellItem **ppsi);
    STDMETHODIMP GetDisplayName(SIGDN sigdnName, LPOLESTR *ppszName);        
    STDMETHODIMP GetAttributes(SFGAOF sfgaoMask, SFGAOF *psfgaoFlags);    
    STDMETHODIMP Compare(IShellItem *psi, SICHINTF hint, int *piOrder);

    // IPersist
    STDMETHODIMP GetClassID(LPCLSID lpClassID) {*lpClassID = CLSID_ShellItem; return S_OK;}
    
    // IPersistIDList
    STDMETHODIMP SetIDList(LPCITEMIDLIST pidl);
    STDMETHODIMP GetIDList(LPITEMIDLIST *ppidl);

    // IParentAndItem
    STDMETHODIMP SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf,  LPCITEMIDLIST pidlChild);
    STDMETHODIMP GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidlChild);

#if 0
    // IPersistStream
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(IStream *pStm);
    STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);

    // implement or we cant ask for the IShellFolder in GetParentAndItem()
    // IMarshal
    STDMETHODIMP GetUnmarshalClass(
        REFIID riid,
        void *pv,
        DWORD dwDestContext,
        void *pvDestContext,
        DWORD mshlflags,
        CLSID *pCid);

    STDMETHODIMP GetMarshalSizeMax(
        REFIID riid,
        void *pv,
        DWORD dwDestContext,
        void *pvDestContext,
        DWORD mshlflags,
        DWORD *pSize);

    STDMETHODIMP MarshalInterface(
        IStream *pStm,
        REFIID riid,
        void *pv,
        dwDestContext,
        void *pvDestContext,
        DWORD mshlflags);

    STDMETHODIMP UnmarshalInterface(
        IStream *pStm,
        REFIID riid,
        void **ppv);

    STDMETHODIMP ReleaseMarshalData(IStream *pStm);

    STDMETHODIMP DisconnectObject(DWORD dwReserved);
#endif // 0 

private:  // methods
    ~CShellItem();

    void _Reset(void);
    //  BindToHandler() helpers
    HRESULT _BindToParent(REFIID riid, void **ppv);
    HRESULT _BindToSelf(REFIID riid, void **ppv);
    //  GetAttributes() helpers
    inline BOOL _IsAttrib(SFGAOF sfgao);
    //  GetDisplayName() helpers
    BOOL _SupportedName(SIGDN sigdnName, SHGDNF *pflags);
    HRESULT _FixupName(SIGDN sigdnName, LPOLESTR *ppszName);
    void _FixupAttributes(IShellFolder *psf, SFGAOF sfgaoMask);

    LONG _cRef;
    LPITEMIDLIST _pidlSelf;
    LPCITEMIDLIST _pidlChild;
    LPITEMIDLIST _pidlParent;
    IShellFolder *_psfSelf;
    IShellFolder *_psfParent;
    BOOL _fInited;
    SFGAOF _sfgaoTried;
    SFGAOF _sfgaoKnown;
};

CShellItem::CShellItem() : _cRef(1)
{
    ASSERT(!_pidlSelf);
    ASSERT(!_pidlChild);
    ASSERT(!_pidlParent);
    ASSERT(!_psfSelf);
    ASSERT(!_psfParent);
}

CShellItem::~CShellItem()
{
    _Reset();
}

void CShellItem::_Reset(void)
{
    ATOMICRELEASE(_psfSelf);
    ATOMICRELEASE(_psfParent);

    ILFree(_pidlSelf);
    ILFree(_pidlParent);

    _pidlSelf = NULL;
    _pidlParent = NULL;
    _pidlChild = NULL;      // alias into _pidlParent
}
    
STDMETHODIMP CShellItem::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CShellItem, IShellItem),
        QITABENT(CShellItem, IPersistIDList),
        QITABENT(CShellItem, IParentAndItem),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CShellItem::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellItem::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CShellItem::SetIDList(LPCITEMIDLIST pidl)
{
    if (!pidl)
    {
        RIPMSG(0, "Tried to Call SetIDList with a NULL pidl");
        return E_INVALIDARG;
    }

    _Reset();

    HRESULT hr = SHILClone(pidl, &_pidlSelf);
    if (SUCCEEDED(hr))
    {
        // possible this item is the desktop in which case
        // there is no parent.
        if (ILIsEmpty(_pidlSelf))
        {
            _pidlParent = NULL;
            _pidlChild = _pidlSelf;
        }
        else
        {
            _pidlParent = ILCloneParent(_pidlSelf);
            _pidlChild = ILFindLastID(_pidlSelf);

            if (NULL == _pidlParent)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

STDMETHODIMP CShellItem::GetIDList(LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (_pidlSelf)
    {
        hr = SHILClone(_pidlSelf, ppidl);
    }

    return hr;
}

HRESULT CShellItem::_BindToParent(REFIID riid, void **ppv)
{
    ASSERT(_pidlChild); // we should already have a child setup

    if (!_psfParent && _pidlParent && _pidlSelf) // check pidlParent to check in case the item is the desktop
    {
        HRESULT hr;
        LPCITEMIDLIST pidlChild;

        hr = SHBindToIDListParent(_pidlSelf, IID_PPV_ARG(IShellFolder, &_psfParent), &pidlChild);

#ifdef DEBUG
        if (SUCCEEDED(hr))
        {
            ASSERT(pidlChild == _pidlChild);
        }
#endif // DEBUG
    }

    if (_psfParent)
    {
        return _psfParent->QueryInterface(riid, ppv);
    }

    return E_FAIL;
}

HRESULT CShellItem::_BindToSelf(REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;

    if (!_psfSelf)
    {
        hr = BindToHandler(NULL, BHID_SFObject, IID_PPV_ARG(IShellFolder, &_psfSelf));
    }

    if (_psfSelf)
    {
        hr = _psfSelf->QueryInterface(riid, ppv);
    }

    return hr;
}

HRESULT _CreateLinkTargetItem(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv)
{
    SFGAOF flags = SFGAO_LINK;
    if (SUCCEEDED(psi->GetAttributes(flags, &flags)) && (flags & SFGAO_LINK))
    {
        //  this is indeed a link
        //  get the target and 
        IShellLink *psl;
        HRESULT hr = psi->BindToHandler(pbc, BHID_SFUIObject, IID_PPV_ARG(IShellLink, &psl));

        if (SUCCEEDED(hr))
        {
            DWORD slr = 0;
            HWND hwnd = _GetBindWindow(pbc);
            
            if (pbc)
            {
                BIND_OPTS2 bo;  
                bo.cbStruct = sizeof(BIND_OPTS2); // Requires size filled in.
                if (SUCCEEDED(pbc->GetBindOptions(&bo)))
                {
                    //  these are the flags to pass to resolve
                    slr = bo.dwTrackFlags;
                }
            }

            hr = psl->Resolve(hwnd, slr);

            if (S_OK == hr)
            {
                LPITEMIDLIST pidl;
                hr = psl->GetIDList(&pidl);

                if (SUCCEEDED(hr))
                {
                    IShellItem *psiTarget;
                    hr = SHCreateShellItem(NULL, NULL, pidl, &psiTarget);

                    if (SUCCEEDED(hr))
                    {
                        hr = psiTarget->QueryInterface(riid, ppv);
                        psiTarget->Release();
                    }
                    ILFree(pidl);
                }
            }
            else if (SUCCEEDED(hr))
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

            psl->Release();
        }

        return hr;
    }

    return E_INVALIDARG;
}

BOOL _IsWebfolders(IShellItem *psi);
HRESULT _CreateStorageHelper(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv);
HRESULT _CreateStream(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv);
HRESULT _CreateEnumHelper(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv);

HRESULT _CreateHelperInstance(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv)
{
    IItemHandler *pih;
    HRESULT hr = SHCoCreateInstance(NULL, &rbhid, NULL, IID_PPV_ARG(IItemHandler, &pih));

    if (SUCCEEDED(hr))
    {
        hr = pih->SetItem(psi);

        if (SUCCEEDED(hr))
        {
            hr = pih->QueryInterface(riid, ppv);
        }
        pih->Release();
    }

    return hr;
}
    
enum 
{
    BNF_OBJECT          = 0x0001,
    BNF_UIOBJECT        = 0x0002,
    BNF_VIEWOBJECT      = 0x0004,
    BNF_USE_RIID        = 0x0008,
    BNF_REFLEXIVE       = 0x0010,
};
typedef DWORD BNF;

typedef HRESULT (* PFNCREATEHELPER)(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv);

typedef struct
{
    const GUID *pbhid;
    BNF bnf;
    const IID *piid;
    PFNCREATEHELPER pfn;
} BINDNONSENSE;

#define BINDHANDLER(bhid, flags, piid, pfn) { &bhid, flags, piid, pfn},
#define SFBINDHANDLER(bhid, flags, piid)    BINDHANDLER(bhid, flags, piid, NULL)
#define BINDHELPER(bhid, flags, pfn)        BINDHANDLER(bhid, flags, NULL, pfn)

const BINDNONSENSE c_bnList[] = 
{
    SFBINDHANDLER(BHID_SFObject, BNF_OBJECT | BNF_USE_RIID, NULL)
    SFBINDHANDLER(BHID_SFUIObject, BNF_UIOBJECT | BNF_USE_RIID, NULL)
    SFBINDHANDLER(BHID_SFViewObject, BNF_VIEWOBJECT | BNF_USE_RIID, NULL)
    BINDHELPER(BHID_LinkTargetItem, 0, _CreateLinkTargetItem)
    BINDHELPER(BHID_LocalCopyHelper, 0, _CreateHelperInstance)
    BINDHELPER(BHID_Storage, BNF_OBJECT | BNF_USE_RIID, _CreateStorageHelper)
    BINDHELPER(BHID_Stream, BNF_OBJECT | BNF_USE_RIID, NULL)
    BINDHELPER(BHID_StorageEnum, 0, _CreateEnumHelper)
};
    
HRESULT _GetBindNonsense(const GUID *pbhid, const IID *piid, BINDNONSENSE *pbn)
{
    HRESULT hr = MK_E_NOOBJECT;
    for (int i = 0; i < ARRAYSIZE(c_bnList); i++)
    {
        if (IsEqualGUID(*pbhid, *(c_bnList[i].pbhid)))
        {
            *pbn = c_bnList[i];
            hr = S_OK;

            if (pbn->bnf & BNF_USE_RIID)
            {
                pbn->piid = piid;
            }

            if (pbn->piid && IsEqualGUID(*(pbn->piid), *piid))
                pbn->bnf |= BNF_REFLEXIVE;

            break;
        }
    }
    return hr;
}

//  the SafeBC functions will use the pbc passed in or
//  create a new one if necessary.  either way, if 
//  the *ppbc is returned non-NULL then it is ref'd
STDAPI SHSafeRegisterObjectParam(LPCWSTR psz, IUnknown *punk, IBindCtx *pbcIn, IBindCtx **ppbc)
{
    IBindCtx *pbc = pbcIn;
    
    if (!pbc)
        CreateBindCtx(0, &pbc);
    else
        pbc->AddRef();

    *ppbc = NULL;
    
    HRESULT hr;
    if (pbc)
    {
        hr = pbc->RegisterObjectParam((LPOLESTR)psz, punk);
        if (SUCCEEDED(hr))
        {
            //  pass our ref to the caller
            *ppbc = pbc;
        }
        else
        {
            pbc->Release();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CShellItem::BindToHandler(IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv)
{
    //  look up handler for bind flags
    //  use the flags to determine BTO GUIO BTS CVO
    BINDNONSENSE bn = {0};
    HRESULT hr = _GetBindNonsense(&rbhid, &riid, &bn);

    *ppv = NULL;
    
    if (SUCCEEDED(hr))
    {
        hr = E_NOINTERFACE;

        if (_pidlParent && (bn.bnf & (BNF_OBJECT | BNF_UIOBJECT)))
        {
            IShellFolder *psf;
            if (SUCCEEDED(_BindToParent(IID_PPV_ARG(IShellFolder, &psf))))
            {
                if (bn.bnf & BNF_OBJECT)
                {
                    hr = psf->BindToObject(_pidlChild, pbc, *(bn.piid), ppv);
                }
                
                if (FAILED(hr) && (bn.bnf & BNF_UIOBJECT))
                {
                    HWND hwnd = _GetBindWindow(pbc);
                    hr = psf->GetUIObjectOf(hwnd, 1, &_pidlChild, *(bn.piid), NULL, ppv);
                }
                psf->Release();
            }
        }

        // if don't have a parent pidl then we are the desktop.
        if (FAILED(hr) && (NULL == _pidlParent) && (bn.bnf & BNF_OBJECT))
        {
            IShellFolder *psf;
            if (SUCCEEDED(SHGetDesktopFolder(&psf)))
            {
                hr = psf->QueryInterface(riid,ppv);
                psf->Release();
            }
        }


        if (FAILED(hr) && (bn.bnf & BNF_VIEWOBJECT))
        {
            IShellFolder *psf;

            if (SUCCEEDED(_BindToSelf(IID_PPV_ARG(IShellFolder, &psf))))
            {
                HWND hwnd = _GetBindWindow(pbc);
                hr = psf->CreateViewObject(hwnd, *(bn.piid), ppv);
                
                psf->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            if (!(bn.bnf & BNF_REFLEXIVE))
            {
                IUnknown *punk = (IUnknown *)*ppv;
                hr = punk->QueryInterface(riid, ppv);
                punk->Release();
            }
            //  else riid is the same as bn.piid
        }
        else if (bn.pfn)
        {
            hr = bn.pfn(this, pbc, rbhid, riid, ppv);
        }
    }

    return hr;
}

STDMETHODIMP CShellItem::GetParent(IShellItem **ppsi)
{
    HRESULT hr = MK_E_NOOBJECT;

    if (_pidlParent)
    {
        if (!ILIsEmpty(_pidlSelf))
        {
            CShellItem *psi = new CShellItem();
            if (psi)
            {
                // may already have the _psf Parent here so be nice
                // to have a way to do this in a set.
                hr = psi->SetIDList(_pidlParent);
                if (SUCCEEDED(hr))
                    hr = psi->QueryInterface(IID_PPV_ARG(IShellItem, ppsi));
                    
                psi->Release();
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

BOOL CShellItem::_IsAttrib(SFGAOF sfgao)
{
    HRESULT hr = GetAttributes(sfgao, &sfgao);
    return hr == S_OK;
}

#define SHGDNF_MASK     0xFFFF  //  bottom word

BOOL CShellItem::_SupportedName(SIGDN sigdn, SHGDNF *pflags)
{
    *pflags = (sigdn & SHGDNF_MASK);
    //  block this completely
    //  to avoid doing any binding at all 
    if (sigdn == SIGDN_FILESYSPATH && !_IsAttrib(SFGAO_FILESYSTEM))
        return FALSE;

    return TRUE;
}

HRESULT CShellItem::_FixupName(SIGDN sigdnName, LPOLESTR *ppszName)
{
    HRESULT hr = S_OK;
    if (sigdnName == SIGDN_URL && !UrlIsW(*ppszName, URLIS_URL))
    {
        WCHAR sz[MAX_URL_STRING];
        DWORD cch = ARRAYSIZE(sz);
        if (SUCCEEDED(UrlCreateFromPathW(*ppszName, sz, &cch, 0)))
        {
            CoTaskMemFree(*ppszName);
            hr = SHStrDupW(sz, ppszName);
        }
    }

    return hr;
}

STDMETHODIMP CShellItem::GetDisplayName(SIGDN sigdnName, LPOLESTR *ppszName)
{
    SHGDNF flags;
    if (_SupportedName(sigdnName, &flags))
    {
        IShellFolder *psf;
        HRESULT hr = _BindToParent(IID_PPV_ARG(IShellFolder, &psf));

        if (SUCCEEDED(hr))
        {
            STRRET str;
            hr = IShellFolder_GetDisplayNameOf(psf, _pidlChild, flags, &str, 0);

            if (SUCCEEDED(hr))
            {
                hr = StrRetToStrW(&str, _pidlChild, ppszName);

                if (SUCCEEDED(hr) && (int)flags != (int)sigdnName)
                {
                    hr = _FixupName(sigdnName, ppszName);
                }
            }
                
            psf->Release();
        }

        return hr;
    }
    
    return E_INVALIDARG;
}

void CShellItem::_FixupAttributes(IShellFolder *psf, SFGAOF sfgaoMask)
{
    // APPCOMPAT: The following if statement and its associated body is an APP HACK for pagis pro
    // folder. Which specifies SFGAO_FOLDER and SFGAO_FILESYSTEM but it doesn't specify SFGAO_STORAGEANCESTOR
    // This APP HACK basically checks for this condition and provides SFGAO_STORAGEANCESTOR bit.
    if (_sfgaoKnown & SFGAO_FOLDER)
    {
        if ((!(_sfgaoKnown & SFGAO_FILESYSANCESTOR) && (sfgaoMask & SFGAO_FILESYSANCESTOR))
        || ((_sfgaoKnown & SFGAO_CANMONIKER) && !(_sfgaoKnown & SFGAO_STORAGEANCESTOR) && (sfgaoMask & SFGAO_STORAGEANCESTOR)))
        {
            OBJCOMPATFLAGS ocf = SHGetObjectCompatFlags(psf, NULL);
            if (ocf & OBJCOMPATF_NEEDSFILESYSANCESTOR)
            {
                _sfgaoKnown |= SFGAO_FILESYSANCESTOR;
            }
            if (ocf & OBJCOMPATF_NEEDSSTORAGEANCESTOR)
            {
                //  switch SFGAO_CANMONIKER -> SFGAO_STORAGEANCESTOR
                _sfgaoKnown |= SFGAO_STORAGEANCESTOR;
                _sfgaoKnown &= ~SFGAO_CANMONIKER;
            }
        }
    }
}

STDMETHODIMP CShellItem::GetAttributes(SFGAOF sfgaoMask, SFGAOF *psfgaoFlags)
{
    HRESULT hr = S_OK;

    //  see if we cached this bits before...
    if ((sfgaoMask & _sfgaoTried) != sfgaoMask)
    {
        IShellFolder *psf;
        hr = _BindToParent(IID_PPV_ARG(IShellFolder, &psf));

        if (SUCCEEDED(hr))
        {
            //  we cache all the bits except VALIDATE
            _sfgaoTried |= (sfgaoMask & ~SFGAO_VALIDATE);
            SFGAOF sfgao = sfgaoMask;

            hr = psf->GetAttributesOf(1, &_pidlChild, &sfgao);

            if (SUCCEEDED(hr))
            {
                //  we cache all the bits except VALIDATE
                _sfgaoKnown |= (sfgao & ~SFGAO_VALIDATE);
                _FixupAttributes(psf, sfgaoMask);
            }

            psf->Release();
        }
    }

    *psfgaoFlags = _sfgaoKnown & sfgaoMask;

    if (SUCCEEDED(hr))
    {
        //  we return S_OK 
        //  only if the bits set match
        //  exactly the bits requested
        if (*psfgaoFlags == sfgaoMask)
            hr = S_OK;
        else
            hr = S_FALSE;
    }
        
    return hr;
}

STDMETHODIMP CShellItem::Compare(IShellItem *psi, SICHINTF hint, int *piOrder)
{
    *piOrder = 0;
    HRESULT hr = IsSameObject(SAFECAST(this, IShellItem *), psi) ? S_OK : E_FAIL;
    if (FAILED(hr))
    {
        IShellFolder *psf;
        hr = _BindToParent(IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            IParentAndItem *pfai;
            hr = psi->QueryInterface(IID_PPV_ARG(IParentAndItem, &pfai));
            if (SUCCEEDED(hr))
            {
                IShellFolder *psfOther;
                LPITEMIDLIST pidlParent, pidlChild;
                hr = pfai->GetParentAndItem(&pidlParent, &psfOther, &pidlChild);
                if (SUCCEEDED(hr))
                {
                    if (IsSameObject(psf, psfOther) || ILIsEqual(_pidlParent, pidlParent))
                    {
                        hr = psf->CompareIDs(hint & 0xf0000000, _pidlChild, pidlChild);
                    }
                    else
                    {
                        //  these items have a different parent
                        //  compare the absolute pidls
                        LPITEMIDLIST pidlOther;
                        hr = SHGetIDListFromUnk(psi, &pidlOther);
                        if (SUCCEEDED(hr))
                        {
                            IShellFolder *psfDesktop;
                            hr = SHGetDesktopFolder(&psfDesktop);
                            if (SUCCEEDED(hr))
                            {
                                hr = psfDesktop->CompareIDs(hint & 0xf0000000, _pidlSelf, pidlOther);
                                psfDesktop->Release();
                            }
                            ILFree(pidlOther);
                        }
                    }
                        
                    if (SUCCEEDED(hr))
                    {
                        *piOrder = ShortFromResult(hr);
                        if (*piOrder)
                            hr = S_FALSE;
                        else
                            hr = S_OK;
                    }
                    
                    psfOther->Release();
                    ILFree(pidlParent);
                    ILFree(pidlChild);
                }
                pfai->Release();
            }
            psf->Release();
        }
    }

    return hr;
}

// IParentAndItem
STDMETHODIMP CShellItem::SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psfParent, LPCITEMIDLIST pidlChild) 
{ 
    // require to have a Parent if making this call. If don't then use SetIDList
    if (!pidlParent && !psfParent)
    {
        RIPMSG(0, "Tried to Call SetParent without a parent");
        return E_INVALIDARG;
    }

    LPITEMIDLIST pidlFree = NULL;

    if ((NULL == pidlParent) && psfParent)
    {
        if (SUCCEEDED(SHGetIDListFromUnk(psfParent, &pidlFree)))
        {
            pidlParent = pidlFree;
        }
    }
 
    if (!ILIsEmpty(_ILNext(pidlChild))) 
    {
        // if more than on item in the child pidl don't use the parent IShellFolder*
        // could revist and bind from this parent to get a new parent so don't have
        // to BindObject through the entire pidl path.

        psfParent = NULL; 
    }

    HRESULT hr = E_FAIL;
    if (pidlParent)
    {
        _Reset();

        hr = SHILCombine(pidlParent, pidlChild, &_pidlSelf);
        if (SUCCEEDED(hr))
        {
            // setup pidls so _pidlChild is a single item.
            if (_pidlParent = ILCloneParent(_pidlSelf))
            {
                _pidlChild = ILFindLastID(_pidlSelf);

                PPUNK_SET(&_psfParent, psfParent);

#ifdef DEBUG
                if (psfParent)
                {
                    LPITEMIDLIST pidlD;
                    if (SUCCEEDED(SHGetIDListFromUnk(psfParent, &pidlD)))
                    {
                        ASSERT(ILIsEqual(pidlD, pidlParent));
                        ILFree(pidlD);
                    }
                }
#endif  //DEBUG
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    ILFree(pidlFree);   // maybe NULL

    return hr;
}

STDMETHODIMP CShellItem::GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidl)
{
    if (ppsf)
    {
        _BindToParent(IID_PPV_ARG(IShellFolder, ppsf));
    }
    
    if (ppidlParent)
    {
        if (_pidlParent)
        {
            *ppidlParent = ILClone(_pidlParent);
        }
        else
        {
            *ppidlParent = NULL;
        }
    }
    
    if (ppidl)
        *ppidl = ILClone(_pidlChild);


    HRESULT hr = S_OK;
    if ((ppidlParent && !*ppidlParent)
    ||  (ppsf && !*ppsf)
    ||  (ppidl && !*ppidl))
    {
        //  this is failure
        //  but we dont know what failed
        if (ppsf && *ppsf)
        {
            (*ppsf)->Release();
            *ppsf = NULL;
        }

        if (ppidlParent)
        {
            ILFree(*ppidlParent);
            *ppidlParent = NULL;
        }

        if (ppidl)
        {
            ILFree(*ppidl);
            *ppidl = NULL;
        }
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDAPI CShellItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    CShellItem *psi = new CShellItem();
    if (psi)
    {
        HRESULT hr = psi->QueryInterface(riid, ppv);
        psi->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}


class CShellItemEnum : IEnumShellItems, public CObjectWithSite
{
public:
    CShellItemEnum();
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder,IShellFolder *psf, DWORD dwFlags,UINT cidl,LPCITEMIDLIST *apidl);
    
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvOut);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP Next(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumShellItems **ppenum);

private:

    virtual ~CShellItemEnum();
    HRESULT _EnsureEnum();

    LONG _cRef;
    DWORD _dwFlags;

    IShellFolder *_psf;
    IEnumIDList *_penum;
    LPITEMIDLIST _pidlFolder;
};



STDMETHODIMP CShellItemEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CShellItemEnum, IEnumShellItems),
        QITABENT(CShellItemEnum, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CShellItemEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellItemEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CShellItemEnum::Next(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched)
{
    HRESULT hr = _EnsureEnum();
    if (FAILED(hr))
        return hr;

    ULONG uTemp;
    if (!pceltFetched)
        pceltFetched = &uTemp;
    
    *pceltFetched = 0;
    
    while (celt--)
    {
        LPITEMIDLIST pidl;
        ULONG cFetched;
        hr = _penum->Next(1, &pidl, &cFetched);
        if (S_OK == hr)
        {
            hr = SHCreateShellItem(_pidlFolder, _psf, pidl, &rgelt[*pceltFetched]);
            if (SUCCEEDED(hr))
                (*pceltFetched)++;
                
            ILFree(pidl);
        }

        if (S_OK != hr)
            break;
    }

    if (SUCCEEDED(hr))
    {
        hr = *pceltFetched ? S_OK : S_FALSE;
    }
    else
    {
        for (UINT i = 0; i < *pceltFetched; i++)
        {
            ATOMICRELEASE(rgelt[i]);
        }
        *pceltFetched = 0;
    }


    return hr;
}

STDMETHODIMP CShellItemEnum::Skip(ULONG celt)
{
    HRESULT hr = _EnsureEnum();
    if (SUCCEEDED(hr))
        hr = _penum->Skip(celt);

    return hr;
}

STDMETHODIMP CShellItemEnum::Reset()
{
    HRESULT hr = _EnsureEnum();
    if (SUCCEEDED(hr))
        hr = _penum->Reset();

    return hr;
}

STDMETHODIMP CShellItemEnum::Clone(IEnumShellItems **ppenum)
{
    return E_NOTIMPL;
}

HRESULT CShellItemEnum::_EnsureEnum()
{
    if (_penum)
        return S_OK;

    HRESULT hr = E_FAIL;

    if (_psf)
    {
        HWND hwnd = NULL;
        IUnknown_GetWindow(_punkSite, &hwnd);

        // if didn't get an enum in Initialize then enumerate the
        // entire folder.
        hr = _psf->EnumObjects(hwnd, _dwFlags, &_penum);
    }

    return hr;
}


CShellItemEnum::CShellItemEnum() 
        : _cRef(1)
{
    ASSERT(NULL == _psf);
    ASSERT(NULL == _penum);
    ASSERT(NULL == _pidlFolder);
}

STDMETHODIMP CShellItemEnum::Initialize(LPCITEMIDLIST pidlFolder, IShellFolder *psf, DWORD dwFlags, UINT cidl, LPCITEMIDLIST *apidl)
{
    HRESULT hr = E_FAIL;

    _dwFlags = dwFlags;

    _psf = psf;
    _psf->AddRef();

    if (NULL == _pidlFolder)
    {
        hr = SHGetIDListFromUnk(_psf, &_pidlFolder);
    }
    else
    {
        hr = SHILClone(pidlFolder, &_pidlFolder);
    }

    if (SUCCEEDED(hr) && cidl)
    {
        ASSERT(apidl);

        // if want to enum with other flags or combos need to implement the filter
        ASSERT(_dwFlags == (SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN));

        hr = CreateIEnumIDListOnIDLists(apidl, cidl, &_penum);
    }

    // on error let our destructor do the cleanup
    
    return hr;
}

CShellItemEnum::~CShellItemEnum()
{
    ATOMICRELEASE(_penum);
    ATOMICRELEASE(_psf);
    ILFree(_pidlFolder);
}

HRESULT _CreateShellItemEnum(LPCITEMIDLIST pidlFolder,IShellFolder *psf,IBindCtx *pbc, REFGUID rbhid, 
                             UINT cidl, LPCITEMIDLIST *apidl,
                             REFIID riid, void **ppv)
{
    DWORD dwFlags;
    HRESULT hr = E_FAIL;
    LPCITEMIDLIST *pidlEnum = NULL;

    UINT mycidl = 0;
    LPITEMIDLIST *myppidl = NULL;;

    if (IsEqualGUID(rbhid, BHID_StorageEnum))
        dwFlags = SHCONTF_STORAGE;
    else
        dwFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN;

    CShellItemEnum *psie = new CShellItemEnum();

    if (psie)
    {
        hr = psie->Initialize(pidlFolder, psf, dwFlags, cidl, apidl);

        if (SUCCEEDED(hr))
        {
            hr = psie->QueryInterface(riid, ppv);
        }

        psie->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT _CreateEnumHelper(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv)
{   
    HRESULT hr = E_FAIL;
    IShellFolder *psf;

    ASSERT(psi);
    
    if (psi)
    {
        hr = psi->BindToHandler(NULL, BHID_SFObject, IID_PPV_ARG(IShellFolder, &psf));

        if (SUCCEEDED(hr))
        {
            hr =  _CreateShellItemEnum(NULL,psf,pbc,rbhid,0,NULL,riid,ppv);
            psf->Release();
        }
    }

    return hr;
}

class CShellItemArray : public IShellItemArray
{
public:
    CShellItemArray();
    ~CShellItemArray();
    HRESULT Initialize(LPCITEMIDLIST pidlParent,IShellFolder *psf,UINT cidl,LPCITEMIDLIST *ppidl);


    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IShellItemArray 
    STDMETHODIMP BindToHandler(
        IBindCtx *pbc, 
        REFGUID rbhid,
        REFIID riid, 
        void **ppvOut);

    STDMETHODIMP GetAttributes(
        SIATTRIBFLAGS dwAttribFlags,
        SFGAOF sfgaoMask, 
        SFGAOF *psfgaoAttribs);

    STDMETHODIMP GetCount(DWORD *pdwNumItems);
    STDMETHODIMP GetItemAt(DWORD dwIndex,IShellItem **ppsi);
    STDMETHODIMP EnumItems(IEnumShellItems **ppenumShellItems);

private:
    HRESULT _CloneIDListArray(UINT cidl, LPCITEMIDLIST *apidl, UINT *pcidl, LPITEMIDLIST **papidl);

    IShellFolder *_pshf;
    LPITEMIDLIST _pidlParent;
    LPITEMIDLIST *_ppidl;
    UINT _cidl;
    LONG _cRef;
    IDataObject *_pdo; // cached data object.
    DWORD _dwAttribAndCacheResults;
    DWORD _dwAttribAndCacheMask;
    DWORD _dwAttribCompatCacheResults;
    DWORD _dwAttribCompatCacheMask;
    BOOL _fItemPidlsRagged; // set to true if have any rugged pidls.
};
                

CShellItemArray::CShellItemArray()
{
    ASSERT(0 == _cidl);
    ASSERT(NULL == _ppidl);
    ASSERT(NULL == _pshf);
    ASSERT(NULL == _pdo);

    _fItemPidlsRagged = TRUE;
    _cRef = 1;
}

CShellItemArray::~CShellItemArray()
{
    ATOMICRELEASE(_pdo);
    ATOMICRELEASE(_pshf);

    ILFree(_pidlParent); // may be null

    if (NULL != _ppidl)
    {
        FreeIDListArray(_ppidl,_cidl);
    }
}

HRESULT CShellItemArray::Initialize(LPCITEMIDLIST pidlParent, IShellFolder *psf, UINT cidl, LPCITEMIDLIST *ppidl)
{
    if ((cidl > 1) && !ppidl || !psf)
    {
        return E_INVALIDARG;
    }

    if (pidlParent)
    {
        _pidlParent = ILClone(pidlParent);  // proceed on alloc failure, just won't use.
    }

    _pshf = psf;
    _pshf->AddRef();

    HRESULT hr = S_OK;
    if (cidl)
    {
        // if there are items then make a copy
        hr = _CloneIDListArray(cidl, ppidl, &_cidl, &_ppidl);
    }

    // on error rely on destructor to do the cleanup
    return hr;
}   

// IUnknown
STDMETHODIMP CShellItemArray::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CShellItemArray, IShellItemArray),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CShellItemArray::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellItemArray::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CShellItemArray::BindToHandler(IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppvOut)
{
    HRESULT hr = E_FAIL;

    if (_pshf)
    {
        // currently only allow bind to IDataObject and
        // cache the result.        
        if (BHID_DataObject == rbhid)
        {
            if (NULL == _pdo)
            {
                _pshf->GetUIObjectOf(NULL, _cidl, (LPCITEMIDLIST *)_ppidl, IID_PPV_ARG_NULL(IDataObject, &_pdo));
            }

            if (_pdo)
            {
                hr = _pdo->QueryInterface(riid, ppvOut);
            }
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }

    return hr;
}

// This should probably take a flag that does an or'ing of attributes but this
// currrently isn't implemented. Do have comments on what the changes would be.
HRESULT CShellItemArray::GetAttributes(SIATTRIBFLAGS dwAttribFlags, SFGAOF sfgaoMask, SFGAOF *psfgaoAttribs)
{
    DWORD dwAttrib;
    HRESULT hr = E_FAIL;
    
    if (dwAttribFlags > (dwAttribFlags & SIATTRIBFLAGS_MASK))
    {
        ASSERT(dwAttribFlags <= (dwAttribFlags & SIATTRIBFLAGS_MASK));
        return E_INVALIDARG;
    }
    
    if (SIATTRIBFLAGS_OR == dwAttribFlags)
    {
        ASSERT(SIATTRIBFLAGS_OR != dwAttribFlags); // or'ing is currently not implemented.
        return E_INVALIDARG;
    }

    if (_pshf)
    {
        DWORD dwAttribMask = sfgaoMask;
        DWORD *pdwCacheMask = NULL;
        DWORD *pdwCacheResults = NULL;

        // setup to point to proper Cached values.
        switch(dwAttribFlags)
        {
        case SIATTRIBFLAGS_AND:
            pdwCacheMask = &_dwAttribAndCacheMask;
            pdwCacheResults = &_dwAttribAndCacheResults;
            break;
        case SIATTRIBFLAGS_APPCOMPAT:
            pdwCacheMask = &_dwAttribCompatCacheMask;
            pdwCacheResults = &_dwAttribCompatCacheResults;
            break;
        default:
            ASSERT(0); // i don't know how to handle this flag.
            break;
        }

        dwAttribMask &= ~(*pdwCacheMask); // only ask for the bits we don't already have.

        dwAttrib = dwAttribMask;

        if (dwAttrib) 
        {
            if (0 == _cidl)
            { 
                dwAttrib = 0;
            }
            else
            {
                // if know this is not a ragged pidl and calling with the APPCOMPAT flag
                // then calls GetAttributesOf for all the items in one call to the
                // shellFolder.
                    
                if (!_fItemPidlsRagged && (SIATTRIBFLAGS_APPCOMPAT == dwAttribFlags))
                {
                    hr = _pshf->GetAttributesOf(_cidl, (LPCITEMIDLIST *)_ppidl, &dwAttrib);
                }
                else
                {
                    LPITEMIDLIST *pCurItem = _ppidl;
                    UINT itemCount = _cidl;
                    DWORD dwAttribLoopResult = -1; // set all result bits for and, if going to or set to zero

                    while (itemCount--)
                    {
                        DWORD dwAttribTemp = dwAttrib;
                        IShellFolder *psfNew;
                        LPCITEMIDLIST pidlChild;

                        hr = SHBindToFolderIDListParent(_pshf, *pCurItem, IID_PPV_ARG(IShellFolder, &psfNew), &pidlChild);

                        if (SUCCEEDED(hr))
                        {
                            hr = psfNew->GetAttributesOf(1, &pidlChild, &dwAttribTemp);
                            psfNew->Release();
                        }

                        if (FAILED(hr))
                        {
                            break;
                        }

                        dwAttribLoopResult &= dwAttribTemp; // could also do an or'ing here
                        
                        if (0 == dwAttribLoopResult) // if no attribs set and doing an and we can stop.
                        {
                            break;
                        }

                        ++pCurItem;
                    }

                    dwAttrib = dwAttribLoopResult; // update the attrib
                }
            }
        }
        else
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            // remember those bits that we just got + 
            // those that we computed before
            *pdwCacheResults = dwAttrib | (*pdwCacheResults & *pdwCacheMask);

            // we know these are now valid, keep track of those +
            // if they gave us more than we asked for, cache them too
            *pdwCacheMask |= dwAttribMask | dwAttrib;

            // don't return anything that wasn't asked for. defview code relies on this.
            *psfgaoAttribs = (*pdwCacheResults & sfgaoMask); 
        }
    }

    return hr;
}

STDMETHODIMP CShellItemArray::GetCount(DWORD *pdwNumItems)
{
    *pdwNumItems = _cidl;
    return S_OK;
}

// way to get zero based index ShellItem without having to
// go through enumerator overhead.
STDMETHODIMP CShellItemArray::GetItemAt(DWORD dwIndex, IShellItem **ppsi)
{
    *ppsi = NULL;

    if (dwIndex >= _cidl)
    {
        return E_FAIL;
    }
    
    ASSERT(_ppidl);

    LPITEMIDLIST pidl = *(_ppidl + dwIndex);

    // if GetItemAt is called a lot may want to
    // a) get the pshf pidl to pass to SHCreateshellItem so doesn't have to create each time
    // b) see if always asking for first item and is so maybe cache the shellItem
    return SHCreateShellItem(NULL, _pshf, pidl, ppsi);
}

STDMETHODIMP CShellItemArray::EnumItems(IEnumShellItems **ppenumShellItems)
{
    return _CreateShellItemEnum(_pidlParent, _pshf, NULL, GUID_NULL, _cidl, 
        (LPCITEMIDLIST *) _ppidl, IID_PPV_ARG(IEnumShellItems, ppenumShellItems));
}

HRESULT CShellItemArray::_CloneIDListArray(UINT cidl, LPCITEMIDLIST *apidl, UINT *pcidl, LPITEMIDLIST **papidl)
{
    HRESULT hr;
    LPITEMIDLIST *ppidl;

    *papidl = NULL;

    _fItemPidlsRagged = FALSE;

    if (cidl && apidl)
    {
        ppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, cidl * sizeof(*ppidl));
        if (ppidl)
        {
            LPITEMIDLIST *apidlFrom = (LPITEMIDLIST *) apidl;
            LPITEMIDLIST *apidlTo = ppidl;

            hr = S_OK;
            for (UINT i = 0; i < cidl ; i++)
            {
                hr = SHILClone(*apidlFrom, apidlTo);
                if (FAILED(hr))
                {
                    FreeIDListArray(ppidl, i);
                    ppidl = NULL;
                    break;
                }
                
                // if more than one item in list then set singeItemPidls to false
                if (!ILIsEmpty(_ILNext(*apidlTo)))
                {
                    _fItemPidlsRagged = TRUE;
                }

                ++apidlFrom;
                ++apidlTo;
            }   
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        ppidl = NULL;
        hr = S_FALSE;   // success by empty
    }

    if (SUCCEEDED(hr))
    {
        *papidl = ppidl;
        *pcidl = cidl;
    }
    else
    {
        _fItemPidlsRagged = TRUE;
    }
    return hr;
}

SHSTDAPI SHCreateShellItemArray(LPCITEMIDLIST pidlParent, IShellFolder *psf, UINT cidl,
                                LPCITEMIDLIST *ppidl, IShellItemArray **ppsiItemArray)
{
    HRESULT hr = E_OUTOFMEMORY;
    CShellItemArray *pItemArray = new CShellItemArray();
    if (pItemArray)
    {
        hr = pItemArray->Initialize(pidlParent, psf, cidl, ppidl);
        if (FAILED(hr))
        {
            pItemArray->Release();
            pItemArray = NULL;
        }
    }
    *ppsiItemArray = pItemArray;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\itemhelp.cpp ===
#include "shellprv.h"


class CLocalCopyHelper  : public ILocalCopy 
                        , public IItemHandler
{
public:
    CLocalCopyHelper();
    
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release ();

    // ILocalCopy methods
    STDMETHODIMP Download(LCFLAGS flags, IBindCtx *pbc, LPWSTR *ppszOut);
    STDMETHODIMP Upload(LCFLAGS flags, IBindCtx *pbc);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) { *pclsid = CLSID_LocalCopyHelper; return S_OK;}

    // IItemHandler
    STDMETHODIMP SetItem(IShellItem *psi);
    STDMETHODIMP GetItem(IShellItem **ppsi);

protected:
    ~CLocalCopyHelper();

    //  private methods
    HRESULT _InitCacheEntry(void);
    HRESULT _SetCacheName(void);
    HRESULT _FinishLocal(BOOL fReadOnly);
    HRESULT _GetLocalStream(DWORD grfMode, IStream **ppstm, FILETIME *pft);
    HRESULT _GetRemoteStream(DWORD grfMode, IBindCtx *pbc, IStream **ppstm, FILETIME *pft);

    // members
    long _cRef;
    IShellItem *_psi;
    LPWSTR _pszName;            //  name retrieved from psi
    LPWSTR _pszCacheName;       //  name used to ID cache entry
    LPCWSTR _pszExt;            //  points into _pszName

    //  caches of the MTIMEs for the streams
    FILETIME _ftRemoteGet;
    FILETIME _ftLocalGet;
    FILETIME _ftRemoteCommit;
    FILETIME _ftLocalCommit;
    
    BOOL _fIsLocalFile;         //  this is actually file system item (pszName is a FS path)
    BOOL _fMadeLocal;           //  we have already copied this item locally

    //  put this at the end so we can see all the rest of the pointers easily in debug
    WCHAR _szLocalPath[MAX_PATH];
};

CLocalCopyHelper::CLocalCopyHelper() : _cRef(1)
{
}

CLocalCopyHelper::~CLocalCopyHelper()
{
    ATOMICRELEASE(_psi);

    if (_pszName)
        CoTaskMemFree(_pszName);

    if (_pszCacheName)
        LocalFree(_pszCacheName);
}
    
STDMETHODIMP CLocalCopyHelper::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CLocalCopyHelper, ILocalCopy),
        QITABENT(CLocalCopyHelper, IItemHandler),
        QITABENTMULTI(CLocalCopyHelper, IPersist, IItemHandler),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CLocalCopyHelper::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CLocalCopyHelper::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CLocalCopyHelper::SetItem(IShellItem *psi)
{
    if (!_psi)
    {
        SFGAOF flags = SFGAO_STREAM;
        if (SUCCEEDED(psi->GetAttributes(flags, &flags))
        && (flags & SFGAO_STREAM))
        {
            HRESULT hr = psi->GetDisplayName(SIGDN_FILESYSPATH, &_pszName);

            if (SUCCEEDED(hr))
            {
                _fIsLocalFile = TRUE;
            }
            else
                hr = psi->GetDisplayName(SIGDN_PARENTRELATIVEEDITING, &_pszName);


            if (SUCCEEDED(hr))
            {
                _psi = psi;
                _psi->AddRef();
            }

            return hr;
        }
    }
    return E_UNEXPECTED;
}

STDMETHODIMP CLocalCopyHelper::GetItem(IShellItem **ppsi)
{
    *ppsi = _psi;

    if (_psi)
    {
        _psi->AddRef();
        return S_OK;
    }
    else
        return E_UNEXPECTED;
}

#define SZTEMPURL     TEXTW("temp:")
#define CCHTEMPURL    SIZECHARS(SZTEMPURL) -1

HRESULT CLocalCopyHelper::_SetCacheName(void)
{
    ASSERT(!_pszCacheName);
    _pszCacheName = (LPWSTR) LocalAlloc(LPTR, CbFromCchW(lstrlenW(_pszName) + CCHTEMPURL + 1));
    
    if (_pszCacheName)
    {
        LPCWSTR pszName = _pszName;
        
        StrCpy(_pszCacheName, SZTEMPURL);
        StrCpy(_pszCacheName + CCHTEMPURL, _pszName);

        if (UrlIs(_pszName, URLIS_URL))
        {
            //  need to push past all slashes
            pszName = StrRChr(pszName, NULL, TEXT('/'));
        }
            
        //  the cache APIs need the extension without the dot
        if (pszName)
        {
            _pszExt = PathFindExtension(pszName);
            
            if (*_pszExt)
                _pszExt++;
        }

        return S_OK;
    }

    return E_OUTOFMEMORY;
}

void _GetMTime(IStream *pstm, FILETIME *pft)
{
    //  see if we can get an accurate Mod time
    STATSTG stat;
    if (S_OK == pstm->Stat(&stat, STATFLAG_NONAME))
        *pft = stat.mtime;
    else     
    {
        GetSystemTimeAsFileTime(pft);
    }
}

HRESULT CLocalCopyHelper::_InitCacheEntry(void)
{
    if (!_pszCacheName)
    {
        HRESULT hr = _SetCacheName();

        if (SUCCEEDED(hr) && !CreateUrlCacheEntryW(_pszCacheName, 0, _pszExt, _szLocalPath, 0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LocalFree(_pszCacheName);
            _pszCacheName = NULL;
        }

        return hr;
    }
    return S_OK;
}

HRESULT CLocalCopyHelper::_GetLocalStream(DWORD grfMode, IStream **ppstm, FILETIME *pft)
{
    HRESULT hr = _InitCacheEntry();
  
    if (SUCCEEDED(hr))
    {
        hr = SHCreateStreamOnFileW(_szLocalPath, grfMode, ppstm);

        if (SUCCEEDED(hr))
            _GetMTime(*ppstm, pft);
    }

    return hr;
}

HRESULT CLocalCopyHelper::_FinishLocal(BOOL fReadOnly)
{
    HRESULT hr = S_OK;
    FILETIME ftExp = {0};
    
    if (CommitUrlCacheEntryW(_pszCacheName, _szLocalPath, ftExp, _ftLocalGet, STICKY_CACHE_ENTRY, NULL, 0, NULL, NULL))
    {
        //  we could also check _GetRemoteStream(STGM_WRITE)
        //  and if it fails we could fail this as well.
        if (fReadOnly)
            SetFileAttributesW(_szLocalPath, FILE_ATTRIBUTE_READONLY);
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    return hr;
}


HRESULT CLocalCopyHelper::_GetRemoteStream(DWORD grfMode, IBindCtx *pbc, IStream **ppstm, FILETIME *pft)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (!pbc)
        CreateBindCtx(0, &pbc);
    else
        pbc->AddRef();
        
    if (pbc)
    {
        BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
        if (SUCCEEDED(pbc->GetBindOptions(&bo)))
        {
            bo.grfMode = grfMode;
            pbc->SetBindOptions(&bo);
        }

        hr = _psi->BindToHandler(pbc, BHID_Storage, IID_PPV_ARG(IStream, ppstm));

        if (SUCCEEDED(hr))
            _GetMTime(*ppstm, pft);
            
        pbc->Release();
    }

    return hr;
}

STDMETHODIMP CLocalCopyHelper::Download(LCFLAGS flags, IBindCtx *pbc, LPWSTR *ppsz)
{
    if (!_psi)
        return E_UNEXPECTED;
        
    HRESULT hr;
    if (_fIsLocalFile)
    {
        hr = SHStrDup(_pszName, ppsz);
    }
    else if (_fMadeLocal && !(flags & LC_FORCEROUNDTRIP))  
    {
        hr = S_OK;
    }
    else if (flags & LC_SAVEAS)
    {
        hr = _InitCacheEntry();
        if (SUCCEEDED(hr))
        {
            _fMadeLocal = TRUE;
        }
    }
    else  
    {
        //  get the local stream first because it is the cheapest operation.
        IStream *pstmDst;
        hr = _GetLocalStream(STGM_WRITE, &pstmDst, &_ftLocalGet);

        if (SUCCEEDED(hr))
        {
            //  we need to create the temp file here
            IStream *pstmSrc;
            
            hr = _GetRemoteStream(STGM_READ, pbc, &pstmSrc, &_ftRemoteGet);

            if (SUCCEEDED(hr))
            {
                hr = CopyStreamUI(pstmSrc, pstmDst, NULL, 0);

                pstmSrc->Release();
                // now that we have copied the stream

            }

            pstmDst->Release();

            //  need to release teh dest stream first
            if (SUCCEEDED(hr))
            {
                //  finish cleaning up the local file
                hr = _FinishLocal(flags & LCDOWN_READONLY);
                _fMadeLocal = SUCCEEDED(hr);
            }
        }

    }

    if (_fMadeLocal)
    {
        ASSERT(SUCCEEDED(hr));
        hr = SHStrDup(_szLocalPath, ppsz);
    }
    else
        ASSERT(_fIsLocalFile || FAILED(hr));
        

    return hr;
}

STDMETHODIMP CLocalCopyHelper::Upload(LCFLAGS flags, IBindCtx *pbc)
{
    if (!_psi)
        return E_UNEXPECTED;

    HRESULT hr = S_OK;
    if (!_fIsLocalFile)
    {
        //  get the local stream first because it is the cheapest operation.
        IStream *pstmSrc;
        hr = _GetLocalStream(STGM_READ, &pstmSrc, &_ftLocalCommit);

        if (SUCCEEDED(hr))
        {
            DWORD stgmRemote = STGM_WRITE;

            if (flags & LC_SAVEAS)
            {
                hr = _FinishLocal(FALSE);
                stgmRemote |= STGM_CREATE;
            }
               
            if (SUCCEEDED(hr))
            {
                IStream *pstmDst;
                hr = _GetRemoteStream(stgmRemote, pbc, &pstmDst, &_ftRemoteCommit);

                if (SUCCEEDED(hr))
                {
                    //  we only bother copying when the local copy changed
                    //  or caller forces us to.
                    //
                    //  FEATURE - UI needs to handle when the remot changes
                    //  if the remote copy changes while the local
                    //  copy is being updated we will overwrite the remote copy
                    //  local changes WIN!
                    //
                    
                    if (flags & LC_FORCEROUNDTRIP || 0 != CompareFileTime(&_ftLocalCommit, &_ftLocalGet))
                        hr = CopyStreamUI(pstmSrc, pstmDst, NULL, 0);
                    else
                        hr = S_FALSE;
                        
                    pstmDst->Release();
                }

            }

            pstmSrc->Release();
        }
    }

    return hr;
}
    
STDAPI CLocalCopyHelper_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CLocalCopyHelper * p = new CLocalCopyHelper();

    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\linkprop.cpp ===
#include "shellprv.h"
#pragma hdrstop

#include <msi.h>
#include <msip.h>
#include "lnkcon.h"
#include "trayp.h"      // for WMTRAY_ messages
#include "util.h"   // for GetIconLocationFromExt
#include "ids.h"

LINKPROP_DATA* Create_LinkPropData()
{
    LINKPROP_DATA *plpd = (LINKPROP_DATA*) LocalAlloc(LPTR, sizeof(*plpd));
    if (plpd)
    {
        plpd->_cRef = 1;
        plpd->hCheckNow = CreateEvent(NULL, TRUE, FALSE, NULL);

    }
    return plpd;
}

LONG AddRef_LinkPropData(LINKPROP_DATA *plpd)
{
    return plpd ? InterlockedIncrement(&plpd->_cRef) : 0;
}

LONG Release_LinkPropData(LINKPROP_DATA *plpd)
{
    if (plpd)
    {
        if (InterlockedDecrement(&plpd->_cRef))
            return plpd->_cRef;

        if (plpd->psl)
            plpd->psl->Release();
        if (plpd->hCheckNow)
        {
            CloseHandle(plpd->hCheckNow);
            plpd->hCheckNow = NULL;
        }
        LocalFree(plpd);

    }
    return 0;
}


//
// This string defined in shlink.c - hack to allow user to set working dir to $$
// and have it map to whatever "My Documents" is mapped to.
//

void _UpdateLinkIcon(LINKPROP_DATA *plpd, HICON hIcon)
{
    if (!hIcon)
    {
        hIcon = SHGetFileIcon(NULL, plpd->szFile, 0, SHGFI_LARGEICON);
    }

    if (hIcon)
    {
        ReplaceDlgIcon(plpd->hDlg, IDD_ITEMICON, hIcon);
    }
}

// put a path into an edit field, doing quoting as necessary

void SetDlgItemPath(HWND hdlg, int id, LPTSTR pszPath)
{
    PathQuoteSpaces(pszPath);
    SetDlgItemText(hdlg, id, pszPath);
}

// get a path from an edit field, unquoting as possible

void GetDlgItemPath(HWND hdlg, int id, LPTSTR pszPath)
{
    GetDlgItemText(hdlg, id, pszPath, MAX_PATH);
    PathRemoveBlanks(pszPath);
    PathUnquoteSpaces(pszPath);
}


const int c_iShowCmds[] = {
    SW_SHOWNORMAL,
    SW_SHOWMINNOACTIVE,
    SW_SHOWMAXIMIZED,
};

void _DisableAllChildren(HWND hwnd)
{
    HWND hwndChild;

    for (hwndChild = GetWindow(hwnd, GW_CHILD); hwndChild != NULL; hwndChild = GetWindow(hwndChild, GW_HWNDNEXT))
    {
        // we don't want to disable the static text controls (makes the dlg look bad)
        if (!(SendMessage(hwndChild, WM_GETDLGCODE, 0, 0) & DLGC_STATIC))
        {
            EnableWindow(hwndChild, FALSE);
        }
    }
}

void _GetPathAndArgs(LINKPROP_DATA *plpd, LPTSTR pszPath, LPTSTR pszArgs)
{
    GetDlgItemText(plpd->hDlg, IDD_FILENAME, pszPath, MAX_PATH);
    PathSeperateArgs(pszPath, pszArgs);
}


//
// Returns fully qualified path to target of link, and # of characters
// in fully qualifed path as return value
//
INT _GetTargetOfLink(LINKPROP_DATA *plpd, LPTSTR pszTarget)
{
    TCHAR szFile[MAX_PATH], szArgs[MAX_PATH];
    INT cch = 0;

    *pszTarget = 0;

    _GetPathAndArgs(plpd, szFile, szArgs);

    if (szFile[0])
    {
        LPTSTR psz;
        TCHAR szExp[MAX_PATH];

        if (SHExpandEnvironmentStrings(szFile, szExp, ARRAYSIZE(szExp)))
        {
            cch = SearchPath(NULL, szExp, TEXT(".EXE"), MAX_PATH, pszTarget, &psz);
        }
    }

    return cch;
}


//
// Do checking of the .exe type in the background so the UI doesn't
// get hung up while we scan.  This is particularly important with
// the .exe is over the network or on a floppy.
//
STDAPI_(DWORD) _LinkCheckThreadProc(void *pv)
{
    LINKPROP_DATA *plpd = (LINKPROP_DATA *)pv;
    BOOL fCheck = TRUE, fEnable = FALSE;

    DebugMsg(DM_TRACE, TEXT("_LinkCheckThreadProc created and running"));

    while (plpd->bCheckRunInSep)
    {
        WaitForSingleObject(plpd->hCheckNow, INFINITE);
        ResetEvent(plpd->hCheckNow);

        if (plpd->bCheckRunInSep)
        {
            TCHAR szFullFile[MAX_PATH];
            DWORD cch = _GetTargetOfLink(plpd, szFullFile);

            if ((cch != 0) && (cch < ARRAYSIZE(szFullFile)))
            {
                DWORD dwBinaryType;

                if (PathIsUNC(szFullFile) || IsRemoteDrive(DRIVEID(szFullFile)))
                {
                    // Net Path, let the user decide...
                    fCheck = FALSE;
                    fEnable = TRUE;
                }
                else if (GetBinaryType(szFullFile, &dwBinaryType) && (dwBinaryType == SCS_WOW_BINARY))
                {
                    // 16-bit binary, let the user decide, default to same VDM
                    fCheck = FALSE;
                    fEnable = TRUE;
                }
                else
                {
                    // 32-bit binary, or non-net path.  don't enable the control
                    fCheck = TRUE;
                    fEnable = FALSE;
                }
            } 
            else 
            {
                // Error getting target of the link.  don't enable the control
                fCheck = TRUE;
                fEnable = FALSE;
            }

            plpd->bEnableRunInSepVDM = fEnable;
            plpd->bRunInSepVDM = fCheck;

            if (plpd->hDlgAdvanced && IsWindow(plpd->hDlgAdvanced))
            {
                CheckDlgButton(plpd->hDlgAdvanced, IDD_RUNINSEPARATE, fCheck ? 1 : 0);
                EnableWindow(GetDlgItem(plpd->hDlgAdvanced, IDD_RUNINSEPARATE), fEnable);
            }
        }
    }
    plpd->bLinkThreadIsAlive = FALSE;
    Release_LinkPropData(plpd);
    DebugMsg(DM_TRACE, TEXT("_LinkCheckThreadProc exiting now..."));
    return 0;
}

// shut down the thread

void _StopThread(LINKPROP_DATA *plpd)
{
    if (plpd->bLinkThreadIsAlive)
    {
        plpd->bCheckRunInSep = FALSE;
        SetEvent(plpd->hCheckNow);
    }
}



void * _GetLinkExtraData(IShellLink* psl, DWORD dwSig)
{
    void * pDataBlock = NULL;

    IShellLinkDataList *psld;
    if (SUCCEEDED(psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &psld))))
    {
        psld->CopyDataBlock(dwSig, &pDataBlock);
        psld->Release();
    }

    return pDataBlock;
}

HRESULT _RemoveLinkExtraData(IShellLink* psl, DWORD dwSig)
{
    IShellLinkDataList *psld;
    HRESULT hr = psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &psld));
    if (SUCCEEDED(hr))
    {
        hr = psld->RemoveDataBlock(dwSig);
        psld->Release();
    }

    return hr;
}

HRESULT _SetLinkExtraData(IShellLink* psl, EXP_HEADER* peh)
{
    IShellLinkDataList *psld;
    HRESULT hr = psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &psld));
    if (SUCCEEDED(hr))
    {
        // remove any existing datablock
        psld->RemoveDataBlock(peh->dwSignature);
        hr = psld->AddDataBlock((void*)peh);
        psld->Release();
    }

    return hr;
}


// Initializes the generic link dialog box.
void _UpdateLinkDlg(LINKPROP_DATA *plpd, BOOL bUpdatePath)
{
    WORD wHotkey;
    int  i, iShowCmd;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szCommand[MAX_PATH];
    HRESULT hr;
    SHFILEINFO sfi;
    BOOL fIsDarwinLink;


    // do this here so we don't slow down the loading
    // of other pages

    if (!bUpdatePath)
    {
        IPersistFile *ppf;

        if (SUCCEEDED(plpd->psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))))
        {
            WCHAR wszPath[MAX_PATH];

            SHTCharToUnicode(plpd->szFile, wszPath, ARRAYSIZE(wszPath));
            hr = ppf->Load(wszPath, 0);
            ppf->Release();

            if (FAILED(hr))
            {
                LoadString(HINST_THISDLL, IDS_LINKNOTLINK, szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText(plpd->hDlg, IDD_FILETYPE, szBuffer);
                _DisableAllChildren(plpd->hDlg);

                DebugMsg(DM_TRACE, TEXT("Shortcut IPersistFile::Load() failed %x"), hr);
                return;
            }
        }
    }
    
    fIsDarwinLink = SetLinkFlags(plpd->psl, 0, 0) & SLDF_HAS_DARWINID;

    SHGetFileInfo(plpd->szFile, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES);
    SetDlgItemText(plpd->hDlg, IDD_NAME, sfi.szDisplayName);

    // we need to check for darwin links here so that we can gray out
    // things that don't apply to darwin
    if (fIsDarwinLink)
    {
        TCHAR szAppState[MAX_PATH];
        DWORD cchAppState = ARRAYSIZE(szAppState);
        HWND hwndTargetType = GetDlgItem(plpd->hDlg, IDD_FILETYPE);

        // disable the children
        _DisableAllChildren(plpd->hDlg);

        // then special case the icon and the "Target type:" text
        _UpdateLinkIcon(plpd, NULL);

        LPEXP_DARWIN_LINK pDarwinData = (LPEXP_DARWIN_LINK)_GetLinkExtraData(plpd->psl, EXP_DARWIN_ID_SIG);

        // The second clause will see if it is a Darwin Advertisement.
        if (pDarwinData && (INSTALLSTATE_ADVERTISED == MsiQueryFeatureStateFromDescriptorW(pDarwinData->szwDarwinID)))
        {
            // the app is advertised (e.g. not installed), but will be faulted in on first use
            LoadString(HINST_THISDLL, IDS_APP_NOT_FAULTED_IN, szAppState, ARRAYSIZE(szAppState));
        }
        else
        {
            // the darwin app is installed
            LoadString(HINST_THISDLL, IDS_APP_FAULTED_IN, szAppState, ARRAYSIZE(szAppState));
        }

        SetWindowText(hwndTargetType, szAppState);
        EnableWindow(hwndTargetType, TRUE);

        // if we can ge the package name, put that in the Target field
        if (pDarwinData &&
            MsiGetProductInfo(pDarwinData->szwDarwinID,
                              INSTALLPROPERTY_PRODUCTNAME,
                              szAppState,
                              &cchAppState) == ERROR_SUCCESS)
        {
            SetWindowText(GetDlgItem(plpd->hDlg, IDD_FILENAME), szAppState);
        }

        if (pDarwinData)
        {
            LocalFree(pDarwinData);
        }
        
        // we disabled everything in _DisableAllChildren, so re-enable the ones we still apply for darwin
        EnableWindow(GetDlgItem(plpd->hDlg, IDD_NAME), TRUE);
        EnableWindow(GetDlgItem(plpd->hDlg, IDD_PATH), TRUE);
        EnableWindow(GetDlgItem(plpd->hDlg, IDD_LINK_HOTKEY), TRUE);
        EnableWindow(GetDlgItem(plpd->hDlg, IDD_LINK_SHOWCMD), TRUE);
        EnableWindow(GetDlgItem(plpd->hDlg, IDD_LINK_DESCRIPTION), TRUE);
        EnableWindow(GetDlgItem(plpd->hDlg, IDC_ADVANCED), TRUE);

        // we skip all of the gook below if we are darwin since we only support the IDD_NAME, IDD_PATH, IDD_LINK_HOTKEY, 
        // IDD_LINK_SHOWCMD, and IDD_LINK_DESCRIPTION fields
    }
    else
    {
        hr = plpd->psl->GetPath(szCommand, ARRAYSIZE(szCommand), NULL, SLGP_RAWPATH);
        
        if (FAILED(hr))
            hr = plpd->psl->GetPath(szCommand, ARRAYSIZE(szCommand), NULL, 0);

        if (S_OK == hr)
        {
            plpd->bIsFile = TRUE;

            // get type
            if (!SHGetFileInfo(szCommand, 0, &sfi, sizeof(sfi), SHGFI_TYPENAME))
            {
                TCHAR szExp[MAX_PATH];

                // Let's see if the string has expandable environment strings
                if (SHExpandEnvironmentStrings(szCommand, szExp, ARRAYSIZE(szExp))
                && lstrcmp(szCommand, szExp)) // don't hit the disk a second time if the string hasn't changed
                {
                    SHGetFileInfo(szExp, 0, &sfi, sizeof(sfi), SHGFI_TYPENAME);
                }
            }
            SetDlgItemText(plpd->hDlg, IDD_FILETYPE, sfi.szTypeName);

            // location
            lstrcpy(szBuffer, szCommand);
            PathRemoveFileSpec(szBuffer);
            SetDlgItemText(plpd->hDlg, IDD_LOCATION, PathFindFileName(szBuffer));

            // command
            plpd->psl->GetArguments(szBuffer, ARRAYSIZE(szBuffer));
            PathComposeWithArgs(szCommand, szBuffer);
            GetDlgItemText(plpd->hDlg, IDD_FILENAME, szBuffer, ARRAYSIZE(szBuffer));
            // Conditionally change to prevent "Apply" button from enabling
            if (lstrcmp(szCommand, szBuffer) != 0)
                SetDlgItemText(plpd->hDlg, IDD_FILENAME, szCommand);
        }
        else
        {
            LPITEMIDLIST pidl;

            plpd->bIsFile = FALSE;

            EnableWindow(GetDlgItem(plpd->hDlg, IDD_FILENAME), FALSE);
            EnableWindow(GetDlgItem(plpd->hDlg, IDD_PATH), FALSE);

            plpd->psl->GetIDList(&pidl);

            if (pidl)
            {
                SHGetNameAndFlags(pidl, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szCommand, SIZECHARS(szCommand), NULL);
                ILRemoveLastID(pidl);
                SHGetNameAndFlags(pidl, SHGDN_NORMAL, szBuffer, SIZECHARS(szBuffer), NULL);
                ILFree(pidl);

                SetDlgItemText(plpd->hDlg, IDD_LOCATION, szBuffer);
                SetDlgItemText(plpd->hDlg, IDD_FILETYPE, szCommand);
                SetDlgItemText(plpd->hDlg, IDD_FILENAME, szCommand);
            }
        }
    }

    if (bUpdatePath)
    {
        return;
    }

    plpd->psl->GetWorkingDirectory(szBuffer, ARRAYSIZE(szBuffer));
    SetDlgItemPath(plpd->hDlg, IDD_PATH, szBuffer);

    plpd->psl->GetDescription(szBuffer, ARRAYSIZE(szBuffer));
    SHLoadIndirectString(szBuffer, szBuffer, ARRAYSIZE(szBuffer), NULL);    // will do nothing if the string isn't indirect
    SetDlgItemText(plpd->hDlg, IDD_LINK_DESCRIPTION, szBuffer);

    plpd->psl->GetHotkey(&wHotkey);
    SendDlgItemMessage(plpd->hDlg, IDD_LINK_HOTKEY, HKM_SETHOTKEY, wHotkey, 0);

    //
    // Now initialize the Run SHOW Command combo box
    //
    for (iShowCmd = IDS_RUN_NORMAL; iShowCmd <= IDS_RUN_MAXIMIZED; iShowCmd++)
    {
        LoadString(HINST_THISDLL, iShowCmd, szBuffer, ARRAYSIZE(szBuffer));
        SendDlgItemMessage(plpd->hDlg, IDD_LINK_SHOWCMD, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)szBuffer);
    }

    // Now setup the Show Command - Need to map to index numbers...
    plpd->psl->GetShowCmd(&iShowCmd);

    for (i = 0; i < ARRAYSIZE(c_iShowCmds); i++)
    {
        if (c_iShowCmds[i] == iShowCmd)
            break;
    }
    if (i == ARRAYSIZE(c_iShowCmds))
    {
        ASSERT(0);      // bogus link show cmd
        i = 0;  // SW_SHOWNORMAL
    }

    SendDlgItemMessage(plpd->hDlg, IDD_LINK_SHOWCMD, CB_SETCURSEL, i, 0);

    // the icon
    _UpdateLinkIcon(plpd, NULL);
}

//
// Opens a folder window with the target of the link selected
//
void _FindTarget(LINKPROP_DATA *plpd)
{
    if (plpd->psl->Resolve(plpd->hDlg, 0) == S_OK)
    {
        LPITEMIDLIST pidl;

        _UpdateLinkDlg(plpd, TRUE);

        plpd->psl->GetIDList(&pidl);
        if (pidl)
        {
            SHOpenFolderAndSelectItems(pidl, 0, NULL, 0);
            ILFree(pidl);
        }
    }
}

// let the user pick a new icon for a link...

BOOL _DoPickIcon(LINKPROP_DATA *plpd)
{
    int iIconIndex;
    SHFILEINFO sfi;
    TCHAR *pszIconPath = sfi.szDisplayName;
    IShellLinkDataList *psldl; 
    EXP_SZ_LINK *esli;
    HRESULT hr;

    *pszIconPath = 0;

    //
    // if the user has picked a icon before use it.
    //
    if (plpd->szIconPath[0] != 0 && plpd->iIconIndex >= 0)
    {
        lstrcpy(pszIconPath, plpd->szIconPath);
        iIconIndex = plpd->iIconIndex;
    }
    else
    {
        //
        // if this link has a icon use that.
        //
        plpd->psl->GetIconLocation(pszIconPath, MAX_PATH, &iIconIndex);

        //
        // check for an escaped version, if its there, use that 
        // 
        if (SUCCEEDED(hr = plpd->psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &psldl)))) 
        { 
            if (SUCCEEDED(hr = psldl->CopyDataBlock(EXP_SZ_ICON_SIG, (void **)&esli))) 
            { 
                ASSERT(esli);
#ifdef UNICODE 
                lstrcpyn(pszIconPath, esli->swzTarget, MAX_PATH); 
#else 
                lstrcpyn(pszIconPath, esli->szTarget, MAX_PATH); 
#endif 
                LocalFree(esli);
            } 

            psldl->Release(); 
        } 


        if (pszIconPath[0] == TEXT('.'))
        {
            TCHAR szFullIconPath[MAX_PATH];

            // We now allow ".txt" for the icon path, but since the user is clicking
            // on the "Change Icon..." button, we show the current icon that ".txt" is
            // associated with
            GetIconLocationFromExt(pszIconPath, szFullIconPath, ARRAYSIZE(szFullIconPath), &iIconIndex);
            lstrcpyn(pszIconPath, szFullIconPath, ARRAYSIZE(sfi.szDisplayName));
        }
        else if (pszIconPath[0] == 0)
        {
            //
            // link does not have a icon, if it is a link to a file
            // use the file name
            //
            TCHAR szArgs[MAX_PATH];
            _GetPathAndArgs(plpd, pszIconPath, szArgs);

            iIconIndex = 0;

            if (!plpd->bIsFile || !PathIsExe(pszIconPath))
            {
                //
                // link is not to a file, go get the icon
                //
                SHGetFileInfo(plpd->szFile, 0, &sfi, sizeof(sfi), SHGFI_ICONLOCATION);
                iIconIndex = sfi.iIcon;
                ASSERT(pszIconPath == sfi.szDisplayName);
            }
        }
    }

    if (PickIconDlg(plpd->hDlg, pszIconPath, MAX_PATH, &iIconIndex))
    {
        HICON hIcon = ExtractIcon(HINST_THISDLL, pszIconPath, iIconIndex);
        _UpdateLinkIcon(plpd, hIcon);

        // don't save it out to the link yet, just store it in our instance data
        plpd->iIconIndex = iIconIndex;
        lstrcpy(plpd->szIconPath, pszIconPath);

        PropSheet_Changed(GetParent(plpd->hDlg), plpd->hDlg);
        return TRUE;
    }

    return FALSE;
}


STDAPI SaveLink(LINKDATA *pld)
{
    WORD wHotkey;
    int iShowCmd;
    IPersistFile *ppf;
    HRESULT hr;
    TCHAR szBuffer[MAX_PATH];

    if (!(pld->plpd->bIsDirty || (pld->cpd.lpConsole && pld->cpd.bConDirty)))
        return S_OK;

    if (pld->plpd->bIsFile)
    {
        TCHAR szArgs[MAX_PATH];

        _GetPathAndArgs(pld->plpd, szBuffer, szArgs);

        // set the path (and pidl) of the link
        pld->plpd->psl->SetPath(szBuffer);

        // may be null
        pld->plpd->psl->SetArguments(szArgs);

        if (pld->plpd->bEnableRunInSepVDM && pld->plpd->bRunInSepVDM)
        {
            SetLinkFlags(pld->plpd->psl, SLDF_RUN_IN_SEPARATE, SLDF_RUN_IN_SEPARATE);
        }
        else
        {
            SetLinkFlags(pld->plpd->psl, 0, SLDF_RUN_IN_SEPARATE);
        }

        if (pld->plpd->bRunAsUser)
        {
            SetLinkFlags(pld->plpd->psl, SLDF_RUNAS_USER, SLDF_RUNAS_USER);
        }
        else
        {
            SetLinkFlags(pld->plpd->psl, 0, SLDF_RUNAS_USER);
        }

    }

    if (pld->plpd->bIsFile || (SetLinkFlags(pld->plpd->psl, 0, 0) & SLDF_HAS_DARWINID))
    {
        // set the working directory of the link
        GetDlgItemPath(pld->plpd->hDlg, IDD_PATH, szBuffer);
        pld->plpd->psl->SetWorkingDirectory(szBuffer);
    }

    // set the description of the link if it changed.
    TCHAR szOldComment[MAX_PATH];
    pld->plpd->psl->GetDescription(szOldComment, ARRAYSIZE(szOldComment));
    SHLoadIndirectString(szOldComment, szOldComment, ARRAYSIZE(szOldComment), NULL);    // will do nothing if the string isn't indirect
    GetDlgItemText(pld->plpd->hDlg, IDD_LINK_DESCRIPTION, szBuffer, ARRAYSIZE(szBuffer));
    if (lstrcmp(szBuffer, szOldComment) != 0)
        pld->plpd->psl->SetDescription(szBuffer);

    // the hotkey
    wHotkey = (WORD)SendDlgItemMessage(pld->plpd->hDlg, IDD_LINK_HOTKEY , HKM_GETHOTKEY, 0, 0);
    pld->plpd->psl->SetHotkey(wHotkey);

    // the show command combo box
    iShowCmd = (int)SendDlgItemMessage(pld->plpd->hDlg, IDD_LINK_SHOWCMD, CB_GETCURSEL, 0, 0L);
    if ((iShowCmd >= 0) && (iShowCmd < ARRAYSIZE(c_iShowCmds)))
    {
        pld->plpd->psl->SetShowCmd(c_iShowCmds[iShowCmd]);
    }

    // If the user explicitly selected a new icon, invalidate
    // the icon cache entry for this link and then send around a file
    // sys refresh message to all windows in case they are looking at
    // this link.
    if (pld->plpd->iIconIndex >= 0)
    {
        pld->plpd->psl->SetIconLocation(pld->plpd->szIconPath, pld->plpd->iIconIndex);
    }

    // Update/Save the console information in the pExtraData section of
    // the shell link.
    if (pld->cpd.lpConsole && pld->cpd.bConDirty)
    {
        LinkConsolePagesSave(pld);
    }

    hr = pld->plpd->psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
    if (SUCCEEDED(hr))
    {
        if (ppf->IsDirty() == S_OK)
        {
            // save using existing file name (pld->plpd->szFile)
            hr = ppf->Save(NULL, TRUE);

            if (FAILED(hr))
            {
                SHSysErrorMessageBox(pld->plpd->hDlg, NULL, IDS_LINKCANTSAVE,
                    hr & 0xFFF, PathFindFileName(pld->plpd->szFile),
                    MB_OK | MB_ICONEXCLAMATION);
            }
            else
            {
                pld->plpd->bIsDirty = FALSE;
            }
        }
        ppf->Release();
    }

    return hr;
}

void SetEditFocus(HWND hwnd)
{
    SetFocus(hwnd);
    Edit_SetSel(hwnd, 0, -1);
}

// returns:
//      TRUE    all link fields are valid
//      FALSE   some thing is wrong with what the user has entered

BOOL _ValidateLink(LINKPROP_DATA *plpd)
{
    TCHAR szDir[MAX_PATH], szPath[MAX_PATH], szArgs[MAX_PATH];
    TCHAR szExpPath[MAX_PATH];
    BOOL  bValidPath = FALSE;

    if (!plpd->bIsFile)
        return TRUE;

    // validate the working directory field

    GetDlgItemPath(plpd->hDlg, IDD_PATH, szDir);

    if (*szDir &&
        StrChr(szDir, TEXT('%')) == NULL &&       // has environement var %USER%
        !IsRemovableDrive(DRIVEID(szDir)) &&
        !PathIsDirectory(szDir))
    {
        ShellMessageBox(HINST_THISDLL, plpd->hDlg, MAKEINTRESOURCE(IDS_LINKBADWORKDIR),
                        MAKEINTRESOURCE(IDS_LINKERROR), MB_OK | MB_ICONEXCLAMATION, szDir);

        SetEditFocus(GetDlgItem(plpd->hDlg, IDD_PATH));

        return FALSE;
    }

    // validate the path (with arguments) field

    _GetPathAndArgs(plpd, szPath, szArgs);

    if (szPath[0] == 0)
        return TRUE;

    if (PathIsRoot(szPath) && IsRemovableDrive(DRIVEID(szPath)))
        return TRUE;

    if (PathIsLnk(szPath))
    {
        ShellMessageBox(HINST_THISDLL, plpd->hDlg, MAKEINTRESOURCE(IDS_LINKTOLINK),
                        MAKEINTRESOURCE(IDS_LINKERROR), MB_OK | MB_ICONEXCLAMATION);
        SetEditFocus(GetDlgItem(plpd->hDlg, IDD_FILENAME));
        return FALSE;
    }

    LPCTSTR dirs[2];
    dirs[0] = szDir;
    dirs[1] = NULL;
    bValidPath = PathResolve(szPath, dirs, PRF_DONTFINDLNK | PRF_TRYPROGRAMEXTENSIONS);
    if (!bValidPath)
    {
        // The path "as is" was invalid.  See if it has environment variables
        // which need to be expanded.

        _GetPathAndArgs(plpd, szPath, szArgs);

        if (SHExpandEnvironmentStrings(szPath, szExpPath, ARRAYSIZE(szExpPath)))
        {
            if (PathIsRoot(szExpPath) && IsRemovableDrive(DRIVEID(szDir)))
                return TRUE;

            bValidPath = PathResolve(szExpPath, dirs, PRF_DONTFINDLNK | PRF_TRYPROGRAMEXTENSIONS);
        }
    }

    if (bValidPath)
    {
        BOOL bSave;

        if (plpd->bLinkThreadIsAlive)
        {
            bSave = plpd->bCheckRunInSep;
            plpd->bCheckRunInSep = FALSE;
        }
        PathComposeWithArgs(szPath, szArgs);
        GetDlgItemText(plpd->hDlg, IDD_FILENAME, szExpPath, ARRAYSIZE(szExpPath));
        // only do this if something changed... that way we avoid having the PSM_CHANGED
        // for nothing
        if (lstrcmpi(szPath, szExpPath))
            SetDlgItemText(plpd->hDlg, IDD_FILENAME, szPath);

        if (plpd->bLinkThreadIsAlive)
        {
            plpd->bCheckRunInSep = bSave;
        }

        return TRUE;
    }

    ShellMessageBox(HINST_THISDLL, plpd->hDlg, MAKEINTRESOURCE(IDS_LINKBADPATH),
                        MAKEINTRESOURCE(IDS_LINKERROR), MB_OK | MB_ICONEXCLAMATION, szPath);
    SetEditFocus(GetDlgItem(plpd->hDlg, IDD_FILENAME));
    return FALSE;
}

// Array for context help:
const DWORD aLinkHelpIDs[] = {
    IDD_LINE_1,             NO_HELP,
    IDD_LINE_2,             NO_HELP,
    IDD_ITEMICON,           IDH_FCAB_LINK_ICON,
    IDD_NAME,               IDH_FCAB_LINK_NAME,
    IDD_FILETYPE_TXT,       IDH_FCAB_LINK_LINKTYPE,
    IDD_FILETYPE,           IDH_FCAB_LINK_LINKTYPE,
    IDD_LOCATION_TXT,       IDH_FCAB_LINK_LOCATION,
    IDD_LOCATION,           IDH_FCAB_LINK_LOCATION,
    IDD_FILENAME,           IDH_FCAB_LINK_LINKTO,
    IDD_PATH,               IDH_FCAB_LINK_WORKING,
    IDD_LINK_HOTKEY,        IDH_FCAB_LINK_HOTKEY,
    IDD_LINK_SHOWCMD,       IDH_FCAB_LINK_RUN,
    IDD_LINK_DESCRIPTION,   IDH_FCAB_LINK_DESCRIPTION,
    IDD_FINDORIGINAL,       IDH_FCAB_LINK_FIND,
    IDD_LINKDETAILS,        IDH_FCAB_LINK_CHANGEICON,
    0, 0
};

// Array for context help (Advanced Dlg):
const DWORD aAdvancedLinkHelpIDs[] = {
    IDD_RUNINSEPARATE,      IDH_TRAY_RUN_SEPMEM,
    IDD_LINK_RUNASUSER,     IDH_FCAB_LINK_RUNASUSER,
    0,0
};

UINT g_msgActivateDesktop = 0;

DWORD CALLBACK _LinkAddRefSyncCallBack(void *pv)
{
    LINKPROP_DATA *plpd = (LINKPROP_DATA *)pv;
    AddRef_LinkPropData(plpd);
    plpd->bLinkThreadIsAlive = TRUE;
    return 0;
}

// Dialog proc for the generic link property sheet
//
// uses DLG_LINKPROP template

BOOL_PTR CALLBACK _LinkAdvancedDlgProc(HWND hDlgAdvanced, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LINKPROP_DATA *plpd = (LINKPROP_DATA *)GetWindowLongPtr(hDlgAdvanced, DWLP_USER);

    switch (msg)
    {
    case WM_INITDIALOG:
    {
        TCHAR szFullFile[MAX_PATH];
        DWORD cchVerb;
        UINT cch;

        plpd = (LINKPROP_DATA *)lParam;
        SetWindowLongPtr(hDlgAdvanced, DWLP_USER, (LPARAM)plpd);

        plpd->hDlgAdvanced = hDlgAdvanced;

        cch = _GetTargetOfLink(plpd, szFullFile);

        if ((cch != 0) && (cch < ARRAYSIZE(szFullFile)))
        {
            DWORD dwBinaryType;

            // enable "run in seperate VDM" if this is a 16-bit image 
            if (GetBinaryType(szFullFile, &dwBinaryType) && (dwBinaryType == SCS_WOW_BINARY))
            {
                if (SetLinkFlags(plpd->psl, 0, 0) & SLDF_RUN_IN_SEPARATE)
                {
                    EnableWindow(GetDlgItem(hDlgAdvanced, IDD_RUNINSEPARATE), TRUE);
                    CheckDlgButton(hDlgAdvanced, IDD_RUNINSEPARATE, BST_CHECKED);
                } 
                else 
                {
                    EnableWindow(GetDlgItem(hDlgAdvanced, IDD_RUNINSEPARATE), TRUE);
                    CheckDlgButton(hDlgAdvanced, IDD_RUNINSEPARATE, BST_UNCHECKED);
                }
            } 
            else 
            {
                // check it
                CheckDlgButton(hDlgAdvanced, IDD_RUNINSEPARATE, BST_CHECKED);
                EnableWindow(GetDlgItem(hDlgAdvanced, IDD_RUNINSEPARATE), FALSE);
            }

            // enable "runas" if the link target has that verb 
            if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_COMMAND, szFullFile, TEXT("runas"), NULL, &cchVerb)) &&
                cchVerb)
            {
                EnableWindow(GetDlgItem(hDlgAdvanced, IDD_LINK_RUNASUSER), TRUE);
                CheckDlgButton(hDlgAdvanced, IDD_LINK_RUNASUSER, (SetLinkFlags(plpd->psl, 0, 0) & SLDF_RUNAS_USER) ? BST_CHECKED : BST_UNCHECKED);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlgAdvanced, IDD_LINK_RUNASUSER), FALSE);
                CheckDlgButton(hDlgAdvanced, IDD_LINK_RUNASUSER, BST_UNCHECKED);
            }

        } 
        else 
        {
            // fall back to disabling everything
            CheckDlgButton(hDlgAdvanced, IDD_RUNINSEPARATE, BST_CHECKED);
            EnableWindow(GetDlgItem(hDlgAdvanced, IDD_RUNINSEPARATE), FALSE);
            EnableWindow(GetDlgItem(hDlgAdvanced, IDD_LINK_RUNASUSER), FALSE);
        }

        // get the initial state of the checkboxes
        plpd->bEnableRunInSepVDM = IsWindowEnabled(GetDlgItem(hDlgAdvanced, IDD_RUNINSEPARATE));
        plpd->bRunInSepVDM = IsDlgButtonChecked(hDlgAdvanced, IDD_RUNINSEPARATE);
        plpd->bRunAsUser = IsDlgButtonChecked(hDlgAdvanced, IDD_LINK_RUNASUSER);
    }
    break;

    case WM_COMMAND:
    {
        UINT idControl = GET_WM_COMMAND_ID(wParam, lParam);

        switch (idControl)
        {
        case IDD_RUNINSEPARATE:
        case IDD_LINK_RUNASUSER:
            plpd->bIsDirty = TRUE;
            break;

        case IDOK:
            // get the final state of the checkboxes
            plpd->bEnableRunInSepVDM = IsWindowEnabled(GetDlgItem(hDlgAdvanced, IDD_RUNINSEPARATE));
            plpd->bRunInSepVDM = IsDlgButtonChecked(hDlgAdvanced, IDD_RUNINSEPARATE);
            plpd->bRunAsUser = IsDlgButtonChecked(hDlgAdvanced, IDD_LINK_RUNASUSER);
            // fall through

        case IDCANCEL:
            ReplaceDlgIcon(hDlgAdvanced, IDD_ITEMICON, NULL);
            plpd->hDlgAdvanced = NULL;
            EndDialog(hDlgAdvanced, (idControl == IDCANCEL) ? FALSE : TRUE);
            break;
        }
    }
    break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)aAdvancedLinkHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aAdvancedLinkHelpIDs);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


BOOL_PTR CALLBACK _LinkDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LINKDATA *pld = (LINKDATA *)GetWindowLongPtr(hdlg, DWLP_USER);

    switch (msg) 
    {
    case WM_INITDIALOG:

        pld = (LINKDATA *)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hdlg, DWLP_USER, (LPARAM)pld);

        // setup dialog state variables

        pld->plpd->hDlg = hdlg;

        SendDlgItemMessage(hdlg, IDD_FILENAME, EM_LIMITTEXT, MAX_PATH-1, 0);
        SetPathWordBreakProc(GetDlgItem(hdlg, IDD_FILENAME), TRUE);
        SendDlgItemMessage(hdlg, IDD_PATH, EM_LIMITTEXT, MAX_PATH-1, 0);
        SetPathWordBreakProc(GetDlgItem(hdlg, IDD_PATH), TRUE);
        SendDlgItemMessage(hdlg, IDD_LINK_DESCRIPTION, EM_LIMITTEXT, MAX_PATH-1, 0);

        // set valid combinations for the hotkey
        SendDlgItemMessage(hdlg, IDD_LINK_HOTKEY, HKM_SETRULES,
                            HKCOMB_NONE | HKCOMB_A | HKCOMB_S | HKCOMB_C,
                            HOTKEYF_CONTROL | HOTKEYF_ALT);

        SHAutoComplete(GetDlgItem(hdlg, IDD_FILENAME), 0);
        SHAutoComplete(GetDlgItem(hdlg, IDD_PATH), 0);

        ASSERT(pld->plpd->bLinkThreadIsAlive == FALSE);

        _UpdateLinkDlg(pld->plpd, FALSE);

        // Set up background thread to handle "Run In Separate Memory Space"
        // check box.
        pld->plpd->bCheckRunInSep = TRUE;
        if (pld->plpd->hCheckNow)
        {
            SHCreateThread(_LinkCheckThreadProc, pld->plpd,  0, _LinkAddRefSyncCallBack);
        }

        // start off clean.
        // do this here because we call some stuff above which generates
        // wm_command/en_changes which we then think makes it dirty
        pld->plpd->bIsDirty = FALSE;

        break;

    case WM_DESTROY:
        ReplaceDlgIcon(pld->plpd->hDlg, IDD_ITEMICON, NULL);
        _StopThread(pld->plpd);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) 
        {
        case PSN_RESET:
                _StopThread(pld->plpd);
            break;
        case PSN_APPLY:

            if ((((PSHNOTIFY *)lParam)->lParam))
                _StopThread(pld->plpd);

            if (FAILED(SaveLink(pld)))
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;

        case PSN_KILLACTIVE:
            // we implement the save on page change model, so
            // validate and save changes here.  this works for
            // Apply Now, OK, and Page chagne.

            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, !_ValidateLink(pld->plpd));   // don't allow close
            break;
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDD_FINDORIGINAL:
            _FindTarget(pld->plpd);
            break;

        case IDD_LINKDETAILS:
            if (_DoPickIcon(pld->plpd))
                pld->plpd->bIsDirty = TRUE;
            break;

        case IDD_LINK_SHOWCMD:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE)
            {
                PropSheet_Changed(GetParent(hdlg), hdlg);
                pld->plpd->bIsDirty = TRUE;
            }
            break;

        case IDD_LINK_HOTKEY:
        case IDD_FILENAME:
        case IDD_PATH:
        case IDD_LINK_DESCRIPTION:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
            {
                PropSheet_Changed(GetParent(hdlg), hdlg);
                pld->plpd->bIsDirty = TRUE;
                if (pld->plpd->bLinkThreadIsAlive && pld->plpd->bCheckRunInSep)
                    SetEvent(pld->plpd->hCheckNow);
            }
            break;

        case IDC_ADVANCED:
            if ((DialogBoxParam(HINST_THISDLL,
                                MAKEINTRESOURCE(DLG_LINKPROP_ADVANCED), 
                                hdlg,
                                _LinkAdvancedDlgProc,
                                (LPARAM)pld->plpd) == TRUE) &&
                (pld->plpd->bIsDirty == TRUE))
            {
                // something on the advanced page changed
                PropSheet_Changed(GetParent(hdlg), hdlg);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aLinkHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aLinkHelpIDs);
        break;

    default:
        if (0 == g_msgActivateDesktop)
            g_msgActivateDesktop = RegisterWindowMessage(TEXT("ActivateDesktop"));

        if (msg == g_msgActivateDesktop)
        {
            HWND hwnd = FindWindow(TEXT(STR_DESKTOPCLASS), NULL);
            SwitchToThisWindow(GetLastActivePopup(hwnd), TRUE);
            SetForegroundWindow(hwnd);
        }
        return FALSE;
    }
    return TRUE;
}

//
// Release the link object allocated during the initialize
//
UINT CALLBACK _LinkPrshtCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    LINKDATA *pld = (LINKDATA *)((PROPSHEETPAGE *)ppsp->lParam);
    switch (uMsg) 
    {
    case PSPCB_RELEASE:
        if (pld->cpd.lpConsole)
        {
            LocalFree(pld->cpd.lpConsole);
        }
        if (pld->cpd.lpFEConsole)
        {
            LocalFree(pld->cpd.lpFEConsole);
        }
        DestroyFonts(&pld->cpd);
        Release_LinkPropData(pld->plpd);
        LocalFree(pld);
        break;
    }

    return 1;
}

STDAPI_(BOOL) AddLinkPage(LPCTSTR pszFile, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    IShellLink *psl;
    if (PathIsLnk(pszFile) && SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IShellLink, &psl))))
    {
        // alloc this data, since is it shared across several pages
        // instead of putting it in as extra data in the page header
        LINKDATA *pld = (LINKDATA *)LocalAlloc(LPTR, sizeof(*pld));
        if (pld)
        {
            pld->plpd = Create_LinkPropData();       
            if (pld->plpd)
            {
                PROPSHEETPAGE psp;

                psp.dwSize      = sizeof(psp);
                psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;
                psp.hInstance   = HINST_THISDLL;
                psp.pszTemplate = MAKEINTRESOURCE(DLG_LINKPROP);
                psp.pfnDlgProc  = _LinkDlgProc;
                psp.pfnCallback = _LinkPrshtCallback;
                psp.lParam      = (LPARAM)pld;  // pass to all dlg procs

                lstrcpyn(pld->plpd->szFile, pszFile, ARRAYSIZE(pld->plpd->szFile));
                pld->plpd->iIconIndex = -1;
                pld->plpd->psl = psl;
                ASSERT(!pld->plpd->szIconPath[0]);

                HPROPSHEETPAGE hpage = CreatePropertySheetPage(&psp);
                if (hpage)
                {
                    if (pfnAddPage(hpage, lParam))
                    {
                        // Add console property pages if appropriate...
                        AddLinkConsolePages(pld, psl, pszFile, pfnAddPage, lParam);
                        return TRUE;    // we added the link page
                    }
                    else
                    {
                        DestroyPropertySheetPage(hpage);
                    }
                }
                Release_LinkPropData(pld->plpd);

            }
            LocalFree(pld);
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\limitinput.cpp ===
/* ************************************************************** *\
   ToddB's Super Cool Balloon ToolTip InputLimiter

   Copyright Microsoft 1998
\* ************************************************************** */

#include "shellprv.h"
#include "ids.h"

#define IsTextPtr(pszText)      ((LPSTR_TEXTCALLBACK != pszText) && !IS_INTRESOURCE(pszText))
#define CHAR_IN_RANGE(ch,l,h)   ((ch >= l) && (ch <= h))

#define LIMITINPUTTIMERID       472

// ************************************************************************************************
// CInputLimiter class description
// ************************************************************************************************

class CInputLimiter : public tagLIMITINPUT
{
public:
    CInputLimiter();
    ~CInputLimiter();

    BOOL SubclassEditControl(HWND hwnd, const LIMITINPUT *pli);

protected:
    BOOL OnChar(HWND hwnd, WPARAM & wParam, LPARAM lParam);
    LRESULT OnPaste(HWND hwnd, WPARAM wParam, LPARAM lParam);
    void ShowToolTip();
    void HideToolTip();
    void CreateToolTipWindow();
    BOOL IsValidChar(TCHAR ch, BOOL bPaste);

    static LRESULT CALLBACK SubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData);

    HWND        m_hwnd;             // the subclassed edit control hwnd
    HWND        m_hwndToolTip;      // the tooltip control
    UINT_PTR    m_uTimerID;         // the timer id
    BOOL        m_dwCallbacks;      // true if any data is callback data.
};

CInputLimiter::CInputLimiter()
{
    // our allocation function should have zeroed our memory.  Check to make sure:
    ASSERT(0==m_hwndToolTip);
    ASSERT(0==m_uTimerID);
}

CInputLimiter::~CInputLimiter()
{
    // we might have allocated some strings, if we did delete them
    if (IsTextPtr(pszFilter))
    {
        delete pszFilter;
    }
    if (IsTextPtr(pszTitle))
    {
        delete pszTitle;
    }
    if (IsTextPtr(pszMessage))
    {
        delete pszMessage;
    }
}

BOOL CInputLimiter::SubclassEditControl(HWND hwnd, const LIMITINPUT *pli)
{
    if (!IsWindow(hwnd))
    {
        // must have a valid hwnd
        TraceMsg(TF_WARNING, "Invalid HWND passed to CInputLimiter::SubclassEditControl");
        return FALSE;
    }

    m_hwnd = hwnd;

    // validate all the data passed in the pli structure.  Return false if
    // any of it is out of whack.
    dwMask = pli->dwMask;

    if (LIM_FLAGS & dwMask)
    {
        dwFlags = pli->dwFlags;

        if ((LIF_FORCEUPPERCASE|LIF_FORCELOWERCASE) == ((LIF_FORCEUPPERCASE|LIF_FORCELOWERCASE) & dwFlags))
        {
            // cannot use both ForceUpperCase and ForceLowerCase flags
            TraceMsg(TF_WARNING, "cannot use both ForceUpperCase and ForceLowerCase flags");
            return FALSE;
        }
    }
    else
    {
        ASSERT(0==dwFlags);
    }

    if (LIM_HINST & dwMask)
    {
        hinst = pli->hinst;
    }
    else
    {
        ASSERT(0==hinst);
    }

    // keep track of which fields require a valid hwndNotify
    ASSERT(0==m_dwCallbacks);

    if (LIM_FILTER & dwMask)
    {
        if (LIF_CATEGORYFILTER & dwFlags)
        {
            // category filters are not callbacks or int resources even though the data looks like it is.
            // The don't need any validation.
            pszFilter = pli->pszFilter;
        }
        else if (LPSTR_TEXTCALLBACK == pli->pszFilter)
        {
            pszFilter = pli->pszFilter;
            m_dwCallbacks |= LIM_FILTER;
        }
        else if (IS_INTRESOURCE(pli->pszFilter))
        {
            if (!hinst)
            {
                // must have valid hinst in order to use int resources
                TraceMsg(TF_WARNING, "must have valid hinst in order to use int resources for filter");
                return FALSE;
            }

            // We need to load the target string upfront and store it in a buffer.
            DWORD cchSize = 64;
            DWORD cchLoaded;

            for (;;)
            {
                pszFilter = new TCHAR[cchSize];
                if (!pszFilter)
                {
                    // Out of memory
                    TraceMsg(TF_WARNING, "Out of memory in CInputLimiter::SubclassEditControl");
                    return FALSE;
                }

                cchLoaded = LoadString(hinst, PtrToUint(pli->pszFilter), pszFilter, cchSize);
                if (0 == cchLoaded)
                {
                    // Could not load filter resource, pszFilter will get deleted in our destructor
                    TraceMsg(TF_WARNING, "Could not load filter resource");
                    return FALSE;
                }
                else if (cchLoaded >= cchSize-1)
                {
                    // didn't fit in the given buffer, try a larger buffer
                    delete [] pszFilter;
                    cchSize *= 2;
                }
                else
                {
                    // the string loaded successfully
                    break;
                }
            }

            ASSERT(IS_VALID_STRING_PTR(pszFilter,-1));
        }
        else
        {
            ASSERT(IS_VALID_STRING_PTR(pli->pszFilter,-1));
            pszFilter = new TCHAR[lstrlen(pli->pszFilter)+1];
            if (!pszFilter)
            {
                // Out of memory
                TraceMsg(TF_WARNING, "CInputLimiter Out of memory");
                return FALSE;
            }
            StrCpy(pszFilter, pli->pszFilter);
        }
    }
    else
    {
        ASSERT(0==pszFilter);
    }

    if (!(LIF_WARNINGOFF & dwFlags) && !((LIM_TITLE|LIM_MESSAGE) & dwMask))
    {
        // if warnings are on then at least one of Title or Message is required.
        TraceMsg(TF_WARNING, "if warnings are on then at least one of Title or Message is required");
        return FALSE;
    }

    if (LIM_TITLE & dwMask)
    {
        if (LPSTR_TEXTCALLBACK == pli->pszTitle)
        {
            pszTitle = pli->pszTitle;
            m_dwCallbacks |= LIM_TITLE;
        }
        else if (IS_INTRESOURCE(pli->pszTitle))
        {
            if (!hinst)
            {
                // must have valid hinst in order to use int resources
                TraceMsg(TF_WARNING, "must have valid hinst in order to use int resources for title");
                return FALSE;
            }
            // REVIEW: Does the title need to be laoded up fromt or will the ToolTip control do this
            // for us?
            pszTitle = pli->pszTitle;
        }
        else
        {
            ASSERT(IS_VALID_STRING_PTR(pli->pszTitle,-1));
            pszTitle = new TCHAR[lstrlen(pli->pszTitle)+1];
            StrCpy(pszTitle, pli->pszTitle);
        }
    }
    else
    {
        ASSERT(0==pszTitle);
    }

    if (LIM_MESSAGE & dwMask)
    {
        if (LPSTR_TEXTCALLBACK == pli->pszMessage)
        {
            pszMessage = pli->pszMessage;
            m_dwCallbacks |= LIM_MESSAGE;
        }
        else if (IS_INTRESOURCE(pli->pszMessage))
        {
            if (!hinst)
            {
                // must have valid hinst in order to use int resources
                TraceMsg(TF_WARNING, "must have valid hinst in order to use int resources for message");
                return FALSE;
            }
            // We will let the ToolTip control load this string for us
            pszMessage = pli->pszMessage;
        }
        else
        {
            ASSERT(IS_VALID_STRING_PTR(pli->pszMessage,-1));
            pszMessage = new TCHAR[lstrlen(pli->pszMessage)+1];
            StrCpy(pszMessage, pli->pszMessage);
        }
    }
    else
    {
        ASSERT(0==pszMessage);
    }

    if (LIM_ICON & dwMask)
    {
        hIcon = pli->hIcon;

        if (I_ICONCALLBACK == hIcon)
        {
            m_dwCallbacks |= LIM_ICON;
        }
    }

    if (LIM_NOTIFY & dwMask)
    {
        hwndNotify = pli->hwndNotify;
    }
    else
    {
        hwndNotify = GetParent(m_hwnd);
    }

    if (m_dwCallbacks && !IsWindow(hwndNotify))
    {
        // invalid notify window
        TraceMsg(TF_WARNING, "invalid notify window");
        return FALSE;
    }

    if (LIM_TIMEOUT & dwMask)
    {
        iTimeout = pli->iTimeout;
    }
    else
    {
        iTimeout = 10000;
    }

    if (LIM_TIPWIDTH & dwMask)
    {
        cxTipWidth = pli->cxTipWidth;
    }
    else
    {
        cxTipWidth = 500;
    }

    // everything in the *pli structure is valid
    TraceMsg(TF_GENERAL, "pli structure is valid");

    return SetWindowSubclass(hwnd, CInputLimiter::SubclassProc, 0, (LONG_PTR)this);
}

LRESULT CALLBACK CInputLimiter::SubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData)
{
    CInputLimiter * pthis = (CInputLimiter*)dwRefData;

    switch (uMsg)
    {
    case WM_CHAR:
        if (!pthis->OnChar(hwnd, wParam, lParam))
        {
            return 0;
        }
        break;

    case WM_KILLFOCUS:
        pthis->HideToolTip();
        break;

    case WM_TIMER:
        if (LIMITINPUTTIMERID == wParam)
        {
            pthis->HideToolTip();
            return 0;
        }
        break;

    case WM_PASTE:
        // Paste handler handles calling the super wnd proc when needed
        return pthis->OnPaste(hwnd, wParam, lParam);

    case WM_NCDESTROY:
        RemoveWindowSubclass(hwnd, CInputLimiter::SubclassProc, uID);
        delete pthis;
        break;

    default:
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

BOOL CInputLimiter::IsValidChar(TCHAR ch, BOOL bPaste)
{
    BOOL  bValidChar = FALSE;           // start by assuming the character is invalid

    if (LIF_CATEGORYFILTER & dwFlags)
    {
        TraceMsg(TF_GENERAL, "Processing LIF_CATEGORYFILTER: <0x%08x>", (WORD)pszFilter);
        // pszFilter is actually a bit field with valid character types
        WORD CharType = 0;
#define GETSTRINGTYPEEX_MASK    0x1FF

        // We only need to call GetStringTypeEx if some of the CT_TYPE1 values are being asked for
        if (((WORD)pszFilter) & GETSTRINGTYPEEX_MASK)
        {
            TraceMsg(TF_GENERAL, "Calling GetStringTypeEx");

            // We treat ch as a one character long string.
            // REVIEW: How are DBCS characters handled?  Is this fundamentally flawed for win9x?
            EVAL(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, (LPTSTR)&ch, 1, &CharType));
        }

        if (((WORD)pszFilter) & (WORD)CharType)
        {
            TraceMsg(TF_GENERAL, "GetStringTypeEx matched a character");
            // GetStringTypeEx found the string in one of the selected groups
            bValidChar = !(LIF_EXCLUDEFILTER & dwFlags);
        }
        else
        {
            TraceMsg(TF_GENERAL, "Checking the extra types not supported by GetStringTypeEx");
            // check for the string in our special groups.  We will temporarily use bValidChar
            // to indicate whether the character was found, not whether it's valid.
            if (LICF_BINARYDIGIT & PtrToUint(pszFilter))
            {
                if (CHAR_IN_RANGE(ch, TEXT('0'), TEXT('1')))
                {
                    bValidChar = TRUE;
                    goto charWasFound;
                }
            }
            if (LICF_OCTALDIGIT & PtrToUint(pszFilter))
            {
                if (CHAR_IN_RANGE(ch, TEXT('0'), TEXT('7')))
                {
                    bValidChar = TRUE;
                    goto charWasFound;
                }
            }
            if (LICF_ATOZUPPER & PtrToUint(pszFilter))
            {
                if (CHAR_IN_RANGE(ch, TEXT('A'), TEXT('Z')))
                {
                    bValidChar = TRUE;
                    goto charWasFound;
                }
            }
            if (LICF_ATOZLOWER & PtrToUint(pszFilter))
            {
                if (CHAR_IN_RANGE(ch, TEXT('a'), TEXT('z')))
                {
                    bValidChar = TRUE;
                    goto charWasFound;
                }
            }

charWasFound:
            // right now we have perverted the meaning of bValidChar to indicate if the
            // character was found or not.  We now convert the meaning from "was the
            // character found" to "is the character valid" by considering LIF_EXCLUDEFILTER.
            if (LIF_EXCLUDEFILTER & dwFlags)
            {
                bValidChar = !bValidChar;
            }
        }
    }
    else
    {
        TraceMsg(TF_GENERAL, "Processing string based filter");
        // pszFilter points to a NULL terminated string of characters
        LPTSTR psz = StrChr(pszFilter, ch);

        if (LIF_EXCLUDEFILTER & dwFlags)
        {
            bValidChar = (NULL == psz);
        }
        else
        {
            bValidChar = (NULL != psz);
        }
    }

    return bValidChar;
}

BOOL CInputLimiter::OnChar(HWND hwnd, WPARAM & wParam, LPARAM lParam)
{
    // if the char is a good one return TRUE, this will pass the char on to the
    // default window proc.  For a bad character do a beep and then display the
    // ballon tooltip pointing at the control.
    TCHAR ch = (TCHAR)wParam;

    if (LIM_FILTER & m_dwCallbacks)
    {
        // If we have callbacks then we need to update the filter and/or mask text.
        // Otherwise the filter and/or mask text is already correct.
        NMLIFILTERINFO lidi = {0};
        lidi.hdr.hwndFrom = m_hwnd;
        lidi.hdr.idFrom = GetWindowLong(m_hwnd, GWL_ID);
        lidi.hdr.code = LIN_GETFILTERINFO;
        lidi.li.dwMask = LIM_FILTER & m_dwCallbacks;

        SendMessage(hwndNotify, WM_NOTIFY, lidi.hdr.idFrom, (LPARAM)&lidi);

        pszFilter = lidi.li.pszFilter;

        // REVIEW: we should have a way for the notify hanlder to say "store this
        // result and stop asking me for the filter to use every time".
    }

    if (LIF_FORCEUPPERCASE & dwFlags)
    {
        ch = (TCHAR)CharUpper((LPTSTR)ch);
    }
    else if (LIF_FORCELOWERCASE & dwFlags)
    {
        ch = (TCHAR)CharLower((LPTSTR)ch);
    }

    if (IsValidChar(ch, FALSE))
    {
        if (LIF_HIDETIPONVALID & dwFlags)
        {
            HideToolTip();
        }

        // We might have upper or lower cased ch, so reflect this in wParam.  Since
        // wParam was passed by reference this will effect the message we forward
        // on to the original window proc.
        wParam = (WPARAM)ch;

        return TRUE;
    }
    else
    {
        // if we get here then an invalid character was entered

        if (LIF_NOTIFYONBADCHAR & dwFlags)
        {
            NMLIBADCHAR libc = {0};
            libc.hdr.hwndFrom = m_hwnd;
            libc.hdr.idFrom = GetWindowLong(m_hwnd, GWL_ID);
            libc.hdr.code = LIN_BADCHAR;
            libc.wParam = wParam;           // use the original, non case shifted wParam
            libc.lParam = lParam;

            SendMessage(hwndNotify, WM_NOTIFY, libc.hdr.idFrom, (LPARAM)&libc);
        }

        if (!(LIF_SILENT & dwFlags))
        {
            MessageBeep(MB_OK);
        }

        if (!(LIF_WARNINGOFF & dwFlags))
        {
            ShowToolTip();
        }

        return FALSE;
    }
}

LRESULT CInputLimiter::OnPaste(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    // There are hundreds of lines of code in user to successfully handle a paste into an edit control.
    // We need to leverage all that code while still disallowing invalid input to result from the paste.
    // As a result, what we need to do is to get the clip board data, validate that data, place the
    // valid data back onto the clipboard, call the default window proc to let user do it's thing, and
    // then restore the clipboard to it's original format.
    if (OpenClipboard(hwnd))
    {
        HANDLE hdata;
        UINT iFormat;
        DWORD cchBad = 0;           // count of the number of bad characters

        // REVIEW: Should this be based on the compile type or the window type?
        // Compile time check for the correct clipboard format to use:
        if (sizeof(WCHAR) == sizeof(TCHAR))
        {
            iFormat = CF_UNICODETEXT;
        }
        else
        {
            iFormat = CF_TEXT;
        }

        hdata = GetClipboardData(iFormat);

        if (hdata)
        {
            LPTSTR pszData;
            pszData = (LPTSTR)GlobalLock(hdata);
            if (pszData)
            {

                // we need to copy the original data because the clipboard owns the hdata
                // pointer.  That data will be invalid after we call SetClipboardData.
                // We start by calculating the size of the data:
                DWORD dwSize = (DWORD)GlobalSize(hdata);

                // Use the prefered GlobalAlloc for clipboard data
                HANDLE hClone = GlobalAlloc(GPTR, dwSize + sizeof(TCHAR));
                HANDLE hNew = GlobalAlloc(GPTR, dwSize + sizeof(TCHAR));
                if (hClone && hNew)
                {
                    LPTSTR pszClone = (LPTSTR)GlobalLock(hClone);
                    LPTSTR pszNew = (LPTSTR)GlobalLock(hNew);
                    if (pszClone && pszNew)
                    {
                        int iNew = 0;

                        // copy the original data as-is
                        memcpy(pszClone, pszData, (size_t)dwSize);
                        // ensure that it's NULL terminated
                        pszClone[(dwSize / sizeof(TCHAR))] = TEXT('\0');

                        // For a paste, we only call the filter callback once, not once for each
                        // character.  Why?  Because.
                        if (LIM_FILTER & m_dwCallbacks)
                        {
                            // If we have callbacks then we need to update the filter and/or mask text.
                            // Otherwise the filter and/or mask text is already correct.
                            NMLIFILTERINFO lidi = {0};
                            lidi.hdr.hwndFrom = m_hwnd;
                            lidi.hdr.idFrom = GetWindowLong(m_hwnd, GWL_ID);
                            lidi.hdr.code = LIN_GETFILTERINFO;
                            lidi.li.dwMask = LIM_FILTER & m_dwCallbacks;

                            SendMessage(hwndNotify, WM_NOTIFY, lidi.hdr.idFrom, (LPARAM)&lidi);

                            pszFilter = lidi.li.pszFilter;

                            // REVIEW: we should have a way for the notify hanlder to say "store this
                            // result and stop asking me for the filter to use every time".
                        }

                        for (LPTSTR psz = pszClone; *psz; psz++)
                        {
                            // we do the Upper/Lower casing one character at a time because we don't want to
                            // alter pszClone.  pszClone is used later to restore the ClipBoard.
                            if (LIF_FORCEUPPERCASE & dwFlags)
                            {
                                pszNew[iNew] = (TCHAR)CharUpper((LPTSTR)*psz);  // yes, this funky cast is correct.
                            }
                            else if (LIF_FORCELOWERCASE & dwFlags)
                            {
                                pszNew[iNew] = (TCHAR)CharLower((LPTSTR)*psz);  // yes, this funky cast is correct.
                            }
                            else
                            {
                                pszNew[iNew] = *psz;
                            }

                            if (IsValidChar(pszNew[iNew], TRUE))
                            {
                                iNew++;
                            }
                            else
                            {
                                if (LIF_NOTIFYONBADCHAR & dwFlags)
                                {
                                    NMLIBADCHAR libc = {0};
                                    libc.hdr.hwndFrom = m_hwnd;
                                    libc.hdr.idFrom = GetWindowLong(m_hwnd, GWL_ID);
                                    libc.hdr.code = LIN_BADCHAR;
                                    libc.wParam = (WPARAM)pszClone[iNew + cchBad];  // use the original, non case shifted chat
                                    libc.lParam = lParam;

                                    SendMessage(hwndNotify, WM_NOTIFY, libc.hdr.idFrom, (LPARAM)&libc);
                                }

                                cchBad++;

                                if (LIF_PASTECANCEL & dwFlags)
                                {
                                    iNew = 0;
                                    break;
                                }
                                if (LIF_PASTESTOP & dwFlags)
                                {
                                    break;
                                }
                            }
                        }
                        pszNew[iNew] = NULL;

                        // If there are any characters in the paste buffer then we paste the validated string
                        if (*pszNew)
                        {
                            // we always set the new string.  Worst case it's identical to the old string
                            GlobalUnlock(hNew);
                            pszNew = NULL;
                            SetClipboardData(iFormat, hNew);
                            hNew = NULL;

                            // call the super proc to do the paste
                            DefSubclassProc(hwnd, WM_PASTE, wParam, lParam);

                            // The above call will have closed the clipboard on us.  We try to re-open it.
                            // If this fails it's no big deal, that simply means the SetClipboardData
                            // call below will fail which is good if somebody else managed to open the
                            // clipboard in the mean time.
                            OpenClipboard(hwnd);

                            // and then we set it back to the original value.
                            GlobalUnlock(hClone);
                            pszClone = NULL;
                            if (LIF_KEEPCLIPBOARD & dwFlags)
                            {
                                SetClipboardData(iFormat, hClone);
                                hClone = NULL;
                            }
                        }
                    }

                    if (pszClone)
                    {
                        GlobalUnlock(hClone);
                    }

                    if (pszNew)
                    {
                        GlobalUnlock(hNew);
                    }
                }

                if (hClone)
                {
                    GlobalFree(hClone);
                }

                if (hNew)
                {
                    GlobalFree(hNew);
                }

                // at this point we are done with hdata so unlock it
                GlobalUnlock(hdata);
            }
        }
        CloseClipboard();

        if (0 == cchBad)
        {
            // the entire paste was valid
            if (LIF_HIDETIPONVALID & dwFlags)
            {
                HideToolTip();
            }
        }
        else
        {
            // if we get here then at least one invalid character was pasted
            if (!(LIF_SILENT & dwFlags))
            {
                MessageBeep(MB_OK);
            }

            if (!(LIF_WARNINGOFF & dwFlags))
            {
                ShowToolTip();
            }
        }
    }
    return TRUE;
}

void CInputLimiter::ShowToolTip()
{
    TraceMsg(TF_GENERAL, "About to show the tooltip");

    if (!m_hwndToolTip)
    {
        CreateToolTipWindow();
    }

    // Set the tooltip display point
    RECT rc;
    GetWindowRect(m_hwnd, &rc);
    int x, y;
    x = (rc.left+rc.right)/2;
    if (LIF_WARNINGABOVE & dwFlags)
    {
        y = rc.top;
    }
    else if (LIF_WARNINGCENTERED & dwFlags)
    {
        y = (rc.top+rc.bottom)/2;
    }
    else
    {
        y = rc.bottom;
    }
    SendMessage(m_hwndToolTip, TTM_TRACKPOSITION, 0, MAKELONG(x,y));

    TOOLINFO ti = {0};
    ti.cbSize = sizeof(ti);
    ti.hwnd = m_hwnd;
    ti.uId = 1;
    if ((LIM_TITLE|LIM_MESSAGE|LIM_ICON) & m_dwCallbacks)
    {
        // If we have callbacks then we need to update the tooltip text.
        // Otherwise the tooltip text is already correct.
        NMLIDISPINFO lidi = {0};
        lidi.hdr.hwndFrom = m_hwnd;
        lidi.hdr.idFrom = GetWindowLong(m_hwnd, GWL_ID);
        lidi.hdr.code = LIN_GETDISPINFO;
        lidi.li.dwMask = (LIM_TITLE|LIM_MESSAGE|LIM_ICON) & m_dwCallbacks;

        SendMessage(hwndNotify, WM_NOTIFY, lidi.hdr.idFrom, (LPARAM)&lidi);

        // REARCHITECT How do we use the icon, bold title, message style tooltips?
        // Until I learn how I'm just using the message string.

        ti.lpszText = lidi.li.pszMessage;

        SendMessage(m_hwndToolTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);
        if (lidi.li.pszTitle || lidi.li.hIcon)
        {
            SendMessage(m_hwndToolTip, TTM_SETTITLE, (WPARAM)lidi.li.hIcon, (LPARAM)lidi.li.pszTitle);
        }
    }

    // Show the tooltip
    SendMessage(m_hwndToolTip, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);

    // Set a timer to hide the tooltip
    if (m_uTimerID)
    {
        KillTimer(NULL,LIMITINPUTTIMERID);
    }
    m_uTimerID = SetTimer(m_hwnd, LIMITINPUTTIMERID, iTimeout, NULL);
}

// CreateToolTipWindow
//
// Creates our tooltip control.  We share this one tooltip control and use it for all invalid
// input messages.  The control is hiden when not in use and then shown when needed.
//
void CInputLimiter::CreateToolTipWindow()
{
    m_hwndToolTip = CreateWindow(
            TOOLTIPS_CLASS,
            NULL,
            WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            m_hwnd,
            NULL,
            GetModuleHandle(NULL),
            NULL);

    if (m_hwndToolTip)
    {
        SetWindowPos(m_hwndToolTip, HWND_TOPMOST,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        TOOLINFO ti = {0};
        RECT     rc = {2,2,2,2};

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_TRACK | TTF_TRANSPARENT;
        ti.hwnd = m_hwnd;
        ti.uId = 1;
        ti.hinst = hinst;
        // REARCHITECT: How do we use the icon, bold title, message style tooltips?
        // Until I learn how I'm just using the message string.
        ti.lpszText = pszMessage;

        // set the version so we can have non buggy mouse event forwarding
        SendMessage(m_hwndToolTip, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(m_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);
        SendMessage(m_hwndToolTip, TTM_SETMAXTIPWIDTH, 0, cxTipWidth);
        SendMessage(m_hwndToolTip, TTM_SETMARGIN, 0, (LPARAM)&rc);
        if (pszTitle || hIcon)
        {
            // REARCHITECT: hIcon needs to be an image list index or some such.  Get details
            // on how this really works.
            SendMessage(m_hwndToolTip, TTM_SETTITLE, (WPARAM)hIcon, (LPARAM)pszTitle);
        }
    }
    else
    {
        // failed to create tool tip window, now what should we do?  Unsubclass ourselves?
        TraceMsg(TF_GENERAL, "Failed to create tooltip window");
    }
}

void CInputLimiter::HideToolTip()
{
    // When the timer fires we hide the tooltip window
    if (m_uTimerID)
    {
        KillTimer(m_hwnd,LIMITINPUTTIMERID);
        m_uTimerID = 0;
    }
    if (m_hwndToolTip)
    {
        SendMessage(m_hwndToolTip, TTM_TRACKACTIVATE, FALSE, 0);
    }
}

// allows caller to pass in already contructed LIMITINPUT structure...
HRESULT SHLimitInputEditWithFlags(HWND hwndEdit, LIMITINPUT * pli)
{
    HRESULT hr;
    CInputLimiter *pInputLimiter = new CInputLimiter;
    if (pInputLimiter)
    {
        if (pInputLimiter->SubclassEditControl(hwndEdit, pli))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
            delete pInputLimiter;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//  LimitInput
//
//      Limits the characters that can be entered into an edit box.  It intercepts WM_CHAR
//    messages and only allows certain characters through.  Some characters, such as backspace
//    are always allowed through.
//
//  Args:
//      hwndEdit        Handle to an edit control.  Results will be unpredictable if any other window
//                      type is passed in.
//
//      pli             Pointer to a LIMITINPUT structure that determines how the input is limited.
HRESULT SHLimitInputEditChars(HWND hwndEdit, LPCWSTR pszValidChars, LPCWSTR pszInvalidChars)
{
    LPWSTR pszMessage = NULL;

    LIMITINPUT li = {0};
    li.cbSize = sizeof(li);
    li.dwMask = LIM_FLAGS | LIM_FILTER | LIM_MESSAGE | LIM_HINST;
    li.dwFlags = LIF_HIDETIPONVALID;
    li.hinst = g_hinst;
    if (pszValidChars)
    {
        // ick, li.pszFilter is used as const, but since CInputLimiter is derived from the struct itd be a
        // pain to define it as such.
        li.pszFilter = (LPWSTR)pszValidChars;
        li.dwFlags |= LIF_INCLUDEFILTER;
    }
    else
    {
        li.pszFilter = (LPWSTR)pszInvalidChars;
        li.dwFlags |= LIF_EXCLUDEFILTER;
    }

    // create the error message.
    PCWSTR pszChars = pszInvalidChars ? pszInvalidChars : pszValidChars;
    PWSTR pszSpacedChars = new WCHAR[2 * lstrlen(pszChars) + 1];
    if (pszSpacedChars)
    {
        // we're mimicing what IDS_INVALIDFN does for the known set of bad chars on the filesystem --
        // append each char and separate them by spaces.
        PWSTR psz = pszSpacedChars;
        for (int i = 0; i < lstrlen(pszChars); i++)
        {
            *psz++ = pszChars[i];
            *psz++ = L' ';
        }
        *psz = 0;

        int id = pszInvalidChars ? IDS_CHARSINVALID : IDS_CHARSVALID;
        pszMessage = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(id), pszSpacedChars);

        delete [] pszSpacedChars;
    }

    if (pszMessage)
    {
        li.pszMessage = pszMessage;
    }
    else
    {
        // fall back to the old message
        li.pszMessage = MAKEINTRESOURCE(IDS_INVALIDFN);
    }

    HRESULT hr = SHLimitInputEditWithFlags(hwndEdit, &li);

    if (pszMessage)
    {
        LocalFree(pszMessage);
    }
    return hr;
}

HRESULT SHLimitInputEdit(HWND hwndEdit, IShellFolder *psf)
{
    IItemNameLimits *pinl;
    HRESULT hr = psf->QueryInterface(IID_PPV_ARG(IItemNameLimits, &pinl));
    if (SUCCEEDED(hr))
    {
        LPWSTR pszValidChars;
        LPWSTR pszInvalidChars;
        hr = pinl->GetValidCharacters(&pszValidChars, &pszInvalidChars);
        if (SUCCEEDED(hr))
        {
            hr = SHLimitInputEditChars(hwndEdit, pszValidChars, pszInvalidChars);

            if (pszValidChars)
                CoTaskMemFree(pszValidChars);
            if (pszInvalidChars)
                CoTaskMemFree(pszInvalidChars);
        }
        pinl->Release();
    }

    return hr;
}

typedef struct tagCBLIMITINPUT
{
    HRESULT hr;
    IShellFolder *psf;
} CBLIMITINPUT;

// Limiting the input on a combo box is special cased because you first
// have to find the edit box and then LimitInput on that.
BOOL CALLBACK FindTheEditBox(HWND hwnd, LPARAM lParam)
{
    // The combo box only has one child, subclass it
    CBLIMITINPUT *pcbli = (CBLIMITINPUT*)lParam;

    pcbli->hr = SHLimitInputEdit(hwnd, pcbli->psf);
    return FALSE;
}

HRESULT SHLimitInputCombo(HWND hwndComboBox, IShellFolder *psf)
{
    CBLIMITINPUT cbli;
    cbli.hr = E_FAIL;
    cbli.psf = psf;

    EnumChildWindows(hwndComboBox, FindTheEditBox, (LPARAM)&cbli);

    return cbli.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\lnkcon.h ===
/*
 * The distinction between the desired and actual font dimensions obtained
 * is important in the case of TrueType fonts, in which there is no guarantee
 * that what you ask for is what you will get.
 *
 * Note that the correspondence between "Desired" and "Actual" is broken
 * whenever the user changes his display driver, because GDI uses driver
 * parameters to control the font rasterization.
 *
 * The SizeDesired is {0, 0} if the font is a raster font.
 */
typedef struct {
    HFONT hFont;
    COORD Size;      // font size obtained
    COORD SizeWant;  // 0;0 if Raster font
    LONG  Weight;
    LPTSTR FaceName;
    BYTE  Family;
    BYTE  tmCharSet;
} FONT_INFO;

typedef struct tagFACENODE {
     struct tagFACENODE *pNext;
     DWORD  dwFlag;
     TCHAR  atch[];
} FACENODE;

//
// TrueType font list
//     This structure shares in windows\inc\wincon.w file
//

// we don't make bold available if BOLD_MARK is in the face name.
#define BOLD_MARK    (L'*')

typedef struct _TT_FONT_LIST {
    SINGLE_LIST_ENTRY List;
    UINT  CodePage;
    BOOL  fDisableBold;
    TCHAR FaceName1[LF_FACESIZE];
    TCHAR FaceName2[LF_FACESIZE];
} TTFONTLIST;

#ifdef MAX_TITLE_LEN
#undef MAX_TITLE_LEN
#endif
#define MAX_TITLE_LEN 256
#define MAXDIMENSTRING     40  // max text in combo box
#define DX_TTBITMAP        20
#define DY_TTBITMAP        12
#define CCH_RASTERFONTS    24
#define CCH_SELECTEDFONT   30

typedef struct {
    IShellLink * psl;
    LPNT_CONSOLE_PROPS lpConsole;
    LPNT_FE_CONSOLE_PROPS lpFEConsole;
    BOOL bConDirty;
    int xScreen;
    int yScreen;
    POINT NonClientSize;
    RECT WindowRect;
    DWORD PreviewFlags;
    FONT_INFO *FontInfo;
    ULONG FontInfoLength;
    ULONG NumberOfFonts;
    BOOL gbEnumerateFaces;
    BOOL gbPointSizeError;
    BOOL gbBold;
    BOOL bFontInit;
    BOOL bColorInit;
    FACENODE *gpFaceNames;
    TCHAR DefaultFaceName[LF_FACESIZE];
    LPTSTR lpFaceName;
#ifndef UNICODE
    CHAR szFaceName[LF_FACESIZE];
#endif
    COORD DefaultFontSize;
    BYTE  DefaultFontFamily;
    ULONG DefaultFontIndex;
    ULONG CurrentFontIndex;
    LONG  FontLong;
    int   Index;
    BYTE  ColorArray[4];
    TCHAR ConsoleTitle[ MAX_TITLE_LEN + 1 ];
    BOOL fChangeCodePage;
    UINT uOEMCP;
    SINGLE_LIST_ENTRY gTTFontList;    // This list contain TTFONTLIST data.
} CONSOLEPROP_DATA;

// got this from wingdip.h so we don't have to compile it all
#define IS_ANY_DBCS_CHARSET( CharSet )                              \
                   ( ((CharSet) == SHIFTJIS_CHARSET)    ? TRUE :    \
                     ((CharSet) == HANGEUL_CHARSET)     ? TRUE :    \
                     ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :    \
                     ((CharSet) == GB2312_CHARSET)      ? TRUE : FALSE )

#define TM_IS_TT_FONT(x)     (((x) & TMPF_TRUETYPE) == TMPF_TRUETYPE)
#define IS_BOLD(w)           ((w) >= FW_SEMIBOLD)
#define SIZE_EQUAL(s1, s2)   (((s1).X == (s2).X) && ((s1).Y == (s2).Y))
#define POINTS_PER_INCH 72
#define MIN_PIXEL_HEIGHT 5
#define MAX_PIXEL_HEIGHT 72
#define CONSOLE_REGISTRY_CURRENTPAGE  (L"CurrentPage")


#define MAX_SCRBUF_WIDTH  9999
#define MAX_SCRBUF_HEIGHT 9999

#define INITIAL_FONTS 20
#define FONT_INCREMENT 3
#define CONSOLE_MAX_FONT_NAME_LENGTH 256

#define CM_SETCOLOR       (WM_USER+1)
#define CM_PREVIEW_UPDATE (WM_USER+2)
#define CM_PREVIEW_INIT   (WM_USER+3)
#define CM_COLOR_INIT     (WM_USER+4)


#define PREVIEW_HSCROLL  0x01
#define PREVIEW_VSCROLL  0x02

#define FE_ABANDONFONT 0
#define FE_SKIPFONT    1
#define FE_FONTOK      2


#define EF_NEW         0x0001 // a newly available face
#define EF_OLD         0x0002 // a previously available face
#define EF_ENUMERATED  0x0004 // all sizes have been enumerated
#define EF_OEMFONT     0x0008 // an OEM face
#define EF_TTFONT      0x0010 // a TT face
#define EF_DEFFACE     0x0020 // the default face
#define EF_DBCSFONT    0x0040 // the DBCS font


/* ----- Macros ----- */
/*
 *  High-level macros
 *
 *  These macros handle the SendMessages that go tofrom list boxes
 *  and combo boxes.
 *
 *  The "xxx_lcb" prefix stands for leaves CritSect & "list or combo box".
 *
 *  Basically, we're providing mnemonic names for what would otherwise
 *  look like a whole slew of confusing SendMessage's.
 *
 */
#define lcbRESETCONTENT(hWnd, bLB) \
        SendMessage(hWnd, bLB ? LB_RESETCONTENT : CB_RESETCONTENT, 0, 0L)

#define lcbGETTEXT(hWnd, bLB, w) \
        SendMessage(hWnd, bLB ? LB_GETTEXT : CB_GETLBTEXT, w, 0L)

#define lcbFINDSTRINGEXACT(hWnd, bLB, pwsz) \
        SendMessage(hWnd, bLB ? LB_FINDSTRINGEXACT : CB_FINDSTRINGEXACT, \
                          (DWORD)-1, (LPARAM)pwsz)

#define lcbADDSTRING(hWnd, bLB, pwsz) \
        SendMessage(hWnd, bLB ? LB_ADDSTRING : CB_ADDSTRING, 0, (LPARAM)pwsz)

#define lcbSETITEMDATA(hWnd, bLB, w, nFont) \
        SendMessage(hWnd, bLB ? LB_SETITEMDATA : CB_SETITEMDATA, w, nFont)

#define lcbGETITEMDATA(hWnd, bLB, w) \
        SendMessage(hWnd, bLB ? LB_GETITEMDATA : CB_GETITEMDATA, w, 0L)

#define lcbGETCOUNT(hWnd, bLB) \
        SendMessage(hWnd, bLB ? LB_GETCOUNT : CB_GETCOUNT, 0, 0L)

#define lcbGETCURSEL(hWnd, bLB) \
        SendMessage(hWnd, bLB ? LB_GETCURSEL : CB_GETCURSEL, 0, 0L)

#define lcbSETCURSEL(hWnd, bLB, w) \
        SendMessage(hWnd, bLB ? LB_SETCURSEL : CB_SETCURSEL, w, 0L)

#define NELEM(array) (sizeof(array)/sizeof(array[0]))
#define AttrToRGB(Attr) (pcpd->lpConsole->ColorTable[(Attr) & 0x0F])
#define ScreenTextColor(pcpd) \
            (AttrToRGB(LOBYTE(pcpd->lpConsole->wFillAttribute) & 0x0F))
#define ScreenBkColor(pcpd) \
            (AttrToRGB(LOBYTE(pcpd->lpConsole->wFillAttribute >> 4)))
#define PopupTextColor(pcpd) \
            (AttrToRGB(LOBYTE(pcpd->lpConsole->wPopupFillAttribute) & 0x0F))
#define PopupBkColor(pcpd) \
            (AttrToRGB(LOBYTE(pcpd->lpConsole->wPopupFillAttribute >> 4)))


NTSTATUS InitializeFonts( CONSOLEPROP_DATA *pcpd );

STDAPI_(void) DestroyFonts( CONSOLEPROP_DATA *pcpd );

NTSTATUS EnumerateFonts( CONSOLEPROP_DATA *pcpd, DWORD Flags);

int FindCreateFont(
    CONSOLEPROP_DATA *pcpd,
    DWORD Family,
    LPTSTR ptszFace,
    COORD Size,
    LONG Weight);

BOOL DoFontEnum(
    CONSOLEPROP_DATA *pcpd,
    HDC hDC,
    LPTSTR ptszFace,
    PSHORT pTTPoints,
    UINT nTTPoints);

void GetTitleFromLinkName(LPTSTR szLinkName, LPTSTR szTitle);
void SetRegistryValues(CONSOLEPROP_DATA *pcpd);
void GetRegistryValues(CONSOLEPROP_DATA *pcpd);
void InitRegistryValues(CONSOLEPROP_DATA *pcpd);
void GetRegistryValues(CONSOLEPROP_DATA *pcpd);
void SetFERegistryValues(CONSOLEPROP_DATA *pcpd);
void GetFERegistryValues(CONSOLEPROP_DATA *pcpd);
void InitFERegistryValues(CONSOLEPROP_DATA *pcpd);

NTSTATUS MakeAltRasterFont(
    CONSOLEPROP_DATA *pcpd,
    UINT CodePage,
    COORD *AltFontSize,
    BYTE  *AltFontFamily,
    ULONG *AltFontIndex,
    LPTSTR AltFaceName
    );

NTSTATUS InitializeDbcsMisc(CONSOLEPROP_DATA *pcpd);

BYTE CodePageToCharSet(UINT CodePage);

TTFONTLIST *SearchTTFont(CONSOLEPROP_DATA *pcpd, LPTSTR ptszFace, BOOL fCodePage, UINT CodePage);

BOOL IsAvailableTTFont(CONSOLEPROP_DATA *pcpd, LPTSTR ptszFace);
BOOL IsAvailableTTFontCP(CONSOLEPROP_DATA *pcpd, LPTSTR pwszFace, UINT CodePage);
BOOL IsDisableBoldTTFont(CONSOLEPROP_DATA *pcpd, LPTSTR ptszFace);
LPTSTR GetAltFaceName(CONSOLEPROP_DATA *pcpd, LPTSTR ptszFace);
NTSTATUS DestroyDbcsMisc(CONSOLEPROP_DATA *pcpd);

int LanguageListCreate(HWND hDlg, UINT CodePage);

typedef struct 
{
    LONG   _cRef;
    // input params
    IShellLink *psl;
    // local state variables
    HWND hDlg;
    HWND hDlgAdvanced;
    BOOL bIsFile;
    BOOL bIsDirty;
    int iIconIndex;
    BOOL bLinkThreadIsAlive;
    BOOL bCheckRunInSep;
    HANDLE hCheckNow;
    BOOL bEnableRunInSepVDM;
    BOOL bRunInSepVDM;
    BOOL bRunAsUser;
    TCHAR szFile[MAX_PATH];
    TCHAR szIconPath[MAX_PATH];
} LINKPROP_DATA;


typedef struct {
    LINKPROP_DATA *plpd;
    CONSOLEPROP_DATA cpd;
} LINKDATA;

STDAPI SaveLink(LINKDATA *pld);
STDAPI_(void) LinkConsolePagesSave(LINKDATA *pld);
STDAPI_(void) AddLinkConsolePages(LINKDATA *pld, IShellLink * psl, LPCTSTR pszFile, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\lnkcon.c ===
//
// lnkcon.c       link console property pages implementation
//
//---------------------------------------------------------------------------

#include "shellprv.h"
#pragma hdrstop
#include "lnkcon.h"


LRESULT PreviewWndProc( HWND hWnd, UINT wMessage, WPARAM wParam, LPARAM lParam );

BOOL_PTR CALLBACK _FontDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam );
LRESULT _FontPreviewWndProc( HWND hWnd, UINT wMessage, WPARAM wParam, LPARAM lParam );

extern TCHAR g_szPreviewText[];

// Context-sensitive help ids

const static DWORD rgdwHelpColor[] = {
    IDC_CNSL_COLOR_SCREEN_TEXT,       IDH_CONSOLE_COLOR_SCR_TEXT,
    IDC_CNSL_COLOR_SCREEN_BKGND,      IDH_CONSOLE_COLOR_SCR_BACK,
    IDC_CNSL_COLOR_POPUP_TEXT,        IDH_CONSOLE_COLOR_POPUP_TEXT,
    IDC_CNSL_COLOR_POPUP_BKGND,       IDH_CONSOLE_COLOR_POPUP_BACK,
    IDC_CNSL_COLOR_RED_LBL,           IDH_CONSOLE_COLOR_RED,
    IDC_CNSL_COLOR_RED,               IDH_CONSOLE_COLOR_RED,
    IDC_CNSL_COLOR_GREEN_LBL,         IDH_CONSOLE_COLOR_RED,
    IDC_CNSL_COLOR_GREEN,             IDH_CONSOLE_COLOR_RED,
    IDC_CNSL_COLOR_BLUE_LBL,          IDH_CONSOLE_COLOR_RED,
    IDC_CNSL_COLOR_BLUE,              IDH_CONSOLE_COLOR_RED,
    IDC_CNSL_COLOR_SCREEN_COLORS,     IDH_CONSOLE_COLOR_SCR_COLORS,
    IDC_CNSL_COLOR_SCREEN_COLORS_LBL, IDH_CONSOLE_COLOR_SCR_COLORS,
    IDC_CNSL_COLOR_POPUP_COLORS,      IDH_CONSOLE_COLOR_WIN_COLORS,
    IDC_CNSL_COLOR_POPUP_COLORS_LBL,  IDH_CONSOLE_COLOR_WIN_COLORS,
    IDC_CNSL_COLOR_1,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_2,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_3,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_4,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_5,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_6,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_7,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_8,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_9,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_10,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_11,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_12,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_13,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_14,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_15,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_16,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_GROUP0,                  -1,
    IDC_CNSL_GROUP1,                  -1,
    IDC_CNSL_GROUP2,                  -1,
    0, 0
};


const static DWORD rgdwHelpSettings[] = {
    IDC_CNSL_HISTORY_NUM_LBL,  IDH_CONSOLE_OPTIONS_BUFF_NUM,
    IDC_CNSL_HISTORY_NUM,      IDH_CONSOLE_OPTIONS_BUFF_NUM,
    IDC_CNSL_HISTORY_SIZE_LBL, IDH_CONSOLE_OPTIONS_BUFF_SIZE,
    IDC_CNSL_HISTORY_SIZE,     IDH_CONSOLE_OPTIONS_BUFF_SIZE,
    IDC_CNSL_CURSOR_SMALL,     IDH_CONSOLE_OPTIONS_CURSOR,
    IDC_CNSL_CURSOR_LARGE,     IDH_CONSOLE_OPTIONS_CURSOR,
    IDC_CNSL_CURSOR_MEDIUM,    IDH_CONSOLE_OPTIONS_CURSOR,
    IDC_CNSL_HISTORY_NODUP,    IDH_CONSOLE_OPTIONS_DISCARD_DUPS,
    IDC_CNSL_INSERT,           IDH_CONSOLE_OPTIONS_INSERT,
    IDC_CNSL_QUICKEDIT,        IDH_CONSOLE_OPTIONS_QUICK_EDIT,
    IDC_CNSL_LANGUAGELIST,     IDH_CONSOLE_OPTIONS_LANGUAGE,
    IDC_CNSL_FULLSCREEN,       IDH_DOS_SCREEN_USAGE_FULL,
    IDC_CNSL_WINDOWED,         IDH_DOS_SCREEN_USAGE_WINDOW,
    IDC_CNSL_GROUP0,           -1,
    IDC_CNSL_GROUP1,           -1,
    IDC_CNSL_GROUP2,           -1,
    0, 0
};

const static DWORD rgdwHelpSize[] = {
    IDC_CNSL_SCRBUF_WIDTH_LBL,   IDH_CONSOLE_SIZE_BUFF_WIDTH,
    IDC_CNSL_SCRBUF_WIDTH,       IDH_CONSOLE_SIZE_BUFF_WIDTH,
    IDC_CNSL_SCRBUF_HEIGHT_LBL,  IDH_CONSOLE_SIZE_BUFF_HEIGHT,
    IDC_CNSL_SCRBUF_HEIGHT,      IDH_CONSOLE_SIZE_BUFF_HEIGHT,
    IDC_CNSL_WINDOW_WIDTH_LBL,   IDH_CONSOLE_SIZE_WIN_WIDTH,
    IDC_CNSL_WINDOW_WIDTH,       IDH_CONSOLE_SIZE_WIN_WIDTH,
    IDC_CNSL_WINDOW_HEIGHT_LBL,  IDH_CONSOLE_SIZE_WIN_HEIGHT,
    IDC_CNSL_WINDOW_HEIGHT,      IDH_CONSOLE_SIZE_WIN_HEIGHT,
    IDC_CNSL_WINDOW_POSX_LBL,    IDH_CONSOLE_SIZE_POS_LEFT,
    IDC_CNSL_WINDOW_POSX,        IDH_CONSOLE_SIZE_POS_LEFT,
    IDC_CNSL_WINDOW_POSY_LBL,    IDH_CONSOLE_SIZE_POS_TOP,
    IDC_CNSL_WINDOW_POSY,        IDH_CONSOLE_SIZE_POS_TOP,
    IDC_CNSL_AUTO_POSITION,      IDH_CONSOLE_SIZE_LET_SYS,
    IDC_CNSL_PREVIEWLABEL,       IDH_DOS_FONT_WINDOW_PREVIEW,
    IDC_CNSL_PREVIEWWINDOW,      IDH_DOS_FONT_WINDOW_PREVIEW,
    IDC_CNSL_GROUP0,             -1,
    IDC_CNSL_GROUP1,             -1,
    IDC_CNSL_GROUP2,             -1,
    0, 0
};





#ifdef ADVANCED_PAGE
VOID
_AddEnvVariable(
    HWND hwndLV,
    INT iItem,
    LPTSTR pszVar
    )
{
    TCHAR szTemp[ 1024 ];
    LV_ITEM lvi;
    LPTSTR p;

    for( p = szTemp; *pszVar!=TEXT('='); *p++ = *pszVar++ );
    *p = TEXT('\0');
    pszVar++;

    lvi.mask = LVIF_TEXT;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.pszText = szTemp;
    SendMessage( hwndLV, LVM_SETITEM, 0, (LPARAM)&lvi );

    for( p=szTemp; *pszVar!=TEXT('\0'); *p++ = *pszVar++ );
    *p = TEXT('\0');
    lvi.mask = LVIF_TEXT;
    lvi.iItem = iItem;
    lvi.iSubItem = 1;
    lvi.pszText = szTemp;
    SendMessage( hwndLV, LVM_SETITEM, 0, (LPARAM)&lvi );

}


BOOL_PTR
CALLBACK
_AdvancedDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the settings dialog box.

--*/

{
    UINT Item;
    HWND hWnd;
    RECT r;
    LV_COLUMN lvc;
    HWND hwndLV;
    LPTSTR pszEnv, pszSave;
    LV_ITEM lvi;
    INT i;

    LINKDATA *pld = (LINKDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {
    case WM_INITDIALOG:
        pld = (LINKDATA *)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pld);

        // Initialize Columns in listview
        hwndLV = GetDlgItem( hDlg, IDC_CNSL_ADVANCED_LISTVIEW );
        GetClientRect( hwndLV, &r );
        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvc.fmt = LVCFMT_LEFT;
        lvc.cx = (((r.right - r.left) - GetSystemMetrics(SM_CXVSCROLL)) * 7) / 20;
        lvc.pszText = TEXT("Variable Name");
        ListView_InsertColumn( hwndLV, 0, &lvc );
        lvc.cx = (((r.right - r.left) - GetSystemMetrics(SM_CXVSCROLL)) * 13) / 20;
        lvc.pszText = TEXT("Value");
        ListView_InsertColumn( hwndLV, 1, &lvc );


        ZeroMemory( &lvi, sizeof(lvi) );
        pszSave = pszEnv = GetEnvironmentStrings();
        while (pszEnv && *pszEnv)
        {
            i = SendMessage( hwndLV, LVM_INSERTITEM, 0, (LPARAM)&lvi );
            
            _AddEnvVariable( hwndLV, i, pszEnv );
            
            for( ; *pszEnv; pszEnv++ )
            {
                // do nothing
            }
            pszEnv++;
        }

        FreeEnvironmentStrings( pszSave );
        return TRUE;

    case WM_DESTROY:
        EndDialog( hDlg, TRUE );
        break;

    case WM_COMMAND:
        Item = LOWORD(wParam);

        switch (Item)
        {


        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            if (FAILED(SaveLink(pld)))
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;

        case PSN_KILLACTIVE:
            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            if (Item = GetDlgCtrlID(GetFocus())) {
                SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            }
            return TRUE;
        }
        break;


    default:
        break;
    }
    return FALSE;
}
#endif // ADVANCED_PAGE

LRESULT
ColorControlProc(
    HWND hColor,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Window proc for the color buttons

--*/

{
    PAINTSTRUCT ps;
    int ColorId;
    RECT rColor;
    RECT rTemp;
    HBRUSH hbr;
    HDC hdc;
    HWND hWnd;
    HWND hDlg;
    COLORREF rgbBrush;

    CONSOLEPROP_DATA * pcpd = (CONSOLEPROP_DATA *)GetWindowLongPtr( hColor, 0 );

    ColorId = GetWindowLong(hColor, GWL_ID);
    hDlg = GetParent(hColor);

    switch (wMsg) {

    case CM_COLOR_INIT:
        SetWindowLongPtr( hColor, 0, lParam );
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS | DLGC_WANTTAB;
        break;

    case WM_SETFOCUS:
        if (pcpd->ColorArray[pcpd->Index] != (BYTE)(ColorId - IDC_CNSL_COLOR_1)) {
            hWnd = GetDlgItem(hDlg, pcpd->ColorArray[pcpd->Index]+IDC_CNSL_COLOR_1);
            SetFocus(hWnd);
        }
        // Fall through
    case WM_KILLFOCUS:
        hdc = GetDC(hDlg);
        hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_1);
        GetWindowRect(hWnd, &rColor);
        hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_16);
        GetWindowRect(hWnd, &rTemp);
        rColor.right = rTemp.right;
        ScreenToClient(hDlg, (LPPOINT)&rColor.left);
        ScreenToClient(hDlg, (LPPOINT)&rColor.right);
        InflateRect(&rColor, 2, 2);
        DrawFocusRect(hdc, &rColor);
        ReleaseDC(hDlg, hdc);
        break;

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_UP:
        case VK_LEFT:
            if (ColorId > IDC_CNSL_COLOR_1) {
                SendMessage(hDlg, CM_SETCOLOR,
                            ColorId - 1 - IDC_CNSL_COLOR_1, (LPARAM)hColor);
            }
            break;
        case VK_DOWN:
        case VK_RIGHT:
            if (ColorId < IDC_CNSL_COLOR_16) {
                SendMessage(hDlg, CM_SETCOLOR,
                            ColorId + 1 - IDC_CNSL_COLOR_1, (LPARAM)hColor);
            }
            break;
        case VK_TAB:
            hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_1);
            hWnd = GetNextDlgTabItem(hDlg, hWnd, GetKeyState(VK_SHIFT) < 0);
            SetFocus(hWnd);
            break;
        default:
            return DefWindowProc(hColor, wMsg, wParam, lParam);
        }
        break;

    case WM_RBUTTONDOWN:
    case WM_LBUTTONDOWN:
        SendMessage(hDlg, CM_SETCOLOR,
                    ColorId - IDC_CNSL_COLOR_1, (LPARAM)hColor);
        break;

    case WM_PAINT:
        BeginPaint(hColor, &ps);
        GetClientRect(hColor, &rColor);
        rgbBrush = GetNearestColor(ps.hdc, pcpd->lpConsole->ColorTable[ColorId-IDC_CNSL_COLOR_1]);
        if ((hbr = CreateSolidBrush(rgbBrush)) != NULL) {
            //
            // are we the selected color for the current object?
            //
            if (pcpd->ColorArray[pcpd->Index] == (BYTE)(ColorId - IDC_CNSL_COLOR_1)) {

                //
                // put current values in dialog box
                //
                SendDlgItemMessage(hDlg, IDC_CNSL_COLOR_REDSCROLL,   UDM_SETPOS, 0, MAKELONG( GetRValue(AttrToRGB(pcpd->ColorArray[pcpd->Index])),0));
                SendDlgItemMessage(hDlg, IDC_CNSL_COLOR_GREENSCROLL, UDM_SETPOS, 0, MAKELONG( GetGValue(AttrToRGB(pcpd->ColorArray[pcpd->Index])),0));
                SendDlgItemMessage(hDlg, IDC_CNSL_COLOR_BLUESCROLL,  UDM_SETPOS, 0, MAKELONG( GetBValue(AttrToRGB(pcpd->ColorArray[pcpd->Index])),0));

                //
                // highlight the selected color
                //
                FrameRect(ps.hdc, &rColor, GetStockObject(BLACK_BRUSH));
                InflateRect(&rColor, -1, -1);
                FrameRect(ps.hdc, &rColor, GetStockObject(BLACK_BRUSH));
            }
            InflateRect(&rColor, -1, -1);
            FillRect(ps.hdc, &rColor, hbr);
            DeleteObject(hbr);
        }
        EndPaint(hColor, &ps);
        break;

    default:
        return DefWindowProc(hColor, wMsg, wParam, lParam);
        break;
    }
    return TRUE;
}

LRESULT
ColorTextProc(
    HWND hWnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Window proc for the color preview windows

--*/

{
    PAINTSTRUCT ps;
    int ColorId;
    RECT rect;
    HBRUSH hbr;
    HFONT hfT;

    CONSOLEPROP_DATA * pcpd = (CONSOLEPROP_DATA *)GetWindowLongPtr( hWnd, 0 );

    ColorId = GetWindowLong(hWnd, GWL_ID);
    switch (wMsg) {
    case CM_COLOR_INIT:
        SetWindowLongPtr( hWnd, 0, lParam );
        break;
    case WM_PAINT:
        BeginPaint(hWnd, &ps);
        GetClientRect(hWnd, &rect);
        InflateRect(&rect, -2, -2);

        if (ColorId == IDC_CNSL_COLOR_SCREEN_COLORS) {
            SetTextColor(ps.hdc, ScreenTextColor(pcpd));
            SetBkColor(ps.hdc, ScreenBkColor(pcpd));
            hbr = CreateSolidBrush( ScreenBkColor(pcpd) );
        } else {
            SetTextColor(ps.hdc, PopupTextColor(pcpd));
            SetBkColor(ps.hdc, PopupBkColor(pcpd));
            hbr = CreateSolidBrush( PopupBkColor(pcpd) );
        }

        /* Draw the text sample */

        if (hbr)
        {
            FillRect(ps.hdc, &rect, hbr);
            DeleteObject(hbr);
        }

        hfT = SelectObject(ps.hdc, pcpd->FontInfo[pcpd->CurrentFontIndex].hFont);
        DrawText(ps.hdc, g_szPreviewText, -1, &rect, 0);
        SelectObject(ps.hdc, hfT);

        EndPaint(hWnd, &ps);
        break;
    default:
        return DefWindowProc(hWnd, wMsg, wParam, lParam);
        break;
    }
    return TRUE;
}

BOOL_PTR
WINAPI
_ColorDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the color selection dialog box.

--*/

{
    UINT Value;
    UINT Red;
    UINT Green;
    UINT Blue;
    UINT Item;
    HWND hWnd;
    HWND hWndOld;
    BOOL bOK;

    LINKDATA *pld = (LINKDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {
    case WM_INITDIALOG:
        pld = (LINKDATA *)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pld);
        pld->cpd.bColorInit = FALSE;
        pld->cpd.ColorArray[IDC_CNSL_COLOR_SCREEN_TEXT - IDC_CNSL_COLOR_SCREEN_TEXT] =
                LOBYTE(pld->cpd.lpConsole->wFillAttribute) & 0x0F;
        pld->cpd.ColorArray[IDC_CNSL_COLOR_SCREEN_BKGND - IDC_CNSL_COLOR_SCREEN_TEXT] =
                LOBYTE(pld->cpd.lpConsole->wFillAttribute >> 4);
        pld->cpd.ColorArray[IDC_CNSL_COLOR_POPUP_TEXT - IDC_CNSL_COLOR_SCREEN_TEXT] =
                LOBYTE(pld->cpd.lpConsole->wPopupFillAttribute) & 0x0F;
        pld->cpd.ColorArray[IDC_CNSL_COLOR_POPUP_BKGND - IDC_CNSL_COLOR_SCREEN_TEXT] =
                LOBYTE(pld->cpd.lpConsole->wPopupFillAttribute >> 4);
        CheckRadioButton(hDlg,IDC_CNSL_COLOR_SCREEN_TEXT,IDC_CNSL_COLOR_POPUP_BKGND,IDC_CNSL_COLOR_SCREEN_BKGND);
        pld->cpd.Index = IDC_CNSL_COLOR_SCREEN_BKGND - IDC_CNSL_COLOR_SCREEN_TEXT;

        // initialize color controls
        for (Item=IDC_CNSL_COLOR_1; Item<=IDC_CNSL_COLOR_16; Item++)
            SendDlgItemMessage(hDlg, Item,  CM_COLOR_INIT, 0, (LPARAM)&pld->cpd );

        // initialize text preview controls
        SendDlgItemMessage(hDlg, IDC_CNSL_COLOR_SCREEN_COLORS, CM_COLOR_INIT, 0, (LPARAM)&pld->cpd );
        SendDlgItemMessage(hDlg, IDC_CNSL_COLOR_POPUP_COLORS,  CM_COLOR_INIT, 0, (LPARAM)&pld->cpd );

        // Set ranges & position for updown controls
        SendDlgItemMessage( hDlg, IDC_CNSL_COLOR_REDSCROLL,   UDM_SETRANGE, 0, (LPARAM)MAKELONG( 255, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_COLOR_GREENSCROLL, UDM_SETRANGE, 0, (LPARAM)MAKELONG( 255, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_COLOR_BLUESCROLL,  UDM_SETRANGE, 0, (LPARAM)MAKELONG( 255, 0 ) );
#define pcpd (&pld->cpd)
        SendDlgItemMessage( hDlg, IDC_CNSL_COLOR_REDSCROLL,   UDM_SETPOS, 0,
            (LPARAM)MAKELONG(GetRValue(AttrToRGB(pld->cpd.ColorArray[pld->cpd.Index])), 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_COLOR_GREENSCROLL, UDM_SETPOS, 0,
            (LPARAM)MAKELONG(GetGValue(AttrToRGB(pld->cpd.ColorArray[pld->cpd.Index])), 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_COLOR_BLUESCROLL,  UDM_SETPOS, 0,
            (LPARAM)MAKELONG(GetBValue(AttrToRGB(pld->cpd.ColorArray[pld->cpd.Index])), 0 ) );
#undef pcpd
        pld->cpd.bColorInit = TRUE;
        return TRUE;

    //
    // handle help messages
    //


    case WM_HELP:               /* F1 or title-bar help button */
        WinHelp( (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                 NULL,
                 HELP_WM_HELP,
                 (ULONG_PTR) (LPVOID) &rgdwHelpColor[0]
                );
        break;

    case WM_CONTEXTMENU:        /* right mouse click */
        WinHelp( (HWND) wParam,
                 NULL,
                 HELP_CONTEXTMENU,
                 (ULONG_PTR) (LPVOID) &rgdwHelpColor[0]
                );
        break;


    case WM_COMMAND:
        Item = LOWORD(wParam);

        switch (Item)
        {

        case IDC_CNSL_COLOR_SCREEN_TEXT:
        case IDC_CNSL_COLOR_SCREEN_BKGND:
        case IDC_CNSL_COLOR_POPUP_TEXT:
        case IDC_CNSL_COLOR_POPUP_BKGND:
            hWndOld = GetDlgItem(hDlg, pld->cpd.ColorArray[pld->cpd.Index]+IDC_CNSL_COLOR_1);

            pld->cpd.Index = Item - IDC_CNSL_COLOR_SCREEN_TEXT;
            CheckRadioButton(hDlg,IDC_CNSL_COLOR_SCREEN_TEXT,IDC_CNSL_COLOR_POPUP_BKGND,Item);

            // repaint new color
            hWnd = GetDlgItem(hDlg, pld->cpd.ColorArray[pld->cpd.Index]+IDC_CNSL_COLOR_1);
            InvalidateRect(hWnd, NULL, TRUE);

            // repaint old color
            if (hWndOld != hWnd)
            {
                InvalidateRect(hWndOld, NULL, TRUE);
            }

            return TRUE;

        case IDC_CNSL_COLOR_RED:
        case IDC_CNSL_COLOR_GREEN:
        case IDC_CNSL_COLOR_BLUE:
            switch (HIWORD(wParam))
            {

            case EN_UPDATE:
                Value = GetDlgItemInt(hDlg, Item, &bOK, TRUE);
                if (bOK)
                {
                    if (Value > 255) {
                        Value = 255;
                        SetDlgItemInt( hDlg, Item, Value, TRUE );
                    }
                    if ((int)Value < 0) {
                        Value = 0;
                        SetDlgItemInt( hDlg, Item, Value, TRUE );
                    }

                }
                if (pld)
                    pld->cpd.bConDirty = TRUE;
                PropSheet_Changed( GetParent( hDlg ), hDlg );
                break;

            case EN_KILLFOCUS:

                if (!pld)
                    return FALSE;

                //
                // Update the state info structure
                //

#define pcpd (&pld->cpd)
                Value = GetDlgItemInt(hDlg, Item, &bOK, TRUE);
                if (bOK)
                {
                    if (Value > 255) {
                        Value = 255;
                        SetDlgItemInt( hDlg, Item, Value, TRUE );
                    }
                    if ((int)Value < 0) {
                        Value = 0;
                        SetDlgItemInt( hDlg, Item, Value, TRUE );
                    }
                    if (Item == IDC_CNSL_COLOR_RED) {
                        Red = Value;
                    } else {
                        Red = GetRValue(AttrToRGB(pld->cpd.ColorArray[pld->cpd.Index]));
                    }
                    if (Item == IDC_CNSL_COLOR_GREEN) {
                        Green = Value;
                    } else {
                        Green = GetGValue(AttrToRGB(pld->cpd.ColorArray[pld->cpd.Index]));
                    }
                    if (Item == IDC_CNSL_COLOR_BLUE) {
                        Blue = Value;
                    } else {
                        Blue = GetBValue(AttrToRGB(pld->cpd.ColorArray[pld->cpd.Index]));
                    }
                    pld->cpd.lpConsole->ColorTable[pld->cpd.ColorArray[pld->cpd.Index]] =
                                    RGB(Red, Green, Blue);
                }
#undef pcpd

                //
                // Update the preview windows with the new value
                //

                hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_SCREEN_COLORS);
                InvalidateRect(hWnd, NULL, FALSE);
                hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_POPUP_COLORS);
                InvalidateRect(hWnd, NULL, FALSE);
                hWnd = GetDlgItem(hDlg, pld->cpd.ColorArray[pld->cpd.Index]+IDC_CNSL_COLOR_1);
                InvalidateRect(hWnd, NULL, FALSE);
                break;
            }
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            if (FAILED(SaveLink(pld)))
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;

        }
        break;

    case WM_VSCROLL:
        // minus 1 because edit control precedes the updown control in the .rc file
        Item = GetDlgCtrlID( (HWND)lParam ) - 1;
        switch (LOWORD(wParam)) {
        case SB_ENDSCROLL:
            SendDlgItemMessage(hDlg, Item, EM_SETSEL, 0, (DWORD)-1);
            break;
        default:
            /*
             * Get the new value for the control
             */
            Value = GetDlgItemInt(hDlg, Item, &bOK, TRUE);
            SendDlgItemMessage(hDlg, Item, EM_SETSEL, 0, (DWORD)-1);
            hWnd = GetDlgItem(hDlg, Item);
            SetFocus(hWnd);

            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );

            break;
        }
        return TRUE;

    case CM_SETCOLOR:
        switch( pld->cpd.Index + IDC_CNSL_COLOR_SCREEN_TEXT )
        {
        case IDC_CNSL_COLOR_SCREEN_TEXT:
            pld->cpd.lpConsole->wFillAttribute = (WORD)
                        ((pld->cpd.lpConsole->wFillAttribute & 0xF0) |
                        (wParam & 0x0F));
            break;
        case IDC_CNSL_COLOR_SCREEN_BKGND:
            pld->cpd.lpConsole->wFillAttribute = (WORD)
                        ((pld->cpd.lpConsole->wFillAttribute & 0x0F) |
                        (wParam << 4));
            break;
        case IDC_CNSL_COLOR_POPUP_TEXT:
            pld->cpd.lpConsole->wPopupFillAttribute = (WORD)
                        ((pld->cpd.lpConsole->wPopupFillAttribute & 0xF0) |
                        (wParam & 0x0F));
            break;
        case IDC_CNSL_COLOR_POPUP_BKGND:
            pld->cpd.lpConsole->wPopupFillAttribute = (WORD)
                        ((pld->cpd.lpConsole->wPopupFillAttribute & 0x0F) |
                        (wParam << 4));
            break;
        }

        hWndOld = GetDlgItem(hDlg, pld->cpd.ColorArray[pld->cpd.Index]+IDC_CNSL_COLOR_1);

        pld->cpd.ColorArray[pld->cpd.Index] = (BYTE)wParam;
        pld->cpd.bConDirty = TRUE;
        PropSheet_Changed( GetParent( hDlg ), hDlg );

        // Force the preview window to repaint

        if (pld->cpd.Index < (IDC_CNSL_COLOR_POPUP_TEXT - IDC_CNSL_COLOR_SCREEN_TEXT)) {
            hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_SCREEN_COLORS);
        } else {
            hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_POPUP_COLORS);
        }
        InvalidateRect(hWnd, NULL, TRUE);

        // repaint new color
        hWnd = GetDlgItem(hDlg, pld->cpd.ColorArray[pld->cpd.Index]+IDC_CNSL_COLOR_1);
        InvalidateRect(hWnd, NULL, TRUE);
        SetFocus(hWnd);

        // repaint old color
        if (hWndOld != hWnd) {
            InvalidateRect(hWndOld, NULL, TRUE);
        }
        return TRUE;

    default:
        break;
    }
    return FALSE;
}



BOOL_PTR
CALLBACK
_ConsoleSettingsDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the settings dialog box.

--*/

{
    UINT Item;
    SYSTEM_INFO SystemInfo;

    LINKDATA *pld = (LINKDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {
    case WM_INITDIALOG:
        pld = (LINKDATA *)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pld);
        GetSystemInfo(&SystemInfo);
        if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
            if (pld->cpd.lpConsole->bFullScreen)
                CheckRadioButton(hDlg,IDC_CNSL_WINDOWED,IDC_CNSL_FULLSCREEN,IDC_CNSL_FULLSCREEN);
            else
                CheckRadioButton(hDlg,IDC_CNSL_WINDOWED,IDC_CNSL_FULLSCREEN,IDC_CNSL_WINDOWED);
        } else {
            ShowWindow(GetDlgItem(hDlg, IDC_CNSL_WINDOWED), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_CNSL_FULLSCREEN), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_CNSL_GROUP2), SW_HIDE);
        }

        CheckDlgButton(hDlg, IDC_CNSL_HISTORY_NODUP, pld->cpd.lpConsole->bHistoryNoDup);
        CheckDlgButton(hDlg, IDC_CNSL_QUICKEDIT, pld->cpd.lpConsole->bQuickEdit);
        CheckDlgButton(hDlg, IDC_CNSL_INSERT, pld->cpd.lpConsole->bInsertMode);

        // initialize cursor radio buttons

        if (pld->cpd.lpConsole->uCursorSize <= 25)
        {
            Item = IDC_CNSL_CURSOR_SMALL;
        }
        else if (pld->cpd.lpConsole->uCursorSize <= 50)
        {
            Item = IDC_CNSL_CURSOR_MEDIUM;
        }
        else
        {
            Item = IDC_CNSL_CURSOR_LARGE;
        }
        CheckRadioButton(hDlg, IDC_CNSL_CURSOR_SMALL, IDC_CNSL_CURSOR_LARGE, Item);

        // initialize updown controls

        SendDlgItemMessage( hDlg, IDC_CNSL_HISTORY_SIZESCROLL,  UDM_SETRANGE, 0, (LPARAM)MAKELONG( 999, 1 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_HISTORY_NUMSCROLL,   UDM_SETRANGE, 0, (LPARAM)MAKELONG( 999, 1 ) );

        //
        // put current values in dialog box
        //
        SendDlgItemMessage( hDlg, IDC_CNSL_HISTORY_SIZESCROLL,  UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->uHistoryBufferSize, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_HISTORY_NUMSCROLL,   UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->uNumberOfHistoryBuffers, 0 ) );

        if (IsFarEastCP(pld->cpd.uOEMCP))
            LanguageListCreate(hDlg, pld->cpd.lpFEConsole->uCodePage);
        else
        {
            ShowWindow(GetDlgItem(hDlg, IDC_CNSL_GROUP3), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_CNSL_LANGUAGELIST), SW_HIDE);
        }
        return TRUE;

    case WM_DESTROY:
        EndDialog( hDlg, TRUE );
        break;

    //
    // handle help messages
    //
    case WM_HELP:               /* F1 or title-bar help button */
        WinHelp( (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                 NULL,
                 HELP_WM_HELP,
                 (ULONG_PTR) (LPVOID) &rgdwHelpSettings[0]
                );
        break;

    case WM_CONTEXTMENU:        /* right mouse click */
        WinHelp( (HWND) wParam,
                 NULL,
                 HELP_CONTEXTMENU,
                 (ULONG_PTR) (LPVOID) &rgdwHelpSettings[0]
                );
        break;


    case WM_COMMAND:
        Item = LOWORD(wParam);

        switch (Item)
        {

        case IDC_CNSL_HISTORY_SIZE:
            if (pld && (HIWORD(wParam)==EN_UPDATE))
            {
                pld->cpd.lpConsole->uHistoryBufferSize =
                    GetDlgItemInt( hDlg, Item, NULL, FALSE );
                pld->cpd.bConDirty = TRUE;
                PropSheet_Changed( GetParent( hDlg ), hDlg );
            }
            break;

        case IDC_CNSL_HISTORY_NUM:
            if (pld && (HIWORD(wParam)==EN_UPDATE))
            {
                pld->cpd.lpConsole->uNumberOfHistoryBuffers =
                    GetDlgItemInt( hDlg, Item, NULL, FALSE );
                pld->cpd.bConDirty = TRUE;
                PropSheet_Changed( GetParent( hDlg ), hDlg );
            }
            break;

#ifdef i386
        case IDC_CNSL_WINDOWED:
        case IDC_CNSL_FULLSCREEN:
            CheckRadioButton(hDlg, IDC_CNSL_WINDOWED, IDC_CNSL_FULLSCREEN, Item);
            pld->cpd.lpConsole->bFullScreen = (Item == IDC_CNSL_FULLSCREEN);
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            return TRUE;
#endif
        case IDC_CNSL_LANGUAGELIST:
            switch (HIWORD(wParam)) {
            case CBN_KILLFOCUS: {
                HWND hWndLanguageCombo;
                LONG lListIndex;
                UINT  Value;

                hWndLanguageCombo = GetDlgItem(hDlg, IDC_CNSL_LANGUAGELIST);
                lListIndex = (LONG) SendMessage(hWndLanguageCombo, CB_GETCURSEL, 0, 0L);
                Value = (UINT) SendMessage(hWndLanguageCombo, CB_GETITEMDATA, lListIndex, 0L);
                if (Value != (UINT)-1) {
                    pld->cpd.fChangeCodePage = (Value != pld->cpd.lpFEConsole->uCodePage);
                    pld->cpd.lpFEConsole->uCodePage = Value;
                    PropSheet_Changed( GetParent( hDlg ), hDlg );
                }
                break;
            }

            default:
                break;
            }
            return TRUE;

        case IDC_CNSL_CURSOR_SMALL:
            pld->cpd.lpConsole->uCursorSize = 25;
            goto SetCursorSize;
        case IDC_CNSL_CURSOR_MEDIUM:
            pld->cpd.lpConsole->uCursorSize = 50;
            goto SetCursorSize;
        case IDC_CNSL_CURSOR_LARGE:
            pld->cpd.lpConsole->uCursorSize = 100;
SetCursorSize:
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            CheckRadioButton(hDlg, IDC_CNSL_CURSOR_SMALL, IDC_CNSL_CURSOR_LARGE, Item);
            return TRUE;

        case IDC_CNSL_HISTORY_NODUP:
            pld->cpd.lpConsole->bHistoryNoDup = IsDlgButtonChecked( hDlg, Item );
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            return TRUE;

        case IDC_CNSL_QUICKEDIT:
            pld->cpd.lpConsole->bQuickEdit = IsDlgButtonChecked( hDlg, Item );
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            return TRUE;

        case IDC_CNSL_INSERT:
            pld->cpd.lpConsole->bInsertMode = IsDlgButtonChecked( hDlg, Item );
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            return TRUE;

        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            if (FAILED(SaveLink(pld)))
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;

        case PSN_KILLACTIVE:
            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            if (0 != (Item = GetDlgCtrlID(GetFocus()))) {
                SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            }
            return TRUE;
        }
        break;


    default:
        break;
    }
    return FALSE;
}

BOOL
CheckBufferSize(
    HWND hDlg,
    UINT Item,
    LINKDATA *pld,
    INT i
    )
/*++

    Checks to make sure the buffer size is not smaller than the window size

    Returns: TRUE if preview window should be updated
             FALSE if not

--*/
{
    BOOL fRet = FALSE;

    if (!pld)
     return fRet;

    switch (Item)
    {

    case IDC_CNSL_SCRBUF_WIDTHSCROLL:
    case IDC_CNSL_SCRBUF_WIDTH:
        if (i >= 1)
        {
            pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;
            if (pld->cpd.lpConsole->dwWindowSize.X > i)
            {
                pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;
                SetDlgItemInt( hDlg,
                               IDC_CNSL_WINDOW_WIDTH,
                               pld->cpd.lpConsole->dwWindowSize.X,
                               TRUE
                              );

                fRet = TRUE;
            }

        }
        break;

    case IDC_CNSL_SCRBUF_HEIGHTSCROLL:
    case IDC_CNSL_SCRBUF_HEIGHT:
        if (i >= 1)
        {
            pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;
            if (pld->cpd.lpConsole->dwWindowSize.Y > i)
            {
                pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;
                SetDlgItemInt( hDlg,
                               IDC_CNSL_WINDOW_HEIGHT,
                               pld->cpd.lpConsole->dwWindowSize.Y,
                               TRUE
                              );
                fRet = TRUE;
            }
        }
        break;

    case IDC_CNSL_WINDOW_WIDTHSCROLL:
    case IDC_CNSL_WINDOW_WIDTH:
        if (i >= 1)
        {
            pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;
            if (pld->cpd.lpConsole->dwScreenBufferSize.X < i)
            {
                pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;
                SetDlgItemInt( hDlg,
                               IDC_CNSL_SCRBUF_WIDTH,
                               pld->cpd.lpConsole->dwScreenBufferSize.X,
                               TRUE
                              );
                fRet = TRUE;
            }

        }
        break;

    case IDC_CNSL_WINDOW_HEIGHTSCROLL:
    case IDC_CNSL_WINDOW_HEIGHT:
        if (i >= 1)
        {
            pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;
            if (pld->cpd.lpConsole->dwScreenBufferSize.Y < i)
            {
                pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;
                SetDlgItemInt( hDlg,
                               IDC_CNSL_SCRBUF_HEIGHT,
                               pld->cpd.lpConsole->dwScreenBufferSize.Y,
                               TRUE
                              );
                fRet = TRUE;
            }
        }

    }

    return fRet;

}

BOOL
IsValidSetting(
    HWND hDlg,
    UINT Item,
    LINKDATA *pld,
    INT i
    )
/*++

    Checks to make sure the proposed new value is valid for the console

    Returns: TRUE if it is valid
             FALSE if not

--*/
{

    BOOL fRet = TRUE;

    if (!pld)
        return FALSE;

    if (i>9999)
        i = -1;

    switch (Item)
    {

    case IDC_CNSL_WINDOW_HEIGHT:
        if (i <= 0)
        {
            SetDlgItemInt( hDlg,
                           Item,
                           pld->cpd.lpConsole->dwWindowSize.Y,
                           TRUE
                          );
            fRet = FALSE;
        }
        else
        {
            pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;
        }
        break;

    case IDC_CNSL_WINDOW_WIDTH:
        if (i <= 0)
        {
            SetDlgItemInt( hDlg,
                           Item,
                           pld->cpd.lpConsole->dwWindowSize.X,
                           TRUE
                          );
            fRet = FALSE;
        }
        else
        {
            pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;
        }
        break;

    case IDC_CNSL_SCRBUF_WIDTH:
        if (i <= 0)
        {
            SetDlgItemInt( hDlg,
                           Item,
                           pld->cpd.lpConsole->dwScreenBufferSize.X,
                           TRUE
                          );
            fRet = FALSE;
        }
        else
        {
            pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;
        }
        break;

    case IDC_CNSL_SCRBUF_HEIGHT:
        if (i <= 0)
        {
            SetDlgItemInt( hDlg,
                           Item,
                           pld->cpd.lpConsole->dwScreenBufferSize.Y,
                           TRUE
                          );
            fRet = FALSE;
        }
        else
        {
            pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;
        }
        break;
    }

    if (i <= 0)
    {
        SendDlgItemMessage( hDlg,
                            Item,
                            EM_SETSEL,
                            (WPARAM)(INT)4,
                            (WPARAM)(INT)4
                           );
    }

    return fRet;
}

BOOL_PTR
CALLBACK
_ScreenSizeDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the screen size dialog box.

--*/

{
    UINT Value;
    UINT Item;
    HWND hWnd;
    LONG xScreen;
    LONG yScreen;
    LONG cxScreen;
    LONG cyScreen;
    LONG cxFrame;
    LONG cyFrame;

    LINKDATA *pld = (LINKDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {

    case WM_INITDIALOG:
        pld = (LINKDATA *)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pld);
        SendDlgItemMessage(hDlg, IDC_CNSL_PREVIEWWINDOW, CM_PREVIEW_INIT, 0, (LPARAM)&pld->cpd );
        SendDlgItemMessage(hDlg, IDC_CNSL_PREVIEWWINDOW, CM_PREVIEW_UPDATE, 0, 0 );

        // Get some system parameters

        xScreen  = GetSystemMetrics(SM_XVIRTUALSCREEN);
        yScreen  = GetSystemMetrics(SM_YVIRTUALSCREEN);
        cxScreen = GetSystemMetrics(SM_CXVIRTUALSCREEN);
        cyScreen = GetSystemMetrics(SM_CYVIRTUALSCREEN);
        cxFrame  = GetSystemMetrics(SM_CXFRAME);
        cyFrame  = GetSystemMetrics(SM_CYFRAME);

        // initialize updown controls

        SendDlgItemMessage( hDlg, IDC_CNSL_SCRBUF_WIDTHSCROLL,  UDM_SETRANGE, 0, (LPARAM)MAKELONG( MAX_SCRBUF_WIDTH, 1 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_SCRBUF_HEIGHTSCROLL, UDM_SETRANGE, 0, (LPARAM)MAKELONG( MAX_SCRBUF_HEIGHT, 1 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_WIDTHSCROLL,  UDM_SETRANGE, 0, (LPARAM)MAKELONG( 9999, 1 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_HEIGHTSCROLL, UDM_SETRANGE, 0, (LPARAM)MAKELONG( 9999, 1 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_POSXSCROLL,   UDM_SETRANGE, 0, (LPARAM)MAKELONG( xScreen + cxScreen - cxFrame, xScreen - cxFrame ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_POSYSCROLL,   UDM_SETRANGE, 0, (LPARAM)MAKELONG( yScreen + cyScreen - cyFrame, yScreen - cyFrame ) );

        //
        // put current values in dialog box
        //

        SendDlgItemMessage( hDlg, IDC_CNSL_SCRBUF_WIDTHSCROLL,  UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->dwScreenBufferSize.X, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_SCRBUF_HEIGHTSCROLL, UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->dwScreenBufferSize.Y, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_WIDTHSCROLL,  UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->dwWindowSize.X, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_HEIGHTSCROLL, UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->dwWindowSize.Y, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_POSXSCROLL,   UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->dwWindowOrigin.X, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_POSYSCROLL,   UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->dwWindowOrigin.Y, 0 ) );

        CheckDlgButton(hDlg, IDC_CNSL_AUTO_POSITION, pld->cpd.lpConsole->bAutoPosition);
        SendMessage(hDlg, WM_COMMAND, IDC_CNSL_AUTO_POSITION, 0);

        return TRUE;

    case WM_DESTROY:
        EndDialog( hDlg, TRUE );
        break;

    //
    // handle help messages
    //
    case WM_HELP:               /* F1 or title-bar help button */
        WinHelp( (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                 NULL,
                 HELP_WM_HELP,
                 (ULONG_PTR) (LPVOID) &rgdwHelpSize[0]
                );
        break;

    case WM_CONTEXTMENU:        /* right mouse click */
        WinHelp( (HWND) wParam,
                 NULL,
                 HELP_CONTEXTMENU,
                 (ULONG_PTR) (LPVOID) &rgdwHelpSize[0]
                );
        break;


    case WM_COMMAND:
        Item = LOWORD(wParam);

        if (Item==IDC_CNSL_AUTO_POSITION)
        {
            pld->cpd.lpConsole->bAutoPosition = IsDlgButtonChecked( hDlg, Item );
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            Value = IsDlgButtonChecked(hDlg, IDC_CNSL_AUTO_POSITION);
            for (Item = IDC_CNSL_WINDOW_POSX; Item < IDC_CNSL_AUTO_POSITION; Item++) {
                hWnd = GetDlgItem(hDlg, Item);
                EnableWindow(hWnd, (Value == FALSE));
            }
        }

        //
        // Make sure that we don't have a buffer size smaller than a window size
        //
        if (pld && (HIWORD(wParam)==EN_KILLFOCUS))
        {
            INT i;

            i = GetDlgItemInt( hDlg, Item, NULL, FALSE );
            if (CheckBufferSize( hDlg, Item, pld, i ))
                goto UpdatePrevWindow;

        }

        //
        // Verify that what is typed is a valid quantity...
        //
        if (pld && (HIWORD(wParam)==EN_UPDATE))
        {
            INT i;

            i = GetDlgItemInt( hDlg, Item, NULL, FALSE );
            IsValidSetting( hDlg, Item, pld, i );

            switch( Item )
            {

            case IDC_CNSL_WINDOW_POSX:
                pld->cpd.lpConsole->dwWindowOrigin.X = (SHORT)
                    GetDlgItemInt( hDlg, Item, NULL, TRUE );
                break;

            case IDC_CNSL_WINDOW_POSY:
                pld->cpd.lpConsole->dwWindowOrigin.Y = (SHORT)
                    GetDlgItemInt( hDlg, Item, NULL, TRUE );
                break;

            }

UpdatePrevWindow:

            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            SendDlgItemMessage(hDlg, IDC_CNSL_PREVIEWWINDOW, CM_PREVIEW_UPDATE, 0, 0 );

        }

        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case UDN_DELTAPOS:
        {
            NM_UPDOWN * lpud = (NM_UPDOWN *)lParam;
            INT i;

            i = lpud->iPos + lpud->iDelta;

            // Check for bad ranges
            if ((i > 9999) || (i < 1))
                return TRUE;

            // check restrictions and alter values accordingly.  (Buffer size
            // can never be smaller than window size!)
            CheckBufferSize( hDlg, (UINT)wParam, pld, i);

            // highlight the changed entry
            SendDlgItemMessage( hDlg,
                                (UINT)wParam,
                                EM_SETSEL,
                                (WPARAM)(INT)4,
                                (WPARAM)(INT)4
                               );

            // Update the preview window
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            SendDlgItemMessage(hDlg, IDC_CNSL_PREVIEWWINDOW, CM_PREVIEW_UPDATE, 0, 0 );
        }
        break;

        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            if (FAILED(SaveLink(pld)))
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;

//        case PSN_HELP:
//            //WinHelp(hDlg, szHelpFileName, HELP_CONTEXT, DID_SCRBUFSIZE);
//            return TRUE;

        case PSN_KILLACTIVE:
            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            if (0 != (Item = GetDlgCtrlID(GetFocus()))) {
                SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            }
            return TRUE;
        }
        break;

    default:
        break;
    }
    return FALSE;
}

void *_CopyDataBlock(IShellLink *psl, DWORD dwSig)
{
    void *pv = NULL;
    IShellLinkDataList *psld;
    if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IShellLinkDataList, (void **)&psld)))
    {
        psld->lpVtbl->CopyDataBlock(psld, dwSig, &pv);
        psld->lpVtbl->Release(psld);
    }
    return (void *)pv;
}

void _RemoveDataBlock(IShellLink *psl, DWORD dwSig)
{
    IShellLinkDataList *psld;
    if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IShellLinkDataList, (void **)&psld)))
    {
        psld->lpVtbl->RemoveDataBlock(psld, dwSig);
        psld->lpVtbl->Release(psld);
    }
}

void _AddDataBlock(IShellLink *psl, void *pv)
{
    IShellLinkDataList *psld;
    if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IShellLinkDataList, (void **)&psld)))
    {
        psld->lpVtbl->AddDataBlock(psld, pv);
        psld->lpVtbl->Release(psld);
    }
}


STDAPI_(void) LinkConsolePagesSave( LINKDATA *pld )
{
    // First, remove the console settings section if it exists
    _RemoveDataBlock(pld->cpd.psl, NT_CONSOLE_PROPS_SIG);
    _RemoveDataBlock(pld->cpd.psl, NT_FE_CONSOLE_PROPS_SIG);

#ifndef UNICODE
    // if we're the ANSI shell, we need to convert FACENAME
    // over to UNICODE before saving...
    {
        WCHAR wszFaceName[LF_FACESIZE];

        MultiByteToWideChar( CP_ACP, 0,
                         pld->cpd.lpFaceName, LF_FACESIZE,
                         wszFaceName, LF_FACESIZE
                        );
        hmemcpy(pld->cpd.lpConsole->FaceName, wszFaceName, LF_FACESIZE*SIZEOF(WCHAR));
    }

#endif
    //
    // Now, add back the new console settings
    _AddDataBlock(pld->cpd.psl, pld->cpd.lpConsole);

    //
    // Now, update registry settings for this title...
    SetRegistryValues( &pld->cpd );

    if (IsFarEastCP(pld->cpd.uOEMCP))
    {
        // Same for FarEast console settings
        //
        _AddDataBlock(pld->cpd.psl, pld->cpd.lpFEConsole);

        SetFERegistryValues( &pld->cpd );
    }
    // And, mark the console data as current
    pld->cpd.bConDirty = FALSE;
}

#define PEMAGIC         ((WORD)'P'+((WORD)'E'<<8))

STDAPI_(void) AddLinkConsolePages(LINKDATA *pld, IShellLink * psl, LPCTSTR pszFile, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    HPROPSHEETPAGE hpage;
    PROPSHEETPAGE psp;
    HRESULT hres;
    TCHAR szTarget[ MAX_PATH ];
    TCHAR szBuffer[ MAX_PATH ];
    WNDCLASS wc;
    IPersistFile *ppf;


    // do this here so we don't slow down the loading
    // of other pages

    if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf)))
    {
        WCHAR wszPath[ MAX_PATH ];

        SHTCharToUnicode(pszFile, wszPath, ARRAYSIZE(wszPath));
        hres = ppf->lpVtbl->Load(ppf, wszPath, 0);
        ppf->lpVtbl->Release(ppf);
    }

    // Get the target of the link
    hres = psl->lpVtbl->GetPath(psl, szBuffer, ARRAYSIZE(szBuffer), NULL, 0);
    pld->cpd.psl = psl;

    if (FAILED(hres) || hres == S_FALSE)
        goto Exit;

    // Remove args first, to:
    // (1) shorten our string, avoiding ExpandEnvironmentStrings overflowing the buffer
    // (2) increase liklihood that PathRemoveArgs won't get confused by spaces in "Program Files" etc
    PathRemoveArgs(szTarget);

    // expand the target
    if (!SHExpandEnvironmentStrings(szBuffer, szTarget, ARRAYSIZE(szTarget)))
        goto Exit;

    // Check what kind of app target is LOWORD==PEMAGIC, HIWORD==0
    if (GetExeType( szTarget )!=PEMAGIC)
        goto Exit;

    // It's a WIN32 console mode app, let's put up our property sheet

    wc.lpszClassName = TEXT("WOACnslWinPreview");
    wc.hInstance     = HINST_THISDLL;
    wc.lpfnWndProc   = PreviewWndProc;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
    wc.style         = 0L;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 2 * sizeof(PVOID);   // (two pointers)
    if (!RegisterClass(&wc))
        if (GetLastError()!=ERROR_CLASS_ALREADY_EXISTS)
            goto Exit;


    wc.lpszClassName = TEXT("WOACnslFontPreview");
    wc.hInstance     = HINST_THISDLL;
    wc.lpfnWndProc   = _FontPreviewWndProc;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.hbrBackground = GetStockObject(BLACK_BRUSH);
    wc.style         = 0L;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PVOID);       // (one pointer)
    if (!RegisterClass(&wc))
        if (GetLastError()!=ERROR_CLASS_ALREADY_EXISTS)
            goto Exit;

    wc.lpszClassName = TEXT("cpColor");
    wc.hInstance     = HINST_THISDLL;
    wc.lpfnWndProc   = ColorControlProc;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wc.style         = 0L;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PVOID);       // (one pointer)
    if (!RegisterClass(&wc))
        if (GetLastError()!=ERROR_CLASS_ALREADY_EXISTS)
            goto Exit;

    wc.lpszClassName = TEXT("cpShowColor");
    wc.hInstance     = HINST_THISDLL;
    wc.lpfnWndProc   = ColorTextProc;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wc.style         = 0L;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PVOID);       // (one pointer)
    if (!RegisterClass(&wc))
        if (GetLastError()!=ERROR_CLASS_ALREADY_EXISTS)
            goto Exit;

    // Needs TTFontList for all platform.
    if (!NT_SUCCESS( InitializeDbcsMisc(&pld->cpd) ))
        goto Exit;

    GetTitleFromLinkName( (LPTSTR)pszFile, (LPTSTR)pld->cpd.ConsoleTitle );

    // Check if Far East settings exist...
    
    if ((pld->cpd.lpFEConsole = (LPNT_FE_CONSOLE_PROPS)_CopyDataBlock(psl, NT_FE_CONSOLE_PROPS_SIG))==NULL)
    {
        pld->cpd.lpFEConsole = (LPNT_FE_CONSOLE_PROPS)LocalAlloc( LPTR, SIZEOF(NT_FE_CONSOLE_PROPS) );
        if (pld->cpd.lpFEConsole) 
        {
            // Initialize Far East Console settings
            pld->cpd.lpFEConsole->cbSize = SIZEOF( NT_FE_CONSOLE_PROPS );
            pld->cpd.lpFEConsole->dwSignature = NT_FE_CONSOLE_PROPS_SIG;
            if (IsFarEastCP(pld->cpd.uOEMCP))
            {
                InitFERegistryValues( &pld->cpd );
                GetFERegistryValues( &pld->cpd );
            }
        }
    }

    if (!pld->cpd.lpFEConsole)
        goto Exit;
    
    // Get standard settings from link if they exist...
    if ((pld->cpd.lpConsole = (LPNT_CONSOLE_PROPS)_CopyDataBlock(psl, NT_CONSOLE_PROPS_SIG ))==NULL)
    {
        pld->cpd.lpConsole = (LPNT_CONSOLE_PROPS)LocalAlloc(LPTR, SIZEOF(NT_CONSOLE_PROPS) );
        if (pld->cpd.lpConsole)
        {
            // Initialize console settings
            pld->cpd.lpConsole->cbSize = SIZEOF( NT_CONSOLE_PROPS );
            pld->cpd.lpConsole->dwSignature = NT_CONSOLE_PROPS_SIG;
            InitRegistryValues( &pld->cpd );
            GetRegistryValues( &pld->cpd );
        }
        else
        {
            // if the above alloc failes, we fault dereferencing lpConsole...
            ASSERT(FALSE);
        }

    }
#ifndef UNICODE
    else
    {
        // we read the properties off of disk -- so need to convert the
        // UNICODE string to ANSI

        WCHAR wszFaceName[LF_FACESIZE];

        hmemcpy(wszFaceName,pld->cpd.lpConsole->FaceName,LF_FACESIZE*SIZEOF(WCHAR));

        WideCharToMultiByte( CP_ACP, 0,
                             wszFaceName, LF_FACESIZE,
                             pld->cpd.szFaceName, LF_FACESIZE,
                             NULL, NULL
                            );
    }
#endif

    if (!pld->cpd.lpConsole)
        goto Exit;

    // set facename pointer to correct place
#ifdef UNICODE
    pld->cpd.lpFaceName = (LPTSTR)pld->cpd.lpConsole->FaceName;
#else
    pld->cpd.lpFaceName = (LPTSTR)pld->cpd.szFaceName;
#endif

    //
    // Initialize the font cache and current font index
    //

    if (STATUS_SUCCESS != InitializeFonts( &pld->cpd ))
    {
        goto Exit;
    }
    pld->cpd.CurrentFontIndex = FindCreateFont( &pld->cpd,
                                                pld->cpd.lpConsole->uFontFamily,
                                                pld->cpd.lpFaceName,
                                                pld->cpd.lpConsole->dwFontSize,
                                                pld->cpd.lpConsole->uFontWeight);

    // Mark the console data as current
    pld->cpd.bConDirty = FALSE;

    // add console settings property sheet
    psp.dwSize      = SIZEOF( psp );
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = HINST_THISDLL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CONSOLE_SETTINGS);
    psp.pfnDlgProc  = _ConsoleSettingsDlgProc;
    psp.lParam      = (LPARAM)pld;

    hpage = CreatePropertySheetPage( &psp );
    if (hpage)
    {
        if (!pfnAddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            goto Exit;
        }
    }
    else
    {
        if (pld->cpd.lpConsole)
        {
            LocalFree( pld->cpd.lpConsole );
            pld->cpd.lpConsole = NULL;
        }
        if (pld->cpd.lpFEConsole)
        {
            LocalFree( pld->cpd.lpFEConsole );
            pld->cpd.lpFEConsole = NULL;
        }
        goto Exit;
    }

    // add font selection property sheet
    psp.dwSize      = SIZEOF( psp );
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = HINST_THISDLL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CONSOLE_FONTDLG);
    psp.pfnDlgProc  = _FontDlgProc;
    psp.lParam      = (LPARAM)pld;

    hpage = CreatePropertySheetPage( &psp );
    if (hpage)
    {
        if (!pfnAddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            goto Exit;
        }
    }
    else
    {
        if (pld->cpd.lpConsole)
        {
            LocalFree( pld->cpd.lpConsole );
            pld->cpd.lpConsole = NULL;
        }
        if (pld->cpd.lpFEConsole)
        {
            LocalFree( pld->cpd.lpFEConsole );
            pld->cpd.lpFEConsole = NULL;
        }
        goto Exit;
    }

    // add console size propery sheet
    psp.dwSize      = SIZEOF( psp );
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = HINST_THISDLL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CONSOLE_SCRBUFSIZE);
    psp.pfnDlgProc  = _ScreenSizeDlgProc;
    psp.lParam      = (LPARAM)pld;

    hpage = CreatePropertySheetPage( &psp );
    if (hpage)
    {
        if (!pfnAddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            goto Exit;
        }
    }
    else
    {
        if (pld->cpd.lpConsole)
        {
            LocalFree( pld->cpd.lpConsole );
            pld->cpd.lpConsole = NULL;
        }
        goto Exit;
    }

    // add console color propery sheet
    psp.dwSize      = SIZEOF( psp );
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = HINST_THISDLL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CONSOLE_COLOR);
    psp.pfnDlgProc  = _ColorDlgProc;
    psp.lParam      = (LPARAM)pld;

    hpage = CreatePropertySheetPage( &psp );
    if (hpage)
    {
        if (!pfnAddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            goto Exit;
        }
    }
    else
    {
        if (pld->cpd.lpConsole)
        {
            LocalFree( pld->cpd.lpConsole );
            pld->cpd.lpConsole = NULL;
        }
        if (pld->cpd.lpFEConsole)
        {
            LocalFree( pld->cpd.lpFEConsole );
            pld->cpd.lpFEConsole = NULL;
        }
        goto Exit;
    }

#ifdef ADVANCED_PAGE
    // add "advanced" settings propery sheet
    psp.dwSize      = SIZEOF( psp );
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = HINST_THISDLL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CONSOLE_ADVANCED);
    psp.pfnDlgProc  = _AdvancedDlgProc;
    psp.lParam      = (LPARAM)pld;

    hpage = CreatePropertySheetPage( &psp );
    if (hpage)
    {
        if (!pfnAddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            goto Exit;
        }
    }
    else
    {
        if (pld->cpd.lpConsole)
        {
            LocalFree( pld->cpd.lpConsole );
            pld->cpd.lpConsole = NULL;
        }
        if (pld->cpd.lpFEConsole)
        {
            LocalFree( pld->cpd.lpFEConsole );
            pld->cpd.lpFEConsole = NULL;
        }
        goto Exit;
    }
#endif


Exit:
    ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\lnkfnt.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fontdlg.dlg

Abstract:

    This module contains the code for console font dialog

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

#include "shellprv.h"
#pragma hdrstop

#include "lnkcon.h"

HBITMAP g_hbmTT = NULL; // handle of TT logo bitmap
BITMAP  g_bmTT;          // attributes of TT source bitmap
int g_dyFacelistItem = 0;


/* ----- Prototypes ----- */

int FontListCreate(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    LPTSTR ptszTTFace,
    BOOL bNewFaceList
    );

BOOL ConsolePreviewUpdate(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    BOOL bLB
    );

int SelectCurrentSize(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    BOOL bLB,
    int FontIndex);

BOOL ConsolePreviewInit(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    BOOL* pfRaster);

VOID ConsoleDrawItemFontList(
    CONSOLEPROP_DATA * pcpd,
    const LPDRAWITEMSTRUCT lpdis);

/* ----- Globals ----- */

const TCHAR g_szPreviewText[] = \
    TEXT("C:\\WINDOWS> dir                       \n") \
    TEXT("SYSTEM       <DIR>     10-01-99   5:00a\n") \
    TEXT("SYSTEM32     <DIR>     10-01-99   5:00a\n") \
    TEXT("README   TXT     26926 10-01-99   5:00a\n") \
    TEXT("WINDOWS  BMP     46080 10-01-99   5:00a\n") \
    TEXT("NOTEPAD  EXE    337232 10-01-99   5:00a\n") \
    TEXT("CLOCK    AVI     39594 10-01-99   5:00p\n") \
    TEXT("WIN      INI      7005 10-01-99   5:00a\n");

// Context-sensitive help ids

const static DWORD rgdwHelpFont[] = {
    IDC_CNSL_PREVIEWLABEL,  IDH_DOS_FONT_WINDOW_PREVIEW,
    IDC_CNSL_PREVIEWWINDOW, IDH_DOS_FONT_WINDOW_PREVIEW,
    IDC_CNSL_STATIC,        IDH_CONSOLE_FONT_FONT,
    IDC_CNSL_FACENAME,      IDH_CONSOLE_FONT_FONT,
    IDC_CNSL_FONTSIZE,      IDH_DOS_FONT_SIZE,
    IDC_CNSL_PIXELSLIST,    IDH_DOS_FONT_SIZE,
    IDC_CNSL_POINTSLIST,    IDH_DOS_FONT_SIZE,
    IDC_CNSL_BOLDFONT,      IDH_CONSOLE_FONT_BOLD_FONTS,
    IDC_CNSL_GROUP,         IDH_DOS_FONT_FONT_PREVIEW,
    IDC_CNSL_STATIC2,       IDH_DOS_FONT_FONT_PREVIEW,
    IDC_CNSL_STATIC3,       IDH_DOS_FONT_FONT_PREVIEW,
    IDC_CNSL_STATIC4,       IDH_DOS_FONT_FONT_PREVIEW,
    IDC_CNSL_FONTWIDTH,     IDH_DOS_FONT_FONT_PREVIEW,
    IDC_CNSL_FONTHEIGHT,    IDH_DOS_FONT_FONT_PREVIEW,
    IDC_CNSL_FONTWINDOW,    IDH_DOS_FONT_FONT_PREVIEW,
    0, 0
};

// selelct font based on the current code page
BOOL
SelectCurrentFont(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    int FontIndex
    );

// Globals strings loaded from resource
TCHAR tszSelectedFont[CCH_SELECTEDFONT+1];
TCHAR tszRasterFonts[CCH_RASTERFONTS+1];


BOOL
CALLBACK
_FontDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the font selection dialog box.
    Returns the near offset into the far table of LOGFONT structures.

--*/

{
    HWND hWndFocus;
    HWND hWndList;
    int FontIndex;
    BOOL bLB;
    TEXTMETRIC tm;
    HDC hDC;
    LINKDATA * pld = (LINKDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {
    case WM_INITDIALOG:
        pld = (LINKDATA *)((PROPSHEETPAGE *)lParam)->lParam;

        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pld);
        pld->cpd.bFontInit = FALSE;

        SendDlgItemMessage(hDlg, IDC_CNSL_PREVIEWWINDOW, CM_PREVIEW_INIT, 0, (LPARAM)&pld->cpd );
        SendDlgItemMessage(hDlg, IDC_CNSL_PREVIEWWINDOW, CM_PREVIEW_UPDATE, 0, 0 );

        /*
         * Load the font description strings
         */
        LoadString(HINST_THISDLL, IDS_CNSL_RASTERFONT,
                   tszRasterFonts, NELEM(tszRasterFonts));
        ASSERT(lstrlen(tszRasterFonts) < CCH_RASTERFONTS);

        LoadString(g_hinst, IDS_CNSL_SELECTEDFONT,
                   tszSelectedFont, NELEM(tszSelectedFont));
        ASSERT(lstrlen(tszSelectedFont) < CCH_SELECTEDFONT);

        /* Save current font size as dialog window's user data */
        if (IsFarEastCP(pld->cpd.uOEMCP))
        {
            // Assigning different value when we run on FarEast codepage
            pld->cpd.FontLong =
                      MAKELONG(pld->cpd.FontInfo[pld->cpd.CurrentFontIndex].tmCharSet,
                               pld->cpd.FontInfo[pld->cpd.CurrentFontIndex].Size.Y);
        }
        else
        {
            pld->cpd.FontLong =
                      MAKELONG(pld->cpd.FontInfo[pld->cpd.CurrentFontIndex].Size.X,
                               pld->cpd.FontInfo[pld->cpd.CurrentFontIndex].Size.Y);
        }

        /* Create the list of suitable fonts */
        pld->cpd.gbEnumerateFaces = TRUE;
        bLB = !TM_IS_TT_FONT(pld->cpd.lpConsole->uFontFamily);
        pld->cpd.gbBold = IS_BOLD(pld->cpd.lpConsole->uFontWeight);
        CheckDlgButton(hDlg, IDC_CNSL_BOLDFONT, pld->cpd.gbBold);
        FontListCreate(&pld->cpd, hDlg, bLB ? NULL : pld->cpd.lpFaceName, TRUE);

        /* Initialize the preview window - selects current face & size too */
        if (ConsolePreviewInit(&pld->cpd, hDlg, &bLB))
        {
            ConsolePreviewUpdate(&pld->cpd, hDlg, bLB);

            /* Make sure the list box has the focus */
            hWndList = GetDlgItem(hDlg, bLB ? IDC_CNSL_PIXELSLIST : IDC_CNSL_POINTSLIST);
            SetFocus(hWndList);
            pld->cpd.bFontInit = TRUE;
        }
        else
        {
            EndDialog(hDlg, IDCANCEL);
        }
        break;

    case WM_FONTCHANGE:
        pld->cpd.gbEnumerateFaces = TRUE;
        bLB = !TM_IS_TT_FONT(pld->cpd.lpConsole->uFontFamily);
        FontListCreate(&pld->cpd, hDlg, NULL, TRUE);
        FontIndex = FindCreateFont(&pld->cpd,
                                   pld->cpd.lpConsole->uFontFamily,
                                   pld->cpd.lpFaceName,
                                   pld->cpd.lpConsole->dwFontSize,
                                   pld->cpd.lpConsole->uFontWeight);
        SelectCurrentSize(&pld->cpd, hDlg, bLB, FontIndex);
        return TRUE;

    case WM_PAINT:
        // fChangeCodePage can be TRUE only on FE codepage
        if (pld->cpd.fChangeCodePage)
        {
            pld->cpd.fChangeCodePage = FALSE;

            /* Create the list of suitable fonts */
            bLB = !TM_IS_TT_FONT(pld->cpd.lpConsole->uFontFamily);
            FontIndex = FontListCreate(&pld->cpd, hDlg, !bLB ? NULL : pld->cpd.lpFaceName, TRUE);
            FontIndex = FontListCreate(&pld->cpd, hDlg, bLB ? NULL : pld->cpd.lpFaceName, TRUE);
            pld->cpd.CurrentFontIndex = FontIndex;

            FontIndex = SelectCurrentSize(&pld->cpd, hDlg, bLB, FontIndex);
            SelectCurrentFont(&pld->cpd, hDlg, FontIndex);

            ConsolePreviewUpdate(&pld->cpd, hDlg, bLB);
        }
        break;

    case WM_HELP:               /* F1 or title-bar help button */
        WinHelp( (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                 NULL,
                 HELP_WM_HELP,
                 (ULONG_PTR) (LPVOID) &rgdwHelpFont[0]
                );
        break;

    case WM_CONTEXTMENU:        /* right mouse click */
        WinHelp( (HWND) wParam,
                 NULL,
                 HELP_CONTEXTMENU,
                 (ULONG_PTR) (LPTSTR) &rgdwHelpFont[0]
                );
        break;


    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CNSL_BOLDFONT:
            pld->cpd.gbBold = IsDlgButtonChecked(hDlg, IDC_CNSL_BOLDFONT);
            pld->cpd.bConDirty = TRUE;
            goto RedoFontListAndPreview;

        case IDC_CNSL_FACENAME:
            switch (HIWORD(wParam))
            {
            case LBN_SELCHANGE:
RedoFontListAndPreview:
                if (pld->cpd.bFontInit)
                    PropSheet_Changed( GetParent( hDlg ), hDlg );
                {
                    TCHAR atchNewFace[LF_FACESIZE];
                    LRESULT l;

                    l = SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_GETCURSEL, 0, 0L);
                    bLB = (BOOL) SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_GETITEMDATA, l, 0L);
                    if (!bLB) {
                        SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_GETTEXT, l, (LPARAM)atchNewFace);
                    }
                    FontIndex = FontListCreate(&pld->cpd, hDlg, bLB ? NULL : atchNewFace, FALSE);
                    FontIndex = SelectCurrentSize(&pld->cpd, hDlg, bLB, FontIndex);
                    ConsolePreviewUpdate(&pld->cpd, hDlg, bLB);
                    pld->cpd.bConDirty = TRUE;
                    return TRUE;
                }
            }
            break;

        case IDC_CNSL_POINTSLIST:
            switch (HIWORD(wParam)) {
            case CBN_SELCHANGE:
                if (pld->cpd.bFontInit)
                    PropSheet_Changed( GetParent( hDlg ), hDlg );
                ConsolePreviewUpdate(&pld->cpd, hDlg, FALSE);
                pld->cpd.bConDirty = TRUE;
                return TRUE;

            case CBN_KILLFOCUS:
                if (!pld->cpd.gbPointSizeError) {
                    hWndFocus = GetFocus();
                    if (hWndFocus != NULL && IsChild(hDlg, hWndFocus) &&
                        hWndFocus != GetDlgItem(hDlg, IDCANCEL)) {
                        ConsolePreviewUpdate(&pld->cpd, hDlg, FALSE);
                    }
                }
                return TRUE;

            default:
                break;
            }
            break;

        case IDC_CNSL_PIXELSLIST:
            switch (HIWORD(wParam)) {
            case LBN_SELCHANGE:
                if (pld->cpd.bFontInit)
                    PropSheet_Changed( GetParent( hDlg ), hDlg );
                ConsolePreviewUpdate(&pld->cpd, hDlg, TRUE);
                pld->cpd.bConDirty = TRUE;
                return TRUE;

            default:
                break;
            }
            break;

        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) 
        {

        case PSN_APPLY:
            // Write out the state values and exit.
            if (FAILED(SaveLink(pld)))
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;

        case PSN_KILLACTIVE:
            //
            // If the TT combo box is visible, update selection
            //
            hWndList = GetDlgItem(hDlg, IDC_CNSL_POINTSLIST);
            if (hWndList != NULL && IsWindowVisible(hWndList)) {
                if (!ConsolePreviewUpdate(&pld->cpd, hDlg, FALSE)) {
                    SetDlgMsgResult(hDlg, PSN_KILLACTIVE, TRUE);
                    return TRUE;
                }
                SetDlgMsgResult(hDlg, PSN_KILLACTIVE, FALSE);
            }

            FontIndex = pld->cpd.CurrentFontIndex;

            if (pld->cpd.FontInfo[FontIndex].SizeWant.Y == 0) {
                // Raster Font, so save actual size
                pld->cpd.lpConsole->dwFontSize = pld->cpd.FontInfo[FontIndex].Size;
            } else {
                // TT Font, so save desired size
                pld->cpd.lpConsole->dwFontSize = pld->cpd.FontInfo[FontIndex].SizeWant;
            }

            pld->cpd.lpConsole->uFontWeight = pld->cpd.FontInfo[FontIndex].Weight;
            pld->cpd.lpConsole->uFontFamily = pld->cpd.FontInfo[FontIndex].Family;
            lstrcpy(pld->cpd.lpFaceName, pld->cpd.FontInfo[FontIndex].FaceName);

            return TRUE;

        }
        break;

    /*
     *  For WM_MEASUREITEM and WM_DRAWITEM, since there is only one
     *  owner-draw item (combobox) in the entire dialog box, we don't have
     *  to do a GetDlgItem to figure out who he is.
     */
    case WM_MEASUREITEM:
        /*
         * Load the TrueType logo bitmap
         */
        if (g_hbmTT == NULL)
        {
            g_hbmTT = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_TRUETYPE));
            if (g_hbmTT)
            {
                if (!GetObject(g_hbmTT, sizeof(BITMAP), &g_bmTT))
                {
                    DeleteObject(g_hbmTT);
                    g_hbmTT = NULL;
                }
            }
        }

        /*
         * Compute the height of face name listbox entries
         */
        if (g_dyFacelistItem == 0) {
            HFONT hFont;
            hDC = GetDC(hDlg);
            if (hDC)
            {
                hFont = GetWindowFont(hDlg);
                if (hFont) {
                    hFont = SelectObject(hDC, hFont);
                }
                GetTextMetrics(hDC, &tm);
                if (hFont) {
                    SelectObject(hDC, hFont);
                }
                ReleaseDC(hDlg, hDC);

                g_dyFacelistItem = max(tm.tmHeight, g_bmTT.bmHeight);
            }
            else
            {
                // We just failed GetDC: Low memory - we might look corrupted here, but its
                // better than using a null DC or bad textmetrics structure. Prefix 98166
                g_dyFacelistItem = g_bmTT.bmHeight;
            }
        }
        ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = g_dyFacelistItem;
        return TRUE;

    case WM_DRAWITEM:
        ConsoleDrawItemFontList(&pld->cpd, (LPDRAWITEMSTRUCT)lParam);
        return TRUE;

    case WM_DESTROY:

        /*
         * Delete the TrueType logo bitmap
         */
        if (g_hbmTT != NULL) {
            DeleteObject(g_hbmTT);
            g_hbmTT = NULL;
        }
        return TRUE;

    default:
        break;
    }
    return FALSE;
}


int
FontListCreate(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    LPTSTR ptszTTFace,
    BOOL bNewFaceList
    )

/*++

    Initializes the font list by enumerating all fonts and picking the
    proper ones for our list.

    Returns
        FontIndex of selected font (LB_ERR if none)
--*/

{
    TCHAR tszText[80];
    LONG lListIndex;
    ULONG i;
    HWND hWndShow;      // List or Combo box
    HWND hWndHide;    // Combo or List box
    HWND hWndFaceCombo;
    BOOL bLB;
    int LastShowX = 0;
    int LastShowY = 0;
    int nSameSize = 0;
    UINT CodePage = pcpd->lpFEConsole->uCodePage;
    BOOL fDbcsCharSet = IS_ANY_DBCS_CHARSET( CodePageToCharSet( CodePage ) );
    BOOL fFESystem = IsFarEastCP(pcpd->uOEMCP);
    BOOL fFindTTFont = FALSE;
    LPTSTR ptszAltTTFace = NULL;
    DWORD dwExStyle = 0L;
    bLB = ((ptszTTFace == NULL) || (ptszTTFace[0] == TEXT('\0')));
    if (! bLB) {
        if (IsAvailableTTFont(pcpd, ptszTTFace)) {
            ptszAltTTFace = GetAltFaceName(pcpd, ptszTTFace);
        }
        else {
            ptszAltTTFace = ptszTTFace;
        }
    }

    /*
     * This only enumerates face names if necessary, and
     * it only enumerates font sizes if necessary
     */
    if (STATUS_SUCCESS != EnumerateFonts(pcpd, bLB ? EF_OEMFONT : EF_TTFONT))
    {
        return LB_ERR;
    }

    /* init the TTFaceNames */


    if (bNewFaceList) {
        FACENODE *panFace;
        hWndFaceCombo = GetDlgItem(hDlg, IDC_CNSL_FACENAME);

        SendMessage(hWndFaceCombo, LB_RESETCONTENT, 0, 0);

        lListIndex = (LONG) SendMessage(hWndFaceCombo, LB_ADDSTRING, 0, (LPARAM)tszRasterFonts);
        SendMessage(hWndFaceCombo, LB_SETITEMDATA, lListIndex, TRUE);
        for (panFace = pcpd->gpFaceNames; panFace; panFace = panFace->pNext) {
            if ((panFace->dwFlag & (EF_TTFONT|EF_NEW)) != (EF_TTFONT|EF_NEW)) {
                continue;
            }
            if (!fDbcsCharSet && (panFace->dwFlag & EF_DBCSFONT)) {
                continue;
            }

            if ( ( fDbcsCharSet && IsAvailableTTFontCP(pcpd, panFace->atch, CodePage)) ||
                 ( !fDbcsCharSet && IsAvailableTTFontCP(pcpd, panFace->atch, 0)))
            {

                if ( !bLB &&
                     (lstrcmp(ptszTTFace, panFace->atch) == 0 ||
                      lstrcmp(ptszAltTTFace, panFace->atch) == 0)
                   )
                    fFindTTFont = TRUE;

                lListIndex = (LONG) SendMessage(hWndFaceCombo, LB_ADDSTRING, 0,
                                        (LPARAM)panFace->atch);
                SendMessage(hWndFaceCombo, LB_SETITEMDATA, lListIndex, FALSE);
            }
        }

        if (! bLB && ! fFindTTFont)
        {
            for (panFace = pcpd->gpFaceNames; panFace; panFace = panFace->pNext) {
                if ((panFace->dwFlag & (EF_TTFONT|EF_NEW)) != (EF_TTFONT|EF_NEW)) {
                    continue;
                }
                if ( !fDbcsCharSet && (panFace->dwFlag & EF_DBCSFONT)) {
                    continue;
                }

                if ( (  fDbcsCharSet && IsAvailableTTFontCP(pcpd, panFace->atch, CodePage)) ||
                     (! fDbcsCharSet && IsAvailableTTFontCP(pcpd, panFace->atch, 0))
                   )
                {

                    if (lstrcmp(ptszTTFace, panFace->atch) != 0)
                    {
                        lstrcpy(ptszTTFace, panFace->atch);
                        break;
                    }
                }
            }
        }
    } // bNewFaceList == TRUE

    hWndShow = GetDlgItem(hDlg, IDC_CNSL_BOLDFONT);

    // Disable bold font if that will be GDI simulated
    if ( fDbcsCharSet && IsDisableBoldTTFont(pcpd, ptszTTFace) )
    {
        EnableWindow(hWndShow, FALSE);
        pcpd->gbBold = FALSE;
        CheckDlgButton(hDlg, IDC_CNSL_BOLDFONT, FALSE);
    }
    else
    {
        CheckDlgButton(hDlg, IDC_CNSL_BOLDFONT, (bLB || !pcpd->gbBold) ? FALSE : TRUE);
        EnableWindow(hWndShow, bLB ? FALSE : TRUE);
    }

    hWndHide = GetDlgItem(hDlg, bLB ? IDC_CNSL_POINTSLIST : IDC_CNSL_PIXELSLIST);
    ShowWindow(hWndHide, SW_HIDE);
    EnableWindow(hWndHide, FALSE);

    hWndShow = GetDlgItem(hDlg, bLB ? IDC_CNSL_PIXELSLIST : IDC_CNSL_POINTSLIST);
//    hStockFont = GetStockObject(SYSTEM_FIXED_FONT);
//    SendMessage(hWndShow, WM_SETFONT, (DWORD)hStockFont, FALSE);
    ShowWindow(hWndShow, SW_SHOW);
    EnableWindow(hWndShow, TRUE);

    if (bNewFaceList)
    {
        lcbRESETCONTENT(hWndShow, bLB);
    }
    dwExStyle = GetWindowLong(hWndShow, GWL_EXSTYLE);
    if(dwExStyle & RTL_MIRRORED_WINDOW)
    {
        // if mirrored RTL Reading means LTR !!
        SetWindowBits(hWndShow, GWL_EXSTYLE, WS_EX_RTLREADING, WS_EX_RTLREADING);
    }
    /* Initialize hWndShow list/combo box */

    for (i=0;i<pcpd->NumberOfFonts;i++) {
        int ShowX, ShowY;

        if (!bLB == !TM_IS_TT_FONT(pcpd->FontInfo[i].Family)) {
            continue;
        }

        if (fDbcsCharSet) {
            if (! IS_ANY_DBCS_CHARSET(pcpd->FontInfo[i].tmCharSet)) {
                continue;
            }
        }
        else {
            if (IS_ANY_DBCS_CHARSET(pcpd->FontInfo[i].tmCharSet)) {
                continue;
            }
        }

        if (!bLB) {
            if (lstrcmp(pcpd->FontInfo[i].FaceName, ptszTTFace) != 0 &&
                lstrcmp(pcpd->FontInfo[i].FaceName, ptszAltTTFace) != 0) {
                /*
                 * A TrueType font, but not the one we're interested in,
                 * so don't add it to the list of point sizes.
                 */
                continue;
            }
            if (pcpd->gbBold != IS_BOLD(pcpd->FontInfo[i].Weight)) {
                continue;
            }
        }

        if (pcpd->FontInfo[i].SizeWant.X > 0) {
            ShowX = pcpd->FontInfo[i].SizeWant.X;
        } else {
            ShowX = pcpd->FontInfo[i].Size.X;
        }
        if (pcpd->FontInfo[i].SizeWant.Y > 0) {
            ShowY = pcpd->FontInfo[i].SizeWant.Y;
        } else {
            ShowY = pcpd->FontInfo[i].Size.Y;
        }
        /*
         * Add the size description string to the end of the right list
         */
        if (TM_IS_TT_FONT(pcpd->FontInfo[i].Family)) {
            // point size
            wsprintf(tszText, TEXT("%2d"), pcpd->FontInfo[i].SizeWant.Y);
        } else {
            // pixel size
            if ((LastShowX == ShowX) && (LastShowY == ShowY)) {
                nSameSize++;
            } else {
                LastShowX = ShowX;
                LastShowY = ShowY;
                nSameSize = 0;
            }

            /*
             * The number nSameSize is appended to the string to distinguish
             * between Raster fonts of the same size.  It is not intended to
             * be visible and exists off the edge of the list
             */

            if(((dwExStyle & WS_EX_RIGHT) && !(dwExStyle & RTL_MIRRORED_WINDOW))
                || (!(dwExStyle & WS_EX_RIGHT) && (dwExStyle & RTL_MIRRORED_WINDOW))) {
                // flip  it so that the hidden part be at the far left
                wsprintf(tszText, TEXT("#%d                %2d x %2d"),
                         nSameSize, ShowX, ShowY);
            } else {
                wsprintf(tszText, TEXT("%2d x %2d                #%d"),
                         ShowX, ShowY, nSameSize);
            }
        }
        lListIndex = (LONG) lcbFINDSTRINGEXACT(hWndShow, bLB, tszText);
        if (lListIndex == LB_ERR) {
            lListIndex = (LONG) lcbADDSTRING(hWndShow, bLB, tszText);
        }
        lcbSETITEMDATA(hWndShow, bLB, (DWORD)lListIndex, i);
    }

    /*
     * Get the FontIndex from the currently selected item.
     * (i will be LB_ERR if no currently selected item).
     */
    lListIndex = (LONG) lcbGETCURSEL(hWndShow, bLB);
    i = (int) lcbGETITEMDATA(hWndShow, bLB, lListIndex);

    return i;
}


/** ConsoleDrawItemFontList
 *
 *  Answer the WM_DRAWITEM message sent from the font list box or
 *  facename list box.
 *
 *  Entry:
 *      lpdis     -> DRAWITEMSTRUCT describing object to be drawn
 *
 *  Returns:
 *      None.
 *
 *      The object is drawn.
 */
VOID WINAPI
ConsoleDrawItemFontList(CONSOLEPROP_DATA * pcpd, const LPDRAWITEMSTRUCT lpdis)
{
    HDC     hDC, hdcMem;
    DWORD   rgbBack, rgbText, rgbFill;
    TCHAR   tszFace[LF_FACESIZE];
    HBITMAP hOld;
    int     dy;
    HBRUSH  hbrFill;
    HWND    hWndItem;
    BOOL    bLB;
    int     dxttbmp;

    if ((int)lpdis->itemID < 0)
        return;

    hDC = lpdis->hDC;

    if (lpdis->itemAction & ODA_FOCUS) {
        if (lpdis->itemState & ODS_SELECTED) {
            DrawFocusRect(hDC, &lpdis->rcItem);
        }
    } else {
        if (lpdis->itemState & ODS_SELECTED) {
            rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            rgbBack = SetBkColor(hDC, rgbFill = GetSysColor(COLOR_HIGHLIGHT));
        } else {
            rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
            rgbBack = SetBkColor(hDC, rgbFill = GetSysColor(COLOR_WINDOW));
        }
        // draw selection background
        hbrFill = CreateSolidBrush(rgbFill);
        if (hbrFill) {
            FillRect(hDC, &lpdis->rcItem, hbrFill);
            DeleteObject(hbrFill);
        }

        // get the string
        if (IsWindow(hWndItem = lpdis->hwndItem) == FALSE) {
            return;
        }
        SendMessage(hWndItem, LB_GETTEXT, lpdis->itemID, (LPARAM)tszFace);
        bLB = (BOOL) SendMessage(hWndItem, LB_GETITEMDATA, lpdis->itemID, 0L);
        dxttbmp = bLB ? 0 : g_bmTT.bmWidth;


        // draw the text
        TabbedTextOut(hDC, lpdis->rcItem.left + dxttbmp,
                      lpdis->rcItem.top, tszFace,
                      lstrlen(tszFace), 0, NULL, dxttbmp);

        // and the TT bitmap if needed
        if (!bLB) {
            hdcMem = CreateCompatibleDC(hDC);
            if (hdcMem) {
                hOld = SelectObject(hdcMem, g_hbmTT);

                dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - g_bmTT.bmHeight) / 2;

                BitBlt(hDC, lpdis->rcItem.left, lpdis->rcItem.top + dy,
                       dxttbmp, g_dyFacelistItem, hdcMem,
                       0, 0, SRCINVERT);

                if (hOld)
                    SelectObject(hdcMem, hOld);
                DeleteDC(hdcMem);
            }
        }

        SetTextColor(hDC, rgbText);
        SetBkColor(hDC, rgbBack);

        if (lpdis->itemState & ODS_FOCUS) {
            DrawFocusRect(hDC, &lpdis->rcItem);
        }
    }
}


UINT
GetPointSizeInRange(
   HWND hDlg,
   INT Min,
   INT Max)
/*++

Routine Description:

   Get a size from the Point Size ComboBox edit field

Return Value:

   Point Size - of the edit field limited by Min/Max size
   0 - if the field is empty or invalid

--*/

{
    TCHAR szBuf[90];
    int nTmp = 0;
    BOOL bOK;

    if (GetDlgItemText(hDlg, IDC_CNSL_POINTSLIST, szBuf, NELEM(szBuf))) {
        nTmp = GetDlgItemInt(hDlg, IDC_CNSL_POINTSLIST, &bOK, TRUE);
        if (bOK && nTmp >= Min && nTmp <= Max) {
            return nTmp;
        }
    }

    return 0;
}


/* ----- Preview routines ----- */

LRESULT
_FontPreviewWndProc(
    HWND hWnd,
    UINT wMessage,
    WPARAM wParam,
    LPARAM lParam
    )

/*  FontPreviewWndProc
 *      Handles the font preview window
 */

{
    PAINTSTRUCT ps;
    RECT rect;
    HBRUSH hbrClient;
    HBRUSH hbrOld;
    COLORREF rgbText;
    COLORREF rgbBk;

    CONSOLEPROP_DATA * pcpd = (CONSOLEPROP_DATA *)GetWindowLongPtr( hWnd, GWLP_USERDATA );

    switch (wMessage) {
    case WM_CREATE:
        pcpd = (CONSOLEPROP_DATA *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr( hWnd, GWLP_USERDATA, (LPARAM)pcpd );
        break;

    case WM_PAINT:
        BeginPaint(hWnd, &ps);

        /* Draw the font sample */
        rgbText = GetNearestColor(ps.hdc, ScreenTextColor(pcpd));
        rgbBk = GetNearestColor(ps.hdc, ScreenBkColor(pcpd));
        SelectObject(ps.hdc, pcpd->FontInfo[pcpd->CurrentFontIndex].hFont);
        SetTextColor(ps.hdc, rgbText);
        SetBkColor(ps.hdc, rgbBk);
        GetClientRect(hWnd, &rect);
        InflateRect(&rect, -2, -2);
        hbrClient = CreateSolidBrush(rgbBk);
        if (hbrClient)
            hbrOld = SelectObject(ps.hdc, hbrClient);
        PatBlt(ps.hdc, rect.left, rect.top,
                rect.right - rect.left, rect.bottom - rect.top,
                PATCOPY);
        DrawText(ps.hdc, g_szPreviewText, -1, &rect, 0);
        if (hbrClient)
        {
            SelectObject(ps.hdc, hbrOld);
            DeleteObject(hbrClient);
        }

        EndPaint(hWnd, &ps);
        break;

    default:
        return DefWindowProc(hWnd, wMessage, wParam, lParam);
    }
    return 0L;
}



/*
 * SelectCurrentSize - Select the right line of the Size listbox/combobox.
 *   bLB       : Size controls is a listbox (TRUE for RasterFonts)
 *   FontIndex : Index into FontInfo[] cache
 *               If < 0 then choose a good font.
 * Returns
 *   FontIndex : Index into FontInfo[] cache
 */
int
SelectCurrentSize(CONSOLEPROP_DATA * pcpd, HWND hDlg, BOOL bLB, int FontIndex)
{
    int iCB;
    HWND hWndList;


    hWndList = GetDlgItem(hDlg, bLB ? IDC_CNSL_PIXELSLIST : IDC_CNSL_POINTSLIST);
    iCB = (int) lcbGETCOUNT(hWndList, bLB);

    if (FontIndex >= 0) {
        /*
         * look for FontIndex
         */
        while (iCB > 0) {
            iCB--;
            if (lcbGETITEMDATA(hWndList, bLB, iCB) == FontIndex) {
                lcbSETCURSEL(hWndList, bLB, iCB);
                break;
            }
        }
    } else {
        /*
         * look for a reasonable default size: looking backwards, find
         * the first one same height or smaller.
         */
        DWORD Size;
        Size = pcpd->FontLong;
        if (IsFarEastCP(pcpd->uOEMCP) & bLB
            && (pcpd->FontInfo[pcpd->CurrentFontIndex].tmCharSet != LOBYTE(LOWORD(Size)))
           )
        {
            TCHAR AltFaceName[LF_FACESIZE];
            COORD AltFontSize;
            BYTE  AltFontFamily;
            ULONG AltFontIndex = 0;

            MakeAltRasterFont(pcpd, pcpd->lpFEConsole->uCodePage, &AltFontSize, &AltFontFamily, &AltFontIndex, AltFaceName);

            while(iCB > 0) {
                iCB--;
                if (lcbGETITEMDATA(hWndList, bLB, iCB) == (int)AltFontIndex) {
                    lcbSETCURSEL(hWndList, bLB, iCB);
                    break;
                }
            }
        }
        else
        {
            while (iCB > 0) {
                iCB--;
                FontIndex = (ULONG) lcbGETITEMDATA(hWndList, bLB, iCB);
                if (pcpd->FontInfo[FontIndex].Size.Y <= HIWORD(Size)) {
                    lcbSETCURSEL(hWndList, bLB, iCB);
                    break;
                }
            }
        }
    }
    return FontIndex;
}


BOOL
SelectCurrentFont(CONSOLEPROP_DATA * pcpd, HWND hDlg, int FontIndex)
{
    BOOL bLB;


    bLB = !TM_IS_TT_FONT(pcpd->FontInfo[FontIndex].Family);

    SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_SELECTSTRING, (DWORD)-1,
            bLB ? (LPARAM)tszRasterFonts : (LPARAM)(pcpd->FontInfo[FontIndex].FaceName));

    SelectCurrentSize(pcpd, hDlg, bLB, FontIndex);
    return bLB;
}


BOOL
ConsolePreviewInit(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    BOOL* pfRaster
    )

/*  PreviewInit
 *      Prepares the preview code, sizing the window and the dialog to
 *      make an attractive preview.
 *  *pfRaster is TRUE if Raster Fonts, FALSE if TT Font
 *  Returns FALSE on critical failure, TRUE otherwise
 */

{
    HDC hDC;
    TEXTMETRIC tm;
    RECT rectLabel;
    RECT rectGroup;
    int nFont;
    SHORT xChar;
    SHORT yChar;


    /* Get the system char size */
    hDC = GetDC(hDlg);
    if (!hDC)
    {
        // Out of memory; just close the dialog - better than crashing: Prefix 98162
        return FALSE;
    }

    GetTextMetrics(hDC, &tm);
    ReleaseDC(hDlg, hDC);
    xChar = (SHORT) (tm.tmAveCharWidth);
    yChar = (SHORT) (tm.tmHeight + tm.tmExternalLeading);

    /* Compute the size of the font preview */
    GetWindowRect(GetDlgItem(hDlg, IDC_CNSL_GROUP), &rectGroup);
    MapWindowRect(HWND_DESKTOP, hDlg, &rectGroup);
    rectGroup.bottom -= rectGroup.top;
    GetWindowRect(GetDlgItem(hDlg, IDC_CNSL_STATIC2), &rectLabel);
    MapWindowRect(HWND_DESKTOP, hDlg, &rectLabel);


    /* Create the font preview */
    CreateWindowEx(0L, TEXT("WOACnslFontPreview"), NULL,
        WS_CHILD | WS_VISIBLE,
        rectGroup.left + xChar, rectGroup.top + 3 * yChar / 2,
        rectLabel.left - rectGroup.left - 2 * xChar,
        rectGroup.bottom -  2 * yChar,
        hDlg, (HMENU)IDC_CNSL_FONTWINDOW, g_hinst, (LPVOID)pcpd);

    /*
     * Set the current font
     */
    nFont = FindCreateFont(pcpd,
                           pcpd->lpConsole->uFontFamily,
                           pcpd->lpFaceName,
                           pcpd->lpConsole->dwFontSize,
                           pcpd->lpConsole->uFontWeight);

    pcpd->CurrentFontIndex = nFont;

    *pfRaster = SelectCurrentFont(pcpd, hDlg, nFont);
    return TRUE;
}


BOOL
ConsolePreviewUpdate(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    BOOL bLB
    )

/*++

    Does the preview of the selected font.

--*/

{
    FONT_INFO *lpFont;
    int FontIndex;
    LONG lIndex;
    HWND hWnd;
    TCHAR tszText[60];
    TCHAR tszFace[LF_FACESIZE + CCH_SELECTEDFONT];
    HWND hWndList;


    hWndList = GetDlgItem(hDlg, bLB ? IDC_CNSL_PIXELSLIST : IDC_CNSL_POINTSLIST);

    /* When we select a font, we do the font preview by setting it into
     *  the appropriate list box
     */
    lIndex = (LONG) lcbGETCURSEL(hWndList, bLB);
    if ((lIndex < 0) && !bLB) {
        COORD NewSize;

        lIndex = (LONG) SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_GETCURSEL, 0, 0L);
        SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_GETTEXT, lIndex, (LPARAM)tszFace);
        NewSize.X = 0;
        NewSize.Y = (SHORT) GetPointSizeInRange(hDlg, MIN_PIXEL_HEIGHT, MAX_PIXEL_HEIGHT);

        if (NewSize.Y == 0) {
            TCHAR tszBuf[60];
            /*
             * Use tszText, tszBuf to put up an error msg for bad point size
             */
            pcpd->gbPointSizeError = TRUE;
            GetWindowText(hDlg, tszBuf, NELEM(tszBuf));
            ShellMessageBox(HINST_THISDLL, hDlg, MAKEINTRESOURCE(IDS_CNSL_FONTSIZE),
                                tszBuf, MB_OK|MB_ICONINFORMATION,
                                MIN_PIXEL_HEIGHT, MAX_PIXEL_HEIGHT);
            SetFocus(hWndList);
            pcpd->gbPointSizeError = FALSE;
            return FALSE;
        }
        FontIndex = FindCreateFont(pcpd,
                                   FF_MODERN|TMPF_VECTOR|TMPF_TRUETYPE,
                                   tszFace, NewSize, 0);
    } else {
        FontIndex = (int) lcbGETITEMDATA(hWndList, bLB, lIndex);
    }

    if (FontIndex < 0) {
        FontIndex = pcpd->DefaultFontIndex;
    }

    /*
     * If we've selected a new font, tell the property sheet we've changed
     */
    if (pcpd->CurrentFontIndex != (ULONG)FontIndex) {
        pcpd->CurrentFontIndex = FontIndex;
    }

    lpFont = &pcpd->FontInfo[FontIndex];

    /* Display the new font */

    lstrcpy(tszFace, tszSelectedFont);
    lstrcat(tszFace, lpFont->FaceName);
    SetDlgItemText(hDlg, IDC_CNSL_GROUP, tszFace);

    /* Put the font size in the static boxes */
    wsprintf(tszText, TEXT("%u"), lpFont->Size.X);
    hWnd = GetDlgItem(hDlg, IDC_CNSL_FONTWIDTH);
    SetWindowText(hWnd, tszText);
    InvalidateRect(hWnd, NULL, TRUE);
    wsprintf(tszText, TEXT("%u"), lpFont->Size.Y);
    hWnd = GetDlgItem(hDlg, IDC_CNSL_FONTHEIGHT);
    SetWindowText(hWnd, tszText);
    InvalidateRect(hWnd, NULL, TRUE);

    /* Force the preview windows to repaint */
    hWnd = GetDlgItem(hDlg, IDC_CNSL_PREVIEWWINDOW);
    SendMessage(hWnd, CM_PREVIEW_UPDATE, 0, 0);
    hWnd = GetDlgItem(hDlg, IDC_CNSL_FONTWINDOW);
    InvalidateRect(hWnd, NULL, TRUE);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\lnkmisc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    misc.c

Abstract:

        This file implements the NT console server font routines.

Author:

    Therese Stowell (thereses) 22-Jan-1991

Revision History:

--*/

#include "shellprv.h"
#pragma hdrstop

#include "lnkcon.h"

#define CONSOLE_REGISTRY_STRING       (TEXT("Console"))
#define CONSOLE_REGISTRY_FONTSIZE     (TEXT("FontSize"))
#define CONSOLE_REGISTRY_FONTFAMILY   (TEXT("FontFamily"))
#define CONSOLE_REGISTRY_BUFFERSIZE   (TEXT("ScreenBufferSize"))
#define CONSOLE_REGISTRY_CURSORSIZE   (TEXT("CursorSize"))
#define CONSOLE_REGISTRY_WINDOWSIZE   (TEXT("WindowSize"))
#define CONSOLE_REGISTRY_WINDOWPOS    (TEXT("WindowPosition"))
#define CONSOLE_REGISTRY_FILLATTR     (TEXT("ScreenColors"))
#define CONSOLE_REGISTRY_POPUPATTR    (TEXT("PopupColors"))
#define CONSOLE_REGISTRY_FULLSCR      (TEXT("FullScreen"))
#define CONSOLE_REGISTRY_QUICKEDIT    (TEXT("QuickEdit"))
#define CONSOLE_REGISTRY_FACENAME     (TEXT("FaceName"))
#define CONSOLE_REGISTRY_FONTWEIGHT   (TEXT("FontWeight"))
#define CONSOLE_REGISTRY_INSERTMODE   (TEXT("InsertMode"))
#define CONSOLE_REGISTRY_HISTORYSIZE  (TEXT("HistoryBufferSize"))
#define CONSOLE_REGISTRY_HISTORYBUFS  (TEXT("NumberOfHistoryBuffers"))
#define CONSOLE_REGISTRY_HISTORYNODUP (TEXT("HistoryNoDup"))
#define CONSOLE_REGISTRY_COLORTABLE   (TEXT("ColorTable%02u"))
#define CONSOLE_REGISTRY_CODEPAGE     (TEXT("CodePage"))


/*
 * Initial default fonts and face names
 */

/*
 * TTPoints -- Initial font pixel heights for TT fonts
 */
SHORT TTPoints[] = {
    5, 6, 7, 8, 10, 12, 14, 16, 18, 20, 24, 28, 36, 72
};
/*
 * TTPointsDbcs -- Initial font pixel heights for TT fonts of DBCS.
 */
SHORT TTPointsDbcs[] = {
    6, 8, 10, 12, 14, 16, 18, 20, 24, 28, 36, 72
};


typedef struct _FONTENUMDATA {
    CONSOLEPROP_DATA *pcpd;
    HDC hDC;
    BOOL bFindFaces;
    ULONG ulFE;
    PSHORT pTTPoints;
    UINT nTTPoints;
    UINT uDefCP;
} FONTENUMDATA, *PFONTENUMDATA;


FACENODE *
AddFaceNode(FACENODE * *ppStart, LPTSTR ptsz) {
    FACENODE * pNew;
    FACENODE * *ppTmp;
    int cb;

    /*
     * Is it already here?
     */
    for (ppTmp = ppStart; *ppTmp; ppTmp = &((*ppTmp)->pNext)) {
        if (lstrcmp(((*ppTmp)->atch), ptsz) == 0) {
            // already there !
            return *ppTmp;
        }
    }

    cb = (lstrlen(ptsz) + 1) * sizeof(TCHAR);
    pNew = (FACENODE *)LocalAlloc(LPTR ,sizeof(FACENODE) + cb);
    if (pNew == NULL) {
        return NULL;
    }

    pNew->pNext = NULL;
    pNew->dwFlag = 0;
    lstrcpy(pNew->atch, ptsz);
    *ppTmp = pNew;
    return pNew;
}


VOID
DestroyFaceNodes( CONSOLEPROP_DATA *pcpd ) {
    FACENODE * pNext;
    FACENODE * pTmp;

    pTmp = pcpd->gpFaceNames;
    while (pTmp != NULL) {
        pNext = pTmp->pNext;
        LocalFree(pTmp);
        pTmp = pNext;
    }
    pcpd->gpFaceNames = NULL;
}


int
AddFont(
    CONSOLEPROP_DATA *pcpd,
    ENUMLOGFONT *pelf,
    NEWTEXTMETRIC *pntm,
    int nFontType,
    HDC hDC,
    FACENODE * pFN
    )

/*++

    Add the font desribed by the LOGFONT structure to the font table if
    it's not already there.

--*/

{
    HFONT hFont;
    TEXTMETRIC tm;
    LONG nFont;
    COORD SizeToShow;
    COORD SizeActual;
    COORD SizeWant;
    BYTE tmFamily;
    SIZE Size;
    LPTSTR ptszFace = pelf->elfLogFont.lfFaceName;

    /* get font info */
    SizeWant.Y = (SHORT)pelf->elfLogFont.lfHeight;
    SizeWant.X = (SHORT)pelf->elfLogFont.lfWidth;
CreateBoldFont:
    hFont = CreateFontIndirect(&pelf->elfLogFont);
    ASSERT(hFont);
    if (!hFont) {
        return FE_SKIPFONT;  // same font in other sizes may still be suitable
    }

    //
    // for reasons unbeknownst to me, removing this code causes GDI
    // to yack, claiming that the font is owned by another process.
    //

    SelectObject(hDC, hFont);
    GetTextMetrics(hDC, &tm);

    GetTextExtentPoint32(hDC, TEXT("0"), 1, &Size);
    SizeActual.X = (SHORT)Size.cx;
    SizeActual.Y = (SHORT)(tm.tmHeight + tm.tmExternalLeading);
    tmFamily = tm.tmPitchAndFamily;
    if (TM_IS_TT_FONT(tmFamily) && (SizeWant.Y >= 0)) {
        SizeToShow = SizeWant;
        if (SizeWant.X == 0) {
            // Asking for zero width height gets a default aspect-ratio width
            // It's better to show that width rather than 0.
            SizeToShow.X = SizeActual.X;
        }
    } else {
        SizeToShow = SizeActual;
    }

    // there's a GDI bug - this assert fails occasionally
    //ASSERT (tm.tmMaxCharWidth == pntm->tmMaxCharWidth);

    /*
     * NOW, determine whether this font entry has already been cached
     * LATER : it may be possible to do this before creating the font, if
     * we can trust the dimensions & other info from pntm.
     * Sort by size:
     *  1) By pixelheight (negative Y values)
     *  2) By height (as shown)
     *  3) By width (as shown)
     */
    for (nFont = 0; nFont < (LONG)pcpd->NumberOfFonts; ++nFont) {
        COORD SizeShown;

        if (pcpd->FontInfo[nFont].hFont == NULL) {
            continue;
        }

        if (pcpd->FontInfo[nFont].SizeWant.X > 0) {
            SizeShown.X = pcpd->FontInfo[nFont].SizeWant.X;
        } else {
            SizeShown.X = pcpd->FontInfo[nFont].Size.X;
        }

        if (pcpd->FontInfo[nFont].SizeWant.Y > 0) {
            // This is a font specified by cell height.
            SizeShown.Y = pcpd->FontInfo[nFont].SizeWant.Y;
        } else {
            SizeShown.Y = pcpd->FontInfo[nFont].Size.Y;
            if (pcpd->FontInfo[nFont].SizeWant.Y < 0) {
                // This is a TT font specified by character height.
                if (SizeWant.Y < 0 && SizeWant.Y > pcpd->FontInfo[nFont].SizeWant.Y) {
                    // Requested pixelheight is smaller than this one.
                    break;
                }
            }
        }


        if (SIZE_EQUAL(SizeShown, SizeToShow) &&
                pcpd->FontInfo[nFont].Family == tmFamily &&
                pcpd->FontInfo[nFont].Weight == tm.tmWeight &&
                lstrcmp(pcpd->FontInfo[nFont].FaceName, ptszFace) == 0) {
            /*
             * Already have this font
             */
            DeleteObject(hFont);
            return FE_FONTOK;
        }


        if ((SizeToShow.Y < SizeShown.Y) ||
                (SizeToShow.Y == SizeShown.Y && SizeToShow.X < SizeShown.X)) {
            /*
             * This new font is smaller than nFont
             */
            break;
        }
    }

    /*
     * If we have to grow our font table, do it
     */
    if (pcpd->NumberOfFonts == pcpd->FontInfoLength) {
        FONT_INFO *Temp;

        pcpd->FontInfoLength += FONT_INCREMENT;
        Temp = (FONT_INFO *)LocalReAlloc(pcpd->FontInfo,
                                       sizeof(FONT_INFO) * pcpd->FontInfoLength, LMEM_MOVEABLE|LMEM_ZEROINIT);
        ASSERT(Temp);
        if (Temp == NULL) {
            pcpd->FontInfoLength -= FONT_INCREMENT;
            return FE_ABANDONFONT;  // no point enumerating more - no memory!
        }
        pcpd->FontInfo = Temp;
    }

    /*
     * The font we are adding should be inserted into the list,
     * if it is smaller than the last one.
     */
    if (nFont < (LONG)pcpd->NumberOfFonts) {
        MoveMemory( &pcpd->FontInfo[nFont+1],
                    &pcpd->FontInfo[nFont],
                    sizeof(FONT_INFO) * (pcpd->NumberOfFonts - nFont)
                   );
    }

    /*
     * Store the font info
     */
    pcpd->FontInfo[nFont].hFont = hFont;
    pcpd->FontInfo[nFont].Family = tmFamily;
    pcpd->FontInfo[nFont].Size = SizeActual;
    if (TM_IS_TT_FONT(tmFamily)) {
        pcpd->FontInfo[nFont].SizeWant = SizeWant;
    } else {
        pcpd->FontInfo[nFont].SizeWant.X = 0;
        pcpd->FontInfo[nFont].SizeWant.Y = 0;
    }
    pcpd->FontInfo[nFont].Weight = tm.tmWeight;
    pcpd->FontInfo[nFont].FaceName = pFN->atch;
    pcpd->FontInfo[nFont].tmCharSet = tm.tmCharSet;

    ++pcpd->NumberOfFonts;

    /*
     * If this is a true type font, create a bold version too.
     */
    if (nFontType == TRUETYPE_FONTTYPE && !IS_BOLD(pcpd->FontInfo[nFont].Weight)) {
          pelf->elfLogFont.lfWeight = FW_BOLD;
          goto CreateBoldFont;
    }

    return FE_FONTOK;  // and continue enumeration
}


NTSTATUS
InitializeFonts( CONSOLEPROP_DATA *pcpd )
{
    return EnumerateFonts( pcpd, EF_DEFFACE);  // Just the Default font
}

STDAPI_(void) DestroyFonts( CONSOLEPROP_DATA *pcpd )
{
    ULONG FontIndex;

    if (pcpd->FontInfo != NULL) {
        for (FontIndex = 0; FontIndex < pcpd->NumberOfFonts; FontIndex++) {
            DeleteObject(pcpd->FontInfo[FontIndex].hFont);
        }
        LocalFree(pcpd->FontInfo);
        pcpd->FontInfo = NULL;
        pcpd->NumberOfFonts = 0;
    }

    DestroyFaceNodes( pcpd );
}


/*
 * Returns bit combination
 *  FE_ABANDONFONT  - do not continue enumerating this font
 *  FE_SKIPFONT     - skip this font but keep enumerating
 *  FE_FONTOK       - font was created and added to cache or already there
 */
int
FontEnum(
    ENUMLOGFONT *pelf,
    NEWTEXTMETRIC *pntm,
    int nFontType,
    PFONTENUMDATA pfed
    )

/*++

    Is called exactly once by GDI for each font in the system.  This
    routine is used to store the FONT_INFO structure.

--*/

{
    UINT i;
    LPTSTR ptszFace = pelf->elfLogFont.lfFaceName;
    FACENODE * pFN;

    BOOL      bNegAC;

#ifdef DEBUG
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);

    // NTMW_STRUCTURE is different on 5.0+ platforms and the flag for 5.0+
    // platforms now lives in NEWTEXTMETRIC structure.
    AssertMsg(osvi.dwMajorVersion > 4, TEXT("We now only support running on Win2k or Millennium and later so we should never hit this."));
#endif

    bNegAC = !(pntm->ntmFlags & NTM_NONNEGATIVE_AC);

    //
    // reject variable width and italic fonts, also tt fonts with neg ac
    //

    if
    (
      !(pelf->elfLogFont.lfPitchAndFamily & FIXED_PITCH) ||
      (pelf->elfLogFont.lfItalic)                        ||
      bNegAC
    )
    {
        if (!IsAvailableTTFont(pfed->pcpd,ptszFace))
            return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject TT fonts for whoom family is not modern, that is do not use
     * FF_DONTCARE    // may be surprised unpleasantly
     * FF_DECORATIVE  // likely to be symbol fonts
     * FF_SCRIPT      // cursive, inappropriate for console
     * FF_SWISS OR FF_ROMAN // variable pitch
     */

    if ((nFontType == TRUETYPE_FONTTYPE) &&
            ((pelf->elfLogFont.lfPitchAndFamily & 0xf0) != FF_MODERN)) {
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject non-TT fonts that aren't OEM
     */
    if ((nFontType != TRUETYPE_FONTTYPE) &&
         (!IsFarEastCP(pfed->uDefCP) || !IS_ANY_DBCS_CHARSET(pelf->elfLogFont.lfCharSet)) &&
         (pelf->elfLogFont.lfCharSet != OEM_CHARSET)) {
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject non-TT vertical/non-Terminal Font for FE
     */
    if (IsFarEastCP(pfed->uDefCP))
    {
        if ((nFontType != TRUETYPE_FONTTYPE) &&
            ((ptszFace[0] == TEXT('@')) ||
             (lstrcmp(ptszFace, TEXT("Terminal")) != 0)))
        {
            return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
        }
    }

    /*
     * reject Far East TT fonts that aren't Far East charset.
     */
    if (IsAvailableTTFont(pfed->pcpd, ptszFace) &&
        !IS_ANY_DBCS_CHARSET(pelf->elfLogFont.lfCharSet) &&
        !IsAvailableTTFontCP(pfed->pcpd, ptszFace,0)
       ) {
        return FE_SKIPFONT;    // should be enumerate next charset.
    }

    /*
     * Add or find the facename
     */
    pFN = AddFaceNode(&pfed->pcpd->gpFaceNames, ptszFace);
    if (pFN == NULL) {
        return FE_ABANDONFONT;
    }

    if (pfed->bFindFaces) {
        DWORD dwFontType = 0;
        if (nFontType == TRUETYPE_FONTTYPE) {
            dwFontType = EF_TTFONT;
        } else if (nFontType == RASTER_FONTTYPE) {
            dwFontType = EF_OEMFONT;
        }
        pFN->dwFlag |= dwFontType | EF_NEW;
        
        if (IS_ANY_DBCS_CHARSET(pelf->elfLogFont.lfCharSet))
            pFN->dwFlag |= EF_DBCSFONT;
            
        return FE_SKIPFONT;
    }


    if (IS_BOLD(pelf->elfLogFont.lfWeight)) {
        // return FE_SKIPFONT;
    }

    /*
     * Add the font to the table. If this is a true type font, add the
     * sizes from the array. Otherwise, just add the size we got.
     */
    if (nFontType & TRUETYPE_FONTTYPE) {
        for (i = 0; i < pfed->nTTPoints; i++) {
            pelf->elfLogFont.lfHeight = pfed->pTTPoints[i];
            pelf->elfLogFont.lfWidth  = 0;
            pelf->elfLogFont.lfWeight = 400;
            pfed->ulFE |= AddFont(pfed->pcpd, pelf, pntm, nFontType, pfed->hDC, pFN);
            if (pfed->ulFE & FE_ABANDONFONT) {
                return FE_ABANDONFONT;
            }
        }
    } else {
            pfed->ulFE |= AddFont(pfed->pcpd, pelf, pntm, nFontType, pfed->hDC, pFN);
            if (pfed->ulFE & FE_ABANDONFONT) {
                return FE_ABANDONFONT;
            }
    }

    return FE_FONTOK;  // and continue enumeration
}

BOOL
DoFontEnum(
    CONSOLEPROP_DATA *pcpd,
    HDC hDC,
    LPTSTR ptszFace,
    PSHORT pTTPoints,
    UINT nTTPoints)
{
    BOOL bDeleteDC = FALSE;
    FONTENUMDATA fed;
    LOGFONT LogFont;

    if (hDC == NULL) {
        hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
        bDeleteDC = TRUE;
    }

    fed.pcpd = pcpd;
    fed.hDC = hDC;
    fed.bFindFaces = (ptszFace == NULL);
    fed.ulFE = 0;
    fed.pTTPoints = pTTPoints;
    fed.nTTPoints = nTTPoints;
    fed.uDefCP = pcpd->uOEMCP;
    RtlZeroMemory(&LogFont, sizeof(LOGFONT));
    LogFont.lfCharSet = DEFAULT_CHARSET;
    if (ptszFace)
        _tcscpy(LogFont.lfFaceName, ptszFace);
    /*
     * EnumFontFamiliesEx function enumerates one font in every face in every character set. 
     */
    EnumFontFamiliesEx(hDC, &LogFont, (FONTENUMPROC)FontEnum, (LPARAM)&fed, 0);
    if (bDeleteDC) {
        DeleteDC(hDC);
    }
    return (fed.ulFE & FE_FONTOK) != 0;
}


VOID
RemoveFace(CONSOLEPROP_DATA *pcpd, LPTSTR ptszFace)
{
    DWORD i;
    int nToRemove = 0;

    //
    // Delete & Remove fonts with Face Name == ptszFace
    //
    for (i = 0; i < pcpd->NumberOfFonts; i++) {
        if (lstrcmp(pcpd->FontInfo[i].FaceName, ptszFace) == 0) {
            BOOL bDeleted = DeleteObject(pcpd->FontInfo[i].hFont);
            pcpd->FontInfo[i].hFont = NULL;
            nToRemove++;
        } else if (nToRemove > 0) {
            /*
             * Shuffle from FontInfo[i] down nToRemove slots.
             */
            MoveMemory( &pcpd->FontInfo[i - nToRemove],
                        &pcpd->FontInfo[i],
                        sizeof(FONT_INFO)*(pcpd->NumberOfFonts - i)
                       );
            pcpd->NumberOfFonts -= nToRemove;
            i -= nToRemove;
            nToRemove = 0;
        }
    }
    pcpd->NumberOfFonts -= nToRemove;
}


NTSTATUS
EnumerateFonts(
    CONSOLEPROP_DATA *pcpd,
    DWORD Flags)
{
    TEXTMETRIC tm;
    HDC hDC;
    FACENODE * pFN;
    ULONG ulOldEnumFilter;
    BOOL  bEnumOEMFace = TRUE;
    DWORD FontIndex;
    DWORD dwFontType = 0;


    dwFontType = (EF_TTFONT|EF_OEMFONT|EF_DEFFACE) & Flags;

    if (pcpd->FontInfo == NULL) {
        //
        // allocate memory for the font array
        //
        pcpd->NumberOfFonts = 0;

        pcpd->FontInfo = (FONT_INFO *)LocalAlloc(LPTR, sizeof(FONT_INFO) * INITIAL_FONTS);
        if (pcpd->FontInfo == NULL)
            return STATUS_NO_MEMORY;
        pcpd->FontInfoLength = INITIAL_FONTS;
    }

    hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);

    // Before enumeration, turn off font enumeration filters.
    ulOldEnumFilter = SetFontEnumeration(FE_FILTER_NONE);

    if (Flags & EF_DEFFACE) {
        SelectObject(hDC, GetStockObject(OEM_FIXED_FONT));
        GetTextFace(hDC, LF_FACESIZE, pcpd->DefaultFaceName);

        // Make sure we are going to enumerate the OEM face.
        pFN = AddFaceNode(&pcpd->gpFaceNames, pcpd->DefaultFaceName);
        if (NULL == pFN)
        {
            LocalFree(pcpd->FontInfo);
            pcpd->FontInfo       = NULL;
            pcpd->FontInfoLength = 0;
            pcpd->NumberOfFonts  = 0;
            SetFontEnumeration(ulOldEnumFilter);
            DeleteDC(hDC);
            return STATUS_NO_MEMORY;
        }

        pFN->dwFlag |= EF_DEFFACE | EF_OEMFONT;
        GetTextMetrics(hDC, &tm);
        pcpd->DefaultFontSize.X = (SHORT)(tm.tmMaxCharWidth);
        pcpd->DefaultFontSize.Y = (SHORT)(tm.tmHeight+tm.tmExternalLeading);
        pcpd->DefaultFontFamily = tm.tmPitchAndFamily;
        
        if (IS_ANY_DBCS_CHARSET(tm.tmCharSet))
            pcpd->DefaultFontSize.X /= 2;
    }

    if (pcpd->gbEnumerateFaces) {
        /*
         * Set the EF_OLD bit and clear the EF_NEW bit
         * for all previously available faces
         */
        for (pFN = pcpd->gpFaceNames; pFN; pFN = pFN->pNext) {
            pFN->dwFlag |= EF_OLD;
            pFN->dwFlag &= ~EF_NEW;
        }

        //
        // Use DoFontEnum to get the names of all the suitable Faces
        // All facenames found will be put in gpFaceNames with
        // the EF_NEW bit set.
        //
        DoFontEnum(pcpd, hDC, NULL, TTPoints, 1);
        pcpd->gbEnumerateFaces = FALSE;
    }

    // Use DoFontEnum to get all fonts from the system.  Our FontEnum
    // proc puts just the ones we want into an array
    //
    for (pFN = pcpd->gpFaceNames; pFN; pFN = pFN->pNext) {

        if ((pFN->dwFlag & (EF_OLD|EF_NEW)) == EF_OLD) {
            // The face is no longer available
            RemoveFace(pcpd, pFN->atch);
            pFN->dwFlag &= ~EF_ENUMERATED;
            continue;
        }
        if ((pFN->dwFlag & dwFontType) == 0) {
            // not the kind of face we want
            continue;
        }
        if (pFN->dwFlag & EF_ENUMERATED) {
            // we already enumerated this face
            continue;
        }

        if (pFN->dwFlag & EF_TTFONT) {
            if (IsFarEastCP(pcpd->uOEMCP) && !IsAvailableTTFontCP(pcpd, pFN->atch, 0))
                DoFontEnum(pcpd, hDC, pFN->atch, TTPointsDbcs, NELEM(TTPointsDbcs));
            else
                DoFontEnum(pcpd, hDC, pFN->atch, TTPoints, NELEM(TTPoints));
        } else {
            DoFontEnum(pcpd, hDC, pFN->atch, NULL, 0);

            // If we find that the face just enumerated is the same as OEM,
            // reset flag so we don't try to enumerate it again.

            if (lstrcmpi(pFN->atch, pcpd->DefaultFaceName) == 0)
            {
                bEnumOEMFace = FALSE;
            }
        }
        pFN->dwFlag |= EF_ENUMERATED;
    }


    // After enumerating fonts, restore the font enumeration filter.
    SetFontEnumeration(ulOldEnumFilter);

    DeleteDC(hDC);

    for (FontIndex = 0; FontIndex < pcpd->NumberOfFonts; FontIndex++) {
        if (pcpd->FontInfo[FontIndex].Size.X == pcpd->DefaultFontSize.X &&
            pcpd->FontInfo[FontIndex].Size.Y == pcpd->DefaultFontSize.Y &&
            pcpd->FontInfo[FontIndex].Family == pcpd->DefaultFontFamily) {
            break;
        }
    }
    ASSERT(FontIndex < pcpd->NumberOfFonts);
    if (FontIndex < pcpd->NumberOfFonts) {
        pcpd->DefaultFontIndex = FontIndex;
    } else {
        pcpd->DefaultFontIndex = 0;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
GetNumFonts(
    CONSOLEPROP_DATA *pcpd,
    OUT PULONG NumFonts
    )
{
    *NumFonts = pcpd->NumberOfFonts;
    return STATUS_SUCCESS;
}


NTSTATUS
GetFontSize(
    CONSOLEPROP_DATA *pcpd,
    IN DWORD  FontIndex,
    OUT PCOORD FontSize
    )
{
    if (FontIndex >= pcpd->NumberOfFonts)
        return STATUS_INVALID_PARAMETER;
    *FontSize = pcpd->FontInfo[FontIndex].Size;
    return STATUS_SUCCESS;
}

/*
 * Get the font index for a new font
 * If necessary, attempt to create the font.
 * Always return a valid FontIndex (even if not correct)
 * Family:   Find/Create a font with of this Family
 *           0    - don't care
 * ptszFace: Find/Create a font with this face name.
 *           NULL or TEXT("")  - use DefaultFaceName
 * Size:     Must match SizeWant or actual Size.
 */
int
FindCreateFont(
    CONSOLEPROP_DATA *pcpd,
    DWORD Family,
    LPTSTR ptszFace,
    COORD Size,
    LONG Weight)
{
#define NOT_CREATED_NOR_FOUND -1
#define CREATED_BUT_NOT_FOUND -2

    int i;
    int FontIndex = NOT_CREATED_NOR_FOUND;
    BOOL bFontOK;
    TCHAR AltFaceName[LF_FACESIZE];
    COORD AltFontSize;
    BYTE  AltFontFamily;
    ULONG AltFontIndex = 0;
    LPTSTR ptszAltFace = NULL;
    UINT  uCurrentCP = pcpd->lpFEConsole->uCodePage;
    UINT  uDefaultCP = pcpd->uOEMCP;
    
    BYTE CharSet = CodePageToCharSet(uCurrentCP);

    if (!IsFarEastCP(uDefaultCP) || IS_ANY_DBCS_CHARSET(CharSet))
    {
        if (ptszFace == NULL || *ptszFace == TEXT('\0')) {
            ptszFace = pcpd->DefaultFaceName;
        }
        if (Size.Y == 0) {
            Size = pcpd->DefaultFontSize;
        }
    }
    else 
    {
        MakeAltRasterFont(pcpd, uCurrentCP, &AltFontSize, &AltFontFamily, &AltFontIndex, AltFaceName);

        if (ptszFace == NULL || *ptszFace == L'\0') {
            ptszFace = AltFaceName;
        }
        if (Size.Y == 0) {
            Size.X = AltFontSize.X;
            Size.Y = AltFontSize.Y;
        }
    }

    if (IsAvailableTTFont(pcpd, ptszFace)) {
        ptszAltFace = GetAltFaceName(pcpd, ptszFace);
    }
    else {
        ptszAltFace = ptszFace;
    }

    /*
     * Try to find the exact font
     */
TryFindExactFont:
    for (i=0; i < (int)pcpd->NumberOfFonts; i++) {
        /*
         * If looking for a particular Family, skip non-matches
         */
        if ((Family != 0) &&
                ((BYTE)Family != pcpd->FontInfo[i].Family)) {
            continue;
        }

        /*
         * Skip non-matching sizes
         */
        if ((!SIZE_EQUAL(pcpd->FontInfo[i].SizeWant, Size) &&
             !SIZE_EQUAL(pcpd->FontInfo[i].Size, Size))) {
            continue;
        }

        /*
         * Skip non-matching weights
         */
        if ((Weight != 0) && (Weight != pcpd->FontInfo[i].Weight)) {
            continue;
        }

        /*
         * Skip fonts that have unmatched charset
         */
        if (!TM_IS_TT_FONT(pcpd->FontInfo[i].Family) &&
                pcpd->FontInfo[i].tmCharSet != CharSet) {
            continue;
        }
        
        /*
         * Size (and maybe Family) match.
         *  If we don't care about the name, or if it matches, use this font.
         *  Else if name doesn't match and it is a raster font, consider it.
         */
        if ((ptszFace == NULL) || (ptszFace[0] == TEXT('\0')) ||
                (lstrcmp(pcpd->FontInfo[i].FaceName, ptszFace) == 0) ||
                (lstrcmp(pcpd->FontInfo[i].FaceName, ptszAltFace) == 0) ) {
            FontIndex = i;
            goto FoundFont;
        } else if (!TM_IS_TT_FONT(pcpd->FontInfo[i].Family)) {
            FontIndex = i;
        }
    }

    if (FontIndex == NOT_CREATED_NOR_FOUND) {
        /*
         * Didn't find the exact font, so try to create it
         */
        ULONG ulOldEnumFilter;
        ulOldEnumFilter = SetFontEnumeration(FE_FILTER_NONE);
        if (Size.Y < 0) {
            Size.Y = -Size.Y;
        }
        bFontOK = DoFontEnum(pcpd, NULL, ptszFace, &Size.Y, 1);
        SetFontEnumeration(ulOldEnumFilter);
        if (bFontOK) {
            FontIndex = CREATED_BUT_NOT_FOUND;
            goto TryFindExactFont;
        } else {
        }
    } else if (FontIndex >= 0) {
        // a close Raster Font fit - only the name doesn't match.
        goto FoundFont;
    }

    /*
     * Failed to find exact match, even after enumeration, so now try
     * to find a font of same family and same size or bigger
     */
    for (i=0; i < (int)pcpd->NumberOfFonts; i++) {
    
        if ((Family != 0) &&
                ((BYTE)Family != pcpd->FontInfo[i].Family)) {
            continue;
        }

        if (!TM_IS_TT_FONT(pcpd->FontInfo[i].Family) &&
            pcpd->FontInfo[i].tmCharSet != CharSet) {
            continue;
        }

        if (pcpd->FontInfo[i].Size.Y >= Size.Y &&
                pcpd->FontInfo[i].Size.X >= Size.X) {
            // Same family, size >= desired.
            FontIndex = i;
            break;
        }
    }

    if (FontIndex < 0) {
        if (uCurrentCP == uDefaultCP) 
        {
            FontIndex = pcpd->DefaultFontIndex;
        }
        else 
        {
            FontIndex = AltFontIndex;
        }
    }

FoundFont:
    return FontIndex;

#undef NOT_CREATED_NOR_FOUND
#undef CREATED_BUT_NOT_FOUND
}


LPTSTR
TranslateConsoleTitle(
    LPTSTR ConsoleTitle
    )
/*++

    this routine translates path characters into '_' characters because
    the NT registry apis do not allow the creation of keys with
    names that contain path characters.  it allocates a buffer that
    must be freed.

--*/
{
    int ConsoleTitleLength, i;
    LPTSTR TranslatedTitle;

    ConsoleTitleLength = lstrlen(ConsoleTitle) + 1;
    TranslatedTitle = LocalAlloc(LPTR,
                                ConsoleTitleLength * sizeof(TCHAR));
    if (TranslatedTitle == NULL) {
        return NULL;
    }
    for (i = 0; i < ConsoleTitleLength; i++) {
        if (ConsoleTitle[i] == TEXT('\\')) {
            TranslatedTitle[i] = TEXT('_');
        } else {
            TranslatedTitle[i] = ConsoleTitle[i];
        }
    }
    return TranslatedTitle;
}



void
InitRegistryValues( CONSOLEPROP_DATA *pcpd )

/*++

Routine Description:

    This routine allocates a state info structure and fill it in with
    default values.  It then tries to load the default settings for
    console from the registry.

Arguments:

    none

Return Value:

    pStateInfo - pointer to structure to receive information

--*/

{
    TCHAR chSave;


    pcpd->lpConsole->wFillAttribute = 0x07;            // white on black
    pcpd->lpConsole->wPopupFillAttribute = 0xf5;      // purple on white
    pcpd->lpConsole->bInsertMode = FALSE;
    pcpd->lpConsole->bQuickEdit = FALSE;
    pcpd->lpConsole->bFullScreen = FALSE;
    pcpd->lpConsole->dwScreenBufferSize.X = 80;
    pcpd->lpConsole->dwScreenBufferSize.Y = 25;
    pcpd->lpConsole->dwWindowSize.X = 80;
    pcpd->lpConsole->dwWindowSize.Y = 25;
    pcpd->lpConsole->dwWindowOrigin.X = 0;
    pcpd->lpConsole->dwWindowOrigin.Y = 0;
    pcpd->lpConsole->bAutoPosition = TRUE;
    pcpd->lpConsole->dwFontSize.X = 0;
    pcpd->lpConsole->dwFontSize.Y = 0;
    pcpd->lpConsole->uFontFamily = 0;
    pcpd->lpConsole->uFontWeight = 0;
#ifdef UNICODE
    FillMemory( pcpd->lpConsole->FaceName, sizeof(pcpd->lpConsole->FaceName), 0 );
    pcpd->lpFaceName = (LPTSTR)pcpd->lpConsole->FaceName;
#else
    FillMemory( pcpd->szFaceName, sizeof(pcpd->szFaceName), 0 );
    pcpd->lpFaceName = pcpd->szFaceName;
#endif
    pcpd->lpConsole->uCursorSize = 25;
    pcpd->lpConsole->uHistoryBufferSize = 25;
    pcpd->lpConsole->uNumberOfHistoryBuffers = 4;
    pcpd->lpConsole->bHistoryNoDup = 0;
    pcpd->lpConsole->ColorTable[ 0] = RGB(0,   0,   0   );
    pcpd->lpConsole->ColorTable[ 1] = RGB(0,   0,   0x80);
    pcpd->lpConsole->ColorTable[ 2] = RGB(0,   0x80,0   );
    pcpd->lpConsole->ColorTable[ 3] = RGB(0,   0x80,0x80);
    pcpd->lpConsole->ColorTable[ 4] = RGB(0x80,0,   0   );
    pcpd->lpConsole->ColorTable[ 5] = RGB(0x80,0,   0x80);
    pcpd->lpConsole->ColorTable[ 6] = RGB(0x80,0x80,0   );
    pcpd->lpConsole->ColorTable[ 7] = RGB(0xC0,0xC0,0xC0);
    pcpd->lpConsole->ColorTable[ 8] = RGB(0x80,0x80,0x80);
    pcpd->lpConsole->ColorTable[ 9] = RGB(0,   0,   0xFF);
    pcpd->lpConsole->ColorTable[10] = RGB(0,   0xFF,0   );
    pcpd->lpConsole->ColorTable[11] = RGB(0,   0xFF,0xFF);
    pcpd->lpConsole->ColorTable[12] = RGB(0xFF,0,   0   );
    pcpd->lpConsole->ColorTable[13] = RGB(0xFF,0,   0xFF);
    pcpd->lpConsole->ColorTable[14] = RGB(0xFF,0xFF,0   );
    pcpd->lpConsole->ColorTable[15] = RGB(0xFF,0xFF,0xFF);
    pcpd->lpFEConsole->uCodePage    = pcpd->uOEMCP;
    
    // make console title NULL so we load the default settings for the console
    chSave = pcpd->ConsoleTitle[0];
    pcpd->ConsoleTitle[0] = TEXT('\0');
    GetRegistryValues( pcpd );

    // restore the console title
    pcpd->ConsoleTitle[0] = chSave;

}


VOID
GetTitleFromLinkName(
    LPTSTR szLinkName,
    LPTSTR szTitle
    )
{
    DWORD dwLen;
    LPTSTR pLnk, pDot;
    LPTSTR pPath = szLinkName;

    // Error checking
    if (!szTitle)
        return;

    if (!szLinkName)
    {
        szTitle[0] = TEXT('\0');
        return;
    }


    // find filename at end of fully qualified link name and point pLnk to it
    for (pLnk = pPath; *pPath; pPath++)
    {
        if ( (pPath[0] == TEXT('\\') || pPath[0] == TEXT(':')) &&
              pPath[1] &&
             (pPath[1] != TEXT('\\'))
            )
            pLnk = pPath + 1;
    }

    // find extension (.lnk)
    pPath = pLnk;
    for (pDot = NULL; *pPath; pPath++)
    {
        switch (*pPath) {
        case TEXT('.'):
            pDot = pPath;       // remember the last dot
            break;
        case TEXT('\\'):
        case TEXT(' '):              // extensions can't have spaces
            pDot = NULL;        // forget last dot, it was in a directory
            break;
        }
    }

    // if we found the extension, pDot points to it, if not, pDot
    // is NULL.

    if (pDot)
    {
        dwLen = min( (DWORD) (pDot - pLnk), (MAX_TITLE_LEN-1) );
    }
    else
    {
        dwLen = min( lstrlen(pLnk), (MAX_TITLE_LEN-1) );
    }

    CopyMemory(szTitle, pLnk, dwLen*sizeof(TCHAR));
    szTitle[ dwLen ] = TEXT('\0');

}



VOID
GetRegistryValues(
    CONSOLEPROP_DATA *pcpd
    )

/*++

Routine Description:

    This routine reads in values from the registry and places them
    in the supplied structure.

Arguments:

    pStateInfo - optional pointer to structure to receive information

Return Value:

    current page number

--*/

{
    HKEY hCurrentUserKey;
    HKEY hConsoleKey;
    HKEY hTitleKey;
    LPTSTR TranslatedTitle;
    DWORD dwValue, dwSize;
    DWORD dwRet = 0;
    DWORD i;
    WCHAR awchBuffer[LF_FACESIZE];

    //
    // Open the current user registry key
    //

    if (RegOpenKey( HKEY_CURRENT_USER, NULL, &hCurrentUserKey)!=ERROR_SUCCESS)
        return;

    //
    // Open the console registry key
    //

    if (RegOpenKey(hCurrentUserKey,CONSOLE_REGISTRY_STRING,&hConsoleKey)!=ERROR_SUCCESS)
    {
        RegCloseKey(hCurrentUserKey);
        return;
    }

    //
    // If there is no structure to fill out, just bail out
    //

    if ((!pcpd) || (!pcpd->lpConsole))
        goto CloseKeys;

    //
    // Open the console title subkey, if there is one
    //

    if (pcpd->ConsoleTitle[0] != TEXT('\0'))
    {
        TranslatedTitle = TranslateConsoleTitle(pcpd->ConsoleTitle);
        if (TranslatedTitle == NULL)
            goto GetDefaultConsole;
        dwValue = RegOpenKey( hConsoleKey,
                              TranslatedTitle,
                              &hTitleKey);
        LocalFree(TranslatedTitle);
        if (dwValue!=ERROR_SUCCESS)
            goto GetDefaultConsole;
    } else {

GetDefaultConsole:
        hTitleKey = hConsoleKey;
    }

    //
    // Initial screen fill
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_FILLATTR,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->wFillAttribute = (WORD)dwValue;
    }

    //
    // Initial popup fill
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_POPUPATTR,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->wPopupFillAttribute = (WORD)dwValue;
    }

    //
    // Initial color table
    //

    for (i = 0; i < 16; i++)
    {
        wsprintf((LPTSTR)awchBuffer, CONSOLE_REGISTRY_COLORTABLE, i);
        dwSize = sizeof(dwValue);
        if (SHQueryValueEx( hTitleKey,
                             (LPTSTR)awchBuffer,
                             NULL,
                             NULL,
                             (LPBYTE)&dwValue,
                             &dwSize
                            ) == ERROR_SUCCESS)
        {
            pcpd->lpConsole->ColorTable[i] = dwValue;
        }
    }

    //
    // Initial insert mode
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_INSERTMODE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->bInsertMode = !!dwValue;
    }

    //
    // Initial quick edit mode
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_QUICKEDIT,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->bQuickEdit = !!dwValue;
    }

#ifdef i386
    //
    // Initial full screen mode
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_FULLSCR,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->bFullScreen = !!dwValue;
    }
#endif

    //
    // Initial code page
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_CODEPAGE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpFEConsole->uCodePage = (UINT)dwValue;
    }
    
    //
    // Initial screen buffer size
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_BUFFERSIZE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->dwScreenBufferSize.X = LOWORD(dwValue);
        pcpd->lpConsole->dwScreenBufferSize.Y = HIWORD(dwValue);
    }

    //
    // Initial window size
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_WINDOWSIZE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->dwWindowSize.X = LOWORD(dwValue);
        pcpd->lpConsole->dwWindowSize.Y = HIWORD(dwValue);
    }

    //
    // Initial window position
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_WINDOWPOS,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->dwWindowOrigin.X = (SHORT)LOWORD(dwValue);
        pcpd->lpConsole->dwWindowOrigin.Y = (SHORT)HIWORD(dwValue);
        pcpd->lpConsole->bAutoPosition = FALSE;
    }

    //
    // Initial font size
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_FONTSIZE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->dwFontSize.X = LOWORD(dwValue);
        pcpd->lpConsole->dwFontSize.Y = HIWORD(dwValue);
    }

    //
    // Initial font family
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_FONTFAMILY,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->uFontFamily = dwValue;
    }

    //
    // Initial font weight
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_FONTWEIGHT,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->uFontWeight = dwValue;
    }

    //
    // Initial font face name
    //

    dwSize = sizeof(awchBuffer);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_FACENAME,
                         NULL,
                         NULL,
                         (LPBYTE)awchBuffer,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        CopyMemory((LPBYTE)pcpd->lpFaceName, (LPBYTE)awchBuffer, LF_FACESIZE*sizeof(TCHAR));
    }

    //
    // Initial cursor size
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_CURSORSIZE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->uCursorSize = dwValue;
    }

    //
    // Initial history buffer size
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_HISTORYSIZE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->uHistoryBufferSize = dwValue;
    }

    //
    // Initial number of history buffers
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_HISTORYBUFS,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->uNumberOfHistoryBuffers = dwValue;
    }

    //
    // Initial history duplication mode
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_HISTORYNODUP,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->bHistoryNoDup = dwValue;
    }

    //
    // Close the registry keys
    //

    if (hTitleKey != hConsoleKey) {
        RegCloseKey(hTitleKey);
    }

CloseKeys:
    RegCloseKey(hConsoleKey);
    RegCloseKey(hCurrentUserKey);

}


VOID
SetRegistryValues(
    CONSOLEPROP_DATA *pcpd
    )

/*++

Routine Description:

    This routine writes values to the registry from the supplied
    structure.

Arguments:

    pStateInfo - optional pointer to structure containing information
    dwPage     - current page number

Return Value:

    none

--*/

{
    HKEY hCurrentUserKey;
    HKEY hConsoleKey;
    HKEY hTitleKey;
    LPTSTR TranslatedTitle;
    DWORD dwValue;
    DWORD i;
    WCHAR awchBuffer[LF_FACESIZE];

    //
    // Open the current user registry key
    //

    if (RegOpenKey( HKEY_CURRENT_USER, NULL, &hCurrentUserKey )!=ERROR_SUCCESS)
    {
        return;
    }

    //
    // Open the console registry key
    //

    if (RegCreateKey( hCurrentUserKey, CONSOLE_REGISTRY_STRING, &hConsoleKey )!=ERROR_SUCCESS)
    {
        RegCloseKey(hCurrentUserKey);
        return;
    }

    //
    // If we only want to save the current page, bail out
    //

    if (pcpd == NULL)
    {
        goto CloseKeys;
    }

    //
    // Open the console title subkey, if there is one
    //

    if (pcpd->ConsoleTitle[0] != TEXT('\0'))
    {
        TranslatedTitle = TranslateConsoleTitle(pcpd->ConsoleTitle);
        if (TranslatedTitle == NULL)
        {
            RegCloseKey(hConsoleKey);
            RegCloseKey(hCurrentUserKey);
            return;
        }
        dwValue = RegCreateKey( hConsoleKey,
                                TranslatedTitle,
                                &hTitleKey);
        LocalFree(TranslatedTitle);
        if (dwValue!=ERROR_SUCCESS)
        {
            RegCloseKey(hConsoleKey);
            RegCloseKey(hCurrentUserKey);
            return;
        }
    } else {
        hTitleKey = hConsoleKey;
    }

    //
    // Save screen and popup colors and color table
    //

    dwValue = pcpd->lpConsole->wFillAttribute;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_FILLATTR,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    dwValue = pcpd->lpConsole->wPopupFillAttribute;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_POPUPATTR,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    for (i = 0; i < 16; i++)
    {
        dwValue = pcpd->lpConsole->ColorTable[i];
        wsprintf((LPTSTR)awchBuffer, CONSOLE_REGISTRY_COLORTABLE, i);
        RegSetValueEx( hTitleKey,
                       (LPTSTR)awchBuffer,
                       0,
                       REG_DWORD,
                       (LPBYTE)&dwValue,
                       sizeof(dwValue)
                      );
    }

    //
    // Save insert, quickedit, and fullscreen mode settings
    //

    dwValue = pcpd->lpConsole->bInsertMode;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_INSERTMODE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    dwValue = pcpd->lpConsole->bQuickEdit;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_QUICKEDIT,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
#ifdef i386
    dwValue = pcpd->lpConsole->bFullScreen;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_FULLSCR,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
#endif

    //
    // Save screen buffer size
    //

    dwValue = MAKELONG(pcpd->lpConsole->dwScreenBufferSize.X,
                       pcpd->lpConsole->dwScreenBufferSize.Y);
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_BUFFERSIZE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );

    //
    // Save window size
    //

    dwValue = MAKELONG(pcpd->lpConsole->dwWindowSize.X,
                       pcpd->lpConsole->dwWindowSize.Y);
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_WINDOWSIZE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );

    //
    // Save window position
    //

    if (pcpd->lpConsole->bAutoPosition) {
        RegDeleteKey(hTitleKey, CONSOLE_REGISTRY_WINDOWPOS);
    } else {
        dwValue = MAKELONG(pcpd->lpConsole->dwWindowOrigin.X,
                           pcpd->lpConsole->dwWindowOrigin.Y);
        RegSetValueEx( hTitleKey,
                       CONSOLE_REGISTRY_WINDOWPOS,
                       0,
                       REG_DWORD,
                       (LPBYTE)&dwValue,
                       sizeof(dwValue)
                      );
    }

    //
    // Save font size, family, weight, and face name
    //

    dwValue = MAKELONG(pcpd->lpConsole->dwFontSize.X,
                       pcpd->lpConsole->dwFontSize.Y);
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_FONTSIZE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    dwValue = pcpd->lpConsole->uFontFamily;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_FONTFAMILY,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    dwValue = pcpd->lpConsole->uFontWeight;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_FONTWEIGHT,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_FACENAME,
                   0,
                   REG_SZ,
                   (LPBYTE)pcpd->lpFaceName,
                   (lstrlen(pcpd->lpFaceName) + 1) * sizeof(TCHAR)
                 );

    //
    // Save cursor size
    //

    dwValue = pcpd->lpConsole->uCursorSize;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_CURSORSIZE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );

    //
    // Save history buffer size and number
    //

    dwValue = pcpd->lpConsole->uHistoryBufferSize;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_HISTORYSIZE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    dwValue = pcpd->lpConsole->uNumberOfHistoryBuffers;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_HISTORYBUFS,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    dwValue = pcpd->lpConsole->bHistoryNoDup;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_HISTORYNODUP,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );

    //
    // Close the registry keys
    //

    if (hTitleKey != hConsoleKey) {
        RegCloseKey(hTitleKey);
    }

CloseKeys:
    RegCloseKey(hConsoleKey);
    RegCloseKey(hCurrentUserKey);
}

void
InitFERegistryValues( CONSOLEPROP_DATA *pcpd )

/*++

Routine Description:

    This routine allocates a state info structure and fill it in with
    default values.  It then tries to load the default settings for
    console from the registry.

Arguments:

    none

Return Value:

    pStateInfo - pointer to structure to receive information

--*/

{
    /*
     * In this case: console reads a property of US version.
     * It doesn't have code page information.
     * Console should sets some code page as default.
     * However, I don't know right value. 437 is temporary value.
     */
    pcpd->lpFEConsole->uCodePage = 437;

    GetFERegistryValues( pcpd );
}


VOID
GetFERegistryValues(
    CONSOLEPROP_DATA *pcpd
    )

/*++

Routine Description:

    This routine reads in values from the registry and places them
    in the supplied structure.

Arguments:

    pStateInfo - optional pointer to structure to receive information

Return Value:

    current page number

--*/

{
    HKEY hCurrentUserKey;
    HKEY hConsoleKey;
    HKEY hTitleKey;
    LPTSTR TranslatedTitle;
    DWORD dwValue, dwSize;
    DWORD dwRet = 0;

    //
    // Open the current user registry key
    //

    if (RegOpenKey( HKEY_CURRENT_USER, NULL, &hCurrentUserKey)!=ERROR_SUCCESS)
        return;

    //
    // Open the console registry key
    //

    if (RegOpenKey(hCurrentUserKey,CONSOLE_REGISTRY_STRING,&hConsoleKey)!=ERROR_SUCCESS)
    {
        NtClose(hCurrentUserKey);
        return;
    }

    //
    // If there is no structure to fill out, just bail out
    //

    if ((!pcpd) || (!pcpd->lpFEConsole))
        goto CloseKeys;

    //
    // Open the console title subkey, if there is one
    //

    if (pcpd->ConsoleTitle[0] != TEXT('\0'))
    {
        TranslatedTitle = TranslateConsoleTitle(pcpd->ConsoleTitle);
        if (TranslatedTitle == NULL)
            goto CloseKeys;
        dwValue = RegOpenKey( hConsoleKey,
                              TranslatedTitle,
                              &hTitleKey);
        LocalFree(TranslatedTitle);
        if (dwValue!=ERROR_SUCCESS)
            goto CloseKeys;
    } else {
            goto CloseKeys;
    }

    //
    // Initial code page
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_CODEPAGE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpFEConsole->uCodePage = (UINT)dwValue;
    }

    //
    // Close the registry keys
    //

    if (hTitleKey != hConsoleKey) {
        RegCloseKey(hTitleKey);
    }

CloseKeys:
    RegCloseKey(hConsoleKey);
    RegCloseKey(hCurrentUserKey);

}


VOID
SetFERegistryValues(
    CONSOLEPROP_DATA *pcpd
    )

/*++

Routine Description:

    This routine writes values to the registry from the supplied
    structure.

Arguments:

    pStateInfo - optional pointer to structure containing information
    dwPage     - current page number

Return Value:

    none

--*/

{
    HKEY hCurrentUserKey;
    HKEY hConsoleKey;
    HKEY hTitleKey;
    LPTSTR TranslatedTitle;
    DWORD dwValue;

    //
    // Open the current user registry key
    //

    if (RegOpenKey( HKEY_CURRENT_USER, NULL, &hCurrentUserKey )!=ERROR_SUCCESS)
    {
        return;
    }

    //
    // Open the console registry key
    //

    if (RegCreateKey( hCurrentUserKey, CONSOLE_REGISTRY_STRING, &hConsoleKey )!=ERROR_SUCCESS)
    {
        RegCloseKey(hCurrentUserKey);
        return;
    }

    //
    // If we only want to save the current page, bail out
    //

    if (pcpd == NULL)
    {
        goto CloseKeys;
    }

    //
    // Open the console title subkey, if there is one
    //

    if (pcpd->ConsoleTitle[0] != TEXT('\0'))
    {
        TranslatedTitle = TranslateConsoleTitle(pcpd->ConsoleTitle);
        if (TranslatedTitle == NULL)
        {
            RegCloseKey(hConsoleKey);
            RegCloseKey(hCurrentUserKey);
            return;
        }
        dwValue = RegCreateKey( hConsoleKey,
                                TranslatedTitle,
                                &hTitleKey);
        LocalFree(TranslatedTitle);
        if (dwValue!=ERROR_SUCCESS)
        {
            RegCloseKey(hConsoleKey);
            RegCloseKey(hCurrentUserKey);
            return;
        }
    } else {
        hTitleKey = hConsoleKey;
    }

    // scotthsu
    dwValue = pcpd->lpFEConsole->uCodePage;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_CODEPAGE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );

    //
    // Close the registry keys
    //

    if (hTitleKey != hConsoleKey) {
        RegCloseKey(hTitleKey);
    }

CloseKeys:
    RegCloseKey(hConsoleKey);
    RegCloseKey(hCurrentUserKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\linkwnd.cpp ===
#include "shellprv.h"
#include "ids.h"
#include <oleacc.h>

#ifndef POINTSPERRECT
#define POINTSPERRECT       (sizeof(RECT)/sizeof(POINT))
#endif

#define TESTKEYSTATE(vk)   ((GetKeyState(vk) & 0x8000)!=0)

#define LINKCOLOR_BKGND     COLOR_WINDOW
#define LINKCOLOR_ENABLED   GetSysColor(COLOR_HOTLIGHT)
#define LINKCOLOR_DISABLED  GetSysColor(COLOR_GRAYTEXT)

#define CF_SETCAPTURE  0x0001
#define CF_SETFOCUS    0x0002

void _InitializeUISTATE(IN HWND hwnd, IN OUT UINT* puFlags);
BOOL _HandleWM_UPDATEUISTATE(IN WPARAM wParam, IN LPARAM lParam, IN OUT UINT* puFlags);


//  common IAccessible implementation.

class CAccessibleBase : public IAccessible, public IOleWindow
{
public:
    CAccessibleBase(const HWND& hwnd)
        :   _cRef(1), _ptiAcc(NULL), _hwnd(hwnd)
    { 
        DllAddRef();
    }
    
    virtual ~CAccessibleBase()
    { 
        DllRelease();
        ATOMICRELEASE(_ptiAcc);
    }

    //  IUnknown
    STDMETHODIMP         QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //  IOleWindow
    STDMETHODIMP GetWindow(HWND* phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
                                LCID lcid, DISPID * rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                         DISPPARAMS * pdispparams, VARIANT * pvarResult, 
                         EXCEPINFO * pexcepinfo, UINT * puArgErr);
    //  IAccessible
    STDMETHODIMP get_accParent(IDispatch ** ppdispParent);
    STDMETHODIMP get_accChildCount(long * pcChildren);
    STDMETHODIMP get_accChild(VARIANT varChildIndex, IDispatch ** ppdispChild);
    STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pbstrValue);
    STDMETHODIMP get_accDescription(VARIANT varChild, BSTR * pbstrDescription);
    STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);
    STDMETHODIMP get_accHelp(VARIANT varChild, BSTR* pbstrHelp);
    STDMETHODIMP get_accHelpTopic(BSTR* pbstrHelpFile, VARIANT varChild, long* pidTopic);
    STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut);
    STDMETHODIMP get_accFocus(VARIANT FAR * pvarFocusChild);
    STDMETHODIMP get_accSelection(VARIANT FAR * pvarSelectedChildren);
    STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR* pbstrDefaultAction);
    STDMETHODIMP accSelect(long flagsSelect, VARIANT varChild);
    STDMETHODIMP accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
    STDMETHODIMP accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    STDMETHODIMP accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
    STDMETHODIMP put_accName(VARIANT varChild, BSTR bstrName);
    STDMETHODIMP put_accValue(VARIANT varChild, BSTR bstrValue);

protected:
    virtual UINT GetDefaultActionStringID() const = 0;
    
private:
    LONG _cRef;
    ITypeInfo*  _ptiAcc;
    const HWND& _hwnd;

#define VALIDATEACCCHILD(varChild, idChild, hrFail) \
        if (!(VT_I4 == varChild.vt && idChild == varChild.lVal)) {return hrFail;}

};


#define TEST_CAPTURE(fTest)           ((_fCapture & fTest) != 0)
#define MODIFY_CAPTURE(fSet, fRemove) {if (fSet){_fCapture |= fSet;} if (fRemove){_fCapture &= ~fRemove;}}
#define RESET_CAPTURE()               {_fCapture=0;}

// this API for compat with old clients of the shell32 link window. that is now
// in comctl32.dll

BOOL WINAPI LinkWindow_RegisterClass()
{
    // get the comctl32 linkwindow, and point the old classname at it
    INITCOMMONCONTROLSEX iccs = {sizeof(iccs), ICC_LINK_CLASS};
    InitCommonControlsEx(&iccs);

    WNDCLASS wc;
    ULONG_PTR dwCookie = 0;
    SHActivateContext(&dwCookie);

    BOOL bRet = GetClassInfo(NULL, WC_LINK, &wc);
    SHDeactivateContext(dwCookie);
    if (bRet)
    {
        wc.lpszClassName = TEXT("Link Window"); // old class name for old clients
        RegisterClass(&wc);
    }
    return bRet;
}

BOOL WINAPI LinkWindow_UnregisterClass(HINSTANCE)
{
    return TRUE;
}

#define GROUPBTN_BKCOLOR    COLOR_WINDOW
#define CAPTION_VPADDING    3
#define CAPTION_HPADDING    2
#define GBM_SENDNOTIFY      (GBM_LAST + 1)

//  class CGroupBtn
class CGroupBtn : public CAccessibleBase

{ // all members private:

    CGroupBtn(HWND hwnd);
    ~CGroupBtn();

    //  IAccessible specialization
    STDMETHODIMP get_accName(VARIANT varChild, BSTR* pbstrName);
    STDMETHODIMP accDoDefaultAction(VARIANT varChild);

    //  CAccessibleBase overrides
    UINT GetDefaultActionStringID() const   { return IDS_GROUPBTN_DEFAULTACTION; }

    //  window procedures
    static  LRESULT WINAPI s_GroupBtnWndProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT WINAPI WndProc(HWND, UINT, WPARAM, LPARAM);


    static LRESULT WINAPI s_BuddyProc(HWND, UINT, WPARAM, LPARAM);

    //  message handlers
    void    NcCreate(LPCREATESTRUCT lpcs);
    LRESULT NcCalcSize(BOOL, LPNCCALCSIZE_PARAMS);
    void    NcPaint(HRGN);
    LRESULT NcMouseMove(WPARAM, LONG, LONG);
    LRESULT NcHitTest(LONG, LONG);
    LRESULT NcButtonDown(UINT nMsg, WPARAM nHittest, const POINTS& pts);
    LRESULT NcDblClick(UINT nMsg, WPARAM nHittest, LPARAM lParam);
    LRESULT ButtonUp(UINT nMsg, WPARAM nHittest, const POINTS& pts);
    void    OnCaptureLost(HWND hwndNew) {RESET_CAPTURE();}
    LRESULT WindowPosChanging(LPWINDOWPOS);
    LRESULT OnSize(WPARAM, LONG, LONG);
    BOOL    SetPlacement(PGBPLACEMENT);
    BOOL    SetBuddy(HWND, ULONG);
    BOOL    SetDropState(BOOL);
    void    SetText(LPCTSTR);
    int     GetText(LPTSTR, int);
    int     GetTextW(LPWSTR, int);
    int     GetTextLength();
    void    SetFont(HFONT);
    HFONT   GetFont();

    //  utility methods
    static void _MapWindowRect(HWND hwnd, HWND hwndRelative, OUT LPRECT prcWindow);
    void        _MapWindowRect(HWND hwndRelative, OUT LPRECT prcWindow);
    HCURSOR     GetHandCursor();
    void        CalcCaptionSize();
    BOOL        CalcClientRect(IN OPTIONAL LPCRECT prcWindow, OUT LPRECT prcClient);
    BOOL        CalcWindowSizeForClient(IN OPTIONAL LPCRECT prcClient, 
                                         IN OPTIONAL LPCRECT prcWindow, 
                                         IN LPCRECT prcNewClient, 
                                         OUT LPSIZE psizeWindow);

    void    DoLayout(BOOL bNewBuddy = FALSE);

    LONG    EnableNotifications(BOOL bEnable);
    LRESULT SendNotify(int nCode, IN OPTIONAL NMHDR* pnmh = NULL);
    void    PostNotify(int nCode);
    
    
    //  instance and static data
    HWND        _hwnd;
    HWND        _hwndBuddy;
    WNDPROC     _pfnBuddy;
    ULONG       _dwBuddyFlags;
    SIZE        _sizeBuddyMargin;
    HFONT       _hf;
    static ATOM _atom;
    LPTSTR      _pszCaption;
    SIZE        _sizeCaption;
    int         _yDrop;
    BOOL        _fDropped : 1,
                _fInLayout : 1;
    UINT        _fCapture;
    UINT        _fKeyboardCues;
    HCURSOR     _hcurHand;
    LONG        _cNotifyLocks;

    friend ATOM GroupButton_RegisterClass();
    friend HWND CreateGroupBtn(DWORD, LPCTSTR, DWORD, 
                                int x, int y, HWND hwndParent, UINT nID);
};

ATOM WINAPI GroupButton_RegisterClass()
{
    WNDCLASSEX wc = {0};
    wc.cbSize         = sizeof(wc);
    wc.style          = CS_GLOBALCLASS;
    wc.lpfnWndProc    = CGroupBtn::s_GroupBtnWndProc;
    wc.hInstance      = HINST_THISDLL;
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground  = (HBRUSH)(GROUPBTN_BKCOLOR+1);
    wc.lpszClassName  = GROUPBUTTON_CLASS;
    RegisterClassEx(&wc);
    return (ATOM)TRUE;
}

CGroupBtn::CGroupBtn(HWND hwnd) 
    :   CAccessibleBase(_hwnd),
        _hwnd(hwnd), 
        _hwndBuddy(NULL), 
        _pfnBuddy(NULL),
        _dwBuddyFlags(GBBF_HRESIZE|GBBF_VRESIZE),
        _fInLayout(FALSE),
        _hf(NULL), 
        _pszCaption(NULL),
        _fDropped(TRUE),
        _fKeyboardCues(0),
        _yDrop(0),
        _fCapture(0),
        _hcurHand(NULL),
        _cNotifyLocks(0)
{
    _sizeCaption.cx = _sizeCaption.cy = 0;
    _sizeBuddyMargin.cx = _sizeBuddyMargin.cy = 0;
}

ATOM    CGroupBtn::_atom = 0;


CGroupBtn::~CGroupBtn() 
{
    SetFont(NULL);
    SetText(NULL);
}


//  CGroupBtn IAccessible impl
STDMETHODIMP CGroupBtn::get_accName(VARIANT varChild, BSTR* pbstrName)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    if (NULL == pbstrName)
        return E_POINTER;
    *pbstrName = 0;

    int cch = GetTextLength();
    if ((*pbstrName = SysAllocStringLen(NULL, cch + 1)) != NULL)
    {
        GetTextW(*pbstrName, cch + 1);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

STDMETHODIMP CGroupBtn::accDoDefaultAction(VARIANT varChild)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    SendNotify(NM_RETURN);
    return S_OK;
}



//  CGroupBtn window impl



//  WM_SETTEXT handler
void CGroupBtn::SetText(LPCTSTR pszText)
{
    if (_pszCaption)
    {
        if (pszText && 0==lstrcmp(_pszCaption, pszText))
            return;
        delete [] _pszCaption;
        _pszCaption = NULL;
    }

    if (pszText && *pszText)
    {
        if ((_pszCaption = new TCHAR[lstrlen(pszText)+1]) != NULL)
            lstrcpy(_pszCaption, pszText);
    }
    
    if (IsWindow(_hwnd))
        CalcCaptionSize();
}


//  WM_GETTEXT handler
int CGroupBtn::GetText(LPTSTR pszText, int cchText)
{
    int cch = 0;
    if (pszText && cchText > 0)
    {
        *pszText = 0;
        if (_pszCaption && lstrcpyn(pszText, _pszCaption, cchText))
            cch = min(lstrlen(_pszCaption), cchText);
    }
    return cch;
}


int CGroupBtn::GetTextW(LPWSTR pwszText, int cchText)
{
#ifdef UNICODE
    return GetText(pwszText, cchText);
#else //UNICODE

    int   cchRet = 0;
    LPSTR pszText = new CHAR[cchText];
    
    if (pszText)
    {
        cchRet = GetText(pszText, cchText);
        if (cchRet)
        {
            SHAnsiToUnicode(pszText, pwszText, cchText);
        }
        delete [] pszText;
    }
    return cchRet;

#endif //UNICODE
}


//  WM_GETTEXTLENGTH handler
int CGroupBtn::GetTextLength()
{
    return (_pszCaption && *_pszCaption) ? lstrlen(_pszCaption) : 0 ;
}


//  WM_SETFONT handler
void CGroupBtn::SetFont(HFONT hf)
{
    if (_hf)
    {
        DeleteObject(_hf);
        _hf = NULL;
    }
    _hf = hf;
}


//  WM_GETFONT handler
HFONT CGroupBtn::GetFont()
{
    if (_hf == NULL)
    {
        //  if we don't have a font, use the parent's font
        HFONT hfParent = (HFONT)SendMessage(GetParent(_hwnd), WM_GETFONT, 0, 0);
        if (hfParent)
        {
            LOGFONT lf;
            if (GetObject(hfParent, sizeof(LOGFONT), &lf) >0)
                _hf = CreateFontIndirect(&lf);
        }
    }
    return _hf;
}


//  Hand cursor load
HCURSOR CGroupBtn::GetHandCursor()
{
    if (!_hcurHand)
        _hcurHand = LoadCursor(NULL, IDC_HAND);

    return _hcurHand;
}


//  Retrieves the window rect in relative coords.
void CGroupBtn::_MapWindowRect(HWND hwnd, HWND hwndRelative, OUT LPRECT prcWindow)
{
    ASSERT(IsWindow(hwnd));
    GetWindowRect(hwnd, prcWindow);
    MapWindowPoints(HWND_DESKTOP, hwndRelative, (LPPOINT)prcWindow, 2);
}


//  Retrieves the window rect in relative coords.
inline void CGroupBtn::_MapWindowRect(HWND hwndRelative, OUT LPRECT prcWindow)
{
    _MapWindowRect(_hwnd, hwndRelative, prcWindow);
}


//  Caches the size of the caption 'bar'.
void CGroupBtn::CalcCaptionSize()
{
    SIZE    sizeCaption = {0,0};
    LPCTSTR pszCaption = (_pszCaption && *_pszCaption) ? _pszCaption : TEXT("|");
    HDC     hdc;

    //  compute caption size based on window text:
    if ((hdc = GetDC(_hwnd)))
    {
        HFONT hf = GetFont(),
              hfPrev = (HFONT)SelectObject(hdc, hf);
        
        if (GetTextExtentPoint32(hdc, pszCaption, lstrlen(pszCaption),
                                  &sizeCaption))
            sizeCaption.cy += CAPTION_VPADDING; // add some vertical padding

        SelectObject(hdc, hfPrev);
        ReleaseDC(_hwnd, hdc);
    }

    _sizeCaption = sizeCaption;
}


//  Computes the size and position of the client area
BOOL CGroupBtn::CalcClientRect(IN OPTIONAL LPCRECT prcWindow, OUT LPRECT prcClient)
{
    DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    RECT  rcWindow;

    if (!prcWindow)
    {
        //  Get parent-relative coords
        _MapWindowRect(GetParent(_hwnd), &rcWindow);
        prcWindow = &rcWindow;
    }

    *prcClient = *prcWindow;

    //  compute client rectangle:

    //  allow for border
    if (dwStyle & WS_BORDER)
        InflateRect(prcClient, -1, -1);

    //  allow for caption 'bar'
    prcClient->top += _sizeCaption.cy;

    //  Normalize for NULL rect.
    if (RECTWIDTH(*prcWindow) <=0)
        prcClient->left = prcClient->right = prcWindow->left;
    if (RECTHEIGHT(*prcWindow) <=0)
        prcClient->bottom = prcClient->top = prcWindow->top;

    return TRUE;
}


BOOL CGroupBtn::CalcWindowSizeForClient(
    IN OPTIONAL LPCRECT prcClient, 
    IN OPTIONAL LPCRECT prcWindow, 
    IN LPCRECT prcNewClient, 
    OUT LPSIZE psizeWindow)
{
    if (!(prcNewClient && psizeWindow))
    {
        ASSERT(FALSE);
        return FALSE;
    }

    RECT rcWindow, rcClient;
    if (NULL == prcWindow)
    {
        GetWindowRect(_hwnd, &rcWindow);
        prcWindow = &rcWindow;
    }

    if (NULL == prcClient)
    {
        GetClientRect(_hwnd, &rcClient);
        prcClient = &rcClient;
    }

    SIZE sizeDelta;
    sizeDelta.cx = RECTWIDTH(*prcWindow) - RECTWIDTH(*prcClient);
    sizeDelta.cy = RECTHEIGHT(*prcWindow) - RECTHEIGHT(*prcClient);

    psizeWindow->cx = RECTWIDTH(*prcNewClient)  + sizeDelta.cx;
    psizeWindow->cy = RECTHEIGHT(*prcNewClient) + sizeDelta.cy;
    
    return TRUE;
}


//  WM_WINDOWPOSCHANGING handler
LRESULT CGroupBtn::WindowPosChanging(LPWINDOWPOS pwp)
{
    if (pwp->flags & SWP_NOSIZE)
        return DefWindowProc(_hwnd, WM_WINDOWPOSCHANGING, 0, (LPARAM)pwp);

    //  disallow sizing in buddy slave dimension(s).
    if (IsWindow(_hwndBuddy) && _dwBuddyFlags & (GBBF_HSLAVE|GBBF_VSLAVE) && !_fInLayout)
    {
        RECT rcWindow, rcClient;
        BOOL fResizeBuddy = FALSE;

        GetWindowRect(_hwnd, &rcWindow);
        GetClientRect(_hwnd, &rcClient);

        //  Prepare a buddy size data block
        GBNQUERYBUDDYSIZE qbs;
        qbs.cy = pwp->cy - (RECTHEIGHT(rcWindow) - RECTHEIGHT(rcClient));
        qbs.cx = pwp->cx - (RECTWIDTH(rcWindow) - RECTWIDTH(rcClient));
        
        if (_dwBuddyFlags & GBBF_HSLAVE) // prevent external horz resizing
        {
            pwp->cx = RECTWIDTH(rcWindow);
            //  If we're being resized in the vert dir, query for
            //  optimal buddy width for this height and adjust
            if (_dwBuddyFlags & GBBF_VRESIZE && RECTHEIGHT(rcWindow) != pwp->cy)
            {
                if (SendNotify(GBN_QUERYBUDDYWIDTH, (NMHDR*)&qbs) && qbs.cx >= 0)
                {
                    //  if the owner wants the buddy width to change, do it now.
                    LONG cxNew = qbs.cx + (RECTWIDTH(rcWindow) - RECTWIDTH(rcClient));
                    fResizeBuddy = cxNew != pwp->cx;
                    pwp->cx = cxNew;
                }
            }
        }
        
        if (_dwBuddyFlags & GBBF_VSLAVE) // prevent external vert resizing
        {
            pwp->cy = RECTHEIGHT(rcWindow);
            //  If we're being resized in the horz dir, query for
            //  optimal buddy height for this horizontal and adjust
            if (_dwBuddyFlags & GBBF_HRESIZE && RECTWIDTH(rcWindow) != pwp->cx)
            {
                if (SendNotify(GBN_QUERYBUDDYHEIGHT, (NMHDR*)&qbs) && qbs.cy >= 0)
                {
                    LONG cyNew = qbs.cy + (RECTHEIGHT(rcWindow) - RECTHEIGHT(rcClient));
                    fResizeBuddy = cyNew != pwp->cy;
                    pwp->cy = cyNew;
                }
            }
        }

        if (fResizeBuddy)
        {
            _fInLayout = TRUE;
            SetWindowPos(_hwndBuddy, NULL, 0, 0, qbs.cx, qbs.cy,
                          SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
            _fInLayout = FALSE;
        }
    }

    //  enforce minimum height:
    if (pwp->cy < _sizeCaption.cy)
        pwp->cy = _sizeCaption.cy;

    return 0;
}


LRESULT CGroupBtn::OnSize(WPARAM flags, LONG cx, LONG cy)
{
    DoLayout();
    return 0;
} 


void CGroupBtn::DoLayout(BOOL bNewBuddy)
{
    if (!_fInLayout && IsWindow(_hwndBuddy))
    {
        RECT  rcWindow, rcThis, rcBuddy;
        DWORD dwSwpBuddy = SWP_NOACTIVATE,
              dwSwpThis  = SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE;
        BOOL  fReposThis = FALSE;
        SIZE  sizeNew;

        GetClientRect(_hwnd, &rcThis);
        GetWindowRect(_hwnd, &rcWindow);

        //  get rectangles in parent coords
        MapWindowPoints(_hwnd, GetParent(_hwnd), (LPPOINT)&rcThis,    POINTSPERRECT); 
        MapWindowPoints(HWND_DESKTOP, GetParent(_hwnd), (LPPOINT)&rcWindow,  POINTSPERRECT); 
        _MapWindowRect(_hwndBuddy, GetParent(_hwnd), &rcBuddy);

        //  If we need to reposition ourself to the buddy, 
        //  calculate the new size now.
        if (_dwBuddyFlags & (GBBF_HSLAVE|GBBF_VSLAVE))
            CalcWindowSizeForClient(&rcThis, &rcWindow, &rcBuddy, &sizeNew);

        //  Resize buddy according to size.
        if (_dwBuddyFlags & GBBF_HRESIZE)
        {
            rcBuddy.right = rcBuddy.left + RECTWIDTH(rcThis);

            if (bNewBuddy && 0 == (_dwBuddyFlags & GBBF_VRESIZE)) 
            {
                // query height
                GBNQUERYBUDDYSIZE qbs;
                qbs.cx = RECTWIDTH(rcThis);
                qbs.cy = -1;
                if (SendNotify(GBN_QUERYBUDDYHEIGHT, (NMHDR*)&qbs) && qbs.cy >= 0)
                    rcBuddy.bottom = rcBuddy.top + qbs.cy;
            }
        }
        else if (_dwBuddyFlags & GBBF_HSLAVE)
        { 
            rcWindow.right = rcWindow.left + sizeNew.cx;
            fReposThis = TRUE;
        }
        if (_dwBuddyFlags & GBBF_VRESIZE)
        {
            rcBuddy.bottom = rcBuddy.top + RECTHEIGHT(rcThis);

            if (bNewBuddy && 0 == (_dwBuddyFlags & GBBF_HRESIZE)) 
            {
                // query width
                GBNQUERYBUDDYSIZE qbs;
                qbs.cx = -1;
                qbs.cy = RECTHEIGHT(rcThis);
                if (SendNotify(GBN_QUERYBUDDYWIDTH, (NMHDR*)&qbs) && qbs.cx >= 0)
                    rcBuddy.right = rcBuddy.left + qbs.cx;
            }
        }
        else if (_dwBuddyFlags & GBBF_VSLAVE)
        { 
            rcWindow.bottom = rcWindow.top + sizeNew.cy;
            fReposThis = TRUE;
        }
        
        if (_dwBuddyFlags & GBBF_HSCROLL) 
        { 
            /* not implemented */
        }

        if (_dwBuddyFlags & GBBF_VSCROLL)
        { 
            /* not implemented */
        }

        //  reposition ourself and update our client rect.
        if (fReposThis)
         {
            _fInLayout = TRUE;
            SetWindowPos(_hwnd, NULL, 0, 0, 
                          RECTWIDTH(rcWindow), RECTHEIGHT(rcWindow), dwSwpThis);
            _fInLayout = FALSE;
            GetClientRect(_hwnd, &rcThis);
            MapWindowPoints(_hwnd, GetParent(_hwnd), (LPPOINT)&rcThis,  POINTSPERRECT); 
        }
        
        //  slide buddy into client area and reposition
        OffsetRect(&rcBuddy, rcThis.left - rcBuddy.left, rcThis.top - rcBuddy.top);
        
        _fInLayout = TRUE;
        SetWindowPos(_hwndBuddy, _hwnd, rcBuddy.left, rcBuddy.top,
                      RECTWIDTH(rcBuddy), RECTHEIGHT(rcBuddy), dwSwpBuddy);
        _fInLayout = FALSE;
    }
}


//  GBM_SETPLACEMENT handler
BOOL CGroupBtn::SetPlacement(PGBPLACEMENT pgbp)
{
    RECT  rcWindow, rcClient;
    SIZE  sizeDelta = {0};
    DWORD dwFlags = SWP_NOZORDER|SWP_NOACTIVATE;

    _MapWindowRect(GetParent(_hwnd), &rcWindow);
    CalcClientRect(&rcWindow, &rcClient);

    //  establish whether we need to resize
    if ((pgbp->x < 0 || pgbp->x == rcWindow.left) && 
        (pgbp->y < 0 || pgbp->y == rcWindow.top))
        dwFlags |= SWP_NOMOVE;

    //  compute horizontal placement
    if (pgbp->x >= 0)  // fixed horz origin requested
        OffsetRect(&rcWindow, pgbp->x - rcWindow.left, 0);

    if (pgbp->cx >= 0) // fixed width requested
        rcWindow.right = rcWindow.left + pgbp->cx;
    else
    {
        if (pgbp->cxBuddy >= 0) // client width requested
            sizeDelta.cx = pgbp->cxBuddy - RECTWIDTH(rcClient);
        rcWindow.right  += sizeDelta.cx;
    }
                          
    //  compute vertical placement
    if (pgbp->y >= 0)  // fixed vert origin requested
        OffsetRect(&rcWindow, 0, pgbp->y - rcWindow.top);

    if (pgbp->cy >= 0) // fixed height requested
        rcWindow.bottom = rcWindow.top + pgbp->cy;
    else
    {
        if (pgbp->cyBuddy >= 0) // client height requested
            sizeDelta.cy = pgbp->cyBuddy - RECTHEIGHT(rcClient);
        rcWindow.bottom += sizeDelta.cy;
    }

    if (pgbp->hdwp && (-1 != (LONG_PTR)pgbp->hdwp))
        DeferWindowPos(pgbp->hdwp, _hwnd, NULL, rcWindow.left, rcWindow.top, 
                        RECTWIDTH(rcWindow), RECTHEIGHT(rcWindow),
                        dwFlags);
    else
        SetWindowPos(_hwnd, NULL, rcWindow.left, rcWindow.top, 
                      RECTWIDTH(rcWindow), RECTHEIGHT(rcWindow),
                      dwFlags);

    //  stuff resulting rects
    pgbp->rcWindow = rcWindow;
    return CalcClientRect(&rcWindow, &pgbp->rcBuddy);
}


BOOL CGroupBtn::SetBuddy(HWND hwnd, ULONG dwFlags)
{
    // If we already have a buddy, unhook ourselves
    //
    if (_hwndBuddy)
    {
        if (IsWindow(_hwndBuddy) && _pfnBuddy)
        {
            SetWindowLongPtr(_hwndBuddy, GWLP_USERDATA, (LONG_PTR)NULL);
            SetWindowLongPtr(_hwndBuddy, GWLP_WNDPROC, (LONG_PTR)_pfnBuddy);
        }
        _hwndBuddy = NULL;
        _pfnBuddy = NULL;
    }

    // Handle an invalid window...
    if (!IsWindow(hwnd))
        hwnd = NULL;

    // If we're being buddy'd with a window, hook it
    //
    if (hwnd)
    {
        if (dwFlags & (GBBF_HSLAVE|GBBF_VSLAVE))
        {
            //  subclass the buddy 
            _pfnBuddy = (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)s_BuddyProc);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)this);
        }

        _hwndBuddy = hwnd;
        _dwBuddyFlags = dwFlags;
        DoLayout(TRUE);
    }

    return TRUE;
}


BOOL CGroupBtn::SetDropState(BOOL bDropped)
{
    _fDropped = bDropped;
    return TRUE;
}


//  WM_NCCREATE handler
void CGroupBtn::NcCreate(LPCREATESTRUCT lpcs)
{
    //  assign user data
    SetWindowLongPtr(_hwnd, GWLP_USERDATA, (LONG_PTR)this);
    
    //  enforce window style bits
    lpcs->style     |= WS_CLIPCHILDREN|WS_CLIPSIBLINGS;
    lpcs->dwExStyle |= WS_EX_TRANSPARENT;
    SetWindowLong(_hwnd, GWL_STYLE, lpcs->style);
    SetWindowLong(_hwnd, GWL_EXSTYLE, lpcs->dwExStyle);

    //  enforce min height
    SetText(lpcs->lpszName);
    if (lpcs->cy < _sizeCaption.cy)
    { 
        lpcs->cy = _sizeCaption.cy;
        SetWindowPos(_hwnd, NULL, 0,0, lpcs->cx, lpcs->cy,
                      SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
    }
}


//  WM_NCCALCSIZE handler
LRESULT CGroupBtn::NcCalcSize(BOOL fCalcValidRects, LPNCCALCSIZE_PARAMS pnccs)
{
    LRESULT lRet = FALSE;
    RECT   rcClient;

    if (fCalcValidRects && CalcClientRect(&pnccs->rgrc[0], &rcClient))
    {
        pnccs->rgrc[1] = pnccs->rgrc[2];
        pnccs->rgrc[0] = pnccs->rgrc[2] = rcClient;
        return WVR_VALIDRECTS;
    }
    
    return lRet;
}


//  WM_NCPAINT handler
void CGroupBtn::NcPaint(HRGN hrgn)
{
    RECT    rcWindow;
    DWORD   dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    HDC     hdc;

    GetWindowRect(_hwnd, &rcWindow);
    OffsetRect(&rcWindow, -rcWindow.left, -rcWindow.top);

    if ((hdc = GetWindowDC(_hwnd)) != NULL)
    {
        if (dwStyle & WS_BORDER)
        {
            HBRUSH hbr = CreateSolidBrush(COLOR_WINDOWFRAME);
            if (hbr)
            {
                FrameRect(hdc, &rcWindow, hbr);
                DeleteObject(hbr);
            }
        }

        rcWindow.bottom = rcWindow.top + _sizeCaption.cy;

        SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
        SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

        ExtTextOut(hdc, rcWindow.left, rcWindow.top, 
                    ETO_OPAQUE, &rcWindow, NULL, 0, NULL);

        InflateRect(&rcWindow, -CAPTION_HPADDING, -(CAPTION_VPADDING/2));
        HFONT hfPrev = (HFONT)SelectObject(hdc, GetFont());
        ExtTextOut(hdc, rcWindow.left, rcWindow.top, 
                    ETO_OPAQUE, &rcWindow, _pszCaption, 
                    _pszCaption ? lstrlen(_pszCaption) : 0, NULL);
        SelectObject(hdc, hfPrev);

        if (0 == (_fKeyboardCues & UISF_HIDEFOCUS))
        {
            if (GetFocus() == _hwnd)
            {
                rcWindow.right = rcWindow.left + _sizeCaption.cx + 1;
                InflateRect(&rcWindow, 1, 0);
                DrawFocusRect(hdc, &rcWindow);
            }
        }

        ReleaseDC(_hwnd, hdc);
    }
}


//  WM_NCMOUSEMOVE handler

LRESULT CGroupBtn::NcMouseMove(WPARAM nHittest, LONG x, LONG y)
{
    if (HTCAPTION == nHittest)
    {
        RECT  rc;
        POINT pt;
        GetWindowRect(_hwnd, &rc);
        rc.bottom = rc.top + _sizeCaption.cy;
        rc.right  = rc.left + _sizeCaption.cx;
        InflateRect(&rc, 0, -(CAPTION_VPADDING/2));
        pt.x = x;
        pt.y = y;

        if (PtInRect(&rc, pt))
        {
            HCURSOR hc = GetHandCursor();
            if (hc != NULL)
            {
                SetCursor(hc);
                return 0;
            }
        }
    }
    return DefWindowProc(_hwnd, WM_NCMOUSEMOVE, nHittest, MAKELPARAM(x, y));
}


//  WM_NCHITTEST handler
LRESULT CGroupBtn::NcHitTest(LONG x, LONG y)
{
    POINT pt;
    RECT  rc, rcClient;
    DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    
    pt.x = x;
    pt.y = y;

    GetWindowRect(_hwnd, &rc);
    CalcClientRect(&rc, &rcClient);

    if (PtInRect(&rcClient, pt))
        return HTTRANSPARENT;

    if (PtInRect(&rc, pt))
    {
        if (dwStyle & WS_BORDER)
        {
            if (pt.x == rc.left ||
                pt.x == rc.right ||
                pt.y == rc.bottom)
                return HTBORDER;
        }
        return HTCAPTION;
    }
    return HTNOWHERE;
}


LRESULT CGroupBtn::NcButtonDown(UINT nMsg, WPARAM nHittest, const POINTS& pts)
{
    LRESULT lRet = 0;

    if (HTCAPTION == nHittest)
    {
        SetCursor(GetHandCursor());
        MODIFY_CAPTURE(CF_SETCAPTURE, 0);

        if (GetFocus() != _hwnd)
        {
            MODIFY_CAPTURE(CF_SETFOCUS, 0);
            EnableNotifications(FALSE); // so the host doesn't reposition the link.
            SetFocus(_hwnd);
            EnableNotifications(TRUE);
        }

        SetCapture(_hwnd);
    }
    else
        lRet = DefWindowProc(_hwnd, nMsg, nHittest, MAKELONG(pts.x, pts.y));
        
    return lRet;
}


LRESULT CGroupBtn::ButtonUp(UINT nMsg, WPARAM nHittest, const POINTS& pts)
{
    if (TEST_CAPTURE(CF_SETCAPTURE))
    {
        ReleaseCapture();
        MODIFY_CAPTURE(0, CF_SETCAPTURE);

        POINT ptScrn;
        ptScrn.x = pts.x;
        ptScrn.y = pts.y;
        MapWindowPoints(_hwnd, HWND_DESKTOP, &ptScrn, 1);

        LRESULT nHittest = SendMessage(_hwnd, WM_NCHITTEST, 0, MAKELONG(ptScrn.x, ptScrn.y));

        if (HTCAPTION == nHittest)
        {
            switch (nMsg)
            {
            case WM_LBUTTONUP:
                SendNotify(NM_CLICK);
                break;
            case WM_RBUTTONUP:
                SendNotify(NM_RCLICK);
                break;
            }
        }
    }

    if (TEST_CAPTURE(CF_SETFOCUS))
    {
        MODIFY_CAPTURE(0, CF_SETFOCUS);
        if (GetFocus() == _hwnd) // if we still have the focus...
            SendNotify(NM_SETFOCUS);
    }
    return 0;
}


//  Non-client mouse click/dblclk handler
LRESULT CGroupBtn::NcDblClick(UINT nMsg, WPARAM nHittest, LPARAM lParam)
{
    LRESULT lRet = 0;
    
    if (HTCAPTION == nHittest)
    {
        SetFocus(_hwnd);

        lRet = DefWindowProc(_hwnd, nMsg, HTCLIENT, lParam);

        switch (nMsg)
        {
            case WM_NCLBUTTONDBLCLK:
                SendNotify(NM_DBLCLK);
                break;
            case WM_NCRBUTTONDBLCLK:
                SendNotify(NM_RDBLCLK);
                break;
        }
    }
    else
        lRet = DefWindowProc(_hwnd, nMsg, nHittest, lParam);

    return lRet;
}


LONG CGroupBtn::EnableNotifications(BOOL bEnable)
{
    if (bEnable)
    {
        if (_cNotifyLocks > 0)
            _cNotifyLocks--;
    }
    else
        _cNotifyLocks++;
    
    return _cNotifyLocks;
}


//  WM_NOTIFY transmit helper
LRESULT CGroupBtn::SendNotify(int nCode, IN OPTIONAL NMHDR* pnmh)
{
    if (0 == _cNotifyLocks)
    {
        NMHDR hdr;
        if (NULL == pnmh)
            pnmh = &hdr; 

        pnmh->hwndFrom = _hwnd;
        pnmh->idFrom   = GetDlgCtrlID(_hwnd);
        pnmh->code     = nCode;
        return SendMessage(GetParent(_hwnd), WM_NOTIFY, hdr.idFrom, (LPARAM)pnmh);
    }
    return 0;
}


//  WM_NOTIFY transmit helper
void CGroupBtn::PostNotify(int nCode)
{
    if (0 == _cNotifyLocks)
        PostMessage(_hwnd, GBM_SENDNOTIFY, nCode, 0);
}

LRESULT CALLBACK CGroupBtn::s_GroupBtnWndProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CGroupBtn *pThis = (CGroupBtn *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    if (!pThis && (WM_NCCREATE == wMsg))
    {
        pThis = new CGroupBtn(hDlg);
        SetWindowLongPtr(hDlg, GWLP_USERDATA, (LPARAM)pThis);
    }

    if (pThis)
        return pThis->WndProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}



LRESULT CGroupBtn::WndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    
    switch (nMsg)
    {
        case WM_NCHITTEST:
        {
            POINTS pts = MAKEPOINTS(lParam);
            return NcHitTest(pts.x, pts.y);
        }

        case WM_NCMOUSEMOVE:
        {
            POINTS pts = MAKEPOINTS(lParam);
            return NcMouseMove(wParam, pts.x, pts.y);
        }

        case WM_NCCALCSIZE:
            return NcCalcSize((BOOL)wParam, (LPNCCALCSIZE_PARAMS)lParam);

        case WM_NCPAINT:
            NcPaint((HRGN)wParam);
            return 0;

        case WM_WINDOWPOSCHANGING:
            return WindowPosChanging((LPWINDOWPOS)lParam);

        case WM_SIZE:
        {
            POINTS pts = MAKEPOINTS(lParam);
            return OnSize(wParam, pts.x, pts.y);
        }

        case WM_DESTROY:
            if (IsWindow(_hwndBuddy))
                DestroyWindow(_hwndBuddy);
            break;

        case WM_ERASEBKGND:
            return TRUE; // transparent: no erase bkgnd

        case WM_NCLBUTTONDOWN:
        case WM_NCRBUTTONDOWN:
        {
            POINTS pts = MAKEPOINTS(lParam);
            return NcButtonDown(nMsg, wParam, pts);
        }

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        {
            POINTS pts = MAKEPOINTS(lParam);
            return ButtonUp(nMsg, wParam, pts);
        }

        case WM_NCLBUTTONDBLCLK:
        case WM_NCRBUTTONDBLCLK:
            return NcDblClick(nMsg, wParam, lParam);

        case WM_SHOWWINDOW:
            if (IsWindow(_hwndBuddy))
                ShowWindow(_hwndBuddy, wParam ? SW_SHOW : SW_HIDE);
            break;

        case WM_SETTEXT:
            SetText((LPCTSTR)lParam);
            return TRUE;

        case WM_GETTEXT:
            return GetText((LPTSTR)lParam, (int)wParam);

        case WM_SETFONT:
            SetFont((HFONT)wParam);
            if (lParam /* fRedraw */)
                InvalidateRect(hwnd, NULL, TRUE);
            break;

        case WM_CAPTURECHANGED:
            if (lParam /* NULL if we called ReleaseCapture() */)
                OnCaptureLost((HWND)lParam);
            break;

        case WM_SETFOCUS:
            NcPaint((HRGN)1);
            SendNotify(NM_SETFOCUS);
            break;
             
        case WM_KILLFOCUS:
            NcPaint((HRGN)1);
            SendNotify(NM_KILLFOCUS);
            break;

        case WM_GETDLGCODE:
        {
            MSG* pmsg;
            lRet = DLGC_BUTTON|DLGC_UNDEFPUSHBUTTON;

            if ((pmsg = (MSG*)lParam))
            {
                if ((WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message))
                {
                    switch (pmsg->wParam)
                    {
                    case VK_RETURN:
                    case VK_SPACE:
                        lRet |= DLGC_WANTALLKEYS;
                        break;
                    }
                }
                else if (WM_CHAR == pmsg->message && VK_RETURN == pmsg->wParam)
                {
                    //  Eat VK_RETURN WM_CHARs; we don't want
                    //  Dialog manager to beep when IsDialogMessage gets it.
                    return lRet |= DLGC_WANTMESSAGE;
                }
            }

            return lRet;
        }

        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
            switch (wParam)
            {
                case VK_RETURN:
                case VK_SPACE:
                    if (WM_KEYDOWN == nMsg)
                        SendNotify(NM_RETURN);
                    return 0;
            }
            break;

        case WM_UPDATEUISTATE:
            if (_HandleWM_UPDATEUISTATE(wParam, lParam, &_fKeyboardCues))
                SendMessage(hwnd, WM_NCPAINT, 1, 0);
            break;

        case GBM_SETPLACEMENT:
            if (lParam)
                return SetPlacement((PGBPLACEMENT)lParam);
            return 0;

        case GBM_SETDROPSTATE: // WPARAM: BOOL fDropped, LPARAM: n/a, return: BOOL
            return 0;

        case GBM_GETDROPSTATE: // WPARAM: n/a, LPARAM: n/a, return: BOOL fDropped
            return 0;

        case GBM_SENDNOTIFY:
            SendNotify((int)wParam);
            break;

        case WM_NCCREATE:
            NcCreate((LPCREATESTRUCT)lParam);
            break;

        case WM_NCDESTROY:
            lRet = DefWindowProc(hwnd, nMsg, wParam, lParam);
            SetWindowPtr(hwnd, GWLP_USERDATA, NULL);
            _hwnd = NULL;
            Release();
            return lRet;

        case WM_CREATE:
            _InitializeUISTATE(hwnd, &_fKeyboardCues);
            SetText(((LPCREATESTRUCT)lParam)->lpszName);
            break;

        case GBM_SETBUDDY:     // WPARAM: HWND hwndBuddy, LPARAM: MAKELPARAM(cxMargin, cyMargin), return: BOOL
            return SetBuddy((HWND)wParam, (ULONG)lParam);

        case GBM_GETBUDDY:     // WPARAM: n/a, LPARAM: n/a, return: HWND
            return (LRESULT)_hwndBuddy;

        default:
            // oleacc defs thunked for WINVER < 0x0500
            if ((WM_GETOBJECT == nMsg) && (OBJID_CLIENT == lParam || OBJID_TITLEBAR == lParam)) 
                return LresultFromObject(IID_IAccessible, wParam, SAFECAST(this, IAccessible*));

            break;
    }

    return DefWindowProc(hwnd, nMsg, wParam, lParam);
}
                                                   

LRESULT CGroupBtn::s_BuddyProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    CGroupBtn *pBtn = (CGroupBtn*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (nMsg)
    {
    case WM_SIZE:
        {
            LRESULT lRet = CallWindowProc(pBtn->_pfnBuddy, hwnd, nMsg, wParam, lParam);
            if (!pBtn->_fInLayout)
                pBtn->DoLayout();
            return lRet;
        }

    case WM_DESTROY:
        {
            WNDPROC pfn = pBtn->_pfnBuddy;
            pBtn->SetBuddy(NULL, 0);
            return CallWindowProc(pfn, hwnd, nMsg, wParam, lParam);
        }
    }
    return pBtn->_pfnBuddy ? CallWindowProc(pBtn->_pfnBuddy, hwnd, nMsg, wParam, lParam) : 0;
}


//  CAccessibleBase IUnknown impl
STDMETHODIMP CAccessibleBase::QueryInterface(REFIID riid, void** ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAccessibleBase, IDispatch),
        QITABENT(CAccessibleBase, IAccessible),
        QITABENT(CAccessibleBase, IOleWindow),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CAccessibleBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CAccessibleBase::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


//  CAccessibleBase IOleWindow impl
STDMETHODIMP CAccessibleBase::GetWindow(HWND* phwnd)
{
    *phwnd = _hwnd;
    return IsWindow(_hwnd) ? S_OK : S_FALSE;
}


//  CAccessibleBase IDispatch impl


static HRESULT _accLoadTypeInfo(ITypeInfo** ppti)
{
    ITypeLib* ptl;
    HRESULT hr = LoadTypeLib(L"oleacc.dll", &ptl);

    if (SUCCEEDED(hr))
    {
        hr = ptl->GetTypeInfoOfGuid(IID_IAccessible, ppti);
        ATOMICRELEASE(ptl);
    }
    return hr;
}

STDMETHODIMP CAccessibleBase::GetTypeInfoCount(UINT * pctinfo) 
{ 
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{ 
    HRESULT hr = E_FAIL;
    if (NULL == _ptiAcc && FAILED((hr = _accLoadTypeInfo(&_ptiAcc))))
        return hr;

    *pptinfo = _ptiAcc;
    (*pptinfo)->AddRef();
    return S_OK;
}

STDMETHODIMP CAccessibleBase::GetIDsOfNames(
    REFIID riid, 
    OLECHAR** rgszNames, 
    UINT cNames,
    LCID lcid, DISPID * rgdispid)
{
    HRESULT hr = E_FAIL;

    if (IID_NULL != riid && IID_IAccessible != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (NULL == _ptiAcc && FAILED((hr = _accLoadTypeInfo(&_ptiAcc))))
        return hr;

    return _ptiAcc->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

STDMETHODIMP CAccessibleBase::Invoke(
    DISPID  dispidMember, 
    REFIID  riid, 
    LCID    lcid, 
    WORD    wFlags,
    DISPPARAMS * pdispparams, 
    VARIANT * pvarResult, 
    EXCEPINFO * pexcepinfo, 
    UINT * puArgErr)
{
    HRESULT hr = E_FAIL;
    if (IID_NULL != riid && IID_IAccessible != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (NULL == _ptiAcc && FAILED((hr = _accLoadTypeInfo(&_ptiAcc))))
        return hr;

    return _ptiAcc->Invoke(this, dispidMember, wFlags, pdispparams, 
                            pvarResult, pexcepinfo, puArgErr);
}

STDMETHODIMP CAccessibleBase::get_accParent(IDispatch ** ppdispParent)
{
    *ppdispParent = NULL;
    if (IsWindow(_hwnd))
        return AccessibleObjectFromWindow(_hwnd, OBJID_WINDOW,
                                           IID_PPV_ARG(IDispatch, ppdispParent));
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accChildCount(long * pcChildren)
{
    *pcChildren = 0;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::get_accChild(VARIANT varChildIndex, IDispatch ** ppdispChild)
{
    *ppdispChild = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accValue(VARIANT varChild, BSTR* pbstrValue)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrValue = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accDescription(VARIANT varChild, BSTR * pbstrDescription)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrDescription = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    pvarRole->vt    = VT_I4;
    pvarRole->lVal  = ROLE_SYSTEM_LINK;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = STATE_SYSTEM_DEFAULT ;

    if (GetFocus() == _hwnd)
        pvarState->lVal |= STATE_SYSTEM_FOCUSED;
    else if (IsWindowEnabled(_hwnd))
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

    if (!IsWindowVisible(_hwnd))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    return S_OK;
}

STDMETHODIMP CAccessibleBase::get_accHelp(VARIANT varChild, BSTR* pbstrHelp)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrHelp = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accHelpTopic(BSTR* pbstrHelpFile, VARIANT varChild, long* pidTopic)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrHelpFile = NULL;
    *pidTopic    = -1;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrKeyboardShortcut = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accFocus(VARIANT FAR * pvarFocusChild)
{
    HWND hwndFocus;
    if ((hwndFocus = GetFocus()) == _hwnd || IsChild(_hwnd, hwndFocus))
    {
        pvarFocusChild->vt = VT_I4;
        pvarFocusChild->lVal = CHILDID_SELF;
        return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accSelection(VARIANT FAR * pvarSelectedChildren)
{
    return get_accFocus(pvarSelectedChildren);  // implemented same as focus.
}

STDMETHODIMP CAccessibleBase::get_accDefaultAction(VARIANT varChild, BSTR* pbstrDefaultAction)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    WCHAR wsz[128];
    if (LoadStringW(HINST_THISDLL, GetDefaultActionStringID(), wsz, ARRAYSIZE(wsz)))
    {
        if (NULL == (*pbstrDefaultAction = SysAllocString(wsz)))
            return E_OUTOFMEMORY;
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CAccessibleBase::accSelect(long flagsSelect, VARIANT varChild)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    if (flagsSelect & SELFLAG_TAKEFOCUS)
    {
        SetFocus(_hwnd);
        return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    RECT rc;
    GetWindowRect(_hwnd, &rc);
    *pxLeft = rc.left;
    *pyTop  = rc.top;
    *pcxWidth  = RECTWIDTH(rc);
    *pcyHeight = RECTHEIGHT(rc);

    varChild.vt = VT_I4;
    varChild.lVal = CHILDID_SELF;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    pvarChildAtPoint->vt   = VT_I4;
    pvarChildAtPoint->lVal = CHILDID_SELF;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::put_accName(VARIANT varChild, BSTR bstrName)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::put_accValue(VARIANT varChild, BSTR bstrValue)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    return S_FALSE;
}

BOOL _HandleWM_UPDATEUISTATE(WPARAM wParam, LPARAM lParam, OUT UINT* puFlags)
{
    UINT uFlags = *puFlags;

    switch (LOWORD(wParam))
    {
    case UIS_CLEAR:
        *puFlags &= ~(HIWORD(wParam));
        break;

    case UIS_SET:
        *puFlags |= HIWORD(wParam);
        break;
    }

    return uFlags != *puFlags;
}

void _InitializeUISTATE(IN HWND hwnd, IN OUT UINT* puFlags)
{
    HWND hwndParent = GetParent(hwnd);
    *puFlags = (UINT)SendMessage(hwndParent, WM_QUERYUISTATE, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\lnkprev.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    preview.c

Abstract:

    This module contains the code for console preview window

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

#include "shellprv.h"
#pragma hdrstop

#include "lnkcon.h"

/* ----- Equates ----- */

LONG CnslAspectScale( LONG n1, LONG n2, LONG m );
void CnslAspectPoint( CONSOLEPROP_DATA * pcpd, RECT* rectPreview, POINT* pt);


VOID
UpdatePreviewRect( CONSOLEPROP_DATA * pcpd )

/*++

    Update the global window size and dimensions

--*/

{
    POINT MinSize;
    POINT MaxSize;
    POINT WindowSize;
    FONT_INFO *lpFont;
    HMONITOR hMonitor;
    MONITORINFO mi;

    /*
     * Get the font pointer
     */
    lpFont = &pcpd->FontInfo[pcpd->CurrentFontIndex];

    /*
     * Get the window size
     */
    MinSize.x = (GetSystemMetrics(SM_CXMIN)-pcpd->NonClientSize.x) / lpFont->Size.X;
    MinSize.y = (GetSystemMetrics(SM_CYMIN)-pcpd->NonClientSize.y) / lpFont->Size.Y;
    MaxSize.x = GetSystemMetrics(SM_CXFULLSCREEN) / lpFont->Size.X;
    MaxSize.y = GetSystemMetrics(SM_CYFULLSCREEN) / lpFont->Size.Y;
    WindowSize.x = max(MinSize.x, min(MaxSize.x, pcpd->lpConsole->dwWindowSize.X));
    WindowSize.y = max(MinSize.y, min(MaxSize.y, pcpd->lpConsole->dwWindowSize.Y));

    /*
     * Get the window rectangle, making sure it's at least twice the
     * size of the non-client area.
     */
    pcpd->WindowRect.left = pcpd->lpConsole->dwWindowOrigin.X;
    pcpd->WindowRect.top = pcpd->lpConsole->dwWindowOrigin.Y;
    pcpd->WindowRect.right = WindowSize.x * lpFont->Size.X + pcpd->NonClientSize.x;
    if (pcpd->WindowRect.right < pcpd->NonClientSize.x * 2) {
        pcpd->WindowRect.right = pcpd->NonClientSize.x * 2;
    }
    pcpd->WindowRect.right += pcpd->WindowRect.left;
    pcpd->WindowRect.bottom = WindowSize.y * lpFont->Size.Y + pcpd->NonClientSize.y;
    if (pcpd->WindowRect.bottom < pcpd->NonClientSize.y * 2) {
        pcpd->WindowRect.bottom = pcpd->NonClientSize.y * 2;
    }
    pcpd->WindowRect.bottom += pcpd->WindowRect.top;

    /*
     * Get information about the monitor we're on
     */
    hMonitor = MonitorFromRect(&pcpd->WindowRect, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);
    pcpd->xScreen = mi.rcWork.right - mi.rcWork.left;
    pcpd->yScreen = mi.rcWork.bottom - mi.rcWork.top;

    /*
     * Convert window rectangle to monitor relative coordinates
     */
    pcpd->WindowRect.right  -= pcpd->WindowRect.left;
    pcpd->WindowRect.left   -= mi.rcWork.left;
    pcpd->WindowRect.bottom -= pcpd->WindowRect.top;
    pcpd->WindowRect.top    -= mi.rcWork.top;

    /*
     * Update the display flags
     */
    if (WindowSize.x < pcpd->lpConsole->dwScreenBufferSize.X) {
        pcpd->PreviewFlags |= PREVIEW_HSCROLL;
    } else {
        pcpd->PreviewFlags &= ~PREVIEW_HSCROLL;
    }
    if (WindowSize.y < pcpd->lpConsole->dwScreenBufferSize.Y) {
        pcpd->PreviewFlags |= PREVIEW_VSCROLL;
    } else {
        pcpd->PreviewFlags &= ~PREVIEW_VSCROLL;
    }
}


VOID
InvalidatePreviewRect(HWND hWnd, CONSOLEPROP_DATA * pcpd)

/*++

    Invalidate the area covered by the preview "window"

--*/

{
    RECT rectWin;
    RECT rectPreview;


    /*
     * Get the size of the preview "screen"
     */
    GetClientRect(hWnd, &rectPreview);

    /*
     * Get the dimensions of the preview "window" and scale it to the
     * preview "screen"
     */
    rectWin.left   = pcpd->WindowRect.left;
    rectWin.top    = pcpd->WindowRect.top;
    rectWin.right  = pcpd->WindowRect.left + pcpd->WindowRect.right;
    rectWin.bottom = pcpd->WindowRect.top + pcpd->WindowRect.bottom;
    CnslAspectPoint( pcpd, &rectPreview, (POINT*)&rectWin.left);
    CnslAspectPoint( pcpd, &rectPreview, (POINT*)&rectWin.right);

    /*
     * Invalidate the area covered by the preview "window"
     */
    InvalidateRect(hWnd, &rectWin, FALSE);
}


VOID
PreviewPaint(
    PAINTSTRUCT* pPS,
    HWND hWnd,
    CONSOLEPROP_DATA * pcpd
    )

/*++

    Paints the font preview.  This is called inside the paint message
    handler for the preview window

--*/

{
    RECT rectWin;
    RECT rectPreview;
    HBRUSH hbrFrame;
    HBRUSH hbrTitle;
    HBRUSH hbrOld;
    HBRUSH hbrClient;
    HBRUSH hbrBorder;
    HBRUSH hbrButton;
    HBRUSH hbrScroll;
    HBRUSH hbrDesktop;
    POINT ptButton;
    POINT ptScroll;
    HDC hDC;
    HBITMAP hBitmap;
    HBITMAP hBitmapOld;
    COLORREF rgbClient;


    /*
     * Get the size of the preview "screen"
     */
    GetClientRect(hWnd, &rectPreview);

    /*
     * Get the dimensions of the preview "window" and scale it to the
     * preview "screen"
     */
    rectWin = pcpd->WindowRect;
    CnslAspectPoint( pcpd, &rectPreview, (POINT*)&rectWin.left);
    CnslAspectPoint( pcpd, &rectPreview, (POINT*)&rectWin.right);

    /*
     * Compute the dimensions of some other window components
     */
    ptButton.x = GetSystemMetrics(SM_CXSIZE);
    ptButton.y = GetSystemMetrics(SM_CYSIZE);
    CnslAspectPoint( pcpd, &rectPreview, &ptButton);
    ptButton.y *= 2;       /* Double the computed size for "looks" */
    ptScroll.x = GetSystemMetrics(SM_CXVSCROLL);
    ptScroll.y = GetSystemMetrics(SM_CYHSCROLL);
    CnslAspectPoint( pcpd, &rectPreview, &ptScroll);

    /*
     * Create the memory device context
     */
    hDC = CreateCompatibleDC(pPS->hdc);
    hBitmap = CreateCompatibleBitmap(pPS->hdc,
                                     rectPreview.right,
                                     rectPreview.bottom);
    hBitmapOld = SelectObject(hDC, hBitmap);

    /*
     * Create the brushes
     */
    hbrBorder  = CreateSolidBrush(GetSysColor(COLOR_ACTIVEBORDER));
    hbrTitle   = CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION));
    hbrFrame   = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME));
    hbrButton  = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    hbrScroll  = CreateSolidBrush(GetSysColor(COLOR_SCROLLBAR));
    hbrDesktop = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND));
    rgbClient  = GetNearestColor(hDC, ScreenBkColor(pcpd));
    hbrClient  = CreateSolidBrush(rgbClient);

    /*
     * Erase the clipping area
     */
    FillRect(hDC, &(pPS->rcPaint), hbrDesktop);

    /*
     * Fill in the whole window with the client brush
     */
    hbrOld = SelectObject(hDC, hbrClient);
    PatBlt(hDC, rectWin.left, rectWin.top,
           rectWin.right - 1, rectWin.bottom - 1, PATCOPY);

    /*
     * Fill in the caption bar
     */
    SelectObject(hDC, hbrTitle);
    PatBlt(hDC, rectWin.left + 3, rectWin.top + 3,
           rectWin.right - 7, ptButton.y - 2, PATCOPY);

    /*
     * Draw the "buttons"
     */
    SelectObject(hDC, hbrButton);
    PatBlt(hDC, rectWin.left + 3, rectWin.top + 3,
           ptButton.x, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptButton.x,
           rectWin.top + 3,
           ptButton.x, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - 2 * ptButton.x - 1,
           rectWin.top + 3,
           ptButton.x, ptButton.y - 2, PATCOPY);
    SelectObject(hDC, hbrFrame);
    PatBlt(hDC, rectWin.left + 3 + ptButton.x, rectWin.top + 3,
           1, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptButton.x - 1,
           rectWin.top + 3,
           1, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - 2 * ptButton.x - 2,
           rectWin.top + 3,
           1, ptButton.y - 2, PATCOPY);

    /*
     * Draw the scrollbars
     */
    SelectObject(hDC, hbrScroll);
    if (pcpd->PreviewFlags & PREVIEW_HSCROLL) {
        PatBlt(hDC, rectWin.left + 3,
               rectWin.top + rectWin.bottom - 4 - ptScroll.y,
               rectWin.right - 7, ptScroll.y, PATCOPY);
    }
    if (pcpd->PreviewFlags & PREVIEW_VSCROLL) {
        PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptScroll.x,
               rectWin.top + 1 + ptButton.y + 1,
               ptScroll.x, rectWin.bottom - 6 - ptButton.y, PATCOPY);
        if (pcpd->PreviewFlags & PREVIEW_HSCROLL) {
            SelectObject(hDC, hbrFrame);
            PatBlt(hDC, rectWin.left + rectWin.right - 5 - ptScroll.x,
                   rectWin.top + rectWin.bottom - 4 - ptScroll.y,
                   1, ptScroll.y, PATCOPY);
            PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptScroll.x,
                   rectWin.top + rectWin.bottom - 5 - ptScroll.y,
                   ptScroll.x, 1, PATCOPY);
        }
    }

    /*
     * Draw the interior window frame and caption frame
     */
    SelectObject(hDC, hbrFrame);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + 2,
           1, rectWin.bottom - 5, PATCOPY);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + 2,
           rectWin.right - 5, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + rectWin.bottom - 4,
           rectWin.right - 5, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4, rectWin.top + 2,
           1, rectWin.bottom - 5, PATCOPY);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + 1 + ptButton.y,
           rectWin.right - 5, 1, PATCOPY);

    /*
     * Draw the border
     */
    SelectObject(hDC, hbrBorder);
    PatBlt(hDC, rectWin.left + 1, rectWin.top + 1,
           1, rectWin.bottom - 3, PATCOPY);
    PatBlt(hDC, rectWin.left + 1, rectWin.top + 1,
           rectWin.right - 3, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + 1, rectWin.top + rectWin.bottom - 3,
           rectWin.right - 3, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 3, rectWin.top + 1,
           1, rectWin.bottom - 3, PATCOPY);

    /*
     * Draw the exterior window frame
     */
    SelectObject(hDC, hbrFrame);
    PatBlt(hDC, rectWin.left, rectWin.top,
           1, rectWin.bottom - 1, PATCOPY);
    PatBlt(hDC, rectWin.left, rectWin.top,
           rectWin.right - 1, 1, PATCOPY);
    PatBlt(hDC, rectWin.left, rectWin.top + rectWin.bottom - 2,
           rectWin.right - 1, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 2, rectWin.top,
           1, rectWin.bottom - 1, PATCOPY);

    /*
     * Copy the memory device context to the screen device context
     */
    BitBlt(pPS->hdc, 0, 0, rectPreview.right, rectPreview.bottom,
           hDC, 0, 0, SRCCOPY);

    /*
     * Clean up everything
     */
    SelectObject(hDC, hbrOld);
    SelectObject(hDC, hBitmapOld);
    DeleteObject(hbrBorder);
    DeleteObject(hbrFrame);
    DeleteObject(hbrTitle);
    DeleteObject(hbrClient);
    DeleteObject(hbrButton);
    DeleteObject(hbrScroll);
    DeleteObject(hbrDesktop);
    DeleteObject(hBitmap);
    DeleteDC(hDC);
}


#define LPCS_INDEX 0
#define PCPD_INDEX sizeof(PVOID)

LRESULT
PreviewWndProc(
    HWND hWnd,
    UINT wMessage,
    WPARAM wParam,
    LPARAM lParam
    )

/*
 * PreviewWndProc
 *      Handles the preview window
 */

{
    PAINTSTRUCT ps;
    LPCREATESTRUCT lpcs;
    RECT rcWindow;
    CONSOLEPROP_DATA * pcpd;
    int cx;
    int cy;


    switch (wMessage) {
    case WM_CREATE:
        lpcs = (LPCREATESTRUCT)LocalAlloc( LPTR, SIZEOF( CREATESTRUCT ) );
        if (lpcs)
        {
            CopyMemory( (PVOID)lpcs, (PVOID)lParam, SIZEOF( CREATESTRUCT ) );
            SetWindowLongPtr( hWnd, LPCS_INDEX, (LONG_PTR)lpcs );
        }
        else
            return 0;
        break;

    case CM_PREVIEW_INIT:

        pcpd = (CONSOLEPROP_DATA *)lParam;
        SetWindowLongPtr( hWnd, PCPD_INDEX, (LONG_PTR)pcpd );

        /*
         * Figure out space used by non-client area
         */
        SetRect(&rcWindow, 0, 0, 50, 50);
        AdjustWindowRect(&rcWindow, WS_OVERLAPPEDWINDOW, FALSE);
        pcpd->NonClientSize.x = rcWindow.right - rcWindow.left - 50;
        pcpd->NonClientSize.y = rcWindow.bottom - rcWindow.top - 50;

        /*
         * Compute the size of the preview "window"
         */
        UpdatePreviewRect( pcpd );

        /*
         * Scale the window so it has the same aspect ratio as the screen
         */
        lpcs = (LPCREATESTRUCT)GetWindowLongPtr( hWnd, LPCS_INDEX );
        cx = lpcs->cx;
        cy = CnslAspectScale( pcpd->yScreen, pcpd->xScreen, cx);
        if (cy > lpcs->cy) {
            cy = lpcs->cy;
            cx = CnslAspectScale(pcpd->xScreen, pcpd->yScreen, cy);
        }
        MoveWindow(hWnd, lpcs->x, lpcs->y, cx, cy, TRUE);
        break;

    case WM_PAINT:
        pcpd = (CONSOLEPROP_DATA *)GetWindowLongPtr( hWnd, PCPD_INDEX );
        BeginPaint(hWnd, &ps);
        if (pcpd)
            PreviewPaint(&ps, hWnd, pcpd);
        EndPaint(hWnd, &ps);
        break;

    case CM_PREVIEW_UPDATE:
        pcpd = (CONSOLEPROP_DATA *)GetWindowLongPtr( hWnd, PCPD_INDEX );
        if (pcpd)
        {
            InvalidatePreviewRect(hWnd, pcpd);
            UpdatePreviewRect( pcpd );

            /*
             * Make sure the preview "screen" has the correct aspect ratio
             */
            GetWindowRect(hWnd, &rcWindow);
            cx = rcWindow.right - rcWindow.left;
            cy = CnslAspectScale(pcpd->yScreen, pcpd->xScreen, cx);
            if (cy != rcWindow.bottom - rcWindow.top) {
                SetWindowPos(hWnd, NULL, 0, 0, cx, cy, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
            }
        
            InvalidatePreviewRect(hWnd, pcpd);
        }
        break;

    case WM_DESTROY:
        lpcs = (LPCREATESTRUCT)GetWindowLongPtr( hWnd, LPCS_INDEX );
        if (lpcs)
            LocalFree( lpcs );
        break;

    default:
        return DefWindowProc(hWnd, wMessage, wParam, lParam);
    }
    return 0L;
}


/*  CnslAspectScale
 *      Performs the following calculation in LONG arithmetic to avoid
 *      overflow:
 *          return = n1 * m / n2
 *      This can be used to make an aspect ration calculation where n1/n2
 *      is the aspect ratio and m is a known value.  The return value will
 *      be the value that corresponds to m with the correct apsect ratio.
 */

LONG
CnslAspectScale(
    LONG n1,
    LONG n2,
    LONG m)
{
    LONG Temp;

    Temp = n1 * m + (n2 >> 1);
    return Temp / n2;
}

/*  CnslAspectPoint
 *      Scales a point to be preview-sized instead of screen-sized.
 */

void
CnslAspectPoint(
    CONSOLEPROP_DATA * pcpd,
    RECT* rectPreview,
    POINT* pt
    )
{
    pt->x = CnslAspectScale(rectPreview->right, pcpd->xScreen, pt->x);
    pt->y = CnslAspectScale(rectPreview->bottom, pcpd->yScreen, pt->y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\lstrfns.h ===
#define OFFSET(x) ((PSTR)(LOWORD((DWORD)(x))))

extern LPWSTR StrChrW(LPCWSTR lpStart, WCHAR wMatch);
extern LPSTR StrChrA(LPCSTR lpStart, CHAR wMatch);
extern LPWSTR StrRChrW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch);
extern LPSTR StrRChrA(LPCSTR lptart, LPCSTR lpEnd, CHAR wMatch);
extern LPWSTR StrChrIW(LPCWSTR lpStart, WCHAR wMatch);
extern LPSTR StrChrIA(LPCSTR lptart, CHAR wMatch);
extern LPWSTR StrRChrIW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch);
extern LPSTR StrRChrIA(LPCSTR lptart, LPCSTR lpEnd, CHAR wMatch);
extern INT StrCpyNW(LPWSTR lpDest, LPWSTR lpSource, INT nBufSize);
extern INT StrCpyNA(LPSTR lpest, LPSTR lpSource, INT nBufSize);
extern INT StrNCpyW(LPWSTR lpDest, LPWSTR lpSource, INT nChar);
extern INT StrNCpyA(LPSTR lpest, LPSTR lpSource, INT nChar);
extern LPWSTR StrStrW(LPWSTR lpFirst, LPWSTR lpSrch);
extern LPSTR StrStrA(LPSTR lpirst, LPSTR lpSrch);
extern LPWSTR StrRStrW(LPWSTR lpSource, LPWSTR lpLast, LPWSTR lpSrch);
extern LPSTR StrRStrA(LPSTR lpource, LPSTR lpLast, LPSTR lpSrch);
extern LPWSTR StrStrIW(LPWSTR lpFirst, LPWSTR lpSrch);
extern LPSTR StrStrIA(LPSTR lpirst, LPSTR lpSrch);
extern LPWSTR StrRStrIW(LPWSTR lpSource, LPWSTR lpLast, LPWSTR lpSrch);
extern LPSTR StrRStrIA(LPSTR lpSource, LPSTR lpLast, LPSTR lpSrch);

extern BOOL IntlStrEqWorkerW(BOOL fCaseSens, LPCWSTR lpWStr1, LPCWSTR lpWStr2, INT nChar);
extern BOOL IntlStrEqWorkerA(BOOL fCaseSens, LPCSTR lptr1, LPCSTR lpWStr2, INT nChar);

#ifndef UNICODE
#define StrChr StrChrA
#define StrRChr StrRChrA
#define StrChrI StrChrIA
#define StrRChrI StrRChrIA
#define StrCpyN StrCpyNA
#define StrNCpy StrNCpyA
#define StrStr StrStrA
#define StrRStr StrRStrA
#define StrStrI StrStrIA
#define StrRStrI StrRStrIA
#define IntlStrEqN(lpStr1, lpStr2, nChar)   IntlStrEqWorkerA(  TRUE, lpStr1, lpStr2, nChar)
#define IntlStrEqNI(lpStr1, lpStr2, nChar)  IntlStrEqWorkerA( FALSE, lpStr1, lpStr2, nChar)
#else
#define StrChr StrChrW
#define StrRChr StrRChrW
#define StrChrI StrChrIW
#define StrRChrI StrRChrIW
#define StrCpyN StrCpyNW
#define StrNCpy StrNCpyW
#define StrStr StrStrW
#define StrRStr StrRStrW
#define StrStrI StrStrIW
#define StrRStrI StrRStrIW
#define IntlStrEqN(lpStr1, lpStr2, nChar)   IntlStrEqWorkerW(  TRUE, lpStr1, lpStr2, nChar)
#define IntlStrEqNI(lpStr1, lpStr2, nChar)  IntlStrEqWorkerW( FALSE, lpStr1, lpStr2, nChar)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\lvutil.c ===
#include "shellprv.h"
#pragma  hdrstop

// convert screen coords to listview view coordinates

// convert listview client window coords into listview view coordinates

void LVUtil_ClientToLV(HWND hwndLV, LPPOINT ppt)
{
    POINT ptOrigin;

    if (!ListView_GetOrigin(hwndLV, &ptOrigin))
        return;

    ppt->x += ptOrigin.x;
    ppt->y += ptOrigin.y;
}

void LVUtil_ScreenToLV(HWND hwndLV, LPPOINT ppt)
{
    ScreenToClient(hwndLV, ppt);

    LVUtil_ClientToLV(hwndLV, ppt);
}

// convert listview client window coords into listview view coordinates

void LVUtil_LVToClient(HWND hwndLV, LPPOINT ppt)
{
    POINT ptOrigin;

    if (!ListView_GetOrigin(hwndLV, &ptOrigin))
        return;

    ppt->x -= ptOrigin.x;
    ppt->y -= ptOrigin.y;
}

//
// Parameters:
//  hwndLV      -- Specifies the listview window
//  nItem       -- Specifies the item to be altered
//  uState      -- Specifies the new state of the item
//  uMask       -- Specifies the state mask
//
void LVUtil_DragSetItemState(HWND hwndLV, int nItem, UINT uState, UINT uMask)
{
    // check the state to see if it is already as we want to avoid
    // flashing while dragging

    if (ListView_GetItemState(hwndLV, nItem, uMask) != (uState & uMask))
    {
        DAD_ShowDragImage(FALSE);
        ListView_SetItemState(hwndLV, nItem, uState, uMask);
        UpdateWindow(hwndLV);   // REVIEW, needed?
        DAD_ShowDragImage(TRUE);
    }
}

void LVUtil_DragSelectItem(HWND hwndLV, int nItem)
{
    int nTemp;

    for (nTemp = ListView_GetItemCount(hwndLV) - 1; nTemp >= 0; --nTemp)
    {
        LVUtil_DragSetItemState(hwndLV, nTemp, nTemp == nItem ? LVIS_DROPHILITED : 0, LVIS_DROPHILITED);
    }
}

//
// Note that it returns NULL, if iItem is -1.
//
LPARAM LVUtil_GetLParam(HWND hwndLV, int i)
{
    LV_ITEM item;

    item.mask = LVIF_PARAM;
    item.iItem = i;
    item.iSubItem = 0;
    item.lParam = 0;
    if (i != -1)
    {
        ListView_GetItem(hwndLV, &item);
    }

    return item.lParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\lowdisk.cpp ===
#include "shellprv.h"
#include "util.h"
#include "ids.h"
#include "balmsg.h"
#include "bitbuck.h"
#include "mtpt.h"

// states for state machine, values are relavant as we compare them
// durring transitions to see if UI should be triggered or not

typedef enum
{
    STATE_1MB = 0,          // the "disk is completely filled" case
    STATE_50MB = 1,         // < 50MB case
    STATE_80MB = 2,         // < 80MB case
    STATE_200MB = 3,        // < 200MB case, only do this one on > 2.25GB drives
    STATE_ALLGOOD = 4,      // > 200MB, everything is fine
    STATE_UNKNOWN = 5,
} LOWDISK_STATE;

#define BYTES_PER_MB		((ULONGLONG)0x100000)

typedef struct 
{
    LOWDISK_STATE lds;
    ULONG dwMinMB;              // range (min) that defines this state
    ULONG dwMaxMB;              // range (max) that defines this state
    DWORD dwCleanupFlags;       // DISKCLEANUP_
    DWORD dwShowTime;           // in sec
    DWORD dwIntervalTime;       // in sec
    UINT  cRetry;
    DWORD niif;
} STATE_DATA;

#define HOURS (60 * 60)
#define MINS  (60)

const STATE_DATA c_state_data[] = 
{
    {STATE_1MB,     0,     1,   DISKCLEANUP_VERYLOWDISK, 30, 5 * MINS,  -1, NIIF_ERROR},
    {STATE_50MB,    1,    50,   DISKCLEANUP_VERYLOWDISK, 30, 5 * MINS,  -1, NIIF_WARNING},
    {STATE_80MB,   50,    80,   DISKCLEANUP_LOWDISK,     30, 4 * HOURS,  1, NIIF_WARNING},
    {STATE_200MB,  80,   200,   DISKCLEANUP_LOWDISK,     30, 0 * HOURS,  0, NIIF_INFO},
};

void SRNotify(LPCWSTR pszDrive, DWORD dwFreeSpaceInMB, BOOL bImproving)
{
    typedef void (* PFNSRNOTIFYFREESPACE)(LPCWSTR, DWORD, BOOL);
    
    static HMODULE s_hmodSR = NULL;
    if (NULL == s_hmodSR)
        s_hmodSR = LoadLibrary(TEXT("srclient.dll"));

    if (s_hmodSR)
    {
	PFNSRNOTIFYFREESPACE pfnNotifyFreeSpace = (PFNSRNOTIFYFREESPACE)GetProcAddress(s_hmodSR, "SRNotify");
        if (pfnNotifyFreeSpace)
            pfnNotifyFreeSpace(pszDrive, dwFreeSpaceInMB, bImproving);
    }
}

class CLowDiskSpaceUI : IQueryContinue
{
public:
    CLowDiskSpaceUI(int iDrive);
    void CheckDiskSpace();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IQueryContinue
    STDMETHODIMP QueryContinue();    // S_OK -> Continue, other 

private:
    ~CLowDiskSpaceUI();
    BOOL _EnterExclusive();
    void _LeaveExclusive();
    void _DoNotificationUI();
    void _DoStateMachine();

    const STATE_DATA *_StateData(LOWDISK_STATE lds);
    LOWDISK_STATE _StateFromFreeSpace(ULARGE_INTEGER ulTotal, ULARGE_INTEGER ulFree);
    LOWDISK_STATE _GetCurrentState(BOOL bInStateMachine);

    static DWORD CALLBACK s_ThreadProc(void *pv);

    LONG _cRef;
    TCHAR _szRoot[5];
    HANDLE _hMutex;
    LOWDISK_STATE _ldsCurrent;
    BOOL _bShowUI;
    BOOL _bSysVolume;
    DWORD _dwLastFreeMB;
};

CLowDiskSpaceUI::CLowDiskSpaceUI(int iDrive) : _cRef(1), _ldsCurrent(STATE_UNKNOWN)
{
    ASSERT(_bShowUI == FALSE);
    ASSERT(_bSysVolume == FALSE);

    PathBuildRoot(_szRoot, iDrive);

    TCHAR szWinDir[MAX_PATH];
    if (GetWindowsDirectory(szWinDir, ARRAYSIZE(szWinDir)))
    {
        _bSysVolume = szWinDir[0] == _szRoot[0];
    }
}

CLowDiskSpaceUI::~CLowDiskSpaceUI()
{
    if (_hMutex)
        CloseHandle(_hMutex);
}

HRESULT CLowDiskSpaceUI::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CLowDiskSpaceUI, IQueryContinue),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CLowDiskSpaceUI::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CLowDiskSpaceUI::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CLowDiskSpaceUI::QueryContinue()
{
    LOWDISK_STATE ldsOld = _ldsCurrent;
    return ldsOld == _GetCurrentState(TRUE) ? S_OK : S_FALSE;
}

const STATE_DATA *CLowDiskSpaceUI::_StateData(LOWDISK_STATE lds)
{
    for (int i = 0; i < ARRAYSIZE(c_state_data); i++)
    {
        if (c_state_data[i].lds == lds)
            return &c_state_data[i];
    }
    return NULL;
}

LOWDISK_STATE CLowDiskSpaceUI::_StateFromFreeSpace(ULARGE_INTEGER ulTotal, ULARGE_INTEGER ulFree)
{
    ULONGLONG ulTotalMB = (ulTotal.QuadPart / BYTES_PER_MB);
    ULONGLONG ulFreeMB = (ulFree.QuadPart / BYTES_PER_MB);

    _dwLastFreeMB = (DWORD)ulFreeMB;

    for (int i = 0; i < ARRAYSIZE(c_state_data); i++)
    {
        // total needs to be 8 times the max of this range for us to consider it
        if ((ulTotalMB / 8) > c_state_data[i].dwMaxMB)
        {
            if ((c_state_data[i].lds == _ldsCurrent) ?
                ((ulFreeMB >= c_state_data[i].dwMinMB) && (ulFreeMB <= (c_state_data[i].dwMaxMB + 3))) :
                ((ulFreeMB >= c_state_data[i].dwMinMB) && (ulFreeMB <=  c_state_data[i].dwMaxMB)))
            {
                // only report 200MB state on drives >= 2.25GB
                if ((c_state_data[i].lds != STATE_200MB) || (ulTotal.QuadPart >= (2250 * BYTES_PER_MB)))
                    return c_state_data[i].lds;
            }
        }
    }
    return STATE_ALLGOOD;
}

LOWDISK_STATE CLowDiskSpaceUI::_GetCurrentState(BOOL bInStateMachine)
{
    LOWDISK_STATE ldsNew = STATE_ALLGOOD;   // assume this in case of failure

    ULARGE_INTEGER ulTotal, ulFree;
    if (SHGetDiskFreeSpaceEx(_szRoot, NULL, &ulTotal, &ulFree))
    {
        ldsNew = _StateFromFreeSpace(ulTotal, ulFree);
    }

    if (bInStateMachine)
    {
        if (_ldsCurrent != ldsNew)
        {
            // state change

            // if things are getting worse need to show UI (if we are in the state machine)
            _bShowUI = (ldsNew < _ldsCurrent);

            SRNotify(_szRoot, _dwLastFreeMB, ldsNew > _ldsCurrent);  // call system restore 
        }
        _ldsCurrent = ldsNew;
    }
    return ldsNew;
}

// creates the notification icon in the tray and shows a balloon with it
// this is a modal call, when it returns either the UI has timed out or the
// user has clicked on the notification UI.

void CLowDiskSpaceUI::_DoNotificationUI()
{
    // assume this will be a one shot UI, but this can get reset via our callback
    _bShowUI = FALSE;

    const STATE_DATA *psd = _StateData(_ldsCurrent);
    if (psd && (_bSysVolume || (psd->lds <= STATE_80MB)))
    {
        IUserNotification *pun;
        HRESULT hr = CoCreateInstance(CLSID_UserNotification, NULL, CLSCTX_ALL, IID_PPV_ARG(IUserNotification, &pun));
        if (SUCCEEDED(hr))
        {
            SHFILEINFO sfi = {0};
            SHGetFileInfo(_szRoot, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi),
                SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME |
                SHGFI_ICON | SHGFI_SMALLICON | SHGFI_ADDOVERLAYS);

            TCHAR szTitle[64], szMsg[256], szTemplate[256];

            UINT niif = _bSysVolume ? psd->niif : NIIF_INFO;

            LoadString(HINST_THISDLL, IDS_DISK_FULL_TITLE, szTitle, ARRAYSIZE(szTitle));
            LoadString(HINST_THISDLL, NIIF_INFO == niif ? IDS_DISK_FULL_TEXT : IDS_DISK_FULL_TEXT_SERIOUS, 
                szTemplate, ARRAYSIZE(szTemplate));

            wnsprintf(szMsg, ARRAYSIZE(szMsg), szTemplate, sfi.szDisplayName);

            pun->SetIconInfo(sfi.hIcon, szTitle);
            pun->SetBalloonRetry(psd->dwShowTime * 1000, psd->dwIntervalTime * 1000, psd->cRetry);
            // pun->SetBalloonInfo(szTitle, L"<a href=\"notepad.exe\"> Click here for notepad</a>", niif);
            pun->SetBalloonInfo(szTitle, szMsg, niif);

            hr = pun->Show(SAFECAST(this, IQueryContinue *), 1 * 1000); // 1 sec poll for callback

            if (sfi.hIcon)
                DestroyIcon(sfi.hIcon);

            if (S_OK == hr)
            {
                // S_OK -> user click on icon or balloon
                LaunchDiskCleanup(NULL, DRIVEID(_szRoot), (_bSysVolume ? psd->dwCleanupFlags : 0) | DISKCLEANUP_MODAL);
            }

            pun->Release();
        }
    }
}

void CLowDiskSpaceUI::_DoStateMachine()
{
    do
    {
        if (_bShowUI)
        {
            _DoNotificationUI();
        }
        else
        {
            SHProcessMessagesUntilEvent(NULL, NULL, 5 * 1000);  // 5 seconds
        }
    }
    while (STATE_ALLGOOD != _GetCurrentState(TRUE));
}

BOOL CLowDiskSpaceUI::_EnterExclusive()
{
    if (NULL == _hMutex)
    {
        TCHAR szEvent[32];
        wsprintf(szEvent, TEXT("LowDiskOn%C"), _szRoot[0]);
        _hMutex = CreateMutex(CreateAllAccessSecurityAttributes(NULL, NULL, NULL), FALSE, szEvent);
    }
    return _hMutex && WAIT_OBJECT_0 == WaitForSingleObject(_hMutex, 0);    // zero timeout
}

void CLowDiskSpaceUI::_LeaveExclusive()
{
    ASSERT(_hMutex);
    ReleaseMutex(_hMutex);
}

DWORD CALLBACK CLowDiskSpaceUI::s_ThreadProc(void *pv)
{
    CLowDiskSpaceUI *pldsui = (CLowDiskSpaceUI *)pv;
    if (pldsui->_EnterExclusive())
    {
        pldsui->_DoStateMachine();
        pldsui->_LeaveExclusive();
    }
    pldsui->Release();
    return 0;
}

void CLowDiskSpaceUI::CheckDiskSpace()
{
    if (STATE_ALLGOOD != _GetCurrentState(FALSE))
    {
        AddRef();
        if (!SHCreateThread(s_ThreadProc, this, CTF_COINIT, NULL))
        {
            Release();
        }
    }
}

STDAPI CheckDiskSpace()
{
    // the only caller of this is in explorer\tray.cpp
    // it checks against SHRestricted(REST_NOLOWDISKSPACECHECKS) on that side.
    for (int i = 0; i < 26; i++)
    {
        CMountPoint* pmp = CMountPoint::GetMountPoint(i);
        if (pmp)
        {
            if (pmp->IsFixedDisk() && !pmp->IsRemovableDevice())
            {
                CLowDiskSpaceUI *pldsui = new CLowDiskSpaceUI(i);
                if (pldsui)
                {
                    pldsui->CheckDiskSpace();
                    pldsui->Release();
                }
            }
            pmp->Release();
        }
    }
    return S_OK;
}

STDAPI_(BOOL) GetDiskCleanupPath(LPTSTR pszBuf, UINT cchSize)
{
    if (pszBuf)
       *pszBuf = 0;

    DWORD cbLen = CbFromCch(cchSize);
    return SUCCEEDED(SKGetValue(SHELLKEY_HKLM_EXPLORER, TEXT("MyComputer\\cleanuppath"), NULL, NULL, pszBuf, &cbLen));
}

STDAPI_(void) LaunchDiskCleanup(HWND hwnd, int iDrive, UINT uFlags)
{
    TCHAR szPathTemplate[MAX_PATH];

    if (GetDiskCleanupPath(szPathTemplate, ARRAYSIZE(szPathTemplate)))
    {
        TCHAR szPath[MAX_PATH], szArgs[MAX_PATH];
        wsprintf(szPath, szPathTemplate, TEXT('A') + iDrive);

        if (uFlags & DISKCLEANUP_LOWDISK)
        {
            lstrcatn(szPath, TEXT(" /LOWDISK"), ARRAYSIZE(szPath));
        }
        else if (uFlags & DISKCLEANUP_VERYLOWDISK)
        {
            lstrcatn(szPath, TEXT(" /VERYLOWDISK"), ARRAYSIZE(szPath));
        }

        PathSeperateArgs(szPath, szArgs);

        SHELLEXECUTEINFO ei =
        {
            sizeof(ei),
            SEE_MASK_FLAG_NO_UI | SEE_MASK_NOCLOSEPROCESS,
            NULL, NULL, szPath, szArgs, NULL, SW_SHOWNORMAL, NULL 
        };

        if (ShellExecuteEx(&ei))
        {
            if (ei.hProcess)
            {
                if (DISKCLEANUP_MODAL & uFlags)
                    SHProcessMessagesUntilEvent(NULL, ei.hProcess, INFINITE);
                CloseHandle(ei.hProcess);
            }
        }
        else
        {
            ShellMessageBox(HINST_THISDLL, NULL, 
                        MAKEINTRESOURCE(IDS_NO_CLEANMGR_APP), 
                        NULL, MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
        }
    }
}


// public export
STDAPI_(void) SHHandleDiskFull(HWND hwnd, int idDrive)
{
    // legacy, no one calls this
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\lstrfns.c ===
#define UNICODE 1

#include "shellprv.h"
#pragma  hdrstop

/*
 * StrEndN - Find the end of a string, but no more than n bytes
 * Assumes   lpStart points to start of null terminated string
 *           nBufSize is the maximum length
 * returns ptr to just after the last byte to be included
 */
LPWSTR StrEndNW(LPCWSTR lpStart, int nBufSize)
{
    LPCWSTR lpEnd;

    for (lpEnd = lpStart + nBufSize; *lpStart && lpStart < lpEnd; lpStart = CharNext(lpStart))
    {
        /* just getting to the end of the string */
        continue;
    }

    if (lpStart > lpEnd)
    {
      /* We can only get here if the last wchar before lpEnd was a lead byte
       */
      lpStart -= 2;
    }

    return((LPWSTR)lpStart);
}

LPSTR StrEndNA(LPCSTR lpStart, int nBufSize)
{
    LPCSTR lpEnd;

    for (lpEnd = lpStart + nBufSize; *lpStart && lpStart < lpEnd; lpStart = CharNextA(lpStart))
    {
        /* just getting to the end of the string */
        continue;
    }

    if (lpStart > lpEnd)
    {
        // We can only get here if the last byte before lpEnd was a lead byte
        lpStart -= 2;
    }

    return (LPSTR)lpStart;
}


/*
 * StrCpyN      - Copy up to N chars, don't end in LeadByte char
 *
 * Assumes   lpDest points to buffer of nBufSize bytes (including NULL)
 *           lpSource points to string to be copied.
 * returns   Number of bytes copied, NOT including NULL
 */
int Shell32_StrCpyNW(LPWSTR lpDest, LPWSTR lpSource, int nBufSize)
{
    LPWSTR lpEnd;
    WCHAR cHold;

    if (nBufSize < 0)
        return(nBufSize);

    lpEnd = StrEndNW(lpSource, nBufSize);
    cHold = *lpEnd;
    *lpEnd = WCHAR_NULL;
    lstrcpy(lpDest, lpSource);
    *lpEnd = cHold;

    return (int)(lpEnd - lpSource);
}

int Shell32_StrCpyNA(LPSTR lpDest, LPSTR lpSource, int nBufSize)
{
    LPSTR lpEnd;
    CHAR cHold;

    if (nBufSize < 0)
        return(nBufSize);

    lpEnd = StrEndNA(lpSource, nBufSize);
    cHold = *lpEnd;
    *lpEnd = '\0';
    lstrcpyA(lpDest, lpSource);
    *lpEnd = cHold;
    
    return (int)(lpEnd - lpSource);
}


/*
 * StrNCmp      - Compare n characters
 *
 * returns   See lstrcmp return values.
 */
int StrNCmpW(LPWSTR lpStr1, LPWSTR lpStr2, int nChar)
{
    WCHAR cHold1, cHold2;
    int i;
    LPWSTR lpsz1 = lpStr1, lpsz2 = lpStr2;

    for (i = 0; i < nChar; i++)
    {
        /* If we hit the end of either string before the given number
        * of bytes, just return the comparison
        */
        if (!*lpsz1 || !*lpsz2)
            return(wcscmp(lpStr1, lpStr2));

        lpsz1 = CharNextW(lpsz1);
        lpsz2 = CharNextW(lpsz2);
    }

    cHold1 = *lpsz1;
    cHold2 = *lpsz2;
    *lpsz1 = *lpsz2 = WCHAR_NULL;
    i = wcscmp(lpStr1, lpStr2);
    *lpsz1 = cHold1;
    *lpsz2 = cHold2;

    return(i);
}

int StrNCmpA(LPSTR lpStr1, LPSTR lpStr2, int nChar)
{
    CHAR cHold1, cHold2;
    int i;
    LPSTR lpsz1 = lpStr1, lpsz2 = lpStr2;

    for (i = 0; i < nChar; i++)
    {
        /* If we hit the end of either string before the given number
        * of bytes, just return the comparison
        */
        if (!*lpsz1 || !*lpsz2)
            return(lstrcmpA(lpStr1, lpStr2));

        lpsz1 = CharNextA(lpsz1);
        lpsz2 = CharNextA(lpsz2);
    }

    cHold1 = *lpsz1;
    cHold2 = *lpsz2;
    *lpsz1 = *lpsz2 = '\0';
    i = lstrcmpA(lpStr1, lpStr2);
    *lpsz1 = cHold1;
    *lpsz2 = cHold2;

    return i;
}


/*
 * StrNCmpI     - Compare n characters, case insensitive
 *
 * returns   See lstrcmpi return values.
 */
int StrNCmpIW(LPWSTR lpStr1, LPWSTR lpStr2, int nChar)
{
    WCHAR cHold1, cHold2;
    int i;
    LPWSTR lpsz1 = lpStr1, lpsz2 = lpStr2;

    for (i = 0; i < nChar; i++)
    {
        /* If we hit the end of either string before the given number
        * of bytes, just return the comparison
        */
        if (!*lpsz1 || !*lpsz2)
            return(lstrcmpi(lpStr1, lpStr2));

        lpsz1 = CharNext(lpsz1);
        lpsz2 = CharNext(lpsz2);
    }

    cHold1 = *lpsz1;
    cHold2 = *lpsz2;
    *lpsz1 = *lpsz2 = WCHAR_NULL;
    i = _wcsicmp(lpStr1, lpStr2);
    *lpsz1 = cHold1;
    *lpsz2 = cHold2;

    return i;
}

int StrNCmpIA(LPSTR lpStr1, LPSTR lpStr2, int nChar)
{
    CHAR cHold1, cHold2;
    int i;
    LPSTR lpsz1 = lpStr1, lpsz2 = lpStr2;

    for (i = 0; i < nChar; i++)
    {
        /* If we hit the end of either string before the given number
        * of bytes, just return the comparison
        */
        if (!*lpsz1 || !*lpsz2)
            return(lstrcmpiA(lpStr1, lpStr2));

        lpsz1 = CharNextA(lpsz1);
        lpsz2 = CharNextA(lpsz2);
    }

    cHold1 = *lpsz1;
    cHold2 = *lpsz2;
    *lpsz1 = *lpsz2 = '\0';
    i = lstrcmpiA(lpStr1, lpStr2);
    *lpsz1 = cHold1;
    *lpsz2 = cHold2;

    return i;
}


/*
 * StrNCpy      - Copy n characters
 *
 * returns   Actual number of characters copied
 */
int StrNCpyW(LPWSTR lpDest, LPWSTR lpSource, int nChar)
{
    WCHAR cHold;
    int i;
    LPWSTR lpch = lpSource;

    if (nChar < 0)
        return(nChar);

    for (i = 0; i < nChar; i++)
    {
        if (!*lpch)
            break;

        lpch = CharNext(lpch);
    }

    cHold = *lpch;
    *lpch = WCHAR_NULL;
    wcscpy(lpDest, lpSource);
    *lpch = cHold;

    return i;
}

int StrNCpyA(LPSTR lpDest, LPSTR lpSource,int nChar)
{
    CHAR cHold;
    int i;
    LPSTR lpch = lpSource;

    if (nChar < 0)
        return(nChar);

    for (i = 0; i < nChar; i++)
    {
        if (!*lpch)
            break;

        lpch = CharNextA(lpch);
    }

    cHold = *lpch;
    *lpch = '\0';
    lstrcpyA(lpDest, lpSource);
    *lpch = cHold;
    
    return i;
}


/*
 * StrRStr      - Search for last occurrence of a substring
 *
 * Assumes   lpSource points to the null terminated source string
 *           lpLast points to where to search from in the source string
 *           lpLast is not included in the search
 *           lpSrch points to string to search for
 * returns   last occurrence of string if successful; NULL otherwise
 */
LPWSTR StrRStrW(LPWSTR lpSource, LPWSTR lpLast, LPWSTR lpSrch)
{
    int iLen;

    iLen = lstrlen(lpSrch);

    if (!lpLast)
    {
        lpLast = lpSource + lstrlen(lpSource);
    }

    do
    {
        /* Return NULL if we hit the exact beginning of the string
        */
        if (lpLast == lpSource)
            return(NULL);

        --lpLast;

        /* Break if we hit the beginning of the string
        */
        if (!lpLast)
            break;

        /* Break if we found the string, and its first byte is not a tail byte
        */
        if (!StrCmpNW(lpLast, lpSrch, iLen) && (lpLast==StrEndNW(lpSource, (int)(lpLast-lpSource))))
            break;
    }
    while (1);

    return lpLast;
}

LPSTR StrRStrA(LPSTR lpSource, LPSTR lpLast, LPSTR lpSrch)
{
    int iLen;

    iLen = lstrlenA(lpSrch);

    if (!lpLast)
    {
        lpLast = lpSource + lstrlenA(lpSource);
    }

    do
    {
        /* Return NULL if we hit the exact beginning of the string
        */
        if (lpLast == lpSource)
            return(NULL);

        --lpLast;

        /* Break if we hit the beginning of the string
        */
        if (!lpLast)
            break;

        /* Break if we found the string, and its first byte is not a tail byte
        */
        if (!StrCmpNA(lpLast, lpSrch, iLen) &&(lpLast==StrEndNA(lpSource, (int)(lpLast-lpSource))))
        {
            break;
        }
    }
    while (1);

    return lpLast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\makefile.inc ===
..\shell32.rc : $(PROJECT_ROOT)\lib\$(O)\shldisp.tlb $(SELFREGNAME) $(O)\cpview.ui $(O)\folder.ui

!include $(CCSHELL_DIR)\makefile.inc

$(O)\cpview.ui : $(O)\cpview.uipp
    cleaninf -w $(O)\cpview.uipp $(O)\cpview.ui

$(O)\cpview.uipp : ..\cpview.uix
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $@

$(O)\folder.ui : $(O)\folder.uipp
    cleaninf -w $(O)\folder.uipp $(O)\folder.ui

$(O)\folder.uipp : ..\folder.uix
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mixctnt.h ===
#ifndef MIXCTNT_H
#define MIXCTNT_H

BOOL _AddAutoplayPrompt(PCWSTR pszDriveOrDeviceID);
void _RemoveFromAutoplayPromptHDPA(LPCWSTR pszAltDeviceID);

void _SetAutoplayPromptHWND(LPCWSTR pszAltDeviceID, HWND hwnd);
BOOL _GetAutoplayPromptHWND(LPCWSTR pszAltDeviceID, HWND* phwnd);

EXTERN_C CRITICAL_SECTION g_csAutoplayPrompt;
extern HDPA g_hdpaAutoplayPrompt;

#endif //MIXCTNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\lvutil.h ===
// Drag the selected items in a ListView.  Other than hwndLV (the ListView
// window), the parameters are the same as those for ShellDragObjects.
//
STDAPI_(void) LVUtil_ScreenToLV(HWND hwndLV, POINT *ppt);
STDAPI_(void) LVUtil_ClientToLV(HWND hwndLV, POINT *ppt);
STDAPI_(void) LVUtil_LVToClient(HWND hwndLV, POINT *ppt);
STDAPI_(void) LVUtil_DragSelectItem(HWND hwndLV, int nItem);
STDAPI_(LPARAM) LVUtil_GetLParam(HWND hwndLV, int i);

STDAPI_(BOOL) DAD_SetDragImageFromWindow(HWND hwnd, POINT* ppt, IDataObject* pDataObject);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\malloc.c ===
#include "shellprv.h"
#pragma  hdrstop

extern const IMallocVtbl c_CShellMallocVtbl;

const IMalloc c_mem = { &c_CShellMallocVtbl };

STDMETHODIMP CShellMalloc_QueryInterface(IMalloc *pmem, REFIID riid, LPVOID * ppvObj)
{
    ASSERT(pmem == &c_mem);
    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IMalloc))
    {
        *ppvObj = pmem;
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CShellMalloc_AddRefRelease(IMalloc *pmem)
{
    ASSERT(pmem == &c_mem);
    return 1; // static object
}

STDMETHODIMP_(void *) CShellMalloc_Alloc(IMalloc *pmem, SIZE_T cb)
{
    ASSERT(pmem == &c_mem);
    return (void*)LocalAlloc(LPTR, cb);
}

//
//  IMalloc::Realloc is slightly different from LocalRealloc.
//
//  IMalloc::Realloc(NULL, 0) = return NULL
//  IMalloc::Realloc(pv, 0) = IMalloc::Free(pv)
//  IMalloc::Realloc(NULL, cb) = IMalloc::Alloc(cb)
//  IMalloc::Realloc(pv, cb) = LocalRealloc()
//
STDMETHODIMP_(void *) CShellMalloc_Realloc(IMalloc *pmem, void *pv, SIZE_T cb)
{
    ASSERT(pmem == &c_mem);

    if (cb == 0)
    {
        if (pv) LocalFree(pv);
        return NULL;
    }
    else if (pv == NULL)
    {
        return LocalAlloc(LPTR, cb);
    }
    else
        return LocalReAlloc(pv, cb, LMEM_MOVEABLE|LMEM_ZEROINIT);
}

//
//  IMalloc::Free is slightly different from LocalFree.
//
//  IMalloc::Free(NULL) - nop
//  IMalloc::Free(pv)   - LocalFree()
//
STDMETHODIMP_(void) CShellMalloc_Free(IMalloc *pmem, void *pv)
{
    ASSERT(pmem == &c_mem);
    if (pv) LocalFree(pv);
}

STDMETHODIMP_(SIZE_T) CShellMalloc_GetSize(IMalloc *pmem, void *pv)
{
    ASSERT(pmem == &c_mem);
    return LocalSize(pv);
}

STDMETHODIMP_(int) CShellMalloc_DidAlloc(IMalloc *pmem, void *pv)
{
    ASSERT(pmem == &c_mem);
    return -1;  // don't know
}

STDMETHODIMP_(void) CShellMalloc_HeapMinimize(IMalloc *pmem)
{
    ASSERT(pmem == &c_mem);
}

const IMallocVtbl c_CShellMallocVtbl = {
    CShellMalloc_QueryInterface, CShellMalloc_AddRefRelease, CShellMalloc_AddRefRelease,
    CShellMalloc_Alloc,
    CShellMalloc_Realloc,
    CShellMalloc_Free,
    CShellMalloc_GetSize,
    CShellMalloc_DidAlloc,
    CShellMalloc_HeapMinimize,
};


typedef HRESULT (STDAPICALLTYPE * LPFNCOGETMALLOC)(DWORD dwMemContext, IMalloc **ppmem);

IMalloc *g_pmemTask = NULL;     // No default task allocator.

#ifdef DEBUG
extern void WINAPI DbgRegisterMallocSpy();
#endif

// on DEBUG builds, mostly for NT, we force using OLE's task allocator at all times.
// for retail we only use OLE if ole32 is already loaded in this process.
//
// this is because OLE's DEBUG allocator will complain if we pass it LocalAlloc()ed
// memory. this can happen if we start up without OLE loaded, then delay load it.
// retail OLE uses LocalAlloc() so we can use our own allocator and switch
// on the fly with no complains from OLE in retail. a common case here would be
// using the file dialogs with notepad

void _GetTaskAllocator(IMalloc **ppmem)
{
    if (g_pmemTask == NULL)
    {
#ifndef DEBUG
        if (GetModuleHandle(TEXT("OLE32.DLL"))) // retail
#endif
        {
            CoGetMalloc(MEMCTX_TASK, &g_pmemTask);
        }

        if (g_pmemTask == NULL)
        {
            // use the shell task allocator (which is LocalAlloc).
            g_pmemTask = (IMalloc *)&c_mem; // const -> non const
        }
    }
    else
    {
        // handing out cached version, add ref it first
        g_pmemTask->lpVtbl->AddRef(g_pmemTask);
    }

    *ppmem = g_pmemTask;
}

//
// To be exported
//
STDAPI SHGetMalloc(IMalloc **ppmem)
{
    _GetTaskAllocator(ppmem);
    return NOERROR;
}

// BOGUS, NT redefines these to HeapAlloc variants...
#ifdef Alloc
#undef Alloc
#undef Free
#undef GetSize
#endif

__inline void FAST_GetTaskAllocator()
{
    IMalloc *pmem;
    if (g_pmemTask == NULL) {
        // perf: avoid calling unless really need to
        _GetTaskAllocator(&pmem);
        ASSERT(g_pmemTask != NULL);
        ASSERT(g_pmemTask == pmem);
    }
    // else n.b. no AddRef!  but we have a refcnt of >=1, and we never Release
    // so who cares...
    return;
}

STDAPI_(void *) SHAlloc(SIZE_T cb)
{
    FAST_GetTaskAllocator();
    return g_pmemTask->lpVtbl->Alloc(g_pmemTask, cb);
}

STDAPI_(void *) SHRealloc(LPVOID pv, SIZE_T cbNew)
{
    IMalloc *pmem;
    _GetTaskAllocator(&pmem);
    return pmem->lpVtbl->Realloc(pmem, pv, cbNew);
}

STDAPI_(void) SHFree(LPVOID pv)
{
    FAST_GetTaskAllocator();
    g_pmemTask->lpVtbl->Free(g_pmemTask, pv);
}

STDAPI_(SIZE_T) SHGetSize(LPVOID pv)
{
    IMalloc *pmem;
    _GetTaskAllocator(&pmem);
    return (SIZE_T) pmem->lpVtbl->GetSize(pmem, pv);
}

#ifdef DEBUG
void TaskMem_MakeInvalid(void)
{
    static IMalloc c_memDummy = { &c_CShellMallocVtbl };
    //
    // so we can catch calls to the allocator after PROCESS_DETATCH
    // which should be illegal because OLE32.DLL can be unloaded before our
    // DLL (unload order is not deterministic) we switch the allocator
    // to this dummy one that will cause our asserts to trip.
    //
    // note, runnin the dummy alllocator is actually fine as it will free
    // memory with LocalAlloc(), which is what the OLE alocator uses in all
    // cases except debug. and besides, our process is about to go away and
    // all process memory will be freed anyway!
    //
    g_pmemTask = &c_memDummy;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mixctnt.cpp ===
#include "shellprv.h"

#include "mixctnt.h"
#include "clsobj.h"
#include "apprmdlg.h"
#include "hwcmmn.h"
#include "ids.h"
#include "shpriv.h"
#include "mtptl.h"
#include "filetbl.h"

class CDeviceEventHandler : public IHWEventHandler
{
public:
    CDeviceEventHandler();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IHWEventHandler
    STDMETHODIMP Initialize(LPCWSTR pszParams);
    STDMETHODIMP HandleEvent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, LPCWSTR pszEventType);
    STDMETHODIMP HandleEventWithContent(LPCWSTR pszDeviceID,
        LPCWSTR pszAltDeviceID, LPCWSTR pszEventType,
        LPCWSTR pszContentTypeHandler, IDataObject* pdtobj);

private:
    ~CDeviceEventHandler();

    LONG _cRef;
    LPWSTR _pszParams;
};

CDeviceEventHandler::CDeviceEventHandler() : _cRef(1)
{
    DllAddRef();
}

CDeviceEventHandler::~CDeviceEventHandler()
{
    CoTaskMemFree(_pszParams)
    DllRelease();
}

STDAPI CDeviceEventHandler_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;
    
    // aggregation checking is handled in class factory
    CDeviceEventHandler* pHWMixedContent = new CDeviceEventHandler();
    if (pHWMixedContent)
    {
        hr = pHWMixedContent->QueryInterface(riid, ppv);
        pHWMixedContent->Release();
    }

    return hr;
}

// IUnknown
STDMETHODIMP CDeviceEventHandler::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CDeviceEventHandler, IHWEventHandler),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CDeviceEventHandler::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDeviceEventHandler::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// IHWEventHandler
STDMETHODIMP CDeviceEventHandler::Initialize(LPCWSTR pszParams)
{
    return SHStrDup(pszParams, &_pszParams);
}

DWORD WINAPI _PromptThreadProc(void* pv)
{
    CBaseContentDlg* pdlg = (CBaseContentDlg*)pv;

    if (IDOK == pdlg->DoModal(pdlg->_hinst, MAKEINTRESOURCE(pdlg->_iResource), pdlg->_hwndParent))
    {
        // Try to Autoplay this type handler
        IHWDevice* phwd;
        if (SUCCEEDED(_GetHWDevice(pdlg->_pszDeviceID, &phwd)))
        {
            phwd->AutoplayHandler(TEXT("DeviceArrival"), pdlg->_szHandler);
            phwd->Release();
        }
    }

    _RemoveFromAutoplayPromptHDPA(pdlg->_pszDeviceID);

    pdlg->Release();

    return 0;
}

HRESULT _Prompt(LPCWSTR pszDeviceID, LPCWSTR pszEventType, BOOL fCheckAlwaysDoThis)
{
    HRESULT hr;

    BOOL fShowDlg = _AddAutoplayPrompt(pszDeviceID);

    if (fShowDlg)
    {
        BOOL fDialogShown = FALSE;
        CBaseContentDlg* pdlg = new CNoContentDlg();

        if (pdlg)
        {
            pdlg->_szContentTypeHandler[0] = 0;
            pdlg->_hinst = g_hinst;
            pdlg->_iResource = DLG_APNOCONTENT;
            pdlg->_hwndParent = NULL;

            hr = pdlg->Init(pszDeviceID, NULL, 0, fCheckAlwaysDoThis);
            if (SUCCEEDED(hr))
            {
                if (SHCreateThread(_PromptThreadProc, pdlg, CTF_COINIT, NULL))
                {
                    fDialogShown = TRUE;
                }
                else
                {   
                    pdlg->Release();
                }
            }
            else
            {
                pdlg->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (!fDialogShown)
        {
            _RemoveFromAutoplayPromptHDPA(pszDeviceID);
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

STDMETHODIMP CDeviceEventHandler::HandleEvent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, LPCWSTR pszEventType)
{
    HRESULT hr = E_NOTIMPL;

    if (!lstrcmp(_pszParams, TEXT("PromptEachTimeNoContent")))
    {
        hr = _Prompt(pszDeviceID, pszEventType, FALSE);
    }
    else
    {
        // The '*' means to check the AlwaysDoThis checkbox!
        if (!lstrcmp(_pszParams, TEXT("PromptEachTimeNoContent*")))
        {
            hr = _Prompt(pszDeviceID, pszEventType, TRUE);
        }
    }

    return hr;
}

STDMETHODIMP CDeviceEventHandler::HandleEventWithContent(LPCWSTR pszDeviceID,
        LPCWSTR pszAltDeviceID, LPCWSTR pszEventType,
        LPCWSTR pszContentTypeHandler, IDataObject* pdtobj)
{
    return E_FAIL;
}


class CDeviceAutoPlayNotification : IQueryContinue
{
public:
    CDeviceAutoPlayNotification();
    void CreateNotificationThread();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IQueryContinue
    STDMETHODIMP QueryContinue();    // S_OK -> Continue, other 

    HRESULT Init(LPCTSTR pszDevice, LPCWSTR pszEventType, CCrossThreadFlag* pDeviceGoneFlag);

private:
    ~CDeviceAutoPlayNotification();

    void _DoNotificationUI();

    static DWORD CALLBACK s_ThreadProc(void *pv);

    LONG                _cRef;
    LPTSTR              _pszDevice;
    LPTSTR              _pszEventType;
    CCrossThreadFlag*   _pDeviceGoneFlag;
    BOOL                _fPoppedUpDlg;
};

CDeviceAutoPlayNotification::CDeviceAutoPlayNotification() : _cRef(1)
{}

HRESULT CDeviceAutoPlayNotification::Init(LPCTSTR pszDevice, LPCWSTR pszEventType,
    CCrossThreadFlag* pDeviceGoneFlag)
{
    HRESULT hr = S_OK;

    _pszDevice = StrDup(pszDevice);
    _pszEventType = StrDup(pszEventType);

    pDeviceGoneFlag->AddRef();
    _pDeviceGoneFlag = pDeviceGoneFlag;

    if (!_pszDevice || !_pszEventType)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

CDeviceAutoPlayNotification::~CDeviceAutoPlayNotification()
{
    LocalFree(_pszDevice);
    LocalFree(_pszEventType);

    if (_pDeviceGoneFlag)
    {
        _pDeviceGoneFlag->Release();
    }
}

HRESULT CDeviceAutoPlayNotification::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDeviceAutoPlayNotification, IQueryContinue),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CDeviceAutoPlayNotification::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDeviceAutoPlayNotification::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDeviceAutoPlayNotification::QueryContinue()
{
    HRESULT hr;

    if (_fPoppedUpDlg || _pDeviceGoneFlag->IsSignaled())
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

void CDeviceAutoPlayNotification::_DoNotificationUI()
{
    DWORD dwTimeOut = 30;

#ifdef DEBUG
    dwTimeOut = 60;
#endif

    IUserNotification *pun;
    HRESULT hr = CoCreateInstance(CLSID_UserNotification, NULL, CLSCTX_ALL, IID_PPV_ARG(IUserNotification, &pun));
    if (SUCCEEDED(hr))
    {
        IHWDeviceCustomProperties* pdcp;
        if (SUCCEEDED(GetDeviceProperties(_pszDevice, &pdcp)))
        {
            HICON hicon = NULL;

            WORD_BLOB* pblob;
            if (SUCCEEDED(pdcp->GetMultiStringProperty(TEXT("Icons"), TRUE, &pblob)))
            {
                TCHAR szLocation[MAX_PATH + 10];
                lstrcpyn(szLocation, pblob->asData, ARRAYSIZE(szLocation));
                int iIcon = PathParseIconLocation(szLocation);
                ExtractIconEx(szLocation, iIcon, NULL, &hicon, 1);
                CoTaskMemFree(pblob);
            }

            LPWSTR psz;
            if (SUCCEEDED(pdcp->GetStringProperty(TEXT("Label"), &psz)))
            {
                TCHAR szName[128];
                SHLoadIndirectString(psz, szName, ARRAYSIZE(szName), NULL);
                pun->SetIconInfo(hicon, szName);
                CoTaskMemFree(psz);
            }

            pdcp->Release();

            if (hicon)
                DestroyIcon(hicon);
        }

        pun->SetBalloonRetry(dwTimeOut * 1000, 0, 0);  // show for 30 sec, then go away

        hr = pun->Show(SAFECAST(this, IQueryContinue *), 1 * 1000); // 1 sec poll for callback

        pun->Release();

        if (S_OK == hr)
        {
            _Prompt(_pszDevice, _pszEventType, FALSE);
            _fPoppedUpDlg = TRUE;
        }
    }
}

DWORD CALLBACK CDeviceAutoPlayNotification::s_ThreadProc(void *pv)
{
    CDeviceAutoPlayNotification *pldsui = (CDeviceAutoPlayNotification *)pv;

    pldsui->_DoNotificationUI();
    pldsui->Release();

    return 0;
}

void CDeviceAutoPlayNotification::CreateNotificationThread()
{
    AddRef();

    if (!SHCreateThread(s_ThreadProc, this, CTF_COINIT, NULL))
    {
        Release();
    }
}

HRESULT DoDeviceNotification(LPCTSTR pszDevice, LPCTSTR pszEventType, CCrossThreadFlag* pDeviceGoneFlag)
{
    HRESULT hr;
    CDeviceAutoPlayNotification *pldsui = new CDeviceAutoPlayNotification();

    if (pldsui)
    {
        hr = pldsui->Init(pszDevice, pszEventType, pDeviceGoneFlag);

        if (SUCCEEDED(hr))
        {
            pldsui->CreateNotificationThread();
        }

        pldsui->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

template <typename TCALLBACKFCT, typename TCALLBACKARG, typename TCALLBACKRET>
BOOL _FindAutoplayStructAndExecuteCB(LPCWSTR pszDriveOrDeviceID, TCALLBACKFCT fct, TCALLBACKARG arg, TCALLBACKRET* pRet)
{
    BOOL fRet = FALSE;

    EnterCriticalSection(&g_csAutoplayPrompt);

    if (g_hdpaAutoplayPrompt)
    {
        int n = DPA_GetPtrCount(g_hdpaAutoplayPrompt);

        for (int i = 0; i < n; ++i)
        {
            AUTOPLAYPROMPT* pap = (AUTOPLAYPROMPT*)DPA_GetPtr(g_hdpaAutoplayPrompt, i);

            if (!lstrcmpi(pap->szDriveOrDeviceID, pszDriveOrDeviceID))
            {
                fRet = TRUE;

                *pRet = fct(pap, arg);

                break;
            }
        }    
    }

    LeaveCriticalSection(&g_csAutoplayPrompt);

    return fRet;
}

BOOL _AddAutoplayPromptEntry(LPCWSTR pszDriveOrDeviceID, BOOL fDlgWillBeShown)
{
    BOOL fFoundEntry = FALSE;
    BOOL fWasRunning = FALSE;
    EnterCriticalSection(&g_csAutoplayPrompt);

    if (g_hdpaAutoplayPrompt)
    {
        int n = DPA_GetPtrCount(g_hdpaAutoplayPrompt);

        for (int i = 0; i < n; ++i)
        {
            AUTOPLAYPROMPT* pap = (AUTOPLAYPROMPT*)DPA_GetPtr(g_hdpaAutoplayPrompt, i);

            if (!lstrcmpi(pap->szDriveOrDeviceID, pszDriveOrDeviceID))
            {
                fWasRunning = pap->fDlgWillBeShown;
                fFoundEntry = TRUE;

                if (!pap->fDlgWillBeShown)
                {
                    pap->fDlgWillBeShown = fDlgWillBeShown;
                }

                TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: Found entry for %s - (dlg = %d -> %d)",
                    pszDriveOrDeviceID, fWasRunning, pap->fDlgWillBeShown);

                break;
            }
        }    
    }

    if (!fFoundEntry)
    {
        if (!g_hdpaAutoplayPrompt)
        {
            g_hdpaAutoplayPrompt = DPA_Create(3);
        }

        if (g_hdpaAutoplayPrompt)
        {
            AUTOPLAYPROMPT* pap;

            if (SUCCEEDED(SHLocalAlloc(sizeof(AUTOPLAYPROMPT), &pap)))
            {
                lstrcpyn(pap->szDriveOrDeviceID, pszDriveOrDeviceID, ARRAYSIZE(pap->szDriveOrDeviceID));
                pap->fDlgWillBeShown = fDlgWillBeShown;

                TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: Adding entry for %s - (dlg = %d)",
                    pszDriveOrDeviceID, fDlgWillBeShown);

                if (-1 == DPA_AppendPtr(g_hdpaAutoplayPrompt, (void*)pap))
                {
                    LocalFree((HLOCAL)pap);
                }
                else
                {
                    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: Total # of entry: %d",
                        DPA_GetPtrCount(g_hdpaAutoplayPrompt));
                }
            }
        }
    }

    LeaveCriticalSection(&g_csAutoplayPrompt);

    return !fWasRunning;
}

BOOL _AddAutoplayPrompt(LPCWSTR pszDriveOrDeviceID)
{
    return _AddAutoplayPromptEntry(pszDriveOrDeviceID, TRUE);
}

void _RemoveFromAutoplayPromptHDPA(LPCWSTR pszAltDeviceID)
{
    EnterCriticalSection(&g_csAutoplayPrompt);

    if (g_hdpaAutoplayPrompt)
    {
        int n = DPA_GetPtrCount(g_hdpaAutoplayPrompt);

        for (int i = 0; i < n; ++i)
        {
            AUTOPLAYPROMPT* pap = (AUTOPLAYPROMPT*)DPA_GetPtr(g_hdpaAutoplayPrompt, i);

            if (!lstrcmpi(pap->szDriveOrDeviceID, pszAltDeviceID))
            {
                TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: Removing %s",
                    pap->szDriveOrDeviceID);

                if (pap->pDeviceGoneFlag)
                {
                    pap->pDeviceGoneFlag->Release();
                }

                LocalFree((HLOCAL)pap);

                DPA_DeletePtr(g_hdpaAutoplayPrompt, i);

                TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: Total # of entry: %d",
                    DPA_GetPtrCount(g_hdpaAutoplayPrompt));

                break;
            }
        }            
    }

    LeaveCriticalSection(&g_csAutoplayPrompt);
}

// Set/Get HWND
typedef BOOL (*PFNSETAAUTOPLAYPROMPTHWNDCB)(AUTOPLAYPROMPT* pap, HWND hwnd);

BOOL _SetAutoplayPromptHWNDCB(AUTOPLAYPROMPT* pap, HWND hwnd)
{
    pap->hwndDlg = hwnd;

    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: SetHWND for %s - (dlg = %d)",
        pap->szDriveOrDeviceID, pap->fDlgWillBeShown);

    return TRUE;
}

void _SetAutoplayPromptHWND(LPCWSTR pszAltDeviceID, HWND hwnd)
{
    BOOL fRet;

    _FindAutoplayStructAndExecuteCB<PFNSETAAUTOPLAYPROMPTHWNDCB, HWND, BOOL>
        (pszAltDeviceID, _SetAutoplayPromptHWNDCB, hwnd, &fRet);
}

typedef BOOL (*PFNGETAAUTOPLAYPROMPTHWNDCB)(AUTOPLAYPROMPT* pap, HWND* phwnd);

BOOL _GetAutoplayPromptHWNDCB(AUTOPLAYPROMPT* pap, HWND* phwnd)
{
    *phwnd = pap->hwndDlg;

    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: GetHWND for %s - (dlg = %d)",
        pap->szDriveOrDeviceID, pap->fDlgWillBeShown);

    return TRUE;
}

BOOL _GetAutoplayPromptHWND(LPCWSTR pszAltDeviceID, HWND* phwnd)
{
    BOOL fRet;

    return _FindAutoplayStructAndExecuteCB<PFNGETAAUTOPLAYPROMPTHWNDCB, HWND*, BOOL>
        (pszAltDeviceID, _GetAutoplayPromptHWNDCB, phwnd, &fRet);
}

// Set/Get DeviceGoneFlag
typedef BOOL (*PFNSETDEVICEGONEFLAGCB)(AUTOPLAYPROMPT* pap, CCrossThreadFlag* pDeviceGoneFlag);

BOOL _SetDeviceGoneFlagCB(AUTOPLAYPROMPT* pap, CCrossThreadFlag* pDeviceGoneFlag)
{
    pap->pDeviceGoneFlag = pDeviceGoneFlag;

    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: SetDeviceGoneFlag for %s - (dlg = %d)",
        pap->szDriveOrDeviceID, pap->fDlgWillBeShown);

    return TRUE;
}

void AttachGoneFlagForDevice(LPCWSTR pszAltDeviceID, CCrossThreadFlag* pDeviceGoneFlag)
{
    BOOL fRet;

    if (!_FindAutoplayStructAndExecuteCB<PFNSETDEVICEGONEFLAGCB, CCrossThreadFlag*, BOOL>
        (pszAltDeviceID, _SetDeviceGoneFlagCB, pDeviceGoneFlag, &fRet))
    {
        _AddAutoplayPromptEntry(pszAltDeviceID, FALSE);

        if (_FindAutoplayStructAndExecuteCB<PFNSETDEVICEGONEFLAGCB, CCrossThreadFlag*, BOOL>
                (pszAltDeviceID, _SetDeviceGoneFlagCB, pDeviceGoneFlag, &fRet))
        {
            if (fRet)
            {
                pDeviceGoneFlag->AddRef();
            }
        }
    }
}

typedef BOOL (*PFNGETDEVICEGONEFLAGCB)(AUTOPLAYPROMPT* pap, CCrossThreadFlag** ppDeviceGoneFlag);

BOOL _GetDeviceGoneFlagCB(AUTOPLAYPROMPT* pap, CCrossThreadFlag** ppDeviceGoneFlag)
{
    *ppDeviceGoneFlag = pap->pDeviceGoneFlag;

    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: GetDeviceGoneFlag for %s - (dlg = %d)",
        pap->szDriveOrDeviceID, pap->fDlgWillBeShown);

    return !!(*ppDeviceGoneFlag);
}

BOOL GetGoneFlagForDevice(LPCWSTR pszAltDeviceID, CCrossThreadFlag** ppDeviceGoneFlag)
{
    BOOL fRet;

    if (_FindAutoplayStructAndExecuteCB<PFNGETDEVICEGONEFLAGCB, CCrossThreadFlag**, BOOL>
        (pszAltDeviceID, _GetDeviceGoneFlagCB, ppDeviceGoneFlag, &fRet))
    {
        (*ppDeviceGoneFlag)->AddRef();
    }
    else
    {
        TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: GetDeviceGoneFlag for %s -> Did not find!",
            pszAltDeviceID);

        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mergfldr.cpp ===
#include "shellprv.h"
#pragma  hdrstop
#include "clsobj.h"

#include "ids.h"
#include <cowsite.h>
#include "datautil.h"
#include "idhidden.h"
#include "prop.h"
#include "stgutil.h"
#include "sfstorage.h"
#include "util.h"
#include "fstreex.h"
#include "basefvcb.h"
#include "category.h"
#include "mergfldr.h"
#include "filefldr.h"
#include "idldata.h"
#include "defcm.h"

#define TF_AUGM 0x10000000


// pidl wrapper contains a TAG word for validation and then
// the count for the number of packaged pidl object.
//
// each pidl has a hidden payload which is the name space
// index that it originated from. 

#pragma pack(1)
typedef struct 
{
    USHORT      cb;         // pidl wrap length 
    USHORT      dwFlags;    // flags
    ULONG       ulTag;      // signature
    ULONG       ulVersion ; // AugMergeISF pidl version
    ULONG       cSrcs;      // Number of source _Namespace objects backing this composite pidl
} AUGM_IDWRAP;
typedef UNALIGNED AUGM_IDWRAP *PAUGM_IDWRAP;

typedef struct  
{
    HIDDENITEMID hid;
    UINT    uSrcID;         // src _Namespace
} AUGM_NAMESPACE;
typedef UNALIGNED AUGM_NAMESPACE *PAUGM_NAMESPACE;
#pragma pack()

#define AUGM_NS_CURRENTVERSION  0
#define AUGM_WRAPVERSION_1_0    MAKELONG(1, 0)
#define AUGM_WRAPVERSION_2_0    MAKELONG(2, 0)

#define AUGM_WRAPCURRENTVERSION AUGM_WRAPVERSION_2_0

#define AUGM_WRAPTAG            MAKELONG(MAKEWORD('A','u'), MAKEWORD('g','M'))
#define CB_IDLIST_TERMINATOR    sizeof(USHORT)

// dwFlags field flags
#define AUGMF_ISSIMPLE          0x0001


// helpers.

HRESULT CMergedFldrContextMenu_CreateInstance(HWND hwnd, CMergedFolder *pmf, UINT cidl, LPCITEMIDLIST *apidl, IContextMenu *pcmCommon, IContextMenu *pcmUser, IContextMenu **ppcm);
HRESULT CMergedFldrEnum_CreateInstance(CMergedFolder*pmf, DWORD grfFlags, IEnumIDList **ppenum);
HRESULT CMergedFldrDropTarget_CreateInstance(CMergedFolder*pmf, HWND hwnd, IDropTarget **ppdt);
HRESULT CMergedFolderViewCB_CreateInstance(CMergedFolder *pmf, IShellFolderViewCB **ppsfvcb);

// Helper function that spans all objects
BOOL AffectAllUsers(HWND hwnd)
{
    BOOL bRet = FALSE;  // default to NO
    if (hwnd)
    {
        TCHAR szMessage[255];
        TCHAR szTitle[20];

        if (LoadString(HINST_THISDLL, IDS_ALLUSER_WARNING, szMessage, ARRAYSIZE(szMessage)) > 0 &&
            LoadString(HINST_THISDLL, IDS_WARNING, szTitle, ARRAYSIZE(szTitle)) > 0)
        {
            bRet = (IDYES == MessageBox(hwnd, szMessage, szTitle, MB_YESNO | MB_ICONINFORMATION));
        }
    }
    else
        bRet = TRUE;    // NULL hwnd implies NO UI, say "yes"
    return bRet;
}



//  CMergedFoldersource _Namespace descriptor.
//
//  Objects of class CMergedFldrNamespace are created by CMergedFolderin 
//  the AddNameSpace() method impl, and are maintained in the collection
//  CMergedFolder::_hdpaNamespaces.
//

class CMergedFldrNamespace
{
public:
    CMergedFldrNamespace();
    ~CMergedFldrNamespace();

    IShellFolder* Folder() const
        { return _psf; }
    REFGUID GetGUID() const
        { return _guid; }
    ULONG FolderAttrib() const  
        { return _dwAttrib; }
    LPCITEMIDLIST GetIDList() const 
        { return _pidl; }
    HRESULT GetLocation(LPWSTR pszBuffer, INT cchBuffer)
        { StrCpyN(pszBuffer, _szLocation, cchBuffer); return S_OK; };
    LPCWSTR GetDropFolder()
        { return _szDrop; };
    ULONG FixItemAttributes(ULONG attrib)
        { return (attrib & _dwItemAttribMask) | _dwItemAttrib; }
    DWORD GetDropEffect(void) const
        { return _dwDropEffect; }
    int GetDefaultOverlayIndex() const
        { return _iDefaultOverlayIndex; }
    int GetConflictOverlayIndex() const
        { return _iConflictOverlayIndex; }
    int GetNamespaceOverlayIndex(LPCITEMIDLIST pidl);
    
    HRESULT SetNamespace(const GUID * pguidUIObject, IShellFolder* psf, LPCITEMIDLIST pidl, ULONG dwAttrib);
    HRESULT SetDropFolder(LPCWSTR pszDrop);
    HRESULT RegisterNotify(HWND, UINT, ULONG);
    HRESULT UnregisterNotify();
    BOOL SetOwner(IUnknown *punk);
    
protected:
    ULONG _RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive);
    void _ReleaseNamespace();

    IShellFolder* _psf;             // IShellFolder interface pointer
    GUID _guid;                     // optional GUID for specialized UI handling
    LPITEMIDLIST _pidl;             // optional pidl
    ULONG  _dwAttrib;               // optional flags
    UINT _uChangeReg;               // Shell change notify registration ID.

    WCHAR _szLocation[MAX_PATH];    // Location to use for object
    WCHAR _szDrop[MAX_PATH];        // folder that gets the forced drop effect
    DWORD _dwItemAttrib;            // OR mask for the attributes
    DWORD _dwItemAttribMask;        // AND mask for the attributes
    DWORD _dwDropEffect;            // default drop effect for this folder
    int   _iDefaultOverlayIndex;    // overlay icon index for default
    int   _iConflictOverlayIndex;   // overlay icon index if the name exists in another namespace
};

CMergedFldrNamespace::CMergedFldrNamespace() :
    _dwItemAttribMask(-1)
{
}

inline CMergedFldrNamespace::~CMergedFldrNamespace()
{ 
    UnregisterNotify();
    _ReleaseNamespace();
}

HRESULT CMergedFldrNamespace::SetNamespace(const GUID * pguidUIObject, IShellFolder* psf, LPCITEMIDLIST pidl, ULONG dwAttrib)
{
    _ReleaseNamespace();

    // store the IShellFolder object if we have one
    if (psf)
    {
        _psf = psf;
        _psf->AddRef();
    }
    else if (pidl)
    {
        SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, &_psf));
    }

    // get the IDLIST that this namespace represnets
    if (pidl)
    {
        _pidl = ILClone(pidl);      // we have a PIDL passed to us.
    }
    else
    {
        _pidl = NULL;
        IPersistFolder3 *ppf3;
        if (SUCCEEDED(_psf->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf3))))
        {
            PERSIST_FOLDER_TARGET_INFO pfti;
            if (SUCCEEDED(ppf3->GetFolderTargetInfo(&pfti)))
            {
                _pidl = pfti.pidlTargetFolder;
            }
            ppf3->Release();
        }

        // if it doesnt have IPersistFolder3 or if there's no target folder then
        // fall back to IPersistFolder2
        if (!_pidl)
        {
            SHGetIDListFromUnk(psf, &_pidl);
        }
    }

    if (!_psf || !_pidl)
        return E_FAIL;

    // now fill out the information about the namespace, including getting the display
    // information from the registry

    _guid = pguidUIObject ? *pguidUIObject : GUID_NULL;
    _dwAttrib = dwAttrib;

    _szLocation[0] = TEXT('\0');
    _dwItemAttrib = 0;                  // item attribute become a NOP
    _dwItemAttribMask = (DWORD)-1;
    _dwDropEffect = 0;                  // default behaviour
    _iDefaultOverlayIndex = -1;
    _iConflictOverlayIndex = -1;

    // format a key to the property bag stored in the registry, then create the
    // property bag which we then query against.

    TCHAR szKey[MAX_PATH], szGUID[GUIDSTR_MAX+1];
    SHStringFromGUID(_guid, szGUID, ARRAYSIZE(szGUID));
    wsprintf(szKey, TEXT("CLSID\\%s\\MergedFolder"), szGUID);

    IPropertyBag *ppb;
    if (SUCCEEDED(SHCreatePropertyBagOnRegKey(HKEY_CLASSES_ROOT, szKey, STGM_READ, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        TCHAR szLocalized[100];
        if (SUCCEEDED(SHPropertyBag_ReadStr(ppb, L"Location", szLocalized, ARRAYSIZE(szLocalized))))
        {
            SHLoadIndirectString(szLocalized, _szLocation, ARRAYSIZE(_szLocation), NULL);
        }

        SHPropertyBag_ReadDWORD(ppb, L"Attributes", &_dwItemAttrib);
        SHPropertyBag_ReadDWORD(ppb, L"AttributeMask", &_dwItemAttribMask);
        SHPropertyBag_ReadDWORD(ppb, L"DropEffect", &_dwDropEffect);

        TCHAR szIconLocation[MAX_PATH];
        szIconLocation[0] = 0;
        SHPropertyBag_ReadStr(ppb, L"DefaultOverlayIcon", szIconLocation, ARRAYSIZE(szIconLocation));
        _iDefaultOverlayIndex = SHGetIconOverlayIndex(szIconLocation, PathParseIconLocation(szIconLocation));

        szIconLocation[0] = 0;
        SHPropertyBag_ReadStr(ppb, L"ConflictOverlayIcon", szIconLocation, ARRAYSIZE(szIconLocation));
        _iConflictOverlayIndex = SHGetIconOverlayIndex(szIconLocation, PathParseIconLocation(szIconLocation));

        ppb->Release();
    }

    if (!SHGetPathFromIDList(_pidl, _szDrop))
    {
        _szDrop[0] = 0;
    }

    return S_OK;
}

HRESULT CMergedFldrNamespace::SetDropFolder(LPCWSTR pszDrop)
{
    StrCpyN(_szDrop, pszDrop, ARRAYSIZE(_szDrop));
    return S_OK;
}

void CMergedFldrNamespace::_ReleaseNamespace()
{
    ATOMICRELEASE(_psf); 
    ILFree(_pidl);
    _pidl = NULL;
    _guid = GUID_NULL;
    _dwAttrib = 0L;
}

ULONG CMergedFldrNamespace::_RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive)
{
    SHChangeNotifyEntry fsne = { 0 };
    fsne.fRecursive = fRecursive;
    fsne.pidl = pidl;
    return SHChangeNotifyRegister(hwnd, uFlags | SHCNRF_NewDelivery, dwEvents, nMsg, 1, &fsne);
}


//  Register change notification for the _Namespace
HRESULT CMergedFldrNamespace::RegisterNotify(HWND hwnd, UINT uMsg, ULONG lEvents)
{
    if (0 == _uChangeReg)
    {
        _uChangeReg = _RegisterNotify(hwnd, uMsg, _pidl, lEvents,
                                       SHCNRF_ShellLevel | SHCNRF_InterruptLevel | SHCNRF_RecursiveInterrupt,
                                       TRUE);
    }

    return 0 != _uChangeReg ? S_OK : E_FAIL;
}

// Unregister change notification for the _Namespace
HRESULT CMergedFldrNamespace::UnregisterNotify()
{
    if (_uChangeReg)
    {
        ::SHChangeNotifyDeregister(_uChangeReg);
        _uChangeReg = 0;
    }
    return S_OK;
}

inline BOOL CMergedFldrNamespace::SetOwner(IUnknown *punkOwner)
{
    if (!_psf)
        return FALSE;

    IUnknown_SetOwner(_psf, punkOwner);
    return TRUE;
}

int CMergedFldrNamespace::GetNamespaceOverlayIndex(LPCITEMIDLIST pidl)
{
    int iIndex = -1;
    if (_psf)
    {
        IShellIconOverlay *psio;
        if (SUCCEEDED(_psf->QueryInterface(IID_PPV_ARG(IShellIconOverlay, &psio))))
        {
            psio->GetOverlayIndex(pidl, &iIndex);
            psio->Release();
        }
    }
    return iIndex;
}

// object which takes ownership of the IDLIST and handles wrapping and returning information from it.

class CMergedFldrItem
{
public:
    ~CMergedFldrItem();
    BOOL Init(IShellFolder* psf, LPITEMIDLIST pidl, int iNamespace);
    BOOL Init(CMergedFldrItem *pmfi);

    BOOL SetDisplayName(LPTSTR pszDispName)
            { return Str_SetPtr(&_pszDisplayName, pszDispName); }
    ULONG GetFolderAttrib()
            { return _rgfAttrib; }
    LPTSTR GetDisplayName()
            { return _pszDisplayName; }
    LPITEMIDLIST GetIDList()
            { return _pidlWrap; }
    int GetNamespaceID()
            { return _iNamespace; }

private:
    ULONG _rgfAttrib;
    LPTSTR _pszDisplayName;
    LPITEMIDLIST _pidlWrap;
    int    _iNamespace;

    friend CMergedFolder;
};

CMergedFldrItem::~CMergedFldrItem()
{   
    Str_SetPtr(&_pszDisplayName, NULL);
    ILFree(_pidlWrap);
}

BOOL CMergedFldrItem::Init(CMergedFldrItem *pmfi)
{
    _iNamespace = pmfi->_iNamespace;
    _pidlWrap = ILClone(pmfi->GetIDList());
    BOOL fRet = (_pidlWrap != NULL);
    if (fRet)
    {
        fRet = SetDisplayName(pmfi->GetDisplayName());
        _rgfAttrib = pmfi->GetFolderAttrib();
    }

    return fRet;
}

BOOL CMergedFldrItem::Init(IShellFolder* psf, LPITEMIDLIST pidl, int iNamespace)
{
    BOOL fRet = FALSE;

    _pidlWrap = pidl;                               // evil, hold an alias
    _rgfAttrib = SFGAO_FOLDER | SFGAO_HIDDEN;
    _iNamespace = iNamespace;

    if (SUCCEEDED(psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidl, &_rgfAttrib)))
    {
        TCHAR szDisplayName[MAX_PATH];
        if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szDisplayName, ARRAYSIZE(szDisplayName))))
        {
            fRet = SetDisplayName(szDisplayName);
        }
    }
    return fRet;
}


// shell folder object.
CMergedFolder::CMergedFolder(CMergedFolder *pmfParent, REFCLSID clsid) : 
        _clsid(clsid),
        _cRef(1), 
        _pmfParent(pmfParent),
        _iColumnOffset(-1)
{
    ASSERT(_hdpaNamespaces == NULL);
    if (_pmfParent)
    {
        _pmfParent->AddRef();
        _fDontMerge = _pmfParent->_fDontMerge;
        _fCDBurn = _pmfParent->_fCDBurn;
        _fInShellView = _pmfParent->_fInShellView;
        _dwDropEffect = _pmfParent->_dwDropEffect;
    }
    else
    {
        _fDontMerge = IsEqualCLSID(_clsid, CLSID_CompositeFolder);
        _fCDBurn = IsEqualCLSID(_clsid, CLSID_CDBurnFolder);
    }

    DllAddRef();
}

CMergedFolder::~CMergedFolder()
{
    SetOwner(NULL);
    ILFree(_pidl);
    _FreeNamespaces();
    _FreeObjects();
    ATOMICRELEASE(_pmfParent);
    ATOMICRELEASE(_pstg);
    DllRelease();
}

// CMergedFolderglobal CreateInstance method for da class factory
HRESULT CMergedFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    // aggregation checking is handled in class factory
    HRESULT hr = E_OUTOFMEMORY;
    CMergedFolder* pmf = new CMergedFolder(NULL, CLSID_MergedFolder);
    if (pmf)
    {
        hr = pmf->QueryInterface(riid, ppv);
        pmf->Release();
    }
    return hr;
}

HRESULT CCompositeFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    // aggregation checking is handled in class factory
    HRESULT hr = E_OUTOFMEMORY;
    CMergedFolder* pmf = new CMergedFolder(NULL, CLSID_CompositeFolder);
    if (pmf)
    {
        hr = pmf->QueryInterface(riid, ppv);
        pmf->Release();
    }
    return hr;
}

#ifdef TESTING_COMPOSITEFOLDER
COMPFOLDERINIT s_rgcfiTripleD[] = {
    {CFITYPE_CSIDL, CSIDL_DRIVES, L"Drives"},
    {CFITYPE_PIDL, (int)&c_idlDesktop, L"Desktop"},
    {CFITYPE_PATH, (int)L"::{450d8fba-ad25-11d0-98a8-0800361b1103}", L"MyDocs"}
};

STDAPI CTripleD_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    ICompositeFolder *pcf;
    HRESULT hr = CCompositeFolder_CreateInstance(punkOuter, IID_PPV_ARG(ICompositeFolder, &pcf));

    if (SUCCEEDED(hr))
    {
        hr = pcf->InitComposite(0x8877, CLSID_TripleD, CFINITF_FLAT, ARRAYSIZE(s_rgcfiTripleD), s_rgcfiTripleD);

        if (SUCCEEDED(hr))
        {
            hr = pcf->QueryInterface(riid, ppv);
        }
        pcf->Release();
    }

    return hr;
}
#endif //TESTING_COMPOSITEFOLDER


STDMETHODIMP CMergedFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CMergedFolder, IShellFolder, IAugmentedShellFolder),
        QITABENT     (CMergedFolder, IAugmentedShellFolder),
        QITABENT     (CMergedFolder, IAugmentedShellFolder2),
        QITABENT     (CMergedFolder, IAugmentedShellFolder3),
        QITABENT     (CMergedFolder, IShellFolder2),
        QITABENT     (CMergedFolder, IShellService),
        QITABENT     (CMergedFolder, ITranslateShellChangeNotify),
        QITABENT     (CMergedFolder, IStorage),
        QITABENT     (CMergedFolder, IShellIconOverlay),
        QITABENTMULTI(CMergedFolder, IPersist, IPersistFolder2),
        QITABENTMULTI(CMergedFolder, IPersistFolder, IPersistFolder2),
        QITABENT     (CMergedFolder, IPersistFolder2),
        QITABENT     (CMergedFolder, IPersistPropertyBag),
        QITABENT     (CMergedFolder, ICompositeFolder),
        QITABENT     (CMergedFolder, IItemNameLimits),
        { 0 },
    };
    if (IsEqualIID(CLSID_MergedFolder, riid))
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMergedFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMergedFolder::Release()
{
    if (InterlockedDecrement(&_cRef)) 
        return _cRef;

    delete this;
    return 0;
}


// get the count from the enumerated items.
int CMergedFolder::_ObjectCount() const
{
    return _hdpaObjects ? DPA_GetPtrCount(_hdpaObjects) : 0;
}

CMergedFldrItem *CMergedFolder::_GetObject(int i)
{
    return _hdpaObjects ? (CMergedFldrItem *)DPA_GetPtr(_hdpaObjects, i) : NULL;
}

int CMergedFolder::_NamespaceCount() const 
{
    return _hdpaNamespaces ? DPA_GetPtrCount(_hdpaNamespaces) : 0;
}


//  Retrieves a pointer to a source _Namespace descriptor associated with 
//  the specified lookup index.

HRESULT CMergedFolder::_Namespace(int iIndex, CMergedFldrNamespace **ppns)
{
    *ppns = NULL;
    if ((iIndex >= 0) && (iIndex < _NamespaceCount()))
        *ppns = _Namespace(iIndex);
    return *ppns ? S_OK : E_INVALIDARG;
}


// given an index for the name space return it.
CMergedFldrNamespace* CMergedFolder::_Namespace(int iNamespace)
{
    if (!_hdpaNamespaces)
        return NULL;

    return (CMergedFldrNamespace*)DPA_GetPtr(_hdpaNamespaces, iNamespace);
}

// Determine whether pidls from the two namespaces should be merged
// The NULL namespace is a wildcard that always merges (if merging is permitted at all)
BOOL CMergedFolder::_ShouldMergeNamespaces(CMergedFldrNamespace *pns1, CMergedFldrNamespace *pns2)
{
    // Early-out:  Identical namespaces can be merged (even if merging
    //             is globally disabled)
    if (pns1 == pns2)
    {
        return TRUE;
    }

    // Early-out:  Merging globally disabled
    if (_fDontMerge)
    {
        return FALSE;
    }

    // Early-out:  Merging globally enabled
    if (!_fPartialMerge)
    {
        return TRUE;
    }

    if (!pns1 || !pns2)
    {
        return TRUE;                // wildcard
    }

    if (!(pns1->FolderAttrib() & ASFF_MERGESAMEGUID))
    {
        // this namespace will merge with anybody!
        return TRUE;
    }

    // Source namespace will merge only with namespaces of the same GUID
    // See if destination namespace has the same GUID
    return IsEqualGUID(pns1->GetGUID(), pns2->GetGUID());
}

// Determine whether pidls from the two namespaces should be merged
// NAmespace -1 is a wildcard that always merges (if merging is permitted at all)
BOOL CMergedFolder::_ShouldMergeNamespaces(int iNS1, int iNS2)
{
    // Early-out:  Merging globally disabled
    if (_fDontMerge)
    {
        return FALSE;
    }

    // Early-out:  Merging globally enabled
    if (!_fPartialMerge)
    {
        return TRUE;
    }

    if (iNS1 < 0 || iNS2 < 0)
    {
        return TRUE;                // wildcard
    }

    return _ShouldMergeNamespaces(_Namespace(iNS1), _Namespace(iNS2));
}


// check to see if the IDLIST we are given is a wrapped one.
HRESULT CMergedFolder::_IsWrap(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_INVALIDARG;
    if (pidl)
    {
        ASSERT(IS_VALID_PIDL(pidl));
        PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)pidl;

        if ((pWrap->cb >= sizeof(AUGM_IDWRAP)) &&
            (pWrap->ulTag == AUGM_WRAPTAG) &&
            (pWrap->ulVersion == AUGM_WRAPVERSION_2_0))
        {
            hr = S_OK;
        }
        else if (ILFindHiddenID(pidl, IDLHID_PARENTFOLDER))
        {
            hr = S_OK;
        }
    }
    return hr;
}


//  STRRET_OFFSET has no meaning in context of the pidl wrapper.
//  We can either calculate the offset into the wrapper, or allocate
//  a wide char for the name.  For expedience, we'll allocate the name.

HRESULT CMergedFolder::_FixStrRetOffset(LPCITEMIDLIST pidl, STRRET *psr)
{
    HRESULT hr = S_OK;

    if (psr->uType == STRRET_OFFSET)
    {
        UINT cch = lstrlenA(STRRET_OFFPTR(pidl, psr));
        LPWSTR pwszName = (LPWSTR)SHAlloc((cch + 1) * sizeof(WCHAR));
        if (pwszName)
        {
            SHAnsiToUnicode(STRRET_OFFPTR(pidl, psr), pwszName, cch + 1);
            pwszName[cch] = 0;
            psr->pOleStr = pwszName;
            psr->uType   = STRRET_WSTR;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}


// is the object a folder?
BOOL CMergedFolder::_IsFolder(LPCITEMIDLIST pidl)
{
    ULONG rgf = SFGAO_FOLDER | SFGAO_STREAM;
    return SUCCEEDED(GetAttributesOf(1, &pidl, &rgf)) && (SFGAO_FOLDER == (rgf & (SFGAO_FOLDER | SFGAO_STREAM)));
}


// does this IDLIST contain the common item.
BOOL CMergedFolder::_ContainsCommonItem(LPCITEMIDLIST pidlWrap)
{
    BOOL bCommonItem = FALSE;
    LPITEMIDLIST pidl;
    CMergedFldrNamespace *pns;
    for (UINT i = 0; !bCommonItem && SUCCEEDED(_GetSubPidl(pidlWrap, i, NULL, &pidl, &pns)); i++)
    {
        bCommonItem = (pns->FolderAttrib() & ASFF_COMMON);
        ILFree(pidl);
    }
    return bCommonItem;
}


// the number of source _Namespace pidls in the wrap.
ULONG CMergedFolder::_GetSourceCount(LPCITEMIDLIST pidl)
{
    if (SUCCEEDED(_IsWrap(pidl)))
    {
        if (ILFindHiddenID(pidl, IDLHID_PARENTFOLDER))
        {
            return 1;
        }
        else
        {
            PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)pidl;
            return pWrap->cSrcs;    
        }
    }
    return 0;
}

// Creates an IDLIST for CMergedFolder that wraps a single source pidl.
HRESULT CMergedFolder::_CreateWrap(LPCITEMIDLIST pidlSrc, UINT nSrcID, LPITEMIDLIST *ppidlWrap)
{
    *ppidlWrap = NULL;              // incase of failure

    LPITEMIDLIST pidlSrcWithID;
    HRESULT hr = SHILClone(pidlSrc, &pidlSrcWithID);
    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;
        if (!ILFindHiddenID(pidlSrcWithID, IDLHID_PARENTFOLDER))
        {
            AUGM_NAMESPACE ans = { {sizeof(ans), AUGM_NS_CURRENTVERSION, IDLHID_PARENTFOLDER} , nSrcID };
            pidlSrcWithID = ILAppendHiddenID((LPITEMIDLIST)pidlSrcWithID, &ans.hid);
        }

        if (pidlSrcWithID)
        {
            UINT cbAlloc = sizeof(AUGM_IDWRAP) + CB_IDLIST_TERMINATOR +      // header for our IDLIST
                           pidlSrcWithID->mkid.cb + CB_IDLIST_TERMINATOR;   // wrapped IDLIST

            AUGM_IDWRAP *pWrap = (AUGM_IDWRAP *)_ILCreate(cbAlloc);
            if (pWrap)
            {
                // fill out wrapped header
                pWrap->cb = (USHORT)(cbAlloc - CB_IDLIST_TERMINATOR);
                pWrap->dwFlags = 0;
                pWrap->ulTag = AUGM_WRAPTAG;
                pWrap->ulVersion = AUGM_WRAPVERSION_2_0;
                pWrap->cSrcs = 1;
        
                // copy the IDLIST with the hidden data into the wrapping object
                LPITEMIDLIST pidl = (LPITEMIDLIST)((BYTE *)pWrap + sizeof(AUGM_IDWRAP));
                memcpy(pidl, pidlSrcWithID, pidlSrcWithID->mkid.cb);
                *ppidlWrap = (LPITEMIDLIST)pWrap;
                hr = S_OK;
            }

            ILFree(pidlSrcWithID);
        }
    }

    return hr;
}

// does the wrapped IDLIST we are passed contain the given source ID?
BOOL CMergedFolder::_ContainsSrcID(LPCITEMIDLIST pidl, UINT uSrcID)
{
    UINT uID;
    for (UINT nSrc = 0; SUCCEEDED(_GetSubPidl(pidl, nSrc, &uID, NULL, NULL)); nSrc++)
    {        
        if (uID == uSrcID)
            return TRUE;
    }        
    return FALSE;
}

// returns new pidl in *ppidl free of nSrcID
HRESULT CMergedFolder::_WrapRemoveIDList(LPITEMIDLIST pidlWrap, UINT nSrcID, LPITEMIDLIST *ppidl)
{
    ASSERT(IS_VALID_WRITE_PTR(ppidl, LPITEMIDLIST));
    
    *ppidl = NULL;

    HRESULT hr = _IsWrap(pidlWrap);
    if (SUCCEEDED(hr))
    {
        UINT uID;
        LPITEMIDLIST pidl;
        for (UINT i = 0; SUCCEEDED(hr) && SUCCEEDED(_GetSubPidl(pidlWrap, i, &uID, &pidl, NULL)); i++)
        {
            if (uID != nSrcID)
                hr = _WrapAddIDList(pidl, uID, ppidl);
            ILFree(pidl);
        }
    }

    return hr;
}

HRESULT CMergedFolder::_WrapRemoveIDListAbs(LPITEMIDLIST pidlWrapAbs, UINT nSrcID, LPITEMIDLIST *ppidlAbs)
{
    ASSERT(ppidlAbs);

    HRESULT hr = E_OUTOFMEMORY;
    *ppidlAbs = ILCloneParent(pidlWrapAbs);
    if (*ppidlAbs)
    {
        LPITEMIDLIST pidlLast;
        hr = _WrapRemoveIDList(ILFindLastID(pidlWrapAbs), nSrcID, &pidlLast);
        if (SUCCEEDED(hr))
        {
            // shilappend frees pidlLast
            hr = SHILAppend(pidlLast, ppidlAbs);
        }
    }
    return hr;
}


// Adds a source pidl to *ppidlWrap (IN/OUT param!)
HRESULT CMergedFolder::_WrapAddIDList(LPCITEMIDLIST pidlSrc, UINT nSrcID, LPITEMIDLIST* ppidlWrap)
{
    HRESULT hr;

    if (!*ppidlWrap)
    {
        // called as a create, rather than append       
        hr = _CreateWrap(pidlSrc, nSrcID, ppidlWrap);   
    }
    else
    {
        // check to see if we already have the ID in this IDLIST we are wrapping onto.        
        LPITEMIDLIST pidlSrcWithID;
        hr = SHILClone(pidlSrc, &pidlSrcWithID);
        if (SUCCEEDED(hr))
        {
            hr = E_OUTOFMEMORY;
            if (!ILFindHiddenID(pidlSrcWithID, IDLHID_PARENTFOLDER))
            {
                AUGM_NAMESPACE ans = { {sizeof(ans), AUGM_NS_CURRENTVERSION, IDLHID_PARENTFOLDER} , nSrcID };
                pidlSrcWithID = ILAppendHiddenID((LPITEMIDLIST)pidlSrcWithID, &ans.hid);
            }

            // ok, we have an IDLIST that we can use to append to this object.
            if (pidlSrcWithID)
            {
                BOOL fOtherSrcIDsExist = TRUE;
                // check to see if this ID already exists within the wrap idlist.
                if (*ppidlWrap && _ContainsSrcID(*ppidlWrap, nSrcID))
                {
                    LPITEMIDLIST pidlFree = *ppidlWrap;
                    if (SUCCEEDED(_WrapRemoveIDList(pidlFree, nSrcID, ppidlWrap)))
                    {
                        ILFree(pidlFree);
                    }
                    fOtherSrcIDsExist = (*ppidlWrap != NULL);
                }

                if (fOtherSrcIDsExist)
                {
                    // now compute the new size of the IDLIST.  (*ppidlWrap has been updated);
                    PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)*ppidlWrap;

                    SHORT cbOld = pWrap->cb;
                    SHORT cbNew = cbOld + (pidlSrcWithID->mkid.cb + CB_IDLIST_TERMINATOR);            // extra terminator is appended.
           
                    pWrap = (PAUGM_IDWRAP)SHRealloc(pWrap, cbNew + CB_IDLIST_TERMINATOR);

                    if (pWrap)
                    {
                        // copy the new idlist and its hidden payload (ensure we are terminated)
                        memcpy(((BYTE*)pWrap)+ cbOld, pidlSrcWithID, cbNew-cbOld);
                        *((UNALIGNED SHORT*)(((BYTE*)pWrap)+ cbNew)) = 0;    

                        pWrap->cb += cbNew-cbOld;
                        pWrap->cSrcs++;
                        hr = S_OK;
                    }
                    *ppidlWrap = (LPITEMIDLIST)pWrap;
                }
                else
                {
                    hr = _CreateWrap(pidlSrc, nSrcID, ppidlWrap);
                }
                ILFree(pidlSrcWithID);
            }
        }
    }

    return hr;
}


// used to itterate through the sub pidls in the wrapped pidl
// all out params optional
//
// out:
//      *ppidl  alias into pidlWrap (nested pidl)

HRESULT CMergedFolder::_GetSubPidl(LPCITEMIDLIST pidlWrap, int i, UINT *pnSrcID, LPITEMIDLIST *ppidl, CMergedFldrNamespace **ppns)
{
    if (pnSrcID)
        *pnSrcID = -1;

    if (ppidl)
        *ppidl = NULL;

    if (ppns)
        *ppns = NULL;
 
    HRESULT hr = _IsWrap(pidlWrap);
    if (SUCCEEDED(hr))
    {
        if ((UINT)i < _GetSourceCount(pidlWrap))
        {
            PAUGM_NAMESPACE pans = (PAUGM_NAMESPACE)ILFindHiddenID(pidlWrap, IDLHID_PARENTFOLDER);
            if (!pans)
            {
                PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)pidlWrap;
                LPITEMIDLIST pidlSrc = (LPITEMIDLIST)(((BYTE *)pWrap) + sizeof(AUGM_IDWRAP));

                while (i--)
                {
                    // advance to next item
                    SHORT cb = pidlSrc->mkid.cb;
                    pidlSrc = (LPITEMIDLIST)(((BYTE *)pidlSrc) + cb + CB_IDLIST_TERMINATOR);
                }

                if (pnSrcID || ppns)
                {
                    PAUGM_NAMESPACE pans = (PAUGM_NAMESPACE)ILFindHiddenID(pidlSrc, IDLHID_PARENTFOLDER);
                    ASSERTMSG((pans != NULL), "Failed to find hidden _Namespace in pidlWrap");
            
                    if (pans && pnSrcID)
                        *pnSrcID = pans->uSrcID;

                    if (pans && ppns)
                        hr = _Namespace(pans->uSrcID, ppns);
                }

                if (SUCCEEDED(hr) && ppidl)
                {
                    hr = SHILClone(pidlSrc, ppidl);
                }
            }
            else
            {
                if (pnSrcID)
                    *pnSrcID = pans->uSrcID;

                if (ppns)
                    hr = _Namespace(pans->uSrcID, ppns);

                if (SUCCEEDED(hr) && ppidl)
                {
                    hr = SHILClone(pidlWrap, ppidl);
                }
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hr) && ppidl)
    {
        // we need to strip away the hidden id that marks this guy as merged.
        // this is because the pidl we're returning is supposed to be a child of one of our
        // namespaces we're merging, so it should know absolutely nothing about being merged.
        // these guys used to slip through and cause problems.
        ILRemoveHiddenID(*ppidl, IDLHID_PARENTFOLDER);
    }

    ASSERT(!ppidl || (ILFindLastID(*ppidl) == *ppidl));

    return hr;
}

// function to compare two opaque pidls.
// this is helpful since in the non-merged case, there's some difficulty
// getting defview to contain items with the same name.  we need a way to
// compare two pidls to say "yes defview, these pidls are actually different!"
// note that the actual order doesn't matter, as long as the comparison
// is consistent (since this is used in sorting functions).
int CMergedFolder::_CompareArbitraryPidls(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    UINT iRet;
    UINT cbItem1 = ILGetSize(pidl1);
    UINT cbItem2 = ILGetSize(pidl2);
    if (cbItem1 != cbItem2)
    {
        iRet = (cbItem1 < cbItem2) ? 1 : -1;
    }
    else
    {
        iRet = memcmp(pidl1, pidl2, cbItem1);
        ASSERTMSG(iRet != 0, "no two pidls from the enumerators should be EXACTLY alike!");
    }
    return iRet;
}

int CMergedFolder::_Compare(void *pv1, void *pv2, LPARAM lParam)
{
    int iRet = -1;
    CMergedFldrItem* pmfiEnum1 = (CMergedFldrItem*)pv1;
    CMergedFldrItem* pmfiEnum2 = (CMergedFldrItem*)pv2;
    if (pmfiEnum1 && pmfiEnum2)
    {
        // Are these two items of different types?
        if (BOOLIFY(pmfiEnum1->GetFolderAttrib() & SFGAO_FOLDER) ^ BOOLIFY(pmfiEnum2->GetFolderAttrib() & SFGAO_FOLDER))
        {
            // Yes. Then Folders sort before items.
            iRet = BOOLIFY(pmfiEnum1->GetFolderAttrib() & SFGAO_FOLDER) ? 1 : -1;
        }
        else    // They are of the same type. Then compare by name
        {
            iRet = lstrcmpi(pmfiEnum1->GetDisplayName(), pmfiEnum2->GetDisplayName());
            if (iRet == 0)
            {
                CMergedFolder *pmf = (CMergedFolder *) lParam;
                if (!pmf->_ShouldMergeNamespaces(pmfiEnum1->GetNamespaceID(), pmfiEnum2->GetNamespaceID()))
                {
                    // these items cannot be merged,
                    // force iRet to be nonzero.  the only reason why this comparison
                    // has to be well-defined is so we can pass our ASSERTs that the
                    // list is sorted using this comparison function.
                    iRet = _CompareArbitraryPidls(pmfiEnum1->GetIDList(), pmfiEnum2->GetIDList());
                }
            }
        }
    }
    return iRet;
}


void *CMergedFolder::_Merge(UINT uMsg, void *pv1, void *pv2, LPARAM lParam)
{
    CMergedFolder*pmf = (CMergedFolder*)lParam;
    void * pvRet = pv1;
    
    switch (uMsg)
    {
    case DPAMM_MERGE:
        {
            UINT nSrcID;
            LPITEMIDLIST pidl;
            CMergedFldrItem* pitemSrc  = (CMergedFldrItem*)pv2;
            if (SUCCEEDED(pmf->_GetSubPidl(pitemSrc->GetIDList(), 0, &nSrcID, &pidl, NULL)))
            {
                // add pidl from src to dest
                CMergedFldrItem* pitemDest = (CMergedFldrItem*)pv1;
                pmf->_WrapAddIDList(pidl, nSrcID, &pitemDest->_pidlWrap);
                ILFree(pidl);
            }
        }
        break;

    case DPAMM_INSERT:
        {
            CMergedFldrItem* pmfiNew = new CMergedFldrItem;
            if (pmfiNew)
            {
                CMergedFldrItem* pmfiSrc = (CMergedFldrItem*)pv1;
                if (!pmfiNew->Init(pmfiSrc))
                {
                    delete pmfiNew;
                    pmfiNew = NULL;
                }
            }
            pvRet = pmfiNew;
        }
        break;

    default:
        ASSERT(0);
    }
    return pvRet;
}


typedef struct
{
    LPTSTR pszDisplayName;
    BOOL   fFolder;
    CMergedFolder *self;
    int    iNamespace;
} SEARCH_FOR_PIDL;

int CALLBACK CMergedFolder::_SearchByName(void *p1, void *p2, LPARAM lParam)
{
    SEARCH_FOR_PIDL* psfp = (SEARCH_FOR_PIDL*)p1;
    CMergedFldrItem* pmfiEnum  = (CMergedFldrItem*)p2;

    // Are they of different types?
    if (BOOLIFY(pmfiEnum->GetFolderAttrib() & SFGAO_FOLDER) ^ psfp->fFolder)
    {
        // Yes. 
        return psfp->fFolder ? 1 : -1;
    }

    // They are of the same type. Then compare by name
    int iRc = StrCmpI(psfp->pszDisplayName, pmfiEnum->GetDisplayName());
    if (iRc)
        return iRc;

    // They are the same name. But if they're not allowed to merge, then
    // they're really different.
    if (!psfp->self->_ShouldMergeNamespaces(pmfiEnum->GetNamespaceID(), psfp->iNamespace))
    {
        // Sort by namespace ID
        return psfp->iNamespace - pmfiEnum->GetNamespaceID();
    }

    // I guess they're really equal
    return 0;
}


// IPersistFolder::Initialize()
STDMETHODIMP CMergedFolder::Initialize(LPCITEMIDLIST pidl)
{
#if 0
    IBindCtx *pbc;
    if (SUCCEEDED(SHCreateSkipBindCtx(SAFECAST(this, IAugmentedShellFolder2*), &pbc)))
    {
        IPropertyBag *pbag;
        if (SUCCEEDED(SHBindToObjectEx(NULL, pidl, pbc, IID_PPV_ARG(IPropertyBag, &pbag))))
        {
            Load(pbag, NULL);         // ignore result here
            pbag->Release();
        }
        pbc->Release();
    }
#endif
    return Pidl_Set(&_pidl, pidl) ? S_OK : E_OUTOFMEMORY;
}

// IPersistFolder2::GetCurFolder()
STDMETHODIMP CMergedFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    if (_pidl)
        return SHILClone(_pidl, ppidl);
    else
    {
        *ppidl = NULL;
        return S_FALSE;
    }
}


// IPersistPropertyBag

void CMergedFolder::_GetKeyForProperty(LPWSTR pszName, LPWSTR pszValue, LPWSTR pszBuffer, INT cchBuffer)
{
    StrCpyW(pszBuffer, L"MergedFolder\\");
    StrCatBuffW(pszBuffer, pszName, cchBuffer);
    StrCatBuffW(pszBuffer, pszValue, cchBuffer);
}

HRESULT CMergedFolder::_AddNameSpaceFromPropertyBag(IPropertyBag *ppb, LPWSTR pszName)
{
    WCHAR szKey[MAX_PATH];

    // get the path of the folder
    WCHAR szPath[MAX_PATH];
    LPITEMIDLIST pidl = NULL;

    _GetKeyForProperty(pszName, L"Path", szKey, ARRAYSIZE(szKey));
    HRESULT hr = SHPropertyBag_ReadStr(ppb, szKey, szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hr))
    {
        // we picked a path from the property bag, so lets convert
        // that to an IDLIST so we can do something with it.

        hr = SHILCreateFromPath(szPath, &pidl, NULL);
    }
    else
    {
        // attempt to determine the CSIDL for the folder we are going
        // to show, if that works then convert it to an IDLIST
        // so that we can pass it to AddNamespace.

        _GetKeyForProperty(pszName, L"CSIDL", szKey, ARRAYSIZE(szKey));

        int csidl;
        hr = SHPropertyBag_ReadDWORD(ppb, szKey, (DWORD*)&csidl);
        if (SUCCEEDED(hr))
        {
            hr = SHGetSpecialFolderLocation(NULL, csidl, &pidl);
        }
    }

    if (SUCCEEDED(hr) && pidl)
    {
        // we succeeded in getting a location for the folder we
        // are going to add, so lets pick up the rest of the
        // information on that object.

        GUID guid;
        GUID *pguid = NULL;
        _GetKeyForProperty(pszName, L"GUID", szKey, ARRAYSIZE(szKey));
        pguid = SUCCEEDED(SHPropertyBag_ReadGUID(ppb, szKey, &guid)) ? &guid:NULL;

        DWORD dwFlags = 0;
        _GetKeyForProperty(pszName, L"Flags", szKey, ARRAYSIZE(szKey));
        SHPropertyBag_ReadDWORD(ppb, szKey, &dwFlags);

        hr = AddNameSpace(pguid, NULL, pidl, dwFlags);
    }

    ILFree(pidl);
    return hr;
}


HRESULT CMergedFolder::Load(IPropertyBag* ppb, IErrorLog *pErrLog)
{
    SHPropertyBag_ReadGUID(ppb, L"MergedFolder\\CLSID", &_clsid);            // get the folders CLSID
    SHPropertyBag_ReadDWORD(ppb, L"MergedFolder\\DropEffect", &_dwDropEffect);
    _fInShellView = SHPropertyBag_ReadBOOLDefRet(ppb, L"MergedFolder\\ShellView", FALSE);

    WCHAR sz[MAX_PATH];
    if (SUCCEEDED(SHPropertyBag_ReadStr(ppb, L"MergedFolder\\Folders", sz, ARRAYSIZE(sz))))
    {
        LPWSTR pszName = sz;
        while (pszName && *pszName)
        {
            LPWSTR pszNext = StrChrW(pszName, L',');
            if (pszNext)
            {
                *pszNext = 0;
                pszNext++;
            }
            
            _AddNameSpaceFromPropertyBag(ppb, pszName);
            pszName = pszNext;
        }
    }

    return S_OK;
}


// IShellFolder

STDMETHODIMP CMergedFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    *ppenumIDList = NULL;

    HRESULT hr = E_FAIL;
    if (_hdpaNamespaces)
    {
        _FreeObjects();
        hr = CMergedFldrEnum_CreateInstance(this, grfFlags, ppenumIDList);
    }

    if (SUCCEEDED(hr) && _fInShellView)
    {
        Register(NULL, 0, 0);
    }
    return hr;
}

HRESULT CMergedFolder::_CreateWithCLSID(CLSID clsid, CMergedFolder **ppmf)
{
    *ppmf = new CMergedFolder(this, clsid);
    return *ppmf ? S_OK : E_OUTOFMEMORY;
}

BOOL CMergedFolder::_ShouldSuspend(REFGUID rguid)
{
    return FALSE;
}

// create a new CMergedFolder from the first element in pidlWrap
// this is our private init method, IPersistFolder::Initialize() is how we
// get inited at our junction point.
HRESULT CMergedFolder::_New(LPCITEMIDLIST pidlWrap, CMergedFolder **ppmf)
{
    ASSERT(ppmf);
    *ppmf = NULL;

    HRESULT hr = E_OUTOFMEMORY; // assume the worst

    // just want the first element in pidlWrap
    LPITEMIDLIST pidlFirst = ILCloneFirst(pidlWrap);
    if (pidlFirst)
    {
        if (_IsFolder(pidlFirst))
        {
            hr = _CreateWithCLSID(_clsid, ppmf);
            if (SUCCEEDED(hr) && _pidl)
            {
                hr = SHILCombine(_pidl, pidlFirst, &(*ppmf)->_pidl);
                if (FAILED(hr))
                {
                    (*ppmf)->Release();
                    *ppmf = NULL;
                }
            }
        }
        else
        {
            hr = E_NOINTERFACE;
        }
        ILFree(pidlFirst);
    }
    return hr;
}

void CMergedFolder::_AddAllOtherNamespaces(LPITEMIDLIST *ppidl)
{
    TCHAR szName[MAX_PATH];
    if (SUCCEEDED(DisplayNameOf(static_cast<CSFStorage *>(this), *ppidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName))))
    {
        CMergedFldrNamespace *pns;
        for (int n = 0; pns = _Namespace(n); n++)
        {
            if (FAILED(_GetSubPidl(*ppidl, n, NULL, NULL, NULL)))
            {
                IBindCtx *pbc;
                WIN32_FIND_DATA wfd = {0};
                wfd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
                if (SUCCEEDED(SHCreateFileSysBindCtx(&wfd, &pbc)))
                {
                    LPITEMIDLIST pidlNamespace;
                    if (SUCCEEDED(pns->Folder()->ParseDisplayName(NULL, pbc, szName, NULL, &pidlNamespace, NULL)))
                    {
                        _WrapAddIDList(pidlNamespace, n, ppidl);
                        ILFree(pidlNamespace);
                    }
                    pbc->Release();
                }
            }
        }
    }
}

STDMETHODIMP CMergedFolder::BindToObject(LPCITEMIDLIST pidlWrap, LPBC pbc, REFIID riid, void **ppv)
{
    ASSERT(IS_VALID_PIDL(pidlWrap));

    *ppv = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST pidlRewrappedFirst;
    if (_fDontMerge)
    {
        // this doesn't contain a wrap consisting of all namespaces but only one instead
        LPITEMIDLIST pidlWrapFirst = ILCloneFirst(pidlWrap);
        if (pidlWrapFirst)
        {
            TCHAR szName[MAX_PATH];
            hr = DisplayNameOf(reinterpret_cast<IShellFolder *>(this), pidlWrapFirst, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                // we want to round-trip the name so the non-merged pidl gets remerged
                // during a bind (so you dont get just one namespace from here on down)
                hr = ParseDisplayName(NULL, NULL, szName, NULL, &pidlRewrappedFirst, NULL);
            }
            ILFree(pidlWrapFirst);
        }
    }
    else
    {
        pidlRewrappedFirst = ILCloneFirst(pidlWrap);
        if (pidlRewrappedFirst)
        {
            hr = S_OK;
            if (_fCDBurn && _IsFolder(pidlRewrappedFirst))
            {
                // in the cdburn case we need to fake up the other namespaces in the pidl we're about to bind to.
                // this is so when we navigate into a subfolder that only exists on the CD and not the staging area,
                // if a file is later added to the staging area it'll still be merged in.
                _AddAllOtherNamespaces(&pidlRewrappedFirst);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // just in case
        ASSERT(SUCCEEDED(_IsWrap(pidlRewrappedFirst)));

        LPCITEMIDLIST pidlNext = _ILNext(pidlWrap);

        CMergedFolder *pmf;
        hr = _New(pidlRewrappedFirst, &pmf);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlSrc;
            CMergedFldrNamespace *pns;
            for (UINT i = 0; SUCCEEDED(_GetSubPidl(pidlRewrappedFirst, i, NULL, &pidlSrc, &pns)); i++)
            {
                hr = E_OUTOFMEMORY;
                ASSERT(ILFindLastID(pidlSrc) == pidlSrc);
                LPITEMIDLIST pidlSrcFirst = ILCloneFirst(pidlSrc);
                if (pidlSrcFirst)
                {
                    IShellFolder *psf;
                    if (SUCCEEDED(pns->Folder()->BindToObject(pidlSrcFirst, pbc, IID_PPV_ARG(IShellFolder, &psf))))
                    {
                        LPITEMIDLIST pidlAbs = ILCombine(pns->GetIDList(), pidlSrcFirst);
                        if (pidlAbs)
                        {
                            CMergedFldrNamespace *pnsNew = new CMergedFldrNamespace();
                            if (pnsNew)
                            {
                                hr = pnsNew->SetNamespace(&(pns->GetGUID()), psf, pidlAbs, pns->FolderAttrib());
                                if (SUCCEEDED(hr))
                                {
                                    // propagate the drop folder down to the child.
                                    hr = pnsNew->SetDropFolder(pns->GetDropFolder());
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = pmf->_SimpleAddNamespace(pnsNew);
                                        if (SUCCEEDED(hr))
                                        {
                                            // success, _SimpleAddNamespace took ownership
                                            pnsNew = NULL;
                                        }
                                    }
                                }
                                if (pnsNew)
                                    delete pnsNew;
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                            ILFree(pidlAbs);
                        }
                        psf->Release();
                    }
                    ILFree(pidlSrcFirst);
                }
                ILFree(pidlSrc);
            }

            // it's possible to go through the loop without adding any namespaces.
            // usually it's when BindToObject above fails -- this can happen if somebody
            // puts a junction point in the merged folder (like a zip file).  in that case
            // we're in trouble.

            if (ILIsEmpty(pidlNext))
                hr = pmf->QueryInterface(riid, ppv);
            else
                hr = pmf->BindToObject(pidlNext, pbc, riid, ppv);
            pmf->Release();
        }

        if (FAILED(hr) && ILIsEmpty(pidlNext))
        {
            // maybe it's an interface that we don't support ourselves (IStream?).
            // we cant merge interfaces that we don't know about so lets just
            // assume we'll pick the interface up from the default namespace in
            // the wrapped pidl.
            LPITEMIDLIST pidlSrc;
            CMergedFldrNamespace *pns;
            hr = _NamespaceForItem(pidlRewrappedFirst, ASFF_DEFNAMESPACE_BINDSTG, ASFF_DEFNAMESPACE_BINDSTG, NULL, &pidlSrc, &pns);
            if (SUCCEEDED(hr))
            {
                hr = pns->Folder()->BindToObject(pidlSrc, pbc, riid, ppv);
                ILFree(pidlSrc);
            }
        }
        ILFree(pidlRewrappedFirst);
    }

    if (SUCCEEDED(hr) && _fInShellView)
    {
        Register(NULL, 0, 0);
    }

    return hr;
}

STDMETHODIMP CMergedFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

HRESULT CMergedFolder::_CompareSingleLevelIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    IShellFolder *psf1;
    LPITEMIDLIST pidlItem1;
    CMergedFldrNamespace *pns1;
    HRESULT hr = _NamespaceForItem(pidl1, ASFF_DEFNAMESPACE_DISPLAYNAME, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf1, &pidlItem1, &pns1);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf2;
        LPITEMIDLIST pidlItem2;
        CMergedFldrNamespace *pns2;
        hr = _NamespaceForItem(pidl2, ASFF_DEFNAMESPACE_DISPLAYNAME, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf2, &pidlItem2, &pns2);
        if (SUCCEEDED(hr))
        {
            //  Same _Namespace? Just forward the request.
            if (psf1 == psf2)
            {
                hr = psf1->CompareIDs(lParam, pidlItem1, pidlItem2);
            }
            else if ((pns1->FolderAttrib() & ASFF_SORTDOWN) ^ (pns2->FolderAttrib() & ASFF_SORTDOWN))
            {
                // One namespace marked ASFF_SORTDOWN and one not?  The SORTDOWN one
                // comes second.
                hr = ResultFromShort((pns1->FolderAttrib() & ASFF_SORTDOWN) ? 1 : -1);
            }
            else
            {
                if (!_IsSimple(pidl1) && !_IsSimple(pidl2))
                {
                    //  Comparison heuristics:
                    //  (1) folders take precedence over nonfolders, (2) alphanum comparison
                    int iFolder1 = SHGetAttributes(psf1, pidlItem1, SFGAO_FOLDER) ? 1 : 0;
                    int iFolder2 = SHGetAttributes(psf2, pidlItem2, SFGAO_FOLDER) ? 1 : 0;
                    hr = ResultFromShort(iFolder2 - iFolder1);
                }
                else
                {
                    // if a pidl is simple, compare based on name only.
                    hr = ResultFromShort(0);
                }

                if (ResultFromShort(0) == hr)
                {
                    TCHAR szName1[MAX_PATH], szName2[MAX_PATH];
                    if (SUCCEEDED(DisplayNameOf(psf1, pidlItem1, SHGDN_INFOLDER, szName1, ARRAYSIZE(szName1))) &&
                        SUCCEEDED(DisplayNameOf(psf2, pidlItem2, SHGDN_INFOLDER, szName2, ARRAYSIZE(szName2))))
                    {
                        int iRet = StrCmp(szName1, szName2); // Comparisons are by name with items of the same type.
                        if ((iRet == 0) &&
                            SUCCEEDED(DisplayNameOf(psf1, pidlItem1, SHGDN_FORPARSING | SHGDN_INFOLDER, szName1, ARRAYSIZE(szName1))) &&
                            SUCCEEDED(DisplayNameOf(psf2, pidlItem2, SHGDN_FORPARSING | SHGDN_INFOLDER, szName2, ARRAYSIZE(szName2))))
                        {
                            iRet = lstrcmp(szName1, szName2); // minimal behavior change for xpsp1: fall back to parsing name if theres still a tie.
                            if ((iRet == 0) && !_ShouldMergeNamespaces(pns1, pns2))
                            {
                                ASSERTMSG(!_fInShellView, "we shouldn't be in this code path for the start menu");
                                // different namespaces must compare differently in the non-merged case.
                                iRet = _CompareArbitraryPidls(pidlItem1, pidlItem2);
                            }
                        }
                        hr = ResultFromShort(iRet);
                    }
                }
            }
            ILFree(pidlItem2);
        }
        ILFree(pidlItem1);
    }
    return hr;
}

STDMETHODIMP CMergedFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // just in case
    //ASSERT(!pidl1 || SUCCEEDED(_IsWrap(pidl1)));
    //ASSERT(!pidl2 || SUCCEEDED(_IsWrap(pidl2)));

    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlFirst1 = pidl1 ? ILCloneFirst(pidl1) : NULL;
    LPITEMIDLIST pidlFirst2 = pidl2 ? ILCloneFirst(pidl2) : NULL;
    if (pidlFirst1 && pidlFirst2)
    {
        hr = _CompareSingleLevelIDs(lParam, pidlFirst1, pidlFirst2);
    }
    ILFree(pidlFirst1);
    ILFree(pidlFirst2);

    // if there was an exact match then lets compare the trailing elements of the IDLIST
    // if there are some (by binding down) etc.

    if (ResultFromShort(0) == hr)
    {
        IShellFolder *psf;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = ILCompareRelIDs(psf, pidl1, pidl2, lParam);
            psf->Release();
        }
    }

    if (!_IsSimple(pidl1) && !_IsSimple(pidl2))
    {
        // if we're still the same, compare the number
        // of namespaces in the pidl.
        int nCount1, nCount2;
        if (ResultFromShort(0) == hr)
        {
            nCount1 = pidl1 ? _GetSourceCount(pidl1) : 0;
            nCount2 = pidl2 ? _GetSourceCount(pidl2) : 0;
            hr = ResultFromShort(nCount1 - nCount2);
        }

        // next compare the namespaces themselves.
        // basically we're only concerned with the two-namespace case, so if both pidls have
        // elements from 0 or 2 namespaces theyre equal; we're worried about when one pidl has
        // 1 sub-pidl in namespace 0 and the other one has 1 sub-pidl in namespace 1.
        // we dont worry about 3+ namespaces and those permutations.
        if ((ResultFromShort(0) == hr) && (nCount1 == 1) && (nCount2 == 1))
        {
            GUID guid1 = GUID_NULL, guid2 = GUID_NULL;

            GetNameSpaceID(pidl1, &guid1);
            GetNameSpaceID(pidl2, &guid2);

            hr = ResultFromShort(memcmp(&guid1, &guid2, sizeof(GUID)));
        }
    }

    return hr;
}

STDMETHODIMP CMergedFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr;
    if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = CMergedFldrDropTarget_CreateInstance(this, hwnd, (IDropTarget**)ppv);
    }
    else if (IsEqualIID(riid, IID_IShellView))
    {
        IShellFolderViewCB *psfvcb;
        hr = CMergedFolderViewCB_CreateInstance(this, &psfvcb);
        if (SUCCEEDED(hr))
        {
            SFV_CREATE csfv = {0};
            csfv.cbSize = sizeof(csfv);
            csfv.pshf = SAFECAST(this, IAugmentedShellFolder2*);
            csfv.psfvcb = psfvcb;
            hr = SHCreateShellFolderView(&csfv, (IShellView **)ppv);

            psfvcb->Release();
        }
    }
    else if (_fInShellView && IsEqualIID(riid, IID_ICategoryProvider))
    {
        IShellFolder *psf;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            BEGIN_CATEGORY_LIST(s_Categories)
            CATEGORY_ENTRY_SCIDMAP(SCID_WHICHFOLDER, CLSID_MergedCategorizer)
            END_CATEGORY_LIST()

            hr = CCategoryProvider_Create(&CLSID_MergedCategorizer, &SCID_WHICHFOLDER, NULL, s_Categories, psf, riid, ppv);
            psf->Release();
        }
    }
    else if (_fInShellView && IsEqualIID(riid, IID_IContextMenu))
    {
        // this is pretty much what filefldr does to create its background
        // context menu.  we don't want to let one of our namespaces take over for the background
        // context menu because then the context menu will think it's in an unmerged namespace.

        // for example the new menu would then work with the storage of the child namespace
        // and couldn't select the new item after its done since it has an unmerged pidl
        // and the view has a merged one.
        IShellFolder *psfToPass;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfToPass));
        if (SUCCEEDED(hr))
        {
            HKEY hkNoFiles;
            RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Directory\\Background"), &hkNoFiles);
            // initialize with our merged pidl.
            IContextMenuCB *pcmcb = new CDefBackgroundMenuCB(_pidl);
            if (pcmcb) 
            {
                hr = CDefFolderMenu_Create2Ex(_pidl, hwnd, 0, NULL, psfToPass, pcmcb, 
                                              1, &hkNoFiles, (IContextMenu **)ppv);
                pcmcb->Release();
            }
            if (hkNoFiles)                          // CDefFolderMenu_Create can handle NULL ok
                RegCloseKey(hkNoFiles);
            psfToPass->Release();
        }
    }
    else
    {
        CMergedFldrNamespace *pns;
        hr = _FindNamespace(ASFF_DEFNAMESPACE_VIEWOBJ, ASFF_DEFNAMESPACE_VIEWOBJ, NULL, &pns);
        if (SUCCEEDED(hr))
        {
            hr = pns->Folder()->CreateViewObject(hwnd, riid, ppv);
        }
    }
    return hr;
}

STDMETHODIMP CMergedFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    // attribs of the namespace root.
    // scope this to the sub-namespaces?
    if (!cidl || !apidl)
    {
        *rgfInOut &= SFGAO_FOLDER | SFGAO_FILESYSTEM | 
                     SFGAO_LINK | SFGAO_DROPTARGET |
                     SFGAO_CANRENAME | SFGAO_CANDELETE |
                     SFGAO_CANLINK | SFGAO_CANCOPY | 
                     SFGAO_CANMOVE | SFGAO_HASSUBFOLDER;
        return S_OK;
    }

    HRESULT hr = S_OK;
    for (UINT i = 0; SUCCEEDED(hr) && (i < cidl); i++)
    {
        ULONG ulAttribs = *rgfInOut;

        IShellFolder* psf;
        LPITEMIDLIST pidlItem;
        CMergedFldrNamespace *pns;
        hr = _NamespaceForItem(apidl[0], ASFF_DEFNAMESPACE_ATTRIB, ASFF_DEFNAMESPACE_ATTRIB, &psf, &pidlItem, &pns);
        if (SUCCEEDED(hr))
        {
            ulAttribs |= SFGAO_FOLDER;
            hr = psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlItem, &ulAttribs);
            if (SUCCEEDED(hr))
            {
                ulAttribs = pns->FixItemAttributes(ulAttribs);
                if (_fInShellView || !(*rgfInOut & SFGAO_FOLDER))
                {
                    ulAttribs &= ~SFGAO_CANLINK;  // avoid people creating links to our pidls
                }

                if (*rgfInOut & (SFGAO_CANCOPY | SFGAO_CANMOVE | SFGAO_CANLINK))
            	{
                    // allow per-type guys to do what they want.
                    IQueryAssociations *pqa;
                    DWORD dwDefEffect = DROPEFFECT_NONE;
                    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&pidlItem, IID_X_PPV_ARG(IQueryAssociations, NULL, &pqa))))
                    {
                        DWORD cb = sizeof(dwDefEffect);
                        pqa->GetData(0, ASSOCDATA_VALUE, L"DefaultDropEffect", &dwDefEffect, &cb);
                        pqa->Release();
                    }
                    ulAttribs |= dwDefEffect & (SFGAO_CANCOPY | SFGAO_CANMOVE | SFGAO_CANLINK);
                }
            }
            ILFree(pidlItem);
        }

        // keep only the attributes common to all pidls.
        *rgfInOut &= ulAttribs;
    }
    return hr;
}

STDMETHODIMP CMergedFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, UINT *prgf, void **ppv)
{
    *ppv = NULL;

    HRESULT hr = E_NOTIMPL;
    if (IsEqualGUID(riid, IID_IContextMenu))
    {
        hr = _GetContextMenu(hwnd, cidl, apidl, riid, ppv);
    }
    else if (IsEqualGUID(riid, IID_IDropTarget) && _IsFolder(apidl[0]))
    {
        IShellFolder *psf;
        hr = BindToObject(apidl[0], NULL, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->CreateViewObject(hwnd, riid, ppv);
            psf->Release();
        }
    }
    else if ((IsEqualIID(riid, IID_IExtractImage) || 
              IsEqualIID(riid, IID_IExtractLogo)) && _IsFolder(apidl[0]))
    {
        IShellFolder *psfThis;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfThis));
        if (SUCCEEDED(hr))
        {
            hr = CFolderExtractImage_Create(psfThis, apidl[0], riid, ppv);
            psfThis->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IDataObject) && _pidl)
    {
        hr = SHCreateFileDataObject(_pidl, cidl, apidl, NULL, (IDataObject **)ppv);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        // Forward to default _Namespace for UI object
        LPITEMIDLIST *apidlItems = new LPITEMIDLIST[cidl];
        if (apidlItems)
        {
            hr = E_FAIL;       // assume failure

            UINT cidlItems = 0;
            IShellFolder *psf, *psfKeep; // not ref counted
            LPITEMIDLIST pidlItem;
            for (UINT i = 0; i < cidl; i++)
            {
                if (SUCCEEDED(_NamespaceForItem(apidl[i], ASFF_DEFNAMESPACE_UIOBJ, ASFF_DEFNAMESPACE_UIOBJ, &psf, &pidlItem, NULL)))
                {
                    // only keep the ones that match the default namespace for UI object
                    // if they dont match, too bad.
                    apidlItems[cidlItems++] = pidlItem;
                    psfKeep = psf;
                }
            }

            if (cidlItems)
            {
                hr = psfKeep->GetUIObjectOf(hwnd, cidlItems, (LPCITEMIDLIST *)apidlItems, riid, NULL, ppv);
            }
            for (UINT j = 0; j < cidlItems; j++)
            {
                ILFree(apidlItems[j]);
            }
            delete [] apidlItems;
        }
    }
    return hr;
}


// in:
//      pidl optional, NULL means get default
// out:
//      *ppidl if pidl is != NULL

HRESULT CMergedFolder::_GetFolder2(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlInner, IShellFolder2 **ppsf)
{
    if (ppidlInner)
        *ppidlInner = NULL;

    HRESULT hr;
    if (NULL == pidl)
    {
        CMergedFldrNamespace *pns;
        hr = _FindNamespace(ASFF_DEFNAMESPACE_DISPLAYNAME, ASFF_DEFNAMESPACE_DISPLAYNAME, NULL, &pns);
        if (FAILED(hr))
        {
            pns = _Namespace(0);
            hr = pns ? S_OK : E_FAIL;
        }

        if (SUCCEEDED(hr))
            hr = pns->Folder()->QueryInterface(IID_PPV_ARG(IShellFolder2, ppsf));
    }
    else
    {
        IShellFolder* psf;
        hr = _NamespaceForItem(pidl, ASFF_DEFNAMESPACE_DISPLAYNAME, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf, ppidlInner, NULL);
        if (SUCCEEDED(hr))
        {
            hr = psf->QueryInterface(IID_PPV_ARG(IShellFolder2, ppsf));
            if (FAILED(hr) && ppidlInner)
            {
                ILFree(*ppidlInner);
            }
        }
    }
    return hr;
}


// extended column information, these are appended after the set from the merged folder.

#define COLID_WHICHFOLDER  0x00    // column index for the merged folder location

static struct
{
    const SHCOLUMNID *pscid;
    UINT iTitle;
    UINT cchCol;
    UINT iFmt;
}
_columns[] =
{
    {&SCID_WHICHFOLDER, IDS_WHICHFOLDER_COL, 20, LVCFMT_LEFT},
};


// column handler helpers

BOOL CMergedFolder::_IsOurColumn(UINT iCol)
{
    return ((_iColumnOffset != -1) && ((iCol >= _iColumnOffset) && ((iCol - _iColumnOffset) < ARRAYSIZE(_columns))));
}

HRESULT CMergedFolder::_GetWhichFolderColumn(LPCITEMIDLIST pidl, LPWSTR pszBuffer, INT cchBuffer)
{
    CMergedFldrNamespace *pns;
    HRESULT hr = _NamespaceForItem(pidl, ASFF_DEFNAMESPACE_ATTRIB, ASFF_DEFNAMESPACE_ATTRIB, NULL, NULL, &pns);
    if (SUCCEEDED(hr))
    {
        hr = pns->GetLocation(pszBuffer, cchBuffer);
    }
    return hr;
}

STDMETHODIMP CMergedFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
{
    // do we have a column offset, or is this within the range of our the ISFs columns
    HRESULT hr = E_FAIL;
    if (!_IsOurColumn(iColumn))
    {
        IShellFolder2 *psf2;
        LPITEMIDLIST pidlItem;

        // get the column value from the folder.
        hr = _GetFolder2(pidl, &pidlItem, &psf2);
        if (SUCCEEDED(hr))
        {
            hr = psf2->GetDetailsOf(pidlItem, iColumn, pDetails);
            psf2->Release();
            ILFree(pidlItem);
        }

        // we failed and we don't know the column offset to handle
        if (FAILED(hr) && (_iColumnOffset == -1))
            _iColumnOffset = iColumn;
    }
    
    if (FAILED(hr) && _IsOurColumn(iColumn))
    {
        iColumn -= _iColumnOffset;

        pDetails->str.uType = STRRET_CSTR;          // we are returning strings
        pDetails->str.cStr[0] = 0;

        WCHAR szTemp[MAX_PATH];
        if (!pidl)
        {
            pDetails->fmt = _columns[iColumn].iFmt;
            pDetails->cxChar = _columns[iColumn].cchCol;
            LoadString(HINST_THISDLL, _columns[iColumn].iTitle, szTemp, ARRAYSIZE(szTemp));
            hr = StringToStrRet(szTemp, &(pDetails->str));
        }
        else if (SUCCEEDED(_IsWrap(pidl)))
        {
            if (iColumn == COLID_WHICHFOLDER)
            {
                hr = _GetWhichFolderColumn(pidl, szTemp, ARRAYSIZE(szTemp));
                if (SUCCEEDED(hr))
                    hr = StringToStrRet(szTemp, &(pDetails->str));
            }
        }
    }
    return hr;
}

STDMETHODIMP CMergedFolder::GetDefaultColumnState(UINT iColumn, DWORD *pbState)
{ 
    IShellFolder2 *psf2;
    HRESULT hr = _GetFolder2(NULL, NULL, &psf2);
    if (SUCCEEDED(hr))
    {
        hr = psf2->GetDefaultColumnState(iColumn, pbState);
        psf2->Release();
    }
    return hr;
}

STDMETHODIMP CMergedFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{ 
    HRESULT hr;

    if (IsEqualSCID(*pscid, SCID_WHICHFOLDER))
    {
        WCHAR szTemp[MAX_PATH];
        hr = _GetWhichFolderColumn(pidl, szTemp, ARRAYSIZE(szTemp));
        if (SUCCEEDED(hr))
            hr = InitVariantFromStr(pv, szTemp);
    }
    else
    {
        IShellFolder2 *psf2;
        LPITEMIDLIST pidlItem;
        hr = _GetFolder2(pidl, &pidlItem, &psf2);
        if (SUCCEEDED(hr))
        {
            hr = psf2->GetDetailsEx(pidlItem, pscid, pv);
            psf2->Release();
            ILFree(pidlItem);
        }
    }
    return hr;
}

STDMETHODIMP CMergedFolder::MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid)
{ 
    HRESULT hr = S_OK;

    // one of our columns?

    if (_IsOurColumn(iCol))
    {
        iCol -= _iColumnOffset;
        *pscid = *_columns[iCol].pscid;
    }
    else
    {
        IShellFolder2 *psf2;
        hr = _GetFolder2(NULL, NULL, &psf2);
        if (SUCCEEDED(hr))
        {
            hr = psf2->MapColumnToSCID(iCol, pscid);
            psf2->Release();
        }
    }
    return hr;
}


//  Forward to default _Namespace for display name
STDMETHODIMP CMergedFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD grfFlags, STRRET *psr)
{
    IShellFolder* psf;
    LPITEMIDLIST pidlItem;
    HRESULT hr = _NamespaceForItem(pidl, ASFF_DEFNAMESPACE_DISPLAYNAME, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf, &pidlItem, NULL);
    if (SUCCEEDED(hr))
    {
        ASSERT(ILFindLastID(pidlItem) == pidlItem);
        hr = psf->GetDisplayNameOf(pidlItem, grfFlags, psr);
        if (SUCCEEDED(hr))
        {
            hr = _FixStrRetOffset(pidlItem, psr);
#ifdef DEBUG
            // If the trace flags are set, and this is not comming from an internal query,
            // Then append the location where this name came from
            if (!((SHGDN_FORPARSING | SHGDN_FOREDITING) & grfFlags) &&
                (g_qwTraceFlags & TF_AUGM))
            {
                LPWSTR pwszOldName;
                hr = StrRetToStrW(psr, pidlItem, &pwszOldName);
                if (SUCCEEDED(hr))
                {
                    UINT cch = lstrlenW(pwszOldName);
                    psr->uType = STRRET_WSTR;
                    psr->pOleStr = (LPWSTR)SHAlloc((cch + 50) * sizeof(WCHAR));
                    if (psr->pOleStr)
                    {
                        LPWSTR pwsz = psr->pOleStr + wsprintfW(psr->pOleStr, L"%s ", pwszOldName);

                        ULONG nSrc = _GetSourceCount(pidl);
                        UINT uSrc;
                        // Cut off after 10 to avoid buffer overflow
                        for (uSrc = 0; uSrc < nSrc && uSrc < 10; uSrc++)
                        {
                            UINT uID;
                            if (SUCCEEDED(_GetSubPidl(pidl, uSrc, &uID, NULL, NULL)))
                            {
                                pwsz += wsprintfW(pwsz, L"%c%d", uSrc ? '+' : '(', uID);
                            }
                        }
                        pwsz += wsprintfW(pwsz, L")");
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    SHFree(pwszOldName);
                }
            }
#endif
        }
        ILFree(pidlItem);
    }
    else
    {
        if (IsSelf(1, &pidl) && 
            ((grfFlags & (SHGDN_FORADDRESSBAR | SHGDN_INFOLDER | SHGDN_FORPARSING)) == SHGDN_FORPARSING))
        {
            IShellFolder2 *psf2;
            hr = _GetFolder2(NULL, NULL, &psf2);
            if (SUCCEEDED(hr))
            {
                hr = psf2->GetDisplayNameOf(NULL, grfFlags, psr);
                psf2->Release();
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}

// CFSFolder helper
HRESULT _NextSegment(LPCWSTR *ppszIn, LPTSTR pszSegment, UINT cchSegment, BOOL bValidate);

void CMergedFolder::_SetSimple(LPITEMIDLIST *ppidl)
{
    PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)*ppidl;
    if ((pWrap->cb >= sizeof(AUGM_IDWRAP)) &&
        (pWrap->ulTag == AUGM_WRAPTAG) &&
        (pWrap->ulVersion == AUGM_WRAPVERSION_2_0))
    {
        pWrap->dwFlags |= AUGMF_ISSIMPLE;
    }
}

BOOL CMergedFolder::_IsSimple(LPCITEMIDLIST pidl)
{
    BOOL fSimple = FALSE;
    PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)pidl;
    if ((pWrap->cb >= sizeof(AUGM_IDWRAP)) &&
        (pWrap->ulTag == AUGM_WRAPTAG) &&
        (pWrap->ulVersion == AUGM_WRAPVERSION_2_0))
    {
        fSimple = (pWrap->dwFlags & AUGMF_ISSIMPLE);
    }
    return fSimple;
}

STDMETHODIMP CMergedFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pwszName, 
                                             ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttrib)
{
    *ppidl = NULL;

    TCHAR szName[MAX_PATH];
    // ISSUE: this relies on the fact that the path that's getting parsed is FS (with backslashes).
    // alternatively this could be rearchitected so that the namespaces would be delegate folders
    // and we could do the merge when we handle their pidl allocation.
    HRESULT hr = _NextSegment((LPCWSTR *) &pwszName, szName, ARRAYSIZE(szName), TRUE);
    if (SUCCEEDED(hr))
    {
        // let all name spaces try to parse, append them into the pidl as these are found
        CMergedFldrNamespace *pns;
        HRESULT hrParse = S_OK;
        for (int i = 0; SUCCEEDED(hr) && (pns = _Namespace(i)); i++)
        {
            LPITEMIDLIST pidl;
            hrParse = pns->Folder()->ParseDisplayName(hwnd, pbc, szName, NULL, &pidl, NULL);
            if (SUCCEEDED(hrParse))
            {
                // let each name space parse, accumulate results
                // into *ppidl across multiple folders
                hr = _WrapAddIDList(pidl, i, ppidl);

                ILFree(pidl);
            }
        }

        if (!*ppidl)
        {
            if (SUCCEEDED(hr))
            {
                hr = hrParse;
            }
            ASSERT(FAILED(hr));
        }
        else
        {
            if (S_OK == SHIsFileSysBindCtx(pbc, NULL))
            {
                _SetSimple(ppidl);
            }
            ASSERT(ILFindLastID(*ppidl) == *ppidl);
        }

        if (SUCCEEDED(hr) && pwszName)
        {
            IShellFolder *psf;
            hr = BindToObject(*ppidl, pbc, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlNext;
                hr = psf->ParseDisplayName(hwnd, pbc, pwszName, NULL, &pidlNext, pdwAttrib);
                if (SUCCEEDED(hr))
                {
                    // shilappend frees pidlNext
                    hr = SHILAppend(pidlNext, ppidl);
                }
                psf->Release();
            }

            if (FAILED(hr))
            {
                Pidl_Set(ppidl, NULL);
            }
        }
        
        if (SUCCEEDED(hr) && pdwAttrib && *pdwAttrib)
        {
            GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, pdwAttrib);
        }
    }
    ASSERT(SUCCEEDED(hr) ? (*ppidl != NULL) : (*ppidl == NULL));
    return hr;
}

STDMETHODIMP CMergedFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidlWrap, 
                                      LPCOLESTR pwszName, DWORD uFlags, LPITEMIDLIST *ppidlOut)
{
    if (ppidlOut)
        *ppidlOut = NULL;

    HRESULT hr = E_FAIL;
    IShellFolder* psf; // not ref counted
    LPITEMIDLIST pidlItem;

    if (!_fInShellView)
    {
        hr = _NamespaceForItem(pidlWrap, ASFF_COMMON, 0, &psf, &pidlItem, NULL, TRUE);
        if (FAILED(hr))
        {
            hr = _NamespaceForItem(pidlWrap, ASFF_COMMON, ASFF_COMMON, &psf, &pidlItem, NULL, TRUE);
            if (SUCCEEDED(hr))
            {
                hr = AffectAllUsers(hwnd) ? S_OK : E_FAIL;
                if (FAILED(hr))
                {
                    ILFree(pidlItem);
                }
            }
        }
    }
    else
    {
        hr = _NamespaceForItem(pidlWrap, ASFF_DEFNAMESPACE_DISPLAYNAME, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf, &pidlItem, NULL);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(ILFindLastID(pidlItem) == pidlItem);
        hr = psf->SetNameOf(hwnd, pidlItem, pwszName, uFlags, NULL);
        ILFree(pidlItem);
    }

    if (SUCCEEDED(hr) && ppidlOut)
    {   
        WCHAR szName[MAX_PATH];
        hr = DisplayNameOf(SAFECAST(this, IAugmentedShellFolder2*), pidlWrap, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
            hr = ParseDisplayName(NULL, NULL, szName, NULL, ppidlOut, NULL);
    }
    return hr;
}


// IAugmentedShellFolder::AddNameSpace
// Adds a source _Namespace to the Merge shell folder object
STDMETHODIMP CMergedFolder::AddNameSpace(const GUID *pguidObject, IShellFolder *psf, LPCITEMIDLIST pidl, DWORD dwFlags)
{
    //  Check for duplicate via full display name
    CMergedFldrNamespace *pns;
    for (int i = 0; pns = _Namespace(i); i++)
    {
        if (pidl && ILIsEqual(pns->GetIDList(), pidl))
        {
            // If Found, then reassign attributes and return
            return pns->SetNamespace(pguidObject, psf, pidl, dwFlags);
        }
    }

    HRESULT hr;
    pns = new CMergedFldrNamespace();
    if (pns) 
    {
        hr = pns->SetNamespace(pguidObject, psf, pidl, dwFlags);
        if (SUCCEEDED(hr))
        {
            hr = _SimpleAddNamespace(pns);
            if (SUCCEEDED(hr))
            {
                pns = NULL; // success, don't free below
            }
        }
        if (pns)
            delete pns;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT CMergedFolder::_SimpleAddNamespace(CMergedFldrNamespace *pns)
{
    if (NULL == _hdpaNamespaces)
        _hdpaNamespaces = DPA_Create(2);

    HRESULT hr = E_OUTOFMEMORY;
    if (_hdpaNamespaces && (DPA_AppendPtr(_hdpaNamespaces, pns) != -1))
    {
        // If there is any conditional merging going on, then remember it
        if (pns->FolderAttrib() & ASFF_MERGESAMEGUID)
        {
            _fPartialMerge = TRUE;
        }
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CMergedFolder::GetNameSpaceID(LPCITEMIDLIST pidl, GUID * pguidOut)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(IS_VALID_WRITE_PTR(pguidOut, GUID));

    if (pidl && pguidOut)
    {
        CMergedFldrNamespace *pns;
        hr = _GetSubPidl(pidl, 0, NULL, NULL, &pns);
        if (SUCCEEDED(hr))
        {
            *pguidOut = pns->GetGUID();
        }
    }

    return hr;
}


//  Retrieves data for the _Namespace identified by dwID.
STDMETHODIMP CMergedFolder::QueryNameSpace(ULONG iIndex, GUID *pguidOut, IShellFolder **ppsf)
{
    CMergedFldrNamespace *pns;
    HRESULT hr = _Namespace(iIndex, &pns);
    if (SUCCEEDED(hr))
    {
        if (pguidOut)  
            *pguidOut = pns->GetGUID();

        if (ppsf)
        {      
            *ppsf = pns->Folder();
            if (*ppsf)
                (*ppsf)->AddRef();
        }
    }
    return hr;
}

#define ASFQNSI_SUPPORTED (ASFQNSI_FLAGS | ASFQNSI_FOLDER | ASFQNSI_GUID | ASFQNSI_PIDL)

STDMETHODIMP CMergedFolder::QueryNameSpace2(ULONG iIndex, QUERYNAMESPACEINFO *pqnsi)
{
    if (pqnsi->cbSize != sizeof(QUERYNAMESPACEINFO) ||
        (pqnsi->dwMask & ~ASFQNSI_SUPPORTED))
    {
        return E_INVALIDARG;
    }


    CMergedFldrNamespace *pns;
    HRESULT hr = _Namespace(iIndex, &pns);
    if (SUCCEEDED(hr))
    {
        // Do PIDL first since it's the only one that can fail
        // so we don't have to do cleanup
        if (pqnsi->dwMask & ASFQNSI_PIDL)
        {
            hr = SHILClone(pns->GetIDList(), &pqnsi->pidl);
            if (FAILED(hr))
                return hr;
        }

        if (pqnsi->dwMask & ASFQNSI_FLAGS)
            pqnsi->dwFlags = pns->FolderAttrib();

        if (pqnsi->dwMask & ASFQNSI_FOLDER)
        {
            pqnsi->psf = pns->Folder();
            if (pqnsi->psf)
                pqnsi->psf->AddRef();
        }

        if (pqnsi->dwMask & ASFQNSI_GUID)
            pqnsi->guidObject = pns->GetGUID();
    }
    return hr;
}



STDMETHODIMP CMergedFolder::EnumNameSpace(DWORD uNameSpace, DWORD *pdwID)
{
    if (uNameSpace == (DWORD)-1)
    {
        return ResultFromShort(_NamespaceCount());
    }

    if (uNameSpace < (UINT)_NamespaceCount())
    {
        // Our namespace IDs are just ordinals
        *pdwID = uNameSpace;
        return S_OK;
    }

    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}

// IAugmentedShellFolder2 methods
STDMETHODIMP CMergedFolder::UnWrapIDList(LPCITEMIDLIST pidlWrap, LONG cPidls, 
                                         IShellFolder** apsf, LPITEMIDLIST* apidlFolder, 
                                         LPITEMIDLIST* apidlItems, LONG* pcFetched)
{
    if (cPidls <= 0)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    
    //  Enumerate pidls in wrap
    LPITEMIDLIST pidlItem;
    CMergedFldrNamespace *pns;
    LONG cFetched;
    for (cFetched = 0; SUCCEEDED(hr) && (cFetched < cPidls) && SUCCEEDED(_GetSubPidl(pidlWrap, cFetched, NULL, &pidlItem, &pns)); cFetched++)
    {
        if (apsf)
        {
            apsf[cFetched] = pns->Folder();
            if (apsf[cFetched])
                apsf[cFetched]->AddRef();
        }
        if (apidlFolder)
        {
            hr = SHILClone(pns->GetIDList(), &apidlFolder[cFetched]);
        }
        if (apidlItems)
        {
            apidlItems[cFetched] = NULL;
            if (SUCCEEDED(hr))
            {
                hr = SHILClone(pidlItem, &apidlItems[cFetched]);
            }
        }
        ILFree(pidlItem);
    }

    if (SUCCEEDED(hr))
    {
        if (pcFetched)
        {
            *pcFetched = cFetched;
        }
    
        hr = (cFetched == cPidls) ? S_OK : S_FALSE;
    }
    else
    {
        // clean up items we've already allocated; since the caller won't free if we
        // return failure
        for (LONG i = 0; i < cFetched; i++)
        {
            if (apsf)
                ATOMICRELEASE(apsf[i]);
            if (apidlFolder)
                ILFree(apidlFolder[i]);
            if (apidlItems)
                ILFree(apidlItems[i]);
        }
    }

    return hr;
}


STDMETHODIMP CMergedFolder::SetOwner(IUnknown* punkOwner)
{
    DPA_EnumCallback(_hdpaNamespaces, _SetOwnerProc, punkOwner);
    return S_OK;
}


int CMergedFolder::_SetOwnerProc(void *pv, void *pvParam)
{
    CMergedFldrNamespace *pns = (CMergedFldrNamespace*) pv;
    return pns->SetOwner((IUnknown*)pvParam);
}


//  ITranslateShellChangeNotify methods

// old translate style only
LPITEMIDLIST CMergedFolder::_ILCombineBase(LPCITEMIDLIST pidlContainingBase, LPCITEMIDLIST pidlRel)
{
    // This routine differs from ILCombine in that it takes the First pidl's base, and
    // cats on the last id of the second pidl. We need this so Wrapped pidls
    // end up with the same base, and we get a valid full pidl.
    LPITEMIDLIST pidlRet = NULL;
    LPITEMIDLIST pidlBase = ILClone(pidlContainingBase);
    if (pidlBase)
    {
        ILRemoveLastID(pidlBase);
        pidlRet = ILCombine(pidlBase, pidlRel);
        ILFree(pidlBase);
    }

    return pidlRet;
}

BOOL CMergedFolder::_IsFolderEvent(LONG lEvent)
{
    return lEvent == SHCNE_MKDIR || lEvent == SHCNE_RMDIR || lEvent == SHCNE_RENAMEFOLDER;
}

BOOL GetRealPidlFromSimple(LPCITEMIDLIST pidlSimple, LPITEMIDLIST* ppidlReal)
{
    // Similar to SHGetRealIDL in Function, but SHGetRealIDL does SHGDN_FORPARSING | INFOLDER.
    // I need the parsing name. I can't rev SHGetRealIDL very easily, so here's this one!
    TCHAR szFullName[MAX_PATH];
    if (SUCCEEDED(SHGetNameAndFlags(pidlSimple, SHGDN_FORPARSING, szFullName, SIZECHARS(szFullName), NULL)))
    {
        *ppidlReal = ILCreateFromPath(szFullName);
    }

    if (*ppidlReal == NULL) // Unable to create? Then use the simple pidl. This is because it does not exist any more
    {                       // For say, a Delete Notify
        *ppidlReal = ILClone(pidlSimple);
    }

    return *ppidlReal != NULL;
}

// the new way we have of translating ids is better than the old way since it handles
// multi-level translation.
// the problem is that the old way is used extensively by the start menu, so the
// start menu will need to be rewritten to use the new way.  when that happens,
// then the old method can be ripped out.
STDMETHODIMP CMergedFolder::TranslateIDs(
    LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, 
    LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
    LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
    LPITEMIDLIST *ppidlOut2Event2)
{
    if (_fInShellView)
    {
        return _NewTranslateIDs(plEvent, pidl1, pidl2, ppidlOut1, ppidlOut2, plEvent2, ppidlOut1Event2, ppidlOut2Event2);
    }
    else
    {
        return _OldTranslateIDs(plEvent, pidl1, pidl2, ppidlOut1, ppidlOut2, plEvent2, ppidlOut1Event2, ppidlOut2Event2);
    }
}


// old version.
HRESULT CMergedFolder::_OldTranslateIDs(
    LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, 
    LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
    LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
    LPITEMIDLIST *ppidlOut2Event2)
{
    HRESULT hr = E_FAIL;

    if (!plEvent)
        return E_FAIL;

    switch (*plEvent)
    {
        case SHCNE_EXTENDED_EVENT:
        case SHCNE_ASSOCCHANGED:
        case SHCNE_UPDATEIMAGE:
            return S_OK;

        case SHCNE_UPDATEDIR:
            _FreeObjects();
            return S_OK;
    }

    ASSERT(ppidlOut1);
    ASSERT(ppidlOut2);
    LONG lEvent = *plEvent;

    *plEvent2 = (LONG)-1;
    *ppidlOut1Event2 = NULL;
    *ppidlOut2Event2 = NULL;
    
    *ppidlOut1 = (LPITEMIDLIST)pidl1;
    *ppidlOut2 = (LPITEMIDLIST)pidl2;

    // If they are already wrapped, don't wrap twice.
    if (SUCCEEDED(_IsWrap(ILFindLastID(pidl1))) ||
        SUCCEEDED(_IsWrap(ILFindLastID(pidl2))))
    {
        // We don't want to wrap twice.
        return E_FAIL;
    }

    if (!_hdpaNamespaces)
        return E_FAIL;

    if (!_hdpaObjects)
        return E_FAIL;

    CMergedFldrItem* pmfi;

    int iIndex;
    int iShellFolder1 = -1;
    int iShellFolder2 = -1;
    IShellFolder* psf1 = NULL;
    IShellFolder* psf2 = NULL;
    LPITEMIDLIST pidlReal1 = NULL;
    LPITEMIDLIST pidlReal2 = NULL;
    LPITEMIDLIST pidlRealRel1 = NULL;
    LPITEMIDLIST pidlRealRel2 = NULL;
    CMergedFldrNamespace * pns1 = NULL;
    CMergedFldrNamespace * pns2 = NULL;

    BOOL fFolder = _IsFolderEvent(*plEvent);

    // Get the information about these Simple pidls: Are they our Children? If so, what _Namespace?
    BOOL fChild1 = _IsChildIDInternal(pidl1, TRUE, &iShellFolder1);
    BOOL fChild2 = _IsChildIDInternal(pidl2, TRUE, &iShellFolder2);

    // Is either a child?
    if (!(fChild1 || fChild2))
        return hr;

    // Ok, pidl1 is a child, can we get the Real pidl from the simple one?
    if (pidl1 && !GetRealPidlFromSimple(pidl1, &pidlReal1))
        goto Cleanup;

    // Ok, pidl2 is a child, can we get the Real pidl from the simple one?
    if (pidl2 && !GetRealPidlFromSimple(pidl2, &pidlReal2))
        goto Cleanup;

    // These are for code clarity later on. We deal with Relative pidls from here until the very end,
    // when we combine the base of the in pidls with the outgoing wrapped pidls.
    if (pidlReal1)
        pidlRealRel1 = ILFindLastID(pidlReal1);

    if (pidlReal2)
        pidlRealRel2 = ILFindLastID(pidlReal2);

    // Is Pidl1 in our _Namespaces?
    if (iShellFolder1 != -1)
    {
        // Yes, lets get the non-refcounted shell folder that know's about this pidl.
        pns1 = _Namespace(iShellFolder1);
        psf1 = pns1->Folder();  // Non ref counted.
    }

    // Is Pidl2 in our _Namespaces?
    if (iShellFolder2 != -1)
    {
        // Yes, lets get the non-refcounted shell folder that know's about this pidl.
        pns2 = _Namespace(iShellFolder2);
        psf2 = pns2->Folder();  // Non ref counted.
    }

    hr = S_OK;

    switch(*plEvent)
    {
    case SHCNE_UPDATEITEM:
    case 0: // Just look up the pidls and return.
        {
            DWORD rgfAttrib = SFGAO_FOLDER;
            if (iShellFolder1 != -1)
            {
                psf1->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlRealRel1, &rgfAttrib);
                if (S_OK == _SearchForPidl(iShellFolder1, pns1, pidlRealRel1, BOOLIFY(rgfAttrib & SFGAO_FOLDER), &iIndex, &pmfi))
                {
                    *ppidlOut1 = _ILCombineBase(pidlReal1, pmfi->GetIDList());
                    if (!*ppidlOut1)
                        hr = E_OUTOFMEMORY;
                }
            }

            rgfAttrib = SFGAO_FOLDER;
            if (iShellFolder2 != -1 && SUCCEEDED(hr))
            {
                psf2->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlRealRel2, &rgfAttrib);
                if (S_OK == _SearchForPidl(iShellFolder2, pns2, pidlRealRel2, BOOLIFY(rgfAttrib & SFGAO_FOLDER), &iIndex, &pmfi))
                {
                    *ppidlOut2 = _ILCombineBase(pidlReal2, pmfi->GetIDList());
                    if (!*ppidlOut2)
                        hr = E_OUTOFMEMORY;
                }
            }
        }
        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        {
            TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s", fFolder?  TEXT("SHCNE_MKDIR") : TEXT("SHCNE_CREATE")); 

            // Is there a thing of this name already?
            if (S_OK == _SearchForPidl(iShellFolder1, pns1, pidlRealRel1, fFolder, &iIndex, &pmfi))
            {
                TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s needs to be merged. Converting to Rename", pmfi->GetDisplayName());

                // Yes; Then we need to merge this new pidl into the wrapped pidl, and change this
                // to a rename, passing the Old wrapped pidl as the first arg, and the new wrapped pidl
                // as the second arg. I have to be careful about the freeing:
                // Free *ppidlOut1
                // Clone pmfi->pidlWrap -> *ppidlOut1.
                // Add pidl1 to pmfi->_pidlWrap.
                // Clone new pmfi->_pidlWrap -> *ppidlOut2.  ASSERT(*ppidlOut2 == NULL)

                *ppidlOut1 = _ILCombineBase(pidl1, pmfi->GetIDList());
                if (*ppidlOut1)
                {
                    _WrapAddIDList(pidlRealRel1, iShellFolder1, &pmfi->_pidlWrap); 
                    *ppidlOut2 = _ILCombineBase(pidl1, pmfi->GetIDList());

                    if (!*ppidlOut2)
                        TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to create new pidl2");

                    *plEvent = fFolder? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;
                }
                else
                {
                    TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to create new pidl1");
                }
            }
            else
            {
                CMergedFldrItem* pmfiEnum = new CMergedFldrItem;
                if (pmfiEnum)
                {
                    LPITEMIDLIST pidlWrap;
                    if (SUCCEEDED(_CreateWrap(pidlRealRel1, (UINT)iShellFolder1, &pidlWrap)) &&
                        pmfiEnum->Init(SAFECAST(this, IAugmentedShellFolder2*), pidlWrap, iShellFolder1))
                    {
                        SEARCH_FOR_PIDL sfp;
                        sfp.pszDisplayName = pmfiEnum->GetDisplayName();
                        sfp.fFolder = fFolder;
                        sfp.self = this;
                        sfp.iNamespace = -1;

                        int iInsertIndex = DPA_Search(_hdpaObjects, &sfp, 0,
                                _SearchByName, NULL, DPAS_SORTED | DPAS_INSERTAFTER);

                        TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Creating new unmerged %s at %d", pmfiEnum->GetDisplayName(), iInsertIndex);

                        if (iInsertIndex < 0)
                            iInsertIndex = DA_LAST;

                        if (DPA_InsertPtr(_hdpaObjects, iInsertIndex, pmfiEnum) == -1)
                        {
                            TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Was unable to add %s for some reason. Bailing", 
                                pmfiEnum->GetDisplayName());
                            delete pmfiEnum;
                        }
                        else
                        {
                            *ppidlOut1 = _ILCombineBase(pidl1, pmfiEnum->GetIDList());
                        }
                    }
                    else
                        delete pmfiEnum;
                }
            }

        }
        break;

    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        {
            TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s", fFolder? 
                TEXT("SHCNE_RMDIR") : TEXT("SHCNE_DELETE")); 
            int iDeleteIndex;
            // Is there a folder of this name already?
            if (S_OK == _SearchForPidl(iShellFolder1, pns1, pidlRealRel1,
                fFolder, &iDeleteIndex, &pmfi))
            {
                TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Found %s checking merge state.", pmfi->GetDisplayName()); 
                // Yes; Then we need to unmerge this pidl from the wrapped pidl, and change this
                // to a rename, passing the Old wrapped pidl as the first arg, and the new wrapped pidl
                // as the second arg. I have to be careful about the freeing:
                // Free *ppidlOut1
                // Clone pmfi->GetIDList() -> *ppidlOut1.
                // Remove pidl1 from pmfi->_GetIDList()
                // Convert to rename, pass new wrapped as second arg. 

                if (_GetSourceCount(pmfi->GetIDList())  > 1)
                {
                    TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s is Merged. Removing pidl, convert to rename", pmfi->GetDisplayName()); 
                    *ppidlOut1 = _ILCombineBase(pidl1, pmfi->GetIDList());
                    if (*ppidlOut1)
                    {
                        LPITEMIDLIST pidlFree = pmfi->GetIDList();
                        if (SUCCEEDED(_WrapRemoveIDList(pidlFree, iShellFolder1, &pmfi->_pidlWrap)))
                        {
                            ILFree(pidlFree);
                        }

                        *ppidlOut2 = _ILCombineBase(pidl1, pmfi->GetIDList());
                        if (!*ppidlOut2)
                            TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to create new pidl2");

                        *plEvent = fFolder? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;
                    }
                    else
                    {
                        TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to create new pidl1");
                    }
                }
                else
                {
                    TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s is not Merged. deleteing", pmfi->GetDisplayName()); 
                    pmfi = (CMergedFldrItem*)DPA_DeletePtr(_hdpaObjects, iDeleteIndex);
                    if (EVAL(pmfi))
                    {
                        *ppidlOut1 = _ILCombineBase(pidl1, pmfi->GetIDList());
                        delete pmfi;
                    }
                    else
                    {
                        TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to get %d from DPA", iDeleteIndex);
                    }
                }
            }
        }
        break;

    case SHCNE_RENAMEITEM:
    case SHCNE_RENAMEFOLDER:
        {
            // REARCHITECT: (lamadio): When renaming an item in the menu, this code will split it into
            // a Delete and a Create. We need to detect this situation and convert it to 1 rename. This
            // will solve the problem of the lost order during a rename....
            BOOL fEvent1Set = FALSE;
            BOOL fFirstPidlInNamespace = FALSE;
            TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s", fFolder? 
                TEXT("SHCNE_RENAMEFOLDER") : TEXT("SHCNE_RENAMEITEM")); 

            // Is this item being renamed FROM the Folder?
            if (iShellFolder1 != -1)
            {
                // Is this pidl a child of the Folder?
                if (S_OK == _SearchForPidl(iShellFolder1, pns1, pidlRealRel1,
                    fFolder, &iIndex, &pmfi))  // Is it found?
                {
                    TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Old pidl %s is in the Folder", pmfi->GetDisplayName()); 
                    // Yes.
                    // Then we need to see if the item that it's being renamed from was Merged

                    // Need this for reentrancy
                    if (_ContainsSrcID(pmfi->GetIDList(), iShellFolder1))
                    {
                        // Was it merged?
                        if (_GetSourceCount(pmfi->GetIDList()) > 1)    // Case 3)
                        {
                            // Yes; Then we need to unmerge that item.
                            *ppidlOut1 = _ILCombineBase(pidl1, pmfi->GetIDList());
                            if (*ppidlOut1)
                            {
                                LPITEMIDLIST pidlFree = pmfi->GetIDList();
                                if (SUCCEEDED(_WrapRemoveIDList(pidlFree, iShellFolder1, &pmfi->_pidlWrap)))
                                {
                                    ILFree(pidlFree);
                                }

                                *ppidlOut2 = _ILCombineBase(pidl1, pmfi->GetIDList());
                                if (!*ppidlOut2)
                                    TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to create new pidl2");

                                // This We need to "Rename" the old wrapped pidl, to this new one
                                // that does not contain the old item.
                                fEvent1Set = TRUE;
                            }
                            else
                            {
                                TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to create new pidl1");
                            }
                        }
                        else
                        {
                            TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s is not merged. Nuking item Convert to Delete for event 1.", 
                                pmfi->GetDisplayName()); 
                            // No, This was not a wrapped pidl. Then, convert to a delete:
                            pmfi = (CMergedFldrItem*)DPA_DeletePtr(_hdpaObjects, iIndex);

                            if (EVAL(pmfi))
                            {
                                // If we're renaming from this folder, into this folder, Then the first event stays a rename.
                                if (iShellFolder2 == -1)
                                {
                                    fEvent1Set = TRUE;
                                    *plEvent = fFolder? SHCNE_RMDIR : SHCNE_DELETE;
                                }
                                else
                                {
                                    fFirstPidlInNamespace = TRUE;
                                }
                                *ppidlOut1 = _ILCombineBase(pidl1, pmfi->GetIDList());
                                delete pmfi;
                            }
                            else
                            {
                                TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to find Item at %d", iIndex);
                            }

                        }
                    }
                    else
                    {
                        TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Skipping this because we already processed it."
                            "Dragging To Desktop?");
                        hr = E_FAIL;
                    }
                }
                else
                {
                    // we were told to rename something that is supposed to exist in the first
                    // namespace, but we couldn't find it.
                    // we dont want to have the caller fire off some more events because of this,
                    // so we fail.
                    hr = E_FAIL;
                }
            }

            // Is this item is being rename INTO the Start Menu?
            if (iShellFolder2 != -1)
            {
                TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: New pidl is in the Folder"); 
                LPITEMIDLIST* ppidlNewWrapped1 = ppidlOut1;
                LPITEMIDLIST* ppidlNewWrapped2 = ppidlOut2;
                LONG* plNewEvent = plEvent;

                if (fEvent1Set)
                {
                    plNewEvent = plEvent2;
                    ppidlNewWrapped1 = ppidlOut1Event2;
                    ppidlNewWrapped2 = ppidlOut2Event2;
                }

                if (S_OK == _SearchForPidl(iShellFolder2, pns2, pidlRealRel2,
                    fFolder, &iIndex, &pmfi))
                {
                    // If we're renaming from this folder, into this folder, Check to see if the destination has a
                    // conflict. If there is a confict (This case), then convert first event to a remove, 
                    // and the second event to the rename.
                    if (fFirstPidlInNamespace)
                    {
                        fEvent1Set = TRUE;
                        *plEvent = fFolder? SHCNE_RMDIR : SHCNE_DELETE;
                        plNewEvent = plEvent2;
                        ppidlNewWrapped1 = ppidlOut1Event2;
                        ppidlNewWrapped2 = ppidlOut2Event2;
                    }
                    
                    TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s is in Folder", pmfi->GetDisplayName());
                    TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Adding pidl to %s. Convert to Rename for event %s", 
                        pmfi->GetDisplayName(), fEvent1Set? TEXT("2") : TEXT("1"));

                    // Then the destination needs to be merged.
                    *ppidlNewWrapped1 = _ILCombineBase(pidl2, pmfi->GetIDList());
                    if (*ppidlNewWrapped1)
                    {
                        TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Successfully created out pidl1");

                        _WrapAddIDList(pidlRealRel2, iShellFolder2, &pmfi->_pidlWrap); 
                        *ppidlNewWrapped2 = _ILCombineBase(pidl2, pmfi->GetIDList());

                        *plNewEvent = fFolder? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;
                    }
                }
                else
                {
                    CMergedFldrItem* pmfiEnum = new CMergedFldrItem;
                    if (pmfiEnum)
                    {
                        LPITEMIDLIST pidlWrap;
                        if (SUCCEEDED(_CreateWrap(pidlRealRel2, (UINT)iShellFolder2, &pidlWrap)) &&
                            pmfiEnum->Init(SAFECAST(this, IAugmentedShellFolder2*), pidlWrap, iShellFolder2))
                        {
                            SEARCH_FOR_PIDL sfp;
                            sfp.pszDisplayName = pmfiEnum->GetDisplayName();
                            sfp.fFolder = BOOLIFY(pmfiEnum->GetFolderAttrib() & SFGAO_FOLDER);
                            sfp.self = this;
                            sfp.iNamespace = -1;

                            int iInsertIndex = DPA_Search(_hdpaObjects, &sfp, 0,
                                                           _SearchByName, NULL, 
                                                           DPAS_SORTED | DPAS_INSERTAFTER);

                            TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s is a new item. Converting to Create", pmfiEnum->GetDisplayName());

                            if (iInsertIndex < 0)
                                iInsertIndex = DA_LAST;

                            if (DPA_InsertPtr(_hdpaObjects, iInsertIndex, pmfiEnum) == -1)
                            {
                                TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Was unable to add %s for some reason. Bailing", 
                                                    pmfiEnum->GetDisplayName());
                                delete pmfiEnum;
                            }
                            else
                            {
                                TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Creating new item %s at %d for event %s", 
                                                  pmfiEnum->GetDisplayName(), iInsertIndex,  fEvent1Set? TEXT("2") : TEXT("1"));

                                // If we're renaming from this folder, into this folder, Then the first event stays
                                // a rename.
                                if (!fFirstPidlInNamespace)
                                {
                                    *plNewEvent = fFolder ? SHCNE_MKDIR : SHCNE_CREATE;
                                    *ppidlNewWrapped1 = _ILCombineBase(pidl2, pidlWrap);
                                    *ppidlNewWrapped2 = NULL;
                                }
                                else
                                    *ppidlOut2 = _ILCombineBase(pidl2, pidlWrap);
                            }
                        }
                        else
                            delete pmfiEnum;
                    }
                }
            }
        }
        break;

    default:
        break;
    }

Cleanup:
    ILFree(pidlReal1);
    ILFree(pidlReal2);

    return hr;
}


// parsedisplayname with some extras.
// this is used to process change notifies.  the change notify can be fired AFTER the
// item has been moved/deleted/whatever, but we still have to be able to correctly process that
// pidl.  so here pidlAbsNamespace identifies the absolute pidl of the item being changenotified.
// if we're parsing a name within that namespace, force the parsedisplayname with STGM_CREATE to
// make sure we get the pidl (because it may have been moved or deleted by now) if fForce==TRUE.
HRESULT CMergedFolder::_ForceParseDisplayName(LPCITEMIDLIST pidlAbsNamespace, LPTSTR pszDisplayName, BOOL fForce, BOOL *pfOthersInWrap, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    *pfOthersInWrap = FALSE;

    HRESULT hr = S_OK;

    // set up a bindctx: will have STGM_CREATE if fForce is passed, NULL otherwise
    IBindCtx *pbc;
    if (fForce)
    {
        hr = BindCtx_CreateWithMode(STGM_CREATE, &pbc);
    }
    else
    {
        pbc = NULL;
    }

    if (SUCCEEDED(hr))
    {
        CMergedFldrNamespace *pnsWrap = NULL;
        CMergedFldrNamespace *pnsLoop;
        for (int i = 0; SUCCEEDED(hr) && (pnsLoop = _Namespace(i)); i++)
        {
            HRESULT hrLoop = E_FAIL;  // not propagated since ParseDisplayName can fail and that's okay
            
            LPITEMIDLIST pidlNamespace;
            // so if the namespace pnsLoop is a parent to the pidl, we know it
            // came from there so use the bindctx to force creation if necessary
            if (ILIsParent(pnsLoop->GetIDList(), pidlAbsNamespace, FALSE))
            {
                hrLoop = pnsLoop->Folder()->ParseDisplayName(NULL, pbc, pszDisplayName, NULL, &pidlNamespace, NULL);
            }
            else if (_ShouldMergeNamespaces(pnsWrap, pnsLoop))
            {
                pnsWrap = pnsLoop;
                // only if we're merging, tack on other namespace's pidls.
                hrLoop = pnsLoop->Folder()->ParseDisplayName(NULL, NULL, pszDisplayName, NULL, &pidlNamespace, NULL);
            }

            if (SUCCEEDED(hrLoop))
            {
                if (*ppidl)
                {
                    *pfOthersInWrap = TRUE;
                }
                hr = _WrapAddIDList(pidlNamespace, i, ppidl);
    
                ILFree(pidlNamespace);
            }
        }

        // it could be NULL
        if (pbc)
        {
            pbc->Release();
        }
    }
    return hr;
}


// this takes an absolute pidl in the given namespace and converts it to a merged pidl.
// if the item does not actually exist in the namespace, it forces creation if fForce==TRUE (so if
// a changenotify comes in on that namespace it will process it normally, even if the
// underlying item has been moved or deleted).
HRESULT CMergedFolder::_AbsPidlToAbsWrap(CMergedFldrNamespace *pns, LPCITEMIDLIST pidl, BOOL fForce, BOOL *pfOthersInWrap, LPITEMIDLIST *ppidl)
{
    LPCITEMIDLIST pidlRel = ILFindChild(pns->GetIDList(), pidl);
    HRESULT hr = SHILClone(_pidl, ppidl);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = SHCreateSkipBindCtx(NULL, &pbc); // skip all other binding
        if (SUCCEEDED(hr))
        {
            CMergedFolder *pmfMerged = this;
            pmfMerged->AddRef();

            IShellFolder *psfNamespace = pns->Folder();
            psfNamespace->AddRef();

            HRESULT hrLoop = S_OK;
            while (SUCCEEDED(hr) && SUCCEEDED(hrLoop) && !ILIsEmpty(pidlRel))
            {
                hr = E_OUTOFMEMORY;
                LPITEMIDLIST pidlRelFirst = ILCloneFirst(pidlRel);
                if (pidlRelFirst)
                {
                    TCHAR szRelPath[MAX_PATH];
                    hr = DisplayNameOf(psfNamespace, pidlRelFirst, SHGDN_FORPARSING | SHGDN_INFOLDER, szRelPath, ARRAYSIZE(szRelPath));

                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlNextPart;
                        hr = pmfMerged->_ForceParseDisplayName(pidl, szRelPath, fForce, pfOthersInWrap, &pidlNextPart);
                        if (SUCCEEDED(hr))
                        {
                            // shilappend frees pidlnextpart
                            hr = SHILAppend(pidlNextPart, ppidl);
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        // advance and clean up
                        IShellFolder *psfFree = psfNamespace;
                        psfNamespace = NULL;
                        hrLoop = psfFree->BindToObject(pidlRelFirst, pbc, IID_PPV_ARG(IShellFolder, &psfNamespace));
                        psfFree->Release();

                        if (SUCCEEDED(hrLoop))
                        {
                            CMergedFolder *pmfFree = pmfMerged;
                            pmfMerged = NULL;
                            hrLoop = pmfFree->BindToObject(ILFindLastID(*ppidl), pbc, CLSID_MergedFolder, (void **) &pmfMerged);
                            pmfFree->Release();
                        }

                        pidlRel = ILGetNext(pidlRel);
                    }

                    ILFree(pidlRelFirst);
                }
            }

            if (pmfMerged)
                pmfMerged->Release();
            if (psfNamespace)
                psfNamespace->Release();

            pbc->Release();
        }
    }
    return hr;
}


// new translateids.
// when the start menu works a little better this whole interface can be revised.
HRESULT CMergedFolder::_NewTranslateIDs(
    LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, 
    LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
    LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
    LPITEMIDLIST *ppidlOut2Event2)
{
    if (!plEvent || !ppidlOut1 || !ppidlOut2)
        return E_INVALIDARG;

    // If they are already wrapped, don't wrap twice.
    if (SUCCEEDED(_IsWrap(ILFindLastID(pidl1))) ||
        SUCCEEDED(_IsWrap(ILFindLastID(pidl2))))
    {
        // We don't want to wrap twice.
        return E_INVALIDARG;
    }

    if (!_hdpaNamespaces)
        return E_FAIL;

    HRESULT hr = E_FAIL;

    switch (*plEvent)
    {
        case SHCNE_EXTENDED_EVENT:
        case SHCNE_ASSOCCHANGED:
        case SHCNE_UPDATEIMAGE:
            return S_OK;
    }

    LONG lEvent = *plEvent;

    *plEvent2 = (LONG)-1;
    *ppidlOut1Event2 = NULL;
    *ppidlOut2Event2 = NULL;
    
    *ppidlOut1 = (LPITEMIDLIST)pidl1;
    *ppidlOut2 = (LPITEMIDLIST)pidl2;

    CMergedFldrNamespace *pns1, *pns2;
    int iShellFolder1, iShellFolder2;
    BOOL fPidl1IsChild, fPidl2IsChild;
    // Get the information about these Simple pidls: Are they our Children? If so, what _Namespace?
    fPidl1IsChild = _IsChildIDInternal(pidl1, FALSE, &iShellFolder1);
    if (fPidl1IsChild)
    {
        pns1 = _Namespace(iShellFolder1);
    }
    fPidl2IsChild = _IsChildIDInternal(pidl2, FALSE, &iShellFolder2);
    if (fPidl2IsChild)
    {
        pns2 = _Namespace(iShellFolder2);
    }

    // and is either a child?
    if (fPidl1IsChild || fPidl2IsChild)
    {
        hr = S_OK;

        BOOL fOthersInNamespace1, fOthersInNamespace2;

        BOOL fFolderEvent = FALSE;
        switch (*plEvent)
        {
        case SHCNE_MKDIR:
            fFolderEvent = TRUE;
        case SHCNE_CREATE:
            if (fPidl1IsChild)
            {
                hr = _AbsPidlToAbsWrap(pns1, pidl1, FALSE, &fOthersInNamespace1, ppidlOut1);
                if (SUCCEEDED(hr) && fOthersInNamespace1 && !_fDontMerge)
                {
                    // whoops, it was already here and this create should become a rename
                    // since we're just merging in with the existing pidl.
                    *plEvent = fFolderEvent ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;

                    // this new wrapped one is what it's renamed TO so bump it to ppidlOut2.
                    *ppidlOut2 = *ppidlOut1;
                    // strip it to get what it used to be.
                    hr = _WrapRemoveIDListAbs(*ppidlOut2, iShellFolder1, ppidlOut1);
                }
            }
            break;

        case SHCNE_RMDIR:
            fFolderEvent = TRUE;
        case SHCNE_DELETE:
            if (fPidl1IsChild)
            {
                hr = _AbsPidlToAbsWrap(pns1, pidl1, TRUE, &fOthersInNamespace1, ppidlOut1);
                if (SUCCEEDED(hr) && fOthersInNamespace1 && !_fDontMerge)
                {
                    // whoops, there are still more parts to it and it should become a rename
                    // since we're just unmerging from the existing pidl.
                    *plEvent = fFolderEvent ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;

                    // strip it to get the "deleted" version
                    hr = _WrapRemoveIDListAbs(*ppidlOut1, iShellFolder1, ppidlOut2);
                }
            }
            break;

        case SHCNE_RENAMEFOLDER:
            fFolderEvent = TRUE;
        case SHCNE_RENAMEITEM:
            if (fPidl1IsChild)
            {
                // this is just like a delete.
                *plEvent = fFolderEvent ? SHCNE_RMDIR : SHCNE_DELETE;
                hr = _AbsPidlToAbsWrap(pns1, pidl1, TRUE, &fOthersInNamespace1, ppidlOut1);
                if (SUCCEEDED(hr) && fOthersInNamespace1 && !_fDontMerge)
                {
                    // whoops, there are still more parts to it and it should become a rename
                    // since we're just unmerging from the existing pidl.
                    *plEvent = fFolderEvent ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;

                    // strip it to get the "deleted" version
                    hr = _WrapRemoveIDListAbs(*ppidlOut1, iShellFolder1, ppidlOut2);
                }

                // set ourselves up so that if fPidl2IsChild, it will write into the second event.
                plEvent = plEvent2;
                ppidlOut1 = ppidlOut1Event2;
                ppidlOut2 = ppidlOut2Event2;
            }

            if (fPidl2IsChild)
            {
                // this is just like a create.
                *plEvent = fFolderEvent ? SHCNE_MKDIR : SHCNE_CREATE;
                hr = _AbsPidlToAbsWrap(pns2, pidl2, FALSE, &fOthersInNamespace2, ppidlOut1);
                if (SUCCEEDED(hr) && fOthersInNamespace2 && !_fDontMerge)
                {
                    // whoops, it was already here and this create should become a rename
                    // since we're just merging in with the existing pidl.
                    *plEvent = fFolderEvent ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;

                    // this new wrapped one is what it's renamed TO so bump it to ppidlOut2.
                    *ppidlOut2 = *ppidlOut1;
                    // strip it to get what it used to be.
                    hr = _WrapRemoveIDListAbs(*ppidlOut2, iShellFolder2, ppidlOut1);
                }
            }
            break;

        case SHCNE_UPDATEDIR:
        case SHCNE_UPDATEITEM:
        case SHCNE_MEDIAINSERTED:
        case SHCNE_MEDIAREMOVED:
            hr = _AbsPidlToAbsWrap(pns1, pidl1, FALSE, &fOthersInNamespace1, ppidlOut1);
            break;

        default:
            break;
        }
    }

    return hr;
}

STDMETHODIMP CMergedFolder::IsChildID(LPCITEMIDLIST pidlKid, BOOL fImmediate)
{
    return _IsChildIDInternal(pidlKid, fImmediate, NULL) ? S_OK : S_FALSE;
}


STDMETHODIMP CMergedFolder::IsEqualID(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // This used to return E_NOTIMPL. I'm kinda overloading the interface to mean:
    // is this equal tp any of your _Namespaces.
    HRESULT hr = S_FALSE;

    CMergedFldrNamespace *pns;
    for (int i = 0; (hr == S_FALSE) && (pns = _Namespace(i)); i++)
    {
        if (pidl1)
        {
            if (ILIsEqual(pns->GetIDList(), pidl1))
                hr = S_OK;
        }
        else if (pidl2) // If you pass a pidl2 it means: Is pidl2 a parent of one of my _Namespaces?
        {
            if (ILIsParent(pidl2, pns->GetIDList(), FALSE))
                hr = S_OK;
        }
    }
    return hr;
}


typedef struct
{
    HWND hwnd;
    UINT uMsg;
    LONG lEvents;
} REGISTERNOTIFYINFO;

int CMergedFolder::_SetNotifyProc(void *pv, void *pvParam)
{
    CMergedFldrNamespace *pns = (CMergedFldrNamespace*)pv;
    if (pvParam)
    {
        REGISTERNOTIFYINFO *prni = (REGISTERNOTIFYINFO*)pvParam;
        pns->RegisterNotify(prni->hwnd, prni->uMsg, prni->lEvents);
    }
    else
    {
        pns->UnregisterNotify();
    }
    return 1;
}

STDMETHODIMP CMergedFolder::Register(HWND hwnd, UINT uMsg, long lEvents)
{
    if (_fInShellView)
    {
        // only register the alias if we have no parent folder
        // the merged folder at the junction point can take care of the registration
        // for everybody.
        if (_pidl && !_pmfParent)
        {
            CMergedFldrNamespace *pns;
            for (int i = 0; pns = _Namespace(i); i++)
            {
                if (!ILIsEqual(pns->GetIDList(), _pidl))
                {
                    SHChangeNotifyRegisterAlias(pns->GetIDList(), _pidl);
                }
            }
        }
    }
    else if (_hdpaNamespaces)
    {
        REGISTERNOTIFYINFO rni = {hwnd, uMsg, lEvents};
        DPA_EnumCallback(_hdpaNamespaces, _SetNotifyProc, &rni);
    }
    return S_OK;
}

STDMETHODIMP CMergedFolder::Unregister()
{
    if (_hdpaNamespaces)
    {
        DPA_EnumCallback(_hdpaNamespaces, _SetNotifyProc, NULL);
    }
    return S_OK;
}


BOOL CMergedFolder::_IsChildIDInternal(LPCITEMIDLIST pidlKid, BOOL fImmediate, int* piShellFolder)
{
    // This is basically the same Method as the interface method, but returns the shell folder
    // that it came from.
    BOOL fChild = FALSE;

    //At this point we should have a translated pidl
    if (SUCCEEDED(_IsWrap(pidlKid)))
    {
        LPCITEMIDLIST pidlRelKid = ILFindLastID(pidlKid);
        if (pidlRelKid)
        {
            CMergedFldrNamespace *pns;
            for (int i = 0; !fChild && (pns = _Namespace(i)); i++)
            {
                if (ILIsParent(pns->GetIDList(), pidlKid, fImmediate) &&
                    !ILIsEqual(pns->GetIDList(), pidlKid))
                {
                    fChild = TRUE;
                    if (piShellFolder)
                        *piShellFolder = i;
                }
            }
        }
    }
    else if (pidlKid)
    {
        CMergedFldrNamespace *pns;
        for (int i = 0; !fChild && (pns = _Namespace(i)); i++)
        {
            if (ILIsParent(pns->GetIDList(), pidlKid, fImmediate))
            {
                fChild = TRUE;
                if (piShellFolder)
                    *piShellFolder = i;
            }
        }
    }

    return fChild;
}


HRESULT CMergedFolder::_SearchForPidl(int iNamespace, CMergedFldrNamespace *pns, LPCITEMIDLIST pidl, BOOL fFolder, int* piIndex, CMergedFldrItem** ppmfi)
{
    int iIndex = -1;
    *ppmfi = NULL;

    TCHAR szDisplayName[MAX_PATH];
    if (SUCCEEDED(DisplayNameOf(pns->Folder(), pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szDisplayName, ARRAYSIZE(szDisplayName))))
    {
        SEARCH_FOR_PIDL sfp;
        sfp.pszDisplayName = szDisplayName;
        sfp.fFolder = fFolder;
        sfp.self = this;
        if (_fPartialMerge)
        {
            sfp.iNamespace = iNamespace;
        }
        else
        {
            sfp.iNamespace = -1;
        }

        iIndex = DPA_Search(_hdpaObjects, &sfp, 0, _SearchByName, NULL, DPAS_SORTED);

        if (iIndex >= 0)
        {
            *ppmfi = _GetObject(iIndex);
        }
    }

    if (piIndex)
        *piIndex = iIndex;

    if (*ppmfi)
        return S_OK;

    return S_FALSE;
}

HRESULT CMergedFolder::_GetTargetUIObjectOf(IShellFolder *psf, HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, UINT *prgf, void **ppv)
{
    *ppv = NULL;

    IPersistFolder3 *ppf3;
    HRESULT hr = psf->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf3));
    if (SUCCEEDED(hr))
    {
        PERSIST_FOLDER_TARGET_INFO pfti;
        hr = ppf3->GetFolderTargetInfo(&pfti);
        if (SUCCEEDED(hr) && pfti.pidlTargetFolder)
        {
            IShellFolder *psfTarget;
            hr = SHBindToObjectEx(NULL, pfti.pidlTargetFolder, NULL, IID_PPV_ARG(IShellFolder, &psfTarget));
            if (SUCCEEDED(hr))
            {
                DWORD dwAttrib = SFGAO_VALIDATE;
                hr = psfTarget->GetAttributesOf(cidl, apidl, &dwAttrib);
                if (SUCCEEDED(hr))
                {
                    hr = psfTarget->GetUIObjectOf(hwnd, cidl, apidl, riid, prgf, ppv);
                }
                psfTarget->Release();
            }
            ILFree(pfti.pidlTargetFolder);
        }
        else
        {
            hr = E_FAIL;
        }
        ppf3->Release();
    }

    if (FAILED(hr))
    {
        DWORD dwAttrib = SFGAO_VALIDATE;
        hr = psf->GetAttributesOf(cidl, apidl, &dwAttrib);
        if (SUCCEEDED(hr))
        {
            hr = psf->GetUIObjectOf(hwnd, cidl, apidl, riid, prgf, ppv);
        }
    }
    return hr;
}

HRESULT CMergedFolder::_GetContextMenu(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    UINT iNumCommon = 0;
    LPITEMIDLIST *apidlCommon = new LPITEMIDLIST[cidl];
    if (apidlCommon)
    {
        UINT iNumUser = 0;
        LPITEMIDLIST *apidlUser = new LPITEMIDLIST[cidl];
        if (apidlUser)
        {
            IShellFolder *psf, *psfCommon, *psfUser;  // not ref counted
            LPITEMIDLIST pidl;
            for (UINT i = 0; i < cidl; i++)
            {
                if (SUCCEEDED(_NamespaceForItem(apidl[i], ASFF_COMMON, ASFF_COMMON, &psf, &pidl, NULL, TRUE)))
                {
                    apidlCommon[iNumCommon++] = pidl;
                    psfCommon = psf;
                }
                if (SUCCEEDED(_NamespaceForItem(apidl[i], ASFF_COMMON, 0, &psf, &pidl, NULL, TRUE)))
                {
                    apidlUser[iNumUser++] = pidl;
                    psfUser = psf;
                }
            }

            IContextMenu *pcmCommon = NULL;
            if (iNumCommon)
            {
                _GetTargetUIObjectOf(psfCommon, hwnd, iNumCommon, (LPCITEMIDLIST *)apidlCommon, IID_X_PPV_ARG(IContextMenu, NULL, &pcmCommon));
            }

            IContextMenu *pcmUser = NULL;
            if (iNumUser)
            {
                _GetTargetUIObjectOf(psfUser, hwnd, iNumUser, (LPCITEMIDLIST *)apidlUser, IID_X_PPV_ARG(IContextMenu, NULL, &pcmUser));
            }

            BOOL fMerge = _fInShellView || (cidl == 1) && _IsFolder(apidl[0]);
            if (fMerge && (pcmCommon || pcmUser))
            {
                hr = CMergedFldrContextMenu_CreateInstance(hwnd, this, cidl, apidl, pcmCommon, pcmUser, (IContextMenu**)ppv);
            }
            else if (pcmUser)
            {
                hr = pcmUser->QueryInterface(riid, ppv);
            }
            else if (pcmCommon)
            {
                hr = pcmCommon->QueryInterface(riid, ppv);
            }
            else
            {
                hr = E_FAIL;
            }

            for (i = 0; i < iNumCommon; i++)
            {
                ILFree(apidlCommon[i]);
            }
            for (i = 0; i < iNumUser; i++)
            {
                ILFree(apidlUser[i]);
            }

            ATOMICRELEASE(pcmCommon);
            ATOMICRELEASE(pcmUser);
            delete [] apidlUser;
        }
        delete [] apidlCommon;
    }

    return hr;
}


// out:
//      *ppsf       unreffed psf, don't call ->Release()!
//      *ppidlItem  clone of pidl in pidlWrap (nested pidl)

HRESULT CMergedFolder::_NamespaceForItem(LPCITEMIDLIST pidlWrap, ULONG dwAttribMask, ULONG dwAttrib, 
                                         IShellFolder **ppsf, LPITEMIDLIST *ppidlItem, CMergedFldrNamespace **ppns, BOOL fExact)
{
    if (ppsf)
        *ppsf = NULL;
    if (ppns)
        *ppns = NULL;

    // first try to get the prefered name space based
    HRESULT hr = E_UNEXPECTED;  // assume failure from here
    CMergedFldrNamespace *pns;
    LPITEMIDLIST pidl;
    for (UINT i = 0; SUCCEEDED(_GetSubPidl(pidlWrap, i, NULL, &pidl, &pns)); i++)
    {
        if ((dwAttribMask & dwAttrib) == (dwAttribMask & pns->FolderAttrib()))
        {
            hr = S_OK; // don't free, we're going to hand this one back.
            break;
        }
        ILFree(pidl);
    }

    // not found, fall back to the first name space in the wrapped pidl
    if (!fExact && FAILED(hr))
    {
        hr = _GetSubPidl(pidlWrap, 0, NULL, &pidl, &pns);
    }

    // it succeeded, so lets pass out the information that the caller wanted    
    if (SUCCEEDED(hr))
    {
        if (ppsf)
            *ppsf = pns->Folder();
        if (ppns)
            *ppns = pns;
        if (ppidlItem)
        {
            // transfer ownership
            *ppidlItem = pidl;
        }
        else
        {
            ILFree(pidl);
        }
    }

    return hr;
}

BOOL CMergedFolder::_NamespaceMatches(ULONG dwAttribMask, ULONG dwAttrib, LPCGUID pguid, CMergedFldrNamespace *pns)
{
    BOOL fRet = FALSE;

    dwAttrib &= dwAttribMask;

    if (dwAttrib == (dwAttribMask & pns->FolderAttrib()))
    {
        // If ASFF_MERGESAMEGUID is set, then the GUID must also match
        if (!(dwAttrib & ASFF_MERGESAMEGUID) ||
            IsEqualGUID(*pguid, pns->GetGUID()))
        {
            fRet = TRUE;
        }
    }
    return fRet;
}

// find a name space based on its attributes
// dwAttribMask is a mask of the bits to test
// dwAttrib is the value of the bits in the mask, tested for equality
// pguid is the GUID to match if dwAttrib includes ASFF_MERGESAMEGUID
//
// pnSrcID is optional out param
HRESULT CMergedFolder::_FindNamespace(ULONG dwAttribMask, ULONG dwAttrib, LPCGUID pguid,
                                      CMergedFldrNamespace **ppns, BOOL fFallback)
{
    *ppns = NULL;

    CMergedFldrNamespace *pns;
    int i;

    // first look for a matching namespace.
    for (i = 0; !*ppns && (pns = _Namespace(i)); i++)
    {
        if (!_ShouldSuspend(pns->GetGUID()) && _NamespaceMatches(dwAttribMask, dwAttrib, pguid, pns))
        {
            *ppns = pns;
        }
    }

    if (fFallback && !*ppns)
    {
        // if the matching namespace got scoped out, fall back to another.
        for (i = 0; !*ppns && (pns = _Namespace(i)); i++)
        {
            if (!_ShouldSuspend(pns->GetGUID()))
            {
                *ppns = pns;
            }
        }
    }

    return *ppns ? S_OK : E_FAIL;
}

// lamadio: Move this to a better location, This is a nice generic function
#ifdef DEBUG
BOOL DPA_VerifySorted(HDPA hdpa, PFNDPACOMPARE pfn, LPARAM lParam)
{
    if (!EVAL(hdpa))
        return FALSE;

    for (int i = 0; i < DPA_GetPtrCount(hdpa) - 1; i++)
    {
        if (pfn(DPA_FastGetPtr(hdpa, i), DPA_FastGetPtr(hdpa, i + 1), lParam) > 0)
            return FALSE;
    }

    return TRUE;
}
#else
#define DPA_VerifySorted(hdpa, pfn, lParam) TRUE
#endif

int CMergedFolder::_AcquireObjects()
{
    _fAcquiring = TRUE;

    HDPA hdpa2 = NULL;

    ASSERT(_hdpaObjects == NULL);

    CMergedFldrNamespace *pns;
    for (int i = 0; pns = _Namespace(i); i++)
    {
        if (_ShouldSuspend(pns->GetGUID()))
        {
            continue;
        }

        HDPA *phdpa = (i == 0) ? &_hdpaObjects : &hdpa2;

        IEnumIDList *peid;
        if (S_OK == pns->Folder()->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN, &peid))
        {
            if (!*phdpa)
                *phdpa = DPA_Create(4);

            if (*phdpa)
            {
                LPITEMIDLIST pidl;
                ULONG cEnum;
                
                while (S_OK == peid->Next(1, &pidl, &cEnum))
                {
                    CMergedFldrItem* pmfiEnum = new CMergedFldrItem;
                    if (pmfiEnum)
                    {
                        // This is ok, the memory just gets 
                        LPITEMIDLIST pidlWrap;
                        if (SUCCEEDED(_CreateWrap(pidl, i, &pidlWrap)) &&
                                pmfiEnum->Init(SAFECAST(this, IAugmentedShellFolder2*), pidlWrap, i))
                        {
                            if (DPA_AppendPtr(*phdpa, pmfiEnum) != -1)
                                pmfiEnum = NULL;   // don't free below
                        }

                        if (pmfiEnum)
                            delete pmfiEnum;
                    }
                    ILFree(pidl);
                }
            }
            peid->Release();
        }

        // if we have only hdpa2 but not _hdpaObjects, do a switcheroo.
        if (hdpa2 && !_hdpaObjects)
        {
            _hdpaObjects = hdpa2;
            hdpa2 = NULL;
        }

        // now that we have both hdpa's (or one) let's merge them.
        if (_hdpaObjects && hdpa2)
        {
            DPA_Merge(_hdpaObjects, hdpa2, DPAM_UNION, _Compare, _Merge, (LPARAM)this);
            DPA_DestroyCallback(hdpa2, _DestroyObjectsProc, NULL);
            hdpa2 = NULL;
        }
        else if (_hdpaObjects)
        {
            DPA_Sort(_hdpaObjects, _Compare, (LPARAM)this);
        }
    }

    _fAcquiring = FALSE;
    return _ObjectCount();
}

int CMergedFolder::_DestroyObjectsProc(void *pv, void *pvData)
{
    CMergedFldrItem* pmfiEnum = (CMergedFldrItem*)pv;
    if (pmfiEnum)
        delete pmfiEnum;
    return TRUE;
}

void CMergedFolder::_FreeObjects()
{
    if (!_fAcquiring && _hdpaObjects)
    {
        DPA_DestroyCallback(_hdpaObjects, _DestroyObjectsProc, NULL);
        _hdpaObjects = NULL;
    }
}

int CMergedFolder::_DestroyNamespacesProc(void *pv, void *pvData)
{
    CMergedFldrNamespace* p = (CMergedFldrNamespace*)pv;
    if (p)
        delete p;
    return TRUE;
}

void CMergedFolder::_FreeNamespaces()
{
    if (_hdpaNamespaces)
    {
        DPA_DestroyCallback(_hdpaNamespaces, _DestroyNamespacesProc, NULL);
        _hdpaNamespaces = NULL;
    }
}

HRESULT CMergedFolder::_GetPidl(int* piPos, DWORD grfEnumFlags, LPITEMIDLIST* ppidl)
{
    *ppidl = NULL;

    if (_hdpaObjects == NULL)
        _AcquireObjects();

    if (_hdpaObjects == NULL)
        return E_OUTOFMEMORY;

    BOOL fWantFolders    = 0 != (grfEnumFlags & SHCONTF_FOLDERS),
         fWantNonFolders = 0 != (grfEnumFlags & SHCONTF_NONFOLDERS),
         fWantHidden     = 0 != (grfEnumFlags & SHCONTF_INCLUDEHIDDEN),
         fWantAll        = 0 != (grfEnumFlags & SHCONTF_STORAGE);

    HRESULT hr = S_FALSE;
    while (*piPos < _ObjectCount())
    {
        CMergedFldrItem* pmfiEnum = _GetObject(*piPos);
        if (pmfiEnum)
        {
            BOOL fFolder = 0 != (pmfiEnum->GetFolderAttrib() & SFGAO_FOLDER),
                 fHidden = 0 != (pmfiEnum->GetFolderAttrib() & SFGAO_HIDDEN);
             
            if (fWantAll ||
                (!fHidden || fWantHidden) && 
                ((fFolder && fWantFolders) || (!fFolder && fWantNonFolders)))
            {
                // Copy out the pidl
                hr = SHILClone(pmfiEnum->GetIDList(), ppidl);
                break;
            }
            else
            {
                (*piPos)++;
            }
        }
    }

    return hr;
}

HRESULT CMergedFolder::_GetOverlayInfo(LPCITEMIDLIST pidl, int *pIndex, DWORD dwFlags)
{
    int iOverlayIndex = -1;
    HRESULT hr = S_OK;

    CMergedFldrNamespace *pns;
    if (_fCDBurn)
    {
        hr = E_OUTOFMEMORY;
        LPITEMIDLIST pidlInNamespace;
        if (SUCCEEDED(_GetSubPidl(pidl, 0, NULL, &pidlInNamespace, &pns)))
        {
            ASSERTMSG(!_fDontMerge || _GetSourceCount(pidl) == 1, "item for overlay should have exactly one wrapped pidl if not merged");

            LPITEMIDLIST pidlFirst = ILCloneFirst(pidl);
            if (pidlFirst)
            {
                if (_GetSourceCount(pidlFirst) > 1)
                {
                    // an overlay to indicate overwrite
                    iOverlayIndex = pns->GetConflictOverlayIndex();
                }
                if (iOverlayIndex == -1)
                {
                    // overlay to indicate staged
                    iOverlayIndex = pns->GetDefaultOverlayIndex();
                }
                if (iOverlayIndex == -1)
                {
                    // use the one provided by the namespace
                    iOverlayIndex = pns->GetNamespaceOverlayIndex(pidlInNamespace);
                }
                ILFree(pidlFirst);
            }
            ILFree(pidlInNamespace);
        }
    }

    ASSERT(pIndex);
    *pIndex = (dwFlags == SIOM_OVERLAYINDEX) ? iOverlayIndex : INDEXTOOVERLAYMASK(iOverlayIndex);

    return hr;
}

HRESULT CMergedFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    return (*pIndex == OI_ASYNC) ? E_PENDING : _GetOverlayInfo(pidl, pIndex, SIOM_OVERLAYINDEX);
}

HRESULT CMergedFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex)
{
    return _GetOverlayInfo(pidl, pIconIndex, SIOM_ICONINDEX);
}

STDMETHODIMP CMergedFolder::BindToParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPITEMIDLIST *ppidlLast)
{
    // tybeam: nobody seems to call this any more.
    // if this is ever needed tell me to add it back.
    return E_NOTIMPL;
}

HRESULT CMergedFolder::_AddComposite(const COMPFOLDERINIT *pcfi)
{
    HRESULT hr = E_FAIL;

    LPITEMIDLIST pidl = NULL;
    switch (pcfi->uType)
    {
    case CFITYPE_CSIDL:
        SHGetSpecialFolderLocation(NULL, pcfi->csidl, &pidl);
        break;

    case CFITYPE_PIDL:
        pidl = ILClone(pcfi->pidl);
        break;

    case CFITYPE_PATH:
        pidl = ILCreateFromPath(pcfi->pszPath);
        break;

    default:
        ASSERT(FALSE);
    }

    if (pidl)
    {
        hr = AddNameSpace(NULL, NULL, pidl, ASFF_DEFNAMESPACE_ALL);
        ILFree(pidl);
    }

    return hr;
}

STDMETHODIMP CMergedFolder::InitComposite(WORD wSignature, REFCLSID refclsid, CFINITF cfiFlags, ULONG celt, const COMPFOLDERINIT *rgCFs)
{
    HRESULT hr = S_OK;

    _clsid = refclsid;

    ASSERTMSG(cfiFlags == CFINITF_FLAT, "merged folder doesn't support listing namespaces as children any more");
    if (cfiFlags != CFINITF_FLAT)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        for (ULONG i = 0; SUCCEEDED(hr) && (i < celt); i++)
        {
            hr = _AddComposite(rgCFs + i);
        }
    }
    return hr;
}

STDMETHODIMP CMergedFolder::_DeleteItemByIDList(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlSrc;
    CMergedFldrNamespace *pns;
    HRESULT hr = _NamespaceForItem(pidl, ASFF_DEFNAMESPACE_BINDSTG, ASFF_DEFNAMESPACE_BINDSTG, NULL, &pidlSrc, &pns, FALSE);
    if (SUCCEEDED(hr))
    {
        IStorage *pstg;
        hr = pns->Folder()->QueryInterface(IID_PPV_ARG(IStorage, &pstg));
        if (SUCCEEDED(hr))
        {
            TCHAR szName[MAX_PATH];
            hr = DisplayNameOf(pns->Folder(), pidlSrc, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                hr = pstg->DestroyElement(szName);
            }
            pstg->Release();
        }
        ILFree(pidlSrc);
    }
    return hr;
}

// helper to take a bind context
// will move to shell\lib if/when there are any other callers (tybeam)
HRESULT SHBindToParentEx(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
{
    HRESULT hr;
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    if (pidlParent) 
    {
        hr = SHBindToObjectEx(NULL, pidlParent, pbc, riid, ppv);
        ILFree(pidlParent);
    }
    else
        hr = E_OUTOFMEMORY;

    if (ppidlLast)
        *ppidlLast = ILFindLastID(pidl);

    return hr;
}

HRESULT CMergedFolder::_GetDestinationStorage(DWORD grfMode, IStorage **ppstg)
{
    CMergedFldrNamespace *pns;
    HRESULT hr = _FindNamespace(ASFF_DEFNAMESPACE_BINDSTG, ASFF_DEFNAMESPACE_BINDSTG, NULL, &pns, TRUE);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlLast;
        hr = SHBindToIDListParent(pns->GetIDList(), IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
        if (SUCCEEDED(hr))
        {
            // SHGetAttributes doesn't help for SFGAO_VALIDATE
            DWORD dwAttrib = SFGAO_VALIDATE;
            hr = psf->GetAttributesOf(1, &pidlLast, &dwAttrib);
            psf->Release();
        }
    }

    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = BindCtx_CreateWithMode(grfMode, &pbc);
        if (SUCCEEDED(hr))
        {
            hr = SHBindToObjectEx(NULL, pns->GetIDList(), pbc, IID_PPV_ARG(IStorage, ppstg));
            pbc->Release();
        }
    }
    else if (_pmfParent)
    {
        // the current pidl doesnt have the storage target namespace, so create it using our parent.
        IStorage *pstgParent;
        hr = _pmfParent->_GetDestinationStorage(grfMode, &pstgParent);
        if (SUCCEEDED(hr))
        {
            TCHAR szName[MAX_PATH];
            hr = DisplayNameOf((IShellFolder*)(void*)_pmfParent, ILFindLastID(_pidl), SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                hr = pstgParent->CreateStorage(szName, STGM_READWRITE, 0, 0, ppstg);
            }
            pstgParent->Release();
        }
    }
    return hr;
}

STDMETHODIMP CMergedFolder::_StgCreate(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;
    // first we need to ensure that the folder exists.
    if (_pstg == NULL)
    {
        hr = _GetDestinationStorage(grfMode, &_pstg);
    }

    if (SUCCEEDED(hr))
    {
        TCHAR szName[MAX_PATH];
        hr = DisplayNameOf((IShellFolder*)(void*)this, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
        {
            if (IsEqualIID(riid, IID_IStorage))
            {
                hr = _pstg->CreateStorage(szName, grfMode, 0, 0, (IStorage **) ppv);
            }
            else if (IsEqualIID(riid, IID_IStream))
            {
                hr = _pstg->CreateStream(szName, grfMode, 0, 0, (IStream **) ppv);
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
    }
    return hr;
}

// enumerator object

class CMergedFldrEnum : public IEnumIDList
{
public:
    // IUnknown
    STDMETHOD (QueryInterface) (REFIID, void **);
    STDMETHOD_(ULONG,AddRef)  ();
    STDMETHOD_(ULONG,Release) ();

    // IEnumIDList
    STDMETHODIMP Next(ULONG, LPITEMIDLIST*, ULONG*);
    STDMETHODIMP Skip(ULONG);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList**);

    CMergedFldrEnum(CMergedFolder*pmf, DWORD grfEnumFlags, int iPos = 0);

private:
    ~CMergedFldrEnum();

    LONG _cRef;
    CMergedFolder*_pmf;
    DWORD _grfEnumFlags;
    int _iPos;
};

CMergedFldrEnum::CMergedFldrEnum(CMergedFolder *pfm, DWORD grfEnumFlags, int iPos) : 
        _cRef(1), _iPos(iPos), _pmf(pfm), _grfEnumFlags(grfEnumFlags)
{ 
    _pmf->AddRef();
}

CMergedFldrEnum::~CMergedFldrEnum()
{
    _pmf->Release();
}

STDMETHODIMP CMergedFldrEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = { 
        QITABENT(CMergedFldrEnum, IEnumIDList), 
        { 0 } 
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMergedFldrEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMergedFldrEnum::Release()
{
    if (InterlockedDecrement(&_cRef)) 
        return _cRef;
    
    delete this;
    return 0;
}

// IEnumIDList

STDMETHODIMP CMergedFldrEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    int iStart = _iPos;
    int cFetched = 0;
    HRESULT hr = S_OK;

    if (!(celt > 0 && rgelt) || (NULL == pceltFetched && celt > 1))
        return E_INVALIDARG;
    
    *rgelt = 0;

    while (hr == S_OK && (_iPos - iStart) < (int)celt)
    {
        LPITEMIDLIST pidl;
        hr = _pmf->_GetPidl(&_iPos, _grfEnumFlags, &pidl);
        if (hr == S_OK)
        {
            rgelt[cFetched] = pidl;
            cFetched++;
        }
        _iPos++;
    }
    
    if (pceltFetched)
        *pceltFetched = cFetched;
    
    return celt == (ULONG)cFetched ? S_OK : S_FALSE;
}

STDMETHODIMP CMergedFldrEnum::Skip(ULONG celt)
{
    _iPos += celt;
    return S_OK;
}

STDMETHODIMP CMergedFldrEnum::Reset()
{
    _iPos = 0;
    return S_OK;
}

STDMETHODIMP CMergedFldrEnum::Clone(IEnumIDList **ppenum)
{
    *ppenum = new CMergedFldrEnum(_pmf, _grfEnumFlags, _iPos);
    return *ppenum ? S_OK : E_OUTOFMEMORY;
}

HRESULT CMergedFldrEnum_CreateInstance(CMergedFolder*pmf, DWORD grfFlags, IEnumIDList **ppenum)
{
    CMergedFldrEnum *penum = new CMergedFldrEnum(pmf, grfFlags);
    if (!penum)
        return E_OUTOFMEMORY;

    HRESULT hr = penum->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
    penum->Release();
    return hr;
}


// Drop Target handler

class CMergedFldrDropTarget : public IDropTarget,
                              public IObjectWithSite
{
public:
    // IUnknown
    STDMETHOD (QueryInterface) (REFIID, void **);
    STDMETHOD_(ULONG,AddRef)  ();
    STDMETHOD_(ULONG,Release) ();

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *punkSite);
    STDMETHODIMP GetSite(REFIID riid, void **ppvSite);

    CMergedFldrDropTarget(CMergedFolder*pmf, HWND hwnd);

private:
    ~CMergedFldrDropTarget();
    HRESULT _CreateOtherNameSpace(IShellFolder **ppsf);
    HRESULT _FindTargetNamespace(CMergedFldrNamespace *pnsToMatch, CMergedFldrNamespace **ppns, CMergedFldrNamespace **ppnsMatched);
    HRESULT _CreateFolder(IShellFolder *psf, LPCWSTR pszName, REFIID riid, void **ppv);
    LPITEMIDLIST _FolderIDListFromData(IDataObject *pdtobj);
    BOOL _IsCommonIDList(LPCITEMIDLIST pidlItem);
    HRESULT _SetDropEffectFolders();
    void _DestroyDropEffectFolders();

    LONG _cRef;
    CMergedFolder *_pmf;
    IDropTarget *_pdt;
    IDataObject *_pdo;
    HWND _hwnd;
    BOOL _fSrcIsCommon;          // is _pdt a common programs folder (or its child)
    LPITEMIDLIST _pidlSrcFolder;         // where the source comes from
    DWORD _grfKeyState;
    DWORD _dwDragEnterEffect;
};


CMergedFldrDropTarget::CMergedFldrDropTarget(CMergedFolder*pfm, HWND hwnd) : 
        _cRef(1), 
        _pmf(pfm), 
        _hwnd(hwnd)
{ 
    _pmf->AddRef();
}

CMergedFldrDropTarget::~CMergedFldrDropTarget()
{
    _pmf->Release();
    ASSERT(!_pdt);
    ASSERT(!_pdo);
}

STDMETHODIMP CMergedFldrDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    { 
        QITABENT(CMergedFldrDropTarget, IDropTarget),
        QITABENT(CMergedFldrDropTarget, IObjectWithSite),
        { 0 }
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMergedFldrDropTarget::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMergedFldrDropTarget::Release()
{
    if (InterlockedDecrement(&_cRef)) 
        return _cRef;
    
    delete this;
    return 0;
}


// is this pidl in the "All Users" part of the name space
BOOL CMergedFldrDropTarget::_IsCommonIDList(LPCITEMIDLIST pidlItem)
{
    BOOL bRet = FALSE;
    LPITEMIDLIST pidlCommon;
    
    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_STARTMENU, &pidlCommon)))
    {
        bRet = ILIsParent(pidlCommon, pidlItem, FALSE);
        ILFree(pidlCommon);
    }
    if (!bRet &&
        SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &pidlCommon)))
    {
        bRet = ILIsParent(pidlCommon, pidlItem, FALSE);
        ILFree(pidlCommon);
    }
    if (!bRet &&
        SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, &pidlCommon)))
    {
        bRet = ILIsParent(pidlCommon, pidlItem, FALSE);
        ILFree(pidlCommon);
    }

    return bRet;
}

LPITEMIDLIST CMergedFldrDropTarget::_FolderIDListFromData(IDataObject *pdtobj)
{
    LPITEMIDLIST pidlFolder = NULL;
    STGMEDIUM medium = {0};
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        pidlFolder = ILClone(HIDA_GetPIDLFolder(pida));
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return pidlFolder;
}

HRESULT CMergedFldrDropTarget::_CreateFolder(IShellFolder *psf, LPCWSTR pszName, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IStorage *pstg;
    HRESULT hr = psf->QueryInterface(IID_PPV_ARG(IStorage, &pstg));
    if (SUCCEEDED(hr))
    {
        DWORD grfMode = STGM_READWRITE;
        IStorage *pstgNew;
        hr = pstg->OpenStorage(pszName, NULL, grfMode, 0, 0, &pstgNew);
        if (FAILED(hr))
        {
            // try create if it's not there
            hr = pstg->CreateStorage(pszName, grfMode, 0, 0, &pstgNew);
        }
        if (SUCCEEDED(hr))
        {
            hr = pstgNew->QueryInterface(riid, ppv);
            pstgNew->Release();
        }
        pstg->Release();
    }
    return hr;
}

HRESULT CMergedFldrDropTarget::_FindTargetNamespace(CMergedFldrNamespace *pnsToMatch, CMergedFldrNamespace **ppnsDstRoot, CMergedFldrNamespace **ppnsMatched)
{
    *ppnsDstRoot = NULL;
    *ppnsMatched = NULL;

    // if the source of the drag drop is in one of our name spaces
    // we prefer that as the target name space
    for (CMergedFolder*pmf = this->_pmf; pmf && (NULL == *ppnsDstRoot); pmf = pmf->_Parent())
    {
        pmf->_FindNamespace(pnsToMatch->FolderAttrib(), pnsToMatch->FolderAttrib(), &pnsToMatch->GetGUID(), ppnsMatched);

        CMergedFldrNamespace *pns;
        for (int i = 0; (pns = pmf->_Namespace(i)) && (NULL == *ppnsDstRoot); i++)
        {
            if (pmf->_ShouldMergeNamespaces(*ppnsMatched, pns) &&
                ILFindChild(pns->GetIDList(), _pidlSrcFolder))
            {
                *ppnsDstRoot = pns;     // if the source is in one of our name spaces
            }
        }
        ASSERT(NULL != *ppnsMatched);   // pnsToMatch must exist above us

        // If merging is disabled, then we don't want parent namespaces
        // to infect us.
        if (pmf->_fDontMerge)
        {
            break;
        }
    }

    if (NULL == *ppnsDstRoot)
    {
        // if the source was not found, find the target name space based on
        // 1) if the source data is an "All Users" item find the first common _Namespace
        if (_fSrcIsCommon)
        {
            for (pmf = this->_pmf; pmf && (NULL == *ppnsDstRoot); pmf = pmf->_Parent())
            {
                pmf->_FindNamespace(pnsToMatch->FolderAttrib(), pnsToMatch->FolderAttrib(), &pnsToMatch->GetGUID(), ppnsMatched);
                pmf->_FindNamespace(ASFF_COMMON, ASFF_COMMON, NULL, ppnsDstRoot);
            }
        }

        // 2) find the first NON common name space for this guy
        for (pmf = this->_pmf; pmf && (NULL == *ppnsDstRoot); pmf = pmf->_Parent())
        {
            pmf->_FindNamespace(pnsToMatch->FolderAttrib(), pnsToMatch->FolderAttrib(), &pnsToMatch->GetGUID(), ppnsMatched);
            pmf->_FindNamespace(ASFF_COMMON, 0, NULL, ppnsDstRoot);    // search for non common items
        }
    }

    if (NULL == *ppnsMatched && NULL != *ppnsDstRoot)
    {
        delete *ppnsDstRoot;
        *ppnsDstRoot = NULL;
    }

    return *ppnsDstRoot ? S_OK : E_FAIL;
}

HRESULT CMergedFldrDropTarget::_CreateOtherNameSpace(IShellFolder **ppsf)
{
    *ppsf = NULL;

    HRESULT hr = E_FAIL;
    if (_pidlSrcFolder && 
            (!_fSrcIsCommon || AffectAllUsers(_hwnd)))
    {
        CMergedFldrNamespace *pnsDstRoot; // name space we want to create this new item in
        CMergedFldrNamespace *pnsSrc;
        CMergedFldrNamespace *pnsStart = this->_pmf->_Namespace(0);

        if (pnsStart)
        {
            hr = _FindTargetNamespace(pnsStart, &pnsDstRoot, &pnsSrc);
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidlChild = ILFindChild(pnsSrc->GetIDList(), pnsStart->GetIDList());
                ASSERT(pidlChild && !ILIsEmpty(pidlChild));  // pnsSrc is a parent of pnsStart

                IShellFolder *psfDst = pnsDstRoot->Folder();
                psfDst->AddRef();

                IShellFolder *psfSrc = pnsSrc->Folder();
                psfSrc->AddRef();

                for (LPCITEMIDLIST pidl = pidlChild; !ILIsEmpty(pidl) && SUCCEEDED(hr); pidl = _ILNext(pidl))
                {
                    LPITEMIDLIST pidlFirst = ILCloneFirst(pidl);
                    if (pidlFirst)
                    {
                        WCHAR szName[MAX_PATH];
                        hr = DisplayNameOf(psfSrc, pidlFirst, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
                        if (SUCCEEDED(hr))
                        {
                            IShellFolder *psfNew;
                            hr = _CreateFolder(psfDst, szName, IID_PPV_ARG(IShellFolder, &psfNew));
                            if (SUCCEEDED(hr))
                            {
                                psfDst->Release();
                                psfDst = psfNew;
                            }
                            else
                            {
                                break;
                            }
                        }

                        // now advance to the next folder in the source name space
                        IShellFolder *psfNew;
                        hr = psfSrc->BindToObject(pidlFirst, NULL, IID_PPV_ARG(IShellFolder, &psfNew));
                        if (SUCCEEDED(hr))
                        {
                            psfSrc->Release();
                            psfSrc = psfNew;
                        }
                        else
                        {
                            break;
                        }

                        ILFree(pidlFirst);
                    }
                    else
                        hr = E_FAIL;
                }
                psfSrc->Release();

                if (SUCCEEDED(hr))
                    *ppsf = psfDst; // copy out our ref
                else
                    psfDst->Release();
            }
        }
    }
    return hr;
}

HRESULT CMergedFldrDropTarget::_SetDropEffectFolders()
{
    INT i, cFolders = 0;

    // Compute the number of folders which have special drop effects
    for (i = 0; i < _pmf->_NamespaceCount(); i++)
    {
        if (_pmf->_Namespace(i)->GetDropEffect() != 0)
            cFolders++;
    }

    // If the number is > 0 then lets add to the IDataObject the clipboard format
    // which defines this information.
    HRESULT hr = S_OK;
    if ((cFolders > 0) || (_pmf->_dwDropEffect != 0))
    {
        DWORD cb = sizeof(DROPEFFECTFOLDERLIST) + sizeof(DROPEFFECTFOLDER) * (cFolders - 1);
        DROPEFFECTFOLDERLIST *pdefl = (DROPEFFECTFOLDERLIST*)LocalAlloc(LPTR, cb);
        if (pdefl)
        {
            pdefl->cFolders = cFolders;
            pdefl->dwDefaultDropEffect = _pmf->_dwDropEffect;           // default effect for the folders.

            // fill the array backwards with the folders we have and their desired effects
            for (i = 0, cFolders--; cFolders >= 0; i++)
            {
                DWORD dwDropEffect = _pmf->_Namespace(i)->GetDropEffect();
                if (dwDropEffect != 0)
                {
                    pdefl->aFolders[cFolders].dwDropEffect = dwDropEffect;
                    StrCpyN(pdefl->aFolders[cFolders].wszPath, _pmf->_Namespace(i)->GetDropFolder(), ARRAYSIZE(pdefl->aFolders[cFolders].wszPath));
                    cFolders--;
                }
            }

            ASSERTMSG(g_cfDropEffectFolderList != 0, "Clipboard format for CFSTR_DROPEFFECTFOLDERS not registered");
            hr = DataObj_SetBlob(_pdo, g_cfDropEffectFolderList, pdefl, cb);
            LocalFree(pdefl);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

// nuke the modified drop effects
void CMergedFldrDropTarget::_DestroyDropEffectFolders()
{
    // there are no DROPEFFECTFOLDERs so subtract off the [1] array
    DWORD cb = sizeof(DROPEFFECTFOLDERLIST) - sizeof(DROPEFFECTFOLDER);
    DROPEFFECTFOLDERLIST *pdefl = (DROPEFFECTFOLDERLIST*)LocalAlloc(LPTR, cb);
    if (pdefl)
    {
        pdefl->cFolders = 0;
        pdefl->dwDefaultDropEffect = DROPEFFECT_NONE;  // means do default handling

        ASSERTMSG(g_cfDropEffectFolderList != 0, "Clipboard format for CFSTR_DROPEFFECTFOLDERS not registered");
        DataObj_SetBlob(_pdo, g_cfDropEffectFolderList, pdefl, cb);
        LocalFree(pdefl);
    }
}

HRESULT CMergedFldrDropTarget::SetSite(IUnknown *punkSite)
{
    IUnknown_SetSite(_pdt, punkSite);
    return S_OK;
}

HRESULT CMergedFldrDropTarget::GetSite(REFIID riid, void **ppvSite)
{
    return IUnknown_GetSite(_pdt, riid, ppvSite);
}

HRESULT CMergedFldrDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    ASSERT(!_fSrcIsCommon);
    ASSERT(_pdt == NULL);
    ASSERT(_pidlSrcFolder == NULL);
    ASSERT(_pdo == NULL);
    
    IUnknown_Set((IUnknown**)&_pdo, pdtobj);
    _SetDropEffectFolders();

    _pidlSrcFolder = _FolderIDListFromData(pdtobj);
    if (_pidlSrcFolder)
        _fSrcIsCommon = _IsCommonIDList(_pidlSrcFolder);

    HRESULT hr;
    CMergedFldrNamespace *pns;
    if (_fSrcIsCommon)
    {
        // if the item is comming from an "All Users" folder we want to target 
        // the common folder. if that does not exist yet then we continue on 
        // with a NULL _pdt and create that name space when the drop happens
        hr = _pmf->_FindNamespace(ASFF_COMMON, ASFF_COMMON, NULL, &pns);
    }
    else
    {
        // not "All Users" item, get the default name space (if there is one)
        hr = _pmf->_FindNamespace(ASFF_DEFNAMESPACE_VIEWOBJ, ASFF_DEFNAMESPACE_VIEWOBJ, NULL, &pns);
    }

    if (SUCCEEDED(hr) || _pmf->_fCDBurn)
    {
        if (_pmf->_fCDBurn)
        {
            IShellExtInit *psei;
            hr = CoCreateInstance(CLSID_CDBurn, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellExtInit, &psei));
            if (SUCCEEDED(hr))
            {
                hr = psei->Initialize(_pmf->_pidl, NULL, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = psei->QueryInterface(IID_PPV_ARG(IDropTarget, &_pdt));
                }
                psei->Release();
            }
        }
        else
        {
            hr = pns->Folder()->CreateViewObject(_hwnd, IID_PPV_ARG(IDropTarget, &_pdt));
        }

        if (SUCCEEDED(hr))
        {
            _pdt->DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
        }
    }

    _grfKeyState = grfKeyState;
    _dwDragEnterEffect = *pdwEffect;

    return S_OK;
}

HRESULT CMergedFldrDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    _grfKeyState = grfKeyState;
    return _pdt ? _pdt->DragOver(grfKeyState, pt, pdwEffect) : S_OK;
}

HRESULT CMergedFldrDropTarget::DragLeave(void)
{
    if (_pdt)
    {
        _pdt->DragLeave();
        IUnknown_SetSite(_pdt, NULL);
        IUnknown_Set((IUnknown **)&_pdt, NULL);
    }
    if (_pdo)
    {
        _DestroyDropEffectFolders();
        IUnknown_Set((IUnknown**)&_pdo, NULL);
    }

    _fSrcIsCommon = 0;
    ILFree(_pidlSrcFolder); // accepts NULL
    _pidlSrcFolder = NULL;
    return S_OK;
}

HRESULT CMergedFldrDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = S_OK;

    if (!_pdt)
    {
        // we came here because we don't have _pdt which means that
        // there is only one folder in our _Namespace and that's not
        // the one we have to drop on. so we need to create it now

        IShellFolder *psf;
        hr = _CreateOtherNameSpace(&psf);
        if (SUCCEEDED(hr))
        {
            hr = psf->CreateViewObject(_hwnd, IID_PPV_ARG(IDropTarget, &_pdt));
            if (SUCCEEDED(hr))
                _pdt->DragEnter(pdtobj, _grfKeyState, pt, &_dwDragEnterEffect);
            psf->Release();
        }
    }

    if (_pdt)
    {
        hr = _pdt->Drop(pdtobj, grfKeyState, pt, pdwEffect);
        DragLeave();
    }
    return S_OK;
}

HRESULT CMergedFldrDropTarget_CreateInstance(CMergedFolder*pmf, HWND hwndOwner, IDropTarget **ppdt)
{
    CMergedFldrDropTarget *pdt = new CMergedFldrDropTarget(pmf, hwndOwner);
    if (!pdt)
        return E_OUTOFMEMORY;

    HRESULT hr = pdt->QueryInterface(IID_PPV_ARG(IDropTarget, ppdt));
    pdt->Release();
    return hr;
}


// context menu handling.

class CMergedFldrContextMenu : public IContextMenu3,
                               public IObjectWithSite
{
public:
    // IUnknown
    STDMETHOD (QueryInterface)(REFIID, void**);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT* pwReserved, LPSTR pszName, UINT cchMax);

    // IContextMenu2    
    STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IContextMenu3
    STDMETHODIMP HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *punkSite);
    STDMETHODIMP GetSite(REFIID riid, void **ppvSite);

    CMergedFldrContextMenu(HWND hwnd, IContextMenu *pcmCommon, IContextMenu *pcmUser);

private:
    ~CMergedFldrContextMenu();

    HRESULT _Initialize(CMergedFolder *pmf, UINT cidl, LPCITEMIDLIST *apidl);
    BOOL _IsMergedCommand(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeCanonical(IContextMenu *pcm, LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeMergedCommand(LPCMINVOKECOMMANDINFO pici);
    IContextMenu* _DefaultMenu();

    LONG            _cRef;
    IContextMenu *  _pcmCommon;
    IContextMenu *  _pcmUser;
    UINT            _cidl;
    LPITEMIDLIST   *_apidl;
    CMergedFolder  *_pmfParent;
    UINT            _idFirst;
    HWND            _hwnd;

    friend HRESULT CMergedFldrContextMenu_CreateInstance(HWND hwnd, CMergedFolder *pmf, UINT cidl, LPCITEMIDLIST *apidl, IContextMenu *pcmCommon, IContextMenu *pcmUser, IContextMenu **ppcm);
};

CMergedFldrContextMenu::CMergedFldrContextMenu(HWND hwnd, IContextMenu *pcmCommon, IContextMenu *pcmUser)
{
    ASSERT(pcmCommon || pcmUser);   // need at least one of these

    _cRef = 1;
    _hwnd = hwnd;

    IUnknown_Set((IUnknown **)&_pcmCommon, pcmCommon);
    IUnknown_Set((IUnknown **)&_pcmUser, pcmUser);
}

CMergedFldrContextMenu::~CMergedFldrContextMenu()
{
    ATOMICRELEASE(_pcmCommon);
    ATOMICRELEASE(_pcmUser);
    ATOMICRELEASE(_pmfParent);

    for (UINT i = 0; i < _cidl; i++)
    {
        ILFree(_apidl[i]);
    }
}

IContextMenu* CMergedFldrContextMenu::_DefaultMenu()
{
    ASSERT(_pcmUser || _pcmCommon);   // need at least one of these; this is pretty much guaranteed since we're given them
                                      // at constructor time.
    return _pcmUser ? _pcmUser : _pcmCommon;
}

HRESULT CMergedFldrContextMenu::_Initialize(CMergedFolder *pmf, UINT cidl, LPCITEMIDLIST *apidl)
{
    _pmfParent = pmf;
    if (_pmfParent)
    {
        _pmfParent->AddRef();
    }

    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST *apidlNew = new LPITEMIDLIST[cidl];
    if (apidlNew)
    {
        hr = S_OK;
        for (UINT i = 0; SUCCEEDED(hr) && i < cidl; i++)
        {
            hr = SHILClone(apidl[i], &(apidlNew[i]));
        }

        if (SUCCEEDED(hr))
        {
            _apidl = apidlNew;
            _cidl = cidl;
        }
        else
        {
            for (i = 0; i < cidl; i++)
            {
                ILFree(apidlNew[i]);
            }
            delete [] apidlNew;
        }
    }
    return hr;
}

STDMETHODIMP CMergedFldrContextMenu::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CMergedFldrContextMenu, IContextMenu,  IContextMenu3),
        QITABENTMULTI(CMergedFldrContextMenu, IContextMenu2, IContextMenu3),
        QITABENT(CMergedFldrContextMenu, IContextMenu3),
        QITABENT(CMergedFldrContextMenu, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMergedFldrContextMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMergedFldrContextMenu::Release()
{
    if (InterlockedDecrement(&_cRef)) 
        return _cRef;

    delete this;
    return 0;
}

HRESULT CMergedFldrContextMenu::SetSite(IUnknown *punkSite)
{
    // setsite/getsite will always be matched because _pcmUser and _pcmCommon never change
    // after the constructor is called.
    IUnknown_SetSite(_DefaultMenu(), punkSite);
    return S_OK;
}

HRESULT CMergedFldrContextMenu::GetSite(REFIID riid, void **ppvSite)
{
    return IUnknown_GetSite(_DefaultMenu(), riid, ppvSite);
}

HRESULT CMergedFldrContextMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr;
    
    if (_pmfParent->_fInShellView)
    {
        hr = _DefaultMenu()->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
    }
    else
    {
        if (hmenu)
        {
            HMENU hmContext = SHLoadMenuPopup(HINST_THISDLL, MENU_SM_CONTEXTMENU);
            if (hmContext)
            {
                int i;

                if (!_pcmCommon || !_pcmUser)
                {
                    DeleteMenu(hmContext, SMIDM_OPENCOMMON, MF_BYCOMMAND);
                    DeleteMenu(hmContext, SMIDM_EXPLORECOMMON, MF_BYCOMMAND);
                }

                _idFirst = idCmdFirst;
                i = Shell_MergeMenus(hmenu, hmContext, -1, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
                DestroyMenu(hmContext);

                // Make it look "Shell Like"
                SetMenuDefaultItem(hmenu, 0, MF_BYPOSITION);

                hr = ResultFromShort(i);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_INVALIDARG;
    }
    
    return hr;
}

BOOL CMergedFldrContextMenu::_IsMergedCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = S_OK;
    WCHAR szVerb[32];
    if (!IS_INTRESOURCE(pici->lpVerb))
    {
        lstrcpyn(szVerb, (LPCWSTR)pici->lpVerb, ARRAYSIZE(szVerb));
    }
    else
    {
        hr = _DefaultMenu()->GetCommandString((UINT_PTR)pici->lpVerb, GCS_VERBW, NULL, (LPSTR)szVerb, ARRAYSIZE(szVerb));
    }

    BOOL fRet = FALSE;
    if (SUCCEEDED(hr))
    {
        if ((lstrcmpi(szVerb, c_szOpen) == 0) ||
            (lstrcmpi(szVerb, c_szExplore) == 0))
        {
            fRet = TRUE;
        }
    }
    return fRet;
}

HRESULT CMergedFldrContextMenu::_InvokeMergedCommand(LPCMINVOKECOMMANDINFO pici)
{
    // this code is mostly to navigate into folders from the shell view.
    // the reason why we have to do this manually is because the context menus for
    // the different namespaces have dataobjects which refer only to one namespace.
    // when the navigate happens, that means we get passed bogus non-merged pidls
    // into our BindToObject which screws things up.
    ASSERT(_pmfParent->_fInShellView);

    BOOL fHasFolders = FALSE;
    BOOL fHasNonFolders = FALSE;
    for (UINT i = 0; i < _cidl; i++)
    {
        if (_pmfParent->_IsFolder(_apidl[i]))
        {
            fHasFolders = TRUE;
        }
        else
        {
            fHasNonFolders = TRUE;
        }
    }

    HRESULT hr;
    if (fHasFolders && _IsMergedCommand(pici))
    {
        if (!fHasNonFolders)
        {
            // reinit the defcm with a new dataobject
            IShellExtInit *psei;
            hr = _DefaultMenu()->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei));
            if (SUCCEEDED(hr))
            {
                IDataObject *pdo;
                hr = SHCreateFileDataObject(_pmfParent->_pidl, _cidl, (LPCITEMIDLIST *)_apidl, NULL, &pdo);
                if (SUCCEEDED(hr))
                {
                    hr = psei->Initialize(_pmfParent->_pidl, pdo, NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = _DefaultMenu()->InvokeCommand(pici);
                    }
                    pdo->Release();
                }
                psei->Release();
            }
        }
        else
        {
            // to open both folders and items simultaneously means we'd have to
            // get a new context menu for just the items.
            // we can do this if this scenario comes up.
            hr = E_FAIL;
        }
    }
    else
    {
        hr = _DefaultMenu()->InvokeCommand(pici);
    }

    return hr;
}

const ICIVERBTOIDMAP c_sIDVerbMap[] = 
{
    { L"delete",     "delete",     SMIDM_DELETE,     SMIDM_DELETE,     },
    { L"rename",     "rename",     SMIDM_RENAME,     SMIDM_RENAME,     },
    { L"properties", "properties", SMIDM_PROPERTIES, SMIDM_PROPERTIES, },
};

HRESULT CMergedFldrContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;
    CMINVOKECOMMANDINFOEX ici = {0};

    memcpy(&ici, pici, min(sizeof(ici), pici->cbSize));
    ici.cbSize = sizeof(ici);

    if (_pmfParent->_fInShellView)
    {
        hr = _InvokeMergedCommand((LPCMINVOKECOMMANDINFO)&ici);
    }
    else
    {
        UINT id;
        hr = SHMapICIVerbToCmdID((LPCMINVOKECOMMANDINFO)&ici, c_sIDVerbMap, ARRAYSIZE(c_sIDVerbMap), &id);
        if (SUCCEEDED(hr))
        {
            // The below sets an ansi verb only, make sure no lpVerbW is used
            ici.fMask &= (~CMIC_MASK_UNICODE);

            switch (id)
            {
            case SMIDM_OPEN:
            case SMIDM_EXPLORE:
            case SMIDM_OPENCOMMON:
            case SMIDM_EXPLORECOMMON:
                {
                    ASSERT(!_pmfParent->_fInShellView);

                    IContextMenu * pcm;
                    if (id == SMIDM_OPEN || id == SMIDM_EXPLORE)
                    {
                        pcm = _DefaultMenu();
                    }
                    else
                    {
                        pcm = _pcmCommon;
                    }

                    hr = SHInvokeCommandOnContextMenu(ici.hwnd, NULL, pcm, ici.fMask,
                            (id == SMIDM_EXPLORE || id == SMIDM_EXPLORECOMMON) ? "explore" : "open");
                }
                break;
            
            case SMIDM_PROPERTIES:
                hr = SHInvokeCommandOnContextMenu(ici.hwnd, NULL, _DefaultMenu(), ici.fMask, "properties");
                break;
            
            case SMIDM_DELETE:
                ici.lpVerb = "delete";
                if (_pcmUser)
                {
                    hr = SHInvokeCommandOnContextMenu(ici.hwnd, NULL, _pcmUser, ici.fMask, "delete");
                }
                else
                {
                    ASSERT(_pcmCommon);

                    ici.fMask |= CMIC_MASK_FLAG_NO_UI;
                    if (AffectAllUsers(_hwnd))
                        hr = SHInvokeCommandOnContextMenu(ici.hwnd, NULL, _pcmCommon, ici.fMask, "delete");   
                    else
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }   
            
                break;
            
            case SMIDM_RENAME:
                ASSERT(0);
                hr = E_NOTIMPL; // sftbar picks this off
                break;

            default:
                ASSERTMSG(FALSE, "shouldn't have unknown command");
                hr = E_INVALIDARG;
            }
        }
    }
    
    return hr;
}

HRESULT CMergedFldrContextMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT* pwReserved, LPSTR pszName, UINT cchMax)
{
    HRESULT hr = E_NOTIMPL;

    switch (uType)
    {
    case GCS_VERBA:
    case GCS_VERBW:
        hr = SHMapCmdIDToVerb(idCmd, c_sIDVerbMap, ARRAYSIZE(c_sIDVerbMap), pszName, cchMax, GCS_VERBW == uType);
    }

    if (FAILED(hr))
    {
        hr = _DefaultMenu()->GetCommandString(idCmd, uType, pwReserved, pszName, cchMax);
    }

    return hr;
}

HRESULT CMergedFldrContextMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    if (_pmfParent->_fInShellView)
    {
        IContextMenu2 *pcm2;
        hr = _DefaultMenu()->QueryInterface(IID_PPV_ARG(IContextMenu2, &pcm2));
        if (SUCCEEDED(hr))
        {
            hr = pcm2->HandleMenuMsg(uMsg, wParam, lParam);
            pcm2->Release();
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }
    return hr;
}

HRESULT CMergedFldrContextMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr;
    if (_pmfParent->_fInShellView)
    {
        IContextMenu3 *pcm3;
        hr = _DefaultMenu()->QueryInterface(IID_PPV_ARG(IContextMenu3, &pcm3));
        if (SUCCEEDED(hr))
        {
            hr = pcm3->HandleMenuMsg2(uMsg, wParam, lParam, plResult);
            pcm3->Release();
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }
    return hr;
}

HRESULT CMergedFldrContextMenu_CreateInstance(HWND hwnd, CMergedFolder *pmf, UINT cidl, LPCITEMIDLIST *apidl, IContextMenu *pcmCommon, IContextMenu *pcmUser, IContextMenu **ppcm)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMergedFldrContextMenu* pcm = new CMergedFldrContextMenu(hwnd, pcmCommon, pcmUser);
    if (pcm)
    {
        hr = pcm->_Initialize(pmf, cidl, apidl);
        if (SUCCEEDED(hr))
        {
            hr = pcm->QueryInterface(IID_PPV_ARG(IContextMenu, ppcm));
        }
        pcm->Release();
    }
    return hr;
}

class CMergedCategorizer : public ICategorizer,
                           public IShellExtInit
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID);

    CMergedCategorizer();
private:
    ~CMergedCategorizer();
    long _cRef;
    CMergedFolder *_pmf;
};

//  Type Categorizer

STDAPI CMergedCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMergedCategorizer *pmc = new CMergedCategorizer();
    if (pmc)
    {
        hr = pmc->QueryInterface(riid, ppv);
        pmc->Release();
    }
    return hr;
}

CMergedCategorizer::CMergedCategorizer() : 
    _cRef(1)
{
}

CMergedCategorizer::~CMergedCategorizer()
{
    ATOMICRELEASE(_pmf);
}

HRESULT CMergedCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CMergedCategorizer, ICategorizer),
        QITABENT(CMergedCategorizer, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CMergedCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CMergedCategorizer::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CMergedCategorizer::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID)
{
    ATOMICRELEASE(_pmf);
    return SHBindToObjectEx(NULL, pidlFolder, NULL, CLSID_MergedFolder, (void**)&_pmf);
}

HRESULT CMergedCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    LoadString(HINST_THISDLL, IDS_WHICHFOLDER_COL, pszDesc, cch);
    return S_OK;
}

HRESULT CMergedCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST *apidl, DWORD *rgCategoryIds)
{
    HRESULT hr = E_ACCESSDENIED;

    if (_pmf)
    {
        for (UINT i = 0; i < cidl; i++)
        {
            rgCategoryIds[i] = -1;
            CMergedFldrNamespace *pns;
            UINT uSrcID;
            for (UINT j = 0; SUCCEEDED(_pmf->_GetSubPidl(apidl[i], j, &uSrcID, NULL, &pns)); j++)
            {
                if (_pmf->_ShouldSuspend(pns->GetGUID()))
                {
                    continue;
                }
                rgCategoryIds[i] = uSrcID;
                if (ASFF_DEFNAMESPACE_ATTRIB & pns->FolderAttrib())
                {
                    // if we have more than one, keep the one from the defnamespace for attrib.
                    break;
                }
            }
        }

        hr = S_OK;
    }

    return hr;
}

HRESULT CMergedCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    CMergedFldrNamespace *pns;
    HRESULT hr = _pmf->_Namespace(dwCategoryId, &pns);
    if (SUCCEEDED(hr))
    {
        hr = pns->GetLocation(pci->wszName, ARRAYSIZE(pci->wszName));
    }
    return hr;
}

HRESULT CMergedCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == dwCategoryId2)
        return ResultFromShort(0);
    else if (dwCategoryId1 > dwCategoryId2)
        return ResultFromShort(-1);
    else
        return ResultFromShort(1);
}


#define NORMALEVENTS (SHCNE_RENAMEITEM | SHCNE_RENAMEFOLDER | SHCNE_CREATE | SHCNE_DELETE | SHCNE_UPDATEDIR | SHCNE_UPDATEITEM | SHCNE_MKDIR | SHCNE_RMDIR)
#define CDBURNEVENTS (SHCNE_MEDIAREMOVED | SHCNE_MEDIAINSERTED)
CMergedFolderViewCB::CMergedFolderViewCB(CMergedFolder *pmf) :
    CBaseShellFolderViewCB(pmf->_pidl, (pmf->_fCDBurn) ? CDBURNEVENTS|NORMALEVENTS : NORMALEVENTS),
    _pmf(pmf)
{
    _pmf->AddRef();
}

CMergedFolderViewCB::~CMergedFolderViewCB()
{
    _pmf->Release();
}

HRESULT CMergedFolderViewCB::_RefreshObjectsWithSameName(IShellFolderView *psfv, LPITEMIDLIST pidl)
{
    TCHAR szName[MAX_PATH];
    HRESULT hr = DisplayNameOf(SAFECAST(_pmf, IShellFolder2 *), pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
    if (SUCCEEDED(hr))
    {
        CMergedFldrNamespace *pns;
        for (int i = 0; SUCCEEDED(hr) && (pns = _pmf->_Namespace(i)); i++)
        {
            LPITEMIDLIST pidlItem;
            if (SUCCEEDED(pns->Folder()->ParseDisplayName(NULL, NULL, szName, NULL, &pidlItem, NULL)))
            {
                LPITEMIDLIST pidlItemWrap;
                hr = _pmf->_CreateWrap(pidlItem, i, &pidlItemWrap);
                if (SUCCEEDED(hr))
                {
                    UINT uItem;
                    hr = psfv->UpdateObject(pidlItemWrap, pidlItemWrap, &uItem);
                    ILFree(pidlItemWrap);
                }
                ILFree(pidlItem);
            }
        }
    }
    return hr;
}

HRESULT CMergedFolderViewCB::_OnFSNotify(DWORD pv, LPCITEMIDLIST *ppidl, LPARAM lp)
{
    // bail out early if we're merging.
    // S_OK indicates to defview to do what it usually does
    if (!_pmf->_fDontMerge)
        return S_OK;

    IShellFolderView *psfv;
    HRESULT hr = IUnknown_GetSite(SAFECAST(this, IShellFolderViewCB*), IID_PPV_ARG(IShellFolderView, &psfv));
    if (SUCCEEDED(hr))
    {
        LONG lEvent = (LONG) lp;
        LPITEMIDLIST pidl1 = ppidl[0] ? ILFindChild(_pidl, ppidl[0]) : NULL;
        LPITEMIDLIST pidl2 = ppidl[1] ? ILFindChild(_pidl, ppidl[1]) : NULL;

        UINT uItem;
        switch (lEvent)
        {
            case SHCNE_RENAMEFOLDER:
            case SHCNE_RENAMEITEM:
                // we need to handle the in/out for the view
                if (pidl1 && pidl2)
                {
                    if (SUCCEEDED(psfv->UpdateObject(pidl1, pidl2, &uItem)))
                        hr = S_FALSE;
                    _RefreshObjectsWithSameName(psfv, pidl1);
                    _RefreshObjectsWithSameName(psfv, pidl2);
                }
                else if (pidl1)
                {
                    if (SUCCEEDED(psfv->RemoveObject(pidl1, &uItem)))
                        hr = S_FALSE;
                    _RefreshObjectsWithSameName(psfv, pidl1);
                }
                else if (pidl2)
                {
                    if (SUCCEEDED(psfv->AddObject(pidl2, &uItem)))
                        hr = S_FALSE;
                    _RefreshObjectsWithSameName(psfv, pidl2);
                }
                break;

            case SHCNE_CREATE:
            case SHCNE_MKDIR:
                ASSERTMSG(pidl1 != NULL, "incoming notify should be child of _pidl because thats what we were listening for");
                if (SUCCEEDED(psfv->AddObject(pidl1, &uItem)))
                    hr = S_FALSE;
                _RefreshObjectsWithSameName(psfv, pidl1);
                break;

            case SHCNE_DELETE:
            case SHCNE_RMDIR: 
                ASSERTMSG(pidl1 != NULL, "incoming notify should be child of _pidl because thats what we were listening for");
                if (SUCCEEDED(psfv->RemoveObject(pidl1, &uItem)))
                    hr = S_FALSE;
                _RefreshObjectsWithSameName(psfv, pidl1);
                break;

            default:
                break;
        }

        psfv->Release();
    }
    return hr;
}

STDMETHODIMP CMergedFolderViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(0, SFVM_FSNOTIFY, _OnFSNotify);

    default:
        return E_NOTIMPL;
    }
    return S_OK;
}

HRESULT CMergedFolderViewCB_CreateInstance(CMergedFolder *pmf, IShellFolderViewCB **ppsfvcb)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMergedFolderViewCB *pcmfvcb = new CMergedFolderViewCB(pmf);
    if (pcmfvcb)
    {
        hr = pcmfvcb->QueryInterface(IID_PPV_ARG(IShellFolderViewCB, ppsfvcb));
        pcmfvcb->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mergfldr.h ===
#ifndef _mergfldr_h_
#define _mergfldr_h_

#include "sfstorage.h"
#include "clsobj.h"

class CMergedFolder;
class CMergedFldrDropTarget;
class CMergedFldrContextMenu;
class CMergedFldrNamespace;
class CMergedFldrItem;
class CMergedFldrEnum;
class CMergedCategorizer;
class CMergedFolderViewCB;

class CMergedFolder : public CSFStorage,
                      public IAugmentedShellFolder3,
                      public IShellService,
                      public ITranslateShellChangeNotify,
                      public IPersistFolder2,
                      public IPersistPropertyBag,
                      public IShellIconOverlay,
                      public ICompositeFolder,
                      public IItemNameLimits
{
public:
    // IUnknown
    STDMETHOD (QueryInterface)(REFIID, void **);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHOD(EnumObjects)(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHOD(CreateViewObject)(HWND hwndOwner, REFIID riid, void **ppvOut);
    STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHOD(GetUIObjectOf)(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHOD(SetNameOf)(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IShellFolder2
    // stub implementation to indicate we support CompareIDs() for identity
    STDMETHOD(GetDefaultSearchGUID)(LPGUID) 
        { return E_NOTIMPL; }
    STDMETHOD(EnumSearches)(LPENUMEXTRASEARCH *pe) 
        { *pe = NULL; return E_NOTIMPL; }
    STDMETHOD(GetDefaultColumn)(DWORD dwRes, ULONG *pSort, ULONG *pDisplay) 
        { return E_NOTIMPL; };
    
    STDMETHOD(GetDefaultColumnState)(UINT iColumn, DWORD *pbState);
    STDMETHOD(GetDetailsEx)(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHOD(MapColumnToSCID)(UINT iCol, SHCOLUMNID *pscid);

    // IAugmentedShellFolder
    STDMETHOD(AddNameSpace)(const GUID * pguidObject, IShellFolder * psf, LPCITEMIDLIST pidl, DWORD dwFlags);
    STDMETHOD(GetNameSpaceID)(LPCITEMIDLIST pidl, GUID * pguidOut);
    STDMETHOD(QueryNameSpace)(DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf);
    STDMETHOD(EnumNameSpace)(DWORD cNameSpaces, DWORD * pdwID);

    // IAugmentedShellFolder2
    STDMETHOD(UnWrapIDList)(LPCITEMIDLIST pidlWrap, LONG cPidls, IShellFolder** apsf, LPITEMIDLIST* apidlFolder, LPITEMIDLIST* apidlItems, LONG* pcFetched);

    // IAugmentedShellFolder3
    STDMETHOD(QueryNameSpace2)(DWORD dwID, QUERYNAMESPACEINFO *pqnsi);

    // IShellService
    STDMETHOD(SetOwner)(IUnknown * punkOwner);

    // ITranslateShellChangeNotify
    STDMETHOD(TranslateIDs)(LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST *ppidlOut1, LPITEMIDLIST *ppidlOut2,
                            LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, LPITEMIDLIST *ppidlOut2Event2);
    STDMETHOD(IsChildID)(LPCITEMIDLIST pidlKid, BOOL fImmediate);
    STDMETHOD(IsEqualID)(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHOD(Register)(HWND hwnd, UINT uMsg, long lEvents);
    STDMETHOD(Unregister)(void);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pclsid) 
        { *pclsid = _clsid; return S_OK; };

    // IPersistFolder
    STDMETHOD(Initialize)(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHOD(GetCurFolder)(LPITEMIDLIST *ppidl);

    // IPersistPropertyBag
    STDMETHOD(InitNew)()
        { return E_NOTIMPL; };
    STDMETHOD(Load)(IPropertyBag* ppb, IErrorLog *pErrLog);
    STDMETHOD(Save)(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
        { return E_NOTIMPL; };

    // IShellIconOverlay
    STDMETHOD(GetOverlayIndex)(LPCITEMIDLIST pidl, int *pIndex);
    STDMETHOD(GetOverlayIconIndex)(LPCITEMIDLIST pidl, int *pIndex);

    // ICompositeFolder
    STDMETHOD(InitComposite)(WORD wSignature, REFCLSID refclsid, CFINITF cfiFlags, ULONG celt, const COMPFOLDERINIT *rgCFs);
    STDMETHOD(BindToParent)(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPITEMIDLIST *ppidlLast);

    // IItemNameLimits
    STDMETHOD(GetValidCharacters)(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars)
        { return E_NOTIMPL; }
    STDMETHOD(GetMaxLength)(LPCWSTR pszName, int *piMaxNameLen)
        { return E_NOTIMPL; }

protected:
    CMergedFolder(CMergedFolder*pmfParent, REFCLSID clsid);
    virtual ~CMergedFolder();
    friend HRESULT CMergedFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
    friend HRESULT CCompositeFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
    virtual HRESULT _CreateWithCLSID(CLSID clsid, CMergedFolder **ppmf);
    virtual BOOL _ShouldSuspend(REFGUID rguid);

private:

    // CSFStorage
    STDMETHOD(_DeleteItemByIDList)(LPCITEMIDLIST pidl);
    STDMETHOD(_StgCreate)(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv);

    CMergedFldrNamespace* _Namespace(int iNamespace);
    HRESULT _Namespace(int i, CMergedFldrNamespace **ppns);
    HRESULT _NamespaceForItem(LPCITEMIDLIST pidlWrap, ULONG dwAttribMask, ULONG dwAttrib, IShellFolder** ppsf, LPITEMIDLIST *ppidl, CMergedFldrNamespace **ppns, BOOL fExact = FALSE);
    HRESULT _OldTranslateIDs(LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST *ppidlOut1, LPITEMIDLIST *ppidlOut2,
                             LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, LPITEMIDLIST *ppidlOut2Event2);
    HRESULT _NewTranslateIDs(LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST *ppidlOut1, LPITEMIDLIST *ppidlOut2,
                             LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, LPITEMIDLIST *ppidlOut2Event2);
    HRESULT _GetOverlayInfo(LPCITEMIDLIST pidl, int * pIndex, DWORD dwFlags);

    BOOL _NamespaceMatches(ULONG dwAttribMask, ULONG dwAttrib, LPCGUID pguid, CMergedFldrNamespace *pns);
    HRESULT _FindNamespace(ULONG dwAttribMask, ULONG dwAttrib, LPCGUID pguid, CMergedFldrNamespace **ppv, BOOL fFallback = FALSE);
    BOOL    _ShouldMergeNamespaces(int iNS1, int iNS2);
    BOOL    _ShouldMergeNamespaces(CMergedFldrNamespace *pns1, CMergedFldrNamespace *pns2);
    CMergedFolder*_Parent() { return _pmfParent; }
    HRESULT _GetPidl(int* piPos, DWORD grfEnumFlags, LPITEMIDLIST *ppidl);
    HRESULT _GetFolder2(LPCITEMIDLIST pidlWrap, LPITEMIDLIST *ppidlItem, IShellFolder2 **ppsf);
    BOOL _ContainsCommonItem(LPCITEMIDLIST pidl);
    HRESULT _New(LPCITEMIDLIST pidlWrap, CMergedFolder **ppmf);

    HRESULT _IsWrap(LPCITEMIDLIST pidlTest);
    HRESULT _CreateWrap(LPCITEMIDLIST pidlSrc, UINT nSrcID, LPITEMIDLIST *ppidlWrap);
    HRESULT _WrapAddIDList(LPCITEMIDLIST pidlSrc, UINT nSrcID, IN OUT LPITEMIDLIST *ppidlWrap);
    ULONG _GetSourceCount(IN LPCITEMIDLIST pidl);
    BOOL _ContainsSrcID(LPCITEMIDLIST pidlWrap, UINT uSrcID);
    HRESULT _WrapRemoveIDList(LPITEMIDLIST pidlWrap, UINT nSrcID, LPITEMIDLIST *ppidl);
    HRESULT _WrapRemoveIDListAbs(LPITEMIDLIST pidlWrapAbs, UINT nSrcID, LPITEMIDLIST *ppidlAbs);
    HRESULT _GetSubPidl(LPCITEMIDLIST pidlWrap, int i, UINT* pnSrcID, LPITEMIDLIST *ppidl, CMergedFldrNamespace **ppns);
    HRESULT _ForceParseDisplayName(LPCITEMIDLIST pidlAbsNamespace, LPTSTR pszDisplayName, BOOL fForce, BOOL *pfOthersInwrap, LPITEMIDLIST *ppidl);
    HRESULT _AbsPidlToAbsWrap(CMergedFldrNamespace *pns, LPCITEMIDLIST pidl, BOOL fForce, BOOL *pfOthersInwrap, LPITEMIDLIST *ppidl);
    HRESULT _AddComposite(const COMPFOLDERINIT *pcfi);
    void _SetSimple(LPITEMIDLIST *ppidl);
    BOOL _IsSimple(LPCITEMIDLIST pidl);

    HRESULT _FixStrRetOffset(LPCITEMIDLIST pidl, STRRET *psr);
    BOOL _IsFolder(LPCITEMIDLIST pidl);
    HRESULT _CreateOtherNameSpace(IShellFolder **ppsf);
    HRESULT _CompareSingleLevelIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    static int CALLBACK _SearchByName(void *p1, void *p2, LPARAM lParam);
    static void *_Merge(UINT uMsg, void * pv1, void * pv2, LPARAM lParam);
    static int _CompareArbitraryPidls(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    static int _Compare(void *pv1, void *pv2, LPARAM lParam);

    HRESULT _SearchForPidl(int iNamespace, CMergedFldrNamespace *pns, LPCITEMIDLIST pidl, BOOL fFolder, int* piIndex, CMergedFldrItem** ppmfi);
    HRESULT _GetTargetUIObjectOf(IShellFolder *psf, HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, UINT *prgf, void **ppv);
    HRESULT _GetContextMenu(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, void **ppv);

    int _NamespaceCount() const;
    void _FreeNamespaces();

    int _AcquireObjects();
    void _FreeObjects();
    int _ObjectCount() const;
    CMergedFldrItem *_GetObject(int i);
    
    BOOL _IsFolderEvent(LONG lEvent);
    LPITEMIDLIST _ILCombineBase(LPCITEMIDLIST pidlContainingBase, LPCITEMIDLIST pidlRel);

    static int _DestroyObjectsProc(void *pv, void *pvData);
    static int _SetOwnerProc(void *, void *);
    static int _SetNotifyProc(void *, void *);
    static int _DestroyNamespacesProc(void *pv, void *pvData);

    BOOL _IsChildIDInternal(LPCITEMIDLIST pidl, BOOL fImmediate, int* iShellFolder);
    
    void _GetKeyForProperty(LPWSTR pszName, LPWSTR pszValue, LPWSTR pszBuffer, INT cchBuffer);
    HRESULT _AddNameSpaceFromPropertyBag(IPropertyBag *ppb, LPWSTR pszName);
    HRESULT _SimpleAddNamespace(CMergedFldrNamespace *pns);
    BOOL _IsOurColumn(UINT iColumn);
    HRESULT _GetWhichFolderColumn(LPCITEMIDLIST pidl, LPTSTR pszBuffer, INT cchBuffer);
    HRESULT _GetDestinationStorage(DWORD grfMode, IStorage **ppstg);
    void _AddAllOtherNamespaces(LPITEMIDLIST *ppidl);

public:
    LPITEMIDLIST      _pidl;                  // CMergedFolder is a base class for several IShellFolders, and their IShellFolderViewCBs need access to this

private:
    CLSID             _clsid;                 // our identity
    LONG              _cRef;                  // reference count.
    HDPA              _hdpaNamespaces;        // source _Namespace collection
    HDPA              _hdpaObjects;           // array of (CMergedFldrItem *)
    CMergedFolder    *_pmfParent;             // parent folder (if any)
    UINT              _iColumnOffset;         // offset to my column set (-1 if unknown)
    DWORD             _dwDropEffect;          // default drop effect for this folder
    BOOL              _fInShellView;          // true if we're in the view.  used in TranslateIDs.
    BOOL              _fDontMerge;            // true means don't merge the items in the view (but still navigate like we're merged).
    BOOL              _fPartialMerge;         // true if only some namespaces should be merged
    BOOL              _fCDBurn;               // true means we're the cdburn case.
    IStorage         *_pstg;                  // hold onto the storage for the first namespace (default for IStorage operations).
    BOOL              _fAcquiring;            // correct for architecture problem where state is kept in the folder about the enumeration

    friend CMergedFldrEnum;
    friend CMergedFldrDropTarget;
    friend CMergedFldrContextMenu;
    friend CMergedCategorizer;
    friend CMergedFolderViewCB;
};


class CMergedFolderViewCB : public CBaseShellFolderViewCB
{
public:
    CMergedFolderViewCB(CMergedFolder *pmf);

    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    virtual ~CMergedFolderViewCB();

    CMergedFolder *_pmf;

private:
    HRESULT _OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvi);
    HRESULT _OnFSNotify(DWORD pv, LPCITEMIDLIST *ppidl, LPARAM lp);
    HRESULT _RefreshObjectsWithSameName(IShellFolderView *psfv, LPITEMIDLIST pidl);
};



#endif // _mergfldr_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mountvol.cpp ===
//   Implements Mounted Volume

#include "shellprv.h"
#include "clsobj.h"

EXTERN_C CLIPFORMAT g_cfMountedVolume = 0;

class CMountedVolume : public IMountedVolume, IDataObject
{
public:
    //IUnknown methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    //IDataObject methods
    STDMETHODIMP GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium);
    STDMETHODIMP GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium);
    STDMETHODIMP QueryGetData(LPFORMATETC pformatetcIn);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut);
    STDMETHODIMP SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppenumFormatEtc);
    STDMETHODIMP DAdvise(FORMATETC *pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD *pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppenumAdvise);

    // IMountedVolume methods
    STDMETHODIMP Initialize(LPCWSTR pcszMountPoint);
protected:
    CMountedVolume();
    ~CMountedVolume();

    friend HRESULT CMountedVolume_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv);

private:
    LONG _cRef;
    TCHAR _szMountPoint[MAX_PATH];
};

//constructor/destructor and related functions

CMountedVolume::CMountedVolume() :
    _cRef(1)
{
    _szMountPoint[0] = 0;
    DllAddRef();
}

CMountedVolume::~CMountedVolume()
{
    DllRelease();
}

STDAPI CMountedVolume_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;
    
    if (!g_cfMountedVolume)
        g_cfMountedVolume = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_MOUNTEDVOLUME);

    // aggregation checking is handled in class factory
    CMountedVolume* pMountedVolume = new CMountedVolume();
    if (pMountedVolume)
    {
        hr = pMountedVolume->QueryInterface(riid, ppv);
        pMountedVolume->Release();
    }

    return hr;
}

//IUnknown handling

STDMETHODIMP CMountedVolume::QueryInterface(REFIID riid,void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMountedVolume, IDataObject),
        QITABENT(CMountedVolume, IMountedVolume),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CMountedVolume::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMountedVolume::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

//IDataObject handling
STDMETHODIMP CMountedVolume::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
    HRESULT hr = E_FAIL;

    //make sure IMountedVolume::Initialize was called
    if (TEXT('\0') != _szMountPoint[0])
    {
        pmedium->hGlobal = NULL;
        pmedium->pUnkForRelease = NULL;
        pmedium->tymed = TYMED_HGLOBAL;

        if ((g_cfMountedVolume == pformatetcIn->cfFormat) && (TYMED_HGLOBAL & pformatetcIn->tymed))
        {
            pmedium->hGlobal = GlobalAlloc(GPTR, (MAX_PATH + 1) * SIZEOF(TCHAR) + SIZEOF(DROPFILES));

            if (pmedium->hGlobal)
            {
                LPDROPFILES pdf = (LPDROPFILES)pmedium->hGlobal;
                LPTSTR pszMountPoint = (LPTSTR)(pdf + 1);
                pdf->pFiles = SIZEOF(DROPFILES);
                ASSERT(pdf->pt.x==0);
                ASSERT(pdf->pt.y==0);
                ASSERT(pdf->fNC==FALSE);
                ASSERT(pdf->fWide==FALSE);
        #ifdef UNICODE
                pdf->fWide = TRUE;
        #endif
                //do the copy
                lstrcpy(pszMountPoint, _szMountPoint);
                hr = S_OK;     // success
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    else
        ASSERTMSG(0, "IMountedVolume::Initialize was NOT called prior to IMountedVolume::GetData");

    return hr;
}

STDMETHODIMP CMountedVolume::QueryGetData(LPFORMATETC pformatetcIn)
{
    HRESULT hr = S_FALSE;

    if ((g_cfMountedVolume == pformatetcIn->cfFormat) && (TYMED_HGLOBAL & pformatetcIn->tymed))
        hr = S_OK;

    return hr;
}

STDMETHODIMP CMountedVolume::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMountedVolume::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium )
{
    return E_NOTIMPL;
}

STDMETHODIMP CMountedVolume::GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMountedVolume::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppenumFormatEtc)
{
    return S_FALSE;
}

STDMETHODIMP CMountedVolume::DAdvise(FORMATETC *pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD *pdwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CMountedVolume::DUnadvise(DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CMountedVolume::EnumDAdvise(LPENUMSTATDATA *ppenumAdvise)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

// IMountedVolume methods
STDMETHODIMP CMountedVolume::Initialize(LPCWSTR pcszMountPoint)
{
    lstrcpy(_szMountPoint, pcszMountPoint);
    PathAddBackslash(_szMountPoint);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mkhelp.cpp ===
#include "shellprv.h"
//#include "mkhelp.h"
#include "urlmon.h"
#include "ids.h"

class CBSCLocalCopyHelper :   public IBindStatusCallback,
                            public IAuthenticate
{
public:
    CBSCLocalCopyHelper(IBindCtx *pbc, BOOL fWebfolders);

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release ();

    // *** IAuthenticate ***
    virtual STDMETHODIMP Authenticate(
        HWND *phwnd,
        LPWSTR *pszUsername,
        LPWSTR *pszPassword);

    // *** IBindStatusCallback ***
    virtual STDMETHODIMP OnStartBinding(
        /* [in] */ DWORD grfBSCOption,
        /* [in] */ IBinding *pib);

    virtual STDMETHODIMP GetPriority(
        /* [out] */ LONG *pnPriority);

    virtual STDMETHODIMP OnLowResource(
        /* [in] */ DWORD reserved);

    virtual STDMETHODIMP OnProgress(
        /* [in] */ ULONG ulProgress,
        /* [in] */ ULONG ulProgressMax,
        /* [in] */ ULONG ulStatusCode,
        /* [in] */ LPCWSTR szStatusText);

    virtual STDMETHODIMP OnStopBinding(
        /* [in] */ HRESULT hresult,
        /* [in] */ LPCWSTR szError);

    virtual STDMETHODIMP GetBindInfo(
        /* [out] */ DWORD *grfBINDINFOF,
        /* [unique][out][in] */ BINDINFO *pbindinfo);

    virtual STDMETHODIMP OnDataAvailable(
        /* [in] */ DWORD grfBSCF,
        /* [in] */ DWORD dwSize,
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pstgmed);

    virtual STDMETHODIMP OnObjectAvailable(
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ IUnknown *punk);


protected:
    ~CBSCLocalCopyHelper();

    long _cRef;
    IBinding *_pib;

    IProgressDialog *_pdlg;
    HWND _hwnd;

    BOOL _fRosebudMagic;
};

CBSCLocalCopyHelper::CBSCLocalCopyHelper(IBindCtx *pbc, BOOL fWebfolders) 
    : _cRef(1) , _fRosebudMagic(fWebfolders)
{
    //  we should use the pbc to 
    //  get our simpler uiprogress
    //  interface.  but for now
    //  we will do nothing
}

CBSCLocalCopyHelper::~CBSCLocalCopyHelper()
{
    ATOMICRELEASE(_pib);
    ATOMICRELEASE(_pdlg);

    //  NOTE dont need to release _ppstm because we dont own it
}

STDMETHODIMP CBSCLocalCopyHelper::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CBSCLocalCopyHelper, IBindStatusCallback),
        QITABENT(CBSCLocalCopyHelper, IAuthenticate),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CBSCLocalCopyHelper::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CBSCLocalCopyHelper::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CBSCLocalCopyHelper::Authenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
{
    if (ppszUsername)
        *ppszUsername = NULL;
    if (ppszPassword)
        *ppszPassword = NULL;
        
    *phwnd = GetLastActivePopup(_hwnd);

    return *phwnd ? S_OK : E_FAIL;
}

STDMETHODIMP CBSCLocalCopyHelper::OnStartBinding(DWORD dwReserved,IBinding *pib)
{
    ATOMICRELEASE(_pib);
    if (pib)
    {
        pib->AddRef();
        _pib = pib;
    }

    if (_pdlg)
    {
        WCHAR sz[MAX_PATH];
        //  we are starting out here
        _pdlg->Timer(PDTIMER_RESET, NULL);
        _pdlg->SetProgress(0, 0);
        LoadStringW(HINST_THISDLL, IDS_ACCESSINGMONIKER, sz, ARRAYSIZE(sz));
        _pdlg->SetLine(1, sz, FALSE, NULL);
    }
    
    return S_OK;
}

STDMETHODIMP CBSCLocalCopyHelper::GetPriority(LONG *pnPriority)
{
    if (pnPriority)
    {
        //  we are a blocking UI thread
        *pnPriority = THREAD_PRIORITY_ABOVE_NORMAL;
    }
    return S_OK;
}

STDMETHODIMP CBSCLocalCopyHelper::OnLowResource(DWORD reserved)
{
    return S_OK;
}

STDMETHODIMP CBSCLocalCopyHelper::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pszStatusText)
{
    HRESULT hr = S_OK;
    //  handle UI udpates
    if (_pdlg)
    {
        if (_pdlg->HasUserCancelled())
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        
        if (ulProgressMax)
        {
            _pdlg->SetProgress(ulProgress, ulProgressMax);
        }

        if (pszStatusText)
            _pdlg->SetLine(1, pszStatusText, FALSE, NULL);
    }
    
    return hr;
}

STDMETHODIMP CBSCLocalCopyHelper::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    //  handle something
    ATOMICRELEASE(_pib);
    return S_OK;
}

STDMETHODIMP CBSCLocalCopyHelper::GetBindInfo(DWORD *grfBINDINFOF, BINDINFO *pbindinfo)
{
    if (_fRosebudMagic && pbindinfo)
    {
        //  this is the magic number that says its ok for URLMON to use DAV/rosebud/webfolders.
        //  we dont need this during download and in fact if we 
        //  set it, we may not be able to retrieve the resource.
        //  we coudl do some kind of check on the moniker to verify the clsid
        //  comes from URLMON.  right now this is how office handles 
        //  all of its requests so we do too.
        pbindinfo->dwOptions = 1;
    }

    if (grfBINDINFOF)
    {
        *grfBINDINFOF = BINDF_GETFROMCACHE_IF_NET_FAIL | BINDF_GETNEWESTVERSION;
    }

    return S_OK;
}

STDMETHODIMP CBSCLocalCopyHelper::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
#if 0   // we might need this, but right now we are sync
        // so we get the stream back in the BindToStorage()
    
    if (grfBSCF & BSCF_LASTDATANOTIFICATION &&
        pformatetc &&
        pformatetc->tymed == TYMED_ISTREAM &&
        pstgmed &&
        pstgmed->pstm)
    {
        if (_ppstm)
        {
            pstgmed->pstm->AddRef();
            *_ppstm = pstgmed->pstm;
        }
    }
#endif

    return S_OK;
}

STDMETHODIMP CBSCLocalCopyHelper::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    return E_UNEXPECTED;
}

HRESULT _CreateUrlmonBindCtx(IBindCtx *pbcIn, BOOL fWebfolders, IBindCtx **ppbc, IBindStatusCallback **ppbsc)
{
    IBindCtx *pbc;
    HRESULT hr = CreateBindCtx(0, &pbc);
    *ppbc = NULL;
    *ppbsc = NULL;

    if (SUCCEEDED(hr))
    {
        IBindStatusCallback *pbsc = (IBindStatusCallback *) new CBSCLocalCopyHelper(pbcIn, fWebfolders);

        if (pbsc)
        {
            //  maybe we should attach it to the existing 
            //  pbc, but for now we will create a new one.
            hr = RegisterBindStatusCallback(pbc, pbsc, NULL, 0);

            if (SUCCEEDED(hr))
            {
                BIND_OPTS bo = {0};
                bo.cbStruct = SIZEOF(bo);
                bo.grfMode = BindCtx_GetMode(pbcIn, STGM_READ);

                //
                //  on webfolders, (and possibly other URLMON
                //  monikers), if you are attempting to create a 
                //  writable stream you also need to pass STGM_CREATE
                //  even if the file you are writing to already exists.
                //
                if (bo.grfMode & (STGM_WRITE | STGM_READWRITE))
                    bo.grfMode |= STGM_CREATE;
                
                hr = pbc->SetBindOptions(&bo);
            }
        }
        else
            hr = E_OUTOFMEMORY;


        if (SUCCEEDED(hr))
        {
            *ppbc = pbc;
            *ppbsc = pbsc;
        }
        else
        {
            pbc->Release();
            if (pbsc)
                pbsc->Release();
        }
    }

    return hr;
}

static const GUID CLSID_WEBFOLDERS = // {BDEADF00-C265-11D0-BCED-00A0C90AB50F}
    { 0xBDEADF00, 0xC265, 0x11D0, { 0xBC, 0xED, 0x00, 0xA0, 0xC9, 0x0A, 0xB5, 0x0F} };

BOOL _IsWebfolders(IShellItem *psi)
{
    BOOL fRet = FALSE;
    IShellItem *psiParent;
    HRESULT hr = psi->GetParent(&psiParent);

    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        SFGAOF flags = SFGAO_LINK;
        if (SUCCEEDED(psiParent->GetAttributes(flags, &flags))
        && (flags & SFGAO_LINK))
        {
            //  this is a folder shortcut that needs derefing
            IShellItem *psiTarget;
            hr = psiParent->BindToHandler(NULL, BHID_LinkTargetItem, IID_PPV_ARG(IShellItem, &psiTarget));

            if (SUCCEEDED(hr))
            {
                //  switcheroo
                psiParent->Release();
                psiParent = psiTarget;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = psiParent->BindToHandler(NULL, BHID_SFObject, IID_PPV_ARG(IShellFolder, &psf));

            if (SUCCEEDED(hr))
            {
                CLSID clsid;
                if (SUCCEEDED(IUnknown_GetClassID(psf, &clsid)))
                    fRet = IsEqualGUID(clsid, CLSID_WEBFOLDERS);

                psf->Release();
            }
        }
        
        psiParent->Release();
    }

    return fRet;
}

HRESULT _CreateStorageHelper(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv)
{
    IMoniker *pmk;
    HRESULT hr = psi->BindToHandler(pbc, BHID_SFObject, IID_PPV_ARG(IMoniker, &pmk));

    if (SUCCEEDED(hr))
    {
        IBindCtx *pbcMk;
        IBindStatusCallback *pbsc;
        hr = _CreateUrlmonBindCtx(pbc, _IsWebfolders(psi), &pbcMk, &pbsc);

        if (SUCCEEDED(hr))
        {
            hr = pmk->BindToStorage(pbcMk, NULL, riid, ppv);
            // urlmon + ftp url can cause this.  remove when 3140245 is fixed
            if (SUCCEEDED(hr) && NULL == *ppv)
                hr = E_FAIL;

            RevokeBindStatusCallback(pbcMk, pbsc);
                
            pbcMk->Release();
            pbsc->Release();
        }
    }

    return hr;
}

#if 0 //  not needed right now

LPCWSTR CLocalCopyHelper::_GetTitle(void)
{
    if (!*_szTitle)
    {
        WCHAR sz[MAX_PATH];
        DWORD cch = ARRAYSIZE(_szTitle);
        GetModuleFileNameW(NULL, sz, ARRAYSIZE(sz));

        if (FAILED(AssocQueryStringW(ASSOCF_INIT_BYEXENAME | ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, sz, NULL, _szTitle, &cch)))
            StrCpyNW(_szTitle, PathFindFileNameW(sz), ARRAYSIZE(_szTitle));
    }

    return _szTitle;
}
void CLocalCopyHelper::_InitUI(MKHELPF flags, IProgressDialog **ppdlg, HWND *phwnd, LPCWSTR pszTitle)
{
    *ppdlg = NULL;
    
    if (flags & MKHELPF_NOUI)
    {
        *phwnd = NULL;
        return;
    }

    if (!(flags & MKHELPF_NOPROGRESSUI) && *phwnd)
    {
        IProgressDialog *pdlg;
        if(SUCCEEDED(CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IProgressDialog, &pdlg))))
        {
            if (!pszTitle)
                pszTitle = _GetTitle();
                
            pdlg->SetTitle(pszTitle);
            pdlg->SetAnimation(g_hinst, IDA_FILECOPY);
            pdlg->SetLine(2, _pszName, TRUE, NULL);
            if (SUCCEEDED(pdlg->StartProgressDialog(*phwnd, NULL, PROGDLG_MODAL | PROGDLG_AUTOTIME, NULL)))
                *ppdlg = pdlg;
            else
                pdlg->Release();
        }
    }
}

#endif

EXTERN_C WINSHELLAPI HRESULT STDAPICALLTYPE SHCopyMonikerToTemp(IMoniker *pmk, LPCWSTR pszIn, LPWSTR pszOut, int cchOut)
{
    //  REMOVE this as soon as ComDlg32 is updated
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mtpt2.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "mtpt.h"
#include "ids.h"
#include "shitemid.h"
#include "filetbl.h"

#include "shpriv.h"
#include "hwcmmn.h"

#include "apithk.h"

#include <ntddcdrm.h>

///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
// get the friendly name for a given drive thing
// for example:
//      Floppy (A:)
//      Volume Name (D:)
//      User on 'Pyrex' (V:)
//      Dist on Strike\sys\public (Netware case)
HRESULT CMountPoint::GetDisplayName(LPTSTR pszName, DWORD cchName)
{
    HRESULT hres = E_FAIL;
    TCHAR szDriveLabel[MAX_DISPLAYNAME];
    static BOOL s_fAllDriveLetterFirst = -1;
    static BOOL s_fRemoteDriveLetterFirst = -1;
    static BOOL s_fNoDriveLetter = -1;

    ASSERT(cchName > 0);
    *pszName = 0; // handle failure case

    // for s_fDriveLetterFirst, see bug 250899, that's a long story.
    if (-1 == s_fRemoteDriveLetterFirst)
    {
        DWORD dw;
        DWORD cb = sizeof(dw);

        s_fRemoteDriveLetterFirst = FALSE;
        s_fAllDriveLetterFirst = FALSE;
        s_fNoDriveLetter = FALSE;

        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), 
            TEXT("ShowDriveLettersFirst"), NULL, &dw, &cb))
        {
            if (1 == dw)
            {
                s_fRemoteDriveLetterFirst = TRUE;
            }
            else
            {
                if (2 == dw)
                {
                    s_fNoDriveLetter = TRUE;
                }
                else
                {
                    if (4 == dw)
                    {
                        s_fAllDriveLetterFirst = TRUE;
                    }
                }
            }
        }
    }

    hres = GetLabel(szDriveLabel, ARRAYSIZE(szDriveLabel));

    if (SUCCEEDED(hres))
    {
        if (s_fNoDriveLetter)
        {
            StrCpyN(pszName, szDriveLabel, cchName);
        }
        else
        {
            BOOL fDriveLetterFirst = ((_IsRemote()) && s_fRemoteDriveLetterFirst) ||
                                        s_fAllDriveLetterFirst;

            // To return something like: "My Drive (c:)", we need a drive letter.
            // Fortunately for us this fct is only called for a drive mounted on a
            // letter (from drive implementation of IShellFolder), for volumes mounted
            // on folders, the folder impl  is called rather than the drive one.
            LPTSTR psz = ShellConstructMessageString(HINST_THISDLL, 
                        MAKEINTRESOURCE(fDriveLetterFirst ? IDS_VOL_FORMAT_LETTER_1ST : IDS_VOL_FORMAT),
                        szDriveLabel, _GetNameFirstCharUCase());
            if (psz)
            {
                StrCpyN(pszName, psz, cchName);
                LocalFree(psz);
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }
    }

    return hres;
}

// { DRIVE_ISCOMPRESSIBLE | DRIVE_COMPRESSED | DRIVE_LFN | DRIVE_SECURITY }
int CMountPoint::GetVolumeFlags()
{
    int iFlags = _GetGVIDriveFlags();

    // Try to avoid getting the attributes
    if (iFlags & DRIVE_ISCOMPRESSIBLE)
    {
        DWORD dwAttrib = -1;

        if (_GetFileAttributes(&dwAttrib))
        {
            if (dwAttrib & FILE_ATTRIBUTE_COMPRESSED)
            {
                iFlags |= DRIVE_COMPRESSED;
            }
        }
    }

    return iFlags;
}

DWORD CMountPoint::GetClusterSize()
{
    DWORD dwSecPerClus, dwBytesPerSec, dwClusters, dwTemp;

    // assume this, avoid div by zero
    DWORD dwRet = 512;

    if (GetDiskFreeSpace(_GetNameForFctCall(), &dwSecPerClus, &dwBytesPerSec, &dwTemp, &dwClusters))
    {
        dwRet = dwSecPerClus * dwBytesPerSec;
    }
    
    return dwRet;   
}

//static
void CMountPoint::GetTypeString(int iDrive, LPTSTR pszType, DWORD cchType)
{
    *pszType = 0;

    CMountPoint* pmtpt = GetMountPoint(iDrive);
    if (pmtpt)
    {
        pmtpt->GetTypeString(pszType, cchType);

        pmtpt->Release();
    }
}

// static
UINT CMountPoint::GetSuperPlainDriveIcon(LPCWSTR pszDrive, UINT uDriveType)
{
    int iIcon;

    switch (uDriveType)
    {
        case DRIVE_REMOVABLE:
        {
            iIcon = II_DRIVEREMOVE;

            if (pszDrive)
            {
                if ((TEXT('a') == *pszDrive) || (TEXT('A') == *pszDrive))
                {
                    iIcon = II_DRIVE35;
                }
                else
                {
                    if ((TEXT('b') == *pszDrive) || (TEXT('B') == *pszDrive))
                    {
                        iIcon = II_DRIVE35;
                    }
                }
            }

            break;
        }
        case DRIVE_FIXED:
        {
            iIcon = II_DRIVEFIXED;
            break;
        }
        case DRIVE_REMOTE:
        {
            iIcon = II_DRIVENET;
            break;
        }
        case DRIVE_CDROM:
        {
            iIcon = II_DRIVECD;
            break;
        }
        case DRIVE_RAMDISK:
        {
            iIcon = II_DRIVERAM;
            break;
        }
        case DRIVE_UNKNOWN:
        case DRIVE_NO_ROOT_DIR:
        default:
        {
            iIcon = -IDI_DRIVEUNKNOWN;
            break;
        }
    }

    return iIcon;
}

///////////////////////////////////////////////////////////////////////////////
// Call Backs
///////////////////////////////////////////////////////////////////////////////
void CMountPoint::_UpdateCommentFromDesktopINI()
{
    WCHAR szCommentFromDesktopINI[MAX_MTPTCOMMENT];

    GetShellClassInfoInfoTip(_GetName(), szCommentFromDesktopINI, ARRAYSIZE(szCommentFromDesktopINI));

    RSSetTextValue(NULL, TEXT("_CommentFromDesktopINI"),
        szCommentFromDesktopINI, REG_OPTION_NON_VOLATILE);
}

///////////////////////////////////////////////////////////////////////////////
// Default Icon/Label
///////////////////////////////////////////////////////////////////////////////
void CMountPoint::_InitLegacyRegIconAndLabel(BOOL fUseAutorunIcon,
    BOOL fUseAutorunLabel)
{
    // No Autorun icon, load the legacy reg icon if any
    if (!fUseAutorunIcon && _IsMountedOnDriveLetter())
    {
        WCHAR szSubKey[MAX_PATH];
        WCHAR szIconLocation[MAX_PATH + 12];

        wnsprintf(szSubKey, ARRAYSIZE(szSubKey),
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DriveIcons\\%c\\DefaultIcon"),
            _GetNameFirstCharUCase());

        szIconLocation[0] = 0;

        if (!RegGetValueString(HKEY_LOCAL_MACHINE, szSubKey, NULL, szIconLocation,
            ARRAYSIZE(szIconLocation) * sizeof(TCHAR)))
        {
            // Let's try second location
            wnsprintf(szSubKey, ARRAYSIZE(szSubKey),
                TEXT("Applications\\Explorer.exe\\Drives\\%c\\DefaultIcon"),
                _GetNameFirstCharUCase());

            RegGetValueString(HKEY_CLASSES_ROOT, szSubKey, NULL, szIconLocation,
                ARRAYSIZE(szIconLocation) * sizeof(TCHAR));
        }

        if (szIconLocation[0])
        {
            AssertMsg(!_pszLegacyRegIcon, TEXT("_InitLegacyRegIconAndLabel: called twice"));
            _pszLegacyRegIcon = StrDup(szIconLocation);
        }
    }

    if (!fUseAutorunLabel && _IsMountedOnDriveLetter())
    {
        WCHAR szSubKey[MAX_PATH];
        WCHAR szLabel[MAX_LABEL];

        wnsprintf(szSubKey, ARRAYSIZE(szSubKey),
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DriveIcons\\%c\\DefaultLabel"),
            _GetNameFirstCharUCase());

        szLabel[0] = 0;

        if (!RegGetValueString(HKEY_LOCAL_MACHINE, szSubKey, NULL, szLabel,
            ARRAYSIZE(szLabel) * sizeof(TCHAR)))
        {
            // Let's try second location
            wnsprintf(szSubKey, ARRAYSIZE(szSubKey),
                TEXT("Applications\\Explorer.exe\\Drives\\%c\\DefaultLabel"),
                _GetNameFirstCharUCase());

            RegGetValueString(HKEY_CLASSES_ROOT, szSubKey, NULL, szLabel,
                ARRAYSIZE(szLabel) * sizeof(TCHAR));
        }

        if (szLabel[0])
        {
            AssertMsg(!_pszLegacyRegLabel, TEXT("_InitLegacyRegIconAndLabel: called twice"));
            _pszLegacyRegLabel = StrDup(szLabel);
        }
    }
}

BOOL CMountPoint::_GetLegacyRegLabel(LPTSTR pszLabel, DWORD cchLabel)
{
    BOOL fRet;
    if (_pszLegacyRegLabel)
    {
        StrCpyN(pszLabel, _pszLegacyRegLabel, cchLabel);
        fRet = TRUE;
    }
    else
    {
        *pszLabel = 0;
        fRet = FALSE;
    }

    return fRet;
}

LPCTSTR CMountPoint::_GetNameForFctCall()
{
    return _szName;
}

// the first character in the name, and convert it to upper case
// the first character is generally the drive letter
TCHAR CMountPoint::_GetNameFirstCharUCase()
{
    return (TCHAR) CharUpper((LPTSTR) _szName[0]);
}

LPTSTR CMountPoint::_GetNameFirstXChar(LPTSTR pszBuffer, int c)
{
    StrCpyN(pszBuffer, _szName, c);

    return pszBuffer;
}

LPCTSTR CMountPoint::_GetNameDebug()
{
    return _szName;
}

LPCTSTR CMountPoint::_GetName()
{
    return _szName;
}

///////////////////////////////////////////////////////////////////////////////
// Misc
///////////////////////////////////////////////////////////////////////////////

//
// External API for use by non-CPP modules.
//
HRESULT MountPoint_RegisterChangeNotifyAlias(int iDrive)
{    
    HRESULT hr = E_FAIL;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive);
    if (pMtPt)
    {
        pMtPt->ChangeNotifyRegisterAlias();
        pMtPt->Release();
        hr = NOERROR;
    }
    return hr;
}    

HRESULT CMountPoint::GetComment(LPTSTR pszComment, DWORD cchComment)
{
    RSGetTextValue(NULL, TEXT("_CommentFromDesktopINI"), pszComment, &cchComment);
    return *pszComment ? S_OK : E_FAIL;
}

BOOL CMountPoint::GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName)
{
    return _GetFileSystemName(pszFileSysName, cchFileSysName);
}

BOOL CMountPoint::_GetLabelFromReg(LPWSTR psz, DWORD cch)
{
    *psz = 0;

    return (RSGetTextValue(NULL, TEXT("_LabelFromReg"), psz, &cch) && *psz);
}

BOOL CMountPoint::_GetLabelFromDesktopINI(LPWSTR psz, DWORD cch)
{
    *psz = 0;

    return (RSGetTextValue(NULL, TEXT("_LabelFromDesktopINI"), psz, &cch) && *psz);
}

DWORD CMountPoint::GetAttributes()
{
    DWORD dwAttrib;

    _GetFileAttributes(&dwAttrib);
    
    return dwAttrib;
}

CMountPoint::CMountPoint() : _cRef(1)
{
}

ULONG CMountPoint::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CMountPoint::Release()
{
    if (InterlockedDecrement(&_cRef) > 0)
        return _cRef;

    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mtptis2.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "mtpt.h"

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMountPoint::IsCDROM()
{
    return _IsCDROM();
}

BOOL CMountPoint::IsFixedDisk()
{
    return _IsFixedDisk();
}

BOOL CMountPoint::IsStrictRemovable()
{
    return _IsStrictRemovable();
}

BOOL CMountPoint::IsAutoRun()
{
    return _IsAutorun();
}

BOOL CMountPoint::IsRemote()
{
    return _IsRemote();
}

BOOL CMountPoint::IsFloppy()
{
    return _IsFloppy();
}

BOOL CMountPoint::IsDVD()
{
    return _IsDVD();
}

BOOL CMountPoint::IsAudioCD()
{
    return _IsAudioCD();
}

BOOL CMountPoint::IsAudioCDNoData()
{
    return _IsAudioCDNoData();
}

BOOL CMountPoint::IsRAMDisk()
{
    return (DRIVE_RAMDISK == GetDriveType(_szName));
}

BOOL CMountPoint::IsDVDRAMMedia()
{
    return _IsDVDRAMMedia();
}

BOOL CMountPoint::IsFormattable()
{
    return _IsFormattable();
}

BOOL CMountPoint::IsCompressible()
{
    return ((DRIVE_ISCOMPRESSIBLE & _GetGVIDriveFlags()) ? TRUE : FALSE);
}

BOOL CMountPoint::IsRemovableDevice()
{
    return _IsRemovableDevice();
}

BOOL CMountPoint::IsCompressed()
{
    BOOL fRet = FALSE;

    if (!_IsFloppy35() && !_IsFloppy525() && !_IsCDROM())
    {
        DWORD dwAttrib;

        TraceMsg(TF_MOUNTPOINT, "CMountPoint::IsCompressed: for '%s'", _GetName());

        if (_GetFileAttributes(&dwAttrib))
        {
            if (dwAttrib & FILE_ATTRIBUTE_COMPRESSED)
            {
                fRet = TRUE;
            }
        }
    }

    return (fRet ? TRUE : FALSE);
}

BOOL CMountPoint::IsSupportingSparseFile()
{
    BOOL fRet = FALSE;
    DWORD dwFlags;
    
    if (_GetFileSystemFlags(&dwFlags))
    {
        fRet = (FILE_SUPPORTS_SPARSE_FILES & dwFlags) ? TRUE : FALSE;
    }

    return fRet;
}

BOOL CMountPoint::IsContentIndexed()
{
    BOOL fRet = FALSE;
    DWORD dwAttrib;

    TraceMsg(TF_MOUNTPOINT, "CMountPoint::IsContentIndexed: for '%s'", _GetName());

    if (_GetFileAttributes(&dwAttrib))
    {
        fRet = !(FILE_ATTRIBUTE_NOT_CONTENT_INDEXED & dwAttrib);
    }

    return (fRet ? TRUE : FALSE);
}

BOOL CMountPoint::IsNTFS()
{
    BOOL fRet = FALSE;
    WCHAR szFileSysName[MAX_FILESYSNAME];

    if (_GetFileSystemName(szFileSysName, ARRAYSIZE(szFileSysName)))
    {
        fRet = BOOLFROMPTR(StrStr(TEXT("NTFS"), szFileSysName));
    }

    return fRet;
}

BOOL CMountPoint::_IsLFN()
{
    int iFlags = GetVolumeFlags();

    return !!(iFlags & DRIVE_LFN);
}

BOOL CMountPoint::_IsSecure()
{
    int iFlags = GetVolumeFlags();

    return !!(iFlags & DRIVE_SECURITY);
}

BOOL CMountPoint::_IsShellOpen()
{
    int iDriveFlags = GetDriveFlags();

    return !!(DRIVE_SHELLOPEN & iDriveFlags);
}

BOOL CMountPoint::_IsAutoOpen()
{
    int iDriveFlags = GetDriveFlags();

    return !!(DRIVE_AUTOOPEN & iDriveFlags);
}
/////////////////////////////////////////////////////////////////////////////
// static IsXXX fct
/////////////////////////////////////////////////////////////////////////////
STDAPI_(BOOL) CMtPt_IsSlow(int iDrive)
{
    BOOL fRet = FALSE;
    CMountPoint* pmtpt = CMountPoint::GetMountPoint(iDrive, FALSE);

    if (pmtpt)
    {
        fRet = pmtpt->_IsSlow();

        pmtpt->Release();
    }

    return fRet;
}

STDAPI_(BOOL) CMtPt_IsLFN(int iDrive)
{
    BOOL fRet = FALSE;
    CMountPoint* pmtpt = CMountPoint::GetMountPoint(iDrive, FALSE);

    if (pmtpt)
    {
        fRet = pmtpt->_IsLFN();

        pmtpt->Release();
    }

    return fRet;
}

STDAPI_(BOOL) CMtPt_IsSecure(int iDrive)
{
    BOOL fRet = FALSE;
    CMountPoint* pmtpt = CMountPoint::GetMountPoint(iDrive, FALSE);

    if (pmtpt)
    {
        fRet = pmtpt->_IsSecure();

        pmtpt->Release();
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mtpt.h ===
#ifndef _MTPT_H
#define _MTPT_H

#include "regsprtb.h"
#include "hwcmmn.h"
#include "dpa.h"

#include <dbt.h>

#define REGSTR_MTPT_ROOTKEY2 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MountPoints2")

/////////////////////////////////////////////////////////////////////////////
// Assumptions
/////////////////////////////////////////////////////////////////////////////
// 1- Floppies (3.5" and 5.25") are always FAT
// 2- FAT does not support compression
// 3- DRIVE_CDROM == CDFS or UDF for File system
// 4- CDFS or UDF does not support compression
//
/////////////////////////////////////////////////////////////////////////////

#define DT_FIXEDDISK                     0x00000001
#define DT_FLOPPY35                      0x00000004
#define DT_FLOPPY525                     0x00000008
#define DT_CDROM                         0x00000020
#define DT_CDR                           0x00000040
#define DT_CDRW                          0x00000080
#define DT_DVDROM                        0x00000100
#define DT_DVDRAM                        0x00000200
#define DT_DVDR                          0x00000400
#define DT_DVDRW                         0x00000800
#define DT_REMOVABLEDISK                 0x00001000
#define DT_REMOTE                        0x00002000

#define DT_ANYTYPE                       0x0000FFFF

#define DT_ANYFLOPPYDRIVES               (   DT_FLOPPY35 | \
                                                        DT_FLOPPY525 )

#define DT_ANYCDDRIVES                   (   DT_CDROM | \
                                                        DT_CDR | \
                                                        DT_CDRW | \
                                                        DT_DVDROM | \
                                                        DT_DVDRAM | \
                                                        DT_DVDR | \
                                                        DT_DVDRW )

#define DT_ANYDVDDRIVES                  (   DT_DVDROM | \
                                                        DT_DVDRAM | \
                                                        DT_DVDR | \
                                                        DT_DVDRW )

#define DT_ANYWRITABLECDDRIVES           (   DT_CDR | \
                                                        DT_CDRW )

#define DT_ANYWRITABLEDVDDRIVES          (   DT_DVDR | \
                                                        DT_DVDRW )

#define DT_ANYREMOVABLEMEDIADRIVES       (   DT_ANYCDDRIVES | \
                                                        DT_ANYFLOPPYDRIVES | \
                                                        DT_REMOVABLEDISK )

#define DT_ANYLOCALDRIVES                (   DT_ANYREMOVABLEMEDIADRIVES | \
                                                        DT_FIXEDDISK )

#define AUTORUNFLAG_MEDIAARRIVAL            0x00000001
#define AUTORUNFLAG_MTPTARRIVAL             0x00000002
#define AUTORUNFLAG_MENUINVOKED             0x00000004

// put in shell32\shellprv.h
#define TF_MOUNTPOINT       0x08000000

#define MAX_DISPLAYNAME         MAX_PATH
#define MAX_MTPTCOMMENT         MAX_PATH

#define OFFSET_GUIDWITHINVOLUMEGUID     (sizeof("\\\\?\\Volume") - 1)

class CMountPoint;
class CMtPtLocal;
class CMtPtRemote;

class CCriticalSection : CRITICAL_SECTION
{
public:
    void Init()
    {
        InitializeCriticalSection(this);
        _fInited = TRUE;

#ifdef DEBUG
        _dwThreadIDThatShouldNotTryToEnter = 0;
        _fFakeEntered = FALSE;
#endif
    }
    void Enter()
    {
#ifdef DEBUG
        if (_dwThreadIDThatShouldNotTryToEnter)
        {
            ASSERT(_dwThreadIDThatShouldNotTryToEnter != GetCurrentThreadId());
        }
#endif

        if (!_fShuttingDown)
        {
            ASSERT(_fInited);
            EnterCriticalSection(this);
        }
    }
    void Leave()
    {
        if (!_fShuttingDown)
        {
            ASSERT(_fInited);
            LeaveCriticalSection(this);
        }
    }

    void Delete()
    {
        if (_fInited)
        {
            _fInited = FALSE;
            DeleteCriticalSection(this);
        }
    }

    BOOL IsInitialized()
    {
        return _fInited;
    }

    BOOL _fInited;
    BOOL _fShuttingDown;
#ifdef DEBUG
    BOOL IsInside()
    {
        ASSERT(_fInited);

        return _fFakeEntered || (OwningThread == UlongToHandle(GetCurrentThreadId()));
    }

    void FakeEnter()
    {
        ASSERT(_fInited);
        // See the comment in CMountPoint::_InitLocalDriveHelper where we use this fct.
        // Basically the cirtiical section should already be entered.  This will not
        // verify that it's entered by the thread that launched us, but it will verify
        // that at least one thread entered it.
        ASSERT(OwningThread);
        
        _fFakeEntered = TRUE;
    }

    void FakeLeave()
    {
        ASSERT(_fInited);
        ASSERT(OwningThread);
        
        _fFakeEntered = FALSE;
    }

    void SetThreadIDToCheckForEntrance(DWORD dwThreadID)
    {
        _dwThreadIDThatShouldNotTryToEnter = dwThreadID;
    }

    DWORD _dwThreadIDThatShouldNotTryToEnter;
    BOOL  _fFakeEntered;
#endif
};

typedef enum
{
    APS_RESET       = 0,
    APS_DID_SNIFF   = 0x0001,
//    APS_
} APSTATEF;

typedef enum
{
    CTI_PIX = 0,
    CTI_MUSIC,
    CTI_VIDEO,
    CTI_MIXCONTENT,
    _CTI_TOTAL_COUNT_
} CONTENTTYPE_INDEX;

class CAutoPlayParams
{
public:
    CAutoPlayParams(LPCWSTR pszDrive, CMountPoint* pMtPt, DWORD dwAutorunFlags);
    ~CAutoPlayParams() { ATOMICRELEASE(_pdo); }

    PCWSTR Drive() { return _pszDrive; }
    CMountPoint *MountPoint() { return _pmtpt; }
    CMtPtLocal *MountPointLocal() { return _pmtptl; }
    DWORD DriveType() { return _dwDriveType; }
    HRESULT DataObject(IDataObject **ppdo) 
    { 
        HRESULT hr = _InitObjects(NULL);
        *ppdo = _pdo; 
        if (SUCCEEDED(hr)) 
            _pdo->AddRef();
        return hr;
    }

    BOOL IsContentTypePresent(DWORD dwContentType);
    DWORD ContentType();
    void ForceSniff();

protected:  // methods
    BOOL _ShouldSniffDrive(BOOL fCheckHandlerDefaults);
    void _TrySniff();
    HRESULT _Sniff(DWORD *pdwFound);
    HRESULT _AddWalkToDataObject(INamespaceWalk* pnsw);
    HRESULT _InitObjects(IShellFolder **ppsf);
    
protected:  //  members
    DWORD _state; // APSTATEF
    DWORD _dwDriveType;
    DWORD _dwContentType;
    DWORD _dwAutorunFlags;
    PCWSTR _pszDrive;
    CMountPoint *_pmtpt;
    CMtPtLocal* _pmtptl;
    IDataObject *_pdo;

public:
    BOOL _fCheckAlwaysDoThisCheckBox;
};

#define AUTORUN_CONDITION_FCT(a) static BOOL (a)(HWND hwndForeground, CAutoPlayParams *papp);

class CMountPoint : public CRegSupport
{
///////////////////////////////////////////////////////////////////////////////
// Management (mtptmgmt.cpp)
///////////////////////////////////////////////////////////////////////////////
public:
    static CMountPoint* GetMountPoint(LPCTSTR pszMountPoint,
        BOOL fCreateNew = TRUE);
    static CMountPoint* GetSimulatedMountPointFromVolumeGuid(
        LPCTSTR pszVolumeGuid );
    static CMountPoint* GetMountPoint(int iDrive, BOOL fCreateNew = TRUE,
        BOOL fOKToHitNet = TRUE);

    static DWORD GetDrivesMask();

    static void HandleMountPointNetEvent(LPCWSTR pszDrive, BOOL fArrival);
    static DWORD WINAPI HandleMountPointLocalEventThreadProc(void* pv);
    static void HandleMountPointLocalEvent(LPCWSTR pszDrive, BOOL fArrival,
        BOOL fMediaEvent);
    static void OnNetShareArrival(LPCWSTR pszDrive);
    static void OnNetShareRemoval(LPCWSTR pszDrive);
    static void OnMediaArrival(LPCWSTR pszDrive);
    static void OnMountPointArrival(LPCWSTR pszDrive);
    static void OnMediaRemoval(LPCWSTR pszDrive);
    static void OnMountPointRemoval(LPCWSTR pszDrive);

    static void FinalCleanUp();
    static void Initialize();

    static void NotifyUnavailableNetDriveGone(LPCWSTR pszMountPoint);
    static void NotifyReconnectedNetDrive(LPCWSTR pszMountPoint);

///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
public:
    HRESULT GetDisplayName(LPTSTR pszName, DWORD cchName);
    HRESULT GetComment(LPTSTR pszComment, DWORD cchComment);
    virtual HRESULT GetLabel(LPTSTR pszLabel, DWORD cchLabel) = 0;
    virtual HRESULT GetLabelNoFancy(LPTSTR pszLabel, DWORD cchLabel) = 0;
    virtual HRESULT SetLabel(HWND hwnd, LPCTSTR pszLabel) = 0;
    virtual HRESULT SetDriveLabel(HWND hwnd, LPCTSTR pszLabel)
    { return SetLabel(hwnd, pszLabel); }

    virtual HRESULT GetRemotePath(LPWSTR pszPath, DWORD cchPath) = 0;
    BOOL GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName);
    virtual void GetTypeString(LPTSTR pszType, DWORD cchType) = 0;
    DWORD GetAttributes();
    DWORD GetClusterSize();
    virtual int GetDriveFlags() = 0;
    int GetVolumeFlags();

    virtual UINT GetIcon(LPTSTR pszModule, DWORD cchModule) = 0;
    virtual HRESULT GetAssocSystemElement(IAssociationElement **ppae) = 0;
    virtual DWORD GetShellDescriptionID() = 0;

    virtual HKEY GetRegKey() = 0;

    BOOL IsStrictRemovable();
    BOOL IsFixedDisk();
    BOOL IsRemote();
    BOOL IsCDROM();
    BOOL IsAudioCD();
    BOOL IsAudioCDNoData();
    BOOL IsAutoRun();
    BOOL IsDVD();
    BOOL IsRAMDisk();
    BOOL IsDVDRAMMedia();

    BOOL IsFormattable();
    BOOL IsNTFS();
    BOOL IsCompressible();
    BOOL IsCompressed();
    BOOL IsSupportingSparseFile();
    BOOL IsContentIndexed();
    BOOL IsSlow();
    BOOL IsFloppy();
    BOOL IsRemovableDevice();

    // Don't call this on net drive for nothing
    virtual BOOL IsFormatted() = 0;

    virtual BOOL IsAutoRunDrive() { return FALSE; }
    virtual BOOL IsEjectable() { return FALSE; }
    virtual BOOL HasMedia() { return TRUE; }

    void SetAutorunStatus(BYTE* rgb, DWORD cbSize);

    // Returns E_FAIL if not applicable
    // Returns S_FALSE if cannot determine capabilities for drive
    virtual HRESULT GetCDInfo(DWORD* pdwDriveCapabilities, DWORD* pdwMediaCapabilities)
    { return E_FAIL; }

    // remote only
    virtual BOOL IsUnavailableNetDrive() { return FALSE; }
    virtual BOOL IsDisconnectedNetDrive() { return FALSE; }
    // local only
    virtual HRESULT Eject(HWND hwnd) { return E_FAIL; }

    virtual HRESULT ChangeNotifyRegisterAlias(void) = 0;
    virtual void StoreIconForUpdateImage(int iImage) { }

    static void HandleWMDeviceChange(ULONG_PTR code, DEV_BROADCAST_HDR *pbh);
    static void GetTypeString(int iDrive, LPTSTR pszType, DWORD cchType);

    static void DoAutorunPrompt(WPARAM iDrive);
    static void DoAutorun(LPCWSTR pszDrive, DWORD dwAutorunFlags);
    static void _DoAutorunHelper(CAutoPlayParams *papp);
    static HRESULT _Sniff(LPCWSTR pszDeviceIDVolume, LPCWSTR pszDrive, DWORD *pdwFound);

    static void WantAutorunUI(LPCWSTR pszDrive);
    static BOOL _AppAllowsAutoRun(HWND hwndApp, CMountPoint* pmtpt);
    static HRESULT _QueryRunningObject(CMountPoint* pmtpt, DWORD dwAutorunContentType, BOOL* pfAllow);

    AUTORUN_CONDITION_FCT(_acShiftKeyDown);
    AUTORUN_CONDITION_FCT(_acCurrentDesktopIsActiveConsole);
    AUTORUN_CONDITION_FCT(_acDriveIsMountedOnDriveLetter);
    AUTORUN_CONDITION_FCT(_acDriveIsRestricted);
    AUTORUN_CONDITION_FCT(_acHasAutorunCommand);
    AUTORUN_CONDITION_FCT(_acHasUseAutoPLAY);
    AUTORUN_CONDITION_FCT(_acForegroundAppAllowsAutorun);
    AUTORUN_CONDITION_FCT(_acQueryCancelAutoplayAllowsAutorun);
    AUTORUN_CONDITION_FCT(_acUserHasSelectedApplication);
    AUTORUN_CONDITION_FCT(_acShellIsForegroundApp);
    AUTORUN_CONDITION_FCT(_acOSIsServer);
    AUTORUN_CONDITION_FCT(_acIsDockedLaptop);
    AUTORUN_CONDITION_FCT(_acDriveIsFormatted);
    AUTORUN_CONDITION_FCT(_acShellExecuteDriveAutorunINF);
    AUTORUN_CONDITION_FCT(_acAlwaysReturnsTRUE);
    AUTORUN_CONDITION_FCT(_acPromptUser);
    AUTORUN_CONDITION_FCT(_acIsMixedContent);
    AUTORUN_CONDITION_FCT(_acExecuteAutoplayDefault);
    AUTORUN_CONDITION_FCT(_acWasjustDocked);
    AUTORUN_CONDITION_FCT(_acShouldSniff);
    AUTORUN_CONDITION_FCT(_acAddAutoplayVerb);
    AUTORUN_CONDITION_FCT(_acDirectXAppRunningFullScreen);

    static BOOL _ExecuteHelper(LPCWSTR pszHandler, LPCWSTR pszContentTypeHandler, 
        CAutoPlayParams *papp, DWORD dwMtPtContentType);

    static UINT GetSuperPlainDriveIcon(LPCWSTR pszDrive, UINT uDriveType);

    static BOOL _CanRegister();

    // returns DT_* defined above
    virtual DWORD _GetMTPTDriveType() = 0;
    // returns CT_* defined above
    virtual DWORD _GetMTPTContentType() = 0;

///////////////////////////////////////////////////////////////////////////////
// 
///////////////////////////////////////////////////////////////////////////////
protected:
    virtual BOOL _IsFloppy() { return FALSE; }
    virtual BOOL _IsFloppy35() { return FALSE; }
    virtual BOOL _IsFloppy525() { return FALSE; }
    virtual BOOL _IsCDROM() { return FALSE; }
    virtual BOOL _IsStrictRemovable() { return FALSE; }
    virtual BOOL _IsAutorun() = 0;
    virtual BOOL _IsFormattable()  { return FALSE; }
    virtual BOOL _IsAudioCD() { return FALSE; }
    virtual BOOL _IsAudioCDNoData() { return FALSE; }
    virtual BOOL _IsDVD() { return FALSE; }
    virtual BOOL _IsFixedDisk() { return FALSE; }
    virtual BOOL _IsDVDRAMMedia() { return FALSE; }
    virtual BOOL _IsRemovableDevice() { return FALSE; }
    BOOL _IsAutoRunDrive();
    BOOL _IsAutoOpen();
    BOOL _IsShellOpen();

    BOOL _ProcessAutoRunFile();
    HRESULT _CopyInvokeVerbKey(LPCWSTR pszProgID, LPCWSTR pszVerb);
    HRESULT _AddAutoplayVerb();

    static BOOL _IsDriveLetter(LPCWSTR pszDrive);

    // Helpers
    void _QualifyCommandToDrive(LPTSTR pszCommand);

    virtual BOOL _NeedToRefresh() { return FALSE; }

public:
    // Should be accessed only by CMtPt_... fcts
    BOOL _IsLFN();
    BOOL _IsSecure();
    virtual BOOL _IsSlow() { return FALSE; }

private:

///////////////////////////////////////////////////////////////////////////////
// 
///////////////////////////////////////////////////////////////////////////////
protected:
    virtual BOOL _IsAudioDisc() { return FALSE; }
    virtual BOOL _IsRemote() { return FALSE; }

    BOOL _GetLegacyRegLabel(LPTSTR pszLabel, DWORD cchLabel);

    void _UpdateCommentFromDesktopINI();
    void _InitLegacyRegIconAndLabel(BOOL fUseAutorunIcon, BOOL fUseAutorunLabel);

    virtual BOOL _IsMountedOnDriveLetter() = 0;

///////////////////////////////////////////////////////////////////////////////
// Management (mtptmgmt.cpp)
///////////////////////////////////////////////////////////////////////////////
public:
    //      Drive Letter (DL)
    static CMountPoint* _GetMountPointDL(int iDrive, BOOL fCreateNew);

    //      Mounted On Folder (MOF)
    static CMtPtLocal* _GetStoredMtPtMOF(LPTSTR pszPathWithBackslash);
    static BOOL _StoreMtPtMOF(CMtPtLocal* pMtPt);
    static CMtPtLocal* _GetStoredMtPtMOFFromHDPA(LPTSTR pszPathWithBackslash);

protected:
    //      Helpers
    static BOOL _IsNetDriveLazyLoadNetDLLs(int iDrive);
    static HRESULT _InitLocalDrives();
    static HRESULT _InitNetDrives();
    static HRESULT _InitNetDrivesHelper(DWORD dwScope);
    static HRESULT _ReInitNetDrives();

    static HRESULT _EnumVolumes(IHardwareDevices* pihwdevs);
    static HRESULT _EnumMountPoints(IHardwareDevices* pihwdevs);

    static HRESULT _DeleteVolumeInfo();
    static HRESULT _DeleteLocalMtPts();
    static HRESULT _GetMountPointsForVolume(LPCWSTR pszDeviceIDVolume,
        HDPA hdpaMtPts);
    static HRESULT _MediaArrivalRemovalHelper(LPCWSTR pszDeviceIDVolume,
        BOOL fArrived);

    static HRESULT _RemoveLocalMountPoint(LPCWSTR pszMountPoint);
    static HRESULT _RemoveNetMountPoint(LPCWSTR pszMountPoint);

    static BOOL _LocalDriveIsCoveredByNetDrive(LPCWSTR pszDriveLetter);

    static BOOL _CheckLocalMtPtsMOF(LPCWSTR pszMountPoint);

public:
    static BOOL _StripToClosestMountPoint(LPCTSTR pszSource, LPTSTR pszDest,
        DWORD cchDest);

public:
    static HRESULT _CleanupLocalMtPtInfo();

    static HRESULT _InitLocalDriveHelper();

///////////////////////////////////////////////////////////////////////////////
// Miscellaneous helpers
///////////////////////////////////////////////////////////////////////////////
protected:
    virtual LPCTSTR _GetNameForFctCall();

    virtual BOOL _GetFileAttributes(DWORD* pdwAttrib) = 0;
    virtual BOOL _GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName) = 0;
    virtual BOOL _GetGVILabelOrMixedCaseFromReg(LPTSTR pszLabel, DWORD cchLabel) = 0;
    virtual BOOL _GetGVILabel(LPTSTR pszLabel, DWORD cchLabel) = 0;
    virtual BOOL _GetSerialNumber(DWORD* pdwSerialNumber) = 0;
    virtual BOOL _GetFileSystemFlags(DWORD* pdwFlags) = 0;
    virtual int _GetGVIDriveFlags() = 0;
    virtual int _GetDriveType() = 0;
    virtual DWORD _GetAutorunContentType() = 0;

    TCHAR _GetNameFirstCharUCase();
    LPTSTR _GetNameFirstXChar(LPTSTR pszBuffer, int c);
    LPCTSTR _GetName();
    LPCTSTR _GetNameDebug();

    BOOL _GetLabelFromReg(LPWSTR psz, DWORD cch);
    BOOL _GetLabelFromDesktopINI(LPWSTR psz, DWORD cch);

    CMountPoint();

public:
    ULONG AddRef();
    ULONG Release();

///////////////////////////////////////////////////////////////////////////////
// 
///////////////////////////////////////////////////////////////////////////////
    static HRESULT _VolumeAddedOrUpdated(BOOL fAdded,
        VOLUMEINFO2* pvolinfo2);
    static HRESULT _VolumeRemoved(LPCWSTR pszDeviceIDVolume);
    static HRESULT _VolumeMountingEvent(LPCWSTR pszDeviceIDVolume,
        DWORD dwEvent);
    static HRESULT _MountPointAdded(LPCWSTR pszMountPoint,
        LPCWSTR pszDeviceIDVolume);
    static HRESULT _MountPointRemoved(LPCWSTR pszMountPoint);
    static HRESULT _DeviceAdded(LPCWSTR pszDeviceID, GUID guidDeviceID);
    static HRESULT _DeviceUpdated(LPCWSTR pszDeviceID);
    static HRESULT _DeviceRemoved(LPCWSTR pszDeviceID);

    static HRESULT RegisterForHardwareNotifications();
    static HRESULT HandleDeviceQueryRemove();
    static DWORD WINAPI _RegisterThreadProc(void* pv);
    static void CALLBACK _EventAPCProc(ULONG_PTR ulpParam);
    static DWORD CALLBACK _EventProc(void* pv);

///////////////////////////////////////////////////////////////////////////////
// Data
///////////////////////////////////////////////////////////////////////////////
protected:
    // Only mtpt, volume, drive real data shared by derived objs
    WCHAR                           _szName[MAX_PATH];
    LPWSTR                          _pszLegacyRegIcon;
    LPWSTR                          _pszLegacyRegLabel;

    BOOL                            _fAutorunFileProcessed;

    // Static, non-mtpt related stuff
    LONG                            _cRef;
    static CCriticalSection         _csLocalMtPtHDPA;
    static CCriticalSection         _csDL;
    
    static HDPA                     _hdpaMountPoints;
    static HDPA                     _hdpaVolumes;
    static HDPA                     _hdpaShares;

    static DWORD                    _dwAdviseToken;
    
    // optimization we have an array for the volumes mounted on drive letters
    static CMtPtLocal*              _rgMtPtDriveLetterLocal[];
    static CMtPtRemote*             _rgMtPtDriveLetterNet[];
    
    static BOOL                     _fNetDrivesInited;
    static BOOL                     _fLocalDrivesInited;
    static BOOL                     _fNoVolLocalDrivesInited;
    static DWORD                    _dwTickCountTriedAndFailed;

    // Constructor/destructor of _hwdevcb will NOT get called
    static BOOL                     _fShuttingDown;

    // Watch out!  No constructor nor destructor called on the next members
    static CRegSupport              _rsMtPtsLocalDL;
    static CRegSupport              _rsMtPtsLocalMOF;
    static CRegSupport              _rsMtPtsRemote;

    static DWORD                    _dwRemoteDriveAutorun;
    static HANDLE                   _hThreadSCN;

    static DWORD                    _dwRememberedNetDrivesMask;

public:
    static BOOL                     _fCanRegisterWithShellService;
};

STDAPI MountPoint_RegisterChangeNotifyAlias(int iDrive);

BOOL _Shell32LoadedInDesktop();

struct TWODWORDS
{
    DWORD dwLeft;
    DWORD dwRight;
};

DWORD _DoDWORDMapping(DWORD dwLeft, const TWODWORDS* rgtwodword, DWORD ctwodword, BOOL fORed);

class PNPNOTIFENTRY : public CRefCounted
{
public:
    HDEVNOTIFY  hdevnotify;
    BOOL        fStopSniffing;
    HANDLE      hThread;
};

// everything is only the things we care about
#define DRIVEHAS_EVERYTHING (CT_AUTOPLAYMUSIC | CT_AUTOPLAYPIX | CT_AUTOPLAYMOVIE)

class CSniffDrive : public INamespaceWalkCB
{
public:
    CSniffDrive();
    ~CSniffDrive();
    
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef()
    {
        // stack created
        return 3;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        // stack created
        return 2;
    }

    // INamespaceWalkCB
    STDMETHODIMP FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel);

    DWORD Found() {return _dwFound;}

    // CSniffDrive
    static HRESULT Init(HANDLE hThreadSCN);
    static HRESULT InitNotifyWindow(HWND hwnd);
    static HRESULT CleanUp();
    static HRESULT HandleNotif(HDEVNOTIFY hdevnotify);
    static void CALLBACK _RegisterForNotifsHelper(ULONG_PTR ul);
    static void CALLBACK _UnregisterForNotifsHelper(ULONG_PTR ul);

    HRESULT RegisterForNotifs(LPCWSTR pszDeviceIDVolume);
    HRESULT UnregisterForNotifs();

private:  // methods
    BOOL _FoundEverything();
        
private:  // members
    DWORD                       _dwFound;
    PNPNOTIFENTRY*              _pne;

public:
    static HANDLE               _hThreadSCN;
    static CDPA<PNPNOTIFENTRY>  _dpaNotifs;
    static HWND                 _hwndNotify;
};

#endif //_MTPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mtptl.h ===
#include "mtpt.h"

class CVolume;

class CMtPtLocal : public CMountPoint
{
///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
public:
    CMtPtLocal();
    ~CMtPtLocal();

    HRESULT GetMountPointName(LPWSTR pszMountPoint, DWORD cchMountPoint);
    HRESULT Eject(HWND hwnd);

    BOOL IsEjectable();
    BOOL HasMedia();

    BOOL IsFormatted();

    HRESULT GetCDInfo(DWORD* pdwDriveCapabilities, DWORD* pdwMediaCapabilities);

    HRESULT GetLabel(LPTSTR pszLabel, DWORD cchLabel);
    HRESULT GetLabelNoFancy(LPTSTR pszLabel, DWORD cchLabel);
    HRESULT SetLabel(HWND hwnd, LPCTSTR pszLabel);
    HRESULT SetDriveLabel(HWND hwnd, LPCTSTR pszLabel);
    HRESULT ChangeNotifyRegisterAlias(void)
        { /* no-op */ return NOERROR; }

    int GetDriveFlags();
    HRESULT GetRemotePath(LPWSTR pszPath, DWORD cchPath) { return E_NOTIMPL; }
    void GetTypeString(LPTSTR pszType, DWORD cchType);

    void StoreIconForUpdateImage(int iImage);

    UINT GetIcon(LPTSTR pszModule, DWORD cchModule);
    HRESULT GetAssocSystemElement(IAssociationElement **ppae);
    DWORD GetShellDescriptionID();

    HKEY GetRegKey();

    static BOOL IsVolume(LPCWSTR pszDeviceID);
    static HRESULT GetMountPointFromDeviceID(LPCWSTR pszDeviceID,
        LPWSTR pszMountPoint, DWORD cchMountPoint);

///////////////////////////////////////////////////////////////////////////////
// Miscellaneous helpers
///////////////////////////////////////////////////////////////////////////////
public: // should be used in mtptmgmt2.cpp only
    BOOL _IsMiniMtPt();
    BOOL _NeedToRefresh();

public: // should be used in mtptarun2.cpp only (when used outside of CMtPtLocal)
    BOOL _IsMediaPresent();
    BOOL _CanUseVolume();

private:
    HRESULT _InitWithVolume(LPCWSTR pszMtPt, CVolume* pvol);
    HRESULT _Init(LPCWSTR pszMtPt);

    LPCTSTR _GetNameForFctCall();

    BOOL _IsFloppy();
    BOOL _IsFloppy35();
    BOOL _IsFloppy525();
    BOOL _IsCDROM();
    // real removable, excludes floppies
    BOOL _IsStrictRemovable();
    BOOL _IsFixedDisk();

    BOOL _IsFormattable();
    BOOL _IsAudioCD();
    BOOL _IsAudioCDNoData();
    BOOL _IsDVD();
    BOOL _IsWritableDisc();
    BOOL _IsRemovableDevice();

    BOOL _IsAutorun();
    BOOL _IsDVDDisc();
    BOOL _IsDVDRAMMedia();
    BOOL _IsAudioDisc();

    BOOL _ForceCheckMediaPresent();
    BOOL _IsFormatted();
    BOOL _IsReadOnly();

    // returns DT_* defined above
    DWORD _GetMTPTDriveType();
    // returns CT_* defined above
    DWORD _GetMTPTContentType();

    BOOL _GetFileAttributes(DWORD* pdwAttrib);
    BOOL _GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName);
    BOOL _GetGVILabelOrMixedCaseFromReg(LPTSTR pszLabel, DWORD cchLabel);
    BOOL _GetGVILabel(LPTSTR pszLabel, DWORD cchLabel);
    BOOL _GetSerialNumber(DWORD* pdwSerialNumber);
    BOOL _GetFileSystemFlags(DWORD* pdwFlags);
    int _GetGVIDriveFlags();
    int _GetDriveType();
    DWORD _GetAutorunContentType();

    HRESULT _Eject(HWND hwnd, LPTSTR pszMountPointNameForError);

    BOOL _HasAutorunLabel();
    BOOL _HasAutorunIcon();
    UINT _GetAutorunIcon(LPTSTR pszModule, DWORD cchModule);
    void _GetAutorunLabel(LPWSTR pszLabel, DWORD cchLabel);
    void _InitLegacyRegIconAndLabelHelper();
    void _InitAutorunInfo();

    BOOL _IsMountedOnDriveLetter();

    HANDLE _GetHandleWithAccessAndShareMode(DWORD dwDesiredAccess, DWORD dwShareMode);
    HANDLE _GetHandleReadRead();

    UINT _GetCDROMIcon();
    BOOL _GetCDROMName(LPWSTR pszName, DWORD cchName);

    DWORD _GetRegVolumeGen();

public:
    static void Initialize();
    static void FinalCleanUp();

    static HRESULT _GetAndRemoveVolumeAndItsMtPts(LPCWSTR pszDeviceIDVolume,
        CVolume** ppvol, HDPA hdpaMtPts);
    static CVolume* _GetVolumeByID(LPCWSTR pszDeviceIDVolume);
    static CVolume* _GetVolumeByMtPt(LPCWSTR pszMountPoint);
    static HRESULT _CreateMtPtLocalWithVolume(LPCWSTR pszMountPoint, CVolume* pvol);
    static HRESULT _CreateMtPtLocal(LPCWSTR pszMountPoint);
    static HRESULT _CreateMtPtLocalFromVolumeGuid(LPCWSTR pszVolumeGuid, CMountPoint ** ppmtpt );
    static HRESULT _CreateVolume(VOLUMEINFO* pvolinfo, CVolume** ppvolNew);

    static HRESULT _CreateVolumeFromReg(LPCWSTR pszDeviceIDVolume, CVolume** ppvolNew);
    static HRESULT _CreateVolumeFromRegHelper(LPCWSTR pszGUID, CVolume** ppvolNew);
    static HRESULT _CreateVolumeFromVOLUMEINFO2(VOLUMEINFO2* pvolinfo2, CVolume** ppvolNew);

    static CVolume* _GetAndRemoveVolumeByID(LPCWSTR pszDeviceIDVolume);

    static HRESULT _UpdateVolumeRegInfo(VOLUMEINFO* pvolinfo);
    static HRESULT _UpdateVolumeRegInfo2(VOLUMEINFO2* pvolinfo2);
///////////////////////////////////////////////////////////////////////////////
// Data
///////////////////////////////////////////////////////////////////////////////
public: // should be used in mtptarun2.cpp only (when used outside of CMtPtLocal)
    CVolume*                _pvol;

    // should be used in mtptevnt.cpp only (when used outside of CMtPtLocal)

    // Watch out!  No constructor nor destructor called on the next member
    static CRegSupport      _rsVolumes;

private:
    BOOL                    _fMountedOnDriveLetter;
    BOOL                    _fVolumePoint;

    WCHAR                   _szNameNoVolume[2];

#ifdef DEBUG
private:
    static DWORD            _cMtPtLocal;
#endif
};

class CVolume
{
public:
    DWORD       dwGeneration;
    DWORD       dwState;
    LPWSTR      pszDeviceIDVolume; // \\?\STORAGE#Volume#...{...GUID...}
    LPWSTR      pszVolumeGUID;     // \\?\Volume{...GUID...}
    DWORD       dwVolumeFlags;               // see HWDVF_... flags
    DWORD       dwDriveType;                 // see HWDT_... flags
    DWORD       dwDriveCapability;          // see HWDDC_... flags
    LPWSTR      pszLabel;          // 
    LPWSTR      pszFileSystem;     // 
    DWORD       dwFileSystemFlags;           // 
    DWORD       dwMaxFileNameLen;            // 
    DWORD       dwRootAttributes;            // 
    DWORD       dwSerialNumber;              // 
    DWORD       dwDriveState;                // see HWDDS_...
    DWORD       dwMediaState;                // see HWDMS_...
    DWORD       dwMediaCap;

    int         iShellImageForUpdateImage;
    LPWSTR      pszAutorunIconLocation;
    LPWSTR      pszAutorunLabel;
    LPWSTR      pszKeyName;

    LPWSTR      pszIconFromService;
    LPWSTR      pszNoMediaIconFromService;
    LPWSTR      pszLabelFromService;

public:
    ULONG AddRef()
    { return InterlockedIncrement(&_cRef); }

    ULONG Release()
    {
        if (InterlockedDecrement(&_cRef) > 0)
            return _cRef;
    
        delete this;
        return 0;
    }

private:
    LONG            _cRef;

public:
    CVolume() : _cRef(1)
    {
#ifdef DEBUG
        ++_cVolume;
#endif
    }
    ~CVolume()
    {
        if (pszDeviceIDVolume)
        {
            LocalFree(pszDeviceIDVolume);
        }
        if (pszVolumeGUID)
        {
            LocalFree(pszVolumeGUID);
        }
        if (pszLabel)
        {
            LocalFree(pszLabel);
        }
        if (pszFileSystem)
        {
            LocalFree(pszFileSystem);
        }
#ifdef DEBUG
        --_cVolume;
#endif
    }
#ifdef DEBUG
private:
    static DWORD                _cVolume;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mtptl2.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "shitemid.h"
#include "ids.h"
#include <ntddcdrm.h>
#include "shpriv.h"
#include "hwcmmn.h"
#include "mtptl.h"
#include "cdburn.h"

#ifdef DEBUG
DWORD CMtPtLocal::_cMtPtLocal = 0;
DWORD CVolume::_cVolume = 0;
#endif

const static WCHAR g_szCrossProcessCacheVolumeKey[] = TEXT("CPC\\Volume");
CRegSupport CMtPtLocal::_rsVolumes;

HRESULT CMtPtLocal::SetLabel(HWND hwnd, LPCTSTR pszLabel)
{
    HRESULT hr = E_FAIL;
    
    TraceMsg(TF_MOUNTPOINT, "CMtPtLocal::SetLabel: for '%s'", _GetNameDebug());
    
    if (SetVolumeLabel(_GetNameForFctCall(), pszLabel))
    {
        TraceMsg(TF_MOUNTPOINT, "   'SetVolumeLabel' succeeded");
        
        if ( !_fVolumePoint )
        {
            RSSetTextValue(NULL, TEXT("_LabelFromReg"), pszLabel, 
                REG_OPTION_NON_VOLATILE);
        }
        
        if (!_CanUseVolume())
        {
            // we notify for only the current drive (no folder mounted drive)
            SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_PATH, _GetName(),
                _GetName());
        }
        hr = S_OK;
    }
    else
    {
        DWORD dwErr = GetLastError();
        
        switch (dwErr)
        {
        case ERROR_SUCCESS:
            break;
            
        case ERROR_ACCESS_DENIED:
            
            hr = S_FALSE;	// don't have permission, shouldn't put them back into editing mode
            
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_ACCESSDENIED ),
                MAKEINTRESOURCE( IDS_TITLE_VOLUMELABELBAD ),
                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
            break;
            
        case ERROR_WRITE_PROTECT:
            hr = S_FALSE; // can't write, shouldn't put them back into editing mode
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_WRITEPROTECTED ),
                MAKEINTRESOURCE( IDS_TITLE_VOLUMELABELBAD ),
                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
            break;
            
        case ERROR_LABEL_TOO_LONG:
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_ERR_VOLUMELABELBAD ),
                MAKEINTRESOURCE( IDS_TITLE_VOLUMELABELBAD ),
                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
            break;
            
        case ERROR_UNRECOGNIZED_VOLUME:
            hr = S_FALSE; // can't write, shouldn't put them back into editing mode
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_ERR_VOLUMEUNFORMATTED ),
                MAKEINTRESOURCE( IDS_TITLE_VOLUMELABELBAD ),
                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
            break;
            
        default:
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_BADLABEL ),
                MAKEINTRESOURCE( IDS_TITLE_VOLUMELABELBAD ),
                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
            break;
        }
        
        TraceMsg(TF_MOUNTPOINT, "   'SetVolumeLabel' failed");
    }
    
    return hr;
}

HRESULT CMtPtLocal::SetDriveLabel(HWND hwnd, LPCTSTR pszLabel)
{
    HRESULT hr = E_FAIL;

    if ((_IsFloppy() || !_IsMediaPresent()) && _IsMountedOnDriveLetter())
    {
        // we rename the drive not the media
        TCHAR szSubKey[MAX_PATH];

        wnsprintf(szSubKey, ARRAYSIZE(szSubKey),
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DriveIcons\\%c\\DefaultLabel"),
            _GetNameFirstCharUCase());

        hr = RegSetValueString(HKEY_LOCAL_MACHINE, szSubKey, NULL, pszLabel) ? S_OK : E_FAIL;

        if (SUCCEEDED(hr))
        {
            LocalFree(_pszLegacyRegLabel);  // may be NULL
            _pszLegacyRegLabel = *pszLabel ? StrDup(pszLabel) : NULL;   // empty string resets
            SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_PATH, _GetName(), _GetName());
        }
    }
    else
    {
        hr = SetLabel(hwnd, pszLabel);
    }

    return hr;
}

HRESULT CMtPtLocal::GetLabelNoFancy(LPTSTR pszLabel, DWORD cchLabel)
{
    HRESULT hr = S_OK;

    if (!_GetGVILabelOrMixedCaseFromReg(pszLabel, cchLabel))
    {
        *pszLabel = 0;
        // Propagate failure code out for caller
        hr = E_FAIL;
    }

    return hr;
}

BOOL _ShowUglyDriveNames()
{
    static BOOL s_fShowUglyDriveNames = (BOOL)42;   // Preload some value to say lets calculate...

    if (s_fShowUglyDriveNames == (BOOL)42)
    {
        int iACP;
        TCHAR szTemp[MAX_PATH];     // Nice large buffer
        if (GetLocaleInfo(GetUserDefaultLCID(), LOCALE_IDEFAULTANSICODEPAGE, szTemp, ARRAYSIZE(szTemp)))
        {
            iACP = StrToInt(szTemp);
            // per Samer Arafeh, show ugly name for 1256 (Arabic ACP)
            if (iACP == 1252 || iACP == 1254 || iACP == 1255 || iACP == 1257 || iACP == 1258)
                goto TryLoadString;
            else
                s_fShowUglyDriveNames = TRUE;
        }
        else
        {
        TryLoadString:
            // All indications are that we can use pretty drive names.
            // Double-check that the localizers didn't corrupt the chars.
            LoadString(HINST_THISDLL, IDS_DRIVES_UGLY_TEST, szTemp, ARRAYSIZE(szTemp));

            // If the characters did not come through properly set ugly mode...
            s_fShowUglyDriveNames = (szTemp[0] != 0x00BC || szTemp[1] != 0x00BD);
        }
    }
    return s_fShowUglyDriveNames;
}

BOOL CMtPtLocal::_HasAutorunLabel()
{
    BOOL fRet = FALSE;

    if (_CanUseVolume())
    {
        fRet = BOOLFROMPTR(_pvol->pszAutorunLabel) &&
            *(_pvol->pszAutorunLabel);
    }

    return fRet;
}

BOOL CMtPtLocal::_HasAutorunIcon()
{
    BOOL fRet = FALSE;

    if (_CanUseVolume())
    {
        fRet = BOOLFROMPTR(_pvol->pszAutorunIconLocation) &&
            *(_pvol->pszAutorunIconLocation);
    }

    return fRet;
}

void CMtPtLocal::_GetAutorunLabel(LPWSTR pszLabel, DWORD cchLabel)
{
    ASSERT(_CanUseVolume());
    lstrcpyn(pszLabel, _pvol->pszAutorunLabel, cchLabel);
}

HRESULT CMtPtLocal::GetLabel(LPTSTR pszLabel, DWORD cchLabel)
{
    HRESULT hr = S_OK;
    BOOL fFoundIt = FALSE;

    // Autorun first
    // Fancy icon (Autoplay) second 
    // True label from drive for non-removable
    // Legacy drive icons third
    // Regular last

    if (_HasAutorunLabel())
    {
        _GetAutorunLabel(pszLabel, cchLabel);
        fFoundIt = TRUE;
    }

    if (!fFoundIt)
    {
        if (!_IsFloppy())
        {
            if (!_GetGVILabelOrMixedCaseFromReg(pszLabel, cchLabel))
            {
                *pszLabel = 0;
            }
            else
            {
                if (*pszLabel)
                {
                    fFoundIt = TRUE;
                }
            }
        }
    }

    if (!fFoundIt)
    {
        fFoundIt = _GetLegacyRegLabel(pszLabel, cchLabel);
    }

    if (!fFoundIt)
    {
        if (!_IsFloppy())
        {
            if (_CanUseVolume())
            {
                if (_pvol->pszLabelFromService)
                {
                    if (SUCCEEDED(SHLoadIndirectString(_pvol->pszLabelFromService, pszLabel,
                        cchLabel, NULL)))
                    {
                        fFoundIt = TRUE;
                    }
                    else
                    {
                        *pszLabel = 0;
                    }
                }
            }
        }
    }

    if (!fFoundIt)
    {
        if (_CanUseVolume() && (HWDTS_CDROM == _pvol->dwDriveType))
        {
            fFoundIt = _GetCDROMName(pszLabel, cchLabel);
        }
    }

    if (!fFoundIt)
    {
        if (_IsFloppy())
        {
            // For some weird reason we have wo sets of "ugly" name for floppies,
            // the other is in GetTypeString
            UINT id;

            if (_IsFloppy35())
            {
                id = _ShowUglyDriveNames() ? IDS_35_FLOPPY_DRIVE_UGLY : IDS_35_FLOPPY_DRIVE;
            }
            else
            {
                id = _ShowUglyDriveNames() ? IDS_525_FLOPPY_DRIVE_UGLY : IDS_525_FLOPPY_DRIVE;
            }

            LoadString(HINST_THISDLL, id, pszLabel, cchLabel);
        }
        else
        {
            // Cook up a default name
            GetTypeString(pszLabel, cchLabel);
        }
    }

    return hr;
}

HRESULT CMtPtLocal::Eject(HWND hwnd)
{
    TCHAR szNameForError[MAX_DISPLAYNAME];

    GetDisplayName(szNameForError, ARRAYSIZE(szNameForError));

    return _Eject(hwnd, szNameForError);
}

BOOL CMtPtLocal::HasMedia()
{
    return _IsMediaPresent();
}

BOOL CMtPtLocal::IsFormatted()
{
    return _IsFormatted();
}

BOOL CMtPtLocal::IsEjectable()
{
    BOOL fIsEjectable = FALSE;

    if (_IsCDROM())
    {
        fIsEjectable = TRUE;
    }
    else
    {
        // Floppies are not Software ejectable
        if (_IsStrictRemovable())
        {
            fIsEjectable = TRUE;
        }
        else
        {
            if (_IsFloppy())
            {
                if (_CanUseVolume() && (HWDDC_FLOPPYSOFTEJECT & _pvol->dwDriveCapability))
                {
                    if (_IsMediaPresent())
                    {
                        fIsEjectable = TRUE;
                    }
                }
            }
        }
    }

    if (fIsEjectable)
    {
        if (_CanUseVolume())
        {
            if (HWDDC_NOSOFTEJECT & _pvol->dwDriveCapability)
            {
                fIsEjectable = FALSE;
            }
        }
    }

    return fIsEjectable;
}

HRESULT CMtPtLocal::GetCDInfo(DWORD* pdwDriveCapabilities, DWORD* pdwMediaCapabilities)
{
    HRESULT hr;

    *pdwDriveCapabilities = 0;
    *pdwMediaCapabilities = 0;

    if (_IsCDROM())
    {
        if (_CanUseVolume())
        {
            if (HWDDC_CAPABILITY_SUPPORTDETECTION & _pvol->dwDriveCapability)
            {
                *pdwDriveCapabilities = (_pvol->dwDriveCapability & HWDDC_CDTYPEMASK);

                if (HWDMC_WRITECAPABILITY_SUPPORTDETECTION & _pvol->dwMediaCap)
                {
                    *pdwMediaCapabilities = (_pvol->dwMediaCap & HWDMC_CDTYPEMASK);
                }

                hr = S_OK;
            }
            else
            {
                // in the case where we really dont know, see if the IMAPI info cached in the
                // registry has what we want.
                hr = CDBurn_GetCDInfo(_pvol->pszVolumeGUID, pdwDriveCapabilities, pdwMediaCapabilities);
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// Put all these together
BOOL CMtPtLocal::_IsDVDDisc()
{
    BOOL fRet = FALSE;

    if (_CanUseVolume())
    {
        if (HWDMC_HASDVDMOVIE & _pvol->dwMediaCap)
        {
            fRet = TRUE;
        }
    }
    // else In safe boot we don't care about Audio Disc

    return fRet;
}

BOOL CMtPtLocal::_IsWritableDisc()
{
    BOOL fRet = FALSE;

    DWORD dwDriveCaps, dwMediaCaps;
    if ((S_OK == GetCDInfo(&dwDriveCaps, &dwMediaCaps)) &&
        ((HWDMC_CDRECORDABLE | HWDMC_CDREWRITABLE) & dwMediaCaps))
    {
        fRet = TRUE;
    }
    return fRet;
}

BOOL CMtPtLocal::_IsRemovableDevice()
{
    BOOL fRet = FALSE;

    if (_CanUseVolume())
    {
        if (HWDDC_REMOVABLEDEVICE & _pvol->dwDriveCapability)
        {
            fRet = TRUE;
        }        
    }

    return fRet;
}

// We keep the functionality we had before: a drive is Autorun only if it has
// a Autorun.inf in the root when inserted.  If it acquires one after, too bad.
BOOL CMtPtLocal::_IsAutorun()
{
    BOOL fRet = FALSE;

    if (_CanUseVolume())
    {
        if ((HWDMC_HASAUTORUNINF & _pvol->dwMediaCap) &&
            (HWDMC_HASAUTORUNCOMMAND & _pvol->dwMediaCap) &&
            !(HWDMC_HASUSEAUTOPLAY & _pvol->dwMediaCap))
        {
            fRet = TRUE;
        }
    }
    else
    {
        WCHAR szAutorun[MAX_PATH];
        DWORD dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        lstrcpyn(szAutorun, _GetNameForFctCall(), ARRAYSIZE(szAutorun));
        StrCatBuff(szAutorun, TEXT("autorun.inf"), ARRAYSIZE(szAutorun));

        if (-1 != GetFileAttributes(szAutorun))
        {
            fRet = TRUE;
        }

        SetErrorMode(dwErrMode);
    }

    return fRet;
}

// try to rename it
BOOL CMtPtLocal::_IsAudioDisc()
{
    BOOL fRet = FALSE;

    if (_CanUseVolume())
    {
        if (HWDMC_HASAUDIOTRACKS & _pvol->dwMediaCap)
        {
            fRet = TRUE;
        }
    }
    // else In safe boot we don't care about Audio Disc

    return fRet;
}

LPCTSTR CMtPtLocal::_GetNameForFctCall()
{
    LPCTSTR psz;

    if (_CanUseVolume())
    {
        psz = _pvol->pszVolumeGUID;
    }
    else
    {
        psz = _szName;
    }

    return psz;
}

HRESULT CMtPtLocal::_Eject(HWND hwnd, LPTSTR pszMountPointNameForError)
{
    HRESULT hr = E_FAIL;

#ifndef _WIN64
    // NTRAID#NTBUG9-093957-2000/09/08-StephStm  Code temporarily disabled for Win64
    // MCI is not 64bit ready.  It crashes.
    // We do this check to see if the CD will accept an IOCTL to eject it.
    // Old CD drives do not.  On W2K ssince the IOCTL was not implemented they use
    // to all say 'no'.  I assumne that on ia64 machine they will have recent CD
    // drives.  I call the IOCTL for them.  It works now, and it's certainly better
    // than the crash we get using MCI, worst come to worst it will silently fail.
    if (IsEjectable())
    {
#endif //_WIN64
        // it is a protect mode drive that we can tell directly...
        if (_IsCDROM())
        {
            HANDLE h = _GetHandleReadRead();

            if (INVALID_HANDLE_VALUE != h)
            {
                DWORD dwReturned;

                DeviceIoControl(h, IOCTL_DISK_EJECT_MEDIA, NULL, 0, NULL, 0,
                    &dwReturned, NULL);

                CloseHandle(h);
            }
            
            hr = S_OK;
        }
        else
        {
            // For removable drives, we want to do all the calls on a single
            // handle, thus we can't do lots of calls to DeviceIoControl.
            // Instead, use the helper routines to do our work...
            
            // Don't bring up any error message if the user already chose to abort.
            BOOL fAborted = FALSE;
            BOOL fFailed = TRUE;

            HANDLE h = _GetHandleWithAccessAndShareMode(GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE);

            if (INVALID_HANDLE_VALUE != h)
            {
                DWORD dwReturned;
_RETRY_LOCK_VOLUME_:

                // Now try to lock the drive...
                //
                // In theory, if no filesystem was mounted, the IOCtl command could go
                // to the device, which would fail with ERROR_INVALID_FUNCTION.  If that
                // occured, we would still want to proceed, since the device might still
                // be able to handle the IOCTL_DISK_EJECT_MEDIA command below.
                //
                if (!DeviceIoControl(h, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0,
                    &dwReturned, NULL) && (GetLastError() != ERROR_INVALID_FUNCTION))
                {
                    // So we can't lock the drive, bring up a message box to see if user
                    // wants to
                    //  1. Abort.
                    //  2. Retry to lock the drive.
                    //  3. Dismount anyway.

                    WCHAR szLabelForMessage[MAX_LABEL];

                    szLabelForMessage[0] = 0;

                    if (_CanUseVolume() && (_pvol->pszLabelFromService))
                    {
                        lstrcpyn(szLabelForMessage, _pvol->pszLabelFromService, ARRAYSIZE(szLabelForMessage));
                    }

                    if (!(szLabelForMessage[0]))
                    {
                        GetTypeString(szLabelForMessage, ARRAYSIZE(szLabelForMessage));

                        LPTSTR psz = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_VOL_FORMAT),
                                    szLabelForMessage, _GetNameFirstCharUCase());

                        if (psz)
                        {
                            StrCpyN(szLabelForMessage, psz, ARRAYSIZE(szLabelForMessage));
                            LocalFree(psz);
                        }
                        else
                        {
                            StrCpyN(szLabelForMessage, pszMountPointNameForError, ARRAYSIZE(szLabelForMessage));
                        }
                    }

                    int iRet = ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_UNMOUNT_TEXT ),
                        pszMountPointNameForError, MB_CANCELTRYCONTINUE | MB_ICONWARNING | MB_SETFOREGROUND,
                        szLabelForMessage);
        
                    switch (iRet)
                    {
                        case IDCANCEL:
                            // we did not fail, we aborted the format
                            fFailed = FALSE;
                            fAborted = TRUE;
                            break;

                        case IDCONTINUE:
                            // send FSCTL_DISMOUNT_VOLUME
                            if (!DeviceIoControl(h, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &dwReturned, NULL))
                            {
                                TraceMsg(TF_WARNING, "FSCTL_DISMOUNT_VOLUME failed with error %d.", GetLastError());
                                fFailed = TRUE;
                                break;
                            }
                            // We sucessfully dismounted the volume, so the h we have is not valid anymore. We
                            // therefore close it and start the process all over again, hoping to lock the volume before
                            // anyone re-opens a handle to it
                            //
                            // (fall through)
                        case IDTRYAGAIN:
                            goto _RETRY_LOCK_VOLUME_;
                    }
                }
                else
                {
                    ASSERT(!fAborted);  // should not have aborted if we got this far...
                    fFailed = FALSE;
                }


                if (!fFailed && !fAborted)
                {
                    PREVENT_MEDIA_REMOVAL pmr;

                    pmr.PreventMediaRemoval = FALSE;

                    // tell the drive to allow removal, then eject
                    if (!DeviceIoControl(h, IOCTL_STORAGE_MEDIA_REMOVAL, &pmr, sizeof(pmr), NULL, 0, &dwReturned, NULL) ||
                        !DeviceIoControl(h, IOCTL_STORAGE_EJECT_MEDIA, NULL, 0, NULL, 0, &dwReturned, NULL))
                    {
                        ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_EJECT_TEXT ),
                                MAKEINTRESOURCE( IDS_EJECT_TITLE ),
                                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND, pszMountPointNameForError);
                    }
                    else
                    {
                        hr = S_OK;
                    }
                }

                CloseHandle(h);
            }

            if (fFailed)
            {
                ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_UNMOUNT_TEXT ),
                        MAKEINTRESOURCE( IDS_UNMOUNT_TITLE ),
                        MB_OK | MB_ICONSTOP | MB_SETFOREGROUND, pszMountPointNameForError);
            }
        }
#ifndef _WIN64
    }
    else
    {
        // Is this needed anymore?

        // See comment above for why this is ifdef'ed out on Win64
        // (stephstm) only works for drive mounted on letter
        TCHAR szMCI[128];

        wsprintf(szMCI, TEXT("Open %c: type cdaudio alias foo shareable"),
            _GetNameFirstCharUCase());

        if (mciSendString(szMCI, NULL, 0, 0L) == MMSYSERR_NOERROR)
        {
            mciSendString(TEXT("set foo door open"), NULL, 0, 0L);
            mciSendString(TEXT("close foo"), NULL, 0, 0L);
            hr = S_OK;
        }
    }
#endif //_WIN64

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  New  //////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
BOOL CMtPtLocal::_GetFileAttributes(DWORD* pdwAttrib)
{
    BOOL fRet = FALSE;
    BOOL fDoRead = FALSE;
    *pdwAttrib = -1;

    if (_CanUseVolume() && !_IsFloppy())
    {
        if (_IsMediaPresent() && _IsFormatted())
        {
            if (_IsReadOnly())
            {
                // The file attrib we received at the begginning should be
                // valid, do not touch the drive for nothing
                *pdwAttrib = _pvol->dwRootAttributes;
                fRet = TRUE;
            }
            else
            {
                fDoRead = TRUE;
            }
        }
    }
    else
    {
        fDoRead = TRUE;
    }

    if (fDoRead)
    {
        DWORD dw = GetFileAttributes(_GetNameForFctCall());

        if (-1 != dw)
        {
            *pdwAttrib = dw;
            fRet = TRUE;
        }
    }

    return fRet;
}

// { DRIVE_ISCOMPRESSIBLE | DRIVE_LFN | DRIVE_SECURITY }
int CMtPtLocal::_GetGVIDriveFlags()
{
    int iFlags = 0;
    DWORD dwFileSystemFlags = 0;
    DWORD dwMaxFileNameLen = 13;

    if (_CanUseVolume() && (_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        if (_IsMediaPresent() && _IsFormatted())
        {
            // No check for _IsReadOnly, we'll be notified if there's a format
            dwFileSystemFlags = _pvol->dwFileSystemFlags;
            dwMaxFileNameLen = _pvol->dwMaxFileNameLen;
        }
    }
    else
    {
        if (!GetVolumeInformation(_GetNameForFctCall(), NULL, 0, NULL,
            &dwMaxFileNameLen, &dwFileSystemFlags, NULL, NULL))
        {
            // Just make sure
            dwMaxFileNameLen = 13;
        }
    }

    // The file attrib we received at the begginning should be
    // valid, do not touch the drive for nothing
    if (dwFileSystemFlags & FS_FILE_COMPRESSION)
    {
        iFlags |= DRIVE_ISCOMPRESSIBLE;
    }

    // Volume supports long filename (greater than 8.3)?
    if (dwMaxFileNameLen > 12)
    {
        iFlags |= DRIVE_LFN;
    }

    // Volume supports security?
    if (dwFileSystemFlags & FS_PERSISTENT_ACLS)
    {
        iFlags |= DRIVE_SECURITY;
    }

    return iFlags;
}

BOOL CMtPtLocal::_GetGVILabel(LPTSTR pszLabel, DWORD cchLabel)
{
    BOOL fRet = FALSE;

    *pszLabel = 0;

    if (_CanUseVolume() && (_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        if (_IsMediaPresent() && _IsFormatted())
        {
            // No check for _IsReadOnly, we'll be notified if there's a change
            // of label
            lstrcpyn(pszLabel, _pvol->pszLabel, cchLabel);
            fRet = TRUE;
        }
    }
    else
    {
        fRet = GetVolumeInformation(_GetNameForFctCall(), pszLabel, cchLabel,
            NULL, NULL, NULL, NULL, NULL);
    }

    return fRet;
}

BOOL CMtPtLocal::_GetSerialNumber(DWORD* pdwSerialNumber)
{
    BOOL fRet = FALSE;

    if (_CanUseVolume() && (_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        if (_IsMediaPresent() && _IsFormatted())
        {
            *pdwSerialNumber = _pvol->dwSerialNumber;
            fRet = TRUE;
        }
    }
    else
    {
        fRet = GetVolumeInformation(_GetNameForFctCall(), NULL, 0,
            pdwSerialNumber, NULL, NULL, NULL, NULL);
    }

    return fRet;
}

BOOL CMtPtLocal::_GetGVILabelOrMixedCaseFromReg(LPTSTR pszLabel, DWORD cchLabel)
{
    BOOL fRet = FALSE;

    *pszLabel = 0;

    fRet = _GetGVILabel(pszLabel, cchLabel);

    if (fRet)
    {
        WCHAR szLabelFromReg[MAX_LABEL];

        // Do we already have a label from the registry for this volume?
        // (the user may have renamed this drive)
        if (_GetLabelFromReg(szLabelFromReg, ARRAYSIZE(szLabelFromReg)) &&
            szLabelFromReg[0])
        {
            // Yes
            // Do they match (only diff in case)
            if (lstrcmpi(szLabelFromReg, pszLabel) == 0)
            {
                // Yes
                lstrcpyn(pszLabel, szLabelFromReg, cchLabel);
            }
        }
    }

    return fRet;
}

BOOL CMtPtLocal::_GetFileSystemFlags(DWORD* pdwFlags)
{
    BOOL fRet = FALSE;
    DWORD dwFileSystemFlags = 0;

    *pdwFlags = 0;

    if (_CanUseVolume() && (_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        if (_IsMediaPresent() && _IsFormatted())
        {
            // No check for _IsReadOnly, we'll be notified if there's a
            // format oper.
            *pdwFlags = _pvol->dwFileSystemFlags;
            fRet = TRUE;
        }
    }
    else
    {
        if (GetVolumeInformation(_GetNameForFctCall(), NULL, 0, NULL,
            NULL, pdwFlags, NULL, NULL))
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

BOOL CMtPtLocal::_GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName)
{
    BOOL fRet = FALSE;

    *pszFileSysName = 0;

    if (_CanUseVolume() && (_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        if (_IsMediaPresent() && _IsFormatted())
        {
            StrCpyN(pszFileSysName, _pvol->pszFileSystem, cchFileSysName);
            fRet = TRUE;
        }
    }
    else
    {
        if (GetVolumeInformation(_GetNameForFctCall(),
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 NULL,
                                 pszFileSysName,
                                 cchFileSysName))
        {
            fRet = TRUE;            
        }
    }

    return fRet;
}

struct CDROMICONS
{
    DWORD   dwCap;
    UINT    iIcon;
    UINT    iName;
};
  
// Go from most wonderful caps to less wonderful (according to stepshtm)
// Keep in order, it is verrrrry important
const CDROMICONS rgMediaPresent[] =
{
    // Specfic content 
    { HWDMC_HASDVDMOVIE, -IDI_AP_VIDEO, 0}, // we display the DVD media icon,
                                          // since it will most likely be
                                          // replaced by an icon from the DVD itself
    { HWDMC_HASAUDIOTRACKS | HWDMC_HASDATATRACKS, -IDI_MEDIACDAUDIOPLUS, 0}, 
    { HWDMC_HASAUDIOTRACKS, -IDI_CDAUDIO, 0 },
    { HWDMC_HASAUTORUNINF, -IDI_DRIVECD, 0 },
    // Specific media
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_DVDRAM, -IDI_MEDIADVDRAM, 0 },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_DVDRECORDABLE, -IDI_MEDIADVDR, 0 },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_DVDREWRITABLE, -IDI_MEDIADVDRW, 0 },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_DVDROM, -IDI_MEDIADVDROM, 0 },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_CDREWRITABLE, -IDI_MEDIACDRW, 0 },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_CDRECORDABLE, -IDI_MEDIACDR, 0 },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_CDROM, -IDI_MEDIACDROM, 0 },
};

// Keep in order, it is verrrrry important
const CDROMICONS rgNoMedia[] =
{
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_DVDRAM, -IDI_DRIVECD, IDS_DRIVES_DVDRAM },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_DVDRECORDABLE, -IDI_DRIVECD, IDS_DRIVES_DVDR },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_DVDREWRITABLE, -IDI_DRIVECD, IDS_DRIVES_DVDRW },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_DVDROM | HWDDC_CDREWRITABLE, -IDI_DRIVECD, IDS_DRIVES_DVDCDRW },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_DVDROM | HWDDC_CDRECORDABLE, -IDI_DRIVECD, IDS_DRIVES_DVDCDR },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_DVDROM, -IDI_DVDDRIVE, IDS_DRIVES_DVD },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_CDREWRITABLE, -IDI_DRIVECD, IDS_DRIVES_CDRW },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_CDRECORDABLE, -IDI_DRIVECD, IDS_DRIVES_CDR },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_CDROM, -IDI_DRIVECD, IDS_DRIVES_CDROM },
};

UINT _GetCDROMIconFromArray(DWORD dwCap, const CDROMICONS* prgcdromicons,
    DWORD ccdromicons)
{
    UINT iIcon = 0;

    for (DWORD dw = 0; dw < ccdromicons; ++dw)
    {
        if ((prgcdromicons[dw].dwCap & dwCap) == prgcdromicons[dw].dwCap)
        {
            iIcon = prgcdromicons[dw].iIcon;
            break;
        }
    }

    return iIcon;
}

UINT _GetCDROMNameFromArray(DWORD dwCap)
{
    UINT iName = 0;

    for (DWORD dw = 0; dw < ARRAYSIZE(rgNoMedia); ++dw)
    {
        if ((rgNoMedia[dw].dwCap & dwCap) == rgNoMedia[dw].dwCap)
        {
            iName = rgNoMedia[dw].iName;
            break;
        }
    }

    return iName;
}

UINT CMtPtLocal::_GetCDROMIcon()
{
    int iIcon;

    if (_IsMediaPresent())
    {
        ASSERT(_CanUseVolume());

        iIcon = _GetCDROMIconFromArray(_pvol->dwMediaCap, rgMediaPresent,
            ARRAYSIZE(rgMediaPresent));

        if (!iIcon)
        {
            iIcon = -IDI_DRIVECD;
        }
    }
    else
    {
        ASSERT(_CanUseVolume());

        iIcon = _GetCDROMIconFromArray(_pvol->dwDriveCapability, rgNoMedia,
            ARRAYSIZE(rgNoMedia));

        if (!iIcon)
        {
            // No media generic CD icon
            iIcon = -IDI_DRIVECD;
        }
    }

    return iIcon;
}

BOOL CMtPtLocal::_GetCDROMName(LPWSTR pszName, DWORD cchName)
{
    BOOL fRet = FALSE;
    *pszName = 0;

    if (!_IsMediaPresent())
    {
        ASSERT(_CanUseVolume());
        UINT iName = _GetCDROMNameFromArray(_pvol->dwDriveCapability);

        if (iName)
        {
            fRet = LoadString(HINST_THISDLL, iName, pszName, cchName);
        }
    }

    return fRet;
}

UINT CMtPtLocal::_GetAutorunIcon(LPTSTR pszModule, DWORD cchModule)
{
    int iIcon = -1;

    ASSERT(_CanUseVolume());

    if (_pvol->pszAutorunIconLocation)
    {
        lstrcpyn(pszModule, _GetName(), cchModule);
        StrCatBuff(pszModule, _pvol->pszAutorunIconLocation, cchModule);

        iIcon = PathParseIconLocation(pszModule);
    }

    return iIcon;
}

UINT CMtPtLocal::GetIcon(LPTSTR pszModule, DWORD cchModule)
{
    UINT iIcon = -IDI_DRIVEUNKNOWN;

    *pszModule = 0;

    if (_CanUseVolume())
    {
        // Autorun first
        // Fancy icon (Autoplay) second 
        // Legacy drive icons last

        if (_HasAutorunIcon())
        {
            iIcon = _GetAutorunIcon(pszModule, cchModule);
        }
        
        if (-IDI_DRIVEUNKNOWN == iIcon)
        {
            // Try fancy icon
            if (!_IsFloppy())
            {
                if (_IsMediaPresent())
                {
                    if (_pvol->pszIconFromService)
                    {
                        lstrcpyn(pszModule, _pvol->pszIconFromService, cchModule);
                    }
                }
                else
                {
                    if (_pvol->pszNoMediaIconFromService)
                    {
                        lstrcpyn(pszModule, _pvol->pszNoMediaIconFromService, cchModule);
                    }
                    else
                    {
                        if (_pvol->pszIconFromService)
                        {
                            lstrcpyn(pszModule, _pvol->pszIconFromService, cchModule);
                        }
                    }
                }

                if (*pszModule)
                {
                    iIcon = PathParseIconLocation(pszModule);
                }
            }

            if (-IDI_DRIVEUNKNOWN == iIcon)
            {
                if (_pszLegacyRegIcon)
                {
                    if (*_pszLegacyRegIcon)
                    {
                        if (lstrcpyn(pszModule, _pszLegacyRegIcon, cchModule))
                        {
                            iIcon = PathParseIconLocation(pszModule);
                        }
                    }
                }
                else
                {
                    if (_CanUseVolume() && (HWDTS_CDROM == _pvol->dwDriveType))
                    {
                        iIcon = _GetCDROMIcon();
                        *pszModule = 0;
                    }
                }
            }

            if (-IDI_DRIVEUNKNOWN == iIcon)
            {
                switch (_pvol->dwDriveType)
                {
                    case HWDTS_FLOPPY35:
                    {
                        iIcon = II_DRIVE35;
                        break;
                    }
                    case HWDTS_FIXEDDISK:
                    {
                        iIcon = II_DRIVEFIXED;
                        break;
                    }
                    case HWDTS_CDROM:
                    {
                        iIcon = II_DRIVECD;
                        break;
                    }
                    case HWDTS_REMOVABLEDISK:
                    {
                        iIcon = II_DRIVEREMOVE;
                        break;
                    }
                    case HWDTS_FLOPPY525:
                    {
                        iIcon = II_DRIVE525;
                        break;
                    }
                    default:
                    {
                        iIcon = -IDI_DRIVEUNKNOWN;
                        break;
                    }
                }
            }
        }
    }
    else
    {
        iIcon = CMountPoint::GetSuperPlainDriveIcon(_szName, GetDriveType(_GetName()));
    }

    if (*pszModule)
        TraceMsg(TF_MOUNTPOINT, "CMtPtLocal::GetIcon: for '%s', chose '%s', '%d'", _GetNameDebug(), pszModule, iIcon);
    else
        TraceMsg(TF_MOUNTPOINT, "CMtPtLocal::GetIcon: for '%s', chose '%d'", _GetNameDebug(), iIcon);

    return iIcon;
}

HRESULT CMtPtLocal::GetAssocSystemElement(IAssociationElement **ppae)
{
    PCWSTR psz = NULL;
    if (_IsFixedDisk())
        psz = L"Drive.Fixed";
    else if (_IsFloppy())
        psz = L"Drive.Floppy";
    else if (_IsCDROM())
        psz = L"Drive.CDROM";
    else if (_IsStrictRemovable())
        psz = L"Drive.Removable";
        
    if (psz)
        return AssocElemCreateForClass(&CLSID_AssocSystemElement, psz, ppae);

    return E_FAIL;
}

int CMtPtLocal::GetDriveFlags()
{
    UINT uDriveFlags = 0;

    // Is this a CD/DVD of some sort?
    if (_IsCDROM()) 
    {
        // Yes
        LPCTSTR pszSubKey = NULL;
        if (_IsAudioDisc())
        {
            uDriveFlags |= DRIVE_AUDIOCD;
            pszSubKey = TEXT("AudioCD\\shell");
        }
        else if (_IsDVDDisc())
        {
            uDriveFlags |= DRIVE_DVD;
            pszSubKey = TEXT("DVD\\shell");
        }

        // Set the AutoOpen stuff, if applicable
        if (pszSubKey)
        {
            TCHAR ach[80];
            LONG cb = sizeof(ach);
            ach[0] = 0;

            // get the default verb for Audio CD/DVD
            SHRegQueryValue(HKEY_CLASSES_ROOT, pszSubKey, ach, &cb);

            // we should only set AUTOOPEN if there is a default verb on Audio CD/DVD
            if (ach[0])
                uDriveFlags |= DRIVE_AUTOOPEN;
        }
    }
    else
    {
        // No, by default every drive type is ShellOpen, except CD-ROMs
        uDriveFlags |= DRIVE_SHELLOPEN;
    }

    if (_IsAutorun())
    {
        uDriveFlags |= DRIVE_AUTORUN;

        //FEATURE should we set AUTOOPEN based on a flag in the AutoRun.inf???
        uDriveFlags |= DRIVE_AUTOOPEN;
    }

    return uDriveFlags;
}

void CMtPtLocal::GetTypeString(LPTSTR pszType, DWORD cchType)
{
    int iID;

    *pszType = 0;

    if (_CanUseVolume())
    {
        switch (_pvol->dwDriveType)
        {
            case HWDTS_FLOPPY35:
                if (_ShowUglyDriveNames())
                {
                    iID = IDS_DRIVES_DRIVE35_UGLY;
                }
                else
                {
                    iID = IDS_DRIVES_DRIVE35;
                }
                break;
            case HWDTS_FLOPPY525:
                if (_ShowUglyDriveNames())
                {
                    iID = IDS_DRIVES_DRIVE525_UGLY;
                }
                else
                {
                    iID = IDS_DRIVES_DRIVE525;
                }
                break;

            case HWDTS_REMOVABLEDISK:
                iID = IDS_DRIVES_REMOVABLE;
                break;
            case HWDTS_FIXEDDISK:
                iID = IDS_DRIVES_FIXED;
                break;
            case HWDTS_CDROM:
                iID = IDS_DRIVES_CDROM;
                break;
        }
    }
    else
    {
        UINT uDriveType = GetDriveType(_GetNameForFctCall());

        switch (uDriveType)
        {
            case DRIVE_REMOVABLE:
                iID = IDS_DRIVES_REMOVABLE;
                break;
            case DRIVE_REMOTE:
                iID = IDS_DRIVES_NETDRIVE;
                break;
            case DRIVE_CDROM:
                iID = IDS_DRIVES_CDROM;
                break;
            case DRIVE_RAMDISK:
                iID = IDS_DRIVES_RAMDISK;
                break;
            case DRIVE_FIXED:
            default:
                iID = IDS_DRIVES_FIXED;
                break;
        }
    }

    LoadString(HINST_THISDLL, iID, pszType, cchType);
}

DWORD CMtPtLocal::GetShellDescriptionID()
{
    DWORD dwShellDescrID;

    if (_CanUseVolume())
    {
        switch (_pvol->dwDriveType)
        {
            case HWDTS_FLOPPY35:
                dwShellDescrID = SHDID_COMPUTER_DRIVE35;
                break;
            case HWDTS_FLOPPY525:
                dwShellDescrID = SHDID_COMPUTER_DRIVE525;
                break;
            case HWDTS_REMOVABLEDISK:
                dwShellDescrID = SHDID_COMPUTER_REMOVABLE;
                break;
            case HWDTS_FIXEDDISK:
                dwShellDescrID = SHDID_COMPUTER_FIXED;
                break;
            case HWDTS_CDROM:
                dwShellDescrID = SHDID_COMPUTER_CDROM;
                break;
            default:
                dwShellDescrID = SHDID_COMPUTER_OTHER;
                break;
        }
    }
    else
    {
        UINT uDriveType = GetDriveType(_GetNameForFctCall());

        switch (uDriveType)
        {
            case DRIVE_REMOVABLE:
                dwShellDescrID = SHDID_COMPUTER_REMOVABLE;
                break;

            case DRIVE_CDROM:
                dwShellDescrID = SHDID_COMPUTER_CDROM;
                break;

            case DRIVE_FIXED:
                dwShellDescrID = SHDID_COMPUTER_FIXED;
                break;

            case DRIVE_RAMDISK:
                dwShellDescrID = SHDID_COMPUTER_RAMDISK;
                break;

            case DRIVE_NO_ROOT_DIR:
            case DRIVE_UNKNOWN:
            default:
                dwShellDescrID = SHDID_COMPUTER_OTHER;
                break;
        }
    }

    return dwShellDescrID;
}

///////////////////////////////////////////////////////////////////////////////
// DeviceIoControl stuff
///////////////////////////////////////////////////////////////////////////////
HANDLE CMtPtLocal::_GetHandleWithAccessAndShareMode(DWORD dwDesiredAccess, DWORD dwShareMode)
{
    HANDLE handle = INVALID_HANDLE_VALUE;
    WCHAR szVolumeGUIDWOSlash[50];
    DWORD dwFileAttributes = 0;

    if (_CanUseVolume())
    {
        StrCpyN(szVolumeGUIDWOSlash, _pvol->pszVolumeGUID,
            ARRAYSIZE(szVolumeGUIDWOSlash));

        PathRemoveBackslash(szVolumeGUIDWOSlash);
    }
    else
    {
        // Go for VolumeGUID first
        if (GetVolumeNameForVolumeMountPoint(_GetName(), szVolumeGUIDWOSlash,
            ARRAYSIZE(szVolumeGUIDWOSlash)))
        {
            PathRemoveBackslash(szVolumeGUIDWOSlash);
        }
        else
        {
            // Probably a floppy, which cannot be mounted on a folder
            lstrcpy(szVolumeGUIDWOSlash, TEXT("\\\\.\\A:"));
            szVolumeGUIDWOSlash[4] = _GetNameFirstCharUCase();
        }
    }

    return CreateFile(szVolumeGUIDWOSlash, dwDesiredAccess, dwShareMode, NULL, OPEN_EXISTING, dwFileAttributes, NULL);
}

// On NT, when use GENERIC_READ (as opposed to 0) in the CreateFile call, we
// get a handle to the filesystem (CDFS), not the device itself.  But we can't
// change DriveIOCTL to do this, since that causes the floppy disks to spin
// up, and we don't want to do that.
HANDLE CMtPtLocal::_GetHandleReadRead()
{
    return _GetHandleWithAccessAndShareMode(GENERIC_READ, FILE_SHARE_READ);
}

BOOL CMtPtLocal::_CanUseVolume()
{
    // This is used in ASSERTs, do not add code that would introduce a side
    // effect in debug only (stephstm)

    // For Dismounted volumes, we want the code to take the alternate code
    // path.  The volume, when ready to be re-mounted, will be remounted
    // until some code tries to access it.  So using the alternate code path
    // will try to remount it, if it's ready it will get remounted, the Shell
    // Service will get an event, and we'll remove the DISMOUNTED bit.
    return (_pvol && !(_pvol->dwVolumeFlags & HWDVF_STATE_ACCESSDENIED) &&
        !(_pvol->dwVolumeFlags & HWDVF_STATE_DISMOUNTED));
}

HRESULT CMtPtLocal::_InitWithVolume(LPCWSTR pszMtPt, CVolume* pvol)
{
    pvol->AddRef();
    _pvol = pvol;

    lstrcpyn(_szName, pszMtPt, ARRAYSIZE(_szName));
    PathAddBackslash(_szName);

    _fMountedOnDriveLetter = _IsDriveLetter(pszMtPt);

    RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2, _pvol->pszKeyName,
        REG_OPTION_NON_VOLATILE);

    RSSetTextValue(NULL, TEXT("BaseClass"), TEXT("Drive"));

    _InitAutorunInfo();

    if (_CanUseVolume())
    {
        if (HWDMC_HASDESKTOPINI & _pvol->dwMediaCap)
        {
            // we need to listen to change notify to know when this guys will change
            _UpdateCommentFromDesktopINI();
        }
    }

    _InitLegacyRegIconAndLabelHelper();
    
    return S_OK;
}

// These can only be mounted on drive letter
HRESULT CMtPtLocal::_Init(LPCWSTR pszMtPt)
{
    HRESULT hr;
    ASSERT(_IsDriveLetter(pszMtPt));

    if (GetLogicalDrives() & (1 << DRIVEID(pszMtPt)))
    {
        _fMountedOnDriveLetter = TRUE;

        lstrcpyn(_szName, pszMtPt, ARRAYSIZE(_szName));
        PathAddBackslash(_szName);

        _GetNameFirstXChar(_szNameNoVolume, ARRAYSIZE(_szNameNoVolume));

        RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2, _szNameNoVolume,
            REG_OPTION_NON_VOLATILE);

        RSSetTextValue(NULL, TEXT("BaseClass"), TEXT("Drive"));

        _InitAutorunInfo();

        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

void CMtPtLocal::_InitLegacyRegIconAndLabelHelper()
{
    CMountPoint::_InitLegacyRegIconAndLabel(_HasAutorunIcon(),
        _HasAutorunLabel());
}

void CMtPtLocal::StoreIconForUpdateImage(int iImage)
{
    if (_CanUseVolume())
    {
        _pvol->iShellImageForUpdateImage = iImage;
    }
}

void CMtPtLocal::_InitAutorunInfo()
{
    if (_Shell32LoadedInDesktop())
    {
        BOOL fAutorun = FALSE;

        if (!_CanUseVolume())
        {
            if (_IsAutorun())
            {
                fAutorun = TRUE;
            }
        }

        if (!fAutorun && !_fVolumePoint)
        {
            // Make sure to delete the shell key
            RSDeleteSubKey(TEXT("Shell"));
        }
    }
}

// Equivalent of GetDriveType API
int CMtPtLocal::_GetDriveType()
{
    int iDriveType = DRIVE_NO_ROOT_DIR;

    if (_CanUseVolume())
    {
        switch (_pvol->dwDriveType)
        {
            case HWDTS_FLOPPY35:
            case HWDTS_FLOPPY525:
            case HWDTS_REMOVABLEDISK:
                iDriveType = DRIVE_REMOVABLE;
                break;
            case HWDTS_FIXEDDISK:
                iDriveType = DRIVE_FIXED;
                break;
            case HWDTS_CDROM:
                iDriveType = DRIVE_CDROM;
                break;
        }
    }
    else
    {
        iDriveType = GetDriveType(_GetNameForFctCall());
    }

    return iDriveType;
}

inline HLOCAL _LocalFree(HLOCAL hMem)
{
    if (hMem)
    {
        LocalFree(hMem);
    }

    return NULL;
}

#define VALID_VOLUME_PREFIX TEXT("\\\\?\\Volume")

// static
HRESULT CMtPtLocal::_CreateVolume(VOLUMEINFO* pvolinfo, CVolume** ppvolNew)
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;

    if (!StrCmpN(pvolinfo->pszVolumeGUID, VALID_VOLUME_PREFIX, ARRAYSIZE(VALID_VOLUME_PREFIX) - 1))
    {
        CVolume* pvol = new CVolume();

        *ppvolNew = NULL;

        if (pvol)
        {
            // The next four strings shouyld always be set to something
            pvol->pszDeviceIDVolume = StrDup(pvolinfo->pszDeviceIDVolume);
            pvol->pszVolumeGUID = StrDup(pvolinfo->pszVolumeGUID);
            pvol->pszLabel = StrDup(pvolinfo->pszLabel);
            pvol->pszFileSystem = StrDup(pvolinfo->pszFileSystem);

            // The following five strings are optional
            if (pvolinfo->pszAutorunIconLocation)
            {
                pvol->pszAutorunIconLocation = StrDup(pvolinfo->pszAutorunIconLocation);
            }

            if (pvolinfo->pszAutorunLabel)
            {
                pvol->pszAutorunLabel = StrDup(pvolinfo->pszAutorunLabel);
            }

            if (pvolinfo->pszIconLocationFromService)
            {
                pvol->pszIconFromService = StrDup(pvolinfo->pszIconLocationFromService);
            }

            if (pvolinfo->pszNoMediaIconLocationFromService)
            {
                pvol->pszNoMediaIconFromService = StrDup(pvolinfo->pszNoMediaIconLocationFromService);
            }

            if (pvolinfo->pszLabelFromService)
            {
                pvol->pszLabelFromService = StrDup(pvolinfo->pszLabelFromService);
            }
        
            if (pvol->pszDeviceIDVolume && pvol->pszVolumeGUID && pvol->pszLabel &&
                pvol->pszFileSystem)
            {
                pvol->dwState = pvolinfo->dwState;
                pvol->dwVolumeFlags = pvolinfo->dwVolumeFlags;
                pvol->dwDriveType = pvolinfo->dwDriveType;
                pvol->dwDriveCapability = pvolinfo->dwDriveCapability;
                pvol->dwFileSystemFlags = pvolinfo->dwFileSystemFlags;
                pvol->dwMaxFileNameLen = pvolinfo->dwMaxFileNameLen;
                pvol->dwRootAttributes = pvolinfo->dwRootAttributes;
                pvol->dwSerialNumber = pvolinfo->dwSerialNumber;
                pvol->dwDriveState = pvolinfo->dwDriveState;
                pvol->dwMediaState = pvolinfo->dwMediaState;
                pvol->dwMediaCap = pvolinfo->dwMediaCap;

                if (_hdpaVolumes && (-1 != DPA_AppendPtr(_hdpaVolumes, pvol)))
                {
                    pvol->pszKeyName = pvol->pszVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID;

                    pvol->AddRef();
                    *ppvolNew = pvol;
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (FAILED(hr))
            {
                _LocalFree(pvol->pszDeviceIDVolume);
                _LocalFree(pvol->pszVolumeGUID);
                _LocalFree(pvol->pszLabel);
                _LocalFree(pvol->pszFileSystem);

                _LocalFree(pvol->pszAutorunIconLocation);
                _LocalFree(pvol->pszAutorunLabel);
                _LocalFree(pvol->pszIconFromService);
                _LocalFree(pvol->pszNoMediaIconFromService);
                _LocalFree(pvol->pszLabelFromService);

                delete pvol;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// this helper function will hit the drive to see if media is present.
// should only be used for drives that don't support the HWDVF_STATE_SUPPORTNOTIFICATION
BOOL CMtPtLocal::_ForceCheckMediaPresent()
{
    BOOL bRet = FALSE;  // assume no media present

    HANDLE hDevice = _GetHandleWithAccessAndShareMode(GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE);

    if (hDevice != INVALID_HANDLE_VALUE)
    {
        DWORD dwDummy;

        // call the ioctl to verify media presence
        if (DeviceIoControl(hDevice,
                            IOCTL_STORAGE_CHECK_VERIFY,
                            NULL,
                            0,
                            NULL,
                            0,
                            &dwDummy,
                            NULL))
        {
            bRet = TRUE;
        }

        CloseHandle(hDevice);
    }

    return bRet;
}

BOOL CMtPtLocal::_IsMediaPresent()
{
    BOOL bRet;

    if (!_CanUseVolume() || !(_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        // if the drive dosen't support notification, we need to ping it now
        bRet = _ForceCheckMediaPresent();
    }
    else
    {
        bRet = (HWDMS_PRESENT & _pvol->dwMediaState);
    }

    return bRet;
}

BOOL CMtPtLocal::_IsFormatted()
{
    BOOL bRet = FALSE;

    if (!_CanUseVolume() || !(_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        // if the drive dosen't support notification, we need to ping it now
        bRet = GetVolumeInformation(_GetNameForFctCall(),
                                    NULL,
                                    0,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
    }
    else
    {
        bRet = (_IsMediaPresent() && (HWDMS_FORMATTED & _pvol->dwMediaState));
    }

    return bRet;
}

BOOL CMtPtLocal::_IsReadOnly()
{
    ASSERT(_CanUseVolume());
    ASSERT(_IsMediaPresent()); // does not make sense otherwise
    BOOL fRet = FALSE;

    if (_IsCDROM() &&
            (
                (HWDMC_WRITECAPABILITY_SUPPORTDETECTION & _pvol->dwMediaState) &&
                (
                    (HWDMC_CDROM & _pvol->dwMediaCap) ||
                    (HWDMC_DVDROM & _pvol->dwMediaCap)
                )
            )
        )
    {
        fRet = TRUE;
    }
    else
    {
        // We could optimize by checking if the floppy is write protected.  But
        // it might not be worth it.
        fRet = FALSE;
    }

    return fRet;
}

BOOL CMtPtLocal::_IsMountedOnDriveLetter()
{
    return _fMountedOnDriveLetter;
}

CMtPtLocal::CMtPtLocal()
{
#ifdef DEBUG
    ++_cMtPtLocal;
#endif
}

CMtPtLocal::~CMtPtLocal()
{
    if (_pvol)
    {
        _pvol->Release();
    }

#ifdef DEBUG
    --_cMtPtLocal;
#endif
}

// static
HRESULT CMtPtLocal::_CreateMtPtLocal(LPCWSTR pszMountPoint)
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;
    CMtPtLocal* pmtptl = new CMtPtLocal();

    if (pmtptl)
    {
        int iDrive = DRIVEID(pszMountPoint);

        if (_rgMtPtDriveLetterLocal[iDrive])
        {
            _rgMtPtDriveLetterLocal[iDrive]->Release();
            _rgMtPtDriveLetterLocal[iDrive] = NULL;
        }

        hr = pmtptl->_Init(pszMountPoint);

        if (SUCCEEDED(hr))
        {
            // Yes
            _rgMtPtDriveLetterLocal[iDrive] = pmtptl;
        }
        else
        {
            delete pmtptl;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

HRESULT CMtPtLocal::GetMountPointName(LPWSTR pszMountPoint, DWORD cchMountPoint)
{
    lstrcpyn(pszMountPoint, _GetName(), cchMountPoint);

    return S_OK;
}

// static
HRESULT CMtPtLocal::_CreateMtPtLocalWithVolume(LPCWSTR pszMountPoint,
    CVolume* pvol)
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;
    CMtPtLocal* pmtptlNew = new CMtPtLocal();

    if (pmtptlNew)
    {
        // Is it a drive letter only?
        if (_IsDriveLetter(pszMountPoint))
        {
            // Yes
            int iDrive = DRIVEID(pszMountPoint);

            if (_rgMtPtDriveLetterLocal[iDrive])
            {
                _rgMtPtDriveLetterLocal[iDrive]->Release();
                _rgMtPtDriveLetterLocal[iDrive] = NULL;
            }
        }
        else
        {
            _RemoveLocalMountPoint(pszMountPoint);
        }

        hr = pmtptlNew->_InitWithVolume(pszMountPoint, pvol);

        if (SUCCEEDED(hr))
        {
            // Is it a drive letter only?
            if (_IsDriveLetter(pszMountPoint))
            {
                // Yes
                int iDrive = DRIVEID(pszMountPoint);

                _rgMtPtDriveLetterLocal[iDrive] = pmtptlNew;
            }
            else
            {
                hr = _StoreMtPtMOF(pmtptlNew);
            }
        }

        if (FAILED(hr))
        {
            delete pmtptlNew;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

// static
HRESULT CMtPtLocal::_CreateMtPtLocalFromVolumeGuid(LPCWSTR pszVolumeGuid, CMountPoint ** ppmtpt )
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;
    CMtPtLocal* pmtptlNew = new CMtPtLocal();

    Assert( NULL != ppmtpt );
    *ppmtpt = (CMountPoint *) pmtptlNew;

    if (pmtptlNew)
    {
        ASSERT(NULL == pmtptlNew->_pvol);

        lstrcpyn(pmtptlNew->_szName, pszVolumeGuid, ARRAYSIZE(pmtptlNew->_szName));
        PathAddBackslash(pmtptlNew->_szName);

        pmtptlNew->_fMountedOnDriveLetter = FALSE;
        pmtptlNew->_fVolumePoint = TRUE;
        pmtptlNew->_InitAutorunInfo();

        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

// static
CVolume* CMtPtLocal::_GetVolumeByMtPt(LPCWSTR pszMountPoint)
{
    ASSERT(_csDL.IsInside());
    CVolume* pvol = NULL;
    WCHAR szVolumeGUID[50];

    if (_fLocalDrivesInited)
    {
        if (GetVolumeNameForVolumeMountPoint(pszMountPoint, szVolumeGUID,
            ARRAYSIZE(szVolumeGUID)))
        {
            DWORD c = DPA_GetPtrCount(_hdpaVolumes);

            for (DWORD dw = 0; dw < c; ++dw)
            {
                pvol = (CVolume*)DPA_GetPtr(_hdpaVolumes, dw);

                if (pvol)
                {
                    if (!lstrcmpi(pvol->pszVolumeGUID, szVolumeGUID))
                    {
                        pvol->AddRef();
                        break;
                    }
                    else
                    {
                        pvol = NULL;
                    }
                }
            }
        }
    }

    return pvol;
}

// static
CVolume* CMtPtLocal::_GetVolumeByID(LPCWSTR pszDeviceIDVolume)
{
    ASSERT(_csDL.IsInside());
    CVolume* pvol = NULL;

    if (_hdpaVolumes)
    {
        DWORD c = DPA_GetPtrCount(_hdpaVolumes);

        for (DWORD dw = 0; dw < c; ++dw)
        {
            pvol = (CVolume*)DPA_GetPtr(_hdpaVolumes, dw);

            if (pvol)
            {
                if (!lstrcmpi(pvol->pszDeviceIDVolume, pszDeviceIDVolume))
                {
                    pvol->AddRef();
                    break;
                }
                else
                {
                    pvol = NULL;
                }
            }
        }
    }

    return pvol;
}

// static
CVolume* CMtPtLocal::_GetAndRemoveVolumeByID(LPCWSTR pszDeviceIDVolume)
{
    CVolume* pvol = NULL;

    _csDL.Enter();

    if (_hdpaVolumes)
    {
        DWORD c = DPA_GetPtrCount(_hdpaVolumes);

        for (int i = c - 1; i >= 0; --i)
        {
            pvol = (CVolume*)DPA_GetPtr(_hdpaVolumes, i);

            if (pvol)
            {
                if (!lstrcmpi(pvol->pszDeviceIDVolume, pszDeviceIDVolume))
                {
                    // Do not AddRef
                    DPA_DeletePtr(_hdpaVolumes, i);
                    break;
                }
                else
                {
                    pvol = NULL;
                }
            }
        }
    }

    _csDL.Leave();

    return pvol;
}

// static
HRESULT CMtPtLocal::_GetAndRemoveVolumeAndItsMtPts(LPCWSTR pszDeviceIDVolume,
    CVolume** ppvol, HDPA hdpaMtPts)
{
    _csDL.Enter();

    CVolume* pvol = _GetAndRemoveVolumeByID(pszDeviceIDVolume);

    if (pvol)
    {
        for (DWORD dw = 0; dw < 26; ++dw)
        {
            CMtPtLocal* pmtptl = (CMtPtLocal*)_rgMtPtDriveLetterLocal[dw];

            if (pmtptl && pmtptl->_pvol)
            {
                if (pmtptl->_pvol == pvol)
                {
                    _rgMtPtDriveLetterLocal[dw] = 0;

                    DPA_AppendPtr(hdpaMtPts, pmtptl);
                    break;
                }
            }
        }

        _csLocalMtPtHDPA.Enter();

        if (_hdpaMountPoints)
        {
            DWORD c = DPA_GetPtrCount(_hdpaMountPoints);

            for (int i = c - 1; i >= 0; --i)
            {
                CMtPtLocal* pmtptl = (CMtPtLocal*)DPA_GetPtr(_hdpaMountPoints, i);

                if (pmtptl && pmtptl->_pvol)
                {
                    if (pmtptl->_pvol == pvol)
                    {
                        DPA_DeletePtr(_hdpaMountPoints, i);

                        DPA_AppendPtr(hdpaMtPts, pmtptl);
                    }
                }
            }
        }

        _csLocalMtPtHDPA.Leave();
    }

    *ppvol = pvol;

    _csDL.Leave();

    return S_OK;
}

BOOL CMtPtLocal::_IsMiniMtPt()
{
    return !_CanUseVolume();
}

HKEY CMtPtLocal::GetRegKey()
{
    TraceMsg(TF_MOUNTPOINT, "CMtPtLocal::GetRegKey: for '%s'", _GetNameDebug());

    if (_IsAutoRunDrive())
    {
        _ProcessAutoRunFile();
    }

    return RSDuplicateRootKey();
}

DWORD CMtPtLocal::_GetRegVolumeGen()
{
    ASSERT(_CanUseVolume());
    DWORD dwGen;

    if (!_rsVolumes.RSGetDWORDValue(_pvol->pszVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID, TEXT("Generation"), &dwGen))
    {
        dwGen = 0;
    }

    return dwGen;
}

BOOL CMtPtLocal::_NeedToRefresh()
{
    ASSERT(_csDL.IsInside());
    ASSERT(!_Shell32LoadedInDesktop());
    BOOL fNeedToRefresh = FALSE;

    if (_CanUseVolume())
    {
        DWORD dwRegVolumeGeneration = _GetRegVolumeGen();

        if (dwRegVolumeGeneration != _pvol->dwGeneration)
        {
            // Remove it so that new mtpts do not get it.
            CVolume* pvolnew;
            CVolume* pvol = _GetAndRemoveVolumeByID(_pvol->pszDeviceIDVolume);

            if (pvol)
            {
                // Release our cache ref count
                pvol->Release();
            }

            // Replace the volume
            if (SUCCEEDED(CMtPtLocal::_CreateVolumeFromReg(_pvol->pszDeviceIDVolume,
                &pvolnew)))
            {
                pvolnew->Release();
            }

            fNeedToRefresh = TRUE;
        }
    }

    return fNeedToRefresh;
}

// static 
HRESULT CMtPtLocal::_CreateVolumeFromVOLUMEINFO2(VOLUMEINFO2* pvolinfo2, CVolume** ppvolNew)
{
    VOLUMEINFO volinfo = {0};

    volinfo.pszDeviceIDVolume = pvolinfo2->szDeviceIDVolume;
    volinfo.pszVolumeGUID = pvolinfo2->szVolumeGUID;
    volinfo.pszLabel = pvolinfo2->szLabel;
    volinfo.pszFileSystem = pvolinfo2->szFileSystem;

    volinfo.dwState = pvolinfo2->dwState;
    volinfo.dwVolumeFlags = pvolinfo2->dwVolumeFlags;
    volinfo.dwDriveType = pvolinfo2->dwDriveType;
    volinfo.dwDriveCapability = pvolinfo2->dwDriveCapability;
    volinfo.dwFileSystemFlags = pvolinfo2->dwFileSystemFlags;
    volinfo.dwMaxFileNameLen = pvolinfo2->dwMaxFileNameLen;
    volinfo.dwRootAttributes = pvolinfo2->dwRootAttributes;
    volinfo.dwSerialNumber = pvolinfo2->dwSerialNumber;
    volinfo.dwDriveState = pvolinfo2->dwDriveState;
    volinfo.dwMediaState = pvolinfo2->dwMediaState;
    volinfo.dwMediaCap = pvolinfo2->dwMediaCap;

    if (-1 != pvolinfo2->oAutorunIconLocation)
    {
        volinfo.pszAutorunIconLocation = pvolinfo2->szOptionalStrings +
            pvolinfo2->oAutorunIconLocation;
    }
    if (-1 != pvolinfo2->oAutorunLabel)
    {
        volinfo.pszAutorunLabel = pvolinfo2->szOptionalStrings +
            pvolinfo2->oAutorunLabel;
    }
    if (-1 != pvolinfo2->oIconLocationFromService)
    {
        volinfo.pszIconLocationFromService = pvolinfo2->szOptionalStrings +
            pvolinfo2->oIconLocationFromService;
    }
    if (-1 != pvolinfo2->oNoMediaIconLocationFromService)
    {
        volinfo.pszNoMediaIconLocationFromService = pvolinfo2->szOptionalStrings +
            pvolinfo2->oNoMediaIconLocationFromService;
    }
    if (-1 != pvolinfo2->oLabelFromService)
    {
        volinfo.pszLabelFromService = pvolinfo2->szOptionalStrings +
            pvolinfo2->oLabelFromService;
    }

    return _CreateVolume(&volinfo, ppvolNew);
}

// static 
HRESULT CMtPtLocal::_CreateVolumeFromRegHelper(LPCWSTR pszGUID, CVolume** ppvolNew)
{
    ASSERT(!_Shell32LoadedInDesktop());
    ASSERT(_csDL.IsInside());
    HRESULT hr;
    
    DWORD cbSize = MAX_VOLUMEINFO2;
    PBYTE pb = (PBYTE)LocalAlloc(LPTR, cbSize);

    if (pb)
    {
        if (_rsVolumes.RSGetBinaryValue(pszGUID, TEXT("Data"), pb, &cbSize))
        {
            DWORD dwGen;

            if (_rsVolumes.RSGetDWORDValue(pszGUID, TEXT("Generation"), &dwGen))
            {
                VOLUMEINFO2* pvolinfo2 = (VOLUMEINFO2*)pb;

                hr = _CreateVolumeFromVOLUMEINFO2(pvolinfo2, ppvolNew);

                if (SUCCEEDED(hr))
                {
                    (*ppvolNew)->dwGeneration = dwGen;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }

        LocalFree(pb);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// static 
HRESULT CMtPtLocal::_CreateVolumeFromReg(LPCWSTR pszDeviceIDVolume, CVolume** ppvolNew)
{
    ASSERT(!_Shell32LoadedInDesktop());
    ASSERT(_csDL.IsInside());
    HRESULT hr;
    
    WCHAR szDeviceIDWithSlash[200];
    WCHAR szVolumeGUID[50];

    lstrcpyn(szDeviceIDWithSlash, pszDeviceIDVolume,
        ARRAYSIZE(szDeviceIDWithSlash));
    PathAddBackslash(szDeviceIDWithSlash);

    if (GetVolumeNameForVolumeMountPoint(szDeviceIDWithSlash,
        szVolumeGUID, ARRAYSIZE(szVolumeGUID)))
    {
        LPWSTR pszGUID = &(szVolumeGUID[OFFSET_GUIDWITHINVOLUMEGUID]);

        hr = _CreateVolumeFromRegHelper(pszGUID, ppvolNew);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// static
HRESULT CMtPtLocal::_UpdateVolumeRegInfo(VOLUMEINFO* pvolinfo)
{
    ASSERT(_Shell32LoadedInDesktop());
    ASSERT(_csDL.IsInside());

    HRESULT hr;
    DWORD cbSize = MAX_VOLUMEINFO2;
    PBYTE pb = (PBYTE)LocalAlloc(LPTR, cbSize);

    if (pb)
    {
        DWORD dwGen;
        DWORD offset = 0;
        VOLUMEINFO2* pvolinfo2 = (VOLUMEINFO2*)pb;

        // Get the Generation
        if (!_rsVolumes.RSGetDWORDValue(
            pvolinfo->pszVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID, TEXT("Generation"),
            &dwGen))
        {
            dwGen = 0;
        }

        ++dwGen;
        
        ASSERT(pvolinfo->pszDeviceIDVolume);
        ASSERT(pvolinfo->pszVolumeGUID);
        ASSERT(pvolinfo->pszLabel);
        ASSERT(pvolinfo->pszFileSystem);

        lstrcpyn(pvolinfo2->szDeviceIDVolume, pvolinfo->pszDeviceIDVolume,
            ARRAYSIZE(pvolinfo2->szDeviceIDVolume));
        lstrcpyn(pvolinfo2->szVolumeGUID, pvolinfo->pszVolumeGUID,
            ARRAYSIZE(pvolinfo2->szVolumeGUID));
        lstrcpyn(pvolinfo2->szLabel, pvolinfo->pszLabel,
            ARRAYSIZE(pvolinfo2->szLabel));
        lstrcpyn(pvolinfo2->szFileSystem, pvolinfo->pszFileSystem,
            ARRAYSIZE(pvolinfo2->szFileSystem));

        pvolinfo2->dwState = pvolinfo->dwState;
        pvolinfo2->dwVolumeFlags = pvolinfo->dwVolumeFlags;
        pvolinfo2->dwDriveType = pvolinfo->dwDriveType;
        pvolinfo2->dwDriveCapability = pvolinfo->dwDriveCapability;
        pvolinfo2->dwFileSystemFlags = pvolinfo->dwFileSystemFlags;
        pvolinfo2->dwMaxFileNameLen = pvolinfo->dwMaxFileNameLen;
        pvolinfo2->dwRootAttributes = pvolinfo->dwRootAttributes;
        pvolinfo2->dwSerialNumber = pvolinfo->dwSerialNumber;
        pvolinfo2->dwDriveState = pvolinfo->dwDriveState;
        pvolinfo2->dwMediaState = pvolinfo->dwMediaState;
        pvolinfo2->dwMediaCap = pvolinfo->dwMediaCap;

        pvolinfo2->oAutorunIconLocation = -1;
        pvolinfo2->oAutorunLabel = -1;
        pvolinfo2->oIconLocationFromService = -1;
        pvolinfo2->oNoMediaIconLocationFromService = -1;
        pvolinfo2->oLabelFromService = -1;

         // The following five strings are optional
        if (pvolinfo->pszAutorunIconLocation)
        {
            pvolinfo2->oAutorunIconLocation = offset;

            offset += lstrlen(pvolinfo->pszAutorunIconLocation) + 1;

            lstrcpy(pvolinfo2->szOptionalStrings + pvolinfo2->oAutorunIconLocation,
                pvolinfo->pszAutorunIconLocation);
        }

        if (pvolinfo->pszAutorunLabel)
        {
            pvolinfo2->oAutorunIconLocation = offset;

            offset += lstrlen(pvolinfo->pszAutorunLabel) + 1;

            lstrcpy(pvolinfo2->szOptionalStrings + pvolinfo2->oAutorunIconLocation,
                pvolinfo->pszAutorunLabel);
        }

        if (pvolinfo->pszIconLocationFromService)
        {
            pvolinfo2->oIconLocationFromService = offset;

            offset += lstrlen(pvolinfo->pszIconLocationFromService) + 1;

            lstrcpy(pvolinfo2->szOptionalStrings + pvolinfo2->oIconLocationFromService,
                pvolinfo->pszIconLocationFromService);
        }

        if (pvolinfo->pszNoMediaIconLocationFromService)
        {
            pvolinfo2->oNoMediaIconLocationFromService = offset;

            offset += lstrlen(pvolinfo->pszNoMediaIconLocationFromService) + 1;

            lstrcpy(pvolinfo2->szOptionalStrings + pvolinfo2->oNoMediaIconLocationFromService,
                pvolinfo->pszNoMediaIconLocationFromService);
        }

        if (pvolinfo->pszLabelFromService)
        {
            pvolinfo2->oLabelFromService = offset;

            offset += lstrlen(pvolinfo->pszLabelFromService) + 1;

            lstrcpy(pvolinfo2->szOptionalStrings + pvolinfo2->oLabelFromService,
                pvolinfo->pszLabelFromService);
        }

        if (_rsVolumes.RSSetBinaryValue(pvolinfo->pszVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID,
            TEXT("Data"), pb, sizeof(VOLUMEINFO2) + (offset * sizeof(WCHAR)), REG_OPTION_VOLATILE))
        {
            if (_rsVolumes.RSSetDWORDValue(pvolinfo->pszVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID,
                TEXT("Generation"), dwGen))
            {
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }

        if (FAILED(hr))
        {
            _rsVolumes.RSDeleteSubKey(pvolinfo->pszVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID);
        }

        LocalFree(pb);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// static
HRESULT CMtPtLocal::_UpdateVolumeRegInfo2(VOLUMEINFO2* pvolinfo2)
{
    ASSERT(_Shell32LoadedInDesktop());
    ASSERT(_csDL.IsInside());

    HRESULT hr;
    DWORD dwGen;

    // Get the Generation
    if (!_rsVolumes.RSGetDWORDValue(
        pvolinfo2->szVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID, TEXT("Generation"),
        &dwGen))
    {
        dwGen = 0;
    }

    ++dwGen;

    if (_rsVolumes.RSSetBinaryValue(pvolinfo2->szVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID,
        TEXT("Data"), (PBYTE)pvolinfo2, pvolinfo2->cbSize, REG_OPTION_VOLATILE))
    {
        if (_rsVolumes.RSSetDWORDValue(pvolinfo2->szVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID,
            TEXT("Generation"), dwGen))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    if (FAILED(hr))
    {
        _rsVolumes.RSDeleteSubKey(pvolinfo2->szVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID);
    }

    return hr;
}

//static
void CMtPtLocal::Initialize()
{
    _rsVolumes.RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2,
        g_szCrossProcessCacheVolumeKey, REG_OPTION_VOLATILE);
}

void CMtPtLocal::FinalCleanUp()
{
    if (_Shell32LoadedInDesktop())
    {
        _rsVolumes.RSDeleteKey();
    }
}

static const TWODWORDS arcontenttypemappings[] =
{
    { HWDMC_HASAUTORUNINF, ARCONTENT_AUTORUNINF },
    { HWDMC_HASAUDIOTRACKS, ARCONTENT_AUDIOCD },
    { HWDMC_HASDVDMOVIE, ARCONTENT_DVDMOVIE },
};

static const TWODWORDS arblankmediamappings[] =
{
    { HWDMC_CDRECORDABLE, ARCONTENT_BLANKCD },
    { HWDMC_CDREWRITABLE, ARCONTENT_BLANKCD },
    { HWDMC_DVDRECORDABLE, ARCONTENT_BLANKDVD },
    { HWDMC_DVDREWRITABLE, ARCONTENT_BLANKDVD },
};

DWORD CMtPtLocal::_GetAutorunContentType()
{
    DWORD dwRet = 0;
    
    if (_CanUseVolume())
    {
        dwRet = _DoDWORDMapping(_pvol->dwMediaCap, arcontenttypemappings,
            ARRAYSIZE(arcontenttypemappings), TRUE);

        if (_pvol->dwMediaState & HWDMS_FORMATTED)
        {
            dwRet |= ARCONTENT_UNKNOWNCONTENT;
        }
        else
        {
            ASSERT(!dwRet);

            DWORD dwDriveCapabilities;
            DWORD dwMediaCapabilities;

            if (_IsCDROM())
            {
                if (SUCCEEDED(CDBurn_GetCDInfo(_pvol->pszVolumeGUID, &dwDriveCapabilities, &dwMediaCapabilities)))
                {
                    dwRet = _DoDWORDMapping(dwMediaCapabilities, arblankmediamappings,
                        ARRAYSIZE(arblankmediamappings), TRUE);
                }
            }
        }
    }
    else
    {
        // If there's no _pvol, we care only about autorun.inf
        if (_IsAutorun())
        {
            dwRet = ARCONTENT_AUTORUNINF;
        }

        if (_IsFormatted())
        {
            dwRet |= ARCONTENT_UNKNOWNCONTENT;
        }
    }
    
    return dwRet;
}

// static
BOOL CMtPtLocal::IsVolume(LPCWSTR pszDeviceID)
{
    BOOL fRet = FALSE;

    _csDL.Enter();

    CVolume* pvol = _GetVolumeByID(pszDeviceID);

    if (pvol)
    {
        fRet = TRUE;
        pvol->Release();
    }

    _csDL.Leave();
    
    return fRet;
}

// static
HRESULT CMtPtLocal::GetMountPointFromDeviceID(LPCWSTR pszDeviceID,
        LPWSTR pszMountPoint, DWORD cchMountPoint)
{
    HRESULT hr = E_FAIL;
    CMtPtLocal* pmtptl = NULL;

    _csDL.Enter();

    for (DWORD dw = 0; dw < 26; ++dw)
    {
        pmtptl = (CMtPtLocal*)_rgMtPtDriveLetterLocal[dw];

        if (pmtptl && pmtptl->_pvol)
        {
            if (!lstrcmpi(pmtptl->_pvol->pszDeviceIDVolume, pszDeviceID))
            {
                lstrcpyn(pszMountPoint, pmtptl->_szName, cchMountPoint);
                hr = S_OK;
                break;
            }
        }
    }

    _csDL.Leave();

    if (FAILED(hr))
    {
        _csLocalMtPtHDPA.Enter();

        if (_hdpaMountPoints)
        {
            DWORD c = DPA_GetPtrCount(_hdpaMountPoints);

            for (int i = c - 1; i >= 0; --i)
            {
                pmtptl = (CMtPtLocal*)DPA_GetPtr(_hdpaMountPoints, i);

                if (pmtptl && pmtptl->_pvol)
                {
                    if (!lstrcmpi(pmtptl->_pvol->pszDeviceIDVolume, pszDeviceID))
                    {
                        lstrcpyn(pszMountPoint, pmtptl->_szName, cchMountPoint);

                        hr = S_OK;
                        break;
                    }
                }
            }
        }

        _csLocalMtPtHDPA.Leave();
    }

    return hr;
}

static const TWODWORDS drivetypemappings[] =
{
    { HWDTS_FLOPPY35     , DT_FLOPPY35 },
    { HWDTS_FLOPPY525    , DT_FLOPPY525 },
    { HWDTS_REMOVABLEDISK, DT_REMOVABLEDISK },
    { HWDTS_FIXEDDISK    , DT_FIXEDDISK },
    { HWDTS_CDROM        , DT_CDROM },
};

static const TWODWORDS drivetypemappingusingGDT[] =
{
    { DRIVE_REMOVABLE    , DT_REMOVABLEDISK },
    { DRIVE_FIXED        , DT_FIXEDDISK },
    { DRIVE_RAMDISK      , DT_FIXEDDISK },
    { DRIVE_CDROM        , DT_CDROM },
};

static const TWODWORDS cdtypemappings[] =
{
    { HWDDC_CDROM        , DT_CDROM },
    { HWDDC_CDRECORDABLE , DT_CDR },
    { HWDDC_CDREWRITABLE , DT_CDRW },
    { HWDDC_DVDROM       , DT_DVDROM },
    { HWDDC_DVDRECORDABLE, DT_DVDR },
    { HWDDC_DVDREWRITABLE, DT_DVDRW },
    { HWDDC_DVDRAM       , DT_DVDRAM },
};

DWORD CMtPtLocal::_GetMTPTDriveType()
{
    DWORD dwRet = 0;
    
    if (_CanUseVolume())
    {
        dwRet = _DoDWORDMapping(_pvol->dwDriveType, drivetypemappings,
            ARRAYSIZE(drivetypemappings), TRUE);

        if (DT_CDROM == dwRet)
        {
            DWORD dwDriveCapabilities;
            DWORD dwMediaCapabilities;

            if (SUCCEEDED(CDBurn_GetCDInfo(_pvol->pszVolumeGUID, &dwDriveCapabilities, &dwMediaCapabilities)))
            {
                dwRet |= _DoDWORDMapping(dwDriveCapabilities, cdtypemappings,
                    ARRAYSIZE(cdtypemappings), TRUE);
            }
        }
    }
    else
    {
        dwRet = _DoDWORDMapping(GetDriveType(_GetNameForFctCall()), drivetypemappingusingGDT,
            ARRAYSIZE(drivetypemappingusingGDT), FALSE);
    }

    return dwRet;
}

/* TBD
        CT_UNKNOWNCONTENT              0x00000008

        CT_AUTOPLAYMUSIC               0x00000100
        CT_AUTOPLAYPIX                 0x00000200
        CT_AUTOPLAYMOVIE               0x00000400*/
static const TWODWORDS contenttypemappings[] =
{
    { HWDMC_HASAUTORUNINF, CT_AUTORUNINF },
    { HWDMC_HASAUDIOTRACKS, CT_CDAUDIO },
    { HWDMC_HASDVDMOVIE, CT_DVDMOVIE },
};

static const TWODWORDS blankmediamappings[] =
{
    { HWDMC_CDRECORDABLE, CT_BLANKCDR },
    { HWDMC_CDREWRITABLE, CT_BLANKCDRW },
    { HWDMC_DVDRECORDABLE, CT_BLANKDVDR },
    { HWDMC_DVDREWRITABLE, CT_BLANKDVDRW },
};

DWORD CMtPtLocal::_GetMTPTContentType()
{
    DWORD dwRet = 0;
    
    if (_CanUseVolume())
    {
        dwRet = _DoDWORDMapping(_pvol->dwMediaCap, contenttypemappings,
            ARRAYSIZE(contenttypemappings), TRUE);

        if (!(_pvol->dwMediaState & HWDMS_FORMATTED))
        {
            ASSERT(!dwRet);

            DWORD dwDriveCapabilities;
            DWORD dwMediaCapabilities;

            if (_IsCDROM())
            {
                if (SUCCEEDED(CDBurn_GetCDInfo(_pvol->pszVolumeGUID, &dwDriveCapabilities, &dwMediaCapabilities)))
                {
                    dwRet = _DoDWORDMapping(dwMediaCapabilities, blankmediamappings,
                        ARRAYSIZE(blankmediamappings), TRUE);
                }
            }
        }
        else
        {
            dwRet |= CT_UNKNOWNCONTENT;
        }
    }
    else
    {
        // If there's no _pvol, we care only about autorun.inf
        if (_IsAutorun())
        {
            dwRet = CT_AUTORUNINF;
        }

        if (_IsFormatted())
        {
            dwRet |= CT_UNKNOWNCONTENT;
        }
    }
    
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\msgbox.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "uemapp.h"

#define MAXRCSTRING 514

// Major hack follows to get this to work with the DEBUG alloc/free -- on NT
// Local and Global heap functions evaluate to the same heap.  The problem
// here is that LocalFree gets mapped to DebugLocalFree, but when we
// call FormatMessage, the buffer is not allocated through DebugLocalAlloc,
// so it dies.
//
#ifdef DEBUG
#undef LocalFree
#define LocalFree GlobalFree
#endif

// this will check to see if lpcstr is a resource id or not.  if it
// is, it will return a LPSTR containing the loaded resource.
// the caller must LocalFree this lpstr.  if pszText IS a string, it
// will return pszText
//
// returns:
//      pszText if it is already a string
//      or
//      LocalAlloced() memory to be freed with LocalFree
//      if pszRet != pszText free pszRet

LPTSTR WINAPI ResourceCStrToStr(HINSTANCE hInst, LPCTSTR pszText)
{
    TCHAR szTemp[MAXRCSTRING];
    LPTSTR pszRet = NULL;

    if (!IS_INTRESOURCE(pszText))
        return (LPTSTR)pszText;

    if (LOWORD((DWORD_PTR)pszText) && LoadString(hInst, LOWORD((DWORD_PTR)pszText), szTemp, ARRAYSIZE(szTemp)))
    {
        pszRet = LocalAlloc(LPTR, (lstrlen(szTemp) + 1) * SIZEOF(TCHAR));
        if (pszRet)
            lstrcpy(pszRet, szTemp);
    }
    return pszRet;
}
#ifdef UNICODE
LPSTR ResourceCStrToStrA(HINSTANCE hInst, LPCSTR pszText)
{
    CHAR szTemp[MAXRCSTRING];
    LPSTR pszRet = NULL;

    if (!IS_INTRESOURCE(pszText))
        return (LPSTR)pszText;

    if (LOWORD((DWORD_PTR)pszText) && LoadStringA(hInst, LOWORD((DWORD_PTR)pszText), szTemp, ARRAYSIZE(szTemp)))
    {
        pszRet = LocalAlloc(LPTR, (lstrlenA(szTemp) + 1) * SIZEOF(CHAR));
        if (pszRet)
            lstrcpyA(pszRet, szTemp);
    }
    return pszRet;
}
#else
LPWSTR ResourceCStrToStrW(HINSTANCE hInst, LPCWSTR pszText)
{
    return NULL;        // Error condition
}
#endif

LPTSTR _ConstructMessageString(HINSTANCE hInst, LPCTSTR pszMsg, va_list *ArgList)
{
    LPTSTR pszRet;
    LPTSTR pszRes = ResourceCStrToStr(hInst, pszMsg);
    if (!pszRes)
    {
        DebugMsg(DM_ERROR, TEXT("_ConstructMessageString: Failed to load string template"));
        return NULL;
    }

    if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                       pszRes, 0, 0, (LPTSTR)&pszRet, 0, ArgList))
    {
        DebugMsg(DM_ERROR, TEXT("_ConstructMessageString: FormatMessage failed %d"),GetLastError());
        DebugMsg(DM_ERROR, TEXT("                         pszRes = %s"), pszRes );
        DebugMsg(DM_ERROR, !IS_INTRESOURCE(pszMsg) ? 
        TEXT("                         pszMsg = %s") : 
        TEXT("                         pszMsg = 0x%x"), pszMsg );
        pszRet = NULL;
    }

    if (pszRes != pszMsg)
        LocalFree(pszRes);

    return pszRet;      // free with LocalFree()
}

#ifdef UNICODE
LPSTR _ConstructMessageStringA(HINSTANCE hInst, LPCSTR pszMsg, va_list *ArgList)
{
    LPSTR pszRet;
    LPSTR pszRes = ResourceCStrToStrA(hInst, pszMsg);
    if (!pszRes)
    {
        DebugMsg(DM_ERROR, TEXT("_ConstructMessageString: Failed to load string template"));
        return NULL;
    }

    if (!FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                       pszRes, 0, 0, (LPSTR)&pszRet, 0, ArgList))
    {
        DebugMsg(DM_ERROR, TEXT("_ConstructMessageString: FormatMessage failed %d"),GetLastError());
        DebugMsg(DM_ERROR, TEXT("                         pszRes = %S"), pszRes );

        DebugMsg(DM_ERROR, !IS_INTRESOURCE(pszMsg) ? 
        TEXT("                         pszMsg = %s") : 
        TEXT("                         pszMsg = 0x%x"), pszMsg );
        pszRet = NULL;
    }

    if (pszRes != pszMsg)
        LocalFree(pszRes);

    return pszRet;      // free with LocalFree()
}
#else
LPWSTR _ConstructMessageStringW(HINSTANCE hInst, LPCWSTR pszMsg, va_list *ArgList)
{
    return NULL;    // Error condition
}
#endif


// NOTE: ShellMessageBoxW has been re-implemented in shlwapi, so shell32 redirects that api there
// Shlwapi doesn't need an A version (because it's in shell32), so we're leaving this code here...
// 
int WINCAPI ShellMessageBoxA(HINSTANCE hInst, HWND hWnd, LPCSTR pszMsg, LPCSTR pszTitle, UINT fuStyle, ...)
{
    LPSTR pszText;
    int result;
    CHAR szBuffer[80];
    va_list ArgList;

    // BUG 95214
#ifdef DEBUG
    IUnknown* punk = NULL;
    if (SUCCEEDED(SHGetThreadRef(&punk)) && punk)
    {
        ASSERTMSG(hWnd != NULL, "shell32\\msgbox.c : ShellMessageBoxA - Caller should either be not under a browser or should have a parent hwnd");
        punk->lpVtbl->Release(punk);
    }
#endif

    if (!IS_INTRESOURCE(pszTitle))
    {
        // do nothing
    }
    else if (LoadStringA(hInst, LOWORD((DWORD_PTR)pszTitle), szBuffer, ARRAYSIZE(szBuffer)))
    {
        // Allow this to be a resource ID or NULL to specifiy the parent's title
        pszTitle = szBuffer;
    }
    else if (hWnd)
    {
        // Grab the title of the parent
        GetWindowTextA(hWnd, szBuffer, ARRAYSIZE(szBuffer));

        //
        //  we would rather not use the "Desktop" as our title,
        //  but sometimes that is the window that is used, and we dont
        //  have a better title.  callers should review to make sure that
        //  they want "Desktop" as the title to the dialog in 
        //  the case that the hwnd passed in is the desktop window.
        //
        if (!lstrcmpA(szBuffer, "Program Manager")) 
        {
            LoadStringA(HINST_THISDLL, IDS_DESKTOP, szBuffer, ARRAYSIZE(szBuffer));
            pszTitle = szBuffer;
            DebugMsg(TF_WARNING, TEXT("No caption for SHMsgBox() on desktop"));
        } 
        else
            pszTitle = szBuffer;
    }
    else
    {
        pszTitle = "";
    }

    va_start(ArgList, fuStyle);
    pszText = _ConstructMessageStringA(hInst, pszMsg, &ArgList);
    va_end(ArgList);

    if (pszText)
    {
        result = MessageBoxA(hWnd, pszText, pszTitle, fuStyle | MB_SETFOREGROUND);
        LocalFree(pszText);
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("smb: Not enough memory to put up dialog."));
        result = -1;    // memory failure
    }

    return result;
}


//
// returns:
//      pointer to formatted string, free this with SHFree() (not Free())
//

LPTSTR WINCAPI ShellConstructMessageString(HINSTANCE hInst, LPCTSTR pszMsg, ...)
{
    LPTSTR pszRet;
    va_list ArgList;

    va_start(ArgList, pszMsg);

    pszRet = _ConstructMessageString(hInst, pszMsg, &ArgList);

    va_end(ArgList);

    return pszRet;      // free with SHFree()
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mtptarun2.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "ids.h"
#include "mtptl.h"
#include "hwcmmn.h"
#include "datautil.h"

// for now
#include "mixctnt.h"

#include "filetbl.h"
#include "apprmdlg.h"

#include "views.h"

#include <ddraw.h>

CDPA<PNPNOTIFENTRY>     CSniffDrive::_dpaNotifs = NULL;
HANDLE                  CSniffDrive::_hThreadSCN = NULL;
HWND                    CSniffDrive::_hwndNotify = NULL;


//
//  if a drive has a AutoRun.inf file and AutoRun is not restricted in
//  the registry.  copy the AutoRun info into a key in the registry.
//
//  HKEY_CLASSES_ROOT\AutoRun\0   (0=A,1=B,...)
//
//  the key is a standard ProgID key, has DefaultIcon, shell, shellex, ...
//
//  the autorun file looks like this....
//
//  [AutoRun]
//      key = value
//      key = value
//      key = value
//
//  examples:
//
//    [AutoRun]
//      DefaultIcon = foo.exe,1
//      shell=myverb
//      shell\myverb = &MyVerb
//      shell\myverb\command = myexe.exe
//
//      will give the drive a icon from 'foo.exe'
//      add a verb called myverb (with name "&My Verb")
//      and make myverb default.
//
//    [AutoRun]
//      shell\myverb = &MyVerb
//      shell\myverb\command = myexe.exe
//
//      add a verb called myverb (with name "&My Verb")
//      verb will not be default.
//
//  any thing they add will be copied over, they can add wacky things
//  like CLSID's or shellx\ContextMenuHandlers and it will work.
//
//  or they can just copy over data the app will look at later.
//
//  the following special cases will be supported....
//
//    [AutoRun]
//      Open = command.exe /params
//      Icon = iconfile, iconnumber
//
//  will be treated like:
//
//    [AutoRun]
//      DefaultIcon = iconfile, iconnumber
//      shell = AutoRun
//      shell\AutoRun = Auto&Play
//      shell\AutoRun\command = command.exe /params
//
//
// This function tries to take care of the case that a command was registered
// in the autrun file of a cdrom.  If the command is relative than see if the
// command exists on the CDROM
void CMountPoint::_QualifyCommandToDrive(LPTSTR pszCommand)
{
    // for now we assume that we'll call this only for CD mounted on a drive letter
    // (by oppoition to a folder)

    if (_IsMountedOnDriveLetter())
    {
        TCHAR szImage[MAX_PATH];

        lstrcpy(szImage, pszCommand);

        PathRemoveArgs(szImage);
        PathUnquoteSpaces(szImage);

        if (PathIsRelative(szImage))
        {
            TCHAR szFinal[MAX_PATH];
            LPTSTR pszTmp = szImage;

            lstrcpy(szFinal, _GetName());

            // do simple check for command, check for "..\abc" or "../abc"
            while ((TEXT('.') == *pszTmp) && (TEXT('.') == *(pszTmp + 1)) &&
                ((TEXT('\\') == *(pszTmp + 2)) || (TEXT('/') == *(pszTmp + 2))))
            {
                pszTmp += 3;
            }

            lstrcatn(szFinal, pszTmp, ARRAYSIZE(szFinal));

            // we first check if it exists on the CD
            DWORD dwAttrib = GetFileAttributes(szFinal);

            if (0xFFFFFFFF == dwAttrib)
            {
                // It's not on the CD, try appending ".exe"

                lstrcatn(szFinal, TEXT(".exe"), ARRAYSIZE(szFinal));

                dwAttrib = GetFileAttributes(szFinal);
            }

            if (0xFFFFFFFF != dwAttrib)
            {
                // Yes, it's on the CD
                PathQuoteSpaces(szFinal);

                LPTSTR pszArgs = PathGetArgs(pszCommand);
                if (pszArgs && *pszArgs)
                    lstrcatn(szFinal, pszArgs - 1, ARRAYSIZE(szFinal));

                // MAX_PATH: educated guess
                lstrcpyn(pszCommand, szFinal, MAX_PATH);
            }
            else
            {
                // No, not on the CD
            }
        } 
    }
}

// This one does not hit the drive
BOOL CMountPoint::_IsAutoRunDrive()
{
    BOOL fRet = TRUE;

    // Add support for now drive letter
    if (_IsMountedOnDriveLetter())
    {
        int iDrive = DRIVEID(_GetName());    

        // Restrict auto-run's to particular drives.
        if (SHRestricted(REST_NODRIVEAUTORUN) & (1 << iDrive))
        {
            fRet = FALSE;
        }
    }

    if (fRet)
    {
        UINT uDriveType = _GetDriveType();

        // Restrict auto-run's to particular types of drives.
        if (SHRestricted(REST_NODRIVETYPEAUTORUN) & (1 << (uDriveType & DRIVE_TYPE)))
        {
            fRet = FALSE;
        }
        else
        {
            if (DRIVE_UNKNOWN == (uDriveType & DRIVE_TYPE))
            {
                fRet = FALSE;
            }
        }

        if (fRet && _IsFloppy())
        {
            fRet = FALSE;
        }
    }

    return fRet;
}

HRESULT CMountPoint::_AddAutoplayVerb()
{
    HRESULT hr = E_FAIL;

    if (RSSetTextValue(TEXT("shell\\Autoplay\\DropTarget"), TEXT("CLSID"),
        TEXT("{f26a669a-bcbb-4e37-abf9-7325da15f931}"), REG_OPTION_NON_VOLATILE))
    {
        // IDS_MENUAUTORUN -> 8504
        if (RSSetTextValue(TEXT("shell\\Autoplay"), TEXT("MUIVerb"),
            TEXT("@shell32.dll,-8504"), REG_OPTION_NON_VOLATILE))
        {
            if (RSSetTextValue(TEXT("shell"), NULL, TEXT("None"), REG_OPTION_NON_VOLATILE))
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}

HRESULT CMountPoint::_CopyInvokeVerbKey(LPCWSTR pszProgID, LPCWSTR pszVerb)
{
    ASSERT(pszProgID);
    ASSERT(pszVerb);
    WCHAR szKey[MAX_PATH];

    HRESULT hr = E_FAIL;

    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("shell\\%s"), pszVerb);

    HKEY hkeyNew = RSDuplicateSubKey(szKey, TRUE, FALSE);

    if (hkeyNew)
    {
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\shell\\%s"), pszProgID, pszVerb);

        if (ERROR_SUCCESS == SHCopyKey(HKEY_CLASSES_ROOT, szKey, hkeyNew, 0))
        {
            if (RSSetTextValue(TEXT("shell"), NULL, pszVerb, REG_OPTION_NON_VOLATILE))
            {
                hr = S_OK;
            }
        }

        RegCloseKey(hkeyNew);
    }

    return hr;
}

BOOL CMountPoint::_ProcessAutoRunFile()
{
    BOOL fRet = TRUE;

    if (!_fAutorunFileProcessed)
    {
        BOOL fProcessFile = FALSE;

        if (_IsCDROM())
        {
            CMtPtLocal* pmtptlocal = (CMtPtLocal*)this;

            // not CDs with no media, or no autorun.inf files
            if (pmtptlocal->_IsMediaPresent())
            {
                if (!pmtptlocal->_CanUseVolume())
                {
                    fProcessFile = TRUE;
                }
                else
                {
                    if ((HWDMC_HASAUTORUNINF & pmtptlocal->_pvol->dwMediaCap) &&
                        !(HWDMC_HASUSEAUTOPLAY & pmtptlocal->_pvol->dwMediaCap))
                    {
                        fProcessFile = TRUE;
                    }
                }
            }
        }
        else
        {
            if (_IsRemote())
            {
                fProcessFile = TRUE;
            }
            else
            {
                if (_IsFixedDisk())
                {
                    fProcessFile = TRUE;
                }
            }
        }

        if (fProcessFile)
        {
            LPCTSTR pszSection;
            TCHAR szInfFile[MAX_PATH];
            TCHAR szKeys[512];
            TCHAR szValue[MAX_PATH];
            TCHAR szIcon[MAX_PATH + 12]; // MAX_PATH + room for ",1000000000" (for icon index part)
            LPTSTR pszKey;
            int iDrive = 0;

            RSDeleteSubKey(TEXT("Shell"));

            if (_IsMountedOnDriveLetter())
            {
                iDrive = DRIVEID(_GetName());
            }

            // build abs path to AutoRun.inf
            lstrcpyn(szInfFile, _GetName(), ARRAYSIZE(szInfFile));
            lstrcat(szInfFile, TEXT("AutoRun.inf"));

#if defined(_X86_)
    pszSection = TEXT("AutoRun.x86");
#elif defined(_IA64_)
    pszSection = TEXT("AutoRun.Ia64");
#elif defined(_AMD64_)
    pszSection = TEXT("AutoRun.Amd64");
#endif
            //
            // make sure a file exists before calling GetPrivateProfileString
            // because for some media this check might take a long long time
            // and we dont want to have kernel wait wiht the Win16Lock
            //
            UINT err = SetErrorMode(SEM_FAILCRITICALERRORS);

            if (!PathFileExistsAndAttributes(szInfFile, NULL))
            {
                SetErrorMode(err);
                _fAutorunFileProcessed = TRUE;

                return FALSE;
            }

            //
            // get all the keys in the [AutoRun] section
            //

            // Flush the INI cache, or this may fail during a Device broadcast
            WritePrivateProfileString(NULL, NULL, NULL, szInfFile);

        #if defined(_X86_)
            pszSection = TEXT("AutoRun.x86");
        #elif defined(_IA64_)
            pszSection = TEXT("AutoRun.Ia64");
        #endif

            int i = GetPrivateProfileString(pszSection, NULL, c_szNULL, szKeys, ARRAYSIZE(szKeys), szInfFile);

            // if we fail to find a platform-specific AutoRun section, fall
            // back to looking for the naked "AutoRun" section.
            if (0 == i)
            {
                pszSection = TEXT("AutoRun");
                i = GetPrivateProfileString(pszSection, NULL, c_szNULL, szKeys, ARRAYSIZE(szKeys), szInfFile);
            }

            SetErrorMode(err);

            if (i >= 4)
            {
                //
                // make sure the external strings are what we think.
                //
                ASSERT(lstrcmpi(c_szOpen,TEXT("open")) == 0);
                ASSERT(lstrcmpi(c_szShell, TEXT("shell")) == 0);

                //  now walk all the keys in the .inf file and copy them to the registry.

                for (pszKey = szKeys; *pszKey; pszKey += lstrlen(pszKey) + 1)
                {
                    GetPrivateProfileString(pszSection, pszKey,
                        c_szNULL, szValue, ARRAYSIZE(szValue), szInfFile);

                    //
                    //  special case open =
                    //
                    if (lstrcmpi(pszKey, c_szOpen) == 0)
                    {
                        if (_IsMountedOnDriveLetter())
                        {
                            RSSetTextValue(c_szShell, NULL, TEXT("AutoRun"));

                            _QualifyCommandToDrive(szValue);
                            RSSetTextValue(TEXT("shell\\AutoRun\\command"), NULL, szValue);

                            LoadString(HINST_THISDLL, IDS_MENUAUTORUN, szValue, ARRAYSIZE(szValue));
                            RSSetTextValue(TEXT("shell\\AutoRun"), NULL, szValue);
                        }
                    }
                    //
                    //  special case ShellExecute
                    //
                    else if (lstrcmpi(pszKey, TEXT("ShellExecute")) == 0)
                    {
                        if (_IsMountedOnDriveLetter())
                        {
                            TCHAR szPath[MAX_PATH];

                            StrCpyN(szPath, TEXT("RunDLL32.EXE Shell32.DLL,ShellExec_RunDLL "), ARRAYSIZE(szPath));
                            StrCatBuff(szPath, szValue, ARRAYSIZE(szPath));

                            RSSetTextValue(c_szShell, NULL, TEXT("AutoRun"));

                            RSSetTextValue(TEXT("shell\\AutoRun\\command"), NULL, szPath);

                            LoadString(HINST_THISDLL, IDS_MENUAUTORUN, szValue, ARRAYSIZE(szValue));
                            RSSetTextValue(TEXT("shell\\AutoRun"), NULL, szValue);
                        }
                    }
                    //
                    //  special case icon =
                    //  make sure the icon file has a full path...
                    //
                    else if (lstrcmpi(pszKey, TEXT("Icon")) == 0)
                    {
                        lstrcpyn(szIcon, _GetName(), ARRAYSIZE(szIcon));
                        lstrcatn(szIcon, szValue, ARRAYSIZE(szIcon));

                        RSSetTextValue(TEXT("_Autorun\\DefaultIcon"), NULL, szIcon);
                    }
                    //
                    //  special case label =
                    //  make sure the label file has a full path...
                    //
                    else if (lstrcmpi(pszKey, TEXT("Label")) == 0)
                    {
                        RSSetTextValue(TEXT("_Autorun\\DefaultLabel"), NULL, szValue);
                    }
                    //
                    //  special case shell = open
                    //  We have an autorun file but this puts open as the default verb
                    //  so we force it to be Autorun
                    //
                    else if (!lstrcmpi(pszKey, TEXT("shell")) && !lstrcmpi(szValue, TEXT("open")))
                    {
                        if (_IsMountedOnDriveLetter())
                        {
                            RSSetTextValue(pszKey, NULL, TEXT("Autorun"));
                        }
                    }
                    //
                    //  it is just a key/value pair copy it over.
                    //
                    else
                    {
                        if (_IsMountedOnDriveLetter())
                        {
                            if (lstrcmpi(PathFindFileName(pszKey), c_szCommand) == 0)
                                _QualifyCommandToDrive(szValue);

                            RSSetTextValue(pszKey, NULL, szValue);
                        }
                    }
                }
            }
            else
            {
                fRet = FALSE;
            }
        }

        _fAutorunFileProcessed = TRUE;
    }

    return fRet;
}

// sends the "QueryCancelAutoPlay" msg to the window to see if it wants
// to cancel the autoplay. useful for dialogs that are prompting for disk
// inserts or cases where the app wants to capture the event and not let
// other apps be run

// static
BOOL CMountPoint::_AppAllowsAutoRun(HWND hwndApp, CMountPoint* pmtpt)
{
    ULONG_PTR dwCancel = 0;

    DWORD dwType = pmtpt->_GetAutorunContentType();
    WCHAR cDrive = pmtpt->_GetNameFirstCharUCase();

    int iDrive = cDrive - TEXT('A');

    SendMessageTimeout(hwndApp, QueryCancelAutoPlayMsg(), iDrive, dwType, SMTO_NORMAL | SMTO_ABORTIFHUNG,
        1000, &dwCancel);

    return (dwCancel == 0);
}

STDAPI SHCreateQueryCancelAutoPlayMoniker(IMoniker** ppmoniker)
{
    return CreateClassMoniker(CLSID_QueryCancelAutoPlay, ppmoniker);
}

struct QUERRYRUNNINGOBJECTSTRUCT
{
    WCHAR szMountPoint[MAX_PATH];
    DWORD dwContentType;
    WCHAR szLabel[MAX_LABEL];
    DWORD dwSerialNumber;
};

BOOL _RegValueExist(HKEY hkey, LPCWSTR pszKey, LPCWSTR pszValue)
{
    BOOL fRet = FALSE;
    HKEY hkeySub;

    if (ERROR_SUCCESS == RegOpenKeyEx(hkey, pszKey, 0, MAXIMUM_ALLOWED, &hkeySub))
    {
        fRet = (RegQueryValueEx(hkeySub, pszValue, 0, NULL, NULL, NULL) ==
            ERROR_SUCCESS);

        RegCloseKey(hkeySub);
    }
    
    return fRet;
}

BOOL _ShouldQueryMoniker(IMoniker* pmoniker, IBindCtx* pbindctx)
{
    BOOL fRet = FALSE;
    DWORD dwMkSys;

    HRESULT hr = pmoniker->IsSystemMoniker(&dwMkSys);

    if (S_OK == hr)
    {
        // Is it a class moniker?
        if (MKSYS_CLASSMONIKER == dwMkSys)
        {
            // Yes
            LPWSTR pszDisplayName;

            hr = pmoniker->GetDisplayName(pbindctx, NULL, &pszDisplayName);

            if (SUCCEEDED(hr))
            {
                // We should get a "clsid:331F1768-05A9-4ddd-B86E-DAE34DDC998A:"

                // 37, because we do not have brackets and to explicitly truncate the trailing ":"
                WCHAR szCLSID[37];

                // The "+ 6" skips the "clsid:" part
                StrCpyN(szCLSID, pszDisplayName + 6, ARRAYSIZE(szCLSID));

                fRet = _RegValueExist(HKEY_LOCAL_MACHINE, 
                    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoplayHandlers\\CancelAutoplay\\CLSID"),
                    szCLSID);

                CoTaskMemFree(pszDisplayName);
            }
        }

    }

    return fRet;
}

DWORD WINAPI _QueryRunningObjectThreadProc(void* pv)
{
    QUERRYRUNNINGOBJECTSTRUCT* pqro = (QUERRYRUNNINGOBJECTSTRUCT*)pv;

    HRESULT hrRet = S_OK;
    HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        IRunningObjectTable* prot;

        hr = GetRunningObjectTable(0, &prot);

        if (SUCCEEDED(hr))
        {
            IMoniker* pmoniker;
            IBindCtx* pbindctx;

            hr = CreateBindCtx(0, &pbindctx);

            if (SUCCEEDED(hr))
            {
                BIND_OPTS2 bindopts;

                ZeroMemory(&bindopts, sizeof(bindopts));

                bindopts.cbStruct = sizeof(bindopts);
                bindopts.dwClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD;

                hr = pbindctx->SetBindOptions(&bindopts);

                if (SUCCEEDED(hr))
                {
                    HKEY hkey;

                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoplayHandlers\\CancelAutoplay\\CLSID"),
                        0, MAXIMUM_ALLOWED, &hkey))
                    {
                        DWORD dwIndex = 0;
                        WCHAR szCLSID[39] = TEXT("{");
                        DWORD cchCLSID = ARRAYSIZE(szCLSID) - 1;

                        while ((S_FALSE != hrRet) &&
                            (ERROR_SUCCESS == RegEnumValue(hkey, dwIndex, &(szCLSID[1]),
                            &cchCLSID, 0, 0, 0, 0)))
                        {
                            CLSID clsid;

                            szCLSID[37] = TEXT('}');
                            szCLSID[38] = 0;

                            hr = CLSIDFromString(szCLSID, &clsid);

                            if (SUCCEEDED(hr))
                            {
                                IMoniker* pmoniker;

                                // Create the moniker that we'll put in the ROT
                                hr = CreateClassMoniker(clsid, &pmoniker);

                                if (SUCCEEDED(hr))
                                {
                                    IUnknown* punk;

                                    hr = prot->GetObject(pmoniker, &punk);

                                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                                    {
                                        IQueryCancelAutoPlay* pqca;
                                        hr = punk->QueryInterface(IID_PPV_ARG(IQueryCancelAutoPlay, &pqca));

                                        if (SUCCEEDED(hr))
                                        {
                                            hrRet = pqca->AllowAutoPlay(pqro->szMountPoint, pqro->dwContentType,
                                                pqro->szLabel, pqro->dwSerialNumber);

                                            pqca->Release();
                                        }

                                        punk->Release();
                                    }

                                    pmoniker->Release();
                                }
                            }

                            ++dwIndex;
                            cchCLSID = ARRAYSIZE(szCLSID) - 1;
                        }

                        RegCloseKey(hkey);
                    }
                }

                pbindctx->Release();
            }

            if (S_FALSE != hrRet)
            {
                // This case is to support WMP and CD burning.  We did not get to replace
                // their cancel logic before shipping.
                hr = SHCreateQueryCancelAutoPlayMoniker(&pmoniker);

                if (SUCCEEDED(hr))
                {
                    IUnknown* punk;

                    hr = prot->GetObject(pmoniker, &punk);

                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                    {
                        IQueryCancelAutoPlay* pqca;
                        hr = punk->QueryInterface(IID_PPV_ARG(IQueryCancelAutoPlay, &pqca));

                        if (SUCCEEDED(hr))
                        {
                            hrRet = pqca->AllowAutoPlay(pqro->szMountPoint, pqro->dwContentType,
                                pqro->szLabel, pqro->dwSerialNumber);

                            pqca->Release();
                        }

                        punk->Release();
                    }

                    pmoniker->Release();
                }
            }

            prot->Release();
        }

        CoUninitialize();
    }

    LocalFree((HLOCAL)pqro);

    return (DWORD)hrRet;
}

// static
HRESULT CMountPoint::_QueryRunningObject(CMountPoint* pmtpt, DWORD dwAutorunContentType, BOOL* pfAllow)
{
    *pfAllow = TRUE;

    QUERRYRUNNINGOBJECTSTRUCT *pqro;
    HRESULT hr = SHLocalAlloc(sizeof(*pqro), &pqro);
    if (SUCCEEDED(hr))
    {
        WCHAR szLabel[MAX_LABEL];

        if (!(ARCONTENT_BLANKCD & dwAutorunContentType) &&
            !(ARCONTENT_BLANKDVD & dwAutorunContentType))
        {
            if (pmtpt->_GetGVILabel(szLabel, ARRAYSIZE(szLabel)))
            {
                lstrcpyn(pqro->szLabel, szLabel, ARRAYSIZE(pqro->szLabel));

                pmtpt->_GetSerialNumber(&(pqro->dwSerialNumber));
            }
        }

        lstrcpyn(pqro->szMountPoint, pmtpt->_GetName(), ARRAYSIZE(pqro->szMountPoint));
        pqro->dwContentType = dwAutorunContentType;

        HANDLE hThread = CreateThread(NULL, 0, _QueryRunningObjectThreadProc, 
            pqro, 0, NULL);

        if (hThread)
        {
            // thread now owns these guys, NULL them out to avoid dbl free
            pqro = NULL;    // don't free this below

            hr = S_FALSE;
            
            // Wait 3 sec to see if wants to process it.  If not, it's
            // fair play for us.
            DWORD dwWait = WaitForSingleObject(hThread, 3000);

            if (WAIT_OBJECT_0 == dwWait)
            {
                // Return within time and did not failed
                DWORD dwExitCode;

                if (GetExitCodeThread(hThread, &dwExitCode))
                {
                    HRESULT hrHandlesEvent = (HRESULT)dwExitCode;
    
                    // Will return S_FALSE if they do NOT allow AutoRun
                    if (SUCCEEDED(hrHandlesEvent) && (S_FALSE == hrHandlesEvent))
                    {
                        *pfAllow = FALSE;
                    }

                    hr = S_OK;
                }
            }
            CloseHandle(hThread);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        LocalFree((HLOCAL)pqro);    // may be NULL
    }

    return hr;
}

CAutoPlayParams::CAutoPlayParams(LPCWSTR pszDrive, CMountPoint* pMtPt, DWORD dwAutorunFlags)
    :   _pszDrive(pszDrive), 
        _pmtpt(pMtPt), 
        _dwAutorunFlags(dwAutorunFlags),
        _state(APS_RESET),
        _pdo(NULL),
        _fCheckAlwaysDoThisCheckBox(FALSE)
{
    _dwDriveType = pMtPt->_GetMTPTDriveType();
    _dwContentType = pMtPt->_GetMTPTContentType();

    if (DT_ANYLOCALDRIVES & _dwDriveType)
        _pmtptl = (CMtPtLocal*)pMtPt;
    else
        _pmtptl = NULL;

    //  maybe assert on these?
}

BOOL CAutoPlayParams::_ShouldSniffDrive(BOOL fCheckHandlerDefaults)
{
    BOOL fSniff = FALSE;

    if (_pmtptl)
    {
        if (CT_AUTORUNINF & _dwContentType)
        {
            if (_pmtptl->_CanUseVolume())
            {
                if (_pmtptl->_pvol->dwMediaCap & HWDMC_HASUSEAUTOPLAY)
                {
                    fSniff = TRUE;
                }
            }
        }
        else
        {
            fSniff = TRUE;
        }

        if (fSniff)
        {
            fSniff = FALSE;
            
            if (!((CT_CDAUDIO | CT_DVDMOVIE) & _dwContentType))
            {
                if (_pmtptl->_CanUseVolume())
                {
                    if (!(HWDVF_STATE_HASAUTOPLAYHANDLER & _pmtptl->_pvol->dwVolumeFlags) &&
                        !(HWDVF_STATE_DONOTSNIFFCONTENT & _pmtptl->_pvol->dwVolumeFlags))
                    {
                        if (AUTORUNFLAG_MENUINVOKED & _dwAutorunFlags)
                        {
                            fSniff = TRUE;
                        }
                        else if (DT_FIXEDDISK & _dwDriveType)
                        {
                            if (HWDDC_REMOVABLEDEVICE & _pmtptl->_pvol->dwDriveCapability)
                            {
                                fSniff = TRUE;
                            }
                        }
                        else
                        {
                            if (AUTORUNFLAG_MEDIAARRIVAL & _dwAutorunFlags)
                            {
                                fSniff = TRUE;
                            }
                            else
                            {
                                if (AUTORUNFLAG_MTPTARRIVAL & _dwAutorunFlags)
                                {
                                    if (HWDDC_REMOVABLEDEVICE & _pmtptl->_pvol->dwDriveCapability)
                                    {
                                        fSniff = TRUE;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if (fSniff && fCheckHandlerDefaults)
    {
        // Let's make sure the user did not pick "Take no action" for all Autoplay
        // content types, it would be useless to sniff.
        BOOL fAllTakeNoAction = TRUE;

        DWORD rgdwContentType[] =
        {
            CT_AUTOPLAYMUSIC,
            CT_AUTOPLAYPIX,
            CT_AUTOPLAYMOVIE,
            CT_AUTOPLAYMUSIC | CT_AUTOPLAYPIX | CT_AUTOPLAYMOVIE, // Mix content
        };

        for (DWORD dw = 0; fAllTakeNoAction && (dw < ARRAYSIZE(rgdwContentType)); ++dw)
        {
            WCHAR szContentTypeHandler[MAX_CONTENTTYPEHANDLER];

            DWORD dwMtPtContentType = rgdwContentType[dw];

            HRESULT hr = _GetContentTypeHandler(dwMtPtContentType, szContentTypeHandler, ARRAYSIZE(szContentTypeHandler));
            if (SUCCEEDED(hr))
            {
                IAutoplayHandler* piah;

                hr = _GetAutoplayHandler(Drive(), TEXT("ContentArrival"), szContentTypeHandler, &piah);

                if (SUCCEEDED(hr))
                {
                    LPWSTR pszHandlerDefault;

                    hr = piah->GetDefaultHandler(&pszHandlerDefault);

                    if (SUCCEEDED(hr))
                    {
                        if (HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED &
                            HANDLERDEFAULT_GETFLAGS(hr))
                        {
                            fAllTakeNoAction = FALSE;
                        }
                        else
                        {
                            if (lstrcmpi(pszHandlerDefault, TEXT("MSTakeNoAction")))
                            {
                                fAllTakeNoAction = FALSE;
                            }
                        }

                        CoTaskMemFree(pszHandlerDefault);
                    }

                    piah->Release();
                }
            }
        }

        if (fAllTakeNoAction)
        {
            fSniff = FALSE;
        }
    }

    return fSniff;
}

DWORD CAutoPlayParams::ContentType() 
{ 
    return _dwContentType;
}

HRESULT CAutoPlayParams::_InitObjects(IShellFolder **ppsf)
{
    HRESULT hr;
    if (!_pdo || ppsf)
    {
        LPITEMIDLIST pidlFolder;
        hr = SHParseDisplayName(_pszDrive, NULL, &pidlFolder, 0, NULL);
        if (SUCCEEDED(hr))
        {
            hr = SHGetUIObjectOf(pidlFolder, NULL, IID_PPV_ARG(IDataObject, &_pdo));

            ILFree(pidlFolder);
        }
    }
    else
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr) && ppsf)
    {
        //  we need to avoid hitting the burn folder
        //  so we skip junctions for the sniff
        IBindCtx * pbc;
        hr = SHCreateSkipBindCtx(NULL, &pbc);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlFolder;
            hr = SHParseDisplayName(_pszDrive, pbc, &pidlFolder, 0, NULL);
            if (SUCCEEDED(hr))
            {
                hr = SHBindToObjectEx(NULL, pidlFolder, pbc, IID_PPV_ARG(IShellFolder, ppsf));
                ILFree(pidlFolder);
            }
            pbc->Release();
        }
    }        
    return hr;
}

HRESULT CAutoPlayParams::_AddWalkToDataObject(INamespaceWalk* pnsw)
{
    UINT cidl;
    LPITEMIDLIST *apidl;
    HRESULT hr = pnsw->GetIDArrayResult(&cidl, &apidl);
    if (SUCCEEDED(hr))
    {
        //  we need to add this back in
        if (cidl)
        {
            //  ragged array
            HIDA hida = HIDA_Create(&c_idlDesktop, cidl, (LPCITEMIDLIST *)apidl);
            if (hida)
            {
                IDLData_InitializeClipboardFormats(); // init our registerd formats
                //  should we free hida on FAILED?
                DataObj_SetGlobal(_pdo, g_cfAutoPlayHIDA, hida);
            }
        }
        FreeIDListArray(apidl, cidl);
    }
    return hr;
}

HRESULT CAutoPlayParams::_Sniff(DWORD *pdwFound)
{
    //  we found nothing
    HRESULT hr = S_FALSE;
    *pdwFound = 0;

    if (_pmtptl->_CanUseVolume())
    {
        //  setup the IDataObject and IShellFolder for the walk
        IShellFolder *psf;
        HRESULT hr = _InitObjects(&psf);
        if (SUCCEEDED(hr))
        {
            INamespaceWalk* pnsw;
            hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));

            if (SUCCEEDED(hr))
            {
                CSniffDrive sniff;

                hr = sniff.RegisterForNotifs(_pmtptl->_pvol->pszDeviceIDVolume);

                if (SUCCEEDED(hr))
                {
                    // We don't care about the return value.  WE don't want to stop Autorun for as much.
                    // If sniffing fail we go on with what we have.
                    if (SUCCEEDED(pnsw->Walk(psf, NSWF_IGNORE_AUTOPLAY_HIDA | NSWF_DONT_TRAVERSE_LINKS | NSWF_SHOW_PROGRESS, 4, &sniff)))
                    {
                        //  we keep everything we found
                        _AddWalkToDataObject(pnsw);
                    }

                    sniff.UnregisterForNotifs();

                    *pdwFound = sniff.Found();
                }

                pnsw->Release();
            }
            psf->Release();
        }
    }

    return hr;
}

// BEGIN: Fcts for matrix below
//
BOOL CMountPoint::_acShiftKeyDown(HWND , CAutoPlayParams *)
{
    return (GetAsyncKeyState(VK_SHIFT) < 0);
}

BOOL _IsDirectXExclusiveMode()
{
    BOOL fRet = FALSE;

    // This code determines whether a DirectDraw 7 process (game) is running and
    // whether it's exclusively holding the video to the machine in full screen mode.

    // The code is probably to be considered untrusted and hence is wrapped in a
    // __try / __except block. It could AV and therefore bring down shell
    // with it. Not very good. If the code does raise an exception the release
    // call is skipped. Tough. Don't trust the release method either.

    IDirectDraw7 *pIDirectDraw7 = NULL;

    HRESULT hr = CoCreateInstance(CLSID_DirectDraw7, NULL, CLSCTX_INPROC_SERVER,
        IID_IDirectDraw7, (void**)&pIDirectDraw7);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIDirectDraw7);

        __try
        {
            hr = IDirectDraw7_Initialize(pIDirectDraw7, NULL);

            if (DD_OK == hr)
            {
                fRet = (IDirectDraw7_TestCooperativeLevel(pIDirectDraw7) ==
                    DDERR_EXCLUSIVEMODEALREADYSET);
            }

            IDirectDraw7_Release(pIDirectDraw7);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    return fRet;
}

// From a mail regarding the DirectX fct below:
//
// You can definitely count on the following:
//
// (1) If shadow cursors are on, there is definitely not an exclusive mode app running.
// (2) If hot tracking is on, there is definitely not an exclusive mode app running.
// (3) If message boxes for SEM_NOGPFAULTERRORBOX, SEM_FAILCRITICALERRORS, or
//     SEM_NOOPENFILEERRORBOX have not been disabled via SetErrorMode, then there
//     is definitely not an exclusive mode app running.
//
// Note: we cannot use (3) since this is per-process.

BOOL CMountPoint::_acDirectXAppRunningFullScreen(HWND hwndForeground, CAutoPlayParams *)
{
    BOOL fRet = FALSE;
    BOOL fSPI;

    if (SystemParametersInfo(SPI_GETCURSORSHADOW, 0, &fSPI, 0) && !fSPI)
    {
        if (SystemParametersInfo(SPI_GETHOTTRACKING, 0, &fSPI, 0) && !fSPI)
        {
            // There's a chance that a DirectX app is running full screen.  Let's do the
            // expensive DirectX calls that will tell us for sure.
            fRet = _IsDirectXExclusiveMode();
        }
    }

    return fRet;
}

BOOL CMountPoint::_acCurrentDesktopIsActiveConsole(HWND , CAutoPlayParams *)
{
    BOOL fRetValue = FALSE;  // block auto-run/auto-play if we can't determine our state.

    if (0 == GetSystemMetrics(SM_REMOTESESSION))
    {
        //
        //  We are not remoted. See if we are the active console session.
        //

        BOOL b;
        DWORD dwProcessSession;

        b = ProcessIdToSessionId(GetCurrentProcessId(), &dwProcessSession);
        if (b)
        {
            DWORD dwConsoleSession = WTSGetActiveConsoleSessionId( );

            if ( dwProcessSession == dwConsoleSession )
            {        
                //
                //  See if the screen saver is running.
                //

                BOOL b;
                BOOL fScreenSaver;

                b = SystemParametersInfo( SPI_GETSCREENSAVERRUNNING, 0, &fScreenSaver, 0 );
                if (b)
                {
                    if (!fScreenSaver)
                    {
                        //
                        //  We made it here, we must be the active console session without a
                        //  screen saver.
                        //

                        HDESK hDesk = OpenInputDesktop( 0, FALSE, DESKTOP_CREATEWINDOW );
                        if ( NULL != hDesk )
                        {
                            //
                            //  We have access to the current desktop which should indicate that
                            //  WinLogon isn't.
                            //
                            CloseDesktop( hDesk );

                            fRetValue = TRUE;
                        }
                        // else "WinLogon" has the "desktop"... don't allow auto-run/auto-play.
                    }
                    // else a screen saver is running... don't allow auto-run/auto-play.
                }
                // else we are in an undeterminate state... don't allow auto-run/auto-play.
            }
            //  else we aren't the console... don't allow auto-run/auto-play
        }
        // else we are in an undeterminate state... don't allow auto-run/auto-play.
    }
    //  else we are remoted... don't allow auto-run/auto-play.

    return fRetValue;
}

BOOL CMountPoint::_acDriveIsMountedOnDriveLetter(HWND , CAutoPlayParams *papp)
{
    return _IsDriveLetter(papp->Drive());
}

BOOL CMountPoint::_acDriveIsRestricted(HWND , CAutoPlayParams *papp)
{
    BOOL fIsRestricted = (SHRestricted(REST_NODRIVES) & (1 << DRIVEID(papp->Drive())));

    if (!fIsRestricted)
    {
        fIsRestricted = !(papp->MountPoint()->_IsAutoRunDrive());
    }

    return fIsRestricted;
}

BOOL CMountPoint::_acHasAutorunCommand(HWND , CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;

    if ((papp->IsContentTypePresent(CT_AUTORUNINF)) &&
        (DT_ANYLOCALDRIVES & papp->DriveType()))
    {
        CMtPtLocal* pmtptl = (CMtPtLocal*)papp->MountPoint();

        if (pmtptl->_CanUseVolume())
        {
            if (pmtptl->_pvol->dwMediaCap & HWDMC_HASAUTORUNCOMMAND)
            {
                fRet = TRUE;
            }
        }
        else
        {
            fRet = papp->MountPoint()->_IsAutorun();
        }
    }
    else
    {
        fRet = papp->IsContentTypePresent(CT_AUTORUNINF);
    }

    return fRet;
}

BOOL CMountPoint::_acHasUseAutoPLAY(HWND , CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;

    if (papp->IsContentTypePresent(CT_AUTORUNINF) &&
        (DT_ANYLOCALDRIVES & papp->DriveType()))
    {
        CMtPtLocal* pmtptl = (CMtPtLocal*)papp->MountPoint();

        if (pmtptl->_CanUseVolume())
        {
            if (pmtptl->_pvol->dwMediaCap & HWDMC_HASUSEAUTOPLAY)
            {
                fRet = TRUE;
            }
        }
        else
        {
            // If we're here, most likely the ShellService is not running, so we won't be able to
            // Autoplay anyway.
            fRet = FALSE;
        }
    }
    else
    {
        // not supported for remote drives
    }

    return fRet;
}

BOOL CMountPoint::_acForegroundAppAllowsAutorun(HWND hwndForeground, CAutoPlayParams *papp)
{
    return _AppAllowsAutoRun(hwndForeground, papp->MountPoint());
}

static const TWODWORDS allcontentsVSarcontenttypemappings[] =
{
    { CT_AUTORUNINF      , ARCONTENT_AUTORUNINF },
    { CT_CDAUDIO         , ARCONTENT_AUDIOCD },
    { CT_DVDMOVIE        , ARCONTENT_DVDMOVIE },
    { CT_UNKNOWNCONTENT  , ARCONTENT_UNKNOWNCONTENT },
    { CT_BLANKCDR        , ARCONTENT_BLANKCD },
    { CT_BLANKCDRW       , ARCONTENT_BLANKCD },
    { CT_BLANKDVDR       , ARCONTENT_BLANKDVD },
    { CT_BLANKDVDRW      , ARCONTENT_BLANKDVD },
    { CT_AUTOPLAYMUSIC   , ARCONTENT_AUTOPLAYMUSIC },
    { CT_AUTOPLAYPIX     , ARCONTENT_AUTOPLAYPIX },
    { CT_AUTOPLAYMOVIE   , ARCONTENT_AUTOPLAYVIDEO },
};

BOOL CMountPoint::_acQueryCancelAutoplayAllowsAutorun(HWND , CAutoPlayParams *papp)
{
    BOOL fAllow = TRUE;

    DWORD dwAutorunContentType = _DoDWORDMapping(papp->ContentType(),
        allcontentsVSarcontenttypemappings, ARRAYSIZE(allcontentsVSarcontenttypemappings),
        TRUE);

    _QueryRunningObject(papp->MountPoint(), dwAutorunContentType, &fAllow);

    return fAllow;
}

BOOL CMountPoint::_acUserHasSelectedApplication(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;
    WCHAR szContentTypeHandler[MAX_CONTENTTYPEHANDLER];

    DWORD dwMtPtContentType = papp->ContentType() & ~CT_UNKNOWNCONTENT;
    HRESULT hr = _GetContentTypeHandler(dwMtPtContentType, szContentTypeHandler, ARRAYSIZE(szContentTypeHandler));
    if (SUCCEEDED(hr))
    {
        IAutoplayHandler* piah;

        hr = _GetAutoplayHandler(papp->Drive(), TEXT("ContentArrival"), szContentTypeHandler, &piah);

        if (SUCCEEDED(hr))
        {
            LPWSTR pszHandlerDefault;

            hr = piah->GetDefaultHandler(&pszHandlerDefault);

            if (SUCCEEDED(hr))
            {
                if (HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED &
                    HANDLERDEFAULT_GETFLAGS(hr))
                {
                    fRet = FALSE;
                }
                else
                {
                    if (HANDLERDEFAULT_USERCHOSENDEFAULT &
                        HANDLERDEFAULT_GETFLAGS(hr))
                    {
                        fRet = lstrcmpi(pszHandlerDefault, TEXT("MSPromptEachTime"));
                    }
                    else
                    {
                        fRet = FALSE;
                    }
                }

                if (!fRet)
                {
                    if (((HANDLERDEFAULT_USERCHOSENDEFAULT &
                        HANDLERDEFAULT_GETFLAGS(hr)) ||
                        (HANDLERDEFAULT_EVENTHANDLERDEFAULT &
                        HANDLERDEFAULT_GETFLAGS(hr))) &&
                        !(HANDLERDEFAULT_DEFAULTSAREDIFFERENT &
                        HANDLERDEFAULT_GETFLAGS(hr)))
                    {
                        papp->_fCheckAlwaysDoThisCheckBox = TRUE;
                    }
                }

                CoTaskMemFree(pszHandlerDefault);
            }

            piah->Release();
        }
    }

    return fRet;
}

BOOL CMountPoint::_acShellIsForegroundApp(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;
    WCHAR szModule[MAX_PATH];

    if (GetWindowModuleFileName(hwndForeground, szModule, ARRAYSIZE(szModule)))
    {
        if (!lstrcmpi(PathFindFileName(szModule), TEXT("explorer.exe")))
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

BOOL CMountPoint::_acOSIsServer(HWND , CAutoPlayParams *papp)
{
    return IsOS(OS_ANYSERVER);
}

BOOL CMountPoint::_acIsDockedLaptop(HWND hwndForeground, CAutoPlayParams *papp)
{
    return (GMID_DOCKED & SHGetMachineInfo(GMI_DOCKSTATE));
}

BOOL CMountPoint::_acDriveIsFormatted(HWND hwndForeground, CAutoPlayParams *papp)
{
    return papp->MountPoint()->IsFormatted();
}

BOOL CMountPoint::_acShellExecuteDriveAutorunINF(HWND hwndForeground, CAutoPlayParams *papp)
{
    SHELLEXECUTEINFO ei = {
        sizeof(ei),                 // size
        SEE_MASK_INVOKEIDLIST | SEE_MASK_FLAG_NO_UI,      // flags
        NULL,
        NULL,                       // verb
        papp->Drive(),              // file
        papp->Drive(),              // params
        papp->Drive(),              // directory
        SW_NORMAL,                  // show.
        NULL,                       // hinstance
        NULL,                       // IDLIST
        NULL,                       // class name
        NULL,                       // class key
        0,                          // hot key
        NULL,                       // icon
        NULL,                       // hProcess
    };

    return ShellExecuteEx(&ei);
}


HRESULT _InvokeAutoRunProgid(HKEY hkProgid, LPCWSTR pszVerb, IDataObject *pdo)
{
    IShellExtInit *psei;
    HRESULT hr = CoCreateInstance(CLSID_ShellFileDefExt, NULL, CLSCTX_INPROC, IID_PPV_ARG(IShellExtInit, &psei));

    if (SUCCEEDED(hr))
    {
        hr = psei->Initialize(NULL, pdo, hkProgid);
        if (SUCCEEDED(hr))
        {
            IContextMenu *pcm;
            hr = psei->QueryInterface(IID_PPV_ARG(IContextMenu, &pcm));
            if (SUCCEEDED(hr))
            {
                CHAR szVerb[64];

                //  maybe hwnd
                //  maybe punkSite
                //  maybe ICI flags
                SHUnicodeToAnsi(pszVerb, szVerb, ARRAYSIZE(szVerb));
    
                hr = SHInvokeCommandOnContextMenu(NULL, NULL, pcm, 0, szVerb);

                pcm->Release();
            }
        }

        psei->Release();
    }
    return hr;
}

HRESULT _GetProgidAndVerb(DWORD dwContentType, PCWSTR pszHandler, PWSTR pszInvokeProgID,
    DWORD cchInvokeProgID, PWSTR pszInvokeVerb, DWORD cchInvokeVerb)
{
    HRESULT hr;
    if (0 == StrCmpI(pszHandler, TEXT("AutoplayLegacyHandler")) && (dwContentType & (CT_CDAUDIO | CT_DVDMOVIE)))
    {
        HKEY hkey;
        BOOL fGotDefault = FALSE;

        if (dwContentType & CT_CDAUDIO)
        {
            StrCpyN(pszInvokeProgID, TEXT("AudioCD"), cchInvokeProgID);
        }
        else
        {
            ASSERT(dwContentType & CT_DVDMOVIE);
            StrCpyN(pszInvokeProgID, TEXT("DVD"), cchInvokeProgID);
        }

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, pszInvokeProgID, 0, MAXIMUM_ALLOWED,
            &hkey))
        {
            HKEY hkey2;

            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, TEXT("shell"), 0, MAXIMUM_ALLOWED,
                &hkey2))
            {
                DWORD cbInvokeVerb = cchInvokeVerb * sizeof(WCHAR);

                if (ERROR_SUCCESS == RegQueryValueEx(hkey2, NULL, NULL, NULL, (PBYTE)pszInvokeVerb,
                    &cbInvokeVerb))
                {
                    if (cbInvokeVerb && *pszInvokeVerb)
                    {                        
                        if (cbInvokeVerb != (cchInvokeVerb * sizeof(WCHAR)))
                        {
                            fGotDefault = TRUE;
                        }
                    }
                }

                RegCloseKey(hkey2);
            }

            RegCloseKey(hkey);
        }

        if (!fGotDefault)
        {
            StrCpyN(pszInvokeVerb, TEXT("play"), cchInvokeVerb);
        }

        hr = S_OK;
    }
    else
    {
        hr = _GetHandlerInvokeProgIDAndVerb(pszHandler, pszInvokeProgID,
                    cchInvokeProgID, pszInvokeVerb, cchInvokeVerb);
    }
    return hr;
}

BOOL CMountPoint::_ExecuteHelper(LPCWSTR pszHandler, LPCWSTR pszContentTypeHandler,
    CAutoPlayParams *papp, DWORD dwMtPtContentType)
{
    HRESULT hr;

    if (lstrcmpi(pszHandler, TEXT("MSTakeNoAction")))
    {
        WCHAR szInvokeProgID[260];
        WCHAR szInvokeVerb[CCH_KEYMAX];

        hr = _GetProgidAndVerb(dwMtPtContentType, pszHandler, szInvokeProgID,
            ARRAYSIZE(szInvokeProgID), szInvokeVerb, ARRAYSIZE(szInvokeVerb));

        if (SUCCEEDED(hr))
        {
            HKEY hkey;
            if (dwMtPtContentType & (CT_CDAUDIO | CT_DVDMOVIE))
            {
                hr = papp->MountPoint()->_CopyInvokeVerbKey(szInvokeProgID, szInvokeVerb);
                hkey = papp->MountPoint()->RSDuplicateRootKey();
                papp->MountPoint()->RSSetTextValue(TEXT("shell"), NULL, szInvokeVerb, REG_OPTION_NON_VOLATILE);
            }
            else
            {
                hr = ResultFromWin32(RegOpenKeyExW(HKEY_CLASSES_ROOT, szInvokeProgID, 0, MAXIMUM_ALLOWED, &hkey));
            }

            if (SUCCEEDED(hr))
            {
                IDataObject* pdo;
                hr = papp->DataObject(&pdo);
                if (SUCCEEDED(hr))
                {
                    hr = _InvokeAutoRunProgid(hkey, szInvokeVerb, pdo);
                    pdo->Release();
                }

                RegCloseKey(hkey);
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return SUCCEEDED(hr);
}

BOOL CMountPoint::_acExecuteAutoplayDefault(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;

    if (DT_ANYLOCALDRIVES & papp->DriveType())
    {
        WCHAR szContentTypeHandler[MAX_CONTENTTYPEHANDLER];

        DWORD dwMtPtContentType = papp->ContentType() & ~CT_UNKNOWNCONTENT;

        HRESULT hr = _GetContentTypeHandler(dwMtPtContentType, szContentTypeHandler, ARRAYSIZE(szContentTypeHandler));

        if (SUCCEEDED(hr))
        {
            IAutoplayHandler* piah;

            hr = _GetAutoplayHandler(papp->Drive(), TEXT("ContentArrival"), szContentTypeHandler, &piah);

            if (SUCCEEDED(hr))
            {
                LPWSTR pszHandlerDefault;

                hr = piah->GetDefaultHandler(&pszHandlerDefault);

                if (SUCCEEDED(hr))
                {
                    // No need to check for (S_HANDLERS_MORE_RECENT_THAN_USER_SELECTION == hr) here
                    // It should have been caught by _acUserHasSelectedApplication
                    fRet = _ExecuteHelper(pszHandlerDefault, szContentTypeHandler, papp, dwMtPtContentType);
                }

                CoTaskMemFree(pszHandlerDefault);
            }

            piah->Release();
        }
    }

    return fRet;
}

BOOL CMountPoint::_acWasjustDocked(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;

    if (DT_ANYLOCALDRIVES & papp->DriveType())
    {
        CMtPtLocal* pmtptl = (CMtPtLocal*)papp->MountPoint();

        if (pmtptl->_CanUseVolume())
        {
            if (pmtptl->_pvol->dwVolumeFlags & HWDVF_STATE_JUSTDOCKED)
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

CRITICAL_SECTION g_csAutoplayPrompt = {0};
HDPA g_hdpaAutoplayPrompt = NULL;

BOOL CMountPoint::_acPromptUser(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;
    BOOL fShowDlg = TRUE;

    if (papp->Drive())
    {
        fShowDlg = _AddAutoplayPrompt(papp->Drive());
    }

    if (fShowDlg)
    {
        CBaseContentDlg* pdlg;

        papp->ForceSniff();

        DWORD dwMtPtContentType = papp->ContentType() & ~CT_UNKNOWNCONTENT;

        if (dwMtPtContentType)
        {
            if (_acIsMixedContent(hwndForeground, papp))
            {
                pdlg = new CMixedContentDlg();

                dwMtPtContentType &= CT_ANYAUTOPLAYCONTENT;

                if (pdlg)
                {
                    pdlg->_iResource = DLG_APMIXEDCONTENT;
                }
            }
            else
            {
                pdlg = new CHWContentPromptDlg();

                if (pdlg)
                {
                    pdlg->_iResource = DLG_APPROMPTUSER;
                }
            }
        }

        if (pdlg)
        {
            // Better be a local drive
            if (DT_ANYLOCALDRIVES & papp->DriveType())
            {
                CMtPtLocal* pmtptl = (CMtPtLocal*)papp->MountPoint();

                if (pmtptl->_CanUseVolume())
                {
                    HRESULT hr = pdlg->Init(pmtptl->_pvol->pszDeviceIDVolume, papp->Drive(), dwMtPtContentType,
                        papp->_fCheckAlwaysDoThisCheckBox);

                    pdlg->_hinst = g_hinst;
                    pdlg->_hwndParent = NULL;

                    if (SUCCEEDED(hr))
                    {
                        INT_PTR iRet = pdlg->DoModal(pdlg->_hinst, MAKEINTRESOURCE(pdlg->_iResource),
                            pdlg->_hwndParent);

                        if (IDOK == iRet)
                        {
                            fRet = _ExecuteHelper(pdlg->_szHandler, pdlg->_szContentTypeHandler,
                                papp, dwMtPtContentType);
                        }
                    }
                }
            }

            pdlg->Release();
        }

        if (papp->Drive())
        {
            _RemoveFromAutoplayPromptHDPA(papp->Drive());
        }
    }
    
    return fRet;
}

BOOL CMountPoint::_acIsMixedContent(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet;

    if (papp->IsContentTypePresent(CT_ANYAUTOPLAYCONTENT))
    {
        fRet = IsMixedContent(papp->ContentType());
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

BOOL CMountPoint::_acAlwaysReturnsTRUE(HWND hwndForeground, CAutoPlayParams *papp)
{
    return TRUE;
}

BOOL CMountPoint::_acShouldSniff(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet = TRUE;
    CMtPtLocal* pmtptl = papp->MountPointLocal();
    if (pmtptl)
    {
        if (pmtptl->_CanUseVolume())
        {
            fRet = !(HWDVF_STATE_DONOTSNIFFCONTENT & pmtptl->_pvol->dwVolumeFlags);
        }
    }

    return fRet;
}

BOOL CMountPoint::_acAddAutoplayVerb(HWND hwndForeground, CAutoPlayParams *papp)
{
    CMtPtLocal* pmtptl = papp->MountPointLocal();

    if (pmtptl)
    {
        if (pmtptl->_CanUseVolume())
        {
            // We don't care about the return value
            pmtptl->_AddAutoplayVerb();
        }
    }

    return TRUE;
}

//
// END: Fcts for matrix below

#define SKIPDEPENDENTS_ONFALSE                      0x00000001  // Skips dependents
#define SKIPDEPENDENTS_ONTRUE                       0x00000002  // Skips dependents
#define CANCEL_AUTOPLAY_ONFALSE                     0x00000004
#define CANCEL_AUTOPLAY_ONTRUE                      0x00000008
#define NOTAPPLICABLE_ONANY                         0x00000010

#define LEVEL_EXECUTE                               0x10000000
#define LEVEL_SKIP                                  0x20000000
#define LEVEL_SPECIALMASK                           0x30000000
#define LEVEL_REALLEVELMASK                         0x0FFFFFFF

typedef BOOL (AUTORUNFCT)(HWND hwndForeground, CAutoPlayParams *papp);

// fct is called with pszDrive, papp->MountPoint(), hwndForeground, drive type and content type
struct AUTORUNCONDITION
{
    DWORD               dwNestingLevel;
    DWORD               dwMtPtDriveType;
    DWORD               dwMtPtContentType;
    DWORD               dwReturnValueHandling;
    AUTORUNFCT*         fct;
#ifdef DEBUG
    LPCWSTR             pszDebug;
#endif
};

// For this table to be more readable, add the content of \\stephstm\public\usertype.dat to
// %ProgramFiles%\Microsoft Visual Studio\Common\MSDev98\Bin\usertype.dat
// then restart MSDev

// AR_ENTRY -> AUTORUN_ENTRY
#ifdef DEBUG
#define AR_ENTRY(a, b, c, d, e) { (a), (b), (c), (d), CMountPoint::e, TEXT(#a) TEXT(":") TEXT(#b) TEXT(":") TEXT(#c) TEXT(":") TEXT(#d) TEXT(":") TEXT(#e) }
#else
#define AR_ENTRY(a, b, c, d, e) { (a), (b), (c), (d), CMountPoint::e }
#endif

// DT_* -> DriveType
// CT_* -> ContentType

static const AUTORUNCONDITION _rgAutorun[] =
{
    // We don't autorun if the drive is not mounted on a drive letter
    AR_ENTRY(0, DT_ANYTYPE, CT_ANYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acDriveIsMountedOnDriveLetter),
    // We don't autorun if this is a restricted drive
    AR_ENTRY(0, DT_ANYTYPE & ~DT_REMOTE, CT_ANYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acDriveIsRestricted),
        // Add the Autoplay Verb
        AR_ENTRY(1, DT_ANYTYPE & ~DT_REMOTE, CT_ANYCONTENT & ~CT_AUTORUNINF, SKIPDEPENDENTS_ONFALSE, _acAddAutoplayVerb),
    // We don't autorun if the Shift key is down
    AR_ENTRY(0, DT_ANYTYPE, CT_ANYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acShiftKeyDown),
    // We don't autorun if a laptop was just docked.  All devices in the craddle come as nhew devices.
    AR_ENTRY(0, DT_ANYTYPE & ~DT_REMOTE, CT_ANYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acWasjustDocked),
    // We don't autorun if the Current Desktop is not the active console desktop
    AR_ENTRY(0, DT_ANYTYPE, CT_ANYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acCurrentDesktopIsActiveConsole),
    // We don't autorun if the Current Desktop is not the active console desktop
    AR_ENTRY(0, DT_ANYTYPE, CT_ANYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acDirectXAppRunningFullScreen),
        // Remote drive always Autorun (mostly opening folder)
        AR_ENTRY(1, DT_REMOTE, CT_ANYCONTENT, SKIPDEPENDENTS_ONFALSE, _acForegroundAppAllowsAutorun),
        AR_ENTRY(1, DT_REMOTE, CT_ANYCONTENT, SKIPDEPENDENTS_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            AR_ENTRY(2 | LEVEL_EXECUTE, DT_REMOTE, CT_ANYCONTENT, NOTAPPLICABLE_ONANY, _acShellExecuteDriveAutorunINF),
        // Autorun.inf
        AR_ENTRY(1, DT_ANYTYPE & ~DT_REMOVABLEDISK, CT_AUTORUNINF, SKIPDEPENDENTS_ONFALSE, _acHasAutorunCommand),
            AR_ENTRY(2, DT_ANYTYPE & ~DT_REMOVABLEDISK, CT_AUTORUNINF, SKIPDEPENDENTS_ONTRUE, _acHasUseAutoPLAY),
                AR_ENTRY(3, DT_ANYTYPE & ~DT_REMOVABLEDISK, CT_AUTORUNINF, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
                AR_ENTRY(3, DT_ANYTYPE & ~DT_REMOVABLEDISK, CT_AUTORUNINF, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
                    AR_ENTRY(4 | LEVEL_EXECUTE, DT_ANYCDDRIVES, CT_AUTORUNINF, NOTAPPLICABLE_ONANY, _acShellExecuteDriveAutorunINF),
        // CD Audio
        AR_ENTRY(1, DT_ANYCDDRIVES, CT_CDAUDIO, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
        AR_ENTRY(1, DT_ANYCDDRIVES, CT_CDAUDIO, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            AR_ENTRY(2, DT_ANYCDDRIVES, CT_CDAUDIO, SKIPDEPENDENTS_ONFALSE, _acUserHasSelectedApplication),
                AR_ENTRY(3 | LEVEL_EXECUTE, DT_ANYCDDRIVES, CT_CDAUDIO, NOTAPPLICABLE_ONANY, _acExecuteAutoplayDefault),
        AR_ENTRY(LEVEL_EXECUTE | 1, DT_ANYCDDRIVES, CT_CDAUDIO, NOTAPPLICABLE_ONANY, _acPromptUser),
        // DVD Movie
        AR_ENTRY(1, DT_ANYCDDRIVES, CT_DVDMOVIE, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
        AR_ENTRY(1, DT_ANYCDDRIVES, CT_DVDMOVIE, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            AR_ENTRY(2, DT_ANYCDDRIVES, CT_DVDMOVIE, SKIPDEPENDENTS_ONFALSE, _acUserHasSelectedApplication),
                AR_ENTRY(3 | LEVEL_EXECUTE, DT_ANYCDDRIVES, CT_DVDMOVIE, NOTAPPLICABLE_ONANY, _acExecuteAutoplayDefault),
        AR_ENTRY(LEVEL_EXECUTE | 1, DT_ANYCDDRIVES, CT_DVDMOVIE, NOTAPPLICABLE_ONANY, _acPromptUser),
        // Writable CDs
        AR_ENTRY(1, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
        AR_ENTRY(1, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            AR_ENTRY(2, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, SKIPDEPENDENTS_ONFALSE, _acUserHasSelectedApplication),
                AR_ENTRY(3 | LEVEL_EXECUTE, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, NOTAPPLICABLE_ONANY, _acExecuteAutoplayDefault),
        AR_ENTRY(LEVEL_EXECUTE | 1, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, NOTAPPLICABLE_ONANY, _acPromptUser),
        // Writable DVDs
        AR_ENTRY(LEVEL_SKIP | 1, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
        AR_ENTRY(LEVEL_SKIP | 1, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            AR_ENTRY(LEVEL_SKIP | 2, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, SKIPDEPENDENTS_ONFALSE, _acUserHasSelectedApplication),
                AR_ENTRY(LEVEL_SKIP | 3 | LEVEL_EXECUTE, DT_ANYDVDDRIVES, CT_BLANKDVDWRITABLE, NOTAPPLICABLE_ONANY, _acExecuteAutoplayDefault),
        AR_ENTRY(LEVEL_SKIP | LEVEL_EXECUTE | 1, DT_ANYDVDDRIVES, CT_BLANKDVDWRITABLE, NOTAPPLICABLE_ONANY, _acPromptUser),
        // Mixed content
        AR_ENTRY(1, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, SKIPDEPENDENTS_ONFALSE, _acIsMixedContent),
            AR_ENTRY(2, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, SKIPDEPENDENTS_ONTRUE, _acUserHasSelectedApplication),
                AR_ENTRY(3, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
                    AR_ENTRY(4 | LEVEL_EXECUTE, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, NOTAPPLICABLE_ONANY, _acPromptUser),
            AR_ENTRY(LEVEL_EXECUTE | 2, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, NOTAPPLICABLE_ONANY, _acExecuteAutoplayDefault),
        // Single Autoplay content
        AR_ENTRY(1, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            AR_ENTRY(2, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, SKIPDEPENDENTS_ONTRUE, _acUserHasSelectedApplication),
                AR_ENTRY(3 | LEVEL_EXECUTE, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, NOTAPPLICABLE_ONANY, _acPromptUser),
            AR_ENTRY(LEVEL_EXECUTE | 2, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, NOTAPPLICABLE_ONANY, _acExecuteAutoplayDefault),
        // Unknown content
        AR_ENTRY(1, DT_ANYREMOVABLEMEDIADRIVES, CT_UNKNOWNCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
        AR_ENTRY(1, DT_ANYREMOVABLEMEDIADRIVES, CT_UNKNOWNCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            // If we should not sniff, we should not open a folder either
            AR_ENTRY(2, DT_ANYREMOVABLEMEDIADRIVES, CT_UNKNOWNCONTENT, SKIPDEPENDENTS_ONFALSE, _acShouldSniff),
                AR_ENTRY(3 | LEVEL_EXECUTE, DT_ANYREMOVABLEMEDIADRIVES, CT_UNKNOWNCONTENT, NOTAPPLICABLE_ONANY, _acShellExecuteDriveAutorunINF),
            // Weird CDs have autorun.inf but no autorun command
            AR_ENTRY(2, DT_ANYREMOVABLEMEDIADRIVES, CT_AUTORUNINF, SKIPDEPENDENTS_ONTRUE, _acHasAutorunCommand),
                AR_ENTRY(3 | LEVEL_EXECUTE, DT_ANYREMOVABLEMEDIADRIVES, CT_AUTORUNINF, NOTAPPLICABLE_ONANY, _acShellExecuteDriveAutorunINF),
        // Former ShellOpen, basically we ShellExecute whatever drives except CD drives if the shell is in the foreground
        AR_ENTRY(1, ~DT_ANYCDDRIVES, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, SKIPDEPENDENTS_ONFALSE, _acShellIsForegroundApp),
            AR_ENTRY(2, ~DT_ANYCDDRIVES, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acAlwaysReturnsTRUE),
                // Additonnal restrictions on Fixed disk drive
                AR_ENTRY(3, DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acDriveIsFormatted),
                    AR_ENTRY(4, DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acOSIsServer),
                        AR_ENTRY(5, DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acIsDockedLaptop),
                            AR_ENTRY(6, DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
                            AR_ENTRY(6, DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
                                AR_ENTRY(7 | LEVEL_EXECUTE, DT_ANYTYPE, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, NOTAPPLICABLE_ONANY, _acShellExecuteDriveAutorunINF),
                // Non Fixed Disk drives
                AR_ENTRY(3, ~DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
                AR_ENTRY(3, ~DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
                    AR_ENTRY(4 | LEVEL_EXECUTE, ~DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, NOTAPPLICABLE_ONANY, _acShellExecuteDriveAutorunINF),
};

// This array will be dumped in the registry under the Volume GUID of the
// drive in a value named _AutorunStatus
//
// Each byte represents an entry in the above table.  Following is the
// meaning of each byte:
//
// 01: Condition was TRUE
// 00: Condition was FALSE
// CF: ContentType condition was failed
// DF: DriveType condition was failed
// 5F: Condition was skipped (5 looks like an 'S' :)
// EE: Condition was executed
// FF: Never got there

// Use a struct to avoid alignement issues
#pragma pack(push, 4)
struct AUTORUNSTATUS
{
    BYTE _rgbAutorunStatus[ARRAYSIZE(_rgAutorun)];
    DWORD dwDriveType;
    DWORD dwContentType;
};
#pragma pack(pop)

static AUTORUNSTATUS s_autorunstatus;

// static
void CMountPoint::DoAutorun(LPCWSTR pszDrive, DWORD dwAutorunFlags)
{
    CMountPoint* pmtpt = GetMountPoint(pszDrive);

    FillMemory(s_autorunstatus._rgbAutorunStatus, sizeof(s_autorunstatus._rgbAutorunStatus), -1);

    if (pmtpt)
    {
        CAutoPlayParams app(pszDrive, pmtpt, dwAutorunFlags);
        if (AUTORUNFLAG_MENUINVOKED & dwAutorunFlags)
        {
            _acPromptUser(GetForegroundWindow(), &app);
        }
        else
        {
            _DoAutorunHelper(&app);
        }

        pmtpt->Release();
    }
}

void CAutoPlayParams::_TrySniff()
{
    if (!(APS_DID_SNIFF & _state))
    {
        if (_ShouldSniffDrive(TRUE))
        {
            DWORD dwFound;

            if (SUCCEEDED(_Sniff(&dwFound)))
            {
                _dwContentType |= dwFound;
            }
        }

        _state |= APS_DID_SNIFF;
    }
}

BOOL CAutoPlayParams::IsContentTypePresent(DWORD dwContentType)
{
    BOOL fRet;

    if (CT_ANYCONTENT == dwContentType)
    {
        fRet = TRUE;
    }
    else
    {
        // We special case this because we do not want to sniff at this point
        if ((CT_ANYCONTENT & ~CT_AUTORUNINF) == dwContentType)
        {
            if (CT_AUTORUNINF == _dwContentType)
            {
                fRet = FALSE;
            }
            else
            {
                // Anything else is good
                fRet = TRUE;
            }
        }
        else
        {
            if (CT_ANYAUTOPLAYCONTENT & dwContentType)
            {
                _TrySniff();
            }

            fRet = !!(dwContentType & _dwContentType);
        }
    }

    return fRet;
}

void CAutoPlayParams::ForceSniff()
{
    if (AUTORUNFLAG_MENUINVOKED & _dwAutorunFlags)
    {
        _TrySniff();
    }
}

// static
void CMountPoint::_DoAutorunHelper(CAutoPlayParams *papp)
{
    DWORD dwMaxLevelToProcess = 0;
    BOOL fStop = FALSE;

    HWND hwndForeground = GetForegroundWindow();

    for (DWORD dwStep = 0; !fStop && (dwStep < ARRAYSIZE(_rgAutorun)); ++dwStep)
    {
        if (!(_rgAutorun[dwStep].dwNestingLevel & LEVEL_SKIP))
        {
            if ((_rgAutorun[dwStep].dwNestingLevel & LEVEL_REALLEVELMASK) <= dwMaxLevelToProcess)
            {
                BOOL fConditionResult = FALSE;
                // We do not want to Cancel the whole Autoplay operation if we do not get a
                // match for a drive type or content type.  We do the Cancel Autoplay only
                // if the condition was evaluated.
                BOOL fConditionEvaluated = FALSE;

                if (_rgAutorun[dwStep].dwMtPtDriveType & papp->DriveType())
                {
                    if (papp->IsContentTypePresent(_rgAutorun[dwStep].dwMtPtContentType))
                    {
                        if (!(_rgAutorun[dwStep].dwNestingLevel & LEVEL_EXECUTE))
                        {
                            fConditionResult = ((_rgAutorun[dwStep].fct)(hwndForeground, papp));

                            s_autorunstatus._rgbAutorunStatus[dwStep] = fConditionResult ? 1 : 0;

                            fConditionEvaluated = TRUE;
                        }
                        else
                        {
                            // LEVEL_EXECUTE
#ifdef DEBUG
                            TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: EXECUTING -> %s", dwStep, _rgAutorun[dwStep].pszDebug);
#endif

                            _rgAutorun[dwStep].fct(hwndForeground, papp);

                            // 2 execute
                            s_autorunstatus._rgbAutorunStatus[dwStep] = 0xEE;

                            // We're done
                            fStop = TRUE;
                        }
                    }
                    else
                    {
#ifdef DEBUG
                        TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: NO MATCH on CONTENTTYPE, %s ", dwStep, _rgAutorun[dwStep].pszDebug);
#endif
                        s_autorunstatus._rgbAutorunStatus[dwStep] = 0xCF;
                    }
                }
                else
                {
#ifdef DEBUG
                    TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: NO MATCH on DRIVETYPE, %s ", dwStep, _rgAutorun[dwStep].pszDebug);
#endif
                    s_autorunstatus._rgbAutorunStatus[dwStep] = 0xDF;
                }

                if (!fStop)
                {
                    if (fConditionResult)
                    {
#ifdef DEBUG
                        TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: TRUE -> %s", dwStep, _rgAutorun[dwStep].pszDebug);
#endif
                        switch (_rgAutorun[dwStep].dwReturnValueHandling)
                        {
                            case SKIPDEPENDENTS_ONTRUE:
                                dwMaxLevelToProcess = _rgAutorun[dwStep].dwNestingLevel & LEVEL_REALLEVELMASK;
                                break;

                            case CANCEL_AUTOPLAY_ONTRUE:
                                if (fConditionEvaluated)
                                {
                                    fStop = TRUE;
                                }

                                break;

                            default:
                                dwMaxLevelToProcess = (_rgAutorun[dwStep].dwNestingLevel & LEVEL_REALLEVELMASK) + 1;
                                break;

                            case NOTAPPLICABLE_ONANY:
                                break;
                        }
                    }
                    else
                    {
#ifdef DEBUG
                        TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: FALSE -> %s", dwStep, _rgAutorun[dwStep].pszDebug);
#endif
                        switch (_rgAutorun[dwStep].dwReturnValueHandling)
                        {
                            case SKIPDEPENDENTS_ONFALSE:
                                dwMaxLevelToProcess = _rgAutorun[dwStep].dwNestingLevel & LEVEL_REALLEVELMASK;
                                break;

                            case CANCEL_AUTOPLAY_ONFALSE:
                                if (fConditionEvaluated)
                                {
                                    fStop = TRUE;
                                }

                                break;

                            default:
                                dwMaxLevelToProcess = (_rgAutorun[dwStep].dwNestingLevel & LEVEL_REALLEVELMASK) + 1;
                                break;

                            case NOTAPPLICABLE_ONANY:
                                break;
                        }                                
                    }
                }
            }
            else
            {
#ifdef DEBUG
                TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: SKIPPING , %s ", dwStep, _rgAutorun[dwStep].pszDebug);
#endif
                s_autorunstatus._rgbAutorunStatus[dwStep] = 0x5F;
            }
        }
        else
        {
#ifdef DEBUG
            TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: LVL-SKIP , %s ", dwStep, _rgAutorun[dwStep].pszDebug);
#endif
            s_autorunstatus._rgbAutorunStatus[dwStep] = 0x5F;
        }
    }

    s_autorunstatus.dwDriveType = papp->DriveType();
    s_autorunstatus.dwContentType = papp->ContentType();

    papp->MountPoint()->SetAutorunStatus((BYTE*)&s_autorunstatus, sizeof(s_autorunstatus));
}

DWORD _DoDWORDMapping(DWORD dwLeft, const TWODWORDS* rgtwodword, DWORD ctwodword, BOOL fORed)
{
    DWORD dwRight = 0;

    for (DWORD dw = 0; dw < ctwodword; ++dw)
    {
        if (fORed)
        {
            if (dwLeft & rgtwodword[dw].dwLeft)
            {
                dwRight |= rgtwodword[dw].dwRight;
            }
        }
        else
        {
            if (dwLeft == rgtwodword[dw].dwLeft)
            {
                dwRight = rgtwodword[dw].dwRight;
                break;
            }
        }
    }

    return dwRight;
}

STDMETHODIMP CSniffDrive::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CSniffDrive, INamespaceWalkCB),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP CSniffDrive::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    // include everything
    HRESULT hr = S_OK;

    if (!_pne || !_pne->fStopSniffing)
    {
        // if we found everything we dont need to worry about sniffing
        // now we are just populating the dataobject
        if (!_FoundEverything())
        {
            PERCEIVED gen = GetPerceivedType(psf, pidl);

            if (GEN_IMAGE == gen)
            {
                _dwFound |= CT_AUTOPLAYPIX;
            }
            else if (GEN_AUDIO == gen)
            {
                _dwFound |= CT_AUTOPLAYMUSIC;
            }
            else if (GEN_VIDEO == gen)
            {
                _dwFound |= CT_AUTOPLAYMOVIE;
            }
            else            
            {
                _dwFound |= CT_UNKNOWNCONTENT;
            }

            hr = S_OK;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    //  we never want the results on the sniff
    return hr;
}

STDMETHODIMP CSniffDrive::EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return S_OK;
}

STDMETHODIMP CSniffDrive::LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return S_OK;
}

STDMETHODIMP CSniffDrive::InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
{
    *ppszCancel = NULL; // use default

    TCHAR szMsg[256];
    
    LoadString(g_hinst, IDS_AP_SNIFFPROGRESSDIALOG, szMsg, ARRAYSIZE(szMsg));
    
    return SHStrDup(szMsg, ppszTitle);
}

// static
HRESULT CSniffDrive::Init(HANDLE hThreadSCN)
{
    HRESULT hr;

    if (DuplicateHandle(GetCurrentProcess(), hThreadSCN, GetCurrentProcess(),
        &_hThreadSCN, THREAD_ALL_ACCESS, FALSE, 0))
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return S_OK;
}

// static
HRESULT CSniffDrive::CleanUp()
{
    if (_dpaNotifs)
    {
        // We should not need to delete the items, they should all be removed.  Even
        // if they're, we should leave them there since something will probably try
        // to access them.
        _dpaNotifs.Destroy();
        _dpaNotifs = NULL;
    }

    if (_hThreadSCN)
    {
        CloseHandle(_hThreadSCN);
        _hThreadSCN = NULL;
    }

    return S_OK;
}

// static
HRESULT CSniffDrive::InitNotifyWindow(HWND hwnd)
{
    _hwndNotify = hwnd;

    return S_OK;
}

HRESULT CSniffDrive::RegisterForNotifs(LPCWSTR pszDeviceIDVolume)
{
    HRESULT hr;

    _pne = new PNPNOTIFENTRY();

    if (_pne)
    {
        HANDLE hDevice = CreateFile(pszDeviceIDVolume, FILE_READ_ATTRIBUTES,
           FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

        if (INVALID_HANDLE_VALUE != hDevice)
        {
            DEV_BROADCAST_HANDLE dbhNotifFilter = {0};

            // Assume failure
            hr = E_FAIL;

            dbhNotifFilter.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
            dbhNotifFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
            dbhNotifFilter.dbch_handle = hDevice;

            _pne->hdevnotify = RegisterDeviceNotification(_hwndNotify, &dbhNotifFilter,
                DEVICE_NOTIFY_WINDOW_HANDLE);

            if (_pne->hdevnotify)
            {
                _pne->AddRef();

                if (QueueUserAPC(CSniffDrive::_RegisterForNotifsHelper, _hThreadSCN, (ULONG_PTR)_pne))
                {
                    hr = S_OK;
                }
                else
                {
                    _pne->Release();
                }
            }

            CloseHandle(hDevice);
        }
        else
        {
            hr = E_FAIL;
        }

        if (FAILED(hr))
        {
            // Something must have gone wrong
            _pne->Release();
            _pne = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CSniffDrive::UnregisterForNotifs()
{
    UnregisterDeviceNotification(_pne->hdevnotify);
    
    QueueUserAPC(CSniffDrive::_UnregisterForNotifsHelper, _hThreadSCN, (ULONG_PTR)_pne);

    _pne->Release();
    _pne = NULL;

    return S_OK;
}

// static
void CALLBACK CSniffDrive::_RegisterForNotifsHelper(ULONG_PTR ul)
{
    PNPNOTIFENTRY* pne = (PNPNOTIFENTRY*)ul;

    if (!_dpaNotifs)
    {
        _dpaNotifs.Create(1);
    }

    if (_dpaNotifs)
    {
        // We do not check the return value.  We cannot free it, since the thread that
        // queued this APC to us, expect this chunk of mem to be there until it calls
        // UnregisterNotify.  We'll leak it.  Hopefully, this won't happen often.
        _dpaNotifs.AppendPtr(pne);
    }
}

// static
void CALLBACK CSniffDrive::_UnregisterForNotifsHelper(ULONG_PTR ul)
{
    PNPNOTIFENTRY* pne = (PNPNOTIFENTRY*)ul;

    if (_dpaNotifs)
    {
        int cItem = _dpaNotifs.GetPtrCount();

        for (int i = 0; i < cItem; ++i)
        {
            PNPNOTIFENTRY* pneTmp = _dpaNotifs.GetPtr(i);
        
            if (pneTmp->hdevnotify == pne->hdevnotify)
            {
                CloseHandle(pne->hThread);

                _dpaNotifs.DeletePtr(i);

                pne->Release();

                break;
            }
        }
    }
}

// static
HRESULT CSniffDrive::HandleNotif(HDEVNOTIFY hdevnotify)
{
    int cItem = _dpaNotifs ? _dpaNotifs.GetPtrCount() : 0;

    for (int i = 0; i < cItem; ++i)
    {
        PNPNOTIFENTRY* pneTmp = _dpaNotifs.GetPtr(i);
        
        if (pneTmp->hdevnotify == hdevnotify)
        {
            pneTmp->fStopSniffing = TRUE;

            // We don't check the return value.  The worst that will happen is that this
            // fails and we'll return too early and PnP will prompt the user to reboot.
            // Wait 2 minutes
            WaitForSingleObjectEx(pneTmp->hThread, 2 * 60 * 1000, FALSE);
        
            break;
        }
    }
    
    return S_OK;
}

BOOL CSniffDrive::_FoundEverything()
{
    return (_dwFound & DRIVEHAS_EVERYTHING) == DRIVEHAS_EVERYTHING;
}

CSniffDrive::CSniffDrive() : _dwFound(0)
{}

CSniffDrive::~CSniffDrive()
{}

void CMountPoint::SetAutorunStatus(BYTE* rgb, DWORD cbSize)
{
    RSSetBinaryValue(NULL, TEXT("_AutorunStatus"), rgb, cbSize);
}

class CAutoPlayVerb : public IDropTarget
{
public:
    CAutoPlayVerb() : _cRef(1) {}

    //  IUnknown refcounting
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void)
    {
       return ++_cRef;
    }

    STDMETHODIMP_(ULONG) Release(void)
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    // IDropTarget ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

protected:
    LONG _cRef;
};

HRESULT CAutoPlayVerb::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAutoPlayVerb, IDropTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

// IDropTarget::DragEnter
HRESULT CAutoPlayVerb::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return S_OK;;
}

// IDropTarget::DragOver
HRESULT CAutoPlayVerb::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return S_OK;;
}

// IDropTarget::DragLeave
HRESULT CAutoPlayVerb::DragLeave(void)
{
    return S_OK;
}

STDAPI CAutoPlayVerb_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;
    
    // aggregation checking is handled in class factory
    CAutoPlayVerb* p = new CAutoPlayVerb();
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

STDAPI SHChangeNotifyAutoplayDrive(PCWSTR pszDrive);

// IDropTarget::DragDrop
HRESULT CAutoPlayVerb::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    //  start the AutoPlayDialog
    WCHAR szDrive[4];
    HRESULT hr = PathFromDataObject(pdtobj, szDrive, ARRAYSIZE(szDrive));
    if (SUCCEEDED(hr))
    {
        hr = SHChangeNotifyAutoplayDrive(szDrive);
    }
    return hr;
}

DWORD CALLBACK _AutorunPromptProc(void *pv)
{
    WCHAR szDrive[4];
    CMountPoint::DoAutorun(PathBuildRoot(szDrive, PtrToInt(pv)), AUTORUNFLAG_MENUINVOKED);
    return 0;
}

void CMountPoint::DoAutorunPrompt(WPARAM iDrive)
{
    SHCreateThread(_AutorunPromptProc, (void *)iDrive, CTF_COINIT | CTF_REF_COUNTED, NULL);
}

STDAPI_(void) Activate_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    DWORD dwProcessID;
    HWND hwnd = GetShellWindow();

    GetWindowThreadProcessId(hwnd, &dwProcessID);

    AllowSetForegroundWindow(dwProcessID);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mtptevnt.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "mtpt.h"
#include "mtptl.h"
#include "mtptr.h"

#include "hwcmmn.h"
#include "cdburn.h"

#include "mixctnt.h"
#include "regsuprt.h"

// Misc comments:

// (1) Do a DoAutorun for all new drives except network ones.  These will be
//     generated externally... 

// static
void CMountPoint::WantAutorunUI(LPCWSTR pszDrive)
{
    int iDrive = DRIVEID(pszDrive);

    CMountPoint::_dwRemoteDriveAutorun |= (1 << iDrive);    
}

BOOL _Shell32LoadedInDesktop()
{
    static BOOL fLoadedInExplorer = -1;

    if (-1 == fLoadedInExplorer)
    {
        fLoadedInExplorer = BOOLFROMPTR(GetModuleHandle(TEXT("EXPLORER.EXE")));
    }

    return fLoadedInExplorer;
}

// static
void CMountPoint::OnNetShareArrival(LPCWSTR pszDrive)
{
    _csDL.Enter();

    if (!_fNetDrivesInited)
    {
        _InitNetDrives();
    }

    _csDL.Leave();

    if (_fNetDrivesInited)
    {
        WCHAR szDriveNoSlash[] = TEXT("A:");
        WCHAR szRemoteName[MAX_PATH];
        DWORD cchRemoteName = ARRAYSIZE(szRemoteName);
        HRESULT hr;
        int iDrive = DRIVEID(pszDrive);

        szDriveNoSlash[0] = *pszDrive;

        DWORD dw = WNetGetConnection(szDriveNoSlash, szRemoteName, &cchRemoteName);

        if (NO_ERROR == dw)
        {
            hr = CMtPtRemote::_CreateMtPtRemote(pszDrive, szRemoteName,
                TRUE);
        }
        else
        {
            DWORD dwGLD = GetLogicalDrives();

            if (dwGLD & (1 << iDrive))
            {
                // This must be a weird System mapped drive
                // which WNet... fcts don't like
                hr = CMtPtRemote::_CreateMtPtRemoteWithoutShareName(pszDrive);
            }
            else
            {
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr))
        {
            SHChangeNotify(SHCNE_DRIVEADD, SHCNF_PATH, pszDrive, NULL);

            if (CMountPoint::_dwRemoteDriveAutorun & (1 << iDrive))
            {
                DoAutorun(pszDrive, AUTORUNFLAG_MTPTARRIVAL);

                CMountPoint::_dwRemoteDriveAutorun &= ~(1 << iDrive);
            }
        }
    }
}

// static
void CMountPoint::OnNetShareRemoval(LPCWSTR pszDrive)
{
    _csDL.Enter();

    if (!_fNetDrivesInited)
    {
        _InitNetDrives();
    }

    _csDL.Leave();

    if (_fNetDrivesInited)
    {
        _RemoveNetMountPoint(pszDrive);

        SHChangeNotify(SHCNE_DRIVEREMOVED, SHCNF_PATH, pszDrive, NULL);

        // There's a possibility that this net drive was covering a local drive
        // with the same drive letter

        CMountPoint* pmtpt = CMountPoint::GetMountPoint(pszDrive);

        if (pmtpt)
        {
            if (CMountPoint::_IsDriveLetter(pszDrive))
            {
                CDBurn_OnDeviceChange(TRUE, pszDrive);
            }
     
            SHChangeNotify(SHCNE_DRIVEADD, SHCNF_PATH, pszDrive, NULL);

            pmtpt->Release();
        }
    }
}

// static
void CMountPoint::OnMediaArrival(LPCWSTR pszDrive)
{
    // Check if this local drive letter is not "covered" by a net
    // drive letter
    if (!_LocalDriveIsCoveredByNetDrive(pszDrive))
    {
        BOOL fDriveLetter = CMountPoint::_IsDriveLetter(pszDrive);

        if (fDriveLetter)
        {
            CDBurn_OnMediaChange(TRUE, pszDrive);
        }

        SHChangeNotify(SHCNE_MEDIAINSERTED, SHCNF_PATH, pszDrive, NULL);

        // for now do it only for drive letter mounted stuff 
        if (fDriveLetter)
        {
            // Send one of these for all media arrival events
            DoAutorun(pszDrive, AUTORUNFLAG_MEDIAARRIVAL);
        }

        // for the non net case force these through right away to make those
        // cd-rom autorun things come up faster
        SHChangeNotify(0, SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, NULL, NULL);
    }
}

// static
void CMountPoint::OnMountPointArrival(LPCWSTR pszDrive)
{
    // Check if this local drive letter is not "covered" by a net
    // drive letter
    _csDL.Enter();

    if (!_IsDriveLetter(pszDrive))
    {
        _rsMtPtsLocalMOF.RSSetTextValue(NULL, pszDrive, TEXT(""));        
    }

    _csDL.Leave();

    if (!_LocalDriveIsCoveredByNetDrive(pszDrive))
    {
        BOOL fDriveLetter = CMountPoint::_IsDriveLetter(pszDrive);
        LONG lEvent;

        if (fDriveLetter)
        {
            CDBurn_OnDeviceChange(TRUE, pszDrive);
            lEvent = SHCNE_DRIVEADD;
        }
        else
        {
            lEvent = SHCNE_UPDATEITEM;
        }

        SHChangeNotify(lEvent, SHCNF_PATH, pszDrive, NULL);

        if (fDriveLetter)
        {
            // If the DBTF_MEDIA is not set, do not send this notification for CDROM
            // or Removable as they may have come from a new device and not have any
            // media in them.  Also, when inserting a floppy drive (not media) in a
            // laptop, this would pop up a window.
            CMountPoint* pmtpt = CMountPoint::GetMountPoint(pszDrive);

            if (pmtpt)
            {
                if (pmtpt->_IsRemote() || pmtpt->_IsFixedDisk() ||
                    (pmtpt->_IsRemovableDevice() && !pmtpt->_IsFloppy()))
                {
                    DoAutorun(pszDrive, AUTORUNFLAG_MTPTARRIVAL);
                }

                pmtpt->Release();
            }
        }

        // for the non net case force these through right away to make those
        // cd-rom autorun things come up faster
        SHChangeNotify(0, SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, NULL, NULL);
    }
}

void _CloseAutoplayPrompt(LPCWSTR pszDriveOrDeviceID)
{
    HWND hwnd;

    if (_GetAutoplayPromptHWND(pszDriveOrDeviceID, &hwnd))
    {
        _RemoveFromAutoplayPromptHDPA(pszDriveOrDeviceID);

        EndDialog(hwnd, IDCANCEL);
    }
}

// static
void CMountPoint::OnMediaRemoval(LPCWSTR pszDrive)
{
    // Check if this local drive letter is not "covered" by a net
    // drive letter
    if (!_LocalDriveIsCoveredByNetDrive(pszDrive))
    {
        if (CMountPoint::_IsDriveLetter(pszDrive))
        {
            CDBurn_OnMediaChange(FALSE, pszDrive);
        }

        SHChangeNotify(SHCNE_MEDIAREMOVED, SHCNF_PATH, pszDrive, NULL);

        _CloseAutoplayPrompt(pszDrive);
    }
}

// static
void CMountPoint::OnMountPointRemoval(LPCWSTR pszDrive)
{
    // Check if this local drive letter is not "covered" by a net
    // drive letter
    _csDL.Enter();

    if (!_IsDriveLetter(pszDrive))
    {
        _rsMtPtsLocalMOF.RSSetTextValue(NULL, pszDrive, TEXT(""));        
    }

    _csDL.Leave();

    if (!_LocalDriveIsCoveredByNetDrive(pszDrive))
    {
        LONG lEvent;

        if (CMountPoint::_IsDriveLetter(pszDrive))
        {
            CDBurn_OnDeviceChange(FALSE, pszDrive);
            lEvent = SHCNE_DRIVEREMOVED;
        }
        else
        {
            lEvent = SHCNE_UPDATEITEM;
        }

        SHChangeNotify(lEvent, SHCNF_PATH, pszDrive, NULL);

        _CloseAutoplayPrompt(pszDrive);
    }
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// static
HRESULT CMountPoint::_MediaArrivalRemovalHelper(LPCWSTR pszDeviceIDVolume,
    BOOL fArrived)
{
    ASSERT(!_csDL.IsInside());

    HRESULT hr;
    HDPA hdpaPaths = DPA_Create(4);

    if (hdpaPaths)
    {
        hr = _GetMountPointsForVolume(pszDeviceIDVolume, hdpaPaths);

        if (SUCCEEDED(hr))
        {
            int n = DPA_GetPtrCount(hdpaPaths);

            for (int i = n - 1; i >= 0; --i)
            {
                LPCWSTR pszMtPt = (LPCWSTR)DPA_GetPtr(hdpaPaths, i);

                // We don't want to call OnMediaXxxal within the critical
                // sections
                ASSERT(!_csDL.IsInside());

                if (fArrived)
                {
                    CMountPoint::OnMediaArrival(pszMtPt);
                }
                else
                {
                    CMountPoint::OnMediaRemoval(pszMtPt);
                }

                LocalFree((HLOCAL)pszMtPt);
                DPA_DeletePtr(hdpaPaths, i);
            }
        }

        DPA_Destroy(hdpaPaths);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// static
HRESULT CMountPoint::_VolumeAddedOrUpdated(BOOL fAdded,
    VOLUMEINFO2* pvolinfo2)
{
    HRESULT hr = S_FALSE;
    HDPA hdpaMtPtsOld = NULL;
    CVolume* pvolOld = NULL;
    CVolume* pvolNew = NULL;
    BOOL fMediaPresenceChanged = FALSE;
    BOOL fMediaArrived;

    _csDL.Enter();

    if (!fAdded)
    {
        // Updated
        // That's a volume that some code might have a ptr to.  We need to drop
        // it from the list and create a new one.

        hdpaMtPtsOld = DPA_Create(3);

        if (hdpaMtPtsOld)
        {
            hr = CMtPtLocal::_GetAndRemoveVolumeAndItsMtPts(
                pvolinfo2->szDeviceIDVolume, &pvolOld, hdpaMtPtsOld);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Common to Add and Update
    if (SUCCEEDED(hr))
    {
        CMtPtLocal::_UpdateVolumeRegInfo2(pvolinfo2);

        hr = CMtPtLocal::_CreateVolumeFromVOLUMEINFO2(pvolinfo2, &pvolNew);
    }

    if (SUCCEEDED(hr))
    {
        if (!fAdded)
        {
            BOOL fLabelChanged;

            if (lstrcmp(pvolOld->pszLabel, pvolNew->pszLabel))
            {
                fLabelChanged = TRUE;
            }
            else
            {
                fLabelChanged = FALSE;
            }

            if (hdpaMtPtsOld)
            {
                // Create new MtPts from old ones
                int n = DPA_GetPtrCount(hdpaMtPtsOld);

                for (int i = 0; i < n; ++i)
                {
                    CMtPtLocal* pmtptl = (CMtPtLocal*)DPA_GetPtr(hdpaMtPtsOld, i);

                    if (pmtptl)
                    {
                        WCHAR szMountPoint[MAX_PATH];

                        HRESULT hrTmp = pmtptl->GetMountPointName(szMountPoint,
                            ARRAYSIZE(szMountPoint));

                        if (SUCCEEDED(hrTmp))
                        {
                            CMtPtLocal::_CreateMtPtLocalWithVolume(szMountPoint, pvolNew);
                            // for now don't care about return value

                            if (fLabelChanged)
                            {
                                SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_PATH,
                                    szMountPoint, szMountPoint);
                            }

                            if (pvolOld->dwMediaState != pvolNew->dwMediaState)
                            {
                                fMediaPresenceChanged = TRUE;
                                fMediaArrived = !!(HWDMS_PRESENT & pvolNew->dwMediaState);
                            }
                        }

                        // Get rid of old mtptl
                        pmtptl->Release();
                    }
                }

                SHChangeNotify(SHCNE_UPDATEIMAGE, SHCNF_DWORD,
                    IntToPtr(pvolOld->iShellImageForUpdateImage), NULL);

                DPA_Destroy(hdpaMtPtsOld);
            }

            if (pvolOld)
            {
                pvolOld->Release();
            }
        }

        pvolNew->Release();
    }

    _csDL.Leave();

    // Outside of the crit sect.
    if (fMediaPresenceChanged)
    {
        _MediaArrivalRemovalHelper(pvolinfo2->szDeviceIDVolume, fMediaArrived);
    }

    return hr;
}

// In theory, we should do the same as for VolumeUpdated, i.e. remove the volume
// from the DPA and all the mtpts, so that code which already has a pointer to it,
// will not see a change.  But the change we need to do is so tiny, that it would
// be overkill.  We're just going to flip a bit.

// static
HRESULT CMountPoint::_VolumeMountingEvent(LPCWSTR pszDeviceIDVolume, DWORD dwEvent)
{
    _csDL.Enter();

    CVolume* pvol = CMtPtLocal::_GetVolumeByID(pszDeviceIDVolume);

    _csDL.Leave();

    if (pvol)
    {
        if (SHHARDWAREEVENT_VOLUMEDISMOUNTED == dwEvent)
        {
            pvol->dwVolumeFlags |= HWDVF_STATE_DISMOUNTED;

            _MediaArrivalRemovalHelper(pszDeviceIDVolume, FALSE);
        }
        else
        {
            ASSERT(SHHARDWAREEVENT_VOLUMEMOUNTED == dwEvent);

            pvol->dwVolumeFlags &= ~HWDVF_STATE_DISMOUNTED;
        }

        pvol->Release();
    }

    return S_OK;
}
 
// static
HRESULT CMountPoint::_VolumeRemoved(
    LPCWSTR pszDeviceIDVolume)
{
    CVolume* pvol = CMtPtLocal::_GetAndRemoveVolumeByID(pszDeviceIDVolume);

    if (pvol)
    {
        CMtPtLocal::_rsVolumes.RSDeleteSubKey(pvol->pszVolumeGUID +
            OFFSET_GUIDWITHINVOLUMEGUID);
        
        // Final release
        pvol->Release();
    }

    return S_OK;
}

HRESULT CMountPoint::_MountPointAdded(
    LPCWSTR pszMountPoint,     // "c:\", or "d:\MountFolder\"
    LPCWSTR pszDeviceIDVolume)// \\?\STORAGE#Volume#...{...GUID...}
{
    HRESULT hrCreateMtPt;
    BOOL fCallOnMountPointArrival = TRUE;

    _csDL.Enter();

    CVolume* pvol = CMtPtLocal::_GetVolumeByID(pszDeviceIDVolume);

    CMtPtLocal* pMtPtLocal = CMountPoint::_rgMtPtDriveLetterLocal[DRIVEID(pszMountPoint)];

    if (pMtPtLocal && pMtPtLocal->_IsMiniMtPt())
    {
        // The WM_DEVICECHANGE message beated us, do not do the notif
        fCallOnMountPointArrival = FALSE;
    }

    if (pvol)
    {
        hrCreateMtPt = CMtPtLocal::_CreateMtPtLocalWithVolume(pszMountPoint, pvol);
    }

    _csDL.Leave();

    if (pvol)
    {
        if (SUCCEEDED(hrCreateMtPt) && fCallOnMountPointArrival)
        {
            CMountPoint::OnMountPointArrival(pszMountPoint);
        }

        pvol->Release();
    }
    else
    {
        hrCreateMtPt = E_FAIL;
    }

    return hrCreateMtPt;
}

HRESULT CMountPoint::_MountPointRemoved(
    LPCWSTR pszMountPoint)
{
    HRESULT hr;
    BOOL fCallOnMountPointRemoval = TRUE;

    _csDL.Enter();

    if (CMountPoint::_IsDriveLetter(pszMountPoint))
    {
        CMtPtLocal* pmtptl = CMountPoint::_rgMtPtDriveLetterLocal[DRIVEID(pszMountPoint)];
    
        if (!pmtptl || pmtptl->_IsMiniMtPt())
        {
            // The WM_DEVICECHANGE message beated us, do not do the notif
            fCallOnMountPointRemoval = FALSE;
        }
    }

    hr = CMountPoint::_RemoveLocalMountPoint(pszMountPoint);

    _csDL.Leave();

    if (SUCCEEDED(hr) && fCallOnMountPointRemoval)
    {
        CMountPoint::OnMountPointRemoval(pszMountPoint);
    }

    return hr;
}

HRESULT CMountPoint::_DeviceAdded(
    LPCWSTR pszDeviceID, GUID guidDeviceID)
{
    return S_FALSE;
}

HRESULT CMountPoint::_DeviceUpdated(
    LPCWSTR pszDeviceID)
{
    return S_FALSE;
}

// Both for devices and volumes
HRESULT CMountPoint::_DeviceRemoved(
    LPCWSTR pszDeviceID)
{
    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//static
void CMountPoint::HandleMountPointNetEvent(LPCWSTR pszDrive, BOOL fArrival)
{
    // These we need to send even if Shell Service is running
    if (fArrival)
    {
        CMountPoint::OnNetShareArrival(pszDrive);
    }
    else
    {
        CMountPoint::OnNetShareRemoval(pszDrive);
    }
}

struct HANDLEMOUNTPOINTLOCALEVENTSTRUCT
{
    WCHAR szDrive[4]; // can only be drive letter
    BOOL fMediaEvent;
};

// static
DWORD WINAPI CMountPoint::HandleMountPointLocalEventThreadProc(void* pv)
{
    HANDLEMOUNTPOINTLOCALEVENTSTRUCT* phmle =
        (HANDLEMOUNTPOINTLOCALEVENTSTRUCT*)pv;

    Sleep(3000);

    if (phmle->fMediaEvent)
    {
        // Nothing to do, we're not doing anything fancy in safe boot
        // mode, so no cache to reset, icons no change...

        // This is common to both Shell Service and non-Shell Service
        // notification, so do anything non Shell Service notif sepcific
        // above
        BOOL fIsMiniMtPt = FALSE;

        _csDL.Enter();

        CMtPtLocal* pMtPtLocal =
            CMountPoint::_rgMtPtDriveLetterLocal[DRIVEID(phmle->szDrive)];

        if (pMtPtLocal)
        {
            fIsMiniMtPt = pMtPtLocal->_IsMiniMtPt();
        }

        _csDL.Leave();

        if (fIsMiniMtPt)
        {
            HRESULT hr = SHCoInitialize();

            if (SUCCEEDED(hr))
            {
                CMountPoint::OnMediaArrival(phmle->szDrive);
            }

            SHCoUninitialize(hr);
        }
    }
    else
    {
        _csDL.Enter();

        CMtPtLocal* pMtPtLocal =
            CMountPoint::_rgMtPtDriveLetterLocal[DRIVEID(phmle->szDrive)];

        if (!pMtPtLocal)
        {
            // New local drive
            CMtPtLocal::_CreateMtPtLocal(phmle->szDrive);
        }

        _csDL.Leave();

        // Can check if pMtMtLocal is NULL or not, but cannot use it
        // might already have been freed.
        if (!pMtPtLocal)
        {
            HRESULT hr = SHCoInitialize();

            if (SUCCEEDED(hr))
            {
                // See comment above (This is common...)
                CMountPoint::OnMountPointArrival(phmle->szDrive);
            }

            SHCoUninitialize(hr);
        }
    }

    LocalFree((HLOCAL)phmle);

    return 0;
}

// fMedia: TRUE  -> Media
//         FALSE -> Drive
//static
void CMountPoint::HandleMountPointLocalEvent(LPCWSTR pszDrive, BOOL fArrival,
    BOOL fMediaEvent)
{
    if (fArrival)
    {
        // We might be racing with the shell service notification.
        HANDLEMOUNTPOINTLOCALEVENTSTRUCT* phmle = (HANDLEMOUNTPOINTLOCALEVENTSTRUCT*)LocalAlloc(LPTR,
            sizeof(HANDLEMOUNTPOINTLOCALEVENTSTRUCT));

        if (phmle)
        {
            lstrcpy(phmle->szDrive, pszDrive);
            phmle->fMediaEvent = fMediaEvent;
                
            if (!SHQueueUserWorkItem(HandleMountPointLocalEventThreadProc, phmle,
                0, (DWORD_PTR)0, (DWORD_PTR*)NULL, NULL, 0))
            {
                LocalFree((HLOCAL)phmle);
            }
        }
    }
    else
    {
        if (fMediaEvent)
        {
            // Nothing to do, we're not doing anything fancy in safe boot
            // mode, so no cache to reset, icons no change...

            // See comment above (This is common...)
            CMountPoint::OnMediaRemoval(pszDrive);
        }
        else
        {
            int iDrive = DRIVEID(pszDrive);
            BOOL fCallOnMountPointRemoval = TRUE;

            _csDL.Enter();

            if (_rgMtPtDriveLetterLocal[iDrive])
            {
                _rgMtPtDriveLetterLocal[iDrive]->Release();
                _rgMtPtDriveLetterLocal[iDrive] = NULL;
            }
            else
            {
                fCallOnMountPointRemoval = FALSE;
            }
        
            _csDL.Leave();

            // Can check if pMtMtLocal is NULL or not, but cannot use it
            // might already have been freed.
            if (fCallOnMountPointRemoval)
            {
                // See comment above (This is common...)
                CMountPoint::OnMountPointRemoval(pszDrive);
            }
        }
    }
}

//static
void CMountPoint::HandleWMDeviceChange(ULONG_PTR code, DEV_BROADCAST_HDR* pbh)
{
    if (DBT_DEVTYP_VOLUME == pbh->dbch_devicetype)
    {
        if ((DBT_DEVICEREMOVECOMPLETE == code) ||
            (DBT_DEVICEARRIVAL == code))
        {
            DEV_BROADCAST_VOLUME* pbv = (DEV_BROADCAST_VOLUME*)pbh;
            BOOL fIsNetEvent = !!(pbv->dbcv_flags & DBTF_NET);
            BOOL fIsMediaEvent = !!(pbv->dbcv_flags & DBTF_MEDIA);

            for (int iDrive = 0; iDrive < 26; ++iDrive)
            {
                if ((1 << iDrive) & pbv->dbcv_unitmask)
                {
                    TCHAR szPath[4];

                    if (DBT_DEVICEARRIVAL == code)
                    {
                        // Subst drive have the netevent flag on: bad.
                        PathBuildRoot(szPath, iDrive);

                        // Check if this is the arrival of a subst drive
                        if (DRIVE_REMOTE != GetDriveType(szPath))
                        {
                            // Yep.
                            fIsNetEvent = FALSE;
                        }
                        else
                        {
                            fIsNetEvent = TRUE;
                        }
                    }
                    else
                    {
                        _csDL.Enter();

                        CMtPtLocal* pMtPtLocal =
                            CMountPoint::_rgMtPtDriveLetterLocal[iDrive];
                        
                        if (pMtPtLocal)
                        {
                            fIsNetEvent = FALSE;
                        }

                        _csDL.Leave();
                    }

                    if (fIsNetEvent)
                    {
                        HandleMountPointNetEvent(PathBuildRoot(szPath, iDrive),
                            DBT_DEVICEARRIVAL == code);
                    }
                    else
                    {
                        HandleMountPointLocalEvent(PathBuildRoot(szPath, iDrive),
                            DBT_DEVICEARRIVAL == code, fIsMediaEvent);
                    }
                }
            }
        }
    }
}

// static
void CMountPoint::NotifyUnavailableNetDriveGone(LPCWSTR pszMountPoint)
{
    CMountPoint::_RemoveNetMountPoint(pszMountPoint);
}

// static
void CMountPoint::NotifyReconnectedNetDrive(LPCWSTR pszMountPoint)
{
    CMtPtRemote::_NotifyReconnectedNetDrive(pszMountPoint);
}

// static
DWORD CALLBACK CMountPoint::_EventProc(void* pv)
{
    SHHARDWAREEVENT* pshhe = (SHHARDWAREEVENT*)pv;
    BOOL fLocalDrivesInited;

    _csDL.Enter();

    fLocalDrivesInited = _fLocalDrivesInited;

    _csDL.Leave();

    // If the Local Drives info was not initialized there's nothing to update.
    if (fLocalDrivesInited)
    {
        switch (pshhe->dwEvent)
        {
            case SHHARDWAREEVENT_VOLUMEARRIVED:
            case SHHARDWAREEVENT_VOLUMEUPDATED:
            {
                VOLUMEINFO2* pvolinfo2 = (VOLUMEINFO2*)pshhe->rgbPayLoad;

                CMountPoint::_VolumeAddedOrUpdated(
                    (SHHARDWAREEVENT_VOLUMEARRIVED == pshhe->dwEvent), pvolinfo2);
                break;
            }
            case SHHARDWAREEVENT_VOLUMEREMOVED:
            {
                LPCWSTR pszDeviceIDVolume = (LPCWSTR)pshhe->rgbPayLoad;

                CMountPoint::_VolumeRemoved(pszDeviceIDVolume);
                break;
            }
            case SHHARDWAREEVENT_MOUNTPOINTARRIVED:
            {
                MTPTADDED* pmtptadded = (MTPTADDED*)pshhe->rgbPayLoad;

                CMountPoint::_MountPointAdded(pmtptadded->szMountPoint,
                    pmtptadded->szDeviceIDVolume);
                break;
            }
            case SHHARDWAREEVENT_MOUNTPOINTREMOVED:
            {
                LPCWSTR pszMountPoint = (LPCWSTR)pshhe->rgbPayLoad;

                CMountPoint::_MountPointRemoved(pszMountPoint);
                break;
            }
            case SHHARDWAREEVENT_VOLUMEDISMOUNTED:
            case SHHARDWAREEVENT_VOLUMEMOUNTED:
            {
                LPCWSTR pszDeviceIDVolume = (LPCWSTR)pshhe->rgbPayLoad;

                CMountPoint::_VolumeMountingEvent(pszDeviceIDVolume, pshhe->dwEvent);
                break;
            }
        }
    }

    switch (pshhe->dwEvent)
    {
        case SHHARDWAREEVENT_DEVICEARRIVED:
        case SHHARDWAREEVENT_DEVICEUPDATED:
        case SHHARDWAREEVENT_DEVICEREMOVED:
        {
            HWDEVICEINFO* phwdevinfo = (HWDEVICEINFO*)pshhe->rgbPayLoad;

            if (SHHARDWAREEVENT_DEVICEARRIVED == pshhe->dwEvent)
            {
                if (HWDDF_HASDEVICEHANDLER & phwdevinfo->dwDeviceFlags)
                {
                    CCrossThreadFlag* pDeviceGoneFlag = new CCrossThreadFlag();

                    if (pDeviceGoneFlag)
                    {
                        if (pDeviceGoneFlag->Init())
                        {
                            AttachGoneFlagForDevice(phwdevinfo->szDeviceIntfID, pDeviceGoneFlag);

                            DoDeviceNotification(phwdevinfo->szDeviceIntfID, TEXT("DeviceArrival"),
                                pDeviceGoneFlag);
                        }

                        pDeviceGoneFlag->Release();
                    }
                }
            }
            else
            {
                if (SHHARDWAREEVENT_DEVICEREMOVED == pshhe->dwEvent)
                {
                    CCrossThreadFlag* pDeviceGoneFlag;

                    if (GetGoneFlagForDevice(phwdevinfo->szDeviceIntfID, &pDeviceGoneFlag))
                    {
                        pDeviceGoneFlag->Signal();
                        pDeviceGoneFlag->Release();
                    }

                    _CloseAutoplayPrompt(phwdevinfo->szDeviceIntfID);
                }
            }
            
            LPITEMIDLIST pidl;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidl)))
            {
                //  wait for WIA to do its stuff
                Sleep(5000);

                SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidl, NULL);
                ILFree(pidl);
            }
            break;
        }

        default:
            // That's no good
            break;
    }
    
    VirtualFree(pv, 0, MEM_RELEASE);

    return 0;
}

// static
void CALLBACK CMountPoint::_EventAPCProc(ULONG_PTR ulpParam)
{
    if (!SHCreateThread(CMountPoint::_EventProc, (void*)ulpParam, CTF_COINIT | CTF_REF_COUNTED, NULL))
    {
        VirtualFree((void*)ulpParam, 0, MEM_RELEASE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mtptlis.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "mtptl.h"

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
// Lies in Safe boot mode about floppies
BOOL CMtPtLocal::_IsStrictRemovable()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwDriveType & HWDTS_REMOVABLEDISK;
    }
    else
    {
        fRet = FALSE;

        if (GetDriveType(_GetNameForFctCall()) == DRIVE_REMOVABLE)
        {
            WCHAR ch = _GetNameFirstCharUCase();

            if ((TEXT('A') != ch) || (TEXT('B') != ch))
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

BOOL CMtPtLocal::_IsFixedDisk()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwDriveType & HWDTS_FIXEDDISK;
    }
    else
    {
        fRet = (GetDriveType(_GetNameForFctCall()) == DRIVE_FIXED);
    }

    return fRet;
}

BOOL CMtPtLocal::_IsFloppy()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwDriveType & (HWDTS_FLOPPY35 | HWDTS_FLOPPY525);
    }
    else
    {
        fRet = FALSE;

        if (GetDriveType(_GetNameForFctCall()) == DRIVE_REMOVABLE)
        {
            WCHAR ch = _GetNameFirstCharUCase();

            if ((TEXT('A') == ch) || (TEXT('B') == ch))
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

// Lies in Safe boot mode about floppies
BOOL CMtPtLocal::_IsFloppy35()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwDriveType & HWDTS_FLOPPY35;
    }
    else
    {
        fRet = FALSE;

        if (GetDriveType(_GetNameForFctCall()) == DRIVE_REMOVABLE)
        {
            WCHAR ch = _GetNameFirstCharUCase();

            if (TEXT('A') == ch)
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

// Lies in Safe boot mode about floppies
BOOL CMtPtLocal::_IsFloppy525()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwDriveType & HWDTS_FLOPPY525;
    }
    else
    {
        fRet = FALSE;

        if (GetDriveType(_GetNameForFctCall()) == DRIVE_REMOVABLE)
        {
            WCHAR ch = _GetNameFirstCharUCase();

            if (TEXT('B') == ch)
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

BOOL CMtPtLocal::_IsCDROM()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwDriveType & HWDTS_CDROM;
    }
    else
    {
        fRet = (GetDriveType(_GetNameForFctCall()) == DRIVE_CDROM);
    }

    return fRet;
}

BOOL CMtPtLocal::_IsAudioCD()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwMediaCap & HWDMC_HASAUDIOTRACKS;
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

BOOL CMtPtLocal::_IsAudioCDNoData()
{
    return _IsAudioCD() && !(_pvol->dwMediaCap & HWDMC_HASDATATRACKS);
}

BOOL CMtPtLocal::_IsDVDRAMMedia()
{
    BOOL fRetVal = FALSE;

    if (_CanUseVolume())
    {
        fRetVal = ((HWDDC_CAPABILITY_SUPPORTDETECTION & _pvol->dwDriveCapability) &&
                   (HWDMC_WRITECAPABILITY_SUPPORTDETECTION & _pvol->dwMediaCap) &&
                   (_pvol->dwMediaCap & HWDMC_DVDRAM) && 
                   (_pvol->dwDriveCapability & HWDDC_DVDRAM));
    }

    return fRetVal;
}

BOOL CMtPtLocal::_IsFormattable()
{
    return (_IsStrictRemovable() || _IsFixedDisk() || _IsFloppy() || _IsDVDRAMMedia());
}

/*BOOL CMtPtLocal::_IsDVDMedia()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        if (HWDMC_WRITECAPABILITY_SUPPORTDETECTION & _pvol->dwMediaCap)
        {
            fRet = !!(_pvol->dwMediaCap &
                (HWDMC_DVDROM | HWDMC_DVDRECORDABLE | HWDMC_DVDRAM));
        }
        else
        {
            fRet = FALSE;
        }
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}*/

BOOL CMtPtLocal::_IsDVD()
{
    return _IsDVDDisc();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mxctdlg.h ===
#ifndef MXCTDLG_H
#define MXCTDLG_H

#include "hwprompt.h"

#define MAX_DEVICENAME      50

class CMixedContentDlg : public CHWPromptDlg
{
public:
    CMixedContentDlg();

protected:
    virtual ~CMixedContentDlg();
    HRESULT _FillListView();
    HRESULT _InitStatics();
    HRESULT _InitSelections();

private:
    LPWSTR              _rgpszContentTypeFN[5];
    DWORD               _cContentTypeFN;
};

#endif //MXCTDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mtptris.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "mtptr.h"

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMtPtRemote::_IsRemote()
{
    return TRUE;
}

BOOL CMtPtRemote::_IsSlow()
{
    BOOL fRet = FALSE;
    DWORD dwSpeed = _GetPathSpeed();
    
    if ((0 != dwSpeed) && (dwSpeed <= SPEED_SLOW))
    {
        fRet = TRUE;
    }

    TraceMsg(TF_MOUNTPOINT, "static CMountPoint::_IsSlow: for '%s'", _GetNameDebug());

    return fRet;
}

BOOL CMtPtRemote::_IsAutorun()
{
    return _pshare->fAutorun;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mtptr2.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "shitemid.h"
#include "ids.h"
#include "hwcmmn.h"

#include "mtptr.h"

#ifdef DEBUG
DWORD CMtPtRemote::_cMtPtRemote = 0;
DWORD CShare::_cShare = 0;
#endif

///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
HRESULT CMtPtRemote::SetLabel(HWND hwnd, LPCTSTR pszLabel)
{
    TraceMsg(TF_MOUNTPOINT, "CMtPtRemote::SetLabel: for '%s'", _GetNameDebug());

    RSSetTextValue(NULL, TEXT("_LabelFromReg"), pszLabel,
        REG_OPTION_NON_VOLATILE);

    // we notify for only the current drive (no folder mounted drive)
    SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_PATH, _GetName(), _GetName());

    return S_OK;
}

BOOL CMtPtRemote::IsDisconnectedNetDrive()
{
    return !_IsConnected();
}

// Expensive, do not call for nothing
BOOL CMtPtRemote::IsFormatted()
{
    return (0xFFFFFFFF != GetFileAttributes(_GetNameForFctCall()));
}

BOOL CMtPtRemote::_GetComputerDisplayNameFromReg(LPTSTR pszLabel, DWORD cchLabel)
{
    *pszLabel = 0;

    return (RSGetTextValue(NULL, TEXT("_ComputerDisplayName"), pszLabel, &cchLabel));
}

HRESULT CMtPtRemote::_GetDefaultUNCDisplayName(LPTSTR pszLabel, DWORD cchLabel)
{
    HRESULT hr = E_FAIL;
    LPTSTR pszShare, pszT;
    TCHAR szTempUNCPath[MAX_PATH];

    pszLabel[0] = TEXT('\0');

    if (!_pshare->fFake)
    {
        // Why would it not be a UNC name?
        if (PathIsUNC(_GetUNCName()))
        {
            // Now we need to handle 3 cases.
            // The normal case: \\pyrex\user
            // The Netware setting root: \\strike\sys\public\dist
            // The Netware CD?            \\stike\sys \public\dist
            lstrcpyn(szTempUNCPath, _GetUNCName(), ARRAYSIZE(szTempUNCPath));
            pszT = StrChr(szTempUNCPath, TEXT(' '));
            while (pszT)
            {
                pszT++;
                if (*pszT == TEXT('\\'))
                {
                    // The netware case of \\strike\sys \public\dist
                    *--pszT = 0;
                    break;
                }
                pszT = StrChr(pszT, TEXT(' '));
            }

            pszShare = StrRChr(szTempUNCPath, NULL, TEXT('\\'));
            if (pszShare)
            {
                *pszShare++ = 0;
                PathMakePretty(pszShare);

                // pszServer should always start at char 2.
                if (szTempUNCPath[2])
                {
                    LPTSTR pszServer, pszSlash;

                    pszServer = &szTempUNCPath[2];
                    for (pszT = pszServer; pszT != NULL; pszT = pszSlash)
                    {
                        pszSlash = StrChr(pszT, TEXT('\\'));
                        if (pszSlash)
                            *pszSlash = 0;

                        PathMakePretty(pszT);
                        if (pszSlash)
                            *pszSlash++ = TEXT('\\');
                    }

                    TCHAR szDisplay[MAX_PATH];
                    hr = SHGetComputerDisplayName(pszServer, 0x0, szDisplay, ARRAYSIZE(szDisplay));
                    if (FAILED(hr))
                    {
                        *szDisplay = 0;
                    }

                    if (SUCCEEDED(hr))
                    {
                        LPTSTR pszLabel2 = ShellConstructMessageString(HINST_THISDLL,
                                MAKEINTRESOURCE(IDS_UNC_FORMAT), pszShare, szDisplay);

                        if (pszLabel2)
                        {
                            lstrcpyn(pszLabel, pszLabel2, cchLabel);
                            LocalFree(pszLabel2);
                        }
                        else
                        {
                            *pszLabel = TEXT('\0');
                        }
                    }
                }
            }
        }
    }

    return hr;
}

int CMtPtRemote::GetDriveFlags()
{
    // By default every drive type is ShellOpen, except CD-ROMs
    UINT uDriveFlags = DRIVE_SHELLOPEN;

    if (_IsAutorun())
    {
        uDriveFlags |= DRIVE_AUTORUN;

        //FEATURE should we set AUTOOPEN based on a flag in the AutoRun.inf???
        uDriveFlags |= DRIVE_AUTOOPEN;
    }

    if (_IsConnected())
    {
        if ((0 != _dwSpeed) && (_dwSpeed <= SPEED_SLOW))
        {
            uDriveFlags |= DRIVE_SLOW;
        }
    }

    return TRUE;
}

void CMtPtRemote::_CalcPathSpeed()
{
    _dwSpeed = 0;

    NETCONNECTINFOSTRUCT nci = {0};
    NETRESOURCE nr = {0};
    TCHAR szPath[3];

    nci.cbStructure = sizeof(nci);

    // we are passing in a local drive and MPR does not like us to pass a
    // local name as Z:\ but only wants Z:
    _GetNameFirstXChar(szPath, 2 + 1);
    
    nr.lpLocalName = szPath;

    // dwSpeed is returned by MultinetGetConnectionPerformance
    MultinetGetConnectionPerformance(&nr, &nci);

    _dwSpeed = nci.dwSpeed;
}

// Imported from fsnotify.c
STDAPI_(void) SHChangeNotifyRegisterAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);
//
// If a mount point is for a remote path (UNC), it needs to respond
// to shell changes identified by both UNC and local drive path (L:\).
// This function performs this registration.
//
HRESULT CMtPtRemote::ChangeNotifyRegisterAlias(void)
{
    HRESULT hr = E_FAIL;

    // Don't wake up sleeping net connections
    if (_IsConnected() && !(_pshare->fFake))
    {
        LPITEMIDLIST pidlLocal = SHSimpleIDListFromPath(_GetName());
        if (NULL != pidlLocal)
        {
            LPITEMIDLIST pidlUNC = SHSimpleIDListFromPath(_GetUNCName());
            if (NULL != pidlUNC)
            {
                SHChangeNotifyRegisterAlias(pidlUNC, pidlLocal);
                ILFree(pidlUNC);
                hr = NOERROR;
            }
            ILFree(pidlLocal);
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  Temp  /////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void _UpdateGFAAndGVIInfoHelper(LPCWSTR pszDrive, CShare* pshare)
{
    pshare->dwGetFileAttributes = GetFileAttributes(pszDrive);

    if (-1 != pshare->dwGetFileAttributes)
    {
        pshare->fGVIRetValue = GetVolumeInformation(pszDrive,
            pshare->szLabel, ARRAYSIZE(pshare->szLabel),
            &(pshare->dwSerialNumber), &(pshare->dwMaxFileNameLen),
            &(pshare->dwFileSystemFlags), pshare->szFileSysName,
            ARRAYSIZE(pshare->szFileSysName));
    }
}

struct GFAGVICALL
{
    HANDLE hEventBegun;
    HANDLE hEventFinish;
    WCHAR szDrive[4];
    CShare* pshare;
};

void _FreeGFAGVICALL(GFAGVICALL* pgfagvicall)
{
    if (pgfagvicall->hEventBegun)
    {
        CloseHandle(pgfagvicall->hEventBegun);
    }

    if (pgfagvicall->hEventFinish)
    {
        CloseHandle(pgfagvicall->hEventFinish);
    }

    if (pgfagvicall->pshare)
    {
        pgfagvicall->pshare->Release();
    }

    if (pgfagvicall)
    {
        LocalFree(pgfagvicall);
    }
}

DWORD WINAPI _UpdateGFAAndGVIInfoCB(LPVOID pv)
{
    GFAGVICALL* pgfagvicall = (GFAGVICALL*)pv;

    SetEvent(pgfagvicall->hEventBegun);

    _UpdateGFAAndGVIInfoHelper(pgfagvicall->szDrive, pgfagvicall->pshare);

    SetEvent(pgfagvicall->hEventFinish);

    _FreeGFAGVICALL(pgfagvicall);

    return 0;
}

GFAGVICALL* CMtPtRemote::_PrepareThreadParam(HANDLE* phEventBegun,
    HANDLE* phEventFinish)
{
    BOOL fSucceeded = FALSE;
    *phEventBegun = NULL;
    *phEventFinish = NULL;

    GFAGVICALL* pgfagvicall = (GFAGVICALL*)LocalAlloc(LPTR,
        sizeof(GFAGVICALL));

    if (pgfagvicall)
    {
        pgfagvicall->hEventBegun = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (pgfagvicall->hEventBegun)
        {
            HANDLE hCurrentProcess = GetCurrentProcess();

            if (DuplicateHandle(hCurrentProcess, pgfagvicall->hEventBegun,
                hCurrentProcess, phEventBegun, 0, FALSE,
                DUPLICATE_SAME_ACCESS))
            {
                pgfagvicall->hEventFinish = CreateEvent(NULL, FALSE, FALSE, NULL);

                if (pgfagvicall->hEventFinish)
                {
                    if (DuplicateHandle(hCurrentProcess,
                        pgfagvicall->hEventFinish, hCurrentProcess,
                        phEventFinish, 0, FALSE, DUPLICATE_SAME_ACCESS))
                    {
                        _pshare->AddRef();
                        pgfagvicall->pshare = _pshare;

                        StrCpyN(pgfagvicall->szDrive, _GetName(),
                            ARRAYSIZE(pgfagvicall->szDrive));

                        fSucceeded = TRUE;
                    }
                }
            }
        }
    }

    if (!fSucceeded)
    {
        if (*phEventBegun)
        {
            CloseHandle(*phEventBegun);
        }

        if (pgfagvicall)
        {
            _FreeGFAGVICALL(pgfagvicall);
            pgfagvicall = NULL;
        }
    }

    return pgfagvicall;
}

// Expiration: 35 secs (what we shipped W2K with)
BOOL CMtPtRemote::_HaveGFAAndGVIExpired(DWORD dwNow)
{
    BOOL fExpired = FALSE;

    // Check also for the wrapping case first.
    if ((_pshare->dwGFAGVILastCall > dwNow) ||
        ((dwNow - _pshare->dwGFAGVILastCall) > 35 * 1000))
    {
        fExpired = TRUE;
    }
    else
    {
        fExpired = FALSE;
    }

    return fExpired;
}

// We launch a thread so that we won't be jammed on this for more than 10 sec.
// If the thread times out, we use the cache value but do not reset the cache
// values.  They're better than nothing.  We do reset the cache last tick count
// so that we do not send another thread to jam here before at least 35 sec.

// Return TRUE or FALSE to tell us if timed out or not.  For GFA and GVI
// success/failure check (-1 != dwGetFileAttributes) && (_fGVIRetValue)
BOOL CMtPtRemote::_UpdateGFAAndGVIInfo()
{
    BOOL fRet = TRUE;
    DWORD dwNow = GetTickCount();

    if (_HaveGFAAndGVIExpired(dwNow))
    {
        _pshare->dwGFAGVILastCall = dwNow;

        BOOL fGoSync = TRUE;
        HANDLE hEventBegun;
        HANDLE hEventFinish;

        GFAGVICALL* pgfagvicall = _PrepareThreadParam(&hEventBegun,
            &hEventFinish);

        if (pgfagvicall)
        {
            if (SHQueueUserWorkItem(_UpdateGFAAndGVIInfoCB, pgfagvicall,
                0, (DWORD_PTR)0, (DWORD_PTR*)NULL, NULL, 0))
            {
                DWORD dw = WaitForSingleObject(hEventFinish, 10 * 1000);

                if (WAIT_TIMEOUT == dw)
                {
                    // we timed out!
                    fRet = FALSE;

                    if (WAIT_OBJECT_0 != WaitForSingleObject(
                        hEventBegun, 0))
                    {
                        // since the thread started, we know that
                        // this call is _really_ slow!
                        fGoSync = FALSE;
                    }
                    else
                    {
                        // our work item was never queued, so we
                        // fall through to the fGoSync case below
                    }
                }
            }
            else
            {
                _FreeGFAGVICALL(pgfagvicall);
            }

            CloseHandle(hEventBegun);
            CloseHandle(hEventFinish);
        }
        
        if (fGoSync)
        {
            // we should come here if we failed to create our workitem
            // or our workitem was never queued
            _UpdateGFAAndGVIInfoHelper(_GetName(), _pshare);
            fRet = TRUE;
        }
    }

    return fRet;
}

BOOL CMtPtRemote::_GetFileAttributes(DWORD* pdwAttrib)
{
    if (_UpdateGFAAndGVIInfo())
    {
        *pdwAttrib = _pshare->dwGetFileAttributes;
    }
    else
    {
        *pdwAttrib = -1;
    }

    return (-1 != *pdwAttrib);
}

// { DRIVE_ISCOMPRESSIBLE | DRIVE_LFN | DRIVE_SECURITY }
int CMtPtRemote::_GetGVIDriveFlags()
{
    int iFlags = 0;

    if (_UpdateGFAAndGVIInfo())
    {
        if (_pshare->fGVIRetValue)
        {
            // The file attrib we received at the begginning should be
            // valid, do not touch the drive for nothing
            if (_pshare->dwFileSystemFlags & FS_FILE_COMPRESSION)
            {
                iFlags |= DRIVE_ISCOMPRESSIBLE;
            }

            // Volume supports long filename (greater than 8.3)?
            if (_pshare->dwMaxFileNameLen > 12)
            {
                iFlags |= DRIVE_LFN;
            }

            // Volume supports security?
            if (_pshare->dwFileSystemFlags & FS_PERSISTENT_ACLS)
            {
                iFlags |= DRIVE_SECURITY;
            }
        }
    }

    return iFlags;
}

BOOL CMtPtRemote::_GetSerialNumber(DWORD* pdwSerialNumber)
{
    BOOL fRet = FALSE;

    if (_UpdateGFAAndGVIInfo())
    {
        if (_pshare->fGVIRetValue)
        {
            *pdwSerialNumber = _pshare->dwSerialNumber;
            fRet = TRUE;
        }
    }

    // No reg stuff

    return fRet;
}

BOOL CMtPtRemote::_GetGVILabel(LPTSTR pszLabel, DWORD cchLabel)
{
    BOOL fRet = FALSE;

    *pszLabel = 0;

    if (_UpdateGFAAndGVIInfo())
    {
        if (_pshare->fGVIRetValue)
        {
            lstrcpyn(pszLabel, _pshare->szLabel, cchLabel);
            fRet = TRUE;
        }
    }

    // No reg stuff

    return fRet;
}

BOOL CMtPtRemote::_GetGVILabelOrMixedCaseFromReg(LPTSTR pszLabel, DWORD cchLabel)
{
    return _GetGVILabel(pszLabel, cchLabel);
}

BOOL CMtPtRemote::_GetFileSystemFlags(DWORD* pdwFlags)
{
    BOOL fRet = FALSE;
    
    *pdwFlags = 0;

    if (_UpdateGFAAndGVIInfo())
    {
        if (_pshare->fGVIRetValue)
        {
            *pdwFlags = _pshare->dwFileSystemFlags;
            fRet = TRUE;
        }
    }

    return fRet;
}

BOOL CMtPtRemote::_GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName)
{
    BOOL fRet = FALSE;

    *pszFileSysName = 0;

    if (_UpdateGFAAndGVIInfo())
    {
        if (_pshare->fGVIRetValue)
        {
            StrCpyN(pszFileSysName, _pshare->szFileSysName, cchFileSysName);
            fRet = TRUE;
        }
    }

    return fRet;
}

DWORD CMtPtRemote::GetShellDescriptionID()
{
    return SHDID_COMPUTER_NETDRIVE;
}
///////////////////////////////////////////////////////////////////////////////
//  New  //////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
UINT CMtPtRemote::_GetAutorunIcon(LPTSTR pszModule, DWORD cchModule)
{
    int iIcon = -1;

    if (RSGetTextValue(TEXT("_Autorun\\DefaultIcon"), NULL, pszModule,
        &cchModule))
    {
        iIcon = PathParseIconLocation(pszModule);
    }
    
    return iIcon;
}

UINT CMtPtRemote::GetIcon(LPTSTR pszModule, DWORD cchModule)
{
    BOOL fFoundIt = FALSE;
    UINT iIcon = II_DRIVENET;

    *pszModule = 0;

    // Autorun first
    // Fancy icon (Autoplay) second 
    // Legacy drive icons last

    if (_IsAutorun())
    {
        iIcon = _GetAutorunIcon(pszModule, cchModule);

        if (-1 != iIcon)
        {
            fFoundIt = TRUE;
        }
    }
    
    if (!fFoundIt)
    {
        if (_pszLegacyRegIcon)
        {
            if (RSGetTextValue(TEXT("DefaultIcon"), NULL, pszModule,
                &cchModule))
            {
                iIcon = PathParseIconLocation(pszModule);
            }
            else
            {
                *pszModule = 0;
            }
        }
        else
        {
            if (_IsUnavailableNetDrive())
            {
                iIcon = II_DRIVENETDISABLED;
            }
        }
    }
    
    if (*pszModule)
        TraceMsg(TF_MOUNTPOINT, "CMtPtRemote::GetIcon: for '%s', chose '%s', '%d'", _GetNameDebug(), pszModule, iIcon);
    else
        TraceMsg(TF_MOUNTPOINT, "CMtPtRemote::GetIcon: for '%s', chose '%d'", _GetNameDebug(), iIcon);

    return iIcon;
}

void CMtPtRemote::GetTypeString(LPTSTR pszType, DWORD cchType)
{
    int iID;

    *pszType = 0;

    if (_IsConnected())
    {
        iID = IDS_DRIVES_NETDRIVE;
    }
    else
    {
        iID = IDS_DRIVES_NETUNAVAIL;
    }

    LoadString(HINST_THISDLL, iID, pszType, cchType);
}

HRESULT CMtPtRemote::GetLabelNoFancy(LPTSTR pszLabel, DWORD cchLabel)
{
    HRESULT hr;

    if (_UpdateGFAAndGVIInfo())
    {
        lstrcpyn(pszLabel, _pshare->szLabel, cchLabel);
        hr = S_OK;
    }
    else
    {
        *pszLabel = 0;
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CMtPtRemote::GetLabel(LPTSTR pszLabel, DWORD cchLabel)
{
    HRESULT hres = E_FAIL;

    ASSERT(pszLabel);

    *pszLabel = 0;
        
    // Do we already have a label from the registry for this volume?
    // (the user may have renamed this drive)

    if (!_GetLabelFromReg(pszLabel, cchLabel))
    {
        // No

        // Do we have a name from the server?
        if (!_GetLabelFromDesktopINI(pszLabel, cchLabel))
        {
            // No
            // We should build up the display name ourselves
            hres = _GetDefaultUNCDisplayName(pszLabel, cchLabel);

            if (SUCCEEDED(hres) && *pszLabel)
            {
                hres = S_OK;
            }
        }
        else
        {
            hres = S_OK;
        }
    }
    else
    {
        hres = S_OK;
    }

    if (FAILED(hres))
    {
        GetTypeString(pszLabel, cchLabel);
        hres = S_OK;
    }

    return hres;
}

HRESULT CMtPtRemote::GetRemotePath(LPWSTR pszPath, DWORD cchPath)
{
    *pszPath = 0;
    if (!_pshare->fFake)
        StrCpyN(pszPath, _pshare->pszRemoteName, cchPath);

    return (pszPath[0]) ? S_OK : E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
// Connection status
///////////////////////////////////////////////////////////////////////////////
// We cannot cache the connection status.  This is already cached at the redirector level.
// When calling the WNetGetConnection fcts you get what's cache there, no check is actually
// done on the network to see if this information is accurate (OK/Disconnected/Unavailable).
// The information is updated only when the share is actually accessed (e.g: GetFileAttributes)
// 
// So we need to always do the calls (fortunately non-expensive) so that we get the most
// up to date info.  Otherwise the following was occuring: A user double click a map drive
// from the Explorer's Listview, WNetConnection gets called and we get the OK cached value 
// from the redirector.  Some other code actually try to access the share, and the redirector 
// realize that the share is not there and set its cache to Disconnected.  We are queried
// again for the state of the connection to update the icon, if we cached this info we
// return OK, if we ask for it (0.1 sec after the first call to WNetGetConnection) we get
// Disconnected. (stephstm 06/02/99)

void CMtPtRemote::_UpdateWNetGCStatus()
{
    TCHAR szRemoteName[MAX_PATH];
    DWORD cchRemoteName = ARRAYSIZE(szRemoteName);
    TCHAR szPath[3];

    // WNetConnection does not take a trailing slash
    _dwWNetGCStatus = WNetGetConnection(
        _GetNameFirstXChar(szPath, 2 + 1), szRemoteName, &cchRemoteName);
}

BOOL CMtPtRemote::IsUnavailableNetDrive()
{
    return _IsUnavailableNetDrive();
}

BOOL CMtPtRemote::_IsUnavailableNetDrive()
{
    BOOL fUnavail = TRUE;
    BOOL fPrevUnavail = _IsUnavailableNetDriveFromStateVar();

    _UpdateWNetGCStatus();

    fUnavail = (ERROR_CONNECTION_UNAVAIL == _dwWNetGCStatus);

    if (fPrevUnavail != fUnavail)
    {
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, _GetName(), NULL);
    }

    return fUnavail;
}

BOOL CMtPtRemote::_IsUnavailableNetDriveFromStateVar()
{
    return (ERROR_CONNECTION_UNAVAIL == _dwWNetGCStatus);
}

BOOL CMtPtRemote::_IsConnected()
{
    BOOL fConnected = TRUE;

    _UpdateWNetGCStatus();

    // This whole if/else statement is the same thing as
    // _IsConnectedFromStateVar() except that we will avoid calling
    // WNetGetConnection3 if possible (optimization)

    if (NO_ERROR != _dwWNetGCStatus)
    {
        fConnected = FALSE;
    }
    else
    {
        DWORD dwSize = sizeof(_wngcs);
        TCHAR szPath[3]; 

        _dwWNetGC3Status = WNetGetConnection3(
            _GetNameFirstXChar(szPath, 2 + 1), NULL,
            WNGC_INFOLEVEL_DISCONNECTED, &_wngcs, &dwSize);

        // Did we succeeded the call to WNetGetConnection 3 and it returned
        // disconnected?
        if (WN_SUCCESS == _dwWNetGC3Status)
        {
            if (WNGC_DISCONNECTED == _wngcs.dwState)
            {
                // Yes
                fConnected = FALSE;
            }
        }
        else
        {
            fConnected = FALSE;
        }
    }

    return fConnected;
}

BOOL CMtPtRemote::_IsMountedOnDriveLetter()
{
    return TRUE;
}

void CMtPtRemote::_UpdateLabelFromDesktopINI()
{
    WCHAR szLabelFromDesktopINI[MAX_MTPTCOMMENT];

    if (!GetShellClassInfo(_GetName(), TEXT("NetShareDisplayName"),
        szLabelFromDesktopINI, ARRAYSIZE(szLabelFromDesktopINI)))
    {
         szLabelFromDesktopINI[0] = 0;
    }

    RSSetTextValue(NULL, TEXT("_LabelFromDesktopINI"),
        szLabelFromDesktopINI, REG_OPTION_NON_VOLATILE);
}

void CMtPtRemote::_UpdateAutorunInfo()
{
    _pshare->fAutorun = FALSE;

    if (_IsAutoRunDrive())
    {
        if (_ProcessAutoRunFile())
        {
            _pshare->fAutorun = TRUE;
        }
    }

    if (!_pshare->fAutorun)
    {
        // Make sure to delete the shell key
        RSDeleteSubKey(TEXT("Shell"));
    }
}

CMtPtRemote::CMtPtRemote()
{
#ifdef DEBUG
    ++_cMtPtRemote;
#endif
}

CMtPtRemote::~CMtPtRemote()
{
    if (_pshare)
    {
        _pshare->Release();
    }

#ifdef DEBUG
    --_cMtPtRemote;
#endif
}

HRESULT CMtPtRemote::_InitWithoutShareName(LPCWSTR pszName)
{
    // Let's make a name
    GUID guid;
    HRESULT hr = CoCreateGuid(&guid);

    if (SUCCEEDED(hr))
    {
        WCHAR szGUID[sizeof("{00000010-0000-0010-8000-00AA006D2EA4}")];

        if (StringFromGUID2(guid, szGUID, ARRAYSIZE(szGUID)))
        {
            hr = _Init(pszName, szGUID, TRUE);

            if (SUCCEEDED(hr))
            {
                _pshare->fFake = TRUE;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

HRESULT CMtPtRemote::_Init(LPCWSTR pszName, LPCWSTR pszShareName,
    BOOL fUnavailable)
{
    HRESULT hr;

    _pshare = _GetOrCreateShareFromID(pszShareName);

    if (_pshare)
    {
        if (fUnavailable)
        {
            _dwWNetGCStatus = ERROR_CONNECTION_UNAVAIL;
        }

        lstrcpyn(_szName, pszName, ARRAYSIZE(_szName));
        PathAddBackslash(_szName);

        // Remote drives uses the Share key for all their stuff.  They do not have
        // anything interesting specific to the drive letter
        RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2, _pshare->pszKeyName,
            REG_OPTION_NON_VOLATILE);

        RSSetTextValue(NULL, TEXT("BaseClass"), TEXT("Drive"));

        // Access the drive on first connection of the share
        _InitOnlyOnceStuff();

        _InitLegacyRegIconAndLabel(FALSE, FALSE);

        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

LPCTSTR CMtPtRemote::_GetUNCName()
{
    return _pshare->pszRemoteName;
}

void CMtPtRemote::_InitOnlyOnceStuff()
{
    if (!RSValueExist(NULL, TEXT("_CommentFromDesktopINI")))
    {
        // Comment
        _UpdateCommentFromDesktopINI();

        // Label
        _UpdateLabelFromDesktopINI();

        // Autorun
        _UpdateAutorunInfo();
    }
}

int CMtPtRemote::_GetDriveType()
{
    return DRIVE_REMOTE;
}

HRESULT CMtPtRemote::GetAssocSystemElement(IAssociationElement **ppae)
{
    return AssocElemCreateForClass(&CLSID_AssocSystemElement, L"Drive.Network", ppae);
}

DWORD CMtPtRemote::_GetPathSpeed()
{
    if (!_dwSpeed)
    {
        _CalcPathSpeed();
    }

    return _dwSpeed;
}

// static
HRESULT CMtPtRemote::_DeleteAllMtPtsAndShares()
{
    _csDL.Enter();

    for (DWORD dw = 0; dw <26; ++dw)
    {
        CMtPtRemote* pmtptr = CMountPoint::_rgMtPtDriveLetterNet[dw];

        if (pmtptr)
        {
            pmtptr->Release();
            CMountPoint::_rgMtPtDriveLetterNet[dw] = 0;
        }
    }

    if (_hdpaShares)
    {
        DPA_Destroy(_hdpaShares);
        _hdpaShares = NULL;
    }

    _csDL.Leave();

    return S_OK;
}

// static
HRESULT CMtPtRemote::_CreateMtPtRemoteWithoutShareName(LPCWSTR pszMountPoint)
{
    HRESULT hr;
    CMtPtRemote* pmtptr = new CMtPtRemote();

    if (pmtptr)
    {
        hr = pmtptr->_InitWithoutShareName(pszMountPoint);

        if (SUCCEEDED(hr))
        {
            _csDL.Enter();

            CMountPoint::_rgMtPtDriveLetterNet[DRIVEID(pszMountPoint)] =
                pmtptr;

            _csDL.Leave();
        }
        else
        {
            delete pmtptr;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// static
HRESULT CMtPtRemote::_CreateMtPtRemote(LPCWSTR pszMountPoint,
    LPCWSTR pszShareName, BOOL fUnavailable)
{
    HRESULT hr;
    CMtPtRemote* pmtptr = new CMtPtRemote();

    if (pmtptr)
    {
        hr = pmtptr->_Init(pszMountPoint, pszShareName, fUnavailable);

        if (SUCCEEDED(hr))
        {
            _csDL.Enter();

            CMountPoint::_rgMtPtDriveLetterNet[DRIVEID(pszMountPoint)] =
                pmtptr;

            _csDL.Leave();
        }
        else
        {
            delete pmtptr;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// static
CShare* CMtPtRemote::_GetOrCreateShareFromID(LPCWSTR pszShareName)
{
    CShare* pshare = NULL;

    _csDL.Enter();

    DWORD c = DPA_GetPtrCount(_hdpaShares);

    for (DWORD dw = 0; dw < c; ++dw)
    {
        pshare = (CShare*)DPA_GetPtr(_hdpaShares, dw);

        if (pshare)
        {
            if (!lstrcmpi(pshare->pszRemoteName, pszShareName))
            {
                pshare->AddRef();
                break;
            }
            else
            {
                pshare = NULL;
            }
        }
    }    

    if (!pshare)
    {
        BOOL fSuccess = FALSE;

        pshare = new CShare();

        if (pshare)
        {
            pshare->pszRemoteName = StrDup(pszShareName);

            if (pshare->pszRemoteName)
            {
                pshare->pszKeyName = StrDup(pszShareName);

                if (pshare->pszKeyName)
                {
                    LPWSTR psz = pshare->pszKeyName;

                    while (*psz)
                    {
                        if (TEXT('\\') == *psz)
                        {
                            *psz = TEXT('#');
                        }

                        ++psz;
                    }

                    if (-1 != DPA_AppendPtr(_hdpaShares, pshare))
                    {
                        fSuccess = TRUE;
                    }
                }
            }
        }

        if (!fSuccess)
        {
            if (pshare)
            {
                if (pshare->pszKeyName)
                {
                    LocalFree(pshare->pszKeyName)