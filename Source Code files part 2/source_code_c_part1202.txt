tePdiscTimedOut       ",
    "SFStateDoAbort             ",
    "SFStateAbortAccept         ",
    "SFStateAbortRej            ",
    "SFStateAbortBadALPA        ",
    "SFStateAbortTimedOut       ",
    "SFStateDoResetDevice       ",
    "SFStateResetDeviceAccept   ",
    "SFStateResetDeviceRej      ",
    "SFStateResetDeviceBadALPA  ",
    "SFStateResetDeviceTimedOut ",
    "SFStateDoLS_RJT            ",
    "SFStateLS_RJT_Done         ",
    "SFStateDoPlogiAccept       ",
    "SFStatePlogiAccept_Done    ",
    "SFStateDoPrliAccept        ",
    "SFStatePrliAccept_Done     ",
    "SFStateDoELSAccept         ",
    "SFStateELSAccept_Done      ",
    "SFStateDoFCP_DR_ACC_Reply  ",
    "SFStateFCP_DR_ACC_Reply_Done ",
    "SFStateLS_RJT_TimeOut        ",
    "SFStatePlogiAccept_TimeOut   ",
    "SFStatePrliAccept_TimeOut       ",
    "SFStateELSAccept_TimeOut        ",
    "SFStateFCP_DR_ACC_Reply_TimeOut ",
    "SFStateDoRFT_ID                 ",
    "SFStateRFT_IDAccept             ",
    "SFStateRFT_IDRej                ",
    "SFStateRFT_IDBadALPA            ",
    "SFStateRFT_IDTimedOut           ",
    "SFStateDoGID_FT                 ",
    "SFStateGID_FTAccept             ",
    "SFStateGID_FTRej                ",
    "SFStateGID_FTBadALPA            ",
    "SFStateGID_FTTimedOut           ",
    "SFStateDoSCR                    ",
    "SFStateSCRAccept                ",
    "SFStateSCRBadALPA               ",
    "SFStateSCRTimedOut              ",
    "SFStateSCRRej                   ",
    "SFStateDoSRR                    ",
    "SFStateSRRAccept                ",
    "SFStateSRRRej                   ",
    "SFStateSRRBadALPA               ",
    "SFStateSRRTimedOut              ",
    "SFStateDoREC                    ",
    "SFStateRECAccept                ",
    "SFStateRECRej                   ",
    "SFStateRECBadALPA               ",
    "SFStateRECTimedOut              ",
    "SFStateDoADISCAccept            ",
    "SFStateADISCAccept_Done         ",
    "SFStateADISCAccept_TimeOut      ",
    agNULL
};

char * SFEventString[]=
{
    "SFEventReset                    ",
    "SFEventDoPlogi                  ",
    "SFEventPlogiAccept              ",
    "SFEventPlogiRej                 ",
    "SFEventPlogiBadALPA             ",
    "SFEventPlogiTimedOut            ",
    "SFEventDoPrli                   ",
    "SFEventPrliAccept               ",
    "SFEventPrliRej                  ",
    "SFEventPrliBadALPA              ",
    "SFEventPrliTimedOut             ",
    "SFEventDoFlogi                  ",
    "SFEventFlogiAccept              ",
    "SFEventFlogiRej                 ",
    "SFEventFlogiBadALPA             ",
    "SFEventFlogiTimedOut            ",
    "SFEventDoLogo                   ",
    "SFEventLogoAccept               ",
    "SFEventLogoRej                  ",
    "SFEventLogoBadALPA              ",
    "SFEventLogoTimedOut             ",
    "SFEventDoPrlo                   ",
    "SFEventPrloAccept               ",
    "SFEventPrloRej                  ",
    "SFEventPrloBadALPA              ",
    "SFEventPrloTimedOut             ",
    "SFEventDoAdisc                  ",
    "SFEventAdiscAccept              ",
    "SFEventAdiscRej                 ",
    "SFEventAdiscBadALPA             ",
    "SFEventAdiscTimedOut            ",
    "SFEventDoPdisc                  ",
    "SFEventPdiscAccept              ",
    "SFEventPdiscRej                 ",
    "SFEventPdiscBadALPA             ",
    "SFEventPdiscTimedOut            ",
    "SFEventDoAbort                  ",
    "SFEventAbortAccept              ",
    "SFEventAbortRej                 ",
    "SFEventAbortBadALPA             ",
    "SFEventAbortTimedOut            ",
    "SFEventDoResetDevice            ",
    "SFEventResetDeviceAccept        ",
    "SFEventResetDeviceRej           ",
    "SFEventResetDeviceBadALPA       ",
    "SFEventResetDeviceTimedOut      ",
    "SFEventDoLS_RJT                 ",
    "SFEventLS_RJT_Done              ",
    "SFEventDoPlogiAccept            ",
    "SFEventPlogiAccept_Done         ",
    "SFEventDoPrliAccept             ",
    "SFEventPrliAccept_Done          ",
    "SFEventDoELSAccept              ",
    "SFEventELSAccept_Done           ",
    "SFEventDoFCP_DR_ACC_Reply       ",
    "SFEventFCP_DR_ACC_Reply_Done    ",
    "SFEventLS_RJT_TimeOut           ",
    "SFEventPlogiAccept_TimeOut      ",
    "SFEventPrliAccept_TimeOut       ",
    "SFEventELSAccept_TimeOut        ",
    "SFEventFCP_DR_ACC_Reply_TimeOut ",
    "SFEventDoRFT_ID                 ",
    "SFEventRFT_IDAccept             ",
    "SFEventRFT_IDRej                ",
    "SFEventRFT_IDBadALPA            ",
    "SFEventRFT_IDTimedOut           ",
    "SFEventDoGID_FT                 ",
    "SFEventGID_FTAccept             ",
    "SFEventGID_FTRej                ",
    "SFEventGID_FTBadALPA            ",
    "SFEventGID_FTTimedOut           ",
    "SFEventDoSCR                    ",
    "SFEventSCRAccept                ",
    "SFEventSCRRej                   ",
    "SFEventSCRBadALPA               ",
    "SFEventSCRTimedOut              ",
    "SFEventDoSRR                    ",
    "SFEventSRRAccept                ",
    "SFEventSRRRej                   ",
    "SFEventSRRBadALPA               ",
    "SFEventSRRTimedOut              ",
    "SFEventDoREC                    ",
    "SFEventRECAccept                ",
    "SFEventRECRej                   ",
    "SFEventRECBadALPA               ",
    "SFEventRECTimedOut              ",
    "SFEventDoADISCAccept            ",
    "SFEventADISCAccept_Done         ",
    "SFEventADISCAccept_TimeOut      ",
    agNULL
};
#endif /* TestSFStateMachine was defined */

#endif /* USESTATEMACROS was defined */

#endif /*  __SFState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\sf_fcp.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/SF_FCP.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/SF_FCP.C

--*/

#ifndef __SF_FCP_H__
#define __SF_FCP_H__

/* SF_CMND_Type(SF_CMND_Class==SFThread_SF_CMND_Class_SF_FCP) Declarations */

#define SFThread_SF_CMND_SF_FCP_Type_TargetReset      0x01
#define SFThread_SF_CMND_SF_FCP_Type_TargetReset_RESP 0x02
#define SFThread_SF_CMND_SF_FCP_Type_FCP_CMND_IU      0x03
#define SFThread_SF_CMND_SF_FCP_Type_FCP_XFER_RDY_IU  0x04
#define SFThread_SF_CMND_SF_FCP_Type_FCP_DATA_IU      0x05
#define SFThread_SF_CMND_SF_FCP_Type_FCP_RSP_IU       0x06

/* SF_CMND_State(SF_CMND_Class==SFThread_SF_CMND_Class_SF_FCP,SF_CMND_Type==<any>) Declarations */

#define SFThread_SF_CMND_SF_FCP_State_Started  0x01
#define SFThread_SF_CMND_SF_FCP_State_Finished 0x02

/* SF_CMND_Status(SF_CMND_Class==SFThread_SF_CMND_Class_SF_FCP,SF_CMND_Type==<any>) Declarations */

#define SFThread_SF_CMND_SF_FCP_Status_Good 0x01
#define SFThread_SF_CMND_SF_FCP_Status_Bad  0x02

/* Function Prototypes */

osGLOBAL void fiFillInSF_FCP_FrameHeader_OnCard(
                                               SFThread_t *SFThread,
                                               os_bit32       D_ID,
                                               os_bit32       X_ID,
                                               os_bit32       F_CTL_Exchange_Context
                                             );

osGLOBAL void fiFillInSF_FCP_FrameHeader_OffCard(
                                                SFThread_t *SFThread,
                                                os_bit32       D_ID,
                                                os_bit32       X_ID,
                                                os_bit32       F_CTL_Exchange_Context
                                              );

osGLOBAL os_bit32 fiFillInTargetReset(
                                  SFThread_t *SFThread
                                );

osGLOBAL os_bit32 fiFillInTargetReset_OnCard(
                                         SFThread_t *SFThread
                                       );

osGLOBAL os_bit32 fiFillInTargetReset_OffCard(
                                          SFThread_t *SFThread
                                        );

osGLOBAL void fiSF_FCP_Process_TargetReset_Response_OnCard(
                                                          SFThread_t *SFThread,
                                                          os_bit32       Frame_Length,
                                                          os_bit32       Offset_to_FCHS,
                                                          os_bit32       Offset_to_Payload,
                                                          os_bit32       Payload_Wrap_Offset,
                                                          os_bit32       Offset_to_Payload_Wrapped
                                                        );

osGLOBAL void fiSF_FCP_Process_TargetReset_Response_OffCard(
                                                           SFThread_t                 *SFThread,
                                                           os_bit32                       Frame_Length,
                                                           FCHS_t                     *FCHS,
                                                           FC_ELS_ACC_PLOGI_Payload_t *Payload,
                                                           os_bit32                       Payload_Wrap_Offset,
                                                           FC_ELS_ACC_PLOGI_Payload_t *Payload_Wrapped
                                                         );

osGLOBAL os_bit32 fiFillInFCP_RSP_IU(
                                 SFThread_t           *SFThread,
                                 os_bit32                 D_ID,
                                 os_bit32                 OX_ID,
                                 os_bit32                 Payload_LEN,
                                 FC_FCP_RSP_Payload_t *Payload
                               );

osGLOBAL os_bit32 fiFillInFCP_RSP_IU_OnCard(
                                        SFThread_t           *SFThread,
                                        os_bit32                 D_ID,
                                        os_bit32                 OX_ID,
                                        os_bit32                 Payload_LEN,
                                        FC_FCP_RSP_Payload_t *Payload
                                      );

osGLOBAL os_bit32 fiFillInFCP_RSP_IU_OffCard(
                                         SFThread_t           *SFThread,
                                         os_bit32                 D_ID,
                                         os_bit32                 OX_ID,
                                         os_bit32                 Payload_LEN,
                                         FC_FCP_RSP_Payload_t *Payload
                                       );

osGLOBAL void fiSF_FCP_Process_TargetRequest_OnCard(
                                                   agRoot_t *hpRoot,
                                                   os_bit32     Frame_Length,
                                                   os_bit32     Offset_to_FCHS,
                                                   os_bit32     Offset_to_Payload,
                                                   os_bit32     Payload_Wrap_Offset,
                                                   os_bit32     Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiSF_FCP_Process_TargetRequest_OffCard(
                                                    agRoot_t *hpRoot,
                                                    os_bit32     Frame_Length,
                                                    FCHS_t   *FCHS,
                                                    void     *Payload,
                                                    os_bit32     Payload_Wrap_Offset,
                                                    void     *Payload_Wrapped
                                                  );

#define fiSF_FCP_Cmd_Status_Success       0x00000000
#define fiSF_FCP_Cmd_Status_TargetRequest 0x00000001
#define fiSF_FCP_Cmd_Status_Bad_CDB_Frame 0x00000002
#define fiSF_FCP_Cmd_Status_Confused      0xFFFFFFFF 

osGLOBAL os_bit32 fiSF_FCP_ProcessSFQ(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t   SFQConsIndex,
                                  os_bit32            Frame_Length,
                                  fi_thread__t       **Thread_to_return
                                );

osGLOBAL os_bit32 fiSF_FCP_ProcessSFQ_OnCard(
                                         agRoot_t        *hpRoot,
                                         SFQConsIndex_t   SFQConsIndex,
                                         os_bit32            Frame_Length,
                                         fi_thread__t       **Thread_to_return
                                       );

osGLOBAL os_bit32 fiSF_FCP_ProcessSFQ_OffCard(
                                          agRoot_t        *hpRoot,
                                          SFQConsIndex_t   SFQConsIndex,
                                          os_bit32            Frame_Length,
                                          fi_thread__t       **Thread_to_return
                                        );

#endif /* __SF_FCP_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\state.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/State.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/16/00 3:00p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/State.C

--*/

#ifndef __State_H__
#define __State_H__

/*+
Defining __State_Force_Static_State_Tables__ disables use of Dynamic State Tables
-*/

#ifndef __State_Force_Static_State_Tables__
#define __State_Force_Static_State_Tables__
#endif /* __State_Force_Static_State_Tables__ was not defined */

/*+
Data stuctures used by State Machine
-*/

typedef os_bit8 event_t;
typedef os_bit8 state_t;

typedef struct thread_s
               fi_thread__t;

typedef struct eventRecord_s
               eventRecord_t;

struct eventRecord_s {
                       fi_thread__t *thread;
                       event_t   event;
                     };

typedef void (*action_t)(
                          fi_thread__t      *thread,
                          eventRecord_t *nextEventRecord
                        );

#define maxEvents 128
#define maxStates 128

typedef struct stateTransitionMatrix_s
               stateTransitionMatrix_t;

struct stateTransitionMatrix_s {
                                 state_t newState[maxEvents][maxStates];
                               };

typedef struct stateActionScalar_s
               stateActionScalar_t;

struct stateActionScalar_s {
                             action_t newAction[maxStates];
                           };

/**
 *
 * To initialize a State Transition Matrix:
 *
 *   stateTransitionMatrix_t stateTransitionMatrix = {
 *                                                     newStateA,
 *                   < event 0 transitions >            newStateB,
 *                                                       newStateC,
 *                                                        ... < for all "maxStates" states >
 *                                                     newStateZ,
 *                   < event 1 transitions >            newStateY,
 *                                                       newStateX,
 *                                                        ... < for all "maxStates" states >
 *    < one for each of "maxEvents" events >           ...
 *                                                   };
 *
 * To initialize a State Action Scalar:
 *
 *   stateActionScalar_t stateActionScalar = {
 *                                             newActionA,
 *                                             newActionB,
 *                                             newActionC,
 *        < one for each State/Action pair >   ...,
 *                                             newActionX,
 *                                             newActionY,
 *                                             newActionZ,
 *                                             ...
 *                                           };
 *
 **/

#ifndef __State_Force_Static_State_Tables__
typedef struct actionUpdate_s
               actionUpdate_t;

struct actionUpdate_s {
                        os_bit32    bitMask;
                        os_bit32    compareTo;
                        action_t originalAction;
                        action_t replacementAction;
                      };
#endif /* __State_Force_Static_State_Tables__ was not defined */

/**
 *
 * To initialize an Action Update Table:
 *
 *   actionUpdate_t testActionUpdate[] = {
 *                                         bitMask1, compareTo1, &originalAction1(), &replacementAction1(),
 *                                         bitMask2, compareTo2, &originalAction2(), &replacementAction2(),
 *                                         ...
 *                                         bitMaskN, compareToN, &originalActionN(), &replacementActionN(),
 *                                         0,        0,          (void *)agNULL,       (void *)agNULL
 *                                       };
 *
 **/

#define threadType_Unknown 0

typedef os_bit32 threadType_t;

struct thread_s {
                  agRoot_t                *hpRoot;
                  threadType_t             threadType;
                  state_t                  currentState;
                  state_t                  subState;
                  stateTransitionMatrix_t *stateTransitionMatrix;
                  stateActionScalar_t     *stateActionScalar;
                };

/*+
State Machine Logging Levels
-*/

#define fiSendEventInfoLogLevel  (2 * osLogLevel_Info_MIN)
#define fiSendEventErrorLogLevel osLogLevel_Error_MIN

/*+
Function prototypes
-*/

/*+
Function:  fiInstallStateMachine()

Purpose:   Copies State Machine data structure(s) updating the actions
           as requested.

Algorithm: After copying the State Machine data structure(s), the actionUpdate
           array is used to modify any action function pointers based on the
           value of compareBase.  The actionUpdate array contains records which
           contain a value to mask compareBase.  If the masked value matches
           the compareTo value for the record, all instances of the originalAction
           function pointer will be replaced by the replacementAction function
           pointer.

           Note that the originalAction function pointers must be found in the source
           of the State Machine data structure(s), not the copied data structure(s).
           This prevents ambiguities which would result if the replacementAction function
           pointers match any originalAction function pointers.
-*/

#ifndef __State_Force_Static_State_Tables__
osGLOBAL void fiInstallStateMachine(
                                   stateTransitionMatrix_t *srcStateTransitionMatrix,
                                   stateActionScalar_t     *srcStateActionScalar,
                                   stateTransitionMatrix_t *dstStateTransitionMatrix,
                                   stateActionScalar_t     *dstStateActionScalar,
                                   os_bit32                    compareBase,
                                   actionUpdate_t           actionUpdate[]
                                 );
#endif /* __State_Force_Static_State_Tables__ was not defined */

/*+
Function:  fiInitializeThread()

Purpose:   Initializes the fi_thread__t data structure to contain hpRoot, the thread
           type and (a) pointer(s) to the State Machine data structure(s).
-*/

osGLOBAL void fiInitializeThread(
                                fi_thread__t                *thread,
                                agRoot_t                *hpRoot,
                                threadType_t             threadType,
                                state_t                  initialState,
                                stateTransitionMatrix_t *stateTransitionMatrix,
                                stateActionScalar_t     *stateActionScalar
                              );

/*+
Function:  fiSendEvent()

Purpose:   Sends an event to a thread immediately as well as (recursively) sending
           any event returned via eventRecord from the action routine called.

Algorithm: The current state of the specified thread and the event passed in are used
           to compute a new state for the thread and to fetch a action routine function
           pointer.

           For the Moore State Machine Model, the actions occur in the states.  So, each
           element of the stateTransitionMatrix contains only the newState for the thread.
           The newAction (which corresponds to this newState) is retrieved from the
           stateActionScalar for this thread.

           In the call to the thread's newAction, an eventRecord_t is passed.  This can be
           used by the action routine to pass on an event to the same or a new thread.  By
           "returning" the event to send, recursion of fiSendEvent() is avoided.  This is
           necessary as stack depth is a critically limited resource in some environments.
-*/

osGLOBAL void fiSendEvent(
                         fi_thread__t *thread,
                         event_t   event
                       );

/*+
Function:  fiSetEventRecord()

Purpose:   Sets the fields of an eventRecord so that the specified event is
           delivered to the specified thread (presumably) upon return from the
           action routine which called fiSetEventRecord().
-*/

osGLOBAL void fiSetEventRecord(
                              eventRecord_t *eventRecord,
                              fi_thread__t      *thread,
                              event_t        event
                            );

/*+
Macro:     fiSetEventRecordNull()

Purpose:   Sets the fields of an eventRecord so that the no event is delivered
           to any thread (presumably) upon return from the action routine which
           called fiSetEventRecordNull().
-*/

#define fiSetEventRecordNull(eventRecord) \
    ((eventRecord_t *)(eventRecord))->thread = (fi_thread__t *)agNULL

/* */

#define STATE_PROTO(x)  extern void x( fi_thread__t *thread,\
                                     eventRecord_t *eventRecord )


#define LogStateTransition( set, threadType, currentState, event)  ((set ? 0x80000000 : 0 ) |(threadType   << 16   ) | (currentState << 8    ) | event )


#endif /* __State_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\startio.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    StartIo.c

Abstract:

    This source handles calls to start processing  requests
    
Authors:

    Michael Bessire
    Dennis Lindfors FC Layer support

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/STARTIO.C $

Revision History:

    $Revision: 6 $
    $Date: 11/10/00 5:51p $
    $Modtime:: 10/19/00 1:46p        $


--*/


#include "buildop.h"        //LP021100 build switches

#include "osflags.h"
#include "hhba5100.ver"
#if defined(HP_PCI_HOT_PLUG)
    #include "HotPlug4.h"    // NT 4.0 PCI Hot-Plug header file
#endif

ULONG LOG_TIME=0;
extern ULONG gGlobalIOTimeout;
#ifdef DBGPRINT_IO
ULONG gDbgPrintIo=0;
#endif

ULONG gMultiMode=FALSE;

BOOLEAN
HPFibreStartIo(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine is called from the SCSI port driver synchronized
    with the kernel to send an ECB or issue an immediate command.

Arguments:

    pCard - HBA miniport driver's adapter data storage
    Srb             - I/O request packet

Return Value:

    TRUE - to acknowledge receipt of srb

--*/

{
    agRoot_t * phpRoot      =   &pCard->hpRoot;
    PSRB_EXTENSION pSrbExt  =   Srb->SrbExtension;
    SCSI_NOTIFICATION_TYPE  notify_type = NextRequest;
    ULONG                           response_length; // ignored
    PULONG ptmp32;

    PSCSI_REQUEST_BLOCK         abortedSrb;
    PLU_EXTENSION               plunExtension = NULL;
    agIORequest_t *             pHpio_request;
    agIORequestBody_t *         pHpio_CDBrequest;
    PLUN plun;
    UCHAR    srbPathId = Srb->PathId;
    UCHAR    srbTargetId = Srb->TargetId;
    UCHAR    srbLun = Srb->Lun;


    #ifdef DBGPRINT_IO   
    if (gDbgPrintIo & DBGPRINT_HPFibreStartIo)
    {
        static count;
        osDEBUGPRINT((ALWAYS_PRINT, "HPStr(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x  Dev=%x &Srb=%x &Ext=%x Flags=%x Buf=%x Len=%x Funct=%d\n",
                   count++,
                   Srb->PathId,
                   Srb->TargetId,
                   Srb->Lun,
                   Srb->Cdb[0],Srb->Cdb[1],Srb->Cdb[2],Srb->Cdb[3],Srb->Cdb[4],
                   Srb->Cdb[5],Srb->Cdb[6],Srb->Cdb[7],Srb->Cdb[8],Srb->Cdb[9],
                    pCard, Srb, Srb->SrbExtension, Srb->SrbFlags, Srb->DataBuffer, Srb->DataTransferLength,Srb->Function));            
    }
    #endif

    pCard->inDriver = TRUE;

    while (pCard->inTimer == TRUE)
        // HPFibreTimerTick routine is running. Busy wait until
        // HPFibreTimerTick returns.
        ;

    //----------------------------------------------------------------------------

    #if defined(HP_PCI_HOT_PLUG)     // NT 4.0 PCI Hot Plug support

    //
    // Added for support of NT 4.0 PCI Hot Plug.  If we are in a state of 
    // transitioning, we need to refuse all requests until we have completed 
    // hot plug transitioning.
    //

    if (PCS_HBA_NOT_READY(pCard->stateFlags)) 
    {
        if (pCard->controlFlags & ~LCS_HBA_TIMER_ACTIVE)   // Check if timer active
        {
            osDEBUGPRINT((ALWAYS_PRINT, "\tStartIo PCS_HBA_NOT_READY: Slot: %x  controlFlags: %x - Send BUSY.\n",
                pCard->rcmcData.slot, pCard->controlFlags));
            Srb->SrbStatus = SRB_STATUS_BUSY;
        }
        else 
            if (pCard->stateFlags & PCS_HBA_FAILED) 
            {
                osDEBUGPRINT((ALWAYS_PRINT, "\tStartIo: (Slot: %x) PCS_HBA_FAILED: SRB_STATUS_ERROR returned.\n",
                    pCard->rcmcData.slot));
                pCard->stateFlags |= PCS_HBA_UNFAIL_PENDING;
                Srb->SrbStatus = SRB_STATUS_ERROR;
            }
            else
            {
                if (pCard->stateFlags & PCS_HPP_POWER_DOWN) 
                {
                    if (pCard->IoHeldRetTimer < pCard->IoHeldRetMaxIter ) 
                    {
                        Srb->SrbStatus = SRB_STATUS_BUSY;
                        osDEBUGPRINT((ALWAYS_PRINT, "\tStartIo: (Slot: %x) - POWER DOWN: Status returned: %x\n",
                        pCard->rcmcData.slot, Srb->SrbStatus));
                    }
                    else 
                    {
                    osDEBUGPRINT((ALWAYS_PRINT, "StartIo: (Slot: %x) - POWER DOWN: Timed out\n",
                        pCard->rcmcData.slot));
                    Srb->SrbStatus = SRB_STATUS_ERROR;
                    }
                }
                else 
                {
                    if ( (pCard->stateFlags & PCS_HBA_UNFAIL_PENDING) &&
                        (pCard->stateFlags & PCS_HBA_OFFLINE) ) 
                    {
                        Srb->SrbStatus = SRB_STATUS_ERROR;
                    }
                    else 
                    {
                        pCard->stateFlags &= ~PCS_HBA_UNFAIL_PENDING;
                        Srb->SrbStatus = SRB_STATUS_BUSY;
                    }
                }
            }

        //    Indicate to system that the controller can take another request
        //    for this device.

        ScsiPortNotification(NextLuRequest,
            pCard,
            Srb->PathId,
            Srb->TargetId,
            Srb->Lun);      

        ScsiPortNotification(RequestComplete, pCard, Srb);
           pCard->inDriver = FALSE;
        return TRUE;

    } // end if (PCS_HBA_NOT_READY(pCard->stateFlags))
    else 
    {
        pCard->stateFlags &= ~PCS_HBA_UNFAIL_PENDING; 
        pCard->IoHeldRetTimer = 0;  

    }

    #endif      // NT 4.0 PCI Hot Plug support
    //----------------------------------------------------------------------------

    if (pCard->flags & OS_IGNORE_NEXT_RESET)
        pCard->flags &= ~OS_IGNORE_NEXT_RESET;

    pCard->State |= CS_DURING_STARTIO;

    // Zero out SRB extension here !!!!
    osZero(Srb->SrbExtension, sizeof(SRB_EXTENSION));

    // osDEBUGPRINT((DHIGH,"IN HPFibreStartIo %lx %lx hpRoot %lx Srb->DataBuffer %lx\n", pCard, Srb, phpRoot ,Srb->DataBuffer ));
    #ifdef _DEBUG_PERF_DATA_
    pSrbExt->Perf_ptr = &pCard->perf_data[ LOG_TIME];

    // PERF     pSrbExt->Perf_ptr->inOsStartio  = get_hi_time_stamp();

    if( LOG_TIME )
    {
        if( LOG_TIME == 1) pCard->PerfStartTimed = osTimeStamp(0);

        if( LOG_TIME < LOGGED_IO_MAX-1)
        {
            LOG_TIME++;
        }
        else
        {
            LOG_TIME = 0;
            pSrbExt->Perf_ptr = &pCard->perf_data[0];
            dump_perf_data( pCard);
        }
    }
    #endif

    // Init SRB Extension
    pSrbExt->pCard              =   pCard;
    pSrbExt->phpRoot            =   phpRoot;
    pSrbExt->pSrb               =   Srb;

    // IWN
    // Init the SCSIStatus, bug in Win2000 SCSIPort of not reinit SCSIStatus.

    Srb->ScsiStatus = SCSISTAT_GOOD;


    if (Srb->Function == SRB_FUNCTION_ABORT_COMMAND) 
    {
        // get ECB to abort.
        abortedSrb = Srb->NextSrb;
        pSrbExt =abortedSrb->SrbExtension;
        pSrbExt->SRB_State =  RS_TO_BE_ABORTED;        

        osDEBUGPRINT((ALWAYS_PRINT,"SRB_FUNCTION_ABORT_COMMAND Srb %lx abortedSrb %lx\n", Srb, abortedSrb ));
        #ifdef _DEBUG_EVENTLOG_
        LogEvent(   pCard, 
                 (PVOID)pSrbExt, 
                 HPFC_MSG_IO_ABORTINITIATED , 
                 NULL, 
                 0, 
                 NULL);
        #endif
        
        plunExtension = ScsiPortGetLogicalUnit(pCard,
                                            abortedSrb->PathId,
                                            abortedSrb->TargetId,
                                            abortedSrb->Lun
                                            );

        fcAbortIO( phpRoot,
                   &pSrbExt->hpIORequest );

        ScsiPortNotification(NextRequest,
                                pCard,
                                Srb->PathId,
                                Srb->TargetId,
                                Srb->Lun);

        // indicate request complete
        pSrbExt->SRB_State = RS_COMPLETE;

        ScsiPortNotification(RequestComplete,
                               pCard,
                               Srb);

        pCard->State &= ~CS_DURING_STARTIO;

        pCard->inDriver = FALSE;

        return TRUE;
    }

    switch (Srb->Function) 
    {
        case SRB_FUNCTION_EXECUTE_SCSI:
            #ifdef _DEBUG_EVENTLOG_
            pSrbExt->pLunExt = NULL;               /* initialize the lun extension */
            #endif
       
            #ifdef _ENABLE_PSEUDO_DEVICE_
            if (gEnablePseudoDevice)
            {
                if (PseudoDeviceIO(pCard, Srb) == TRUE)
                {
                    return TRUE;
                }
            }
            #endif
         
            /* Check if the link is down
            * So that we can block any inquiry IO
            */
            if((pCard->LinkState == LS_LINK_DOWN) && (Srb->Cdb[0] == SCSIOP_INQUIRY))
            {
                if(!pCard->SrbStatusFlag) 
                    pCard->SrbStatusFlag = TRUE;
                /* Check if the link has been down for atleast
                * Global_IO_Timeout value
                * If it has then set the status to selection timeout
                * else set the status to busy
                */
                if(pCard->TicksSinceLinkDown > gGlobalIOTimeout)
                    Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
                else 
                    Srb->SrbStatus = SRB_STATUS_BUSY;
                break;
            }  /* end if LinkState==LS_LINK_DOWN */
            
            plunExtension = ScsiPortGetLogicalUnit(pCard,
                                                  Srb->PathId,
                                                  Srb->TargetId,
                                                  Srb->Lun );

            pHpio_request    = &pSrbExt->hpIORequest;
            pHpio_CDBrequest = &pSrbExt->hpRequestBody;

            #ifdef DBGPRINT_IO   
            if (gDbgPrintIo & DBGPRINT_START )
            {
                static count;
                osDEBUGPRINT((ALWAYS_PRINT, "Start(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Buf=%x Len=%x\n",
                        count++,
                        Srb->PathId,
                        Srb->TargetId,
                        Srb->Lun,
                        Srb->Cdb[0],Srb->Cdb[1],Srb->Cdb[2],Srb->Cdb[3],Srb->Cdb[4],
                        Srb->Cdb[5],Srb->Cdb[6],Srb->Cdb[7],Srb->Cdb[8],Srb->Cdb[9],
                        Srb->DataBuffer, Srb->DataTransferLength));
              
            }


            #endif

            if(plunExtension == NULL)
            {
                Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
                osDEBUGPRINT((ALWAYS_PRINT,"..........EXECUTE_SCSI NO LU EXT srb %lx luext %lx\n", Srb,plunExtension ));
                osDEBUGPRINT((ALWAYS_PRINT,"..........Bus %x TargetId %x Lun %x\n", Srb->PathId,Srb->TargetId,Srb->Lun));
                
                break;
            } 
            else 
            {
                 // osDEBUGPRINT((DHIGH,"Lu Extension srb %lx luext %lx\n", Srb,plunExtension ));

                if (!(plunExtension->flags & LU_EXT_INITIALIZED))
                    InitLunExtension (plunExtension);

                if (pCard->LinkState != LS_LINK_DOWN) 
                {
                    if(plunExtension->phandle == NULL) 
                    {
                        plunExtension->phandle = MapToHandle(pCard, Srb->PathId, Srb->TargetId, Srb->Lun, plunExtension);
                        if (plunExtension->phandle == NULL) 
                        {
                            Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
                            
                            break;
                        }
                    }
                } 
                else 
                {
                    // For now set phandle to NULL.
                    // The phandle will be updated after the link comes up.
                    plunExtension->phandle = NULL;
                }
                
                plunExtension->OutstandingIOs++;
                plunExtension->MaxOutstandingIOs = MAX(plunExtension->MaxOutstandingIOs, plunExtension->OutstandingIOs);

                plun = (PLUN)&pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[0];
                *plun = plunExtension->Lun;

                if(plunExtension->OutstandingIOs > plunExtension->MaxOutstandingIOs )
                {
                    osDEBUGPRINT((ALWAYS_PRINT,"plunExtension->OutstandingIOs:%d > plunExtension->MaxOutstandingIOs:%d\n",plunExtension->OutstandingIOs ,plunExtension->MaxOutstandingIOs ));
                }
                osDEBUGPRINT((DHIGH,"IN HPFibreStartIo %lx %lx hpRoot %lx Srb->DataBuffer %lx OUT %x \n", pCard, Srb, phpRoot ,Srb->DataBuffer, plunExtension->OutstandingIOs ));
            }

            if (Srb->SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE) 
            {
                if (Srb->QueueAction == SRB_SIMPLE_TAG_REQUEST)
                    pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[1] = FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_SIMPLE_Q;
                else 
                    if (Srb->QueueAction == SRB_HEAD_OF_QUEUE_TAG_REQUEST)
                        pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[1] = FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_HEAD_OF_Q;
                    else 
                        if (Srb->QueueAction == SRB_ORDERED_QUEUE_TAG_REQUEST)
                            pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[1] = FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_ORDERED_Q;

                if (plunExtension->OutstandingIOs < plunExtension->MaxAllowedIOs) 
                {
                    osDEBUGPRINT((DMOD,"Next Lu Req srb %lx luext %lx\n", Srb,plunExtension));
                    notify_type = NextLuRequest;
                }
            } 
            else 
                if (pCard->ForceTag) 
                {
                    pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[1] = FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_SIMPLE_Q;
                    if (plunExtension->OutstandingIOs < plunExtension->MaxAllowedIOs) 
                    {
                        osDEBUGPRINT((DMOD,"Next Lu Req srb %lx luext %lx\n", Srb,plunExtension));
                        notify_type = NextLuRequest;
                    }

                } 
                else
                    pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[1] = FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_UNTAGGED;

            osDEBUGPRINT((DMOD,"HPFibreStartIo: CDB %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x pCDB %lx\n",
                Srb->Cdb[0],Srb->Cdb[1],Srb->Cdb[2],Srb->Cdb[3],Srb->Cdb[4],
                Srb->Cdb[5],Srb->Cdb[6],Srb->Cdb[7],Srb->Cdb[8],Srb->Cdb[9], &Srb->Cdb[0] ));
            osDEBUGPRINT((DMOD, "HPFibreStartIo: PathId = %d, TargetId = %d, lun = %d DateBuffer = 0x%x XferLen = 0x%x\n",
                Srb->PathId, Srb->TargetId, Srb->Lun, Srb->DataBuffer, Srb->DataTransferLength));


            osDEBUGPRINT((DMOD,"Setup Pointers SrbExtension %lx\n", Srb->SrbExtension));

            pSrbExt->pLunExt = plunExtension;
            // Point request to extension

            // Save extension for later
            pHpio_request->osData = pSrbExt;
            // Build response
            // Move (destin, source, size)
            // osCopyAndSwap(&pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCdb[0],Srb->Cdb,16);
            osCopy(&pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCdb[0],Srb->Cdb,16);

            osDEBUGPRINT((DHIGH,"ScsiPortMoveMemory pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun %lx\n",
                  pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCdb));

            // LunExt does not exist !!! ScsiPortMoveMemory(pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun,plunExtension->FcpLun,8);

#ifdef FCLayer_Stub // Stub only !!!!

            if(Srb->Lun)
            {
                Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
                //ScsiPortLogError( pCard,
                //                Srb,
                //              Srb->PathId,
                //            Srb->TargetId,
                //          Srb->Lun,
                //        SP_BUS_TIME_OUT,
                //      0xABAD );
                pSrbExt->SRB_State = RS_COMPLETE;
                ScsiPortNotification(RequestComplete, pCard, Srb);
                pCard->inDriver = FALSE;
                return;
            }

            pHpio_CDBrequest->CDBRequest.FcpDataVirtAddr= Srb->DataBuffer;
            pHpio_CDBrequest->CDBRequest.FcpRespVirtAddr= &pSrbExt->ResponseHeader;

#endif /*  FCLayer_Stub */

            // plun = (pLUN)&pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[1];
            // plun->Address_mode  = 0;
            // plun->Bus_number    = 0;
            // plun->Lun           = Srb->Lun;
            // ptmp32 = (PULONG)&pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[0];
            // * ptmp32 = SWAPDWORD(*ptmp32);

            #ifdef TESTING_CRASH_DUMP
            if(gCrashDumping)
            {
                SCSI_PHYSICAL_ADDRESS phys_addr;
                ULONG length = 0;
                ULONG addr;

                
                // we have a write, then just check if we 
                // pass ScsiPortGetPhysical Address
                if(Srb->Cdb[0] == 0x2a)
                {
                    phys_addr = ScsiPortGetPhysicalAddress(pCard,
                                        Srb,
                                        Srb->DataBuffer,
                                        &length);

                    addr=ScsiPortConvertPhysicalAddressToUlong(phys_addr);
                    {
                    osDEBUGPRINT((ALWAYS_PRINT,"ScsiPortGetPhysicalAddress: return %x:%x addr = %x for vBuffer=%x\n Length=%x", 
                        phys_addr.HighPart, phys_addr.LowPart, addr, Srb->DataBuffer,length));
                    }
                }
            }
            #endif

            #ifdef DOUBLE_BUFFER_CRASHDUMP
            // if we are in dump path, we find that some of the DataBuffers
            // dont give any physical addresses. to bypass that, we have our 
            // own dma area, which we use to succeed the ScsiPortGetPhysical
            // call
            if(gCrashDumping)
            {
                if (Srb->DataBuffer && Srb->DataTransferLength)
                {
                    osDEBUGPRINT((ALWAYS_PRINT, "CrashDump: Buffer = %x data = %02x%02x%02x%02x\n",
                        Srb->DataBuffer, 
                        *(char *)((char*)Srb->DataBuffer+0), 
                        *(char *)((char*)Srb->DataBuffer+1), 
                        *(char *)((char*)Srb->DataBuffer+2), 
                        *(char *)((char*)Srb->DataBuffer+3) )); 
                } 
                   
                if(Srb->Cdb[0] == 0x2a)
                {
                    SCSI_PHYSICAL_ADDRESS phys_addr;
                    ULONG length = 0;
                    // we have a write, then just check if we 
                    // pass ScsiPortGetPhysical Address
                    phys_addr = ScsiPortGetPhysicalAddress(pCard,
                                        Srb,
                                        Srb->DataBuffer,
                                        &length);

                    if(phys_addr.LowPart == 0 &&  phys_addr.HighPart == 0 )
                    {
                        // we failed to get physical address, lets use our own,
                        // if the buffer is small enuff.. 8K is the limit
                        if(Srb->DataTransferLength <= (8 * 1024))
                        {
                            // save away the Original DataBuffer
                            pSrbExt->orgDataBuffer = Srb->DataBuffer;
                            // make the copy into our local DMA buffer
                            osCopy(pCard->localDataBuffer, Srb->DataBuffer, Srb->DataTransferLength);
                            // patch the pointer..
                            Srb->DataBuffer = pCard->localDataBuffer;
                            osDEBUGPRINT((ALWAYS_PRINT,"patching SRB->DataBuffer - VA %x Len %x\n",Srb->DataBuffer,Srb->DataTransferLength));
                        }
                        else
                        {
                            // transfer length is greater than 8K
                            // we are screwed.. let the fc layer handle this.. 
                            osDEBUGPRINT((ALWAYS_PRINT,"!!Cant get physical address - VA %x Len %x ( %ld )\n",Srb->DataBuffer,Srb->DataTransferLength));
                        }
                    }// if physical ZERO
                }// if its a Write
            }// if in Dump path
            #endif // DOUBLE_BUFFER

            osDEBUGPRINT((DHIGH,"** Srb->Lun %02x  FcpLun %02x %02x %02x %02x %02x %02x %02x %02x\n",
               Srb->Lun,
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[0],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[1],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[2],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[3],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[4],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[5],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[6],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[7]));


            ptmp32 = (PULONG) &pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpDL[0];
            response_length = Srb->DataTransferLength;
            * ptmp32 = SWAPDWORD(response_length);

            osDEBUGPRINT((DHIGH,"Srb->Datalength %08x response_length %08x  FcpDL %02x %02x %02x %02x\n",
               Srb->DataTransferLength,response_length,
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpDL[0],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpDL[1],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpDL[2],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpDL[3]));


            // pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpDL = Srb->DataTransferLength;

            pSrbExt->SglDataLen  = Srb->DataTransferLength;
            pSrbExt->SglVirtAddr = Srb->DataBuffer;

            // if(Srb->DataBuffer){
            pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[3] = (  ((Srb->SrbFlags & SRB_FLAGS_DATA_IN ) ? agFcpCntlReadData  : 0)
                                                            | ((Srb->SrbFlags & SRB_FLAGS_DATA_OUT) ? agFcpCntlWriteData : 0) );
            //  }
            //else pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[3] = 0;

            osDEBUGPRINT((DMOD,"Set direction flag %x @ %x OutstandingIOs %x\n",pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[3], osTimeStamp(0),plunExtension->OutstandingIOs));

            SrbEnqueueTail (&pCard->AdapterQ, Srb);

            if (pCard->LinkState == LS_LINK_UP)
                Startio (pCard);

            if (pCard->LinkState != LS_LINK_UP)
                osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartio called while not LS_LINK_UP.\n" ));

            pCard->inDriver = FALSE;

            return(TRUE);
// The following should be added to the SCSI miniport driver's source
// code :
//
// and the following should be added to the SCSI miniport driver's
// StartIo routine :

// the following ioctl case is added in function HPFibreStartIo()

        case SRB_FUNCTION_IO_CONTROL: 
        {
            DoIoctl(pCard, Srb);
            pCard->inDriver = FALSE;
            return(TRUE);
        } //end case SRB_FUNCTION_IO_CONTROL

    

        // the scsiport routine calls the HwResetBus routine directly.
        // these and others are defined in srb.h for future use.
        // just drop through for now. We may want to implement these later.


        case SRB_FUNCTION_RESET_BUS:
            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_FUNCTION_RESET_BUS\n"));

            pSrbExt->SRB_State = RS_COMPLETE;
            ScsiPortNotification(notify_type,
                                  pCard,
                                  srbPathId,
                                  srbTargetId,
                                  srbLun);

            ScsiPortNotification(RequestComplete, pCard, Srb);
            pCard->State &= ~CS_DURING_STARTIO;
            pCard->inDriver = FALSE;
            return TRUE;


        case SRB_FUNCTION_RESET_DEVICE:
            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_FUNCTION_RESET_DEVICE\n"));
            pSrbExt->SRB_State = RS_COMPLETE;
            ScsiPortNotification(notify_type,
                                  pCard,
                                  srbPathId,
                                  srbTargetId,
                                  srbLun);

            ScsiPortNotification(RequestComplete, pCard, Srb);
            pCard->State &= ~CS_DURING_STARTIO;
            pCard->inDriver = FALSE;
            return TRUE;

        case SRB_FUNCTION_REMOVE_DEVICE:
            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_FUNCTION_REMOVE_DEVICE\n"));
            pSrbExt->SRB_State = RS_COMPLETE;
            ScsiPortNotification(notify_type,
                                  pCard,
                                  srbPathId,
                                  srbTargetId,
                                  srbLun);

            ScsiPortNotification(RequestComplete, pCard, Srb);
            pCard->State &= ~CS_DURING_STARTIO;
            pCard->inDriver = FALSE;
            return TRUE;


        #ifdef __REGISTERFORSHUTDOWN__
        /* 
        * LP: Flush and Shutdown will not be called unless there is a logical drive 
        * created on a drive. Shutdown will be called once, but Flush will be called
        * many times in between the normal IOs
        */
        case SRB_FUNCTION_SHUTDOWN:
            Srb->SrbStatus = SRB_STATUS_SUCCESS;
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_FUNCTION_SHUTDOWN\n"));
            pSrbExt->SRB_State = RS_COMPLETE;
            ScsiPortNotification(notify_type,
                                  pCard,
                                  srbPathId,
                                  srbTargetId,
                                  srbLun);

            ScsiPortNotification(RequestComplete, pCard, Srb);
            if (!pCard->AlreadyShutdown)
                fcShutdownChannel(&pCard->hpRoot);
            pCard->AlreadyShutdown++;
               
            pCard->State &= ~CS_DURING_STARTIO;
            pCard->inDriver = FALSE;
            return TRUE;
            break;
         
        case SRB_FUNCTION_FLUSH:
            Srb->SrbStatus = SRB_STATUS_SUCCESS;
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_FUNCTION_FLUSH\n"));
            pSrbExt->SRB_State = RS_COMPLETE;
            ScsiPortNotification(notify_type,
                                  pCard,
                                  srbPathId,
                                  srbTargetId,
                                  srbLun);

            ScsiPortNotification(RequestComplete, pCard, Srb);
            pCard->State &= ~CS_DURING_STARTIO;
            pCard->inDriver = FALSE;
            return TRUE;

            break;
        #endif
         
        default:
            // set error and complete request.
            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

            osDEBUGPRINT((ALWAYS_PRINT,"SRB_STATUS_INVALID_REQUEST\n"));
            pSrbExt->SRB_State = RS_COMPLETE;
        } // end switch Srb->Function

        // request another request for this logical unit.
        // osDEBUGPRINT((DHIGH,"ScsiPortNotification %x\n", notify_type));

        #ifdef ORG
        ScsiPortNotification(notify_type,
                         pCard,
                         srbPathId,
                         srbTargetId,
                         srbLun);
        #endif

    pCard->State &= ~CS_DURING_STARTIO;
    //pSrbExt->Perf_ptr->outOsStartio = get_hi_time_stamp();

    pCard->inDriver = FALSE;

#ifdef DEBUG_OTHERS
    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartIo: Completing other type of request: %d.%d.%d Func: %x SrbSta: %x ScsiSta: %x\n",
      Srb->PathId,
      Srb->TargetId,
      Srb->Lun,
      Srb->Function,
      Srb->SrbStatus,
      Srb->ScsiStatus ));
#endif
      
    ScsiPortNotification(RequestComplete, pCard, Srb);

    ScsiPortNotification(notify_type,
                         pCard,
                         srbPathId,
                         srbTargetId,
                         srbLun);

    return TRUE;

} // end HPFibreStartIo()


agFCDev_t
MapToHandle (PCARD_EXTENSION pCard,
    ULONG           pathId,
    ULONG           targetId,
    ULONG           lun,
    PLU_EXTENSION   pLunExt)
{   
    #ifndef YAM2_1
    ULONG       slot, specialDevIdx, volume;
    agFCDev_t   devHandle = NULL;
    
    if (pathId <= 3) 
    {
        slot = BUILD_SLOT(pathId, targetId);
        if (pCard->nodeInfo[slot].DeviceType & agDevSCSITarget) 
        {
            devHandle = pCard->hpFCDev[slot];
            if (pLunExt) 
            {
                pLunExt->Lun.lun_pd[0].Address_mode = PERIPHERAL_ADDRESS;
                pLunExt->Lun.lun_pd[0].Bus_number = 0;
                pLunExt->Lun.lun_pd[0].Lun = (UCHAR)lun;
            }
        }
    } 
    else 
    {
        specialDevIdx = targetId >> 4;
        if ((specialDevIdx < MAX_SPECIAL_DEVICES) &&
            (pCard->specialDev[specialDevIdx].devType != DEV_NONE)) 
        {
            if (pCard->specialDev[specialDevIdx].addrMode == LUN_ADDRESS) 
            {
                // This case is for MUX
                // LUN Addressing mode has only 5 bits for LUN number
                if (lun < 32) 
                {
                devHandle = pCard->hpFCDev [pCard->specialDev[specialDevIdx].devHandleIndex];
                if (pLunExt) 
                {
                    pLunExt->Lun.lun_lu[0].Address_mode = LUN_ADDRESS;
                    pLunExt->Lun.lun_lu[0].Target = (UCHAR) (targetId & 0xf);
                    pLunExt->Lun.lun_lu[0].Bus_number = (UCHAR) (pathId & 3);
                    pLunExt->Lun.lun_lu[0].Lun = (UCHAR) lun;
                }
            }
        } 
        else 
            if (pCard->specialDev[specialDevIdx].addrMode == VOLUME_SET_ADDRESS) 
            {
                //
                // This case is for EMC and COMPAQ
                // In order to be downward compatible with NT SP3, here we use only
                // 3 bits in LUN to build volume set number.
                //
                // Compaq array seems to be supporting only 256 volume sets.
                // It takes voume set 256 as volume set 0.
                // To work-around this problem we return NULL device handle for Compaq
                // array if the the volume set address is >= 256
                //
                if (lun < 8 && 
                    (pCard->specialDev[specialDevIdx].devType != DEV_COMPAQ || !(pathId & 2))) 
                {
                    devHandle = pCard->hpFCDev [pCard->specialDev[specialDevIdx].devHandleIndex];
                    if (pLunExt) 
                    {
                        volume = ((pathId & 3) << 7) | ((targetId & 0xf) << 3) | lun;
                        pLunExt->Lun.lun_vs[0].Address_mode = VOLUME_SET_ADDRESS;
                        pLunExt->Lun.lun_vs[0].Lun_hi = (UCHAR) (volume >> 8);
                        pLunExt->Lun.lun_vs[0].Lun = (UCHAR) (volume & 0xff);
                    }
                }
            }
        }
    }

    return devHandle;
    #else
    agFCDev_t   devHandle = NULL;
    USHORT      paIndex;
   
    if (GetPaDeviceHandle(pCard,pathId,targetId,lun,pLunExt,&paIndex) != -1L)
    {
        if ((pCard->Dev->PaDevice[paIndex].Index.Pa.FcDeviceIndex != PA_DEVICE_NO_ENTRY) )
        {
            ULONG fcIndex;
            fcIndex = pCard->Dev->PaDevice[paIndex].Index.Pa.FcDeviceIndex;
            #ifdef DBG
            if (fcIndex > gMaxPaDevices)
                osDEBUGPRINT((ALWAYS_PRINT, "MapToHandle: fcindex (=%d) > gMaxPaDevices (=%d)\n", fcIndex, gMaxPaDevices));
            #endif
         
            devHandle = pCard->hpFCDev[fcIndex];
        }
        else
            devHandle = NULL;
    }
    else
    {
        devHandle = NULL;
    }
    return devHandle;
    #endif
}

#ifdef _DEBUG_PERF_DATA_
void cdbswitch(PSCSI_REQUEST_BLOCK pSrb)
{
    PCARD_EXTENSION     pCard;
    PSRB_EXTENSION      pSrbExt;

    pSrbExt          = pSrb->SrbExtension;
    pCard            = pSrbExt->pCard;

    switch( pSrb->Cdb[0])
    {
        case SCSIOP_TEST_UNIT_READY    :
            osDEBUGPRINT((DMOD,"SCSIOP_TEST_UNIT_READY    \n"));break;
        case SCSIOP_REZERO_UNIT        :
            osDEBUGPRINT((DMOD,"SCSIOP_REZERO_UNIT        \n"));break;
        case SCSIOP_REQUEST_BLOCK_ADDR :
            osDEBUGPRINT((DMOD,"SCSIOP_REQUEST_BLOCK_ADDR \n"));break;
        case SCSIOP_REQUEST_SENSE      :
            osDEBUGPRINT((DMOD,"SCSIOP_REQUEST_SENSE      \n"));break;
        case SCSIOP_FORMAT_UNIT        :
            osDEBUGPRINT((DMOD,"SCSIOP_FORMAT_UNIT        \n"));break;
        case SCSIOP_READ_BLOCK_LIMITS  :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_BLOCK_LIMITS  \n"));break;
        case SCSIOP_REASSIGN_BLOCKS    :
            osDEBUGPRINT((DMOD,"SCSIOP_REASSIGN_BLOCKS    \n"));break;
        case SCSIOP_READ6              :
            osDEBUGPRINT((DMOD,"SCSIOP_READ6              \n"));break;
        case SCSIOP_WRITE6             :
            osDEBUGPRINT((DMOD,"SCSIOP_WRITE6             \n"));break;
        case SCSIOP_SEEK6              :
            osDEBUGPRINT((DMOD,"SCSIOP_SEEK6              \n"));break;
        case SCSIOP_PARTITION          :
            osDEBUGPRINT((DMOD,"SCSIOP_PARTITION          \n"));break;
        case SCSIOP_READ_REVERSE       :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_REVERSE       \n"));break;
        case SCSIOP_WRITE_FILEMARKS    :
            osDEBUGPRINT((DMOD,"SCSIOP_WRITE_FILEMARKS    \n"));break;
        case SCSIOP_SPACE              :
            osDEBUGPRINT((DMOD,"SCSIOP_SPACE              \n"));break;
        case SCSIOP_INQUIRY            :
            osDEBUGPRINT((DMOD,"SCSIOP_INQUIRY            \n"));break;
        case SCSIOP_VERIFY6            :
            osDEBUGPRINT((DMOD,"SCSIOP_VERIFY6            \n"));break;
        case SCSIOP_RECOVER_BUF_DATA   :
            osDEBUGPRINT((DMOD,"SCSIOP_RECOVER_BUF_DATA   \n"));break;
        case SCSIOP_MODE_SELECT        :
            osDEBUGPRINT((DMOD,"SCSIOP_MODE_SELECT        \n"));break;
        case SCSIOP_RESERVE_UNIT       :
            osDEBUGPRINT((ALWAYS_PRINT,"SCSIOP_RESERVE_UNIT       \n"));break;
        case SCSIOP_RELEASE_UNIT       :
            osDEBUGPRINT((ALWAYS_PRINT,"SCSIOP_RELEASE_UNIT       \n"));break;
        case SCSIOP_COPY               :
            osDEBUGPRINT((DMOD,"SCSIOP_COPY               \n"));break;
        case SCSIOP_ERASE              :
            osDEBUGPRINT((DMOD,"SCSIOP_ERASE              \n"));break;
        case SCSIOP_MODE_SENSE         :
            osDEBUGPRINT((DMOD,"SCSIOP_MODE_SENSE         \n"));break;
        case SCSIOP_START_STOP_UNIT    :
            osDEBUGPRINT((DMOD,"SCSIOP_START_STOP_UNIT    \n"));break;
        case SCSIOP_RECEIVE_DIAGNOSTIC :
            osDEBUGPRINT((DMOD,"SCSIOP_RECEIVE_DIAGNOSTIC \n"));break;
        case SCSIOP_SEND_DIAGNOSTIC    :
            osDEBUGPRINT((DMOD,"SCSIOP_SEND_DIAGNOSTIC    \n"));break;
        case SCSIOP_MEDIUM_REMOVAL     :
            osDEBUGPRINT((DMOD,"SCSIOP_MEDIUM_REMOVAL     \n"));break;
        case SCSIOP_READ_CAPACITY      :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_CAPACITY      \n"));break;
        case SCSIOP_READ               :
            osDEBUGPRINT((DMOD,"SCSIOP_READ               \n"));break;
        case SCSIOP_WRITE              :
            osDEBUGPRINT((DMOD,"SCSIOP_WRITE              \n"));break;
        case SCSIOP_SEEK               :
            osDEBUGPRINT((DMOD,"SCSIOP_SEEK               \n"));break;
        case SCSIOP_WRITE_VERIFY       :
            osDEBUGPRINT((DMOD,"SCSIOP_WRITE_VERIFY       \n"));break;
        case SCSIOP_VERIFY             :
            osDEBUGPRINT((DMOD,"SCSIOP_VERIFY             \n"));break;
        case SCSIOP_SEARCH_DATA_HIGH   :
            osDEBUGPRINT((DMOD,"SCSIOP_SEARCH_DATA_HIGH   \n"));break;
        case SCSIOP_SEARCH_DATA_EQUAL  :
            osDEBUGPRINT((DMOD,"SCSIOP_SEARCH_DATA_EQUAL  \n"));break;
        case SCSIOP_SEARCH_DATA_LOW    :
            osDEBUGPRINT((DMOD,"SCSIOP_SEARCH_DATA_LOW    \n"));break;
        case SCSIOP_SET_LIMITS         :
            osDEBUGPRINT((DMOD,"SCSIOP_SET_LIMITS         \n"));break;
        case SCSIOP_READ_POSITION      :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_POSITION      \n"));break;
        case SCSIOP_SYNCHRONIZE_CACHE  :
            osDEBUGPRINT((DMOD,"SCSIOP_SYNCHRONIZE_CACHE  \n"));break;
        case SCSIOP_COMPARE            :
            osDEBUGPRINT((DMOD,"SCSIOP_COMPARE            \n"));break;
        case SCSIOP_COPY_COMPARE       :
            osDEBUGPRINT((DMOD,"SCSIOP_COPY_COMPARE       \n"));break;
        case SCSIOP_WRITE_DATA_BUFF    :
            osDEBUGPRINT((DMOD,"SCSIOP_WRITE_DATA_BUFF    \n"));break;
        case SCSIOP_READ_DATA_BUFF     :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_DATA_BUFF     \n"));break;
        case SCSIOP_CHANGE_DEFINITION  :
            osDEBUGPRINT((DMOD,"SCSIOP_CHANGE_DEFINITION  \n"));break;
        case SCSIOP_READ_SUB_CHANNEL   :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_SUB_CHANNEL   \n"));break;
        case SCSIOP_READ_TOC           :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_TOC           \n"));break;
        case SCSIOP_READ_HEADER        :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_HEADER        \n"));break;
        case SCSIOP_PLAY_AUDIO         :
            osDEBUGPRINT((DMOD,"SCSIOP_PLAY_AUDIO         \n"));break;
        case SCSIOP_PLAY_AUDIO_MSF     :
            osDEBUGPRINT((DMOD,"SCSIOP_PLAY_AUDIO_MSF     \n"));break;
        case SCSIOP_PLAY_TRACK_INDEX   :
            osDEBUGPRINT((DMOD,"SCSIOP_PLAY_TRACK_INDEX   \n"));break;
        case SCSIOP_PLAY_TRACK_RELATIVE:
            osDEBUGPRINT((DMOD,"SCSIOP_PLAY_TRACK_RELATIVE\n"));break;
        case SCSIOP_PAUSE_RESUME       :
            osDEBUGPRINT((DMOD,"SCSIOP_PAUSE_RESUME       \n"));break;
        case SCSIOP_LOG_SELECT         :
            osDEBUGPRINT((DMOD,"SCSIOP_LOG_SELECT         \n"));break;
        case SCSIOP_LOG_SENSE          :
            osDEBUGPRINT((DMOD,"SCSIOP_LOG_SENSE          \n"));break;
        case SCSIOP_MODE_SELECT10      :
            osDEBUGPRINT((DMOD,"SCSIOP_MODE_SELECT10      \n"));break;
        case SCSIOP_MODE_SENSE10       :
            osDEBUGPRINT((DMOD,"SCSIOP_MODE_SENSE10       \n"));break;
        case SCSIOP_LOAD_UNLOAD_SLOT   :
            osDEBUGPRINT((DMOD,"SCSIOP_LOAD_UNLOAD_SLOT   \n"));break;
        case SCSIOP_MECHANISM_STATUS   :
            osDEBUGPRINT((DMOD,"SCSIOP_MECHANISM_STATUS   \n"));break;
        case SCSIOP_READ_CD            :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_CD            \n"));break;
        default:
            osDEBUGPRINT((DMOD,"UNKNOWN_CMD               \n"));break;
    }    
            
}
#endif

PSRB_EXTENSION  Add_next_Srbext( PSRB_EXTENSION pSrbExt,PSRB_EXTENSION pNewSrbExt)
{
    if(pSrbExt->pNextSrbExt) 
        return pSrbExt->pNextSrbExt;
    else 
    {
        pSrbExt->pNextSrbExt = pNewSrbExt;
        pNewSrbExt->pNextSrbExt = NULL;
        return pNewSrbExt->pNextSrbExt;
    }
}

void insert_Srbext(PCARD_EXTENSION  pCard,PSRB_EXTENSION pSrbExt)
{
    PSRB_EXTENSION pTmpSrbExt = pCard->RootSrbExt;
    if(!pTmpSrbExt)
    {
        pCard->RootSrbExt = pSrbExt;
        return;
    }
   
    while(pTmpSrbExt)
    {
        pTmpSrbExt= Add_next_Srbext( pTmpSrbExt,pSrbExt);
    }
}

PSRB_EXTENSION  Del_next_Srbext( PSRB_EXTENSION pSrbExt,PSRB_EXTENSION pOldSrbExt)
{
    if(pSrbExt->pNextSrbExt != pOldSrbExt)
    {
        return pSrbExt->pNextSrbExt;
    }
    else 
    {
        pSrbExt->pNextSrbExt = pOldSrbExt->pNextSrbExt;
        return NULL;
    }
}

int remove_Srbext(PCARD_EXTENSION  pCard, PSRB_EXTENSION pSrbExt)
{
    PSRB_EXTENSION pTmpSrbExt = pCard->RootSrbExt;

    if(pTmpSrbExt == pSrbExt )
    {    
        pCard->RootSrbExt = pTmpSrbExt->pNextSrbExt;
        return(TRUE);
    }
   
    while(pTmpSrbExt)
    {
        pTmpSrbExt= Del_next_Srbext( pTmpSrbExt,pSrbExt);
    }
    return(TRUE);
}

void
SrbEnqueueTail (OSL_QUEUE *queue, PSCSI_REQUEST_BLOCK pSrb)
{
    ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb = NULL;
    if (queue->Head == NULL) 
    {
        queue->Head = pSrb;
        queue->Tail = pSrb;
    } 
    else 
    {
        ((PSRB_EXTENSION)(((PSCSI_REQUEST_BLOCK)(queue->Tail))->SrbExtension))->pNextSrb = pSrb;
        queue->Tail = pSrb;
    }

    #ifdef DBGPRINT_IO
    if (gDbgPrintIo & DBGPRINT_QTAIL )
    {
        static   count;
        UCHAR    *uptr;
        osDEBUGPRINT((ALWAYS_PRINT, " QueT(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Srb=%x Next=%x Head=%x Tail=%x\n",
         count++,
         pSrb->PathId,
         pSrb->TargetId,
         pSrb->Lun,
         pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
         pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], 
         pSrb,
         ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb,
         queue->Head,
         queue->Tail
         ));
    }
    #endif   

}

void
SrbEnqueueHead (OSL_QUEUE *queue, PSCSI_REQUEST_BLOCK pSrb)
{
    if (queue->Head == NULL) 
    {
        queue->Head = pSrb;
        queue->Tail = pSrb;
        ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb = NULL;
    } 
    else 
    {
        ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb = queue->Head;
        queue->Head = pSrb;
    }
    #ifdef DBGPRINT_IO
    if (gDbgPrintIo & DBGPRINT_QHEAD )
    {
        static   count;
        UCHAR    *uptr;
        osDEBUGPRINT((ALWAYS_PRINT, " QueH(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Srb=%x Next=%x Head=%x Tail=%x\n",
            count++,
            pSrb->PathId,
            pSrb->TargetId,
            pSrb->Lun,
            pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
            pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], 
            pSrb,
            ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb,
            queue->Head,
            queue->Tail
            ));
    }
    #endif   
}

PSCSI_REQUEST_BLOCK
SrbDequeueHead (OSL_QUEUE *queue)
{  
    PSCSI_REQUEST_BLOCK  pSrb;

    pSrb = queue->Head;
    if (pSrb != NULL) 
    {
        queue->Head = ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb;
        if (queue->Head == NULL)
            queue->Tail = NULL;
        #ifdef DBGPRINT_IO
        if (gDbgPrintIo & DBGPRINT_DEQHEAD )
        {
            static   count;
            UCHAR    *uptr;
            osDEBUGPRINT((ALWAYS_PRINT, " DeQH(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Srb=%x Next=%x Head=%x Tail=%x\n",
                count++,
                pSrb->PathId,
                pSrb->TargetId,
                pSrb->Lun,
                pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], 
                pSrb,
                ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb,
                queue->Head,
                queue->Tail
                ));
        }
        #endif   
    }

    return pSrb;
}

void
Startio (PCARD_EXTENSION pCard)
{
    PSCSI_REQUEST_BLOCK     pSrb;
    PSRB_EXTENSION          pSrbExt;
    agRoot_t                *phpRoot;
    agFCDev_t               handle;
    agIORequest_t           *pHpio_request;
    agIORequestBody_t       *pHpio_CDBrequest;
    ULONG                   fcIoStatus;
    PLU_EXTENSION           pLunExt;
    int                     completeRequest;
    UCHAR                    pathId, targetId, lun;
    #ifdef YAM2_1
    PA_DEVICE                  *dev;
    #endif
   
    while ((pSrb = SrbDequeueHead (&pCard->AdapterQ)) != NULL) 
    {
        #ifdef _DEBUG_LOSE_IOS_
        osDEBUGPRINT((DMOD, "Startio Srb = %lx pCard->Srb_IO_Count = %x\n", pSrb, pCard->Srb_IO_Count));
        #endif
        pSrbExt          = pSrb->SrbExtension;
        phpRoot          = pSrbExt->phpRoot;
        handle           = pSrbExt->pLunExt->phandle;
        pHpio_request    = &pSrbExt->hpIORequest;
        pHpio_CDBrequest = &pSrbExt->hpRequestBody;
        pathId           = pSrb->PathId;
        targetId         = pSrb->TargetId;
        lun              = pSrb->Lun;
        completeRequest  = 0;
      
        #ifdef YAM2_1
        pLunExt = ScsiPortGetLogicalUnit (pCard, pSrb->PathId, pSrb->TargetId, pSrb->Lun);
        dev = pCard->Dev->PaDevice + pLunExt->PaDeviceIndex;
   
       /* wait till the addressing mode are established before processing non zeo LUNs */
//       if ( (dev->ModeFlag & PA_DEVICE_BUILDING_DEVICE_MAP) && (lun != 0) )
        if ( !(dev->ModeFlag & PA_DEVICE_TRY_MODE_ALL) && (lun != 0) )
        {
            pSrbExt->SRB_State =  RS_WAITING;
            SrbEnqueueTail (&pCard->RetryQ, pSrb);
            return;
        }
            
        /* make suer the FCP LUNs are set properly */
        SetFcpLunBeforeStartIO (pLunExt, pHpio_CDBrequest, pSrb);
        #endif
      
        #ifdef _DEBUG_PERF_DATA_
        cdbswitch(pSrb);
        pSrbExt->SRB_StartTime = osTimeStamp(0);
        #endif
        
        #ifdef _DEBUG_LOSE_IOS_
        pSrbExt->SRB_IO_COUNT = pCard->Srb_IO_Count;
        #endif
      
        #ifdef _DEBUG_PERF_DATA_
        pSrbExt->SRB_TimeOutTime = pSrbExt->SRB_StartTime+((pSrb->TimeOutValue - 3 ) * OS_STAMP_PER_SECOND);
        #endif
        
        #if DBG > 4
        if(pSrb->TimeOutValue < 10)
            osDEBUGPRINT((DMOD,"Time out value of IO is less than 10 seconds %d\n",pSrb->TimeOutValue));
        #endif

        #ifdef _DEBUG_PERF_DATA_
        pSrbExt->Perf_ptr->inFcStartio  = get_hi_time_stamp();
        #endif
        pSrbExt->SRB_State = RS_STARTIO;

        #ifdef DBGPRINT_IO
        if (gDbgPrintIo & DBGPRINT_SEND )
        {
            static   count;
            UCHAR    *uptr;
            ULONG    paDeviceIndex = 0;
         
            #ifdef YAM2_1
            paDeviceIndex = pLunExt->PaDeviceIndex,
            #endif

            osDEBUGPRINT((ALWAYS_PRINT, " Send(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x FCP0 %02x%02x PAIx=%d FCHndl=%08x\n",
                        count++,
                        pSrb->PathId,
                        pSrb->TargetId,
                        pSrb->Lun,
                        pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                        pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9],          
                        pSrbExt->hpRequestBody.CDBRequest.FcpCmnd.FcpLun[0],
                        pSrbExt->hpRequestBody.CDBRequest.FcpCmnd.FcpLun[1],
                        paDeviceIndex,
                        pSrbExt->pLunExt->phandle));
        }
        #endif   

        if (pCard->LinkState != LS_LINK_UP) 
            fcIoStatus = fcIOBusy;
        else
            fcIoStatus = fcStartIO( phpRoot,
                                pHpio_request,
                                handle, // pLunExt->phandle,
                                fcCDBRequest,
                                &pSrbExt->hpRequestBody);

        #ifdef _DEBUG_PERF_DATA_
        pSrbExt->Perf_ptr->outFcStartio = get_hi_time_stamp();
        #endif
        
        switch (fcIoStatus )
        {
            case fcIOStarted:

                #ifdef FCLayer_Stub // Stub only !!!!
                osDEBUGPRINT((DMOD,"HPFibreStartIo DO TimerCall @ %x\n", osTimeStamp(0) ));
                ScsiPortNotification(RequestTimerCall,
                                    pCard,
                                    (PHW_TIMER) osFakeInterrupt,
                                    // 1000000 ); // 1000000 should be 1 second
                                    12000 ); //  .012 sec
                                    //100000 ); //  .10 sec
                                    // 250000 ); //  .25 sec

                #endif /*  FCLayer_Stub */

                #ifdef _DEBUG_LOSE_IOS_
                pCard->Srb_IO_Count++;
                #endif
                //
                // NOTE: There is a chance that FC Layer may complete the request (call
                // osIoCompleted) before fcStartIo returns.
                // So don't make any references to Srb from here onwards.
                
                
                #ifdef _DEBUG_PERF_DATA_
                insert_Srbext( pCard, pSrbExt);
                #endif
                break;

            case fcIOBusy:

                pSrbExt->SRB_State =  RS_WAITING;
                SrbEnqueueHead (&pCard->AdapterQ, pSrb);
                osDEBUGPRINT((ALWAYS_PRINT,"startio FCLAYER Busy\n"));
                #ifdef _DEBUG_EVENTLOG_
                LogEvent(   pCard, 
                    (PVOID)pSrbExt, 
                    HPFC_MSG_STARTIO_ERROR,
                    NULL, 
                    0, 
                    "%x", fcIoStatus);
                #endif
                return;

            case fcIONoDevice:
                pSrbExt->SRB_State =  RS_NODEVICE;
                osDEBUGPRINT((ALWAYS_PRINT,"startio FCLAYER reports fcIONoDevice\n"));
                pSrb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
                completeRequest = 1;
                #ifdef _DEBUG_EVENTLOG_
                LogEvent(   pCard, 
                     (PVOID)pSrbExt, 
                     HPFC_MSG_STARTIO_ERROR,
                     NULL, 
                     0, 
                     "%x", fcIoStatus);
                #endif
                break;

            case fcIONoSupport:
            case fcIOBad:
            default:
                osDEBUGPRINT((ALWAYS_PRINT,"startio FCLAYER reports fcIoStatus = %d\n", fcIoStatus));
                pSrb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
                completeRequest = 1;
                #ifdef _DEBUG_EVENTLOG_
                LogEvent(   pCard, 
                  (PVOID)pSrbExt, 
                  HPFC_MSG_STARTIO_ERROR,
                  NULL, 
                  0, 
                  "%x", fcIoStatus);
                #endif
                break;

        } // switch fcIoStatus

        if (completeRequest) 
        {
            pLunExt = ScsiPortGetLogicalUnit (pCard, pSrb->PathId, pSrb->TargetId, pSrb->Lun);

            if (pLunExt)
                pLunExt->OutstandingIOs--;

            pSrbExt->SRB_State = RS_COMPLETE;
            osDEBUGPRINT((ALWAYS_PRINT,"StartIO: Completing request Srb=%x\n",pSrb));

            ScsiPortNotification (RequestComplete, pCard, pSrb);
        }
    } // while ((pSrb = SrbDequeueFromHead (&pCard->AdapterQ)) != NULL)

    ScsiPortNotification (NextLuRequest, pCard, pathId, targetId, lun);

    osDEBUGPRINT((DMOD,"OUT StartIo\n" ));
    return;
}

void
InitLunExtension (PLU_EXTENSION pLunExt)
{
    pLunExt->flags = LU_EXT_INITIALIZED;
    pLunExt->MaxAllowedIOs = MAX_IO_PER_DEVICE;
    pLunExt->OutstandingIOs = 0;
    pLunExt->MaxOutstandingIOs = 0;
    pLunExt->phandle = 0;

    /* if not multi mode, set it to PA addressing only */
    if (gMultiMode == FALSE)
        pLunExt->Mode = PA_DEVICE_TRY_MODE_PA;

}

#ifdef _ENABLE_PSEUDO_DEVICE_
ULONG PseudoDeviceIO(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    ULONG tid, tmp, i;
   
    PSRB_EXTENSION pSrbExt  =   Srb->SrbExtension;
   
    if ((Srb->PathId == 4) && (Srb->TargetId == 0))
    {
        if ( (Srb->Lun == 0)  && (Srb->Cdb[0] == SCSIOP_INQUIRY) )
        {
            Srb->SrbStatus = SRB_STATUS_SUCCESS;
            //
            // Zero INQUIRY data structure.
            //
            for (i = 0; i < Srb->DataTransferLength; i++) 
            {
                ((PUCHAR) Srb->DataBuffer)[i] = 0;
            }

            //
            // Set to funky device type to hide from windisk.
            //
            ((PINQUIRYDATA) Srb->DataBuffer)->DeviceType = PROCESSOR_DEVICE;

            //
            // Fill in vendor identification fields.
            //
            tid = Srb->TargetId + 0x30;

            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[0] = 'F';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[1] = 'C';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[2] = 'C';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[3] = 'I';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[4] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[5] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[6] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[7] = ' ';

            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[0]  = 'P';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[1]  = 'S';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[2]  = 'E';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[3]  = 'U';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[4]  = 'D';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[5]  = 'O';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[6]  = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[7]  = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[8]  = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[9]  = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[10] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[11] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[12] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[13] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[14] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[15] = ' ';

            tmp = 1;

            for (i = 0; i < 4; i++) 
            {
                ((PINQUIRYDATA) Srb->DataBuffer)->ProductRevisionLevel[i] = (UCHAR) tmp + 0x30;
                tmp >>= 8;
            }
        }
        else 
        {
            Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
        }
         
        pSrbExt->SRB_State = RS_COMPLETE;
        ScsiPortNotification(RequestComplete, pCard, Srb);
        ScsiPortNotification(NextRequest,
                         pCard,
                         Srb->PathId,
                         Srb->TargetId,
                         Srb->Lun);

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\tlstruct.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/TLStruct.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/29/00 11:34a  $ (Last Modified)

Purpose:

  This file validates the typedef declarations in ../H/TLStruct.H

--*/
#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/tlstruct.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "tlstruct.h"
#endif  /* _New_Header_file_Layout_ */

/*+
Function:  TLStructASSERTs()

Purpose:   Returns the number of TLStruct.H typedefs which are not the correct size.

Algorithm: Each typedef in TLStruct.H is checked for having the correct size.  While
           this property doesn't guarantee correct packing of the fields within, it
           is a pretty good indicator that the typedef has the intended layout.

           The total number of typedefs which are not of correct size is returned from
           this function.  Hence, if the return value is non-zero, the declarations
           can not be trusted to match the TachyonTL specification.
-*/

os_bit32 TLStructASSERTs(
                       void
                     )
{
    os_bit32 to_return = 0;

    if ( sizeof(ChipConfig_t)                   !=                   ChipConfig_t_SIZE ) to_return++;
    if ( sizeof(ChipIOLo_t)                     !=                     ChipIOLo_t_SIZE ) to_return++;
    if ( sizeof(ChipIOUp_t)                     !=                     ChipIOUp_t_SIZE ) to_return++;
    if ( sizeof(ChipMem_t)                      !=                      ChipMem_t_SIZE ) to_return++;
    if ( sizeof(ERQProdIndex_t)                 !=                 ERQProdIndex_t_SIZE ) to_return++;
    if ( sizeof(ERQConsIndex_t)                 !=                 ERQConsIndex_t_SIZE ) to_return++;
    if ( sizeof(IMQProdIndex_t)                 !=                 IMQProdIndex_t_SIZE ) to_return++;
    if ( sizeof(IMQConsIndex_t)                 !=                 IMQConsIndex_t_SIZE ) to_return++;
    if ( sizeof(SFQProdIndex_t)                 !=                 SFQProdIndex_t_SIZE ) to_return++;
    if ( sizeof(SFQConsIndex_t)                 !=                 SFQConsIndex_t_SIZE ) to_return++;
    if ( sizeof(FCHS_t)                         !=                         FCHS_t_SIZE ) to_return++;
    if ( sizeof(X_ID_t)                         !=                         X_ID_t_SIZE ) to_return++;
    if ( sizeof(SG_Element_t)                   !=                   SG_Element_t_SIZE ) to_return++;
    if ( sizeof(USE_t)                          !=                          USE_t_SIZE ) to_return++;
    if ( sizeof(IWE_t)                          !=                          IWE_t_SIZE ) to_return++;
    if ( sizeof(IRE_t)                          !=                          IRE_t_SIZE ) to_return++;
    if ( sizeof(TWE_t)                          !=                          TWE_t_SIZE ) to_return++;
    if ( sizeof(TRE_t)                          !=                          TRE_t_SIZE ) to_return++;
    if ( sizeof(SEST_t)                         !=                         SEST_t_SIZE ) to_return++;
    if ( sizeof(IRB_Part_t)                     !=                     IRB_Part_t_SIZE ) to_return++;
    if ( sizeof(IRB_t)                          !=                          IRB_t_SIZE ) to_return++;
    if ( sizeof(CM_Unknown_t)                   !=                   CM_Unknown_t_SIZE ) to_return++;
    if ( sizeof(CM_Outbound_t)                  !=                  CM_Outbound_t_SIZE ) to_return++;
    if ( sizeof(CM_Error_Idle_t)                !=                CM_Error_Idle_t_SIZE ) to_return++;
    if ( sizeof(CM_Inbound_t)                   !=                   CM_Inbound_t_SIZE ) to_return++;
    if ( sizeof(CM_ERQ_Frozen_t)                !=                CM_ERQ_Frozen_t_SIZE ) to_return++;
    if ( sizeof(CM_FCP_Assists_Frozen_t)        !=        CM_FCP_Assists_Frozen_t_SIZE ) to_return++;
    if ( sizeof(CM_Frame_Manager_t)             !=             CM_Frame_Manager_t_SIZE ) to_return++;
    if ( sizeof(CM_Inbound_FCP_Exchange_t)      !=      CM_Inbound_FCP_Exchange_t_SIZE ) to_return++;
    if ( sizeof(CM_Class_2_Frame_Header_t)      !=      CM_Class_2_Frame_Header_t_SIZE ) to_return++;
    if ( sizeof(CM_Class_2_Sequence_Received_t) != CM_Class_2_Sequence_Received_t_SIZE ) to_return++;
    if ( sizeof(Completion_Message_t)           !=           Completion_Message_t_SIZE ) to_return++;

    return to_return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\state.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/State.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/30/00 11:31a $ (Last Modified)

Purpose:

  This file implements the FC Layer State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#endif  /* _New_Header_file_Layout_ */

/*+
Function:  fiInstallStateMachine()

Purpose:   Copies State Machine data structure(s) updating the actions
           as requested.

Algorithm: After copying the State Machine data structure(s), the actionUpdate
           array is used to modify any action function pointers based on the
           value of compareBase.  The actionUpdate array contains records which
           contain a value to mask compareBase.  If the masked value matches
           the compareTo value for the record, all instances of the originalAction
           function pointer will be replaced by the replacementAction function
           pointer.

           Note that the originalAction function pointers must be found in the source
           of the State Machine data structure(s), not the copied data structure(s).
           This prevents ambiguities which would result if the replacementAction function
           pointers match any originalAction function pointers.
-*/

#ifndef __State_Force_Static_State_Tables__
void fiInstallStateMachine(
                            stateTransitionMatrix_t *srcStateTransitionMatrix,
                            stateActionScalar_t     *srcStateActionScalar,
                            stateTransitionMatrix_t *dstStateTransitionMatrix,
                            stateActionScalar_t     *dstStateActionScalar,
                            os_bit32                    compareBase,
                            actionUpdate_t           actionUpdate[]
                          )
{
    actionUpdate_t *oneActionUpdate;
    os_bit32           bitMask;
    action_t        originalAction;
    action_t        replacementAction;
    state_t         state;

    *dstStateTransitionMatrix = *srcStateTransitionMatrix;
    *dstStateActionScalar     = *srcStateActionScalar;

    oneActionUpdate = &actionUpdate[0];

    while ((bitMask = oneActionUpdate->bitMask) != 0)
    {
        if ((compareBase & bitMask) == oneActionUpdate->compareTo)
        {
            originalAction    = oneActionUpdate->originalAction;
            replacementAction = oneActionUpdate->replacementAction;

            for (state=0;state<maxStates;state++)
            {
                if (originalAction == srcStateActionScalar->newAction[state])
                {
                    dstStateActionScalar->newAction[state] = replacementAction;
                }
            }
        }

        oneActionUpdate++;
    }
}
#endif /* __State_Force_Static_State_Tables__ was not defined */

/*+
Function:  fiInitializeThread()

Purpose:   Initializes the fi_thread__t data structure to contain hpRoot, the thread
           type and (a) pointer(s) to the State Machine data structure(s).
-*/

void fiInitializeThread(
                         fi_thread__t                *thread,
                         agRoot_t                *hpRoot,
                         threadType_t             threadType,
                         state_t                  initialState,
                         stateTransitionMatrix_t *stateTransitionMatrix,
                         stateActionScalar_t     *stateActionScalar
                       )
{
    thread->hpRoot                = hpRoot;
    thread->threadType            = threadType;
    thread->currentState          = initialState;
    thread->stateTransitionMatrix = stateTransitionMatrix;
    thread->stateActionScalar     = stateActionScalar;
}

/*+
Function:  fiSendEvent()

Purpose:   Sends an event to a thread immediately as well as (recursively) sending
           any event returned via eventRecord from the action routine called.

Algorithm: The current state of the specified thread and the event passed in are used
           to compute a new state for the thread and to fetch a action routine function
           pointer.

           For the Moore State Machine Model, the actions occur in the states.  So, each
           element of the stateTransitionMatrix contains only the newState for the thread.
           The newAction (which corresponds to this newState) is retrieved from the
           stateActionScalar for this thread.

           In the call to the thread's newAction, an eventRecord_t is passed.  This can be
           used by the action routine to pass on an event to the same or a new thread.  By
           "returning" the event to send, recursion of fiSendEvent() is avoided.  This is
           necessary as stack depth is a critically limited resource in some environments.
-*/

void fiSendEvent(
                  fi_thread__t *thread,
                  event_t   event
                )
{
    eventRecord_t nextEventRecord;
    state_t       oldState;
    state_t       newState;
    action_t      newAction;

#ifdef LOG_STATE_TRANSITIONS
    os_bit32         StateInfo = 0;
#endif /* LOG_STATE_TRANSITIONS */

    oldState = thread->currentState;

    newState = thread->stateTransitionMatrix->newState[event][oldState];

    if(newState == 0)
    {
        fiLogString(thread->hpRoot,
                        "SConfused T %d S %d E %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                         (os_bit32)thread->threadType,
                        (os_bit32)oldState,
                        (os_bit32)event,
                        0,0,0,0,0);
    }

#ifndef osLogDebugString
    if (newState == 0)
    {
        fiLogDebugString(
                          thread->hpRoot,
                          fiSendEventErrorLogLevel,
                          "*** fiSendEvent Thread(%p) type %d Confused OldState %d Event %d NewState %d",
                          (char *)agNULL,
                          (char *)agNULL,
                          thread,(void *)agNULL,
                          (os_bit32)thread->threadType,
                          (os_bit32)oldState,
                          (os_bit32)event,
                          (os_bit32)newState,
                          (os_bit32)0,
                          (os_bit32)0,
                          (os_bit32)0,
                          (os_bit32)0
                        );
    }
#endif /* fiLogDebugString was not defined */

    thread->currentState = newState;

    newAction = thread->stateActionScalar->newAction[newState];

#ifndef Performance_Debug
    fiLogDebugString(
                      thread->hpRoot,
                      fiSendEventInfoLogLevel,
                      "fiSendEvent(callEvent): ThreadType = %x Thread = 0x%p Event = %d OldState = %d NewState = %d Action = 0x%p",
                      (char *)agNULL,(char *)agNULL,
                      thread,(void *)newAction,
                      (os_bit32)thread->threadType,
                      (os_bit32)event,
                      (os_bit32)oldState,
                      (os_bit32)newState,
                      (os_bit32)0,
                      (os_bit32)0,
                      (os_bit32)0,
                      (os_bit32)0
                    );
#endif /* Performance_Debug */

#ifdef LOG_STATE_TRANSITIONS
    osLogStateTransition(thread->hpRoot,  LogStateTransition(0, thread->threadType,thread->currentState, event) );
#endif /* LOG_STATE_TRANSITIONS */


    (*newAction)(
                  thread,
                  &nextEventRecord
                );

    while (nextEventRecord.thread != (fi_thread__t *)agNULL)
    {
        oldState = nextEventRecord.thread->currentState;

        newState = nextEventRecord.thread->stateTransitionMatrix->newState[nextEventRecord.event][oldState];

        nextEventRecord.thread->currentState = newState;

        if(newState == 0)
        {
            fiLogString(thread->hpRoot,
                            "NConfused T %d S %d E %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                             (os_bit32)nextEventRecord.thread->threadType,
                            (os_bit32)oldState,
                            (os_bit32)nextEventRecord.event,
                            0,0,0,0,0);
        }

#ifndef fiLogDebugString
        if (newState == 0)
        {
            fiLogDebugString(
                              thread->hpRoot,
                              fiSendEventErrorLogLevel,
                              "fiSendEvent(nextEvent) Thread(%p) type %d Confused OldState %d Event %d NewState %d",
                              (char *)agNULL,(char *)agNULL,
                              nextEventRecord.thread,(void *)agNULL,
                              (os_bit32)nextEventRecord.thread->threadType,
                              (os_bit32)oldState,
                              (os_bit32)nextEventRecord.event,
                              (os_bit32)newState,
                              (os_bit32)0,
		                      (os_bit32)0,
                              (os_bit32)0,
                              (os_bit32)0
                            );
        }
#endif /* fiLogDebugString was not defined */

        newAction = nextEventRecord.thread->stateActionScalar->newAction[newState];

#ifndef Performance_Debug
        fiLogDebugString(
                          thread->hpRoot,
                          fiSendEventInfoLogLevel,
                          "fiSendEvent(nextEvent): ThreadType = %x Thread = 0x%p Event = %d OldState = %d NewState = %d Action = 0x%p",
                          (char *)agNULL,(char *)agNULL,
                          nextEventRecord.thread,(void *)newAction,
                          (os_bit32)nextEventRecord.thread->threadType,
                          (os_bit32)nextEventRecord.event,
                          (os_bit32)oldState,
                          (os_bit32)newState,
	                      (os_bit32)0,
		                  (os_bit32)0,
                          (os_bit32)0,
                          (os_bit32)0
                        );

#endif /* Performance_Debug */

#ifdef LOG_STATE_TRANSITIONS
        osLogStateTransition(thread->hpRoot,  LogStateTransition(agTRUE, nextEventRecord.thread->threadType,nextEventRecord.thread->currentState, nextEventRecord.event) );
#endif /* LOG_STATE_TRANSITIONS */

        (*newAction)(
                      nextEventRecord.thread,
                      &nextEventRecord
                    );
    }
}

/*+
Function:  fiSetEventRecord()

Purpose:   Sets the fields of an eventRecord so that the specified event is
           delivered to the specified thread (presumably) upon return from the
           action routine which called fiSetEventRecord().
-*/

void fiSetEventRecord(
                       eventRecord_t *eventRecord,
                       fi_thread__t      *thread,
                       event_t        event
                     )
{
    eventRecord->thread = thread;
    eventRecord->event  = event;
}

/*+
  Function: State_c
   Purpose: When compiled updates browser info file for VC 5.0 / 6.0
   Returns: none
 Called By: none
     Calls: none
-*/
/* void State_c(void){} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\timersvc.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/TimerSvc.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/TimerSvc.C

--*/

#ifndef __TimerSvc_H__
#define __TimerSvc_H__

osGLOBAL void fiTimerSvcInit(
                            agRoot_t *hpRoot
                          );

osGLOBAL void fiTimerInitializeRequest(
                                      fiTimer_Request_t *Timer_Request
                                    );

osGLOBAL void fiTimerSetDeadlineFromNow(
                                       agRoot_t          *hpRoot,
                                       fiTimer_Request_t *Timer_Request,
                                       os_bit32              From_Now
                                     );

osGLOBAL void fiTimerAddToDeadline(
                                  fiTimer_Request_t *Timer_Request,
                                  os_bit32              To_Add
                                );

osGLOBAL void fiTimerStart(
                          agRoot_t          *hpRoot,
                          fiTimer_Request_t *Timer_Request
                        );

osGLOBAL void fiTimerStop(
                         fiTimer_Request_t *Timer_Request
                       );

osGLOBAL void fiTimerTick(
                         agRoot_t *hpRoot,
                         os_bit32     tickDelta
                       );

#endif /* __TimerSvc_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\timersvc.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/TimerSvc.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/29/00 11:33a  $ (Last Modified)

Purpose:

  This file implements Timer Services for the FC Layer.

--*/

#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/queue.h"
#include "../h/timersvc.h"
#include "../h/cstate.h"
#include "../h/cfunc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "queue.h"
#include "timersvc.h"
#include "cstate.h"
#include "cfunc.h"
#endif  /* _New_Header_file_Layout_ */

void fiTimerSvcInit(
                     agRoot_t *hpRoot
                   )
{
    CThread_t *CThread = CThread_ptr(hpRoot);

    fiLogDebugString(
                        hpRoot,
                        TimerServiceLogErrorLevel,
                        "fiTimerSvcInit",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0
                        );


    CThread->TimeBase.Lo = 0;
    CThread->TimeBase.Hi = 0;

    fiListInitHdr(
                   &(CThread->TimerQ)
                 );

/*
     We need to initialize the list since this is called from CActionInitialize during
     error recovery. We may have to walk the list and initialize all the elements in 
     the list to the sentinel value.

*/
	fiTimerInitializeRequest(&(CThread->Timer_Request));

}

void fiTimerInitializeRequest(
                               fiTimer_Request_t *Timer_Request
                             )
{
    fiListInitElement(
                       &(Timer_Request->TimerQ_Link)
                     );

    Timer_Request->Active = agFALSE;
}

void fiTimerSetDeadlineFromNow(
                                agRoot_t          *hpRoot,
                                fiTimer_Request_t *Timer_Request,
                                os_bit32              From_Now
                              )
{
    fiTime_t *TimeBase = &(CThread_ptr(hpRoot)->TimeBase);
    os_bit32     newLo    = TimeBase->Lo + From_Now;

    Timer_Request->Deadline.Lo = newLo;

    if (newLo < From_Now)
    {
        Timer_Request->Deadline.Hi = TimeBase->Hi + 1;
    }
    else
    {
        Timer_Request->Deadline.Hi = TimeBase->Hi;
    }
}

void fiTimerAddToDeadline(
                           fiTimer_Request_t *Timer_Request,
                           os_bit32              To_Add
                         )
{
    os_bit32 newLo = Timer_Request->Deadline.Lo + To_Add;

    if (newLo < To_Add)
    {
        Timer_Request->Deadline.Hi += 1;
    }
}

void fiTimerStart(
                   agRoot_t          *hpRoot,
                   fiTimer_Request_t *Timer_Request
                 )
{
    CThread_t         *CThread            = CThread_ptr(hpRoot);
    fiList_t          *TimerQ             = &(CThread->TimerQ);
    fiTimer_Request_t *Prev_Timer_Request = (fiTimer_Request_t *)(TimerQ->blink);

    osDebugBreakpoint(
                       hpRoot,
                       ((Timer_Request->Active == agFALSE) ? agFALSE : agTRUE),
                       "fiTimerStart(): Timer_Request->Active != agFALSE"
                     );
    if(Timer_Request->Active )
    { /* Assertion was true  */ 
        return;
    }



    while (   (Prev_Timer_Request != (fiTimer_Request_t *)TimerQ)
           && (   (Prev_Timer_Request->Deadline.Hi > Timer_Request->Deadline.Hi)
               || (   (Prev_Timer_Request->Deadline.Hi == Timer_Request->Deadline.Hi)
                   && (Prev_Timer_Request->Deadline.Lo > Timer_Request->Deadline.Lo))))
    {
        Prev_Timer_Request = (fiTimer_Request_t *)(Prev_Timer_Request->TimerQ_Link.blink);
    }

    fiLogDebugString(
              hpRoot,
              TimerServiceLogInfoLevel,
              "Adding Timer Request Thread = %p  Event  %x",
              (char *)agNULL,(char *)agNULL,
              Timer_Request->eventRecord_to_send.thread,(void *)agNULL,
              (os_bit32)Timer_Request->eventRecord_to_send.event,
              0,0,0,0,0,0,0
            );

    Timer_Request->Active = agTRUE;

    fiListEnqueueAtHead(
                         Timer_Request,
                         Prev_Timer_Request
                       );
}

void fiTimerStop(
                  fiTimer_Request_t *Timer_Request
                )
{
    osDebugBreakpoint(
                       (agRoot_t *)agNULL,
                       ((Timer_Request->Active == agTRUE) ? agFALSE : agTRUE),
                       "fiTimerStop(): Timer_Request->Active != agTRUE"
                     );

    fiLogDebugString(
                      (agRoot_t *)agNULL,
                      TimerServiceLogInfoLevel,
                      "Stop Timer Request Thread = %p  Event  %x",
                      (char *)agNULL,(char *)agNULL,
                      Timer_Request->eventRecord_to_send.thread,(void *)agNULL,
                      (os_bit32)Timer_Request->eventRecord_to_send.event,
                      0,0,0,0,0,0,0
                    );

    fiListDequeueThis(
                       &(Timer_Request->TimerQ_Link)
                     );

    Timer_Request->Active = agFALSE;
}

void fiTimerTick(
                  agRoot_t *hpRoot,
                  os_bit32     tickDelta
                )
{
    CThread_t         *CThread;
    fiList_t          *TimerQ;
    fiTimer_Request_t *Timer_Request;
    os_bit32              oldLo;
    os_bit32              newLo;

    CThread = CThread_ptr(hpRoot);

    /* Increment TimeBase */

    oldLo = CThread->TimeBase.Lo;
    newLo = oldLo + tickDelta;

    CThread->TimeBase.Lo = newLo;

    if (newLo < oldLo)
    {
        CThread->TimeBase.Hi += 1;
    }

    CFuncGreenLed(hpRoot, CThread->Green_LED_State);

    CThread->Green_LED_State = ! CThread->Green_LED_State;

    fiLogDebugString(
                      hpRoot,
                      TimerServiceLogConsoleLevel,
                      "fcTimerTick TimeBase.Hi = 0x%08X TimeBase.Lo = 0x%08X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      CThread->TimeBase.Hi,
                      CThread->TimeBase.Lo,
                      0,0,0,0,0,0
                    );

    /* Deliver Timer Events for Requests which are past their Deadlines */

    TimerQ        = &(CThread->TimerQ);
    Timer_Request = (fiTimer_Request_t *)(TimerQ->flink);

    while (   (Timer_Request != (fiTimer_Request_t *)TimerQ)
           && (   (Timer_Request->Deadline.Hi < CThread->TimeBase.Hi)
               || (   (Timer_Request->Deadline.Hi == CThread->TimeBase.Hi)
                   && (Timer_Request->Deadline.Lo <= CThread->TimeBase.Lo))))
    {

         fiLogDebugString(
                      hpRoot,
                      TimerServiceLogErrorLevel,
                      "Timer Popped Thread = %p  Event %d",
                      (char *)agNULL,(char *)agNULL,
                      Timer_Request->eventRecord_to_send.thread,(void *)agNULL,
                      (os_bit32)Timer_Request->eventRecord_to_send.event,
                      0,0,0,0,0,0,0
                    );


        fiListDequeueThis(
                           Timer_Request
                         );

        Timer_Request->Active = agFALSE;

        fiSendEvent(
                     Timer_Request->eventRecord_to_send.thread,
                     Timer_Request->eventRecord_to_send.event
                   );

        Timer_Request = (fiTimer_Request_t *)(TimerQ->flink);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\tgtstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/TGTSTATE.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/30/00 12:20p $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/cdbState.C

--*/

#ifndef __TgtState_H__
#define __TgtState_H__

#define  TgtStateConfused                      0
#define  TgtStateIdle                          1
#define  TgtStateIncoming                      2
#define  TgtStatePLOGI_RJT_Reply               3
#define  TgtStatePLOGI_RJT_ReplyDone           4

#define  TgtStatePLOGI_ACC_Reply               5
#define  TgtStatePLOGI_ACC_ReplyDone           6

#define  TgtStatePRLI_ACC_Reply                7
#define  TgtStatePRLI_ACC_ReplyDone            8

#define  TgtStateLOGO_ACC_Reply                9
#define  TgtStateELS_ACC_ReplyDone            10

#define  TgtStateFCP_DR_ACC_Reply             11
#define  TgtStateFCP_DR_ACC_ReplyDone         12
#define  TgtStateELSAcc                       13
#define  TgtStateADISCAcc_Reply               14
#define  TgtStateADISCAcc_ReplyDone           15

#define  TgtStateFARP_Reply                   16
#define  TgtStateFARP_ReplyDone               17

#define  TgtStatePRLOAcc_Reply                18
#define  TgtStatePRLOAcc_ReplyDone            19

#define  TgtStateMAXState                     TgtStatePRLOAcc_ReplyDone 


#define  TgtEventConfused                      0
#define  TgtEventIdle                          1
#define  TgtEventIncoming                      2
#define  TgtEventPLOGI_RJT_Reply               3
#define  TgtEventPLOGI_RJT_ReplyDone           4

#define  TgtEventPLOGI_ACC_Reply               5
#define  TgtEventPLOGI_ACC_ReplyDone           6

#define  TgtEventPRLI_ACC_Reply                7
#define  TgtEventPRLI_ACC_ReplyDone            8

#define  TgtEventLOGO_ACC_Reply                9
#define  TgtEventELS_ACC_ReplyDone             10

#define  TgtEventFCP_DR_ACC_Reply              11
#define  TgtEventFCP_DR_ACC_ReplyDone          12

#define  TgtEventELSAcc                        13

#define  TgtEventADISC_Reply                   14
#define  TgtEventADISC_ReplyDone               15

#define  TgtEventFARP_Reply                    16
#define  TgtEventFARP_ReplyDone                17
#define  TgtEventPRLO_Reply                    18
#define  TgtEventPRLO_ReplyDone                19

#define  TgtEventMAXEvent                      TgtEventPRLO_ReplyDone


STATE_PROTO(TgtActionConfused          );
STATE_PROTO(TgtActionIdle              );
STATE_PROTO(TgtActionIncoming          );

STATE_PROTO(TgtActionPLOGI_RJT_Reply       );
STATE_PROTO(TgtActionPLOGI_RJT_ReplyDone   );

STATE_PROTO(TgtActionPLOGI_ACC_Reply    );
STATE_PROTO(TgtActionPLOGI_ACC_ReplyDone);

STATE_PROTO(TgtActionPRLI_ACC_Reply     );
STATE_PROTO(TgtActionPRLI_ACC_ReplyDone );

STATE_PROTO(TgtActionLOGO_ACC_Reply    );
STATE_PROTO(TgtActionELS_ACC_ReplyDone);

STATE_PROTO(TgtActionFCP_DR_ACC_Reply     );
STATE_PROTO(TgtActionFCP_DR_ACC_ReplyDone );

STATE_PROTO(TgtActionELSAcc);
STATE_PROTO(TgtActionFCP_DR_ACC_ReplyDone);
STATE_PROTO(TgtActionFCP_DR_ACC_Reply);
STATE_PROTO(TgtActionELS_ACC_ReplyDone);
STATE_PROTO(TgtActionLOGO_ACC_Reply);
STATE_PROTO(TgtActionPRLI_ACC_ReplyDone);
STATE_PROTO(TgtActionPRLI_ACC_Reply);
STATE_PROTO(TgtActionPLOGI_ACC_ReplyDone);
STATE_PROTO(TgtActionPLOGI_ACC_Reply);
STATE_PROTO(TgtActionPLOGI_RJT_ReplyDone);
STATE_PROTO(TgtActionPLOGI_RJT_Reply);

STATE_PROTO(TgtActionADISCAcc_Reply);
STATE_PROTO(TgtActionADISCAcc_ReplyDone);

STATE_PROTO(TgtActionFARP_Reply);
STATE_PROTO(TgtActionFARP_ReplyDone);

STATE_PROTO(TgtActionPRLOAcc_Reply);
STATE_PROTO(TgtActionPRLOAcc_ReplyDone);


extern stateTransitionMatrix_t TgtStateTransitionMatrix;
extern stateActionScalar_t TgtStateActionScalar;

#ifdef USESTATEMACROS

#define TgtSTATE_FUNCTION_TERMINATE(x) extern void x(fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){\
    agRoot_t * hpRoot=thread->hpRoot;                   \
    CThread_t  * pCThread=CThread_ptr(hpRoot);          \
    CDBThread_t * pCDBThread=(CDBThread_t * )thread;    \
    DevThread_t * pDevThread=pCDBThread->Device;        \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...simply returns",            \
                      (void * )agNULL,(void * )agNULL,  \
                      (char *)agNULL,(char *)agNULL,        \
                      0,0,0,0,0,0,0,0);                 \
    eventRecord->thread = agNULL;                         \
    }\

#ifdef TestTgtStateMachine
char * TgtStateString[]=
{
    "TgtStateConfused             ",
    "TgtStateIdle                 ",
    "TgtStateIncoming             ",
    "TgtStatePLOGI_RJT_Reply      ",
    "TgtStatePLOGI_RJT_ReplyDone  ",
    "TgtStatePLOGI_ACC_Reply      ",
    "TgtStatePLOGI_ACC_ReplyDone  ",
    "TgtStatePRLI_ACC_Reply       ",
    "TgtStatePRLI_ACC_ReplyDone   ",
    "TgtStateLOGO_ACC_Reply       ",
    "TgtStateELS_ACC_ReplyDone    ",
    "TgtStateFCP_DR_ACC_Reply     ",
    "TgtStateFCP_DR_ACC_ReplyDone ",
    "TgtStateELSAcc               ",
    "TgtStateADISCAcc_Reply       ",
    "TgtStateADISCAcc_ReplyDone   ",
    agNULL
};

char * TgtEventString[]=
{

    "TgtEventConfused             ",
    "TgtEventIdle                 ",
    "TgtEventIncoming             ",
    "TgtEventPLOGI_RJT_Reply      ",
    "TgtEventPLOGI_RJT_ReplyDone  ",
    "TgtEventPLOGI_ACC_Reply      ",
    "TgtEventPLOGI_ACC_ReplyDone  ",
    "TgtEventPRLI_ACC_Reply       ",
    "TgtEventPRLI_ACC_ReplyDone   ",
    "TgtEventLOGO_ACC_Reply       ",
    "TgtEventELS_ACC_ReplyDone    ",
    "TgtEventFCP_DR_ACC_Reply     ",
    "TgtEventFCP_DR_ACC_ReplyDone ",
    "TgtEventELSAcc               ",
    "TgtEventADISC_Reply          ",
    "TgtEventADISC_ReplyDone      ",
     agNULL
};

char * TgtActionString[]=
{
    "TgtActionConfused             ",
    "TgtActionIdle                 ",
    "TgtActionIncoming             ",
    "TgtActionPLOGI_RJT_Reply      ",
    "TgtActionPLOGI_RJT_ReplyDone  ",
    "TgtActionPLOGI_ACC_Reply      ",
    "TgtActionPLOGI_ACC_ReplyDone  ",
    "TgtActionPRLI_ACC_Reply       ",
    "TgtActionPRLI_ACC_ReplyDone   ",
    "TgtActionLOGO_ACC_Reply       ",
    "TgtActionELS_ACC_ReplyDone    ",
    "TgtActionFCP_DR_ACC_Reply     ",
    "TgtActionFCP_DR_ACC_ReplyDone ",
    "TgtActionELSAcc               ",
    "TgtActionADISCAcc_Reply       ",
    "TgtActionADISCAcc_ReplyDone   ",
    agNULL
};


#endif /* TestTgtStateMachine */


#endif /* USESTATEMACROS */

#endif /*  __TgtState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\tgtstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/TGTSTATE.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/30/00 3:26p  $

Purpose:

  This file implements the FC Layer State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/timersvc.h"

#include "../h/sfstate.h"
#include "../h/tgtstate.h"
#include "../h/cstate.h"
#include "../h/devstate.h"
#include "../h/cfunc.h"
#include "../h/queue.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "timersvc.h"

#include "sfstate.h"
#include "tgtstate.h"
#include "cstate.h"
#include "devstate.h"
#include "cfunc.h"
#include "queue.h"
#endif  /* _New_Header_file_Layout_ */

stateTransitionMatrix_t TgtStateTransitionMatrix = {
    /* Event/State 0        State 1          State 2...             */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 1 TgtEventIdle                                         */
    0,            TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
      TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
        TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
          TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
            TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
              TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                  TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                    TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                      TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                        TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                          TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                            TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
    TgtStateIdle,
      TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
        TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
          TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
            TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
              TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 2 TgtEventIncoming                                    */
    0,TgtStateIncoming,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 3 TgtEventPLOGI_Reply                                 */
    0,0,TgtStatePLOGI_RJT_Reply,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 4 TgtEventPLOGI_ReplyDone                             */
    0,0,0,TgtEventPLOGI_RJT_ReplyDone,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 5 TgtEventPLOGI_ACC_Reply                                                    */
    0,0,TgtStatePLOGI_ACC_Reply,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 6 TgtEventPLOGI_ACC_ReplyDone                                                    */
    0,0,0,0,0, TgtStatePLOGI_ACC_ReplyDone,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 7 TgtEventPRLI_ACC_Reply                              */
    0,0,TgtStatePRLI_ACC_Reply,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 8 TgtEventPRLI_ACC_ReplyDone                          */
    0,0,0,0,0, 0,0,TgtStatePRLI_ACC_ReplyDone,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 9 TgtEventLOGO_ACC_Reply                              */
    0,0,TgtStateLOGO_ACC_Reply,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 10 TgtEventELS_ACC_ReplyDone                         */
    0,0,0,0,0, 0,0,0,0,TgtStateELS_ACC_ReplyDone, 0,0,0,TgtStateELS_ACC_ReplyDone,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 11 TgtEventFCP_DR_ACC_Reply                           */
    0,0,TgtStateFCP_DR_ACC_Reply,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 12 TgtEventFCP_DR_ACC_ReplyDone                       */
    0,0,0,0,0, 0,0,0,0,0, 0,TgtStateFCP_DR_ACC_ReplyDone,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 13 TgtEventELSAcc */                                                  
    0,0,TgtStateELSAcc,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 14 TgtEventADISC_Reply                                */
    0,0,TgtStateADISCAcc_Reply,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 15 TgtEventADISC_ReplyDone                            */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,TgtStateADISCAcc_ReplyDone, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 16   TgtEventFARP_Reply                               */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 17   TgtEventFARP_ReplyDone                           */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 18   TgtEventPRLO_Reply                               */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19   TgtEventPRLO_ReplyDone                           */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 20                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 23                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 24                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 25                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 26                                                   */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 27                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 28                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 29                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 30                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 31                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 32                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 34                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 35                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 40                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 42                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 48                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 50                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 57                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 58                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 59                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 60                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 61                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 70                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 72                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 80                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 90                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 95                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 110                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 120                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 125                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    };

stateTransitionMatrix_t copiedTgtStateTransitionMatrix;

stateActionScalar_t TgtStateActionScalar = {
    &TgtActionConfused,
    &TgtActionIdle,
    &TgtActionIncoming,
    &TgtActionPLOGI_RJT_Reply,
    &TgtActionPLOGI_RJT_ReplyDone,
    &TgtActionPLOGI_ACC_Reply,
    &TgtActionPLOGI_ACC_ReplyDone,
    &TgtActionPRLI_ACC_Reply,
    &TgtActionPRLI_ACC_ReplyDone,
    &TgtActionLOGO_ACC_Reply,
    &TgtActionELS_ACC_ReplyDone,
    &TgtActionFCP_DR_ACC_Reply,
    &TgtActionFCP_DR_ACC_ReplyDone,
    &TgtActionELSAcc,
    &TgtActionADISCAcc_Reply,
    &TgtActionADISCAcc_ReplyDone,
    &TgtActionFARP_Reply,
    &TgtActionFARP_ReplyDone,
    &TgtActionPRLOAcc_Reply,
    &TgtActionPRLOAcc_ReplyDone,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    };

stateActionScalar_t copiedTgtStateActionScalar;

#ifdef USESTATEMACROS

TgtSTATE_FUNCTION_TERMINATE(TgtActionConfused);

#endif /* USESTATEMACROS */

#define testTgtCompareBase 0x00000110


#ifndef USESTATEMACROS

/*+
  Function: TgtActionConfused
   Purpose: Terminating State for error detection 
 Called By: Any State/Event pair that does not have an assigned action.
            This function is called only in programming error condtions.
     Calls: None
-*/
/* TgtStateConfused 0  */
extern void TgtActionConfused( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    fiLogString(thread->hpRoot,
                    "TgtActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogErrorLevel,
                    "In %s - State = %d",
                    "TgtActionConfused",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: TgtActionIdle
   Purpose: "Free" state for target threads.Terminating State  
 Called By: All target threads complete to this state.
     Calls: TgtThreadFree
-*/
/* TgtStateIdle 1  */
extern void TgtActionIdle( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionIdle",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                   "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(thread->hpRoot)->LOOP_DOWN,
                    CThread_ptr(thread->hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(thread->hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(thread->hpRoot)->ERQ_FROZEN,
                    CThread_ptr(thread->hpRoot)->FCP_FROZEN,
                    CThread_ptr(thread->hpRoot)->ProcessingIMQ,
                    0,0);

    fiSetEventRecordNull(eventRecord);

    TgtThreadFree(thread->hpRoot, pTgtThread );

}

/*+
  Function: TgtActionIncoming
   Purpose: Parsing state for target threads. This state determines appropriate action
            for all external messages. All known ELS types have an entry, most do nothing.
 Called By: 
     Calls: TgtThreadFree
            TgtEventPLOGI_ACC_Reply
            TgtEventIdle
            CFunc_LOGO_Completion
            TgtEventLOGO_ACC_Reply
            TgtEventELSAcc
            TgtEventPRLI_ACC_Reply
            TgtEventADISC_Reply
            CEventRSCNErrorBackIOs
            TgtEventConfused
            SFThreadAlloc
-*/
/* TgtStateIncoming 2  */
extern void TgtActionIncoming( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t        * hpRoot                 = thread->hpRoot;
    CThread_t       * pCThread               = CThread_ptr(hpRoot);
    TgtThread_t     * pTgtThread             = ( TgtThread_t  * )thread;
    event_t           event_to_send          = 0;
    os_bit32          FCHS_TYPE;
    os_bit32          FC_ELS_Type;
    X_ID_t            OX_ID                  = 0;
    FC_Port_ID_t      Port_ID;
    FC_ELS_Unknown_Payload_t  * Payload      = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)&(pTgtThread->TgtCmnd_FCHS) + sizeof(FCHS_t));
    FC_ELS_FAN_Payload_t      * FAN_PayLoad  = (FC_ELS_FAN_Payload_t *)Payload;
    FC_ELS_LOGO_Payload_t     * LOGO_Payload = (FC_ELS_LOGO_Payload_t *)Payload;
    os_bit32                  * pPayload     = (os_bit32 *)Payload;
    SFThread_t                * pSFThread    = (SFThread_t *)agNULL;

    FCHS_t                 *FCHS     = &(pTgtThread->TgtCmnd_FCHS);
    os_bit32                D_ID     = (FCHS->R_CTL__D_ID & FCHS_D_ID_MASK) >> FCHS_D_ID_SHIFT;


    FCHS_TYPE = pTgtThread->TgtCmnd_FCHS.TYPE__F_CTL & FCHS_TYPE_MASK;

    if( pCThread->DeviceSelf ==(DevThread_t *) agNULL )
    {
        fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

        FC_ELS_Type = hpSwapBit32(Payload->ELS_Type);
        FC_ELS_Type &= FC_ELS_Type_MASK;

        fiLogDebugString(hpRoot,
                    TgtStateLogConsoleLevel,
                    "%s In %s - State = %d FC_ELS_Type %x Payload->ELS_Type %x",
                    "Don't Have AL_PA !!", 
                    "TgtActionIncoming",
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    FC_ELS_Type & FC_ELS_Type_MASK,
                    hpSwapBit32(Payload->ELS_Type),
                    0,0,0,0,0);
        if( FC_ELS_Type == FC_ELS_Type_PLOGI)
        {
            
            fiLogDebugString(hpRoot,
                        TgtStateLogConsoleLevel,
                        "In %s - State = %d FC_ELS_Type %x (%s)%x OX_ID__RX_ID %08X DID %x",
                        "TgtActionIncoming",
                        "FC_ELS_Type_PLOGI",
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        FC_ELS_Type,
                        Payload->ELS_Type,
                        FCHS->OX_ID__RX_ID,
                        D_ID,
                        0,0,0);
            if(D_ID  != 0 && D_ID != 0xff)
            {

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, D_ID);

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                        (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                        ( D_ID <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ));

                Port_ID.Struct_Form.reserved = 0;
                Port_ID.Struct_Form.Domain = 0;
                Port_ID.Struct_Form.Area   = 0;
                Port_ID.Struct_Form.AL_PA  = (os_bit8)D_ID;

                pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );

                pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                            Port_ID.Struct_Form.Domain,
                                                            Port_ID.Struct_Form.Area,
                                                            Port_ID.Struct_Form.AL_PA,
                                                           (FC_Port_Name_t *)(&pCThread->ChanInfo.PortWWN));

                fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
                fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

                pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)D_ID;
            }
            else
            {
                return;
            }
        
        }
        else
        {
            return;
        }
    }

    if (FCHS_TYPE == FC_Frame_Header_TYPE_ELS)
    {
        /* Process incoming ELS */

        FC_ELS_Type = hpSwapBit32(Payload->ELS_Type);
        FC_ELS_Type &= FC_ELS_Type_MASK;


        switch(FC_ELS_Type)
        {
            case FC_ELS_Type_PLOGI:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x OX_ID__RX_ID %08X",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_PLOGI",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                FCHS->OX_ID__RX_ID,
                                                0,0,0,0);

                                       event_to_send = TgtEventPLOGI_ACC_Reply;  break;
            case FC_ELS_Type_LS_RJT:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_LS_RJT",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_ACC:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ACC",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                        fiLogDebugString( hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                                                "FC_ELS_Type_ACC",
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                hpSwapBit32( *(pPayload+0)),
                                                hpSwapBit32( *(pPayload+1)),
                                                hpSwapBit32( *(pPayload+2)),
                                                hpSwapBit32( *(pPayload+3)),
                                                hpSwapBit32( *(pPayload+4)),
                                                hpSwapBit32( *(pPayload+5)),
                                                hpSwapBit32( *(pPayload+6)),
                                                hpSwapBit32( *(pPayload+7)));
                                        fiLogDebugString( hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "    FCHS 0 %08X 1 %08X 2 %08X 3 %08X",
                                                (char *)agNULL,
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                FCHS->MBZ1,
                                                FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                                                FCHS->R_CTL__D_ID,
                                                FCHS->CS_CTL__S_ID,
                                                0,0,0,0 );

                                        fiLogDebugString( hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "    FCHS 4 %08X 5 %08X 6 %08X 7 %08X",
                                                (char *)agNULL,
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                FCHS->TYPE__F_CTL,
                                                FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                                                FCHS->OX_ID__RX_ID,
                                                FCHS->RO,
                                                0,0,0,0 );


                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_FLOGI:
                                        fiLogString( hpRoot,
                                                    "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                    "TgtActionIncoming",
                                                    "FC_ELS_Type_FLOGI",
                                                    (void *)agNULL,(void *)agNULL,
                                                    (os_bit32)thread->currentState,
                                                    FC_ELS_Type,
                                                    Payload->ELS_Type,
                                                    0,0,0,0,0);

                                        pSFThread = pCThread->SFThread_Request.SFThread;
                                        if(pSFThread != agNULL )
                                        {
                                            fiLogString( hpRoot,
                                                        "SF %p State %d",
                                                        (char *)agNULL,(char *)agNULL,
                                                        pSFThread,(void *)agNULL,
                                                        pSFThread->thread_hdr.currentState,
                                                        0,0,0,0,0,0,0);
                                            pCThread->FlogiRcvdFromTarget = agTRUE;
                                            if(pSFThread->thread_hdr.currentState == SFStateDoFlogi)
                                            {
                                                fiTimerStop(&pSFThread->Timer_Request );
                                                fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiTimedOut);
                                            }
                                        }
                                        else
                                        {
                                            fiLogString( hpRoot,
                                                        "%s From Other !",
                                                        "FC_ELS_Type_FLOGI",(char *)agNULL,
                                                        (void *)agNULL,(void *)agNULL,
                                                        0,0,0,0,0,0,0,0);

                                        }
                                        event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_LOGO:
                                        OX_ID = (X_ID_t)(( FCHS->OX_ID__RX_ID & FC_Frame_Header_OX_ID_MASK ) >> FC_Frame_Header_OX_ID_SHIFT );
                                        OX_ID &= 0x7fff;
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d %s ELS %x %08X OX_ID %3X",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_LOGO",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                LOGO_Payload->ELS_Type,
                                                LOGO_Payload->N_Port_Identifier,
                                                OX_ID,
                                                0,0,0,0);
                                                
                                        fiLogDebugString(
                                                hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "    FCHS 0 %08X 1 %08X 2 %08X 3 %08X",
                                                (char *)agNULL,
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                FCHS->MBZ1,
                                                FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                                                FCHS->R_CTL__D_ID,
                                                FCHS->CS_CTL__S_ID,
                                                0,0,0,0 );

                                        fiLogDebugString(
                                                hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "    FCHS 4 %08X 5 %08X 6 %08X 7 %08X",
                                                (char *)agNULL,
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                FCHS->TYPE__F_CTL,
                                                FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                                                FCHS->OX_ID__RX_ID,
                                                FCHS->RO,
                                                0,0,0,0 );

                                       CFunc_LOGO_Completion( hpRoot,  OX_ID);
                                       event_to_send = TgtEventLOGO_ACC_Reply; break;
            case FC_ELS_Type_ABTX:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ABTX",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RCS:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RCS",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RES:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RES",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RSS:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RSS",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RSI:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RSI",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_ESTS:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ESTS",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_ESTC:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ESTC",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_ADVC:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ADVC",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RTV:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RTV",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RLS:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RLS",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_ECHO:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ECHO",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventELSAcc; break;
            case FC_ELS_Type_TEST:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_TEST",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RRQ:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RRQ",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_PRLI:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_PRLI",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventPRLI_ACC_Reply;   break;
            case FC_ELS_Type_PRLO:

                                        fiLogString(hpRoot,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_PRLO",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);

                                        fiLogString(hpRoot,
                                                "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                                                "FC_ELS_Type_ACC",
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                hpSwapBit32( *(pPayload+0)),
                                                hpSwapBit32( *(pPayload+1)),
                                                hpSwapBit32( *(pPayload+2)),
                                                hpSwapBit32( *(pPayload+3)),
                                                hpSwapBit32( *(pPayload+4)),
                                                hpSwapBit32( *(pPayload+5)),
                                                hpSwapBit32( *(pPayload+6)),
                                                hpSwapBit32( *(pPayload+7)));
                                        fiLogString(hpRoot,
                                                "    FCHS 0 %08X 1 %08X 2 %08X 3 %08X",
                                                (char *)agNULL,
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                FCHS->MBZ1,
                                                FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                                                FCHS->R_CTL__D_ID,
                                                FCHS->CS_CTL__S_ID,
                                                0,0,0,0 );

                                        fiLogString(hpRoot,
                                                "    FCHS 4 %08X 5 %08X 6 %08X 7 %08X",
                                                (char *)agNULL,
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                FCHS->TYPE__F_CTL,
                                                FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                                                FCHS->OX_ID__RX_ID,
                                                FCHS->RO,
                                                0,0,0,0 );


                                       event_to_send = TgtEventPLOGI_RJT_Reply; break;
            case FC_ELS_Type_SCN:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_SCN",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RSCN:
                                     
	                                    fiLogDebugString(hpRoot,
	                                            TgtStateLogConsoleLevel,
	                                            "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
	                                            "TgtActionIncoming",
	                                            "FC_ELS_Type_RSCN",
                                                (void *)agNULL,(void *)agNULL,
	                                            (os_bit32)thread->currentState,
	                                            FC_ELS_Type,
	                                            Payload->ELS_Type,
	                                            0,0,0,0,0);
                                        if( ( (hpSwapBit32(*(pPayload+1)) ) & 0xffff ) == 8 )
                                        fiLogDebugString(
                                                hpRoot,
                                                CTLogConsoleLevelInfo,
                                                "%s %08X %08X",
                                                "RSCN",
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                hpSwapBit32( *(pPayload+0)),
                                                hpSwapBit32( *(pPayload+1)),
                                                0,0,0,0,0,0);
                                        else
                                        fiLogDebugString(
                                                hpRoot,
                                                CTLogConsoleLevelInfo,
                                                "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                                                "RSCN",
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                hpSwapBit32( *(pPayload+0)),
                                                hpSwapBit32( *(pPayload+1)),
                                                hpSwapBit32( *(pPayload+2)),
                                                hpSwapBit32( *(pPayload+3)),
                                                hpSwapBit32( *(pPayload+4)),
                                                hpSwapBit32( *(pPayload+5)),
                                                hpSwapBit32( *(pPayload+6)),
                                                hpSwapBit32( *(pPayload+7)));
 

                                        /* If we are in CStateNormal, error back IOs by sending
                                         * CEventRSCNErrorBackIos to Cthread. 
                                         * For now, we will not look at the payload and just rediscover
                                         * everything by quering the name server again.
                                         */
                                        if((pCThread->thread_hdr.currentState == CStateNormal ) &&
                                          (pCThread->thread_hdr.subState != CSubStateResettingDevices))
                                        {
                                            fiSendEvent(&pCThread->thread_hdr,CEventRSCNErrorBackIOs);
                                        }

	                                   event_to_send = TgtEventELSAcc; 
                                    break;
            case FC_ELS_Type_TPLS:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_TPLS",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_TPRLO:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_TPRLO",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_GAID:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_GAID",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_FACT:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_FACT",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_FDACT:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_FDACT",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_NACT:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_NACT",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_NDACT:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_NDACT",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_QoSR:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_QoSR",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RVCS:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RVCS",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_PDISC:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_PDISC",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_FDISC:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_FDISC",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;

            case FC_ELS_Type_ADISC:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ADISC",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                        fiLogDebugString( hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                                                "FC_ELS_Type_ADISC",
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                hpSwapBit32( *(pPayload+0)),
                                                hpSwapBit32( *(pPayload+1)),
                                                hpSwapBit32( *(pPayload+2)),
                                                hpSwapBit32( *(pPayload+3)),
                                                hpSwapBit32( *(pPayload+4)),
                                                hpSwapBit32( *(pPayload+5)),
                                                hpSwapBit32( *(pPayload+6)),
                                                hpSwapBit32( *(pPayload+7)));

                                       event_to_send = TgtEventADISC_Reply; break;

            case FC_ELS_Type_FAN:
                                       fiLogDebugString(hpRoot,
	                                            TgtStateLogConsoleLevel,
	                                            "In %s - State = %d (%s) ELS_Type %x",
	                                            "TgtActionIncoming",
	                                            "FC_ELS_Type_FAN",
                                                (void *)agNULL,(void *)agNULL,
	                                            (os_bit32)thread->currentState,
	                                            Payload->ELS_Type,
	                                            0,0,0,0,0,0);
                                       fiLogDebugString(thread->hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "Domain %02X Area %02X ALPA %02X Found CCnt %x",
                                                (char *)agNULL,(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                pCThread->ChanInfo.CurrentAddress.Domain,
                                                pCThread->ChanInfo.CurrentAddress.Area,
                                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                                pCThread->CDBpollingCount,
                                                0,0,0,0);

	                                     fiLogDebugString(hpRoot,
	                                            TgtStateLogConsoleLevel,
	                                            "Type %X FabricLoopAddress %8X",
	                                            agNULL,
	                                            agNULL,
                                                (void *)agNULL,(void *)agNULL,
	                                            FAN_PayLoad->ELS_Type,
                                                FAN_PayLoad->FabricLoopAddress,
	                                            0,0,0,0,0,0);

	                                    event_to_send = TgtEventIdle; 
                                        
                                        if((pCThread->thread_hdr.currentState == CStateNormal ) &&
                                          (pCThread->thread_hdr.subState != CSubStateResettingDevices))
                                        {
                                            fiSendEvent(&pCThread->thread_hdr,CEventRSCNErrorBackIOs);
                                        }


                                    break;


           default:
                                   fiLogString(hpRoot,
                                                "%s Payload->ELS_Type %08X !!!",
                                                "TgtEventConfused",(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                (hpSwapBit32(Payload->ELS_Type) & FC_ELS_Type_MASK),
                                                0,0,0,0,0,0,0);

                                        event_to_send = TgtEventConfused;
        }


        if( event_to_send == TgtEventIdle )
        {
            fiLogString(hpRoot,
                        "%s ELS_Type %08X ETS %d",
                        "TgtActionIncoming",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (hpSwapBit32(Payload->ELS_Type) & FC_ELS_Type_MASK),
                        event_to_send,
                        0,0,0,0,0,0);
            fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

        }
        else
        {
            pTgtThread->SFThread_Request.eventRecord_to_send.event = event_to_send;
            pTgtThread->SFThread_Request.eventRecord_to_send.thread = thread;

            fiSetEventRecordNull(eventRecord);

            SFThreadAlloc(thread->hpRoot, & pTgtThread->SFThread_Request );
        }
    }
    else if (FCHS_TYPE == FC_Frame_Header_TYPE_SCSI_FCP)
    {
        /* Process incoming FCP_SCSI */

        if( *((os_bit32 *)Payload + 0) == 0            &&
            *((os_bit32 *)Payload + 1) == 0            &&
            *((os_bit32 *)Payload + 2) == 0x00200000   &&
            *((os_bit32 *)Payload + 3) == 0            &&
            *((os_bit32 *)Payload + 4) == 0            &&
            *((os_bit32 *)Payload + 5) == 0            &&
            *((os_bit32 *)Payload + 6) == 0            &&
            *((os_bit32 *)Payload + 7) == 0                )
        {
            /* Process incoming Target Reset */

            fiLogString(hpRoot,
                             "Device Reset from someone  !!!!",
                             (char *)agNULL,(char *)agNULL,
                             (void *)agNULL,(void *)agNULL,
                             0,0,0,0,0,0,0,0);

            CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
            pCThread->LinkDownTime = pCThread->TimeBase;
/**/
            pTgtThread->SFThread_Request.eventRecord_to_send.event = TgtEventFCP_DR_ACC_Reply;
            pTgtThread->SFThread_Request.eventRecord_to_send.thread = thread;

            fiSetEventRecordNull(eventRecord);
            SFThreadAlloc(thread->hpRoot, & pTgtThread->SFThread_Request );
        }
        else
        {
            fiLogDebugString(hpRoot,
                             CFuncLogConsoleERROR,
                             "Unsupported FCP ",
                             (char *)agNULL,(char *)agNULL,
                             (void *)agNULL,(void *)agNULL,
                             0,0,0,0,0,0,0,0);

            fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);
        }
    }
    else
    {
        /* Discard */

        fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);
    }
}

/*+
  Function: TgtActionPLOGI_RJT_Reply
   Purpose: Does PLOGI reject reply
 Called By: 
     Calls: SFEventDoLS_RJT
-*/
/* TgtStatePLOGI_RJT_Reply 3 */
extern void TgtActionPLOGI_RJT_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    /*+ Check This DRL Do we need this ? -*/
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPLOGI_RJT_Reply",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    /* Send SF event LS Rej */
    fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoLS_RJT);

}

/*+
  Function: TgtActionPLOGI_RJT_ReplyDone
   Purpose: Completeion state for  PLOGI reject reply
 Called By: 
     Calls: SFThreadFree
            TgtEventIdle
-*/
/*TgtStatePLOGI_RJT_ReplyDone 4 */
extern void TgtActionPLOGI_RJT_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    /*+ Check This DRL Do we need this ? -*/
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPLOGI_RJT_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

}

/*+
  Function: TgtActionPLOGI_ACC_Reply
   Purpose: Sends  PLOGI accept
 Called By: 
     Calls: CFuncMatchALPAtoThread
            SFEventDoPlogiAccept
            fiTimerStart
-*/
/* TgtStatePLOGI_ACC_Reply 5 */
extern void TgtActionPLOGI_ACC_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t   * pTgtThread = ( TgtThread_t  * )thread;
    FC_Port_ID_t    FCHS_SID;
    DevThread_t   * pDevThread=agNULL;

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    FCHS_SID.Bit32_Form = pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FC_Frame_Header_S_ID_MASK;

    pDevThread = CFuncMatchALPAtoThread(thread->hpRoot, FCHS_SID );

    fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "In %s SFThread (%p) DevThread (%p)",
                    "TgtActionPLOGI_ACC_Reply",(char *)agNULL,
                    pTgtThread->SFThread_Request.SFThread,pDevThread,
                    0,0,0,0,0,0,0,0);

    if (pDevThread)
    {

        fiLogDebugString(thread->hpRoot,
                        CFuncLogConsoleERROR,
                        "In %s - State = %d ALPA %X TGT SFThread (%p) Req State %x SF State %d",
                        "TgtActionPLOGI_ACC_Reply",(char *)agNULL,
                        pTgtThread->SFThread_Request.SFThread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pDevThread->DevInfo.CurrentAddress.AL_PA,
                        (os_bit32)pTgtThread->SFThread_Request.State,
                        (os_bit32)pTgtThread->SFThread_Request.SFThread->thread_hdr.currentState,
                        0,0,0,0);

        if( pDevThread->SFThread_Request.SFThread)
        {
            fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "   %s Device  SFThread (%p) Req State %x SF State %d",
                            "TgtActionPLOGI_ACC_Reply",(char *)agNULL,
                            pDevThread->SFThread_Request.SFThread,(void *)agNULL,
                            (os_bit32)pDevThread->SFThread_Request.State,
                            (os_bit32)pDevThread->SFThread_Request.SFThread->thread_hdr.currentState,
                            0,0,0,0,0,0);
        }

        if( pDevThread->SFThread_Request.State == SFThread_Request_Granted )
        {

            fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "%s Setting timer ",
                            "TgtActionPLOGI_ACC_Reply",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);

            fiSetEventRecordNull(eventRecord);
            fiTimerSetDeadlineFromNow( thread->hpRoot, &pTgtThread->Timer_Request, 100 );
            pTgtThread->Timer_Request.eventRecord_to_send.thread = ((fi_thread__t *)pTgtThread->SFThread_Request.SFThread);
            pTgtThread->Timer_Request.eventRecord_to_send.event = SFEventDoPlogiAccept;
            fiTimerStart( thread->hpRoot,&pTgtThread->Timer_Request );
        }
        else
        {
            fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoPlogiAccept);
        }
    }
    else
    {
        if( pTgtThread->SFThread_Request.SFThread)
        {
            fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "%s %s SFThread (%p) Req State %x SF State %d",
                            "TgtActionPLOGI_ACC_Reply","No Device",
                            pTgtThread->SFThread_Request.SFThread,(void *)agNULL,
                            (os_bit32)pTgtThread->SFThread_Request.State,
                            (os_bit32)pTgtThread->SFThread_Request.SFThread->thread_hdr.currentState,
                            0,0,0,0,0,0);
        }
        fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoPlogiAccept);
    }
}

/*+
  Function: TgtActionPLOGI_ACC_ReplyDone
   Purpose: Frees resources after  PLOGI accept completes
 Called By: 
     Calls: SFThreadFree
            TgtEventIdle
-*/
/*TgtStatePLOGI_ACC_ReplyDone 6 */
extern void TgtActionPLOGI_ACC_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPLOGI_ACC_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if(pSFThread != (SFThread_t * )agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

}

/*+
  Function: TgtActionPRLI_ACC_Reply
   Purpose: Sends  PRLI accept
 Called By: 
     Calls: CFuncMatchALPAtoThread
            SFEventDoPrliAccept
            fiTimerStart
-*/
/* TgtStatePRLI_ACC_Reply 7 */
extern void TgtActionPRLI_ACC_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPRLI_ACC_Reply",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    /*  */
    fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoPrliAccept);

}

/*+
  Function: TgtActionPRLI_ACC_ReplyDone
   Purpose: Frees resources after  PRLI accept completes
 Called By: 
     Calls: SFThreadFree
            TgtEventIdle
-*/
/* TgtStatePRLI_ACC_ReplyDone 8 */
extern void TgtActionPRLI_ACC_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPRLI_ACC_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(thread->hpRoot)->LOOP_DOWN,
                    CThread_ptr(thread->hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(thread->hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(thread->hpRoot)->ERQ_FROZEN,
                    CThread_ptr(thread->hpRoot)->FCP_FROZEN,
                    CThread_ptr(thread->hpRoot)->ProcessingIMQ,
                    0,0);

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);
}

/*+
  Function: TgtActionLOGO_ACC_Reply
   Purpose: Sends  LOGO accept
 Called By: 
     Calls: CFuncMatchALPAtoThread
            SFEventDoPrliAccept
            fiTimerStart
-*/
/* TgtStateLOGO_ACC_Reply 9 */
extern void TgtActionLOGO_ACC_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t   * pTgtThread = ( TgtThread_t  * )thread;
    FC_Port_ID_t    FCHS_SID;
    DevThread_t   * pDevThread=agNULL;

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    FCHS_SID.Bit32_Form = pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FC_Frame_Header_S_ID_MASK;

    pDevThread = CFuncMatchALPAtoThread(thread->hpRoot, FCHS_SID );

    /* If we recieve a LOGO from a device that we do not know of, send an 
     * ACC for now and get done with it. Maybe we should really send a 
     * LS_RJT, but since we send an ACC for a PLOGI from any device, we 
     * got to be consistant. */
    if (pDevThread)
    {

        fiLogDebugString(thread->hpRoot,
                        CFuncLogConsoleERROR,
                        "In %s - State = %d ALPA %X TGT SFThread (%p) Req State %x SF State %d",
                        "TgtActionLOGO_ACC_Reply",(char *)agNULL,
                        pTgtThread->SFThread_Request.SFThread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pDevThread->DevInfo.CurrentAddress.AL_PA,
                        (os_bit32)pTgtThread->SFThread_Request.State,
                        (os_bit32)pTgtThread->SFThread_Request.SFThread->thread_hdr.currentState,
                        0,0,0,0);

/*
        if( pDevThread->SFThread_Request.SFThread)
        {
            fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "Device    SFThread (%p) Req State %x SF State %d",
                            (void *)agNULL,(void *)agNULL,
                            pDevThread->SFThread_Request.SFThread,(char *)agNULL,
                            (os_bit32)pDevThread->SFThread_Request.State,
                            (os_bit32)pDevThread->SFThread_Request.SFThread->thread_hdr.currentState,
                            0,0,0,0,0,0);
        }
*/
        pDevThread->DevInfo.LoggedIn   = agFALSE;
/**/
        if( CThread_ptr(thread->hpRoot)->thread_hdr.currentState == CStateNormal ||
            CThread_ptr(thread->hpRoot)->thread_hdr.currentState == CStateFindDevice )
        {
            
/*  DRL           fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
*/
            fiSendEvent(&CThread_ptr(thread->hpRoot)->thread_hdr,CEventExternalLogout);

        }
    }
    /*
    fiSendEvent(&CThread_ptr(thread->hpRoot)->thread_hdr,CEventAsyncLoopEventDetected);
  */
    fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoELSAccept);

}

/*TgtStateELS_ACC_ReplyDone 10 */
extern void TgtActionELS_ACC_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionELS_ACC_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "Loop_Reset_Event_to_Send %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(thread->hpRoot)->Loop_Reset_Event_to_Send,
                    0,0,0,0,0,0,0);

#ifdef NeedToReset
    fiSendEvent(&(CThread_ptr(thread->hpRoot)->thread_hdr),(event_t) CThread_ptr(thread->hpRoot)->Loop_Reset_Event_to_Send);
#endif /* NeedToReset */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

}

/*+
  Function: TgtActionFCP_DR_ACC_Reply
   Purpose: Sends accept Reply to Task manangement reset.
 Called By: 
     Calls: CFuncMatchALPAtoThread
            SFEventDoFCP_DR_ACC_Reply
-*/
/* TgtStateFCP_DR_ACC_Reply  11 */
extern void TgtActionFCP_DR_ACC_Reply ( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t   * pTgtThread = ( TgtThread_t  * )thread;
    FC_Port_ID_t    FCHS_SID;
    DevThread_t   * pDevThread=agNULL;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionFCP_DR_ACC_Reply",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    FCHS_SID.Bit32_Form = pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FC_Frame_Header_S_ID_MASK;

    pDevThread = CFuncMatchALPAtoThread(thread->hpRoot, FCHS_SID );


    /*  */
    fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoFCP_DR_ACC_Reply);

}

/*+
  Function: TgtActionFCP_DR_ACC_ReplyDone
   Purpose: Frees resources for reply to task manangement reset.
     Calls: SFThreadFree
            TgtEventIdle
-*/
/*TgtStateFCP_DR_ACC_ReplyDone 12 */
extern void TgtActionFCP_DR_ACC_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionFCP_DR_ACC_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

}


/* TgtStateELSAcc 13 */
extern void TgtActionELSAcc( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionELSAcc",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    /* Send SF event LS Rej */
    fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoELSAccept);

}

/*+
  Function: TgtActionFCP_DR_ACC_ReplyDone
   Purpose: Does reply to ADISC.
     Calls: SFEventDoADISCAccept
-*/
/* TgtStateADISCAcc_Reply                14  */
extern void TgtActionADISCAcc_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionADISC_Reply",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    /*  */
    fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoADISCAccept);

}

/*+
  Function: TgtActionFCP_DR_ACC_ReplyDone
   Purpose: Frees resources for reply to ADISC.
     Calls: SFThreadFree
            TgtEventIdle
-*/
/* TgtStateADISCAcc_ReplyDone            15 */
extern void TgtActionADISCAcc_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionADISC_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if(pSFThread != (SFThread_t * )agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

}

/*+
  Function: TgtActionFARP_Reply
   Purpose: Does reply to .
     Calls: 
-*/
/* TgtStateFARP_Reply 16  */
extern void TgtActionFARP_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    fiLogString(thread->hpRoot,
                    "TgtActionFARP_Reply",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogErrorLevel,
                    "In %s - State = %d",
                    "TgtActionFARP_Reply",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: TgtActionFARP_ReplyDone
   Purpose: Does reply to .
     Calls: 
-*/
/* TgtEventFARP_ReplyDone                17 */
extern void TgtActionFARP_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    fiLogString(thread->hpRoot,
                    "TgtActionFARP_ReplyDone",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogErrorLevel,
                    "In %s - State = %d",
                    "TgtActionFARP_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}
/*+
  Function: TgtActionPRLOAcc_Reply
   Purpose: Does reply to PRLO.
     Calls: SFEventDoAccept
-*/
/* TgtStatePRLOAcc_Reply                18                  */
extern void TgtActionPRLOAcc_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPRLOAcc_Reply",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    pSFThread->parent.Target = pTgtThread;

    /*  */
    fiSetEventRecord(eventRecord,&(pSFThread->thread_hdr),SFEventReset);

}

/*+
  Function: TgtActionPRLOAcc_ReplyDone
   Purpose: Frees resources for reply to ADISC.
     Calls: SFThreadFree
            TgtEventIdle
-*/
/* TgtStatePRLOAcc_ReplyDone            19 */
extern void TgtActionPRLOAcc_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPRLOAcc_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if(pSFThread != (SFThread_t * )agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

}

/* void tgtstate(void){}  */

#endif /* USESTATEMACROS  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\tlstruct.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/TLStruct.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 9/11/00 6:18p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures specific to TachyonTL/TS

Reference Documents:

  Tachyon TL/TS User's Manual - Revision 6.0 - September 1998
  Tachyon XL User Manual - Revision 4.0 - September 1998

--*/

#ifndef __TLStruct_H__
#define __TLStruct_H__


/* _TACHYON_XL is defined to enable XL2 specific features/changes */
 
#define	__TACHYON_XL
#define	__TACHYON_XL2


/*+
PCI Configuration Space Registers
-*/

typedef struct ChipConfig_s
               ChipConfig_t;

#define ChipConfig_t_SIZE                                  0x00000100

struct ChipConfig_s {
                      os_bit32 DEVID_VENDID;
                      os_bit32 CFGSTAT_CFGCMD;
                      os_bit32 CLSCODE_REVID;
                      os_bit32 BIST_HDRTYPE_LATTIM_CLSIZE;
                      os_bit8  Reserved_1[0x13-0x10+1];
                      os_bit32 IOBASEL;
                      os_bit32 IOBASEU;
                      os_bit32 MEMBASE;
                      os_bit32 RAMBASE;
                      os_bit32 SROMBASE;
                      os_bit8  Reserved_2[0x2B-0x28+1];
                      os_bit32 SVID;
                      os_bit32 ROMBASE;
                      os_bit32 Reserved_3__CAP_PTR;
                      os_bit8  Reserved_4[0x3B-0x38+1];
                      os_bit32 MAXLAT_MINGNT_INTPIN_INTLINE;
                      os_bit32 PCIMCTR__ROMCTR__Reserved_5__Reserved_6;
                      os_bit32 INTSTAT_INTEN_INTPEND_SOFTRST;
                      os_bit8  Reserved_7[0x4F-0x48+1];
                      os_bit32 PMC__CAP_NEXT_PTR__CAP_ID;
                      os_bit32 Reserved_8__PMCSR;
                      os_bit8  Reserved_9[0xFF-0x58+1];
                    };

#define ChipConfig_DEVID_VENDID                            hpFieldOffset(ChipConfig_t,DEVID_VENDID)

#define ChipConfig_DEVID_MASK                              0xFFFF0000
#define ChipConfig_DEVID_TachyonTL                         0x10280000
#define ChipConfig_DEVID_TachyonTL33                       ChipConfig_DEVID_TachyonTL
#define ChipConfig_DEVID_TachyonTS                         0x102A0000
#define ChipConfig_DEVID_TachyonTL66                       ChipConfig_DEVID_TachyonTS
#define ChipConfig_DEVID_TachyonXL                         0x10290000
#define ChipConfig_DEVID_TachyonT2                         ChipConfig_DEVID_TachyonXL
#define ChipConfig_DEVID_TachyonXL2                        0x10290000

#define ChipConfig_VENDID_MASK                             0x0000FFFF
#define ChipConfig_VENDID_Agilent_Technologies             0x000015BC
#define ChipConfig_VENDID_Hewlett_Packard                  0x0000103C

#define ChipConfig_CFGSTAT_CFGCMD                          hpFieldOffset(ChipConfig_t,CFGSTAT_CFGCMD)

#define ChipConfig_CFGSTAT_MASK                            0xFFFF0000
#define ChipConfig_CFGSTAT_PER                             0x80000000
#define ChipConfig_CFGSTAT_SSE                             0x40000000
#define ChipConfig_CFGSTAT_RMA                             0x20000000
#define ChipConfig_CFGSTAT_RTA                             0x10000000
#define ChipConfig_CFGSTAT_STA                             0x08000000
#define ChipConfig_CFGSTAT_DST_MASK                        0x06000000
#define ChipConfig_CFGSTAT_DST_VALUE                       0x02000000
#define ChipConfig_CFGSTAT_DPE                             0x01000000
#define ChipConfig_CFGSTAT_FBB                             0x00800000
#define ChipConfig_CFGSTAT_UDF                             0x00400000
#define ChipConfig_CFGSTAT_66M                             0x00200000
#define ChipConfig_CFGSTAT_CPL                             0x00100000

#define ChipConfig_CFGCMD_MASK                             0x0000FFFF
#define ChipConfig_CFGCMD_FBB                              0x00000200
#define ChipConfig_CFGCMD_SEE                              0x00000100
#define ChipConfig_CFGCMD_WCC                              0x00000080
#define ChipConfig_CFGCMD_PER                              0x00000040
#define ChipConfig_CFGCMD_VGA                              0x00000020
#define ChipConfig_CFGCMD_MWI                              0x00000010
#define ChipConfig_CFGCMD_SPC                              0x00000008
#define ChipConfig_CFGCMD_MST                              0x00000004
#define ChipConfig_CFGCMD_MEM                              0x00000002
#define ChipConfig_CFGCMD_IOA                              0x00000001

#define ChipConfig_CLSCODE_REVID                           hpFieldOffset(ChipConfig_t,CLSCODE_REVID)

#define ChipConfig_CLSCODE_MASK                            0xFFFFFF00
#define ChipConfig_CLSCODE_VALUE                           0x0C040000

#define ChipConfig_REVID_MASK                              0x000000FF
#define ChipConfig_REVID_Major_MASK                        0x0000001C
#define ChipConfig_REVID_Major_MASK_Shift                  2
#define ChipConfig_REVID_Minor_MASK                        0x00000003
#define ChipConfig_REVID_Major_Minor_MASK                  (ChipConfig_REVID_Major_MASK | ChipConfig_REVID_Minor_MASK)
#define ChipConfig_REVID_1_0                               0x00000004
#define ChipConfig_REVID_2_0                               0x00000008
#define ChipConfig_REVID_2_2                               0x0000000A

#define ChipConfig_BIST_HDRTYPE_LATTIM_CLSIZE              hpFieldOffset(ChipConfig_t,BIST_HDRTYPE_LATTIM_CLSIZE)

#define ChipConfig_BIST_MASK                               0xFF000000
#define ChipConfig_BIST_Not_Supported                      0x00000000

#define ChipConfig_HDRTYPE_MASK                            0x00FF0000
#define ChipConfig_HDRTYPE_Single_Function                 0x00000000

#define ChipConfig_LATTIM_MASK                             0x0000FF00

#define ChipConfig_CLSIZE_MASK                             0x000000FF
#define ChipConfig_CLSIZE_32_Byte                          0x00000008

#define ChipConfig_IOBASEL                                 hpFieldOffset(ChipConfig_t,IOBASEL)

#define ChipConfig_IOBASEL_IO_Space                        0x00000001

#define ChipConfig_IOBASEU                                 hpFieldOffset(ChipConfig_t,IOBASEU)

#define ChipConfig_IOBASEU_IO_Space                        0x00000001

#define ChipConfig_MEMBASE                                 hpFieldOffset(ChipConfig_t,MEMBASE)

#define ChipConfig_RAMBASE                                 hpFieldOffset(ChipConfig_t,RAMBASE)

#define ChipConfig_SROMBASE                                hpFieldOffset(ChipConfig_t,SROMBASE)

#define ChipConfig_SVID                                    hpFieldOffset(ChipConfig_t,SVID)

/*
 * HSIO has been allocated the following:
 *
 *   For TachyonTL,  SubsystemIDs 0x0001-0x000A
 *   For TachyonTS,  SubsystemIDs 0x0001-0x000A
 *   For TachyonXL2, SubsystemIDs 0x0001-0x000F
 */

#define ChipConfig_SubsystemID_MASK                        0xFFFF0000
#define ChipConfig_SubsystemID_HHBA5100A_or_HHBA5101A      0x00010000 /* HP (DB-9 or GBIC) HBA utilizing TachyonTL    */
#define ChipConfig_SubsystemID_HHBA5100A                   0x00020000 /* HP DB-9 HBA utilizing TachyonTL              */
#define ChipConfig_SubsystemID_HHBA5101A                   0x00030000 /* HP GBIC HBA utilizing TachyonTL              */
#define ChipConfig_SubsystemID_HHBA5101B                   0x00040000 /* HP GBIC HBA utilizing TachyonTL              */
#define ChipConfig_SubsystemID_HHBA5123                    0x00050000 /* HP Dual-GBIC HBA utilizing 2 TachyonTLs      */
#define ChipConfig_SubsystemID_HHBA5101B_BCC               0x00060000 /* HP GBIC HBA utilizing TachyonTL for BCC      */
#define ChipConfig_SubsystemID_HHBA5101C                   0x00070000 /* Agilent GBIC HBA utilizing TachyonTL         */
#define ChipConfig_SubsystemID_HHBA5121A                   0x00010000 /* HP GBIC HBA utilizing TachyonTS              */
#define ChipConfig_SubsystemID_HHBA5121B                   0x00020000 /* Agilent GBIC HBA utilizing TachyonTS         */
#define ChipConfig_SubsystemID_HHBA5220A                   0x00010000 /* Agilent Copper  2Gb HBA utilizing TachyonXL2 */
#define ChipConfig_SubsystemID_HHBA5221A                   0x00020000 /* Agilent Optical 2Gb HBA utilizing TachyonXL2 */

#define ChipConfig_SubsystemVendorID_MASK                  0x0000FFFF
#define ChipConfig_SubsystemVendorID_Agilent_Technologies  ChipConfig_VENDID_Agilent_Technologies
#define ChipConfig_SubsystemVendorID_Hewlett_Packard       ChipConfig_VENDID_Hewlett_Packard


#define ChipConfig_SubsystemVendorID_Adaptec               0x00009004
#define ChipConfig_SubsystemID_Adaptec                     0x91100000

#define ChipConfig_ROMBASE                                 hpFieldOffset(ChipConfig_t,ROMBASE)

#define ChipConfig_Reserved_3__CAP_PTR                     hpFieldOffset(ChipConfig_t,Reserved_3__CAP_PTR)

#define ChipConfig_CAP_PTR_MASK                            0x000000FF
#define ChipConfig_CAP_PTR_VALUE                           0x00000050

#define ChipConfig_MAXLAT_MINGNT_INTPIN_INTLINE            hpFieldOffset(ChipConfig_t,MAXLAT_MINGNT_INTPIN_INTLINE)

#define ChipConfig_MAXLAT_MASK                             0xFF000000
#define ChipConfig_MAXLAT_Not_Supported                    0x00000000

#define ChipConfig_MINGNT_MASK                             0x00FF0000
#define ChipConfig_MINGNT_VALUE                            0x00200000

#define ChipConfig_INTPIN_MASK                             0x0000FF00
#define ChipConfig_INTPIN_INTA_L                           0x00000100

#define ChipConfig_INTLINE_MASK                            0x000000FF
#define ChipConfig_INTLINE_Not_Used                        0x00000000

#define ChipConfig_PCIMCTR__ROMCTR__Reserved_5__Reserved_6 hpFieldOffset(ChipConfig_t,PCIMCTR__ROMCTR__Reserved_5__Reserved_6)

#define ChipConfig_PCIMCTR_MASK                            0xFF000000
#define ChipConfig_PCIMCTL_P64                             0x04000000

#define ChipConfig_ROMCTR_MASK                             0x00FF0000
#define ChipConfig_ROMCTR_PAR                              0x00400000
#define ChipConfig_ROMCTR_SVL                              0x00200000
#define ChipConfig_ROMCTR_256                              0x00100000
#define ChipConfig_ROMCTR_128                              0x00080000
#define ChipConfig_ROMCTR_ROM                              0x00040000
#define ChipConfig_ROMCTR_FLA                              0x00020000
#define ChipConfig_ROMCTR_VPP                              0x00010000

#define ChipConfig_INTSTAT_INTEN_INTPEND_SOFTRST           hpFieldOffset(ChipConfig_t,INTSTAT_INTEN_INTPEND_SOFTRST)

#define ChipConfig_INTSTAT_MASK                            0xFF000000
#define ChipConfig_INTSTAT_Reserved                        0xE0000000
#define ChipConfig_INTSTAT_MPE                             0x10000000
#define ChipConfig_INTSTAT_CRS                             0x08000000
#define ChipConfig_INTSTAT_INT                             0x04000000
#define ChipConfig_INTSTAT_DER                             0x02000000
#define ChipConfig_INTSTAT_PER                             0x01000000

#define ChipConfig_INTEN_MASK                              0x00FF0000
#define ChipConfig_INTEN_Reserved                          0x00E00000
#define ChipConfig_INTEN_MPE                               0x00100000
#define ChipConfig_INTEN_CRS                               0x00080000
#define ChipConfig_INTEN_INT                               0x00040000
#define ChipConfig_INTEN_DER                               0x00020000
#define ChipConfig_INTEN_PER                               0x00010000

#define ChipConfig_INTPEND_MASK                            0x0000FF00
#define ChipConfig_INTPEND_Reserved                        0x0000E000
#define ChipConfig_INTPEND_MPE                             0x00001000
#define ChipConfig_INTPEND_CRS                             0x00000800
#define ChipConfig_INTPEND_INT                             0x00000400
#define ChipConfig_INTPEND_DER                             0x00000200
#define ChipConfig_INTPEND_PER                             0x00000100

#define ChipConfig_SOFTRST_MASK                            0x000000FF
#define ChipConfig_SOFTRST_Reserved                        0x000000FC
#define ChipConfig_SOFTRST_DPE                             0x00000002
#define ChipConfig_SOFTRST_RST                             0x00000001

#define ChipConfig_PMC__CAP_NEXT_PTR__CAP_ID               hpFieldOffset(ChipConfig_t,PMC__CAP_NEXT_PTR__CAP_ID)

#define ChipConfig_PMC_MASK                                0xFFFF0000
#define ChipConfig_PMC_PME_MASK                            0xF8000000
#define ChipConfig_PMC_PME_Not_Supported                   0x00000000
#define ChipConfig_PMC_D2                                  0x04000000
#define ChipConfig_PMC_D1                                  0x02000000
#define ChipConfig_PMC_DSI                                 0x00200000
#define ChipConfig_PMC_APS                                 0x00100000
#define ChipConfig_PMC_CLK                                 0x00080000
#define ChipConfig_PMC_VER_MASK                            0x00070000

#define ChipConfig_CAP_NEXT_PTR_MASK                       0x0000FF00
#define ChipConfig_CAP_NEXT_PTR_No_Further                 0x00000000

#define ChipConfig_CAP_ID_MASK                             0x000000FF
#define ChipConfig_CAP_ID_Power_Management                 0x00000001

#define ChipConfig_Reserved_8__PMCSR                       hpFieldOffset(ChipConfig_t,Reserved_8__PMCSR)

#define ChipConfig_PMCSR_MASK                              0x0000FFFF
#define ChipConfig_PMCSR_PME                               0x00008000
#define ChipConfig_PMCSR_SCL_MASK                          0x00006000
#define ChipConfig_PMCSR_SEL_MASK                          0x00001E00
#define ChipConfig_PMCSR_PEN                               0x00000100
#define ChipConfig_PMCSR_PST_MASK                          0x00000003
#define ChipConfig_PMCSR_PST_Enable_DO_Power_State         0x00000000
#define ChipConfig_PMCSR_PST_Enable_D1_Power_State         0x00000001 /* Not supported */
#define ChipConfig_PMCSR_PST_Enable_D2_Power_State         0x00000002 /* Not supported */
#define ChipConfig_PMCSR_PST_Enable_D3_Power_State         0x00000003

/*+
Chip Registers
-*/

typedef struct ChipIOLo_s
               ChipIOLo_t;

#define ChipIOLo_t_SIZE                                    0x00000100

struct ChipIOLo_s {
                    os_bit32 ERQ_Base;
                    os_bit32 ERQ_Length;
                    os_bit32 ERQ_Producer_Index;
                    os_bit32 ERQ_Consumer_Index_Address;
                    os_bit32 ERQ_Consumer_Index;
                    os_bit8  Reserved_1[0x4F-0x14+1];
                    os_bit32 SFQ_Base;
                    os_bit32 SFQ_Length;
                    os_bit32 SFQ_Consumer_Index;
                    os_bit8  Reserved_2[0x7B-0x5C+1];          /* XL only  */
                    os_bit32 Interrupt_Delay_Timer;
                    os_bit32 IMQ_Base;
                    os_bit32 IMQ_Length;
                    os_bit32 IMQ_Consumer_Index;
                    os_bit32 IMQ_Producer_Index_Address;
                    os_bit8  Reserved_3[0xEF-0x90+1];
                    os_bit8  Reserved_4[0xFF-0xF0+1];
                  };

#define ChipIOLo_ERQ_Base                   hpFieldOffset(ChipIOLo_t,ERQ_Base)

#define ChipIOLo_ERQ_Length                 hpFieldOffset(ChipIOLo_t,ERQ_Length)

#define ChipIOLo_ERQ_Length_MASK            0x00000FFF
#define ChipIOLo_ERQ_Length_MIN             0x00000001 /*    2 */
#define ChipIOLo_ERQ_Length_MAX             0x00000FFF /* 4096 */
#define ChipIOLo_ERQ_Length_POWER_OF_2      agTRUE

#define ChipIOLo_ERQ_Producer_Index         hpFieldOffset(ChipIOLo_t,ERQ_Producer_Index)

#define ChipIOLo_ERQ_Producer_Index_MASK    0x00000FFF

#define ChipIOLo_ERQ_Consumer_Index_Address hpFieldOffset(ChipIOLo_t,ERQ_Consumer_Index_Address)

#define ChipIOLo_ERQ_Consumer_Index         hpFieldOffset(ChipIOLo_t,ERQ_Consumer_Index)

#define ChipIOLo_ERQ_Consumer_Index_MASK    0x00000FFF

#define ChipIOLo_SFQ_Base                   hpFieldOffset(ChipIOLo_t,SFQ_Base)

#define ChipIOLo_SFQ_Length                 hpFieldOffset(ChipIOLo_t,SFQ_Length)

#define ChipIOLo_SFQ_Length_MASK            0x00000FFF
#define ChipIOLo_SFQ_Length_MIN             0x0000001F /*   32 */
#define ChipIOLo_SFQ_Length_MAX             0x00000FFF /* 4096 */
#define ChipIOLo_SFQ_Length_POWER_OF_2      agTRUE

#define ChipIOLo_SFQ_Consumer_Index         hpFieldOffset(ChipIOLo_t,SFQ_Consumer_Index)

#define ChipIOLo_SFQ_Consumer_Index_MASK    0x00000FFF

#define ChipIOLo_Interrupt_Delay_Timer      hpFieldOffset (ChipIOLo_t, Interrupt_Delay_Timer)
#define ChipIOLo_Interrupt_Delay_Timer_MASK         0x0000000F

#define ChipIOUp_Interrupt_Delay_Timer_Immediate    0x00000000
#define ChipIOUp_Interrupt_Delay_Timer_125          0x00000001
#define ChipIOUp_Interrupt_Delay_Timer_250          0x00000002
#define ChipIOUp_Interrupt_Delay_Timer_375          0x00000003
#define ChipIOUp_Interrupt_Delay_Timer_500          0x00000004
#define ChipIOUp_Interrupt_Delay_Timer_625          0x00000005
#define ChipIOUp_Interrupt_Delay_Timer_750          0x00000006
#define ChipIOUp_Interrupt_Delay_Timer_875          0x00000007
#define ChipIOUp_Interrupt_Delay_Timer_1ms          0x00000008
#define ChipIOUp_Interrupt_Delay_Timer_1_125ms      0x00000009
#define ChipIOUp_Interrupt_Delay_Timer_1_250ms      0x0000000a
#define ChipIOUp_Interrupt_Delay_Timer_1_375ms      0x0000000b
#define ChipIOUp_Interrupt_Delay_Timer_1_500ms      0x0000000c
#define ChipIOUp_Interrupt_Delay_Timer_1_625ms      0x0000000d
#define ChipIOUp_Interrupt_Delay_Timer_1_875ms      0x0000000e



#define ChipIOLo_IMQ_Base                   hpFieldOffset(ChipIOLo_t,IMQ_Base)

#define ChipIOLo_IMQ_Length                 hpFieldOffset(ChipIOLo_t,IMQ_Length)

#define ChipIOLo_IMQ_Length_MASK            0x00000FFF
#define ChipIOLo_IMQ_Length_MIN             0x00000001 /*    2 */
#define ChipIOLo_IMQ_Length_MAX             0x00000FFF /* 4096 */
#define ChipIOLo_IMQ_Length_POWER_OF_2      agTRUE

#define ChipIOLo_IMQ_Consumer_Index         hpFieldOffset(ChipIOLo_t,IMQ_Consumer_Index)

#define ChipIOLo_IMQ_Consumer_Index_MASK    0x00000FFF

#define ChipIOLo_IMQ_Producer_Index_Address hpFieldOffset(ChipIOLo_t,IMQ_Producer_Index_Address)

typedef struct ChipIOUp_s
               ChipIOUp_t;

#define ChipIOUp_t_SIZE                                    0x00000100

struct ChipIOUp_s {
#ifdef __TACHYON_XL2
					os_bit32 Frame_Manager_Configuration_3;						
					os_bit32 Frame_Manager_Shadow_Status;						
                    os_bit8  Reserved_1[0x3F-0x08+1];
#else
                    os_bit8  Reserved_1[0x3F+1];
#endif	/* __TACHYON_XL2 */																	
                    os_bit32 SEST_Base;
                    os_bit32 SEST_Length;
                    os_bit8  Reserved_2[0x4B-0x48+1];
                    os_bit32 SEST_Linked_List_Head_Tail;
#ifdef __TACHYON_XL2
                    os_bit32 SPI_RAM_ROM_Address;
                    os_bit32 SPI_RAM_ROM_Data;
                    os_bit8  Reserved_3[0x67-0x58+1];
#else
                    os_bit8  Reserved_3[0x67-0x50+1];
#endif	/* __TACHYON_XL2 */																	
                    os_bit32 ScatterGather_List_Page_Length;
                    os_bit32 My_ID;
#ifdef __TACHYON_XL2
                    os_bit32 General_Purpose_IO;
                    os_bit8  Reserved_4[0x83-0x74+1];
#else
                    os_bit8  Reserved_4[0x83-0x70+1];
#endif	/* __TACHYON_XL2 */																	
                    os_bit32 TachLite_Configuration;
                    os_bit32 TachLite_Control;
                    os_bit32 TachLite_Status;
                    os_bit32 Reserved_5;                                       /* XL only  */
                    os_bit32 High_Priority_Send_1;                             /* XL only  */
                    os_bit32 High_Priority_Send_2;                             /* XL only  */
                    os_bit32 Inbound_Resource_Status_1;                        /* XL only  */
                    os_bit32 Inbound_Resource_Status_2;                        /* XL only  */
                    os_bit32 EE_Credit_Zero_Timer_Threshold;                   /* XL only  */
                    os_bit32 Upper_Data_Address;                               /* XL only  */
                    os_bit32 Upper_Control_Address;                            /* XL only  */
                    os_bit32 Dynamic_Half_Duplex_3;                            /* XL only  */
                    os_bit32 Dynamic_Half_Duplex_2;                            /* XL only  */
                    os_bit32 Dynamic_Half_Duplex_1;                            /* XL only  */
                    os_bit32 Dynamic_Half_Duplex_0;                            /* XL only  */
                    os_bit32 Frame_Manager_Configuration;
                    os_bit32 Frame_Manager_Control;
                    os_bit32 Frame_Manager_Status;
                    os_bit32 Frame_Manager_TimeOut_Values_1;
                    os_bit32 Frame_Manager_Link_Status_1;
                    os_bit32 Frame_Manager_Link_Status_2;
                    os_bit32 Frame_Manager_TimeOut_Values_2;
                    os_bit32 Frame_Manager_BBCredit_Zero_Timer;
                    os_bit32 Frame_Manager_World_Wide_Name_High;
                    os_bit32 Frame_Manager_World_Wide_Name_Low;
                    os_bit32 Frame_Manager_Received_ALPA;
                    os_bit32 Frame_Manager_Primitive;
                    os_bit32 Frame_Manager_Link_Status_3;                      /* XL only  */
                    os_bit32 Frame_Manager_Configuration_2;                    /* XL only  */
                    os_bit32 PCIMCTR__ROMCTR__Reserved_8__Reserved_9;
                    os_bit32 INTSTAT_INTEN_INTPEND_SOFTRST;
                  };

#ifdef __TACHYON_XL
#define ChipIOUp_Frame_Manager_Configuration_3                    hpFieldOffset(ChipIOUp_t,Frame_Manager_Configuration_3)
 
#define ChipIOUp_Frame_Manager_Configuration_3_AutoSpeed_Nego_In_Prog	0x40000000     

#define ChipIOUp_Frame_Manager_Configuration_3_EN_AutoSpeed_Nego		0x10000000 

#define ChipIOUp_Frame_Manager_Configuration_3_2Gig_TXS					0x04000000     
#define ChipIOUp_Frame_Manager_Configuration_3_2Gig_RXS					0x01000000 

#endif	/* __TACHYON_XL */																	

#define ChipIOUp_SEST_Base                                        hpFieldOffset(ChipIOUp_t,SEST_Base)

#define ChipIOUp_SPI_RAM_ROM_Address                              hpFieldOffset(ChipIOUp_t,SPI_RAM_ROM_Address);
#define ChipIOUp_SPI_RAM_ROM_Address_Access_RAM                   0x80000000
#define ChipIOUp_SPI_RAM_ROM_Data                                 hpFieldOffset(ChipIOUp_t,SPI_RAM_ROM_Data);
#define ChipIOUp_SPI_RAM_ROM_Data_Access_ROM_MASK                 0x000000FF


#define ChipIOUp_SEST_Length                                      hpFieldOffset(ChipIOUp_t,SEST_Length)

#define ChipIOUp_SEST_Length_MASK                                 0x0000FFFF
#define ChipIOUp_SEST_Length_MIN                                  0x00000001 /*     1 */
#define ChipIOUp_SEST_Length_MAX                                  0x00007FFF /* 32767 */
#define ChipIOUp_SEST_Length_POWER_OF_2                           agFALSE

#define ChipIOUp_SEST_Linked_List_Head_Tail                       hpFieldOffset(ChipIOUp_t,SEST_Linked_List_Head_Tail)

#define ChipIOUp_SEST_Linked_List_Head_MASK                       0xFFFF0000
#define ChipIOUp_SEST_Linked_List_Head_SHIFT                            0x10
#define ChipIOUp_SEST_Linked_List_Tail_MASK                       0x0000FFFF
#define ChipIOUp_SEST_Linked_List_Tail_SHIFT                            0x00

#define ChipIOUp_SEST_Linked_List_Tail_RESET_VALUE                (ChipIOUp_SEST_Linked_List_Head_MASK | ChipIOUp_SEST_Linked_List_Tail_MASK)

#define ChipIOUp_ScatterGather_List_Page_Length                   hpFieldOffset(ChipIOUp_t,ScatterGather_List_Page_Length)

#define ChipIOUp_ScatterGather_List_Page_Length_MASK              0x000000FF
#define ChipIOUp_ScatterGather_List_Page_Length_MIN               0x00000003 /*   4 */
#define ChipIOUp_ScatterGather_List_Page_Length_MAX               0x000000FF /* 256 */
#define ChipIOUp_ScatterGather_List_Page_Length_POWER_OF_2        agTRUE

#define ChipIOUp_My_ID                                            hpFieldOffset(ChipIOUp_t,My_ID)

#define ChipIOUp_My_ID_MASK                                       0x00FFFFFF

#define ChipIOUp_TachLite_Configuration                           hpFieldOffset(ChipIOUp_t,TachLite_Configuration)

#define ChipIOUp_TachLite_Configuration_M66EN                     0x80000000 /* Always set for TachyonTL */
#define ChipIOUp_TachLite_Configuration_OB_Thresh_MASK            0x00007C00
#define ChipIOUp_TachLite_Configuration_OB_Thresh_100             0x00000000
#define ChipIOUp_TachLite_Configuration_OB_Thresh_132             0x00002000
#define ChipIOUp_TachLite_Configuration_OB_Thresh_150             0x00002C00
#define ChipIOUp_TachLite_Configuration_OB_Thresh_200             0x00004000
#define ChipIOUp_TachLite_Configuration_OB_Thresh_264             0x00005000
#define ChipIOUp_TachLite_Configuration_OB_Thresh_528             0x00006800 /* Only valid for TachyonTS */
#define ChipIOUp_TachLite_Configuration_SIC                       0x00000040
#define ChipIOUp_TachLite_Configuration_FAD                       0x00000001

#define ChipIOUp_TachLite_Control                                 hpFieldOffset(ChipIOUp_t,TachLite_Control)

#define ChipIOUp_TachLite_Control_CRS                             0x80000000
#define ChipIOUp_TachLite_Control_ROF                             0x00040000
#define ChipIOUp_TachLite_Control_RIF                             0x00020000
#define ChipIOUp_TachLite_Control_REQ                             0x00010000
#define ChipIOUp_TachLite_Control_FIS                             0x00001000
#define ChipIOUp_TachLite_Control_FFA                             0x00000200
#define ChipIOUp_TachLite_Control_FEQ                             0x00000100
#define ChipIOUp_TachLite_Control_GP4                             0x00000010
#define ChipIOUp_TachLite_Control_GP3                             0x00000008
#define ChipIOUp_TachLite_Control_GP2                             0x00000004
#define ChipIOUp_TachLite_Control_GP1                             0x00000002
#define ChipIOUp_TachLite_Control_GP0                             0x00000001

#define ChipIOUp_TachLite_Control_GPIO_0_3_MASK                   (ChipIOUp_TachLite_Control_GP3 | ChipIOUp_TachLite_Control_GP2 | ChipIOUp_TachLite_Control_GP1 | ChipIOUp_TachLite_Control_GP0)
#define ChipIOUp_TachLite_Control_GPIO_ALL_MASK                   (ChipIOUp_TachLite_Control_GP4 | ChipIOUp_TachLite_Control_GPIO_0_3_MASK)

#define ChipIOUp_TachLite_Status                                  hpFieldOffset(ChipIOUp_t,TachLite_Status)

#define ChipIOUp_TachLite_Status_SFF                              0x80000000
#define ChipIOUp_TachLite_Status_IMF                              0x40000000
#define ChipIOUp_TachLite_Status_OFE                              0x20000000
#define ChipIOUp_TachLite_Status_IFE                              0x10000000
#define ChipIOUp_TachLite_Status_OFF                              0x00040000
#define ChipIOUp_TachLite_Status_IFF                              0x00020000
#define ChipIOUp_TachLite_Status_EQF                              0x00010000
#define ChipIOUp_TachLite_Status_Stop_Cnt_MASK                    0x0000F000
#define ChipIOUp_TachLite_Status_OPE                              0x00000800
#define ChipIOUp_TachLite_Status_IPE                              0x00000400
#define ChipIOUp_TachLite_Status_REVID_MASK                       0x000003E0
#define ChipIOUp_TachLite_Status_REVID_SHIFT                            0x05
#define ChipIOUp_TachLite_Status_GP4                              0x00000010
#define ChipIOUp_TachLite_Status_GP3                              0x00000008
#define ChipIOUp_TachLite_Status_GP2                              0x00000004
#define ChipIOUp_TachLite_Status_GP1                              0x00000002
#define ChipIOUp_TachLite_Status_GP0                              0x00000001
#define ChipIOUp_TachLite_Status_OLE                              0x08000000
#define ChipIOUp_TachLite_Status_ILE                              0x04000000
#define ChipIOUp_TachLite_Status_M66                              0x02000000


#define ChipIOUp_TachLite_Status_GPIO_0_3_MASK                    (ChipIOUp_TachLite_Status_GP3 | ChipIOUp_TachLite_Status_GP2 | ChipIOUp_TachLite_Status_GP1 | ChipIOUp_TachLite_Status_GP0)
#define ChipIOUp_TachLite_Status_GPIO_ALL_MASK                    (ChipIOUp_TachLite_Status_GP4 | ChipIOUp_TachLite_Status_GPIO_0_3_MASK)

#define ChipIOUp_Tachlite_High_Priority_Send_1                      hpFieldOffset(ChipIOUp_t, High_Priority_Send_1)

#define ChipIOUp_TachLite_High_Priority_Send_1_HP_Frame_Upper_Addr_MASK     0x7ff80000
#define ChipIOUp_Tachlite_High_Priority_Send_1_HP_Frame_Upper_Addr_SHIFT    0x13
#define ChipIOUp_Tachlite_High_Priority_Send_1_HP_Frame_Length_MASK         0x00000fff
#define ChipIOUp_Tachlite_High_Priority_Send_1_HP_Frame_Length_SHIFT        0x0

   
#define ChipIOUp_Inbound_Resource_Status                          hpFieldOffset(ChipIOUp_t,Inbound_Resource_Status_1)

#define ChipIOUp_Inbound_Resource_Status_SEST_LRU_Count_MASK      0xFF000000
#define ChipIOUp_Inbound_Resource_Status_SEST_LRU_Count_SHIFT           0x18

#define ChipIOUp_Inbound_Resource_Status_2                          hpFieldOffset(ChipIOUp_t,Inbound_Resource_Status_2)

#define ChipIOUp_Inbound_Resource_Status_Discarded_Frame_Counter_MASK      0x000000FF
#define ChipIOUp_Inbound_Resource_Status_Discarded_Frame_Counter_SHIFT           0x0

#define ChipIOUp_EE_Credit_Zero_Timer_Threshold                   hpFieldOffset(ChipIOUp_t,EE_Credit_Zero_Timer_Threshold)

#define ChipIOUp_EE_Credit_Zero_Timer_Threshold_MASK              0x0fffffff
#define ChipIOUp_EE_Credit_Zero_Timer_Threshold_SHIFT             0x0

#define ChipIOUp_Upper_Data_Address                               hpFieldOffset(ChipIOUp_t,ChipIOUp_Upper_Data_Address)
#define ChipIOUp_Upper_Control_Address                            hpFieldOffset(ChipIOUp_t,ChipIOUp_Upper_Control_Address)

#define ChipIOUp_Inbound_Resource_Status_Discarded_Frame_Counter_MASK      0x000000FF
#define ChipIOUp_Inbound_Resource_Status_Discarded_Frame_Counter_SHIFT           0x0


#define ChipIOUp_Frame_Manager_Configuration                      hpFieldOffset(ChipIOUp_t,Frame_Manager_Configuration)

#define ChipIOUp_Frame_Manager_Configuration_AL_PA_MASK           0xFF000000
#define ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT                0x18
#define ChipIOUp_Frame_Manager_Configuration_BB_Credit_MASK       0x00FF0000
#define ChipIOUp_Frame_Manager_Configuration_BB_Credit_SHIFT            0x10
#define ChipIOUp_Frame_Manager_Configuration_NPI                  0x00008000
#define ChipIOUp_Frame_Manager_Configuration_ILB                  0x00004000
#define ChipIOUp_Frame_Manager_Configuration_ELB                  0x00002000
#define ChipIOUp_Frame_Manager_Configuration_SAP                  0x00001000
#define ChipIOUp_Frame_Manager_Configuration_TD                   0x00000800
#define ChipIOUp_Frame_Manager_Configuration_FA                   0x00000400
#define ChipIOUp_Frame_Manager_Configuration_AQ                   0x00000200
#define ChipIOUp_Frame_Manager_Configuration_HA                   0x00000100
#define ChipIOUp_Frame_Manager_Configuration_SA                   0x00000080
#define ChipIOUp_Frame_Manager_Configuration_BLM                  0x00000040
#define ChipIOUp_Frame_Manager_Configuration_RF                   0x00000020
#define ChipIOUp_Frame_Manager_Configuration_IF                   0x00000010
#define ChipIOUp_Frame_Manager_Configuration_LR                   0x00000008
#define ChipIOUp_Frame_Manager_Configuration_ENP                  0x00000004
#define ChipIOUp_Frame_Manager_Configuration_BLI                  0x00000001

#define ChipIOUp_TachLite_Configuration_DAM                       0x10000000
#define ChipIOUp_Tachlite_Configuration_RDE                       0x08000000     
#define ChipIOUp_Tachlite_Configuration_SDF                       0x04000000
#define ChipIOUp_Tachlite_Configuration_FC2                       0x01000000 
#define ChipIOUp_Tachlite_Configuration_CAE                       0x00000200
#define ChipIOUp_Tachlite_Configuration_SIC                       0x00000040
#define ChipIOUp_Tachlite_Configuration_FAB                       0x00000020
#define ChipIOUp_Tachlite_Configuration_FUA                       0x00000008                     
#define ChipIOUp_Tachlite_Configuration_DOF                       0x00000004
#define ChipIOUp_Tachlite_Configuration_INO                       0x00000002
#define ChipIOUp_TachLite_Configuration_FAD                       0x00000001                                             



#define ChipIOUp_Frame_Manager_Control                            hpFieldOffset(ChipIOUp_t,Frame_Manager_Control)

#define ChipIOUp_Frame_Manager_Control_SAS                        0x00000080
#define ChipIOUp_Frame_Manager_Control_SQ                         0x00000040
#define ChipIOUp_Frame_Manager_Control_SP                         0x00000020
#define ChipIOUp_Frame_Manager_Control_CL                         0x00000008
#define ChipIOUp_Frame_Manager_Control_CMD_MASK                   0x00000007
#define ChipIOUp_Frame_Manager_Control_CMD_NOP                    0x00000000
#define ChipIOUp_Frame_Manager_Control_CMD_Exit_Loop              0x00000001
#define ChipIOUp_Frame_Manager_Control_CMD_Host_Control           0x00000002
#define ChipIOUp_Frame_Manager_Control_CMD_Exit_Host_Control      0x00000003
#define ChipIOUp_Frame_Manager_Control_CMD_Link_Reset             0x00000004
#define ChipIOUp_Frame_Manager_Control_CMD_Offline                0x00000005
#define ChipIOUp_Frame_Manager_Control_CMD_Initialize             0x00000006
#define ChipIOUp_Frame_Manager_Control_CMD_Clear_LF               0x00000007

#define ChipIOUp_Frame_Manager_Status                             hpFieldOffset(ChipIOUp_t,Frame_Manager_Status)

#define ChipIOUp_Frame_Manager_Status_LP                          0x80000000
#define ChipIOUp_Frame_Manager_Status_TP                          0x40000000
#define ChipIOUp_Frame_Manager_Status_NP                          0x20000000
#define ChipIOUp_Frame_Manager_Status_BYP                         0x10000000
#define ChipIOUp_Frame_Manager_Status_FLT                         0x04000000
#define ChipIOUp_Frame_Manager_Status_OS                          0x02000000
#define ChipIOUp_Frame_Manager_Status_LS                          0x01000000
#define ChipIOUp_Frame_Manager_Status_DRS                         0x00400000
#define ChipIOUp_Frame_Manager_Status_LPE                         0x00200000
#define ChipIOUp_Frame_Manager_Status_LPB                         0x00100000
#define ChipIOUp_Frame_Manager_Status_OLS                         0x00080000
#define ChipIOUp_Frame_Manager_Status_LST                         0x00040000
#define ChipIOUp_Frame_Manager_Status_LPF                         0x00020000
#define ChipIOUp_Frame_Manager_Status_BA                          0x00010000
#define ChipIOUp_Frame_Manager_Status_PRX                         0x00008000
#define ChipIOUp_Frame_Manager_Status_PTX                         0x00004000
#define ChipIOUp_Frame_Manager_Status_LG                          0x00002000
#define ChipIOUp_Frame_Manager_Status_LF                          0x00001000
#define ChipIOUp_Frame_Manager_Status_CE                          0x00000800
#define ChipIOUp_Frame_Manager_Status_EW                          0x00000400
#define ChipIOUp_Frame_Manager_Status_LUP                         0x00000200
#define ChipIOUp_Frame_Manager_Status_LDN                         0x00000100
#define ChipIOUp_Frame_Manager_Status_LSM_MASK                    0x000000F0
#define ChipIOUp_Frame_Manager_Status_LSM_Monitor                 0x00000000
#define ChipIOUp_Frame_Manager_Status_LSM_ARB                     0x00000010
#define ChipIOUp_Frame_Manager_Status_LSM_ARB_Won                 0x00000020
#define ChipIOUp_Frame_Manager_Status_LSM_Open                    0x00000030
#define ChipIOUp_Frame_Manager_Status_LSM_Opened                  0x00000040
#define ChipIOUp_Frame_Manager_Status_LSM_Xmit_CLS                0x00000050
#define ChipIOUp_Frame_Manager_Status_LSM_Rx_CLS                  0x00000060
#define ChipIOUp_Frame_Manager_Status_LSM_Xfer                    0x00000070
#define ChipIOUp_Frame_Manager_Status_LSM_Initialize              0x00000080
#define ChipIOUp_Frame_Manager_Status_LSM_O_I_Init_Finish         0x00000090
#define ChipIOUp_Frame_Manager_Status_LSM_O_I_Protocol            0x000000A0
#define ChipIOUp_Frame_Manager_Status_LSM_O_I_Lip_Received        0x000000B0
#define ChipIOUp_Frame_Manager_Status_LSM_Host_Control            0x000000C0
#define ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail               0x000000D0
#define ChipIOUp_Frame_Manager_Status_LSM_Offline                 0x000000E0
#define ChipIOUp_Frame_Manager_Status_LSM_Old_Port                0x000000F0
#define ChipIOUp_Frame_Manager_Status_PSM_MASK                    0x0000000F
#define ChipIOUp_Frame_Manager_Status_PSM_Offline                 0x00000000
#define ChipIOUp_Frame_Manager_Status_PSM_OL1                     0x00000001
#define ChipIOUp_Frame_Manager_Status_PSM_OL2                     0x00000002
#define ChipIOUp_Frame_Manager_Status_PSM_OL3                     0x00000003
#define ChipIOUp_Frame_Manager_Status_PSM_Reserved_1              0x00000004
#define ChipIOUp_Frame_Manager_Status_PSM_LR1                     0x00000005
#define ChipIOUp_Frame_Manager_Status_PSM_LR2                     0x00000006
#define ChipIOUp_Frame_Manager_Status_PSM_LR3                     0x00000007
#define ChipIOUp_Frame_Manager_Status_PSM_Reserved_2              0x00000008
#define ChipIOUp_Frame_Manager_Status_PSM_LF1                     0x00000009
#define ChipIOUp_Frame_Manager_Status_PSM_LF2                     0x0000000A
#define ChipIOUp_Frame_Manager_Status_PSM_Reserved_3              0x0000000B
#define ChipIOUp_Frame_Manager_Status_PSM_Reserved_4              0x0000000C
#define ChipIOUp_Frame_Manager_Status_PSM_Reserved_5              0x0000000D
#define ChipIOUp_Frame_Manager_Status_PSM_Reserved_6              0x0000000E
#define ChipIOUp_Frame_Manager_Status_PSM_ACTIVE                  0x0000000F

#define ChipIOUp_Frame_Manager_TimeOut_Values_1                   hpFieldOffset(ChipIOUp_t,Frame_Manager_TimeOut_Values_1)
#define Chip_Frame_Manager_TimeOut_Values_1(rt_tov, ed_tov)  (( rt_tov << ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_SHIFT) | ( ed_tov <<ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT)) 
#define Chip_Frame_Manager_TimeOut_Values_1_RT_TOV_Default_After_Reset 100
#define Chip_Frame_Manager_TimeOut_Values_1_ED_TOV_Default_After_Reset 500
#define Chip_Frame_Manager_TimeOut_Values_1_ED_TOV_Default 2000

#define ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_MASK       0x01FF0000
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_SHIFT            0x10
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_100ms      (100<<ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_Default    ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_100ms
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_MASK       0x0000FFFF
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT            0x00
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_500ms      (500<<ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_2000ms      (2000<<ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_4000ms      (4000<<ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_Default    ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_500ms

#define ChipIOUp_Frame_Manager_Link_Status_1                      hpFieldOffset(ChipIOUp_t,Frame_Manager_Link_Status_1)

#define ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_MASK  0xFF000000
#define ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_SHIFT       0x18
#define ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_AdjustToChar( x ) (( x & ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_SHIFT )
#define ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_MASK     0x00FF0000
#define ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_SHIFT          0x10
#define ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_AdjustToChar( x )    (( x & ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_SHIFT )

#define ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_MASK    0x0000FF00
#define ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_SHIFT         0x08
#define ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_AdjustToChar( x )  (( x & ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_SHIFT )

#define ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_MASK       0x000000FF
#define ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_SHIFT            0x00
#define ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_AdjustToChar( x )  (( x & ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_SHIFT )

#define ChipIOUp_Frame_Manager_Link_Status_2                      hpFieldOffset(ChipIOUp_t,Frame_Manager_Link_Status_2)

#define ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_MASK         0xFF000000
#define ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_SHIFT              0x18
#define ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_AdjustToChar( x )  (( x & ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_SHIFT )
#define ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_MASK         0x00FF0000
#define ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_SHIFT              0x10
#define ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_AdjustToChar( x )  (( x & ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_SHIFT )
#define ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_MASK         0x0000FF00
#define ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_SHIFT              0x08
#define ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_AdjustToChar( x )  (( x & ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_SHIFT )
#define ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_MASK       0x000000FF
#define ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_SHIFT            0x00
#define ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_AdjustToChar( x )  (( x & ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_SHIFT )

#define ChipIOUp_Frame_Manager_TimeOut_Values_2                   hpFieldOffset(ChipIOUp_t,Frame_Manager_TimeOut_Values_2)
#define Chip_Frame_Manager_TimeOut_Values_2(lp_tov, al_time)  (( lp_tov << ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_SHIFT) | ( al_time << ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_SHIFT)) 
#define Chip_Frame_Manager_TimeOut_Values_2_LP_TOV_Default_After_Reset  500
#define Chip_Frame_Manager_TimeOut_Values_2_AL_Time_Default_After_Reset 15
#define Chip_Frame_Manager_TimeOut_Values_2_LP_TOV_Default Chip_Frame_Manager_TimeOut_Values_1_ED_TOV_Default

#define ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_MASK       0xFFFF0000
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_SHIFT            0x10
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_2s         ((2*1000)<<ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_500ms      (( 500)<<ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_Default    ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_2s
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_MASK      0x000001FF
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_SHIFT           0x00
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_15ms      (15<<ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_1000ms    (1000<<ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_Default   ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_15ms

#define ChipIOUp_Frame_Manager_BBCredit_Zero_Timer                hpFieldOffset(ChipIOUp_t,Frame_Manager_BBCredit_Zero_Timer)

#define ChipIOUp_Frame_Manager_BBCredit_Zero_Timer_MASK           0x00FFFFFF

#define ChipIOUp_Frame_Manager_World_Wide_Name_High               hpFieldOffset(ChipIOUp_t,Frame_Manager_World_Wide_Name_High)

#define ChipIOUp_Frame_Manager_World_Wide_Name_Low                hpFieldOffset(ChipIOUp_t,Frame_Manager_World_Wide_Name_Low)

#define ChipIOUp_Frame_Manager_Received_ALPA                      hpFieldOffset(ChipIOUp_t,Frame_Manager_Received_ALPA)

#define ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK        0x00FF0000
#define ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT             0x10
#define ChipIOUp_Frame_Manager_Received_ALPA_Bad_ALPA_MASK        0x0000FF00
#define ChipIOUp_Frame_Manager_Received_ALPA_Bad_ALPA_SHIFT             0x08
#define ChipIOUp_Frame_Manager_Received_ALPA_LIPf_ALPA_MASK       0x000000FF
#define ChipIOUp_Frame_Manager_Received_ALPA_LIPf_ALPA_SHIFT            0x00

#define ChipIOUp_Frame_Manager_Primitive                          hpFieldOffset(ChipIOUp_t,Frame_Manager_Primitive)

#define ChipIOUp_Frame_Manager_Primitive_MASK                     0x00FFFFFF

#define ChipIOUp_Frame_Manager_Link_Status_3                      hpFieldOffset(ChipIOUp_t,Frame_Manager_Link_Status_3)
#define ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_MASK         0x000000FF
#define ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_SHIFT        0x0
#define ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_AdjustToChar( x ) (( x & ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_SHIFT )

#define ChipIOUp_Frame_Manager_Configuration_2                    hpFieldOffset(ChipIOUp_t,Frame_Manager_Configuration_2)

#define ChipIOUp_Frame_Manager_Configuration_2_LAA_MASK           0xFF000000
#define ChipIOUp_Frame_Manager_Configuration_2_LAA_SHIFT          0x18
#define ChipIOUp_Frame_Manager_Configuration_2_XTP_MASK           0x00C00000
#define ChipIOUp_Frame_Manager_Configuration_2_XTP                0x0
#define ChipIOUp_Frame_Manager_Configuration_2_XTZ_MASK           0x00400000
#define ChipIOUp_Frame_Manager_Configuration_2_XTZ_SHIFT          0x14
#define ChipIOUp_Frame_Manager_Configuration_2_XTZ                0x3
#define ChipIOUp_Frame_Manager_Configuration_2_XRP_MASK           0x000C0000
#define ChipIOUp_Frame_Manager_Configuration_2_XRP                0x0
#define ChipIOUp_Frame_Manager_Configuration_2_XRZ_MASK           0x00040000
#define ChipIOUp_Frame_Manager_Configuration_2_XRZ_SHIFT          0xF
#define ChipIOUp_Frame_Manager_Configuration_2_XRZ                0x1

#define ChipIOUp_Frame_Manager_Configuration_2_XEM_MASK           0x00006000
#define ChipIOUp_Frame_Manager_Configuration_2_XEM_SHIFT          0xC
#define ChipIOUp_Frame_Manager_Configuration_2_XEM                0x0

#define ChipIOUp_Frame_Manager_Configuration_2_XLP                0x00001000

#define ChipIOUp_Frame_Manager_Configuration_2_ATV_MASK           0x000000C0
#define ChipIOUp_Frame_Manager_Configuration_2_ATV_SHIFT          0x5
#define ChipIOUp_Frame_Manager_Configuration_2_ATV_Single_Frame   0x0
#define ChipIOUp_Frame_Manager_Configuration_2_ATV_25_Percent     0x1
#define ChipIOUp_Frame_Manager_Configuration_2_ATV_50_Percent     0x2
#define ChipIOUp_Frame_Manager_Configuration_2_ATV_75_Percent     0x3

#define ChipIOUp_Frame_Manager_Configuration_2_ICB                0x00000010
#define ChipIOUp_Frame_Manager_Configuration_2_DCI                0x00000008
#define ChipIOUp_Frame_Manager_Configuration_2_NBC                0x00000004
#define ChipIOUp_Frame_Manager_Configuration_2_DAC                0x00000001



#define ChipIOUp_PCIMCTR__ROMCTR__Reserved_8__Reserved_9          hpFieldOffset(ChipIOUp_t,PCIMCTR__ROMCTR__Reserved_8__Reserved_9)

#define ChipIOUp_PCIMCTR_MASK                                     0xFF000000
#define ChipIOUp_PCIMCTL_P64                                      0x04000000

#define ChipIOUp_ROMCTR_MASK                                      0x00FF0000
#define ChipIOUp_ROMCTR_PAR                                       0x00400000
#define ChipIOUp_ROMCTR_SVL                                       0x00200000
#define ChipIOUp_ROMCTR_256                                       0x00100000
#define ChipIOUp_ROMCTR_128                                       0x00080000
#define ChipIOUp_ROMCTR_ROM                                       0x00040000
#define ChipIOUp_ROMCTR_FLA                                       0x00020000
#define ChipIOUp_ROMCTR_VPP                                       0x00010000

#define ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST                    hpFieldOffset(ChipIOUp_t,INTSTAT_INTEN_INTPEND_SOFTRST)

#define ChipIOUp_INTSTAT_MASK                                     0xFF000000
#define ChipIOUp_INTSTAT_Reserved                                 0xE0000000
#define ChipIOUp_INTSTAT_MPE                                      0x10000000
#define ChipIOUp_INTSTAT_CRS                                      0x08000000
#define ChipIOUp_INTSTAT_INT                                      0x04000000
#define ChipIOUp_INTSTAT_DER                                      0x02000000
#define ChipIOUp_INTSTAT_PER                                      0x01000000

#define ChipIOUp_INTEN_MASK                                       0x00FF0000
#define ChipIOUp_INTEN_Reserved                                   0x00E00000
#define ChipIOUp_INTEN_MPE                                        0x00100000
#define ChipIOUp_INTEN_CRS                                        0x00080000
#define ChipIOUp_INTEN_INT                                        0x00040000
#define ChipIOUp_INTEN_DER                                        0x00020000
#define ChipIOUp_INTEN_PER                                        0x00010000

#define ChipIOUp_INTPEND_MASK                                     0x0000FF00
#define ChipIOUp_INTPEND_Reserved                                 0x0000E000
#define ChipIOUp_INTPEND_MPE                                      0x00001000
#define ChipIOUp_INTPEND_CRS                                      0x00000800
#define ChipIOUp_INTPEND_INT                                      0x00000400
#define ChipIOUp_INTPEND_DER                                      0x00000200
#define ChipIOUp_INTPEND_PER                                      0x00000100

#define ChipIOUp_SOFTRST_MASK                                     0x000000FF
#define ChipIOUp_SOFTRST_Reserved                                 0x000000FC
#define ChipIOUp_SOFTRST_DPE                                      0x00000002
#define ChipIOUp_SOFTRST_RST                                      0x00000001

typedef struct ChipMem_s
               ChipMem_t;

#define ChipMem_t_SIZE                                     0x00000200

struct ChipMem_s {
                   ChipIOLo_t Lo;
                   ChipIOUp_t Up;
                 };

#define ChipMem_ERQ_Base                                          hpFieldOffset(ChipMem_t,Lo.ERQ_Base)

#define ChipMem_ERQ_Length                                        hpFieldOffset(ChipMem_t,Lo.ERQ_Length)

#define ChipMem_ERQ_Length_MASK                                   ChipIOLo_ERQ_Length_MASK
#define ChipMem_ERQ_Length_MIN                                    ChipIOLo_ERQ_Length_MIN
#define ChipMem_ERQ_Length_MAX                                    ChipIOLo_ERQ_Length_MAX
#define ChipMem_ERQ_Length_POWER_OF_2                             ChipIOLo_ERQ_Length_POWER_OF_2

#define ChipMem_ERQ_Producer_Index                                hpFieldOffset(ChipMem_t,Lo.ERQ_Producer_Index)

#define ChipMem_ERQ_Producer_Index_MASK                           ChipIOLo_ERQ_Producer_Index_MASK

#define ChipMem_ERQ_Consumer_Index_Address                        hpFieldOffset(ChipMem_t,Lo.ERQ_Consumer_Index_Address)

#define ChipMem_ERQ_Consumer_Index                                hpFieldOffset(ChipMem_t,Lo.ERQ_Consumer_Index)

#define ChipMem_ERQ_Consumer_Index_MASK                           ChipIOLo_ERQ_Consumer_Index_MASK

#define ChipMem_SFQ_Base                                          hpFieldOffset(ChipMem_t,Lo.SFQ_Base)

#define ChipMem_SFQ_Length                                        hpFieldOffset(ChipMem_t,Lo.SFQ_Length)

#define ChipMem_SFQ_Length_MASK                                   ChipIOLo_SFQ_Length_MASK
#define ChipMem_SFQ_Length_MIN                                    ChipIOLo_SFQ_Length_MIN
#define ChipMem_SFQ_Length_MAX                                    ChipIOLo_SFQ_Length_MAX
#define ChipMem_SFQ_Length_POWER_OF_2                             ChipIOLo_SFQ_Length_POWER_OF_2

#define ChipMem_SFQ_Consumer_Index                                hpFieldOffset(ChipMem_t,Lo.SFQ_Consumer_Index)

#define ChipMem_SFQ_Consumer_Index_MASK                           ChipIOLo_SFQ_Consumer_Index_MASK

#define ChipMem_IMQ_Base                                          hpFieldOffset(ChipMem_t,Lo.IMQ_Base)

#define ChipMem_IMQ_Length                                        hpFieldOffset(ChipMem_t,Lo.IMQ_Length)

#define ChipMem_IMQ_Length_MASK                                   ChipIOLo_IMQ_Length_MASK
#define ChipMem_IMQ_Length_MIN                                    ChipIOLo_IMQ_Length_MIN
#define ChipMem_IMQ_Length_MAX                                    ChipIOLo_IMQ_Length_MAX
#define ChipMem_IMQ_Length_POWER_OF_2                             ChipIOLo_IMQ_Length_POWER_OF_2

#define ChipMem_IMQ_Consumer_Index                                hpFieldOffset(ChipMem_t,Lo.IMQ_Consumer_Index)

#define ChipMem_IMQ_Consumer_Index_MASK                           ChipIOLo_IMQ_Consumer_Index_MASK

#define ChipMem_IMQ_Producer_Index_Address                        hpFieldOffset(ChipMem_t,Lo.IMQ_Producer_Index_Address)

#define ChipMem_SEST_Base                                         hpFieldOffset(ChipMem_t,Up.SEST_Base)

#define ChipMem_SEST_Length                                       hpFieldOffset(ChipMem_t,Up.SEST_Length)

#define ChipMem_SEST_Length_MASK                                  ChipIOUp_SEST_Length_MASK
#define ChipMem_SEST_Length_MIN                                   ChipIOUp_SEST_Length_MIN
#define ChipMem_SEST_Length_MAX                                   ChipIOUp_SEST_Length_MAX
#define ChipMem_SEST_Length_POWER_OF_2                            ChipIOUp_SEST_Length_POWER_OF_2

#define ChipMem_SEST_Linked_List_Head_Tail                        hpFieldOffset(ChipMem_t,Up.SEST_Linked_List_Head_Tail)

#define ChipMem_SEST_Linked_List_Head_MASK                        ChipIOUp_SEST_Linked_List_Head_MASK
#define ChipMem_SEST_Linked_List_Head_SHIFT                       ChipIOUp_SEST_Linked_List_Head_SHIFT
#define ChipMem_SEST_Linked_List_Tail_MASK                        ChipIOUp_SEST_Linked_List_Tail_MASK
#define ChipMem_SEST_Linked_List_Tail_SHIFT                       ChipIOUp_SEST_Linked_List_Tail_SHIFT
#define ChipMem_SEST_Linked_List_Tail_RESET_VALUE                 ChipIOUp_SEST_Linked_List_Tail_RESET_VALUE

#define ChipMem_ScatterGather_List_Page_Length                    hpFieldOffset(ChipMem_t,Up.ScatterGather_List_Page_Length)

#define ChipMem_ScatterGather_List_Page_Length_MASK               ChipIOUp_ScatterGather_List_Page_Length_MASK
#define ChipMem_ScatterGather_List_Page_Length_MIN                ChipIOUp_ScatterGather_List_Page_Length_MIN
#define ChipMem_ScatterGather_List_Page_Length_MAX                ChipIOUp_ScatterGather_List_Page_Length_MAX
#define ChipMem_ScatterGather_List_Page_Length_POWER_OF_2         ChipMem_ScatterGather_List_Page_Length_POWER_OF_2

#define ChipMem_My_ID                                             hpFieldOffset(ChipMem_t,Up.My_ID)

#define ChipMem_My_ID_MASK                                        ChipIOUp_My_ID_MASK

#define ChipMem_TachLite_Configuration                            hpFieldOffset(ChipMem_t,Up.TachLite_Configuration)

#define ChipMem_TachLite_Configuration_M66EN                      ChipIOUp_TachLite_Configuration_M66EN
#define ChipMem_TachLite_Configuration_OB_Thresh_MASK             ChipIOUp_TachLite_Configuration_OB_Thresh_MASK
#define ChipMem_TachLite_Configuration_OB_Thresh_100              ChipIOUp_TachLite_Configuration_OB_Thresh_100
#define ChipMem_TachLite_Configuration_OB_Thresh_132              ChipIOUp_TachLite_Configuration_OB_Thresh_132
#define ChipMem_TachLite_Configuration_OB_Thresh_150              ChipIOUp_TachLite_Configuration_OB_Thresh_150
#define ChipMem_TachLite_Configuration_OB_Thresh_200              ChipIOUp_TachLite_Configuration_OB_Thresh_200
#define ChipMem_TachLite_Configuration_OB_Thresh_264              ChipIOUp_TachLite_Configuration_OB_Thresh_264
#define ChipMem_TachLite_Configuration_OB_Thresh_528              ChipIOUp_TachLite_Configuration_OB_Thresh_528

#define ChipMem_Tachlite_Configuration_DAM                        ChipIOUp_TachLite_Configuration_DAM


/* XL only bits in the configuration register defined below */
#define ChipMem_Tachlite_Configuration_RDE                        ChipIOUp_Tachlite_Configuration_RDE
#define ChipMem_Tachlite_Configuration_SDF                        ChipIOUp_Tachlite_Configuration_SDF
#define ChipMem_Tachlite_Configuration_FC2                        ChipIOUp_Tachlite_Configuration_FC2 
#define ChipMem_Tachlite_Configuration_CAE                        ChipIOUp_Tachlite_Configuration_CAE
#define ChipMem_Tachlite_Configuration_SIC                        ChipIOUp_Tachlite_Configuration_SIC
#define ChipMem_Tachlite_Configuration_FAB                        ChipIOUp_Tachlite_Configuration_FAB
#define ChipMem_Tachlite_Configuration_FUA                        ChipIOUp_Tachlite_Configuration_FUA 
#define ChipMem_Tachlite_Configuration_DOF                        ChipIOUp_Tachlite_Configuration_DOF 
#define ChipMem_Tachlite_Configuration_INO                        ChipIOUp_Tachlite_Configuration_INO
#define ChipMem_TachLite_Configuration_SIC                        ChipIOUp_TachLite_Configuration_SIC
#define ChipMem_TachLite_Configuration_FAD                        ChipIOUp_TachLite_Configuration_FAD

#define ChipMem_TachLite_Control                                  hpFieldOffset(ChipMem_t,Up.TachLite_Control)

#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_ROF                              ChipIOUp_TachLite_Control_ROF
#define ChipMem_TachLite_Control_RIF                              ChipIOUp_TachLite_Control_RIF
#define ChipMem_TachLite_Control_REQ                              ChipIOUp_TachLite_Control_REQ
#define ChipMem_TachLite_Control_FIS                              ChipIOUp_TachLite_Control_FIS
#define ChipMem_TachLite_Control_FFA                              ChipIOUp_TachLite_Control_FFA
#define ChipMem_TachLite_Control_FEQ                              ChipIOUp_TachLite_Control_FEQ
#define ChipMem_TachLite_Control_GP4                              ChipIOUp_TachLite_Control_GP4
#define ChipMem_TachLite_Control_GP3                              ChipIOUp_TachLite_Control_GP3
#define ChipMem_TachLite_Control_GP2                              ChipIOUp_TachLite_Control_GP2
#define ChipMem_TachLite_Control_GP1                              ChipIOUp_TachLite_Control_GP1
#define ChipMem_TachLite_Control_GP0                              ChipIOUp_TachLite_Control_GP0
#define ChipMem_TachLite_Control_GPIO_0_3_MASK                    ChipIOUp_TachLite_Control_GPIO_0_3_MASK
#define ChipMem_TachLite_Control_GPIO_ALL_MASK                    ChipIOUp_TachLite_Control_GPIO_ALL_MASK


/* XL only bits in the control register */

#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_ROF                              ChipIOUp_TachLite_Control_ROF
#define ChipMem_TachLite_Control_RIF                              ChipIOUp_TachLite_Control_RIF
#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS


#define ChipMem_TachLite_Status                                   hpFieldOffset(ChipMem_t,Up.TachLite_Status)

#define ChipMem_TachLite_Status_SFF                               ChipIOUp_TachLite_Status_SFF
#define ChipMem_TachLite_Status_IMF                               ChipIOUp_TachLite_Status_IMF
#define ChipMem_TachLite_Status_OFE                               ChipIOUp_TachLite_Status_OFE
#define ChipMem_TachLite_Status_IFE                               ChipIOUp_TachLite_Status_IFE
#define ChipMem_TachLite_Status_OFF                               ChipIOUp_TachLite_Status_OFF
#define ChipMem_TachLite_Status_IFF                               ChipIOUp_TachLite_Status_IFF
#define ChipMem_TachLite_Status_EQF                               ChipIOUp_TachLite_Status_EQF
#define ChipMem_TachLite_Status_Stop_Cnt_MASK                     ChipIOUp_TachLite_Status_Stop_Cnt_MASK
#define ChipMem_TachLite_Status_OPE                               ChipIOUp_TachLite_Status_OPE
#define ChipMem_TachLite_Status_IPE                               ChipIOUp_TachLite_Status_IPE
#define ChipMem_TachLite_Status_REVID_MASK                        ChipIOUp_TachLite_Status_REVID_MASK
#define ChipMem_TachLite_Status_REVID_SHIFT                       ChipIOUp_TachLite_Status_REVID_SHIFT
#define ChipMem_TachLite_Status_GP4                               ChipIOUp_TachLite_Status_GP4
#define ChipMem_TachLite_Status_GP3                               ChipIOUp_TachLite_Status_GP3
#define ChipMem_TachLite_Status_GP2                               ChipIOUp_TachLite_Status_GP2
#define ChipMem_TachLite_Status_GP1                               ChipIOUp_TachLite_Status_GP1
#define ChipMem_TachLite_Status_GP0                               ChipIOUp_TachLite_Status_GP0
#define ChipMem_TachLite_Status_GPIO_0_3_MASK                     ChipIOUp_TachLite_Status_GPIO_0_3_MASK
#define ChipMem_TachLite_Status_GPIO_ALL_MASK                     ChipIOUp_TachLite_Status_GPIO_ALL_MASK
#define ChipMem_TachLite_Status_OLE                               ChipIOUp_TachLite_Status_OLE 
#define ChipMem_TachLite_Status_ILE                               ChipIOUp_TachLite_Status_ILE  
#define ChipMem_TachLite_Status_M66                               ChipIOUp_TachLite_Status_M66   


#define ChipMem_Inbound_Resource_Status                           hpFieldOffset(ChipMem_t,Up.Inbound_Resource_Status)

#define ChipMem_Inbound_Resource_Status_SEST_LRU_Count_MASK       ChipIOUp_Inbound_Resource_Status_SEST_LRU_Count_MASK
#define ChipMem_Inbound_Resource_Status_SEST_LRU_Count_SHIFT      ChipIOUp_Inbound_Resource_Status_SEST_LRU_Count_SHIFT

#define ChipMem_Frame_Manager_Configuration                       hpFieldOffset(ChipMem_t,Up.Frame_Manager_Configuration)

#define ChipMem_Frame_Manager_Configuration_AL_PA_MASK            ChipIOUp_Frame_Manager_Configuration_AL_PA_MASK
#define ChipMem_Frame_Manager_Configuration_AL_PA_SHIFT           ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT
#define ChipMem_Frame_Manager_Configuration_BB_Credit_MASK        ChipIOUp_Frame_Manager_Configuration_BB_Credit_MASK
#define ChipMem_Frame_Manager_Configuration_BB_Credit_SHIFT       ChipIOUp_Frame_Manager_Configuration_BB_Credit_SHIFT
#define ChipMem_Frame_Manager_Configuration_NPI                   ChipIOUp_Frame_Manager_Configuration_NPI
#define ChipMem_Frame_Manager_Configuration_ILB                   ChipIOUp_Frame_Manager_Configuration_ILB
#define ChipMem_Frame_Manager_Configuration_ELB                   ChipIOUp_Frame_Manager_Configuration_ELB
#define ChipMem_Frame_Manager_Configuration_TD                    ChipIOUp_Frame_Manager_Configuration_TD
#define ChipMem_Frame_Manager_Configuration_FA                    ChipIOUp_Frame_Manager_Configuration_FA
#define ChipMem_Frame_Manager_Configuration_AQ                    ChipIOUp_Frame_Manager_Configuration_AQ
#define ChipMem_Frame_Manager_Configuration_HA                    ChipIOUp_Frame_Manager_Configuration_HA
#define ChipMem_Frame_Manager_Configuration_SA                    ChipIOUp_Frame_Manager_Configuration_SA
#define ChipMem_Frame_Manager_Configuration_BLM                   ChipIOUp_Frame_Manager_Configuration_BLM
#define ChipMem_Frame_Manager_Configuration_RF                    ChipIOUp_Frame_Manager_Configuration_RF
#define ChipMem_Frame_Manager_Configuration_IF                    ChipIOUp_Frame_Manager_Configuration_IF
#define ChipMem_Frame_Manager_Configuration_LR                    ChipIOUp_Frame_Manager_Configuration_LR
#define ChipMem_Frame_Manager_Configuration_ENP                   ChipIOUp_Frame_Manager_Configuration_ENP
#define ChipMem_Frame_Manager_Configuration_BLI                   ChipIOUp_Frame_Manager_Configuration_BLI

#define ChipMem_Frame_Manager_Control                             hpFieldOffset(ChipMem_t,Up.Frame_Manager_Control)

#define ChipMem_Frame_Manager_Control_SAS                         ChipIOUp_Frame_Manager_Control_SAS
#define ChipMem_Frame_Manager_Control_SQ                          ChipIOUp_Frame_Manager_Control_SQ
#define ChipMem_Frame_Manager_Control_SP                          ChipIOUp_Frame_Manager_Control_SP
#define ChipMem_Frame_Manager_Control_CL                          ChipIOUp_Frame_Manager_Control_CL
#define ChipMem_Frame_Manager_Control_CMD_MASK                    ChipIOUp_Frame_Manager_Control_CMD_MASK
#define ChipMem_Frame_Manager_Control_CMD_NOP                     ChipIOUp_Frame_Manager_Control_CMD_NOP
#define ChipMem_Frame_Manager_Control_CMD_Exit_Loop               ChipIOUp_Frame_Manager_Control_CMD_Exit_Loop
#define ChipMem_Frame_Manager_Control_CMD_Host_Control            ChipIOUp_Frame_Manager_Control_CMD_Host_Control
#define ChipMem_Frame_Manager_Control_CMD_Exit_Host_Control       ChipIOUp_Frame_Manager_Control_CMD_Exit_Host_Control
#define ChipMem_Frame_Manager_Control_CMD_Link_Reset              ChipIOUp_Frame_Manager_Control_CMD_Link_Reset
#define ChipMem_Frame_Manager_Control_CMD_Offline                 ChipIOUp_Frame_Manager_Control_CMD_Offline
#define ChipMem_Frame_Manager_Control_CMD_Initialize              ChipIOUp_Frame_Manager_Control_CMD_Initialize
#define ChipMem_Frame_Manager_Control_CMD_Clear_LF                ChipIOUp_Frame_Manager_Control_CMD_Clear_LF

#define ChipMem_Frame_Manager_Status                              hpFieldOffset(ChipMem_t,Up.Frame_Manager_Status)

#define ChipMem_Frame_Manager_Status_LP                           ChipIOUp_Frame_Manager_Status_LP
#define ChipMem_Frame_Manager_Status_TP                           ChipIOUp_Frame_Manager_Status_TP
#define ChipMem_Frame_Manager_Status_NP                           ChipIOUp_Frame_Manager_Status_NP
#define ChipMem_Frame_Manager_Status_BYP                          ChipIOUp_Frame_Manager_Status_BYP
#define ChipMem_Frame_Manager_Status_FLT                          ChipIOUp_Frame_Manager_Status_FLT
#define ChipMem_Frame_Manager_Status_OS                           ChipIOUp_Frame_Manager_Status_OS
#define ChipMem_Frame_Manager_Status_LS                           ChipIOUp_Frame_Manager_Status_LS
#define ChipMem_Frame_Manager_Status_LPE                          ChipIOUp_Frame_Manager_Status_LPE
#define ChipMem_Frame_Manager_Status_LPB                          ChipIOUp_Frame_Manager_Status_LPB
#define ChipMem_Frame_Manager_Status_OLS                          ChipIOUp_Frame_Manager_Status_OLS
#define ChipMem_Frame_Manager_Status_LST                          ChipIOUp_Frame_Manager_Status_LST
#define ChipMem_Frame_Manager_Status_LPF                          ChipIOUp_Frame_Manager_Status_LPF
#define ChipMem_Frame_Manager_Status_BA                           ChipIOUp_Frame_Manager_Status_BA
#define ChipMem_Frame_Manager_Status_PRX                          ChipIOUp_Frame_Manager_Status_PRX
#define ChipMem_Frame_Manager_Status_PTX                          ChipIOUp_Frame_Manager_Status_PTX
#define ChipMem_Frame_Manager_Status_LG                           ChipIOUp_Frame_Manager_Status_LG
#define ChipMem_Frame_Manager_Status_LF                           ChipIOUp_Frame_Manager_Status_LF
#define ChipMem_Frame_Manager_Status_CE                           ChipIOUp_Frame_Manager_Status_CE
#define ChipMem_Frame_Manager_Status_EW                           ChipIOUp_Frame_Manager_Status_EW
#define ChipMem_Frame_Manager_Status_LUP                          ChipIOUp_Frame_Manager_Status_LUP
#define ChipMem_Frame_Manager_Status_LDN                          ChipIOUp_Frame_Manager_Status_LDN
#define ChipMem_Frame_Manager_Status_LSM_MASK                     ChipIOUp_Frame_Manager_Status_LSM_MASK
#define ChipMem_Frame_Manager_Status_LSM_Monitor                  ChipIOUp_Frame_Manager_Status_LSM_Monitor
#define ChipMem_Frame_Manager_Status_LSM_ARB                      ChipIOUp_Frame_Manager_Status_LSM_ARB
#define ChipMem_Frame_Manager_Status_LSM_ARB_Won                  ChipIOUp_Frame_Manager_Status_LSM_ARB_Won
#define ChipMem_Frame_Manager_Status_LSM_Open                     ChipIOUp_Frame_Manager_Status_LSM_Open
#define ChipMem_Frame_Manager_Status_LSM_Opened                   ChipIOUp_Frame_Manager_Status_LSM_Opened
#define ChipMem_Frame_Manager_Status_LSM_Xmit_CLS                 ChipIOUp_Frame_Manager_Status_LSM_Xmit_CLS
#define ChipMem_Frame_Manager_Status_LSM_Rx_CLS                   ChipIOUp_Frame_Manager_Status_LSM_Rx_CLS
#define ChipMem_Frame_Manager_Status_LSM_Xfer                     ChipIOUp_Frame_Manager_Status_LSM_Xfer
#define ChipMem_Frame_Manager_Status_LSM_Initialize               ChipIOUp_Frame_Manager_Status_LSM_Initialize
#define ChipMem_Frame_Manager_Status_LSM_O_I_Init_Finish          ChipIOUp_Frame_Manager_Status_LSM_O_I_Init_Finish
#define ChipMem_Frame_Manager_Status_LSM_O_I_Protocol             ChipIOUp_Frame_Manager_Status_LSM_O_I_Protocol
#define ChipMem_Frame_Manager_Status_LSM_O_I_Lip_Received         ChipIOUp_Frame_Manager_Status_LSM_O_I_Lip_Received
#define ChipMem_Frame_Manager_Status_LSM_Host_Control             ChipIOUp_Frame_Manager_Status_LSM_Host_Control
#define ChipMem_Frame_Manager_Status_LSM_Loop_Fail                ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail
#define ChipMem_Frame_Manager_Status_LSM_Offline                  ChipIOUp_Frame_Manager_Status_LSM_Offline
#define ChipMem_Frame_Manager_Status_LSM_Old_Port                 ChipIOUp_Frame_Manager_Status_LSM_Old_Port
#define ChipMem_Frame_Manager_Status_PSM_MASK                     ChipIOUp_Frame_Manager_Status_PSM_MASK
#define ChipMem_Frame_Manager_Status_PSM_Offline                  ChipIOUp_Frame_Manager_Status_PSM_Offline
#define ChipMem_Frame_Manager_Status_PSM_OL1                      ChipIOUp_Frame_Manager_Status_PSM_OL1
#define ChipMem_Frame_Manager_Status_PSM_OL2                      ChipIOUp_Frame_Manager_Status_PSM_OL2
#define ChipMem_Frame_Manager_Status_PSM_OL3                      ChipIOUp_Frame_Manager_Status_PSM_OL3
#define ChipMem_Frame_Manager_Status_PSM_Reserved_1               ChipIOUp_Frame_Manager_Status_PSM_Reserved_1
#define ChipMem_Frame_Manager_Status_PSM_LR1                      ChipIOUp_Frame_Manager_Status_PSM_LR1
#define ChipMem_Frame_Manager_Status_PSM_LR2                      ChipIOUp_Frame_Manager_Status_PSM_LR2
#define ChipMem_Frame_Manager_Status_PSM_LR3                      ChipIOUp_Frame_Manager_Status_PSM_LR3
#define ChipMem_Frame_Manager_Status_PSM_Reserved_2               ChipIOUp_Frame_Manager_Status_PSM_Reserved_2
#define ChipMem_Frame_Manager_Status_PSM_LF1                      ChipIOUp_Frame_Manager_Status_PSM_LF1
#define ChipMem_Frame_Manager_Status_PSM_LF2                      ChipIOUp_Frame_Manager_Status_PSM_LF2
#define ChipMem_Frame_Manager_Status_PSM_Reserved_3               ChipIOUp_Frame_Manager_Status_PSM_Reserved_3
#define ChipMem_Frame_Manager_Status_PSM_Reserved_4               ChipIOUp_Frame_Manager_Status_PSM_Reserved_4
#define ChipMem_Frame_Manager_Status_PSM_Reserved_5               ChipIOUp_Frame_Manager_Status_PSM_Reserved_5
#define ChipMem_Frame_Manager_Status_PSM_Reserved_6               ChipIOUp_Frame_Manager_Status_PSM_Reserved_6
#define ChipMem_Frame_Manager_Status_PSM_ACTIVE                   ChipIOUp_Frame_Manager_Status_PSM_ACTIVE

#define ChipMem_Frame_Manager_TimeOut_Values_1                    hpFieldOffset(ChipMem_t,Up.Frame_Manager_TimeOut_Values_1)

#define ChipMem_Frame_Manager_TimeOut_Values_1_RT_TOV_MASK        ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_MASK
#define ChipMem_Frame_Manager_TimeOut_Values_1_RT_TOV_SHIFT       ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_SHIFT
#define ChipMem_Frame_Manager_TimeOut_Values_1_RT_TOV_100ms       ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_100ms
#define ChipMem_Frame_Manager_TimeOut_Values_1_RT_TOV_Default     ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_Default
#define ChipMem_Frame_Manager_TimeOut_Values_1_ED_TOV_MASK        ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_MASK
#define ChipMem_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT       ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT
#define ChipMem_Frame_Manager_TimeOut_Values_1_ED_TOV_500ms       ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_500ms
#define ChipMem_Frame_Manager_TimeOut_Values_1_ED_TOV_Default     ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_Default

#define ChipMem_Frame_Manager_Link_Status_1                       hpFieldOffset(ChipMem_t,Up.Frame_Manager_Link_Status_1)

#define ChipMem_Frame_Manager_Link_Status_1_Loss_of_Signal_MASK   ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_MASK
#define ChipMem_Frame_Manager_Link_Status_1_Loss_of_Signal_SHIFT  ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_SHIFT
#define ChipMem_Frame_Manager_Link_Status_1_Bad_RX_Char_MASK      ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_MASK
#define ChipMem_Frame_Manager_Link_Status_1_Bad_RX_Char_SHIFT     ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_SHIFT
#define ChipMem_Frame_Manager_Link_Status_1_Loss_of_Sync_MASK     ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_MASK
#define ChipMem_Frame_Manager_Link_Status_1_Loss_of_Sync_SHIFT    ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_SHIFT
#define ChipMem_Frame_Manager_Link_Status_1_Link_Fail_MASK        ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_MASK
#define ChipMem_Frame_Manager_Link_Status_1_Link_Fail_SHIFT       ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_SHIFT

#define ChipMem_Frame_Manager_Link_Status_2                       hpFieldOffset(ChipMem_t,Up.Frame_Manager_Link_Status_2)

#define ChipMem_Frame_Manager_Link_Status_2_Rx_EOFa_MASK          ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_MASK
#define ChipMem_Frame_Manager_Link_Status_2_Rx_EOFa_SHIFT         ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_SHIFT
#define ChipMem_Frame_Manager_Link_Status_2_Dis_Frm_MASK          ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_MASK
#define ChipMem_Frame_Manager_Link_Status_2_Dis_Frm_SHIFT         ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_SHIFT
#define ChipMem_Frame_Manager_Link_Status_2_Bad_CRC_MASK          ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_MASK
#define ChipMem_Frame_Manager_Link_Status_2_Bad_CRC_SHIFT         ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_SHIFT
#define ChipMem_Frame_Manager_Link_Status_2_Proto_Err_MASK        ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_MASK
#define ChipMem_Frame_Manager_Link_Status_2_Proto_Err_SHIFT       ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_SHIFT

#define ChipMem_Frame_Manager_TimeOut_Values_2                    hpFieldOffset(ChipMem_t,Up.Frame_Manager_TimeOut_Values_2)

#define ChipMem_Frame_Manager_TimeOut_Values_2_LP_TOV_MASK        ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_MASK
#define ChipMem_Frame_Manager_TimeOut_Values_2_LP_TOV_SHIFT       ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_SHIFT
#define ChipMem_Frame_Manager_TimeOut_Values_2_LP_TOV_2s          ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_2s
#define ChipMem_Frame_Manager_TimeOut_Values_2_LP_TOV_Default     ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_Default
#define ChipMem_Frame_Manager_TimeOut_Values_2_AL_Time_MASK       ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_MASK
#define ChipMem_Frame_Manager_TimeOut_Values_2_AL_Time_SHIFT      ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_SHIFT
#define ChipMem_Frame_Manager_TimeOut_Values_2_AL_Time_15ms       ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_15ms
#define ChipMem_Frame_Manager_TimeOut_Values_2_AL_Time_Default    ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_Default

#define ChipMem_Frame_Manager_BBCredit_Zero_Timer                 hpFieldOffset(ChipMem_t,Up.Frame_Manager_BBCredit_Zero_Timer)

#define ChipMem_Frame_Manager_BBCredit_Zero_Timer_MASK            ChipIOUp_Frame_Manager_BBCredit_Zero_Timer_MASK

#define ChipMem_Frame_Manager_World_Wide_Name_High                hpFieldOffset(ChipMem_t,Up.Frame_Manager_World_Wide_Name_High)

#define ChipMem_Frame_Manager_World_Wide_Name_Low                 hpFieldOffset(ChipMem_t,Up.Frame_Manager_World_Wide_Name_Low)

#define ChipMem_Frame_Manager_Received_ALPA                       hpFieldOffset(ChipMem_t,Up.Frame_Manager_Received_ALPA)

#define ChipMem_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK         ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK
#define ChipMem_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT        ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT
#define ChipMem_Frame_Manager_Received_ALPA_Bad_ALPA_MASK         ChipIOUp_Frame_Manager_Received_ALPA_Bad_ALPA_MASK
#define ChipMem_Frame_Manager_Received_ALPA_Bad_ALPA_SHIFT        ChipIOUp_Frame_Manager_Received_ALPA_Bad_ALPA_SHIFT
#define ChipMem_Frame_Manager_Received_ALPA_LIPf_ALPA_MASK        ChipIOUp_Frame_Manager_Received_ALPA_LIPf_ALPA_MASK
#define ChipMem_Frame_Manager_Received_ALPA_LIPf_ALPA_SHIFT       ChipIOUp_Frame_Manager_Received_ALPA_LIPf_ALPA_SHIFT

#define ChipMem_Frame_Manager_Primitive                           hpFieldOffset(ChipMem_t,Up.Frame_Manager_Primitive)

#define ChipMem_Frame_Manager_Primitive_MASK                      ChipIOUp_Frame_Manager_Primitive_MASK

#define ChipMem_PCIMCTR__ROMCTR__Reserved_8__Reserved_9           hpFieldOffset(ChipMem_t,Up.PCIMCTR__ROMCTR__Reserved_8__Reserved_9)

#define ChipMem_PCIMCTR_MASK                                      ChipIOUp_PCIMCTR_MASK
#define ChipMem_PCIMCTL_P64                                       ChipIOUp_PCIMCTL_P64

#define ChipMem_ROMCTR_MASK                                       ChipIOUp_ROMCTR_MASK
#define ChipMem_ROMCTR_PAR                                        ChipIOUp_ROMCTR_PAR
#define ChipMem_ROMCTR_SVL                                        ChipIOUp_ROMCTR_SVL
#define ChipMem_ROMCTR_256                                        ChipIOUp_ROMCTR_256
#define ChipMem_ROMCTR_128                                        ChipIOUp_ROMCTR_128
#define ChipMem_ROMCTR_ROM                                        ChipIOUp_ROMCTR_ROM
#define ChipMem_ROMCTR_FLA                                        ChipIOUp_ROMCTR_FLA
#define ChipMem_ROMCTR_VPP                                        ChipIOUp_ROMCTR_VPP

#define ChipMem_INTSTAT_INTEN_INTPEND_SOFTRST                     hpFieldOffset(ChipMem_t,Up.INTSTAT_INTEN_INTPEND_SOFTRST)

#define ChipMem_INTSTAT_MASK                                      ChipIOUp_INTSTAT_MASK
#define ChipMem_INTSTAT_Reserved                                  ChipIOUp_INTSTAT_Reserved
#define ChipMem_INTSTAT_MPE                                       ChipIOUp_INTSTAT_MPE
#define ChipMem_INTSTAT_CRS                                       ChipIOUp_INTSTAT_CRS
#define ChipMem_INTSTAT_INT                                       ChipIOUp_INTSTAT_INT
#define ChipMem_INTSTAT_DER                                       ChipIOUp_INTSTAT_DER
#define ChipMem_INTSTAT_PER                                       ChipIOUp_INTSTAT_PER

#define ChipMem_INTEN_MASK                                        ChipIOUp_INTEN_MASK
#define ChipMem_INTEN_Reserved                                    ChipIOUp_INTEN_Reserved
#define ChipMem_INTEN_MPE                                         ChipIOUp_INTEN_MPE
#define ChipMem_INTEN_CRS                                         ChipIOUp_INTEN_CRS
#define ChipMem_INTEN_INT                                         ChipIOUp_INTEN_INT
#define ChipMem_INTEN_DER                                         ChipIOUp_INTEN_DER
#define ChipMem_INTEN_PER                                         ChipIOUp_INTEN_PER

#define ChipMem_INTPEND_MASK                                      ChipIOUp_INTPEND_MASK
#define ChipMem_INTPEND_Reserved                                  ChipIOUp_INTPEND_Reserved
#define ChipMem_INTPEND_MPE                                       ChipIOUp_INTPEND_MPE
#define ChipMem_INTPEND_CRS                                       ChipIOUp_INTPEND_CRS
#define ChipMem_INTPEND_INT                                       ChipIOUp_INTPEND_INT
#define ChipMem_INTPEND_DER                                       ChipIOUp_INTPEND_DER
#define ChipMem_INTPEND_PER                                       ChipIOUp_INTPEND_PER

#define ChipMem_SOFTRST_MASK                                      ChipIOUp_SOFTRST_MASK
#define ChipMem_SOFTRST_Reserved                                  ChipIOUp_SOFTRST_Reserved
#define ChipMem_SOFTRST_DPE                                       ChipIOUp_SOFTRST_DPE
#define ChipMem_SOFTRST_RST                                       ChipIOUp_SOFTRST_RST

/*+
ERQ Producer/Consumer Index Types
-*/

typedef os_bit32 ERQProdIndex_t;
typedef os_bit32 ERQConsIndex_t;

#define ERQProdIndex_t_SIZE                                0x00000004
#define ERQConsIndex_t_SIZE                                0x00000004

/*+
IMQ Producer/Consumer Index Types
-*/

typedef os_bit32 IMQProdIndex_t;
typedef os_bit32 IMQConsIndex_t;

#define IMQProdIndex_t_SIZE                                0x00000004
#define IMQConsIndex_t_SIZE                                0x00000004

/*+
SFQ Producer/Consumer Index Types
-*/

typedef os_bit32 SFQProdIndex_t;
typedef os_bit32 SFQConsIndex_t;

#define SFQProdIndex_t_SIZE                                0x00000004
#define SFQConsIndex_t_SIZE                                0x00000004

/*+
Configuration Parameters
-*/

#define TachyonXL_Max_Frame_Payload           0x0800
#define TachyonTL_Max_Frame_Payload           0x3F0  /* 0x0400 */
#define TachyonTL_BB_Credit                     0x00
#define TachyonTL_Nport_BB_Credit               0x04
#define TachyonTL_Total_Concurrent_Sequences    0xFF
#define TachyonTL_Open_Sequences_per_Exchange 0x0001
#define TachyonTL_RO_Valid_by_Category        ( FC_N_Port_Common_Parms_RO_Valid_for_Category_0111 | \
                                                FC_N_Port_Common_Parms_RO_Valid_for_Category_0110 | \
                                                FC_N_Port_Common_Parms_RO_Valid_for_Category_0101 | \
                                                FC_N_Port_Common_Parms_RO_Valid_for_Category_0100 | \
                                                FC_N_Port_Common_Parms_RO_Valid_for_Category_0011 | \
                                                FC_N_Port_Common_Parms_RO_Valid_for_Category_0010 | \
                                                FC_N_Port_Common_Parms_RO_Valid_for_Category_0001 )


/*+
Fibre Channel Header Structure (FCHS)
-*/

typedef struct FCHS_s
               FCHS_t;

#define FCHS_t_SIZE                                        0x00000020

struct FCHS_s
       {
         os_bit32 MBZ1;
         os_bit32 SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp;
         os_bit32 R_CTL__D_ID;
         os_bit32 CS_CTL__S_ID;
         os_bit32 TYPE__F_CTL;
         os_bit32 SEQ_ID__DF_CTL__SEQ_CNT;
         os_bit32 OX_ID__RX_ID;
         os_bit32 RO;
       };

#define FCHS_SOF_MASK        0xF0000000
#define FCHS_SOF_SOFc1       0x30000000
#define FCHS_SOF_SOFi1       0x50000000
#define FCHS_SOF_SOFi2       0x60000000
#define FCHS_SOF_SOFi3       0x70000000
#define FCHS_SOF_SOFt        0x80000000
#define FCHS_SOF_SOFn1       0x90000000
#define FCHS_SOF_SOFn2       0xA0000000
#define FCHS_SOF_SOFn3       0xB0000000

#define FCHS_EOF_MASK        0x0F000000
#define FCHS_EOF_EOFdt       0x01000000
#define FCHS_EOF_EOFdti      0x02000000
#define FCHS_EOF_EOFni       0x03000000
#define FCHS_EOF_EOFa        0x04000000
#define FCHS_EOF_EOFn        0x05000000
#define FCHS_EOF_EOFt        0x06000000

#define FCHS_MBZ2_MASK       0x00FF8000

#define FCHS_UAM             0x00004000

#define FCHS_CLS             0x00002000

#define FCHS_LCr_MASK        0x00001C00
#define FCHS_LCr_SHIFT             0x0A

#define FCHS_MBZ3_MASK       0x00000200

#define FCHS_TFV             0x00000100

#define FCHS_Timestamp_MASK  0x000000FF
#define FCHS_Timestamp_SHIFT       0x00

#define FCHS_R_CTL_MASK      0xFF000000
#define FCHS_R_CTL_SHIFT           0x18

#define FCHS_D_ID_MASK       0x00FFFFFF
#define FCHS_D_ID_SHIFT            0x00

#define FCHS_CS_CTL_MASK     0xFF000000
#define FCHS_CS_CTL_SHIFT          0x18

#define FCHS_S_ID_MASK       0x00FFFFFF
#define FCHS_S_ID_SHIFT            0x00

#define FCHS_TYPE_MASK       0xFF000000
#define FCHS_TYPE_SHIFT            0x18

#define FCHS_F_CTL_MASK      0x00FFFFFF
#define FCHS_F_CTL_SHIFT           0x00

#define FCHS_SEQ_ID_MASK     0xFF000000
#define FCHS_SEQ_ID_SHIFT          0x18

#define FCHS_DF_CTL_MASK     0x00FF0000
#define FCHS_DF_CTL_SHIFT          0x10

#define FCHS_SEQ_CNT_MASK    0x0000FFFF
#define FCHS_SEQ_CNT_SHIFT         0x00

#define FCHS_OX_ID_MASK      0xFFFF0000
#define FCHS_OX_ID_SHIFT           0x10

#define FCHS_RX_ID_MASK      0x0000FFFF
#define FCHS_RX_ID_SHIFT           0x00

/*+
ExchangeID type (OX_ID or RX_ID)
-*/

#define X_ID_Invalid        0xFFFF
#define X_ID_ReadWrite_MASK 0x8000
#define X_ID_Read           0x8000
#define X_ID_Write          0x0000

typedef os_bit16 X_ID_t;

#define X_ID_t_SIZE                                        0x00000002

/*+
Scatter-Gather List Element (Local or Extended)
-*/

typedef struct SG_Element_s
               SG_Element_t;

#define SG_Element_t_SIZE                                  0x00000008

struct SG_Element_s
       {
         os_bit32 U32_Len;
         os_bit32 L32;
       };

#define SG_Element_U32_MASK       0xFFF80000
#define SG_Element_U32_SHIFT            0x13

#define SG_Element_Len_MASK       0x0007FFFF
#define SG_Element_Len_SHIFT            0x00
#define SG_Element_Len_MAX        0x0007FFF0

#define SG_Element_Chain_Res_MASK 0x80000000

/*+
Unknown SEST Entry ("USE")
-*/

typedef struct USE_s
               USE_t;

#define USE_t_SIZE                                         0x00000040

struct USE_s
       {
         os_bit32        Bits;
         os_bit32        Unused_DWord_1;
         os_bit32        Unused_DWord_2;
         os_bit32        Unused_DWord_3;
         os_bit32        LOC;
         os_bit32        Unused_DWord_5;
         os_bit32        Unused_DWord_6;
         os_bit32        Unused_DWord_7;
         os_bit32        Unused_DWord_8;
         os_bit32        Unused_DWord_9;
         SG_Element_t First_SG;
         SG_Element_t Second_SG;
         SG_Element_t Third_SG;
       };

#define USE_VAL                 0x80000000

#define USE_DIR                 0x40000000

#define USE_INI                 0x08000000

#define USE_Entry_Type_MASK     (USE_DIR | USE_INI)
#define USE_Entry_Type_IWE      USE_INI
#define USE_Entry_Type_IRE      (USE_DIR | USE_INI)
#define USE_Entry_Type_TWE      USE_DIR
#define USE_Entry_Type_TRE      0

#define USE_LOC                 0x80000000

#define USE_First_SG_Offset     (hpFieldOffset(USE_t,First_SG))

#define USE_Number_of_Local_SGs ((sizeof(USE_t) - USE_First_SG_Offset)/sizeof(SG_Element_t))

/*+
Initiator Write Entry (IWE)
-*/

typedef struct IWE_s
               IWE_t;

#define IWE_t_SIZE                                         0x00000040

struct IWE_s
       {
         os_bit32        Bits__MBZ1__LNK__MBZ2__FL__MBZ3__Hdr_Len;
         os_bit32        Hdr_Addr;
         os_bit32        Remote_Node_ID__RSP_Len;
         os_bit32        RSP_Addr;
         os_bit32        LOC__0xF__MBZ4__Buff_Off;
         os_bit32        Buff_Index__Link;
         os_bit32        MBZ5__RX_ID;
         os_bit32        Data_Len;
         os_bit32        Exp_RO;
         os_bit32        Exp_Byte_Cnt;
         SG_Element_t First_SG;
         SG_Element_t Second_SG;
         SG_Element_t Third_SG;
       };

#define IWE_VAL                  0x80000000

#define IWE_DIR                  0x40000000

#define IWE_DCM                  0x20000000

#define IWE_DIN                  0x10000000

#define IWE_INI                  0x08000000

#define IWE_DAT                  0x04000000

#define IWE_RSP                  0x02000000

#define IWE_CTS                  0x01000000

#define IWE_DUR                  0x00800000

#define IWE_MBZ1_MASK            0x00600000

#define IWE_LNK                  0x00100000

#define IWE_MBZ2_MASK            0x000C0000

#define IWE_FL_MASK              0x00030000
#define IWE_FL_128_Bytes         0x00000000
#define IWE_FL_512_Bytes         0x00010000
#define IWE_FL_1024_Bytes        0x00020000
#define IWE_FL_2048_Bytes        0x00030000

#define IWE_MBZ3_MASK            0x0000F000

#define IWE_Hdr_Len_MASK         0x00000FFF
#define IWE_Hdr_Len_SHIFT              0x00

#define IWE_Remote_Node_ID_MASK  0xFFFFFF00
#define IWE_Remote_Node_ID_SHIFT       0x08

#define IWE_RSP_Len_MASK         0x000000FF
#define IWE_RSP_Len_SHIFT              0x00

#define IWE_LOC                  0x80000000

#define IWE_0xF_MASK             0x78000000
#define IWE_0xF_ALWAYS           0x78000000

#define IWE_MBZ4_MASK            0x07F80000

#define IWE_Buff_Off_MASK        0x0007FFFF
#define IWE_Buff_Off_SHIFT             0x00

#define IWE_Buff_Index_MASK      0xFFFF0000
#define IWE_Buff_Index_SHIFT           0x10

#define IWE_Link_MASK            0x0000FFFF
#define IWE_Link_SHIFT                 0x00
#define IWE_Link_Initializer     0x0000FFFF

#define IWE_MBZ5_MASK            0xFFFF0000

#define IWE_RX_ID_MASK           0x0000FFFF
#define IWE_RX_ID_SHIFT                0x00

/*+
Initiator Read Entry (IRE)
-*/

typedef struct IRE_s
               IRE_t;

#define IRE_t_SIZE                                         0x00000040

struct IRE_s
       {
         os_bit32        Bits_MBZ1_EQL_MBZ2;
         os_bit32        MBZ3;
         os_bit32        Remote_Node_ID__RSP_Len;
         os_bit32        RSP_Addr;
         os_bit32        LOC__MBZ4__Buff_Off;
         os_bit32        Buff_Index__MBZ5;
         os_bit32        Exp_RO;
         os_bit32        Byte_Count;
         os_bit32        MBZ6;
         os_bit32        Exp_Byte_Cnt;
         SG_Element_t First_SG;
         SG_Element_t Second_SG;
         SG_Element_t Third_SG;
       };

#define IRE_VAL                  0x80000000

#define IRE_DIR                  0x40000000

#define IRE_DCM                  0x20000000

#define IRE_DIN                  0x10000000

#define IRE_INI                  0x08000000

#define IRE_DAT                  0x04000000

#define IRE_RSP                  0x02000000

#define IRE_MBZ1_MASK            0x01F00000

#define IRE_EQL                  0x00080000

#define IRE_MBZ2_MASK            0x0007FFFF

#define IRE_Remote_Node_ID_MASK  0xFFFFFF00
#define IRE_Remote_Node_ID_SHIFT       0x08

#define IRE_RSP_Len_MASK         0x000000FF
#define IRE_RSP_Len_SHIFT              0x00

#define IRE_LOC                  0x80000000

#define IRE_MBZ4_MASK            0x7FF80000

#define IRE_Buff_Off_MASK        0x0007FFFF
#define IRE_Buff_Off_SHIFT             0x00

#define IRE_Buff_Index_MASK      0xFFFF0000
#define IRE_Buff_Index_SHIFT           0x10

#define IRE_MBZ5_MASK            0x0000FFFF

/*+
Target Write Entry (TWE)
-*/

typedef struct TWE_s
               TWE_t;

#define TWE_t_SIZE                                         0x00000040

struct TWE_s
       {
         os_bit32        Bits_MBZ1;
         os_bit32        MBZ2;
         os_bit32        Remote_Node_ID__MBZ3;
         os_bit32        MBZ4;
         os_bit32        LOC__MBZ5__Buff_Off;
         os_bit32        Buff_Index__MBZ6;
         os_bit32        Exp_RO;
         os_bit32        Byte_Count;
         os_bit32        MBZ7;
         os_bit32        Exp_Byte_Cnt;
         SG_Element_t First_SG;
         SG_Element_t Second_SG;
         SG_Element_t Third_SG;
       };

#define TWE_VAL                  0x80000000

#define TWE_DIR                  0x40000000

#define TWE_DCM                  0x20000000

#define TWE_DIN                  0x10000000

#define TWE_INI                  0x08000000

#define TWE_DAT                  0x04000000

#define TWE_MBZ1_MASK            0x03FFFFFF

#define TWE_Remote_Node_ID_MASK  0xFFFFFF00
#define TWE_Remote_Node_ID_SHIFT       0x08

#define TWE_MBZ3_MASK            0x000000FF

#define TWE_LOC                  0x80000000

#define TWE_MBZ5_MASK            0x7FF80000

#define TWE_Buff_Off_MASK        0x0007FFFF
#define TWE_Buff_Off_SHIFT             0x00

#define TWE_Buff_Index_MASK      0xFFFF0000
#define TWE_Buff_Index_SHIFT           0x10

#define TWE_MBZ6_MASK            0x0000FFFF

/*+
Target Read Entry (TRE)
-*/

typedef struct TRE_s
               TRE_t;

#define TRE_t_SIZE                                         0x00000040

struct TRE_s
       {
         os_bit32        Bits__MBZ1__FL__MBZ2__Hdr_Len;
         os_bit32        Hdr_Addr;
         os_bit32        Remote_Node_ID__RSP_Len;
         os_bit32        RSP_Addr;
         os_bit32        LOC__0xF__MBZ3__Buff_Off;
         os_bit32        Buff_Index__MBZ4;
         os_bit32        MBZ5;
         os_bit32        Data_Len;
         os_bit32        MBZ6;
         os_bit32        MBZ7;
         SG_Element_t First_SG;
         SG_Element_t Second_SG;
         SG_Element_t Third_SG;
       };

#define TRE_VAL                  0x80000000

#define TRE_DIR                  0x40000000

#define TRE_DCM                  0x20000000

#define TRE_DIN                  0x10000000

#define TRE_INI                  0x08000000

#define TRE_DAT                  0x04000000

#define TRE_RSP                  0x02000000

#define TRE_CTS                  0x01000000

#define TRE_MBZ1_MASK            0x00FC0000

#define TRE_FL_MASK              0x00030000
#define TRE_FL_128_Bytes         0x00000000
#define TRE_FL_512_Bytes         0x00010000
#define TRE_FL_1024_Bytes        0x00020000

#define TRE_MBZ2_MASK            0x0000F000

#define TRE_Hdr_Len_MASK         0x00000FFF
#define TRE_Hdr_Len_SHIFT              0x00

#define TRE_Remote_Node_ID_MASK  0xFFFFFF00
#define TRE_Remote_Node_ID_SHIFT       0x08

#define TRE_RSP_Len_MASK         0x000000FF
#define TRE_RSP_Len_SHIFT              0x00

#define TRE_LOC                  0x80000000

#define TRE_0xF_MASK             0x78000000
#define TRE_0xF_ALWAYS           0x78000000

#define TRE_MBZ3_MASK            0x07F80000

#define TRE_Buff_Off_MASK        0x0007FFFF
#define TRE_Buff_Off_SHIFT             0x00

#define TRE_Buff_Index_MASK      0xFFFF0000
#define TRE_Buff_Index_SHIFT           0x10

#define TRE_MBZ4_MASK            0x0000FFFF

/*+
SCSI Exchange State Table (SEST) Entry
-*/

typedef union SEST_u
              SEST_t;

#define SEST_t_SIZE                                        0x00000040

union SEST_u
      {
        USE_t USE;
        IWE_t IWE;
        IRE_t IRE;
        TWE_t TWE;
        TRE_t TRE;
      };

/*+
I/O Request Block (IRB) - Exchange Request Queue (ERQ) Entry
-*/

typedef struct IRB_Part_s
               IRB_Part_t;

#define IRB_Part_t_SIZE                                    0x00000010

struct IRB_Part_s
       {
         os_bit32 Bits__SFS_Len;
         os_bit32 SFS_Addr;
         os_bit32 D_ID;
         os_bit32 MBZ__SEST_Index__Trans_ID;
       };

#define IRB_SBV              0x80000000

#define IRB_CTS              0x40000000

#define IRB_DCM              0x20000000

#define IRB_DIN              0x10000000

#define IRB_DNC              0x08000000

#define IRB_SFA              0x04000000

#define IRB_BRD              0x01000000

#define IRB_SFS_Len_MASK     0x00000FFF
#define IRB_SFS_Len_SHIFT          0x00

#define IRB_D_ID_MASK        0xFFFFFF00
#define IRB_D_ID_SHIFT             0x08

#define IRB_MBZ_MASK         0xFFFF8000

#define IRB_SEST_Index_MASK  0x00007FFF
#define IRB_SEST_Index_SHIFT       0x00

#define IRB_Trans_ID_MASK    0x00007FFF
#define IRB_Trans_ID_SHIFT         0x00

typedef struct IRB_s
               IRB_t;

#define IRB_t_SIZE                                         0x00000020

struct IRB_s
       {
         IRB_Part_t Req_A;
         IRB_Part_t Req_B;
       };

/*+
Unknown Completion Message
-*/

typedef struct CM_Unknown_s
               CM_Unknown_t;

#define CM_Unknown_t_SIZE                                  0x00000020

struct CM_Unknown_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 Unused_DWord_1;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Unknown_INT                               0x00000100

#define CM_Unknown_CM_Type_MASK                      0x000000FF
#define CM_Unknown_CM_Type_Outbound                  0x00000000
#define CM_Unknown_CM_Type_Error_Idle                0x00000001
#define CM_Unknown_CM_Type_Inbound                   0x00000004
#define CM_Unknown_CM_Type_ERQ_Frozen                0x00000006
#define CM_Unknown_CM_Type_FCP_Assists_Frozen        0x00000007
#define CM_Unknown_CM_Type_Frame_Manager             0x0000000A
#define CM_Unknown_CM_Type_Inbound_FCP_Exchange      0x0000000C
#define CM_Unknown_CM_Type_Class_2_Frame_Header      0x0000000D
#define CM_Unknown_CM_Type_Class_2_Sequence_Received 0x0000000E

#define CM_Unknown_CM_Type_InvalidType               0x00000002

/*+
Outbound Completion Message
-*/

typedef struct CM_Outbound_s
               CM_Outbound_t;

#define CM_Outbound_t_SIZE                                 0x00000020

struct CM_Outbound_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 SEQ_CNT__RX_ID;
         os_bit32 Bits__SEST_Index__Trans_ID;
         os_bit32 More_Bits;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Outbound_INT              0x00000100

#define CM_Outbound_CM_Type_MASK     0x000000FF

#define CM_Outbound_SEQ_CNT_MASK     0xFFFF0000
#define CM_Outbound_SEQ_CNT_SHIFT          0x10

#define CM_Outbound_RX_ID_MASK       0x0000FFFF
#define CM_Outbound_RX_ID_SHIFT            0x00

#define CM_Outbound_SPC              0x80000000

#define CM_Outbound_DPC              0x40000000

#define CM_Outbound_RPC              0x20000000

#define CM_Outbound_SPE              0x10000000

#define CM_Outbound_SEST_Index_MASK  0x00007FFF
#define CM_Outbound_SEST_Index_SHIFT       0x00

#define CM_Outbound_Trans_ID_MASK    0x00007FFF
#define CM_Outbound_Trans_ID_SHIFT         0x00

#define CM_Outbound_INV              0x40000000

#define CM_Outbound_FTO              0x20000000

#define CM_Outbound_HPE              0x10000000

#define CM_Outbound_LKF              0x08000000

#define CM_Outbound_ASN              0x02000000

/*+
Error Idle Completion Message
-*/

typedef struct CM_Error_Idle_s
               CM_Error_Idle_t;

#define CM_Error_Idle_t_SIZE                               0x00000020

struct CM_Error_Idle_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 Unused_DWord_1;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Error_Idle_INT          0x00000100

#define CM_Error_Idle_CM_Type_MASK 0x000000FF

/*+
Inbound Completion Message
-*/

typedef struct CM_Inbound_s
               CM_Inbound_t;

#define CM_Inbound_t_SIZE                                  0x00000020

struct CM_Inbound_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 SFQ_Prod_Index;
         os_bit32 Frame_Length;
         os_bit32 LKF_Type;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Inbound_INT                  0x00000100

#define CM_Inbound_CM_Type_MASK         0x000000FF

#define CM_Inbound_SFQ_Prod_Index_MASK  0x00000FFF
#define CM_Inbound_SFQ_Prod_Index_SHIFT       0x00

#define CM_Inbound_LKF                  0x40000000

#define CM_Inbound_Type_MASK            0x0000000F
#define CM_Inbound_Type_Unassisted_FCP  0x00000001
#define CM_Inbound_Type_Bad_FCP         0x00000002
#define CM_Inbound_Type_Unknown_Frame   0x00000003

/*+
ERQ Frozen Completion Message
-*/

typedef struct CM_ERQ_Frozen_s
               CM_ERQ_Frozen_t;

#define CM_ERQ_Frozen_t_SIZE                               0x00000020

struct CM_ERQ_Frozen_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 Unused_DWord_1;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_ERQ_Frozen_INT          0x00000100

#define CM_ERQ_Frozen_CM_Type_MASK 0x000000FF

/*+
FCP Assists Frozen Completion Message
-*/

typedef struct CM_FCP_Assists_Frozen_s
               CM_FCP_Assists_Frozen_t;

#define CM_FCP_Assists_Frozen_t_SIZE                       0x00000020

struct CM_FCP_Assists_Frozen_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 Unused_DWord_1;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_FCP_Assists_Frozen_INT          0x00000100

#define CM_FCP_Assists_Frozen_CM_Type_MASK 0x000000FF

/*+
Frame Manager Completion Message
-*/

typedef struct CM_Frame_Manager_s
               CM_Frame_Manager_t;

#define CM_Frame_Manager_t_SIZE                            0x00000020

struct CM_Frame_Manager_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 Unused_DWord_1;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Frame_Manager_INT          0x00000100

#define CM_Frame_Manager_CM_Type_MASK 0x000000FF

/*+
Inbound FCP Exchange Completion Message
-*/

typedef struct CM_Inbound_FCP_Exchange_s
               CM_Inbound_FCP_Exchange_t;

#define CM_Inbound_FCP_Exchange_t_SIZE                     0x00000020

struct CM_Inbound_FCP_Exchange_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 Bits__SEST_Index;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Inbound_FCP_Exchange_INT              0x00000100

#define CM_Inbound_FCP_Exchange_CM_Type_MASK     0x000000FF

#define CM_Inbound_FCP_Exchange_LKF              0x40000000

#define CM_Inbound_FCP_Exchange_CNT              0x20000000

#define CM_Inbound_FCP_Exchange_OVF              0x10000000

#define CM_Inbound_FCP_Exchange_RPC              0x08000000

#define CM_Inbound_FCP_Exchange_SEST_Index_MASK  0x00007FFF
#define CM_Inbound_FCP_Exchange_SEST_Index_SHIFT       0x00

/*+
Class 2 Frame Header Completion Message
-*/

typedef struct CM_Class_2_Frame_Header_s
               CM_Class_2_Frame_Header_t;

#define CM_Class_2_Frame_Header_t_SIZE                     0x00000020

struct CM_Class_2_Frame_Header_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 SOF_EOF_Timestamp;
         os_bit32 R_CTL__D_ID;
         os_bit32 CS_CTL__S_ID;
         os_bit32 TYPE__F_CTL;
         os_bit32 SEQ_ID__DF_CTL__SEQ_CNT;
         os_bit32 OX_ID__RX_ID;
         os_bit32 RO;
       };

#define CM_Class_2_Frame_Header_INT             0x00000100

#define CM_Class_2_Frame_Header_CM_Type_MASK    0x000000FF

#define CM_Class_2_Frame_Header_SOF_MASK        0xF0000000
#define CM_Class_2_Frame_Header_SOF_SOFc1       0x30000000
#define CM_Class_2_Frame_Header_SOF_SOFi1       0x50000000
#define CM_Class_2_Frame_Header_SOF_SOFi2       0x60000000
#define CM_Class_2_Frame_Header_SOF_SOFi3       0x70000000
#define CM_Class_2_Frame_Header_SOF_SOFt        0x80000000
#define CM_Class_2_Frame_Header_SOF_SOFn1       0x90000000
#define CM_Class_2_Frame_Header_SOF_SOFn2       0xA0000000
#define CM_Class_2_Frame_Header_SOF_SOFn3       0xB0000000

#define CM_Class_2_Frame_Header_EOF_MASK        0x0F000000
#define CM_Class_2_Frame_Header_EOF_EOFdt       0x01000000
#define CM_Class_2_Frame_Header_EOF_EOFdti      0x02000000
#define CM_Class_2_Frame_Header_EOF_EOFni       0x03000000
#define CM_Class_2_Frame_Header_EOF_EOFa        0x04000000
#define CM_Class_2_Frame_Header_EOF_EOFn        0x05000000
#define CM_Class_2_Frame_Header_EOF_EOFt        0x06000000

#define CM_Class_2_Frame_Header_Timestamp_MASK  0x000000FF
#define CM_Class_2_Frame_Header_Timestamp_SHIFT       0x00

#define CM_Class_2_Frame_Header_R_CTL_MASK      0xFF000000
#define CM_Class_2_Frame_Header_R_CTL_SHIFT           0x18

#define CM_Class_2_Frame_Header_D_ID_MASK       0x00FFFFFF
#define CM_Class_2_Frame_Header_D_ID_SHIFT            0x00

#define CM_Class_2_Frame_Header_CS_CTL_MASK     0xFF000000
#define CM_Class_2_Frame_Header_CS_CTL_SHIFT          0x18

#define CM_Class_2_Frame_Header_S_ID_MASK       0x00FFFFFF
#define CM_Class_2_Frame_Header_S_ID_SHIFT            0x00

#define CM_Class_2_Frame_Header_TYPE_MASK       0xFF000000
#define CM_Class_2_Frame_Header_TYPE_SHIFT            0x18

#define CM_Class_2_Frame_Header_F_CTL_MASK      0x00FFFFFF
#define CM_Class_2_Frame_Header_F_CTL_SHIFT           0x00

#define CM_Class_2_Frame_Header_SEQ_ID_MASK     0xFF000000
#define CM_Class_2_Frame_Header_SEQ_ID_SHIFT          0x18

#define CM_Class_2_Frame_Header_DF_CTL_MASK     0x00FF0000
#define CM_Class_2_Frame_Header_DF_CTL_SHIFT          0x10

#define CM_Class_2_Frame_Header_SEQ_CNT_MASK    0x0000FFFF
#define CM_Class_2_Frame_Header_SEQ_CNT_SHIFT         0x00

#define CM_Class_2_Frame_Header_OX_ID_MASK      0xFFFF0000
#define CM_Class_2_Frame_Header_OX_ID_SHIFT           0x10

#define CM_Class_2_Frame_Header_RX_ID_MASK      0x0000FFFF
#define CM_Class_2_Frame_Header_RX_ID_SHIFT           0x00

/*+
Class 2 Sequence Received Completion Message
-*/

typedef struct CM_Class_2_Sequence_Received_s
               CM_Class_2_Sequence_Received_t;

#define CM_Class_2_Sequence_Received_t_SIZE                0x00000020

struct CM_Class_2_Sequence_Received_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 SEST_Index;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Class_2_Sequence_Received_INT              0x00000100

#define CM_Class_2_Sequence_Received_CM_Type_MASK     0x000000FF

#define CM_Class_2_Sequence_Received_SEST_Index_MASK  0x00007FFF
#define CM_Class_2_Sequence_Received_SEST_Index_SHIFT       0x00

/*+
Union of all Completion Message types
-*/

typedef union Completion_Message_u
              Completion_Message_t;

#define Completion_Message_t_SIZE                          0x00000020

union Completion_Message_u
      {
        CM_Unknown_t                   Unknown;
        CM_Outbound_t                  Outbound;
        CM_Error_Idle_t                Error_Idle;
        CM_Inbound_t                   Inbound;
        CM_ERQ_Frozen_t                ERQ_Frozen;
        CM_FCP_Assists_Frozen_t        FCP_Assists_Frozen;
        CM_Frame_Manager_t             Frame_Manager;
        CM_Inbound_FCP_Exchange_t      Inbound_FCP_Exchange;
        CM_Class_2_Frame_Header_t      Class_2_Frame_Header;
        CM_Class_2_Sequence_Received_t Class_2_Sequence_Received;
      };

/*+
Function:  TLStructASSERTs()

Purpose:   Returns the number of TLStruct.H typedefs which are not the correct size.

Algorithm: Each typedef in TLStruct.H is checked for having the correct size.  While
           this property doesn't guarantee correct packing of the fields within, it
           is a pretty good indicator that the typedef has the intended layout.

           The total number of typedefs which are not of correct size is returned from
           this function.  Hence, if the return value is non-zero, the declarations
           can not be trusted to match the TachyonTL specification.
-*/

osGLOBAL os_bit32 TLStructASSERTs(
                              void
                            );

#endif /* __TLStruct_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\aha154x\aha154x.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    aha154x.c

Abstract:

    This is the port driver for the Adaptec 1540B SCSI Adapter.

Author:

    Mike Glass
    Tuong Hoang (Adaptec)
    Renato Maranon (Adaptec)
    Bill Williams (Adaptec)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "miniport.h"
#include "aha154x.h"           // includes scsi.h

VOID
ScsiPortZeroMemory(
    IN PVOID Destination,
    IN ULONG Length
    );

//
// This conditionally compiles in the code to force the DMA transfer speed
// to 5.0.
//

#define FORCE_DMA_SPEED 1

//
// Function declarations
//
// Functions that start with 'A154x' are entry points
// for the OS port driver.
//

ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    );

ULONG
A154xDetermineInstalled(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN OUT PSCAN_CONTEXT Context,
    OUT PBOOLEAN Again
    );


VOID
A154xClaimBIOSSpace(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension,
    IN PBASE_REGISTER baseIoAddress,
    IN PSCAN_CONTEXT Context,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    );

ULONG
A154xFindAdapter(
    IN PVOID HwDeviceExtension,
    IN PSCAN_CONTEXT Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );


BOOLEAN
A154xAdapterState(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN BOOLEAN SaveState
    );


BOOLEAN
A154xHwInitialize(
    IN PVOID DeviceExtension
    );

#if defined(_SCAM_ENABLED)
//
// Issues SCAM command to HA
//
BOOLEAN
PerformScamProtocol(
    IN PHW_DEVICE_EXTENSION DeviceExtension
    );
#endif

BOOLEAN
A154xStartIo(
    IN PVOID DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
A154xInterrupt(
    IN PVOID DeviceExtension
    );

BOOLEAN
A154xResetBus(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    );

SCSI_ADAPTER_CONTROL_STATUS
A154xAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    );

BOOLEAN
GetHostAdapterBoardId (
    IN PVOID HwDeviceExtension,
    OUT PUCHAR BoardId
    );

//
// This function is called from A154xStartIo.
//

VOID
BuildCcb(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

//
// This function is called from BuildCcb.
//

VOID
BuildSdl(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

//
// This function is called from A154xInitialize.
//

BOOLEAN
AdapterPresent(
    IN PVOID HwDeviceExtension
    );

//
// This function is called from A154xInterrupt.
//

UCHAR
MapError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCCB Ccb
    );

BOOLEAN
ScatterGatherSupported (
   IN PHW_DEVICE_EXTENSION HwDeviceExtension
   );

BOOLEAN SendUnlockCommand(
    IN PVOID HwDeviceExtension,
    IN UCHAR locktype
    );

BOOLEAN UnlockMailBoxes(
    IN PVOID HwDeviceExtension
    );

ULONG
AhaParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    );

//
// This function determines whether adapter is an AMI
//
BOOLEAN
A4448IsAmi(
    IN PHW_DEVICE_EXTENSION  HwDeviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    ULONG portNumber
    );


ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Installable driver initialization entry point for system.

Arguments:

    Driver Object

Return Value:

    Status from ScsiPortInitialize()

--*/

{
    HW_INITIALIZATION_DATA hwInitializationData;
    SCAN_CONTEXT context;
    ULONG isaStatus;
    ULONG mcaStatus;
    ULONG i;

    DebugPrint((1,"\n\nSCSI Adaptec 154X MiniPort Driver\n"));

    //
    // Zero out structure.
    //

    for (i=0; i<sizeof(HW_INITIALIZATION_DATA); i++) {
    ((PUCHAR)&hwInitializationData)[i] = 0;
    }

    //
    // Set size of hwInitializationData.
    //

    hwInitializationData.HwInitializationDataSize = sizeof(HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitializationData.HwInitialize = A154xHwInitialize;
    hwInitializationData.HwResetBus = A154xResetBus;
    hwInitializationData.HwStartIo = A154xStartIo;
    hwInitializationData.HwInterrupt = A154xInterrupt;
    hwInitializationData.HwFindAdapter = A154xFindAdapter;
    hwInitializationData.HwAdapterState = A154xAdapterState;
    hwInitializationData.HwAdapterControl = A154xAdapterControl;

    //
    // Indicate no buffer mapping but will need physical addresses.
    //

    hwInitializationData.NeedPhysicalAddresses = TRUE;

    //
    // Specify size of extensions.
    //

    hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    hwInitializationData.SpecificLuExtensionSize = sizeof(HW_LU_EXTENSION);

    //
    // Specifiy the bus type.
    //

    hwInitializationData.AdapterInterfaceType = Isa;
    hwInitializationData.NumberOfAccessRanges = 2;

    //
    // Ask for SRB extensions for CCBs.
    //

    hwInitializationData.SrbExtensionSize = sizeof(CCB);

    //
    // The adapter count is used by the find adapter routine to track how
    // which adapter addresses have been tested.
    //

    context.adapterCount = 0;
    context.biosScanStart = 0;

    isaStatus = ScsiPortInitialize(DriverObject, Argument2, &hwInitializationData, &context);

    //
    // Now try to configure for the Mca bus.
    // Specifiy the bus type.
    //

    hwInitializationData.AdapterInterfaceType = MicroChannel;
    context.adapterCount = 0;
    context.biosScanStart = 0;
    mcaStatus = ScsiPortInitialize(DriverObject, Argument2, &hwInitializationData, &context);

    //
    // Return the smaller status.
    //

    return(mcaStatus < isaStatus ? mcaStatus : isaStatus);

} // end A154xEntry()


ULONG
A154xFindAdapter(
    IN PVOID HwDeviceExtension,
    IN PSCAN_CONTEXT Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
/*++

Routine Description:

    This function is called by the OS-specific port driver after
    the necessary storage has been allocated, to gather information
    about the adapter's configuration.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Context - Register base address
    ConfigInfo - Configuration information structure describing HBA
    This structure is defined in PORT.H.

Return Value:

    ULONG

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG length;
    ULONG status;
    UCHAR adapterTid;
    UCHAR dmaChannel;
    UCHAR irq;
    UCHAR bit;
    UCHAR hostAdapterId[4];

#if defined(_SCAM_ENABLED)
    UCHAR temp, i;
        UCHAR BoardID;
        UCHAR EepromData;
#endif

    //
    // Inform SCSIPORT that we are a WMI data provider and have we GUIDs
    // to register.
    //

    ConfigInfo->WmiDataProvider = TRUE;
    A154xWmiInitialize(deviceExtension);

    //
    // Determine if there are any adapters installed.  Determine installed
    // will initialize the BaseIoAddress if an adapter is found.
    //

    status = A154xDetermineInstalled(deviceExtension,
            ConfigInfo,
            Context,
            Again);

    //
    // If there are no adapters found then return.
    //

    if (status != SP_RETURN_FOUND) {
        return(status);
    }

    //
    // Issue adapter command to get IRQ, DMA channel, and adapter SCSI ID.
    // But first, check for PnP non-default values.  If any of these values
    // are default, then we do 'em all to save code space, since the same
    // command is used.
    //
    // Returns 3 data bytes:
    //
    // Byte 0   Dma Channel
    //
    // Byte 1   Interrupt Channel
    //
    // Byte 2   Adapter SCSI ID
    //

    if (((ConfigInfo->DmaChannel+1) == 0) ||            // default DMA channel ?
        (ConfigInfo->BusInterruptLevel == 0) ||         // default IRQ ?
        ((ConfigInfo->InitiatorBusId[0]+1) == 0)        // default adapter ID ?
        ) {



        if (!WriteCommandRegister(deviceExtension, AC_RET_CONFIGURATION_DATA, TRUE)) {
            DebugPrint((1,"A154xFindAdapter: Get configuration data command failed\n"));
            return SP_RETURN_ERROR;
        }

        //
        // Determine DMA channel.
        //

        if (!ReadCommandRegister(deviceExtension,&dmaChannel,TRUE)) {
            DebugPrint((1,"A154xFindAdapter: Can't read dma channel\n"));
            return SP_RETURN_ERROR;
        }

        if (ConfigInfo->AdapterInterfaceType != MicroChannel) {

            WHICH_BIT(dmaChannel,bit);

            ConfigInfo->DmaChannel = bit;

            DebugPrint((2,"A154xFindAdapter: DMA channel is %x\n",
            ConfigInfo->DmaChannel));

        } else {
            ConfigInfo->InterruptMode = LevelSensitive;
        }

        //
        // Determine hardware interrupt vector.
        //

        if (!ReadCommandRegister(deviceExtension,&irq,TRUE)) {
            DebugPrint((1,"A154xFindAdapter: Can't read adapter irq\n"));
            return SP_RETURN_ERROR;
        }

        WHICH_BIT(irq, bit);

        ConfigInfo->BusInterruptLevel = (UCHAR) 9 + bit;

        //
        // Determine what SCSI bus id the adapter is on.
        //

        if (!ReadCommandRegister(deviceExtension,&adapterTid,TRUE)) {
            DebugPrint((1,"A154xFindAdapter: Can't read adapter SCSI id\n"));
            return SP_RETURN_ERROR;
        }

        //
        // Wait for HACC interrupt.
        //

        SpinForInterrupt(deviceExtension,FALSE);  // eddy

        //
        // Use PnP fields
        //
    } else {
        adapterTid = ConfigInfo->InitiatorBusId[0];
    }

    //
    // Set number of buses.
    //

    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->InitiatorBusId[0] = adapterTid;
    deviceExtension->HostTargetId = adapterTid;

    //
    // Set default CCB command to scatter/gather with residual counts.
    // If the adapter rejects this command, then set the command
    // to scatter/gather without residual.
    //

    deviceExtension->CcbScatterGatherCommand = SCATTER_GATHER_COMMAND;

    if ((ConfigInfo->MaximumTransferLength+1) == 0)
        ConfigInfo->MaximumTransferLength = MAX_TRANSFER_SIZE;

        //
        // NumberOfPhysicalBreaks incorrectly defined.
        // Must be set to MAX_SG_DESCRIPTORS.
        //

    if ((ConfigInfo->NumberOfPhysicalBreaks+1) == 0)
        ConfigInfo->NumberOfPhysicalBreaks = MAX_SG_DESCRIPTORS;
        //ConfigInfo->NumberOfPhysicalBreaks = MAX_SG_DESCRIPTORS - 1;

    if (!ConfigInfo->ScatterGather)
        ConfigInfo->ScatterGather = ScatterGatherSupported(HwDeviceExtension);

    if (!ConfigInfo->ScatterGather) {
        //ConfigInfo->NumberOfPhysicalBreaks = 1;
        DebugPrint((1,"Aha154x: Scatter/Gather not supported!\n"));
    }

    ConfigInfo->Master = TRUE;

    //
    // Allocate a Noncached Extension to use for mail boxes.
    //

    deviceExtension->NoncachedExtension =
    ScsiPortGetUncachedExtension(deviceExtension,
                     ConfigInfo,
                     sizeof(NONCACHED_EXTENSION));

    if (deviceExtension->NoncachedExtension == NULL) {

        //
        // Log error.
        //

        ScsiPortLogError(deviceExtension,
                         NULL,
                         0,
                         0,
                         0,
                         SP_INTERNAL_ADAPTER_ERROR,
                         7 << 8);

        return(SP_RETURN_ERROR);
    }

    //
    // Convert virtual to physical mailbox address.
    //

    deviceExtension->NoncachedExtension->MailboxPA =
       ScsiPortConvertPhysicalAddressToUlong(
        ScsiPortGetPhysicalAddress(deviceExtension,
                 NULL,
                 deviceExtension->NoncachedExtension->Mbo,
                 &length));

    //
    // Set default bus on time.  Then check for an override parameter.
    //

    deviceExtension->BusOnTime = 0x07;
    if (ArgumentString != NULL) {

        length = AhaParseArgumentString(ArgumentString, "BUSONTIME");

        //
        // Validate that the new bus on time is reasonable before attempting
        // to set it.
        //

        if (length >= 2 && length <= 15) {

            deviceExtension->BusOnTime = (UCHAR) length;
            DebugPrint((1,"A154xFindAdapter: Setting bus on time: %ld\n", length));
        }
    }

    //
    // Set maximum cdb length to zero unless the user has overridden the value
    //

    if( ArgumentString != NULL) {

        length = AhaParseArgumentString(ArgumentString, "MAXCDBLENGTH");

        //
        // Validate the maximum cdb length before attempting to set it
        //

        if (length >= 6 && length <= 20) {

            deviceExtension->MaxCdbLength = (UCHAR) length;
            DebugPrint((1, "A154xFindAdapter: Setting maximum cdb length: %ld\n", length));
        }

    } else {

        GetHostAdapterBoardId(HwDeviceExtension,&hostAdapterId[0]);

        if(hostAdapterId[BOARD_ID] < 'E') {

            deviceExtension->MaxCdbLength = 10;
            DebugPrint((1, "A154xFindAdapter: Old firmware - Setting maximum cdb length: %ld\n", length));

        } else {

            length = deviceExtension->MaxCdbLength = 0;
            DebugPrint((1, "A154xFindAdapter: Setting maximum cdb length: %ld\n", length));

        }

    }

#if defined(_SCAM_ENABLED)
        //
        // Get info to determine if miniport must issues SCAM command.
        //
    DebugPrint((1,"A154x => Start SCAM enabled determination.", length));

    deviceExtension->PerformScam = FALSE;

    do {
        //
        // Fall through do loop if a command fails.
        //
        if (!WriteCommandRegister(deviceExtension,AC_ADAPTER_INQUIRY,FALSE)) {
            break;
        }

        if ((ReadCommandRegister(deviceExtension,&BoardID,TRUE)) == FALSE) {
            break;
        }

        //
        // Don't care about three other bytes
        //
        for (i=0; i < 0x3; i++) {
            if ((ReadCommandRegister(deviceExtension,&temp,TRUE)) == FALSE) {
                            break;
            }
        }

        SpinForInterrupt(HwDeviceExtension,FALSE);

        //
        // Check to see that three 'extra bytes' were read.
        //
        if (i != 0x3)
            break;

        if (BoardID >= 'F') {

            if (!WriteCommandRegister(deviceExtension,AC_RETURN_EEPROM,FALSE)) {
                break;
            }

            //
            // Flag Byte => set returns configured options
            //
            if (!WriteCommandRegister(deviceExtension,0x01,FALSE)) {
                break;
            }
            //
            // Data length => reading one byte.
            //
            if (!WriteCommandRegister(deviceExtension,0x01,FALSE)) {
                break;

            }
            //
            // Data offset => read SCSI_BUS_CONTROL_FLAG
            //
            if (!WriteCommandRegister(deviceExtension,SCSI_BUS_CONTROL_FLAG,FALSE)) {
                break;
            }

            //
            // Read it!
            //
            if ((ReadCommandRegister(deviceExtension,&EepromData,TRUE)) == FALSE) {
                break;
            }

            SpinForInterrupt(HwDeviceExtension,FALSE);

            //
            // SCAM only if it's enabled in SCSISelect.
            //
            if (EepromData | SCAM_ENABLED) {
                DebugPrint((1,"A154x => SCAM Enabled\n"));
                deviceExtension->PerformScam = TRUE;
            }
        }
    } while (FALSE);

#endif

    DebugPrint((3,"A154xFindAdapter: Configuration completed\n"));
    return SP_RETURN_FOUND;
} // end A154xFindAdapter()



BOOLEAN
A154xAdapterState(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN BOOLEAN SaveState
    )
/*++

Routine Description:

    This function is called after FindAdapter with SaveState set to TRUE,
    inidicating that the adapter state should be saved.  Before Chicago
    exits, this function is again called with SaveState set to FALSE,
    indicating the adapter should be restored to the same state it was
    when this function was first called.  By saving its real mode state
    and restoring it during protected mode exit will give the adapter
    a higher chance of working back in real mode.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Context - Register base address
    SaveState - Flag to indicate whether to perform SAVE or RESTORE.
                                     TRUE == SAVE, FALSE == RESTORE.

Return Value:

    TRUE                SAVE/RESTORE operation was successful.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    UCHAR idx;
    UCHAR cfgsz = sizeof(RM_CFG);
    PRM_CFG SaveCfg;

    deviceExtension = HwDeviceExtension;
    SaveCfg = &deviceExtension->RMSaveState;

    //
    // SAVE real mode state
    //
    if (SaveState) {
        //
        // Read off config data from AHA154X...
        //
        if (!WriteCommandRegister(deviceExtension, AC_RETURN_SETUP_DATA, TRUE))
            return FALSE;

        if (!WriteDataRegister(deviceExtension, cfgsz))
            return FALSE;

        for (idx=0;idx<cfgsz;idx++) {
            if (!(ReadCommandRegister(HwDeviceExtension,(PUCHAR)(SaveCfg),TRUE)))
                return FALSE;
            ((PUCHAR)SaveCfg)++;
        }

        //
        // ...and wait for interrupt
        //

        if (!SpinForInterrupt(deviceExtension,TRUE))
            return FALSE;

        //
        // RESTORE state to real mode
        //
    } else {
        //
        // If mailbox count was not zero, re-initialize mailbox addresses
        // saved from real mode
        //

        if (SaveCfg->NumMailBoxes) {

        if (!WriteCommandRegister(deviceExtension, AC_MAILBOX_INITIALIZATION, TRUE))
            return FALSE;
        if (!WriteDataRegister(deviceExtension, SaveCfg->NumMailBoxes))
            return FALSE;
        if (!WriteDataRegister(deviceExtension, SaveCfg->MBAddrHiByte))
            return FALSE;
        if (!WriteDataRegister(deviceExtension, SaveCfg->MBAddrMiByte))
            return FALSE;
        if (!WriteDataRegister(deviceExtension, SaveCfg->MBAddrLoByte))
            return FALSE;

        //
        // ... and wait for interrupt.
        //

        if (!SpinForInterrupt(deviceExtension,TRUE))
            return FALSE;

        }

        //
        // Restore transfer speed gotten from real mode...
        //

        if (!WriteCommandRegister(deviceExtension, AC_SET_TRANSFER_SPEED, TRUE))
            return FALSE;

        if (!WriteDataRegister(deviceExtension, SaveCfg->TxSpeed))
            return FALSE;

        //
        // ... and wait for interrupt.
        //

        if (!SpinForInterrupt(deviceExtension,TRUE))
            return FALSE;

        //
        // Restore setting for bus on time from real mode...
        //

        if (!WriteCommandRegister(deviceExtension, AC_SET_BUS_ON_TIME, TRUE))
            return FALSE;

        if (!WriteDataRegister(deviceExtension, SaveCfg->BusOnTime))
            return FALSE;

        //
        // ...and wait for interrupt
        //
        if (!SpinForInterrupt(deviceExtension,TRUE))
            return FALSE;

        //
        // Restore setting for bus off time from real mode...
        //

        if (!WriteCommandRegister(deviceExtension, AC_SET_BUS_OFF_TIME, TRUE))
            return FALSE;

        if (!WriteDataRegister(deviceExtension, SaveCfg->BusOffTime))
            return FALSE;

        //
        // ...and wait for interrupt
        //
        if (!SpinForInterrupt(deviceExtension,TRUE))
            return FALSE;

        //
        // Reset any pending interrupts
        //
        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

    }
    return TRUE;

} // end A154xAdapterState()


SCSI_ADAPTER_CONTROL_STATUS
A154xAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )

/*++

Routine Description:

    This routine is called at various time's by SCSIPort and is used
        to provide a control function over the adapter. Most commonly, NT
        uses this entry point to control the power state of the HBA during
        a hibernation operation.

Arguments:

    HwDeviceExtension - HBA miniport driver's per adapter storage
    Parameters  - This varies by control type, see below.
    ControlType - Indicates which adapter control function should be
                  executed. Conrol Types are detailed below.

Return Value:

     ScsiAdapterControlSuccess - requested ControlType completed successfully
     ScsiAdapterControlUnsuccessful - requested ControlType failed

--*/


{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    PSCSI_SUPPORTED_CONTROL_TYPE_LIST ControlTypeList;
    ULONG AdjustedMaxControlType;

    ULONG Index;
    UCHAR Retries;
    //
    // Default Status
    //
    SCSI_ADAPTER_CONTROL_STATUS Status = ScsiAdapterControlSuccess;

    //
    // Structure defining which functions this miniport supports
    //

    BOOLEAN SupportedConrolTypes[A154X_TYPE_MAX] = {
        TRUE,   // ScsiQuerySupportedControlTypes
        TRUE,   // ScsiStopAdapter
        TRUE,   // ScsiRestartAdapter
        FALSE,  // ScsiSetBootConfig
        FALSE   // ScsiSetRunningConfig
        };

    //
    // Execute the correct code path based on ControlType
    //
    switch (ControlType) {

        case ScsiQuerySupportedControlTypes:
            //
            // This entry point provides the method by which SCSIPort determines the
            // supported ControlTypes. Parameters is a pointer to a
            // SCSI_SUPPORTED_CONTROL_TYPE_LIST structure. Fill in this structure
            // honoring the size limits.
            //
            ControlTypeList = Parameters;
            AdjustedMaxControlType =
                (ControlTypeList->MaxControlType < A154X_TYPE_MAX) ?
                ControlTypeList->MaxControlType :
                                                                                                                                                                                 A154X_TYPE_MAX;
            for (Index = 0; Index < AdjustedMaxControlType; Index++) {
                ControlTypeList->SupportedTypeList[Index] =
                    SupportedConrolTypes[Index];
            }
            break;

        case ScsiStopAdapter:
            //
            // This entry point  is called by SCSIPort when it needs to stop/disable
            // the HBA. Parameters is a pointer to the HBA's HwDeviceExtension. The adapter
            // has already been quiesced by SCSIPort (i.e. no outstanding SRBs). Hence the adapter
            // should abort/complete any internally generated commands, disable adapter interrupts
            // and optionally power down the adapter.
            //

            //
            // Before we stop the adapter, we need to save the adapter's state
            // information for reinitialization purposes. For this adpater the
            // HwSaveState entry point will suffice.
            //
            if (A154xAdapterState(HwDeviceExtension, NULL, TRUE) == FALSE) {
                //
                // Adapter is unable to save it's state information, we must fail this
                // request since the process of restarting the adapter will not succeed.
                //
                return ScsiAdapterControlUnsuccessful;
            }

            //
            // It is not possible to disable interrupts on the 1540 series of cards. The alternative is to
            // reset the adapter, clear any remaining interrupts and return success. If it is impossible to
            // queiese the interrupt line, we may not honor the request to stop the adapter. It should be
            // noted that while this solution is not perfect, the typical usage of the 1540 series of adapters
            // renders the likelihood of asyncnronous interrupts nil.
            //
            Retries = 0x0;

            do {
                //
                // Reset the adapter
                //
                ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_HARD_RESET);

                //
                // Wait for idle with timeout (500ms timer)
                //
                for (Index = 0; Index < 500000; Index++) {

                    if (ScsiPortReadPortUchar(&baseIoAddress->StatusRegister) & IOP_SCSI_HBA_IDLE) {

                        //
                        // Upon reaching this point, the adapter has been reset and idled. If there are no interrupts
                        // pending, we can leave having given ourselves the greatest level of assurance that no
                        // future interrupts await.
                        //
                        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

                        if (!(ScsiPortReadPortUchar(&baseIoAddress->InterruptRegister) & IOP_ANY_INTERRUPT)) {
                            //
                            // Sucess!
                            //
                            return Status;
                        }
                    }

                    //
                    // one ms delay
                    //
                    ScsiPortStallExecution(1);
                }
                //
                // Operation should be retried a few times in case it fails.
                //
            } while (Retries < 10);

            break;

            case ScsiRestartAdapter:
                //
                // This entry point is called by SCSIPort when it needs to re-enable
                // a previously stopped adapter. In the generic case, previously
                // suspended IO operations should be restarted and the adapter's
                // previous configuration should be reinstated. Our hardware device
                // extension and uncached extensions have been preserved so no
                // actual driver software reinitialization is necesarry.
                //

                //
                // The adapter's firmware configuration is returned via HwAdapterState.
                //
                if (A154xAdapterState(HwDeviceExtension, NULL, FALSE) == FALSE) {
                    //
                    // Adapter is unable to restore it's state information, we must fail this
                    // request since the process of restarting the adapter will not succeed.
                    //
                    Status = ScsiAdapterControlUnsuccessful;
                }

                A154xResetBus(deviceExtension, SP_UNTAGGED);
                break;

            case ScsiSetBootConfig:
                Status = ScsiAdapterControlUnsuccessful;
                break;

            case ScsiSetRunningConfig:
                Status = ScsiAdapterControlUnsuccessful;
                break;

            case ScsiAdapterControlMax:
                Status = ScsiAdapterControlUnsuccessful;
                break;

            default:
                Status = ScsiAdapterControlUnsuccessful;
                break;
    }

    return Status;
}


BOOLEAN
AdaptecAdapter(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension,
    IN ULONG   IoPort,
    IN BOOLEAN Mca
    )

/*++

Routine Description:

    This routine checks the Special Options byte of the Adapter Inquiry
    command to see if it is one of the two values returned by Adaptec
    Adapters.  This avoids claiming adapters from BusLogic and DTC.

Arguments:

    HwDeviceExtension - miniport driver's adapter extension.

Return Values:

    TRUE if the adapter looks like an Adaptec.
    FALSE if not.

--*/

{
    UCHAR byte;
    UCHAR specialOptions;
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;

    if (Mca == TRUE) {
        INIT_DATA initData;
        LONG slot;
        LONG i;

        for (slot = 0; slot < NUMBER_POS_SLOTS; slot++) {
            i = ScsiPortGetBusData(HwDeviceExtension,
                       Pos,
                       0,
                       slot,
                       &initData.PosData[slot],
                       sizeof(POS_DATA));
            if (i < (sizeof(POS_DATA))) {
                initData.PosData[slot].AdapterId = 0xffff;
            }
        }

        for (slot = 0; slot < NUMBER_POS_SLOTS; slot++) {
            if (initData.PosData[slot].AdapterId == POS_IDENTIFIER) {
                switch (initData.PosData[slot].IoPortInformation & POS_PORT_MASK) {
                    case POS_PORT_130:
                        if (IoPort == 0x0130) {
                            return TRUE;
                        }
                        break;
                    case POS_PORT_134:
                        if (IoPort == 0x0134) {
                            return TRUE;
                        }
                        break;
                    case POS_PORT_230:
                        if (IoPort == 0x0230) {
                            return TRUE;
                        }
                        break;
                    case POS_PORT_234:
                        if (IoPort == 0x234) {
                            return TRUE;
                        }
                        break;
                    case POS_PORT_330:
                        if (IoPort == 0x330) {
                            return TRUE;
                        }
                        break;
                    case POS_PORT_334:
                        if (IoPort == 0x334) {
                            return TRUE;
                        }
                        break;
                }
            }
        }
        return FALSE;
    }

    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister,
        IOP_INTERRUPT_RESET);

    if (!WriteCommandRegister(HwDeviceExtension,AC_ADAPTER_INQUIRY,FALSE)) {
        return FALSE;
    }

    //
    // Byte 0.
    //

    if ((ReadCommandRegister(HwDeviceExtension,&byte,TRUE)) == FALSE) {
        return FALSE;
    }

    //
    // Get the special options byte.
    //

    if ((ReadCommandRegister(HwDeviceExtension,&specialOptions,TRUE)) == FALSE) {
        return FALSE;
    }

    //
    // Get the last two bytes and clear the interrupt.
    //

    if ((ReadCommandRegister(HwDeviceExtension,&byte,TRUE)) == FALSE) {
        return FALSE;
    }

    if ((ReadCommandRegister(HwDeviceExtension,&byte,TRUE)) == FALSE) {
        return FALSE;
    }

    //
    // Wait for HACC interrupt.
    //

    SpinForInterrupt(HwDeviceExtension,FALSE);   // eddy


    if ((specialOptions == 0x30) || (specialOptions == 0x42)) {
        return TRUE;
    }

    return FALSE;
}

ULONG
A154xDetermineInstalled(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN OUT PSCAN_CONTEXT Context,
    OUT PBOOLEAN Again
    )

/*++

Routine Description:

    Determine if Adaptec 154X SCSI adapter is installed in system
    by reading the status register as each base I/O address
    and looking for a pattern.  If an adapter is found, the BaseIoAddres is
    initialized.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

    ConfigInfo - Supplies the known configuraiton information.

    AdapterCount - Supplies the count of adapter slots which have been tested.

    Again - Returns whehter the  OS specific driver should call again.

Return Value:

    Returns a status indicating whether a driver is present or not.

--*/

{
    PBASE_REGISTER baseIoAddress;
    PUCHAR ioSpace;
    UCHAR  portValue;
    ULONG  ioPort;

    //
    // Check for configuration information passed in from system.
    //

    if ((*ConfigInfo->AccessRanges)[0].RangeLength != 0) {

        ULONG i;
        PACCESS_RANGE ioRange = NULL;

        for(i = 0; i < ConfigInfo->NumberOfAccessRanges; i++) {

            ioRange = &((*ConfigInfo->AccessRanges)[i]);

            //
            // Search for an io port range.
            //

            if(ioRange->RangeInMemory == FALSE) {
                break;
            }
        }

        if(ioRange->RangeInMemory) {

            //
            // No i/o range found for the card in the provided config.  Bail
            //

            *Again = TRUE;
            return SP_RETURN_BAD_CONFIG;
        }

        ioSpace = ScsiPortGetDeviceBase(HwDeviceExtension,
                                        ConfigInfo->AdapterInterfaceType,
                                        ConfigInfo->SystemIoBusNumber,
                                        ioRange->RangeStart,
                                        ioRange->RangeLength,
                                        TRUE);

        if(ioSpace == NULL) {
            return SP_RETURN_ERROR;
        }

        baseIoAddress = (PBASE_REGISTER) ioSpace;

        HwDeviceExtension->BaseIoAddress = baseIoAddress;

        *Again = FALSE;

        return (ULONG)SP_RETURN_FOUND;

    } else {

        //
        // The following table specifies the ports to be checked when searching for
        // an adapter.  A zero entry terminates the search.
        //

        CONST ULONG AdapterAddresses[7] = {0X330, 0X334, 0X234, 0X134, 0X130, 0X230, 0};

        //
        // Scan possible base addresses looking for adapters.
        //

        while (AdapterAddresses[Context->adapterCount] != 0) {

            //
            // Get the system physical address for this card.  The card uses
            // I/O space.
            //

            ioPort = AdapterAddresses[Context->adapterCount];

            ioSpace =
                ScsiPortGetDeviceBase(HwDeviceExtension,
                                      ConfigInfo->AdapterInterfaceType,
                                      ConfigInfo->SystemIoBusNumber,
                                      ScsiPortConvertUlongToPhysicalAddress(ioPort),
                                      0x4,
                                      TRUE);

            //
            // Get next base address.
            //

            baseIoAddress = (PBASE_REGISTER) ioSpace;

            HwDeviceExtension->BaseIoAddress = baseIoAddress;

            //
            // Update the Adapter count
            //

            (Context->adapterCount)++;

            //
            // Check to see if adapter present in system.
            //

            portValue = ScsiPortReadPortUchar((PUCHAR)baseIoAddress);

            //
            // Check for Adaptec adapter.
            // The mask (0x29) are bits that may or may not be set.
            // The bit 0x10 (IOP_SCSI_HBA_IDLE) should be set.
            //

            if ((portValue & ~0x29) == IOP_SCSI_HBA_IDLE) {

                if (!AdaptecAdapter(
                        HwDeviceExtension,
                        ioPort,
                        (BOOLEAN)(ConfigInfo->AdapterInterfaceType == MicroChannel ? TRUE : FALSE))) {

                    DebugPrint((1,"A154xDetermineInstalled: Clone command completed successfully - \n not our board;"));

                    ScsiPortFreeDeviceBase(HwDeviceExtension, ioSpace);
                    continue;

                //
                // Run AMI4448 detection code.
                //

                } else if (A4448IsAmi(HwDeviceExtension,
                                      ConfigInfo,
                                      AdapterAddresses[(Context->adapterCount) - 1])) {

                    DebugPrint ((1,
                                 "A154xDetermineInstalled: Detected AMI4448\n"));
                    ScsiPortFreeDeviceBase(HwDeviceExtension, ioSpace);
                    continue;
                }

                //
                // An adapter has been found. Request another call.
                //

                *Again = TRUE;

                //
                // Fill in the access array information.
                //

                (*ConfigInfo->AccessRanges)[0].RangeStart =
                    ScsiPortConvertUlongToPhysicalAddress(
                        AdapterAddresses[Context->adapterCount - 1]);
                (*ConfigInfo->AccessRanges)[0].RangeLength = 4;
                (*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

                //
                // Check if BIOS is enabled and claim that memory range.
                //

                A154xClaimBIOSSpace(HwDeviceExtension,
                                    baseIoAddress,
                                    Context,
                                    ConfigInfo);

                return (ULONG)SP_RETURN_FOUND;

            } else {
                ScsiPortFreeDeviceBase(HwDeviceExtension, ioSpace);
            }
        }
    }

    //
    // The entire table has been searched and no adapters have been found.
    // There is no need to call again and the device base can now be freed.
    // Clear the adapter count for the next bus.
    //

    *Again = FALSE;
    Context->adapterCount = 0;
    Context->biosScanStart = 0;

     return SP_RETURN_NOT_FOUND;

} // end A154xDetermineInstalled()

VOID
A154xClaimBIOSSpace(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension,
    IN PBASE_REGISTER  BaseIoAddress,
    IN OUT PSCAN_CONTEXT Context,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )

/*++

Routine Description:

    This routine is called from A154xDetermineInstalled to find
    and claim BIOS space.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    BaseIoAddress - IO address of adapter
    ConfigInfo - Miniport configuration information

Return Value:

    None.

--*/

{

    UCHAR  inboundData, byte;
    ULONG  baseBIOSAddress;
    ULONG  i, j;
    PUCHAR biosSpace, biosPtr;
    UCHAR  aha154xBSignature[16] =
           { 0x06, 0x73, 0x01, 0xC3, 0x8A, 0xE7, 0xC6, 0x06,
             0x42, 0x00, 0x00, 0xF9, 0xC3, 0x88, 0x26, 0x42 };

    //
    // Reset interrupt just in case.
    //

    ScsiPortWritePortUchar(&BaseIoAddress->StatusRegister,
                           IOP_INTERRUPT_RESET);

    //
    // The Adapter Inquiry command will return 4 bytes describing
    // the firmware revision level.
    //

    if (WriteCommandRegister(HwDeviceExtension,
                             AC_ADAPTER_INQUIRY,TRUE) == FALSE) {
        return;
    }

    if ((ReadCommandRegister(HwDeviceExtension,
                             &inboundData,TRUE)) == FALSE) {
        return;
    }

    if ((ReadCommandRegister(HwDeviceExtension,&byte,TRUE)) == FALSE) {
        return;
    }

    if ((ReadCommandRegister(HwDeviceExtension,&byte,TRUE)) == FALSE) {
        return;
    }

    if ((ReadCommandRegister(HwDeviceExtension,&byte,TRUE)) == FALSE) {
        return;
    }

    //
    // Wait for HACC by hand.
    //

    SpinForInterrupt(HwDeviceExtension, FALSE);

    //
    // If the 1st bytethe adapter inquiry command is 0x41,
    // then the adapter is an AHA154XB; if 0x44 or 0x45 then
    // it is an AHA154XC or CF respectively
    //
    // if we've already checked all the possible locations for
    // an AHA154XB bios don't waste time mapping the ports
    //

    if ((inboundData == 0x41)&&(Context->biosScanStart < 6)) {

        //
        // Get the system physical address for this BIOS section.
        //

        biosSpace =
            ScsiPortGetDeviceBase(HwDeviceExtension,
                                  ConfigInfo->AdapterInterfaceType,
                                  ConfigInfo->SystemIoBusNumber,
                                  ScsiPortConvertUlongToPhysicalAddress(0xC8000),
                                  0x18000,
                                  FALSE);

        //
        // Loop through all BIOS base possibilities.  Use the context information
        // to pick up where we left off the last time around.
        //

        for (i = Context->biosScanStart; i < 6; i ++) {

            biosPtr = biosSpace + i * 0x4000 + 16;

            //
            // Compare the second 16 bytes to BIOS header

            for (j = 0; j < 16; j++) {

                if (aha154xBSignature[j] != ScsiPortReadRegisterUchar(biosPtr)) {
                    break;
                }

                biosPtr++;
            }

            if (j == 16) {

                //
                // Found the BIOS. Set up ConfigInfo->AccessRanges
                //

                (*ConfigInfo->AccessRanges)[1].RangeStart =
                    ScsiPortConvertUlongToPhysicalAddress(0xC8000 + i * 0x4000);
                (*ConfigInfo->AccessRanges)[1].RangeLength = 0x4000;
                (*ConfigInfo->AccessRanges)[1].RangeInMemory = TRUE;

                DebugPrint((1,
                           "A154xClaimBiosSpace: 154XB BIOS address = %lX\n",
                           0xC8000 + i * 0x4000 ));
                break;
            }
        }

        Context->biosScanStart = i + 1;
        ScsiPortFreeDeviceBase(HwDeviceExtension, (PVOID)biosSpace);

    } else {

        if ((inboundData == 0x44) || (inboundData == 0x45)) {

            //
            // Fill in BIOS address information
            //

            ScsiPortWritePortUchar(&BaseIoAddress->StatusRegister,
                                   IOP_INTERRUPT_RESET);

            if (WriteCommandRegister(HwDeviceExtension,
                                     AC_RETURN_SETUP_DATA,TRUE) == FALSE) {
                return;
            }

            //
            // Send length of incoming transfer for the Return Setup Data
            //

            if (WriteDataRegister(HwDeviceExtension,0x27) == FALSE) {
                return;
            }

            //
            // Magic Adaptec C rev byte.
            //

            for (i = 0; i < 0x27; i++) {
                if ((ReadCommandRegister(HwDeviceExtension,
                                         &inboundData,TRUE)) == FALSE) {
                    return;
                }
            }

            //
            // Interrupt handler is not yet installed so wait for HACC by hand.
            //

            SpinForInterrupt(HwDeviceExtension, FALSE);

            inboundData >>= 4;
            inboundData &= 0x07;        // Filter BIOS bits out
            baseBIOSAddress = 0xC8000;

            if (inboundData != 0x07 && inboundData != 0x06) {

                baseBIOSAddress +=
                    (ULONG)((~inboundData & 0x07) - 2) * 0x4000;

                (*ConfigInfo->AccessRanges)[1].RangeStart =
                    ScsiPortConvertUlongToPhysicalAddress(baseBIOSAddress);
                (*ConfigInfo->AccessRanges)[1].RangeLength = 0x4000;
                (*ConfigInfo->AccessRanges)[1].RangeInMemory = TRUE;

                DebugPrint((1,
                           "A154xClaimBiosSpace: 154XC BIOS address = %lX\n",
                           baseBIOSAddress));
            }
        }
    }

    return;
}



BOOLEAN
A154xHwInitialize(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine is called from ScsiPortInitialize
    to set up the adapter so that it is ready to service requests.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PNONCACHED_EXTENSION noncachedExtension =
    deviceExtension->NoncachedExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    UCHAR status;
    ULONG i;

    DebugPrint((2,"A154xHwInitialize: Reset aha154X and SCSI bus\n"));

    //
    // Reset SCSI chip.
    //

    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_HARD_RESET);

    //
    // Inform the port driver that the bus has been reset.
    //

    ScsiPortNotification(ResetDetected, HwDeviceExtension, 0);

    ScsiPortStallExecution(500*1000);

    //
    // Wait up to 5000 microseconds for adapter to initialize.
    //

    for (i = 0; i < 5000; i++) {

        ScsiPortStallExecution(1);

        status = ScsiPortReadPortUchar(&deviceExtension->BaseIoAddress->StatusRegister);

        if (status & IOP_SCSI_HBA_IDLE) {
            break;
        }
    }

    //
    // Check if reset failed or succeeded.
    //

    if (!(status & IOP_SCSI_HBA_IDLE) || !(status & IOP_MAILBOX_INIT_REQUIRED)) {
        DebugPrint((1,"A154xInitialize: Reset SCSI bus failed\n"));
        return FALSE;
    }

    //
    // Unlock mailboxes in case the adapter is a 1540B with 1Gb support
    // or 1540C with extended translation enabled.
    //

    status = UnlockMailBoxes(deviceExtension);
    (VOID) SpinForInterrupt(deviceExtension,FALSE);  // eddy

    //
    // Zero out mailboxes.
    //

    for (i=0; i<MB_COUNT; i++) {

        PMBO mailboxOut;
        PMBI mailboxIn;

        mailboxIn = &noncachedExtension->Mbi[i];
        mailboxOut = &noncachedExtension->Mbo[i];

        mailboxOut->Command = mailboxIn->Status = 0;
    }

    //
    // Zero preivous indexes.
    //

    deviceExtension->MboIndex = 0;
    deviceExtension->MbiIndex = 0;

    DebugPrint((3,"A154xHwInitialize: Initialize mailbox\n"));

    if (!WriteCommandRegister(deviceExtension,AC_MAILBOX_INITIALIZATION, TRUE)) {
        DebugPrint((1,"A154xHwInitialize: Can't initialize mailboxes\n"));
        return FALSE;
    }

    //
    // Send Adapter number of mailbox locations.
    //

    if (!WriteDataRegister(deviceExtension, MB_COUNT)) {
        return FALSE;
    }

    //
    // Send the most significant byte of the mailbox physical address.
    //

    if (!WriteDataRegister(deviceExtension,
        ((PFOUR_BYTE)&noncachedExtension->MailboxPA)->Byte2)) {
        return FALSE;
    }

    //
    // Send the middle byte of the mailbox physical address.
    //

    if (!WriteDataRegister(deviceExtension,
        ((PFOUR_BYTE)&noncachedExtension->MailboxPA)->Byte1)) {
        return FALSE;
    }

    //
    // Send the least significant byte of the mailbox physical address.
    //

    if (!WriteDataRegister(deviceExtension,
        ((PFOUR_BYTE)&noncachedExtension->MailboxPA)->Byte0)) {
        return FALSE;
    }

#ifdef FORCE_DMA_SPEED
    //
    // Set the DMA transfer speed to 5.0 MB/second. This is because
    // faster transfer speeds cause data corruption on 486/33 machines.
    // This overrides the card jumper setting.
    //

    if (!WriteCommandRegister(deviceExtension, AC_SET_TRANSFER_SPEED, TRUE)) {

        DebugPrint((1,"Can't set dma transfer speed\n"));

    } else if (!WriteDataRegister(deviceExtension, DMA_SPEED_50_MBS)) {

        DebugPrint((1,"Can't set dma transfer speed\n"));
    }

    //
    // Wait for interrupt.
    //

    if (!SpinForInterrupt(deviceExtension,TRUE)) {
        DebugPrint((1,"Timed out waiting for adapter command to complete\n"));
        return TRUE;
    }
#endif

    //
    // Override default setting for bus on time. This makes floppy
    // drives work better with this adapter.
    //

    if (!WriteCommandRegister(deviceExtension, AC_SET_BUS_ON_TIME, TRUE)) {

        DebugPrint((1,"Can't set bus on time\n"));

    } else if (!WriteDataRegister(deviceExtension, deviceExtension->BusOnTime)) {

        DebugPrint((1,"Can't set bus on time\n"));
    }

    //
    // Wait for interrupt.
    //

    if (!SpinForInterrupt(deviceExtension,TRUE)) {
        DebugPrint((1,"Timed out waiting for adapter command to complete\n"));
        return TRUE;
    }


    //
    // Override the default CCB timeout of 250 mseconds to 500 (0x1F4).
    //

    if (!WriteCommandRegister(deviceExtension, AC_SET_SELECTION_TIMEOUT, TRUE)) {
        DebugPrint((1,"A154xHwInitialize: Can't set CCB timeout\n"));
    }
    else {
        if (!WriteDataRegister(deviceExtension,0x01)) {
            DebugPrint((1,"A154xHwInitialize: Can't set timeout selection enable\n"));
        }

        if (!WriteDataRegister(deviceExtension,0x00)) {
            DebugPrint((1,"A154xHwInitialize: Can't set second byte\n"));
        }

        if (!WriteDataRegister(deviceExtension,0x01)) {
            DebugPrint((1,"A154xHwInitialize: Can't set MSB\n"));
        }

        if (!WriteDataRegister(deviceExtension,0xF4)) {
            DebugPrint((1,"A154xHwInitialize: Can't set LSB\n"));
        }
    }


    //
    // Wait for interrupt.
    //

    if (!SpinForInterrupt(deviceExtension,TRUE)) {
        DebugPrint((1,"Timed out waiting for adapter command to complete\n"));
        return TRUE;
    }

#if defined(_SCAM_ENABLED)
    //
    // SCAM because A154xHwInitialize reset's the SCSI bus.
    //

    PerformScamProtocol(deviceExtension);
#endif

    return TRUE;

} // end A154xHwInitialize()

#if defined(_SCAM_ENABLED)

BOOLEAN
PerformScamProtocol(
    IN PHW_DEVICE_EXTENSION deviceExtension
        )

{

    if (deviceExtension->PerformScam) {

        DebugPrint((1,"AHA154x => Starting SCAM operation.\n"));

        if (!WriteCommandRegister(deviceExtension, AC_PERFORM_SCAM, TRUE)) {

            DebugPrint((0,"AHA154x => Adapter time out, SCAM command failure.\n"));

            ScsiPortLogError(deviceExtension,
                             NULL,
                             0,
                             deviceExtension->HostTargetId,
                             0,
                             SP_INTERNAL_ADAPTER_ERROR,
                             0xA << 8);
            return FALSE;

        } else {

            DebugPrint((1,"AHA154x => SCAM Performed OK.\n"));
            return TRUE;
        }
    } else {

        DebugPrint((1,"AHA154x => SCAM not performed, non-SCAM adapter.\n"));
        return FALSE;
    }

} //End PerformScamProtocol
#endif


BOOLEAN
A154xStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine is called from the SCSI port driver synchronized
    with the kernel. The mailboxes are scanned for an empty one and
    the CCB is written to it. Then the doorbell is rung and the
    OS port driver is notified that the adapter can take
    another request, if any are available.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    TRUE

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PNONCACHED_EXTENSION noncachedExtension =
    deviceExtension->NoncachedExtension;
    PMBO mailboxOut;
    PCCB ccb;
    PHW_LU_EXTENSION luExtension;

    ULONG i = deviceExtension->MboIndex;
    ULONG physicalCcb;
    ULONG length;

    DebugPrint((3,"A154xStartIo: Enter routine\n"));

    //
    // Check if command is a WMI request.
    //

    if (Srb->Function == SRB_FUNCTION_WMI) {

       //
       // Process the WMI request and return.
       //

       return A154xWmiSrb(HwDeviceExtension, (PSCSI_WMI_REQUEST_BLOCK) Srb);
    }

    //
    // Check if command is an ABORT request.
    //

    if (Srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

        //
        // Verify that SRB to abort is still outstanding.
        //

        luExtension =
            ScsiPortGetLogicalUnit(deviceExtension,
                       Srb->PathId,
                       Srb->TargetId,
                       Srb->Lun);

        if ((luExtension == NULL) ||
            (luExtension->CurrentSrb == NULL)) {

            DebugPrint((1, "A154xStartIo: SRB to abort already completed\n"));

            //
            // Complete abort SRB.
            //

            Srb->SrbStatus = SRB_STATUS_ABORT_FAILED;

            ScsiPortNotification(RequestComplete,
                 deviceExtension,
                Srb);
            //
            // Adapter ready for next request.
            //

            ScsiPortNotification(NextRequest,
                deviceExtension,
                NULL);

            return TRUE;
        }

        //
        // Get CCB to abort.
        //

        ccb = Srb->NextSrb->SrbExtension;

        //
        // Set abort SRB for completion.
        //

        ccb->AbortSrb = Srb;

    } else {

        ccb = Srb->SrbExtension;

        //
        // Save SRB back pointer in CCB.
        //

        ccb->SrbAddress = Srb;
    }

    //
    // Make sure that this request isn't too long for the adapter.  If so
    // bounce it back as an invalid request
    //

    if ((deviceExtension->MaxCdbLength) &&
        (deviceExtension->MaxCdbLength < Srb->CdbLength)) {

        DebugPrint((1,"A154xStartIo: Srb->CdbLength [%d] > MaxCdbLength [%d].  Invalid request\n",
                    Srb->CdbLength,
                    deviceExtension->MaxCdbLength
                  ));

        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

        ScsiPortNotification(RequestComplete,
            deviceExtension,
            Srb);

        ScsiPortNotification(NextRequest,
            deviceExtension,
            NULL);

        return TRUE;
    }

    //
    // Get CCB physical address.
    //

    physicalCcb = ScsiPortConvertPhysicalAddressToUlong(
        ScsiPortGetPhysicalAddress(deviceExtension, NULL, ccb, &length));

    //
    // Find free mailboxOut.
    //

    do {

        mailboxOut = &noncachedExtension->Mbo[i % MB_COUNT];
        i++;

    } while (mailboxOut->Command != MBO_FREE);

    //
    // Save the next free location.
    //

    deviceExtension->MboIndex = (UCHAR) (i % MB_COUNT);

    DebugPrint((3,"A154xStartIo: MBO address %lx, Loop count = %d\n", mailboxOut, i));

    //
    // Write CCB to mailbox.
    //

    FOUR_TO_THREE(&mailboxOut->Address,
          (PFOUR_BYTE)&physicalCcb);

    switch (Srb->Function) {

        case SRB_FUNCTION_ABORT_COMMAND:

            DebugPrint((1, "A154xStartIo: Abort request received\n"));

            //
            // Race condition (what if CCB to be aborted
            // completes after setting new SrbAddress?)
            //

            mailboxOut->Command = MBO_ABORT;

            break;

        case SRB_FUNCTION_RESET_BUS:

            //
            // Reset aha154x and SCSI bus.
            //

            DebugPrint((1, "A154xStartIo: Reset bus request received\n"));

            if (!A154xResetBus(
                deviceExtension,
                Srb->PathId
                )) {

                DebugPrint((1,"A154xStartIo: Reset bus failed\n"));

                Srb->SrbStatus = SRB_STATUS_ERROR;

            } else {

                Srb->SrbStatus = SRB_STATUS_SUCCESS;
            }


            ScsiPortNotification(RequestComplete,
                deviceExtension,
                Srb);

            ScsiPortNotification(NextRequest,
                deviceExtension,
                NULL);

            return TRUE;

        case SRB_FUNCTION_EXECUTE_SCSI:

            //
            // Get logical unit extension.
            //

            luExtension =
            ScsiPortGetLogicalUnit(deviceExtension,
                       Srb->PathId,
                       Srb->TargetId,
                       Srb->Lun);

            //
            // Move SRB to logical unit extension.
            //

            luExtension->CurrentSrb = Srb;

            //
            // Build CCB.
            //

            BuildCcb(deviceExtension, Srb);

            mailboxOut->Command = MBO_START;

            break;

        case SRB_FUNCTION_RESET_DEVICE:

            DebugPrint((1,"A154xStartIo: Reset device not supported\n"));

            //
            // Drop through to default.
            //

        default:

            //
            // Set error, complete request
            // and signal ready for next request.
            //

            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

            ScsiPortNotification(RequestComplete,
                deviceExtension,
                Srb);

            ScsiPortNotification(NextRequest,
                deviceExtension,
                NULL);

            return TRUE;

    } // end switch

    //
    // Tell 154xb a CCB is available now.
    //

    if (!WriteCommandRegister(deviceExtension,AC_START_SCSI_COMMAND, FALSE)) {

        //
        // Let request time out and fail.
        //

        DebugPrint((1,"A154xStartIo: Can't write command to adapter\n"));

        deviceExtension->PendingRequest = TRUE;

    } else {

        //
        // Command(s) submitted. Clear pending request flag.
        //

        deviceExtension->PendingRequest = FALSE;

        //
        // Adapter ready for next request.
        //

        ScsiPortNotification(NextRequest,
            deviceExtension,
            NULL);
        }

    return TRUE;

} // end A154xStartIo()


BOOLEAN
A154xInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This is the interrupt service routine for the adaptec 154x SCSI adapter.
    It reads the interrupt register to determine if the adapter is indeed
    the source of the interrupt and clears the interrupt at the device.
    If the adapter is interrupting because a mailbox is full, the CCB is
    retrieved to complete the request.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE if MailboxIn full

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PNONCACHED_EXTENSION noncachedExtension =
    deviceExtension->NoncachedExtension;
    PCCB ccb;
    PSCSI_REQUEST_BLOCK srb;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    PMBI mailboxIn;
    ULONG physicalCcb;
    PHW_LU_EXTENSION luExtension;
    ULONG residualBytes;
    ULONG i;

    UCHAR InterruptFlags;

    InterruptFlags = ScsiPortReadPortUchar(&baseIoAddress->InterruptRegister);

    //
    // Determine cause of interrupt.
    //

    if(InterruptFlags == 0) {

        DebugPrint((4,"A154xInterrupt: Spurious interrupt\n"));

        return FALSE;
    }

    if (InterruptFlags & IOP_COMMAND_COMPLETE) {

        //
        // Adapter command completed.
        //

        DebugPrint((2,"A154xInterrupt: Adapter Command complete\n"));
        DebugPrint((3,"A154xInterrupt: Interrupt flags %x\n", InterruptFlags));
        DebugPrint((3,"A154xInterrupt: Status %x\n",
            ScsiPortReadPortUchar(&baseIoAddress->StatusRegister)));

        //
        // Clear interrupt on adapter.
        //

        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

        return TRUE;

    } else if (InterruptFlags & IOP_MBI_FULL) {

        DebugPrint((3,"A154xInterrupt: MBI Full\n"));

        //
        // Clear interrupt on adapter.
        //

        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

    } else if (InterruptFlags & IOP_SCSI_RESET_DETECTED) {

        DebugPrint((1,"A154xInterrupt: SCSI Reset detected\n"));

        //
        // Clear interrupt on adapter.
        //

        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

        //
        // Notify of reset.
        //

        ScsiPortNotification(ResetDetected,
                 deviceExtension,
                 NULL);

#if defined(_SCAM_ENABLED)
        //
        // Interrupt handler where reset is detected
        //
        PerformScamProtocol(deviceExtension);
#endif

        return TRUE;

    }

    //
    // Determine which MailboxIn location contains the CCB.
    //

    for (i=0; i<MB_COUNT; i++) {

        mailboxIn = &noncachedExtension->Mbi[deviceExtension->MbiIndex];

        //
        // Look for a mailbox entry with a legitimate status.
        //

        if (mailboxIn->Status != MBI_FREE) {

            //
            // Point to the next in box.
            //

            deviceExtension->MbiIndex = (deviceExtension->MbiIndex + 1) % MB_COUNT;

            //
            // MBI found. Convert CCB to big endian.
            //

            THREE_TO_FOUR((PFOUR_BYTE)&physicalCcb,
                &mailboxIn->Address);

            DebugPrint((3, "A154xInterrupt: Physical CCB %lx\n", physicalCcb));

            //
            // Check if physical CCB is zero.
            // This is done to cover for hardware errors.
            //

            if (!physicalCcb) {

                DebugPrint((1,"A154xInterrupt: Physical CCB address is 0\n"));

                //
                // Indicate MBI is available.
                //

                mailboxIn->Status = MBI_FREE;

                continue;
            }

            //
            // Convert Physical CCB to Virtual.
            //

            ccb = ScsiPortGetVirtualAddress(deviceExtension, ScsiPortConvertUlongToPhysicalAddress(physicalCcb));


            DebugPrint((3, "A154xInterrupt: Virtual CCB %lx\n", ccb));

            //
            // Make sure the virtual address was found.
            //

            if (ccb == NULL) {

                //
                // A bad physcial address was return by the adapter.
                // Log it as an error.
                //

                ScsiPortLogError(
                    HwDeviceExtension,
                    NULL,
                    0,
                    deviceExtension->HostTargetId,
                    0,
                    SP_INTERNAL_ADAPTER_ERROR,
                    5 << 8
                    );

                //
                // Indicate MBI is available.
                //

                mailboxIn->Status = MBI_FREE;

                continue;
            }

            //
            // Get SRB from CCB.
            //

            srb = ccb->SrbAddress;

            //
            // Get logical unit extension.
            //

            luExtension =
                ScsiPortGetLogicalUnit(deviceExtension,
                                       srb->PathId,
                                       srb->TargetId,
                                       srb->Lun);

            //
            // Make sure the luExtension was found and it has a current request.
            //

            if (luExtension == NULL || (luExtension->CurrentSrb == NULL &&
                mailboxIn->Status != MBI_NOT_FOUND)) {

                //
                // A bad physcial address was return by the adapter.
                // Log it as an error.
                //

                ScsiPortLogError(
                    HwDeviceExtension,
                    NULL,
                    0,
                    deviceExtension->HostTargetId,
                    0,
                    SP_INTERNAL_ADAPTER_ERROR,
                    (6 << 8) | mailboxIn->Status
                    );

                //
                // Indicate MBI is available.
                //

                mailboxIn->Status = MBI_FREE;

                continue;
            }

            //
            // Check MBI status.
            //

            switch (mailboxIn->Status) {

                case MBI_SUCCESS:

                    srb->SrbStatus = SRB_STATUS_SUCCESS;

                    //
                    // Check for data underrun if using scatter/gather
                    // command with residual bytes.
                    //

                    if (deviceExtension->CcbScatterGatherCommand == SCATTER_GATHER_COMMAND) {

                        //
                        // Update SRB with number of bytes transferred.
                        //

                        THREE_TO_FOUR((PFOUR_BYTE)&residualBytes,
                            &ccb->DataLength);

                        if (residualBytes != 0) {

                            ULONG transferLength = srb->DataTransferLength;

                            DebugPrint((2,
                                       "A154xInterrupt: Underrun occured. Request length = %lx, Residual length = %lx\n",
                                       srb->DataTransferLength,
                                       residualBytes));

                            //
                            // Update SRB with bytes transferred and
                            // underrun status.
                            //

                            srb->DataTransferLength -= residualBytes;
                            srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;

                            if ((LONG)(srb->DataTransferLength) < 0) {

                                DebugPrint((0,
                                           "A154xInterrupt: Overrun occured. Request length = %lx, Residual length = %lx\n",
                                           transferLength,
                                           residualBytes));
                                //
                                // Seems to be a FW bug in some revs. where
                                // residual comes back as a negative number, yet the
                                // request is successful.
                                //

                                srb->DataTransferLength = 0;
                                srb->SrbStatus = SRB_STATUS_PHASE_SEQUENCE_FAILURE;


                                //
                                // Log the event and then the residual byte count.
                                //

                                ScsiPortLogError(HwDeviceExtension,
                                                 NULL,
                                                 0,
                                                 deviceExtension->HostTargetId,
                                                 0,
                                                 SP_PROTOCOL_ERROR,
                                                 0xb);

                                ScsiPortLogError(HwDeviceExtension,
                                                 NULL,
                                                 0,
                                                 deviceExtension->HostTargetId,
                                                 0,
                                                 SP_PROTOCOL_ERROR,
                                                 residualBytes);

                            }
                        }
                    }

                    luExtension->CurrentSrb = NULL;

                    break;

                case MBI_NOT_FOUND:

                    DebugPrint((1, "A154xInterrupt: CCB abort failed %lx\n", ccb));

                    srb = ccb->AbortSrb;

                    srb->SrbStatus = SRB_STATUS_ABORT_FAILED;

                    //
                    // Check if SRB still outstanding.
                    //

                    if (luExtension->CurrentSrb) {

                        //
                        // Complete this SRB.
                        //

                        luExtension->CurrentSrb->SrbStatus = SRB_STATUS_TIMEOUT;

                        ScsiPortNotification(RequestComplete,
                            deviceExtension,
                            luExtension->CurrentSrb);

                        luExtension->CurrentSrb = NULL;
                    }

                    break;

                case MBI_ABORT:

                    DebugPrint((1, "A154xInterrupt: CCB aborted\n"));

                    //
                    // Update target status in aborted SRB.
                    //

                    srb->SrbStatus = SRB_STATUS_ABORTED;

                    //
                    // Call notification routine for the aborted SRB.
                    //

                    ScsiPortNotification(RequestComplete,
                        deviceExtension,
                        srb);

                    luExtension->CurrentSrb = NULL;

                    //
                    // Get the abort SRB from CCB.
                    //

                    srb = ccb->AbortSrb;

                    //
                    // Set status for completing abort request.
                    //

                    srb->SrbStatus = SRB_STATUS_SUCCESS;

                    break;

                case MBI_ERROR:

                        DebugPrint((2, "A154xInterrupt: Error occurred\n"));

                        srb->SrbStatus = MapError(deviceExtension, srb, ccb);

                        //
                        // Check if ABORT command.
                        //

                        if (srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

                            //
                            // Check if SRB still outstanding.
                            //

                            if (luExtension->CurrentSrb) {

                                //
                                // Complete this SRB.
                                //

                                luExtension->CurrentSrb->SrbStatus = SRB_STATUS_TIMEOUT;

                                ScsiPortNotification(RequestComplete,
                                                     deviceExtension,
                                                     luExtension->CurrentSrb);

                            }

                            DebugPrint((1,"A154xInterrupt: Abort command failed\n"));
                        }

                        luExtension->CurrentSrb = NULL;

                        break;

                    default:

                        //
                        // Log the error.
                        //

                        ScsiPortLogError(
                            HwDeviceExtension,
                            NULL,
                            0,
                            deviceExtension->HostTargetId,
                            0,
                            SP_INTERNAL_ADAPTER_ERROR,
                            (1 << 8) | mailboxIn->Status
                            );

                        DebugPrint((1, "A154xInterrupt: Unrecognized mailbox status\n"));

                        mailboxIn->Status = MBI_FREE;

                        continue;

                } // end switch

                //
                // Indicate MBI is available.
                //

                mailboxIn->Status = MBI_FREE;

                DebugPrint((2, "A154xInterrupt: SCSI Status %x\n", srb->ScsiStatus));

                DebugPrint((2, "A154xInterrupt: Adapter Status %x\n", ccb->HostStatus));

                //
                // Update target status in SRB.
                //

                srb->ScsiStatus = ccb->TargetStatus;

                //
                // Signal request completion.
                //

                ScsiPortNotification(RequestComplete,
                                     (PVOID)deviceExtension,
                                     srb);

        } else {

            break;

        } // end if ((mailboxIn->Status == MBI_SUCCESS ...

    } // end for (i=0; i<MB_COUNT; i++) {

    if (deviceExtension->PendingRequest) {

        //
        // The last write command to the adapter failed.  Try and start it now.
        //

        deviceExtension->PendingRequest = FALSE;

        //
        // Tell 154xb a CCB is available now.
        //

        if (!WriteCommandRegister(deviceExtension,AC_START_SCSI_COMMAND, FALSE)) {

            //
            // Let request time out and fail.
            //

            DebugPrint((1,"A154xInterrupt: Can't write command to adapter\n"));

            deviceExtension->PendingRequest = TRUE;

        } else {

            //
            // Adapter ready for next request.
            //

             ScsiPortNotification(NextRequest,
                                  deviceExtension,
                                  NULL);
        }
    }

    return TRUE;

} // end A154xInterrupt()


VOID
BuildCcb(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Build CCB for 154x.

Arguments:

    DeviceExtenson
    SRB

Return Value:

    Nothing.

--*/

{
    PCCB ccb = Srb->SrbExtension;

    DebugPrint((3,"BuildCcb: Enter routine\n"));

    //
    // Set target id and LUN.
    //

    ccb->ControlByte = (UCHAR)(Srb->TargetId << 5) | Srb->Lun;

    //
    // Set CCB Operation Code.
    //

    ccb->OperationCode = DeviceExtension->CcbScatterGatherCommand;

    //
    // Set transfer direction bit.
    //

    if (Srb->SrbFlags & SRB_FLAGS_DATA_OUT) {

        //
        // Check if both direction bits are set. This is an
        // indication that the direction has not been specified.
        //

        if (!(Srb->SrbFlags & SRB_FLAGS_DATA_IN)) {
            ccb->ControlByte |= CCB_DATA_XFER_OUT;
        }

    } else if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {
        ccb->ControlByte |= CCB_DATA_XFER_IN;
    } else {

        //
        // if no data transfer, we must set ccb command to to INITIATOR
        // instead of SCATTER_GATHER and zero ccb data pointer and length.
        //

        ccb->OperationCode = DeviceExtension->CcbInitiatorCommand;
        ccb->DataPointer.Msb = 0;
        ccb->DataPointer.Mid = 0;
        ccb->DataPointer.Lsb = 0;
        ccb->DataLength.Msb = 0;
        ccb->DataLength.Mid = 0;
        ccb->DataLength.Lsb = 0;
    }

    //
    // 01h disables auto request sense.
    //

    ccb->RequestSenseLength = 1;

    //
    // Set CDB length and copy to CCB.
    //

    ccb->CdbLength = (UCHAR)Srb->CdbLength;

    ScsiPortMoveMemory(ccb->Cdb, Srb->Cdb, ccb->CdbLength);

    //
    // Set reserved bytes to zero.
    //

    ccb->Reserved[0] = 0;
    ccb->Reserved[1] = 0;

    ccb->LinkIdentifier = 0;

    //
    // Zero link pointer.
    //

    ccb->LinkPointer.Msb = 0;
    ccb->LinkPointer.Lsb = 0;
    ccb->LinkPointer.Mid = 0;

    //
    // Build SDL in CCB if data transfer.
    //

    if (Srb->DataTransferLength > 0) {
        BuildSdl(DeviceExtension, Srb);
    }

    //
    // Move 0xff to Target Status to indicate
    // CCB has not completed.
    //

    ccb->TargetStatus = 0xFF;

    return;

} // end BuildCcb()


VOID
BuildSdl(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine builds a scatter/gather descriptor list for the CCB.

Arguments:

    DeviceExtension
    Srb

Return Value:

    None

--*/

{
    PVOID dataPointer = Srb->DataBuffer;
    ULONG bytesLeft = Srb->DataTransferLength;
    PCCB ccb = Srb->SrbExtension;
    PSDL sdl = &ccb->Sdl;
    ULONG physicalSdl;
    ULONG physicalAddress;
    ULONG length;
    ULONG four;
    PTHREE_BYTE three;
    ULONG i = 0;

    DebugPrint((3,"BuildSdl: Enter routine\n"));

    //
    // Get physical SDL address.
    //

    physicalSdl = ScsiPortConvertPhysicalAddressToUlong(
        ScsiPortGetPhysicalAddress(DeviceExtension, NULL,
        sdl, &length));

   //
   // Create SDL segment descriptors.
   //

   do {

        DebugPrint((3, "BuildSdl: Data buffer %lx\n", dataPointer));

        //
        // Get physical address and length of contiguous
        // physical buffer.
        //

        physicalAddress =
            ScsiPortConvertPhysicalAddressToUlong(
            ScsiPortGetPhysicalAddress(DeviceExtension,
                    Srb,
                    dataPointer,
                    &length));

        DebugPrint((3, "BuildSdl: Physical address %lx\n", physicalAddress));
        DebugPrint((3, "BuildSdl: Data length %lx\n", length));
        DebugPrint((3, "BuildSdl: Bytes left %lx\n", bytesLeft));

        //
        // If length of physical memory is more
        // than bytes left in transfer, use bytes
        // left as final length.
        //

        if  (length > bytesLeft) {
            length = bytesLeft;
        }

        //
        // Convert length to 3-byte big endian format.
        //

        four = length;
        three = &sdl->Sgd[i].Length;
        FOUR_TO_THREE(three, (PFOUR_BYTE)&four);

        //
        // Convert physical address to 3-byte big endian format.
        //

        four = (ULONG)physicalAddress;
        three = &sdl->Sgd[i].Address;
        FOUR_TO_THREE(three, (PFOUR_BYTE)&four);
        i++;

        //
        // Adjust counts.
        //

        dataPointer = (PUCHAR)dataPointer + length;
        bytesLeft -= length;

    } while (bytesLeft);

        //##BW
        //
        // For data transfers that have less than one scatter gather element, convert
        // CCB to one transfer without using SG element. This will clear up the data
        // overrun/underrun problem with small transfers that reak havoc with scanners
        // and CD-ROM's etc. This is the method employed in ASPI4DOS to avoid similar
        // problems.
        //
        if (i == 0x1) {
                //
                // Only one element, so convert...
                //

                //
                // The above Do..While loop performed all necessary conversions for the
                // SRB buffer, so we copy over the length and address directly into the
                // CCB
                //
                ccb->DataLength  = sdl->Sgd[0x0].Length;
                ccb->DataPointer = sdl->Sgd[0x0].Address;

                //
                // Change the OpCode from SG command to initiator command and we're
                // done. Easy, huh?
                //
                ccb->OperationCode = SCSI_INITIATOR_COMMAND; //##BW _OLD_ command?

        } else {
                //
                // Multiple SG elements, so continue as normal.
                //

            //
            // Write SDL length to CCB.
            //

            four = i * sizeof(SGD);
            three = &ccb->DataLength;
            FOUR_TO_THREE(three, (PFOUR_BYTE)&four);

            DebugPrint((3,"BuildSdl: SDL length is %d\n", four));

            //
            // Write SDL address to CCB.
            //

            FOUR_TO_THREE(&ccb->DataPointer,
                (PFOUR_BYTE)&physicalSdl);

            DebugPrint((3,"BuildSdl: SDL address is %lx\n", sdl));

            DebugPrint((3,"BuildSdl: CCB address is %lx\n", ccb));
        }

    return;

} // end BuildSdl()


BOOLEAN
A154xResetBus(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    )

/*++

Routine Description:

    Reset Adaptec 154X SCSI adapter and SCSI bus.
    Initialize adapter mailbox.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Nothing.


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PNONCACHED_EXTENSION noncachedExtension =
    deviceExtension->NoncachedExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    UCHAR status;
    ULONG i;

    DebugPrint((2,"ResetBus: Reset aha154X and SCSI bus\n"));

    //
    // Complete all outstanding requests with SRB_STATUS_BUS_RESET.
    //

    ScsiPortCompleteRequest(deviceExtension,
                (UCHAR) PathId,
                0xFF,
                0xFF,
                (ULONG) SRB_STATUS_BUS_RESET);

    //
    // Read status register.
    //

    status = ScsiPortReadPortUchar(&baseIoAddress->StatusRegister);

    //
    // If value is normal then reset device only.
    //

    if ((status & ~IOP_MAILBOX_INIT_REQUIRED) != IOP_SCSI_HBA_IDLE) {

        //
        // Reset SCSI chip.
        //

        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_HARD_RESET);

        ScsiPortStallExecution(500 * 1000);

        //
        // Wait up to 5000 microseconds for adapter to initialize.
        //

        for (i = 0; i < 5000; i++) {

            ScsiPortStallExecution(1);

            status = ScsiPortReadPortUchar(&deviceExtension->BaseIoAddress->StatusRegister);

            if (status & IOP_SCSI_HBA_IDLE) {
                break;
            }
        }
    }

    //
    // Zero out mailboxes.
    //

    for (i=0; i<MB_COUNT; i++) {

        PMBO mailboxOut;
        PMBI mailboxIn;

        mailboxIn = &noncachedExtension->Mbi[i];
        mailboxOut = &noncachedExtension->Mbo[i];

        mailboxOut->Command = mailboxIn->Status = 0;
    }

    //
    // Zero previous indexes.
    //

    deviceExtension->MboIndex = 0;
    deviceExtension->MbiIndex = 0;

    if (deviceExtension->PendingRequest) {

        deviceExtension->PendingRequest = FALSE;

        //
        // Adapter ready for next request.
        //

        ScsiPortNotification(NextRequest,
                 deviceExtension,
                 NULL);
    }

    if (!(status & IOP_SCSI_HBA_IDLE)) {
        return(FALSE);
    }

    //
    // Unlock mailboxes in case the adapter is a 1540B with 1Gb support
    // or 1540C with extended translation enabled.  Maiboxes cannot be
    // initialized until unlock code is sent.

    status = UnlockMailBoxes(deviceExtension);

    if (!SpinForInterrupt(deviceExtension,FALSE)) {
        DebugPrint((1,"A154xResetBus: Failed to unlock mailboxes\n"));
        return FALSE;
    }

    DebugPrint((3,"ResetBus: Initialize mailbox\n"));

    if (!WriteCommandRegister(deviceExtension,AC_MAILBOX_INITIALIZATION, TRUE)) {
        DebugPrint((1,"A154xResetBus: Can't initialize mailboxes\n"));
        return FALSE;
    }

    //
    // Send Adapter number of mailbox locations.
    //

    if (!WriteDataRegister(deviceExtension,MB_COUNT)) {
        return FALSE;
    }

    //
    // Send the most significant byte of the mailbox physical address.
    //

    if (!WriteDataRegister(deviceExtension,
        ((PFOUR_BYTE)&noncachedExtension->MailboxPA)->Byte2)) {
        return FALSE;
    }

    //
    // Send the middle byte of the mailbox physical address.
    //

    if (!WriteDataRegister(deviceExtension,
        ((PFOUR_BYTE)&noncachedExtension->MailboxPA)->Byte1)) {
        return FALSE;
    }

    //
    // Send the least significant byte of the mailbox physical address.
    //

    if (!WriteDataRegister(deviceExtension,
        ((PFOUR_BYTE)&noncachedExtension->MailboxPA)->Byte0)) {
        return FALSE;
    }

#ifdef FORCE_DMA_SPEED
    //
    // Set the DMA transfer speed to 5.0 MB/second. This is because
    // faster transfer speeds cause data corruption on 486/33 machines.
    // This overrides the card jumper setting.
    //

    if (!WriteCommandRegister(deviceExtension, AC_SET_TRANSFER_SPEED, TRUE)) {

        DebugPrint((1,"Can't set dma transfer speed\n"));

    } else if (!WriteDataRegister(deviceExtension, DMA_SPEED_50_MBS)) {

        DebugPrint((1,"Can't set dma transfer speed\n"));
    }

    //
    // Wait for interrupt.
    //

    if (!SpinForInterrupt(deviceExtension,TRUE)) {
        DebugPrint((1,"Timed out waiting for adapter command to complete\n"));
    }
#endif

    //
    // Override default setting for bus on time. This makes floppy
    // drives work better with this adapter.
    //

    if (!WriteCommandRegister(deviceExtension, AC_SET_BUS_ON_TIME, TRUE)) {

        DebugPrint((1,"Can't set bus on time\n"));

    } else if (!WriteDataRegister(deviceExtension, 0x07)) {

        DebugPrint((1,"Can't set bus on time\n"));
    }

    //
    // Wait for interrupt.
    //

    if (!SpinForInterrupt(deviceExtension,TRUE)) {
        DebugPrint((1,"Timed out waiting for adapter command to complete\n"));
    }

#if defined(_SCAM_ENABLED)
        //
        // SCAM because we're a154xResetBus
        //
    PerformScamProtocol(deviceExtension);
#endif
    return TRUE;


} // end A154xResetBus()


UCHAR
MapError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    Translate A154x error to SRB error, and log an error if necessary.

Arguments:

    HwDeviceExtension - The hardware device extension.

    Srb - The failing Srb.

    Ccb - Command Control Block contains error.

Return Value:

    SRB Error

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    UCHAR status;
    ULONG logError;
    ULONG residualBytes;

    switch (Ccb->HostStatus) {

        case CCB_SELECTION_TIMEOUT:

            return SRB_STATUS_SELECTION_TIMEOUT;

        case CCB_COMPLETE:

            if (Ccb->TargetStatus == SCSISTAT_CHECK_CONDITION) {

                //
                // Update SRB with number of bytes transferred.
                //

                THREE_TO_FOUR((PFOUR_BYTE)&residualBytes,
                          &Ccb->DataLength);

                DebugPrint((2, "Aha154x MapError: Underrun occured. Request length = %lx, Residual length = %lx\n", Srb->DataTransferLength, residualBytes));
                if (Srb->DataTransferLength < residualBytes) {
                    DebugPrint((0,
                               "A154xInterrupt: Overrun occured. Request length = %lx, Residual length = %lx\n",
                               Srb->DataTransferLength,
                               residualBytes));
                    //
                    // Seems to be a FW bug in some revs. where
                    // residual comes back as a negative number, yet the
                    // request is successful.
                    //

                    Srb->DataTransferLength = 0;
                    Srb->SrbStatus = SRB_STATUS_PHASE_SEQUENCE_FAILURE;

                    //
                    // Log the event and then the residual byte count.
                    //

                    ScsiPortLogError(HwDeviceExtension,
                                     NULL,
                                     0,
                                     deviceExtension->HostTargetId,
                                     0,
                                     SP_PROTOCOL_ERROR,
                                     0xc << 8);

                    return(SRB_STATUS_PHASE_SEQUENCE_FAILURE);

                } else {
                    Srb->DataTransferLength -= residualBytes;
                }

            }

            return SRB_STATUS_ERROR;

        case CCB_DATA_OVER_UNDER_RUN:


            //
            // Check for data underrun if using scatter/gather
            // command with residual bytes.
            //

            if (deviceExtension->CcbScatterGatherCommand == SCATTER_GATHER_COMMAND) {

                THREE_TO_FOUR((PFOUR_BYTE)&residualBytes,
                      &Ccb->DataLength);

                if (residualBytes) {
                    if (Srb->DataTransferLength < residualBytes) {

                        DebugPrint((0,
                                   "A154xInterrupt: Overrun occured. Request length = %lx, Residual length = %lx\n",
                                   Srb->DataTransferLength,
                                   residualBytes));
                        //
                        // Seems to be a FW bug in some revs. where
                        // residual comes back as a negative number, yet the
                        // request is successful.
                        //

                        Srb->DataTransferLength = 0;
                        Srb->SrbStatus = SRB_STATUS_PHASE_SEQUENCE_FAILURE;

                        //
                        // Log the event and then the residual byte count.
                        //

                        ScsiPortLogError(HwDeviceExtension,
                                         NULL,
                                         0,
                                         deviceExtension->HostTargetId,
                                         0,
                                         SP_PROTOCOL_ERROR,
                                         0xd << 8);

                        return(SRB_STATUS_PHASE_SEQUENCE_FAILURE);

                    } else {
                        Srb->DataTransferLength -= residualBytes;
                    }

                    return SRB_STATUS_DATA_OVERRUN; //##BW this look good
                } else {
                    logError = SP_PROTOCOL_ERROR;
                }
            }

                        //
                        //  Return instead of posting DU/DO to the log file.
                        //
            //status = SRB_STATUS_DATA_OVERRUN;
            return SRB_STATUS_DATA_OVERRUN;
            break;

        case CCB_UNEXPECTED_BUS_FREE:
            status = SRB_STATUS_UNEXPECTED_BUS_FREE;
            logError = SP_UNEXPECTED_DISCONNECT;
            break;

        case CCB_PHASE_SEQUENCE_FAIL:
        case CCB_INVALID_DIRECTION:
            status = SRB_STATUS_PHASE_SEQUENCE_FAILURE;
            logError = SP_PROTOCOL_ERROR;
            break;

        case CCB_INVALID_OP_CODE:

            //
            // Try CCB commands without residual bytes.
            //

            deviceExtension->CcbScatterGatherCommand = SCATTER_GATHER_OLD_COMMAND;
            deviceExtension->CcbInitiatorCommand = SCSI_INITIATOR_OLD_COMMAND;
            status = SRB_STATUS_INVALID_REQUEST;
            logError = SP_BAD_FW_WARNING;
            break;

        case CCB_INVALID_CCB:
        case CCB_BAD_MBO_COMMAND:
        case CCB_BAD_LINKED_LUN:
        case CCB_DUPLICATE_CCB:
            status = SRB_STATUS_INVALID_REQUEST;
            logError = SP_INTERNAL_ADAPTER_ERROR;
            break;

        default:
            status = SRB_STATUS_ERROR;
            logError = SP_INTERNAL_ADAPTER_ERROR;
            break;
        }

    ScsiPortLogError(
            HwDeviceExtension,
            Srb,
            Srb->PathId,
            Srb->TargetId,
            Srb->Lun,
            logError,
            (2 << 8) | Ccb->HostStatus
            );

    return(status);

} // end MapError()


BOOLEAN
ReadCommandRegister(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    OUT PUCHAR DataByte,
    IN BOOLEAN TimeOutFlag
    )

/*++

Routine Description:

    Read command register.

Arguments:

    DeviceExtesion - Pointer to adapder extension
    DataByte - Byte read from register

Return Value:

    TRUE if command register read.
    FALSE if timed out waiting for adapter.

--*/

{
    PBASE_REGISTER baseIoAddress = DeviceExtension->BaseIoAddress;
    ULONG i;

    //
    // Wait up to 5000 microseconds for adapter to be ready.
    //

    for (i=0; i<5000; i++) {

        if (ScsiPortReadPortUchar(&baseIoAddress->StatusRegister) &
            IOP_DATA_IN_PORT_FULL) {

            //
            // Adapter ready. Break out of loop.
            //

            break;

        } else {

            //
            // Stall 1 microsecond before
            // trying again.
            //

            ScsiPortStallExecution(1);
        }
    }

    if ( (i==5000) && (TimeOutFlag == TRUE)) {

        ScsiPortLogError(
            DeviceExtension,
            NULL,
            0,
            DeviceExtension->HostTargetId,
            0,
            SP_INTERNAL_ADAPTER_ERROR,
            3 << 8
            );

        DebugPrint((1, "Aha154x:ReadCommandRegister:  Read command timed out\n"));
        return FALSE;
    }

    *DataByte = ScsiPortReadPortUchar(&baseIoAddress->CommandRegister);

    return TRUE;

} // end ReadCommandRegister()


BOOLEAN
WriteCommandRegister(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR AdapterCommand,
    IN BOOLEAN WaitForIdle
    )

/*++

Routine Description:

    Write operation code to command register.

Arguments:

    DeviceExtension - Pointer to adapter extension
    AdapterCommand - Value to be written to register
    WaitForIdle - Indicates if the idle bit needs to be checked

Return Value:

    TRUE if command sent.
    FALSE if timed out waiting for adapter.

--*/

{
    PBASE_REGISTER baseIoAddress = DeviceExtension->BaseIoAddress;
    ULONG i;
    UCHAR status;

    //
    // Wait up to 500 milliseconds for adapter to be ready.
    //

    for (i=0; i<5000; i++) {

        status = ScsiPortReadPortUchar(&baseIoAddress->StatusRegister);

        if ((status & IOP_COMMAND_DATA_OUT_FULL) ||
            ( WaitForIdle && !(status & IOP_SCSI_HBA_IDLE))) {

            //
            // Stall 100 microseconds before
            // trying again.
            //

            ScsiPortStallExecution(100);

        } else {

            //
            // Adapter ready. Break out of loop.
            //

            break;
        }
    }

    if (i==5000) {

        ScsiPortLogError(
            DeviceExtension,
            NULL,
            0,
            DeviceExtension->HostTargetId,
            0,
            SP_INTERNAL_ADAPTER_ERROR,
            (4 << 8) | status
            );


        DebugPrint((1, "Aha154x:WriteCommandRegister:  Write command timed out\n"));
        return FALSE;
    }

    ScsiPortWritePortUchar(&baseIoAddress->CommandRegister, AdapterCommand);

    return TRUE;

} // end WriteCommandRegister()


BOOLEAN
WriteDataRegister(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR DataByte
    )

/*++

Routine Description:

    Write data byte to data register.

Arguments:

    DeviceExtension - Pointer to adapter extension
    DataByte - Value to be written to register

Return Value:

    TRUE if byte sent.
    FALSE if timed out waiting for adapter.

--*/

{
    PBASE_REGISTER baseIoAddress = DeviceExtension->BaseIoAddress;
    ULONG i;

    //
    // Wait up to 500 microseconds for adapter to be idle
    // and ready for next byte.
    //

    for (i=0; i<500; i++) {

        if (ScsiPortReadPortUchar(&baseIoAddress->StatusRegister) &
            IOP_COMMAND_DATA_OUT_FULL) {

            //
            // Stall 1 microsecond before
            // trying again.
            //

            ScsiPortStallExecution(1);

        } else {

            //
            // Adapter ready. Break out of loop.
            //

            break;
        }
    }

    if (i==500) {

        ScsiPortLogError(
            DeviceExtension,
            NULL,
            0,
            DeviceExtension->HostTargetId,
            0,
            SP_INTERNAL_ADAPTER_ERROR,
            8 << 8
            );

        DebugPrint((1, "Aha154x:WriteDataRegister:  Write data timed out\n"));
        return FALSE;
    }

    ScsiPortWritePortUchar(&baseIoAddress->CommandRegister, DataByte);

    return TRUE;

} // end WriteDataRegister()


BOOLEAN
FirmwareBug (
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Check to see if the host adapter firmware has the scatter/gather
    bug.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Return FALSE if there is no firmware bug.
    Return TRUE if firmware has scatter/gather bug.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    UCHAR ch;
    int i;

    //
    // Issue a RETURN SETUP DATA command
    // If timeout then return TRUE to indicate that there is a firmware bug.
    //

    if ((WriteCommandRegister(HwDeviceExtension,
        AC_RETURN_SETUP_DATA,FALSE)) == FALSE) {
        return TRUE;
    }


    //
    // Tell the adapter we want to read in 0x11 bytes.
    //

    if (WriteDataRegister(HwDeviceExtension,0x11) == FALSE) {
        return TRUE;
    }

    //
    // Now try to read in 0x11 bytes.
    //

    for (i = 0; i< 0x11; i++) {
        if (ReadCommandRegister(HwDeviceExtension,&ch,TRUE) == FALSE) {
            return TRUE;
        }
    }

    //
    // Wait for HACC interrupt.
    //

    SpinForInterrupt(HwDeviceExtension,FALSE);    // eddy


    //
    // Issue SET HA OPTION command.
    //

    if (WriteCommandRegister(HwDeviceExtension,
        AC_SET_HA_OPTION,FALSE) == FALSE) {
        return TRUE;
    }

    //
    // Delay 500 microseconds.
    //

    ScsiPortStallExecution(500);

    //
    // Check for invalid command.
    //

    if ( (ScsiPortReadPortUchar(&baseIoAddress->StatusRegister) &
            IOP_INVALID_COMMAND) ) {
        //
        // Clear adapter interrupt.
        //

        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister,
            IOP_INTERRUPT_RESET);
        return TRUE;
    }

    //
    // send 01h
    //

    if (WriteDataRegister(HwDeviceExtension,0x01) == FALSE) {
        return TRUE;
    }

    //
    // Send same byte as was last received.
    //

    if (WriteDataRegister(HwDeviceExtension,ch) == FALSE) {
        return TRUE;
    }

    //
    // Clear adapter interrupt.
    //

    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister,
            IOP_INTERRUPT_RESET);
    return FALSE;
} // end of FirmwareBug ()


BOOLEAN
GetHostAdapterBoardId (
    IN PVOID HwDeviceExtension,
    OUT PUCHAR BoardId
    )

/*++

Routine Description:

    Get board id, firmware id and hardware id from the host adapter.
    These info are used to determine if the host adapter supports
    scatter/gather.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Board id, hardware id and firmware id (in that order) by modyfing *BoardId
    If there is any error, it will just return with *BoardId unmodified

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    UCHAR firmwareId;
    UCHAR boardId;
    UCHAR hardwareId;

    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister,
               IOP_INTERRUPT_RESET);

    if (!WriteCommandRegister(HwDeviceExtension,AC_ADAPTER_INQUIRY,FALSE)) {
        return FALSE;
    }

    //
    // Save byte 0 as board ID.
    //

    if ((ReadCommandRegister(HwDeviceExtension,&boardId,TRUE)) == FALSE) {
        return FALSE;
    }

    //
    // Ignore byte 1.  Use hardwareId as scrap storage.
    //

    if ((ReadCommandRegister(HwDeviceExtension,&hardwareId,TRUE)) == FALSE) {
        return FALSE;
    }

    //
    // Save byte 2 as hardware revision in hardwareId.
    //

    if ((ReadCommandRegister(HwDeviceExtension,&hardwareId,TRUE)) == FALSE) {
        return FALSE;
    }

    if ((ReadCommandRegister(HwDeviceExtension,&firmwareId,TRUE)) == FALSE) {
        return FALSE;
    }



    //
    // If timeout then return with *BoardId unmodified.  This means that
    // scatter/gather won't be supported.
    //

    if (!SpinForInterrupt(HwDeviceExtension, TRUE)) { // eddy
        return FALSE;
    }

    //
    // Clear adapter interrupt.
    //

    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister,IOP_INTERRUPT_RESET);

    //
    // Return with appropriate ID's.
    //

    *BoardId++ = boardId;
    *BoardId++ = hardwareId;
    *BoardId++ = firmwareId;

    DebugPrint((2,"board id = %d, hardwareid = %d, firmware id = %d\n",
               boardId,
               hardwareId,
               firmwareId));

    return TRUE;

}  // end of GetHostAdapterBoardId ()


BOOLEAN
ScatterGatherSupported (
   IN PHW_DEVICE_EXTENSION HwDeviceExtension
   )

/*++

Routine Description:
   Determine if the host adapter supports scatter/gather.  On older
   boards, scatter/gather is not supported.  On some boards, there is
   a bug that causes data corruption on multi-segment WRITE commands.
   The algorithm to determine whether the board has the scatter/gather
   bug is not "clean" but there is no other way since the firmware revision
   levels returned by the host adapter are inconsistent with previous
   releases.

Arguments:

   HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

   Return TRUE if the algorithm determines that there is no scatter/gather
   firmware bug.

   Return FALSE if the algorithm determines that the adapter is an older
   board or that the firmware contains the scatter gather bug

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    BOOLEAN status;
    UCHAR HostAdapterId[3];

    status = GetHostAdapterBoardId(HwDeviceExtension, HostAdapterId);

    //
    // Could not read the board id.  assume no scatter gather.
    //

    if(!status) {
        return FALSE;
    }

    //
    // If it's an older board then scatter/gather is not supported.
    //

    if ((HostAdapterId[BOARD_ID] == OLD_BOARD_ID1) ||
            (HostAdapterId[BOARD_ID] == OLD_BOARD_ID2) ) {
        return FALSE;
    }

    //
    // If 1540A/B then check for firmware bug.
    //

    if (HostAdapterId[BOARD_ID] == A154X_BOARD) {
        if (FirmwareBug(HwDeviceExtension)) {
            return FALSE;
       }
    }

    //
    // Now check hardware ID and firmware ID.
    //

    if (HostAdapterId[HARDWARE_ID] != A154X_BAD_HARDWARE_ID) {
        return TRUE;
    }

    if (HostAdapterId[FIRMWARE_ID] != A154X_BAD_FIRMWARE_ID) {
        return TRUE;
    }

    //
    // Host adapter has scatter/gather bug.
    // Clear interrupt on adapter.
    //

    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister,IOP_INTERRUPT_RESET);

    return FALSE;

}  // end of ScatterGatherSupported ()


BOOLEAN
SpinForInterrupt(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN TimeOutFlag
    )

/*++

Routine Description:

    Wait for interrupt.

Arguments:

    DeviceExtension - Pointer to adapter extension

Return Value:

    TRUE if interrupt occurred.
    FALSE if timed out waiting for interrupt.

--*/

{
    PBASE_REGISTER baseIoAddress = DeviceExtension->BaseIoAddress;
    ULONG i;

    //
    // Wait up to 5 millisecond for interrupt to occur.
    //

    for (i=0; i<5000; i++) {

        if (ScsiPortReadPortUchar(&baseIoAddress->InterruptRegister) & IOP_COMMAND_COMPLETE) {

            //
            // Interrupt occurred. Break out of wait loop.
            //

            break;

        } else {

            //
            // Stall one microsecond.
            //

            ScsiPortStallExecution(1);
        }
    }

    if ( (i==5000) && (TimeOutFlag == TRUE)) {

        ScsiPortLogError(DeviceExtension,
                NULL,
                0,
                DeviceExtension->HostTargetId,
                0,
                SP_INTERNAL_ADAPTER_ERROR,
                9 << 8
                );

        DebugPrint((1, "Aha154x:SpinForInterrupt:  Timed out waiting for interrupt\n"));

        return FALSE;

    } else {

        //
        // Clear interrupt on adapter.
        //

        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

        return TRUE;
    }

} // end SpinForInterrupt()


BOOLEAN UnlockMailBoxes (
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Unlock 1542B+ or 1542C mailboxes so that the driver
    can zero out mailboxes when it's initializing the adapter.

    The mailboxes are locked if:
    1. >1Gb option is enabled (this option is available for 154xB+ and
       154xC).

    2. Dynamic scan lock option is enabled (154xC board only)

    The reason the mailboxes are locked by the adapter's firmware is
    because the BIOS is now reporting 255/63 translation instead of 64/32.
    As such, if a user inadvertently enabled the >1Gb option (enabling
    255/63 translation) and still uses an old driver, hard disk data
    will be corrupted.  Therefore, the firmware will not allow mailboxes
    to be initialized unless the user knows what he is doing and updates
    his driver so that his disk won't be trashed.

Arguments:

    DeviceExtension - Pointer to adapter extension

Return Value:

    TRUE if mailboxes are unlocked.
    FALSE if mailboxes are not unlocked.
    Note that if the adapter is just a 154xB board (without the >1Gb
    option), this routine will return FALSE.

--*/

{
    UCHAR locktype;

    //
    // Request information.
    //

    if (WriteCommandRegister(HwDeviceExtension, AC_GET_BIOS_INFO, TRUE) == FALSE) {
       return FALSE;
    }


    //
    // Retrieve first byte.
    //

    if (ReadCommandRegister(HwDeviceExtension,&locktype,FALSE) == FALSE) {
        return FALSE;
    }

    //
    // Check for extended bios translation enabled option on 1540C and
    // 1540B with 1GB support.
    //

    if (locktype != TRANSLATION_ENABLED) {

        //
        // Extended translation is disabled.  Retrieve lock status.
        //

        if (ReadCommandRegister(HwDeviceExtension,&locktype,FALSE) == FALSE) {
            return FALSE;
        }

        //
        // Wait for HACC interrupt.
        //

        SpinForInterrupt(HwDeviceExtension,FALSE);  // eddy


        if (locktype == DYNAMIC_SCAN_LOCK) {
            return(SendUnlockCommand(HwDeviceExtension,locktype));
        }
        return FALSE;
    }

    //
    // Extended BIOS translation (255/63) is enabled.
    //


    if (ReadCommandRegister(HwDeviceExtension,&locktype,FALSE) == FALSE) {
        return FALSE;
    }

    //
    // Wait for HACC interrupt.
    //

    SpinForInterrupt(HwDeviceExtension,FALSE);  // eddy


    if ((locktype == TRANSLATION_LOCK) || (locktype == DYNAMIC_SCAN_LOCK)) {
        return(SendUnlockCommand(HwDeviceExtension,locktype));
    }

    return FALSE;
}  // end of UnlockMailBoxes ()


BOOLEAN
SendUnlockCommand(
    IN PVOID HwDeviceExtension,
    IN UCHAR locktype
    )

/*++

Routine Description:

    Send unlock command to 1542B+ or 1542C board so that the driver
    can zero out mailboxes when it's initializing the adapter.


Arguments:

    DeviceExtension - Pointer to adapter extension

Return Value:

    TRUE if commands are sent successfully.
    FALSE if not.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;

    if (WriteCommandRegister(deviceExtension,
                AC_SET_MAILBOX_INTERFACE,TRUE) == FALSE) {
        return FALSE;
    }

    if (WriteDataRegister(deviceExtension,MAILBOX_UNLOCK) == FALSE) {
        return FALSE;
    }

    if (WriteDataRegister(deviceExtension,locktype) == FALSE) {
        return FALSE;
    }

    //
    // Clear interrupt on adapter.
    //


    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

    return TRUE;
}  // end of SendUnlockCommand ()

CHAR
AhaToLower(
    IN CHAR C
    )
{
    CHAR c = C;
    if (c >= 'A' && c <= 'Z') {
	return (c - 'A' + 'a');
    }
    return c;
}

ULONG
AhaParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    )

/*++

Routine Description:

    This routine will parse the string for a match on the keyword, then
    calculate the value for the keyword and return it to the caller.

Arguments:

    String - The ASCII string to parse.
    KeyWord - The keyword for the value desired.

Return Values:

    Zero if value not found
    Value converted from ASCII to binary.

--*/

{
    PCHAR cptr;
    PCHAR kptr;
    ULONG value;
    ULONG stringLength = 0;
    ULONG keyWordLength = 0;
    ULONG index;

    //
    // Calculate the string length and lower case all characters.
    //
    cptr = String;
    while (*cptr) {
        cptr++;
        stringLength++;
    }

    //
    // Calculate the keyword length and lower case all characters.
    //
    cptr = KeyWord;
    while (*cptr) {
        cptr++;
        keyWordLength++;
    }

    if (keyWordLength > stringLength) {

        //
        // Can't possibly have a match.
        //
        return 0;
    }

    //
    // Now setup and start the compare.
    //
    cptr = String;

ContinueSearch:
    //
    // The input string may start with white space.  Skip it.
    //
    while (*cptr == ' ' || *cptr == '\t') {
        cptr++;
    }

    if (*cptr == '\0') {

        //
        // end of string.
        //
        return 0;
    }

    kptr = KeyWord;
    while (AhaToLower(*cptr) == AhaToLower(*kptr)) {
        
        cptr++;
        kptr++;

        if (*(cptr - 1) == '\0') {

            //
            // end of string
            //
	
            return 0;
        }
    }

    cptr++;
    kptr++;

    if (*(kptr - 1) == '\0') {

        //
        // May have a match backup and check for blank or equals.
        //

        cptr--;
        while (*cptr == ' ' || *cptr == '\t') {
            cptr++;
        }

        //
        // Found a match.  Make sure there is an equals.
        //
        if (*cptr != '=') {

            //
            // Not a match so move to the next semicolon.
            //
            while (*cptr) {
                if (*cptr++ == ';') {
                    goto ContinueSearch;
                }
            }
            return 0;
        }

        //
        // Skip the equals sign.
        //
        cptr++;

        //
        // Skip white space.
        //
        while ((*cptr == ' ') || (*cptr == '\t')) {
            cptr++;
        }

        if (*cptr == '\0') {

            //
            // Early end of string, return not found
            //
            return 0;
        }

        if (*cptr == ';') {

            //
            // This isn't it either.
            //
            cptr++;
            goto ContinueSearch;
        }

        value = 0;
        if ((*cptr == '0') && (AhaToLower(*(cptr + 1)) == 'x')) {

            //
            // Value is in Hex.  Skip the "0x"
            //
            cptr += 2;
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                     break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (16 * value) + (*(cptr + index) - '0');
                } else {
                    if ((AhaToLower(*(cptr + index)) >= 'a') && (AhaToLower(*(cptr + index)) <= 'f')) {
                        value = (16 * value) + AhaToLower((*(cptr + index)) - 'a' + 10);
                    } else {

                        //
                        // Syntax error, return not found.
                        //
                        return 0;
                    }
                }
            }
        } else {

            //
            // Value is in Decimal.
            //
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                    break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (10 * value) + (*(cptr + index) - '0');
                } else {

                    //
                    // Syntax error return not found.
                    //
                    return 0;
                }
            }
        }

        return value;
    } else {

        //
        // Not a match check for ';' to continue search.
        //
        while (*cptr) {
            if (*cptr++ == ';') {
                goto ContinueSearch;
            }
        }

        return 0;
    }
}

BOOLEAN
A4448ReadString(
    IN PHW_DEVICE_EXTENSION deviceExtension,
    PUCHAR theString,
    UCHAR  stringLength,
    UCHAR  stringCommand
    )
/*++

Routine Description:


Arguments:


Return Values:

    True if read was OK.
    False otherwise.

--*/
{
     ULONG ii;

     //
     // Send in the string command
     //
     if (!WriteCommandRegister(deviceExtension, stringCommand, TRUE)) {
         return FALSE;
     }

    //
    // Send in the string length
    //
    if (!WriteCommandRegister(deviceExtension, stringLength, FALSE)) {
        return FALSE;
    }

    //
    // Read each byte of the string
    //
    for (ii = 0; ii < stringLength; ++ii) {
        if (!ReadCommandRegister(deviceExtension, &theString[ii],FALSE)) {
            return FALSE;
        }
    }

    //
    // Wait for interrupt.
    //

    if (!SpinForInterrupt(deviceExtension,FALSE)) {
        return FALSE;
    }


    return TRUE;

} // End A4448ReadString


BOOLEAN
A4448IsAmi(
    IN PHW_DEVICE_EXTENSION  HwDeviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    ULONG portNumber
    )
/*++

Routine Description:

    This routine determines if the adapter this driver recognized is an
    AMI4448. Eddy Quicksall of AMI provided MS with this detection code.

Arguments:

    HwDeviceExtension - Pointer to driver device data area.
    ConfigInfo - Structure describing this adapter's configuration.
    portNumber - Indicates the ordinal of the card relative to this driver.

Return Values:

    True if an AMI board.
    False otherwise.

--*/
{

    PUCHAR     x330IoSpace;     // mapped I/O for 330
    ULONG      x330Address;     // unmapped 330
    PX330_REGISTER x330IoBase;  // mapped 330 for use with struct X330_REGISTER

    //
    // this string is only avalable if new BIOS
    // you will get INVDCMD if an old BIOS or some other manufacturer
    // if an old BIOS, there is nothing that can be done except to check
    // the Manufacturers ID if you are on an EISA system
    //
    struct _CONFIG_STRING {
        UCHAR companyString[4];     // AMI<0)
        UCHAR modelString[6];       // <0>
        UCHAR seriesString[6];      // 48<0>
        UCHAR versionString[6];     // 1.00<0)
    } configString;

    //
    // Get the system physical address for this card.  The card uses I/O space.
    // This actually just maps the I/O if necessary, it does not reserve it.
    //

    x330IoSpace = ScsiPortGetDeviceBase(
                        HwDeviceExtension,                  // HwDeviceExtension
                        ConfigInfo->AdapterInterfaceType,   // AdapterInterfaceType
                        ConfigInfo->SystemIoBusNumber,      // SystemIoBusNumber
                        ScsiPortConvertUlongToPhysicalAddress(portNumber),
                        4,                                  // NumberOfBytes
                        TRUE                                // InIoSpace
                        );


    //
    // Intel port number
    //

    x330Address = portNumber;

    //
    // Check to see if the adapter is present in the system.
    //

    x330IoBase = (PX330_REGISTER)(x330IoSpace);

    //
    // Criteria is IDLE and not STST,DIAGF,INVDCMD
    // but INIT, CDF, and DF are don't cares.
    //
    // Can't check for INIT because the driver may already be running if it
    // is the boot device.
    //

    if (((ScsiPortReadPortUchar((PUCHAR)x330IoBase)) & (~0x2C)) == 0x10) {

        if (A4448ReadString(HwDeviceExtension, (PUCHAR)&configString,
                                 sizeof(configString), AC_AMI_INQUIRY ) &&
                             configString.companyString[0] == 'A' &&
                             configString.companyString[1] == 'M' &&
                             configString.companyString[2] == 'I') {

            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\aha154x\makefile.inc ===
clean:
    del aha154dt.h $(O)\aha154x.bmf

$(O)\aha154x.mof: aha154x.mof

aha154dt.h: $(O)\aha154x.bmf
    wmimofck -haha154dt.h $(O)\aha154x.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\aha154x\aha154x.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    aha154x.h

Abstract:

    This module contains the structures, specific to the Adaptec aha154x
    host bus adapter, used by the SCSI miniport driver. Data structures
    that are part of standard ANSI SCSI will be defined in a header
    file that will be available to all SCSI device drivers.

Author:

    Mike Glass  December 1990
    Bill Williams (Adaptec)

Revision History:

--*/

#include "scsi.h"
#include "scsiwmi.h"

//
// The following definitions are used to convert ULONG addresses
// to Adaptec's 3 byte address format.
//

typedef struct _THREE_BYTE {
    UCHAR Msb;
    UCHAR Mid;
    UCHAR Lsb;
} THREE_BYTE, *PTHREE_BYTE;

//
// Convert four-byte Little Endian to three-byte Big Endian
//

#define FOUR_TO_THREE(Three, Four) {                \
    ASSERT(!((Four)->Byte3));                       \
    (Three)->Lsb = (Four)->Byte0;                   \
    (Three)->Mid = (Four)->Byte1;                   \
    (Three)->Msb = (Four)->Byte2;                   \
}

#define THREE_TO_FOUR(Four, Three) {                \
    (Four)->Byte0 = (Three)->Lsb;                   \
    (Four)->Byte1 = (Three)->Mid;                   \
    (Four)->Byte2 = (Three)->Msb;                   \
    (Four)->Byte3 = 0;                              \
}

//
// Context information for adapter scan/sniff
//

typedef struct _SCAN_CONTEXT {
    ULONG   adapterCount;
    ULONG   biosScanStart;
} SCAN_CONTEXT, *PSCAN_CONTEXT;

///////////////////////////////////////////////////////////////////////////////
//
// CCB - Adaptec SCSI Command Control Block
//
//    The CCB is a superset of the CDB (Command Descriptor Block)
//    and specifies detailed information about a SCSI command.
//
///////////////////////////////////////////////////////////////////////////////

//
//    Byte 0    Command Control Block Operation Code
//

#define SCSI_INITIATOR_OLD_COMMAND 0x00
#define TARGET_MODE_COMMAND       0x01
#define SCATTER_GATHER_OLD_COMMAND 0x02
#define SCSI_INITIATOR_COMMAND    0x03
#define SCATTER_GATHER_COMMAND    0x04

//
//    Byte 1    Address and Direction Control
//

#define CCB_TARGET_ID_SHIFT       0x06            // CCB Op Code = 00, 02
#define CCB_INITIATOR_ID_SHIFT    0x06            // CCB Op Code = 01
#define CCB_DATA_XFER_OUT         0x10            // Write
#define CCB_DATA_XFER_IN          0x08            // Read
#define CCB_LUN_MASK              0x07            // Logical Unit Number

//
//    Byte 2    SCSI_Command_Length - Length of SCSI CDB
//
//    Byte 3    Request Sense Allocation Length
//

#define FOURTEEN_BYTES            0x00            // Request Sense Buffer size
#define NO_AUTO_REQUEST_SENSE     0x01            // No Request Sense Buffer

//
//    Bytes 4, 5 and 6    Data Length             // Data transfer byte count
//
//    Bytes 7, 8 and 9    Data Pointer            // SGD List or Data Buffer
//
//    Bytes 10, 11 and 12 Link Pointer            // Next CCB in Linked List
//
//    Byte 13   Command Link ID                   // TBD (I don't know yet)
//
//    Byte 14   Host Status                       // Host Adapter status
//

#define CCB_COMPLETE              0x00            // CCB completed without error
#define CCB_LINKED_COMPLETE       0x0A            // Linked command completed
#define CCB_LINKED_COMPLETE_INT   0x0B            // Linked complete with interrupt
#define CCB_SELECTION_TIMEOUT     0x11            // Set SCSI selection timed out
#define CCB_DATA_OVER_UNDER_RUN   0x12
#define CCB_UNEXPECTED_BUS_FREE   0x13            // Target dropped SCSI BSY
#define CCB_PHASE_SEQUENCE_FAIL   0x14            // Target bus phase sequence failure
#define CCB_BAD_MBO_COMMAND       0x15            // MBO command not 0, 1 or 2
#define CCB_INVALID_OP_CODE       0x16            // CCB invalid operation code
#define CCB_BAD_LINKED_LUN        0x17            // Linked CCB LUN different from first
#define CCB_INVALID_DIRECTION     0x18            // Invalid target direction
#define CCB_DUPLICATE_CCB         0x19            // Duplicate CCB
#define CCB_INVALID_CCB           0x1A            // Invalid CCB - bad parameter

//
//    Byte 15   Target Status
//
//    See SCSI.H files for these statuses.
//

//
//    Bytes 16 and 17   Reserved (must be 0)
//

//
//    Bytes 18 through 18+n-1, where n=size of CDB  Command Descriptor Block
//

//
//    Bytes 18+n through 18+m-1, where m=buffer size Allocated for Sense Data
//

#define REQUEST_SENSE_BUFFER_SIZE 18

///////////////////////////////////////////////////////////////////////////////
//
// Scatter/Gather Segment List Definitions
//
///////////////////////////////////////////////////////////////////////////////

//
// Adapter limits
//

#define MAX_SG_DESCRIPTORS 17
#define MAX_TRANSFER_SIZE  64 * 1024
#define A154X_TYPE_MAX 5

//
// Scatter/Gather Segment Descriptor Definition
//

typedef struct _SGD {
    THREE_BYTE Length;
    THREE_BYTE Address;
} SGD, *PSGD;

typedef struct _SDL {
    SGD Sgd[MAX_SG_DESCRIPTORS];
} SDL, *PSDL;

#define SEGMENT_LIST_SIZE         MAX_SG_DESCRIPTORS * sizeof(SGD)

///////////////////////////////////////////////////////////////////////////////
//
// CCB Typedef
//

typedef struct _CCB {
    UCHAR OperationCode;
    UCHAR ControlByte;
    UCHAR CdbLength;
    UCHAR RequestSenseLength;
    THREE_BYTE DataLength;
    THREE_BYTE DataPointer;
    THREE_BYTE LinkPointer;
    UCHAR LinkIdentifier;
    UCHAR HostStatus;
    UCHAR TargetStatus;
    UCHAR Reserved[2];
    UCHAR Cdb[MAXIMUM_CDB_SIZE];
    PVOID SrbAddress;
    PVOID AbortSrb;
    SDL   Sdl;
    UCHAR RequestSenseBuffer[REQUEST_SENSE_BUFFER_SIZE];
} CCB, *PCCB;

//
// CCB and request sense buffer
//

#define CCB_SIZE sizeof(CCB)

///////////////////////////////////////////////////////////////////////////////
//
// Adapter Command Overview
//
//    Adapter commands are issued by writing to the Command/Data Out port.
//    They are used to initialize the host adapter and to establish control
//    conditions within the host adapter. They may not be issued when there
//    are outstanding SCSI commands.
//
//    All adapter commands except Start SCSI(02) and Enable Mailbox-Out
//    Interrupt(05) must be executed only when the IDLE bit (Status bit 4)
//    is one. Many commands require additional parameter bytes which are
//    then written to the Command/Data Out I/O port (base+1). Before each
//    byte is written by the host to the host adapter, the host must verify
//    that the CDF bit (Status bit 3) is zero, indicating that the command
//    port is ready for another byte of information. The host adapter usually
//    clears the Command/Data Out port within 100 microseconds. Some commands
//    require information bytes to be returned from the host adapter to the
//    host. In this case, the host monitors the DF bit (Status bit 2) to
//    determine when the host adapter has placed a byte in the Data In I/O
//    port for the host to read. The DF bit is reset automatically when the
//    host reads the byte. The format of each adapter command is strictly
//    defined, so the host adapter and host system can always agree upon the
//    correct number of parameter bytes to be transferred during a command.
//
//
///////////////////////////////////////////////////////////////////////////////

//
// Host Adapter Command Operation Codes
//

#define AC_NO_OPERATION           0x00
#define AC_MAILBOX_INITIALIZATION 0x01
#define AC_START_SCSI_COMMAND     0x02
#define AC_START_BIOS_COMMAND     0x03
#define AC_ADAPTER_INQUIRY        0x04
#define AC_ENABLE_MBO_AVAIL_INT   0x05
#define AC_SET_SELECTION_TIMEOUT  0x06
#define AC_SET_BUS_ON_TIME        0x07
#define AC_SET_BUS_OFF_TIME       0x08
#define AC_SET_TRANSFER_SPEED     0x09
#define AC_RET_INSTALLED_DEVICES  0x0A
#define AC_RET_CONFIGURATION_DATA 0x0B
#define AC_ENABLE_TARGET_MODE     0x0C
#define AC_RETURN_SETUP_DATA      0x0D
#define AC_WRITE_CHANNEL_2_BUFFER 0x1A
#define AC_READ_CHANNEL_2_BUFFER  0x1B
#define AC_WRITE_FIFO_BUFFER      0x1C
#define AC_READ_FIFO_BUFFER       0x1D
#define AC_ECHO_COMMAND_DATA      0x1F
#define AC_SET_HA_OPTION          0x21
#define AC_RETURN_EEPROM          0x23
#define AC_GET_BIOS_INFO          0x28
#define AC_SET_MAILBOX_INTERFACE  0x29
#define AC_EXTENDED_SETUP_INFO    0x8D

//
//Adapter commands new to the AHA-154xCP are defined below.
//
#define AC_SET_DMS_BUS_SPEED            0x2B
#define AC_TERMINATION_AND_CABLE_STATUS 0x2C
#define AC_DEVICE_INQUIRY               0x2D
#define AC_SCSI_DEVICE_TABLE            0x2E
#define AC_PERFORM_SCAM                 0x2F

//
// EEPROM define for SCAM
//
#define SCSI_BUS_CONTROL_FLAG           0x06
#define SCAM_ENABLED                    0x40

//
// DMA Transfer Speeds
//

#define DMA_SPEED_50_MBS          0x00

//
// I/O Port Interface
//

typedef struct _BASE_REGISTER {
    UCHAR StatusRegister;
    UCHAR CommandRegister;
    UCHAR InterruptRegister;
} BASE_REGISTER, *PBASE_REGISTER;

//
//    Base+0    Write: Control Register
//

#define IOP_HARD_RESET            0x80            // bit 7
#define IOP_SOFT_RESET            0x40            // bit 6
#define IOP_INTERRUPT_RESET       0x20            // bit 5
#define IOP_SCSI_BUS_RESET        0x10            // bit 4

//
//    Base+0    Read: Status
//

#define IOP_SELF_TEST             0x80            // bit 7
#define IOP_INTERNAL_DIAG_FAILURE 0x40            // bit 6
#define IOP_MAILBOX_INIT_REQUIRED 0x20            // bit 5
#define IOP_SCSI_HBA_IDLE         0x10            // bit 4
#define IOP_COMMAND_DATA_OUT_FULL 0x08            // bit 3
#define IOP_DATA_IN_PORT_FULL     0x04            // bit 2
#define IOP_INVALID_COMMAND       0X01            // bit 1

//
//    Base+1    Write: Command/Data Out
//

//
//    Base+1    Read: Data In
//

//
//    Base+2    Read: Interrupt Flags
//

#define IOP_ANY_INTERRUPT         0x80            // bit 7
#define IOP_SCSI_RESET_DETECTED   0x08            // bit 3
#define IOP_COMMAND_COMPLETE      0x04            // bit 2
#define IOP_MBO_EMPTY             0x02            // bit 1
#define IOP_MBI_FULL              0x01            // bit 0

///////////////////////////////////////////////////////////////////////////////
//
// Mailbox Definitions
//
//
///////////////////////////////////////////////////////////////////////////////

//
// Mailbox Definition
//

#define MB_COUNT                  0x08            // number of mailboxes

//
// Mailbox Out
//

typedef struct _MBO {
    UCHAR Command;
    THREE_BYTE Address;
} MBO, *PMBO;

//
// MBO Command Values
//

#define MBO_FREE                  0x00
#define MBO_START                 0x01
#define MBO_ABORT                 0x02

//
// Mailbox In
//

typedef struct _MBI {
    UCHAR Status;
    THREE_BYTE Address;
} MBI, *PMBI;

//
// MBI Status Values
//

#define MBI_FREE                  0x00
#define MBI_SUCCESS               0x01
#define MBI_ABORT                 0x02
#define MBI_NOT_FOUND             0x03
#define MBI_ERROR                 0x04

//
// Mailbox Initialization
//

typedef struct _MAILBOX_INIT {
    UCHAR Count;
    THREE_BYTE Address;
} MAILBOX_INIT, *PMAILBOX_INIT;

#define MAILBOX_UNLOCK      0x00
#define TRANSLATION_LOCK    0x01    // mailbox locked for extended BIOS
#define DYNAMIC_SCAN_LOCK   0x02    // mailbox locked for 154xC
#define TRANSLATION_ENABLED 0x08    // extended BIOS translation (1023/64)

//
// Scatter/Gather firmware bug detection
//

#define BOARD_ID                  0x00
#define HARDWARE_ID               0x01
#define FIRMWARE_ID               0x02
#define OLD_BOARD_ID1             0x00
#define OLD_BOARD_ID2             0x30
#define A154X_BOARD               0x41
#define A154X_BAD_HARDWARE_ID     0x30
#define A154X_BAD_FIRMWARE_ID     0x33

//
// MCA specific definitions.
//

#define NUMBER_POS_SLOTS 8
#define POS_IDENTIFIER   0x0F1F
#define POS_PORT_MASK    0xC7
#define POS_PORT_130     0x01
#define POS_PORT_134     0x41
#define POS_PORT_230     0x02
#define POS_PORT_234     0x42
#define POS_PORT_330     0x03
#define POS_PORT_334     0x43

typedef struct _POS_DATA {
    USHORT AdapterId;
    UCHAR  BiosEnabled;
    UCHAR  IoPortInformation;
    UCHAR  ScsiInformation;
    UCHAR  DmaInformation;
} POS_DATA, *PPOS_DATA;

typedef struct _INIT_DATA {

    ULONG AdapterId;
    ULONG CardSlot;
    POS_DATA PosData[NUMBER_POS_SLOTS];

} INIT_DATA, *PINIT_DATA;


//
// Real Mode Adapter Config Info
//
typedef struct _RM_SAVRES {
	UCHAR		SDTPar;
	UCHAR		TxSpeed;
	UCHAR		BusOnTime;
	UCHAR		BusOffTime;
	UCHAR		NumMailBoxes;
	UCHAR		MBAddrHiByte;
	UCHAR		MBAddrMiByte;
	UCHAR		MBAddrLoByte;
	UCHAR		SyncNeg[8];
	UCHAR		DisOpt;

} RM_CFG, *PRM_CFG;

#define RM_CFG_MAX_SIZE 0xFF

//
//AMI Detect Code
//
#define AC_AMI_INQUIRY  0x41    // Get model number, ect. (ASCIIZ)

//
// I/O Port Interface
//

typedef struct _X330_REGISTER {
    UCHAR StatusRegister;
    UCHAR CommandRegister;
    UCHAR InterruptRegister;
    UCHAR DiagRegister;
} X330_REGISTER, *PX330_REGISTER;

///////////////////////////////////////////////////////////////////////////////
//
// Structures
//
//
///////////////////////////////////////////////////////////////////////////////

//
// The following structure is allocated
// from noncached memory as data will be DMA'd to
// and from it.
//

typedef struct _NONCACHED_EXTENSION {

    //
    // Physical base address of mailboxes
    //

    ULONG MailboxPA;

    //
    // Mailboxes
    //

    MBO          Mbo[MB_COUNT];
    MBI          Mbi[MB_COUNT];

} NONCACHED_EXTENSION, *PNONCACHED_EXTENSION;

//
// Device extension
//

typedef struct _HW_DEVICE_EXTENSION {

    //
    // NonCached extension
    //

    PNONCACHED_EXTENSION NoncachedExtension;

    //
    // Adapter parameters
    //

    PBASE_REGISTER   BaseIoAddress;

    //
    // Host Target id.
    //

    UCHAR HostTargetId;

    //
    // Old in\out box indexes.
    //

    UCHAR MboIndex;

    UCHAR MbiIndex;

    //
    // Pending request.
    //

    BOOLEAN PendingRequest;

    //
    // Bus on time to use.
    //

    UCHAR BusOnTime;

    //
    // Scatter gather command
    //

    UCHAR CcbScatterGatherCommand;

    //
    // Non scatter gather command
    //

    UCHAR CcbInitiatorCommand;

    //
    // Don't send CDB's longer than this to any device on the bus
    // Ignored if the value is 0
    //

    UCHAR MaxCdbLength;

    //
    // Real Mode adapter config info
    //

    RM_CFG RMSaveState;

        #if defined(_SCAM_ENABLED)
        //
        // SCAM boolean, set to TRUE if miniport must control SCAM operation.
        //
        BOOLEAN PerformScam;
        #endif

    SCSI_WMILIB_CONTEXT WmiLibContext;
		
		
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// Logical unit extension
//

typedef struct _HW_LU_EXTENSION {
    PSCSI_REQUEST_BLOCK CurrentSrb;
} HW_LU_EXTENSION, *PHW_LU_EXTENSION;

///////////////////////////////////////////////////////////////////////////////
//
// Common Prototypes to all Source Files
//
//
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
A154xWmiSrb(
    IN     PHW_DEVICE_EXTENSION    HwDeviceExtension,
    IN OUT PSCSI_WMI_REQUEST_BLOCK Srb
    );

BOOLEAN
ReadCommandRegister(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    OUT PUCHAR DataByte,
    IN BOOLEAN TimeOutFlag
    );

BOOLEAN
WriteCommandRegister(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR AdapterCommand,
    IN BOOLEAN LogError
    );

BOOLEAN
WriteDataRegister(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR DataByte
    );

BOOLEAN
SpinForInterrupt(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN TimeOutFlag
    );

void A154xWmiInitialize(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension
    );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\aha154x\support.c ===
#include "miniport.h"
#include "scsi.h"

#define LONG_ALIGN (sizeof(LONG) - 1)

BOOLEAN
ScsiPortCompareMemory(
    IN PVOID Source1,
    IN PVOID Source2,
    IN ULONG Length
    )
/*++

Routine Description:

    Compares two blocks of memory and returns TRUE if they are identical.

Arguments:

    Source1 - block of memory to compare
    Source2 - block of memory to compare
    Length  - number of bytes to copy

Return Value:

    TRUE if the two buffers are identical.

--*/

{
    BOOLEAN identical = TRUE;

    //
    // See if the length, source and desitination are word aligned.
    //

    if ((Length & LONG_ALIGN) || 
        ((ULONG_PTR) Source1 & LONG_ALIGN) ||
        ((ULONG_PTR) Source2 & LONG_ALIGN)) {

        PCHAR source2 = Source2;
        PCHAR source  = Source1;

        for (; Length > 0 && identical; Length--) {
            if (*source2++ != *source++) {
               identical = FALSE;
            }
        }
    } else {

        PLONG source2 = Source2;
        PLONG source  = Source1;

        Length /= sizeof(LONG);
        for (; Length > 0 && identical; Length--) {
            if (*source2++ != *source++) {
               identical = FALSE;
            }
        }
    }

    return identical;

} // end ScsiPortCompareMemory()


VOID
ScsiPortZeroMemory(
    IN PVOID Destination,
    IN ULONG Length
    )
/*++

Routine Description:

    Fills a block of memory with zeros, given a pointer to the block and
    the length, in bytes, to be filled.

Arguments:

    Destination - Points to the memory to be filled with zeros.

    Length      - Specifies the number of bytes to be zeroed.

Return Value:

    None.

--*/

{
    //
    // See if the length, source and desitination are word aligned.
    //

    if (Length & LONG_ALIGN || (ULONG_PTR) Destination & LONG_ALIGN) {

        PUCHAR destination = Destination;

        for (; Length > 0; Length--) {
            *destination = 0;
            destination++;
        }
    } else {

        PULONG destination = Destination;

        Length /= sizeof(LONG);
        for (; Length > 0; Length--) {
            *destination = 0;
            destination++;
        }
    }

    return;

} // end ScsiPortZeroMemory()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\aha154x\support.h ===
BOOLEAN
ScsiPortCompareMemory(
    IN PVOID Source1,
    IN PVOID Source2,
    IN ULONG Length
    );

VOID
ScsiPortZeroMemory(
    IN PVOID Destination,
    IN ULONG Length
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\atapi\intel.h ===
BOOLEAN
PiixTimingControl (
    struct _HW_DEVICE_EXTENSION DeviceExtension
    );

BOOLEAN IntelIsChannelEnabled (
    PPCI_COMMON_CONFIG PciData,
    ULONG Channel);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\atapi\intel.c ===
#include "miniport.h"
#include "devioctl.h"
#include "atapi.h"
#include "ntdddisk.h"
#include "ntddscsi.h"
#include "intel.h"

BOOLEAN
PiixTimingControl (
    struct _HW_DEVICE_EXTENSION DeviceExtension
    )
{




    return TRUE;
}

BOOLEAN IntelIsChannelEnabled (
    PPCI_COMMON_CONFIG PciData,
    ULONG Channel)
{
    PUCHAR rawPciData = (PUCHAR) PciData;
    ULONG pciDataOffset;

    if (Channel == 0) {
        pciDataOffset = 0x41;
    } else {
        pciDataOffset = 0x43;
    }

    return (rawPciData[pciDataOffset] & 0x80);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\atapi\atapi.h ===
/*++

Copyright (c) 1993-1996  Microsoft Corporation

Module Name:

    atapi.h

Abstract:

    This module contains the structures and definitions for the ATAPI
    IDE miniport driver.

Author:

    Mike Glass


Revision History:

--*/

#include "scsi.h"
#include "stdio.h"
#include "string.h"

//
// Function Prototypes
//
ULONG
GetPciBusData(
    IN PVOID              DeviceExtension,
    IN ULONG              SystemIoBusNumber,
    IN PCI_SLOT_NUMBER    SlotNumber,
    OUT PVOID             PciConfigBuffer,
    IN ULONG              NumByte
    );

ULONG
SetPciBusData(
    IN PVOID              HwDeviceExtension,
    IN ULONG              SystemIoBusNumber,
    IN PCI_SLOT_NUMBER    SlotNumber,
    IN PVOID              Buffer,
    IN ULONG              Offset,
    IN ULONG              Length
    );

BOOLEAN
ChannelIsAlwaysEnabled (
    IN PPCI_COMMON_CONFIG PciData,
    IN ULONG Channel
    );

//
// IDE register definition
//

typedef struct _IDE_REGISTERS_1 {
    USHORT Data;
    UCHAR BlockCount;
    UCHAR BlockNumber;
    UCHAR CylinderLow;
    UCHAR CylinderHigh;
    UCHAR DriveSelect;
    UCHAR Command;
} IDE_REGISTERS_1, *PIDE_REGISTERS_1;

typedef struct _IDE_REGISTERS_2 {
    UCHAR DeviceControl;
    UCHAR DriveAddress;
} IDE_REGISTERS_2, *PIDE_REGISTERS_2;

typedef struct _IDE_REGISTERS_3 {
    ULONG Data;
    UCHAR Others[4];
} IDE_REGISTERS_3, *PIDE_REGISTERS_3;

//
// Bus Master Controller Register
//
typedef struct _IDE_BUS_MASTER_REGISTERS {
         UCHAR  Command;
         UCHAR  Reserved1;
         UCHAR  Status;
         UCHAR  Reserved2;
         ULONG  DescriptionTable;
} IDE_BUS_MASTER_REGISTERS, *PIDE_BUS_MASTER_REGISTERS;

//
// Device Extension Device Flags
//

#define DFLAGS_DEVICE_PRESENT        (1 << 0)    // Indicates that some device is present.
#define DFLAGS_ATAPI_DEVICE          (1 << 1)    // Indicates whether Atapi commands can be used.
#define DFLAGS_TAPE_DEVICE           (1 << 2)    // Indicates whether this is a tape device.
#define DFLAGS_INT_DRQ               (1 << 3)    // Indicates whether device interrupts as DRQ is set after
                                                 // receiving Atapi Packet Command
#define DFLAGS_REMOVABLE_DRIVE       (1 << 4)    // Indicates that the drive has the 'removable' bit set in
                                                 // identify data (offset 128)
#define DFLAGS_MEDIA_STATUS_ENABLED  (1 << 5)    // Media status notification enabled
#define DFLAGS_ATAPI_CHANGER         (1 << 6)    // Indicates atapi 2.5 changer present.
#define DFLAGS_SANYO_ATAPI_CHANGER   (1 << 7)    // Indicates multi-platter device, not conforming to the 2.5 spec.
#define DFLAGS_CHANGER_INITED        (1 << 8)    // Indicates that the init path for changers has already been done.
#define DFLAGS_USE_DMA               (1 << 9)    // Indicates whether device can use DMA
#define DFLAGS_LBA                   (1 << 10)   // support LBA addressing

//
// Controller Flags
//
#define CFLAGS_BUS_MASTERING              (1 << 0)    // The Controller is capable of doing bus mastering
                                                  // defined by SFF-8038i

//
// Used to disable 'advanced' features.
//

#define MAX_ERRORS                     4

//
// ATAPI command definitions
//

#define ATAPI_MODE_SENSE   0x5A
#define ATAPI_MODE_SELECT  0x55
#define ATAPI_FORMAT_UNIT  0x24

//
// ATAPI Command Descriptor Block
//

typedef struct _MODE_SENSE_10 {
        UCHAR OperationCode;
        UCHAR Reserved1;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved3[3];
} MODE_SENSE_10, *PMODE_SENSE_10;

typedef struct _MODE_SELECT_10 {
        UCHAR OperationCode;
        UCHAR Reserved1 : 4;
        UCHAR PFBit : 1;
        UCHAR Reserved2 : 3;
        UCHAR Reserved3[5];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved4[3];
} MODE_SELECT_10, *PMODE_SELECT_10;

typedef struct _MODE_PARAMETER_HEADER_10 {
    UCHAR ModeDataLengthMsb;
    UCHAR ModeDataLengthLsb;
    UCHAR MediumType;
    UCHAR Reserved[5];
}MODE_PARAMETER_HEADER_10, *PMODE_PARAMETER_HEADER_10;

//
// IDE command definitions
//

#define IDE_COMMAND_ATAPI_RESET             0x08
#define IDE_COMMAND_RECALIBRATE             0x10
#define IDE_COMMAND_READ                    0x20
#define IDE_COMMAND_WRITE                   0x30
#define IDE_COMMAND_VERIFY                  0x40
#define IDE_COMMAND_SEEK                    0x70
#define IDE_COMMAND_SET_DRIVE_PARAMETERS    0x91
#define IDE_COMMAND_ATAPI_PACKET            0xA0
#define IDE_COMMAND_ATAPI_IDENTIFY          0xA1
#define IDE_COMMAND_READ_MULTIPLE           0xC4
#define IDE_COMMAND_WRITE_MULTIPLE          0xC5
#define IDE_COMMAND_SET_MULTIPLE            0xC6
#define IDE_COMMAND_READ_DMA                0xC8
#define IDE_COMMAND_WRITE_DMA               0xCA
#define IDE_COMMAND_GET_MEDIA_STATUS        0xDA
#define IDE_COMMAND_ENABLE_MEDIA_STATUS     0xEF
#define IDE_COMMAND_IDENTIFY                0xEC
#define IDE_COMMAND_MEDIA_EJECT             0xED
#define IDE_COMMAND_DOOR_LOCK               0xDE
#define IDE_COMMAND_DOOR_UNLOCK             0xDF

//
// IDE status definitions
//

#define IDE_STATUS_ERROR             0x01
#define IDE_STATUS_INDEX             0x02
#define IDE_STATUS_CORRECTED_ERROR   0x04
#define IDE_STATUS_DRQ               0x08
#define IDE_STATUS_DSC               0x10
#define IDE_STATUS_DRDY              0x40
#define IDE_STATUS_IDLE              0x50
#define IDE_STATUS_BUSY              0x80

//
// IDE drive select/head definitions
//

#define IDE_DRIVE_SELECT_1           0xA0
#define IDE_DRIVE_SELECT_2           0x10

//
// IDE drive control definitions
//

#define IDE_DC_DISABLE_INTERRUPTS    0x02
#define IDE_DC_RESET_CONTROLLER      0x04
#define IDE_DC_REENABLE_CONTROLLER   0x00

//
// IDE error definitions
//

#define IDE_ERROR_BAD_BLOCK          0x80
#define IDE_ERROR_DATA_ERROR         0x40
#define IDE_ERROR_MEDIA_CHANGE       0x20
#define IDE_ERROR_ID_NOT_FOUND       0x10
#define IDE_ERROR_MEDIA_CHANGE_REQ   0x08
#define IDE_ERROR_COMMAND_ABORTED    0x04
#define IDE_ERROR_END_OF_MEDIA       0x02
#define IDE_ERROR_ILLEGAL_LENGTH     0x01

//
// ATAPI register definition
//

typedef struct _ATAPI_REGISTERS_1 {
    USHORT Data;
    UCHAR InterruptReason;
    UCHAR Unused1;
    UCHAR ByteCountLow;
    UCHAR ByteCountHigh;
    UCHAR DriveSelect;
    UCHAR Command;
} ATAPI_REGISTERS_1, *PATAPI_REGISTERS_1;

typedef struct _ATAPI_REGISTERS_2 {
    UCHAR DeviceControl;
    UCHAR DriveAddress;
} ATAPI_REGISTERS_2, *PATAPI_REGISTERS_2;


//
// ATAPI interrupt reasons
//

#define ATAPI_IR_COD 0x01
#define ATAPI_IR_IO  0x02

//
// IDENTIFY data
//
#pragma pack (1)
typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumberOfCylinders;               // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumberOfHeads;                   // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT SectorsPerTrack;                 // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    USHORT SerialNumber[10];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    UCHAR  FirmwareRevision[8];             // 2E  23-26
    UCHAR  ModelNumber[40];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:3;        // 6A  53
    USHORT Reserved3:13;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[11];                   //     69-79
    USHORT MajorRevision;                   //     80
    USHORT MinorRevision;                   //     81
    USHORT Reserved6[6];                    //     82-87
    USHORT UltraDMASupport : 8;             //     88
    USHORT UltraDMAActive  : 8;             //
    USHORT Reserved7[38];                   //     89-126
    USHORT SpecialFunctionsEnabled;         //     127
    USHORT Reserved8[128];                  //     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;

//
// Identify data without the Reserved4.
//

typedef struct _IDENTIFY_DATA2 {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumberOfCylinders;               // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumberOfHeads;                   // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT SectorsPerTrack;                 // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    USHORT SerialNumber[10];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    UCHAR  FirmwareRevision[8];             // 2E  23-26
    UCHAR  ModelNumber[40];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:3;        // 6A  53
    USHORT Reserved3:13;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[11];                   //     69-79
    USHORT MajorRevision;                   //     80
    USHORT MinorRevision;                   //     81
    USHORT Reserved6[6];                    //     82-87
    USHORT UltraDMASupport : 8;             //     88
    USHORT UltraDMAActive  : 8;             //
    USHORT Reserved7[38];                   //     89-126
    USHORT SpecialFunctionsEnabled;         //     127
    USHORT Reserved8[2];                    //     128-129
} IDENTIFY_DATA2, *PIDENTIFY_DATA2;
#pragma pack ()

#define IDENTIFY_DATA_SIZE sizeof(IDENTIFY_DATA)

//
// IDENTIFY capability bit definitions.
//

#define IDENTIFY_CAPABILITIES_DMA_SUPPORTED             (1 << 8)
#define IDENTIFY_CAPABILITIES_LBA_SUPPORTED             (1 << 9)
#define IDENTIFY_CAPABILITIES_IOREADY_CAN_BE_DISABLED   (1 << 10)
#define IDENTIFY_CAPABILITIES_IOREADY_SUPPORTED         (1 << 11)


//
// Select LBA mode when progran IDE device
//
#define IDE_LBA_MODE                                    (1 << 6)

//
// Beautification macros
//

#define GetStatus(BaseIoAddress, Status) \
    Status = ScsiPortReadPortUchar(&BaseIoAddress->Command);

#define GetBaseStatus(BaseIoAddress, Status) \
    Status = ScsiPortReadPortUchar(&BaseIoAddress->Command);

#define WriteCommand(BaseIoAddress, Command) \
    ScsiPortWritePortUchar(&BaseIoAddress->Command, Command);



#define ReadBuffer(BaseIoAddress, Buffer, Count) \
    ScsiPortReadPortBufferUshort(&BaseIoAddress->Data, \
                                 Buffer, \
                                 Count);

#define WriteBuffer(BaseIoAddress, Buffer, Count) \
    ScsiPortWritePortBufferUshort(&BaseIoAddress->Data, \
                                  Buffer, \
                                  Count);

#define ReadBuffer2(BaseIoAddress, Buffer, Count) \
    ScsiPortReadPortBufferUlong(&BaseIoAddress->Data, \
                             Buffer, \
                             Count);

#define WriteBuffer2(BaseIoAddress, Buffer, Count) \
    ScsiPortWritePortBufferUlong(&BaseIoAddress->Data, \
                              Buffer, \
                              Count);

#define WaitOnBusy(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<20000; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(150); \
            continue; \
        } else { \
            break; \
        } \
    if (i == 20000) \
        DebugPrint ((0, "WaitOnBusy failed in %s line %u. status = 0x%x\n", __FILE__, __LINE__, (ULONG) (Status))); \
    } \
}

#define WaitOnBaseBusy(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<20000; i++) { \
        GetBaseStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(150); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WaitForDrq(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<1000; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(200); \
        } \
    } \
}


#define WaitShortForDrq(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<2; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(100); \
        } \
    } \
}

#define AtapiSoftReset(BaseIoAddress, DeviceNumber, interruptOff) \
{\
    ULONG __i=0;\
    UCHAR statusByte; \
    DebugPrintTickCount(); \
    ScsiPortWritePortUchar(&BaseIoAddress->DriveSelect,(UCHAR)(((DeviceNumber & 0x1) << 4) | 0xA0)); \
    ScsiPortStallExecution(500);\
    ScsiPortWritePortUchar(&BaseIoAddress->Command, IDE_COMMAND_ATAPI_RESET); \
    ScsiPortStallExecution(10); \
    do {                        \
        WaitOnBusy(BaseIoAddress, statusByte); \
        __i++;                                   \
    } while ((statusByte & IDE_STATUS_BUSY) && (__i < 1000)); \
    ScsiPortWritePortUchar(&BaseIoAddress->DriveSelect,(UCHAR)((DeviceNumber << 4) | 0xA0)); \
    WaitOnBusy(BaseIoAddress, statusByte); \
    ScsiPortStallExecution(500);\
    if (interruptOff) { \
        ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl, IDE_DC_DISABLE_INTERRUPTS); \
    } \
    DebugPrintTickCount(); \
}

#define IdeHardReset(BaseIoAddress1, BaseIoAddress2, result) \
{\
    UCHAR statusByte;\
    ULONG i;\
    ScsiPortWritePortUchar(&BaseIoAddress2->DeviceControl,IDE_DC_RESET_CONTROLLER );\
    ScsiPortStallExecution(50 * 1000);\
    ScsiPortWritePortUchar(&BaseIoAddress2->DeviceControl,IDE_DC_REENABLE_CONTROLLER);\
    for (i = 0; i < 1000 * 1000; i++) {\
        statusByte = ScsiPortReadPortUchar(&BaseIoAddress1->Command);\
        if (statusByte != IDE_STATUS_IDLE && statusByte != 0x0) {\
            ScsiPortStallExecution(5);\
        } else {\
            break;\
        }\
    }\
    if (i == 1000*1000) {\
        result = FALSE;\
    }\
    result = TRUE;\
}

#define IS_RDP(OperationCode)\
    ((OperationCode == SCSIOP_ERASE)||\
    (OperationCode == SCSIOP_LOAD_UNLOAD)||\
    (OperationCode == SCSIOP_LOCATE)||\
    (OperationCode == SCSIOP_REWIND) ||\
    (OperationCode == SCSIOP_SPACE)||\
    (OperationCode == SCSIOP_SEEK)||\
    (OperationCode == SCSIOP_WRITE_FILEMARKS))

struct _CONTROLLER_PARAMETERS;

//
// Keep trap off DriverEntry status
//
typedef struct _FIND_STATE {

    ULONG   BusNumber;
    ULONG   SlotNumber;
    ULONG   LogicalDeviceNumber;
    ULONG   IdeChannel;

    PULONG   DefaultIoPort;
    PULONG   DefaultInterrupt;
    PBOOLEAN IoAddressUsed;

    struct _CONTROLLER_PARAMETERS * ControllerParameters;

} FIND_STATE, * PFIND_STATE;

//
// Bus Master Physical Region Descriptor
//
#pragma pack (1)
typedef struct _PHYSICAL_REGION_DESCRIPTOR {
    ULONG PhyscialAddress;
    ULONG ByteCount:16;
    ULONG Reserved:15;
    ULONG EndOfTable:1;
} PHYSICAL_REGION_DESCRIPTOR, * PPHYSICAL_REGION_DESCRIPTOR;
#pragma pack ()

#define MAX_TRANSFER_SIZE_PER_SRB                   (0x20000)

#define MAX_DEVICE                          (2)
#define MAX_CHANNEL                         (2)

//
// Device extension
//
typedef struct _HW_DEVICE_EXTENSION {

    //
    // Current request on controller.
    //

    PSCSI_REQUEST_BLOCK CurrentSrb;

    //
    // Base register locations
    //

    PIDE_REGISTERS_1            BaseIoAddress1[2];
    PIDE_REGISTERS_2            BaseIoAddress2[2];
    PIDE_BUS_MASTER_REGISTERS   BusMasterPortBase[2];

    //
    // Interrupt level
    //

    ULONG InterruptLevel;

    //
    // Interrupt Mode (Level or Edge)
    //

    ULONG InterruptMode;

    //
    // Data buffer pointer.
    //

    PUSHORT DataBuffer;

    //
    // Data words left.
    //

    ULONG WordsLeft;

    //
    // Number of channels being supported by one instantiation
    // of the device extension. Normally (and correctly) one, but
    // with so many broken PCI IDE controllers being sold, we have
    // to support them.
    //

    ULONG NumberChannels;

    //
    // Count of errors. Used to turn off features.
    //

    ULONG ErrorCount;

    //
    // Indicates number of platters on changer-ish devices.
    //

    ULONG DiscsPresent[MAX_DEVICE * MAX_CHANNEL];

    //
    // Flags word for each possible device.
    //

    USHORT DeviceFlags[MAX_DEVICE * MAX_CHANNEL];

    //
    // Indicates the number of blocks transferred per int. according to the
    // identify data.
    //

    UCHAR MaximumBlockXfer[MAX_DEVICE * MAX_CHANNEL];

    //
    // Indicates expecting an interrupt
    //

    BOOLEAN ExpectingInterrupt;

    //
    // Indicates DMA is in progress
    //

    BOOLEAN DMAInProgress;


    //
    // Indicate last tape command was DSC Restrictive.
    //

    BOOLEAN RDP;

    //
    // Driver is being used by the crash dump utility or ntldr.
    //

    BOOLEAN DriverMustPoll;

    //
    // Indicates use of 32-bit PIO
    //

    BOOLEAN DWordIO;

    //
    // Indicates whether '0x1f0' is the base address. Used
    // in SMART Ioctl calls.
    //

    BOOLEAN PrimaryAddress;

    //
    // Placeholder for the sub-command value of the last
    // SMART command.
    //

    UCHAR SmartCommand;

    //
    // Placeholder for status register after a GET_MEDIA_STATUS command
    //

    UCHAR ReturningMediaStatus;

    UCHAR Reserved[1];

    //
    // Mechanism Status Srb Data
    //
    PSCSI_REQUEST_BLOCK OriginalSrb;
    SCSI_REQUEST_BLOCK InternalSrb;
    MECHANICAL_STATUS_INFORMATION_HEADER MechStatusData;
    SENSE_DATA MechStatusSense;
    ULONG MechStatusRetryCount;

    //
    // Identify data for device
    //
    IDENTIFY_DATA2 IdentifyData[MAX_DEVICE * MAX_CHANNEL];

    //
    // Bus Master Data
    //
    // Physcial Region Table for bus mastering
    PPHYSICAL_REGION_DESCRIPTOR DataBufferDescriptionTablePtr;
    ULONG                       DataBufferDescriptionTableSize;
    PHYSICAL_ADDRESS            DataBufferDescriptionTablePhysAddr;

    //
    // Controller Flags
    //
    USHORT ControllerFlags;

    //
    // Control whether we ship try to enable busmastering
    //
    BOOLEAN UseBusMasterController;

    //
    // Function to set bus master timing
    //
    BOOLEAN (*BMTimingControl) (struct _HW_DEVICE_EXTENSION * DeviceExtension);

    //
    // Function to set check whether a PCI IDE channel is enabled
    //
    BOOLEAN (*IsChannelEnabled) (PPCI_COMMON_CONFIG PciData, ULONG Channel);


    // PCI Address
    ULONG   PciBusNumber;
    ULONG   PciDeviceNumber;
    ULONG   PciLogDevNumber;

    //
    // Device Specific Info.
    //
    struct _DEVICE_PARAMETERS {

        ULONG   MaxWordPerInterrupt;

        UCHAR   IdeReadCommand;
        UCHAR   IdeWriteCommand;

        BOOLEAN IoReadyEnabled;
        ULONG   PioCycleTime;
        ULONG   DmaCycleTime;

        ULONG   BestPIOMode;
        ULONG   BestSingleWordDMAMode;
        ULONG   BestMultiWordDMAMode;

    } DeviceParameters[MAX_CHANNEL * MAX_DEVICE];

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


//
// PCI IDE Controller definition
//
typedef struct _CONTROLLER_PARAMETERS {

    INTERFACE_TYPE AdapterInterfaceType;

    PUCHAR  VendorId;
    USHORT  VendorIdLength;
    PUCHAR  DeviceId;
    USHORT  DeviceIdLength;

    ULONG   NumberOfIdeBus;

    BOOLEAN SingleFIFO;

    BOOLEAN (*TimingControl) (PHW_DEVICE_EXTENSION DeviceExtension);

    BOOLEAN (*IsChannelEnabled) (PPCI_COMMON_CONFIG PciData, ULONG Channel);

} CONTROLLER_PARAMETERS, * PCONTROLLER_PARAMETERS;

//
// max number of CHS addressable sectors
//
#define MAX_NUM_CHS_ADDRESSABLE_SECTORS     ((ULONG) (16515072 - 1))


//
// IDE Cycle Timing
//
#define PIO_MODE0_CYCLE_TIME        600
#define PIO_MODE1_CYCLE_TIME        383
#define PIO_MODE2_CYCLE_TIME        240
#define PIO_MODE3_CYCLE_TIME        180
#define PIO_MODE4_CYCLE_TIME        120

#define SWDMA_MODE0_CYCLE_TIME      960
#define SWDMA_MODE1_CYCLE_TIME      480
#define SWDMA_MODE2_CYCLE_TIME      240

#define MWDMA_MODE0_CYCLE_TIME      480
#define MWDMA_MODE1_CYCLE_TIME      150
#define MWDMA_MODE2_CYCLE_TIME      120

#define UNINITIALIZED_CYCLE_TIME    0xffffffff

//
// invalid mode values
//
#define INVALID_PIO_MODE        0xffffffff
#define INVALID_SWDMA_MODE        0xffffffff
#define INVALID_MWDMA_MODE        0xffffffff


//
// Bus Master Status Register
//
#define BUSMASTER_DMA_SIMPLEX_BIT     ((UCHAR) (1 << 7))
#define BUSMASTER_DEVICE1_DMA_OK      ((UCHAR) (1 << 6))
#define BUSMASTER_DEVICE0_DMA_OK      ((UCHAR) (1 << 5))
#define BUSMASTER_INTERRUPT           ((UCHAR) (1 << 2))
#define BUSMASTER_ERROR               ((UCHAR) (1 << 1))
#define BUSMASTER_ACTIVE              ((UCHAR) (1 << 0))


//
// PCI access port
//
#define PCI_ADDR_PORT               (0x0cf8)
#define PCI_DATA_PORT               (0x0cfc)
#define PCI_ADDRESS(bus, deviceNum, funcNum, offset) \
                                     ((1 << 31) |                 \
                                     ((bus & 0xff) << 16) |       \
                                     ((deviceNum & 0x1f) << 11) | \
                                     ((funcNum & 0x7) << 8) |     \
                                     ((offset & 0x3f) << 2))

// GET PAGE_SIZE into miniport.h
#ifdef ALPHA
#define PAGE_SIZE (ULONG)0x2000
#else // MIPS, PPC, I386
#define PAGE_SIZE (ULONG)0x1000
#endif

#define SCSIOP_ATA_PASSTHROUGH       (0xcc)

//
// valid DMA detection level
//
#define DMADETECT_PIO       0
#define DMADETECT_SAFE      1
#define DMADETECT_UNSAFE    2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\atapi\atapi.c ===
/*++

Copyright (c) 1993-6  Microsoft Corporation

Module Name:

    atapi.c

Abstract:

    This is the miniport driver for ATAPI IDE controllers.

Author:

    Mike Glass (MGlass)
    Chuck Park (ChuckP)
    Joe Dai (joedai)

Environment:

    kernel mode only

Notes:

Revision History:

    george C.(georgioc)     Merged wtih Compaq code to make miniport driver function
                            with the 120MB floppy drive
                            Added support for MEDIA STATUS NOTIFICATION
                            Added support for SCSIOP_START_STOP_UNIT (eject media)

    joedai                  PCI Bus Master IDE Support
                            ATA Passthrough (temporary solution)
                            LBA with ATA drive > 8G
                            PCMCIA IDE support
                            Native mode support

--*/


#include "miniport.h"
#include "devioctl.h"
#include "atapi.h"               // includes scsi.h
#include "ntdddisk.h"
#include "ntddscsi.h"

#include "intel.h"

//
// Logical unit extension
//

typedef struct _HW_LU_EXTENSION {
   ULONG Reserved;
} HW_LU_EXTENSION, *PHW_LU_EXTENSION;

//
// control DMA detection
//
ULONG AtapiPlaySafe = 1;

//
// PCI IDE Controller List
//
CONTROLLER_PARAMETERS
PciControllerParameters[] = {
    {                     PCIBus,
                          "8086",                   // Intel
                               4,
                          "7111",                   // PIIX4 82371
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
            IntelIsChannelEnabled
    },
    {                     PCIBus,
                          "8086",                   // Intel
                               4,
                          "7010",                   // PIIX3 82371
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
            IntelIsChannelEnabled
    },
    {                     PCIBus,
                          "8086",                   // Intel
                               4,
                          "1230",                   // PIIX 82371
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
            IntelIsChannelEnabled
    },
    {                     PCIBus,
                          "1095",                   // CMD
                               4,
                          "0646",                   // 646
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },
    {                     PCIBus,
                          "10b9",                   // ALi (Acer)
                               4,
                          "5219",                   // 5219
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },
    {                     PCIBus,
                          "1039",                   // SiS
                               4,
                          "5513",                   // 5513
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },
    {                     PCIBus,
                          "0e11",                   // Compaq
                               4,
                          "ae33",                   //
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },
    {                     PCIBus,
                          "10ad",                   // WinBond
                               4,
                          "0105",                   // 105
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },
    {                     PCIBus,
                          "105a",                   // Promise Technologies
                               4,
                          "4D33",                   // U33
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },


// Broken PCI controllers
    {                     PCIBus,
                          "1095",                   // CMD
                               4,
                          "0640",                   // 640
                               4,
                               2,                   // NumberOfIdeBus
                            TRUE,                   // Single FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },
    {                     PCIBus,
                          "1039",                   // SiS
                               4,
                          "0601",                   // ????
                               4,
                               2,                   // NumberOfIdeBus
                            TRUE,                   // Single FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    }
};
#define NUMBER_OF_PCI_CONTROLLER (sizeof(PciControllerParameters) / sizeof(CONTROLLER_PARAMETERS))

PSCSI_REQUEST_BLOCK
BuildMechanismStatusSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    );

PSCSI_REQUEST_BLOCK
BuildRequestSenseSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    );

VOID
AtapiHwInitializeChanger (
    IN PVOID HwDeviceExtension,
    IN ULONG TargetId,
    IN PMECHANICAL_STATUS_INFORMATION_HEADER MechanismStatus
    );

ULONG
AtapiSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
AtapiZeroMemory(
    IN PCHAR Buffer,
    IN ULONG Count
    );

VOID
AtapiHexToString (
    ULONG Value,
    PCHAR *Buffer
    );

LONG
AtapiStringCmp (
    PCHAR FirstStr,
    PCHAR SecondStr,
    ULONG Count
    );

BOOLEAN
AtapiInterrupt(
    IN PVOID HwDeviceExtension
    );

BOOLEAN
AtapiHwInitialize(
    IN PVOID HwDeviceExtension
        );

ULONG
IdeBuildSenseBuffer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
IdeMediaStatus(
    IN BOOLEAN EnableMSN,
    IN PVOID HwDeviceExtension,
    IN ULONG Channel
    );

VOID
DeviceSpecificInitialize(
    IN PVOID HwDeviceExtension
    );

BOOLEAN
PrepareForBusMastering(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
EnableBusMastering(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
SetBusMasterDetectionLevel (
    IN PVOID HwDeviceExtension,
    IN PCHAR userArgumentString
    );

BOOLEAN
AtapiDeviceDMACapable (
    IN PVOID HwDeviceExtension,
    IN ULONG deviceNumber
    );

#if defined (xDBG)
// Need to link to nt kernel
void KeQueryTickCount(PLARGE_INTEGER c);
LONGLONG lastTickCount = 0;
#define DebugPrintTickCount()     _DebugPrintTickCount (__LINE__)

//
// for performance tuning
//
void _DebugPrintTickCount (ULONG lineNumber)
{
    LARGE_INTEGER tickCount;

        KeQueryTickCount(&tickCount);
    DebugPrint ((1, "Line %u: CurrentTick = %u (%u ticks since last check)\n", lineNumber, tickCount.LowPart, (ULONG) (tickCount.QuadPart - lastTickCount)));
    lastTickCount = tickCount.QuadPart;
}
#else
#define DebugPrintTickCount()
#endif //DBG



BOOLEAN
IssueIdentify(
    IN PVOID HwDeviceExtension,
    IN ULONG DeviceNumber,
    IN ULONG Channel,
    IN UCHAR Command,
    IN BOOLEAN InterruptOff
    )

/*++

Routine Description:

    Issue IDENTIFY command to a device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    DeviceNumber - Indicates which device.
    Command - Either the standard (EC) or the ATAPI packet (A1) IDENTIFY.
    InterruptOff - should leave interrupt disabled

Return Value:

    TRUE if all goes well.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[Channel] ;
    PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[Channel];
    ULONG                waitCount = 20000;
    ULONG                i,j;
    UCHAR                statusByte;
    UCHAR                signatureLow,
                         signatureHigh;
    IDENTIFY_DATA        fullIdentifyData;

    DebugPrintTickCount();

    //
    // Select device 0 or 1.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                           (UCHAR)((DeviceNumber << 4) | 0xA0));

    //
    // Check that the status register makes sense.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    if (Command == IDE_COMMAND_IDENTIFY) {

        //
        // Mask status byte ERROR bits.
        //

        statusByte &= ~(IDE_STATUS_ERROR | IDE_STATUS_INDEX);

        DebugPrint((1,
                    "IssueIdentify: Checking for IDE. Status (%x)\n",
                    statusByte));

        //
        // Check if register value is reasonable.
        //

        if (statusByte != IDE_STATUS_IDLE) {

            //
            // Reset the controller.
            //

            AtapiSoftReset(baseIoAddress1,DeviceNumber, InterruptOff);

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                   (UCHAR)((DeviceNumber << 4) | 0xA0));

            WaitOnBusy(baseIoAddress1,statusByte);

            signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
            signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

            if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                //
                // Device is Atapi.
                //

                DebugPrintTickCount();
                return FALSE;
            }

            DebugPrint((1,
                        "IssueIdentify: Resetting controller.\n"));

            ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl,IDE_DC_RESET_CONTROLLER | IDE_DC_DISABLE_INTERRUPTS);
            ScsiPortStallExecution(500 * 1000);
            if (InterruptOff) {
                ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl, IDE_DC_DISABLE_INTERRUPTS);
            } else {
                ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl, IDE_DC_REENABLE_CONTROLLER);
            }


            // We really should wait up to 31 seconds
            // The ATA spec. allows device 0 to come back from BUSY in 31 seconds!
            // (30 seconds for device 1)
            do {

                //
                // Wait for Busy to drop.
                //

                ScsiPortStallExecution(100);
                GetStatus(baseIoAddress1, statusByte);

            } while ((statusByte & IDE_STATUS_BUSY) && waitCount--);

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                   (UCHAR)((DeviceNumber << 4) | 0xA0));

            //
            // Another check for signature, to deal with one model Atapi that doesn't assert signature after
            // a soft reset.
            //

            signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
            signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

            if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                //
                // Device is Atapi.
                //

                DebugPrintTickCount();
                return FALSE;
            }

            statusByte &= ~IDE_STATUS_INDEX;

            if (statusByte != IDE_STATUS_IDLE) {

                //
                // Give up on this.
                //

                DebugPrintTickCount();
                return FALSE;
            }

        }

    } else {

        DebugPrint((1,
                    "IssueIdentify: Checking for ATAPI. Status (%x)\n",
                    statusByte));

    }

    //
    // Load CylinderHigh and CylinderLow with number bytes to transfer.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, (0x200 >> 8));
    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,  (0x200 & 0xFF));

    for (j = 0; j < 2; j++) {

        //
        // Send IDENTIFY command.
        //

        WaitOnBusy(baseIoAddress1,statusByte);

        ScsiPortWritePortUchar(&baseIoAddress1->Command, Command);

        WaitOnBusy(baseIoAddress1,statusByte);

        //
        // Wait for DRQ.
        //

        for (i = 0; i < 4; i++) {

            WaitForDrq(baseIoAddress1, statusByte);

            if (statusByte & IDE_STATUS_DRQ) {

                //
                // Read status to acknowledge any interrupts generated.
                //

                GetBaseStatus(baseIoAddress1, statusByte);

                //
                // One last check for Atapi.
                //


                signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    //
                    // Device is Atapi.
                    //

                    DebugPrintTickCount();
                    return FALSE;
                }

                break;
            }

            if (Command == IDE_COMMAND_IDENTIFY) {

                //
                // Check the signature. If DRQ didn't come up it's likely Atapi.
                //

                signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    //
                    // Device is Atapi.
                    //

                    DebugPrintTickCount();
                    return FALSE;
                }
            }

            WaitOnBusy(baseIoAddress1,statusByte);
        }

        if (i == 4 && j == 0) {

            //
            // Device didn't respond correctly. It will be given one more chances.
            //

            DebugPrint((1,
                        "IssueIdentify: DRQ never asserted (%x). Error reg (%x)\n",
                        statusByte,
                         ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1)));

            AtapiSoftReset(baseIoAddress1, DeviceNumber, InterruptOff);

            GetStatus(baseIoAddress1,statusByte);

            DebugPrint((1,
                       "IssueIdentify: Status after soft reset (%x)\n",
                       statusByte));

        } else {

            break;

        }
    }

    //
    // Check for error on really bad master devices that assert random
    // patterns of bits in the status register at the slave address.
    //

    if ((Command == IDE_COMMAND_IDENTIFY) && (statusByte & IDE_STATUS_ERROR)) {
        DebugPrintTickCount();
        return FALSE;
    }

    DebugPrint((1,
               "IssueIdentify: Status before read words %x\n",
               statusByte));

    //
    // Suck out 256 words. After waiting for one model that asserts busy
    // after receiving the Packet Identify command.
    //

    WaitOnBusy(baseIoAddress1,statusByte);

    if (!(statusByte & IDE_STATUS_DRQ)) {
        DebugPrintTickCount();
        return FALSE;
    }

    ReadBuffer(baseIoAddress1,
               (PUSHORT)&fullIdentifyData,
               sizeof (fullIdentifyData) / 2);

    //
    // Check out a few capabilities / limitations of the device.
    //

    if (fullIdentifyData.SpecialFunctionsEnabled & 1) {

        //
        // Determine if this drive supports the MSN functions.
        //

        DebugPrint((2,"IssueIdentify: Marking drive %d as removable. SFE = %d\n",
                    Channel * 2 + DeviceNumber,
                    fullIdentifyData.SpecialFunctionsEnabled));


        deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_REMOVABLE_DRIVE;
    }

    if (fullIdentifyData.MaximumBlockTransfer) {

        //
        // Determine max. block transfer for this device.
        //

        deviceExtension->MaximumBlockXfer[(Channel * 2) + DeviceNumber] =
            (UCHAR)(fullIdentifyData.MaximumBlockTransfer & 0xFF);
    }

    ScsiPortMoveMemory(&deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber],&fullIdentifyData,sizeof(IDENTIFY_DATA2));

    if (deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber].GeneralConfiguration & 0x20 &&
        Command != IDE_COMMAND_IDENTIFY) {

        //
        // This device interrupts with the assertion of DRQ after receiving
        // Atapi Packet Command
        //

        deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_INT_DRQ;

        DebugPrint((2,
                    "IssueIdentify: Device interrupts on assertion of DRQ.\n"));

    } else {

        DebugPrint((2,
                    "IssueIdentify: Device does not interrupt on assertion of DRQ.\n"));
    }

    if (((deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber].GeneralConfiguration & 0xF00) == 0x100) &&
        Command != IDE_COMMAND_IDENTIFY) {

        //
        // This is a tape.
        //

        deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_TAPE_DEVICE;

        DebugPrint((2,
                    "IssueIdentify: Device is a tape drive.\n"));

    } else {

        DebugPrint((2,
                    "IssueIdentify: Device is not a tape drive.\n"));
    }

    //
    // Work around for some IDE and one model Atapi that will present more than
    // 256 bytes for the Identify data.
    //

    WaitOnBusy(baseIoAddress1,statusByte);

    for (i = 0; i < 0x10000; i++) {

        GetStatus(baseIoAddress1,statusByte);

        if (statusByte & IDE_STATUS_DRQ) {

            //
            // Suck out any remaining bytes and throw away.
            //

            ScsiPortReadPortUshort(&baseIoAddress1->Data);

        } else {

            break;

        }
    }

    DebugPrint((3,
               "IssueIdentify: Status after read words (%x)\n",
               statusByte));

    DebugPrintTickCount();
    return TRUE;

} // end IssueIdentify()


BOOLEAN
SetDriveParameters(
    IN PVOID HwDeviceExtension,
    IN ULONG DeviceNumber,
    IN ULONG Channel
    )

/*++

Routine Description:

    Set drive parameters using the IDENTIFY data.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    DeviceNumber - Indicates which device.

Return Value:

    TRUE if all goes well.


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[Channel];
    PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[Channel];
    PIDENTIFY_DATA2      identifyData   = &deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber];
    ULONG i;
    UCHAR statusByte;

    DebugPrint((1,
               "SetDriveParameters: Number of heads %x\n",
               identifyData->NumberOfHeads));

    DebugPrint((1,
               "SetDriveParameters: Sectors per track %x\n",
                identifyData->SectorsPerTrack));

    //
    // Set up registers for SET PARAMETER command.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                           (UCHAR)(((DeviceNumber << 4) | 0xA0) | (identifyData->NumberOfHeads - 1)));

    ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                           (UCHAR)identifyData->SectorsPerTrack);

    //
    // Send SET PARAMETER command.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->Command,
                           IDE_COMMAND_SET_DRIVE_PARAMETERS);

    //
    // Wait for up to 30 milliseconds for ERROR or command complete.
    //

    for (i=0; i<30 * 1000; i++) {

        UCHAR errorByte;

        GetStatus(baseIoAddress1, statusByte);

        if (statusByte & IDE_STATUS_ERROR) {
            errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
            DebugPrint((1,
                        "SetDriveParameters: Error bit set. Status %x, error %x\n",
                        errorByte,
                        statusByte));

            return FALSE;
        } else if ((statusByte & ~IDE_STATUS_INDEX ) == IDE_STATUS_IDLE) {
            break;
        } else {
            ScsiPortStallExecution(100);
        }
    }

    //
    // Check for timeout.
    //

    if (i == 30 * 1000) {
        return FALSE;
    } else {
        return TRUE;
    }

} // end SetDriveParameters()


BOOLEAN
AtapiResetController(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    )

/*++

Routine Description:

    Reset IDE controller and/or Atapi device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Nothing.


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG                numberChannels  = deviceExtension->NumberChannels;
    PIDE_REGISTERS_1 baseIoAddress1;
    PIDE_REGISTERS_2 baseIoAddress2;
    BOOLEAN result = FALSE;
    ULONG i,j;
    UCHAR statusByte;

    DebugPrint((2,"AtapiResetController: Reset IDE\n"));

    //
    // Check and see if we are processing an internal srb
    //
    if (deviceExtension->OriginalSrb) {
        deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
        deviceExtension->OriginalSrb = NULL;
    }

    //
    // Check if request is in progress.
    //

    if (deviceExtension->CurrentSrb) {

        //
        // Complete outstanding request with SRB_STATUS_BUS_RESET.
        //

        ScsiPortCompleteRequest(deviceExtension,
                                deviceExtension->CurrentSrb->PathId,
                                deviceExtension->CurrentSrb->TargetId,
                                deviceExtension->CurrentSrb->Lun,
                                (ULONG)SRB_STATUS_BUS_RESET);

        //
        // Clear request tracking fields.
        //

        deviceExtension->CurrentSrb = NULL;
        deviceExtension->WordsLeft = 0;
        deviceExtension->DataBuffer = NULL;

        //
        // Indicate ready for next request.
        //

        ScsiPortNotification(NextRequest,
                             deviceExtension,
                             NULL);
    }

    //
    // Clear DMA
    //
    if (deviceExtension->DMAInProgress) {

        for (j = 0; j < numberChannels; j++) {
            UCHAR dmaStatus;

            dmaStatus = ScsiPortReadPortUchar (&deviceExtension->BusMasterPortBase[j]->Status);
            ScsiPortWritePortUchar (&deviceExtension->BusMasterPortBase[j]->Command, 0);  // disable BusMastering
            ScsiPortWritePortUchar (&deviceExtension->BusMasterPortBase[j]->Status,
                                    (UCHAR) (dmaStatus & (BUSMASTER_DEVICE0_DMA_OK | BUSMASTER_DEVICE1_DMA_OK)));    // clear interrupt/error
        }
        deviceExtension->DMAInProgress = FALSE;
    }

    //
    // Clear expecting interrupt flag.
    //

    deviceExtension->ExpectingInterrupt = FALSE;
    deviceExtension->RDP = FALSE;

    for (j = 0; j < numberChannels; j++) {

        baseIoAddress1 = deviceExtension->BaseIoAddress1[j];
        baseIoAddress2 = deviceExtension->BaseIoAddress2[j];

        //
        // Do special processing for ATAPI and IDE disk devices.
        //

        for (i = 0; i < 2; i++) {

            //
            // Check if device present.
            //

            if (deviceExtension->DeviceFlags[i + (j * 2)] & DFLAGS_DEVICE_PRESENT) {

                //
                // Check for ATAPI disk.
                //

                if (deviceExtension->DeviceFlags[i + (j * 2)] & DFLAGS_ATAPI_DEVICE) {

                    //
                    // Issue soft reset and issue identify.
                    //

                    GetStatus(baseIoAddress1,statusByte);
                    DebugPrint((1,
                                "AtapiResetController: Status before Atapi reset (%x).\n",
                                statusByte));

                    AtapiSoftReset(baseIoAddress1,i, FALSE);

                    GetStatus(baseIoAddress1,statusByte);


                    if (statusByte == 0x0) {

                        IssueIdentify(HwDeviceExtension,
                                      i,
                                      j,
                                      IDE_COMMAND_ATAPI_IDENTIFY,
                                      FALSE);
                    } else {

                        DebugPrint((1,
                                   "AtapiResetController: Status after soft reset %x\n",
                                   statusByte));
                    }

                } else {

                    //
                    // Write IDE reset controller bits.
                    //

                    IdeHardReset(baseIoAddress1, baseIoAddress2,result);

                    if (!result) {
                        return FALSE;
                    }

                    //
                    // Set disk geometry parameters.
                    //

                    if (!SetDriveParameters(HwDeviceExtension,
                                            i,
                                            j)) {

                        DebugPrint((1,
                                   "AtapiResetController: SetDriveParameters failed\n"));
                    }

                    // re-enable MSN
                    IdeMediaStatus(TRUE, HwDeviceExtension, j * numberChannels + i);
                }
            }
        }
    }

    //
    // Call the HwInitialize routine to setup multi-block.
    //

    AtapiHwInitialize(HwDeviceExtension);

    return TRUE;

} // end AtapiResetController()



ULONG
MapError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine maps ATAPI and IDE errors to specific SRB statuses.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG i;
    UCHAR errorByte;
    UCHAR srbStatus;
    UCHAR scsiStatus;

    //
    // Read the error register.
    //

    errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
    DebugPrint((1,
               "MapError: Error register is %x\n",
               errorByte));

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

        switch (errorByte >> 4) {
        case SCSI_SENSE_NO_SENSE:

            DebugPrint((1,
                       "ATAPI: No sense information\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_RECOVERED_ERROR:

            DebugPrint((1,
                       "ATAPI: Recovered error\n"));
            scsiStatus = 0;
            srbStatus = SRB_STATUS_SUCCESS;
            break;

        case SCSI_SENSE_NOT_READY:

            DebugPrint((1,
                       "ATAPI: Device not ready\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_MEDIUM_ERROR:

            DebugPrint((1,
                       "ATAPI: Media error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_HARDWARE_ERROR:

            DebugPrint((1,
                       "ATAPI: Hardware error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:

            DebugPrint((1,
                       "ATAPI: Illegal request\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_UNIT_ATTENTION:

            DebugPrint((1,
                       "ATAPI: Unit attention\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_DATA_PROTECT:

            DebugPrint((1,
                       "ATAPI: Data protect\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_BLANK_CHECK:

            DebugPrint((1,
                       "ATAPI: Blank check\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_ABORTED_COMMAND:
            DebugPrint((1,
                        "Atapi: Command Aborted\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        default:

            DebugPrint((1,
                       "ATAPI: Invalid sense information\n"));
            scsiStatus = 0;
            srbStatus = SRB_STATUS_ERROR;
            break;
        }

    } else {

        scsiStatus = 0;
        //
        // Save errorByte,to be used by SCSIOP_REQUEST_SENSE.
        //

        deviceExtension->ReturningMediaStatus = errorByte;

        if (errorByte & IDE_ERROR_MEDIA_CHANGE_REQ) {
            DebugPrint((1,
                       "IDE: Media change\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

        } else if (errorByte & IDE_ERROR_COMMAND_ABORTED) {
            DebugPrint((1,
                       "IDE: Command abort\n"));
            srbStatus = SRB_STATUS_ABORTED;
            scsiStatus = SCSISTAT_CHECK_CONDITION;

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_ABORTED_COMMAND;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

            deviceExtension->ErrorCount++;

        } else if (errorByte & IDE_ERROR_END_OF_MEDIA) {

            DebugPrint((1,
                       "IDE: End of media\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)){
                deviceExtension->ErrorCount++;
            }

        } else if (errorByte & IDE_ERROR_ILLEGAL_LENGTH) {

            DebugPrint((1,
                       "IDE: Illegal length\n"));
            srbStatus = SRB_STATUS_INVALID_REQUEST;

        } else if (errorByte & IDE_ERROR_BAD_BLOCK) {

            DebugPrint((1,
                       "IDE: Bad block\n"));
            srbStatus = SRB_STATUS_ERROR;
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_ID_NOT_FOUND) {

            DebugPrint((1,
                       "IDE: Id not found\n"));
            srbStatus = SRB_STATUS_ERROR;
            scsiStatus = SCSISTAT_CHECK_CONDITION;

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

            deviceExtension->ErrorCount++;

        } else if (errorByte & IDE_ERROR_MEDIA_CHANGE) {

            DebugPrint((1,
                       "IDE: Media change\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
                senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_DATA_ERROR) {

            DebugPrint((1,
                   "IDE: Data error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)){
                deviceExtension->ErrorCount++;
            }

            //
            // Build sense buffer
            //

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }
        }

        if ((deviceExtension->ErrorCount >= MAX_ERRORS) &&
            (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA))) {
            deviceExtension->DWordIO = FALSE;
            deviceExtension->MaximumBlockXfer[Srb->TargetId] = 0;

            DebugPrint((1,
                        "MapError: Disabling 32-bit PIO and Multi-sector IOs\n"));

            //
            // Log the error.
            //

            ScsiPortLogError( HwDeviceExtension,
                              Srb,
                              Srb->PathId,
                              Srb->TargetId,
                              Srb->Lun,
                              SP_BAD_FW_WARNING,
                              4);
            //
            // Reprogram to not use Multi-sector.
            //

            for (i = 0; i < 4; i++) {
                UCHAR statusByte;

                if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT &&
                     !(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                    //
                    // Select the device.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                           (UCHAR)(((i & 0x1) << 4) | 0xA0));

                    //
                    // Setup sector count to reflect the # of blocks.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                                           0);

                    //
                    // Issue the command.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress1->Command,
                                           IDE_COMMAND_SET_MULTIPLE);

                    //
                    // Wait for busy to drop.
                    //

                    WaitOnBaseBusy(baseIoAddress1,statusByte);

                    //
                    // Check for errors. Reset the value to 0 (disable MultiBlock) if the
                    // command was aborted.
                    //

                    if (statusByte & IDE_STATUS_ERROR) {

                        //
                        // Read the error register.
                        //

                        errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);

                        DebugPrint((1,
                                    "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
                                    statusByte,
                                    errorByte));
                        //
                        // Adjust the devExt. value, if necessary.
                        //

                        deviceExtension->MaximumBlockXfer[i] = 0;

                    }

                    deviceExtension->DeviceParameters[i].IdeReadCommand      = IDE_COMMAND_READ;
                    deviceExtension->DeviceParameters[i].IdeWriteCommand     = IDE_COMMAND_WRITE;
                    deviceExtension->DeviceParameters[i].MaxWordPerInterrupt = 256;
                    deviceExtension->MaximumBlockXfer[i] = 0;
                }
            }
        }
    }


    //
    // Set SCSI status to indicate a check condition.
    //

    Srb->ScsiStatus = scsiStatus;

    return srbStatus;

} // end MapError()


BOOLEAN
AtapiHwInitialize(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress;
    ULONG i;
    UCHAR statusByte, errorByte;


    for (i = 0; i < 4; i++) {
        if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT) {

            if (!(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                //
                // Enable media status notification
                //

                baseIoAddress = deviceExtension->BaseIoAddress1[i >> 1];

                IdeMediaStatus(TRUE,HwDeviceExtension,i);

                //
                // If supported, setup Multi-block transfers.
                //
                if (deviceExtension->MaximumBlockXfer[i]) {

                    //
                    // Select the device.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress->DriveSelect,
                                           (UCHAR)(((i & 0x1) << 4) | 0xA0));

                    //
                    // Setup sector count to reflect the # of blocks.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress->BlockCount,
                                           deviceExtension->MaximumBlockXfer[i]);

                    //
                    // Issue the command.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress->Command,
                                           IDE_COMMAND_SET_MULTIPLE);

                    //
                    // Wait for busy to drop.
                    //

                    WaitOnBaseBusy(baseIoAddress,statusByte);

                    //
                    // Check for errors. Reset the value to 0 (disable MultiBlock) if the
                    // command was aborted.
                    //

                    if (statusByte & IDE_STATUS_ERROR) {

                        //
                        // Read the error register.
                        //

                        errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress + 1);

                        DebugPrint((1,
                                    "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
                                    statusByte,
                                    errorByte));
                        //
                        // Adjust the devExt. value, if necessary.
                        //

                        deviceExtension->MaximumBlockXfer[i] = 0;

                    } else {
                        DebugPrint((2,
                                    "AtapiHwInitialize: Using Multiblock on Device %d. Blocks / int - %d\n",
                                    i,
                                    deviceExtension->MaximumBlockXfer[i]));
                    }
                }
            } else if (!(deviceExtension->DeviceFlags[i] & DFLAGS_CHANGER_INITED)){

                ULONG j;
                BOOLEAN isSanyo = FALSE;
                UCHAR vendorId[26];

                //
                // Attempt to identify any special-case devices - psuedo-atapi changers, atapi changers, etc.
                //

                for (j = 0; j < 13; j += 2) {

                    //
                    // Build a buffer based on the identify data.
                    //

                    vendorId[j] = ((PUCHAR)deviceExtension->IdentifyData[i].ModelNumber)[j + 1];
                    vendorId[j+1] = ((PUCHAR)deviceExtension->IdentifyData[i].ModelNumber)[j];
                }

                if (!AtapiStringCmp (vendorId, "CD-ROM  CDR", 11)) {

                    //
                    // Inquiry string for older model had a '-', newer is '_'
                    //

                    if (vendorId[12] == 'C') {

                        //
                        // Torisan changer. Set the bit. This will be used in several places
                        // acting like 1) a multi-lun device and 2) building the 'special' TUR's.
                        //

                        deviceExtension->DeviceFlags[i] |= (DFLAGS_CHANGER_INITED | DFLAGS_SANYO_ATAPI_CHANGER);
                        deviceExtension->DiscsPresent[i] = 3;
                        isSanyo = TRUE;
                    }
                }
            }

            //
            // We need to get our device ready for action before
            // returning from this function
            //
            // According to the atapi spec 2.5 or 2.6, an atapi device
            // clears its status BSY bit when it is ready for atapi commands.
            // However, some devices (Panasonic SQ-TC500N) are still
            // not ready even when the status BSY is clear.  They don't react
            // to atapi commands.
            //
            // Since there is really no other indication that tells us
            // the drive is really ready for action.  We are going to check BSY
            // is clear and then just wait for an arbitrary amount of time!
            //
            if (deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE) {
                PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[i >> 1];
                PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[i >> 1];
                ULONG waitCount;

                // have to get out of the loop sometime!
                // 10000 * 100us = 1000,000us = 1000ms = 1s
                waitCount = 10000;
                GetStatus(baseIoAddress1, statusByte);
                while ((statusByte & IDE_STATUS_BUSY) && waitCount) {
                    //
                    // Wait for Busy to drop.
                    //
                    ScsiPortStallExecution(100);
                    GetStatus(baseIoAddress1, statusByte);
                    waitCount--;
                }

                // 5000 * 100us = 500,000us = 500ms = 0.5s
                waitCount = 5000;
                do {
                    ScsiPortStallExecution(100);
                } while (waitCount--);
            }
        }
    }

    return TRUE;

} // end AtapiHwInitialize()


VOID
AtapiHwInitializeChanger (
    IN PVOID HwDeviceExtension,
    IN ULONG TargetId,
    IN PMECHANICAL_STATUS_INFORMATION_HEADER MechanismStatus)
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;

    if (MechanismStatus) {
        deviceExtension->DiscsPresent[TargetId] = MechanismStatus->NumberAvailableSlots;
        if (deviceExtension->DiscsPresent[TargetId] > 1) {
            deviceExtension->DeviceFlags[TargetId] |= DFLAGS_ATAPI_CHANGER;
        }
    }
    return;
}



BOOLEAN
FindDevices(
    IN PVOID HwDeviceExtension,
    IN BOOLEAN AtapiOnly,
    IN ULONG   Channel
    )

/*++

Routine Description:

    This routine is called from AtapiFindController to identify
    devices attached to an IDE controller.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    AtapiOnly - Indicates that routine should return TRUE only if
        an ATAPI device is attached to the controller.

Return Value:

    TRUE - True if devices found.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[Channel];
    PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[Channel];
    BOOLEAN              deviceResponded = FALSE,
                         skipSetParameters = FALSE;
    ULONG                waitCount = 10000;
    ULONG                deviceNumber;
    ULONG                i;
    UCHAR                signatureLow,
                         signatureHigh;
    UCHAR                statusByte;

    DebugPrintTickCount();

    //
    // Clear expecting interrupt flag and current SRB field.
    //

    deviceExtension->ExpectingInterrupt = FALSE;
    deviceExtension->CurrentSrb = NULL;

    // We are about to talk to our devices before our interrupt handler is installed
    // If our device uses sharable level sensitive interrupt, we may assert too
    // many bogus interrupts
    // Turn off device interrupt here
    for (deviceNumber = 0; deviceNumber < 2; deviceNumber++) {
        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR)((deviceNumber << 4) | 0xA0));
        ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl, IDE_DC_DISABLE_INTERRUPTS);
    }

    //
    // Search for devices.
    //

    for (deviceNumber = 0; deviceNumber < 2; deviceNumber++) {

        //
        // Select the device.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR)((deviceNumber << 4) | 0xA0));

        //
        // Check here for some SCSI adapters that incorporate IDE emulation.
        //

        GetStatus(baseIoAddress1, statusByte);
        if (statusByte == 0xFF) {
            continue;
        }

        DebugPrintTickCount();

        AtapiSoftReset(baseIoAddress1,deviceNumber, TRUE);

        DebugPrintTickCount();

        WaitOnBusy(baseIoAddress1,statusByte);

        DebugPrintTickCount();

        signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
        signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

        if (signatureLow == 0x14 && signatureHigh == 0xEB) {

            //
            // ATAPI signature found.
            // Issue the ATAPI identify command if this
            // is not for the crash dump utility.
            //

atapiIssueId:

            if (!deviceExtension->DriverMustPoll) {

                //
                // Issue ATAPI packet identify command.
                //

                if (IssueIdentify(HwDeviceExtension,
                                  deviceNumber,
                                  Channel,
                                  IDE_COMMAND_ATAPI_IDENTIFY,
                                  TRUE)) {

                    //
                    // Indicate ATAPI device.
                    //

                    DebugPrint((1,
                               "FindDevices: Device %x is ATAPI\n",
                               deviceNumber));

                    deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] |= DFLAGS_ATAPI_DEVICE;
                    deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] |= DFLAGS_DEVICE_PRESENT;

                    deviceResponded = TRUE;

                    GetStatus(baseIoAddress1, statusByte);
                    if (statusByte & IDE_STATUS_ERROR) {
                        AtapiSoftReset(baseIoAddress1, deviceNumber, TRUE);
                    }


                } else {

                    //
                    // Indicate no working device.
                    //

                    DebugPrint((1,
                               "FindDevices: Device %x not responding\n",
                               deviceNumber));

                    deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] &= ~DFLAGS_DEVICE_PRESENT;
                }

            }

        } else {

            //
            // Issue IDE Identify. If an Atapi device is actually present, the signature
            // will be asserted, and the drive will be recognized as such.
            //

            if (IssueIdentify(HwDeviceExtension,
                              deviceNumber,
                              Channel,
                              IDE_COMMAND_IDENTIFY,
                              TRUE)) {

                //
                // IDE drive found.
                //


                DebugPrint((1,
                           "FindDevices: Device %x is IDE\n",
                           deviceNumber));

                deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] |= DFLAGS_DEVICE_PRESENT;

                if (!AtapiOnly) {
                    deviceResponded = TRUE;
                }

                //
                // Indicate IDE - not ATAPI device.
                //

                deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] &= ~DFLAGS_ATAPI_DEVICE;


            } else {

                //
                // Look to see if an Atapi device is present.
                //

                AtapiSoftReset(baseIoAddress1, deviceNumber, TRUE);

                WaitOnBusy(baseIoAddress1,statusByte);

                signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {
                    goto atapiIssueId;
                }
            }
        }

#if DBG
        if (deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] & DFLAGS_DEVICE_PRESENT) {
            {
                ULONG i;
                UCHAR string[41];

                for (i=0; i<8; i+=2) {
                    string[i] = deviceExtension->IdentifyData[Channel * MAX_CHANNEL + deviceNumber].FirmwareRevision[i + 1];
                    string[i + 1] = deviceExtension->IdentifyData[Channel * MAX_CHANNEL + deviceNumber].FirmwareRevision[i];
                }
                string[i] = 0;
                DebugPrint((1, "FindDevices: firmware version: %s\n", string));


                for (i=0; i<40; i+=2) {
                    string[i] = deviceExtension->IdentifyData[Channel * MAX_CHANNEL + deviceNumber].ModelNumber[i + 1];
                    string[i + 1] = deviceExtension->IdentifyData[Channel * MAX_CHANNEL + deviceNumber].ModelNumber[i];
                }
                string[i] = 0;
                DebugPrint((1, "FindDevices: model number: %s\n", string));
            }
        }
#endif
    }

    for (i = 0; i < 2; i++) {
        if ((deviceExtension->DeviceFlags[i + (Channel * 2)] & DFLAGS_DEVICE_PRESENT) &&
            (!(deviceExtension->DeviceFlags[i + (Channel * 2)] & DFLAGS_ATAPI_DEVICE)) && deviceResponded) {

            //
            // This hideous hack is to deal with ESDI devices that return
            // garbage geometry in the IDENTIFY data.
            // This is ONLY for the crashdump environment as
            // these are ESDI devices.
            //

            if (deviceExtension->IdentifyData[i].SectorsPerTrack ==
                    0x35 &&
                deviceExtension->IdentifyData[i].NumberOfHeads ==
                    0x07) {

                DebugPrint((1,
                           "FindDevices: Found nasty Compaq ESDI!\n"));

                //
                // Change these values to something reasonable.
                //

                deviceExtension->IdentifyData[i].SectorsPerTrack =
                    0x34;
                deviceExtension->IdentifyData[i].NumberOfHeads =
                    0x0E;
            }

            if (deviceExtension->IdentifyData[i].SectorsPerTrack ==
                    0x35 &&
                deviceExtension->IdentifyData[i].NumberOfHeads ==
                    0x0F) {

                DebugPrint((1,
                           "FindDevices: Found nasty Compaq ESDI!\n"));

                //
                // Change these values to something reasonable.
                //

                deviceExtension->IdentifyData[i].SectorsPerTrack =
                    0x34;
                deviceExtension->IdentifyData[i].NumberOfHeads =
                    0x0F;
            }


            if (deviceExtension->IdentifyData[i].SectorsPerTrack ==
                    0x36 &&
                deviceExtension->IdentifyData[i].NumberOfHeads ==
                    0x07) {

                DebugPrint((1,
                           "FindDevices: Found nasty UltraStor ESDI!\n"));

                //
                // Change these values to something reasonable.
                //

                deviceExtension->IdentifyData[i].SectorsPerTrack =
                    0x3F;
                deviceExtension->IdentifyData[i].NumberOfHeads =
                    0x10;
                skipSetParameters = TRUE;
            }


            if (!skipSetParameters) {

                //
                // Select the device.
                //

                ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                       (UCHAR)((i << 4) | 0xA0));

                WaitOnBusy(baseIoAddress1,statusByte);

                if (statusByte & IDE_STATUS_ERROR) {

                    //
                    // Reset the device.
                    //

                    DebugPrint((2,
                                "FindDevices: Resetting controller before SetDriveParameters.\n"));

                    ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl,IDE_DC_RESET_CONTROLLER | IDE_DC_DISABLE_INTERRUPTS);
                    ScsiPortStallExecution(500 * 1000);
                    ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl, IDE_DC_DISABLE_INTERRUPTS);
                    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                           (UCHAR)((i << 4) | 0xA0));

                    do {

                        //
                        // Wait for Busy to drop.
                        //

                        ScsiPortStallExecution(100);
                        GetStatus(baseIoAddress1, statusByte);

                    } while ((statusByte & IDE_STATUS_BUSY) && waitCount--);
                }

                WaitOnBusy(baseIoAddress1,statusByte);
                DebugPrint((2,
                            "FindDevices: Status before SetDriveParameters: (%x) (%x)\n",
                            statusByte,
                            ScsiPortReadPortUchar(&baseIoAddress1->DriveSelect)));

                //
                // Use the IDENTIFY data to set drive parameters.
                //

                if (!SetDriveParameters(HwDeviceExtension,i,Channel)) {

                    DebugPrint((0,
                               "AtapHwInitialize: Set drive parameters for device %d failed\n",
                               i));

                    //
                    // Don't use this device as writes could cause corruption.
                    //

                    deviceExtension->DeviceFlags[i + Channel] = 0;
                    continue;

                }
                if (deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] & DFLAGS_REMOVABLE_DRIVE) {

                    //
                    // Pick up ALL IDE removable drives that conform to Yosemite V0.2...
                    //

                    AtapiOnly = FALSE;
                }


                //
                // Indicate that a device was found.
                //

                if (!AtapiOnly) {
                    deviceResponded = TRUE;
                }
            }
        }
    }

    //
    // Make sure master device is selected on exit.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect, 0xA0);

    //
    // Reset the controller. This is a feeble attempt to leave the ESDI
    // controllers in a state that ATDISK driver will recognize them.
    // The problem in ATDISK has to do with timings as it is not reproducible
    // in debug. The reset should restore the controller to its poweron state
    // and give the system enough time to settle.
    //

    if (!deviceResponded) {

        ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl,IDE_DC_RESET_CONTROLLER | IDE_DC_DISABLE_INTERRUPTS);
        ScsiPortStallExecution(50 * 1000);
        ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl,IDE_DC_REENABLE_CONTROLLER);
    }

    // Turn device interrupt back on
    for (deviceNumber = 0; deviceNumber < 2; deviceNumber++) {
        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR)((deviceNumber << 4) | 0xA0));
        // Clear any pending interrupts
        GetStatus(baseIoAddress1, statusByte);
        ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl, IDE_DC_REENABLE_CONTROLLER);
    }

    DebugPrintTickCount();

    return deviceResponded;

} // end FindDevices()


ULONG
AtapiParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    )

/*++

Routine Description:

    This routine will parse the string for a match on the keyword, then
    calculate the value for the keyword and return it to the caller.

Arguments:

    String - The ASCII string to parse.
    KeyWord - The keyword for the value desired.

Return Values:

    Zero if value not found
    Value converted from ASCII to binary.

--*/

{
    PCHAR cptr;
    PCHAR kptr;
    ULONG value;
    ULONG stringLength = 0;
    ULONG keyWordLength = 0;
    ULONG index;

    if (!String) {
        return 0;
    }
    if (!KeyWord) {
        return 0;
    }

    //
    // Calculate the string length and lower case all characters.
    //

    cptr = String;
    while (*cptr) {
        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        stringLength++;
    }

    //
    // Calculate the keyword length and lower case all characters.
    //

    cptr = KeyWord;
    while (*cptr) {

        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        keyWordLength++;
    }

    if (keyWordLength > stringLength) {

        //
        // Can't possibly have a match.
        //

        return 0;
    }

    //
    // Now setup and start the compare.
    //

    cptr = String;

ContinueSearch:

    //
    // The input string may start with white space.  Skip it.
    //

    while (*cptr == ' ' || *cptr == '\t') {
        cptr++;
    }

    if (*cptr == '\0') {

        //
        // end of string.
        //

        return 0;
    }

    kptr = KeyWord;
    while (*cptr++ == *kptr++) {

        if (*(cptr - 1) == '\0') {

            //
            // end of string
            //

            return 0;
        }
    }

    if (*(kptr - 1) == '\0') {

        //
        // May have a match backup and check for blank or equals.
        //

        cptr--;
        while (*cptr == ' ' || *cptr == '\t') {
            cptr++;
        }

        //
        // Found a match.  Make sure there is an equals.
        //

        if (*cptr != '=') {

            //
            // Not a match so move to the next semicolon.
            //

            while (*cptr) {
                if (*cptr++ == ';') {
                    goto ContinueSearch;
                }
            }
            return 0;
        }

        //
        // Skip the equals sign.
        //

        cptr++;

        //
        // Skip white space.
        //

        while ((*cptr == ' ') || (*cptr == '\t')) {
            cptr++;
        }

        if (*cptr == '\0') {

            //
            // Early end of string, return not found
            //

            return 0;
        }

        if (*cptr == ';') {

            //
            // This isn't it either.
            //

            cptr++;
            goto ContinueSearch;
        }

        value = 0;
        if ((*cptr == '0') && (*(cptr + 1) == 'x')) {

            //
            // Value is in Hex.  Skip the "0x"
            //

            cptr += 2;
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                     break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (16 * value) + (*(cptr + index) - '0');
                } else {
                    if ((*(cptr + index) >= 'a') && (*(cptr + index) <= 'f')) {
                        value = (16 * value) + (*(cptr + index) - 'a' + 10);
                    } else {

                        //
                        // Syntax error, return not found.
                        //
                        return 0;
                    }
                }
            }
        } else {

            //
            // Value is in Decimal.
            //

            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                     break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (10 * value) + (*(cptr + index) - '0');
                } else {

                    //
                    // Syntax error return not found.
                    //
                    return 0;
                }
            }
        }

        return value;
    } else {

        //
        // Not a match check for ';' to continue search.
        //

        while (*cptr) {
            if (*cptr++ == ';') {
                goto ContinueSearch;
            }
        }

        return 0;
    }
}



BOOLEAN
AtapiAllocateIoBase (
    IN PVOID HwDeviceExtension,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN OUT PFIND_STATE FindState,
    OUT PIDE_REGISTERS_1 CmdLogicalBasePort[2],
    OUT PIDE_REGISTERS_2 CtrlLogicalBasePort[2],
    OUT PIDE_BUS_MASTER_REGISTERS BmLogicalBasePort[2],
    OUT ULONG *NumIdeChannel,
    OUT PBOOLEAN PreConfig
)
/*++

Routine Description:

    Return ide controller io addresses for device detection

    This function populate these PORT_CONFIGURATION_INFORMATION
    entries

        1st ACCESS_RANGE - first channel command block register base
        2nd ACCESS_RANGE - first channel control block register base
        3rd ACCESS_RANGE - second channel command block register base
        4th ACCESS_RANGE - second channel control block register base
        5th ACCESS_RANGE - first channel bus master register base
        6th ACCESS_RANGE - second channel bus master register base

        InterruptMode           - first channel interrupt mode
        BusInterruptLevel       - first channel interrupt level
        InterruptMode2          - second channel interrupt mode
        BusInterruptLevel2      - second channel interrupt level
        AdapterInterfaceType
        AtdiskPrimaryClaimed
        AtdiskSecondaryClaimed


Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    ArgumentString      - registry user arugment
    ConfigInfo          = Scsi Port Config. Structure
    FindState           - Keep track of what addresses has been returned
    CmdLogicalBasePort  - command block register logical base address
    CtrlLogicalBasePort - control block register logical base address
    BmLogicalBasePort   - bus master register logical base address
    NumIdeChannel       - number of IDE channel base address returned
    PreConfig           - the reutrned address is user configured

Return Value:

    TRUE  - io address is returned.
    FASLE - no more io address to return.


--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;

    ULONG cmdBasePort[2]                 = {0, 0};
    ULONG ctrlBasePort[2]                = {0, 0};
    ULONG bmBasePort[2]                  = {0, 0};
    BOOLEAN getDeviceBaseFailed;


    CmdLogicalBasePort[0]   = 0;
    CmdLogicalBasePort[1]   = 0;
    CtrlLogicalBasePort[0]  = 0;
    CtrlLogicalBasePort[1]  = 0;
    BmLogicalBasePort[0]    = 0;
    BmLogicalBasePort[1]    = 0;
    *PreConfig              = FALSE;

    //
    // check for pre-config controller (pcmcia)
    //
    cmdBasePort[0] = ScsiPortConvertPhysicalAddressToUlong((*ConfigInfo->AccessRanges)[0].RangeStart);
    ctrlBasePort[0] = ScsiPortConvertPhysicalAddressToUlong((*ConfigInfo->AccessRanges)[1].RangeStart);
    if (cmdBasePort[0] != 0) {
        *PreConfig      = TRUE;
        *NumIdeChannel  = 1;

        if (!ctrlBasePort[0]) {
            //
            // The pre-config init is really made for pcmcia ata disk
            // When we get pre-config data, both io access ranges are lumped together
            // the command registers are mapped to the first 7 address locations, and
            // the control registers are mapped to the 0xE th location
            //
            ctrlBasePort[0] = cmdBasePort[0] + 0xe;
        }

        DebugPrint ((2, "AtapiAllocateIoBase: found pre-config pcmcia controller\n"));
    }

    //
    // check for user defined controller (made for IBM Caroline ppc)
    //
    if ((cmdBasePort[0] == 0) && ArgumentString) {

        ULONG irq;

        irq            = AtapiParseArgumentString(ArgumentString, "Interrupt");
        cmdBasePort[0] = AtapiParseArgumentString(ArgumentString, "BaseAddress");
        if (irq && cmdBasePort[0]) {

            *NumIdeChannel = 1;

            // the control register offset is implied!!
            ctrlBasePort[0] = cmdBasePort[0] + 0x206;

            ConfigInfo->InterruptMode = Latched;
            ConfigInfo->BusInterruptLevel = irq;

            DebugPrint ((2, "AtapiAllocateIoBase: found user config controller\n"));
        }
    }

    //
    // PCI controller
    //
    if (cmdBasePort[0] == 0 &&
        (ConfigInfo->AdapterInterfaceType == Isa)) {

        PCI_SLOT_NUMBER     pciSlot;
        PUCHAR              vendorStrPtr;
        PUCHAR              deviceStrPtr;
        UCHAR               vendorString[5];
        UCHAR               deviceString[5];

        ULONG               pciBusNumber;
        ULONG               slotNumber;
        ULONG               logicalDeviceNumber;
        ULONG               ideChannel;
        PCI_COMMON_CONFIG   pciData;
        ULONG               cIndex;
        UCHAR               bmStatus;
        BOOLEAN             foundController;

        pciBusNumber        = FindState->BusNumber;
        slotNumber          = FindState->SlotNumber;
        logicalDeviceNumber = FindState->LogicalDeviceNumber;
        ideChannel          = FindState->IdeChannel;
        foundController     = FALSE;
        *NumIdeChannel      = 1;

        for (;pciBusNumber < 256 && !(cmdBasePort[0]); pciBusNumber++, slotNumber=logicalDeviceNumber=0) {
            pciSlot.u.AsULONG = 0;

            for (;slotNumber < PCI_MAX_DEVICES && !(cmdBasePort[0]); slotNumber++, logicalDeviceNumber=0) {
                pciSlot.u.bits.DeviceNumber = slotNumber;

                for (;logicalDeviceNumber < PCI_MAX_FUNCTION && !(cmdBasePort[0]); logicalDeviceNumber++, ideChannel=0) {

                    pciSlot.u.bits.FunctionNumber = logicalDeviceNumber;

                    for (;ideChannel < MAX_CHANNEL && !(cmdBasePort[0]); ideChannel++) {

                        if (!GetPciBusData(HwDeviceExtension,
                                                pciBusNumber,
                                                pciSlot,
                                                &pciData,
                                                offsetof (PCI_COMMON_CONFIG, DeviceSpecific))) {
                            break;
                        }

                        if (pciData.VendorID == PCI_INVALID_VENDORID) {
                            break;
                        }

                        //
                        // Translate hex ids to strings.
                        //
                        vendorStrPtr = vendorString;
                        deviceStrPtr = deviceString;
                        AtapiHexToString(pciData.VendorID, &vendorStrPtr);
                        AtapiHexToString(pciData.DeviceID, &deviceStrPtr);

                        DebugPrint((2,
                                   "AtapiAllocateIoBase: Bus %x Slot %x Function %x Vendor %s Product %s\n",
                                   pciBusNumber,
                                   slotNumber,
                                   logicalDeviceNumber,
                                   vendorString,
                                   deviceString));

                        //
                        // Search for controller we know about
                        //
                        ConfigInfo->AdapterInterfaceType = Isa;
                        foundController = FALSE;
                        *NumIdeChannel = 1;
                        for (cIndex = 0; cIndex < NUMBER_OF_PCI_CONTROLLER; cIndex++) {

                            if ((!AtapiStringCmp(vendorString,
                                        FindState->ControllerParameters[cIndex].VendorId,
                                        FindState->ControllerParameters[cIndex].VendorIdLength) &&
                                 !AtapiStringCmp(deviceString,
                                        FindState->ControllerParameters[cIndex].DeviceId,
                                        FindState->ControllerParameters[cIndex].DeviceIdLength))) {

                                foundController = TRUE;
                                deviceExtension->BMTimingControl = FindState->ControllerParameters[cIndex].TimingControl;
                                deviceExtension->IsChannelEnabled = FindState->ControllerParameters[cIndex].IsChannelEnabled;

                                if (FindState->ControllerParameters[cIndex].SingleFIFO) {
                                    DebugPrint ((0, "AtapiAllocateIoBase: hardcoded single FIFO pci controller\n"));
                                    *NumIdeChannel = 2;
                                }
                                break;
                            }
                        }

                        //
                        // Look for generic IDE controller
                        //
                        if (cIndex >= NUMBER_OF_PCI_CONTROLLER) {
                           if (pciData.BaseClass == 0x1) { // Mass Storage Device
                               if (pciData.SubClass == 0x1) { // IDE Controller

                                    DebugPrint ((0, "AtapiAllocateIoBase: found an unknown pci ide controller\n"));
                                    deviceExtension->BMTimingControl = NULL;
                                    deviceExtension->IsChannelEnabled = ChannelIsAlwaysEnabled;
                                    foundController = TRUE;
                                }
                            }
                        }

                        if (foundController) {

                            DebugPrint ((2, "AtapiAllocateIoBase: found pci ide controller 0x%4x 0x%4x\n", pciData.VendorID, pciData.DeviceID));

                            GetPciBusData(HwDeviceExtension,
                                          pciBusNumber,
                                          pciSlot,
                                          &pciData,
                                          sizeof (PCI_COMMON_CONFIG));

                            //
                            // Record pci device location
                            //
                            deviceExtension->PciBusNumber    = pciBusNumber;
                            deviceExtension->PciDeviceNumber = slotNumber;
                            deviceExtension->PciLogDevNumber = logicalDeviceNumber;

#if defined (DBG)
                            {
                                ULONG i, j;

                                DebugPrint ((2, "AtapiAllocateIoBase: PCI Configuration Data\n"));
                                for (i=0; i<sizeof(PCI_COMMON_CONFIG); i+=16) {
                                    DebugPrint ((2, "AtapiAllocateIoBase: "));
                                    for (j=0; j<16; j++) {
                                        if ((i + j) < sizeof(PCI_COMMON_CONFIG)) {
                                            DebugPrint ((2, "%02x ", ((PUCHAR)&pciData)[i + j]));
                                        } else {
                                            break;
                                        }
                                    }
                                    DebugPrint ((2, "\n"));
                                }
                            }
#endif //DBG

                            if (!AtapiPlaySafe) {
                                //
                                // Try to turn on the bus master bit in PCI space if it is not already on
                                //
                                if ((pciData.Command & PCI_ENABLE_BUS_MASTER) == 0) {

                                    DebugPrint ((0, "ATAPI: Turning on PCI Bus Master bit\n"));

                                    pciData.Command |= PCI_ENABLE_BUS_MASTER;

                                    SetPciBusData (HwDeviceExtension,
                                                   pciBusNumber,
                                                   pciSlot,
                                                   &pciData.Command,
                                                   offsetof (PCI_COMMON_CONFIG, Command),
                                                   sizeof(pciData.Command));

                                    GetPciBusData(HwDeviceExtension,
                                                  pciBusNumber,
                                                  pciSlot,
                                                  &pciData,
                                                  offsetof (PCI_COMMON_CONFIG, DeviceSpecific)
                                                  );

                                    if (pciData.Command & PCI_ENABLE_BUS_MASTER) {
                                        DebugPrint ((0, "ATAPI: If we play safe, we would NOT detect this IDE controller is busmaster capable\n"));
                                    }
                                }
                            }

                            //
                            // Check to see if the controller is bus master capable
                            //
                            bmStatus = 0;
                            if ((pciData.Command & PCI_ENABLE_BUS_MASTER) &&
                                (pciData.ProgIf & 0x80) &&
                                deviceExtension->UseBusMasterController) {

                                PIDE_BUS_MASTER_REGISTERS bmLogicalBasePort;

                                bmBasePort[0] = pciData.u.type0.BaseAddresses[4] & 0xfffffffc;
                                if ((bmBasePort[0] != 0) && (bmBasePort[0] != 0xffffffff)) {

                                    bmLogicalBasePort = (PIDE_BUS_MASTER_REGISTERS) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                            ConfigInfo->AdapterInterfaceType,
                                                            ConfigInfo->SystemIoBusNumber,
                                                            ScsiPortConvertUlongToPhysicalAddress(bmBasePort[0]),
                                                            8,
                                                            TRUE);

                                    if (bmLogicalBasePort) {

                                        // Some controller (ALi M5219) doesn't implement the readonly simplex bit
                                        // We will try to clear it.  If it works, we will assume simplex bit
                                        // is not set
                                        bmStatus = ScsiPortReadPortUchar(&bmLogicalBasePort->Status);
                                        ScsiPortWritePortUchar(&bmLogicalBasePort->Status, (UCHAR) (bmStatus & ~BUSMASTER_DMA_SIMPLEX_BIT));


                                        bmStatus = ScsiPortReadPortUchar(&bmLogicalBasePort->Status);
                                        ScsiPortFreeDeviceBase(HwDeviceExtension, bmLogicalBasePort);

                                        DebugPrint ((2, "AtapiAllocateIoBase: controller is capable of bus mastering\n"));
                                    } else {
                                        bmBasePort[0] = 0;
                                        DebugPrint ((2, "AtapiAllocateIoBase: controller is NOT capable of bus mastering\n"));
                                    }
                                } else {
                                    bmBasePort[0] = 0;
                                    DebugPrint ((2, "AtapiAllocateIoBase: controller is NOT capable of bus mastering\n"));
                                }

                            } else {
                                bmBasePort[0] = 0;
                                DebugPrint ((2, "AtapiAllocateIoBase: controller is NOT capable of bus mastering\n"));
                            }

                            if (bmStatus & BUSMASTER_DMA_SIMPLEX_BIT) {
                                DebugPrint ((0, "AtapiAllocateIoBase: simplex bit is set.  single FIFO pci controller\n"));
                                *NumIdeChannel = 2;
                            }

                            if (*NumIdeChannel == 2) {
                                if (!((*deviceExtension->IsChannelEnabled) (&pciData,
                                                                            0) &&
                                     (*deviceExtension->IsChannelEnabled) (&pciData,
                                                                           0))) {
                                    //
                                    // if we have a single FIFO controller, but one of the channels
                                    // is not turned on.  We don't need to sync. access the both channels
                                    // We can pretend we have a single channel controller
                                    //
                                    *NumIdeChannel = 1;
                                }
                            }

                            //
                            //  figure out what io address the controller is using
                            //  If it is in native mode, get the address out of the PCI
                            //  config space.  If it is in legacy mode, it will be hard
                            //  wired to use standard primary (0x1f0) or secondary
                            //  (0x170) channel addresses
                            //
                            if (ideChannel == 0) {

                                if ((*deviceExtension->IsChannelEnabled) (&pciData,
                                                                          ideChannel)) {

                                    //
                                    // check to see if the controller has a single FIFO for both
                                    // IDE channel
                                    //
                                    if (bmStatus & BUSMASTER_DMA_SIMPLEX_BIT) {
                                        DebugPrint ((0, "AtapiAllocateIoBase: simplex bit is set.  single FIFO pci controller\n"));
                                        *NumIdeChannel = 2;
                                    }

                                    if ((pciData.ProgIf & 0x3) == 0x3 || (pciData.VendorID == 0x105A)) {
                                       
                                        // Native Mode
                                        cmdBasePort[0]  = pciData.u.type0.BaseAddresses[0] & 0xfffffffc;
                                        ctrlBasePort[0] = (pciData.u.type0.BaseAddresses[1] & 0xfffffffc) + 2;

                                        ConfigInfo->InterruptMode = LevelSensitive;
                                        ConfigInfo->BusInterruptVector    =
                                            ConfigInfo->BusInterruptLevel = pciData.u.type0.InterruptLine;
                                        ConfigInfo->AdapterInterfaceType = PCIBus;

                                    } else {
                                        // Legacy Mode
                                        cmdBasePort[0]  = 0x1f0;
                                        ctrlBasePort[0] = 0x1f0 + 0x206;

                                        ConfigInfo->InterruptMode       = Latched;
                                        ConfigInfo->BusInterruptLevel = 14;
                                    }
                                }
                                if (*NumIdeChannel == 2) {

                                    // grab both channels
                                    ideChannel++;

                                    if ((*deviceExtension->IsChannelEnabled) (&pciData,
                                                                              ideChannel)) {

                                        if (bmBasePort[0]) {
                                            bmBasePort[1] = bmBasePort[0] + 8;
                                        }

                                        if ((pciData.ProgIf & 0xc) == 0xc || (pciData.VendorID == 0x105A)) {
                                           
                                            // Native Mode
                                            cmdBasePort[1]  = pciData.u.type0.BaseAddresses[2] & 0xfffffffc;
                                            ctrlBasePort[1] = (pciData.u.type0.BaseAddresses[3] & 0xfffffffc) + 2;
                                        } else {
                                            // Legacy Mode
                                            cmdBasePort[1]  = 0x170;
                                            ctrlBasePort[1] = 0x170 + 0x206;

                                            ConfigInfo->InterruptMode2     = Latched;
                                            ConfigInfo->BusInterruptLevel2 = 15;
                                        }
                                    }
                                }
                            } else if (ideChannel == 1) {

                                if ((*deviceExtension->IsChannelEnabled) (&pciData,
                                                                          ideChannel)) {

                                    if (bmBasePort[0]) {
                                        bmBasePort[0] += 8;
                                    }

                                    if ((pciData.ProgIf & 0xc) == 0xc || (pciData.VendorID == 0x105A)) {

                                       if (pciData.VendorID == 0x105A) {

                                          DebugPrint((0, "Setting Native Mode on Promise controller"));

                                       }

                                        // Native Mode
                                        cmdBasePort[0]  = pciData.u.type0.BaseAddresses[2] & 0xfffffffc;
                                        ctrlBasePort[0] = (pciData.u.type0.BaseAddresses[3] & 0xfffffffc) + 2;

                                        ConfigInfo->InterruptMode = LevelSensitive;
                                        ConfigInfo->BusInterruptVector    =
                                            ConfigInfo->BusInterruptLevel = pciData.u.type0.InterruptLine;
                                        ConfigInfo->AdapterInterfaceType = PCIBus;

                                    } else {
                                        // Legacy Mode
                                        cmdBasePort[0]  = 0x170;
                                        ctrlBasePort[0] = 0x170 + 0x206;

                                        ConfigInfo->InterruptMode       = Latched;
                                        ConfigInfo->BusInterruptLevel   = 15;
                                    }
                                }
                            }
                        } else {
                            ideChannel = MAX_CHANNEL;
                        }
                        if (cmdBasePort[0])
                            break;
                    }
                    if (cmdBasePort[0])
                        break;
                }
                if (cmdBasePort[0])
                    break;
            }
            if (cmdBasePort[0])
                break;
        }
        FindState->BusNumber           = pciBusNumber;
        FindState->SlotNumber          = slotNumber;
        FindState->LogicalDeviceNumber = logicalDeviceNumber;
        FindState->IdeChannel          = ideChannel + 1;
    }

    //
    // look for legacy controller
    //
    if (cmdBasePort[0] == 0) {
        ULONG i;

        for (i = 0; FindState->DefaultIoPort[i]; i++) {
            if (FindState->IoAddressUsed[i] != TRUE) {

                *NumIdeChannel = 1;
                cmdBasePort[0]  = FindState->DefaultIoPort[i];
                ctrlBasePort[0] = FindState->DefaultIoPort[i] + 0x206;
                bmBasePort[0]   = 0;

                ConfigInfo->InterruptMode     = Latched;
                ConfigInfo->BusInterruptLevel = FindState->DefaultInterrupt[i];
                break;
            }
        }
    }

    if (cmdBasePort[0]) {
        ULONG i;

        // Mark io addresses used
        for (i = 0; FindState->DefaultIoPort[i]; i++) {
            if (FindState->DefaultIoPort[i] == cmdBasePort[0]) {
                FindState->IoAddressUsed[i] = TRUE;
            }
            if (FindState->DefaultIoPort[i] == cmdBasePort[1]) {
                FindState->IoAddressUsed[i] = TRUE;
            }
        }


        if (cmdBasePort[0] == 0x1f0) {
            ConfigInfo->AtdiskPrimaryClaimed = TRUE;
            deviceExtension->PrimaryAddress = TRUE;
        } else if (cmdBasePort[0] == 0x170) {
            ConfigInfo->AtdiskSecondaryClaimed = TRUE;
            deviceExtension->PrimaryAddress = FALSE;
        }

        if (cmdBasePort[1] == 0x1f0) {
            ConfigInfo->AtdiskPrimaryClaimed = TRUE;
        } else if (cmdBasePort[1] == 0x170) {
            ConfigInfo->AtdiskSecondaryClaimed = TRUE;
        }

        if (*PreConfig == FALSE) {

            (*ConfigInfo->AccessRanges)[0].RangeStart    = ScsiPortConvertUlongToPhysicalAddress(cmdBasePort[0]);
            (*ConfigInfo->AccessRanges)[0].RangeLength   = 8;
            (*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

            (*ConfigInfo->AccessRanges)[1].RangeStart    = ScsiPortConvertUlongToPhysicalAddress(ctrlBasePort[0]);
            (*ConfigInfo->AccessRanges)[1].RangeLength   = 1;
            (*ConfigInfo->AccessRanges)[1].RangeInMemory = FALSE;

            if (cmdBasePort[1]) {
                (*ConfigInfo->AccessRanges)[2].RangeStart    = ScsiPortConvertUlongToPhysicalAddress(cmdBasePort[1]);
                (*ConfigInfo->AccessRanges)[2].RangeLength   = 8;
                (*ConfigInfo->AccessRanges)[2].RangeInMemory = FALSE;

                (*ConfigInfo->AccessRanges)[3].RangeStart    = ScsiPortConvertUlongToPhysicalAddress(ctrlBasePort[1]);
                (*ConfigInfo->AccessRanges)[3].RangeLength   = 1;
                (*ConfigInfo->AccessRanges)[3].RangeInMemory = FALSE;
            }

            if (bmBasePort[0]) {
                (*ConfigInfo->AccessRanges)[4].RangeStart    = ScsiPortConvertUlongToPhysicalAddress(bmBasePort[0]);
                (*ConfigInfo->AccessRanges)[4].RangeLength   = 8;
                (*ConfigInfo->AccessRanges)[4].RangeInMemory = FALSE;
            }

            if (bmBasePort[1]) {
                (*ConfigInfo->AccessRanges)[5].RangeStart    = ScsiPortConvertUlongToPhysicalAddress(bmBasePort[1]);
                (*ConfigInfo->AccessRanges)[5].RangeLength   = 8;
                (*ConfigInfo->AccessRanges)[5].RangeInMemory = FALSE;
            }
        }


        //
        // map all raw io addresses to logical io addresses
        //
        getDeviceBaseFailed = FALSE;
        CmdLogicalBasePort[0]  = (PIDE_REGISTERS_1) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                        ConfigInfo->AdapterInterfaceType,
                                                        ConfigInfo->SystemIoBusNumber,
                                                        (*ConfigInfo->AccessRanges)[0].RangeStart,
                                                        (*ConfigInfo->AccessRanges)[0].RangeLength,
                                                        (BOOLEAN) !((*ConfigInfo->AccessRanges)[0].RangeInMemory));
        if (!CmdLogicalBasePort[0]) {
            getDeviceBaseFailed = TRUE;
        }

        if (*PreConfig) {
            CtrlLogicalBasePort[0] = (PIDE_REGISTERS_2) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                            ConfigInfo->AdapterInterfaceType,
                                                            ConfigInfo->SystemIoBusNumber,
                                                            ScsiPortConvertUlongToPhysicalAddress(ctrlBasePort[0]),
                                                            1,
                                                            (BOOLEAN) !((*ConfigInfo->AccessRanges)[0].RangeInMemory));

        } else {
            CtrlLogicalBasePort[0] = (PIDE_REGISTERS_2) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                            ConfigInfo->AdapterInterfaceType,
                                                            ConfigInfo->SystemIoBusNumber,
                                                            (*ConfigInfo->AccessRanges)[1].RangeStart,
                                                            (*ConfigInfo->AccessRanges)[1].RangeLength,
                                                            (BOOLEAN) !((*ConfigInfo->AccessRanges)[1].RangeInMemory));
        }
        if (!CtrlLogicalBasePort[0]) {
            getDeviceBaseFailed = TRUE;
        }

        if (cmdBasePort[1]) {
            CmdLogicalBasePort[1]  = (PIDE_REGISTERS_1) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                            ConfigInfo->AdapterInterfaceType,
                                                            ConfigInfo->SystemIoBusNumber,
                                                            (*ConfigInfo->AccessRanges)[2].RangeStart,
                                                            (*ConfigInfo->AccessRanges)[2].RangeLength,
                                                            (BOOLEAN) !((*ConfigInfo->AccessRanges)[2].RangeInMemory));
            if (!CmdLogicalBasePort[0]) {
                getDeviceBaseFailed = TRUE;
            }

            CtrlLogicalBasePort[1] = (PIDE_REGISTERS_2) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                            ConfigInfo->AdapterInterfaceType,
                                                            ConfigInfo->SystemIoBusNumber,
                                                            (*ConfigInfo->AccessRanges)[3].RangeStart,
                                                            (*ConfigInfo->AccessRanges)[3].RangeLength,
                                                            (BOOLEAN) !((*ConfigInfo->AccessRanges)[3].RangeInMemory));
            if (!CtrlLogicalBasePort[0]) {
                getDeviceBaseFailed = TRUE;
            }
        }

        if (bmBasePort[0]) {
            BmLogicalBasePort[0] = (PIDE_BUS_MASTER_REGISTERS) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                                   ConfigInfo->AdapterInterfaceType,
                                                                   ConfigInfo->SystemIoBusNumber,
                                                                   (*ConfigInfo->AccessRanges)[4].RangeStart,
                                                                   (*ConfigInfo->AccessRanges)[4].RangeLength,
                                                                   (BOOLEAN) !((*ConfigInfo->AccessRanges)[4].RangeInMemory));
            if (!BmLogicalBasePort[0]) {
                getDeviceBaseFailed = TRUE;
            }
        }
        if (bmBasePort[1]) {
            BmLogicalBasePort[1] = (PIDE_BUS_MASTER_REGISTERS) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                                   ConfigInfo->AdapterInterfaceType,
                                                                   ConfigInfo->SystemIoBusNumber,
                                                                   (*ConfigInfo->AccessRanges)[5].RangeStart,
                                                                   (*ConfigInfo->AccessRanges)[5].RangeLength,
                                                                   (BOOLEAN) !((*ConfigInfo->AccessRanges)[5].RangeInMemory));
            if (!BmLogicalBasePort[1]) {
                getDeviceBaseFailed = TRUE;
            }
        }

        if (!getDeviceBaseFailed)
            return TRUE;
    }

    return FALSE;
}


BOOLEAN
AtapiFreeIoBase (
    IN PVOID HwDeviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN OUT PFIND_STATE FindState,
    OUT PIDE_REGISTERS_1 CmdLogicalBasePort[2],
    OUT PIDE_REGISTERS_2 CtrlLogicalBasePort[2],
    OUT PIDE_BUS_MASTER_REGISTERS BmLogicalBasePort[2]
)
/*++

Routine Description:

    free logical io addresses.

    This function is called when no device found on the io addresses

    This function clears these PORT_CONFIGURATION_INFORMATION entries

        AccessRanges
        BusInterruptLevel
        BusInterruptLevel2
        AtdiskPrimaryClaimed
        AtdiskSecondaryClaimed

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    ConfigInfo          = Scsi Port Config. Structure
    FindState           - Keep track of what addresses has been returned
    CmdLogicalBasePort  - command block register logical base address
    CtrlLogicalBasePort - control block register logical base address
    BmLogicalBasePort   - bus master register logical base address

Return Value:

    TRUE  - always

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;

    if (CmdLogicalBasePort[0]) {
        ScsiPortFreeDeviceBase(HwDeviceExtension,
                               CmdLogicalBasePort[0]);
        (*ConfigInfo->AccessRanges)[0].RangeStart = ScsiPortConvertUlongToPhysicalAddress(0);
        CmdLogicalBasePort[0]   = 0;
    }
    if (CmdLogicalBasePort[1]) {
        ScsiPortFreeDeviceBase(HwDeviceExtension,
                               CmdLogicalBasePort[1]);
        (*ConfigInfo->AccessRanges)[1].RangeStart = ScsiPortConvertUlongToPhysicalAddress(0);
        CmdLogicalBasePort[1]   = 0;
    }
    if (CtrlLogicalBasePort[0]) {
        ScsiPortFreeDeviceBase(HwDeviceExtension,
                               CtrlLogicalBasePort[0]);
        (*ConfigInfo->AccessRanges)[2].RangeStart = ScsiPortConvertUlongToPhysicalAddress(0);
        CtrlLogicalBasePort[0]  = 0;
    }
    if (CtrlLogicalBasePort[1]) {
        ScsiPortFreeDeviceBase(HwDeviceExtension,
                               CtrlLogicalBasePort[1]);
        (*ConfigInfo->AccessRanges)[3].RangeStart = ScsiPortConvertUlongToPhysicalAddress(0);
        CtrlLogicalBasePort[1]  = 0;
    }
    if (BmLogicalBasePort[0]) {
        ScsiPortFreeDeviceBase(HwDeviceExtension,
                               BmLogicalBasePort[0]);
        (*ConfigInfo->AccessRanges)[4].RangeStart = ScsiPortConvertUlongToPhysicalAddress(0);
        BmLogicalBasePort[0]    = 0;
    }
    if (BmLogicalBasePort[1]) {
        ScsiPortFreeDeviceBase(HwDeviceExtension,
                               BmLogicalBasePort[1]);
        (*ConfigInfo->AccessRanges)[5].RangeStart = ScsiPortConvertUlongToPhysicalAddress(0);
        BmLogicalBasePort[1]    = 0;
    }

    ConfigInfo->AtdiskPrimaryClaimed    = FALSE;
    ConfigInfo->AtdiskSecondaryClaimed  = FALSE;
    ConfigInfo->BusInterruptLevel       = 0;
    ConfigInfo->BusInterruptLevel2      = 0;
    deviceExtension->PrimaryAddress     = FALSE;
    deviceExtension->BMTimingControl    = NULL;

    return TRUE;
}



BOOLEAN
AtapiAllocatePRDT(
    IN OUT PVOID HwDeviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )
/*++

Routine Description:

    allocate scatter/gather list for PCI IDE controller call
    Physical Region Descriptor Table (PRDT)

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    ConfigInfo          = Scsi Port Config. Structure

Return Value:

    TRUE  - if successful
    FASLE - if failed


--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG                bytesMapped;
    ULONG                totalBytesMapped;
    PUCHAR               buffer;
    PHYSICAL_ADDRESS     physAddr;
    ULONG                uncachedExtensionSize;
    INTERFACE_TYPE       oldAdapterInterfaceType;

    ConfigInfo->ScatterGather = TRUE;
    ConfigInfo->Master = TRUE;
    ConfigInfo->Dma32BitAddresses = TRUE;
    ConfigInfo->DmaWidth = Width16Bits;

    //
    // word align
    //
    ConfigInfo->AlignmentMask = 1;

    //
    // PRDT cannot cross a page boundary, so number of physical breaks
    // are limited by page size
    //
    ConfigInfo->NumberOfPhysicalBreaks = PAGE_SIZE / sizeof(PHYSICAL_REGION_DESCRIPTOR);

    //
    // MAX_TRANSFER_SIZE_PER_SRB can spread over
    // (MAX_TRANSFER_SIZE_PER_SRB / PAGE_SIZE) + 2 pages
    // Each page requires 8 bytes in the bus master descriptor table
    // To guarantee we will have a buffer that is big enough and does not
    // cross a page boundary, we will allocate twice of what we need.
    // Half of that will always be big enough and will not cross
    // any page boundary
    //
    uncachedExtensionSize = (MAX_TRANSFER_SIZE_PER_SRB / PAGE_SIZE) + 2;
    uncachedExtensionSize *= sizeof (PHYSICAL_REGION_DESCRIPTOR);
    uncachedExtensionSize *= 2;

    //
    // ScsiPortGetUncachedExtension() will allocate Adapter object,
    // change the AdapterInterfaceType to PCI temporarily so that
    // we don't inherit ISA DMA limitation.
    // We can't keep the AdapterInterfaceType to PCI because the
    // irq resources we are asking for are ISA resources
    //
    oldAdapterInterfaceType = ConfigInfo->AdapterInterfaceType;
    ConfigInfo->AdapterInterfaceType = PCIBus;

    buffer = ScsiPortGetUncachedExtension(HwDeviceExtension,
                                          ConfigInfo,
                                          uncachedExtensionSize);

    ConfigInfo->AdapterInterfaceType = oldAdapterInterfaceType;

    if (buffer) {

        deviceExtension->DataBufferDescriptionTableSize = 0;
        totalBytesMapped = 0;
        while (totalBytesMapped < uncachedExtensionSize) {
            physAddr = ScsiPortGetPhysicalAddress(HwDeviceExtension,
                                                  NULL,
                                                  buffer,
                                                  &bytesMapped);
            if (bytesMapped == 0) {
                break;
            }

            //
            // Find the biggest chuck of physically contiguous memory
            //
            totalBytesMapped += bytesMapped;
            while (bytesMapped) {
                ULONG chunkSize;

                chunkSize = PAGE_SIZE - (ScsiPortConvertPhysicalAddressToUlong(physAddr) & (PAGE_SIZE-1));
                if (chunkSize > bytesMapped)
                    chunkSize = bytesMapped;

                if (chunkSize > deviceExtension->DataBufferDescriptionTableSize) {
                    deviceExtension->DataBufferDescriptionTableSize = chunkSize;
                    deviceExtension->DataBufferDescriptionTablePtr = (PPHYSICAL_REGION_DESCRIPTOR) buffer;
                    deviceExtension->DataBufferDescriptionTablePhysAddr = physAddr;
                }
                buffer      += chunkSize;
                physAddr     = ScsiPortConvertUlongToPhysicalAddress
                                   (ScsiPortConvertPhysicalAddressToUlong(physAddr) + chunkSize);
                bytesMapped -= chunkSize;
            }
        }
        // Did we get at least the minimal amount (half of what we ask for)?
        if (deviceExtension->DataBufferDescriptionTableSize < (uncachedExtensionSize / 2)) {
            buffer = NULL;
        }
    }

    if (buffer) {
        return TRUE;
    } else {
        DebugPrint ((0, "atapi: unable to get buffer for physical descriptor table!\n"));
        ConfigInfo->ScatterGather = FALSE;
        ConfigInfo->Master = FALSE;
        ConfigInfo->Dma32BitAddresses = FALSE;
        return FALSE;
    }
}


ULONG
AtapiFindController(
    IN PVOID HwDeviceExtension,
    IN PFIND_STATE FindState,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
/*++

Routine Description:

    This function is called by the OS-specific port driver after
    the necessary storage has been allocated, to gather information
    about the adapter's configuration.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Context - Address of findstate
    ArgumentString - Used to determine whether driver is client of ntldr or crash dump utility.
    ConfigInfo - Configuration information structure describing HBA
    Again - Indicates search for adapters to continue

Return Value:

    ULONG

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG                i,j;
    ULONG                retryCount;
    PCI_SLOT_NUMBER      slotData;
    PPCI_COMMON_CONFIG   pciData;
    ULONG                pciBuffer;
    BOOLEAN              atapiOnly;
    UCHAR                statusByte;
    ULONG                ideChannel;
    BOOLEAN              foundDevice0 = FALSE;
    BOOLEAN              foundDevice1 = FALSE;

    PIDE_REGISTERS_1            cmdLogicalBasePort[2];
    PIDE_REGISTERS_2            ctrlLogicalBasePort[2];
    PIDE_BUS_MASTER_REGISTERS   bmLogicalBasePort[2];
    ULONG                       numIdeChannel;
    BOOLEAN                     preConfig = FALSE;
    PCHAR                       userArgumentString;


    if (!deviceExtension) {
        return SP_RETURN_ERROR;
    }

    //
    // set the dma detection level
    //
    SetBusMasterDetectionLevel (HwDeviceExtension, ArgumentString);

    *Again = TRUE;
    userArgumentString = ArgumentString;
    while (AtapiAllocateIoBase (HwDeviceExtension,
                                userArgumentString,
                                ConfigInfo,
                                FindState,
                                cmdLogicalBasePort,
                                ctrlLogicalBasePort,
                                bmLogicalBasePort,
                                &numIdeChannel,
                                &preConfig)) {

        // only use user argument string once
        userArgumentString = NULL;

        ConfigInfo->NumberOfBuses = 1;
        ConfigInfo->MaximumNumberOfTargets = (UCHAR) (2 * numIdeChannel);
        deviceExtension->NumberChannels = numIdeChannel;

        for (i = 0; i < 4; i++) {
            deviceExtension->DeviceFlags[i] &= ~(DFLAGS_ATAPI_DEVICE | DFLAGS_DEVICE_PRESENT | DFLAGS_TAPE_DEVICE);
        }

        for (ideChannel = 0; ideChannel < numIdeChannel; ideChannel++) {

            retryCount = 4;

    retryIdentifier:

            //
            // Select master.
            //

            ScsiPortWritePortUchar(&cmdLogicalBasePort[ideChannel]->DriveSelect, 0xA0);

            //
            // Check if card at this address.
            //

            ScsiPortWritePortUchar(&cmdLogicalBasePort[ideChannel]->CylinderLow, 0xAA);

            //
            // Check if indentifier can be read back.
            //

            if ((statusByte = ScsiPortReadPortUchar(&cmdLogicalBasePort[ideChannel]->CylinderLow)) != 0xAA) {

                DebugPrint((2,
                            "AtapiFindController: Identifier read back from Master (%x)\n",
                            statusByte));

                statusByte = ScsiPortReadPortUchar(&cmdLogicalBasePort[ideChannel]->Command);

                if (statusByte & IDE_STATUS_BUSY) {

                    i = 0;

                    //
                    // Could be the TEAC in a thinkpad. Their dos driver puts it in a sleep-mode that
                    // warm boots don't clear.
                    //

                    do {
                        ScsiPortStallExecution(1000);
                        statusByte = ScsiPortReadPortUchar(&cmdLogicalBasePort[ideChannel]->Command);
                        DebugPrint((3,
                                    "AtapiFindController: First access to status %x\n",
                                    statusByte));
                    } while ((statusByte & IDE_STATUS_BUSY) && ++i < 10);

                    if (retryCount-- && (!(statusByte & IDE_STATUS_BUSY))) {
                        goto retryIdentifier;
                    }
                }

                //
                // Select slave.
                //

                ScsiPortWritePortUchar(&cmdLogicalBasePort[ideChannel]->DriveSelect, 0xB0);

                //
                // See if slave is present.
                //

                ScsiPortWritePortUchar(&cmdLogicalBasePort[ideChannel]->CylinderLow, 0xAA);

                if ((statusByte = ScsiPortReadPortUchar(&cmdLogicalBasePort[ideChannel]->CylinderLow)) != 0xAA) {

                    DebugPrint((2,
                                "AtapiFindController: Identifier read back from Slave (%x)\n",
                                statusByte));

                    //
                    //
                    // No controller at this base address.
                    //

                    continue;
                }
            }

            //
            // Record base IO address.
            //

            deviceExtension->BaseIoAddress1[ideChannel] = cmdLogicalBasePort[ideChannel];
            deviceExtension->BaseIoAddress2[ideChannel] = ctrlLogicalBasePort[ideChannel];
            deviceExtension->BusMasterPortBase[ideChannel] = bmLogicalBasePort[ideChannel];
            if (bmLogicalBasePort[ideChannel]) {
                deviceExtension->ControllerFlags |= CFLAGS_BUS_MASTERING;
            } else {
                deviceExtension->ControllerFlags &= ~CFLAGS_BUS_MASTERING;
            }

            DebugPrint ((2, "atapi: command register logical base port: 0x%x\n", deviceExtension->BaseIoAddress1[ideChannel]));
            DebugPrint ((2, "atapi: control register logical base port: 0x%x\n", deviceExtension->BaseIoAddress2[ideChannel]));
            DebugPrint ((2, "atapi: busmaster register logical base port: 0x%x\n", deviceExtension->BusMasterPortBase[ideChannel]));

            //
            // Indicate maximum transfer length is 64k.
            //
            ConfigInfo->MaximumTransferLength = MAX_TRANSFER_SIZE_PER_SRB;

            DebugPrint((1,
                       "AtapiFindController: Found IDE at %x\n",
                       deviceExtension->BaseIoAddress1[ideChannel]));


            //
            // For Daytona, the atdisk driver gets the first shot at the
            // primary and secondary controllers.
            //

            if (preConfig == FALSE) {

                if (ConfigInfo->AtdiskPrimaryClaimed || ConfigInfo->AtdiskSecondaryClaimed) {

                    //
                    // Determine whether this driver is being initialized by the
                    // system or as a crash dump driver.
                    //

                    if (ArgumentString) {

                        if (AtapiParseArgumentString(ArgumentString, "dump") == 1) {
                            DebugPrint((3,
                                       "AtapiFindController: Crash dump\n"));
                            atapiOnly = FALSE;
                            deviceExtension->DriverMustPoll = TRUE;
                        } else {
                            DebugPrint((3,
                                       "AtapiFindController: Atapi Only\n"));
                            atapiOnly = TRUE;
                            deviceExtension->DriverMustPoll = FALSE;
                        }
                    } else {

                        DebugPrint((3,
                                   "AtapiFindController: Atapi Only\n"));
                        atapiOnly = TRUE;
                        deviceExtension->DriverMustPoll = FALSE;
                    }

                } else {
                    atapiOnly = FALSE;
                }

                //
                // If this is a PCI machine, pick up all devices.
                //


                pciData = (PPCI_COMMON_CONFIG)&pciBuffer;

                slotData.u.bits.DeviceNumber = 0;
                slotData.u.bits.FunctionNumber = 0;

                if (ScsiPortGetBusData(deviceExtension,
                                       PCIConfiguration,
                                       0,                  // BusNumber
                                       slotData.u.AsULONG,
                                       pciData,
                                       sizeof(ULONG))) {

                    atapiOnly = FALSE;

                    //
                    // Wait on doing this, until a reliable method
                    // of determining support is found.
                    //

        #if 0
                    deviceExtension->DWordIO = TRUE;
        #endif

                } else {
                    deviceExtension->DWordIO = FALSE;
                }

            } else {

                atapiOnly = FALSE;
                deviceExtension->DriverMustPoll = FALSE;

            }// preConfig check

            //
            // Save the Interrupe Mode for later use
            //
            deviceExtension->InterruptMode = ConfigInfo->InterruptMode;

            //
            // Search for devices on this controller.
            //

            if (FindDevices(HwDeviceExtension, atapiOnly, ideChannel)) {

                if (ideChannel == 0) {

                    foundDevice0 = TRUE;
                } else {

                    foundDevice1 = TRUE;
                }
            }
        }

        if ((!foundDevice0) && (!foundDevice1)) {
            AtapiFreeIoBase (HwDeviceExtension,
                             ConfigInfo,
                             FindState,
                             cmdLogicalBasePort,
                             ctrlLogicalBasePort,
                             bmLogicalBasePort);
        } else {

            ULONG deviceNumber;

            if ((foundDevice0) && (!foundDevice1)) {

                //
                // device on channel 0, but not on channel 1
                //

                ConfigInfo->BusInterruptLevel2 = 0;

            } else if ((!foundDevice0) && (foundDevice1)) {
    
                //
                // device on channel 1, but not on channel 0
                //
                ConfigInfo->BusInterruptLevel = ConfigInfo->BusInterruptLevel2;
                ConfigInfo->BusInterruptLevel2 = 0;
            }

            DeviceSpecificInitialize(HwDeviceExtension);

            for (deviceNumber = 0; deviceNumber < 4; deviceNumber++) {
                if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {
                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_USE_DMA) {
                        ConfigInfo->NeedPhysicalAddresses = TRUE;
                    } else {
                        ConfigInfo->MapBuffers = TRUE;
                    }
                    break;
                }
            }
            if (ConfigInfo->NeedPhysicalAddresses) {
                if (!AtapiAllocatePRDT(HwDeviceExtension, ConfigInfo)) {
                    // Unable to get buffer descriptor table,
                    // go back to PIO mode
                    deviceExtension->ControllerFlags &= ~CFLAGS_BUS_MASTERING;
                    DeviceSpecificInitialize(HwDeviceExtension);
                    ConfigInfo->NeedPhysicalAddresses = FALSE;
                    ConfigInfo->MapBuffers = TRUE;
                }
            }

            if (!AtapiPlaySafe &&
                (deviceExtension->ControllerFlags & CFLAGS_BUS_MASTERING) &&
                (deviceExtension->BMTimingControl)) {
                (*deviceExtension->BMTimingControl) (deviceExtension);
            }

            return(SP_RETURN_FOUND);
        }
    }

    //
    // The entire table has been searched and no adapters have been found.
    // There is no need to call again and the device base can now be freed.
    // Clear the adapter count for the next bus.
    //

    *Again = FALSE;

    return(SP_RETURN_NOT_FOUND);

} // end AtapiFindController()


VOID
DeviceSpecificInitialize(
    IN PVOID HwDeviceExtension
    )
/*++

Routine Description:

    software-initialize devices on the ide bus

    figure out
        if the attached devices are dma capable
        if the attached devices are LBA ready


Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage

Return Value:

    none

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG deviceNumber;
    BOOLEAN pioDevicePresent;
    IDENTIFY_DATA2 * identifyData;
    struct _DEVICE_PARAMETERS * deviceParameters;
    BOOLEAN dmaCapable;
    ULONG pioCycleTime;
    ULONG standardPioCycleTime;
    ULONG dmaCycleTime;
    ULONG standardDmaCycleTime;

    //
    // Figure out who can do DMA and who cannot
    //
    for (deviceNumber = 0; deviceNumber < 4; deviceNumber++) {

        if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {

            //
            // check LBA capabilities
            //
            deviceExtension->DeviceFlags[deviceNumber] &= ~DFLAGS_LBA;

            // Some drives lie about their ability to do LBA
            // we don't want to do LBA unless we have to (>8G drive)
//            if (deviceExtension->IdentifyData[targetId].Capabilities & IDENTIFY_CAPABILITIES_LBA_SUPPORTED) {
//                deviceExtension->DeviceFlags[targetId] |= DFLAGS_LBA;
//            }
            if (deviceExtension->IdentifyData[deviceNumber].UserAddressableSectors > MAX_NUM_CHS_ADDRESSABLE_SECTORS) {
                // some device has a bogus value in the UserAddressableSectors field
                // make sure these 3 fields are max. out as defined in ATA-3 (X3T10 Rev. 6)
                if ((deviceExtension->IdentifyData[deviceNumber].NumberOfCylinders == 16383) &&
                    (deviceExtension->IdentifyData[deviceNumber].NumberOfHeads == 16) &&
                    (deviceExtension->IdentifyData[deviceNumber].SectorsPerTrack == 63)) {
                        deviceExtension->DeviceFlags[deviceNumber] |= DFLAGS_LBA;
                }
            }
            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_LBA) {
                DebugPrint ((1, "atapi: target %d supports LBA\n", deviceNumber));
            }

            //
            // Try to enable DMA
            //
            dmaCapable = FALSE;

            if (deviceExtension->ControllerFlags & CFLAGS_BUS_MASTERING) {
                UCHAR dmaStatus;
                dmaStatus = ScsiPortReadPortUchar (&deviceExtension->BusMasterPortBase[deviceNumber >> 1]->Status);
                if (deviceNumber & 1) {
                    if (dmaStatus & BUSMASTER_DEVICE1_DMA_OK) {
                        DebugPrint ((1, "atapi: target %d busmaster status 0x%x DMA capable bit is set\n", deviceNumber, dmaStatus));
                        dmaCapable = TRUE;
                    }
                } else {
                    if (dmaStatus & BUSMASTER_DEVICE0_DMA_OK) {
                        DebugPrint ((1, "atapi: target %d busmaster status 0x%x DMA capable bit is set\n", deviceNumber, dmaStatus));
                        dmaCapable = TRUE;
                    }
                }
            }

            //
            // figure out the shortest PIO cycle time the deivce supports
            //
            deviceExtension->DeviceParameters[deviceNumber].BestPIOMode           = INVALID_PIO_MODE;
            deviceExtension->DeviceParameters[deviceNumber].BestSingleWordDMAMode = INVALID_SWDMA_MODE;
            deviceExtension->DeviceParameters[deviceNumber].BestMultiWordDMAMode  = INVALID_MWDMA_MODE;
            pioCycleTime = standardPioCycleTime = UNINITIALIZED_CYCLE_TIME;
            deviceExtension->DeviceParameters[deviceNumber].IoReadyEnabled = FALSE;

            if (deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 1)) {
                if (deviceExtension->IdentifyData[deviceNumber].MinimumPIOCycleTimeIORDY) {
                    pioCycleTime = deviceExtension->IdentifyData[deviceNumber].MinimumPIOCycleTimeIORDY;
                }
            }

            if (deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 1)) {
                if (deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes & (1 << 1)) {
                    standardPioCycleTime = PIO_MODE4_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestPIOMode = 4;
                } else if (deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes & (1 << 0)) {
                    standardPioCycleTime = PIO_MODE3_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestPIOMode = 3;
                }
                if (pioCycleTime == UNINITIALIZED_CYCLE_TIME) {
                    pioCycleTime = standardPioCycleTime;
                }

            } else {

                if ((deviceExtension->IdentifyData[deviceNumber].PioCycleTimingMode & 0x00ff) == 2) {
                    standardPioCycleTime = PIO_MODE2_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestPIOMode = 2;
                } else if ((deviceExtension->IdentifyData[deviceNumber].PioCycleTimingMode & 0x00ff) == 1) {
                    standardPioCycleTime = PIO_MODE1_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestPIOMode = 1;
                } else {
                    standardPioCycleTime = PIO_MODE0_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestPIOMode = 0;
                }

                if (pioCycleTime == UNINITIALIZED_CYCLE_TIME) {
                    pioCycleTime = standardPioCycleTime;
                }
            }

            deviceExtension->DeviceParameters[deviceNumber].PioCycleTime = pioCycleTime;
            if (deviceExtension->IdentifyData[deviceNumber].Capabilities & IDENTIFY_CAPABILITIES_IOREADY_SUPPORTED) {
                deviceExtension->DeviceParameters[deviceNumber].IoReadyEnabled = TRUE;
            }

            //
            // figure out the shortest DMA cycle time the device supports
            //
            // check min cycle time
            //
            dmaCycleTime = standardDmaCycleTime = UNINITIALIZED_CYCLE_TIME;
            if (deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 1)) {
                DebugPrint ((1, "atapi: target %d IdentifyData word 64-70 are valid\n", deviceNumber));

                if (deviceExtension->IdentifyData[deviceNumber].MinimumMWXferCycleTime &&
                    deviceExtension->IdentifyData[deviceNumber].RecommendedMWXferCycleTime) {
                    DebugPrint ((1,
                                 "atapi: target %d IdentifyData MinimumMWXferCycleTime = 0x%x\n",
                                 deviceNumber,
                                 deviceExtension->IdentifyData[deviceNumber].MinimumMWXferCycleTime));
                    DebugPrint ((1,
                                 "atapi: target %d IdentifyData RecommendedMWXferCycleTime = 0x%x\n",
                                 deviceNumber,
                                 deviceExtension->IdentifyData[deviceNumber].RecommendedMWXferCycleTime));
                    dmaCycleTime = deviceExtension->IdentifyData[deviceNumber].RecommendedMWXferCycleTime;
                }
            }
            //
            // check mulitword DMA timing
            //
            if (deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport) {
                DebugPrint ((1,
                             "atapi: target %d IdentifyData MultiWordDMASupport = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport));
                DebugPrint ((1,
                             "atapi: target %d IdentifyData MultiWordDMAActive = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].MultiWordDMAActive));

                if (deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport & (1 << 2)) {
                    standardDmaCycleTime = MWDMA_MODE2_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestMultiWordDMAMode = 2;

                } else if (deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport & (1 << 1)) {
                    standardDmaCycleTime = MWDMA_MODE1_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestMultiWordDMAMode = 1;

                } else if (deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport & (1 << 0)) {
                    standardDmaCycleTime = MWDMA_MODE0_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestMultiWordDMAMode = 0;
                }
                if (dmaCycleTime == UNINITIALIZED_CYCLE_TIME) {
                    dmaCycleTime = standardDmaCycleTime;
                }
            }

            //
            // check singleword DMA timing
            //
            if (deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport) {
                DebugPrint ((1,
                             "atapi: target %d IdentifyData SingleWordDMASupport = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport));
                DebugPrint ((1,
                             "atapi: target %d IdentifyData SingleWordDMAActive = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].SingleWordDMAActive));

                if (deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport & (1 << 2)) {
                    standardDmaCycleTime = SWDMA_MODE2_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestSingleWordDMAMode = 2;

                } else if (deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport & (1 << 1)) {
                    standardDmaCycleTime = SWDMA_MODE1_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestSingleWordDMAMode = 1;

                } else if (deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport & (1 << 0)) {
                    standardDmaCycleTime = SWDMA_MODE0_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestSingleWordDMAMode = 0;
                }
                if (dmaCycleTime == UNINITIALIZED_CYCLE_TIME) {
                    dmaCycleTime = standardDmaCycleTime;
                }
            }

            deviceExtension->DeviceParameters[deviceNumber].DmaCycleTime = dmaCycleTime;

//
// Study shows that even dma cycle time may be larger than pio cycle time, dma
// can still give better data throughput
//
//            if (dmaCycleTime > pioCycleTime) {
//                DebugPrint ((0, "atapi: target %d can do PIO (%d) faster than DMA (%d).  Turning off DMA...\n", deviceNumber, pioCycleTime, dmaCycleTime));
//                dmaCapable = FALSE;
//            } else {
//                if (!AtapiPlaySafe) {
//                    if (dmaCapable == FALSE) {
//                        DebugPrint ((0, "atapi: If we play safe, we would NOT detect target %d is DMA capable\n", deviceNumber));
//                    }
//                    dmaCapable = TRUE;
//                }
//            }

            if (((deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 1)) &&
                 (deviceExtension->IdentifyData[deviceNumber].SingleWordDMAActive == 0) &&
                 (deviceExtension->IdentifyData[deviceNumber].MultiWordDMAActive == 0)) 
                 &&
                ((deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 2)) &&
                 (deviceExtension->IdentifyData[deviceNumber].UltraDMAActive == 0))) {
                dmaCapable = FALSE;
            } else {
                if (!AtapiPlaySafe) {
                    if (dmaCapable == FALSE) {
                        DebugPrint ((0, "atapi: If we play safe, we would NOT detect target %d is DMA capable\n", deviceNumber));
                    }
                    dmaCapable = TRUE;
                }
            }

            //
            // Check for bad devices
            //
            if (AtapiDeviceDMACapable (deviceExtension, deviceNumber) == FALSE) {
                dmaCapable = FALSE;
            }

            if ((deviceExtension->ControllerFlags & CFLAGS_BUS_MASTERING) && dmaCapable) {
                deviceExtension->DeviceFlags[deviceNumber] |= DFLAGS_USE_DMA;
            } else {
                deviceExtension->DeviceFlags[deviceNumber] &= ~DFLAGS_USE_DMA;
            }
        }
    }




    //
    // Default everyone to pio if anyone of them cannot do DMA
    // We can remove this if it is ok to mix DMA and PIO devices on the same channel
    //
    // If we are going to allow mixing DMA and PIO, we need to change SCSIPORT
    // to allow setting both NeedPhysicalAddresses and MapBuffers to TRUE in
    // PORT_CONFIGURATION_INFORMATION
    //
    pioDevicePresent = FALSE;
    for (deviceNumber = 0; deviceNumber < 4 && !pioDevicePresent; deviceNumber++) {
        if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {
            if (!(deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_USE_DMA)) {
                pioDevicePresent = TRUE;    // bummer!
            }
        }
    }

    if (pioDevicePresent) {
        for (deviceNumber = 0; deviceNumber < 4; deviceNumber++) {
            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {
                deviceExtension->DeviceFlags[deviceNumber] &= ~DFLAGS_USE_DMA;
            }
        }
    }


    //
    // pick out the ATA or ATAPI r/w command we are going to use
    //
    for (deviceNumber = 0; deviceNumber < 4; deviceNumber++) {
        if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {

            DebugPrint ((0, "ATAPI: Base=0x%x Device %d is going to do ", deviceExtension->BaseIoAddress1[deviceNumber >> 1], deviceNumber));
            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_USE_DMA) {
                DebugPrint ((0, "DMA\n"));
            } else {
                DebugPrint ((0, "PIO\n"));
            }


            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE) {

                deviceExtension->DeviceParameters[deviceNumber].MaxWordPerInterrupt = 256;

            } else {

                if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_USE_DMA) {

                    DebugPrint ((2, "ATAPI: ATA Device (%d) is going to do DMA\n", deviceNumber));
                    deviceExtension->DeviceParameters[deviceNumber].IdeReadCommand = IDE_COMMAND_READ_DMA;
                    deviceExtension->DeviceParameters[deviceNumber].IdeWriteCommand = IDE_COMMAND_WRITE_DMA;
                    deviceExtension->DeviceParameters[deviceNumber].MaxWordPerInterrupt = MAX_TRANSFER_SIZE_PER_SRB / 2;

                } else {

                    if (deviceExtension->MaximumBlockXfer[deviceNumber]) {

                        DebugPrint ((2, "ATAPI: ATA Device (%d) is going to do PIO Multiple\n", deviceNumber));
                        deviceExtension->DeviceParameters[deviceNumber].IdeReadCommand = IDE_COMMAND_READ_MULTIPLE;
                        deviceExtension->DeviceParameters[deviceNumber].IdeWriteCommand = IDE_COMMAND_WRITE_MULTIPLE;
                        deviceExtension->DeviceParameters[deviceNumber].MaxWordPerInterrupt =
                            deviceExtension->MaximumBlockXfer[deviceNumber] * 256;
                    } else {

                        DebugPrint ((2, "ATAPI: ATA Device (%d) is going to do PIO Single\n", deviceNumber));
                        deviceExtension->DeviceParameters[deviceNumber].IdeReadCommand = IDE_COMMAND_READ;
                        deviceExtension->DeviceParameters[deviceNumber].IdeWriteCommand = IDE_COMMAND_WRITE;
                        deviceExtension->DeviceParameters[deviceNumber].MaxWordPerInterrupt = 256;
                    }
                }
            }
        }
    }

}


ULONG
Atapi2Scsi(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN char *DataBuffer,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    Convert atapi cdb and mode sense data to scsi format

Arguments:

    Srb         - SCSI request block
    DataBuffer  - mode sense data
    ByteCount   - mode sense data length

Return Value:

    word adjust

--*/
{
    ULONG bytesAdjust = 0;
    if (Srb->Cdb[0] == ATAPI_MODE_SENSE) {

        PMODE_PARAMETER_HEADER_10 header_10 = (PMODE_PARAMETER_HEADER_10)DataBuffer;
        PMODE_PARAMETER_HEADER header = (PMODE_PARAMETER_HEADER)DataBuffer;

        header->ModeDataLength = header_10->ModeDataLengthLsb;
        header->MediumType = header_10->MediumType;

        //
        // ATAPI Mode Parameter Header doesn't have these fields.
        //

        header->DeviceSpecificParameter = header_10->Reserved[0];
        header->BlockDescriptorLength = header_10->Reserved[1];

        ByteCount -= sizeof(MODE_PARAMETER_HEADER_10);
        if (ByteCount > 0)
            ScsiPortMoveMemory(DataBuffer+sizeof(MODE_PARAMETER_HEADER),
                               DataBuffer+sizeof(MODE_PARAMETER_HEADER_10),
                               ByteCount);

        //
        // Change ATAPI_MODE_SENSE opcode back to SCSIOP_MODE_SENSE
        // so that we don't convert again.
        //

        Srb->Cdb[0] = SCSIOP_MODE_SENSE;

        bytesAdjust = sizeof(MODE_PARAMETER_HEADER_10) -
                      sizeof(MODE_PARAMETER_HEADER);


    }

    //
    // Convert to words.
    //

    return bytesAdjust >> 1;
}


VOID
AtapiCallBack(
    IN PVOID HwDeviceExtension
    )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK  srb = deviceExtension->CurrentSrb;
    PATAPI_REGISTERS_1   baseIoAddress1;
    UCHAR statusByte;

    //
    // If the last command was DSC restrictive, see if it's set. If so, the device is
    // ready for a new request. Otherwise, reset the timer and come back to here later.
    //

    if (srb && (!(deviceExtension->ExpectingInterrupt))) {
#if DBG
        if (!IS_RDP((srb->Cdb[0]))) {
            DebugPrint((1,
                        "AtapiCallBack: Invalid CDB marked as RDP - %x\n",
                        srb->Cdb[0]));
        }
#endif

        baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[srb->TargetId >> 1];
        if (deviceExtension->RDP) {
            GetStatus(baseIoAddress1, statusByte);
            if (statusByte & IDE_STATUS_DSC) {

                ScsiPortNotification(RequestComplete,
                                     deviceExtension,
                                     srb);

                //
                // Clear current SRB.
                //

                deviceExtension->CurrentSrb = NULL;
                deviceExtension->RDP = FALSE;

                //
                // Ask for next request.
                //

                ScsiPortNotification(NextRequest,
                                     deviceExtension,
                                     NULL);


                return;

            } else {

                DebugPrint((3,
                            "AtapiCallBack: Requesting another timer for Op %x\n",
                            deviceExtension->CurrentSrb->Cdb[0]));

                ScsiPortNotification(RequestTimerCall,
                                     HwDeviceExtension,
                                     AtapiCallBack,
                                     1000);
                return;
            }
        }
    }

    DebugPrint((2,
                "AtapiCallBack: Calling ISR directly due to BUSY\n"));
    AtapiInterrupt(HwDeviceExtension);
}


BOOLEAN
AtapiInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This is the interrupt service routine for ATAPI IDE miniport driver.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE if expecting an interrupt.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb              = deviceExtension->CurrentSrb;
    PATAPI_REGISTERS_1 baseIoAddress1;
    PATAPI_REGISTERS_2 baseIoAddress2;
    ULONG wordCount = 0, wordsThisInterrupt = 256;
    ULONG status;
    ULONG i;
    UCHAR statusByte,interruptReason;
    BOOLEAN commandComplete = FALSE;
    BOOLEAN atapiDev = FALSE;
    UCHAR dmaStatus;

    if (srb) {
        // PCI Busmaster IDE Controller spec defines a bit in its status
        // register which indicates pending interrupt.  However,
        // CMD 646 (maybe some other one, too) doesn't always do that if
        // the interrupt is from a atapi device.  (strange, but true!)
        // Since we have to look at the interrupt bit only if we are sharing
        // interrupt, we will do just that
        if (deviceExtension->InterruptMode == LevelSensitive) {
            if (deviceExtension->ControllerFlags & CFLAGS_BUS_MASTERING) {
                dmaStatus = ScsiPortReadPortUchar (&deviceExtension->BusMasterPortBase[srb->TargetId >> 1]->Status);
                if ((dmaStatus & BUSMASTER_INTERRUPT) == 0) {
                    return FALSE;
                }
            }
        }

        baseIoAddress1 =    (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[srb->TargetId >> 1];
        baseIoAddress2 =    (PATAPI_REGISTERS_2)deviceExtension->BaseIoAddress2[srb->TargetId >> 1];
    } else {
        DebugPrint((2,
                    "AtapiInterrupt: CurrentSrb is NULL\n"));
        //
        // We can only support one ATAPI IDE master on Carolina, so find
        // the base address that is non NULL and clear its interrupt before
        // returning.
        //

#ifdef _PPC_

        if ((PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[0] != NULL) {
           baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[0];
        } else {
           baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[1];
        }

        GetBaseStatus(baseIoAddress1, statusByte);
#else

        if (deviceExtension->InterruptMode == LevelSensitive) {
            if (deviceExtension->BaseIoAddress1[0] != NULL) {
               baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[0];
               GetBaseStatus(baseIoAddress1, statusByte);
            }
            if (deviceExtension->BaseIoAddress1[1] != NULL) {
               baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[1];
               GetBaseStatus(baseIoAddress1, statusByte);
            }
        }
#endif
        return FALSE;
    }

    if (!(deviceExtension->ExpectingInterrupt)) {

        DebugPrint((3,
                    "AtapiInterrupt: Unexpected interrupt.\n"));
        return FALSE;
    }

    //
    // Clear interrupt by reading status.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    DebugPrint((3,
                "AtapiInterrupt: Entered with status (%x)\n",
                statusByte));


    if (statusByte & IDE_STATUS_BUSY) {
        if (deviceExtension->DriverMustPoll) {

            //
            // Crashdump is polling and we got caught with busy asserted.
            // Just go away, and we will be polled again shortly.
            //

            DebugPrint((3,
                        "AtapiInterrupt: Hit BUSY while polling during crashdump.\n"));

            return TRUE;
        }

        //
        // Ensure BUSY is non-asserted.
        //

        for (i = 0; i < 10; i++) {

            GetBaseStatus(baseIoAddress1, statusByte);
            if (!(statusByte & IDE_STATUS_BUSY)) {
                break;
            }
            ScsiPortStallExecution(5000);
        }

        if (i == 10) {

            DebugPrint((2,
                        "AtapiInterrupt: BUSY on entry. Status %x, Base IO %x\n",
                        statusByte,
                        baseIoAddress1));

            ScsiPortNotification(RequestTimerCall,
                                 HwDeviceExtension,
                                 AtapiCallBack,
                                 500);
            return TRUE;
        }
    }


    if (deviceExtension->DMAInProgress) {
        deviceExtension->DMAInProgress = FALSE;
        dmaStatus = ScsiPortReadPortUchar (&deviceExtension->BusMasterPortBase[srb->TargetId >> 1]->Status);
        ScsiPortWritePortUchar (&deviceExtension->BusMasterPortBase[srb->TargetId >> 1]->Command,
                                0);  // disable BusMastering
        ScsiPortWritePortUchar (&deviceExtension->BusMasterPortBase[srb->TargetId >> 1]->Status,
                                (UCHAR) (dmaStatus | BUSMASTER_INTERRUPT | BUSMASTER_ERROR));    // clear interrupt/error

        deviceExtension->WordsLeft = 0;

        if ((dmaStatus & (BUSMASTER_INTERRUPT | BUSMASTER_ERROR | BUSMASTER_ACTIVE)) != BUSMASTER_INTERRUPT) { // dma ok?
            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        } else {
            deviceExtension->WordsLeft = 0;
        }

    }

    //
    // Check for error conditions.
    //

    if (statusByte & IDE_STATUS_ERROR) {

        if (srb->Cdb[0] != SCSIOP_REQUEST_SENSE) {

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }
    }

    //
    // check reason for this interrupt.
    //


    if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

        interruptReason = (ScsiPortReadPortUchar(&baseIoAddress1->InterruptReason) & 0x3);
        atapiDev = TRUE;
        wordsThisInterrupt = 256;

    } else {

        if (statusByte & IDE_STATUS_DRQ) {

            if (deviceExtension->MaximumBlockXfer[srb->TargetId]) {
                wordsThisInterrupt = 256 * deviceExtension->MaximumBlockXfer[srb->TargetId];

            }

            if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

                interruptReason =  0x2;

            } else if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {
                interruptReason = 0x0;

            } else {
                status = SRB_STATUS_ERROR;
                goto CompleteRequest;
            }

        } else if (statusByte & IDE_STATUS_BUSY) {

            return FALSE;

        } else {

            if (deviceExtension->WordsLeft) {

                ULONG k;

                //
                // Funky behaviour seen with PCI IDE (not all, just one).
                // The ISR hits with DRQ low, but comes up later.
                //

                for (k = 0; k < 5000; k++) {
                    GetStatus(baseIoAddress1,statusByte);
                    if (!(statusByte & IDE_STATUS_DRQ)) {
                        ScsiPortStallExecution(100);
                    } else {
                        break;
                    }
                }

                if (k == 5000) {

                    //
                    // reset the controller.
                    //

                    DebugPrint((1,
                                "AtapiInterrupt: Resetting due to DRQ not up. Status %x, Base IO %x\n",
                                statusByte,
                                baseIoAddress1));

                    AtapiResetController(HwDeviceExtension,srb->PathId);
                    return TRUE;
                } else {

                    interruptReason = (srb->SrbFlags & SRB_FLAGS_DATA_IN) ? 0x2 : 0x0;
                }

            } else {

                //
                // Command complete - verify, write, or the SMART enable/disable.
                //
                // Also get_media_status

                interruptReason = 0x3;
            }
        }
    }

    if (interruptReason == 0x1 && (statusByte & IDE_STATUS_DRQ)) {

        //
        // Write the packet.
        //

        DebugPrint((2,
                    "AtapiInterrupt: Writing Atapi packet.\n"));

        //
        // Send CDB to device.
        //

        WriteBuffer(baseIoAddress1,
                    (PUSHORT)srb->Cdb,
                    6);

        switch (srb->Cdb[0]) {

            case SCSIOP_RECEIVE:
            case SCSIOP_SEND:
            case SCSIOP_READ:
            case SCSIOP_WRITE:
                if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_USE_DMA) {
                    EnableBusMastering(HwDeviceExtension, srb);
                }
                break;

            default:
                break;
        }

        return TRUE;

    } else if (interruptReason == 0x0 && (statusByte & IDE_STATUS_DRQ)) {

        //
        // Write the data.
        //

        if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

            //
            // Pick up bytes to transfer and convert to words.
            //

            wordCount =
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountLow);

            wordCount |=
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountHigh) << 8;

            //
            // Covert bytes to words.
            //

            wordCount >>= 1;

            if (wordCount != deviceExtension->WordsLeft) {
                DebugPrint((3,
                           "AtapiInterrupt: %d words requested; %d words xferred\n",
                           deviceExtension->WordsLeft,
                           wordCount));
            }

            //
            // Verify this makes sense.
            //

            if (wordCount > deviceExtension->WordsLeft) {
                wordCount = deviceExtension->WordsLeft;
            }

        } else {

            //
            // IDE path. Check if words left is at least 256.
            //

            if (deviceExtension->WordsLeft < wordsThisInterrupt) {

               //
               // Transfer only words requested.
               //

               wordCount = deviceExtension->WordsLeft;

            } else {

               //
               // Transfer next block.
               //

               wordCount = wordsThisInterrupt;
            }
        }

        //
        // Ensure that this is a write command.
        //

        if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {

           DebugPrint((3,
                      "AtapiInterrupt: Write interrupt\n"));

           WaitOnBusy(baseIoAddress1,statusByte);

           if (atapiDev || !deviceExtension->DWordIO) {

               WriteBuffer(baseIoAddress1,
                           deviceExtension->DataBuffer,
                           wordCount);
           } else {

               PIDE_REGISTERS_3 address3 = (PIDE_REGISTERS_3)baseIoAddress1;

               WriteBuffer2(address3,
                           (PULONG)(deviceExtension->DataBuffer),
                           wordCount / 2);
           }
        } else {

            DebugPrint((1,
                        "AtapiInterrupt: Int reason %x, but srb is for a write %x.\n",
                        interruptReason,
                        srb));

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }


        //
        // Advance data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer += wordCount;
        deviceExtension->WordsLeft -= wordCount;

        return TRUE;

    } else if (interruptReason == 0x2 && (statusByte & IDE_STATUS_DRQ)) {


        if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

            //
            // Pick up bytes to transfer and convert to words.
            //

            wordCount =
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountLow);

            wordCount |=
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountHigh) << 8;

            //
            // Covert bytes to words.
            //

            wordCount >>= 1;

            if (wordCount != deviceExtension->WordsLeft) {
                DebugPrint((3,
                           "AtapiInterrupt: %d words requested; %d words xferred\n",
                           deviceExtension->WordsLeft,
                           wordCount));
            }

            //
            // Verify this makes sense.
            //

            if (wordCount > deviceExtension->WordsLeft) {
                wordCount = deviceExtension->WordsLeft;
            }

        } else {

            //
            // Check if words left is at least 256.
            //

            if (deviceExtension->WordsLeft < wordsThisInterrupt) {

               //
               // Transfer only words requested.
               //

               wordCount = deviceExtension->WordsLeft;

            } else {

               //
               // Transfer next block.
               //

               wordCount = wordsThisInterrupt;
            }
        }

        //
        // Ensure that this is a read command.
        //

        if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

           DebugPrint((3,
                      "AtapiInterrupt: Read interrupt\n"));

           WaitOnBusy(baseIoAddress1,statusByte);

           if (atapiDev || !deviceExtension->DWordIO) {
               ReadBuffer(baseIoAddress1,
                         deviceExtension->DataBuffer,
                         wordCount);

           } else {
               PIDE_REGISTERS_3 address3 = (PIDE_REGISTERS_3)baseIoAddress1;

               ReadBuffer2(address3,
                          (PULONG)(deviceExtension->DataBuffer),
                          wordCount / 2);
           }
        } else {

            DebugPrint((1,
                        "AtapiInterrupt: Int reason %x, but srb is for a read %x.\n",
                        interruptReason,
                        srb));

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }

        //
        // Translate ATAPI data back to SCSI data if needed
        //

        if (srb->Cdb[0] == ATAPI_MODE_SENSE &&
            deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

            //
            //convert and adjust the wordCount
            //

            wordCount -= Atapi2Scsi(srb, (char *)deviceExtension->DataBuffer,
                                     wordCount << 1);
        }
        //
        // Advance data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer += wordCount;
        deviceExtension->WordsLeft -= wordCount;

        //
        // Check for read command complete.
        //

        if (deviceExtension->WordsLeft == 0) {

            if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

                //
                // Work around to make many atapi devices return correct sector size
                // of 2048. Also certain devices will have sector count == 0x00, check
                // for that also.
                //

                if ((srb->Cdb[0] == 0x25) &&
                    ((deviceExtension->IdentifyData[srb->TargetId].GeneralConfiguration >> 8) & 0x1f) == 0x05) {

                    deviceExtension->DataBuffer -= wordCount;
                    if (deviceExtension->DataBuffer[0] == 0x00) {

                        *((ULONG *) &(deviceExtension->DataBuffer[0])) = 0xFFFFFF7F;

                    }

                    *((ULONG *) &(deviceExtension->DataBuffer[2])) = 0x00080000;
                    deviceExtension->DataBuffer += wordCount;
                }
            } else {

                //
                // Completion for IDE drives.
                //


                if (deviceExtension->WordsLeft) {

                    status = SRB_STATUS_DATA_OVERRUN;

                } else {

                    status = SRB_STATUS_SUCCESS;

                }

                goto CompleteRequest;

            }
        }

        return TRUE;

    } else if (interruptReason == 0x3  && !(statusByte & IDE_STATUS_DRQ)) {

        //
        // Command complete.
        //

        if (deviceExtension->WordsLeft) {

            status = SRB_STATUS_DATA_OVERRUN;

        } else {

            status = SRB_STATUS_SUCCESS;

        }

CompleteRequest:

        //
        // Check and see if we are processing our secret (mechanism status/request sense) srb
        //
        if (deviceExtension->OriginalSrb) {

            ULONG srbStatus;

            if (srb->Cdb[0] == SCSIOP_MECHANISM_STATUS) {

                if (status == SRB_STATUS_SUCCESS) {
                    // Bingo!!
                    AtapiHwInitializeChanger (HwDeviceExtension,
                                              srb->TargetId,
                                              (PMECHANICAL_STATUS_INFORMATION_HEADER) srb->DataBuffer);

                    // Get ready to issue the original srb
                    srb = deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
                    deviceExtension->OriginalSrb = NULL;

                } else {
                    // failed!  Get the sense key and maybe try again
                    srb = deviceExtension->CurrentSrb = BuildRequestSenseSrb (
                                                          HwDeviceExtension,
                                                          deviceExtension->OriginalSrb->PathId,
                                                          deviceExtension->OriginalSrb->TargetId);
                }

                srbStatus = AtapiSendCommand(HwDeviceExtension, deviceExtension->CurrentSrb);
                if (srbStatus == SRB_STATUS_PENDING) {
                    return TRUE;
                }

            } else { // srb->Cdb[0] == SCSIOP_REQUEST_SENSE)

                PSENSE_DATA senseData = (PSENSE_DATA) srb->DataBuffer;

                if (status == SRB_STATUS_DATA_OVERRUN) {
                    // Check to see if we at least get mininum number of bytes
                    if ((srb->DataTransferLength - deviceExtension->WordsLeft) >
                        (offsetof (SENSE_DATA, AdditionalSenseLength) + sizeof(senseData->AdditionalSenseLength))) {
                        status = SRB_STATUS_SUCCESS;
                    }
                }

                if (status == SRB_STATUS_SUCCESS) {
                    if ((senseData->SenseKey != SCSI_SENSE_ILLEGAL_REQUEST) &&
                        deviceExtension->MechStatusRetryCount) {

                        // The sense key doesn't say the last request is illegal, so try again
                        deviceExtension->MechStatusRetryCount--;
                        srb = deviceExtension->CurrentSrb = BuildMechanismStatusSrb (
                                                              HwDeviceExtension,
                                                              deviceExtension->OriginalSrb->PathId,
                                                              deviceExtension->OriginalSrb->TargetId);
                    } else {

                        // last request was illegal.  No point trying again

                        AtapiHwInitializeChanger (HwDeviceExtension,
                                                  srb->TargetId,
                                                  (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);

                        // Get ready to issue the original srb
                        srb = deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
                        deviceExtension->OriginalSrb = NULL;
                    }

                    srbStatus = AtapiSendCommand(HwDeviceExtension, deviceExtension->CurrentSrb);
                    if (srbStatus == SRB_STATUS_PENDING) {
                        return TRUE;
                    }
                }
            }

            // If we get here, it means AtapiSendCommand() has failed
            // Can't recover.  Pretend the original srb has failed and complete it.

            if (deviceExtension->OriginalSrb) {
                AtapiHwInitializeChanger (HwDeviceExtension,
                                          srb->TargetId,
                                          (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);
                srb = deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
                deviceExtension->OriginalSrb = NULL;
            }

            // fake an error and read no data
            status = SRB_STATUS_ERROR;
            srb->ScsiStatus = 0;
            deviceExtension->DataBuffer = srb->DataBuffer;
            deviceExtension->WordsLeft = srb->DataTransferLength;
            deviceExtension->RDP = FALSE;

        } else if (status == SRB_STATUS_ERROR) {

            //
            // Map error to specific SRB status and handle request sense.
            //

            status = MapError(deviceExtension,
                              srb);

            deviceExtension->RDP = FALSE;

        } else {

            //
            // Wait for busy to drop.
            //

            for (i = 0; i < 30; i++) {
                GetStatus(baseIoAddress1,statusByte);
                if (!(statusByte & IDE_STATUS_BUSY)) {
                    break;
                }
                ScsiPortStallExecution(500);
            }

            if (i == 30) {

                //
                // reset the controller.
                //

                DebugPrint((1,
                            "AtapiInterrupt: Resetting due to BSY still up - %x. Base Io %x\n",
                            statusByte,
                            baseIoAddress1));
                AtapiResetController(HwDeviceExtension,srb->PathId);
                return TRUE;
            }

            //
            // Check to see if DRQ is still up.
            //

            if (statusByte & IDE_STATUS_DRQ) {

                for (i = 0; i < 500; i++) {
                    GetStatus(baseIoAddress1,statusByte);
                    if (!(statusByte & IDE_STATUS_DRQ)) {
                        break;
                    }
                    ScsiPortStallExecution(100);

                }

                if (i == 500) {

                    //
                    // reset the controller.
                    //

                    DebugPrint((1,
                                "AtapiInterrupt: Resetting due to DRQ still up - %x\n",
                                statusByte));
                    AtapiResetController(HwDeviceExtension,srb->PathId);
                    return TRUE;
                }

            }
        }


        //
        // Clear interrupt expecting flag.
        //

        deviceExtension->ExpectingInterrupt = FALSE;

        //
        // Sanity check that there is a current request.
        //

        if (srb != NULL) {

            //
            // Set status in SRB.
            //

            srb->SrbStatus = (UCHAR)status;

            //
            // Check for underflow.
            //

            if (deviceExtension->WordsLeft) {

                //
                // Subtract out residual words and update if filemark hit,
                // setmark hit , end of data, end of media...
                //

                if (!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_TAPE_DEVICE)) {
                if (status == SRB_STATUS_DATA_OVERRUN) {
                    srb->DataTransferLength -= deviceExtension->WordsLeft;
                } else {
                    srb->DataTransferLength = 0;
                }
                } else {
                    srb->DataTransferLength -= deviceExtension->WordsLeft;
                }
            }

            if (srb->Function != SRB_FUNCTION_IO_CONTROL) {

                //
                // Indicate command complete.
                //

                if (!(deviceExtension->RDP)) {
                    ScsiPortNotification(RequestComplete,
                                         deviceExtension,
                                         srb);

                }
            } else {

                PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                UCHAR             error = 0;

                if (status != SRB_STATUS_SUCCESS) {
                    error = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
                }

                //
                // Build the SMART status block depending upon the completion status.
                //

                cmdOutParameters->cBufferSize = wordCount;
                cmdOutParameters->DriverStatus.bDriverError = (error) ? SMART_IDE_ERROR : 0;
                cmdOutParameters->DriverStatus.bIDEError = error;

                //
                // If the sub-command is return smart status, jam the value from cylinder low and high, into the
                // data buffer.
                //

                if (deviceExtension->SmartCommand == RETURN_SMART_STATUS) {
                    cmdOutParameters->bBuffer[0] = RETURN_SMART_STATUS;
                    cmdOutParameters->bBuffer[1] = ScsiPortReadPortUchar(&baseIoAddress1->InterruptReason);
                    cmdOutParameters->bBuffer[2] = ScsiPortReadPortUchar(&baseIoAddress1->Unused1);
                    cmdOutParameters->bBuffer[3] = ScsiPortReadPortUchar(&baseIoAddress1->ByteCountLow);
                    cmdOutParameters->bBuffer[4] = ScsiPortReadPortUchar(&baseIoAddress1->ByteCountHigh);
                    cmdOutParameters->bBuffer[5] = ScsiPortReadPortUchar(&baseIoAddress1->DriveSelect);
                    cmdOutParameters->bBuffer[6] = SMART_CMD;
                    cmdOutParameters->cBufferSize = 8;
                }

                //
                // Indicate command complete.
                //

                ScsiPortNotification(RequestComplete,
                                     deviceExtension,
                                     srb);

            }

        } else {

            DebugPrint((1,
                       "AtapiInterrupt: No SRB!\n"));
        }

        //
        // Indicate ready for next request.
        //

        if (!(deviceExtension->RDP)) {

            //
            // Clear current SRB.
            //

            deviceExtension->CurrentSrb = NULL;

            ScsiPortNotification(NextRequest,
                                 deviceExtension,
                                 NULL);
        } else {

            ScsiPortNotification(RequestTimerCall,
                                 HwDeviceExtension,
                                 AtapiCallBack,
                                 2000);
        }

        return TRUE;

    } else {

        //
        // Unexpected int.
        //

        DebugPrint((3,
                    "AtapiInterrupt: Unexpected interrupt. InterruptReason %x. Status %x.\n",
                    interruptReason,
                    statusByte));
        return FALSE;
    }

    return TRUE;

} // end AtapiInterrupt()


ULONG
IdeSendSmartCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles SMART enable, disable, read attributes and threshold commands.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    PSENDCMDOUTPARAMS    cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    SENDCMDINPARAMS      cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    PIDEREGS             regs = &cmdInParameters.irDriveRegs;
    ULONG                i;
    UCHAR                statusByte,targetId;


    if (cmdInParameters.irDriveRegs.bCommandReg == SMART_CMD) {

        targetId = cmdInParameters.bDriveNumber;

        //TODO optimize this check

        if ((!(deviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT)) ||
             (deviceExtension->DeviceFlags[targetId] & DFLAGS_ATAPI_DEVICE)) {

            return SRB_STATUS_SELECTION_TIMEOUT;
        }

        deviceExtension->SmartCommand = cmdInParameters.irDriveRegs.bFeaturesReg;

        //
        // Determine which of the commands to carry out.
        //

        if ((cmdInParameters.irDriveRegs.bFeaturesReg == READ_ATTRIBUTES) ||
            (cmdInParameters.irDriveRegs.bFeaturesReg == READ_THRESHOLDS)) {

            WaitOnBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

            //
            // Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
            //

            for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + READ_ATTRIBUTE_BUFFER_SIZE - 1); i++) {
                ((PUCHAR)cmdOutParameters)[i] = 0;
            }

            //
            // Set data buffer pointer and words left.
            //

            deviceExtension->DataBuffer = (PUSHORT)cmdOutParameters->bBuffer;
            deviceExtension->WordsLeft = READ_ATTRIBUTE_BUFFER_SIZE / 2;

            //
            // Indicate expecting an interrupt.
            //

            deviceExtension->ExpectingInterrupt = TRUE;

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,(UCHAR)(((targetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,regs->bFeaturesReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,regs->bSectorCountReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,regs->bCylLowReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            ScsiPortWritePortUchar(&baseIoAddress1->Command,regs->bCommandReg);

            //
            // Wait for interrupt.
            //

            return SRB_STATUS_PENDING;

        } else if ((cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_SMART) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == DISABLE_SMART) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == RETURN_SMART_STATUS) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_DISABLE_AUTOSAVE) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == EXECUTE_OFFLINE_DIAGS) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == SAVE_ATTRIBUTE_VALUES)) {

            WaitOnBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

            //
            // Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
            //

            for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) - 1); i++) {
                ((PUCHAR)cmdOutParameters)[i] = 0;
            }

            //
            // Set data buffer pointer and indicate no data transfer.
            //

            deviceExtension->DataBuffer = (PUSHORT)cmdOutParameters->bBuffer;
            deviceExtension->WordsLeft = 0;

            //
            // Indicate expecting an interrupt.
            //

            deviceExtension->ExpectingInterrupt = TRUE;

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,(UCHAR)(((targetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,regs->bFeaturesReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,regs->bSectorCountReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,regs->bCylLowReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            ScsiPortWritePortUchar(&baseIoAddress1->Command,regs->bCommandReg);

            //
            // Wait for interrupt.
            //

            return SRB_STATUS_PENDING;
        }
    }

    return SRB_STATUS_INVALID_REQUEST;

} // end IdeSendSmartCommand()


ULONG
IdeReadWrite(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles IDE read and writes.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG                startingSector,i;
    ULONG                wordCount;
    UCHAR                statusByte,statusByte2;
    UCHAR                cylinderHigh,cylinderLow,drvSelect,sectorNumber;

    //
    // Select device 0 or 1.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                            (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));

    WaitOnBusy(baseIoAddress1,statusByte2);

    if (statusByte2 & IDE_STATUS_BUSY) {
        DebugPrint((1,
                    "IdeReadWrite: Returning BUSY status\n"));
        return SRB_STATUS_BUSY;
    }

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA) {
        if (!PrepareForBusMastering(HwDeviceExtension, Srb))
            return SRB_STATUS_ERROR;
    }

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
    deviceExtension->WordsLeft = Srb->DataTransferLength / 2;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;

    //
    // Set up sector count register. Round up to next block.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                           (UCHAR)((Srb->DataTransferLength + 0x1FF) / 0x200));

    //
    // Get starting sector number from CDB.
    //

    startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((2,
               "IdeReadWrite: Starting sector is %x, Number of bytes %x\n",
               startingSector,
               Srb->DataTransferLength));

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA) {

        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR) (((Srb->TargetId & 0x1) << 4) |
                                        0xA0 |
                                        IDE_LBA_MODE |
                                        ((startingSector & 0x0f000000) >> 24)));

        ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,
                               (UCHAR) ((startingSector & 0x000000ff) >> 0));
        ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,
                               (UCHAR) ((startingSector & 0x0000ff00) >> 8));
        ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,
                               (UCHAR) ((startingSector & 0x00ff0000) >> 16));

    } else {  //CHS

        //
        // Set up sector number register.
        //

        sectorNumber =  (UCHAR)((startingSector % deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) + 1);
        ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,sectorNumber);

        //
        // Set up cylinder low register.
        //

        cylinderLow =  (UCHAR)(startingSector / (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads));
        ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,cylinderLow);

        //
        // Set up cylinder high register.
        //

        cylinderHigh = (UCHAR)((startingSector / (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads)) >> 8);
        ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,cylinderHigh);

        //
        // Set up head and drive select register.
        //

        drvSelect = (UCHAR)(((startingSector / deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
                          deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads) |((Srb->TargetId & 0x1) << 4) | 0xA0);
        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,drvSelect);

        DebugPrint((2,
                   "IdeReadWrite: Cylinder %x Head %x Sector %x\n",
                   startingSector /
                   (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                   deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads),
                   (startingSector /
                   deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
                   deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads,
                   startingSector %
                   deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack + 1));
    }

    //
    // Check if write request.
    //

    if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {

        //
        // Send read command.
        //
        ScsiPortWritePortUchar(&baseIoAddress1->Command,
                               deviceExtension->DeviceParameters[Srb->TargetId].IdeReadCommand);

    } else {


        //
        // Send write command.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->Command,
                               deviceExtension->DeviceParameters[Srb->TargetId].IdeWriteCommand);

        if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA)) {

            if (deviceExtension->WordsLeft < deviceExtension->DeviceParameters[Srb->TargetId].MaxWordPerInterrupt) {
                wordCount = deviceExtension->WordsLeft;
            } else {
                wordCount = deviceExtension->DeviceParameters[Srb->TargetId].MaxWordPerInterrupt;
            }
            //
            // Wait for BSY and DRQ.
            //

            WaitOnBaseBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {

                DebugPrint((1,
                            "IdeReadWrite 2: Returning BUSY status %x\n",
                            statusByte));
                return SRB_STATUS_BUSY;
            }

            for (i = 0; i < 1000; i++) {
                GetBaseStatus(baseIoAddress1, statusByte);
                if (statusByte & IDE_STATUS_DRQ) {
                    break;
                }
                ScsiPortStallExecution(200);

            }

            if (!(statusByte & IDE_STATUS_DRQ)) {

                DebugPrint((1,
                           "IdeReadWrite: DRQ never asserted (%x) original status (%x)\n",
                           statusByte,
                           statusByte2));

                deviceExtension->WordsLeft = 0;

                //
                // Clear interrupt expecting flag.
                //

                deviceExtension->ExpectingInterrupt = FALSE;

                //
                // Clear current SRB.
                //

                deviceExtension->CurrentSrb = NULL;

                return SRB_STATUS_TIMEOUT;
            }

            //
            // Write next 256 words.
            //

            WriteBuffer(baseIoAddress1,
                        deviceExtension->DataBuffer,
                        wordCount);

            //
            // Adjust buffer address and words left count.
            //

            deviceExtension->WordsLeft -= wordCount;
            deviceExtension->DataBuffer += wordCount;

        }
    }

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA) {
        EnableBusMastering(HwDeviceExtension, Srb);
    }

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeReadWrite()



ULONG
IdeVerify(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles IDE Verify.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG                startingSector;
    ULONG                sectors;
    ULONG                endSector;
    USHORT               sectorCount;

    //
    // Drive has these number sectors.
    //

    sectors = deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
              deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads *
              deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders;

    DebugPrint((3,
                "IdeVerify: Total sectors %x\n",
                sectors));

    //
    // Get starting sector number from CDB.
    //

    startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((3,
                "IdeVerify: Starting sector %x. Number of blocks %x\n",
                startingSector,
                ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb));

    sectorCount = (USHORT)(((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8 |
                           ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb );
    endSector = startingSector + sectorCount;

    DebugPrint((3,
                "IdeVerify: Ending sector %x\n",
                endSector));

    if (endSector > sectors) {

        //
        // Too big, round down.
        //

        DebugPrint((1,
                    "IdeVerify: Truncating request to %x blocks\n",
                    sectors - startingSector - 1));

        ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                               (UCHAR)(sectors - startingSector - 1));

    } else {

        //
        // Set up sector count register. Round up to next block.
        //

        if (sectorCount > 0xFF) {
            sectorCount = (USHORT)0xFF;
        }

        ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,(UCHAR)sectorCount);
    }

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
    deviceExtension->WordsLeft = Srb->DataTransferLength / 2;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;


    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA) { // LBA

        ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,
                               (UCHAR) ((startingSector & 0x000000ff) >> 0));

        ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,
                               (UCHAR) ((startingSector & 0x0000ff00) >> 8));

        ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,
                               (UCHAR) ((startingSector & 0x00ff0000) >> 16));

        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR) (((Srb->TargetId & 0x1) << 4) |
                                        0xA0 |
                                        IDE_LBA_MODE |
                                        (startingSector & 0x0f000000 >> 24)));

        DebugPrint((2,
                   "IdeVerify: LBA: startingSector %x\n",
                   startingSector));

    } else {  //CHS

        //
        // Set up sector number register.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,
                               (UCHAR)((startingSector %
                               deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) + 1));

        //
        // Set up cylinder low register.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,
                               (UCHAR)(startingSector /
                               (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads)));

        //
        // Set up cylinder high register.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,
                               (UCHAR)((startingSector /
                               (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads)) >> 8));

        //
        // Set up head and drive select register.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR)(((startingSector /
                               deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
                               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads) |
                               ((Srb->TargetId & 0x1) << 4) | 0xA0));

        DebugPrint((2,
                   "IdeVerify: CHS: Cylinder %x Head %x Sector %x\n",
                   startingSector /
                   (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                   deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads),
                   (startingSector /
                   deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
                   deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads,
                   startingSector %
                   deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack + 1));
    }

    //
    // Send verify command.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->Command,
                           IDE_COMMAND_VERIFY);

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeVerify()


VOID
Scsi2Atapi(
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Convert SCSI packet command to Atapi packet command.

Arguments:

    Srb - IO request packet

Return Value:

    None

--*/
{
    //
    // Change the cdb length
    //

    Srb->CdbLength = 12;

    switch (Srb->Cdb[0]) {
        case SCSIOP_MODE_SENSE: {
            PMODE_SENSE_10 modeSense10 = (PMODE_SENSE_10)Srb->Cdb;
            UCHAR PageCode = ((PCDB)Srb->Cdb)->MODE_SENSE.PageCode;
            UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SENSE.AllocationLength;

            AtapiZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

            modeSense10->OperationCode = ATAPI_MODE_SENSE;
            modeSense10->PageCode = PageCode;
            modeSense10->ParameterListLengthMsb = 0;
            modeSense10->ParameterListLengthLsb = Length;
            break;
        }

        case SCSIOP_MODE_SELECT: {
            PMODE_SELECT_10 modeSelect10 = (PMODE_SELECT_10)Srb->Cdb;
            UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SELECT.ParameterListLength;

            //
            // Zero the original cdb
            //

            AtapiZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

            modeSelect10->OperationCode = ATAPI_MODE_SELECT;
            modeSelect10->PFBit = 1;
            modeSelect10->ParameterListLengthMsb = 0;
            modeSelect10->ParameterListLengthLsb = Length;
            break;
        }

        case SCSIOP_FORMAT_UNIT:
        Srb->Cdb[0] = ATAPI_FORMAT_UNIT;
        break;
    }
}



ULONG
AtapiSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Send ATAPI packet command to device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PATAPI_REGISTERS_1   baseIoAddress1  = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PATAPI_REGISTERS_2   baseIoAddress2 =  (PATAPI_REGISTERS_2)deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG i;
    ULONG flags;
    UCHAR statusByte,byteCountLow,byteCountHigh;

    //
    // We need to know how many platters our atapi cd-rom device might have.
    // Before anyone tries to send a srb to our target for the first time,
    // we must "secretly" send down a separate mechanism status srb in order to
    // initialize our device extension changer data.  That's how we know how
    // many platters our target has.
    //
    if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_CHANGER_INITED) &&
        !deviceExtension->OriginalSrb) {

        ULONG srbStatus;

        //
        // Set this flag now. If the device hangs on the mech. status
        // command, we will not have the change to set it.
        //
        deviceExtension->DeviceFlags[Srb->TargetId] |= DFLAGS_CHANGER_INITED;

        deviceExtension->MechStatusRetryCount = 3;
        deviceExtension->CurrentSrb = BuildMechanismStatusSrb (
                                        HwDeviceExtension,
                                        Srb->PathId,
                                        Srb->TargetId);
        deviceExtension->OriginalSrb = Srb;

        srbStatus = AtapiSendCommand(HwDeviceExtension, deviceExtension->CurrentSrb);
        if (srbStatus == SRB_STATUS_PENDING) {
            return srbStatus;
        } else {
            deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
            deviceExtension->OriginalSrb = NULL;
            AtapiHwInitializeChanger (HwDeviceExtension,
                                      Srb->TargetId,
                                      (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);
            // fall out
        }
    }

    DebugPrint((2,
               "AtapiSendCommand: Command %x to TargetId %d lun %d\n",
               Srb->Cdb[0],
               Srb->TargetId,
               Srb->Lun));

    //
    // Make sure command is to ATAPI device.
    //

    flags = deviceExtension->DeviceFlags[Srb->TargetId];
    if (flags & (DFLAGS_SANYO_ATAPI_CHANGER | DFLAGS_ATAPI_CHANGER)) {
        if ((Srb->Lun) > (deviceExtension->DiscsPresent[Srb->TargetId] - 1)) {

            //
            // Indicate no device found at this address.
            //

            return SRB_STATUS_SELECTION_TIMEOUT;
        }
    } else if (Srb->Lun > 0) {
        return SRB_STATUS_SELECTION_TIMEOUT;
    }

    if (!(flags & DFLAGS_ATAPI_DEVICE)) {
        return SRB_STATUS_SELECTION_TIMEOUT;
    }

    //
    // Select device 0 or 1.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                           (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));

    //
    // Verify that controller is ready for next command.
    //

    GetStatus(baseIoAddress1,statusByte);

    DebugPrint((2,
                "AtapiSendCommand: Entered with status %x\n",
                statusByte));

    if (statusByte & IDE_STATUS_BUSY) {
        DebugPrint((1,
                    "AtapiSendCommand: Device busy (%x)\n",
                    statusByte));
        return SRB_STATUS_BUSY;

    }

    if (statusByte & IDE_STATUS_ERROR) {
        if (Srb->Cdb[0] != SCSIOP_REQUEST_SENSE) {

            DebugPrint((1,
                        "AtapiSendCommand: Error on entry: (%x)\n",
                        statusByte));
            //
            // Read the error reg. to clear it and fail this request.
            //

            return MapError(deviceExtension,
                            Srb);
        }
    }

    //
    // If a tape drive has doesn't have DSC set and the last command is restrictive, don't send
    // the next command. See discussion of Restrictive Delayed Process commands in QIC-157.
    //

    if ((!(statusByte & IDE_STATUS_DSC)) &&
          (flags & DFLAGS_TAPE_DEVICE) && deviceExtension->RDP) {
        ScsiPortStallExecution(1000);
        DebugPrint((2,"AtapiSendCommand: DSC not set. %x\n",statusByte));
        return SRB_STATUS_BUSY;
    }

    if (IS_RDP(Srb->Cdb[0])) {

        deviceExtension->RDP = TRUE;

        DebugPrint((3,
                    "AtapiSendCommand: %x mapped as DSC restrictive\n",
                    Srb->Cdb[0]));

    } else {

        deviceExtension->RDP = FALSE;
    }

    if (statusByte & IDE_STATUS_DRQ) {

        DebugPrint((1,
                    "AtapiSendCommand: Entered with status (%x). Attempting to recover.\n",
                    statusByte));
        //
        // Try to drain the data that one preliminary device thinks that it has
        // to transfer. Hopefully this random assertion of DRQ will not be present
        // in production devices.
        //

        for (i = 0; i < 0x10000; i++) {

           GetStatus(baseIoAddress1, statusByte);

           if (statusByte & IDE_STATUS_DRQ) {

              ScsiPortReadPortUshort(&baseIoAddress1->Data);

           } else {

              break;
           }
        }

        if (i == 0x10000) {

            DebugPrint((1,
                        "AtapiSendCommand: DRQ still asserted.Status (%x)\n",
                        statusByte));

            AtapiSoftReset(baseIoAddress1,Srb->TargetId, FALSE);

            DebugPrint((1,
                         "AtapiSendCommand: Issued soft reset to Atapi device. \n"));

            //
            // Re-initialize Atapi device.
            //

            IssueIdentify(HwDeviceExtension,
                          (Srb->TargetId & 0x1),
                          (Srb->TargetId >> 1),
                          IDE_COMMAND_ATAPI_IDENTIFY,
                          FALSE);

            //
            // Inform the port driver that the bus has been reset.
            //

            ScsiPortNotification(ResetDetected, HwDeviceExtension, 0);

            //
            // Clean up device extension fields that AtapiStartIo won't.
            //

            deviceExtension->ExpectingInterrupt = FALSE;
            deviceExtension->RDP = FALSE;

            return SRB_STATUS_BUS_RESET;

        }
    }

    if (flags & (DFLAGS_SANYO_ATAPI_CHANGER | DFLAGS_ATAPI_CHANGER)) {

        //
        // As the cdrom driver sets the LUN field in the cdb, it must be removed.
        //

        Srb->Cdb[1] &= ~0xE0;

        if ((Srb->Cdb[0] == SCSIOP_TEST_UNIT_READY) && (flags & DFLAGS_SANYO_ATAPI_CHANGER)) {

            //
            // Torisan changer. TUR's are overloaded to be platter switches.
            //

            Srb->Cdb[7] = Srb->Lun;

        }
    }

    switch (Srb->Cdb[0]) {

        //
        // Convert SCSI to ATAPI commands if needed
        //
        case SCSIOP_MODE_SENSE:
        case SCSIOP_MODE_SELECT:
        case SCSIOP_FORMAT_UNIT:
            if (!(flags & DFLAGS_TAPE_DEVICE)) {
                Scsi2Atapi(Srb);
            }

            break;

        case SCSIOP_RECEIVE:
        case SCSIOP_SEND:
        case SCSIOP_READ:
        case SCSIOP_WRITE:
            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA) {
                if (!PrepareForBusMastering(HwDeviceExtension, Srb))
                    return SRB_STATUS_ERROR;
            }
            break;

        default:
            break;
    }


    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
    deviceExtension->WordsLeft = Srb->DataTransferLength / 2;

    WaitOnBusy(baseIoAddress1,statusByte);

    //
    // Write transfer byte count to registers.
    //

    byteCountLow = (UCHAR)(Srb->DataTransferLength & 0xFF);
    byteCountHigh = (UCHAR)(Srb->DataTransferLength >> 8);

    if (Srb->DataTransferLength >= 0x10000) {
        byteCountLow = byteCountHigh = 0xFF;
    }

    ScsiPortWritePortUchar(&baseIoAddress1->ByteCountLow,byteCountLow);
    ScsiPortWritePortUchar(&baseIoAddress1->ByteCountHigh, byteCountHigh);

    ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,0);
    if ((Srb->Cdb[0] == SCSIOP_READ)  || 
        (Srb->Cdb[0] == SCSIOP_WRITE) ||
        (Srb->Cdb[0] == SCSIOP_SEND)  || 
        (Srb->Cdb[0] == SCSIOP_RECEIVE)) {
        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA) {
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1, 0x1);
        }
    }

    if (flags & DFLAGS_INT_DRQ) {

        //
        // This device interrupts when ready to receive the packet.
        //
        // Write ATAPI packet command.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->Command,
                               IDE_COMMAND_ATAPI_PACKET);

        DebugPrint((3,
                   "AtapiSendCommand: Wait for int. to send packet. Status (%x)\n",
                   statusByte));

        deviceExtension->ExpectingInterrupt = TRUE;

        return SRB_STATUS_PENDING;

    } else {

        //
        // Write ATAPI packet command.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->Command,
                               IDE_COMMAND_ATAPI_PACKET);

        //
        // Wait for DRQ.
        //

        WaitOnBusy(baseIoAddress1, statusByte);
        WaitForDrq(baseIoAddress1, statusByte);

        if (!(statusByte & IDE_STATUS_DRQ)) {

            DebugPrint((1,
                       "AtapiSendCommand: DRQ never asserted (%x)\n",
                       statusByte));
            return SRB_STATUS_ERROR;
        }
    }

    //
    // Need to read status register.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    //
    // Send CDB to device.
    //

    WaitOnBusy(baseIoAddress1,statusByte);

    WriteBuffer(baseIoAddress1,
                (PUSHORT)Srb->Cdb,
                6);

    //
    // Indicate expecting an interrupt and wait for it.
    //

    deviceExtension->ExpectingInterrupt = TRUE;

    switch (Srb->Cdb[0]) {

        case SCSIOP_RECEIVE:
        case SCSIOP_SEND:
        case SCSIOP_READ:
        case SCSIOP_WRITE:
            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA) {
                EnableBusMastering(HwDeviceExtension, Srb);
            }
            break;

        default:
            break;
    }

    return SRB_STATUS_PENDING;

} // end AtapiSendCommand()

ULONG
IdeSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Program ATA registers for IDE disk transfer.

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    PCDB cdb;

    UCHAR statusByte,errorByte;
    ULONG status;
    ULONG i;
    PMODE_PARAMETER_HEADER   modeData;

    DebugPrint((2,
               "IdeSendCommand: Command %x to device %d\n",
               Srb->Cdb[0],
               Srb->TargetId));



    switch (Srb->Cdb[0]) {
    case SCSIOP_INQUIRY:

        //
        // Filter out all TIDs but 0 and 1 since this is an IDE interface
        // which support up to two devices.
        //

        if ((Srb->Lun != 0) ||
            (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT))) {

            //
            // Indicate no device found at this address.
            //

            status = SRB_STATUS_SELECTION_TIMEOUT;
            break;

        } else {

            PINQUIRYDATA    inquiryData  = Srb->DataBuffer;
            PIDENTIFY_DATA2 identifyData = &deviceExtension->IdentifyData[Srb->TargetId];

            //
            // Zero INQUIRY data structure.
            //

            for (i = 0; i < Srb->DataTransferLength; i++) {
               ((PUCHAR)Srb->DataBuffer)[i] = 0;
            }

            //
            // Standard IDE interface only supports disks.
            //

            inquiryData->DeviceType = DIRECT_ACCESS_DEVICE;

            //
            // Set the removable bit, if applicable.
            //

            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE) {
                inquiryData->RemovableMedia = 1;
            }

            //
            // Fill in vendor identification fields.
            //

            for (i = 0; i < 20; i += 2) {
               inquiryData->VendorId[i] =
                   ((PUCHAR)identifyData->ModelNumber)[i + 1];
               inquiryData->VendorId[i+1] =
                   ((PUCHAR)identifyData->ModelNumber)[i];
            }

            //
            // Initialize unused portion of product id.
            //

            for (i = 0; i < 4; i++) {
               inquiryData->ProductId[12+i] = ' ';
            }

            //
            // Move firmware revision from IDENTIFY data to
            // product revision in INQUIRY data.
            //

            for (i = 0; i < 4; i += 2) {
               inquiryData->ProductRevisionLevel[i] =
                   ((PUCHAR)identifyData->FirmwareRevision)[i+1];
               inquiryData->ProductRevisionLevel[i+1] =
                   ((PUCHAR)identifyData->FirmwareRevision)[i];
            }

            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SCSIOP_MODE_SENSE:

        //
        // This is used to determine of the media is write-protected.
        // Since IDE does not support mode sense then we will modify just the portion we need
        // so the higher level driver can determine if media is protected.
        //

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                             (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_GET_MEDIA_STATUS);
            WaitOnBusy(baseIoAddress1,statusByte);

            if (!(statusByte & IDE_STATUS_ERROR)){

                //
                // no error occured return success, media is not protected
                //

                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;

            } else {

                //
                // error occured, handle it locally, clear interrupt
                //

                errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);

                GetBaseStatus(baseIoAddress1, statusByte);
                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;

                if (errorByte & IDE_ERROR_DATA_ERROR) {

                   //
                   //media is write-protected, set bit in mode sense buffer
                   //

                   modeData = (PMODE_PARAMETER_HEADER)Srb->DataBuffer;

                   Srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER);
                   modeData->DeviceSpecificParameter |= MODE_DSP_WRITE_PROTECT;
                }
            }
            status = SRB_STATUS_SUCCESS;
        } else {
            status = SRB_STATUS_INVALID_REQUEST;
        }
        break;

    case SCSIOP_TEST_UNIT_READY:

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {

            //
            // Select device 0 or 1.
            //

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                            (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_GET_MEDIA_STATUS);

            //
            // Wait for busy. If media has not changed, return success
            //

            WaitOnBusy(baseIoAddress1,statusByte);

            if (!(statusByte & IDE_STATUS_ERROR)){
                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;
            } else {
                errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
                if (errorByte == IDE_ERROR_DATA_ERROR){

                    //
                    // Special case: If current media is write-protected,
                    // the 0xDA command will always fail since the write-protect bit
                    // is sticky,so we can ignore this error
                    //

                   GetBaseStatus(baseIoAddress1, statusByte);
                   deviceExtension->ExpectingInterrupt = FALSE;
                   status = SRB_STATUS_SUCCESS;

                } else {

                    //
                    // Request sense buffer to be build
                    //
                    deviceExtension->ExpectingInterrupt = TRUE;
                    status = SRB_STATUS_PENDING;
               }
            }
        } else {
            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SCSIOP_READ_CAPACITY:

        //
        // Claim 512 byte blocks (big-endian).
        //

        ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->BytesPerBlock = 0x20000;

        //
        // Calculate last sector.
        //
        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA) {
            // LBA device
            i = deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors - 1;

            DebugPrint((1,
                       "IDE LBA disk %x - total # of sectors = 0x%x\n",
                       Srb->TargetId,
                       deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors));

        } else {
            // CHS device
            i = (deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads *
                 deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders *
                 deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) - 1;

            DebugPrint((1,
                       "IDE CHS disk %x - #sectors %x, #heads %x, #cylinders %x\n",
                       Srb->TargetId,
                       deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack,
                       deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads,
                       deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders));

        }

        ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress =
           (((PUCHAR)&i)[0] << 24) |  (((PUCHAR)&i)[1] << 16) |
           (((PUCHAR)&i)[2] << 8) | ((PUCHAR)&i)[3];


        status = SRB_STATUS_SUCCESS;
        break;

    case SCSIOP_VERIFY:
       status = IdeVerify(HwDeviceExtension,Srb);

       break;

    case SCSIOP_READ:
    case SCSIOP_WRITE:

       status = IdeReadWrite(HwDeviceExtension,
                                  Srb);
       break;

    case SCSIOP_START_STOP_UNIT:

       //
       //Determine what type of operation we should perform
       //
       cdb = (PCDB)Srb->Cdb;

       if (cdb->START_STOP.LoadEject == 1){

           //
           // Eject media,
           // first select device 0 or 1.
           //
           WaitOnBusy(baseIoAddress1,statusByte);

           ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                            (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
           ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_MEDIA_EJECT);
       }
       status = SRB_STATUS_SUCCESS;
       break;

    case SCSIOP_MEDIUM_REMOVAL:

       cdb = (PCDB)Srb->Cdb;

       WaitOnBusy(baseIoAddress1,statusByte);

       ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                              (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
       if (cdb->MEDIA_REMOVAL.Prevent == TRUE) {
           ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_DOOR_LOCK);
       } else {
           ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_DOOR_UNLOCK);
       }
       status = SRB_STATUS_SUCCESS;
       break;

    case SCSIOP_REQUEST_SENSE:
       // this function makes sense buffers to report the results
       // of the original GET_MEDIA_STATUS command

       if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {
           status = IdeBuildSenseBuffer(HwDeviceExtension,Srb);
           break;
       }

    // ATA_PASSTHORUGH
    case SCSIOP_ATA_PASSTHROUGH:
        {
            PIDEREGS pIdeReg;
            pIdeReg = (PIDEREGS) &(Srb->Cdb[2]);

            pIdeReg->bDriveHeadReg &= 0x0f;
            pIdeReg->bDriveHeadReg |= (UCHAR) (((Srb->TargetId & 0x1) << 4) | 0xA0);

            if (pIdeReg->bReserved == 0) {      // execute ATA command

                ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,  pIdeReg->bDriveHeadReg);
                ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,    pIdeReg->bFeaturesReg);
                ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,   pIdeReg->bSectorCountReg);
                ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,  pIdeReg->bSectorNumberReg);
                ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,  pIdeReg->bCylLowReg);
                ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, pIdeReg->bCylHighReg);
                ScsiPortWritePortUchar(&baseIoAddress1->Command,      pIdeReg->bCommandReg);

                ScsiPortStallExecution(1);                  // wait for busy to be set
                WaitOnBusy(baseIoAddress1,statusByte);      // wait for busy to be clear
                GetBaseStatus(baseIoAddress1, statusByte);
                if (statusByte & (IDE_STATUS_BUSY | IDE_STATUS_ERROR)) {

                    if (Srb->SenseInfoBuffer) {

                        PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                        senseBuffer->ErrorCode = 0x70;
                        senseBuffer->Valid     = 1;
                        senseBuffer->AdditionalSenseLength = 0xb;
                        senseBuffer->SenseKey =  SCSI_SENSE_ABORTED_COMMAND;
                        senseBuffer->AdditionalSenseCode = 0;
                        senseBuffer->AdditionalSenseCodeQualifier = 0;

                        Srb->SrbStatus = SRB_STATUS_AUTOSENSE_VALID;
                        Srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
                    }
                    status = SRB_STATUS_ERROR;
                } else {

                    if (statusByte & IDE_STATUS_DRQ) {
                        if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {
                            ReadBuffer(baseIoAddress1,
                                       (PUSHORT) Srb->DataBuffer,
                                       Srb->DataTransferLength / 2);
                        } else if (Srb->SrbFlags & SRB_FLAGS_DATA_OUT) {
                            WriteBuffer(baseIoAddress1,
                                        (PUSHORT) Srb->DataBuffer,
                                        Srb->DataTransferLength / 2);
                        }
                    }
                    status = SRB_STATUS_SUCCESS;
                }

            } else { // read task register

                ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,  pIdeReg->bDriveHeadReg);

                pIdeReg = (PIDEREGS) Srb->DataBuffer;
                pIdeReg->bDriveHeadReg    = ScsiPortReadPortUchar(&baseIoAddress1->DriveSelect);
                pIdeReg->bFeaturesReg     = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
                pIdeReg->bSectorCountReg  = ScsiPortReadPortUchar(&baseIoAddress1->BlockCount);
                pIdeReg->bSectorNumberReg = ScsiPortReadPortUchar(&baseIoAddress1->BlockNumber);
                pIdeReg->bCylLowReg       = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                pIdeReg->bCylHighReg      = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);
                pIdeReg->bCommandReg      = ScsiPortReadPortUchar(&baseIoAddress1->Command);
                status = SRB_STATUS_SUCCESS;
            }
        }
    break;

    default:

       DebugPrint((1,
                  "IdeSendCommand: Unsupported command %x\n",
                  Srb->Cdb[0]));

       status = SRB_STATUS_INVALID_REQUEST;

    } // end switch

    return status;

} // end IdeSendCommand()

VOID
IdeMediaStatus(
    BOOLEAN EnableMSN,
    IN PVOID HwDeviceExtension,
    ULONG Channel
    )
/*++

Routine Description:

    Enables disables media status notification

Arguments:

HwDeviceExtension - ATAPI driver storage.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress = deviceExtension->BaseIoAddress1[Channel >> 1];
    UCHAR statusByte,errorByte;


    if (EnableMSN == TRUE){

        //
        // If supported enable Media Status Notification support
        //

        if ((deviceExtension->DeviceFlags[Channel] & DFLAGS_REMOVABLE_DRIVE)) {

            //
            // enable
            //
            ScsiPortWritePortUchar(&baseIoAddress->DriveSelect,
                                   (UCHAR)(((Channel & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1,(UCHAR) (0x95));
            ScsiPortWritePortUchar(&baseIoAddress->Command,
                                   IDE_COMMAND_ENABLE_MEDIA_STATUS);

            WaitOnBaseBusy(baseIoAddress,statusByte);

            if (statusByte & IDE_STATUS_ERROR) {
                //
                // Read the error register.
                //
                errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress + 1);

                DebugPrint((1,
                            "IdeMediaStatus: Error enabling media status. Status %x, error byte %x\n",
                             statusByte,
                             errorByte));
            } else {
                deviceExtension->DeviceFlags[Channel] |= DFLAGS_MEDIA_STATUS_ENABLED;
                DebugPrint((1,"IdeMediaStatus: Media Status Notification Supported\n"));
                deviceExtension->ReturningMediaStatus = 0;

            }

        }
    } else { // end if EnableMSN == TRUE

        //
        // disable if previously enabled
        //
        if ((deviceExtension->DeviceFlags[Channel] & DFLAGS_MEDIA_STATUS_ENABLED)) {

            ScsiPortWritePortUchar(&baseIoAddress->DriveSelect,
                                   (UCHAR)(((Channel & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1,(UCHAR) (0x31));
            ScsiPortWritePortUchar(&baseIoAddress->Command,
                                   IDE_COMMAND_ENABLE_MEDIA_STATUS);

            WaitOnBaseBusy(baseIoAddress,statusByte);
            deviceExtension->DeviceFlags[Channel] &= ~DFLAGS_MEDIA_STATUS_ENABLED;
        }


    }



}

ULONG
IdeBuildSenseBuffer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Builts an artificial sense buffer to report the results of a GET_MEDIA_STATUS
    command. This function is invoked to satisfy the SCSIOP_REQUEST_SENSE.
Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (ALWAYS SUCCESS).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG status;
    PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->DataBuffer;


    if (senseBuffer){


        if(deviceExtension->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if(deviceExtension->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE_REQ) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if(deviceExtension->ReturningMediaStatus & IDE_ERROR_END_OF_MEDIA) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_NOT_READY;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if(deviceExtension->ReturningMediaStatus & IDE_ERROR_DATA_ERROR) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_DATA_PROTECT;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }
        return SRB_STATUS_SUCCESS;
    }
    return SRB_STATUS_ERROR;

}// End of IdeBuildSenseBuffer




BOOLEAN
AtapiStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine is called from the SCSI port driver synchronized
    with the kernel to start an IO request.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    TRUE

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG status;

    //
    // Determine which function.
    //

    switch (Srb->Function) {

    case SRB_FUNCTION_EXECUTE_SCSI:

        //
        // Sanity check. Only one request can be outstanding on a
        // controller.
        //

        if (deviceExtension->CurrentSrb) {

            DebugPrint((1,
                       "AtapiStartIo: Already have a request!\n"));
            Srb->SrbStatus = SRB_STATUS_BUSY;
            ScsiPortNotification(RequestComplete,
                                 deviceExtension,
                                 Srb);
            return FALSE;
        }

        //
        // Indicate that a request is active on the controller.
        //

        deviceExtension->CurrentSrb = Srb;

        //
        // Send command to device.
        //

        // ATA_PASSTHORUGH
        if (Srb->Cdb[0] == SCSIOP_ATA_PASSTHROUGH) {

           status = IdeSendCommand(HwDeviceExtension,
                                   Srb);

        } else if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

           status = AtapiSendCommand(HwDeviceExtension,
                                     Srb);

        } else if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) {

           status = IdeSendCommand(HwDeviceExtension,
                                   Srb);
        } else {

            status = SRB_STATUS_SELECTION_TIMEOUT;
        }

        break;

    case SRB_FUNCTION_ABORT_COMMAND:

        //
        // Verify that SRB to abort is still outstanding.
        //

        if (!deviceExtension->CurrentSrb) {

            DebugPrint((1, "AtapiStartIo: SRB to abort already completed\n"));

            //
            // Complete abort SRB.
            //

            status = SRB_STATUS_ABORT_FAILED;

            break;
        }

        //
        // Abort function indicates that a request timed out.
        // Call reset routine. Card will only be reset if
        // status indicates something is wrong.
        // Fall through to reset code.
        //

    case SRB_FUNCTION_RESET_BUS:

        //
        // Reset Atapi and SCSI bus.
        //

        DebugPrint((1, "AtapiStartIo: Reset bus request received\n"));

        if (!AtapiResetController(deviceExtension,
                             Srb->PathId)) {

              DebugPrint((1,"AtapiStartIo: Reset bus failed\n"));

            //
            // Log reset failure.
            //

            ScsiPortLogError(
                HwDeviceExtension,
                NULL,
                0,
                0,
                0,
                SP_INTERNAL_ADAPTER_ERROR,
                5 << 8
                );

              status = SRB_STATUS_ERROR;

        } else {

              status = SRB_STATUS_SUCCESS;
        }

        break;

    case SRB_FUNCTION_IO_CONTROL:

        if (deviceExtension->CurrentSrb) {

            DebugPrint((1,
                       "AtapiStartIo: Already have a request!\n"));
            Srb->SrbStatus = SRB_STATUS_BUSY;
            ScsiPortNotification(RequestComplete,
                                 deviceExtension,
                                 Srb);
            return FALSE;
        }

        //
        // Indicate that a request is active on the controller.
        //

        deviceExtension->CurrentSrb = Srb;

        if (AtapiStringCmp( ((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature,"SCSIDISK",strlen("SCSIDISK"))) {

            DebugPrint((1,
                        "AtapiStartIo: IoControl signature incorrect. Send %s, expected %s\n",
                        ((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature,
                        "SCSIDISK"));

            status = SRB_STATUS_INVALID_REQUEST;
            break;
        }

        switch (((PSRB_IO_CONTROL)(Srb->DataBuffer))->ControlCode) {

            case IOCTL_SCSI_MINIPORT_SMART_VERSION: {

                PGETVERSIONINPARAMS versionParameters = (PGETVERSIONINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                UCHAR deviceNumber;

                //
                // Version and revision per SMART 1.03
                //

                versionParameters->bVersion = 1;
                versionParameters->bRevision = 1;
                versionParameters->bReserved = 0;

                //
                // Indicate that support for IDE IDENTIFY, ATAPI IDENTIFY and SMART commands.
                //

                versionParameters->fCapabilities = (CAP_ATA_ID_CMD | CAP_ATAPI_ID_CMD | CAP_SMART_CMD);

                //
                // This is done because of how the IOCTL_SCSI_MINIPORT
                // determines 'targetid's'. Disk.sys places the real target id value
                // in the DeviceMap field. Once we do some parameter checking, the value passed
                // back to the application will be determined.
                //

                deviceNumber = versionParameters->bIDEDeviceMap;

                if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) ||
                    (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE)) {

                    status = SRB_STATUS_SELECTION_TIMEOUT;
                    break;
                }

                //
                // NOTE: This will only set the bit
                // corresponding to this drive's target id.
                // The bit mask is as follows:
                //
                //     Sec Pri
                //     S M S M
                //     3 2 1 0
                //

                if (deviceExtension->NumberChannels == 1) {
                    if (deviceExtension->PrimaryAddress) {
                        deviceNumber = 1 << Srb->TargetId;
                    } else {
                        deviceNumber = 4 << Srb->TargetId;
                    }
                } else {
                    deviceNumber = 1 << Srb->TargetId;
                }

                versionParameters->bIDEDeviceMap = deviceNumber;

                status = SRB_STATUS_SUCCESS;
                break;
            }

            case IOCTL_SCSI_MINIPORT_IDENTIFY: {

                PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                SENDCMDINPARAMS   cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                ULONG             i;
                UCHAR             targetId;


                if (cmdInParameters.irDriveRegs.bCommandReg == ID_CMD) {

                    //
                    // Extract the target.
                    //

                    targetId = cmdInParameters.bDriveNumber;

                    if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) ||
                         (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE)) {

                        status = SRB_STATUS_SELECTION_TIMEOUT;
                        break;
                    }

                    //
                    // Zero the output buffer
                    //

                    for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE - 1); i++) {
                        ((PUCHAR)cmdOutParameters)[i] = 0;
                    }

                    //
                    // Build status block.
                    //

                    cmdOutParameters->cBufferSize = IDENTIFY_BUFFER_SIZE;
                    cmdOutParameters->DriverStatus.bDriverError = 0;
                    cmdOutParameters->DriverStatus.bIDEError = 0;

                    //
                    // Extract the identify data from the device extension.
                    //

                    ScsiPortMoveMemory (cmdOutParameters->bBuffer, &deviceExtension->IdentifyData[targetId], IDENTIFY_DATA_SIZE);

                    status = SRB_STATUS_SUCCESS;


                } else {
                    status = SRB_STATUS_INVALID_REQUEST;
                }
                break;
            }

            case  IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS:
            case  IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS:
            case  IOCTL_SCSI_MINIPORT_ENABLE_SMART:
            case  IOCTL_SCSI_MINIPORT_DISABLE_SMART:
            case  IOCTL_SCSI_MINIPORT_RETURN_STATUS:
            case  IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE:
            case  IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES:
            case  IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS:

                status = IdeSendSmartCommand(HwDeviceExtension,Srb);
                break;

            default :

                status = SRB_STATUS_INVALID_REQUEST;
                break;

        }

        break;

    default:

        //
        // Indicate unsupported command.
        //

        status = SRB_STATUS_INVALID_REQUEST;

        break;

    } // end switch

    //
    // Check if command complete.
    //

    if (status != SRB_STATUS_PENDING) {

        DebugPrint((2,
                   "AtapiStartIo: Srb %x complete with status %x\n",
                   Srb,
                   status));

        //
        // Clear current SRB.
        //

        deviceExtension->CurrentSrb = NULL;

        //
        // Set status in SRB.
        //

        Srb->SrbStatus = (UCHAR)status;

        //
        // Indicate command complete.
        //

        ScsiPortNotification(RequestComplete,
                             deviceExtension,
                             Srb);

        //
        // Indicate ready for next request.
        //

        ScsiPortNotification(NextRequest,
                             deviceExtension,
                             NULL);
    }

    return TRUE;

} // end AtapiStartIo()


ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Installable driver initialization entry point for system.

Arguments:

    Driver Object

Return Value:

    Status from ScsiPortInitialize()

--*/

{
    HW_INITIALIZATION_DATA  hwInitializationData;
//    ULONG                  adapterCount;
    ULONG                   i;
    ULONG                   statusToReturn, newStatus;
    FIND_STATE              findState;
    ULONG                   AdapterAddresses[5] = {0x1F0, 0x170, 0x1e8, 0x168, 0};
    ULONG                   InterruptLevels[5]  = {   14,    15,    11,    10, 0};
    BOOLEAN                 IoAddressUsed[5]    = {FALSE, FALSE, FALSE, FALSE, 0};

    DebugPrint((1,"\n\nATAPI IDE MiniPort Driver\n"));

    DebugPrintTickCount();

    statusToReturn = 0xffffffff;

    //
    // Zero out structure.
    //

    AtapiZeroMemory(((PUCHAR)&hwInitializationData), sizeof(HW_INITIALIZATION_DATA));

    AtapiZeroMemory(((PUCHAR)&findState), sizeof(FIND_STATE));


    findState.DefaultIoPort    = AdapterAddresses;
    findState.DefaultInterrupt = InterruptLevels;
    findState.IoAddressUsed    = IoAddressUsed;

    //
    // Set size of hwInitializationData.
    //

    hwInitializationData.HwInitializationDataSize =
      sizeof(HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitializationData.HwInitialize = AtapiHwInitialize;
    hwInitializationData.HwResetBus = AtapiResetController;
    hwInitializationData.HwStartIo = AtapiStartIo;
    hwInitializationData.HwInterrupt = AtapiInterrupt;

    //
    // Specify size of extensions.
    //

    hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    hwInitializationData.SpecificLuExtensionSize = sizeof(HW_LU_EXTENSION);

    hwInitializationData.NumberOfAccessRanges = 6;
    hwInitializationData.HwFindAdapter = AtapiFindController;

    hwInitializationData.AdapterInterfaceType = Isa;
    findState.ControllerParameters            = PciControllerParameters;

    newStatus = ScsiPortInitialize(DriverObject,
                                   Argument2,
                                   &hwInitializationData,
                                   &findState);
    if (newStatus < statusToReturn)
        statusToReturn = newStatus;


    //
    // Set up for MCA
    //

    hwInitializationData.AdapterInterfaceType = MicroChannel;

    newStatus =  ScsiPortInitialize(DriverObject,
                                    Argument2,
                                    &hwInitializationData,
                                    &findState);
    if (newStatus < statusToReturn)
        statusToReturn = newStatus;

    DebugPrintTickCount();

    return statusToReturn;

} // end DriverEntry()



LONG
AtapiStringCmp (
    PCHAR FirstStr,
    PCHAR SecondStr,
    ULONG Count
    )
{
    UCHAR  first ,last;

    if (Count) {
        do {

            //
            // Get next char.
            //

            first = *FirstStr++;
            last = *SecondStr++;

            if (first != last) {

                //
                // If no match, try lower-casing.
                //

                if (first>='A' && first<='Z') {
                    first = first - 'A' + 'a';
                }
                if (last>='A' && last<='Z') {
                    last = last - 'A' + 'a';
                }
                if (first != last) {

                    //
                    // No match
                    //

                    return first - last;
                }
            }
        }while (--Count && first);
    }

    return 0;
}


VOID
AtapiZeroMemory(
    IN PCHAR Buffer,
    IN ULONG Count
    )
{
    ULONG i;

    for (i = 0; i < Count; i++) {
        Buffer[i] = 0;
    }
}


VOID
AtapiHexToString (
    IN ULONG Value,
    IN OUT PCHAR *Buffer
    )
{
    PCHAR  string;
    PCHAR  firstdig;
    CHAR   temp;
    ULONG i;
    USHORT digval;

    string = *Buffer;

    firstdig = string;

    for (i = 0; i < 4; i++) {
        digval = (USHORT)(Value % 16);
        Value /= 16;

        //
        // convert to ascii and store. Note this will create
        // the buffer with the digits reversed.
        //

        if (digval > 9) {
            *string++ = (char) (digval - 10 + 'a');
        } else {
            *string++ = (char) (digval + '0');
        }

    }

    //
    // Reverse the digits.
    //

    *string-- = '\0';

    do {
        temp = *string;
        *string = *firstdig;
        *firstdig = temp;
        --string;
        ++firstdig;
    } while (firstdig < string);
}



PSCSI_REQUEST_BLOCK
BuildMechanismStatusSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;

    srb = &deviceExtension->InternalSrb;

    AtapiZeroMemory((PUCHAR) srb, sizeof(SCSI_REQUEST_BLOCK));

    srb->PathId     = (UCHAR) PathId;
    srb->TargetId   = (UCHAR) TargetId;
    srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
    srb->Length     = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set flags to disable synchronous negociation.
    //
    srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set timeout to 2 seconds.
    //
    srb->TimeOutValue = 4;

    srb->CdbLength          = 6;
    srb->DataBuffer         = &deviceExtension->MechStatusData;
    srb->DataTransferLength = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

    //
    // Set CDB operation code.
    //
    cdb = (PCDB)srb->Cdb;
    cdb->MECH_STATUS.OperationCode       = SCSIOP_MECHANISM_STATUS;
    cdb->MECH_STATUS.AllocationLength[1] = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

    return srb;
}


PSCSI_REQUEST_BLOCK
BuildRequestSenseSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;

    srb = &deviceExtension->InternalSrb;

    AtapiZeroMemory((PUCHAR) srb, sizeof(SCSI_REQUEST_BLOCK));

    srb->PathId     = (UCHAR) PathId;
    srb->TargetId   = (UCHAR) TargetId;
    srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
    srb->Length     = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set flags to disable synchronous negociation.
    //
    srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set timeout to 2 seconds.
    //
    srb->TimeOutValue = 4;

    srb->CdbLength          = 6;
    srb->DataBuffer         = &deviceExtension->MechStatusSense;
    srb->DataTransferLength = sizeof(SENSE_DATA);

    //
    // Set CDB operation code.
    //
    cdb = (PCDB)srb->Cdb;
    cdb->CDB6INQUIRY.OperationCode    = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.AllocationLength = sizeof(SENSE_DATA);

    return srb;
}


BOOLEAN
PrepareForBusMastering(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Get ready for IDE bus mastering

    init. PDRT
    init. bus master controller but keep it disabled

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    Srb                 - scsi request block

Return Value:

    TRUE if successful
    FALSE if failed

--*/
{
    PHW_DEVICE_EXTENSION        deviceExtension = HwDeviceExtension;
    SCSI_PHYSICAL_ADDRESS       physAddr;
    ULONG                       bytesMapped;
    ULONG                       bytes;
    PUCHAR                      buffer;
    PPHYSICAL_REGION_DESCRIPTOR physAddrTablePtr;
    ULONG                       physAddrTableIndex;
    PIDE_BUS_MASTER_REGISTERS   busMasterBase;

    busMasterBase = deviceExtension->BusMasterPortBase[Srb->TargetId >> 1];

    buffer = Srb->DataBuffer;
    physAddrTablePtr = deviceExtension->DataBufferDescriptionTablePtr;
    physAddrTableIndex = 0;
    bytesMapped = 0;
    DebugPrint ((2, "ATAPI: Mapping 0x%x bytes\n", Srb->DataTransferLength));

    //
    // PDRT has these limitation
    //    each entry maps up to is 64K bytes
    //    each physical block mapped cannot cross 64K page boundary
    //
    while (bytesMapped < Srb->DataTransferLength) {
        ULONG bytesLeft;
        ULONG nextPhysicalAddr;
        ULONG bytesLeftInCurrent64KPage;

        physAddr = ScsiPortGetPhysicalAddress(HwDeviceExtension,
                                              Srb,
                                              buffer,
                                              &bytes);

        bytesLeft = bytes;
        nextPhysicalAddr = ScsiPortConvertPhysicalAddressToUlong(physAddr);
        while (bytesLeft > 0) {
            physAddrTablePtr[physAddrTableIndex].PhyscialAddress = nextPhysicalAddr;

            bytesLeftInCurrent64KPage = (0x10000 - (nextPhysicalAddr & 0xffff));

            if (bytesLeftInCurrent64KPage < bytesLeft) {

                //
                // Are we crossing 64K page
                // got to break it up.  Map up to the 64k boundary
                //
                physAddrTablePtr[physAddrTableIndex].ByteCount = bytesLeftInCurrent64KPage;
                bytesLeft -= bytesLeftInCurrent64KPage;
                nextPhysicalAddr += bytesLeftInCurrent64KPage;
                DebugPrint ((3, "PrepareForBusMastering: buffer crossing 64K Page!\n"));

            } else if (bytesLeft <= 0x10000) {
                //
                // got a perfect page, map all of it
                //
                physAddrTablePtr[physAddrTableIndex].ByteCount = bytesLeft & 0xfffe;
                bytesLeft = 0;
                nextPhysicalAddr += bytesLeft;

            } else {
                //
                // got a perfectly aligned 64k page, map all of it but the count
                // need to be 0
                //
                physAddrTablePtr[physAddrTableIndex].ByteCount = 0;  // 64K
                bytesLeft -= 0x10000;
                nextPhysicalAddr += 0x10000;
            }
        physAddrTablePtr[physAddrTableIndex].EndOfTable = 0;  // not end of table
        physAddrTableIndex++;
        }
        bytesMapped += bytes;
        buffer += bytes;
    }

    //
    // the bus master circutry need to know it hits the end of the PRDT
    //
    physAddrTablePtr[physAddrTableIndex - 1].EndOfTable = 1;  // end of table

    //
    // init bus master contoller, but keep it disabled
    //
    ScsiPortWritePortUchar (&busMasterBase->Command, 0);  // disable BM
    ScsiPortWritePortUchar (&busMasterBase->Status, 0x6);  // clear errors
    ScsiPortWritePortUlong (&busMasterBase->DescriptionTable,
        ScsiPortConvertPhysicalAddressToUlong(deviceExtension->DataBufferDescriptionTablePhysAddr));

    return TRUE;
}


BOOLEAN
EnableBusMastering(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Enable bus mastering contoller

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    Srb                 - scsi request block

Return Value:

    always TRUE

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_BUS_MASTER_REGISTERS busMasterBase;
    UCHAR bmStatus = 0;

    busMasterBase = deviceExtension->BusMasterPortBase[Srb->TargetId >> 1];

    deviceExtension->DMAInProgress = TRUE;

    //
    // inidcate we are doing DMA
    //
    if (Srb->TargetId == 0)
        bmStatus = BUSMASTER_DEVICE0_DMA_OK;
    else
        bmStatus = BUSMASTER_DEVICE1_DMA_OK;

    //
    // clear the status bit
    //
    bmStatus |= BUSMASTER_INTERRUPT | BUSMASTER_ERROR;

    ScsiPortWritePortUchar (&busMasterBase->Status, bmStatus);

    //
    // on your mark...get set...go!!
    //
    if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {
        ScsiPortWritePortUchar (&busMasterBase->Command, 0x09);  // enable BM read
    } else {
        ScsiPortWritePortUchar (&busMasterBase->Command, 0x01);  // enable BM write
    }

    DebugPrint ((2, "ATAPI: BusMaster Status = 0x%x\n", ScsiPortReadPortUchar (&busMasterBase->Status)));

    return TRUE;
}



ULONG
GetPciBusData(
    IN PVOID                  HwDeviceExtension,
    IN ULONG                  SystemIoBusNumber,
    IN PCI_SLOT_NUMBER        SlotNumber,
    OUT PVOID                 PciConfigBuffer,
    IN ULONG                  NumByte
    )
/*++

Routine Description:

    read PCI bus data

    we can't always use ScsiPortSetBusDataByOffset directly because many Intel PIIXs
    are "hidden" from the function.  The PIIX is usually the second
    function of some other pci device (PCI-ISA bridge).  However, the
    mulit-function bit of the PCI-Isa bridge is not set. ScsiportGetBusData
    will not be able to find it.

    This function will try to figure out if we have the "bad" PCI-ISA bridge,
    and read the PIIX PCI space directly if necessary

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    SystemIoBusNumber   - bus number
    SlotNumber          - pci slot and function numbers
    PciConfigBuffer     = pci data pointer

Return Value:

    byte returned

--*/
{
    ULONG           byteRead;
    PULONG          pciAddrReg;
    PULONG          pciDataReg;
    ULONG           i;
    ULONG           j;
    ULONG           data;
    PULONG          dataBuffer;

    USHORT          vendorId;
    USHORT          deviceId;
    UCHAR           headerType;

    //
    // If we have a hidden PIIX, it is always a function 1 of
    // some device (PCI-ISA bridge (0x8086\0x122e)
    // If we are NOT looking at function 1, skip the extra work
    //
    if (!AtapiPlaySafe && (SlotNumber.u.bits.FunctionNumber == 1)) {

        pciAddrReg = (PULONG) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                    PCIBus,
                                                    0,
                                                    ScsiPortConvertUlongToPhysicalAddress(PCI_ADDR_PORT),
                                                    4,
                                                    TRUE);
        pciDataReg = (PULONG) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                    PCIBus,
                                                    0,
                                                    ScsiPortConvertUlongToPhysicalAddress(PCI_DATA_PORT),
                                                    4,
                                                    TRUE);
    } else {
        pciAddrReg = pciDataReg = NULL;
    }

    if (pciAddrReg && pciDataReg) {
        //
        // get the vendor id and device id of the previous function
        //
        ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                       SlotNumber.u.bits.DeviceNumber,
                                                       SlotNumber.u.bits.FunctionNumber - 1,    // looking at last function
                                                       0));
        data = ScsiPortReadPortUlong(pciDataReg);
        vendorId = (USHORT) ((data >>  0) & 0xffff);
        deviceId = (USHORT) ((data >> 16) & 0xffff);

        ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                       SlotNumber.u.bits.DeviceNumber,
                                                       SlotNumber.u.bits.FunctionNumber - 1,    // looking at last function
                                                       3));
        data = ScsiPortReadPortUlong(pciDataReg);
        headerType = (UCHAR) ((data >> 16) & 0xff);

    } else {
        vendorId = PCI_INVALID_VENDORID;
    }

    //
    // The hidden PIIX is the pci function after the PCI-ISA bridge
    // When it is hidden, the PCI-ISA bridge PCI_MULTIFUNCTION bit is not set
    //
    byteRead = 0;
    if ((vendorId == 0x8086) &&                 // Intel
        (deviceId == 0x122e) &&                 // PCI-ISA Bridge
        !(headerType & PCI_MULTIFUNCTION)) {

        DebugPrint ((1, "ATAPI: found the hidden PIIX\n"));

        if (pciDataReg && pciAddrReg) {

            for (i=0, dataBuffer = (PULONG) PciConfigBuffer;
                 i < NumByte / 4;
                 i++, dataBuffer++) {
                ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                               SlotNumber.u.bits.DeviceNumber,
                                                               SlotNumber.u.bits.FunctionNumber,
                                                               i));
                dataBuffer[0] = ScsiPortReadPortUlong(pciDataReg);
            }

            if (NumByte % 4) {
                ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                               SlotNumber.u.bits.DeviceNumber,
                                                               SlotNumber.u.bits.FunctionNumber,
                                                               i));
                data = ScsiPortReadPortUlong(pciDataReg);
    
                for (j=0; j <NumByte%4; j++) {
                    ((PUCHAR)dataBuffer)[j] = (UCHAR) (data & 0xff);
                    data = data >> 8;
                }
            }
            byteRead = NumByte;
        }

        if ((((PPCI_COMMON_CONFIG)PciConfigBuffer)->VendorID != 0x8086) ||                 // Intel
            (((PPCI_COMMON_CONFIG)PciConfigBuffer)->DeviceID != 0x1230)) {                 // PIIX

            //
            // If the hidden device is not Intel PIIX, don't
            // show it
            //
            byteRead = 0;
        } else {
            DebugPrint ((0, "If we play safe, we would NOT detect hidden PIIX controller\n"));
        }

    }

    if (!byteRead) {
        //
        // Didn't find any hidden PIIX.  Get the PCI
        // data via the normal call (ScsiPortGetBusData)
        //
        byteRead = ScsiPortGetBusData(HwDeviceExtension,
                                      PCIConfiguration,
                                      SystemIoBusNumber,
                                      SlotNumber.u.AsULONG,
                                      PciConfigBuffer,
                                      NumByte);
    }

    if (pciAddrReg)
        ScsiPortFreeDeviceBase(HwDeviceExtension, pciAddrReg);
    if (pciDataReg)
        ScsiPortFreeDeviceBase(HwDeviceExtension, pciDataReg);

    return byteRead;
}


ULONG
SetPciBusData(
    IN PVOID              HwDeviceExtension,
    IN ULONG              SystemIoBusNumber,
    IN PCI_SLOT_NUMBER    SlotNumber,
    IN PVOID              Buffer,
    IN ULONG              Offset,
    IN ULONG              Length
    )
/*++

Routine Description:

    set PCI bus data

    we can't always use ScsiPortSetBusDataByOffset directly because many Intel PIIXs
    are "hidden" from the function.  The PIIX is usually the second
    function of some other pci device (PCI-ISA bridge).  However, the
    mulit-function bit of the PCI-Isa bridge is not set. ScsiPortSetBusDataByOffset
    will not be able to find it.

    This function will try to figure out if we have the "bad" PCI-ISA bridge,
    and write to the PIIX PCI space directly if necessary

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    SystemIoBusNumber   - bus number
    SlotNumber          - pci slot and function numbers
    Buffer              - pci data buffer
    Offset              - byte offset into the pci space
    Length              - number of bytes to write

Return Value:

    byte written

--*/
{
    ULONG           byteWritten;
    PULONG          pciAddrReg;
    PULONG          pciDataReg;
    ULONG           i;
    ULONG           j;
    ULONG           data;
    PULONG          dataBuffer;

    USHORT          vendorId;
    USHORT          deviceId;
    UCHAR           headerType;

    //
    // If we have a hidden PIIX, it is always a function 1 of
    // some device (PCI-ISA bridge (0x8086\0x122e)
    // If we are NOT looking at function 1, skip the extra work
    //
    if (!AtapiPlaySafe && (SlotNumber.u.bits.FunctionNumber == 1)) {

        pciAddrReg = (PULONG) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                    PCIBus,
                                                    0,
                                                    ScsiPortConvertUlongToPhysicalAddress(PCI_ADDR_PORT),
                                                    4,
                                                    TRUE);
        pciDataReg = (PULONG) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                    PCIBus,
                                                    0,
                                                    ScsiPortConvertUlongToPhysicalAddress(PCI_DATA_PORT),
                                                    4,
                                                    TRUE);
    } else {
        pciAddrReg = pciDataReg = NULL;
    }

    if (pciAddrReg && pciDataReg) {
        //
        // get the vendor id and device id of the previous function
        //
        ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                       SlotNumber.u.bits.DeviceNumber,
                                                       SlotNumber.u.bits.FunctionNumber - 1,    // looking at last function
                                                       0));
        data = ScsiPortReadPortUlong(pciDataReg);
        vendorId = (USHORT) ((data >>  0) & 0xffff);
        deviceId = (USHORT) ((data >> 16) & 0xffff);

        ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                       SlotNumber.u.bits.DeviceNumber,
                                                       SlotNumber.u.bits.FunctionNumber - 1,    // looking at last function
                                                       3));
        data = ScsiPortReadPortUlong(pciDataReg);
        headerType = (UCHAR) ((data >> 16) & 0xff);

    } else {
        vendorId = PCI_INVALID_VENDORID;
    }

    //
    // The hidden PIIX is the pci function after the PCI-ISA bridge
    // When it is hidden, the PCI-ISA bridge PCI_MULTIFUNCTION bit is not set
    //
    byteWritten = 0;
    if ((vendorId == 0x8086) &&                 // Intel
        (deviceId == 0x122e) &&                 // PCI-ISA Bridge
        !(headerType & PCI_MULTIFUNCTION)) {

        ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                       SlotNumber.u.bits.DeviceNumber,
                                                       SlotNumber.u.bits.FunctionNumber,
                                                       0));
        data = ScsiPortReadPortUlong(pciDataReg);
        vendorId = (USHORT) ((data >>  0) & 0xffff);
        deviceId = (USHORT) ((data >> 16) & 0xffff);

        if ((vendorId == 0x8086) &&                 // Intel
            (deviceId == 0x1230)) {                 // PIIX

            PCI_COMMON_CONFIG pciData;

            //
            // read the same range of data in first
            //
            for (i=0, dataBuffer = (((PULONG) &pciData) + Offset/4);
                 i<(Length+3)/4;
                 i++, dataBuffer++) {
                ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                               SlotNumber.u.bits.DeviceNumber,
                                                               SlotNumber.u.bits.FunctionNumber,
                                                               i + Offset/4));
                data = ScsiPortReadPortUlong(pciDataReg);
                if (i < (Length/4)) {
                    dataBuffer[0] = data;
                } else {
                    for (j=0; j < Length%4; j++) {
                        ((PUCHAR)dataBuffer)[j] = (UCHAR) (data & 0xff);
                        data = data >> 8;
                    }
                }
            }

            //
            // Copy the new data over
            //
            for (i = 0; i<Length; i++) {
                ((PUCHAR)&pciData)[i + Offset] = ((PUCHAR)Buffer)[i];
            }

            //
            // write out the same range of data
            //
            for (i=0, dataBuffer = (((PULONG) &pciData) + Offset/4);
                 i<(Length+3)/4;
                 i++, dataBuffer++) {
                ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                               SlotNumber.u.bits.DeviceNumber,
                                                               SlotNumber.u.bits.FunctionNumber,
                                                               i + Offset/4));
                ScsiPortWritePortUlong(pciDataReg, dataBuffer[0]);
            }

            byteWritten = Length;

        } else {

            // If the hidden device is not Intel PIIX, don't
            // write to it
            byteWritten = 0;
        }

    }

    if (!byteWritten) {
        //
        // Didn't find any hidden PIIX.  Write to the PCI
        // space via the normal call (ScsiPortSetBusDataByOffset)
        //
        byteWritten = ScsiPortSetBusDataByOffset(HwDeviceExtension,
                                                 PCIConfiguration,
                                                 SystemIoBusNumber,
                                                 SlotNumber.u.AsULONG,
                                                 Buffer,
                                                 Offset,
                                                 Length);
    }

    if (pciAddrReg)
        ScsiPortFreeDeviceBase(HwDeviceExtension, pciAddrReg);
    if (pciDataReg)
        ScsiPortFreeDeviceBase(HwDeviceExtension, pciDataReg);

    return byteWritten;
}

BOOLEAN
ChannelIsAlwaysEnabled (
    PPCI_COMMON_CONFIG PciData,
    ULONG Channel)
/*++

Routine Description:

    dummy routine that always returns TRUE

Arguments:

    PPCI_COMMON_CONFIG  - pci config data
    Channel             - ide channel number

Return Value:

    TRUE

--*/
{
    return TRUE;
}

VOID
SetBusMasterDetectionLevel (
    IN PVOID HwDeviceExtension,
    IN PCHAR userArgumentString
    )
/*++

Routine Description:

    check whether we should try to enable bus mastering

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    ArgumentString      - register arguments

Return Value:

    TRUE

--*/
{
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    BOOLEAN                 useBM;

    ULONG                   pciBusNumber;
    PCI_SLOT_NUMBER         pciSlot;
    ULONG                   slotNumber;
    ULONG                   logicalDeviceNumber;
    PCI_COMMON_CONFIG       pciData;
    ULONG                   DMADetectionLevel;

    useBM = TRUE;

    DMADetectionLevel = AtapiParseArgumentString(userArgumentString, "DMADetectionLevel");
    if (DMADetectionLevel == DMADETECT_SAFE) {
        AtapiPlaySafe = TRUE;
    } else if (DMADetectionLevel == DMADETECT_UNSAFE) {
        AtapiPlaySafe = FALSE;
    } else { // default is no busmastering
        useBM = FALSE;
    }


    //
    // search for bad chip set
    //
    for (pciBusNumber=0;
         pciBusNumber < 256 && useBM;
         pciBusNumber++) {

        pciSlot.u.AsULONG = 0;

        for (slotNumber=0;
             slotNumber < PCI_MAX_DEVICES && useBM;
             slotNumber++) {

            pciSlot.u.bits.DeviceNumber = slotNumber;

            for (logicalDeviceNumber=0;
                 logicalDeviceNumber < PCI_MAX_FUNCTION && useBM;
                 logicalDeviceNumber++) {

                pciSlot.u.bits.FunctionNumber = logicalDeviceNumber;

                if (!GetPciBusData(HwDeviceExtension,
                                   pciBusNumber,
                                   pciSlot,
                                   &pciData,
                                   offsetof (PCI_COMMON_CONFIG, DeviceSpecific)
                                   )) {
                    break;
                }

                if (pciData.VendorID == PCI_INVALID_VENDORID) {
                    break;
                }

                if ((pciData.VendorID == 0x8086) && // Intel
                    (pciData.DeviceID == 0x84c4) && // 82450GX/KX Pentium Pro Processor to PCI bridge
                    (pciData.RevisionID < 0x4)) {   // Stepping less than 4

                    DebugPrint((1,
                                "atapi: Find a bad Intel processor-pci bridge.  Disable PCI IDE busmastering...\n"));
                    useBM = FALSE;
                }
            }
        }
    }

    deviceExtension->UseBusMasterController = useBM;
    DebugPrint ((0, "ATAPI: UseBusMasterController = %d\n", deviceExtension->UseBusMasterController));

    if (deviceExtension->UseBusMasterController) {
        DebugPrint ((0, "ATAPI: AtapiPlaySafe = %d\n", AtapiPlaySafe));
    }

    return;
}



UCHAR PioDeviceModelNumber[][41] = {
    {"    Conner Peripherals 425MB - CFS425A   "},
    {"MATSHITA CR-581                          "},
    {"FX600S                                   "},
    {"CD-44E                                   "},
    {"QUANTUM TRB850A                          "},
    {"QUANTUM MARVERICK 540A                   "},
    {" MAXTOR MXT-540  AT                      "},
    {"Maxtor 71260 AT                          "},
    {"Maxtor 7850 AV                           "},
    {"Maxtor 7540 AV                           "},
    {"Maxtor 7213 AT                           "},
    {"Maxtor 7345                              "},
    {"Maxtor 7245 AT                           "},
    {"Maxtor 7245                              "},
    {"Maxtor 7211AU                            "},
    {"Maxtor 7171 AT                           "}
};
#define NUMBER_OF_PIO_DEVICES (sizeof(PioDeviceModelNumber) / (sizeof(UCHAR) * 41))

UCHAR SpecialWDDevicesFWVersion[][9] = {
    {"14.04E28"},
    {"25.26H35"},
    {"26.27J38"},
    {"27.25C38"},
    {"27.25C39"}
};
#define NUMBER_OF_SPECIAL_WD_DEVICES (sizeof(SpecialWDDevicesFWVersion) / (sizeof (UCHAR) * 9))

BOOLEAN
AtapiDeviceDMACapable (
    IN PVOID HwDeviceExtension,
    IN ULONG deviceNumber
    )
/*++

Routine Description:

    check the given device whether it is on our bad device list (non dma device)

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    deviceNumber        - device number

Return Value:

    TRUE if dma capable
    FALSE if not dma capable

--*/
{
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    UCHAR modelNumber[41];
    UCHAR firmwareVersion[9];
    ULONG i;
    BOOLEAN turnOffDMA = FALSE;
    PCI_SLOT_NUMBER     pciSlot;
    PCI_COMMON_CONFIG   pciData;

    if (!(deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT)) {
        return FALSE;
    }

    for (i=0; i<40; i+=2) {
        modelNumber[i + 0] = deviceExtension->IdentifyData[deviceNumber].ModelNumber[i + 1];
        modelNumber[i + 1] = deviceExtension->IdentifyData[deviceNumber].ModelNumber[i + 0];
    }
    modelNumber[i] = 0;

    for (i=0; i<NUMBER_OF_PIO_DEVICES; i++) {
        if (!AtapiStringCmp(modelNumber, PioDeviceModelNumber[i], 40)) {

            DebugPrint ((0, "ATAPI: device on the hall of shame list.  no DMA!\n"));

            turnOffDMA = TRUE;
        }
    }

    //
    // if we have a Western Digial device
    //     if the best dma mode is multi word dma mode 1
    //         if the identify data word offset 129 is not 0x5555
    //            turn off dma unless
    //            if the device firmware version is on the list and
    //            it is the only drive on the bus
    //
    if (!AtapiStringCmp(modelNumber, "WDC", 3)) {
        if (deviceExtension->DeviceParameters[deviceNumber].BestMultiWordDMAMode == 1) {

            for (i=0; i<8; i+=2) {
                firmwareVersion[i + 0] = deviceExtension->IdentifyData[deviceNumber].FirmwareRevision[i + 1];
                firmwareVersion[i + 1] = deviceExtension->IdentifyData[deviceNumber].FirmwareRevision[i + 0];
            }
            firmwareVersion[i] = 0;

            //
            // Check the special flag.  If not found, can't use dma
            //
            if (*(((PUSHORT)&deviceExtension->IdentifyData[deviceNumber]) + 129) != 0x5555) {

                DebugPrint ((0, "ATAPI: found mode 1 WD drive. no dma unless it is the only device\n"));

                turnOffDMA = TRUE;

                for (i=0; i<NUMBER_OF_SPECIAL_WD_DEVICES; i++) {

                    if (!AtapiStringCmp(firmwareVersion, SpecialWDDevicesFWVersion[i], 8)) {

                        ULONG otherDeviceNumber;

                        //
                        // 0 becomes 1
                        // 1 becomes 0
                        // 2 becomes 3
                        // 3 becomes 2
                        //
                        otherDeviceNumber = ((deviceNumber & 0x2) | ((deviceNumber & 0x1) ^ 1));

                        //
                        // if the device is alone on the bus, we can use dma
                        //
                        if (!(deviceExtension->DeviceFlags[otherDeviceNumber] & DFLAGS_DEVICE_PRESENT)) {
                            turnOffDMA = FALSE;
                            break;
                        }
                    }
                }
            }
        }
    }

    //
    // ALi IDE controller cannot busmaster with an ATAPI device
    //
    pciSlot.u.AsULONG = 0;
    pciSlot.u.bits.DeviceNumber = deviceExtension->PciDeviceNumber;
    pciSlot.u.bits.FunctionNumber = deviceExtension->PciLogDevNumber;
                
    if (GetPciBusData(HwDeviceExtension,
                           deviceExtension->PciBusNumber,
                           pciSlot,
                           &pciData,
                           offsetof (PCI_COMMON_CONFIG, DeviceSpecific)
                           )) {

        if ((pciData.VendorID == 0x10b9) &&
            (pciData.DeviceID == 0x5219)) {

            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE) {

                DebugPrint ((0, "ATAPI: Can't do DMA because we have a ALi controller and a ATAPI device\n"));

                turnOffDMA = TRUE;



            }
        }
    }

    if (turnOffDMA) {
        return FALSE;
    } else {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\aha154x\wmi.c ===
#include "miniport.h"
#include "aha154x.h"           // includes scsi.h
#include "wmistr.h"             // WMI definitions

#include "support.h"           // ScsiPortZeroMemory(), ScsiPortCompareMemory()
#include "aha154dt.h"

#define Aha154xWmi_MofResourceName        L"MofResource"

#define AHA154x_SETUP_GUID_INDEX 0

GUID A154xWmiSetupDataGuid = Aha154xWmi_SetupData_Guid;

UCHAR
A154xReadSetupData(
   IN  PHW_DEVICE_EXTENSION HwDeviceExtension,
   OUT PUCHAR               Buffer
   );

BOOLEAN
A154xQueryWmiDataBlock(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    );

UCHAR
A154xQueryWmiRegInfo(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    OUT PWCHAR *MofResourceName
    );

SCSIWMIGUIDREGINFO A154xGuidList[] =
{
   {&A154xWmiSetupDataGuid,
    1,
    0
   },
};

#define A154xGuidCount (sizeof(A154xGuidList) / sizeof(SCSIWMIGUIDREGINFO))


void A154xWmiInitialize(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    PSCSI_WMILIB_CONTEXT WmiLibContext;

    WmiLibContext = &HwDeviceExtension->WmiLibContext;

    WmiLibContext->GuidList = A154xGuidList;
    WmiLibContext->GuidCount = A154xGuidCount;
    WmiLibContext->QueryWmiRegInfo = A154xQueryWmiRegInfo;
    WmiLibContext->QueryWmiDataBlock = A154xQueryWmiDataBlock;
    WmiLibContext->SetWmiDataItem = NULL;
    WmiLibContext->SetWmiDataBlock = NULL;
    WmiLibContext->WmiFunctionControl = NULL;
    WmiLibContext->ExecuteWmiMethod = NULL;
}



BOOLEAN
A154xWmiSrb(
    IN     PHW_DEVICE_EXTENSION    HwDeviceExtension,
    IN OUT PSCSI_WMI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

   Process an SRB_FUNCTION_WMI request packet.

   This routine is called from the SCSI port driver synchronized with the
   kernel via Aha154xStartIo.   On completion of WMI processing, the SCSI
   port driver is notified that the adapter can take another request,  if
   any are available.

Arguments:

   HwDeviceExtension - HBA miniport driver's adapter data storage.

   Srb               - IO request packet.

Return Value:

   Value to return to Aha154xStartIo caller.   Always TRUE.

--*/
{
   UCHAR status;
   SCSIWMI_REQUEST_CONTEXT requestContext;
   ULONG retSize;
   BOOLEAN pending;

   //
   // Validate our assumptions.
   //

   ASSERT(Srb->Function == SRB_FUNCTION_WMI);
   ASSERT(Srb->Length == sizeof(SCSI_WMI_REQUEST_BLOCK));
   ASSERT(Srb->DataTransferLength >= sizeof(ULONG));
   ASSERT(Srb->DataBuffer);

   //
   // Check if the WMI SRB is targetted for the adapter or one of the disks
   if (!(Srb->WMIFlags & SRB_WMI_FLAGS_ADAPTER_REQUEST)) {

      //
      // This is targetted to one of the disks, since there are no per disk
      // wmi information we return an error. Note that if there was per
      // disk information, then you'd likely have a differen WmiLibContext
      // and a different set of guids.
      //
      Srb->DataTransferLength = 0;
      Srb->SrbStatus = SRB_STATUS_SUCCESS;

   } else {

       //
       // Process the incoming WMI request.
       //

       pending = ScsiPortWmiDispatchFunction(&HwDeviceExtension->WmiLibContext,
                                                Srb->WMISubFunction,
                                                HwDeviceExtension,
                                                &requestContext,
                                                Srb->DataPath,
                                                Srb->DataTransferLength,
                                                Srb->DataBuffer);

       //
       // We assune that the wmi request will never pend so that we can
       // allocate the requestContext from stack. If the WMI request could
       // ever pend then we'd need to allocate the request context from
       // the SRB extension.
       //
       ASSERT(! pending);

       retSize =  ScsiPortWmiGetReturnSize(&requestContext);
       status =  ScsiPortWmiGetReturnStatus(&requestContext);

       // We can do this since we assume it is done synchronously

       Srb->DataTransferLength = retSize;

       //
       // Adapter ready for next request.
       //

       Srb->SrbStatus = status;
   }

   ScsiPortNotification(RequestComplete, HwDeviceExtension, Srb);
   ScsiPortNotification(NextRequest,     HwDeviceExtension, NULL);

   return TRUE;
}



BOOLEAN
A154xQueryWmiDataBlock(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the miniport to query for the contents of
    one or more instances of a data block. This callback may be called with
    an output buffer that is too small to return all of the data queried.
    In this case the callback is responsible to report the correct output
        buffer size needed.

    If the request can be completed immediately without pending,
        ScsiPortWmiPostProcess should be called from within this callback and
    FALSE returned.

    If the request cannot be completed within this callback then TRUE should
    be returned. Once the pending operations are finished the miniport should
    call ScsiPortWmiPostProcess and then complete the srb.

Arguments:

    DeviceContext is a caller specified context value originally passed to
        ScsiPortWmiDispatchFunction.

    RequestContext is a context associated with the srb being processed.

    GuidIndex is the index into the list of guids provided when the
        miniport registered

    InstanceIndex is the index that denotes first instance of the data block
        is being queried.

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. This may be NULL when
        there is not enough space in the output buffer to fufill the request.
        In this case the miniport should call ScsiPortWmiPostProcess with
        a status of SRB_STATUS_DATA_OVERRUN and the size of the output buffer
        needed to fufill the request.

    BufferAvail on entry has the maximum size available to write the data
        blocks in the output buffer. If the output buffer is not large enough
        to return all of the data blocks then the miniport should call
        ScsiPortWmiPostProcess with a status of SRB_STATUS_DATA_OVERRUN
        and the size of the output buffer needed to fufill the request.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry. This
        may be NULL when there is not enough space in the output buffer to
        fufill the request. In this case the miniport should call
        ScsiPortWmiPostProcess with a status of SRB_STATUS_DATA_OVERRUN and
        the size of the output buffer needed to fufill the request.


Return Value:

    TRUE if request is pending else FALSE

--*/
{
    PHW_DEVICE_EXTENSION HwDeviceExtension = (PHW_DEVICE_EXTENSION)Context;
    ULONG size = 0;
    UCHAR status;

    //
    // Only ever registers 1 instance per guid
    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));

    switch (GuidIndex)
    {
        case AHA154x_SETUP_GUID_INDEX:
        {
            size = sizeof(AHA154SetupData)-1;
            if (OutBufferSize < size)
            {
                //
                // The buffer passed to return the data is too small
                //
                status = SRB_STATUS_DATA_OVERRUN;
                break;
            }

            if ( !A154xReadSetupData(HwDeviceExtension,
                                     Buffer))
            {
                ASSERT(FALSE);
                size = 0;
                status = SRB_STATUS_ERROR;
            } else {
                *InstanceLengthArray = size;
                status = SRB_STATUS_SUCCESS;
            }

            break;
        }

        default:
        {
            status = SRB_STATUS_ERROR;
        }
    }

    ScsiPortWmiPostProcess(RequestContext,
                           status,
                           size);

    return status;
}

UCHAR
A154xQueryWmiRegInfo(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    OUT PWCHAR *MofResourceName
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    *MofResourceName = Aha154xWmi_MofResourceName;
    return SRB_STATUS_SUCCESS;
}


UCHAR
A154xReadSetupData(
   IN  PHW_DEVICE_EXTENSION HwDeviceExtension,
   OUT PUCHAR               Buffer
   )
/*++

Routine Description:

   Read the adapter setup information into the supplied buffer.  The buffer
   must be RM_CFG_MAX_SIZE (255) bytes large.

Arguments:

   HwDeviceExtension - HBA miniport driver's adapter data storage.

   Buffer - Buffer to hold adapter's setup information structure [manual 5-10].

Return Value:

   TRUE on success, FALSE on failure.

--*/
{
   UCHAR numberOfBytes = sizeof(AHA154SetupData)-1;

   //
   // Read off config data from AHA154X...
   //

   if (!WriteCommandRegister(HwDeviceExtension, AC_RETURN_SETUP_DATA, TRUE))
      return FALSE;

   if (!WriteDataRegister(HwDeviceExtension, numberOfBytes))
      return FALSE;

   for (; numberOfBytes; numberOfBytes--) {
      if (!(ReadCommandRegister(HwDeviceExtension, Buffer, TRUE)))
          return FALSE;
      Buffer++;
   }

   //
   // ...and wait for interrupt
   //

   if (!SpinForInterrupt(HwDeviceExtension, TRUE))
      return FALSE;

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hbaapi_sample\wmi.c ===
#include "miniport.h"
#include "aha154x.h"           // includes scsi.h
#include "wmistr.h"             // WMI definitions

#include "support.h"           // ScsiPortZeroMemory(), ScsiPortCompareMemory()
#include "hbapiwmi.h"

#define Aha154xWmi_MofResourceName        L"MofResource"

#define NUMBEROFPORTS   8

UCHAR
QueryWmiDataBlock(
    IN PVOID Context,
    IN PVOID DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    );

UCHAR
QueryWmiRegInfo(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    OUT PWCHAR *MofResourceName
    );
        
UCHAR
WmiFunctionControl (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN SCSIWMI_ENABLE_DISABLE_CONTROL Function,
    IN BOOLEAN Enable
    );

UCHAR
WmiExecuteMethod (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );

UCHAR
WmiSetDataItem (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

UCHAR
WmiSetDataBlock (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );


//
// Define symbolic names for the guid indexes
#define MSFC_FibrePortHBAStatisticsGuidIndex    0
#define MSFC_FibrePortHBAAttributesGuidIndex    1
#define MSFC_FibrePortHBAMethodsGuidIndex    2
#define MSFC_FCAdapterHBAAttributesGuidIndex    3
#define MSFC_HBAPortMethodsGuidIndex    4
#define MSFC_HBAFc3MgmtMethodsGuidIndex    5
#define MSFC_HBAFCPInfoGuidIndex    6
//
// List of guids supported

GUID MSFC_FibrePortHBAStatisticsGUID = MSFC_FibrePortHBAStatisticsGuid;
GUID MSFC_FibrePortHBAAttributesGUID = MSFC_FibrePortHBAAttributesGuid;
GUID MSFC_FibrePortHBAMethodsGUID = MSFC_FibrePortHBAMethodsGuid;
GUID MSFC_FCAdapterHBAAttributesGUID = MSFC_FCAdapterHBAAttributesGuid;
GUID MSFC_HBAPortMethodsGUID = MSFC_HBAPortMethodsGuid;
GUID MSFC_HBAFc3MgmtMethodsGUID = MSFC_HBAFc3MgmtMethodsGuid;
GUID MSFC_HBAFCPInfoGUID = MSFC_HBAFCPInfoGuid;

//
// TODO: Make sure the instance count and flags are set properly for each
//       guid
SCSIWMIGUIDREGINFO HbaapiGuidList[] =
{
    {
        &MSFC_FibrePortHBAStatisticsGUID,                        // Guid
        NUMBEROFPORTS,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_FibrePortHBAAttributesGUID,                        // Guid
        NUMBEROFPORTS,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_FibrePortHBAMethodsGUID,                        // Guid
        NUMBEROFPORTS,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_FCAdapterHBAAttributesGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_HBAPortMethodsGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_HBAFc3MgmtMethodsGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_HBAFCPInfoGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    }
};

#define HbaapiGuidCount (sizeof(HbaapiGuidList) / sizeof(SCSIWMIGUIDREGINFO))


void A154xWmiInitialize(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    PSCSI_WMILIB_CONTEXT WmiLibContext;

    WmiLibContext = &HwDeviceExtension->WmiLibContext;

    memset(WmiLibContext, 0, sizeof(SCSI_WMILIB_CONTEXT));
    
    WmiLibContext->GuidCount = HbaapiGuidCount;
    WmiLibContext->GuidList = HbaapiGuidList;    
    
    WmiLibContext->QueryWmiRegInfo = QueryWmiRegInfo;
    WmiLibContext->QueryWmiDataBlock = QueryWmiDataBlock;
    WmiLibContext->WmiFunctionControl = WmiFunctionControl;
    WmiLibContext->SetWmiDataBlock = WmiSetDataBlock;
    WmiLibContext->SetWmiDataItem = WmiSetDataItem;
    WmiLibContext->ExecuteWmiMethod = WmiExecuteMethod;
}



BOOLEAN
A154xWmiSrb(
    IN     PHW_DEVICE_EXTENSION    HwDeviceExtension,
    IN OUT PSCSI_WMI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

   Process an SRB_FUNCTION_WMI request packet.

   This routine is called from the SCSI port driver synchronized with the
   kernel via Aha154xStartIo.   On completion of WMI processing, the SCSI
   port driver is notified that the adapter can take another request,  if
   any are available.

Arguments:

   HwDeviceExtension - HBA miniport driver's adapter data storage.

   Srb               - IO request packet.

Return Value:

   Value to return to Aha154xStartIo caller.   Always TRUE.

--*/
{
   UCHAR status;
   SCSIWMI_REQUEST_CONTEXT requestContext;
   ULONG retSize;
   BOOLEAN pending;

   //
   // Validate our assumptions.
   //

   ASSERT(Srb->Function == SRB_FUNCTION_WMI);
   ASSERT(Srb->Length == sizeof(SCSI_WMI_REQUEST_BLOCK));
   ASSERT(Srb->DataTransferLength >= sizeof(ULONG));
   ASSERT(Srb->DataBuffer);

   //
   // Check if the WMI SRB is targetted for the adapter or one of the disks
   if (!(Srb->WMIFlags & SRB_WMI_FLAGS_ADAPTER_REQUEST)) {

      //
      // This is targetted to one of the disks, since there are no per disk
      // wmi information we return an error. Note that if there was per
      // disk information, then you'd likely have a differen WmiLibContext
      // and a different set of guids.
      //
      Srb->DataTransferLength = 0;
      Srb->SrbStatus = SRB_STATUS_SUCCESS;

   } else {

       //
       // Process the incoming WMI request.
       //

       pending = ScsiPortWmiDispatchFunction(&HwDeviceExtension->WmiLibContext,
                                                Srb->WMISubFunction,
                                                HwDeviceExtension,
                                                &requestContext,
                                                Srb->DataPath,
                                                Srb->DataTransferLength,
                                                Srb->DataBuffer);

       //
       // We assune that the wmi request will never pend so that we can
       // allocate the requestContext from stack. If the WMI request could
       // ever pend then we'd need to allocate the request context from
       // the SRB extension.
       //
       ASSERT(! pending);

       retSize =  ScsiPortWmiGetReturnSize(&requestContext);
       status =  ScsiPortWmiGetReturnStatus(&requestContext);

       // We can do this since we assume it is done synchronously

       Srb->DataTransferLength = retSize;

       //
       // Adapter ready for next request.
       //

       Srb->SrbStatus = status;
   }

   ScsiPortNotification(RequestComplete, HwDeviceExtension, Srb);
   ScsiPortNotification(NextRequest,     HwDeviceExtension, NULL);

   return TRUE;
}

#define CopyString(field, string, length) \
{ \
    PWCHAR p = field; \
    *p++ = length*sizeof(WCHAR); \
    ScsiPortMoveMemory(p, string, length*sizeof(WCHAR)); \
}


BOOLEAN
QueryWmiDataBlock(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
{
    PHW_DEVICE_EXTENSION CardPtr = (PHW_DEVICE_EXTENSION)Context;
    UCHAR status;
    ULONG SizeNeeded;
    ULONG i, LastIndex, InstanceSize;

    DebugPrint((1, "QueryWmiDataBlock (%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n",
        Context,
        DispatchContext,
        GuidIndex,
        InstanceIndex,
        InstanceCount,
        InstanceLengthArray,
        BufferAvail,
        Buffer));
	
    switch(GuidIndex)
    {
        case MSFC_FibrePortHBAStatisticsGuidIndex:
        {
            PMSFC_FibrePortHBAStatistics PortStats;
            
            //
            // First thing to do is verify if there is enough room in
            // the output buffer to return all data requested
            //
            InstanceSize = (sizeof(MSFC_FibrePortHBAStatistics)+7)&~7;          
            SizeNeeded = InstanceCount * InstanceSize;
            
            if (BufferAvail >= SizeNeeded)
            {
                //
                // Yes, loop over all instances for the data block and
                // fill in the values for them
                //
                LastIndex = InstanceIndex + InstanceCount;
                for (i = InstanceIndex; i < LastIndex; i++)
                {
                    PortStats = (PMSFC_FibrePortHBAStatistics)Buffer;

                    //
                    // TODO: Initialize values in PortStats for the port
                    //
//                    memset(Buffer, (CHAR)i, InstanceSize);

                    //
                    // Establish a unique value for the port
                    //
                    PortStats->UniquePortId = ((ULONGLONG)CardPtr) + i;
                    
                    Buffer += InstanceSize;
                    *InstanceLengthArray++ = sizeof(MSFC_FibrePortHBAStatistics);
                }
                status = SRB_STATUS_SUCCESS;
            } else {
                status = SRB_STATUS_DATA_OVERRUN;
            }
            
            
            break;
        }

        case MSFC_FibrePortHBAAttributesGuidIndex:
        {
            PMSFC_FibrePortHBAAttributes PortAttributes;
            
            //
            // First thing to do is verify if there is enough room in
            // the output buffer to return all data requested
            //
            InstanceSize = (sizeof(MSFC_FibrePortHBAAttributes)+7)&~7;          
            SizeNeeded = InstanceCount * InstanceSize;
            
            if (BufferAvail >= SizeNeeded)
            {
                //
                // Yes, loop over all instances for the data block and
                // fill in the values for them
                //
                LastIndex = InstanceIndex + InstanceCount;
                for (i = InstanceIndex; i < LastIndex; i++)
                {
                    PortAttributes = (PMSFC_FibrePortHBAAttributes)Buffer;

                    //
                    // TODO: initialize port attribute values properly
                    //
                    memset(Buffer, (CHAR)i, InstanceSize);

#define PORTNAME L"FibrePortName"
                    CopyString(PortAttributes->Attributes.PortSymbolicName,
                               PORTNAME,
                               256);

#define OSDEVICENAME L"OsDeviceName"
                    CopyString(PortAttributes->Attributes.OSDeviceName,
                               OSDEVICENAME,
                               256);

                    //
                    // Establish a unique value for the port
                    //
                    PortAttributes->UniquePortId = ((ULONGLONG)CardPtr) + i;
                    
                    Buffer += InstanceSize;
                    *InstanceLengthArray++ = sizeof(MSFC_FibrePortHBAAttributes);
                }
                status = SRB_STATUS_SUCCESS;
            } else {
                status = SRB_STATUS_DATA_OVERRUN;
            }
            break;
        }

        case MSFC_FCAdapterHBAAttributesGuidIndex:
        {
            PMSFC_FCAdapterHBAAttributes AdapterAttributes;
            
            //
            // First thing to do is verify if there is enough room in
            // the output buffer to return all data requested
            //
            SizeNeeded = (sizeof(MSFC_FCAdapterHBAAttributes));
            
            if (BufferAvail >= SizeNeeded)
            {
                //
                // We know there is always only 1 instance for this
                // guid
                //
                AdapterAttributes = (PMSFC_FCAdapterHBAAttributes)Buffer;

                //
                // TODO: initialize adapter attribute values properly
                //
                memset(Buffer, (CHAR)7, SizeNeeded);
                AdapterAttributes->NumberOfPorts = 8;

#define  MANUFACTURER L"FibreAdapter Manufacturer"
                CopyString(AdapterAttributes->Manufacturer,
                           MANUFACTURER,
                           64);

#define SERIALNUMBER L"FibreAdapter SerialNumber"
                CopyString(AdapterAttributes->SerialNumber,
                           SERIALNUMBER,
                           64);

#define MODEL L"FibreAdapter Model"
                CopyString(AdapterAttributes->Model,
                           MODEL,
                           256);

#define MODELDESCRIPTION L"FibreAdapter ModelDescription"
                CopyString(AdapterAttributes->ModelDescription,
                           MODELDESCRIPTION,
                           256);

#define NODESYMBOLICNAME L"FibreAdapter NodeSymbolicName"
                CopyString(AdapterAttributes->NodeSymbolicName,
                           NODESYMBOLICNAME,
                           256);

#define HARDWAREVERSION L"FibreAdapter HardwareVersion"
                CopyString(AdapterAttributes->HardwareVersion,
                           HARDWAREVERSION,
                           256);

#define DRIVERVERSION L"FibreAdapter DriverVersion"
                CopyString(AdapterAttributes->DriverVersion,
                           DRIVERVERSION,
                           256);

#define OPTIONROMVERSION L"FibreAdapter OptionROMVersion"
                CopyString(AdapterAttributes->OptionROMVersion,
                           OPTIONROMVERSION,
                           256);

#define FIRMWAREVERSION L"FibreAdapter FirmwareVersion"
                CopyString(AdapterAttributes->FirmwareVersion,
                           FIRMWAREVERSION,
                           256);

#define DRIVERNAME L"FibreAdapter DriverName"
                CopyString(AdapterAttributes->DriverName,
                           DRIVERNAME,
                           256);

                
                //
                // Establish a unique value for the Adapter
                //
                AdapterAttributes->UniqueAdapterId = ((ULONGLONG)CardPtr);

                *InstanceLengthArray = sizeof(MSFC_FCAdapterHBAAttributes);
                status = SRB_STATUS_SUCCESS;
            } else {
                status = SRB_STATUS_DATA_OVERRUN;
            }
            break;
        }

        case MSFC_HBAFCPInfoGuidIndex:
        case MSFC_HBAFc3MgmtMethodsGuidIndex:
        case MSFC_FibrePortHBAMethodsGuidIndex:
        case MSFC_HBAPortMethodsGuidIndex:
        {
            //
            // Methods don't return data per se, but must respond to
            // queries with an empty data block. We know that all of
            // these method guids only have one instance
            //
            SizeNeeded = sizeof(ULONG);
            
            if (BufferAvail >= SizeNeeded)
            {
                status = SRB_STATUS_SUCCESS;
            } else {
                status = SRB_STATUS_DATA_OVERRUN;
            }
            break;
        }

        default:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
    }

    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  SizeNeeded);

    return FALSE;
}

//
// Name of MOF resource as specified in the RC file
//
#define Wmi_MofResourceName        L"MofResource"

UCHAR
QueryWmiRegInfo(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    OUT PWCHAR *MofResourceName
    )
{

//
// Mof for HBA api implementation is not needed so this is commented
// out. If adapter specific classes are added then you'll need to
// specify the MOF resource name to WMI
//
//    *MofResourceName = Wmi_MofResourceName;

    return SRB_STATUS_SUCCESS;
}

BOOLEAN
WmiExecuteMethod (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    )
{
    PHW_DEVICE_EXTENSION CardPtr = (PHW_DEVICE_EXTENSION)Context;
    ULONG sizeNeeded = 0;
    UCHAR status;
    ULONG i;

    DebugPrint((1, "WmiExecuteMethod(%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
        Context,
            DispatchContext,
                GuidIndex,
                    InstanceIndex,
                        MethodId,
                        InBufferSize,
                        OutBufferSize,
                             Buffer));
	
    switch(GuidIndex)
    {            
        case MSFC_FibrePortHBAMethodsGuidIndex:
        {
            switch(MethodId)
            {
                //
                //     void ResetStatistics();
                //
                case ResetStatistics:
                {
                    //
                    // No input or output buffers expected so no
                    // validation needed. InstanceIndex has the Port
                    // Index
                    //

                    //
                    // TODO: Do what is needed to reset port
                    //       statistics. The index to the port is the
                    //       InstanceIndex parameter
                    //
                    sizeNeeded = 0;
                    status = SRB_STATUS_SUCCESS;
                    break;
                }

                default:
                {
                    status = SRB_STATUS_ERROR;
                    break;
                }
            }
            break;
        }

        case MSFC_HBAPortMethodsGuidIndex:
        {
            switch(MethodId)
            {

                //              
                //    void GetDiscoveredPortAttributes(
                //            [in
                //             ] uint32 PortIndex,
                //
                //             [in] uint32 DiscoveredPortIndex,
                //
                //             [out,
                //              HBAType("HBA_PORTATTRIBUTES")
                //             ] MSFC_HBAPortAttributesResults PortAttributes);
                //
                case GetDiscoveredPortAttributes:
                {
                    //
                    // Validate that the input buffer is the correct
                    // size and the output buffer is large enough
                    //
                    if (InBufferSize >= sizeof(GetDiscoveredPortAttributes_IN))
                    {
                        sizeNeeded = sizeof(GetDiscoveredPortAttributes_OUT);
                        if (OutBufferSize >= sizeNeeded)
                        {
                            PGetDiscoveredPortAttributes_IN In;
                            PGetDiscoveredPortAttributes_OUT Out;

                            In = (PGetDiscoveredPortAttributes_IN)Buffer;
                            Out = (PGetDiscoveredPortAttributes_OUT)Buffer;

                            //
                            // TODO: Examine In->PortIndex and
                            //       In->DiscoveredPortIndex and
                            //       validate that they are correct.
                            //

                            //
                            // TODO: Fill Out->PortAttributes with
                            //       correct values.
                            //
                            memset(&Out->PortAttributes,
                                   3,
                                   sizeof(MSFC_HBAPortAttributesResults));
                            
                            CopyString(Out->PortAttributes.PortSymbolicName,
                                       PORTNAME,
                                       256);

                            CopyString(Out->PortAttributes.OSDeviceName,
                                       OSDEVICENAME,
                                       256);

                            status = SRB_STATUS_SUCCESS;
                        } else {
                            status = SRB_STATUS_DATA_OVERRUN;
                        }
                    } else {
                        status = SRB_STATUS_ERROR;
                    }
                    break;
                }

                case GetPortAttributesByWWN:
                {            
                    //
                    // Validate that the input buffer is the correct
                    // size and the output buffer is large enough
                    //
                    if (InBufferSize >= sizeof(GetPortAttributesByWWN_IN))
                    {
                        sizeNeeded = sizeof(GetPortAttributesByWWN_OUT);
                        if (OutBufferSize >= sizeNeeded)
                        {
                            PGetPortAttributesByWWN_IN In;
                            PGetPortAttributesByWWN_OUT Out;

                            In = (PGetPortAttributesByWWN_IN)Buffer;
                            Out = (PGetPortAttributesByWWN_OUT)Buffer;

                            //
                            // TODO: Examine In->wwn to                         //       In->DiscoveredPortIndex and
                            //       validate that it is correct.
                            //

                            //
                            // TODO: Fill Out->PortAttributes with
                            //       correct values.
                            //
                            memset(&Out->PortAttributes,
                                   3,
                                   sizeof(MSFC_HBAPortAttributesResults));
                            
                            CopyString(Out->PortAttributes.PortSymbolicName,
                                       PORTNAME,
                                       256);

                            CopyString(Out->PortAttributes.OSDeviceName,
                                       OSDEVICENAME,
                                       256);

                            status = SRB_STATUS_SUCCESS;
                        } else {
                            status = SRB_STATUS_DATA_OVERRUN;
                        }
                    } else {
                        status = SRB_STATUS_ERROR;
                    }
                    break;
                }

                default:
                {
                    status = SRB_STATUS_ERROR;
                    break;
                }
            }
            break;
        }

        case MSFC_HBAFc3MgmtMethodsGuidIndex:
        {
            switch(MethodId)
            {
                case SendCTPassThru:
                {
                    PSendCTPassThru_IN In;
                    PSendCTPassThru_OUT Out;
                    ULONG RequestCount, ResponseCount;
                    ULONG InSizeNeeded;
                    
                    //
                    // Validate that the input buffer is the correct
                    // size and the output buffer is large enough
                    //
                    if (InBufferSize >= sizeof(ULONG))
                    {
                        In = (PSendCTPassThru_IN)Buffer;
                        
                        RequestCount = In->RequestBufferCount;
                        InSizeNeeded = sizeof(SendCTPassThru_IN) - 1 + RequestCount;
                        if (InBufferSize >= InSizeNeeded)
                        {
#define RESPONSE_BUFFER_SIZE 0x1000
                            ResponseCount = RESPONSE_BUFFER_SIZE;
                            sizeNeeded = sizeof(SendCTPassThru_OUT) - 1 + ResponseCount;
                            
                            if (OutBufferSize >= sizeNeeded)
                            {
                                Out = (PSendCTPassThru_OUT)Buffer;

                                //
                                // TODO: Do the CT Pass thru
                                //

                                //
                                // TODO: Fill the output buffer with
                                //       results
                                //
                                Out->ResponseBufferCount = ResponseCount;
                                memset(Out->ResponseBuffer,
                                       7,
                                       ResponseCount);
                            

                                status = SRB_STATUS_SUCCESS;
                            } else {
                                status = SRB_STATUS_DATA_OVERRUN;
                            }
                        } else {
                            status = SRB_STATUS_ERROR;
                        }
                    } else {
                        status = SRB_STATUS_ERROR;
                    }
                    break;
                }

                case SendRNID:
                {            
                    PSendRNID_IN In;
                    PSendRNID_OUT Out;
                    ULONG ResponseCount;
                    ULONG InSizeNeeded;
                    
                    //
                    // Validate that the input buffer is the correct
                    // size and the output buffer is large enough
                    //
                    if (InBufferSize >= sizeof(SendRNID_IN))
                    {

                        ResponseCount = 72;
                        sizeNeeded = sizeof(SendRNID_OUT) - 1 + ResponseCount;

                        if (OutBufferSize >= sizeNeeded)
                        {
                            In = (PSendRNID_IN)Buffer;
                            Out = (PSendRNID_OUT)Buffer;

                            //
                            // TODO: Do the SendRNID
                            //

                            //
                            // TODO: Fill the output buffer with
                            //       results
                            //
                            Out->ResponseBufferCount = ResponseCount;
                            memset(Out->ResponseBuffer,
                                   7,
                                   ResponseCount);


                            status = SRB_STATUS_SUCCESS;
                        } else {
                            status = SRB_STATUS_DATA_OVERRUN;
                        }
                    } else {
                        status = SRB_STATUS_ERROR;
                    }
                    break;
                }

				case GetFC3MgmtInfo:
				{
					PGetFC3MgmtInfo_OUT Out;

					Out = (PGetFC3MgmtInfo_OUT)Buffer;
					
					sizeNeeded = sizeof(GetFC3MgmtInfo_OUT);
					if (OutBufferSize >= sizeNeeded)
					{
						memset(Buffer, 0x99, sizeNeeded);
						Out->HBAStatus = 0;
						status = SRB_STATUS_SUCCESS;
					} else {
						status = SRB_STATUS_DATA_OVERRUN;
					}
								 
					break;
				};

				case SetFC3MgmtInfo:
				{
					PSetFC3MgmtInfo_OUT Out;

					Out = (PSetFC3MgmtInfo_OUT)Buffer;
					
					sizeNeeded = sizeof(SetFC3MgmtInfo_OUT);
					if (OutBufferSize >= sizeNeeded)
					{
						Out->HBAStatus = 0;
						status = SRB_STATUS_SUCCESS;
					} else {
						status = SRB_STATUS_DATA_OVERRUN;
					}
					break;
				}

                default:
                {
                    status = SRB_STATUS_ERROR;
                    break;
                }
            }
            break;
        }

        case MSFC_HBAFCPInfoGuidIndex:
        {
            switch(MethodId)
            {
                case GetFcpTargetMapping:
                {
                    PGetFcpTargetMapping_OUT Out;
                    
                    //
                    // TODO: Change this code to return the correct
                    //       number of mappings and the correct
                    //       mappings
                    //
#define FCPTargetMappingCount 0x20                  
                    sizeNeeded = sizeof(GetFcpTargetMapping_OUT) -
                                 sizeof(HBAFCPScsiEntry) +
                                 FCPTargetMappingCount * sizeof(HBAFCPScsiEntry);
                    if (OutBufferSize >= sizeNeeded)
                    {
                        Out = (PGetFcpTargetMapping_OUT)Buffer;
                        Out->EntryCount = FCPTargetMappingCount;
                        for (i = 0; i < FCPTargetMappingCount; i++)
                        {
                            memset(&Out->Entry[i],
                                   3,
                                   sizeof(HBAFCPScsiEntry));
                            
                            CopyString(Out->Entry[i].ScsiId.OSDeviceName,
                                       OSDEVICENAME,
                                       256);
                        }
						
						status = SRB_STATUS_SUCCESS;						
                    } else {
						status = SRB_STATUS_DATA_OVERRUN;						
					}
                    break;
                }

                case GetFcpPersistentBinding:
                {
                    PGetFcpPersistentBinding_OUT Out;
                    
                    //
                    // TODO: Change this code to return the correct
                    //       number of mappings and the correct
                    //       mappings
                    //
#define FCPPersistentBindingCount 0x20                  
                    sizeNeeded = sizeof(GetFcpPersistentBinding_OUT) -
                                 sizeof(HBAFCPBindingEntry) +
                                 FCPPersistentBindingCount * sizeof(HBAFCPBindingEntry);
                    if (OutBufferSize >= sizeNeeded)
                    {
                        Out = (PGetFcpPersistentBinding_OUT)Buffer;
                        Out->EntryCount = FCPPersistentBindingCount;
                        for (i = 0; i < FCPPersistentBindingCount; i++)
                        {
                            memset(&Out->Entry[i],
                                   3,
                                   sizeof(HBAFCPBindingEntry));
                            
                            CopyString(Out->Entry[i].ScsiId.OSDeviceName,
                                       OSDEVICENAME,
                                       256);
                        }
						
						status = SRB_STATUS_SUCCESS;						
                    } else {
						status = SRB_STATUS_DATA_OVERRUN;						
                    }
                    break;
                }

                default:
                {
                    status = SRB_STATUS_ERROR;
                    break;
                }
            }
            break;
        }

        default:
        {
            status = SRB_STATUS_ERROR;
        }
    }

    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  sizeNeeded);

    return(FALSE);    
}


BOOLEAN
WmiSetDataBlock (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
{
    PHW_DEVICE_EXTENSION CardPtr = (PHW_DEVICE_EXTENSION)Context;
    UCHAR status;

    DebugPrint((1, "WmiSetDataBlock(%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
        Context,
            DispatchContext,
                GuidIndex,
                    InstanceIndex,
                        BufferSize,
                             Buffer));

    switch(GuidIndex)
    {

        case MSFC_HBAFCPInfoGuidIndex:
        case MSFC_HBAFc3MgmtMethodsGuidIndex:
        case MSFC_FibrePortHBAMethodsGuidIndex:
        case MSFC_HBAPortMethodsGuidIndex:
        case MSFC_FibrePortHBAAttributesGuidIndex:
        case MSFC_FCAdapterHBAAttributesGuidIndex:
        case MSFC_FibrePortHBAStatisticsGuidIndex:
        {
            //
            // These are read only
            //
            status = SRB_STATUS_ERROR;
            break;
        }
        
        default:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
    }

    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  0);
    return(FALSE);  
}

BOOLEAN
WmiSetDataItem (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
{
    UCHAR status;
    
    DebugPrint((1, "WmiSetDataItem(%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
        Context,
            DispatchContext,
                GuidIndex,
                    InstanceIndex,
                        DataItemId,
                        BufferSize,
                             Buffer));

	//
	// SetDataItem does not need to be supported
	//
	status = SRB_STATUS_ERROR;

    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  0);

    return(FALSE);    
}

    
BOOLEAN
WmiFunctionControl (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN SCSIWMI_ENABLE_DISABLE_CONTROL Function,
    IN BOOLEAN Enable
    )
{
    UCHAR status = SRB_STATUS_SUCCESS;

    DebugPrint((1, "WmiFunctionControl(%x,\n%x,\n%x,\n%x,\n%x)\n\n",
        Context,
            DispatchContext,
                GuidIndex,
                    Function,
                             Enable));
	
    switch(GuidIndex)
    {
        case MSFC_FibrePortHBAStatisticsGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_FibrePortHBAAttributesGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_FibrePortHBAMethodsGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_FCAdapterHBAAttributesGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_HBAPortMethodsGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_HBAFc3MgmtMethodsGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_HBAFCPInfoGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        
        default:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
    }
    
    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  0);

    return(FALSE);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\aha154x\wmitest\aha154dc.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    aha154dc.c

Abstract:

    This is a Sample WMI Data Consumer.

    This user-mode app performs two WMI queries to the AHA154x driver for the
    Setup Data Guid and prints its findings to the console.

Authors:

    Alan Warwick
    Dan Markarian

Environment:

    User mode only.

Notes:

    None.

Revision History:

    - Based on "dc1" test code by Alan Warwick.
    - 17-Apr-1997, Original Revision, Dan Markarian

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include "wmium.h"

//
// Macros.
//

#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))

//
// WMI data block definitions.
//

#define Aha154xWmi_SetupData_InstanceName L"Aha154xAdapter"
#define Aha154xWmi_SetupData_Guid \
         { 0xea992010,0xb75b,0x11d0,0xa3,0x07,0x00,0xaa,0x00,0x6c,0x3f,0x30 }

GUID   AdapterSetupDataGuid = Aha154xWmi_SetupData_Guid;
PWCHAR AdapterSetupDataInstances[] = { Aha154xWmi_SetupData_InstanceName };

//
// Global variables.
//

BYTE  Buffer[4096];
ULONG BufferSize = sizeof(Buffer);

//
// Structure definitions.
//

typedef struct tagTESTGUID TESTGUID;

typedef BOOLEAN (*QADVALIDATION)(
   TESTGUID *TestGuid,
   PVOID Buffer,
   ULONG BufferSize
);

typedef ULONG (*QSINSET)(
   TESTGUID *TestGuid,
   PULONG *DataList,
   PULONG DataListSize,
    PBYTE *ValueBuffer,
   ULONG *ValueBufferSize,
   ULONG Instance
);

typedef ULONG (*QSITSET)(
   TESTGUID *TestGuid,
   PULONG *DataList,
   PULONG DataListSize,
    PBYTE *ValueBuffer,
   ULONG *ValueBufferSize,
   ULONG Instance,
   ULONG ItemId
   );

typedef BOOLEAN (*QSINTVALIDATION)(
   TESTGUID *TestGuid,
   PULONG *DataList,
   PULONG DataListSize,
    PVOID Buffer,
   ULONG BufferSize,
   ULONG Instance
   );

typedef PWCHAR (*GETINSTANCENAME)(
   TESTGUID *TestGuid,
    ULONG Instance
   );

typedef struct tagTESTGUID
{
   LPGUID Guid;
   HANDLE Handle;

   PULONG DataListSize;

   PULONG *InitDataList;
   PULONG *SINDataList;
   PULONG *SITDataList;

   PWCHAR *InstanceNames;

   QADVALIDATION QADValidation;
   ULONG QADFlags;

   ULONG InstanceCount;
    GETINSTANCENAME GetInstanceName;

   ULONG QSINTFlags;
   QSINTVALIDATION QSINTValidation;

   QSINSET QSINSet;

   ULONG ItemCount;
   QSITSET QSITSet;

} TESTGUID;

//
// Support functions.
//

void PrintOutAdapterSetupData(PULONG Data);

PWCHAR GetInstanceName(
   TESTGUID *TestGuid,
   ULONG Instance
   )
{
   return(TestGuid->InstanceNames[Instance]);
}

BOOLEAN AdapterSetupDataQADValidate(
   TESTGUID *TestGuid,
   PVOID Buffer,
   ULONG BufferSize
)
{
   PWNODE_ALL_DATA Wnode = Buffer;
   PULONG Data;

   //
   // Validate WNODE fields.
   //

   if ((Wnode->WnodeHeader.BufferSize == 0) ||
       (Wnode->WnodeHeader.ProviderId == 0) ||
       (Wnode->WnodeHeader.Version != 1) ||
       (Wnode->WnodeHeader.Linkage != 0) ||
       (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
       (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
       (memcmp(&Wnode->WnodeHeader.Guid, TestGuid->Guid, sizeof(GUID)) != 0) ||
       (Wnode->WnodeHeader.Flags != (WNODE_FLAG_ALL_DATA |
                                     WNODE_FLAG_FIXED_INSTANCE_SIZE |
                                     WNODE_FLAG_STATIC_INSTANCE_NAMES)) ||
       (Wnode->InstanceCount != 1) ||
       (Wnode->DataBlockOffset == 0) ||
       (Wnode->FixedInstanceSize != 0xff))
   {
      return(FALSE);
   }

   Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);

   //
   // Check data here if you wish; actual values will depend on your
   // AHA154x adapter.
   //
   // [NOT IMPLEMENTED]
   //

   //
   // Print out adapter Setup Data to console.
   //

   PrintOutAdapterSetupData(Data);

   return(TRUE);
}

BOOLEAN AdapterSetupDataQSIValidate(
	TESTGUID * TestGuid,
	PULONG *   DataList,
	PULONG     DataListSize,
   PVOID      Buffer,
	ULONG      BufferSize,
	ULONG      Instance
	)
{
   PWNODE_SINGLE_INSTANCE Wnode = Buffer;
   PULONG Data;

   //
   // Validate WNODE fields.
   //

   if ((Wnode->WnodeHeader.BufferSize == 0) ||
       (Wnode->WnodeHeader.ProviderId == 0) ||
       (Wnode->WnodeHeader.Version != 1) ||
       (Wnode->WnodeHeader.Linkage != 0) ||
       (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
       (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
       (memcmp(&Wnode->WnodeHeader.Guid, TestGuid->Guid, sizeof(GUID)) != 0) ||
       (Wnode->WnodeHeader.Flags != (WNODE_FLAG_SINGLE_INSTANCE |
                                     WNODE_FLAG_STATIC_INSTANCE_NAMES) ) ||
       (Wnode->InstanceIndex != 0) ||
       (Wnode->SizeDataBlock != 0xff))
   {
      return(FALSE);
   }

   Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);

   //
   // Check data here if you wish; actual values will depend on your
   // AHA154x adapter.
   //
   // [NOT IMPLEMENTED]
   //

   //
   // Print out adapter Setup Data to console.
   //

   PrintOutAdapterSetupData(Data);

   return TRUE;
}

//
// Tests.
//

TESTGUID TestList[] = {
    { &AdapterSetupDataGuid,       // LPGUID Guid
      0,                           // (reserved)
      NULL,                        // PULONG DataListSize
      NULL,                        // PULONG * InitDataList
      NULL,                        // PULONG * SINDataList
      NULL,                        // PULONG * SITDataList
      AdapterSetupDataInstances,   // PWCHAR * InstanceNames
      AdapterSetupDataQADValidate, // QADVALIDATION QADValidation
      (WNODE_FLAG_ALL_DATA | WNODE_FLAG_FIXED_INSTANCE_SIZE), // ULONG QADFlags
      1,                           // ULONG InstanceCount
      GetInstanceName,             // GETINSTANCENAME GetInstanceName
      WNODE_FLAG_SINGLE_INSTANCE,  // ULONG QSINTFlags
      AdapterSetupDataQSIValidate, // QDINTVALIDATION QSINTValidation
      NULL,                        // QSINSET QSINSet
      0,                           // ULONG ItemCount
      NULL }                       // QSITSET QSITSet
};

#define TestCount ( sizeof(TestList) / sizeof(TestList[0]) )

//
// Query-All-Data Generic Tester.
//

ULONG QADTest(void)
{
   ULONG i;
   ULONG status;

   for (i = 0; i < TestCount; i++)
   {
      status = WMIOpenBlock(TestList[i].Guid, &TestList[i].Handle);

      if (status != ERROR_SUCCESS)
      {
         printf("Error: QADTest: Couldn't open Handle %d %x\n", i, status);
         TestList[i].Handle = (HANDLE)NULL;
      }
   }

   for (i = 0; i < TestCount;i++)
   {
      if (TestList[i].Handle != (HANDLE)NULL)
      {
         BufferSize = sizeof(Buffer);
         status = WMIQueryAllData(TestList[i].Handle, &BufferSize, Buffer);

         if (status == ERROR_SUCCESS)
         {
            if (! (*TestList[i].QADValidation)(&TestList[i], Buffer, BufferSize))
            {
               printf("ERROR: QADValidation %d failed\n", i);
            }
         }
         else
         {
            printf("Error TestList WMIQueryAllData %d failed %x\n", i, status);
         }
      }
   }

   for (i = 0; i < TestCount;i++)
   {
      if (TestList[i].Handle != (HANDLE)NULL)
      {
         WMICloseBlock(TestList[i].Handle);
      }
   }
   return(ERROR_SUCCESS);
}

//
// Query-Single-Instance Generic Tester.
//

ULONG QSITest(void)
{
   ULONG  i,j;
   ULONG  status;
   PWCHAR InstanceName;
   PBYTE  ValueBuffer;
   ULONG  ValueBufferSize;

   for (i = 0; i < TestCount; i++)
   {
      status = WMIOpenBlock(TestList[i].Guid, &TestList[i].Handle);

      if (status != ERROR_SUCCESS)
      {
         printf("Error: QSINTest: Couldn't open Handle %d %x\n", i, status);
         TestList[i].Handle = (HANDLE)NULL;
      }

      for (j = 0; j < TestList[i].InstanceCount; j++)
      {
         InstanceName = ((*TestList[i].GetInstanceName)(&TestList[i], j));

         //
         // Initial value check
         BufferSize = sizeof(Buffer);

         status = WMIQuerySingleInstance(TestList[i].Handle,
                                         InstanceName,
                                         &BufferSize,
                                         Buffer);
         if (status == ERROR_SUCCESS)
         {
            if (! (*TestList[i].QSINTValidation)(&TestList[i],
                                                 TestList[i].InitDataList,
                                                 TestList[i].DataListSize,
                                                 Buffer, BufferSize, j))
            {
               printf("ERROR: QSINTest Init %d/%d Validation failed %x\n", i,j,status);
            }
         }
         else
         {
            printf("Error QSINTest WMIQuerySingleInstance %d/%d failed %x\n", i, j, status);
         }
      }
   }
   for (i = 0; i < TestCount;i++)
   {
      if (TestList[i].Handle != (HANDLE)NULL)
      {
         WMICloseBlock(TestList[i].Handle);
      }
   }
   return(ERROR_SUCCESS);
}

//
// Executable's entry point.
//

int _cdecl main(int argc, char *argv[])
{
   QADTest();
   QSITest();

   return(ERROR_SUCCESS);
}

//
// Routine to print out queried data from the data provider, for the AHA154x
// Setup Data Guid.
//

typedef struct { PCHAR on; PCHAR off; } BINTYPE;

BINTYPE BinSdtPar[8] =
{
   { "Reserved Bit 0 On", "" },
   { "Parity On", "Parity Off" },
   { "Reserved Bit 2 On", "" },
   { "Reserved Bit 3 On", "" },
   { "Reserved Bit 4 On", "" },
   { "Reserved Bit 5 On", "" },
   { "Reserved Bit 6 On", "" },
   { "Reserved Bit 7 On", "" }
};

BINTYPE BinDisOpt[8] =
{
   { "0", "" },
   { "1", "" },
   { "2", "" },
   { "3", "" },
   { "4", "" },
   { "5", "" },
   { "6", "" },
   { "7", "" }
};

void PrintBinaryFlags(char * string, BINTYPE * binType, UCHAR byte)
{
   int i;
   int none = 1;

   printf("%s", string);

   for (i = 0; i < 8; i++) {
      if (byte & 0x1) {
         if (*binType[i].on) {
            if (!none) {
               printf(", ");
            }
            printf("%s", binType[i].on);
            none = 0;
         }
      } else {
         if (*binType[i].off) {
            if (!none) {
               printf(", ");
            }
            printf("%s", binType[i].off);
            none = 0;
         }
      }
      byte = byte >> 1;
   }

   if (none) {
      printf("None.");
   }

   printf("\n");
}

void PrintTransferSpeed(char * string, UCHAR byte)
{
   printf("%s", string);

   if (byte == 0) {
      printf("5.0 Mb/s");
   } else if (byte == 1) {
      printf("6.7 Mb/s");
   } else if (byte == 2) {
      printf("8.0 Mb/s");
   } else if (byte == 3) {
      printf("10 Mb/s");
   } else if (byte == 4) {
      printf("5.7 Mb/s");
   } else if (byte == 0xff) {
      printf("3.3 Mb/s");
   } else {
      if (byte & 0x80) {
         printf("Bit 7 On, ");
      }

      if (byte & 0x08) {
         printf("Strobe 150ns, ");
      } else {
         printf("Strobe 100ns, ");
      }

      printf("Read Pulse ");
      switch ((byte >> 4) & 0x7) {
      case 0:
         printf("100ns");
         break;
      case 1:
         printf("150ns");
         break;
      case 2:
         printf("200ns");
         break;
      case 3:
         printf("250ns");
         break;
      case 4:
         printf("300ns");
         break;
      case 5:
         printf("350ns");
         break;
      case 6:
         printf("400ns");
         break;
      case 7:
         printf("450ns");
         break;
      }

      printf(", Write Pulse ");
      switch (byte & 0x7) {
      case 0:
         printf("100ns");
         break;
      case 1:
         printf("150ns");
         break;
      case 2:
         printf("200ns");
         break;
      case 3:
         printf("250ns");
         break;
      case 4:
         printf("300ns");
         break;
      case 5:
         printf("350ns");
         break;
      case 6:
         printf("400ns");
         break;
      case 7:
         printf("450ns");
         break;
      }
   }

   printf("\n");
}

void PrintSynTraAgr(char * string, UCHAR byte)
{
   printf("%s", string);

   if (byte & 0x80) {
      printf("Negotiated, ");
   } else {
      printf("Not Negotiated, ");
   }

   printf("Period %d ns, ", ((int)(byte>>4) & 0x07) * 50 + 100);

   if (byte & 0xF) {
      printf("Offset %d", (int)(byte&0xF));
   } else {
      printf("Offset Async");
   }

   printf("\n");
}

void PrintString(char * string, char * ptr, int length)
{
   int none = 1;

   printf("%s", string);

   for (; length; length--) {
      if (*ptr == 0) {
         break;
      }
      printf("%c",*ptr);
      none = 0;
      ptr++;
   }

   if (none) {
      printf("None.");
   }

   printf("\n");
}

void PrintSwitches(UCHAR byte)
{
   int i;

   printf("Adapter DIP Switches [7-0]: ");

   for (i = 0; i < 8; i++) {
      if (byte & 0x1) {
         printf("1");
      } else {
         printf("0");
      }
      byte = byte >> 1;
   }
   printf("\n");
}

void PrintOutAdapterSetupData(PULONG Data)
{
   PUCHAR ptr = (PUCHAR)Data;
   int  i;

   printf("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n"
          "                  AHA154X ADAPTER SETUP DATA\n"
          "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");

   for (i = 0; i < 0xff; i++) {
      if ((i % 16) == 0) {
         printf("\n%02x: ", i);
      }
      printf("%02x ", *ptr);
      ptr++;
   }

   printf("\n\n");
   ptr = (PUCHAR) Data;

   PrintBinaryFlags("SDT and Parity Status: ", BinSdtPar, *ptr++);
   PrintTransferSpeed("Transfer Speed: ", *ptr++);

   printf("Bus On Time: %d ms\n", (int)*ptr++);
   printf("Bus Off Time: %d ms\n", (int)*ptr++);
   printf("Number Of Mailboxes: %d\n", (int)*ptr++);
   printf("Mailbox Address: 0x%02x%02x%02x\n", (int)*ptr, (int)*(ptr+1), (int)*(ptr+2));
   ptr += 3;

   PrintSynTraAgr("Sync Target 0 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 1 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 2 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 3 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 4 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 5 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 6 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 7 Agreements: ", *ptr++);

   PrintBinaryFlags("Disconnection Options: ", BinDisOpt, *ptr++);

   PrintString("Customer Banner: ", ptr, 20);
   ptr += 20;

   if (*ptr++) {
      printf("Auto Retry Options: NON-ZERO (BAD).\n");
   } else {
      printf("Auto Retry Options: None.\n");
   }

   PrintSwitches(*ptr++);

   printf("Firmware Checksum: 0x%02x%02x\n", (int)*ptr, (int)*(ptr+1) );
   ptr += 2;
   printf("BIOS Mailbox Address: 0x%02x%02x%02x\n", (int)*ptr, (int)*(ptr+1), (int)*(ptr+2));
   ptr += 3;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\dam.h ===
/*++
Copyright (c) HighPoint Technologies, Inc. 2000

Module Name:
    DAM.h

Abstract:
    Defines the interface of Disk Array Management, including some constant 
    defintions, data structures and routine prototypes.

Author:
    Liu Ge (LG)
    
Environment:
    Win32 User Mode Only    

Revision History:
   03-17-2000  Created initiallly
	11-17-2000  SLeng Added functions to R/W Validity & RebuiltSector flag
	11-20-2000  GengXin Added DiskArray_GetDiskIsBroken function to get array of disk whether broken
	11-20-2000  SLeng Added DiskArray_SetDeviceFlag function to Enable/Disable a device
	11-21-2000  SLeng Added function DiskArray_VerifyMirrorBlock to verify mirror block
	11-23-2000  SLeng Added functions to Remove/Add spare disk
	11-29-2000  SLeng Added function to add a Mirror disk
--*/
#ifndef DiskArrayManagement_H_
#define DiskArrayManagement_H_

#include "RaidCtl.h"

#pragma pack(push, 1)

DECLARE_HANDLE(HFIND_DISK);
DECLARE_HANDLE(HFAILURE_MONITOR);
DECLARE_HANDLE(HMIRROR_BUILDER);

// The St_FindDisk structure describes a disk found by the DiskArray_FindFirstNext function.

typedef struct
{
    HDISK   hFoundDisk; //  The handle of the found disk
    int     iDiskType;  //  See Eu_DiskArrayType
    BOOL    isSpare;    //  Indicate if this disk is a spare disk
}St_FindDisk, * PSt_FindDisk;

#pragma pack(pop)

#ifdef  __cplusplus
extern "C"
{
#endif

/*++
Function:
    RAIDController_GetNum

Description:
    Retrieve the number of RAID controllers in computer

Arguments:

Returns:
    return the number of RAID controllers in computer

See also:
    RAIDController_GetInfo
--*/
int WINAPI RAIDController_GetNum(void);

/*++
Function:
    RAIDController_GetInfo

Description:
    Retrieve the information of a controller

Arguments:
    iController - Specify the zero-base index of the controller
    pInfo - Points to a St_StorageControllerInfo structure that receives 
            the information about the specified controller.

Returns:
    return TRUE if success
    else return FALSE if failed.

See also:
    RAIDController_GetNum
--*/
BOOL WINAPI RAIDController_GetInfo( int iController, St_StorageControllerInfo * pInfo );

/*++
Function:
    DiskArray_FindFirst

Description:
    Search a compound disk for a child disk

Arguments:
    hRoot     - Specify the compound disk from which all child disks will be 
                found. This parameter can be NULL if the root is the whole system
    pFindData - Points to a St_FindDisk structure that receives information about the found
                disk.

Returns:
    return a search handle
    else return NULL if failed.

See also:
    DiskArray_FindNext
    DiskArray_FindClose
--*/
HFIND_DISK WINAPI DiskArray_FindFirst(HDISK hParent, PSt_FindDisk pFindData );

/*++
Function:
    DiskArray_FindNext

Description:
    Continue a disk search from a previous call to the DiskArray_FindFirst function

Arguments:
    hSearchHandle - Identifies a search handle returned by a previous call 
                    to the FindFirstFile function. 

    pFindData - Points to a St_FindDisk structure that receives information about the found
                disk.

Returns:
    return TRUE
    else return FALSE, if failed.

See also:
    DiskArray_FindFirst
    DiskArray_FindClose
--*/
BOOL WINAPI DiskArray_FindNext(HFIND_DISK hSearchHandle, PSt_FindDisk pFindData);

/*++
Function:
    DiskArray_FindClose

Description:
    Closes the specified search handle

Arguments:
    hSearchHandle - Identifies the search handle. This handle must have been previously 
                    opened by the DiskArray_FindFirst function. 

Returns:
    return TRUE,
    else return FALSE if failed.

See also:
    DiskArray_FindFirst
    DiskArray_FindNext
--*/
BOOL WINAPI DiskArray_FindClose(HFIND_DISK hSearchHandle);

/*++
Function:
    DiskArray_GetStatus

Description:
    Retrieve the status information of a disk, either a 
    physical disk or a virtual disk.

Arguments:
    hDisk -     Identifies the disk of which the status information will be
                retrieved.
    pStatus -   Points to a St_DiskStatus structure that describe the status
                of the disk

Returns:
    return TRUE,
    else return FALSE if failed.
--*/
BOOL WINAPI DiskArray_GetStatus( HDISK hDisk, PSt_DiskStatus pStatus );

/*++
Function:
    DiskArray_OpenFailureMonitor

Description:
    Create a failure monitor which will be signaled if a failure occur. The handle
    this routine return can be closed with DiskArray_OpenFailureMonitor

Arguments:

Returns:
    return the handle of the failure monitor, which can be passed to DiskArray_WaitForFailure
    else return NULL if failed.

See also:
    DiskArray_WaitForFailure
    DiskArray_CloseFailureMonitor
--*/
HFAILURE_MONITOR WINAPI DiskArray_OpenFailureMonitor(void);

/*++
Function:
    DiskArray_WaitForFailure

Description:
    Wait a monitor for a failure occurred if any.

Arguments:
    hFailureMonitor - Specify the monitor
    pInfo - Points to a St_DiskArrayEvent containing the detail information of a 
            failure.

Returns:
    return TRUE if a failure happened,
    else return FALSE if this monitor has been closed by a calling to
    DiskArray_CloseFailureMonitor

See also:
    DiskArray_OpenFailureMonitor
    DiskArray_CloseFailureMonitor
--*/
BOOL WINAPI DiskArray_WaitForFailure( HFAILURE_MONITOR hFailureMonitor, 
    PSt_DiskArrayEvent pInfo, HANDLE hProcessStopEvent );

/*++
Function:
    DiskArray_CloseFailureMonitor

Description:
    Close a failure monitor

Arguments:
    hFailureMonitor - Specify the monitor to be closed

Returns:
    return TRUE if success,
    else return FALSE if failed.

See also:
    DiskArray_OpenFailureMonitor
    DiskArray_CloseFailureMonitor
--*/
BOOL WINAPI DiskArray_CloseFailureMonitor( HFAILURE_MONITOR hFailureMonitor );

/*++
Function:
    DiskArray_CreateMirror

Description:
    Create a mirror array. 
    This function will return immediately without any wait for 
    the completion of the creation progress. That means the returned
    mirror array will not work until the creation complete. After this
    call, the interface will call the DiskArray_CreateMirrorBlock to 
    create all blocks sequently. If the creation failed or aborted, the
    DiskArray_RemoveMirror function ought to be called to destroy the
    uncompleted mirror array. If the creation complete, the 
    DiskArray_ValidateMirror function ought to be called to make the
    mirror work.

Arguments:
    pDisks -    The address of a array containing the handles of all 
                physical disks which will be associated as a mirror.
                
    uDiskNum -  The number of physical disks associated togather

Returns:
    return the handle of the new mirror array, the status of which is
    being created, i.e. this mirror array will not work until created.
    if failed, return NULL.

See also:
    DiskArray_CreateMirrorBlock
    DiskArray_ValidateMirror
    DiskArray_RemoveMirror
--*/
HDISK WINAPI DiskArray_CreateMirror( HDISK * pDisks, ULONG uDiskNum, UCHAR* sz_ArrayName );		//modified by wx 12/25/00
BOOL WINAPI DiskArray_RemoveMirror( HDISK hMirror );

//  The following two functions need not be implemented in this version
HDISK WINAPI DiskArray_ExpandMirror( HDISK hMirror, HDISK * pDisks, ULONG uDiskNum );
HDISK WINAPI DiskArray_ShrinkMirror( HDISK hMirror, HDISK * pDisks, ULONG uDiskNum );

/*++
Function:
    DiskArray_CreateStripping

Description:
    Create a stripe array. 
    This function will return immediately without any wait for 
    the completion of the creation progress. That means the returned
    stripe array will not work until the creation complete. After this
    call, the interface will call the DiskArray_CreateStrippingBlock to 
    create all blocks sequently. If the creation failed or aborted, the
    DiskArray_RemoveStripping function ought to be called to destroy the
    uncompleted stripe array.

Arguments:
    pDisks -    The address of a array containing the handles of all 
                physical disks which will be associated as a stripe array.
                
    uDiskNum -  The number of physical disks associated togather

    nStripSizeShift - The exponent of the number of blocks per strip, e.g. 
                      it is 7 if the strip size is 128 blocks, 3 if 8 blocks.

Returns:
    return the handle of the new stripe array, the status of which is
    being created, i.e. this stripe array will not work until created.
    if failed, return NULL.

See also:
    DiskArray_QueryAvailableStripSize
    DiskArray_CreateStrippingBlock
    DiskArray_RemoveStripping
--*/
HDISK WINAPI DiskArray_CreateStripping( HDISK * pDisks, ULONG uDiskNum, UINT nStripSizeShift, UCHAR* sz_ArrayName );		//modified by wx 12/25/00
HDISK WINAPI DiskArray_CreateRAID10( HDISK * pDisks, ULONG uDiskNum, UINT nStripSizeShift, UCHAR* sz_ArrayName );		//add by karl karl 2001/01/10
BOOL WINAPI DiskArray_CreateStrippingBlock( HDISK hStripping, ULONG uLba );
BOOL WINAPI DiskArray_RemoveStripping( HDISK hStripping );

//  The following two functions need not be implemented in this version
HDISK WINAPI DiskArray_ExpandStripping( HDISK hStripping, HDISK * pDisks, ULONG uDiskNum );
HDISK WINAPI DiskArray_ShrinkStripping( HDISK hStripping, HDISK * pDisks, ULONG uDiskNum );

/*++
Function:
    DiskArray_QueryAvailableStripSize

Description:
    Retrieve the available strip size which RAID system supports

Arguments:
    return 
                    
                    
                
Returns:
    return a bit mask representing all available strip size,
    Bit position 0 representing 1 block per strip, 1 representing 2,
    blocks per strip, 7 representing 128 blocks per strip etc.
    
    return FALSE if failed, 

See also:
    DiskArray_CreateStrippingBlock
--*/
DWORD WINAPI DiskArray_QueryAvailableStripSize(void);

/*++
Function:
    DiskArray_CreateSpan

Description:
    Create a span array. 

Arguments:
    pDisks -    The address of a array containing the handles of all 
                physical disks which will be associated as a stripe array.
                
    uDiskNum -  The number of physical disks associated togather

Returns:
    return the handle of the new stripe array, the status of which is
    being created, i.e. this stripe array will not work until created.
    if failed, return NULL.

See also:
    DiskArray_RemoveSpan
--*/
HDISK WINAPI DiskArray_CreateSpan( HDISK * pDisks, ULONG uDiskNum, UCHAR* sz_ArrayName );		//modified by wx 12/25/00
BOOL WINAPI DiskArray_RemoveSpan( HDISK hSpan );

//  The following two functions need not be implemented in this version
HDISK WINAPI DiskArray_ExpandSpan( HDISK hSpan, HDISK * pDisks, ULONG uDiskNum );
HDISK WINAPI DiskArray_ShrinkSpan( HDISK hSpan, HDISK * pDisks, ULONG uDiskNum );


/*++
Function:
    DiskArray_Plug

Description:
    Hot plug a physical disk. The plugged disk can be a child of a virtual
    disk. For example, it can be a child of stripe array.

Arguments:
    hParentDisk -   Identifies the parent disk under which the plugged
                    disk will be a child. If it is null, the plugged disk
                    have not any parent, i.e. which is not a child of 
                    any virtual disk.

Returns:
    return the handle of the plugged disk
    else return NULL if failed.

See also:
    DiskArray_Unplug
--*/
HDISK WINAPI DiskArray_Plug( HDISK hParentDisk );
BOOL WINAPI DiskArray_Unplug( HDISK hDisk );

//  No need to be implemented in this version
BOOL WINAPI DiskArray_FailDisk( HDISK hDisk );

/*++
Function:
    DiskArray_QueryRebuildingBlockSize

Description:
    Retrieve the maximum value of parameter 'nSectors' before calling
    DiskArray_RebuildMirrorBlock

Arguments:
	
Returns:
    return the maximum value.
    else return zero if failed.

See also:
    DiskArray_RebuildMirrorBlock
--*/
ULONG WINAPI DiskArray_QueryRebuildingBlockSize( void );

/*++
Function:
    DiskArray_BeginRebuildingMirror

Description:
    Begin to rebuild a failed mirror array.
    After this call, DiskArray_RebuildMirrorBlock will be called block by block.
    When the rebuilding complete, DiskArray_ValidateMirror ought to be called 
    to make the mirror array work.
    If the rebuilding progress is aborted, DiskArray_AbortMirrorRebuilding will be
    called.

Arguments:
    hMirror - Identifies the mirror array which is about to be rebuilt.
	
Returns:
    return a handle specifying a mirror builder.
    else return INVALID_HANDLE_VALUE if failed.

See also:
    DiskArray_RebuildMirrorBlock
    DiskArray_AbortMirrorRebuilding
    DiskArray_ValidateMirror
    DiskArray_QueryRebuildingBlockSize
--*/
HMIRROR_BUILDER WINAPI DiskArray_BeginRebuildingMirror( HDISK hMirror );

/*++
Function:
    DiskArray_RebuildMirrorBlock

Description:
    Rebuild the data of the specified block in a mirror array.
    The interface will call the this function block by block when
    rebuilding the data. If the rebuilding complete, the 
    DiskArray_ValidateMirror function ought to be called to make the
    mirror array work.
    If the rebuilding progress is aborted, DiskArray_AbortMirrorRebuilding will be
    called.

Arguments:
    hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror
    uLba  - A 32 bits value identifying the block which need to be rebuilt
	nSectors - Sectors of the block to rebuild, cann't be larger then 
    the result of calling DiskArray_QueryRebuildingBlockSize.
	
Returns:
    return TRUE
    else return FALSE if failed.

See also:
    DiskArray_BeginRebuildingMirror
    DiskArray_AbortMirrorRebuilding
    DiskArray_ValidateMirror
    DiskArray_QueryRebuildingBlockSize
--*/
BOOL WINAPI DiskArray_RebuildMirrorBlock( HMIRROR_BUILDER hBuilder, ULONG uLba, ULONG nSectors,int nRebuildType );

/*++
Function:
    DiskArray_AbortMirrorRebuilding

Description:
    Abort a mirror rebuilding progress.

Arguments:
    hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror
	
Returns:
    return TRUE if succeeded
    else return FALSE if failed.

See also:
    DiskArray_QueryRebuildingBlockSize
    DiskArray_BeginRebuildingMirror
    DiskArray_RebuildMirrorBlock
--*/
BOOL WINAPI DiskArray_AbortMirrorRebuilding( HMIRROR_BUILDER hBuilder );
 
/*++
Function:
    DiskArray_ValidateMirror

Description:
    When all blocks of a failed mirror array are built, this
    function ought to be called to make the mirror array work.

Arguments:
    hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror
	
Returns:
    return TRUE if succeeded
    else return FALSE if failed.

See also:
    DiskArray_QueryRebuildingBlockSize
    DiskArray_BeginRebuildingMirror
    DiskArray_RebuildMirrorBlock
    DiskArray_AbortMirrorRebuilding
--*/
BOOL WINAPI DiskArray_ValidateMirror( HMIRROR_BUILDER hBuilder );

/*++
Function:
    DiskArray_SetTransferMode

Description:
    Set the transfer mode of a disk.
    The transfer mode can be retrieved by calling the DiskArray_GetStatus funtion

Arguments:
    hDisk - Identifies the disk the transfer mode of which will be set
    nMode - The transfer mode
    nSubMode - The submode

Returns:
    return TRUE
    else return FALSE if failed.

See also:
    DiskArray_GetStatus

--*/
BOOL WINAPI DiskArray_SetTransferMode( HDISK hDisk, int nMode, int nSubMode );

/*++
Function:
    DiskArray_RaiseError

Description:
    Get  disk error link
Arguments:
    pInfo - Points to a St_DiskArrayEvent containing the detail information of a 
            failure.

Returns:
    return TRUE
    else return FALSE if failed.

See also:
    DiskArray_WaitForFailure

--*/
BOOL WINAPI DiskArray_RaiseError(PSt_DiskArrayEvent pInfo);


//////////////////////
					// Added by SLeng
					//
/*++
Function:
    DiskArray_GetValidFlag

Description:
	This function will read the Valid Flag of a mirror array disk

Arguments:
	hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror

Returns:
	The Valid Flag for a mirror array disk, if read fail,
	the return value is ARRAY_INVALID.

See also:

--*/
UCHAR WINAPI DiskArray_GetValidFlag( HMIRROR_BUILDER hBuilder );


/*++
Function:
    DiskArray_SetValidFlag

Description:
	This function will set the Valid Flag of a mirror array disk

Arguments:
	hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror
	flag     - Specifies the value of valid flag, ARRAY_VALID to enable the device, 
				and ARRAY_INVALID to disable the device.

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL WINAPI DiskArray_SetValidFlag( HMIRROR_BUILDER hBuilder, UCHAR Flag);
BOOL WINAPI DiskArray_SetValidFlagEx( HDISK hDisk, UCHAR Flag);

/*++
Function:
    DiskArray_GetRebuiltSector

Description:
	This function will read the rebuilt sector of a mirror array disk

Arguments:
	hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror

Returns:
	The Value of rebuilt sector

See also:

--*/
ULONG WINAPI DiskArray_GetRebuiltSector( HMIRROR_BUILDER hBuilder );
//
// ldx overrode this function 12/20/00
//
ULONG WINAPI DiskArray_GetRebuiltSectorEx( HDISK hDisk );


/*++
Function:
	DiskArray_SetRebuiltSector

Description:
	This function will set the rebuilt sector of a mirror array disk

Arguments:
	hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror
	lSector  - The Value of rebuilt sector

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL WINAPI DiskArray_SetRebuiltSector( HMIRROR_BUILDER hBuilder, ULONG lSector);
BOOL WINAPI DiskArray_SetRebuiltSectorEx( HDISK hDisk, ULONG lSector);

/*++
Function:
	DiskArray_SetDeviceFlag

Description:
	This function will Disable/Enable a device

Arguments:
	hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror
	flag  - TRUE to Enable a device, FALSE to Disable a device.

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL WINAPI DiskArray_SetDeviceFlag( HMIRROR_BUILDER hBuilder, BOOL flag);


/*++
Function:
	DiskArray_VerifyMirrorBlock

Description:
	This function will verify a block for a mirror

Arguments:
	hDiskSrc, hDiskDest - Specifies the disks to verify
	uLba     - The start lba for verify
	nSectors - Verify sectors number

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL WINAPI DiskArray_VerifyMirrorBlock( HDISK hMirror, ULONG uLba, ULONG nSectors, BOOL bFix );


/*++
Function:
	DiskArray_RemoveSpareDisk

Description:
	This function will delete a spare disk from a mirror array

Arguments:
	hDisk - Specifies the disk to remove

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL WINAPI DiskArray_RemoveSpareDisk( HDISK hDisk );


/*++
Function:
	DiskArray_AddSpareDisk

Description:
	This function will add a spare disk to a mirror array

Arguments:
	hMirror - The mirror array
	hDisk   - Specifies the disk to add

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL WINAPI DiskArray_AddSpareDisk( HDISK hMirror, HDISK hDisk );


/*++
Function:
	DiskArray_AddMirrorDisk

Description:
	This function will add a mirror disk to a mirror array

Arguments:
	hMirror - The mirror array
	hDisk   - Specifies the disk to add

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL  WINAPI DiskArray_AddMirrorDisk( HDISK hMirror, HDISK hDisk);

//////////////////////


/*++
Function:
    DiskArray_GetDiskIsBroken

Description:
    Get  array of disk whether broken
Arguments:
    HMIRROR_BUILDER hBuilder
	BOOL &bBroken: output variable, if TRUE, then disk is broken
	int &type: output variable, if disk is broken, it is array type

Returns:
    return TRUE when success
    else return FALSE if failed.

Modify date:
	2000/11/20 by GengXin
--*/
BOOL WINAPI DiskArray_GetDiskIsBroken( HMIRROR_BUILDER hBuilder , BOOL &bBroken, int &type);

//gmm
BOOL WINAPI DiskArray_SetArrayName(HDISK hDisk, const char *name);
//ldx
BOOL WINAPI DiskArray_RescanAll();
BOOL WINAPI DiskArray_ReadPhysicalDiskSectors(int nControllerId,int nBusId,int nTargetId,
											  ULONG	nStartLba,ULONG	nSectors,LPVOID	lpOutBuffer);
BOOL WINAPI DiskArray_WritePhysicalDiskSectors(int nControllerId,int nBusId,int nTargetId,
											  ULONG	nStartLba,ULONG	nSectors,LPVOID	lpOutBuffer);

#ifdef  __cplusplus
}   //  extern C
#endif

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\hpinfo.h ===
/*++
Copyright (c) 1999, HighPoint Technologies, Inc.

Module Name:
    HpInfo.h - include file 

Abstract:

Author:
    HongSheng Zhang (HS)

Environment:

Notes:

Revision History:
    12-02-99    Created initiallly

--*/
#ifndef __HPINFO_H__
#define __HPINFO_H__
					 
//#include "hptenum.h"
#include "hptioctl.h"

///////////////////////////////////////////////////////////////////////
// macro define area
///////////////////////////////////////////////////////////////////////
#if	!defined(EXTERNC)
	#if defined(__cplusplus)
		#define EXTERNC	extern "C"
	#else					  
		#define EXTERNC extern
	#endif	// __cplusplus
#endif	// EXTERNC
///////////////////////////////////////////////////////////////////////
// function declare area
///////////////////////////////////////////////////////////////////////
EXTERNC
   HANDLE WINAPI HptConnectPort(int iPortId);
EXTERNC	
   VOID WINAPI HptReleasePort(HANDLE hPort);
EXTERNC
   BOOL WINAPI HptGetPhysicalDeviceInfo(HANDLE hPort, int iDeviceId, PSt_PHYSICAL_DEVINFO pDeviceInfo);
EXTERNC
   BOOL WINAPI HptCreateDiskArray(HANDLE hPort, int iDeviceId1, int iDeviceId2, BOOL fStripe);
EXTERNC
   BOOL WINAPI HptRemoveDiskArray(HANDLE hPort, int iDeviceId1, int iDeviceId2);
EXTERNC
   VOID WINAPI HptSwitchPower(HANDLE hPort, ULONG bPowerState);
EXTERNC
   DWORD WINAPI HptWaitForWarning(HANDLE hStopEvent);
#endif	// __HPINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\hptver.h ===
/*++
Copyright (c) 1999-2000, HighPoint Technologies, Inc.

Module Name:
	HptVer.h: Hpt driver version structure declare header file

Abstract:

Author:
    HongSheng Zhang (HS)

Environment:
	Window32 platform
Notes:

Revision History:
    01-11-2000  Created initiallly

--*/
#ifndef __HPTVER_H__
#define __HPTVER_H__
//
// Platform type id
//
typedef enum _eu_HPT_PLATFORM_ID{
	PLATFORM_ID_WIN32_WINDOWS,
	PLATFORM_ID_WIN32_NT = 0x80000000,
	PLATFORM_ID_WIN32_2K
} Eu_HPT_PLATFORM_ID;	 

#define HPT_FUNCTION_RAID	0x00000001
#define HPT_FUNCTION_HSWAP	0x00000002
//
// Device version info structure
//
typedef	struct _st_HPT_VERSION_INFO{				 
	ULONG	dwVersionInfoSize;
	ULONG	dwPlatformId;
	ULONG	dwDriverVersion;
	ULONG	dwSupportFunction;
} St_HPT_VERSION_INFO, *PSt_HPT_VERSION_INFO;

#define MAKE_VERSION_NUMBER(v1, v2, v3, date) ((v1)<<28 | (v2)<<24 | (v3)<<16 | date)
#define VERSION_NUMBER MAKE_VERSION_NUMBER(1, 0, 5, 212)

#endif	//__HPTVER_H__


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\raidctl.h ===
/*++
Copyright (c) HighPoint Technologies, Inc. 2000

Module Name:
    RaidCtl.h

Abstract:
    Defines the common types shared by user and kernel code of Disk Array Management

Author:
    Liu Ge (LG)

Revision History:
    07-14-2000  Created initiallly
--*/
#ifndef DiskArrayIoCtl_H_
#define DiskArrayIoCtl_H_

#pragma pack(push, 1)

//  The following defines the type of disk in a disk array
typedef enum
{
    enDA_Nothing,
    enDA_NonDisk,
    enDA_Physical,
    //  The following are all compound disks, i.e. they all consist of multiple physical disks
    enDA_Stripping, enDA_RAID0 = enDA_Stripping,
    enDA_Mirror, enDA_RAID1 = enDA_Mirror,
    enDA_RAID2,
    enDA_RAID3,
    enDA_RAID4,
    enDA_RAID5,
    enDA_RAID6,
    enDA_Complex,   //  This constant is defined for Multiple Level RAID
	enDA_TAPE,
	enDA_CDROM,

    enDA_Vendor = 0x80,
    enDA_Span,
    
    enDA_Unknown = 0xFF
}Eu_DiskArrayType;

typedef enum
{
    enDiskStatus_Working,
    enDiskStatus_WorkingWithError,
    enDiskStatus_Disabled,
    enDiskStatus_BeingBuilt,
    enDiskStatus_NeedBuilding,
}Eu_DiskWorkingStatus;

#ifdef DECLARE_HANDLE
DECLARE_HANDLE(HDISK);
#else
typedef HANDLE HDISK;
#endif

#define MAX_DEVICES_PER_BUS 8
struct St_IoBusInfo
{
    HDISK vecDevices[MAX_DEVICES_PER_BUS];
    UINT  uDevices;
};
typedef struct St_IoBusInfo St_IoBusInfo;

#define MAX_BUSES_PER_CONTROLLER    8
typedef enum
{
    STORAGE_CONTROLLER_SUPPORT_BUSMASTER        = 0,
    STORAGE_CONTROLLER_SUPPORT_RAID0            = 1,
    STORAGE_CONTROLLER_SUPPORT_RAID1            = 2,
    STORAGE_CONTROLLER_SUPPORT_RAID2            = 4,
    STORAGE_CONTROLLER_SUPPORT_RAID3            = 8,
    STORAGE_CONTROLLER_SUPPORT_RAID4            = 0x10,
    STORAGE_CONTROLLER_SUPPORT_RAID5            = 0x20,
    STORAGE_CONTROLLER_SUPPORT_RAID6            = 0x40,
    STORAGE_CONTROLLER_SUPPORT_RESERVED         = 0x80,
    STORAGE_CONTROLLER_SUPPORT_VENDOR_SPEC      = 0x100,
    STORAGE_CONTROLLER_SUPPORT_SPAN             = 0x200,
    STORAGE_CONTROLLER_SUPPORT_RESERVED1        = 0x400,
    STORAGE_CONTROLLER_SUPPORT_CACHE            = 0x800,
    STORAGE_CONTROLLER_SUPPORT_POWER_PROTECTION = 0x1000,
    STORAGE_CONTROLLER_SUPPORT_HOTSWAP          = 0x2000,
    STORAGE_CONTROLLER_SUPPORT_BOOTABLE_DEVICE  = 0x4000
}Eu_StorageControllerCapability;

#define MAX_NAME_LENGTH 260
typedef struct
{
    TCHAR szProductID[MAX_NAME_LENGTH];
    TCHAR szVendorID[MAX_NAME_LENGTH];

    int iInterruptRequest;

    St_IoBusInfo vecBuses[MAX_BUSES_PER_CONTROLLER];
    UINT  uBuses;
    
    int     nFirmwareVersion;
    int     nBIOSVersion;
    
    DWORD   dwCapabilites;  //  Please see Eu_StorageControllerCapability
    int     nClockFrquency;
    
    int     nCacheSize;
    int     nCacheLineSize;
}St_StorageControllerInfo;

typedef struct
{
    int iPathId;
    int iAdapterId; //  For a IDE controller, an adapter is equal to a channel
    int iTargetId;
    int iLunId;
}St_DiskPhysicalId, * PSt_DiskPhysicalId;

typedef enum
{
    DEVTYPE_DIRECT_ACCESS_DEVICE, DEVTYPE_DISK = DEVTYPE_DIRECT_ACCESS_DEVICE,
    DEVTYPE_SEQUENTIAL_ACCESS_DEVICE, DEVTYPE_TAPE = DEVTYPE_SEQUENTIAL_ACCESS_DEVICE,
    DEVTYPE_PRINTER_DEVICE,
    DEVTYPE_PROCESSOR_DEVICE,
    DEVTYPE_WRITE_ONCE_READ_MULTIPLE_DEVICE, DEVTYPE_WORM = DEVTYPE_WRITE_ONCE_READ_MULTIPLE_DEVICE,
    DEVTYPE_READ_ONLY_DIRECT_ACCESS_DEVICE, DEVTYPE_CDROM = DEVTYPE_READ_ONLY_DIRECT_ACCESS_DEVICE,
    DEVTYPE_SCANNER_DEVICE,
    DEVTYPE_OPTICAL_DEVICE,
    DEVTYPE_MEDIUM_CHANGER,
    DEVTYPE_COMMUNICATION_DEVICE,
    DEVTYPE_FLOPPY_DEVICE
}En_DeviceType;

typedef struct              
{
    ULONG	nErrorNumber;
    UCHAR	aryCdb[16];
}St_DiskError;

typedef struct
{
    St_DiskPhysicalId   PhysicalId;
    WORD                iDiskType;  	//  See Eu_DiskArrayType
	WORD				iRawArrayType;  // arrayType defined in driver
    TCHAR               szModelName[40];

    ULONG               uTotalBlocks;  //  The total number of blocks of a disk
    int                 nStripSize;		//  Blocks per strip

    BOOL                isSpare;    	// Indicate if this disk is a spare disk
    BOOL                isBootable;

    int                 nTransferMode;
    int                 nTransferSubMode;
    UCHAR					bestPIO;        /* Best PIO mode of this device */
    UCHAR 					bestDMA;        /* Best MW DMA mode of this device */
    UCHAR 					bestUDMA;		 /* Best Ultra DMA mode of this device */
	
    int                 iArrayNum;
    
    HDISK               hParentArray;   //  The handle of parent array if any
    DWORD               dwArrayStamp;   //  The stamp of an array
    
    int                 iOtherDeviceType;   //  See En_DeviceType

    int                 iWorkingStatus;     //  See Eu_DiskWorkingStatus
    
    St_DiskError        stLastError;    /* The last error occurred on this disk*/
	UCHAR				ArrayName[32];	//the name of array //added by wx 12/26/00
    
}St_DiskStatus, *PSt_DiskStatus;

typedef enum
{
    enDA_EventNothing,
    
    enDA_EventDiskFailure,

    enDA_EventCreateMirror,
    enDA_EventRemoveMirror,
    enDA_EventExpandMirror,
    enDA_EventShrinkMirror,
    enDA_EventCreateStripping,
    enDA_EventRemoveStripping,
    enDA_EventExpandStripping,
    enDA_EventShrinkStripping,
    enDA_EventPlug,
    enDA_EventUnplug,
    enDA_EventDisableDisk,
    enDA_EventEnableDisk,
    enDA_EventRebuildMirror,
    enDA_EventSetTransferMode,
    enDA_EventCreateSpan,
    enDA_EventRemoveSpan,
    enDA_EventExpandSpan,
    enDA_EventShrinkSpan,
	enDA_EventRemoveRaid01,
	enDA_EventRemoveRaid10,
	enDA_EventCreateRaid10
}Eu_DiskArrayEventType;

typedef struct
{
    HDISK	hDisk;						//  The handle of the failed disk
    BYTE	vecCDB[16];					//  About CDB, please see scsi.h
    BOOL	bNeedRebuild;				//  indicate if a rebuilding progress should be invoked
	ULONG	HotPlug;					//  The flag of disk add by hotplug
}St_DiskFailure, * PSt_DiskFailure;

typedef struct
{
    St_DiskPhysicalId DiskId;				//  The physical id of the failed disk
    BYTE	vecCDB[16];					//  About CDB, please see scsi.h
    BOOL	bNeedRebuild;				//  indicate if a rebuilding progress should be invoked
}St_DiskFailureInLog, * PSt_DiskFailureInLog;

typedef struct tagDiskArrayEvent
{
    int iType;  //  See Eu_DiskArrayEventType;
    ULARGE_INTEGER u64DateTime;  //  The data time of the event, equal to FILETIME

    union
    {
        St_DiskFailure DiskFailure;     //  this field stores the runtime information
        St_DiskFailureInLog DiskFailureInLog;
        //  Above field stores the failure information loaded from log file

        struct
        {
            int                 iMirrorNum;
            ULONG               uDiskNum;
            HDISK				* phDisks;
        }CreateMirror;
        struct
        {
            int iMirrorNum;
			HDISK hDisk;
        }RemoveMirror;
        struct
        {
            int iRaid10Num;
			HDISK hDisk;
        }CreateRaid10;
        struct
        {
            int                 iStrippingNum;
            ULONG               uDiskNum;
            St_DiskPhysicalId * pDisks;
        }CreateStripping;
        struct
        {
            int iStrippingNum;
        }RemoveStripping;
        struct
        {
            int                 iSpanNum;
            ULONG               uDiskNum;
            St_DiskPhysicalId * pDisks;
        }CreateSpan;
        struct
        {
            int iSpanNum;
        }RemoveSpan;
        struct
        {
            St_DiskPhysicalId DiskId;
        }Plug;
        struct
        {
            St_DiskPhysicalId DiskId;
        }Unplug;
        struct
        {
            int iMirrorNum;
        }RebuildMirror;
        struct
        {
            St_DiskPhysicalId DiskId;
            int nMode;
            int nSubMode;
        }SetTransferMode;
    }u;

    ULONG uResult;  //  zero represents success, nonzero represents error code

    PVOID pToFree;  //  this pointer points to a memory block this structure allocated if any
                    //  So, it is user's responsibility to free this block
                    //  if this structure is used in C code but not C++.
#ifdef  __cplusplus
    tagDiskArrayEvent()
    {
        memset( this, 0, sizeof(tagDiskArrayEvent) );
    }

    ~tagDiskArrayEvent()
    {
        if( pToFree )
        {
            delete pToFree;
            pToFree = NULL;
        }
    }
#endif
}St_DiskArrayEvent, * PSt_DiskArrayEvent;

#define REBUILD_INITIALIZE	  0	/* Clear Data */
#define BROKEN_MIRROR         1
#define CREATE_MIRROR_BUILD   2 /* this may be not useful now */
#define REBUILD_SYNCHRONIZE	  3 /* synchronize */


#pragma pack(pop)

#define HROOT_DEVICE    NULL

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\array.c ===
/***************************************************************************
 * File:          array.c
 * Description:   Subroutines in the file are used to perform the operations
 *                of array which are called at Disk IO and check, create and 
 *                remove array
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:   
 *     DH  05/10/2000 initial code
 *     GX  11/23/2000 process broken array in driver(Gengxin)
 *     SC  12/10/2000 add retry while reading RAID info block sector. This is
 *            			 caused by cable detection reset
 ***************************************************************************/


#include "global.h"

#ifdef _BIOS_
static int callFromDeleteArray = 0;
#endif

/***************************************************************************
 * Function:     BOOLEAN ArrayInterrupt(PDevice pDev) 
 * Description:  
 *               
 *               
 * Dependence:   array.h srb.h io.c
 * Source file:  array.c
 * Argument:     
 *               PDevice pDev - The device that is waiting for a interrupt
 *               
 * Retures:      BOOLEAN - TRUE  This interrupt is for the device
 *                         FALSE This interrupt is not for the device
 *               
 ***************************************************************************/
BOOLEAN ArrayInterrupt(PDevice pDev)
{
    PVirtualDevice    pArray = pDev->pArray;  
    PChannel          pChan = pDev->pChannel;
    PChannel          pIntrChan;
    int               i;
    LOC_SRB
    LOC_SRBEXT_PTR

	pIntrChan= pChan;
	/*
     * clean the bit of this device from the array waiting interrupt flag
     */
    pSrbExt->WaitInterrupt &= ~pDev->ArrayMask;

    /*
     * Find some error? Clean all bits of the devices which has not been
     * executed from the array waiting interrupt flag
     */
    if(Srb->SrbStatus != SRB_STATUS_PENDING) 
        pSrbExt->WaitInterrupt ^= pSrbExt->JoinMembers;

	 /*
     * No interrupt we should wait? 
     */
    if(pSrbExt->WaitInterrupt == 0) {

		  if(Srb->SrbStatus == SRB_STATUS_PENDING) {

		    /*
             * No.
             * write to the second stripe disk of a RAID 0+1 if it is a
             * mirror from two RAID0 and the operation is WRITE.
             */
             if(pArray->arrayType == VD_RAID_01_2STRIPE &&
				!(pSrbExt->WorkingFlags & SRB_WFLAGS_ON_SOURCE_DISK) &&
                Srb->Cdb[0] == SCSIOP_WRITE) {
mirror_stripe:
                /*+
                 * gmm: due to GUI change this mirror array may be a broken array.
                 *      we must check it before write to it.
                 */
                if (pArray->pDevice[MIRROR_DISK] == 0 ||
               (pArray->pDevice[MIRROR_DISK] && pArray->pDevice[MIRROR_DISK]->pArray &&
					pArray->pDevice[MIRROR_DISK]->pArray->BrokenFlag))
				{
					if (Srb->SrbStatus==SRB_STATUS_PENDING)
						Srb->SrbStatus = SRB_STATUS_SUCCESS;
                	goto finish;
				}
                //-*/
                
                /*
                 * tell bios that pArray has been changed
                 */
                BIOS_2STRIPE_NOTIFY

                /*
                 * Get the first disk of the second RAID0. see CheckArray for
                 * detail
                 */
                pDev = pArray->pDevice[MIRROR_DISK];
                pArray = pDev->pArray;
                /*
                 * Start command
                 */
				if((Srb->SrbFlags & (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)) &&
				   BuildSgl(pDev, pSrbExt->ArraySg ARG_SRB)){
					pSrbExt->SrbFlags &= ~ARRAY_FORCE_PIO;
				}else{
					pSrbExt->SrbFlags |= ARRAY_FORCE_PIO;
				}

				pSrbExt->JoinMembers = 0;
				Stripe_Prepare(pArray ARG_SRBEXT_PTR);
				pSrbExt->WaitInterrupt = pSrbExt->JoinMembers;

				WinSetSrbExt(pDev, pArray, Srb, pSrbExt);

				Srb->SrbStatus = SRB_STATUS_PENDING;
				StartArrayIo(pArray ARG_SRB);

                return TRUE;
			} 
			/*
			* RAID 1+0 case
			*/
			if (pArray->arrayType==VD_RAID_10_SOURCE && Srb->Cdb[0]==SCSIOP_WRITE) {
				int nDisk = pArray->nDisk;
				pSrbExt->JoinMembers = 0;
				Stripe_Prepare(pArray ARG_SRBEXT_PTR);
				pArray = pArray->pRAID10Mirror;
				for (i=0; i<nDisk; i++) {
					if (!pArray->pDevice[i] ||
						(pArray->pDevice[i]->DeviceFlags2 & DFLAGS_DEVICE_DISABLED))
						pSrbExt->JoinMembers &= ~(1<<i);
				}
				if (pSrbExt->JoinMembers==0) {
					Srb->SrbStatus = SRB_STATUS_SUCCESS;
					goto finish;
				}
				pSrbExt->WaitInterrupt = pSrbExt->JoinMembers;

				WinSetSrbExt(pDev, pArray, Srb, pSrbExt);

				Srb->SrbStatus = SRB_STATUS_PENDING;
                /*
                 * tell bios that pArray has been changed
                 */
                BIOS_2STRIPE_NOTIFY

				StartArrayIo(pArray ARG_SRB);

				return TRUE;
			}
            Srb->SrbStatus = SRB_STATUS_SUCCESS;
        }

        /*
         * find some error. recover the error
         */
        else  if(Srb->SrbStatus != SRB_STATUS_ABORTED) {
            /* 
             * add the recover code for RAID xxx here 
             */



            /*
             * recover for Mirror read
             */
			if((Srb->Cdb[0] == SCSIOP_READ) && 
				!(pSrbExt->WorkingFlags & SRB_WFLAGS_ON_SOURCE_DISK)
#ifndef _BIOS_
			   &&(Srb->Function != SRB_FUNCTION_IO_CONTROL)
#endif
			  ) {

				/*
                 * the mirror is the second RAID0 of a RAID0+1
                 */
				if(pArray->arrayType == VD_RAID_01_2STRIPE)
					goto mirror_stripe;

				/*
                 * the mirror is a single disk.
                 */
				if(pArray->pDevice[MIRROR_DISK] &&
				   pArray->pDevice[MIRROR_DISK] != pDev &&
				   pArray->arrayType != VD_RAID01_MIRROR) {
					pSrbExt->WaitInterrupt = 
											pSrbExt->JoinMembers = (1 << MIRROR_DISK);
					Srb->SrbStatus = SRB_STATUS_PENDING;
					StartArrayIo(pArray ARG_SRB);
					return TRUE;
				}
			}

        } 

finish: // gmm: added label
#ifndef _BIOS_
		  /*
         * copy data from internal buffer to user buffer if the SRB
         * is using the internal buffer. Win98 only
         */
        CopyInternalBuffer(pDev, Srb);

        if(pArray->arrayType == VD_RAID01_MIRROR) {
            pArray->Srb = 0;
            pArray = pArray->pDevice[MIRROR_DISK]->pArray;
        }
        else if(pArray->arrayType == VD_RAID_10_MIRROR) {
            pArray->Srb = 0;
            pArray = pArray->pRAID10Mirror;
        }

		/* gmm:
		 * we should using the initial channel when StartIO Called
		 * It's difficult to get it by pArray, since pArray may be broken
		 */
        pChan = pSrbExt->StartChannel;	
		if(pChan->CurrentSrb == Srb) {
			pChan->pWorkDev = 0;
			pChan->CurrentSrb = 0;
		}
        pArray->Srb = 0;
 
#endif

        OS_EndCmd_Interrupt(pChan ARG_SRB);
#ifndef _BIOS_
////// new adding 10/20/00 to fix r/w/c failure on two RAID
/////  disks. The command free channel might not be the same of
/////  current SRB channel
//////
		if(pIntrChan != pChan)
			CheckNextRequest(pIntrChan);
/////////////////
#endif

    }else{
        WIN_NextRequest(pChan);
    }

    return TRUE;
}

/******************************************************************
 * 
 *******************************************************************/

void StartArrayIo(PVirtualDevice pArray DECL_SRB)
{
    int i, flag = 0;
    LOC_SRBEXT_PTR
    PDevice pDevice;
    PChannel pChan;

    for(i = 0; i < (int)pArray->nDisk; i++) 
check_mirror:
        if(pSrbExt->JoinMembers & (1 << i)) {
            pDevice = pArray->pDevice[i];
			if(pDevice == NULL){
				continue;
			}
            flag++;
            pChan = pDevice->pChannel;
            if(btr(pChan->exclude_index) == 0) {
                OS_Set_Array_Wait_Flag(pDevice);
                continue;
            }

			pSrbExt->JoinMembers &= ~pDevice->ArrayMask;

            if(pDevice->DeviceFlags & DFLAGS_ARRAY_DISK) {
                if(pArray->arrayType == VD_SPAN) 
                    Span_Lba_Sectors(pDevice ARG_SRBEXT_PTR);
                else
                    Stripe_Lba_Sectors(pDevice ARG_SRBEXT_PTR);
            } else {
                pChan->Lba = pSrbExt->Lba;
                pChan->nSector = pSrbExt->nSector;
            }

            StartIdeCommand(pDevice ARG_SRB);
            if(Srb->SrbStatus != SRB_STATUS_PENDING) 
                DeviceInterrupt(pDevice, 1);
        }

    if(i == (int)pArray->nDisk) {
        i = MIRROR_DISK;
        goto check_mirror;
    }
	 // if the whole array is removed then no command can't be sent
    // to disks. In this case, driver should report "selection timeout"
    // to inform kernel device is disabled
	 //
    if(flag == 0) {
       Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT ;
    }
}

/******************************************************************
 * Check if this disk is a member of array
 *******************************************************************/

#define OldArrayBlk        ArrayBlk.old

void CheckArray(
                IN PDevice pDevice
               )
{
    PChannel             pChan = pDevice->pChannel;
    PVirtualDevice       pStripe, pMirror;
    UCHAR                Mode, i=0;
    LOC_ARRAY_BLK;

    ReadWrite(pDevice, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
#ifdef _BIOS_
    Mode = (UCHAR)ArrayBlk.Signature;
	 while(Mode ==0 && i++<3) {
          ReadWrite(pDevice, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
          Mode = (UCHAR)ArrayBlk.Signature;
		    StallExec(1000L);
    }
#endif

    Mode = (UCHAR)ArrayBlk.DeviceModeSelect;
    if(ArrayBlk.ModeBootSig == HPT_CHK_BOOT &&
       DEVICE_MODE_SET(ArrayBlk.DeviceModeSelect) &&
       Mode <= pDevice->Usable_Mode &&
       Mode != pDevice->DeviceModeSetting)
    {   //  set device timing mode
        DeviceSelectMode(pDevice, Mode);
    }


#ifdef CHECK_OLD_FORMAT
    if(OldArrayBlk.Signature == HPT_ARRAY_OLD) {
        for(pStripe = VirtualDevices; pStripe < pLastVD; pStripe++) 
            if(OldArrayBlk.CreateTime == pStripe->capacity && 
               OldArrayBlk.CreateDate == pStripe->Stamp) 
                goto old_set;
        pStripe = pLastVD++;
        ZeroMemory(pStripe, sizeof(VirtualDevice));
        pStripe->capacity = OldArrayBlk.CreateTime;
        pStripe->Stamp = OldArrayBlk.CreateDate;
        pStripe->ArrayNumBlock = OLD_FORMAT;
old_set:
        pStripe->nDisk++;
        pStripe->pDevice[OldArrayBlk.DeviceNum] = pDevice;

        if(pStripe->nDisk != OldArrayBlk.nDisks) 
            goto hiden;

        pStripe->capacity = OldArrayBlk.capacity;
        pStripe->BlockSizeShift = 3;
        pStripe->ArrayNumBlock = (1 << 3);

        if(OldArrayBlk.nDisks == 4) {
            pMirror = pLastVD++;
            ZeroMemory(p, sizeof(VirtualDevice));
            pMirror->nDisk = pStripe->nDisk = 2;
            pMirror->pDevice[0] = pStripe->pDevice[2];
            pMirror->pDevice[1] = pStripe->pDevice[3];
            pStripe->pDevice[2] = 0;
            pStripe->pDevice[3] = 0;
            pMirror->pDevice[0]->DeviceFlags |= DFLAGS_ARRAY_DISK;
            pMirror->pDevice[1]->DeviceFlags |= DFLAGS_ARRAY_DISK;
            pStripe->arrayType = VD_RAID_0_STRIPE;
            goto set_first;

        } else if(pStripe->pDevice[2]) {
            pStripe->pDevice[MIRROR_DISK] = pStripe->pDevice[2];
            pStripe->pDevice[2] = 0;
            pStripe->arrayType = VD_RAID_1_MIRROR;
        } else {
set_first:
            pStripe->pDevice[0]->DeviceFlags |= DFLAGS_ARRAY_DISK;
            pStripe->pDevice[1]->DeviceFlags |= DFLAGS_ARRAY_DISK;
            pStripe->arrayType = VD_RAID_0_STRIPE;
        }
        return;
    }
#endif // CHECK_OLD_FORMAT

//////////////////
				// Modified by Gengxin, 11/22/2000
				// Enable process broken disk
	if( (ArrayBlk.Signature != HPT_ARRAY_NEW) && (ArrayBlk.Signature != HPT_TMP_SINGLE))
		goto os_check;
	
	//Old code
	//if(ArrayBlk.Signature != HPT_ARRAY_NEW BIOS_CHK_TMP(ArrayBlk.Signature))
	//	goto os_check;
//////////////////

    pStripe = pMirror = 0;
    for(pStripe = VirtualDevices; pStripe < pLastVD; pStripe++) 
    {
        if(ArrayBlk.StripeStamp == pStripe->Stamp) 
        {   //  find out that this disk is a member of an existing array
            goto set_device;
        }
    }

    pStripe = pLastVD++;
    ZeroMemory(pStripe, sizeof(VirtualDevice));
    pStripe->arrayType = ArrayBlk.ArrayType;
    pStripe->Stamp = ArrayBlk.StripeStamp;
    /*+
     * gmm: We will clear Broken flag only on a array correctly constructed.
     *		Otherwise the GUI will report a wrong status.
     */
    pStripe->BrokenFlag = TRUE;
    //-*/
	/* 
	 * if it's a 1+0 array we will allocate another structure to hold the mirrors
	 */
	if ((pStripe->arrayType==VD_RAID_10_SOURCE || pStripe->arrayType==VD_RAID_10_MIRROR) 
		&& pStripe->pRAID10Mirror==NULL)
	{
		ZeroMemory(pLastVD, sizeof(VirtualDevice));
		pStripe->pRAID10Mirror = pLastVD;
		pLastVD->pRAID10Mirror = pStripe;
		pLastVD->arrayType = (pStripe->arrayType==VD_RAID_10_SOURCE)?
			VD_RAID_10_MIRROR : VD_RAID_10_SOURCE;
		pLastVD->Stamp = pStripe->Stamp;
		pLastVD->BrokenFlag = TRUE;
		pLastVD++;
	}

set_device:
	/* gmm */
	pDevice->RebuiltSector = ArrayBlk.RebuiltSector;

	if ((pStripe->arrayType==VD_RAID_10_SOURCE || pStripe->arrayType==VD_RAID_10_MIRROR) 
		&& ArrayBlk.ArrayType!=pStripe->arrayType)
		pStripe = pStripe->pRAID10Mirror;

    if(pStripe->pDevice[ArrayBlk.DeviceNum] != 0)	//if the position exist disk then ...
	{												//for prevent a array destroied
        ArrayBlk.Signature = 0;
        ReadWrite(pDevice, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
        goto os_check;
    }
    {
	    int iName = 0;
	    if(pStripe->ArrayName[0] == 0)
		for(iName=0; iName<32; iName++)
			pStripe->ArrayName[iName] = ArrayBlk.ArrayName[iName];
	}

//////////////////
				// Add by Gengxin, 11/22/2000
				// For enable process broken array
				// When pDevice[0] lost,
				// disk of after pDevice[0] change to pDevice[0],
				// otherwise driver will down.
#ifndef _BIOS_
	if( (ArrayBlk.Signature == HPT_TMP_SINGLE) &&
			(ArrayBlk.ArrayType == VD_RAID_1_MIRROR) &&
			(ArrayBlk.DeviceNum ==  MIRROR_DISK) )
	{
		ArrayBlk.DeviceNum= 0;
	}
	else if( (ArrayBlk.Signature == HPT_TMP_SINGLE) &&
		(ArrayBlk.ArrayType == VD_RAID_0_STRIPE) &&
		(pStripe->pDevice[0] ==0 ) &&  //if the stripe contain disk number>2, need the condition
		//||(ArrayBlk.ArrayType == VD_SPAN)
		(ArrayBlk.DeviceNum != 0) )  //if raid0 then it can't reach here, only for raid0+1
								//because if raid0 broken,then it will become physical disk
	{
		ArrayBlk.DeviceNum= 0;
	}

	/*-
	 * gmm: rem out this code. See also above code
	 *
	if( ArrayBlk.Signature == HPT_TMP_SINGLE )
	{
		pStripe->BrokenFlag= TRUE;
		pMirror->BrokenFlag= TRUE; // pMirror==NULL now
	}
	*/

#endif //_BIOS_
//////////////////
    
    pStripe->pDevice[ArrayBlk.DeviceNum] = pDevice;

    pDevice->ArrayNum  = ArrayBlk.DeviceNum;
    pDevice->ArrayMask = (UCHAR)(1 << ArrayBlk.DeviceNum);
    pDevice->pArray    = pStripe;

	// RAID 1+0 case
	if (pStripe->arrayType==VD_RAID_10_SOURCE || pStripe->arrayType==VD_RAID_10_MIRROR) {
		pStripe->nDisk = ArrayBlk.nDisks;
        pStripe->BlockSizeShift = ArrayBlk.BlockSizeShift;
        pStripe->ArrayNumBlock = (UCHAR)(1 << ArrayBlk.BlockSizeShift);
        pStripe->capacity = ArrayBlk.capacity;
        if(ArrayBlk.DeviceNum != 0) {
            pDevice->HidenLBA = (RECODR_LBA + 1);
            pDevice->capacity -= (RECODR_LBA + 1);
        }
		goto os_check;
	}
//////////////////
				// Added by SLeng, 11/20/2000
				//
//    if(ArrayBlk.Validity == ARRAY_INVALID)
//	{	// Set the device disabled flag
//		pDevice->DeviceFlags2 |= DFLAGS_DEVICE_DISABLED;
//	}
//////////////////

    if(ArrayBlk.DeviceNum <= ArrayBlk.nDisks) {
        if(ArrayBlk.DeviceNum < ArrayBlk.nDisks) 
        {
            pStripe->nDisk++;
        }

        if(ArrayBlk.DeviceNum != 0) {
            pDevice->HidenLBA = (RECODR_LBA + 1);
            pDevice->capacity -= (RECODR_LBA + 1);
        }
        
        if(ArrayBlk.nDisks > 1)
        {
            pDevice->DeviceFlags |= DFLAGS_ARRAY_DISK;
        }

    } 
    else if(ArrayBlk.DeviceNum == MIRROR_DISK) 
    {

      pStripe->arrayType = (UCHAR)((ArrayBlk.nDisks == 1)? 
           VD_RAID_1_MIRROR : VD_RAID_01_1STRIPE);
//      if(pStripe->capacity)
//          pStripe->Stamp = ArrayBlk.order & SET_ORDER_OK;
      goto hiden;

    } 
    else if(ArrayBlk.DeviceNum == SPARE_DISK) 
    {
        goto hiden;
    }

   if( (pStripe->nDisk == ArrayBlk.nDisks)
//////////////
			// Added by Gengxin, 11/24/2000
			// For process array broken .
			// Let broken array may become a array.
#ifndef _BIOS_
		||(ArrayBlk.Signature == HPT_TMP_SINGLE)
#endif //_BIOS_
//////////////
		)
	{
 		//+
 		// gmm:
		// An array is completely setup.
		// Unhide pDevice[0].
		// Thus the hidden flag is consistent with BIOS setting interface.
		//
		pDevice->DeviceFlags |= DFLAGS_HIDEN_DISK; 
		if (pStripe->pDevice[0]) pStripe->pDevice[0]->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
		//-*/
		
        pStripe->BlockSizeShift = ArrayBlk.BlockSizeShift;
        pStripe->ArrayNumBlock = (UCHAR)(1 << ArrayBlk.BlockSizeShift);
        pStripe->capacity = ArrayBlk.capacity;

        //  check if there are some 0+1 arrays
        if(ArrayBlk.MirrorStamp) 
        {
            for(pMirror = VirtualDevices; pMirror < pLastVD; pMirror++) 
            {
                //  looking for another member array of the 0+1 array
                if( pMirror->arrayType != VD_INVALID_TYPE &&
					pMirror != pStripe && 
                    pMirror->capacity != 0 &&
                    ArrayBlk.MirrorStamp == pMirror->Stamp ) 
                {
					int i;
					PVirtualDevice	pArrayNeedHide;
					
					//  find the sibling array of 'pStripe', it 'pMirror'
                    pStripe->pDevice[MIRROR_DISK] = pMirror->pDevice[0];
                    pMirror->pDevice[MIRROR_DISK] = pStripe->pDevice[0];
                    
                    //  If the order flag of this disk contains SET_ORDER_OK,
                    //  it belongs to the original array of the 0+1 array
                    if( ArrayBlk.order & SET_ORDER_OK )
                    {   //  so the 'pStripe' points to the original array
                        pStripe->arrayType = VD_RAID_01_2STRIPE;
                        pMirror->arrayType = VD_RAID01_MIRROR;
						pArrayNeedHide = pMirror;
                    }
                    else
                    {   //  else the disk belongs to the mirror array of the 0+1 array
                        //  so the 'pStripe' points to the mirror array
                        pStripe->arrayType = VD_RAID01_MIRROR;
                        pMirror->arrayType = VD_RAID_01_2STRIPE;
						
						// now save the true mirror stripe point to
						// pMirror
						pArrayNeedHide = pStripe;
                    }
                    
                    if(ArrayBlk.capacity < pMirror->capacity)
                    {
                        pMirror->capacity = ArrayBlk.capacity;
                    }

//                    pMirror->Stamp = ArrayBlk.order & SET_ORDER_OK;
					
					// now we need hide all disk in mirror group
					for(i = 0; i < pArrayNeedHide->nDisk; i++){
						pArrayNeedHide->pDevice[i]->DeviceFlags |= DFLAGS_HIDEN_DISK;
					}
                }
            }
            
            pStripe->Stamp = ArrayBlk.MirrorStamp;

        } 
//      else if(pStripe->pDevice[MIRROR_DISK])
//         pStripe->Stamp = ArrayBlk.order & SET_ORDER_OK;

    } else
hiden:
//////////
		// Add by Gengxin, 11/30/2000
		// If the disk belong to a broken array(stripe or mirror),
		// then its 'hidden_flag' disable .
	{
		if (
			(ArrayBlk.Signature == HPT_TMP_SINGLE) &&
				( pStripe->arrayType==VD_RAID_0_STRIPE ||
				  pStripe->arrayType==VD_RAID_1_MIRROR
				)
			)
			pDevice->DeviceFlags |= ~DFLAGS_HIDEN_DISK;
		else
			pDevice->DeviceFlags |= DFLAGS_HIDEN_DISK; 
	}
////////// for process broken array

    /*+
     * gmm: We will clear Broken flag only on a array correctly constructed.
     *		Otherwise the GUI will report a wrong status.
     */
    switch(pStripe->arrayType){
    case VD_RAID_0_STRIPE:
    case VD_RAID_01_2STRIPE:
    case VD_RAID01_MIRROR:
    case VD_SPAN:
	    if (pStripe->nDisk == ArrayBlk.nDisks)
	    	pStripe->BrokenFlag = FALSE;
	    break;
	case VD_RAID_1_MIRROR:
		if (pStripe->pDevice[0] && pStripe->pDevice[MIRROR_DISK])
			pStripe->BrokenFlag = FALSE;
		break;
	case VD_RAID_01_1STRIPE:
		if (pStripe->pDevice[0] && pStripe->pDevice[1] && pStripe->pDevice[MIRROR_DISK])
			pStripe->BrokenFlag = FALSE;
		/*
		 * for this type of 0+1 we should check which is the source disk.
		 */
		if (ArrayBlk.DeviceNum==MIRROR_DISK && (ArrayBlk.order & SET_ORDER_OK))
			pStripe->RaidFlags |= RAID_FLAGS_INVERSE_MIRROR_ORDER;
		break;
	default:
		break;
	}
#ifndef _BIOS_
	if (pStripe->capacity ==0 ) pStripe->capacity=ArrayBlk.capacity;
#endif
	if (!pStripe->BrokenFlag) {
		if (pStripe->pDevice[0]->RebuiltSector < pStripe->capacity)
			pStripe->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
	}
    //-*/

os_check:

	OS_Array_Check(pDevice); 
}

/***************************************************************************
 * Description:  Adjust 2 array structure of RAID 10 so the source is always
 *  functional when possible
 ***************************************************************************/
void AdjustRAID10Array(PVirtualDevice pArray)
{
	int i, nDisks;
	PDevice pDev;
	PVirtualDevice pMirror;
	int totalDisks;
	if (pArray->arrayType!=VD_RAID_10_SOURCE) return;
	pMirror = pArray->pRAID10Mirror;
	totalDisks = MAX(pArray->nDisk, pMirror->nDisk);
	nDisks = 0;
	for (i=0; i<totalDisks; i++) {
		if (!(pDev=pArray->pDevice[i]) ||
			(pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED))
		{
			if ((pDev=pMirror->pDevice[i]) && 
				!(pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED))
			{
				// swap this two devices
				if (pMirror->pDevice[i]=pArray->pDevice[i])
					pMirror->pDevice[i]->pArray=pMirror;
				pArray->pDevice[i] = pDev;
				pDev->pArray = pArray;
				pDev->DeviceFlags2 ^= DFLAGS_DEVICE_SWAPPED; // use XOR here
			}
			else
				break;
		}
		nDisks++;
	}
	if (nDisks<totalDisks || totalDisks==0) {
		pArray->BrokenFlag = TRUE;
		pArray->RaidFlags |= RAID_FLAGS_DISABLED;
		pArray->pRAID10Mirror->RaidFlags |= RAID_FLAGS_DISABLED;
	}
	else {
		pArray->nDisk = (UCHAR)nDisks;
		pArray->pRAID10Mirror->nDisk = (UCHAR)nDisks;
		pArray->BrokenFlag = FALSE;
		pArray->RaidFlags &= ~RAID_FLAGS_DISABLED;
		pArray->pRAID10Mirror->BrokenFlag = FALSE;
		pArray->pRAID10Mirror->RaidFlags &= ~RAID_FLAGS_DISABLED;
		for (i=0; i<nDisks; i++) {
			pDev = pArray->pDevice[i];
            pDev->DeviceFlags |= DFLAGS_ARRAY_DISK;
			if (i>0){
	            pDev->DeviceFlags |= DFLAGS_HIDEN_DISK;
			} else
				pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
			if (pDev = pArray->pRAID10Mirror->pDevice[i]) {
	            pDev->DeviceFlags |= DFLAGS_ARRAY_DISK | DFLAGS_HIDEN_DISK;
			}
			else {
				pArray->pRAID10Mirror->BrokenFlag = TRUE;
				pArray->pRAID10Mirror->RaidFlags |= RAID_FLAGS_DISABLED;
			}
			// check for rebuild state
			{
				PDevice pDev1, pDev2;
				ULONG mirror_cap;
				if ((pDev1=pArray->pDevice[i]) && (pDev2=pArray->pRAID10Mirror->pDevice[i])) {
					mirror_cap = pDev1->capacity;
					if (mirror_cap > pDev2->capacity) mirror_cap = pDev2->capacity;
					if (pDev1->RebuiltSector<mirror_cap || pDev2->RebuiltSector<mirror_cap) {
						pDev1->DeviceFlags2 |= DFLAGS_NEED_REBUILD;
						pDev2->DeviceFlags2 |= DFLAGS_NEED_REBUILD;
					}
				}
			}
        }
	}
}

/***************************************************************************
 * Description:
 *   Adjust array settings after all device is checked
 *   Currently we call it from hwInitialize370 
 *   But it works only when one controller installed
 ***************************************************************************/
void Final_Array_Check()
{
	PVirtualDevice pArray;
	PDevice pDev;
	LOC_ARRAY_BLK;

	for (pArray=VirtualDevices; pArray<pLastVD; pArray++) {
		switch (pArray->arrayType){
		case VD_RAID_1_MIRROR:
			if ((!pArray->pDevice[0]) && pArray->pDevice[MIRROR_DISK]) {
				/*
				 * source lost. Change mirror disk to source.
				 */
				pDev = pArray->pDevice[MIRROR_DISK];
				pDev->ArrayMask = 1;
				pDev->ArrayNum = 0;
				pArray->pDevice[0] = pDev;
				pArray->pDevice[MIRROR_DISK] = NULL;
				pArray->nDisk = 1;
				ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
				ArrayBlk.DeviceNum = 0;
				ArrayBlk.StripeStamp++; // use another stamp.// = GetStamp();
				ArrayBlk.RebuiltSector = 0;
				ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
				pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
			}
			break;
		case VD_RAID_0_STRIPE:
		case VD_RAID_01_2STRIPE:
		case VD_RAID01_MIRROR:
			if (pArray->BrokenFlag)
				pArray->RaidFlags |= RAID_FLAGS_DISABLED;
			break;
		case VD_RAID_10_SOURCE:
			AdjustRAID10Array(pArray);
			break;
		}

#ifndef _BIOS_
		/*
		 *  check bootable flag.
		 */
		pDev = pArray->pDevice[0];
		if (pDev && !(pDev->DeviceFlags & DFLAGS_HIDEN_DISK))
		{
			struct master_boot_record mbr;
			ReadWrite(pDev, 0, IDE_COMMAND_READ, (PUSHORT)&mbr);
			if (mbr.signature==0xAA55) {
				int i;
				for (i=0; i<4; i++) {
					if (mbr.parts[i].bootid==0x80) {
						pArray->RaidFlags |= RAID_FLAGS_BOOTDISK;
						break;
					}
				}
			}
		}
#endif
	}
}

/***************************************************************************
 * Description:  Seperate a array int single disks
 ***************************************************************************/

void MaptoSingle(PVirtualDevice pArray, int flag)
{
    PDevice pDev;
    UINT    i;
//    LOC_ARRAY_BLK;

    if(flag == REMOVE_DISK) {
        i = MIRROR_DISK;
        pDev = (PDevice)pArray;
        goto delete;
    }

    pArray->nDisk = 0;
    for(i = 0; i < MAX_MEMBERS; i++) {
        if((pDev = pArray->pDevice[i]) == 0)
            continue;
delete:
        pDev->DeviceFlags &= ~(DFLAGS_HIDEN_DISK | DFLAGS_ARRAY_DISK);
        pDev->pArray = 0;
        if(pDev->ArrayNum && i < SPARE_DISK) {
            pDev->capacity += (RECODR_LBA + 1);
            pDev->HidenLBA = 0;
        }
        pDev->DeviceFlags &= ~(DFLAGS_HIDEN_DISK | DFLAGS_ARRAY_DISK);
#ifdef _BIOS_
        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
        ArrayBlk.Signature = (flag != REMOVE_TMP)? (ULONG)0 : (ULONG)HPT_TMP_SINGLE; 
        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif        
    }
}

/***************************************************************************
 * Description:  Create Mirror
 ***************************************************************************/

ULONG   Last_stamp = 0;
  
void SetArray(PVirtualDevice pArray, int flag, ULONG stamp)
{
    PDevice        pDev;
    ULONG          Stamp = GetStamp();
    UINT           i, j;
    LOC_ARRAY_BLK;

    if(Stamp == Last_stamp)
        Stamp++;
    Last_stamp = Stamp;

    i = pArray - VirtualDevices;
    Stamp |= (i << 24);

    for(i = 0; i < MAX_MEMBERS; i++) {
        if((pDev = pArray->pDevice[i]) == 0)
            continue;

		ZeroMemory((char *)&ArrayBlk, 512);
    
#ifdef _BIOS_
        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
#endif

#ifdef _BIOS_
		//wx clear ArrayName
		if(pArray->arrayType == 2 || pArray->arrayType == 6 || pArray->arrayType == 7 )
		{
			for(j=0; j<16; j++)
				ArrayBlk.ArrayName[j+16] = 0;
		}
		else if(callFromDeleteArray != 1)
		{
			for(j=0; j<32; j++)
				ArrayBlk.ArrayName[j] = 0;
		}
		for(j=0; j<32; j++)
			pArray->ArrayName[j] = ArrayBlk.ArrayName[j];
		//end clear
#endif
		
        ArrayBlk.Signature = HPT_ARRAY_NEW; 
        ArrayBlk.order = flag;

        pDev->pArray = pArray;
        pDev->ArrayNum  = (UCHAR)i;
        pDev->ArrayMask = (UCHAR)(1 << i);

        ArrayBlk.StripeStamp  = Stamp;
        ArrayBlk.nDisks       = pArray->nDisk;            
        ArrayBlk.BlockSizeShift = pArray->BlockSizeShift;
        ArrayBlk.DeviceNum    = (UCHAR)i; 

        if(flag & SET_STRIPE_STAMP) {
            pDev->DeviceFlags |= DFLAGS_HIDEN_DISK;
            if(pArray->nDisk > 1)
                pDev->DeviceFlags |= DFLAGS_ARRAY_DISK;

            if(i == 0) {
                pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
                pArray->ArrayNumBlock = (UCHAR)(1 << pArray->BlockSizeShift);
                pDev->HidenLBA = 0;
            } else if (i < SPARE_DISK) {
                pDev->capacity -= (RECODR_LBA + 1);
                pDev->HidenLBA = (RECODR_LBA + 1);
            }

            ArrayBlk.ArrayType    = pArray->arrayType;    
            ArrayBlk.MirrorStamp  = 0;
        }

        if(flag & SET_MIRROR_STAMP) {
            ArrayBlk.MirrorStamp  = stamp;
            ArrayBlk.ArrayType    = VD_RAID_01_2STRIPE;    
        }

        ArrayBlk.capacity = pArray->capacity; 

#ifdef _BIOS_
		/*+
		 * gmm: clear RebuiltSector
		 */
		if (callFromDeleteArray) ArrayBlk.RebuiltSector = 0;
		//-*/
#endif

/*********** Wang Beiwen 2000.11.10 *******************/
		//if (ArrayBlk.lDevSpec!=SPECIALIZED_CHAR) 
		//{
		//	ArrayBlk.lDevSpec=SPECIALIZED_CHAR;
		//	ArrayBlk.lDevFlag=0x00000001;
		//}
		//if (pArray->lMaxDevFlag==0) pArray->lMaxDevFlag=1;
 		//ArrayBlk.lDevFlag=pArray->lMaxDevFlag;
 		//ArrayBlk.lDevDate=GetCurrentDate();
		//ArrayBlk.lDevTime=GetCurrentTime();
	

/******************************************************/
		
#ifdef _BIOS_
        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif        
    }
}

/***************************************************************************
 * Description:  Create Array
 ***************************************************************************/

int CreateArray(PVirtualDevice pArray, int flags)
{
    PVirtualDevice pMirror;
    PDevice        pDev, pSec;
    ULONG          capacity, tmp;
    UINT           i, j;
    LOC_ARRAY_BLK;

    if(pArray->arrayType == VD_SPAN) {
        capacity = 0;
        for(i = 0; i < pArray->nDisk; i++)
            capacity += (pArray->pDevice[i]->capacity - RECODR_LBA - 1);
        goto  set_array;
    }

    capacity = 0x7FFFFFFF;

    for(i = 0; i < pArray->nDisk; i++) {
        pSec = pArray->pDevice[i];
        tmp = (pSec->pArray)? pSec->pArray->capacity : pSec->capacity;
        if(tmp < capacity) {
            capacity = tmp;
            pDev = pSec;
        }
    }

    switch(pArray->arrayType) {
        case VD_RAID_1_MIRROR:
        case VD_RAID_01_2STRIPE:
            if(pDev != pArray->pDevice[0]) 
                return(MIRROR_SMALL_SIZE);

            pSec = pArray->pDevice[1];

            if((pMirror = pSec->pArray) != 0 && pDev->pArray) {
                pArray = pDev->pArray;
                tmp = ++Last_stamp;
#ifdef _BIOS_        
				callFromDeleteArray = 1;
#endif
                SetArray(pArray, SET_MIRROR_STAMP | SET_ORDER_OK, tmp);
                SetArray(pMirror, SET_MIRROR_STAMP, tmp);
#ifdef _BIOS_        
				callFromDeleteArray = 0;
#endif			
                pArray->pDevice[MIRROR_DISK] = pMirror->pDevice[0];
                pMirror->pDevice[MIRROR_DISK] = pArray->pDevice[0];
                pArray->arrayType = VD_RAID_01_2STRIPE;
                pMirror->arrayType = VD_RAID01_MIRROR;
                pSec->DeviceFlags |= DFLAGS_HIDEN_DISK;
                pArray->Stamp = SET_ORDER_OK;
                return(RELEASE_TABLE);
            } else if(pMirror) {
                i = SET_STRIPE_STAMP;
single_stripe:
                pMirror->capacity = capacity;
                pMirror->pDevice[MIRROR_DISK] = pDev;
#ifdef _BIOS_        
				callFromDeleteArray = 1;
#endif
                SetArray(pMirror, i, 0);
#ifdef _BIOS_        
				callFromDeleteArray = 0;
#endif
                pMirror->arrayType = VD_RAID_01_1STRIPE;
                pMirror->Stamp = i & SET_ORDER_OK;
                return(RELEASE_TABLE);
            } else if((pMirror = pDev->pArray) != 0) {
                pDev = pSec;
                i = SET_STRIPE_STAMP | SET_ORDER_OK;
                goto single_stripe;
            } else {
                pArray->nDisk = 1;
                pArray->capacity = capacity;
                
//////////////////
				//Modified by Gengxin, 2000/11/22
				//old code : pArray->arrayType = VD_RAID_0_STRIPE;
				pArray->arrayType = VD_RAID_1_MIRROR;
//////////////////
                
                pArray->pDevice[MIRROR_DISK] = pSec;
                pArray->pDevice[1] = 0;
#ifdef _BIOS_        
				callFromDeleteArray = 0;
#endif
                SetArray(pArray, SET_STRIPE_STAMP | SET_ORDER_OK, 0);
                pArray->arrayType = VD_RAID_1_MIRROR;
                pArray->Stamp = SET_ORDER_OK;
            }
            break;

        case VD_RAID_3:
        case VD_RAID_5:
            pArray->nDisk--;

        default:
            capacity -= (RECODR_LBA + 1);
            capacity &= ~((1 << pArray->BlockSizeShift) - 1);
            capacity = LongMul(capacity, pArray->nDisk);

            pArray->ArrayNumBlock = (UCHAR)(1 << pArray->BlockSizeShift);

            if(flags)
                goto set_array;

            for(i = 0; i < MAX_MEMBERS; i++) {
                if((pDev = pArray->pDevice[i]) == 0)
                    continue;
                ZeroMemory((char *)&ArrayBlk, 512);
				
#ifdef _BIOS_
				// write win2000 signature.
				*(ULONG*)&((struct master_boot_record*)&ArrayBlk)->bootinst[440] = 0x5FDE642F;
//				((struct master_boot_record*)&ArrayBlk)->signature = 0xAA55;
                ReadWrite(pDev, 0, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif                
            }

set_array:
            pArray->capacity = capacity;

            SetArray(pArray, SET_STRIPE_STAMP, 0);
    }
    return(KEEP_TABLE);
}

/***************************************************************************
 * Description:  Remove a array
 ***************************************************************************/

void CreateSpare(PVirtualDevice pArray, PDevice pDev)
{

    pArray->pDevice[SPARE_DISK] = pDev;
#ifdef _BIOS_
	{
		LOC_ARRAY_BLK;	
		ReadWrite(pArray->pDevice[0], RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
		ArrayBlk.DeviceNum = SPARE_DISK; 
		ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
	}
#endif    
    pDev->pArray = pArray;
    pDev->DeviceFlags |= DFLAGS_HIDEN_DISK;
    pDev->ArrayNum  = SPARE_DISK; 
}

/***************************************************************************
 * Description:  Remove a array
 ***************************************************************************/

void DeleteArray(PVirtualDevice pArray)
{
    int i, j;
    PDevice pTmp, pDev;
    ULONG Mode;

    LOC_ARRAY_BLK;
    
    pDev = pArray->pDevice[MIRROR_DISK];

    switch(pArray->arrayType) {
        case VD_RAID_01_1STRIPE:
            MaptoSingle((PVirtualDevice)pDev, REMOVE_DISK);
            i = 2;
            goto remove;

        case VD_RAID01_MIRROR:
        case VD_RAID_01_2STRIPE:
            for(i = 0; i < 2; i++, pArray = (pDev? pDev->pArray: NULL)) {
remove:
				if (!pArray) break;
                pArray->arrayType = VD_RAID_0_STRIPE;
                pArray->pDevice[MIRROR_DISK] = 0;
                for(j = 0; (UCHAR)j < SPARE_DISK; j++) 
                    if((pTmp = pArray->pDevice[j]) != 0)
                        pTmp->pArray = 0;
                if (pArray->nDisk)
					CreateArray(pArray, 1);
				else
					goto delete_default;
            }
            break;

        default:
delete_default:
            for(i = 0; i < SPARE_DISK; i++) {
                if((pDev = pArray->pDevice[i]) == 0)
                    continue;

            	ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
				Mode = ArrayBlk.DeviceModeSelect;
                if(i == 0 && pArray->arrayType == VD_SPAN) {
                    partition *pPart = (partition *)((int)&ArrayBlk + 0x1be);
#ifdef _BIOS_
                    ReadWrite(pDev, 0, IDE_COMMAND_READ ARG_ARRAY_BLK);
#endif                    
                    for(j = 0; j < 4; j++, pPart++) 
                        if(pPart->start_abs_sector + pPart->num_of_sector >=
                           pDev->capacity) 
                            ZeroMemory((char *)pPart, 0x10);

                } else
                    ZeroMemory((char *)&ArrayBlk, 512);
				for(j=0; j<32; j++)
				{
					//ArrayBlk.ArrayName[j] = 0;
					pArray->ArrayName[j] = ArrayBlk.ArrayName[j];
				}
				
#ifdef _BIOS_
                ArrayBlk.DeviceModeSelect = Mode;
                ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
				ArrayBlk.DeviceModeSelect = 0;

				*(ULONG*)&((struct master_boot_record*)&ArrayBlk)->bootinst[440] = 0x5FDE642F;
//				((struct master_boot_record*)&ArrayBlk)->signature = 0xAA55;
                ReadWrite(pDev, 0, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif                
            }


        case VD_RAID_1_MIRROR:
			for(j=0; j<32; j++)
				ArrayBlk.ArrayName[j] = 0;
            MaptoSingle(pArray, REMOVE_ARRAY);

    }
}

PVirtualDevice Array_alloc()
{
	PVirtualDevice pArray;
	for (pArray=VirtualDevices; pArray<pLastVD; pArray++) {
		if (pArray->arrayType==VD_INVALID_TYPE)
		{
			ZeroMemory(pArray, sizeof(VirtualDevice));
			return pArray;
		}
	}
	return pLastVD++;
}

void Array_free(PVirtualDevice pArray)
{
	pArray->arrayType = VD_INVALID_TYPE;
    if(pArray == pLastVD) pLastVD--;
}

PVirtualDevice CreateRAID10(PVirtualDevice FAR * pArrays, BYTE nArray, BYTE nBlockSizeShift)
{
	int i, j;
	ULONG stamp = GetStamp();
	PVirtualDevice pSource = Array_alloc();
	PVirtualDevice pMirror = Array_alloc();
	PVirtualDevice pArray;
	PDevice pDev;
    ULONG  	capacity, tmp;
	
	capacity = 0x7FFFFFFF;
	for (i=0; i<nArray; i++)
	{
		tmp = pArrays[i]->capacity;
		if (capacity > tmp)
			capacity = tmp;
	}
	
	//set source disk
	pSource->arrayType=VD_RAID_10_SOURCE;
	pSource->BlockSizeShift = nBlockSizeShift;
	pSource->ArrayNumBlock = 1<<nBlockSizeShift;
	pSource->nDisk = nArray;
	pSource->Stamp = stamp;
	pSource->capacity = LongMul(capacity, nArray);
	for (i=0; i<nArray; i++) {
		pArray = pArrays[i];
		pDev = pArray->pDevice[0];
		pSource->pDevice[i] = pDev;
		pDev->ArrayMask = 1<<i;
		pDev->ArrayNum = (UCHAR)i;
		pDev->pArray = pSource;
		pDev->RebuiltSector = 0x7FFFFFFF;
		if (i>0) {
			if (pDev->HidenLBA >0 ) {
	            pDev->HidenLBA = 0;
	            pDev->capacity += (RECODR_LBA + 1);
			}
		}

#ifdef _BIOS_
        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
		
		for(j=0; j<16; j++)
			ArrayBlk.ArrayName[j+16] = 0;
		for(j=0; j<32; j++)
			pSource->ArrayName[j] = ArrayBlk.ArrayName[j];
		
        ArrayBlk.Signature = HPT_ARRAY_NEW; 
        ArrayBlk.order = 0;

        ArrayBlk.StripeStamp  = stamp;
        ArrayBlk.nDisks       = pSource->nDisk;            
        ArrayBlk.BlockSizeShift = pSource->BlockSizeShift;
        ArrayBlk.DeviceNum    = (UCHAR)i; 

        ArrayBlk.ArrayType    = pSource->arrayType;    
        ArrayBlk.MirrorStamp  = 0;

        ArrayBlk.capacity = pSource->capacity; 
		ArrayBlk.RebuiltSector = 0x7FFFFFFF;
		
        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
	}
	
	//set mirror disk
	pMirror->arrayType=VD_RAID_10_MIRROR;
	pMirror->BlockSizeShift = nBlockSizeShift;
	pSource->ArrayNumBlock = 1<<nBlockSizeShift;
	pMirror->nDisk = nArray;
	pMirror->Stamp = stamp;
	pMirror->capacity = pSource->capacity;
	for (i=0; i<nArray; i++) {
		pArray = pArrays[i];
		pDev = pArray->pDevice[MIRROR_DISK];
		pMirror->pDevice[i] = pDev;
		pDev->ArrayMask = 1<<i;
		pDev->ArrayNum = (UCHAR)i;
		pDev->pArray = pMirror;
		pDev->RebuiltSector = 0x7FFFFFFF;
		if (i>0) {
			if (pDev->HidenLBA >0 ) {
	            pDev->HidenLBA = 0;
	            pDev->capacity += (RECODR_LBA + 1);
			}
		}

#ifdef _BIOS_
        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);

		for(j=0; j<16; j++)
			ArrayBlk.ArrayName[j+16] = '0';
		for(j=0; j<32; j++)
			pMirror->ArrayName[j] = ArrayBlk.ArrayName[j];
		
        ArrayBlk.Signature = HPT_ARRAY_NEW; 
        ArrayBlk.order = 1;

        ArrayBlk.StripeStamp  = stamp;
        ArrayBlk.nDisks       = pMirror->nDisk;            
        ArrayBlk.BlockSizeShift = pMirror->BlockSizeShift;
        ArrayBlk.DeviceNum    = (UCHAR)i; 

        ArrayBlk.ArrayType    = pMirror->arrayType;    
        ArrayBlk.MirrorStamp  = 0;

        ArrayBlk.capacity = pMirror->capacity; 
		ArrayBlk.RebuiltSector = 0x7FFFFFFF;
		
        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
	}

	pSource->pRAID10Mirror = pMirror;
	pMirror->pRAID10Mirror = pSource;

	AdjustRAID10Array(pSource);
	for (i=0; i<nArray; i++)
		Array_free(pArrays[i]);
	return pSource;
}

#if 0
void DeleteRAID10(PVirtualDevice pArray)
{
	int i, j;
	LONG capacity;
	PDevice pDev;
	PVirtualDevice pMirror;
	
	for (i=0; i<pArray->nDisk; i++) {
		if (!pArray->pDevice[i] && !pArray->pRAID10Mirror->pDevice[i]) continue;
		pMirror = Array_alloc();
		pMirror->arrayType = VD_RAID_1_MIRROR;
		pMirror->nDisk = 1;
		pMirror->Stamp = GetStamp();

		// set source disk
		if (pDev = pArray->pDevice[i]){
			pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
			pMirror->pDevice[0] = pDev;
			pDev->ArrayMask = 1;
			pDev->ArrayNum = 0;
			pDev->pArray = pMirror;
			if (pDev->HidenLBA >0 ) {
	            pDev->HidenLBA = 0;
	            pDev->capacity += (RECODR_LBA + 1);
			}
			capacity = pDev->capacity;
	
#ifdef _BIOS_
	        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
			
			for(j=0; j<16; j++)
				ArrayBlk.ArrayName[j+16] = 0;
			
	        ArrayBlk.Signature = HPT_ARRAY_NEW; 
	        ArrayBlk.order = SET_MIRROR_STAMP | SET_ORDER_OK;
	
	        ArrayBlk.StripeStamp  = pMirror->Stamp;
	        ArrayBlk.nDisks       = 1;
	        ArrayBlk.DeviceNum    = pDev->ArrayNum;
	
	        ArrayBlk.ArrayType    = pMirror->arrayType;
	        ArrayBlk.MirrorStamp  = 0;
	
	        ArrayBlk.capacity = capacity;
			ArrayBlk.RebuiltSector = 0;
			
	        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
		}	
		// set mirror disk
		if (pDev = pArray->pRAID10Mirror->pDevice[i]) {
			pMirror->pDevice[MIRROR_DISK] = pDev;
			pDev->ArrayMask = 1 << MIRROR_DISK;
			pDev->ArrayNum = MIRROR_DISK;
			pDev->pArray = pMirror;
			if (pDev->HidenLBA >0 ) {
	            pDev->HidenLBA = 0;
	            pDev->capacity += (RECODR_LBA + 1);
			}
			if (capacity>pDev->capacity) capacity = pDev->capacity;
			pMirror->capacity = capacity;

#ifdef _BIOS_
	        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
			
			for(j=0; j<16; j++)
				ArrayBlk.ArrayName[j+16] = 0;
			
	        ArrayBlk.Signature = HPT_ARRAY_NEW; 
	        ArrayBlk.order = SET_MIRROR_STAMP;
	
	        ArrayBlk.StripeStamp  = pMirror->Stamp;
	        ArrayBlk.nDisks       = 1;
	        ArrayBlk.DeviceNum    = pDev->ArrayNum;
	
	        ArrayBlk.ArrayType    = pMirror->arrayType; 
	        ArrayBlk.MirrorStamp  = 0;
	
	        ArrayBlk.capacity = capacity;
			ArrayBlk.RebuiltSector = 0;
			
	        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
		}
	}

	Array_free(pArray->pRAID10Mirror);
	Array_free(pArray);
}
#endif

void DeleteRAID10(PVirtualDevice pArray)
{
	int i, j, diskNum;
	LONG capacity;
	PDevice pDev;
	ULONG stamp1 = GetStamp();
	ULONG stamp2;
    ULONG Mode;
	BOOL bSource = FALSE, bMirror = FALSE;
	while ((stamp2 = GetStamp()) == stamp1) ;
	
	diskNum = pArray->nDisk;
	for (i=0; i<diskNum; i++) {
		//if (pArray->pDevice[i] || pArray->pRAID10Mirror->pDevice[i]) 
		{
			//source disk
			if (pDev = pArray->pDevice[i]){
				if(i == 0) {
					pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
	                pDev->HidenLBA = 0;
				}
				else {
					pDev->DeviceFlags |= DFLAGS_ARRAY_DISK | DFLAGS_HIDEN_DISK;
	                pDev->HidenLBA = (RECODR_LBA + 1);
	            }
		        pDev->pArray = pArray;
		        pDev->ArrayNum  = (UCHAR)i;
		        pDev->ArrayMask = (UCHAR)(1 << i);
#ifdef _BIOS_
		        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
				for(j=0; j<16; j++)
					ArrayBlk.ArrayName[j+16] = 0;
		        ArrayBlk.StripeStamp  = stamp1;
		        ArrayBlk.ArrayType    = VD_RAID_0_STRIPE;
				ArrayBlk.RebuiltSector = 0;
	        	ArrayBlk.order = SET_STRIPE_STAMP;
	            ArrayBlk.MirrorStamp  = 0;
		        ArrayBlk.DeviceNum    = (UCHAR)i;
	            ArrayBlk.MirrorStamp  = 0;
		        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
			}
			//mirror disk
			if (pDev = pArray->pRAID10Mirror->pDevice[i]) {
				if(i == 0) {
					pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
	                pDev->HidenLBA = 0;
				}
				else {
					pDev->DeviceFlags |= DFLAGS_ARRAY_DISK | DFLAGS_HIDEN_DISK;
	                pDev->HidenLBA = (RECODR_LBA + 1);
	            }
		        pDev->pArray = pArray->pRAID10Mirror;
		        pDev->ArrayNum  = (UCHAR)i;
		        pDev->ArrayMask = (UCHAR)(1 << i);
#ifdef _BIOS_
		        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
				for(j=0; j<16; j++)
					ArrayBlk.ArrayName[j+16] = 0;
		        ArrayBlk.StripeStamp  = stamp2;
		        ArrayBlk.ArrayType    = VD_RAID_0_STRIPE;
				ArrayBlk.RebuiltSector = 0;
	        	ArrayBlk.order = SET_STRIPE_STAMP;
	            ArrayBlk.MirrorStamp  = 0;
		        ArrayBlk.DeviceNum    = (UCHAR)i;
	            ArrayBlk.MirrorStamp  = 0;
		        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
			}
		}
		//else
		{
			if(!pArray->pDevice[i]) bSource = TRUE;
			if(!pArray->pRAID10Mirror->pDevice[i]) bMirror = TRUE;

		}
	}

	for (i=0; i<diskNum; i++) {
		if(bSource && (pDev = pArray->pDevice[i]))
		{
#ifdef _BIOS_
        	ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
			Mode = ArrayBlk.DeviceModeSelect;
            ZeroMemory((char *)&ArrayBlk, 512);
            ReadWrite(pDev, 0, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
            ArrayBlk.DeviceModeSelect = Mode;
            ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
            pArray->pDevice[i] = 0;

	        pDev->DeviceFlags &= ~(DFLAGS_HIDEN_DISK | DFLAGS_ARRAY_DISK);
    	    pDev->pArray = 0;
        	if(pDev->HidenLBA>0) {
            	pDev->capacity += (RECODR_LBA + 1);
            	pDev->HidenLBA = 0;
        	}
        }
		if(bMirror && (pDev = pArray->pRAID10Mirror->pDevice[i]))
		{
#ifdef _BIOS_
        	ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
			Mode = ArrayBlk.DeviceModeSelect;
            ZeroMemory((char *)&ArrayBlk, 512);
            ReadWrite(pDev, 0, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
            ArrayBlk.DeviceModeSelect = Mode;
            ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
            pArray->pRAID10Mirror->pDevice[i] = 0;

	        pDev->DeviceFlags &= ~(DFLAGS_HIDEN_DISK | DFLAGS_ARRAY_DISK);
    	    pDev->pArray = 0;
        	if(pDev->HidenLBA>0) {
            	pDev->capacity += (RECODR_LBA + 1);
            	pDev->HidenLBA = 0;
        	}
        }
	}
	if(bMirror) {
		pArray->pRAID10Mirror = 0;
	}
	else {
		pArray->pRAID10Mirror->arrayType = VD_RAID_0_STRIPE;	
		pArray->pRAID10Mirror->Stamp = stamp2;
	}
	
	if(bSource) {
		pArray = 0;
	}
	else {
		pArray->arrayType = VD_RAID_0_STRIPE;	
		pArray->Stamp = stamp1;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\dam.hpp ===
/*++
Copyright (c) HighPoint Technologies, Inc. 2000

Module Name:
    DAM.hpp

Abstract:
    Encapsulates the interface of Disk Array Management

Author:
    Liu Ge (LG)

Environment:
    Win32 User Mode Only    
    
Revision History:
    07-16-2000  Created initiallly
--*/
#ifndef DiskArrayManagement_HPP_
#define DiskArrayManagement_HPP_

#include "dam.h"

//  The following are defined only for applications 
//  just like the interface program of DAM

#ifndef AbstractIterator_H_
#include "..\OWF_TCK\EnumIt.h"
#endif
#ifndef Progress_Control_H_
#include "..\HPT_DEV\progress.h"
#endif

#pragma warning( disable : 4290 ) 

#define MAIN_BOOT_SECTOR    0

class XFailedToLoadLog{};

#ifdef KEEP_UNUSED_CODE

ostream & operator << (ostream & os, const St_DiskPhysicalId & id );
istream & operator >> (istream & is, St_DiskPhysicalId & id );

ostream & operator << (ostream & os, const St_DiskFailure & Data );
istream & operator >> (istream & is, St_DiskFailureInLog & Data );

ostream & operator << (ostream & os, const St_DiskArrayEvent & Data );
istream & operator >> (istream & is, St_DiskArrayEvent & Data ) throw (XFailedToLoadLog);

#endif

class ClDiskArrayIterator : public TypeIterator<St_FindDisk>
{
protected:
    St_FindDisk m_Info;
    HFIND_DISK m_hSearchHandle;
    BOOL m_hasFound;
public:
    ClDiskArrayIterator(HDISK hRoot) 
    { 
        m_hSearchHandle = ::DiskArray_FindFirst(hRoot, &m_Info);
        m_hasFound = (m_hSearchHandle != INVALID_HANDLE_VALUE);
    }
    ~ClDiskArrayIterator()
    {
        if( m_hSearchHandle != INVALID_HANDLE_VALUE )
        {
            ::DiskArray_FindClose(m_hSearchHandle);
        }
    }
    virtual operator int() const { return m_hasFound; }
	virtual Abs_Iterator & operator ++()
    {
        if( m_hSearchHandle != INVALID_HANDLE_VALUE )
        {
            m_hasFound = ::DiskArray_FindNext(m_hSearchHandle, &m_Info);
        }
        return *this;
    }
	virtual St_FindDisk & operator *() { return m_Info; }
};

#ifdef KEEP_UNUSED_CODE

class ClCreatingStripping : public St_ProgressControl
{
public:
    typedef void (*PFN_Notification)(ClCreatingStripping &);
    typedef struct
    {
        HDISK * pDisks;
        ULONG uDiskNum;
        int nStripSizeShift;
    }St_Parameters;

    struct St_Status : 
        public St_ProgressStatus, 
        public St_Parameters
    {
        HDISK hFailedDisk;
        ULONG uFailedBlock;
    };

    ClCreatingStripping(HDISK * pDisks, ULONG uDiskNum, int nStripSizeShift, PFN_Notification);

    BOOL getStatus(St_Status & Status)
    {
        (St_ProgressStatus &)Status = (St_ProgressStatus &)*this;
        (St_Parameters &)Status = m_Parameters;
        return TRUE;
    }

protected:
    St_Parameters m_Parameters;
    
    BOOL DoCreating();

    static DWORD WINAPI Creating(ClCreatingStripping * pCreating);
};
#endif // KEEP_UNUSED_CODE

class ClRebuildingMirror : public St_ProgressControl
{
public:
    typedef void (*PFN_Notification)(ClRebuildingMirror &);

    struct St_Status : public St_ProgressStatus
    {
        HDISK hMirror;
        HDISK hFailedDisk;
        ULONG uFailedBlock;
    };

    ClRebuildingMirror(HDISK hMirror, PFN_Notification);

    BOOL getStatus(St_Status & Status)
    {
        (St_ProgressStatus &)Status = (St_ProgressStatus &)*this;
        Status.hMirror = m_hBeingRebuilt;
        return TRUE;
    }
    virtual BOOL stop();
	//CZHANG ADD IT
	int   m_nRebuildType;
	// 0-----normal 
	// 1---- rebuild after  broken mirror
    // 2-----rebuild after create mirror immediately

    HDISK             m_hBeingRebuilt;
protected:
    HMIRROR_BUILDER   m_hBuilder;
	//CZHANG ADD IT
	ULONG             uLba;
	
    
    BOOL    DoRebuilding();

    static DWORD WINAPI Rebuilding(ClRebuildingMirror * pRebuilding);
};

#endif // DiskArrayManagement_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\hptenum.h ===
/*++
Copyright (c) 2000, HighPoint Technologies, Inc.

Module Name:
    HptEnum.h - include file 

Abstract:

Author:
    HongSheng Zhang (HS)

Environment:

Notes:

Revision History:
    02-22-2000  Created initiallly

--*/

#ifndef __HPT_ENUM_H__
#define __HPT_ENUM_H__

///////////////////////////////////////////////////////////////////////
// HPT controller adapter I/O control structure
///////////////////////////////////////////////////////////////////////
#include "pshpack1.h"	// make sure use pack 1
///////////////////////////////////////////////////////////////////////
// Enumerator define area
///////////////////////////////////////////////////////////////////////
//
// IDE id
//	In furure, this enumerator will be canceled. we'll use SCSI LUN sturture
// to indicate a device.
typedef enum  IDE_ID{
	IDE_PRIMARY_MASTER,
	IDE_PRIMARY_SLAVE,
	IDE_SECONDARY_MASTER,
	IDE_SECONDARY_SLAVE,
}IDE_ABS_DEVID;

//
// device type
//	same as SCSI declaration, except DEVTYPE_FLOPPY_DEVICE
typedef enum _eu_DEVICETYPE{
	DEVTYPE_DIRECT_ACCESS_DEVICE, DEVTYPE_DISK = DEVTYPE_DIRECT_ACCESS_DEVICE,
	DEVTYPE_SEQUENTIAL_ACCESS_DEVICE, DEVTYPE_TAPE = DEVTYPE_SEQUENTIAL_ACCESS_DEVICE,
	DEVTYPE_PRINTER_DEVICE,
	DEVTYPE_PROCESSOR_DEVICE,
	DEVTYPE_WRITE_ONCE_READ_MULTIPLE_DEVICE, DEVTYPE_WORM = DEVTYPE_WRITE_ONCE_READ_MULTIPLE_DEVICE,
	DEVTYPE_READ_ONLY_DIRECT_ACCESS_DEVICE, DEVTYPE_CDROM = DEVTYPE_READ_ONLY_DIRECT_ACCESS_DEVICE,
	DEVTYPE_SCANNER_DEVICE,
	DEVTYPE_OPTICAL_DEVICE,
	DEVTYPE_MEDIUM_CHANGER,
	DEVTYPE_COMMUNICATION_DEVICE,
	DEVTYPE_FLOPPY_DEVICE
}Eu_DEVICETYPE;
#include <poppack.h>	// pop the pack number
#endif	// __HPT_ENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\hptioctl.h ===
/*++
Copyright (c) 1999, HighPoint Technologies, Inc.

Module Name:
    HptIoctl.h - include file 

Abstract:

Author:
    HongSheng Zhang (HS)

Environment:

Notes:

Revision History:
    12-07-99    Created initiallly
	2-22-00		gmm modify ioctl code definition
--*/

#ifndef __HPTIOCTL_H__
#define __HPTIOCTL_H__

///////////////////////////////////////////////////////////////////////
// HPT controller adapter I/O control code
///////////////////////////////////////////////////////////////////////

#define HPT_MINIDEVICE_TYPE 0x0370
	  
#ifndef CTL_CODE

#define CTL_CODE( DeviceType, Function, Method, Access ) \
			(((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method))
#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3
#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

#endif

#define HPT_CTL_CODE(x) \
			CTL_CODE(HPT_MINIDEVICE_TYPE, x, METHOD_BUFFERED, FILE_ANY_ACCESS)

///////////////////////////////////////////////////////////////////////
// HPT device I/O function code
///////////////////////////////////////////////////////////////////////
//
//Generic I/O function codes
//
#define IOCTL_HPT_GET_VERSION				HPT_CTL_CODE(0x900)
#define IOCTL_HPT_GET_IDENTIFY_INFO			HPT_CTL_CODE(0x901)
#define IOCTL_HPT_GET_CAPABILITY_DATA		HPT_CTL_CODE(0x902)
#define IOCTL_HPT_IDE_READ_SECTORS			HPT_CTL_CODE(0x903)
#define IOCTL_HPT_IDE_WRITE_SECTORS			HPT_CTL_CODE(0x904)
#define IOCTL_HPT_GET_FULL_IDENTIFY_INFO	HPT_CTL_CODE(0x905)
#define IOCTL_HPT_GET_LAST_ERROR			HPT_CTL_CODE(0x906)
#define IOCTL_HPT_LOCK_BLOCK				HPT_CTL_CODE(0x907)
#define IOCTL_HPT_UNLOCK_BLOCK				HPT_CTL_CODE(0x908)
#define IOCTL_HPT_EXECUTE_CDB				HPT_CTL_CODE(0x909)
#define IOCTL_HPT_GET_LAST_ERROR_DEVICE		HPT_CTL_CODE(0x90A)
#define IOCTL_HPT_SCSI_PASSTHROUGH			HPT_CTL_CODE(0x90B)
#define IOCTL_HPT_MINIPORT_SET_ARRAY_NAME	HPT_CTL_CODE(0x90C)
/* add for rescan the adapters and devices*/
#define IOCTL_HPT_MINIPORT_RESCAN_ALL		HPT_CTL_CODE(0x90D)

//
//RAID I/O function codes
//
#define IOCTL_HPT_GET_RAID_INFO				HPT_CTL_CODE(0xA00)
#define IOCTL_HPT_GET_ARRAY					HPT_CTL_CODE(0xA01)
#define IOCTL_HPT_UPDATE_RAID_INFO			HPT_CTL_CODE(0xA02)
#define IOCTL_HPT_SET_NOTIFY_EVENT			HPT_CTL_CODE(0xA03)
#define IOCTL_HPT_REMOVE_NOTIFY_EVENT		HPT_CTL_CODE(0xA04)
#define IOCTL_HPT_CREATE_MIRROR				HPT_CTL_CODE(0xA05)
#define IOCTL_HPT_CREATE_STRIPE				HPT_CTL_CODE(0xA06)
#define IOCTL_HPT_CREATE_SPAN				HPT_CTL_CODE(0xA07)
#define IOCTL_HPT_REMOVE_RAID				HPT_CTL_CODE(0xA08)
#define IOCTL_HPT_CREATE_RAID10				HPT_CTL_CODE(0xA09)
#define IOCTL_HPT_CHECK_NOTIFY_EVENT		HPT_CTL_CODE(0xA0A)
//
//Hotswap I/O function codes
//																				
#define IOCTL_HPT_CHECK_HOTSWAP				HPT_CTL_CODE(0xB00)
#define IOCTL_HPT_SWITCH_POWER				HPT_CTL_CODE(0xB01)
#define IOCTL_HPT_REMOVE_DEVICE				HPT_CTL_CODE(0xB02)

//
// Raid enumerate I/O function codes for LiuGe
//
#define IOCTL_HPT_ENUM_GET_DEVICE_INFO 		HPT_CTL_CODE(0xC00)
#define IOCTL_HPT_ENUM_GET_DEVICE_CHILD 	HPT_CTL_CODE(0xC01)
#define IOCTL_HPT_ENUM_GET_DEVICE_SIBLING	HPT_CTL_CODE(0xC02)
#define IOCTL_HPT_ENUM_GET_CONTROLLER_NUMBER	HPT_CTL_CODE(0xC03)
#define IOCTL_HPT_ENUM_GET_CONTROLLER_INFO 	HPT_CTL_CODE(0xC04)
#define IOCTL_HPT_BEGIN_REBUILDING_MIRROR  	HPT_CTL_CODE(0xC05)
#define IOCTL_HPT_VALIDATE_MIRROR    		HPT_CTL_CODE(0xC06)
#define IOCTL_HPT_ABORT_MIRROR_REBUILDING   HPT_CTL_CODE(0xC07)

//
// XStore Pro I/O function codes
//
#define IOCTL_HPT_SET_XPRO					HPT_CTL_CODE(0xE00)

//
// Disable/Enable Device I/O function codes
//
#define IOCTL_HPT_ENABLE_DEVICE				HPT_CTL_CODE(0xE01)
#define IOCTL_HPT_DISABLE_DEVICE			HPT_CTL_CODE(0xE02)

//
// Add/Remove Disk I/O function codes
//
#define IOCTL_HPT_ADD_SPARE_DISK			HPT_CTL_CODE(0xE03)
#define IOCTL_HPT_DEL_SPARE_DISK			HPT_CTL_CODE(0xE04)
#define IOCTL_HPT_ADD_MIRROR_DISK			HPT_CTL_CODE(0xE05)

//
// All diagnostic I/O function codes
//
#define IOCTL_HPT_DIAG_RAISE_ERROR			HPT_CTL_CODE(0xF00)

///////////////////////////////////////////////////////////////////////
// HPT Miniport redefinitions
///////////////////////////////////////////////////////////////////////
#define IOCTL_HPT_MINIPORT_GET_VERSION					IOCTL_HPT_GET_VERSION
#define IOCTL_HPT_MINIPORT_GET_IDENTIFY_INFO	 		IOCTL_HPT_GET_IDENTIFY_INFO	 
#define IOCTL_HPT_MINIPORT_GET_CAPABILITY_DATA	 		IOCTL_HPT_GET_CAPABILITY_DATA	 
#define IOCTL_HPT_MINIPORT_IDE_READ_SECTORS		 		IOCTL_HPT_IDE_READ_SECTORS		 
#define IOCTL_HPT_MINIPORT_IDE_WRITE_SECTORS	 		IOCTL_HPT_IDE_WRITE_SECTORS	 
#define IOCTL_HPT_MINIPORT_GET_FULL_IDENTIFY_INFO		IOCTL_HPT_GET_FULL_IDENTIFY_INFO	  
#define IOCTL_HPT_MINIPORT_GET_LAST_ERROR				IOCTL_HPT_GET_LAST_ERROR
#define IOCTL_HPT_MINIPORT_LOCK_BLOCK  					IOCTL_HPT_LOCK_BLOCK  
#define IOCTL_HPT_MINIPORT_UNLOCK_BLOCK					IOCTL_HPT_UNLOCK_BLOCK
#define IOCTL_HPT_MINIPORT_EXECUTE_CDB					IOCTL_HPT_EXECUTE_CDB
#define IOCTL_HPT_MINIPORT_GET_LAST_ERROR_DEVICE		IOCTL_HPT_GET_LAST_ERROR_DEVICE
#define IOCTL_HPT_MINIPORT_SCSI_PASSTHROUGH				IOCTL_HPT_SCSI_PASSTHROUGH
#define IOCTL_HPT_MINIPORT_GET_RAID_INFO				IOCTL_HPT_GET_RAID_INFO       	
#define IOCTL_HPT_MINIPORT_GET_ARRAY	    			IOCTL_HPT_GET_ARRAY	   
#define IOCTL_HPT_MINIPORT_UPDATE_RAID_INFO				IOCTL_HPT_UPDATE_RAID_INFO
#define IOCTL_HPT_MINIPORT_SET_NOTIFY_EVENT	  			IOCTL_HPT_SET_NOTIFY_EVENT
#define IOCTL_HPT_MINIPORT_REMOVE_NOTIFY_EVENT			IOCTL_HPT_REMOVE_NOTIFY_EVENT
#define IOCTL_HPT_MINIPORT_CREATE_MIRROR   				IOCTL_HPT_CREATE_MIRROR	
#define IOCTL_HPT_MINIPORT_CREATE_STRIPE				IOCTL_HPT_CREATE_STRIPE	
#define IOCTL_HPT_MINIPORT_CREATE_SPAN					IOCTL_HPT_CREATE_SPAN	
#define IOCTL_HPT_MINIPORT_CREATE_RAID10				IOCTL_HPT_CREATE_RAID10	
#define IOCTL_HPT_MINIPORT_REMOVE_RAID					IOCTL_HPT_REMOVE_RAID
#define IOCTL_HPT_MINIPORT_CHECK_HOTSWAP 				IOCTL_HPT_CHECK_HOTSWAP
#define IOCTL_HPT_MINIPORT_SWITCH_POWER					IOCTL_HPT_SWITCH_POWER	
#define IOCTL_HPT_MINIPORT_REMOVE_DEVICE				IOCTL_HPT_REMOVE_DEVICE
#define IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_INFO			IOCTL_HPT_ENUM_GET_DEVICE_INFO
#define IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_CHILD		IOCTL_HPT_ENUM_GET_DEVICE_CHILD
#define IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_SIBLING		IOCTL_HPT_ENUM_GET_DEVICE_SIBLING
#define IOCTL_HPT_MINIPORT_ENUM_GET_CONTROLLER_NUMBER	IOCTL_HPT_ENUM_GET_CONTROLLER_NUMBER
#define IOCTL_HPT_MINIPORT_ENUM_GET_CONTROLLER_INFO		IOCTL_HPT_ENUM_GET_CONTROLLER_INFO
#define IOCTL_HPT_MINIPORT_BEGIN_REBUILDING_MIRROR      IOCTL_HPT_BEGIN_REBUILDING_MIRROR
#define IOCTL_HPT_MINIPORT_VALIDATE_MIRROR              IOCTL_HPT_VALIDATE_MIRROR
#define IOCTL_HPT_MINIPORT_ABORT_MIRROR_REBUILDING      IOCTL_HPT_ABORT_MIRROR_REBUILDING
#define IOCTL_HPT_MINIPORT_SET_XPRO 					IOCTL_HPT_SET_XPRO
#define IOCTL_HPT_MINIPORT_ENABLE_DEVICE				IOCTL_HPT_ENABLE_DEVICE
#define IOCTL_HPT_MINIPORT_DISABLE_DEVICE				IOCTL_HPT_DISABLE_DEVICE
#define IOCTL_HPT_MINIPORT_ADD_SPARE_DISK				IOCTL_HPT_ADD_SPARE_DISK
#define IOCTL_HPT_MINIPORT_DEL_SPARE_DISK				IOCTL_HPT_DEL_SPARE_DISK
#define IOCTL_HPT_MINIPORT_ADD_MIRROR_DISK				IOCTL_HPT_ADD_MIRROR_DISK
#define IOCTL_HPT_MINIPORT_DIAG_RAISE_ERROR             IOCTL_HPT_DIAG_RAISE_ERROR
#define IOCTL_HPT_MINIPORT_CHECK_NOTIFY_EVENT			IOCTL_HPT_CHECK_NOTIFY_EVENT

///////////////////////////////////////////////////////////////////////
// HPT controller adapter I/O control structure
///////////////////////////////////////////////////////////////////////
#include "pshpack1.h"	// make sure use pack 1

#define RAID_DISK_ERROR	0x1234
#define RAID_DISK_WORK	0x4321
#define RAID_THREAD_STOP	0x5678
#define RAID_OTHER_ERROR	0xFFFF
//
// Read/Write sectors parameter structure
//
typedef struct _st_HPT_RW_PARAM{	 
	ULONG	nTargetId;					// the Target device id
	ULONG	nLbaSector;					// the first sector to read/write, in LBA
	ULONG	cnSectors;					// How many sectors to read/write? max 256 sectors. 0x00 mean 256
	UCHAR	pBuffer[1];
} St_HPT_RW_PARAM, *PSt_HPT_RW_PARAM;

//
// Platform type id
//
typedef enum _eu_HPT_POWER_STATE{
	HPT_POWER_ON	=	0,
	HPT_POWER_OFF	=	0xFFFFFFFF
} Eu_HPT_POWER_STATE;

//	
// ATAPI identify data
//
typedef struct _st_IDENTIFY_DATA {
	ULONG	nNumberOfCylinders;			// max number of cylinders
	ULONG	nNumberOfHeads;				// max number of heads
	ULONG	nSectorsPerTrack;			// sector per track
	ULONG	nBytesPerSector;			// bytes per sector
	ULONG	nUserAddressableSectors;	// max sectors user can address
	UCHAR	st20_SerialNumber[20];		// device serial number given by manufacturer (in ASCII)
	UCHAR	st8_FirmwareRevision[8];	// firmware revision number (in ASCII)
	UCHAR	st40_ModelNumber[40];		// model number given by manufacturer (in ASCII)
} St_IDENTIFY_DATA, *PSt_IDENTIFY_DATA;

//
// Disk array information
//						 
typedef struct _st_DISK_ARRAY_INFO{
	ULARGE_INTEGER	uliGroupNumber;	// the array group number,
									// all disks in an array should have same group number

	ULONG	nMemberCount;			// indicate how many disks in this array

	ULONG	nDiskSets;				// indicate what set is this disk belong
									//		available value: 0,1,2,3
									//			0-1, 2-3	stripe set
									//			0-2, 1-3	mirror set

	ULONG	nCylinders;				// the arrayed disk cylinders
	ULONG	nHeads;					// the arrayed disk heads
	ULONG	nSectorsPerTrack;		// the arrayed disk sectors
	ULONG	nBytesPerSector;		// the bytes per sector
	ULONG	nCapacity;				// the capacity of arrayed disk in sector
}St_DISK_ARRAY_INFO, *PSt_DISK_ARRAY_INFO;

//
// Structure for updating RAID info
//
typedef struct _st_HPT_UPDATE_RAID{		   
	ULONG	nTargetId;
	St_DISK_ARRAY_INFO	raidInfo;
} St_HPT_UPDATE_RAID, *PSt_HPT_UPDATE_RAID;

///////////////////////////////////////////////////////////////////////
// Enumerator define area
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
// structure define area											   
///////////////////////////////////////////////////////////////////////
//
// SCSI inquiry data
//
//		This structure is defined as same as INQUIRYDATA which defined in DDK,
//	be care to use memcpy assign value to this structure for the future compatible.
typedef struct _st_CAPABILITY_DATA{
	UCHAR DeviceType : 5;
	UCHAR DeviceTypeQualifier : 3;
	UCHAR DeviceTypeModifier : 7;
	UCHAR RemovableMedia : 1;
	UCHAR Versions;
	UCHAR ResponseDataFormat;
	UCHAR AdditionalLength;
	UCHAR Reserved[2];
	UCHAR SoftReset : 1;
	UCHAR CommandQueue : 1;
	UCHAR Reserved2 : 1;
	UCHAR LinkedCommands : 1;
	UCHAR Synchronous : 1;
	UCHAR Wide16Bit : 1;
	UCHAR Wide32Bit : 1;
	UCHAR RelativeAddressing : 1;
}St_CAPABILITY_DATA, *PSt_CAPABILITY_DATA;


//   
// Physical device information
//
typedef struct _st_PHYSICAL_DEVINFO{
	ULONG	nSize;					   
	ULONG	nSignature;					// disk signature
	ULONG	nPartitionCount;
	St_IDENTIFY_DATA	IdentifyData;
	St_CAPABILITY_DATA	CapabilityData;
	St_DISK_ARRAY_INFO	DiskArrayInfo;
}St_PHYSICAL_DEVINFO, *PSt_PHYSICAL_DEVINFO;

//
// get array structure;
//
typedef struct _st_GET_ARRAY{ 
	ULONG	nPortId;
	ULONG	nTargetId;
	St_PHYSICAL_DEVINFO	rgPhysicalDevInfo[2][2]; // [MAX_PORT_ID][MAX_TARGET_ID]
}St_GET_ARRAY, *PSt_GET_ARRAY;

//
// Ioctl structure for Win95 platform
//
typedef struct _st_HPT_LUN{
	DWORD	nPathId;
	DWORD	nTargetId;
	DWORD	nLun;
	DWORD	resv;
}St_HPT_LUN, *PSt_HPT_LUN;

typedef struct _st_HPT_ERROR_RECORD{	
	DWORD	nLastError;
}St_HPT_ERROR_RECORD, *PSt_HPT_ERROR_RECORD;

typedef struct _st_HPT_NOTIFY_EVENT{		
	HANDLE	hEvent;
}St_HPT_NOTIFY_EVENT, *PSt_HPT_NOTIFY_EVENT;

typedef struct _st_HPT_ENUM_GET_DEVICE_INFO{		
	HDISK	hDeviceNode;				// HDISK, input parameter
	St_DiskStatus	DiskStatus;			// DISK_STATUS, input & output parameter
}St_HPT_ENUM_GET_DEVICE_INFO, *PSt_HPT_ENUM_GET_DEVICE_INFO;

typedef struct _st_HPT_ENUM_DEVICE_RELATION{		  
	HDISK	hNode;						// HDISK, input parameter
	HDISK	hRelationNode;				// HDISK, relation device node, output parameter
}St_HPT_ENUM_DEVICE_RELATION, *PSt_HPT_ENUM_DEVICE_RELATION;

typedef struct _st_HPT_ENUM_GET_CONTROLLER_NUMBER{
	ULONG	nControllerNumber;			// output parameter, the current controller number
}St_HPT_ENUM_GET_CONTROLLER_NUMBER, * PSt_HPT_ENUM_GET_CONTROLLER_NUMBER;

typedef struct _st_HPT_ENUM_GET_CONTROLLER_INFO{					
	int		iController;				// input parameter, the index of controller what get the info
	St_StorageControllerInfo stControllerInfo; //output parameter, the info of the controller 
	struct
	{
	    int iVendorID;
	    int iDeviceID;
	    int iSubSysNumber;
	    int iRevsionID;
	    int iBusNumber;
	    int iDeviceNumber;
	    int iFunctionNumber;
	}stDeviceNodeID;
}St_HPT_ENUM_GET_CONTROLLER_INFO, *PSt_HPT_ENUM_GET_CONTROLLER_INFO;

typedef struct _st_HPT_BLOCK{ 
	ULONG	nStartLbaAddress;			// the first LBA address of the block
	ULONG	nBlockSize;					// the block size in sectors of the block
}St_HPT_BLOCK, *PSt_HPT_BLOCK;

typedef struct _st_HPT_EXECUTE_CDB{
	ULONG	OperationFlags;				// the operation flags, see OPERATION_FLAGS
	UCHAR	CdbLength;
	UCHAR	reserved[3];				// adjust the size of structure
	UCHAR	Cdb[16];
}St_HPT_EXECUTE_CDB, *PSt_HPT_EXECUTE_CDB;													   

// the operation flags declare area
#define OPERATION_FLAGS_DATA_IN			0x00000001 // DATA_IN or DATA_OUT, refer SRB_FLAGS_DATA_XXX
#define OPERATION_FLAGS_ON_MIRROR_DISK	0x00000002 // read/write mirror array (1 or 0+1) mirror disk
#define OPERATION_FLAGS_ON_SOURCE_DISK 0x00000004 // read/write mirror array (1 or 0+1) source disk

typedef struct _st_HPT_CREATE_RAID{		  
	int		nDisks;
	HDISK	hRaidDisk;					// the disk handle of the created RAID disk 
	ULONG	nStripeBlockSizeShift;
	HDISK	aryhDisks[1];
}St_HPT_CREATE_RAID, *PSt_HPT_CREATE_RAID;

typedef struct _st_HPT_REMOVE_RAID{
	HDISK	hDisk;
}St_HPT_REMOVE_RAID, *PSt_HPT_REMOVE_RAID;

//
// Define the SCSI pass through structure.
//
typedef struct _st_HPT_SCSI_PASS_THROUGH {
	USHORT Length;
	UCHAR ScsiStatus;
	UCHAR PathId;
	UCHAR TargetId;
	UCHAR Lun;
	UCHAR CdbLength;
	UCHAR SenseInfoLength;
	UCHAR DataIn;
	ULONG DataTransferLength;
	ULONG TimeOutValue;
	ULONG DataBufferOffset;
	ULONG SenseInfoOffset;
	UCHAR Cdb[16];
}St_HPT_SCSI_PASS_THROUGH, *PSt_HPT_SCSI_PASS_THROUGH;


typedef struct _st_HPT_ADD_DISK{
	HDISK	hArray;
	HDISK	hDisk;
}St_HPT_ADD_DISK, *PSt_HPT_ADD_DISK;

#include <poppack.h>	// pop the pack number
#endif	// __HPTIOCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\ata.c ===
#include "global.h"


/******************************************************************
 *  
 *******************************************************************/

BOOLEAN AtaPioInterrupt(PDevice pDevice)
{
    PVirtualDevice    pArray = pDevice->pArray;
    PChannel          pChan = pDevice->pChannel;
    PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
    PSCAT_GATH        pSG;
    PUCHAR            BMI = pChan->BMI;
    UINT              wordCount, ThisWords, SgWords;
    LOC_SRB
    LOC_SRBEXT_PTR
 
    wordCount = MIN(pChan->WordsLeft, pDevice->MultiBlockSize);
    pChan->WordsLeft -= wordCount;

    if(((pDevice->DeviceFlags & DFLAGS_ARRAY_DISK) == 0)||
	   (pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY)) {
        if(Srb->SrbFlags & SRB_FLAGS_DATA_OUT) 
             RepOUTS(IoPort, (ADDRESS)pChan->BufferPtr, wordCount);
        else 
             RepINS(IoPort, (ADDRESS)pChan->BufferPtr, wordCount);
        pChan->BufferPtr += (wordCount * 2);
        goto end_io;
    }

    pSG = (PSCAT_GATH)pChan->BufferPtr;

    while(wordCount > 0) {
        if((SgWords	= pSG->SgSize) == 0)
           	SgWords = 0x8000;
		  else
				SgWords >>= 1;
        
        ThisWords = MIN(SgWords, wordCount);

        if(Srb->SrbFlags & SRB_FLAGS_DATA_OUT) 
             RepOUTS(IoPort, (ADDRESS)pSG->SgAddress, ThisWords);
        else 
             RepINS(IoPort, (ADDRESS)pSG->SgAddress, ThisWords);

        if((SgWords -= (USHORT)ThisWords) == 0) {
           wordCount -= ThisWords;
           pSG++;
       } else {
           pSG->SgAddress += (ThisWords * 2);
			  pSG->SgSize -= (ThisWords * 2);
           break;
        }
    }

    pChan->BufferPtr = (ADDRESS)pSG;

end_io:
#ifdef BUFFER_CHECK
	GetStatus(pChan->BaseIoAddress2);
#endif												 
	
	if(pChan->WordsLeft){
		pSrbExt->WaitInterrupt |= pDevice->ArrayMask;
	} else {
		if(Srb->SrbFlags & SRB_FLAGS_DATA_OUT)
			pSrbExt->WaitInterrupt |= pDevice->ArrayMask;

     	OutDWord((PULONG)(pChan->BMI + ((pDevice->UnitId & 0x10)>>2) + 0x60),
        pChan->Setting[pDevice->DeviceModeSetting]);
 	}
	
    return((BOOLEAN)(pChan->WordsLeft || 
       (Srb->SrbFlags & SRB_FLAGS_DATA_OUT)));
}

/******************************************************************
 *  
 *******************************************************************/

void StartIdeCommand(PDevice pDevice DECL_SRB)
{
	LOC_SRBEXT_PTR
	PChannel         pChan = pDevice->pChannel;
	PIDE_REGISTERS_1 IoPort;
	PIDE_REGISTERS_2 ControlPort;
	ULONG            Lba = pChan->Lba;
	UINT             nSector = (UINT)pChan->nSector;
	PUCHAR           BMI;
	UCHAR            statusByte, cnt=0;

	IoPort = pChan->BaseIoAddress1;
	ControlPort = pChan->BaseIoAddress2;
	BMI = pChan->BMI;
	pChan->pWorkDev = pDevice;
	pChan->CurrentSrb = Srb;


#ifndef USE_PCI_CLK
	if(pDevice->DeviceFlags & DFLAGS_NEED_SWITCH){
		if(Srb->Cdb[0] == SCSIOP_READ){
			Switching370Clock(pChan, 0x23);
		}else if(Srb->Cdb[0] == SCSIOP_WRITE){
			Switching370Clock(pChan, 0x21);
		}
	}
#endif
	
	/*
     * Set IDE Command Register
     */
_retry_:
	SelectUnit(IoPort, pDevice->UnitId);
	statusByte = WaitOnBusy(ControlPort);
	if(statusByte & IDE_STATUS_ERROR) {
		statusByte= GetErrorCode(IoPort);
		DisableBoardInterrupt(pChan->BaseBMI);
		IssueCommand(IoPort, IDE_COMMAND_RECALIBRATE);
		EnableBoardInterrupt(pChan->BaseBMI);
		GetBaseStatus(IoPort);
		if(cnt++< 10) goto _retry_;
	}

	/*
     * Check if the disk has been removed
     */
	if((statusByte & 0x7e)== 0x7e || (statusByte & 0x40) == 0) {
		//// changes on 11/28/00
		ReportError(pDevice, DEVICE_REMOVED ARG_SRB);

	#ifndef _BIOS_
		if(pDevice->pArray) {
          ResetArray(pDevice->pArray);
      }
	#endif

		//if((pDevice = ReportError(pDevice, DEVICE_REMOVED ARG_SRB)) != 0) {
		//	pChan = pDevice->pChannel;
		//	pChan->Lba = Lba;
		//	pChan->nSector = (UCHAR)nSector;
		//	goto redo;
		//}
timeout:
		Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
		return;
	}

	if(statusByte & IDE_STATUS_BUSY) {
busy:
		Srb->SrbStatus = SRB_STATUS_BUSY;
		return;
	}

	if(Srb->Cdb[0] == SCSIOP_VERIFY) {
		if(Lba + (ULONG)nSector > pDevice->capacity){ 
			Lba = pDevice->capacity - (ULONG)nSector - 1;
		}
	} 

	SetBlockCount(IoPort, (UCHAR)nSector);

	if((pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY) == 0){
		Lba += pDevice->HidenLBA;								   
	}

	 /*
     * Boot sector protection
     */
	if(Lba == 0 && Srb->Cdb[0] == SCSIOP_WRITE &&
	   (pDevice->DeviceFlags & DFLAGS_BOOT_SECTOR_PROTECT) &&
	   GetUserResponse(pDevice) == 0){
		goto timeout;				  
	}

	if((pDevice->DeviceFlags & DFLAGS_LBA) && (Lba & 0xF0000000)==0){ 
		Lba |= 0xE0000000;											 
	}else{
		Lba = MapLbaToCHS(Lba, pDevice->RealHeadXsect, pDevice->RealSector);
	}

	SetBlockNumber(IoPort, (UCHAR)(Lba & 0xFF));
	SetCylinderLow(IoPort, (UCHAR)((Lba >> 8) & 0xFF));
	SetCylinderHigh(IoPort,(UCHAR)((Lba >> 16) & 0xFF));
	SelectUnit(IoPort,(UCHAR)((Lba >> 24) | (pDevice->UnitId)));

	if (WaitOnBusy(ControlPort) & (IDE_STATUS_BUSY | IDE_STATUS_DRQ)){
		goto busy;													  
	}

	if((Srb->SrbFlags & (SRB_FLAGS_DATA_OUT | SRB_FLAGS_DATA_IN)) == 0){
		goto pio;														
	}

#ifdef USE_DMA
	/*
     * Check if the drive & buffer support DMA
     */
	if(pDevice->DeviceFlags & (DFLAGS_DMA | DFLAGS_ULTRA)) {
		if((pDevice->pArray == 0)||
		   (pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY)){
			if(BuildSgl(pDevice, pChan->pSgTable ARG_SRB)){
				goto start_dma;
			}
		}else{
			if((pSrbExt->SrbFlags & ARRAY_FORCE_PIO) == 0){
				goto start_dma;							   
			}
		}
	}
#endif //USE_DMA

	if((pDevice->DeviceFlags & DFLAGS_ARRAY_DISK)&&
	   ((pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY) == 0)){
		if(pDevice->pArray->arrayType == VD_SPAN){ 
			Span_SG_Table(pDevice, (PSCAT_GATH)&pSrbExt->DataBuffer
						  ARG_SRBEXT_PTR);		  
		}else{
			Stripe_SG_Table(pDevice, (PSCAT_GATH)&pSrbExt->DataBuffer
							ARG_SRBEXT_PTR);						 
		}

		pChan->BufferPtr = (ADDRESS)pChan->pSgTable;
		pChan->WordsLeft = ((UINT)pChan->nSector) << 8;

	}else{
		pChan->BufferPtr = (ADDRESS)Srb->DataBuffer;
#ifdef _BIOS_
		if(Srb->DataTransferLength == 0){
			pChan->WordsLeft = 0x8000;	 
		}else
#endif
			pChan->WordsLeft = Srb->DataTransferLength / 2;
	}
	 /*
     * Send PIO I/O Command
     */
pio:

	pDevice->DeviceFlags &= ~DFLAGS_DMAING;
	Srb->SrbFlags &= ~(SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT);

	switch(Srb->Cdb[0]) {
		case SCSIOP_SEEK:
			IssueCommand(IoPort, IDE_COMMAND_SEEK);
			break;

		case SCSIOP_VERIFY:
			IssueCommand(IoPort, IDE_COMMAND_VERIFY);
			break;

		case SCSIOP_READ:
			OutDWord((PULONG)(pChan->BMI + ((pDevice->UnitId & 0x10)>>2) + 0x60),
					 pChan->Setting[pDevice->bestPIO]);
			Srb->SrbFlags |= SRB_FLAGS_DATA_IN;
			IssueCommand(IoPort, pDevice->ReadCmd);
			break;

		default:
			OutDWord((PULONG)(pChan->BMI + ((pDevice->UnitId & 0x10)>>2) + 0x60),
					 pChan->Setting[pDevice->bestPIO]);
			Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
			IssueCommand(IoPort,  pDevice->WriteCmd);
			if (!(WaitForDrq(ControlPort) & IDE_STATUS_DRQ)) {
				Srb->SrbStatus = SRB_STATUS_ERROR;
				return;
			}

			AtaPioInterrupt(pDevice);
	}
	return;

#ifdef USE_DMA
start_dma:

#ifdef SUPPORT_TCQ

	 /*
     * Send Commamd Queue DMA I/O Command
     */

	if(pDevice->MaxQueue) {


		pDevice->pTagTable[pSrbExt->Tag] = (ULONG)Srb;

		IssueCommand(IoPort, (UCHAR)((Srb->Cdb[0] == SCSIOP_READ)?
									  IDE_COMMAND_READ_DMA_QUEUE : IDE_COMMAND_WRITE_DMA_QUEUE));

		for ( ; ; ) {
			status = GetStatus(ControlPort);
			if((status & IDE_STATUS_BUSY) == 0){
				break;							
			}
		}

		if(status & IDE_STATUS_ERROR) {
			AbortAllCommand(pChan, pDevice);
			Srb->SrbStatus = MapATAError(pChan, Srb); 
			return;
		}

		// read sector count register
		//
		if((GetInterruptReason(IoPort) & 4) == 0){
			goto start_dma_now;					  
		}

		// wait for service
		//
		status = GetBaseStatus(IoPort);

		if(status & IDE_STATUS_SRV) {
			IssueCommand(IoPort, IDE_COMMAND_SERVICE);

			for( ; ; ) {
				status = GetStatus(ControlPort);
				if((status & IDE_STATUS_BUSY) == 0){
					break;							
				}
			}

			if((Srb = pDevice->pTagTable[GetInterruptReason(IoPort >> 3]) != 0) {
				pSrbExt = Srb->SrbExtension;
				if((pDevice->pArray == 0)||
				   (pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY)){
					BuildSgl(pDevice, pChan->pSgTable ARG_SRB);
				}
				goto start_dma_now;
			}
		}

		pChan->pWorkDev = 0;
		return;
	}

#endif //SUPPORT_TCQ

	OutPort(BMI, BMI_CMD_STOP);
	OutPort (BMI + BMI_STS, BMI_STS_INTR);

	if(Srb->Cdb[0] == SCSIOP_READ) {
#ifndef USE_PCI_CLK
		if(pDevice->DeviceFlags & DFLAGS_NEED_SWITCH){
			Switching370Clock(pChan, 0x23);
		}
#endif
		IssueCommand(IoPort, IDE_COMMAND_DMA_READ);
	}else{
#ifndef USE_PCI_CLK
		if(pDevice->DeviceFlags & DFLAGS_NEED_SWITCH){
			Switching370Clock(pChan, 0x21);
		}
#endif
		IssueCommand(IoPort, IDE_COMMAND_DMA_WRITE);
	}


#ifdef SUPPORT_TCQ
start_dma_now:
#endif //SUPPORT_TCQ
	
	pDevice->DeviceFlags |= DFLAGS_DMAING;
					   
	if((pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY) == 0){
		if(pDevice->DeviceFlags & DFLAGS_ARRAY_DISK){
			if(pDevice->pArray->arrayType == VD_SPAN){
				Span_SG_Table(pDevice, pSrbExt->ArraySg ARG_SRBEXT_PTR);
			}else{
				Stripe_SG_Table(pDevice, pSrbExt->ArraySg ARG_SRBEXT_PTR);
			}
		} else if(pDevice->pArray){
			MemoryCopy(pChan->pSgTable, pSrbExt->ArraySg, sizeof(SCAT_GATH)
					   * MAX_SG_DESCRIPTORS);
		}
	}

	OutDWord((PULONG)(pChan->BMI + BMI_DTP), pChan->SgPhysicalAddr);

	OutPort(BMI, (UCHAR)((Srb->Cdb[0] == SCSIOP_READ)? BMI_CMD_STARTREAD : 
						 BMI_CMD_STARTWRITE));

#endif //USE_DMA
}

/******************************************************************
 *  
 *******************************************************************/

void NewIdeIoCommand(PDevice pDevice DECL_SRB)
{
    LOC_SRBEXT_PTR  
    PVirtualDevice pArray = pDevice->pArray;
    PChannel pChan = pDevice->pChannel;
	// gmm: added
	BOOL source_only = ((pSrbExt->WorkingFlags & SRB_WFLAGS_ON_SOURCE_DISK) !=0);
	BOOL mirror_only = ((pSrbExt->WorkingFlags & SRB_WFLAGS_ON_MIRROR_DISK) !=0);

    /*
     * single disk
     */
	   
    if((pArray == 0)||(pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY)) {
		if (pDevice->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)
			goto no_device;
        StartIdeCommand(pDevice ARG_SRB);
        return;
    }

    /*
     * gmm: Don't start io on broken raid0, 1+0 and span
     * in case of broken mirror there is a chance that JoinMembers==0
     */
    if (pArray->BrokenFlag &&
		(pArray->arrayType==VD_RAID_0_STRIPE ||
		 pArray->arrayType==VD_SPAN ||
		 pArray->arrayType==VD_RAID_10_SOURCE))
	{
    	Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
    	return;
    }
    //-*/

    pSrbExt->Lba     = pChan->Lba;
    pSrbExt->nSector = pChan->nSector;

    if((Srb->SrbFlags & (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)) &&
        BuildSgl(pDevice, pSrbExt->ArraySg ARG_SRB))
        pSrbExt->SrbFlags &= ~ARRAY_FORCE_PIO;
    else
        pSrbExt->SrbFlags |= ARRAY_FORCE_PIO;
 
    pSrbExt->JoinMembers = 0;

    excluded_flags |= (1 << pChan->exclude_index);

    switch (pArray->arrayType) {
    case VD_SPAN:
         if (pArray->nDisk)
			 Span_Prepare(pArray ARG_SRBEXT_PTR);
         break;

    case VD_RAID_1_MIRROR:
	{
		if (pArray->nDisk == 0 || 
			(pDevice->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)){
			// is the source disk broken?
			// in this case mirror disk will move to pDevice[0] and become source disk
			if (source_only)
				pSrbExt->JoinMembers = pArray->pDevice[0]? 1 : 0;
			else if (mirror_only)
				pSrbExt->JoinMembers = (pArray->pDevice[MIRROR_DISK])? (1 << MIRROR_DISK) : 0;
			else {
				pSrbExt->JoinMembers = pArray->pDevice[0]? 1 : (1<<MIRROR_DISK);
				if (Srb->Cdb[0] == SCSIOP_WRITE && pArray->pDevice[MIRROR_DISK])
					pSrbExt->JoinMembers |= (1 << MIRROR_DISK);
			}
		}else if(pArray->pDevice[MIRROR_DISK]){
			 // does the mirror disk present?

			if(Srb->Cdb[0] == SCSIOP_WRITE){
				if(!source_only && pArray->pDevice[MIRROR_DISK])
					pSrbExt->JoinMembers = 1 << MIRROR_DISK;
				
				if(!mirror_only){
					// if the SRB_WFLAGS_MIRRO_SINGLE flags not set, we
					// need write both source and target disk.
					pSrbExt->JoinMembers |= 1;
				}
			}else{
				if (mirror_only){
					if (pArray->pDevice[MIRROR_DISK])
						pSrbExt->JoinMembers = (1 << MIRROR_DISK);
				}
				else
					pSrbExt->JoinMembers = 1;
			}

		}else{	
			// is the mirror disk broken?
			if(!mirror_only)
				pSrbExt->JoinMembers = 1;
		}
	}
	break;

    case VD_RAID_01_1STRIPE:
        if(pArray->nDisk == 0) {
			if ((source_only && !(pArray->RaidFlags & RAID_FLAGS_INVERSE_MIRROR_ORDER)) ||
				(mirror_only && (pArray->RaidFlags & RAID_FLAGS_INVERSE_MIRROR_ORDER)))
				break;
read_single_disk:
			if (pArray->pDevice[MIRROR_DISK]) // gmm added
            	pSrbExt->JoinMembers = (1 << MIRROR_DISK);
			break;

        }else if(pArray->pDevice[MIRROR_DISK] && Srb->Cdb[0] == SCSIOP_WRITE){

			if (!source_only)
				pSrbExt->JoinMembers = (1 << MIRROR_DISK);					 
			if(mirror_only){
				/* gmm:
				 * write only the stripe when RAID_FLAGS_INVERSE_MIRROR_ORDER is set
				 */
				if (pArray->RaidFlags & RAID_FLAGS_INVERSE_MIRROR_ORDER)
					pSrbExt->JoinMembers &= ~(1 << MIRROR_DISK);					 
				else
					break;
			}
		}
		else {
			if (mirror_only){
				// read only from mirror disk
				if (!(pArray->RaidFlags & RAID_FLAGS_INVERSE_MIRROR_ORDER))
					goto read_single_disk;
			}
			else {
				/* gmm:
				 * we read from the source. in case of 0+1 when single 
				 * disk is as source disk we read from single disk
				 */
				if (pArray->RaidFlags & RAID_FLAGS_INVERSE_MIRROR_ORDER) {
					if (pArray->pDevice[MIRROR_DISK]) goto read_single_disk;
				}
				// else flow down
				//-*/
			}
		}
		 
		Stripe_Prepare(pArray ARG_SRBEXT_PTR);								   
		break;

	case VD_RAID_10_SOURCE:
		if (pArray->BrokenFlag)
			break;
		if (mirror_only) {
			pArray = pArray->pRAID10Mirror;
		}
		goto stripe_prepare;

	case VD_RAID01_MIRROR:
		// in case of hot-plug pDevice->pArray may be changed to this.
		pDevice = pArray->pDevice[MIRROR_DISK];
		pArray = pDevice->pArray;
		// flow down
    case VD_RAID_01_2STRIPE:
		if(pArray->nDisk == 0) {
			if (source_only) // fail
				break;
			pDevice = pArray->pDevice[MIRROR_DISK];
			if (!pDevice) break; // fail
			pArray = pDevice->pArray;
		}else{
			if (mirror_only) {
				pDevice = pArray->pDevice[MIRROR_DISK];
				if (!pDevice) break; // fail
				pArray = pDevice->pArray;
			}
		}

    default:
stripe_prepare:
         if (pArray->nDisk)
			 Stripe_Prepare(pArray ARG_SRBEXT_PTR);
		 break;
    }
    
    /*
     * gmm: added
     * in case of broken mirror there is a chance that JoinMembers==0
     */
    if (pSrbExt->JoinMembers==0) {
no_device:
    	Srb->SrbStatus = 0x8; /* 0x8==SRB_STATUS_NO_DEVICE */;
    	return;
    }
    //-*/

    pSrbExt->WaitInterrupt = pSrbExt->JoinMembers;

    WinSetSrbExt(pDevice, pArray, Srb, pSrbExt);
 
    StartArrayIo(pArray ARG_SRB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\atapi.c ===
#include "global.h"

#ifdef SUPPORT_ATAPI

/******************************************************************
 *  
 *******************************************************************/

void AtapiCommandPhase(PDevice pDevice DECL_SRB)
{
    PChannel pChan = pDevice->pChannel;
    PUCHAR   BMI = pChan->BMI;

    RepOUTS(pChan->BaseIoAddress1, (ADDRESS)Srb->Cdb, 6);
    if((pDevice->DeviceFlags & DFLAGS_REQUEST_DMA) != 0) {
        OutDWord((PULONG)(BMI + BMI_DTP), pChan->SgPhysicalAddr);
            OutDWord((PULONG)(BMI + ((pDevice->UnitId & 0x10)>>2)
            + 0x60), pChan->Setting[pDevice->DeviceModeSetting]);
        OutPort(BMI, (UCHAR)((Srb->SrbFlags & SRB_FLAGS_DATA_IN)?
            BMI_CMD_STARTREAD : BMI_CMD_STARTWRITE));
        pDevice->DeviceFlags |= DFLAGS_DMAING;
        pDevice->DeviceFlags &= ~DFLAGS_REQUEST_DMA;
    }
} 


/******************************************************************
 *  
 *******************************************************************/

void AtapiInterrupt(PDevice pDevice)
{
    PChannel         pChan = pDevice->pChannel;
    PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
    UINT   i;
    UCHAR  Reason;
	 LOC_SRB

    Reason = GetInterruptReason(IoPort) & 3;
    if(Reason & 1) 
        AtapiCommandPhase(pDevice ARG_SRB);
    else {
        i = (UINT)(GetByteLow(IoPort) | (GetByteHigh(IoPort) << 8));
        i >>= 1;
        if(Reason) // read
            OS_RepINS(IoPort, (ADDRESS)pChan->BufferPtr, i);
        else
            RepOUTS(IoPort, (ADDRESS)pChan->BufferPtr, i);
        pChan->BufferPtr += (i * 2);
        pChan->WordsLeft -=  i;
    } 
}


/******************************************************************
 *  
 *******************************************************************/

void StartAtapiCommand(PDevice pDevice DECL_SRB)
{
    PChannel         pChan = pDevice->pChannel;
    PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
 
    pChan->BufferPtr = (ADDRESS)Srb->DataBuffer;
    pChan->WordsLeft = Srb->DataTransferLength / 2;
 

    SelectUnit(IoPort, pDevice->UnitId);
    if(WaitOnBusy(ControlPort) & IDE_STATUS_BUSY) {
         Srb->SrbStatus = SRB_STATUS_BUSY;
         return;
    }

    SetFeaturePort(IoPort, 
        (UCHAR)((pDevice->DeviceFlags & DFLAGS_REQUEST_DMA)? 1 : 0));

    SetCylinderLow(IoPort,0xFF);
    SetCylinderHigh(IoPort, 0xFF);
    IssueCommand(IoPort, 0xA0);

    pChan->pWorkDev = pDevice;
    pChan->CurrentSrb = Srb;

    if((pDevice->DeviceFlags & DFLAGS_INTR_DRQ) == 0) {
        WaitOnBusy(ControlPort);
        if(WaitForDrq(ControlPort) & IDE_STATUS_DRQ) 
            AtapiCommandPhase(pDevice ARG_SRB);
        else  {
            Srb->SrbStatus =  SRB_STATUS_ERROR;
				pChan->pWorkDev = 0;
				pChan->CurrentSrb = 0;
        }
    }
}


#endif //SUPPORT_ATAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\array.h ===
/***************************************************************************
 * File:          array.h
 * Description:   This file include 2 data structures which used for RAID
 *                function.
 *                (2) Srb Extension for array operation 
 *                (3) Virtual disk informatiom
 * Author:        DaHai Huang    (DH)
 * Dependence:    
 *      arraydat.h
 *
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:       DH 5/10/2000 initial code
 *
 ***************************************************************************/

#ifndef _ARRAY_H_
#define _ARRAY_H_

#include <pshpack1.h>

#include "arraydat.h"
/***************************************************************************
 * Description:  Error Log
 ***************************************************************************/

PDevice ReportError(PDevice pDev, UCHAR ErrorReason DECL_SRB);
int  GetUserResponse(PDevice pDevice);

/***************************************************************************
 * Description:  Commmand
 ***************************************************************************/


/***************************************************************************
 * Description: Srb Extesion
 ***************************************************************************/

/*
 * The SrbExtension is used for spilting a logic <LBA, nSector> command	to
 * read, write and verify a striping/span/RAID3/5 to several related physical
 * <lba, nsector> command to do with the members
 * example:
 *	LBA = 17   nSector = 8	  BlockSizeShift = 2  nDisk = 3
 *
 *      (0)              (1)            (2)        sequence munber of the stripe
 * 0   1  2  3       4   5  6  7     8  9  10 11     Logic LBA
 * 12  13 14 15      16 (17 18 10    20 21 22 23     (same line )
 * 24) 25 26 27      28  29 30 31    32 33 34 35 ...
 *
 *   <8, 1>              <5, 3>         <4, 4>      physical <lba, nsectors>
 *
 * tmp = LBA >> BlockSizeShift = 17 >> 2 = 4
 * FirstMember = tmp % nDisk = 4 % 3 = 1
 * StartLBA = (tmp / nDisk) << BlockSizeShift = (4 / 3) << 2 = 4
 * FirstOffset = LBA & ((1 << BlockSizeShift) - 1) = 17 & 3 = 1
 * FirstSectors = (1 << BlockSizeShift) - FirstOffset = 4 - 1 = 3
 * LastMember = 0
 * LastSectors = 1
 * AllMemberBlocks = 0
 * InSameLine = FALSE
 */ 
typedef struct _SrbExtension {
    ULONG      StartLBA;       /* start physical LBA  */

    UCHAR      FirstSectors;   /* the number of sectors for the first member */
    UCHAR      FirstMember;    /* the sequence number of the first member */
    UCHAR      FirstOffset;    /* the offset from the StartLBA for the first member */
    UCHAR      LastMember;     /* the sequence number of the last member */

    UCHAR      LastSectors;    /* the number of sectors for the last member */
    UCHAR      AllMemberBlocks;/* the number of sectors for all member */
    UCHAR      InSameLine;     /* if the start and end on the same line */
    UCHAR      reserved;

    USHORT     JoinMembers;    /* bit map the members who join this IO */ 
    USHORT     WaitInterrupt;  /* bit map the members who wait interrupt */

    SCAT_GATH  ArraySg[MAX_SG_DESCRIPTORS]; // must at the offset 16!!

    ADDRESS    DataBuffer;     /* pointer to buffer in main memory */
    USHORT     DataTransferLength; /* Transfer length */
    USHORT     SgFlags;        /* allways = 0x8000 */

    ULONG      Lba;            /* start logic LBA */
    UCHAR      nSector;        /* the number of sectors for the IO */
    UCHAR      SrbFlags;       /* see below defination */          

    /* Srb  for bios / dos */
    UCHAR      ScsiStatus;     /* IDE error status(1x7) */
    UCHAR      SrbStatus;      /* IDE completion status */

#ifdef _BIOS_
    UCHAR      Cdb[12];        /* Atapi command */
#else
    struct _Device *pMaster;   /* point to the non-hidden disk in a array */
#endif

    struct _VirtualDevice *pWorkingArray; /* point to current array table */

    ULONG       WorkingFlags;
	PChannel    StartChannel;  // the channel on which the request is initialed
#ifndef	_BIOS_
	// for our special SRB, we need store the original informations
	UCHAR	OriginalPathId;
	UCHAR	OriginalTargetId;
	UCHAR	OriginalLun;
	
	void		(*pfnCallBack)(PHW_DEVIEC_EXTENSION, PSCSI_REQUEST_BLOCK);
#endif			//#ifndef _BIOS_
} SrbExtension, *PSrbExtension;

/* SrbFlags */
#define ARRAY_FORCE_PIO   1

/* SRB Working flags define area */
#define	SRB_WFLAGS_USE_INTERNAL_BUFFER		0x00000001 // the transfer is using internal buffer
#define	SRB_WFLAGS_IGNORE_ARRAY				0x00000002 // the operation should ignore the array present
#define	SRB_WFLAGS_HAS_CALL_BACK			0x00000004 // the operation need call a call back routine when finish the working
#define	SRB_WFLAGS_MUST_DONE				0x00000008 // the operation must be done, ignore the locked block setting
#define	SRB_WFLAGS_ON_MIRROR_DISK			0x00000010 // the operation only vaild one mirror part of group
#define	SRB_WFLAGS_ON_SOURCE_DISK			0x00000020 // the operation only vaild one mirror part of group

/***************************************************************************
 * Description: Virtual Device Table
 ***************************************************************************/

typedef struct _VirtualDevice {
    UCHAR   nDisk;             /* the number of disks in the stripe */
    UCHAR   BlockSizeShift;    /* the number of shift bit for a block */
    UCHAR   arrayType;         /* see the defination */
    UCHAR   ArrayNumBlock;     /* = (1 << BlockSizeShift) */

    ULONG   Stamp;             /* array ID. all disks in a array has same ID */

    ULONG   capacity;          /* capacity for the array */

#ifdef _BIOS_
    USHORT  headerXsect_per_tck; /* = MaxSector * MaxHeader */
    USHORT  MaxCylinder;       /* maximum logic cylinders for the array    */

    UCHAR   MaxSector;         /* maximum logic sectors for a track of the array */
    UCHAR   MaxHeader;         /* maximum logic head of the array */
#else
    PSCSI_REQUEST_BLOCK Srb;   /* current command block from OS */
#endif 
	ULONG	RaidFlags;		   /* see RAID FLAGS delcare area */

	ULONG	lMaxDevFlag;		/* maximum and new date/time flag */ 
	UCHAR	bStdMember;			/* Standard member devNum in this array */
	UCHAR	BrokenFlag;			/* if TRUE then broken */

	struct _Device  *pDevice[MAX_MEMBERS]; /* member list */
	struct _VirtualDevice  * pRAID10Mirror;

	UCHAR				ArrayName[32];	//the name of array //added by wx 12/26/00
} VirtualDevice, *PVirtualDevice;

/* pDevice[MAX_MEMBERS] */
extern PVirtualDevice  pLastVD;	

/*************** Wang Beiwen *************** 2000.11.10 *******************************/
typedef struct _Lose_Disk_List {
	PDevice			pDev;			/* device handle pointer of error device be found */ 
	UCHAR			ArrayType;		/* Array type of this device */    
	PVirtualDevice	pArray;			/* point Array */ 	
	UCHAR			NewDisk;		/* if TRUE then find new device */
	UCHAR			LoseDisk;		/* if TRUE then find lose device */
} Lose_Disk_List;

typedef struct _Array_Inf {
	PDevice			pDev;			/* device handle pointer of error device be found */ 
	PVirtualDevice	pArray;			/* point Array of this device	 */ 	
	ULONG			Signature;      /* see ArrayBlock  struct */
	ULONG			StripeStamp;    /* see ArrayBlock  struct */
	ULONG			MirrorStamp;    /* see ArrayBlock  struct */  
	ULONG			order;          /* Mirror sequence. 0 - source, 1 - copy */
	UCHAR			nDisks;         /* How many of disks in the array */
 	UCHAR			ArrayType;      /* Array type of this device 0-7 */
	UCHAR			DeviceNum;      /* The sequence number of this disk in the array */

	UCHAR			Seq;		    /* scan disk seq number 0--7	 */    
 	UCHAR			Status;			/* device status	ok/broken	 */
	UCHAR			LoseFlag;		/* if 1 then lose device if 2 then new device */
} Array_Inf;

/** add date 2000.11.23 ***************************************************************/

/*
 * RAID FLAGS declare area
 */						  

#define RAID_FLAGS_NEED_REBUILD		0x00000001
#define RAID_FLAGS_INVERSE_MIRROR_ORDER 0x00000002 
#define RAID_FLAGS_BEING_BUILT	0x00000004
#define RAID_FLAGS_DISABLED	0x00000008
#define RAID_FLAGS_BOOTDISK 0x00000010

/* 
 * relationship between ArrayBlock and VirtualDevice
 * VirtualDevice                   | ArrayBlock
 * arrayType  pDevice[]             ArrayType StripeStamp MirrorStamp
 0 RAID 0      0-nDisk-1             0             use      ignore
 1 RAID 1      0,MIRROR_DISK         1             use      ignore
 2 RAID 0+1    0-nDisk-1             0             use      use
 3 SPAN        0-nDisk-1             3             use      ignore
 6 RAID 0+disk 0-nDisk-1,MIRROR_DISK 0             use      ignore
 7 RAID 0+1                          0             use      use
 */




#include <poppack.h>

#endif //_ARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\arraydat.h ===
/*++
Copyright (c) 2000, HighPoint Technologies, Inc.

Module Name:
	ArrayDat.h : Define the Array Information in disk.

Abstract:

Author:
    LiuGe (LG)

Dependence:    none

Environment:
	Windows Kernel and User Mode
	BIOS Mode

Notes:

Revision History:
    07-25-2000    Created initiallly

--*/
#ifndef ArrayStructures_H_
#define ArrayStructures_H_

#include <pshpack1.h>
 
/*
 * The time when the error happend
 */
typedef struct _Time_Record {
   int         seconds:6;      /* 0 - 59 */
   int         minutes:6;      /* 0 - 59 */
   int         month:4;        /* 1 - 12 */
   int         hours:6;        /* 0 - 59 */
   int         day:5;          /* 1 - 31 */
   int         year:5;         /* 0=2000, 31=2031 */
} TimeRecord;

/*
 * Error Record
 */
typedef struct _ErrorLog {
   TimeRecord  Time;           /* the time when the error happend */
   UCHAR       ErrorReason;    /* Error Reason or command, see below */
   UCHAR       DiskSeq;        /* Which disk has the error */
   UCHAR       AtaStatus;      /* Ata error status (read from 1x7) */
   UCHAR       nSectors;       /* the number of sectors for I/O command */
   LONG        LBA;            /* the LBA of error location on the disk */
} ErrorLog, *PErrorLog;


/* ErrorReason : others == SCSI command */
#define ARRAY_BROKEN    0xFF   /* some members lost in the array */
#define DEVICE_REMOVED  0xFE   /* some members was removed by hot plug */
#define DEVICE_PLUGGED	0xFD   /* some members was added by hot plug */


#define MAX_ERROR_LOG  32      /* Maximum error log in the info block */

#define RECODR_LBA     9       /* the LBA of the information block on disk */

/*
 * Old version Data structure. No use now. Skip it
 */
typedef struct _ArrayOld {
    LONG       DataOk;         /* This block is vaild disk information block */
    BYTE       BootSelect;     /* This disk was selected as boot disk */
    WORD       BootMark;       /* The boot/set mark is vaild */
    BYTE       Set;            /* disk data transfer mode, 0-4 PIO0-4 */
                               /* 5-7 MW DMA0-3, 8-13 UDMA0-5, 0xFF default */
    LONG       Signature;		 /* This block is vaild disk information block */
    LONG       CreateTime;		 /* Create Time, BCD format */
    LONG       CreateDate;     /* Create Date, BCD format */

    BYTE       nDisk;          /* How many of disks in the array */
    BYTE       DeviceNum;      /* the sequence number of this disk in the array */

    BYTE       Max_Sector;     /* logic sectors in a logic track */
    BYTE       Max_Header;     /* logic head in array disk */
    WORD       Max_Cylinder;   /* logic cylinder in the array disk */
    LONG       capacity;       /* capacity of this array disk */

    WORD       Flag;           /* see below */
} ArrayOld;

/*
 * Array information block on disk (LBA == RECODR_LBA)
 */
typedef union _ArrayBlock {				  
	struct{
		ArrayOld	Old;            /* for compebility. No use now */

		ULONG		Signature;      /* 0 This block is vaild array info block */
		ULONG		StripeStamp;    /* 4 Group mark to link disks into array */
		ULONG		MirrorStamp;    /* 8 RAID 0+1 mark to link two RAID0 */  
		ULONG		order;          /*12 Mirror sequence. 0 - source, 1 - copy */

		UCHAR		nDisks;         /*16 How many of disks in the array */
		UCHAR		BlockSizeShift; /*17 Block size == (1 << BlockSizeShift) */
		UCHAR		ArrayType;      /*18 See below */
		UCHAR		DeviceNum;      /*19 The sequence number of this disk in the array */

		ULONG		capacity;       /*20 the capacity of the array */

		ULONG		DeviceModeSelect;/*24 disk data transfer mode, 0-4 PIO0-4 */
								    /* 5-7 MW DMA0-3, 8-13 UDMA0-5, 0xFF default */
		ULONG		ModeBootSig;    /*28 The BootDisk is vaild or ont */
		UCHAR		BootDisk;       /*32 AF_BOOT_DISK this disk was selected as
								    /*   boot disk. others is not */

		UCHAR		ProtectBootSector;/*33 AF_PROTECT_BS protect boot secter from writing */
		UCHAR		nErrorLog;      /*34 the number of error log in errorlog */
		UCHAR		ErrorLogStart;  /*35 the index of start one */
		ErrorLog	errorLog[MAX_ERROR_LOG]; /* 36 error log records */

		ULONG		lDevSpec;       /* Array Signature        */
		ULONG		lDevDate;       /* The time when the modify happend */
		ULONG		lDevTime;       /* The time when the modify happend */
		ULONG		lDevFlag;       /* Array sequence number of error happend */

		ULONG		RebuiltSector;	/* The sectors have been rebuilt */
		UCHAR		Validity;		/* The usable flag of the device, see below */
		UCHAR		ArrayName[32];	/* The Name of the array */	//added by wx 12/25/00

	};
	UCHAR		reserved[512];	  // to keep the arrayblock 512 bytes
} ArrayBlock;

/* Flag: Old Array only support RAID0 and RAID1 */
#define  AI_STRIPE     0x80    /* this is a stripe disk */
#define  AI_MIRROR     0x40    /* this is a mirror disk */



/* Signature */
#define HPT_ARRAY_OLD  0x5a7816fc /* this is old vaild array block */
#define HPT_ARRAY_NEW  0x5a7816f0 /* this is new vaild array block */
#define HPT_TMP_SINGLE 0x5a7816fd /* the array including this disk is broken */
#define HPT_CHK_BOOT   0x12345678 /* user set the boot mark */
#define HPT_MODE_SET   0x5a874600 /* user set the data transfer mode for it */
#define DEVICE_MODE_SET(x) ((x & 0xFFFFFF00)==HPT_MODE_SET)

#define SPECIALIZED_CHAR  0x5A1234A5 /* use to find lose device's Signature word */

/* order */
#define SET_STRIPE_STAMP   4
#define SET_MIRROR_STAMP   2
#define SET_ORDER_OK       1


/* ProtectBootSector */
#define AF_PROTECT_BS      0x69

/* DeviceModeSelect */
#define AF_AUTO_SELECT     0xFF

/* BootDisk */
#define AF_BOOT_DISK       0x80

#define MAX_MEMBERS       7    // Maximum members in an array 

#define MIRROR_DISK    (MAX_MEMBERS - 1)
#define SPARE_DISK     (MAX_MEMBERS - 2)

/* arrayType */
#define VD_RAID_0_STRIPE     0 /* RAID 0 stripe */
#define VD_RAID_1_MIRROR     1 /* RAID 1 mirror */
#define VD_RAID_01_2STRIPE   2 /* the first member of RAID 0+1 made of two RAID 0 */
#define VD_SPAN              3 /* Span */
#define VD_RAID_3            4 /* RAID 3, not implement now */
#define VD_RAID_5            5 /* RAID 5, not implement now */
#define VD_RAID_01_1STRIPE   6 /* RAID 0 + 1 single disk */
#define VD_RAID01_MIRROR     7 /* the second member of RAID 0+1 made of two RAID 0 */

#define VD_RAID_10_SOURCE    8 /* RAID 1+0 source disk */
#define VD_RAID_10_MIRROR    9 /* RAID 1+0 mirror disk */

#define VD_INVALID_TYPE 0xFF  /* invalid array type */

/* Validity */
#define ARRAY_VALID			0x00	/* The device is valid   */
#define ARRAY_INVALID		0xFF	/* The device is invalid */

#include <poppack.h>


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\buffer.c ===
#include "global.h"

#ifdef WIN95
#include "blockdev.h"
#endif									// WIN95

#define PAGEMAPGLOBAL       0x40000000
#pragma intrinsic(memcpy)

#ifdef SUPPORT_INTERNAL_BUFFER

SCAT_GATH ext_buf_sg[MAX_SG_DESCRIPTORS];
PUCHAR     ext_buf_start = 0;
PUCHAR __cdecl LOCK__HeapAllocate(int, int);
ULONG  __cdecl LOCK__LinPageLock(int, int, int);
ULONG ScsiPortDDB = 0;
ULONG __stdcall LOCK_Get_DDB (ULONG DeviceID, PCHAR pName) ;

void Create_Internal_Buffer(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    PUCHAR  dataPointer;
    ULONG   bytesLeft   = 1024 * 64;
    ULONG   physicalAddress[MAX_SG_DESCRIPTORS];
    ULONG   addressLength[MAX_SG_DESCRIPTORS];
    ULONG   addressCount = 0;
    ULONG   sgEnteries = 0;
    PSCAT_GATH psg = (PSCAT_GATH)ext_buf_sg;
    ULONG   length;
    ULONG   i;

	 if(ext_buf_start || (ext_buf_start = 
        LOCK__HeapAllocate(4096 * 17, 0)) == 0) // allocate 64KBytes
		  return;

	 if(ScsiPortDDB == 0) {
       ScsiPortDDB = LOCK_Get_DDB(0, "SCSIPORT");
       if(ScsiPortDDB == 0)
             return;
       ScsiPortDDB += 12;
    }

	 i = ((ULONG)ext_buf_start + 4096)>> 12;
	 i = LOCK__LinPageLock(i, 16, PAGEMAPGLOBAL); // lock 64KBytes
	 dataPointer =  ext_buf_start = (PUCHAR)i;

    do {
        physicalAddress[addressCount] =
            ScsiPortConvertPhysicalAddressToUlong(
            ScsiPortGetPhysicalAddress(HwDeviceExtension,
                    0,
                    dataPointer,
                    &length));

        if  (length > bytesLeft)
            length = bytesLeft;

        addressLength[addressCount] = length;

        dataPointer = (PUCHAR)dataPointer + length;
        bytesLeft  -= length;
        addressCount++;

    } while (bytesLeft);

    //
    // Create Scatter/Gather List
    //
    for (i = 0; i < addressCount; i++) {
        psg->SgAddress = physicalAddress[i];
        length = addressLength[i];

        while ((i+1 < addressCount) &&
               (psg->SgAddress+length == physicalAddress[i+1])) {
            i++;
            length += addressLength[i];
        }

        if ((psg->SgAddress & 0xFFFF0000) !=
            ((psg->SgAddress+length-1) & 0xFFFF0000)) {
            ULONG firstPart;

            firstPart = 0x10000 - (psg->SgAddress & 0xFFFF);
            psg->SgSize = (USHORT)firstPart;
            psg->SgFlag = 0;

            sgEnteries++;
            psg++;

            psg->SgAddress = (psg-1)->SgAddress + firstPart;
            length -= firstPart;
        } // skip 64K boundary

        psg->SgSize = (USHORT)length;
        psg->SgFlag = (i < addressCount-1) ? 0 : SG_FLAG_EOT;

        sgEnteries++;
        psg++;
    } 
}


void ScsiportMemcpySrb(PSCSI_REQUEST_BLOCK pSrb, PUCHAR pBuffer, BOOLEAN bToSrb)
{				
	IOP		*pIop = *(IOP**)(pSrb+1);
	int		nBytesLeft = pSrb->DataTransferLength;

	if(pIop->IOP_ior.IOR_flags & IORF_SCATTER_GATHER){

		_BlockDev_Scatter_Gather *pSgt;		
		int nBlockShift;
		pSgt = (_BlockDev_Scatter_Gather*)pIop->IOP_ior.IOR_buffer_ptr;
		nBlockShift = pIop->IOP_physical_dcb->DCB_apparent_blk_shift;

		while(nBytesLeft > 0){
			int	nBytesToCopy;								  
			nBytesToCopy = pSgt->BD_SG_Count << nBlockShift;
			nBytesLeft -= nBytesToCopy;
			if(nBytesLeft < 0){
				nBytesToCopy += nBytesLeft;
			}
			if(bToSrb){					// copy from buffer to SRB?
				memcpy(pSgt->BD_SG_Buffer_Ptr, pBuffer, nBytesToCopy); 
			}else{
				memcpy(pBuffer, pSgt->BD_SG_Buffer_Ptr, nBytesToCopy);
			}
			pSgt++;
			pBuffer += nBytesToCopy;
		}			   
	}else{
		if(bToSrb){					// copy from buffer to SRB?
			memcpy(pSrb->DataBuffer, pBuffer, nBytesLeft);
		}else{
			memcpy(pBuffer, pSrb->DataBuffer, nBytesLeft);
		}
	}				 
}

int Use_Internal_Buffer(
						IN PSCAT_GATH psg,
						IN PSCSI_REQUEST_BLOCK Srb
					   )
{
	PSCAT_GATH pExtSg =	ext_buf_sg;
	ULONG   bytesLeft   = Srb->DataTransferLength;

	if(btr(EXCLUDE_BUFFER) == 0)
		return (0);

	while(bytesLeft > 0) {
		*psg = *pExtSg;
		if(bytesLeft <= pExtSg->SgSize) {
			psg->SgSize = (USHORT)bytesLeft;
			psg->SgFlag = SG_FLAG_EOT;
			break;
		}
		psg->SgFlag = 0;
		
		bytesLeft -= pExtSg->SgSize;
		psg++;
		pExtSg++;
	}

	if(Srb->Cdb[0] == SCSIOP_WRITE) {
		ScsiportMemcpySrb(Srb, ext_buf_start, FALSE);
	}

	((PSrbExtension)(Srb->SrbExtension))->WorkingFlags |= SRB_WFLAGS_USE_INTERNAL_BUFFER;
	return(1);
}

void CopyTheBuffer(PSCSI_REQUEST_BLOCK Srb)
{
	if(Srb->Cdb[0] != SCSIOP_WRITE){
		ScsiportMemcpySrb(Srb, ext_buf_start, TRUE);
	}
	excluded_flags |= (1 << EXCLUDE_BUFFER);
	((PSrbExtension)(Srb->SrbExtension))->WorkingFlags &= ~SRB_WFLAGS_USE_INTERNAL_BUFFER;
}

#endif //SUPPORT_INTERNAL_BUFFER
/*
 * Add by Robin
 */	 
#ifdef BUFFER_CHECK

#define BYTES_FOR_CHECK	256

#ifdef	WIN95
void CheckBuffer(PSCSI_REQUEST_BLOCK pSrb)
{							   
	PULONG plTmp;
	int nBlockShift;
	_BlockDev_Scatter_Gather *pSgt;
	char	tmpBuf[BUFFER_SIZE];

	IOP		*pIop = *(IOP**)(pSrb+1);
	int		nBytesLeft = pSrb->DataTransferLength;
	PUCHAR	pcTmp = pSrb->DataBuffer;	
	int		nBytesChecked = 0;

	if((pSrb->Cdb[0] != SCSIOP_READ)&&(pSrb->Cdb[0] != SCSIOP_WRITE)){
		return;
	}

	nBlockShift = pIop->IOP_physical_dcb->DCB_apparent_blk_shift;
	pSgt = (_BlockDev_Scatter_Gather*)pIop->IOP_ior.IOR_buffer_ptr;

	while(nBytesLeft > 0){
		if(pIop->IOP_ior.IOR_flags & IORF_SCATTER_GATHER){
			int	nBytesOfSgt;
			nBytesOfSgt = pSgt->BD_SG_Count << nBlockShift - nBytesChecked;
			if(nBytesOfSgt < sizeof(tmpBuf)){
				memcpy(tmpBuf, (pSgt->BD_SG_Buffer_Ptr+nBytesChecked), nBytesOfSgt);
				memcpy(&tmpBuf[nBytesOfSgt], (pSgt+1)->BD_SG_Buffer_Ptr, sizeof(tmpBuf)-nBytesOfSgt);
				pcTmp = tmpBuf;
			}else{
				pcTmp = (PUCHAR)(pSgt->BD_SG_Buffer_Ptr + nBytesChecked);
			}
			nBytesChecked += sizeof(tmpBuf);
			nBytesOfSgt -= nBytesChecked;
			if(nBytesOfSgt <= 0){
				pSgt++;		
				if(nBytesOfSgt == 0){
					nBytesChecked = 0;
				}else{
					nBytesChecked += nBytesOfSgt;
				}
			}
		}

		plTmp = (PULONG)pcTmp;
		if(((plTmp[0] == 0x03020100)||(plTmp[1] == 0x07060504))||
		   ((plTmp[0] == 0xFCFDFEFF)||(plTmp[1] == 0xF8F9FAFB))){
			if(*pcTmp != 0x1A){
				ScsiPortReadPortUchar((PUCHAR)0xcf0);
				_asm{
//					int 3;		   
				}
			}
		}
		nBytesLeft -= 0x100;
		pcTmp += 0x100;
	}
}			 
#else									// WIN95
void CheckBuffer(PSCSI_REQUEST_BLOCK pSrb)
{							   
	PULONG plTmp;
	int	i;

	int		nBytesLeft = pSrb->DataTransferLength;
	PUCHAR	pcTmp = pSrb->DataBuffer;	

	if((pSrb->Cdb[0] != SCSIOP_READ)&&(pSrb->Cdb[0] != SCSIOP_WRITE)){
		return;
	}

	while(nBytesLeft > 0){
		plTmp = (PULONG)pcTmp;
		if(((plTmp[0] == 0x03020100)||(plTmp[1] == 0x07060504))||
		   ((plTmp[0] == 0xFCFDFEFF)||(plTmp[1] == 0xF8F9FAFB))){
			if(*pcTmp != 0x1A){
				for(i = 0; i < BYTES_FOR_CHECK-1; i ++){
					int iTmp;
					iTmp = pcTmp[i] - pcTmp[i+1];

					if((iTmp != 1)&&(iTmp != -1)){
						if((i != 0x1B)&&(i!=0x1A)){
							ScsiPortReadPortUchar((PUCHAR)0xcf0);
						}
					}	
				}
			}
		}
		nBytesLeft -= BYTES_FOR_CHECK;
		pcTmp += BYTES_FOR_CHECK;
	}
}			 
#endif									// WIN95
#endif									// BUFFER_CHECK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\atapi.h ===
/***************************************************************************
 * File:          atapi.h
 * Description:   Ata/Atapi Interface Defination
 * Author:        Dahai Huang
 * Dependence:    None
 * Reference:     AT Attachment Interface with Extensions (ATA-2)
 *                Revison 2K, Dec. 2, 1994
 *                ATA Packet Interface for CD-ROMs SFF-8020
 *                Revision 1.2 Feb. 24, 1994
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:       DH 5/10/2000 initial code
 *
 ***************************************************************************/


#ifndef _ATAPI_H_
#define _ATAPI_H_

#include <pshpack1.h>

/***************************************************************************
 *            IDE IO Register File
 ***************************************************************************/

/*
 * IDE IO Port definition
 */
typedef struct _IDE_REGISTERS_1 {
    USHORT Data;               /* RW: Data port                  */
    UCHAR BlockCount;			 /* RW: Sector count               */
    UCHAR BlockNumber;			 /* RW: Sector number & LBA 0-7    */
    UCHAR CylinderLow;			 /* RW: Cylinder low & LBA 8-15    */
    UCHAR CylinderHigh;			 /* RW: Cylinder hign & LBA 16-23  */
    UCHAR DriveSelect;			 /* RW: Drive/head & LBA 24-27     */
    UCHAR Command;				 /* RO: Status WR:Command          */
} IDE_REGISTERS_1, *PIDE_REGISTERS_1;


/*
 * IDE status definitions
 */
#define IDE_STATUS_ERROR             0x01 /* Error Occurred in Execution    */
#define IDE_STATUS_INDEX             0x02	/* is vendor specific             */
#define IDE_STATUS_CORRECTED_ERROR   0x04	/* Corrected Data                 */
#define IDE_STATUS_DRQ               0x08	/* Ready to transfer data         */
#define IDE_STATUS_DSC               0x10	/* not defined in ATA-2           */
#define IDE_STATUS_DWF               0x20	/* Device Fault has been detected */
#define IDE_STATUS_DRDY              0x40	/* Device Ready to accept command */
#define IDE_STATUS_IDLE              0x50	/* Device is OK                   */
#define IDE_STATUS_BUSY              0x80	/* Device Busy, must wait         */


#define IDE_ERROR_BAD_BLOCK          0x80 /* Reserved now                   */
#define IDE_ERROR_DATA_ERROR         0x40	/* Uncorreectable  Data Error     */
#define IDE_ERROR_MEDIA_CHANGE       0x20	/* Media Changed                  */
#define IDE_ERROR_ID_NOT_FOUND       0x10	/* ID Not Found                   */
#define IDE_ERROR_MEDIA_CHANGE_REQ   0x08	/* Media Change Requested         */
#define IDE_ERROR_COMMAND_ABORTED    0x04	/* Aborted Command                */
#define IDE_ERROR_TRACK0_NOT_FOUND   0x02	/* Track 0 Not Found              */
#define IDE_ERROR_ADDRESS_NOT_FOUND  0x01	/* Address Mark Not Found         */


#define LBA_MODE                     0x40

/*
 * IDE command definitions
 */

#define IDE_COMMAND_RECALIBRATE      0x10 /* Recalibrate                    */
#define IDE_COMMAND_READ             0x20	/* Read Sectors with retry        */
#define IDE_COMMAND_WRITE            0x30	/* Write Sectors with retry       */
#define IDE_COMMAND_VERIFY           0x40	/* Read Verify Sectors with Retry */
#define IDE_COMMAND_SEEK             0x70	/* Seek                           */
#define IDE_COMMAND_SET_DRIVE_PARAMETER   0x91 /* Initialize Device Parmeters */
#define IDE_COMMAND_GET_MEDIA_STATUS 0xDA
#define IDE_COMMAND_DOOR_LOCK        0xDE	/* Door Lock                      */
#define IDE_COMMAND_DOOR_UNLOCK      0xDF	/* Door Unlock 						 */
#define IDE_COMMAND_ENABLE_MEDIA_STATUS   0xEF /* Set Features              */
#define IDE_COMMAND_IDENTIFY         0xEC /* Identify Device                */
#define IDE_COMMAND_MEDIA_EJECT      0xED
#define IDE_COMMAND_SET_FEATURES     0xEF /* IDE set features command       */

#define IDE_COMMAND_FLUSH_CACHE      0xE7
#define IDE_COMMAND_STANDBY_IMMEDIATE 0xE0


#ifdef USE_MULTIPLE
#define IDE_COMMAND_READ_MULTIPLE    0xC4	/* Read Multiple                  */
#define IDE_COMMAND_WRITE_MULTIPLE   0xC5	/* Write Multiple                 */
#define IDE_COMMAND_SET_MULTIPLE     0xC6	/* Set Multiple Mode              */
#endif //USE_MULTIPLE

#ifdef USE_DMA
#define IDE_COMMAND_DMA_READ        0xc9  /* IDE DMA read command           */
#define IDE_COMMAND_DMA_WRITE       0xcb  /* IDE DMA write command          */
#endif //USE_DMA

#ifdef SUPPORT_TCQ
#define IDE_COMMAND_READ_DMA_QUEUE   0xc7 /* IDE read DMA queue command     */
#define IDE_COMMAND_WRITE_DMA_QUEUE  0xcc /* IDE write DMA queue command	 */
#define IDE_COMMAND_SERVICE          0xA2 /* IDE service command command	 */
#define IDE_COMMAND_NOP              0x00 /* IDE NOP command 					 */
#define IDE_STATUS_SRV               0x10
#endif //SUPPORT_TCQ

/*
 * IDE_COMMAND_SET_FEATURES
 */
#define FT_USE_ULTRA        0x40    /* Set feature for Ultra DMA           */
#define FT_USE_MWDMA        0x20    /* Set feature for MW DMA					*/
#define FT_USE_SWDMA        0x10    /* Set feature for SW DMA					*/
#define FT_USE_PIO          0x8     /* Set feature for PIO						*/
#define FT_DISABLE_IORDY    0x10    /* Set feature for disabling IORDY		*/

/***************************************************************************
 *            IDE Control Register File 
 ***************************************************************************/

typedef struct _IDE_REGISTERS_2 {
    UCHAR AlternateStatus;     /* RW: device control port        */
} IDE_REGISTERS_2, *PIDE_REGISTERS_2;


/*
 * IDE drive control definitions
 */
#define IDE_DC_DISABLE_INTERRUPTS    0x02
#define IDE_DC_RESET_CONTROLLER      0x04
#define IDE_DC_REENABLE_CONTROLLER   0x00


/***************************************************************************
 *            ATAPI IO Register File  
 ***************************************************************************/

/*
 * ATAPI register definition
 */

typedef struct _ATAPI_REGISTERS_1 {
    USHORT Data;
    UCHAR InterruptReason;		 /* Atapi Phase Port               */
    UCHAR Unused1;
    UCHAR ByteCountLow;        /* Byte Count LSB                 */
    UCHAR ByteCountHigh;		 /* Byte Count MSB                 */
    UCHAR DriveSelect;
    UCHAR Command;
} ATAPI_REGISTERS_1, *PATAPI_REGISTERS_1;

/*
 *	Atapi Error Status
 */
#define IDE_ERROR_END_OF_MEDIA       IDE_ERROR_TRACK0_NOT_FOUND 
#define IDE_ERROR_ILLEGAL_LENGTH     IDE_ERROR_ADDRESS_NOT_FOUND

/*
 * ATAPI interrupt reasons
 */
#define ATAPI_IR_COD 0x01
#define ATAPI_IR_IO  0x02

/* sense key */
#define NOERROR                0x00      /* No sense                       */
#define CORRECTED_DATA         0x01      /* Recovered Error                */
#define NOTREADYERROR          0x02      /* Not Ready Error                */
#define MEDIAERROR             0x03      /* Medium Error                   */
#define HARDWAREERROR          0x04      /* HardWare Error                 */
#define ILLEGALREQUSET         0x05      /* Illegal Request                */
#define UNITATTENTION          0x06      /* Unit Attention                 */
#define DATAPROTECT            0x07      /* Data Protect Error             */
#define BLANKCHECK             0x08      /* Blank Check                    */
#define VENDORSPECIFIC         0x09      /* Vendor Specific                */
#define COPYABROT              0x0a      /* Copy Aborted                   */
#define ABORETCOMMAND          0x0b      /* Aborted Command                */
#define EQUALCOMPARISON        0x0c      /* Equal Comparison satisfied     */
#define VOLUMOVERFLOW          0x0d      /* Volume Overflow                */
#define MISCOMPARE             0x0e      /* Miscompare                     */

/*
 * IDE command definitions ( for ATAPI )
 */

#define IDE_COMMAND_ATAPI_RESET      0x08 /* Atapi Software Reset command   */
#define IDE_COMMAND_ATAPI_PACKET     0xA0	/* Atapi Identify command         */
#define IDE_COMMAND_ATAPI_IDENTIFY   0xA1	/* Atapi Packet Command           */


/*
 * ATAPI command definitions
 */

#define ATAPI_MODE_SENSE   0x5A
#define ATAPI_MODE_SELECT  0x55
#define ATAPI_FORMAT_UNIT  0x24

#define MODE_DSP_WRITE_PROTECT  0x80

#ifndef _BIOS_
/*
 * ATAPI Command Descriptor Block
 */
typedef struct _MODE_SENSE_10 {
        UCHAR OperationCode;
        UCHAR Reserved1;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved3[3];
} MODE_SENSE_10, *PMODE_SENSE_10;

typedef struct _MODE_SELECT_10 {
        UCHAR OperationCode;
        UCHAR Reserved1 : 4;
        UCHAR PFBit : 1;
        UCHAR Reserved2 : 3;
        UCHAR Reserved3[5];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved4[3];
} MODE_SELECT_10, *PMODE_SELECT_10;

typedef struct _MODE_PARAMETER_HEADER_10 {
    UCHAR ModeDataLengthMsb;
    UCHAR ModeDataLengthLsb;
    UCHAR MediumType;
    UCHAR Reserved[5];
}MODE_PARAMETER_HEADER_10, *PMODE_PARAMETER_HEADER_10;

#endif //_BIOS_


/***************************************************************************
 *            ATAPI IO Register File  
 ***************************************************************************/


typedef struct _ATAPI_REGISTERS_2 {
    UCHAR AlternateStatus;
} ATAPI_REGISTERS_2, *PATAPI_REGISTERS_2;


/***************************************************************************
 *            ATAPI IO Register File  
 ***************************************************************************/

/*
 * IDENTIFY data
 */
typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumberOfCylinders;               // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumberOfHeads;                   // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT SectorsPerTrack;                 // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    USHORT SerialNumber[10];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    USHORT FirmwareRevision[4];             // 2E  23-26
    USHORT ModelNumber[20];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid;          // 6A  53
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       // 76  59
    ULONG  UserAddressableSectors;          // 78  60-61
    USHORT SingleWordDMASupport : 8;        // 7C  62
    USHORT SingleWordDMAActive : 8;              // 7D
    USHORT MultiWordDMASupport : 8;         // 7E  63
    USHORT MultiWordDMAActive : 8;                 // 7F
    UCHAR  AdvancedPIOModes;                // 80  64
    UCHAR  Reserved4;                              // 81
    USHORT MinimumMWXferCycleTime;          // 82  65
    USHORT RecommendedMWXferCycleTime;      // 84  66
    USHORT MinimumPIOCycleTime;             // 86  67
    USHORT MinimumPIOCycleTimeIORDY;        // 88  68
    USHORT Reserved5[2];                    // 8A  69-70
    USHORT ReleaseTimeOverlapped;           // 8E  71
    USHORT ReleaseTimeServiceCommand;       // 90  72
    USHORT MajorRevision;                   // 92  73
    USHORT MinorRevision;                   // 94  74
    USHORT MaxQueueDepth;                   // 96  75
    USHORT Reserved6[12];                   // 98  76-87
    USHORT UtralDmaMode;                    /*     88 */
    USHORT Reserved8[38];                   //     89-126
    USHORT SpecialFunctionsEnabled;         //     127
    USHORT Reserved7[128];                  //     128-255

} IDENTIFY_DATA, *PIDENTIFY_DATA;


//
// Identify data without the Reserved4.
//
typedef struct _IDENTIFY_DATA2 {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumberOfCylinders;               // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumberOfHeads;                   // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT SectorsPerTrack;                 // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    USHORT SerialNumber[10];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    USHORT FirmwareRevision[4];             // 2E  23-26
    USHORT ModelNumber[20];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:1;        // 6A  53
    USHORT Reserved3:15;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[2];                    //     69-70
    USHORT ReleaseTimeOverlapped;           //     71
    USHORT ReleaseTimeServiceCommand;       //     72
    USHORT MajorRevision;                   //     73
    USHORT MinorRevision;                   //     74
//    USHORT Reserved6[14];                   //     75-88
} IDENTIFY_DATA2, *PIDENTIFY_DATA2;

#define IDENTIFY_DATA_SIZE sizeof(IDENTIFY_DATA2)

//
// IDENTIFY DMA timing cycle modes.
//

#define IDENTIFY_DMA_CYCLES_MODE_0 0x00
#define IDENTIFY_DMA_CYCLES_MODE_1 0x01
#define IDENTIFY_DMA_CYCLES_MODE_2 0x02

// Best PIO Mode definitions
#define PI_PIO_0    0x00
#define PI_PIO_1    0x01
#define PI_PIO_2    0x02
#define PI_PIO_3    0x03
#define PI_PIO_4    0x04
#define PI_PIO_5    0x05

#define    WDC_MW1_FIX_FLAG_OFFSET        129            
#define WDC_MW1_FIX_FLAG_VALUE        0x00005555  


#include <poppack.h>
#endif //_ATAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\device.c ===
/***************************************************************************
 * File:          device.c
 * Description:   Functions for IDE devices
 * Author:        Dahai Huang
 * Dependence:    global.h
 * Reference:     None
 *                
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/08/2000	HS.Zhang	Added this header
 *
 ***************************************************************************/
#include "global.h"


/******************************************************************
 * Issue Identify Command
 *******************************************************************/

int IssueIdentify(PDevice pDev, UCHAR Cmd DECL_BUFFER)
{
    PChannel   pChan = pDev->pChannel;
    PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2  ControlPort = pChan->BaseIoAddress2;
    int      i;
	 PULONG     SettingPort;
	 ULONG      OldSettings;

    SettingPort = (PULONG)(pChan->BMI+ ((pDev->UnitId & 0x10)>> 2) + 0x60);
	 OldSettings = InDWord(SettingPort);
	 OutDWord(SettingPort, pChan->Setting[DEFAULT_TIMING]);

    SelectUnit(IoPort, pDev->UnitId);
    if(WaitOnBusy(ControlPort) & IDE_STATUS_BUSY)  {
         IdeHardReset(ControlPort);
	 }

    SelectUnit(IoPort, pDev->UnitId);
    IssueCommand(IoPort, Cmd);

    for(i = 0; i < 5; i++)
        if(!(WaitOnBusy(ControlPort) & (IDE_STATUS_ERROR |IDE_STATUS_BUSY)))
            break;
    

    if (i < 5 && (WaitForDrq(ControlPort) & IDE_STATUS_DRQ)) {
         WaitOnBusy(ControlPort);
         GetBaseStatus(IoPort);
         OutPort(pChan->BMI + BMI_STS, BMI_STS_ERROR|BMI_STS_INTR);

         BIOS_IDENTIFY
         RepINS(IoPort, (ADDRESS)tmpBuffer, 256);
//			pDev->DeviceFlags = 0;
	      OutDWord(SettingPort, OldSettings);

         return(TRUE);
    }

    OutDWord(SettingPort, OldSettings);

    GetBaseStatus(IoPort);
    return(FALSE);
}

/******************************************************************
 * Select Device Mode
 *******************************************************************/


void DeviceSelectMode(PDevice pDev, UCHAR NewMode)
{
    PChannel   pChan = pDev->pChannel;
    PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	 UCHAR      Feature;


    SelectUnit(IoPort, pDev->UnitId);
    StallExec(200);
    SelectUnit(IoPort, pDev->UnitId);
	
#ifdef _BIOS_
	if(pDev->DeviceFlags2 & DFLAGS_REDUCE_MODE)
		NewMode= 4;
#endif

    /* Set Feature */
    SetFeaturePort(IoPort, 3);
	 if(NewMode < 5) {
        pDev->DeviceFlags &= ~(DFLAGS_DMA | DFLAGS_ULTRA);
		  Feature = (UCHAR)(NewMode | FT_USE_PIO);
	 } else if(NewMode < 8) {
        pDev->DeviceFlags |= DFLAGS_DMA;
		  Feature = (UCHAR)((NewMode - 5)| FT_USE_MWDMA);
	 } else {
        pDev->DeviceFlags |= DFLAGS_DMA | DFLAGS_ULTRA;
		  Feature = (UCHAR)((NewMode - 8) | FT_USE_ULTRA);
    }

    SetBlockCount(IoPort, Feature);

	 SetAtaCmd(pDev, IDE_COMMAND_SET_FEATURES);

	 pDev->DeviceModeSetting = NewMode;
	 OutDWord((PULONG)(pChan->BMI + ((pDev->UnitId & 0x10)>>2) + 
        0x60), pChan->Setting[(pDev->DeviceFlags & DFLAGS_ATAPI)? 
        pDev->bestPIO : NewMode]);
    
//OutDWord(0xcf4, pChan->Setting[NewMode]);

}

/******************************************************************
 * Set Disk
 *******************************************************************/

void SetDevice(PDevice pDev)
{
    PChannel   pChan = pDev->pChannel;
    PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;

    SelectUnit(IoPort, pDev->UnitId);
    StallExec(200);
    SelectUnit(IoPort, pDev->UnitId);

    /* set parameter for disk */
    SelectUnit(IoPort, (UCHAR)(pDev->UnitId | (pDev->RealHeader-1)));
    SetBlockCount(IoPort,  (UCHAR)pDev->RealSector);
	 SetAtaCmd(pDev, IDE_COMMAND_SET_DRIVE_PARAMETER);

    /* recalibrate */
    SetAtaCmd(pDev, IDE_COMMAND_RECALIBRATE);

#ifdef USE_MULTIPLE
    if (pDev->MultiBlockSize  > 512) {
        /* Set to use multiple sector command */
        SetBlockCount(IoPort,  (UCHAR)(pDev->MultiBlockSize >> 8));
		SelectUnit(IoPort, pDev->UnitId);
        if (!(SetAtaCmd(pDev, IDE_COMMAND_SET_MULTIPLE) & (IDE_STATUS_BUSY | IDE_STATUS_ERROR))) {
            pDev->ReadCmd  = IDE_COMMAND_READ_MULTIPLE;
            pDev->WriteCmd = IDE_COMMAND_WRITE_MULTIPLE;
            pDev->DeviceFlags |= DFLAGS_MULTIPLE;
            return;
         }
    }
#endif //USE_MULTIPLE
    pDev->ReadCmd  = IDE_COMMAND_READ;
    pDev->WriteCmd = IDE_COMMAND_WRITE;
    pDev->MultiBlockSize= 256;
}

/******************************************************************
 * Reset Controller
 *******************************************************************/
	
void IdeResetController(PChannel pChan)
{
    LOC_IDENTIFY
	 int i;
	 PDevice pDev;
    PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	 PULONG    SettingPort;
    ULONG     OldSettings;
    LOC_ARRAY_BLK;


	 DisableBoardInterrupt(pChan->BaseBMI);
	
    for(i = 0; i < 2; i++) {
        if((pDev = pChan->pDevice[i]) == 0)
			continue;
        if(pDev->DeviceFlags & DFLAGS_ATAPI) {
			GetStatus(ControlPort);
			AtapiSoftReset(IoPort, ControlPort, pDev->UnitId);
			if(GetStatus(ControlPort) == 0) 
				IssueIdentify(pDev, IDE_COMMAND_ATAPI_IDENTIFY ARG_IDENTIFY);
        } else {
#ifndef NOT_ISSUE_37
			////////////////////////////////////////
		   PUCHAR tmpBMI = pChan->BMI + (((UINT)pChan->BMI & 0xF)? 0x6C : 0x70);

         Reset370IdeEngine(pChan);
         StallExec(100L);
			SettingPort= (PULONG)(pChan->BMI+((pDev->UnitId &0x10) >>2)+ 0x60);
         OldSettings= InDWord(SettingPort);
         OutDWord(SettingPort, 0x80000000);

		   OutPort(tmpBMI+3, 0x80);
         OutWord(IoPort, 0x0);
         StallExec(500L);
	    	OutPort(tmpBMI+3, 0);

         Reset370IdeEngine(pChan);
         StallExec(100L);
			OutDWord(SettingPort, OldSettings);

#endif

         if(IdeHardReset(ControlPort) == FALSE)
				continue;
			SetDevice(pDev);
			DeviceSelectMode(pDev, pDev->DeviceModeSetting);
		}
	}
	EnableBoardInterrupt(pChan->BaseBMI);
}


/******************************************************************
 * Device Interrupt
 *******************************************************************/

UCHAR DeviceInterrupt(PDevice pDev, UINT abort)
{
	PVirtualDevice    pArray = pDev->pArray;
	PChannel          pChan = pDev->pChannel;
	PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
	PUCHAR            BMI = pChan->BMI;
	UINT              i;
	UCHAR             state;
	PULONG            SettingPort;
   ULONG             OldSettings;
	PUCHAR            tmpBMI;
	
#if !defined(_BIOS_) && !defined(WIN95)
	UCHAR             Orig = (UCHAR)pChan->OriginalSrb;
#endif									// !(_BIOS_) && !(WIN95)
	
	LOC_SRB
			
#ifndef _BIOS_
	PSrbExtension  pSrbExt;
	if(Srb == 0) {
		OutPort(BMI, BMI_CMD_STOP);					   
		
#ifndef NOT_ISSUE_37
		Reset370IdeEngine(pChan); 
	   // add 2/09/01
		tmpBMI = pChan->BMI + (((UINT)pChan->BMI & 0xF)? 0x6C : 0x70);
      StallExec(100L);
		SettingPort= (PULONG)(pChan->BMI+((pDev->UnitId &0x10) >>2)+ 0x60);
      OldSettings= InDWord(SettingPort);
      OutDWord(SettingPort, 0x80000000);

		OutPort(tmpBMI+3, 0x80);
      OutWord(IoPort, 0x0);
      StallExec(500L);
	   OutPort(tmpBMI+3, 0);

      Reset370IdeEngine(pChan);
      StallExec(100L);
		OutDWord(SettingPort, OldSettings);

#endif									// NOT_ISSUE_37
		
		while(InPort(BMI + BMI_STS) & BMI_STS_INTR){
			SelectUnit(IoPort, pDev->UnitId);
			state = GetBaseStatus(IoPort);
			OutPort(BMI + BMI_STS, BMI_STS_INTR);		
		}

		return(TRUE);
	}
	pSrbExt = (PSrbExtension)Srb->SrbExtension;
#endif									// !(_BIOS_)

	if(abort)
		goto end_process;

	i = 0;
	if(pDev->DeviceFlags & DFLAGS_DMAING) {
		/*
		 * BugFix: by HS.Zhang
		 * 
		 * if the device failed the request before DMA transfer.We
		 * cann't detect whether the INTR is corrent depended on
		 * BMI_STS_ACTIVE. We should check whether the FIFO count is
		 * zero.
		 */
//		if((InPort(BMI + BMI_STS) & BMI_STS_ACTIVE)!=0){
		if((InWord(pChan->MiscControlAddr+2) & 0x1FF)){ // if FIFO count in misc 3 register NOT equ 0, it's a fake interrupt.
			return FALSE;
		}

		OutPort(BMI, BMI_CMD_STOP);
#ifndef NOT_ISSUE_37
		Reset370IdeEngine(pChan);		  
	   // add 2/09/01
		tmpBMI = pChan->BMI + (((UINT)pChan->BMI & 0xF)? 0x6C : 0x70);
      StallExec(100L);
		SettingPort= (PULONG)(pChan->BMI+((pDev->UnitId &0x10) >>2)+ 0x60);
      OldSettings= InDWord(SettingPort);
      OutDWord(SettingPort, 0x80000000);

		OutPort(tmpBMI+3, 0x80);
      OutWord(IoPort, 0x0);
      StallExec(500L);
	   OutPort(tmpBMI+3, 0);

      Reset370IdeEngine(pChan);
      StallExec(100L);
		OutDWord(SettingPort, OldSettings);

#endif

/*		  
#ifndef USE_PCI_CLK
        if((Srb->Cdb[0] == SCSIOP_READ) && (pDev->DeviceFlags & DFLAGS_NEED_SWITCH)){ 
			if((InPort(pChan->NextChannelBMI + BMI_STS) & BMI_STS_ACTIVE) == 0){
				OutPort((PUCHAR)((ULONG)pChan->BaseBMI+0x7B), 0x20);
			}
		}
#endif
*/
	}

	while(InPort(BMI + BMI_STS) & BMI_STS_INTR){
		SelectUnit(IoPort, pDev->UnitId);
		state = GetBaseStatus(IoPort);
		OutPort(BMI + BMI_STS, BMI_STS_INTR);		
	}

	if (state & IDE_STATUS_BUSY) {
		for (i = 0; i < 10; i++) {
			state = GetBaseStatus(IoPort);
			if (!(state & IDE_STATUS_BUSY))
				break;
			StallExec(5000);
		}
		if(i == 10) {
			OS_Busy_Handle(pChan, pDev);
			return TRUE;
		}
	}

	if((state & IDE_STATUS_DRQ) == 0 || (pDev->DeviceFlags & DFLAGS_DMAING))
		goto  complete;

#ifdef SUPPORT_ATAPI

	if(pDev->DeviceFlags & DFLAGS_ATAPI) {
		AtapiInterrupt(pDev);
		return TRUE;
	}

#endif //SUPPORT_ATAPI

	if((Srb->SrbFlags & (SRB_FLAGS_DATA_OUT | SRB_FLAGS_DATA_IN)) == 0) {
		OS_Reset_Channel(pChan);
		return TRUE;
	}

	if(AtaPioInterrupt(pDev))    
		return TRUE;

complete:

#ifdef SUPPORT_ATAPI

	if(pDev->DeviceFlags & DFLAGS_ATAPI) {
		if(pDev->DeviceFlags & DFLAGS_DMAING);
		OutDWord((PULONG)(pChan->BMI + ((pDev->UnitId & 0x10)>>2) + 
						  0x60), pChan->Setting[pDev->bestPIO]);

		if(state & IDE_STATUS_ERROR) 
			Srb->SrbStatus = MapAtapiErrorToOsError(GetErrorCode(IoPort) ARG_SRB);
					
		/*
		 * BugFix: by HS.Zhang
		 * The Atapi_End_Interrupt will call DeviceInterrupt with Abort
		 * flag set as TRUE, so if we don't return here. the
		 * CheckNextRequest should be called twice.
		 */
#if !defined(_BIOS_)
		return Atapi_End_Interrupt(pDev ARG_SRB);
#endif // !(_BIOS_)
/*		
#if !defined(_BIOS_) && !defined(WIN95)
		if(Orig)
			return TRUE;
#endif // !(_BIOS_ & WIN95)
*/
	} else
#endif	// SUPPORT_ATAPI

		if (state & IDE_STATUS_ERROR) {
			UCHAR   statusByte, cnt=0;
			PIDE_REGISTERS_2 ControlPort;

			Srb->SrbStatus = MapAtaErrorToOsError(GetErrorCode(IoPort) ARG_SRB);

			// clear IDE bus status
         DisableBoardInterrupt(pChan->BaseBMI);
			ControlPort = pChan->BaseIoAddress2;
			for(cnt=0;cnt<10;cnt++) {
				SelectUnit(IoPort, pDev->UnitId);
				statusByte = WaitOnBusy(ControlPort);
				if(statusByte & IDE_STATUS_ERROR) {
					IssueCommand(IoPort, IDE_COMMAND_RECALIBRATE);
					statusByte = WaitOnBusy(ControlPort);
					GetBaseStatus(IoPort);
				}
				else break;
			}
         EnableBoardInterrupt(pChan->BaseBMI);

			/* gmm 2001-1-20
			 *
			 * Retry R/W operation.
			 */
			if (pChan->RetryTimes++ < 10) {
				StartIdeCommand(pDev ARG_SRB);
				return TRUE;
			}
			else
				ReportError(pDev, Srb->SrbStatus ARG_SRB);
		}

end_process:
/*

#if defined(SUPPORT_ATAPI) && !defined(_BIOS_) && !defined(WIN95)
	if(Orig) {
		if(abort)
			Atapi_End_Interrupt(pDev, Srb);
		return TRUE;
	}
#endif									// (SUPPORT_ATAPI) && !(BIOS) && !(WIN95)

*/
	pChan->RetryTimes = 0;
	pChan->pWorkDev = 0;
	excluded_flags |= (1 << pChan->exclude_index);

	pDev->DeviceFlags &= ~(DFLAGS_DMAING | DFLAGS_REQUEST_DMA WIN_DFLAGS);

	if((pArray == 0)||
	   (pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY)){
		if(Srb->SrbStatus == SRB_STATUS_PENDING)
			Srb->SrbStatus = SRB_STATUS_SUCCESS;
		CopyInternalBuffer(pDev, Srb);
		OS_EndCmd_Interrupt(pChan ARG_SRB);
		return TRUE;
	}

	return ArrayInterrupt(pDev);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\device.h ===
/***************************************************************************
 * File:          device.h
 * Description:   Data structure for Device and IDE channel object
 * Author:        Dahai Huang
 * Dependence:    None
 * Reference:     None
 *                
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:       DH 5/10/2000 initial code
 *		11/07/2000	HS.Zhang	Added a member MiscControlAddr
 *
 ***************************************************************************/


#ifndef _DEVICE_H_
#define _DEVICE_H_

#include <pshpack1.h>
/***************************************************************************
 * Description:  Device Table
 ***************************************************************************/

typedef struct _Device {
    UINT    DeviceFlags;       /* Device Flags, see below */
	UINT	DeviceFlags2;	   /* Second Device Flags storage */
    UCHAR   UnitId;            /* Device ID: 0xA0 or 0x B0 */
    UCHAR   DeviceModeSetting; /* Current Data Transfer mode: 0-4 PIO 0-4 */
                               /* 5-7 MW DMA0-2, 8-13 UDMA0-5             */
    UCHAR   ReadCmd;           /* Read or Read Multiple */ 
    UCHAR   WriteCmd;          /* Write or Write Multiple */
    UINT    MultiBlockSize;    /* Word count per interrupt */

    USHORT  RealHeadXsect;     /* Disk physical head */
    UCHAR   RealSector;        /* Disk physical sector per track */
    UCHAR   RealHeader;        /* Disk physical head */
 
    UCHAR   bestPIO;           /* Best PIO mode of this device */
    UCHAR   bestDMA;           /* Best MW DMA mode of this device */
    UCHAR   bestUDMA;          /* Best Ultra DMA mode of this device */
    UCHAR   Usable_Mode;       /* actual maximum data transfer mode */

    ULONG   HidenLBA;          /* Hiden sectors for stripe disk */
    struct _Channel *pChannel; /* The channel this device attached */

    ULONG   capacity;          /* The real capacity of this disk */
#ifdef _BIOS_
    USHORT  headerXsect_per_tck;/* = MaxSector * MaxHeader */
    USHORT  MaxCylinder;       /* Disk Maximum Logic cylinders */
    UCHAR   MaxSector;         /* Disk Maximum Logic sectors per track */
    UCHAR   MaxHeader;         /* Disk Maximum Logic head */
    USHORT  RealCylinder;      /* Disk Maximum physical cylinders */

    UCHAR   bios_num;          /* bios device letter: 0x80 = c: 0x81 = d: */
    UCHAR   Seq;               /* device sequence number when scanning device */
    UCHAR   LockNum;           /* How many lock commands have be received */
    UCHAR   BestModeSelect;    /* Best transfer mode of the disk */
    FDPT_Ext *pFdptExt;
	ULONG   RebuiltSector;
#else
    PSCSI_REQUEST_BLOCK CurrentList;/* first link list for waiting SRB */
    PSCSI_REQUEST_BLOCK NextList;/* second link list for waiting SRB */    

    IDENTIFY_DATA2 IdentifyData;/* Identify Data of this device */

	union {
		ULONG   DiscsPresent;      /* The number of logic Disc in the CD Changer */
		ULONG   RebuiltSector;
	};
    UCHAR   SmartCommand;      /* Last smart command */
    UCHAR   ReturningMediaStatus; /* Last Media status */
#endif

    UCHAR   ArrayMask;         /* constant = (1 << ArrayNum) */
    UCHAR   ArrayNum;		   /* the sequence number in an array */
    struct _VirtualDevice *pArray;/* the array this disk belong to */

#ifdef SUPPORT_TCQ
    UCHAR   MaxQueue;          /* the queue depth of the TCQ disk */
    UCHAR   CurrentQueued;	   /* how many commands are in disk queue */
    USHORT  reserved; 
    ULONG   TagIndex;          /* bit map for who is queued */
    PULONG  pTagTable;         /* point to the Tag list */
#endif
																			  
	struct{	   
		ULONG	nLastError;				/* Last Error happend on this device */
		struct _Device	*pNextErrorDevice;		/* next device which has error */
		UCHAR	Cdb[16];
	}stErrorLog;
	
	ULONG	nLockedLbaStart;			/* the start LBA address of locked block */
	ULONG	nLockedLbaEnd;				/* the end LBA address of locked block */
	
} Device, *PDevice;

/*First device flags declare*/
#define DFLAGS_LBA                  0x1    // Use LBA mode on drive
#define DFLAGS_DMA                  0x2    // Use DMA on the drive
#define DFLAGS_MULTIPLE             0x4    // Use Multi-Block commands
#define DFLAGS_ULTRA                0x8    // Support ultra DMA

#define DFLAGS_DMAING               0x10   // This Device is doing DMA 
#define DFLAGS_REQUEST_DMA          0x20   // This Device want to do DMA
#define DFLAGS_HIDEN_DISK           0x40   // This is a hiden disk in a array
#define DFLAGS_ARRAY_DISK           0x80   // This is member of an array

#define DFLAGS_ATAPI                0x100  // This is ATAPI device
#define DFLAGS_INTR_DRQ             0x4    // This ATAPI device need interrupt DRQ
#define DFLAGS_NEED_SWITCH          0x200  // This disk need fix HPT370 bug
#define DFLAGS_REMOVABLE_DRIVE      0x400  // ATA removable device (IDE ZIP)
#define DFLAGS_DEVICE_LOCKABLE      0x800  // This devices is lockable 

#define DFLAGS_CDROM_DEVICE         0x1000 // This is a CDROM device
#define DFLAGS_HARDDISK             0x2000 // This is a non-removable disk
#define DFLAGS_LS120                0x4000 // This is a LS-120 
#define DFLAGS_BOOT_SECTOR_PROTECT  0x8000 // Protect boot sector from write

#ifndef _BIOS_
#define DFLAGS_FORCE_PIO            0x10000 // Force to do PIO 
#define DFLAGS_TAPE_RDP             0x20000 // Tape special commamds
#define DFLAGS_MEDIA_STATUS_ENABLED 0x40000 // This device receive 0xDA	command
#define DFLAGS_TAPE_DEVICE          0x80000 // TAPE device

#define DFLAGS_SET_CALL_BACK        0x100000 // in CallBack mode
#define DFLAGS_SORT_UP              0x200000 // Direction for sorting LBA
#define DFLAGS_ARRAY_WAIT_EXEC      0x400000 // Wait for executing Array command
#define DFLAGS_TCQ_WAIT_SERVICE     0x800000 // Wait TCQ service status

#define DFLAGS_WIN_SHUTDOWN			0x1000000
#define DFLAGS_WIN_FLUSH   			0x2000000
#define DFLAGS_HAS_LOCKED			0x4000000

#ifdef WIN95
#define DFLAGS_OPCODE_CONVERTED     0x10000000
#else
#define DFLAGS_CHANGER_INITED       0x10000000  // Indicates that the init path for changers has already been done.
#define DFLAGS_ATAPI_CHANGER        0x20000000  // Indicates atapi 2.5 changer present.
#define DFLAGS_SANYO_ATAPI_CHANGER  0x40000000  // Indicates multi-platter device, not conforming to the 2.5 spec.
#endif
#endif //_BIOS_

/*Second device flags*/
#define DFLAGS_REDUCE_MODE	        0x10000
#define DFLAGS_DEVICE_DISABLED	    0x20000		// Indicates that the device disabled
#define DFLAGS_DEVICE_SWAPPED	    0x40000		// A swapped mirror disk in 1+0 case
#define DFLAGS_BEING_BUILT			0x10000000  // rebuilding state in 1+0 case
#define DFLAGS_NEED_REBUILD			0x20000000  // rebuilding state in 1+0 case
#define DFLAGS_NEW_ADDED			0x40000000  // newly added disk

/*
 * Added by HS.Zhang
 * this structure is used to save transfer mode settings
 */
typedef union _st_XFER_TYPE_SETTING{
	struct{
		UCHAR	XferMode : 4;		// the MAX usable mode in this transfer type
		UCHAR	XferType : 4;		// the transfer type
	};
	UCHAR	Mode;
}ST_XFER_TYPE_SETTING;
						
#define XFER_TYPE_PIO		0x0			// transfer type is PIO
#define XFER_TYPE_MDMA		0x1			// transfer type is Multiwords DMA
#define XFER_TYPE_UDMA		0x2			// transfer type is Ultra DMA
#define	XFER_TYPE_AUTO		0xF			// auto detect tranfer mode

/***************************************************************************
 * Description: Bad Device 
 ***************************************************************************/

typedef struct _BadModeList {
    UCHAR      UltraDMAMode;	 /* 0xFF not support, others useable mode */
    UCHAR      DMAMode;			 /* 0xFF not support, others useable mode */
    UCHAR      PIOMode;			 /* 0xFF not support, others useable mode */
    UCHAR      length;			 /* length of identify string */
    UCHAR     *name;			 /* point to identify string */
} BadModeList, *PBadModeList;

#define HPT366_ONLY   0x20		 /* only modify if it is the HPT366 */
#define HPT368_ONLY   0x40		 /* only modify if it is the HPT368 */
#define HPT370_ONLY   0x80		 /* only modify if it is the HPT370 */

/***************************************************************************
 * Description: Bus Table
 ***************************************************************************/

typedef struct _Channel {
    PIDE_REGISTERS_1 BaseIoAddress1;  // IDE Base Port Address
    PIDE_REGISTERS_2 BaseIoAddress2;  // IDE Control Port Address
    PUCHAR           BMI;             // IDE DMA extended Port Addresss
    PUCHAR           BaseBMI;         // HPT370 IO base PCI config address
	
	PUCHAR			 NextChannelBMI;  // BMI address of another channel
	PUCHAR			 MiscControlAddr; // Misc. Control register base for this channel

    UCHAR            InterruptLevel;  // IRQ number for the channel  
    UCHAR            ChannelFlags;    // Channel Flags, see below

    UCHAR            RetryTimes;      // Don't insert any item at above
    UCHAR            nSector;         // Current Logic Disk command: N sector
    ULONG            Lba;             // Current Logic Disk command: LBA

    ADDRESS          BufferPtr;       // Data buffer that OS pass to
    UINT             WordsLeft;       // word length of data transfer

    UINT             exclude_index;   // exclusive resource allocate mark

    PSCSI_REQUEST_BLOCK CurrentSrb;   // current SRB
    PDevice          pWorkDev;        // current Working device

    PCI1_CFG_ADDR    pci1_cfg;        // PCI Address for the channel
    ULONG            *Setting;        // point to HPT3xx Timing table

    PDevice          pDevice[2];      // point to the exsiting devices */

    ULONG            SgPhysicalAddr;  // physcial address of SG table
    PSCAT_GATH       pSgTable;        // point to SG table of this channel

#ifndef _BIOS_
    struct _HW_DEVICE_EXTENSION *HwDeviceExtension;
    VOID   (* CallBack)(struct _Channel *);

    Device           Devices[2];

#ifdef WIN95
    UCHAR            OrgCdb[MAXIMUM_CDB_SIZE];
#else
    PSCSI_REQUEST_BLOCK OriginalSrb;
    SCSI_REQUEST_BLOCK InternalSrb;
    MECHANICAL_STATUS_INFORMATION_HEADER MechStatusData;
    SENSE_DATA MechStatusSense;
    ULONG MechStatusRetryCount;
#endif //WIN95
#endif //_BIOS_

} Channel, *PChannel;

/* ChannelFlags */
#define IS_HPT_366      1      /* This is a HPT366 Adapter */
#define IS_HPT_368      2      /* This is a HPT368 Adapter */
#define IS_HPT_370      4      /* This is a HPT370 Adapter */
#define IS_DPLL_MODE    0x8    /* HPT370 is using DPLL */
#define IS_80PIN_CABLE  0x30   /* 80 pin cable attached */
#define IS_CABLE_CHECK  0x40   /* 80 pin cable attached */
#define PF_ACPI_INTR    0x80   /* hptpwr.c is waiting a interrupt */

#include <poppack.h>
#endif //_DEVICE_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\devmgr.h ===
#ifndef DeviceManagement_H_
#define DeviceManagement_H_

#include "RaidCtl.h"

#define MAX_DISKS           8

int RAIDController_GetNum();
BOOL RAIDController_GetInfo( int iController, St_StorageControllerInfo* pInfo );

HDISK Device_GetHandle( PDevice pDevice );
void Device_ReportFailure( PDevice pDevice );

BOOL Device_GetSibling( HDISK hNode, HDISK * pSilbingNode );
BOOL Device_GetChild( HDISK hParentNode, HDISK * pChildNode );
BOOL Device_GetInfo( HDISK hDeviceNode, St_DiskStatus * pInfo );

HDISK Device_CreateMirror( HDISK * pDisks, int nDisks );
HDISK Device_CreateStriping( HDISK *pDisks, int nDisks, int nStripSizeShift );
HDISK Device_CreateSpan( HDISK * pDisks, int nDisks );
BOOL Device_Remove( HDISK hDisk );
BOOL Device_AddSpare( HDISK hMirror, HDISK hDisk );
BOOL Device_DelSpare( HDISK hDisk );
BOOL Device_AddMirrorDisk( HDISK hMirror, HDISK hDisk );
BOOL Device_AddPhysicalDisk( IN PDevice pDev );

BOOL Device_BeginRebuildingMirror( HDISK hMirror );
BOOL Device_AbortMirrorBuilding( HDISK hMirror );
BOOL Device_ValidateMirror( HDISK hMirror );

void Device_SetArrayName(HDISK hDisk, char* arrayname);
HDISK Device_CreateRAID10 ( HDISK * pDisks, int nDisks, int nStripSizeShift);
BOOL Device_RescanAll();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\finddev.c ===
#include "global.h"

/***************************************************************************
 * File:          Finddev.c
 * Description:   Subroutines in the file are used to scan devices
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 *                
 * History:     
 *	
 *	SC 12/06/2000  The cable detection will cause drive not
 *                ready when drive try to read RAID information block. There
 *                is a fix in "ARRAY.C" to retry several times
 *
 * SC 12/04/2000  In previous changes, the reset will cause
 *                hard disk detection failure if a ATAPI device is connected
 *                with hard disk on the same channel. Add a "drive select" 
 *                right after reset to fix this issue
 *
 *	SC 11/27/2000  modify cable detection (80-pin/40-pin)
 *
 *	SC 11/01/2000  remove hardware reset if master device
 *                is missing
 * DH 5/10/2000 initial code
 *
 ***************************************************************************/

/******************************************************************
 * Find Device
 *******************************************************************/

USHORT    pioTiming[6] = {960, 480, 240, 180, 120, 90};

int FindDevice(
   PDevice pDev,
   ST_XFER_TYPE_SETTING osAllowedMaxXferMode
   )
{
    LOC_IDENTIFY
    PChannel          pChan = pDev->pChannel;
    PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2  ControlPort = pChan->BaseIoAddress2;
    PBadModeList      pbd;
    OLD_IRQL
    int               j;
    UCHAR             stat, mod;

    DISABLE

	// initialize the critical member of Device
 
	memset(&pDev->stErrorLog, 0, sizeof(pDev->stErrorLog));

	pDev->nLockedLbaStart = -1;	// when start LBA == -1, mean no block locked
	pDev->nLockedLbaEnd = 0;		// when end LBA == 0, mean no block locked also

    SelectUnit(IoPort,pDev->UnitId);
    for(j = 1; j < 15; j++) {
        stat = WaitOnBusy(ControlPort);
        SelectUnit(IoPort,pDev->UnitId);
        if((stat & IDE_STATUS_BUSY) == 0)
            goto check_port;
    }

	 //  01/11 Maxtor disk on a single disk single cable
    //  can't accept this reset. It should be OK without this 
    //  reset if master disk is missing
    //IdeHardReset(ControlPort);

check_port:
    SetBlockNumber(IoPort, 0x55);
    SetBlockCount(IoPort, 0);
    if(GetBlockNumber(IoPort) != 0x55) {
no_dev:
        SelectUnit(IoPort,(UCHAR)(pDev->UnitId ^ 0x10));
        ENABLE
//		  OutPort(pChan->BaseBMI+0x7A, 0);
        return(FALSE);
    }
    SetBlockNumber(IoPort, 0xAA);
    if(GetBlockNumber(IoPort) != 0xAA)
        goto no_dev;
    ENABLE

/*===================================================================
 * check if the device is a ATAPI one
 *===================================================================*/

    if(GetByteLow(IoPort) == 0x14 && GetByteHigh(IoPort) == 0xEB)
          goto is_cdrom;

    for(j = 0; j != 0xFFFF; j++) {
        stat = GetBaseStatus(IoPort);
        if(stat & IDE_STATUS_DWF)
             break;
        if((stat & IDE_STATUS_BUSY) == 0) {
             if((stat & (IDE_STATUS_DSC|IDE_STATUS_DRDY)) == (IDE_STATUS_DSC|IDE_STATUS_DRDY))
                 goto chk_cd_again;
             break;
        }
        StallExec(5000);
    }

    if((GetBaseStatus(IoPort) & 0xAE) != 0)
        goto no_dev;

/*===================================================================
 * Read Identifytify data for a device
 *===================================================================*/

chk_cd_again:
    if(GetByteLow(IoPort) == 0x14 && GetByteHigh(IoPort) == 0xEB) {
is_cdrom:
        AtapiSoftReset(IoPort, ControlPort, pDev->UnitId);
		  StallExec(1000000L);

        if(IssueIdentify(pDev, IDE_COMMAND_ATAPI_IDENTIFY ARG_IDENTIFY) == 0) 
             goto no_dev;

        pDev->DeviceFlags = DFLAGS_ATAPI;

#ifndef _BIOS_
		  if(osAllowedMaxXferMode.XferType== 0xE)
               pDev->DeviceFlags |= DFLAGS_FORCE_PIO;
#endif

        if(Identify.GeneralConfiguration & 0x20)
            pDev->DeviceFlags |= DFLAGS_INTR_DRQ;

        if((Identify.GeneralConfiguration & 0xF00) == 0x500)
                pDev->DeviceFlags |= DFLAGS_CDROM_DEVICE;

#ifndef _BIOS_
        if((Identify.GeneralConfiguration & 0xF00) == 0x100)
                 pDev->DeviceFlags |= DFLAGS_TAPE_DEVICE;
#endif

        stat = (UCHAR)GetMediaStatus(pDev);
        if((stat & 0x100) == 0 || (stat & 4) == 0)
            pDev->DeviceFlags |= DFLAGS_DEVICE_LOCKABLE;

    } else if(IssueIdentify(pDev, IDE_COMMAND_IDENTIFY ARG_IDENTIFY) == FALSE) { 

        if((GetBaseStatus(IoPort) & ~1) == 0x50 ||
            (GetByteLow(IoPort) == 0x14 && GetByteHigh(IoPort) == 0xEB))
            goto is_cdrom;
        else
            goto no_dev;
	 }

    if((Identify.SpecialFunctionsEnabled & 1) || 
       (Identify.GeneralConfiguration & 0x80))
       pDev->DeviceFlags |= DFLAGS_REMOVABLE_DRIVE;

    if(*(PULONG)Identify.ModelNumber == 0x2D314C53) // '-1LS')
          pDev->DeviceFlags |= DFLAGS_LS120;
 
#ifdef _BIOS_ 
	 // reduce mode for all Maxtor ATA-100 hard disk
	//	  
	{
		PUCHAR modelnum= (PUCHAR)&Identify.ModelNumber;
		if(modelnum[0]=='a' && modelnum[1]=='M' && modelnum[2]=='t' &&
		   modelnum[3]=='x' && modelnum[4]=='r' && modelnum[13]=='H'){
			pDev->DeviceFlags2 = DFLAGS_REDUCE_MODE;				  
		}
	}
#endif
	
    if((pDev->DeviceFlags & (DFLAGS_ATAPI | DFLAGS_REMOVABLE_DRIVE |
        DFLAGS_LS120)) == 0)
        pDev->DeviceFlags |= DFLAGS_HARDDISK;
       
/*===================================================================
 * Copy Basic Info
 *===================================================================*/   

 	 SetMaxCmdQueue(pDev, Identify.MaxQueueDepth & 0x1F);

    pDev->DeviceFlags |= (UCHAR)((Identify.Capabilities  >> 9) & 1);
    pDev->MultiBlockSize = Identify.MaximumBlockTransfer << 7;

    if(Identify.TranslationFieldsValid & 1) {
       pDev->RealHeader     = (UCHAR)Identify.NumberOfCurrentHeads;
       pDev->RealSector     = (UCHAR)Identify.CurrentSectorsPerTrack;
       pDev->capacity = ((Identify.CurrentSectorCapacity <
            Identify.UserAddressableSectors)? Identify.UserAddressableSectors :
            Identify.CurrentSectorCapacity) - 1;
    } else {
       pDev->RealHeader     = (UCHAR)Identify.NumberOfHeads;
       pDev->RealSector     = (UCHAR)Identify.SectorsPerTrack;
       pDev->capacity = Identify.UserAddressableSectors - 1;
    }

    pDev->RealHeadXsect = pDev->RealSector * pDev->RealHeader;

/*===================================================================
 * Select Best PIO mode
 *===================================================================*/   

    if((mod = Identify.PioCycleTimingMode) > 4)
        mod = 0;
    if((Identify.TranslationFieldsValid & 2) &&
       (Identify.Capabilities & 0x800) && (Identify.AdvancedPIOModes)) {
       if(Identify.MinimumPIOCycleTime > 0)
             for (mod = 5; mod > 0 &&
                 Identify.MinimumPIOCycleTime > pioTiming[mod]; mod-- );
        else
             mod = (UCHAR)(
             (Identify.AdvancedPIOModes & 0x1) ? 3 :
             (Identify.AdvancedPIOModes & 0x2) ? 4 :
             (Identify.AdvancedPIOModes & 0x4) ? 5 : mod);
    }

    // add by HSZ 11/14
	 if(osAllowedMaxXferMode.XferType == XFER_TYPE_PIO){
		mod = MIN(osAllowedMaxXferMode.XferMode, mod);
	 }
    pDev->bestPIO = (UCHAR)mod;

/*===================================================================
 * Select Best Multiword DMA
 *===================================================================*/   

#ifdef USE_DMA
    if((Identify.Capabilities & 0x100) &&   // check mw dma
       (Identify.MultiWordDMASupport & 6)) {
       pDev->bestDMA = (UCHAR)((Identify.MultiWordDMASupport & 4)? 2 : 1);
		 // add by HSZ	11/14
		 if(osAllowedMaxXferMode.XferType == XFER_TYPE_MDMA){
		 	pDev->bestDMA = MIN(osAllowedMaxXferMode.XferMode, pDev->bestDMA);
		 }else if(osAllowedMaxXferMode.XferType < XFER_TYPE_MDMA){
		 	pDev->bestDMA = 0xFF;
		 }
    } else 
#endif //USE_DMA
        pDev->bestDMA = 0xFF;

/*===================================================================
 * Select Best Ultra DMA
 *===================================================================*/   
//   11/27/00 for cable detection
//   out 3f6, 4   // reset twice
//   read 7A
//   out 3f6, 0   // stop rest
//   out 1f6, 0ah // drive select again
//
	 if(!(pChan->ChannelFlags & IS_CABLE_CHECK) &&
       (pDev->DeviceFlags & DFLAGS_HARDDISK)) {
      SelectUnit(IoPort,pDev->UnitId);
      UnitControl(ControlPort,IDE_DC_RESET_CONTROLLER );
      StallExec(10000L);
	  
      UnitControl(ControlPort,IDE_DC_RESET_CONTROLLER );
      StallExec(50000L);
	 }
////////////

    if((pChan->ChannelFlags & IS_80PIN_CABLE) &&
        ((InPort(pChan->BaseBMI+0x7A) << 4) & pChan->ChannelFlags)) 
        pChan->ChannelFlags &= ~IS_80PIN_CABLE;

//   11/27/00 for cable detection
//    add drive select to make sure drive is ready after reset
//
	 if(!(pChan->ChannelFlags & IS_CABLE_CHECK) &&
        (pDev->DeviceFlags & DFLAGS_HARDDISK)) {

      pChan->ChannelFlags |= IS_CABLE_CHECK;
      UnitControl(ControlPort,IDE_DC_REENABLE_CONTROLLER);
      for (j = 0; j < 1000000L; j++) {
         SelectUnit(IoPort,pDev->UnitId);
         stat = GetBaseStatus(IoPort);
         if (stat != IDE_STATUS_IDLE && stat != 0x0) 
             StallExec(30);
	      else
            break;
	  }
     SelectUnit(IoPort,pDev->UnitId);
	 }
//////////// 
#ifdef USE_DMA
    if(Identify.TranslationFieldsValid & 0x4)  {
       mod = (UCHAR)((Identify.UtralDmaMode & 0x20)? 5 :
            (Identify.UtralDmaMode & 0x8)? 4 :
            (Identify.UtralDmaMode & 0x10 ) ? 3:
            (Identify.UtralDmaMode & 0x4) ? 2 :    /* ultra DMA Mode 2 */
            (Identify.UtralDmaMode & 0x2) ? 1 : 0);   /* ultra DMA Mode 1 */

			if((pChan->ChannelFlags & IS_80PIN_CABLE) == 0 && mod > 2)
              mod = 2;

		   if(osAllowedMaxXferMode.XferType == XFER_TYPE_UDMA){
		      mod = MIN(osAllowedMaxXferMode.XferMode, mod);
		   }else if(osAllowedMaxXferMode.XferType < XFER_TYPE_MDMA){
		      mod = 0xFF;
		   }
         pDev->bestUDMA = (UCHAR)mod;

    } else
#endif //USE_DMA
        pDev->bestUDMA = 0xFF;

/*===================================================================
 * select bset mode 
 *===================================================================*/   

    pbd = check_bad_disk((PUCHAR)&Identify.ModelNumber, pChan);

    if((pbd->UltraDMAMode | pDev->bestUDMA) != 0xFF) 
        pDev->Usable_Mode = (UCHAR)((MIN(pbd->UltraDMAMode, pDev->bestUDMA)) + 8);
    else if((pbd->DMAMode | pDev->bestDMA) != 0xFF) 
        pDev->Usable_Mode = (UCHAR)((MIN(pbd->DMAMode, pDev->bestDMA)) + 5);
     else 
        pDev->Usable_Mode = MIN(pbd->PIOMode, pDev->bestPIO);

     OS_Identify(pDev);

     if((pDev->DeviceFlags & DFLAGS_ATAPI) == 0) 
         SetDevice(pDev);

#ifdef DPLL_SWITCH
     if((pChan->ChannelFlags & IS_HPT_370) && pDev->Usable_Mode == 13) {
         if(pChan->ChannelFlags & IS_DPLL_MODE)
            pDev->DeviceFlags |= DFLAGS_NEED_SWITCH;
     }
#endif
 
     DeviceSelectMode(pDev, pDev->Usable_Mode);

     return(TRUE);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\devtree.c ===
#include "global.h"
#include "devmgr.h"

extern int num_adapters;
extern PHW_DEVICE_EXTENSION hpt_adapters[];

/*
 * Array id: 32bit
 *  31   27          23      15      7          0
 *  -----+-----------+-------+-------+------------
 *  0x80 | child_seq |   0   | flags | array_seq 
 *  -----+-----------+-------+-------+------------
 */
#define IS_ARRAY_ID(hDisk)				(((DWORD)(hDisk) & 0xF0000000) == 0x80000000)
#define GET_ARRAY_NUM(pArray)			(pArray-VirtualDevices)
#define MAKE_ARRAY_ID(pArray)			(HDISK)(0x80000000|GET_ARRAY_NUM(pArray))
#define MAKE_COMPOSED_ARRAY_ID(pArray)	(HDISK)(0x80000100|GET_ARRAY_NUM(pArray))
#define IS_COMPOSED_ARRAY(hDisk)		((DWORD)(hDisk) & 0x0100)
#define MAKE_CHILD_ARRAY_ID(pArray, iChild) \
										(HDISK)((DWORD)MAKE_ARRAY_ID(pArray) | ((iChild) & 0xF)<<24)
#define ARRAY_FROM_ID(hDisk)			(&VirtualDevices[(DWORD)(hDisk) & 0xFF])
#define CHILDNUM_FROM_ID(hDisk)			(((DWORD)(hDisk))>>24 & 0xF)

/*
 * Device id: 32bit
 *  31    23            15        7     0
 *  ------+-------------+---------+------
 *   0xC0 | adapter_num | bus_num | id
 *  ------+-------------+---------+------
 */
#define IS_DEVICE_ID(hDisk) (((DWORD)(hDisk) & 0xF0000000) == 0xC0000000)
static HDISK MAKE_DEVICE_ID(PDevice pDev)
{
	int iAdapter, iChan, iDev;
	for (iAdapter=0; iAdapter<num_adapters; iAdapter++)
		for (iChan=0; iChan<2; iChan++)
			for (iDev=0; iDev<2; iDev++)
				if (hpt_adapters[iAdapter]->IDEChannel[iChan].pDevice[iDev] == pDev)
					return (HDISK)(0xC0000000 | iAdapter<<16 | iChan<<8 | iDev);
	return INVALID_HANDLE_VALUE;
}
static PDevice DEVICE_FROM_ID(HDISK hDisk)
{
	if (hDisk!=INVALID_HANDLE_VALUE)
		return 
		hpt_adapters[((DWORD)(hDisk) & 0x00FF0000)>>16]->
		IDEChannel[((DWORD)(hDisk) & 0xFF00)>>8].pDevice[(DWORD)(hDisk) & 0xFF];
	else
		return NULL;
}
#define ADAPTER_FROM_ID(hDisk) (((DWORD)(hDisk) & 0x00FF0000)>>16)
#define BUS_FROM_ID(hDisk) (((DWORD)(hDisk) & 0xFF00)>>8)
#define DEVID_FROM_ID(hDisk) ((DWORD)(hDisk) & 0xFF)

static const St_DiskPhysicalId VIRTUAL_DISK_ID = { -1, -1, -1, -1 };

static void GetPhysicalId(PDevice pDev, St_DiskPhysicalId * pId )
{
	int iAdapter, iChan, iDev;
	for (iAdapter=0; iAdapter<num_adapters; iAdapter++)
		for (iChan=0; iChan<2; iChan++)
			for (iDev=0; iDev<2; iDev++)
				if (hpt_adapters[iAdapter]->IDEChannel[iChan].pDevice[iDev] == pDev) {
					/*
					 * gmm: this should be corrected to (adapter/bus/id/lun)
					 * but the GUI should also be modified
					 */
					pId->iPathId = 0;
					pId->iAdapterId = iChan;
					pId->iTargetId = iDev;
					pId->iLunId = 0;
					return;
				}
	*pId = VIRTUAL_DISK_ID;
}

HDISK Device_GetHandle( PDevice pDevice )
{
    return MAKE_DEVICE_ID(pDevice);
}

static void SwapCopy(LPSTR sz, const char vec[], unsigned n)
{
    unsigned i;
    for(i = 0; i < n/( sizeof(unsigned short)/sizeof(char) ); ) {
        sz[i] = vec[i+1];
        sz[i+1] = vec[i];
        i ++; i ++;
    }
}

BOOL Device_GetInfo( HDISK hDeviceNode, St_DiskStatus * pInfo )
{
	int iName=0;	//added by wx 12/26/00

    memset(pInfo, 0, sizeof(*pInfo));
	pInfo->hParentArray = INVALID_HANDLE_VALUE;

	if (IS_DEVICE_ID(hDeviceNode)) {
		PDevice pDev = DEVICE_FROM_ID(hDeviceNode);
		int nDeviceMode;

        pInfo->iWorkingStatus = (pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)? 
			enDiskStatus_Disabled : enDiskStatus_Working;
        pInfo->stLastError.nErrorNumber = pDev->stErrorLog.nLastError;
        memcpy(pInfo->stLastError.aryCdb, pDev->stErrorLog.Cdb, 16);
		GetPhysicalId(pDev, &pInfo->PhysicalId);

		nDeviceMode = pDev->DeviceModeSetting;
            
		pInfo->bestPIO = pDev->bestPIO;
		pInfo->bestDMA = pDev->bestDMA;
		pInfo->bestUDMA = pDev->bestUDMA;

        if( pDev->DeviceFlags & DFLAGS_HARDDISK )
            pInfo->iDiskType = enDA_Physical;
        else if(pDev->DeviceFlags & DFLAGS_CDROM_DEVICE)
            pInfo->iDiskType = enDA_CDROM;
		else if(pDev->DeviceFlags &DFLAGS_ATAPI)
			pInfo->iDiskType = enDA_TAPE;
		else 
			pInfo->iDiskType = enDA_NonDisk;
            
        SwapCopy( pInfo->szModelName, (const char *)pDev->IdentifyData.ModelNumber, 
            sizeof(pDev->IdentifyData.ModelNumber) );
            
        pInfo->uTotalBlocks = pDev->capacity;
            
        if( pDev->pArray && !(pDev->DeviceFlags2 & DFLAGS_NEW_ADDED))
        {
            PVirtualDevice pDevArray = pDev->pArray;
			switch (pDevArray->arrayType) {
			case VD_RAID_01_2STRIPE:
				pInfo->hParentArray = MAKE_CHILD_ARRAY_ID(pDevArray, 1);
				break;
			case VD_RAID01_MIRROR:
				pInfo->hParentArray = MAKE_CHILD_ARRAY_ID(pDevArray, 2);
				break;
			case VD_RAID_01_1STRIPE:
				if (pDev->ArrayNum==MIRROR_DISK)
					pInfo->hParentArray = MAKE_COMPOSED_ARRAY_ID(pDevArray);
				else
					pInfo->hParentArray = MAKE_CHILD_ARRAY_ID(pDevArray, 1);
				break;
			case VD_RAID_10_SOURCE:
			case VD_RAID_10_MIRROR:
				pInfo->hParentArray = MAKE_CHILD_ARRAY_ID(pDevArray, pDev->ArrayNum+1);
				break;
			default:
				pInfo->hParentArray = MAKE_ARRAY_ID(pDevArray);
				break;
			}
            if( pDevArray->arrayType == VD_RAID_1_MIRROR &&
                pDevArray->pDevice[SPARE_DISK] == pDev)
            {
                pInfo->isSpare = TRUE;
            }
        }
            
        if( nDeviceMode < 5 )
        {
            pInfo->nTransferMode = 0;
            pInfo->nTransferSubMode = nDeviceMode;
        }
        else if( nDeviceMode < 8 )
        {
            pInfo->nTransferMode = 1;
            pInfo->nTransferSubMode = nDeviceMode - 5;
        }
        else
        {
            pInfo->nTransferMode = 2;
            pInfo->nTransferSubMode = nDeviceMode - 8;
        }
        
        pInfo->isBootable = FALSE;
	}
	else if (IS_ARRAY_ID(hDeviceNode)) {
		PVirtualDevice pArray = ARRAY_FROM_ID(hDeviceNode);
		int iChildArray = CHILDNUM_FROM_ID(hDeviceNode);

		// in case when 0+1 source/mirror swapped 
		if (IS_COMPOSED_ARRAY(hDeviceNode) && pArray->arrayType==VD_RAID01_MIRROR)
			pArray = pArray->pDevice[MIRROR_DISK]->pArray;

		/*
		 * set working status 
		 */
		switch(pArray->arrayType){
		case VD_RAID_01_2STRIPE:
			if (!IS_COMPOSED_ARRAY(hDeviceNode))
				goto default_status;
			else {
				// check both source RAID0 and mirror RAID0
				PVirtualDevice pMirror=NULL;
				PDevice pMirrorDev = pArray->pDevice[MIRROR_DISK];
				if (pMirrorDev)	pMirror = pMirrorDev->pArray;
				if (!pMirror){
					if (pArray->RaidFlags & RAID_FLAGS_DISABLED)
						pInfo->iWorkingStatus = enDiskStatus_Disabled;
					else
						pInfo->iWorkingStatus = enDiskStatus_WorkingWithError;
				}
				else if ((pArray->RaidFlags & RAID_FLAGS_DISABLED || pArray->BrokenFlag) &&
					(pMirror->RaidFlags & RAID_FLAGS_DISABLED || pMirror->BrokenFlag))
					pInfo->iWorkingStatus = enDiskStatus_Disabled;
				else if (pArray->BrokenFlag || pMirror->BrokenFlag)
					pInfo->iWorkingStatus = enDiskStatus_WorkingWithError;
				else if (pArray->RaidFlags & RAID_FLAGS_BEING_BUILT)
					pInfo->iWorkingStatus = enDiskStatus_BeingBuilt;
				else if (pArray->RaidFlags & RAID_FLAGS_NEED_REBUILD)
					pInfo->iWorkingStatus = enDiskStatus_NeedBuilding;
				else
					pInfo->iWorkingStatus = enDiskStatus_Working;
			}
			break;
		case VD_RAID_01_1STRIPE:
			if (!IS_COMPOSED_ARRAY(hDeviceNode))
				goto default_status;
			// VD_RAID_01_1STRIPE same as VD_RAID_1_MIRROR
		case VD_RAID_1_MIRROR:
			if (pArray->RaidFlags & RAID_FLAGS_DISABLED)
				pInfo->iWorkingStatus = enDiskStatus_Disabled;
			else if (pArray->BrokenFlag)
				pInfo->iWorkingStatus = enDiskStatus_WorkingWithError;
			else if (pArray->RaidFlags & RAID_FLAGS_BEING_BUILT)
				pInfo->iWorkingStatus = enDiskStatus_BeingBuilt;
			else if (pArray->RaidFlags & RAID_FLAGS_NEED_REBUILD)
				pInfo->iWorkingStatus = enDiskStatus_NeedBuilding;
			else
				pInfo->iWorkingStatus = enDiskStatus_Working;
			break;
		case VD_RAID_10_SOURCE:
			if (IS_COMPOSED_ARRAY(hDeviceNode)) {
				if (pArray->pRAID10Mirror->BrokenFlag && !pArray->BrokenFlag) {
					pInfo->iWorkingStatus = enDiskStatus_WorkingWithError;
					break;
				}
			}
			// flow down
		case VD_RAID_10_MIRROR:
			if (IS_COMPOSED_ARRAY(hDeviceNode))
				goto default_status;
			else
			{
				PDevice pDev1, pDev2;
				pDev1 = pArray->pDevice[iChildArray-1];
				pDev2 = pArray->pRAID10Mirror->pDevice[iChildArray-1];
				if ((!pDev1 || (pDev1->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)) &&
					(!pDev2 || (pDev2->DeviceFlags2 & DFLAGS_DEVICE_DISABLED))) {
					pInfo->iWorkingStatus = enDiskStatus_Disabled;
				}
				else if ((!pDev1 || (pDev1->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)) ||
					(!pDev2 || (pDev2->DeviceFlags2 & DFLAGS_DEVICE_DISABLED))) {
					pInfo->iWorkingStatus = enDiskStatus_WorkingWithError;
				}
				else if (pDev1->DeviceFlags2 & DFLAGS_BEING_BUILT ||
						pDev2->DeviceFlags2 & DFLAGS_BEING_BUILT)
					pInfo->iWorkingStatus = enDiskStatus_BeingBuilt;
				else if (pDev1->DeviceFlags2 & DFLAGS_NEED_REBUILD ||
						pDev2->DeviceFlags2 & DFLAGS_NEED_REBUILD)
					pInfo->iWorkingStatus = enDiskStatus_NeedBuilding;
				else
					pInfo->iWorkingStatus = enDiskStatus_Working;
			}
			break;
		default:
default_status:
			if (pArray->BrokenFlag || pArray->RaidFlags & RAID_FLAGS_DISABLED)
				pInfo->iWorkingStatus = enDiskStatus_Disabled;
			else
				pInfo->iWorkingStatus = enDiskStatus_Working;
			break;
		}
		
		if (pArray->pDevice[0])
			GetPhysicalId(pArray->pDevice[0], &pInfo->PhysicalId );
		else if (pArray->pDevice[MIRROR_DISK])
			GetPhysicalId(pArray->pDevice[MIRROR_DISK], &pInfo->PhysicalId );
		else
			pInfo->PhysicalId = VIRTUAL_DISK_ID;

        for(iName=0; iName<sizeof(pInfo->ArrayName); iName++)		//added by wx 12/26/00
        	pInfo->ArrayName[iName] = pArray->ArrayName[iName];

		if (iChildArray && !IS_COMPOSED_ARRAY(hDeviceNode)) {
			if (pArray->arrayType==VD_RAID01_MIRROR)
				pInfo->hParentArray = MAKE_COMPOSED_ARRAY_ID(pArray->pDevice[MIRROR_DISK]->pArray);
			else if (pArray->arrayType==VD_RAID_10_MIRROR)
				pInfo->hParentArray = MAKE_COMPOSED_ARRAY_ID(pArray->pRAID10Mirror);
			else
				pInfo->hParentArray = MAKE_COMPOSED_ARRAY_ID(pArray);
		}
        
       	pInfo->iRawArrayType = pArray->arrayType;
        switch( pArray->arrayType )
        {
            case VD_RAID_0_STRIPE:
                pInfo->iDiskType = enDA_Stripping;
		        pInfo->uTotalBlocks = pArray->capacity;
				pInfo->nStripSize = 1<<pArray->BlockSizeShift;
                break;
            case VD_RAID_01_1STRIPE:
				if (!IS_COMPOSED_ARRAY(hDeviceNode)) {
					DWORD capacity = 0x7FFFFFFF;
					int i;
					for (i=0; i<SPARE_DISK; i++) {
						if (pArray->pDevice[i] && capacity>pArray->pDevice[i]->capacity)
							capacity = pArray->pDevice[i]->capacity;
					}
					pInfo->iDiskType = enDA_Stripping;
					pInfo->nStripSize = 1<<pArray->BlockSizeShift;
			        pInfo->uTotalBlocks = capacity * pArray->nDisk;
				}
				else {
					pInfo->iDiskType = enDA_Mirror;
			        pInfo->uTotalBlocks = pArray->capacity;
				}
				break;
			case VD_RAID01_MIRROR:
				pInfo->iDiskType = enDA_Stripping;
			    pInfo->uTotalBlocks = pArray->capacity;
				pInfo->nStripSize = 1<<pArray->BlockSizeShift;
				break;
            case VD_RAID_01_2STRIPE:
				if (!IS_COMPOSED_ARRAY(hDeviceNode)) {
					pInfo->iDiskType = enDA_Stripping;
			        pInfo->uTotalBlocks = pArray->capacity;
					pInfo->nStripSize = 1<<pArray->BlockSizeShift;
					break;
				}
				// else same as VD_RAID10_MIRROR
            case VD_RAID_1_MIRROR:
				pInfo->iDiskType = enDA_Mirror;
		        pInfo->uTotalBlocks = pArray->capacity;
				pInfo->isSpare = (pArray->pDevice[SPARE_DISK]!=NULL);
                break;
			case VD_RAID_10_SOURCE:
			case VD_RAID_10_MIRROR:
				if (iChildArray) {
					DWORD capacity =0;
					if (pArray->pDevice[iChildArray-1])
						capacity = pArray->pDevice[iChildArray-1]->capacity;
					if (pArray->pRAID10Mirror->pDevice[iChildArray-1])
						if (capacity>pArray->pRAID10Mirror->pDevice[iChildArray-1]->capacity)
							capacity = pArray->pRAID10Mirror->pDevice[iChildArray-1]->capacity;
					pInfo->iDiskType = enDA_Mirror;
			        pInfo->uTotalBlocks = capacity;
				}
				else {
					pInfo->iDiskType = enDA_Stripping;
			        pInfo->uTotalBlocks = pArray->capacity;
				}
				pInfo->nStripSize = 1<<pArray->BlockSizeShift;
				break;
            case VD_SPAN:
                pInfo->iDiskType = enDA_Span;
		        pInfo->uTotalBlocks = pArray->capacity;
                break;
            case VD_RAID_3:
                pInfo->iDiskType = enDA_RAID3;
		        pInfo->uTotalBlocks = pArray->capacity;
                break;
            case VD_RAID_5:
                pInfo->iDiskType = enDA_RAID5;
		        pInfo->uTotalBlocks = pArray->capacity;
                break;
            default:
                pInfo->iDiskType = enDA_Unknown;
        }

		pInfo->dwArrayStamp = pArray->Stamp;
		if (pArray->arrayType==VD_RAID_10_SOURCE && !IS_COMPOSED_ARRAY(hDeviceNode))
			pInfo->iArrayNum = CHILDNUM_FROM_ID(hDeviceNode);
		else
			pInfo->iArrayNum = GET_ARRAY_NUM(pArray);
		pInfo->isBootable = (pArray->RaidFlags & RAID_FLAGS_BOOTDISK)!=0;
    }
	else
        return FALSE;
    return TRUE;
}

BOOL Device_GetChild( HDISK hParentNode, HDISK * pChildNode )
{
	PVirtualDevice pArray;
    if( hParentNode == HROOT_DEVICE )
    {
		int iAdapter, iChan, iDev;
		for (pArray=VirtualDevices; pArray<pLastVD; pArray++) {
			if (pArray->arrayType!=VD_INVALID_TYPE &&
				pArray->arrayType!=VD_RAID01_MIRROR &&
				pArray->arrayType!=VD_RAID_10_MIRROR) {
				switch(pArray->arrayType){
				case VD_RAID_01_1STRIPE:
				case VD_RAID_01_2STRIPE:
				case VD_RAID_10_SOURCE:
					*pChildNode = MAKE_COMPOSED_ARRAY_ID(pArray);
					break;
				default:
					*pChildNode = MAKE_ARRAY_ID(pArray);
					break;
				}
				return TRUE;
			}
		}
		for (iAdapter=0; iAdapter<num_adapters; iAdapter++)
			for (iChan=0; iChan<2; iChan++)
				for (iDev=0; iDev<2; iDev++)
					if (hpt_adapters[iAdapter]->IDEChannel[iChan].pDevice[iDev]) {
						*pChildNode = (HDISK)(0xC0000000 | iAdapter<<16 | iChan<<8 | iDev);
						return TRUE;
					}
		return FALSE;
    }
    else if (IS_ARRAY_ID(hParentNode)) {
		int i;
		pArray = ARRAY_FROM_ID(hParentNode);
		// in case when 0+1 source/mirror swapped 
		if (IS_COMPOSED_ARRAY(hParentNode) && pArray->arrayType==VD_RAID01_MIRROR)
			pArray = pArray->pDevice[MIRROR_DISK]->pArray;
		switch(pArray->arrayType) {
		case VD_RAID_01_1STRIPE:
			if (IS_COMPOSED_ARRAY(hParentNode)) {
				for (i=0; i<SPARE_DISK; i++) {
					if (pArray->pDevice[i]) {
						*pChildNode = MAKE_CHILD_ARRAY_ID(pArray, 1);
						return TRUE;
					}
				}
				if (pArray->pDevice[MIRROR_DISK]) {
					*pChildNode = MAKE_DEVICE_ID(pArray->pDevice[MIRROR_DISK]);
					return TRUE;
				}
				return FALSE;
			} else {
				for (i=0; i<SPARE_DISK; i++) {
					if (pArray->pDevice[i] &&
						!(pArray->pDevice[i]->DeviceFlags2 & DFLAGS_NEW_ADDED)) {
						*pChildNode = MAKE_DEVICE_ID(pArray->pDevice[i]);
						return TRUE;
					}
				}
			}
			return FALSE;
		case VD_RAID_01_2STRIPE:
			if (IS_COMPOSED_ARRAY(hParentNode)) {
				for (i=0; i<SPARE_DISK; i++) {
					if (pArray->pDevice[i]) {
						*pChildNode = MAKE_CHILD_ARRAY_ID(pArray, 1);
						return TRUE;
					}
				}
				if (pArray->pDevice[MIRROR_DISK]) {
					*pChildNode = MAKE_ARRAY_ID(pArray->pDevice[MIRROR_DISK]->pArray);
					return TRUE;
				}
			}
			else
			{
				if (CHILDNUM_FROM_ID(hParentNode)==2) 
					if (pArray->pDevice[MIRROR_DISK])
						pArray = pArray->pDevice[MIRROR_DISK]->pArray;
					else
						pArray=NULL;
				if (pArray) {
					for (i=0; i<SPARE_DISK; i++) {
						if (pArray->pDevice[i] && 
							!(pArray->pDevice[i]->DeviceFlags2 & DFLAGS_NEW_ADDED)) {
							*pChildNode = MAKE_DEVICE_ID(pArray->pDevice[i]);
							return TRUE;
						}
					}
				}
			}
			return FALSE;
		case VD_RAID_10_SOURCE:
			if (IS_COMPOSED_ARRAY(hParentNode)) {
				for (i=0; i<pArray->nDisk; i++) {
					if (pArray->pDevice[i]) {
						*pChildNode = MAKE_CHILD_ARRAY_ID(pArray, i+1);
						return TRUE;
					}
				}
				return FALSE;
			}
			else {
				i = CHILDNUM_FROM_ID(hParentNode)-1;
				if (pArray->pDevice[i]) {
					*pChildNode = MAKE_DEVICE_ID(pArray->pDevice[i]);
					return TRUE;
				}
				else if (pArray->pRAID10Mirror->pDevice[i]) {
					*pChildNode = MAKE_DEVICE_ID(pArray->pRAID10Mirror->pDevice[i]);
					return TRUE;
				}
				return FALSE;
			}
			return FALSE;
		default:
			for (i=0; i<MAX_MEMBERS; i++) {
				if (pArray->pDevice[i]) {
					*pChildNode = MAKE_DEVICE_ID(pArray->pDevice[i]);
					return TRUE;
				}
			}
        }
    }
    return FALSE;
}

BOOL Device_GetSibling( HDISK hNode, HDISK * pSilbingNode )
{
	PVirtualDevice pArray;
	PDevice pDev;
	int iAdapter, iChan, iDev;
    if( IS_ARRAY_ID(hNode))
    {
		int iChild;
		pArray = ARRAY_FROM_ID(hNode);
		iChild = CHILDNUM_FROM_ID(hNode);
		if (iChild==0) {
			// root level siblings
			pArray++;
			for (; pArray<pLastVD; pArray++) {
				if (pArray->arrayType!=VD_INVALID_TYPE &&
					pArray->arrayType!=VD_RAID01_MIRROR &&
					pArray->arrayType!=VD_RAID_10_MIRROR) {
					switch(pArray->arrayType){
					case VD_RAID_01_1STRIPE:
					case VD_RAID_01_2STRIPE:
					case VD_RAID_10_SOURCE:
						*pSilbingNode = MAKE_COMPOSED_ARRAY_ID(pArray);
						break;
					default:
						*pSilbingNode = MAKE_ARRAY_ID(pArray);
						break;
					}
					return TRUE;
				}
			}
			for (iAdapter=0; iAdapter<num_adapters; iAdapter++) {
				for( iChan= 0; iChan< 2; iChan++ ){
					for( iDev= 0; iDev< 2; iDev++ )	{
						if( pDev=hpt_adapters[iAdapter]->IDEChannel[iChan].pDevice[iDev]) {
							if (!pDev->pArray || (pDev->DeviceFlags2 & DFLAGS_NEW_ADDED)){
								*pSilbingNode = MAKE_DEVICE_ID(pDev);
								return TRUE;
							}
						}
					}
				}
			}
		}
		else {
			switch(pArray->arrayType){
			case VD_RAID_01_1STRIPE:
				if (iChild==1) {
					if (pArray->pDevice[MIRROR_DISK]) {
						*pSilbingNode = MAKE_DEVICE_ID(pArray->pDevice[MIRROR_DISK]);
						return TRUE;
					}
				}
				break;
			case VD_RAID_01_2STRIPE:
				if (iChild==1) {
					if (pArray->pDevice[MIRROR_DISK]) {
						*pSilbingNode = MAKE_CHILD_ARRAY_ID(pArray->pDevice[MIRROR_DISK]->pArray, 2);
						return TRUE;
					}
				}
				break;
			case VD_RAID_10_MIRROR:
				break;				
			case VD_RAID_10_SOURCE:
				if (iChild<pArray->nDisk) {
					int i;
					for (i=iChild; i<pArray->nDisk; i++)
					{
						if (pArray->pDevice[i]) {
							*pSilbingNode = MAKE_CHILD_ARRAY_ID(pArray, i+1);
						}
						return TRUE;
					}
				}
				break;
			}
		}
		return FALSE;
    }
    else if (IS_DEVICE_ID(hNode)) {
		pDev = DEVICE_FROM_ID(hNode);
		if ((pArray=pDev->pArray) && !(pDev->DeviceFlags2 & DFLAGS_NEW_ADDED)) {
			switch(pArray->arrayType) {
			case VD_RAID_1_MIRROR:
				if (pDev==pArray->pDevice[0]) {
					if (pArray->pDevice[MIRROR_DISK]) {
						*pSilbingNode = MAKE_DEVICE_ID(pArray->pDevice[MIRROR_DISK]);
						return TRUE;
					}else if (pArray->pDevice[SPARE_DISK]) {
						*pSilbingNode = MAKE_DEVICE_ID(pArray->pDevice[SPARE_DISK]);
						return TRUE;
					}
				}
				else if (pDev==pArray->pDevice[MIRROR_DISK]) {
					if (pArray->pDevice[SPARE_DISK]) {
						*pSilbingNode = MAKE_DEVICE_ID(pArray->pDevice[SPARE_DISK]);
						return TRUE;
					}
				}
				break;
			case VD_RAID_10_MIRROR:
				break;				
			case VD_RAID_10_SOURCE:
				if (pArray->pRAID10Mirror->pDevice[pDev->ArrayNum]) {
					*pSilbingNode = MAKE_DEVICE_ID(pArray->pRAID10Mirror->pDevice[pDev->ArrayNum]);
					return TRUE;
				}
				break;
			case VD_RAID_01_1STRIPE:
			case VD_RAID_01_2STRIPE:
			case VD_RAID01_MIRROR:
			default:
				for (iDev=pDev->ArrayNum+1; iDev<SPARE_DISK; iDev++)
					if (pArray->pDevice[iDev] &&
						!(pArray->pDevice[iDev]->DeviceFlags2 & DFLAGS_NEW_ADDED)) {
						*pSilbingNode = MAKE_DEVICE_ID(pArray->pDevice[iDev]);
						return TRUE;
					}
				break;
			}
		}
		else{
			iAdapter = ADAPTER_FROM_ID(hNode);
			iChan = BUS_FROM_ID(hNode);
			iDev = DEVID_FROM_ID(hNode);
			iDev++;
			if (iDev>1) { iDev=0; iChan++; }
			if (iChan>1) { iAdapter++; iChan=0; }
			for (; iAdapter<num_adapters; iAdapter++) {
				for (; iChan<2; iChan++) {
					for (; iDev<2; iDev++) {
						if (pDev=hpt_adapters[iAdapter]->IDEChannel[iChan].pDevice[iDev]) {
							if (!pDev->pArray || (pDev->DeviceFlags2 & DFLAGS_NEW_ADDED)) {
								*pSilbingNode = MAKE_DEVICE_ID(pDev);
								return TRUE;
							}
						}
					}
					iDev=0;
				}
				iChan=0;
			}
		}
    }
    return FALSE;
}

int RAIDController_GetNum()
{
    return num_adapters;
}

BOOL RAIDController_GetInfo( int iController, St_StorageControllerInfo* pInfo )
{
    int iChannel;
    
    strcpy( pInfo->szProductID, "HPT370 UDMA/ATA100 RAID Controller" );
    strcpy( pInfo->szVendorID, "HighPoint Technologies, Inc" );
    pInfo->uBuses = 2;
    pInfo->iInterruptRequest = hpt_adapters[iController]->IDEChannel[0].InterruptLevel;
    
    for( iChannel = 0; iChannel < 2; iChannel ++ )
    {
        int iDevice;
        St_IoBusInfo * pBusInfo = &pInfo->vecBuses[iChannel];
        
        pBusInfo->uDevices = 0;
        
        for( iDevice = 0; iDevice < 2; iDevice ++ )
        {
            PDevice pDevice = hpt_adapters[iController]->IDEChannel[iChannel].pDevice[iDevice];
            
            if( pDevice )
            {
                pBusInfo->vecDevices[pBusInfo->uDevices] = Device_GetHandle( pDevice );
                pBusInfo->uDevices ++;
            }
        }
    }
    
    return TRUE;
}

HDISK Device_CreateMirror( HDISK * pDisks, int nDisks )
{
	PDevice pDevice0, pDevice1;
	PVirtualDevice pArray=NULL, pArray0, pArray1;
	if (nDisks<2) return INVALID_HANDLE_VALUE;

	pDevice0 = IS_DEVICE_ID(pDisks[0])? DEVICE_FROM_ID(pDisks[0]) : NULL;
	pDevice1 = IS_DEVICE_ID(pDisks[1])? DEVICE_FROM_ID(pDisks[1]) : NULL;
	pArray0 = IS_ARRAY_ID(pDisks[0])? ARRAY_FROM_ID(pDisks[0]) : NULL;
	pArray1 = IS_ARRAY_ID(pDisks[1])? ARRAY_FROM_ID(pDisks[1]) : NULL;

	if (pDevice0) pDevice0->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
	if (pDevice1) pDevice1->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;

    if( pDevice0 && pDevice1)
	{   //  mirror two physical disks
        pArray = Array_alloc();
        
        pArray->nDisk = 1;
        pArray->arrayType = VD_RAID_1_MIRROR;
		pArray->BlockSizeShift = 7;
        pArray->pDevice[0] = pDevice0;
        pDevice0->ArrayNum = 0;
		pDevice0->ArrayMask = (1 << 0);
		pDevice0->pArray = pArray;
		pDevice0->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
		if (pDevice0->HidenLBA>0) {
			pDevice0->HidenLBA=0;
			pDevice0->capacity += (RECODR_LBA + 1);
		}

		pArray->pDevice[MIRROR_DISK] = pDevice1;
		pDevice1->ArrayNum = MIRROR_DISK;
		pDevice1->ArrayMask = (1 << MIRROR_DISK);
		pDevice1->pArray = pArray;
            
        if (nDisks > 2 && IS_DEVICE_ID(pDisks[2]))
        {   //  a spare disk has been specified
            pArray->pDevice[SPARE_DISK] = DEVICE_FROM_ID(pDisks[2]);
			pArray->pDevice[SPARE_DISK]->ArrayNum = SPARE_DISK;
			pArray->pDevice[SPARE_DISK]->ArrayMask = (1 << SPARE_DISK);
			pArray->pDevice[SPARE_DISK]->pArray = pArray;
        }
            
        pDevice1->DeviceFlags |= DFLAGS_HIDEN_DISK;
		if (pDevice1->HidenLBA>0) {
			pDevice1->HidenLBA=0;
			pDevice1->capacity += (RECODR_LBA + 1);
		}
        if (pArray->pDevice[SPARE_DISK]) {
            pArray->pDevice[SPARE_DISK]->DeviceFlags |= DFLAGS_HIDEN_DISK;
        }
		pArray->capacity = (pDevice0->capacity > pDevice1->capacity)? 
			pDevice1->capacity : pDevice0->capacity;
	}
    else if( pArray0 && pArray1 && 
        pArray0->arrayType == VD_RAID_0_STRIPE &&
        pArray1->arrayType == VD_RAID_0_STRIPE )
    {   //  mirror two striped arrays
        pArray = pArray0;
        pArray0->arrayType = VD_RAID_01_2STRIPE;
        pArray0->pDevice[MIRROR_DISK] = pArray1->pDevice[0];
        pArray1->arrayType = VD_RAID01_MIRROR;
        pArray1->pDevice[MIRROR_DISK] = pArray0->pDevice[0];
        pArray1->pDevice[0]->DeviceFlags |= DFLAGS_HIDEN_DISK;
		if (pArray0->capacity > pArray1->capacity) pArray->capacity=pArray1->capacity;
    }
    else if( pArray0 && pDevice1 && pArray0->arrayType == VD_RAID_0_STRIPE )
    {   //  0+1 Array, the first one is a stripe, second one is a physcial disk
        pArray = pArray0;
        pArray->arrayType = VD_RAID_01_1STRIPE;
        pArray->pDevice[MIRROR_DISK] = pDevice1;
		pDevice1->ArrayNum = MIRROR_DISK;
		pDevice1->ArrayMask = (1 << MIRROR_DISK);
		pDevice1->pArray = pArray;
        pDevice1->DeviceFlags |= DFLAGS_HIDEN_DISK;
		if (pDevice1->HidenLBA>0) {
			pDevice1->HidenLBA=0;
			pDevice1->capacity += (RECODR_LBA + 1);
		}
    }
    else if( pDevice0 && pArray1 && pArray1->arrayType == VD_RAID_0_STRIPE )
    {   //  0+1 Array, the first one is a physcial disk, second one is a stripe
		// DO NOT HIDE THE SINGLE DISK SINCE IT IS A SOURCE DISK
		int i;
        pArray = pArray1;
		for (i=0; i<pArray->nDisk; i++) {
			if (pArray->pDevice[i])
				pArray->pDevice[i]->DeviceFlags |= DFLAGS_HIDEN_DISK;
		}
        pArray->arrayType = VD_RAID_01_1STRIPE;
		pArray->RaidFlags |= RAID_FLAGS_INVERSE_MIRROR_ORDER;
        pArray->pDevice[MIRROR_DISK] = pDevice0;
		pDevice0->ArrayNum = MIRROR_DISK;
		pDevice0->ArrayMask = (1 << MIRROR_DISK);
		pDevice0->pArray = pArray;
		pArray->capacity = pDevice0->capacity;
    }
    else
    {   //  Not support yet
        return INVALID_HANDLE_VALUE;
    }
   
	pArray->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
	if (pArray->arrayType==VD_RAID_1_MIRROR)
		return MAKE_ARRAY_ID(pArray);
	else
		return MAKE_COMPOSED_ARRAY_ID(pArray);
}

static HDISK CreateMultiDiskArray(
    int iArrayType,
    HDISK * pDisks, int nDisks, 
    int nStripSizeShift )
{    
    PVirtualDevice pArray;
    int i;
	DWORD capacity=0x7FFFFFFF;
    for( i = 0; i < nDisks; i ++ )
        if( (!IS_DEVICE_ID(pDisks[i])) || DEVICE_FROM_ID(pDisks[i])->pArray)
			return INVALID_HANDLE_VALUE;

	pArray = Array_alloc();
        
    pArray->nDisk = (BYTE)nDisks;
    pArray->arrayType = (BYTE)iArrayType;
    pArray->BlockSizeShift = (BYTE)nStripSizeShift;
	// DO NOT FORTET TO SET THIS:
	pArray->ArrayNumBlock = 1<<(BYTE)nStripSizeShift;
        
    for( i = 0; i < nDisks; i ++ )
    {
		PDevice pDev;
		pDev = DEVICE_FROM_ID(pDisks[i]);
        pArray->pDevice[i] = pDev;
		/* 
		 * important to set pDev attributes.
		 */
		pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
		pDev->pArray = pArray;
		pDev->ArrayMask = 1<<i;
		pDev->ArrayNum = (UCHAR)i;
		ZeroMemory(&pDev->stErrorLog, sizeof(pDev->stErrorLog));
		if (i>0) {
			pDev->DeviceFlags |= DFLAGS_HIDEN_DISK;
			if (pDev->HidenLBA==0) {
				pDev->HidenLBA = (RECODR_LBA + 1);
				pDev->capacity -= (RECODR_LBA + 1);
			}
		}
		else {
			if (pDev->HidenLBA>0) {
				pDev->HidenLBA = 0;
				pDev->capacity += (RECODR_LBA + 1);
			}
		}
    }
    
    /*
     * calc capacity.
     */
	if (iArrayType==VD_SPAN) {
		pArray->capacity=0;
		for (i=0; i<nDisks; i++) pArray->capacity+=pArray->pDevice[i]->capacity;
	}
	else if (iArrayType==VD_RAID_0_STRIPE) {
		for (i=0; i<nDisks; i++) 
			if (capacity>pArray->pDevice[i]->capacity) 
				capacity = pArray->pDevice[i]->capacity;
		pArray->capacity = capacity*nDisks;
	}
    return MAKE_ARRAY_ID(pArray);
}

HDISK Device_CreateStriping( HDISK *pDisks, int nDisks, int nStripSizeShift )
{
    return CreateMultiDiskArray( VD_RAID_0_STRIPE, pDisks, nDisks, nStripSizeShift );
}

HDISK Device_CreateSpan( HDISK * pDisks, int nDisks )
{
    return CreateMultiDiskArray( VD_SPAN, pDisks, nDisks, 7 );
}

BOOL Device_Remove( HDISK hDisk )
{
	PVirtualDevice pArray;

    if(!IS_ARRAY_ID( hDisk )) return FALSE;
	if (CHILDNUM_FROM_ID(hDisk)) return FALSE;
	pArray = ARRAY_FROM_ID(hDisk);

	/*+
	 * gmm: it's safe to call DeleteArray on a mirror.
	 */
	switch (pArray->arrayType) {
	case VD_RAID_1_MIRROR:
		DeleteArray(pArray);
		Array_free(pArray);
		return TRUE;
	case VD_RAID_01_1STRIPE:
	case VD_RAID_01_2STRIPE:
	case VD_RAID01_MIRROR:
		DeleteArray(pArray);
		return TRUE;

	case VD_RAID_10_SOURCE:
		DeleteRAID10(pArray);
		return TRUE;

	case VD_RAID_10_MIRROR:
		return FALSE;

	default:
		/*
		 * gmm: Although it's unsafe to delete a stripe array,
		 * we delete it, give the responsibility of keeping data
		 * safe to the user. Otherwise the GUI can't keep consistent
		 * with driver and system must reboot.
		 */
		DeleteArray(pArray);
		Array_free(pArray);
		return TRUE;
	}
    return FALSE;
}

BOOL Device_BeginRebuildingMirror( HDISK hMirror )
{
    if( IS_ARRAY_ID( hMirror ) )
    {
		PVirtualDevice pArray = ARRAY_FROM_ID(hMirror);
		// in case when 0+1 source/mirror swapped 
		if (IS_COMPOSED_ARRAY(hMirror) && pArray->arrayType==VD_RAID01_MIRROR)
			pArray = pArray->pDevice[MIRROR_DISK]->pArray;

		if (!(pArray->RaidFlags & RAID_FLAGS_DISABLED)) {
			if (pArray->arrayType==VD_RAID_10_SOURCE) {
				int iChild = CHILDNUM_FROM_ID(hMirror);
				PDevice pDev;
				if (iChild==0) return FALSE;
				pDev = pArray->pDevice[iChild-1];
				pDev->DeviceFlags2 |= DFLAGS_BEING_BUILT;
			}
			else {
	            pArray->RaidFlags |= RAID_FLAGS_BEING_BUILT;
			}
            return TRUE;
        }
    }
    return FALSE;
}

BOOL Device_AbortMirrorBuilding( HDISK hMirror )
{
    if( IS_ARRAY_ID( hMirror ) )
    {
		PVirtualDevice pArray = ARRAY_FROM_ID(hMirror);
		if (pArray->arrayType==VD_RAID_10_SOURCE) {
			int iChild = CHILDNUM_FROM_ID(hMirror);
			PDevice pDev;
			if (iChild==0) return FALSE;
			pDev = pArray->pDevice[iChild-1];
			pDev->DeviceFlags2 &= ~DFLAGS_BEING_BUILT;
			pDev = pArray->pRAID10Mirror->pDevice[iChild-1];
			pDev->DeviceFlags2 &= ~DFLAGS_BEING_BUILT;			
		}
		else if (pArray->RaidFlags & RAID_FLAGS_BEING_BUILT) {
	            pArray->RaidFlags &= ~RAID_FLAGS_BEING_BUILT;
		}
        return TRUE;
    }
    return FALSE;
}

BOOL Device_ValidateMirror( HDISK hMirror )
{
    if( IS_ARRAY_ID( hMirror ) )
    {
		PVirtualDevice pArray = ARRAY_FROM_ID(hMirror);
		if (pArray->arrayType==VD_RAID_10_SOURCE) {
			int iChild = CHILDNUM_FROM_ID(hMirror);
			PDevice pDev;
			if (iChild==0) return FALSE;
			pDev = pArray->pDevice[iChild-1];
			pDev->DeviceFlags2 &= ~(DFLAGS_BEING_BUILT | DFLAGS_NEED_REBUILD);
			pDev = pArray->pRAID10Mirror->pDevice[iChild-1];
			pDev->DeviceFlags2 &= ~(DFLAGS_BEING_BUILT | DFLAGS_NEED_REBUILD);			
		}
		else
			pArray->RaidFlags &= ~(RAID_FLAGS_BEING_BUILT | RAID_FLAGS_NEED_REBUILD);
		return TRUE;
    }
    return FALSE;
}

void Device_ReportFailure( PDevice pDevice )
{
}

//////////////////////////////
//
// Add spare disk to a mirror
BOOL Device_AddSpare( HDISK hMirror, HDISK hDisk)
{
	LOC_ARRAY_BLK;
	PVirtualDevice pArray;
	PDevice pDev;
	
	if (!IS_ARRAY_ID(hMirror) || !IS_DEVICE_ID(hDisk)) return FALSE;

	pArray = ARRAY_FROM_ID(hMirror);
	pDev  = DEVICE_FROM_ID(hDisk);
	// If the array is not Mirror
	if(pArray->arrayType != VD_RAID_1_MIRROR) return FALSE;
	
	if (pDev->pArray) return FALSE;
	// If the capacity of spare disk less than the array
	if(pDev->capacity < pArray->capacity ) return FALSE;

	if(pArray->pDevice[SPARE_DISK])	return FALSE;
	pDev->ArrayNum     = SPARE_DISK;
	pDev->ArrayMask    = (1 << SPARE_DISK);
	pDev->DeviceFlags |= DFLAGS_HIDEN_DISK;
	pDev->pArray       = pArray;
	pArray->pDevice[SPARE_DISK]	 = pDev;

	ReadWrite(pArray->pDevice[0] , RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
	ArrayBlk.DeviceNum = SPARE_DISK;
	ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
	
	return TRUE;
}

// Del spare disk from a mirror
BOOL Device_DelSpare( HDISK hDisk)
{
	LOC_ARRAY_BLK;
	PVirtualDevice pArray;
	PDevice pDev;
	
	if (!IS_DEVICE_ID(hDisk)) return FALSE;

	pDev = DEVICE_FROM_ID(hDisk);
	pArray = pDev->pArray;
	// If the array is not Mirror
	if(!pArray || pArray->arrayType != VD_RAID_1_MIRROR) return FALSE;
	
	if ((pDev!=pArray->pDevice[SPARE_DISK])) return FALSE;
	pDev->ArrayNum     = 0;
	pDev->ArrayMask    = 0;
	pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
	pDev->pArray       = NULL;
	pArray->pDevice[SPARE_DISK]	 = NULL;

	ZeroMemory((char *)&ArrayBlk, 512);
	ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
	
	return TRUE;
}

/*++
 Function:
	Device_AddMirrorDisk
	 
 Description:
	Add a source/mirror disk to a mirror array
 	 
 Argument:
	hMirror - The handle of the mirror array
	hDisk   - The handle of the disk to add

 Return:
	BOOL
++*/
BOOL Device_AddMirrorDisk( HDISK hMirror, HDISK hDisk )
{
	LOC_ARRAY_BLK;
	PVirtualDevice pArray;
	PDevice pDev;
	int nChild,i;	
	
	if (!IS_ARRAY_ID(hMirror) || !IS_DEVICE_ID(hDisk)) return FALSE;

	pArray = ARRAY_FROM_ID(hMirror);
	pDev  = DEVICE_FROM_ID(hDisk);

	if (!pArray || !pDev) return FALSE;

//remark by karl 2001/01/17
/*+
	if(pArray && pArray->arrayType != VD_RAID_1_MIRROR) return FALSE;
-*/
	/* gmm:
	 * We should not hide this new disk since it is a previously failed disk
	 * the OS is still using it as a visible disk for the array.
	 */	 

	if(pArray->arrayType == VD_RAID_1_MIRROR)
	{		
		// if pDev belongs to other array, return
		if (pDev->pArray && pDev->pArray!=pArray) return FALSE;
		// If the capacity of mirror disk is less than the array
		if(pDev->capacity < pArray->capacity ) return FALSE;

		if (pArray->nDisk == 0 && pArray->pDevice[MIRROR_DISK])
		{
			// move mirror to pDevice[0]
#ifdef _BIOS_
			ReadWrite(pArray->pDevice[MIRROR_DISK], RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
			ArrayBlk.nDisks    = 1;
			ArrayBlk.DeviceNum = 0;
			ReadWrite(pArray->pDevice[MIRROR_DISK], RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
			pArray->pDevice[0] = pArray->pDevice[MIRROR_DISK];
			pArray->nDisk = 1;
	
			// add as mirror disk
			pDev->ArrayNum  = MIRROR_DISK;
#ifdef _BIOS_
			ArrayBlk.nDisks    = 1;
			ArrayBlk.DeviceNum = MIRROR_DISK;
// add by karl 2001/01/17
//+
			for(i=0; i<16; i++)
				ArrayBlk.ArrayName[i] = pArray->ArrayName[i];
//-			
			ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
			pArray->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
		}
		else if (!pArray->pDevice[MIRROR_DISK])
		{
			// add as mirror disk
			pDev->ArrayNum  = MIRROR_DISK;
#ifdef _BIOS_
// add by karl 2001/01/17
//+
			for(i=0; i<16; i++)
				ArrayBlk.ArrayName[i] = pArray->ArrayName[i];
//-			
			ReadWrite(pArray->pDevice[0], RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
			ArrayBlk.nDisks    = 1;
			ArrayBlk.DeviceNum = MIRROR_DISK;
			ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
			pArray->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
		}
		else if (!pArray->pDevice[SPARE_DISK])
		{
			// add as spare disk
			pDev->ArrayNum  = SPARE_DISK;
#ifdef _BIOS_
			ReadWrite(pArray->pDevice[0], RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
			ArrayBlk.nDisks    = 1;
			ArrayBlk.DeviceNum = SPARE_DISK;
			ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
		}
		else
			return FALSE;

		pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
		pDev->ArrayMask = (1<<pDev->ArrayNum);
		pDev->pArray = pArray;
		pArray->pDevice[pDev->ArrayNum] = pDev;
		pArray->BrokenFlag = FALSE;		
		return TRUE;
	}
	else if (pArray->arrayType==VD_RAID_01_2STRIPE)
	{
		PVirtualDevice pMirror = NULL;
		int nDisk;
		if (pArray->pDevice[MIRROR_DISK])
			pMirror = pArray->pDevice[MIRROR_DISK]->pArray;
		if (pDev->pArray && pDev->pArray!=pArray && pDev->pArray!=pMirror) return FALSE;
		if (pDev->pArray==pArray ||
			(pDev->pArray==NULL && pArray->BrokenFlag))
		{
			if (!pMirror) return FALSE;
			if (pMirror->BrokenFlag) return FALSE;
			nDisk=0;
			while (pArray->pDevice[nDisk] && (nDisk<SPARE_DISK)) nDisk++;
			if (pDev->ArrayNum && !pDev->HidenLBA) {
				pDev->HidenLBA = (RECODR_LBA + 1);
				pDev->capacity -= (RECODR_LBA + 1);
			}
			if (pDev->capacity * nDisk < pArray->capacity) return FALSE;
			// ok to put it back
			pDev->DeviceFlags |= DFLAGS_ARRAY_DISK;
			pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
			for (i=0; i<nDisk; i++) {
				if (!pArray->pDevice[i] || 
					(pArray->pDevice[i]->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)) {
					return TRUE;
				}
			}
			pArray->BrokenFlag = FALSE;
			pArray->nDisk = (UCHAR)nDisk;
			pArray->RaidFlags &= ~RAID_FLAGS_DISABLED;
			pArray->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
			// swap source/mirror
			pArray->arrayType = VD_RAID01_MIRROR;
			pMirror->arrayType = VD_RAID_01_2STRIPE;
			pMirror->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
			return TRUE;
		}
		else if (pMirror && 
			(pDev->pArray==pMirror || pDev->pArray==NULL) && 
			pMirror->BrokenFlag)
		{
			if (pArray->BrokenFlag) return FALSE;
			nDisk=0;
			while (pMirror->pDevice[nDisk] && (nDisk<SPARE_DISK)) nDisk++;
			if (pDev->ArrayNum && !pDev->HidenLBA) {
				pDev->HidenLBA = (RECODR_LBA + 1);
				pDev->capacity -= (RECODR_LBA + 1);
			}
			if (pDev->capacity * nDisk < pMirror->capacity) return FALSE;
			// ok to put it back
			pDev->DeviceFlags |= DFLAGS_ARRAY_DISK;
			pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
			for (i=0; i<nDisk; i++) {
				if (!pMirror->pDevice[i] || 
					(pMirror->pDevice[i]->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)) {
					return TRUE;
				}
			}
			pMirror->BrokenFlag = FALSE;
			pMirror->nDisk = (UCHAR)nDisk;
			pMirror->RaidFlags &= ~RAID_FLAGS_DISABLED;
			pArray->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
			return TRUE;
		}
		else if (!pMirror)
		{
			if (pArray->BrokenFlag) return FALSE;
			if (pDev->HidenLBA>0) {
				pDev->HidenLBA = 0;
				pDev->capacity += (RECODR_LBA + 1);
			}
			if (pDev->capacity * 2 < pArray->capacity) return FALSE;
			pMirror = Array_alloc();
			pMirror->nDisk = 0;
			pMirror->capacity = pDev->capacity;
			pMirror->BrokenFlag = TRUE;
			pMirror->RaidFlags = RAID_FLAGS_DISABLED;
			pMirror->arrayType = VD_RAID01_MIRROR;
			pMirror->BlockSizeShift = 7;
			pMirror->ArrayNumBlock = 1<<7;
			pMirror->Stamp = pArray->Stamp;
			pMirror->pDevice[0] = pDev;
			pMirror->pDevice[MIRROR_DISK] = pArray->pDevice[0];
			pArray->pDevice[MIRROR_DISK] = pDev;
			
			pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
			pDev->pArray = pMirror;
			pDev->ArrayMask = 1;
			pDev->ArrayNum = 0;

			return TRUE;
		}
		return FALSE;
	}
// add by karl 2001/01/17
//+
	else if(pArray->arrayType == VD_RAID_10_SOURCE)
	{
		PVirtualDevice pMirror;
		nChild = CHILDNUM_FROM_ID(hMirror) - 1;
		pMirror = pArray->pRAID10Mirror;
		if (pArray->pDevice[nChild] && 
			(!pMirror->pDevice[nChild] ||
			 (pMirror->pDevice[nChild]->DeviceFlags2 & DFLAGS_DEVICE_DISABLED) ||
			 (pDev==pMirror->pDevice[nChild])
			))
		{
			// add as mirror disk
			if(pDev->capacity*pArray->nDisk < pArray->capacity ) return FALSE;

#ifdef _BIOS_
			ReadWrite(pArray->pDevice[nChild], RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
			if (ArrayBlk.ArrayType!=VD_RAID_10_SOURCE) {
				ArrayBlk.ArrayType = VD_RAID_10_SOURCE;
				ReadWrite(pArray->pDevice[nChild], RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
			}
			ArrayBlk.ArrayType = VD_RAID_10_MIRROR;
			ArrayBlk.RebuiltSector = 0;
			ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
			pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
			pDev->ArrayNum  = (UCHAR)nChild;
			pDev->ArrayMask = (1<<nChild);
			pDev->pArray = pMirror;
			pMirror->pDevice[nChild] = pDev;
			if (nChild && pDev->HidenLBA==0) {
				pDev->HidenLBA = (RECODR_LBA + 1);
				pDev->capacity -= (RECODR_LBA + 1);
			}
			AdjustRAID10Array(pArray);
			return TRUE;
		}
		else
			return FALSE;
	}
	else 
		return FALSE;
}

void Device_SetArrayName(HDISK hDisk, char* arrayname)
{
	int iName = 0;
	int iStart;
	int arrayType;
	PVirtualDevice pArray;

	if (!IS_ARRAY_ID(hDisk)) return;
	pArray = ARRAY_FROM_ID(hDisk);
	arrayType = pArray->arrayType;
		
	if (!CHILDNUM_FROM_ID(hDisk) &&
		(arrayType==VD_RAID_01_1STRIPE ||
		arrayType==VD_RAID_01_2STRIPE ||
		arrayType==VD_RAID_10_SOURCE ||
		arrayType==VD_RAID01_MIRROR))
		iStart = 16;
	else
		iStart=0;
	
	for(iName=0; iName<16; iName++)
		pArray->ArrayName[iStart+iName] = arrayname[iName];
	if (arrayType==VD_RAID_01_2STRIPE) {
		PDevice pDev = pArray->pDevice[MIRROR_DISK];
		if (pDev && pDev->pArray) {
			for(iName=0; iName<16; iName++)
				pDev->pArray->ArrayName[iStart+iName] = arrayname[iName];
		}
	}
}

HDISK Device_CreateRAID10 ( HDISK * pDisks, int nDisks, int nStripSizeShift)
{
	PVirtualDevice pArrays[MAX_V_DEVICE];
	PVirtualDevice pArray;
	int i;

	for (i=0; i<nDisks; i++) {
		if (!IS_ARRAY_ID(pDisks[i])) return INVALID_HANDLE_VALUE;
		pArrays[i] = ARRAY_FROM_ID(pDisks[i]);
		if (pArrays[i]->arrayType!=VD_RAID_1_MIRROR) return INVALID_HANDLE_VALUE;
		if (pArrays[i]->RaidFlags & RAID_FLAGS_BEING_BUILT) return INVALID_HANDLE_VALUE;
	}

	pArray = CreateRAID10(pArrays, (UCHAR)nDisks, (UCHAR)nStripSizeShift);	
	
    return MAKE_COMPOSED_ARRAY_ID(pArray);
}

BOOL Device_RescanAll()
{
	int iChan;
	int iDev;
	int iAdapter;
	ST_XFER_TYPE_SETTING	osAllowedDeviceXferMode;

	PDevice pDevice;
	PChannel pChan;

	for (iAdapter=0; iAdapter<num_adapters; iAdapter++)
	    for( iChan = 0; iChan < 2; iChan ++ )
	    {
			pChan = &hpt_adapters[iAdapter]->IDEChannel[iChan];
			DisableBoardInterrupt(pChan->BaseBMI);
	        for( iDev = 0; iDev < 2; iDev ++ )
	        {
				if( pChan == &hpt_adapters[iAdapter]->IDEChannel[0]){
					osAllowedDeviceXferMode.Mode = pChan->HwDeviceExtension->m_rgWinDeviceXferModeSettings[0][iDev].Mode;
				}
				else
				{
					osAllowedDeviceXferMode.Mode = pChan->HwDeviceExtension->m_rgWinDeviceXferModeSettings[1][iDev].Mode;
				}
				pDevice=pChan->pDevice[iDev];
				if (!pDevice || (pDevice->DeviceFlags2 & DFLAGS_DEVICE_DISABLED))
				{
					pChan->pDevice[iDev] = 0;
					pDevice = &pChan->Devices[iDev];
					/// NO: ZeroMemory(pDevice,sizeof(struct _Device));
					pDevice->UnitId = (iDev)? 0xB0 : 0xA0;
					pDevice->pChannel = pChan;
					if(FindDevice(pDevice,osAllowedDeviceXferMode)) 
					{
						pChan->pDevice[iDev] = pDevice;

						if (pChan->pSgTable == NULL) 
							pDevice->DeviceFlags &= ~(DFLAGS_DMA | DFLAGS_ULTRA);
						
						if(pDevice->DeviceFlags & DFLAGS_HARDDISK) {
							StallExec(1000000);
						}
						
						if((pDevice->DeviceFlags & DFLAGS_ATAPI) == 0 && 
							(pDevice->DeviceFlags & DFLAGS_REMOVABLE_DRIVE))
							IdeMediaStatus(TRUE, pDevice);
						
						Nt2kHwInitialize(pDevice);

						// notify monitor application
						if(pDevice->DeviceFlags & DFLAGS_HARDDISK) {
							pDevice->DeviceFlags2 |= DFLAGS_NEW_ADDED;
							ReportError(pDevice, DEVICE_PLUGGED, NULL);
						}
					}
				}
				else {
					/*
					 * Check if device is still working.
					 */
					PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
					PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
					UCHAR            statusByte, cnt=0;

				_retry_:
					SelectUnit(IoPort, pDevice->UnitId);
					statusByte = WaitOnBusy(ControlPort);
					if(statusByte & IDE_STATUS_ERROR) {
						statusByte= GetErrorCode(IoPort);
						DisableBoardInterrupt(pChan->BaseBMI);
						IssueCommand(IoPort, IDE_COMMAND_RECALIBRATE);
						EnableBoardInterrupt(pChan->BaseBMI);
						GetBaseStatus(IoPort);
						if(cnt++< 10) goto _retry_;
					}
					if((statusByte & 0x7e)== 0x7e || (statusByte & 0x40) == 0) {
						ReportError(pDevice, DEVICE_REMOVED, NULL);
						if(pDevice->pArray) ResetArray(pDevice->pArray);
					}
				}
	        }
			
			Win98HwInitialize(pChan);
			EnableBoardInterrupt(pChan->BaseBMI);
	    }
	    
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\hptchip.c ===
/***************************************************************************
 * File:          Hptchip.c
 * Description:   This module include searching routines for scan PCI
 *				  devices
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/06/2000	HS.Zhang	Added this header
 ***************************************************************************/
#include "global.h"
/*===================================================================
 * Scan Chip
 *===================================================================*/   

#if defined(_BIOS_) || defined(WIN95)

PUCHAR
ScanHptChip(
    IN PChannel deviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )
{
    PCI1_CFG_ADDR  pci1_cfg = { 0, };
     
    pci1_cfg.enable = 1;

    for ( ; ; ) {
        if(Hpt_Slot >= MAX_PCI_DEVICE_NUMBER * 2) {
            Hpt_Slot = 0;
            if(Hpt_Bus++ >= MAX_PCI_BUS_NUMBER)
                break;
        }

        do {
            pci1_cfg.dev_num = Hpt_Slot >> 1;
            pci1_cfg.fun_num= Hpt_Slot & 1;
            pci1_cfg.reg_num = 0;
            pci1_cfg.bus_num = Hpt_Bus;
 
            Hpt_Slot++;
            OutDWord(CFG_INDEX, *((PULONG)&pci1_cfg));

            if (InDWord((PULONG)CFG_DATA) == SIGNATURE_366) {
                 deviceExtension->pci1_cfg = pci1_cfg;
				 pci1_cfg.reg_num = REG_RID;
				 OutDWord(CFG_INDEX, *((PULONG)&pci1_cfg));
				 if(InPort(CFG_DATA) < 3) {
					 pci1_cfg.reg_num = 0;
				 } else {
					 deviceExtension->pci1_cfg = pci1_cfg;
					 pci1_cfg.reg_num = REG_BMIBA;
					 OutDWord(CFG_INDEX, *((PULONG)&pci1_cfg));
					 return((PUCHAR)(InDWord(CFG_DATA) & ~1));
				 }
            }
#ifdef SUPPORT_HPT370_2DEVNODE
            else if((Hpt_Slot & 1) == 0) {
					  pci1_cfg.fun_num = 0;
					  OutDWord(CFG_INDEX, *((PULONG)&pci1_cfg));
                 deviceExtension->pci1_cfg = pci1_cfg;
                 pci1_cfg.reg_num = REG_BMIBA;
                 OutDWord(CFG_INDEX, *((PULONG)&pci1_cfg));
                 return((PUCHAR)((InDWord(CFG_DATA) & ~1) + 8));
			   }
#endif  //SUPPORT_HPT370_2DEVNODE

        } while (Hpt_Slot < MAX_PCI_DEVICE_NUMBER * 2);
    }
    return (0);
}

#endif

/*===================================================================
 * Set Chip
 *===================================================================*/   

UINT exlude_num = EXCLUDE_HPT366;

void SetHptChip(PChannel Primary, PUCHAR BMI)
{
    ULONG          loop;
    int            nClkCount, f_low, adjust;
    PChannel       Secondry;
    UCHAR          version, s3 = 0;

    if(BMI == (PUCHAR)-3) {
        s3 = 1;
		  BMI = Primary->BMI;
        OutDWord(BMI+0x10, (ULONG)Primary->BaseIoAddress1);
        OutDWord(BMI+0x14, (ULONG)Primary->BaseIoAddress2);
        Secondry = &Primary[1];
        OutDWord(BMI+0x18, (ULONG)Secondry->BaseIoAddress1);
        OutDWord(BMI+0x1C, (ULONG)Secondry->BaseIoAddress2);
    }

#ifdef SUPPORT_HPT370_2DEVNODE
	 if(BMI & 0x8)	{
		 Primary->exclude_index  =	(++exlude_num);
       Primary->BaseIoAddress1 = (PIDE_REGISTERS_1)(InDWord((PULONG)(BMI + 0x18)) & ~1);
       Primary->BaseIoAddress2 = (PIDE_REGISTERS_2)((InDWord((PULONG)(BMI + 0x1C)) & ~1) + 2);
       Primary->BMI  = BMI;
       Primary->BaseBMI = (PUCHAR)((ULONG)BMI & ~8);
       Primary->InterruptLevel = (UCHAR)(InPort(BMI + 0x5C));
       Primary->ChannelFlags  = (UCHAR)(0x10 | IS_HPT_370);
		 return;
	 }
#endif //SUPPORT_HPT370_2DEVNODE

    version = (InPort(BMI+0x2E) == 0)? IS_HPT_370 :
        (InPort(BMI+0x54) == 0x60)? IS_HPT_368 : IS_HPT_366 ;

    OutWord((BMI + 0x20 + REG_PCICMD), 
        (USHORT)((InWord((BMI + 0x20 + REG_PCICMD)) & ~0x12) |
        PCI_BMEN | PCI_IOSEN));

    OutPort(BMI + 0x20 + REG_MLT, 0x40);

    Primary->BaseIoAddress1  = (PIDE_REGISTERS_1)(InDWord((PULONG)(BMI + 0x10)) & ~1);
    Primary->BaseIoAddress2 = (PIDE_REGISTERS_2)((InDWord((PULONG)(BMI + 0x14)) & ~1) + 2);
    Primary->BMI  = BMI;
    Primary->BaseBMI = BMI;

    Primary->InterruptLevel = (UCHAR)InPort(BMI + 0x5C);
    Primary->ChannelFlags  = (UCHAR)(0x20 | version);

    switch(version) {
    case IS_HPT_366:
		   Primary->exclude_index  =	EXCLUDE_HPT366;
         goto set_hpt_36x;

    case IS_HPT_368:
		   Primary->exclude_index  = (++exlude_num);
set_hpt_36x:
         Primary->Setting = setting366;
         OutWord((PUSHORT)(BMI + 0x20 +REG_MISC), 0x2033);        
         break;

    case IS_HPT_370:
       Secondry = &Primary[1];
       if(s3 == 0) {
		    Primary->exclude_index  = (++exlude_num);
		    Secondry->exclude_index  = (++exlude_num);
       }
       Secondry->pci1_cfg = Primary->pci1_cfg;
       Secondry->BaseIoAddress1  = (PIDE_REGISTERS_1)(InDWord((PULONG)(BMI + 0x18)) & ~1);
       Secondry->BaseIoAddress2 = (PIDE_REGISTERS_2)((InDWord((PULONG)(BMI + 0x1C)) & ~1) + 2);
       Secondry->BMI  = BMI + 8;
       Secondry->BaseBMI = BMI;

	   /*
	    * Added by HS.Zhang
	    *
	    * We need check the BMI state on another channel when do DPLL
	    * clock swithing.
	    */
	   Primary->NextChannelBMI = BMI + 8;
	   Secondry->NextChannelBMI = BMI;

	   /*  Added by HS.Zhang
	    *  We need check the FIFO count when INTRQ generated. our chip
	    *  generated the INTR immediately when device generated a IRQ.
	    *  but at this moment, the DMA transfer may not finished, so we
	    *  need check FIFO count to determine whether the INTR is true
	    *  interrupt we need.
	    */
	   Primary->MiscControlAddr = BMI + 0x20 + REG_MISC;
	   Secondry->MiscControlAddr = BMI + 0x24 + REG_MISC;

       Secondry->InterruptLevel = (UCHAR)(InPort(BMI + 0x5C));
       Secondry->ChannelFlags  = (UCHAR)(0x10 | version);

       OutPort(BMI + 0x20 + REG_MISC, 5);        
       OutPort(BMI + 0x24 + REG_MISC, 5);        

       adjust = 1;
       nClkCount = InWord((PUSHORT)(BMI + 0x98)) & 0x1FF;
       if(nClkCount < 0x9C) 
          f_low = PCI_33_F;
       else if(nClkCount < 0xb0)
          f_low = PCI_40_F;
       else if (nClkCount < 0xc8)
          f_low = PCI_50_F;
       else
          f_low = PCI_66_F;
reset_5C:
       OutDWord((BMI + 0x7C), 
          ((ULONG)((f_low < PCI_50_F? 2 : 4) + f_low) << 16) | f_low | 0x100);

       OutPort(BMI + 0x7B, 0x20);

       for(loop = 0; loop < 0x50000; loop++)
          if(InPort(BMI + 0x7B) & 0x80) {
              for(loop = 0; loop < 0x1000; loop++)
                  if((InPort(BMI + 0x7B) & 0x80) == 0)
                       goto re_try;
              OutDWord((BMI + 0x7C), 
                  InDWord((PULONG)(BMI + 0x7C)) & ~0x100);
#ifndef USE_PCI_CLK
              Primary->ChannelFlags |= IS_DPLL_MODE;
              Secondry->ChannelFlags |= IS_DPLL_MODE;
#endif
              goto wait_awhile;
          }
re_try:
       if(++adjust < 6) {
           if(adjust & 1)
               f_low -= (adjust >> 1);
           else
               f_low += (adjust >> 1);
           goto  reset_5C;
       }

wait_awhile:
#ifdef USE_PCI_CLK
       OutPort(BMI + 0x7B, 0x22);
#endif
       Primary->Setting = Secondry->Setting = 
           (Primary->ChannelFlags & IS_DPLL_MODE)? setting370_50 : setting370_33;
    }
}


/*===================================================================
 * check if the disk is "bad" disk
 *===================================================================*/   

static BadModeList bad_disks[] = {
	{0xFF, 0xFF, 4, 8,  "TO-I79 5" },       // 0
	{3, 2, 4, 10,       "DW CCA6204" },     // 1
	{0xFF, 0xFF, 3, 10, "nIetrglaP " },     // 2
	{3, 2, 4, 10,       "DW CDW0000" },     // 3 reduce mode on AA series
	{0xFF, 2, 4, 10,    "aMtxro9 01"},      // 4 reduce mode on 91xxxDx series
	{0xFF, 2, 4, 14,    "aMtxro9 80544D"},  // 5 Maxtor 90845D4
	{0xFF, 0xFF, 4, 10, "eHlwte-taP"},      // 6 HP CD-Writer (0x5A cmd error)
	{0xFF, 2, 4, 8|HPT366_ONLY|HPT368_ONLY,  "DW CCA13" },         // 7
	{0xFF, 0xFF, 0, 16, "iPnoee rVD-DOR M"},// 8 PIONEER DVD-ROM
	{0xFF, 0xFF, 4, 10, "DCR- WC XR" },     // 9 SONY CD-RW   (0x5A cmd error)
	{0xFF, 0xFF, 0, 8,  "EN C    " },       // 10
	{0xFF, 1, 4, 18,    "UFIJST UPM3C60A5 H"}, 
	{0x2,  2, 4, 14,    "aMtxro9 80284U"},     // Maxtor 90882U4

	{0x3,  2, 4, 10|HPT368_ONLY,    "TS132002 A"},        // Seagate 10.2GB ST310220A
	{0x3,  2, 4, 10|HPT368_ONLY,    "TS136302 A"},        // Seagate 13.6GB ST313620A
	{0x3,  2, 4, 10|HPT368_ONLY,    "TS234003 A"},        // Seagate 20.4GB ST320430A
	{0x3,  2, 4, 10|HPT368_ONLY,    "TS232704 A"},        // Seagate 27.2GB ST327240A
	{0x3,  2, 4, 10|HPT368_ONLY,    "TS230804 A"},        // Seagate 28GB   ST328040A
	{0x3,  2, 4, 8|HPT368_ONLY,     "TS6318A0"},          // Seagate 6.8GB  ST36810A

	{3, 2, 4, 14,       "aMtxro9 02848U"},                // Maxtor 92048U8

	{0x3, 2, 4, 14|HPT368_ONLY,    "ASSMNU GVS5135"},	   // SUMSUNG SV1553D
	{0x3, 2, 4, 14|HPT368_ONLY,    "ASSMNU GVS0122"},	   // SUMSUNG SV1022D
	{0x3, 2, 4, 14|HPT368_ONLY,    "ASSMNU GGS5011"},	   // SUMSUNG SG0511D
	{0x3, 2, 4, 14|HPT368_ONLY,    "ASSMNU GGS0122"},	   // SUMSUNG SG1022D
	{0x3, 2, 4, 14|HPT368_ONLY,    "aMtxro9 80544D"},     // Maxtor 90845D4 
	{0x3, 2, 4, 14|HPT368_ONLY,    "aMtxro9 71828D"},     // Maxtor 91728D8 
	{0x3, 2, 4, 14|HPT368_ONLY,    "aMtxro9 02144U"},     // Maxtor 92041U4 
	{0x3, 2, 4, 8|HPT368_ONLY,     "TS8324A1"},	    // Seagate 28GB   ST38421A
	{0x3, 2, 4, 22|HPT368_ONLY,    "UQNAUT MIFERABLLC 8R4."},  //QUANTUM FIREBALL CR8.4A
	{0x3, 2, 4, 16|HPT368_ONLY,    "uFijst hPM3E01A2"},        // Fujitsh MPE3102A
	{0x3, 2, 4, 14|HPT368_ONLY,    "BI MJDAN739001"},	        // IBM DJNA370910
	{0x3,  2, 4, 16|HPT370_ONLY, "UFIJST UPM3D60A4"},// Fujitsu MPD3064AT 
//add new here !!

//#ifdef USE_PCI_CLK						// if use pci clk, just alow UDMA4
//   { 4, 2, 4, 0, 0 }
//#else
	{ 5, 2, 4, 0, 0 }
//#endif									// USE_PCI_CLK
};

#define MAX_BAD_DISKS (sizeof(bad_disks)/sizeof(BadModeList))


PBadModeList check_bad_disk(char *ModelNumber, PChannel pChan)
{
     int l;
     PBadModeList pbd;

    /*
     * kick out the "bad device" which do not work with our chip
     */
     for(l=0, pbd = bad_disks; l < MAX_BAD_DISKS - 1; pbd++,l++) {
        if(StringCmp(ModelNumber, pbd->name, pbd->length & 0x1F) == 0) {
          switch (l) {
          case 3:
            if(ModelNumber[3]== 'C' && ModelNumber[4]=='D' && ModelNumber[5]=='W' && 
                 ModelNumber[8]=='A' && (ModelNumber[11]=='A' || 
                 ModelNumber[10]=='A' || ModelNumber[9]=='A')) 
                 goto out;
          case 4:
            if(ModelNumber[0]== 'a' && ModelNumber[1]=='M' && ModelNumber[2]=='t' && 
                 ModelNumber[3]=='x' && ModelNumber[6]== '9' && ModelNumber[9]=='1' && 
                 ModelNumber[13] =='D')
                 goto out;
          case 6:
             if(ModelNumber[16]== 'D' && ModelNumber[17]=='C' && ModelNumber[18]=='W' && ModelNumber[19]=='-' &&
                ModelNumber[20]== 'i' && ModelNumber[21]=='r' && ModelNumber[22] =='e')
                 goto out;
          default:
                break;
			 }
        }
    }
out:
    if((pbd->length & (HPT366_ONLY | HPT368_ONLY | HPT370_ONLY)) == 0 ||
       ((pbd->length & HPT366_ONLY) && (pChan->ChannelFlags & IS_HPT_366)) ||
       ((pbd->length & HPT368_ONLY) && (pChan->ChannelFlags & IS_HPT_368)) ||
       ((pbd->length & HPT370_ONLY) && (pChan->ChannelFlags & IS_HPT_370)))
          return(pbd);
    return (&bad_disks[MAX_BAD_DISKS - 1]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\forwin.h ===
/***************************************************************************
 * File:          forwin.h
 * Description:   This file include major constant definition and
 *				  global for windows drivers.
 *				  
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/08/2000	HS.Zhang	Added this header
 *		11/14/2000	HS.Zhang	Added m_nWinXferModeSetting member in
 *								HW_DEVICE_EXTENSION.
 *		11/22/2000	SLeng		Changed OS_Identify(x) to OS_Identify(pDev)
 *
 ***************************************************************************/
#ifndef _FORWIN_H_
#define _FORWIN_H_

#ifndef _BIOS_
//#define USE_PCI_CLK					// will use PCI clk to write date, mean 66Mhz

#ifndef USE_PCI_CLK
#define DPLL_SWITCH						// switch clk between read and write

//#define FORCE_100						// force use true ATA100 clock,
										// if undef this macro, will
										// use 9xMhz clk instead of 100mhz
#endif

#ifdef DPLL_SWITCH									  
#define SERIAL_CMD						// Force use serial command when use clock switching
#endif									// DPLL_SWITCH

/************************************************************************
**       FUNCTION SELECT
*************************************************************************/

#ifdef  WIN95
//#define SUPPORT_HPT370_2DEVNODE
#define SUPPORT_XPRO
//#define SUPPORT_HOTSWAP								 

// BUG FIX: create a internal buffer for small data block
//				otherwise it causes data compare error
#define SUPPORT_INTERNAL_BUFFER
#endif

//#define SUPPORT_TCQ
#define SUPPORT_ATAPI


#pragma intrinsic (memset, memcpy)
#define ZeroMemory(a, b) memset(a, 0, b)

#define FAR

/************************************************************************
**  Special define for windows
*************************************************************************/

#define LOC_IDENTIFY IDENTIFY_DATA Identify;
#define ARG_IDENTIFY    , (PUSHORT)&Identify
#define LOC_ARRAY_BLK   ArrayBlock ArrayBlk
#define ARG_ARRAY_BLK	, (PUSHORT)&ArrayBlk
#define DECL_BUFFER     , PUSHORT tmpBuffer
#define ARG_BUFFER      , tmpBuffer 
#define DECL_SRB        , PSCSI_REQUEST_BLOCK Srb
#define ARG_SRB         , Srb
#define LOC_SRBEXT_PTR  PSrbExtension  pSrbExt = (PSrbExtension)Srb->SrbExtension;
#define DECL_SRBEXT_PTR , struct _SrbExtension  *pSrbExt
#define ARG_SRBEXT_PTR  , pSrbExt
#define ARG_SRBEXT(Srb)	, Srb->SrbExtension
#define LOC_SRB         PSCSI_REQUEST_BLOCK Srb = pChan->CurrentSrb;
#define WIN_DFLAGS      | DFLAGS_TAPE_RDP | DFLAGS_SET_CALL_BACK 
#define BIOS_IDENTIFY
#define BIOS_2STRIPE_NOTIFY
#define BIOS_CHK_TMP(x)

/***************************************************************************
 * Description: include
 ***************************************************************************/
#include "miniport.h"

#ifndef WIN95	   
#include "devioctl.h"
#endif

#include "srb.h"
#include "scsi.h"

#include "stypes.h"						// share typedefs for window and bios

#ifdef WIN95
#include <dcb.h>
#include <ddb.h>
#include "ior.h"
#include "iop.h"

typedef struct _st_SRB_IO_CONTROL {
	ULONG HeaderLength;
	UCHAR Signature[8];
	ULONG Timeout;
	ULONG ControlCode;
	ULONG ReturnCode;
	ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;

#else

#include "ntdddisk.h"
#include "ntddscsi.h"

#endif

#include  "hptchip.h"
#include  "atapi.h"
#include  "device.h"
#include  "array.h"

typedef struct _HW_DEVICE_EXTENSION {
	Channel   IDEChannel[2];
	
	PHW_INITIALIZE	HwInitialize;		// initialize function pointer for different chips
	PHW_INTERRUPT	HwInterrupt;		// interrupt function pointer for different chips
	
	ULONG	m_nChannelNumber;			// the number of IDE channel this extension hold
	HANDLE	m_hAppNotificationEvent;	// the event handle to notify application
	PDevice	m_pErrorDevice;				// the most recent device which occurs errors
								
	/* Added by HS.Zhang
	 * this is the settings get from windows registry, the
	 * AtapiFindController will parse the argument string passed by
	 * SCSIPORT, It get the AdapterXferModeSetting argument value and
	 * store it in here. because there are four devices in one adapter,
	 * the data format is in x86 little enddin format
	 *	0xXX XX XX XX
	 *	  SS SM PS PM
	 */
	union{
		ST_XFER_TYPE_SETTING m_rgWinDeviceXferModeSettings[2][2];
		ULONG	m_nWinXferModeSetting;
	};
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


/************************************************************************
**                  Rename	& Macro
*************************************************************************/

#define OutDWord(x, y)    ScsiPortWritePortUlong((PULONG)(x), y)
#define InDWord(x)        ScsiPortReadPortUlong((PULONG)(x))
#define OutPort(x, y)     ScsiPortWritePortUchar((PUCHAR)(x), y)
#define InPort(x)         ScsiPortReadPortUchar((PUCHAR)(x))
#define OutWord(x, y)     ScsiPortWritePortUshort((PUSHORT)(x), y)
#define InWord(x)         ScsiPortReadPortUshort((PUSHORT)(x))
#define RepINS(x,y,z)     ScsiPortReadPortBufferUshort(&x->Data, (PUSHORT)y, z)
#define RepOUTS(x,y,z)    ScsiPortWritePortBufferUshort(&x->Data, (PUSHORT)y, z)
#define RepINSD(x,y,z)    ScsiPortReadPortBufferUlong((PULONG)&x->Data, (PULONG)y, (z) >> 1)
#define RepOUTSD(x,y,z)   ScsiPortWritePortBufferUlong((PULONG)&x->Data, (PULONG)y, (z) >> 1)
#define OS_RepINS(x,y,z)  RepINS(x,y,z)
#define StallExec(x)      ScsiPortStallExecution(x)


/***************************************************************************
 * Windows global data
 ***************************************************************************/

extern char HPT_SIGNATURE[];
extern VirtualDevice  VirtualDevices[];
extern ULONG excluded_flags;

#ifdef SUPPORT_INTERNAL_BUFFER
int  Use_Internal_Buffer(
						 IN PSCAT_GATH psg,
						 IN PSCSI_REQUEST_BLOCK Srb
						);
VOID Create_Internal_Buffer(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID CopyTheBuffer(PSCSI_REQUEST_BLOCK Srb);
#define CopyInternalBuffer(pDev, Srb) \
								if(((PSrbExtension)(Srb->SrbExtension))->WorkingFlags & SRB_WFLAGS_USE_INTERNAL_BUFFER)\
								CopyTheBuffer(Srb)

#else //Not SUPPORT_INTERNAL_BUFFER
#define Use_Internal_Buffer(psg, Srb) 0
#define Create_Internal_Buffer(HwDeviceExtension)
#define CopyInternalBuffer(pDev, Srb)
#endif

#ifdef SUPPORT_TCQ
#define SetMaxCmdQueue(x, y) x->MaxQueue = (UCHAR)(y)
#else //Not SUPPORT_TCQ
#define SetMaxCmdQueue(x, y)
#endif // SUPPORT_TCQ


#ifdef SUPPORT_HOTSWAP
void CheckDeviceReentry(PChannel pChan, PSCSI_REQUEST_BLOCK Srb);
#else //Not SUPPORT_HOTSWAP
#define CheckDeviceReentry(pChan, Srb)
#endif //SUPPORT_HOTSWAP

#ifdef SUPPORT_XPRO
extern int  need_read_ahead;
VOID  _cdecl  start_ifs_hook(PCHAR pDriveName);
#else	 // Not 	SUPPORT_XPRO
#define start_ifs_hook(a)
#endif //SUPPORT_XPRO

/***************************************************************************
 * Windows Function prototype special for WIn98 /NT2k
 ***************************************************************************/

__inline void __enable(void) {
	_asm  sti  
}
__inline int __disable(void) {
	_asm { pushfd
			pop  eax
			test eax, 200h
			jz   disable_out
			cli
disable_out:
	}
}

#define ENABLE   if (old_flag & 0x200) { __enable();} else;
#define DISABLE  {old_flag = __disable();}
#define OLD_IRQL int old_flag;

#ifdef WIN95 //++++++++++++++++++++

#define Nt2kHwInitialize(pDevice)
VOID w95_initialize(VOID);
VOID w95_scan_all_adapters(VOID);
VOID Win98HwInitialize(PChannel pChan);
VOID Win95CheckBiosInterrupt(VOID);

#else // NT2K ++++++++++++++++++++

VOID  Nt2kHwInitialize(PDevice pDevice);
#define w95_initialize()
#define w95_scan_all_adapters()
#define Win98HwInitialize(pChan)
#define Win95CheckBiosInterrupt()

void IdeSendSmartCommand(IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb);
PSCSI_REQUEST_BLOCK BuildMechanismStatusSrb (IN PChannel pChan,
											 IN ULONG PathId, IN ULONG TargetId);
PSCSI_REQUEST_BLOCK BuildRequestSenseSrb (IN PChannel pChan,
										  IN ULONG PathId, IN ULONG TargetId);

#ifdef WIN2000
SCSI_ADAPTER_CONTROL_STATUS AtapiAdapterControl(
												IN PHW_DEVICE_EXTENSION deviceExtension,
												IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
												IN PVOID Parameters);
#endif //WIN2000

#endif //WIN95


/***************************************************************************
 * Windows Function prototype
 ***************************************************************************/


/* win95.c / winnt.c */
VOID  Start_Atapi(PDevice pDev DECL_SRB);
BOOLEAN Interrupt_Atapi(PDevice pDev);
ULONG   GetStamp(VOID);


/* win.c */
ULONG DriverEntry(IN PVOID DriverObject, IN PVOID Argument2);
BOOLEAN AtapiStartIo(IN PHW_DEVICE_EXTENSION HwDeviceExtension, 
					 IN PSCSI_REQUEST_BLOCK Srb);
BOOLEAN AtapiHwInterrupt(IN PChannel pChan);
BOOLEAN AtapiHwInterrupt370(IN PChannel pChan);
BOOLEAN AtapiAdapterState(IN PVOID HwDeviceExtension, IN PVOID Context, 
						  IN BOOLEAN SaveState);
VOID AtapiCallBack(IN PChannel);
VOID AtapiCallBack370(IN PChannel);
BOOLEAN AtapiHwInitialize(IN PChannel pChan);
BOOLEAN AtapiHwInitialize370(IN PHW_DEVICE_EXTENSION HwDeviceExtension);
BOOLEAN AtapiResetController(IN PHW_DEVICE_EXTENSION HwDeviceExtension, 
							 IN ULONG PathId);
ULONG AtapiFindController(
							 IN PHW_DEVICE_EXTENSION HwDeviceExtension,
							 IN PVOID Context,
							 IN PVOID BusInformation,
							 IN PCHAR ArgumentString,
							 IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
							 OUT PBOOLEAN Again
							);
void ResetArray(PVirtualDevice  pArray); // gmm added


/* winio.c  */
void WinStartCommand(IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb);
void CheckNextRequest(PChannel pChan);
void PutQueue(PDevice pDev, PSCSI_REQUEST_BLOCK Srb);
int  __fastcall btr (ULONG locate);
ULONG __fastcall MapLbaToCHS(ULONG Lba, WORD sectorXhead, BYTE head);
void IdeSendCommand(IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb);
VOID IdeMediaStatus(BOOLEAN EnableMSN, IN PDevice pDev);
UCHAR IdeBuildSenseBuffer(IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb);

/*
 * for notify application
 * If for Win95, follow function are stored in xpro.c
 * else, follow functions are stored in winlog.c
 */	 
HANDLE __stdcall PrepareForNotification(HANDLE hEvent);
void __stdcall NotifyApplication(HANDLE hEvent);
void __stdcall CloseNotifyEventHandle(HANDLE hEvent);

LONG __stdcall GetCurrentTime();
LONG __stdcall GetCurrentDate();

#define IS_RDP(OperationCode)\
							 ((OperationCode == SCSIOP_ERASE)||\
							 (OperationCode == SCSIOP_LOAD_UNLOAD)||\
							 (OperationCode == SCSIOP_LOCATE)||\
							 (OperationCode == SCSIOP_REWIND) ||\
							 (OperationCode == SCSIOP_SPACE)||\
							 (OperationCode == SCSIOP_SEEK)||\
							 (OperationCode == SCSIOP_WRITE_FILEMARKS))

#pragma pack(push, 1)
typedef struct {
	UCHAR      status;     /* 0 nonbootable; 80h bootable */
	UCHAR      start_head;
	USHORT     start_sector;
	UCHAR      type;
	UCHAR      end_head;
	USHORT     end_sector;
	ULONG      start_abs_sector;
	ULONG      num_of_sector;
} partition;

struct fdisk_partition_table {
	unsigned char bootid;   /* bootable?  0=no, 128=yes  */
	unsigned char beghead;  /* beginning head number */
	unsigned char begsect;  /* beginning sector number */
	unsigned char begcyl;   /* 10 bit nmbr, with high 2 bits put in begsect */	
	unsigned char systid;   /* Operating System type indicator code */
	unsigned char endhead;  /* ending head number */
	unsigned char endsect;  /* ending sector number */
	unsigned char endcyl;   /* also a 10 bit nmbr, with same high 2 bit trick */
	int relsect;            /* first sector relative to start of disk */
	int numsect;            /* number of sectors in partition */
};
struct master_boot_record {
	char    bootinst[446];   /* space to hold actual boot code */
	struct fdisk_partition_table parts[4];
	unsigned short  signature;       /* set to 0xAA55 to indicate PC MBR format */
};
#pragma pack(pop)

//
// Find adapter context structure
//
typedef struct _HPT_FIND_CONTEXT{	  
	ULONG	nAdapterCount;
	PCI_SLOT_NUMBER	nSlot;
	ULONG	nBus;
}HPT_FIND_CONTEXT, *PHPT_FIND_CONTEXT;

/************************************************************************
**  Special define for windows
*************************************************************************/

#define LongDivLShift(x, y, z)  ((x / (ULONG)y) << z)
#define LongRShift(x, y)  (x  >> y)
#define LongRem(x, y)	  (x % (ULONG)y)
#define LongMul(x, y)	  (x * (ULONG)y)
#define MemoryCopy(x,y,z) memcpy((char *)(x), (char *)(y), z)
#define OS_Array_Check(pDevice)
#define OS_RemoveStrip(x)

#define OS_Identify(pDev)  ScsiPortMoveMemory((char *)&pDev->IdentifyData,\
						(char *)&Identify, sizeof(IDENTIFY_DATA2))

#define OS_Busy_Handle(pChan, pDev) { ScsiPortNotification(RequestTimerCall, \
									pChan->HwDeviceExtension, pChan->CallBack, 1000); \
									pDev->DeviceFlags |= DFLAGS_SET_CALL_BACK;	}

#define OS_Reset_Channel(pChan) \
								AtapiResetController(pChan->HwDeviceExtension,Srb->PathId);

__inline void OS_EndCmd_Interrupt(PChannel pChan DECL_SRB)
{
	PSrbExtension pSrbExtension = (PSrbExtension)(Srb->SrbExtension);
	
#ifdef BUFFER_CHECK
	void CheckBuffer(PSCSI_REQUEST_BLOCK pSrb);
	CheckBuffer(Srb);
#endif //BUFFER_CHECK
	if(pSrbExtension){
		if(pSrbExtension->pWorkingArray != NULL){
			pSrbExtension->pWorkingArray->Srb = NULL;
		}

		if(pSrbExtension->WorkingFlags & SRB_WFLAGS_HAS_CALL_BACK){
			pSrbExtension->pfnCallBack(pChan->HwDeviceExtension, Srb);
		}
	}
	
	ScsiPortNotification(RequestComplete, pChan->HwDeviceExtension, Srb);
	
	if(pChan->CurrentSrb == Srb){
		pChan->CurrentSrb = NULL;	 
	}
#ifdef	SERIAL_CMD	
	ScsiPortNotification(NextRequest, pChan->HwDeviceExtension, NULL);
#endif									// SERIAL_CMD
	CheckNextRequest(pChan);
}			   

__inline void  WinSetSrbExt(PDevice pDevice, PVirtualDevice pArray, PSCSI_REQUEST_BLOCK Srb, PSrbExtension pSrbExt)
{
	pSrbExt->DataBuffer = Srb->DataBuffer;
	pSrbExt->DataTransferLength = (USHORT)Srb->DataTransferLength;
	pSrbExt->SgFlags = SG_FLAG_EOT;
	pSrbExt->pMaster = pDevice;
	pArray->Srb = Srb;
	pSrbExt->pWorkingArray = pArray;
}

#define OS_Set_Array_Wait_Flag(pDevice) pDevice->DeviceFlags |= DFLAGS_ARRAY_WAIT_EXEC
#define WIN_NextRequest(pChan) { pChan->CurrentSrb = NULL;  \
							   CheckNextRequest(pChan);}

#endif //_BIOS_

#endif //_FORWIN_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\hptchip.h ===
/***************************************************************************
 * File:          hptchip.h
 * Description:   Definiation of PCI configuration register
 * Author:        Dahai Huang
 * Dependence:    None
 * Reference:     HPT 366/368/370 Manual
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:       DH 5/10/2000 initial code
 *
 ***************************************************************************/


#ifndef _HPTCHIP_H_
#define _HPTCHIP_H_

#include <pshpack1.h>

/***************************************************************************
 * Description:  PCI
 ***************************************************************************/

typedef struct _PCI1_CFG_ADDR {
    USHORT    reg_num : 8;          // Register number
    USHORT    fun_num : 3;          // function number (0-1)
    USHORT    dev_num : 5;          // device number (0-20)

    USHORT    bus_num : 8;          // bus number (0)
    USHORT    reserved: 7;
    USHORT    enable  : 1;

}  PCI1_CFG_ADDR, *PPCI1_CFG_ADDR;
																  
#define MAX_PCI_BUS_NUMBER		0x10	// Maximum PCI device number
#define MAX_PCI_DEVICE_NUMBER   0x20  // Maximum PCI device number

#define  CFG_INDEX	0xCF8
#define 	CFG_DATA		0xCFC

/*
 * PCI config Register offset
 */
#define REG_VID             0x00    // vender identification register
#define REG_DID             0x02    // device identification register
#define REG_PCICMD          0x04    // command register
#define REG_PCISTS          0x06    // PCI device status register
#define REG_RID             0x08    // revision identification register
#define REG_PI              0x09    // programming interface register
#define REG_SUBC            0x0a    // sub class code register
#define REG_BCC             0x0b    // base class code register
#define REG_MLT             0x0d    // master latency timer register
#define REG_HEDT            0x0e    // header type register
#define REG_IOPORT0         0x10    //
#define REG_IOPORT1         0x14    //
#define REG_BMIBA           0x20    // bus master interface base address reg
#define REG_MISC            0x50    // brooklyn,MISC.control register


#define PCI_IOSEN           0x01    // Enable IO space
#define PCI_BMEN            0x04    // Enable IDE bus master


/*
 * Bus Master Interface
 */

#define BMI_CMD             0       // Bus master IDE command register offset
#define BMI_STS             2       // Bus master IDE status register offset
#define BMI_DTP             4       // Bus master IDE descriptor table
                                    // pointer register offset

#define BMI_CMD_STARTREAD   9       // Start write (read from disk)
#define BMI_CMD_STARTWRITE  1       // Start read (write to disk)
#define BMI_CMD_STOP        0       // Stop BM DMI

#define BMI_STS_ACTIVE      1       // RO:   bus master IDE active
#define BMI_STS_ERROR       2       // R/WC: IDE dma error
#define BMI_STS_INTR        4       // R/WC: interrupt happen
#define BMI_STS_DRV0EN      0x20    // R/W:  drive0 is capable of DMA xfer
#define BMI_STS_DRV1EN      0x40    // R/W:  drive1 is capable of DMA xfer


/***************************************************************************
 * Description:  Scatter-gather table
 ***************************************************************************/


typedef struct _SCAT_GATH
{
    ULONG   SgAddress;					// Physical address of main memory
    USHORT  SgSize;                 // length of this block
    USHORT  SgFlag;                 // 0 following next SG, 0x8000 last SG
}   SCAT_GATH, *PSCAT_GATH;

#define SG_FLAG_EOT         0x8000  // End flag of SG list
#define MAX_SG_DESCRIPTORS   33   //17 -- 4K

/***************************************************************************
 * HPT Special
 ***************************************************************************/
#define  SIGNATURE_366   0x41103

#ifdef   FORCE_100 // DPLL settings
#define  PCI_33_F     0x20
#define  PCI_40_F     0x26
#define  PCI_50_F     0x2A
#define  PCI_66_F     0x3F
#else
#define  PCI_33_F     0x23
#define  PCI_40_F     0x29
#define  PCI_50_F     0x2D
#define  PCI_66_F     0x42
#endif

/*
 * 370-370A timing 
 */

#define PIO_370MODE      0
#define DMA_370MODE      0x2
#define UDMA_370MODE     1

#define DATA_HIGH370(x)  ((ULONG)x)
#define DATA_LOW370(x)   ((ULONG)x << 4)
#define UDMA_CYCLE370(x) ((ULONG)x << 18)
#define DATA_PRE370(x)   ((ULONG)x << 22)
#define CTRL_ENA370(x)   ((ULONG)x << 28)

#define CMD_HIGH370(x)   ((ULONG)x << 9)
#define CMD_LOW370(x)    ((ULONG)x << 13)
#define CMD_PRE370(x)    ((ULONG)x << 25)

#define CLK50_PIO370     (CTRL_ENA370(PIO_370MODE)|CMD_PRE370(5)|CMD_LOW370(15)|CMD_HIGH370(10))

#define CLK50_370PIO0    (CLK50_PIO370|DATA_PRE370(3)|DATA_LOW370(8)|DATA_HIGH370(10))
#define CLK50_370PIO1    (CLK50_PIO370|DATA_PRE370(3)|DATA_LOW370(6)|DATA_HIGH370(5))
#define CLK50_370PIO2    (CLK50_PIO370|DATA_PRE370(2)|DATA_LOW370(5)|DATA_HIGH370(4))
#define CLK50_370PIO3    (CLK50_PIO370|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(3))
#define CLK50_370PIO4    (CLK50_PIO370|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))

#define CLK50_DMA370     (CTRL_ENA370(DMA_370MODE)|CMD_PRE370(1)|CMD_LOW370(4)|CMD_HIGH370(1))
#define CLK50_370DMA0    (CLK50_DMA370|DATA_PRE370(2)|DATA_LOW370(14)|DATA_HIGH370(10))
#define CLK50_370DMA1    (CLK50_DMA370|DATA_PRE370(2)|DATA_LOW370(5)|DATA_HIGH370(4))
#define CLK50_370DMA2    (CLK50_DMA370|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))

#define CLK50_UDMA370    (CTRL_ENA370(UDMA_370MODE)|CMD_PRE370(1)|CMD_LOW370(4)|CMD_HIGH370(1))
#define CLK50_370UDMA0   (CLK50_UDMA370|UDMA_CYCLE370(6)|DATA_LOW370(14)|DATA_HIGH370(10))
#define CLK50_370UDMA1   (CLK50_UDMA370|UDMA_CYCLE370(5)|DATA_LOW370(5)|DATA_HIGH370(4))
#define CLK50_370UDMA2   (CLK50_UDMA370|UDMA_CYCLE370(3)|DATA_LOW370(4)|DATA_HIGH370(2))
#define CLK50_370UDMA3   (CLK50_UDMA370|UDMA_CYCLE370(3)|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))
#define CLK50_370UDMA4   (CLK50_UDMA370|UDMA_CYCLE370(11)|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))
#define CLK50_370UDMA5   (CLK50_UDMA370|UDMA_CYCLE370(1)|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))

#define CLK33_PIOCMD370  (CTRL_ENA370(PIO_370MODE)|CMD_PRE370(3)|CMD_LOW370(10)|CMD_HIGH370(7))
#define CLK33_370PIO0    (CLK33_PIOCMD370|DATA_PRE370(2)|DATA_LOW370(10)|DATA_HIGH370(7))
#define CLK33_370PIO1    (CLK33_PIOCMD370|DATA_PRE370(2)|DATA_LOW370(9)|DATA_HIGH370(3))
#define CLK33_370PIO2    (CLK33_PIOCMD370|DATA_PRE370(1)|DATA_LOW370(5)|DATA_HIGH370(3))
#define CLK33_370PIO3    (CLK33_PIOCMD370|DATA_PRE370(1)|DATA_LOW370(4)|DATA_HIGH370(2))
#define CLK33_370PIO4    (CLK33_PIOCMD370|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))

#define CLK33_DMACMD370  (CTRL_ENA370(DMA_370MODE)|CMD_PRE370(1)|CMD_LOW370(3)|CMD_HIGH370(6))
#define CLK33_370DMA0    (CLK33_DMACMD370|DATA_PRE370(1)|DATA_LOW370(9)|DATA_HIGH370(7))
#define CLK33_370DMA1    (CLK33_DMACMD370|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(3))
#define CLK33_370DMA2    (CLK33_DMACMD370|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))

#define CLK33_UDMACMD370 (CTRL_ENA370(UDMA_370MODE)|CMD_PRE370(1)|CMD_LOW370(3)|CMD_HIGH370(1))
#define CLK33_370UDMA0   (CLK33_UDMACMD370|UDMA_CYCLE370(4)|DATA_PRE370(1)|DATA_LOW370(9)|DATA_HIGH370(7))
#define CLK33_370UDMA1   (CLK33_UDMACMD370|UDMA_CYCLE370(3)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(3))
#define CLK33_370UDMA2   (CLK33_UDMACMD370|UDMA_CYCLE370(2)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))
#define CLK33_370UDMA3   (CLK33_UDMACMD370|UDMA_CYCLE370(11)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))
#define CLK33_370UDMA4   (CLK33_UDMACMD370|UDMA_CYCLE370(1)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))
//#define CLK33_370UDMA5    0x1a85f442
#define CLK33_370UDMA5   (CLK33_UDMACMD370|UDMA_CYCLE370(1)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH(1))

/* original timing  
#define CLK50_PIO370     (CTRL_ENA370(PIO_370MODE)|CMD_PRE370(5)|CMD_LOW370(15)|CMD_HIGH370(10))
#define CLK50_370PIO0    (CLK50_PIO370|DATA_PRE370(3)|DATA_LOW370(16)|DATA_HIGH370(11))
#define CLK50_370PIO1    (CLK50_PIO370|DATA_PRE370(3)|DATA_LOW370(14)|DATA_HIGH370(5))
#define CLK50_370PIO2    (CLK50_PIO370|DATA_PRE370(2)|DATA_LOW370(8)|DATA_HIGH370(4))
#define CLK50_370PIO3    (CLK50_PIO370|DATA_PRE370(2)|DATA_LOW370(6)|DATA_HIGH370(3))
#define CLK50_370PIO4    (CLK50_PIO370|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))

#define CLK50_DMA370     (CTRL_ENA370(DMA_370MODE)|CMD_PRE370(5)|CMD_LOW370(15)|CMD_HIGH370(10))
#define CLK50_370DMA0    (CLK50_DMA370|DATA_PRE370(2)|DATA_LOW370(14)|DATA_HIGH370(10))
#define CLK50_370DMA1    (CLK50_DMA370|DATA_PRE370(2)|DATA_LOW370(5)|DATA_HIGH370(4))
#define CLK50_370DMA2    (CLK50_DMA370|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))

#define CLK50_UDMA370    (CTRL_ENA370(UDMA_370MODE)|CMD_PRE370(5)|CMD_LOW370(15)|CMD_HIGH370(10))
#define CLK50_370UDMA0   (CLK50_UDMA370|UDMA_CYCLE370(6)|DATA_LOW370(14)|DATA_HIGH370(10))
#define CLK50_370UDMA1   (CLK50_UDMA370|UDMA_CYCLE370(5)|DATA_LOW370(5)|DATA_HIGH370(4))
#define CLK50_370UDMA2   (CLK50_UDMA370|UDMA_CYCLE370(3)|DATA_LOW370(4)|DATA_HIGH370(2))
#define CLK50_370UDMA3   (CLK50_UDMA370|UDMA_CYCLE370(3)|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))
#define CLK50_370UDMA4   (CLK50_UDMA370|UDMA_CYCLE370(11)|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))
#define CLK50_370UDMA5   (CLK50_UDMA370|UDMA_CYCLE370(1)|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))

#define CLK33_PIOCMD370  (CTRL_ENA370(PIO_370MODE)|CMD_PRE370(3)|CMD_LOW370(10)|CMD_HIGH370(7))
#define CLK33_370PIO0    (CLK33_PIOCMD370|DATA_PRE370(2)|DATA_LOW370(10)|DATA_HIGH370(7))
#define CLK33_370PIO1    (CLK33_PIOCMD370|DATA_PRE370(2)|DATA_LOW370(9)|DATA_HIGH370(3))
#define CLK33_370PIO2    (CLK33_PIOCMD370|DATA_PRE370(1)|DATA_LOW370(5)|DATA_HIGH370(3))
#define CLK33_370PIO3    (CLK33_PIOCMD370|DATA_PRE370(1)|DATA_LOW370(4)|DATA_HIGH370(2))
#define CLK33_370PIO4    (CLK33_PIOCMD370|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))

#define CLK33_DMACMD370  (CTRL_ENA370(DMA_370MODE)|CMD_PRE370(3)|CMD_LOW370(10)|CMD_HIGH370(7))
#define CLK33_370DMA0    (CLK33_DMACMD370|DATA_PRE370(1)|DATA_LOW370(9)|DATA_HIGH370(7))
#define CLK33_370DMA1    (CLK33_DMACMD370|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(3))
#define CLK33_370DMA2    (CLK33_DMACMD370|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))

#define CLK33_UDMACMD370 (CTRL_ENA370(UDMA_370MODE)|CMD_PRE370(3)|CMD_LOW370(10)|CMD_HIGH370(7))
#define CLK33_370UDMA0   (CLK33_UDMACMD370|UDMA_CYCLE370(4)|DATA_PRE370(1)|DATA_LOW370(9)|DATA_HIGH370(7))
#define CLK33_370UDMA1   (CLK33_UDMACMD370|UDMA_CYCLE370(3)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(3))
#define CLK33_370UDMA2   (CLK33_UDMACMD370|UDMA_CYCLE370(2)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))
#define CLK33_370UDMA3   (CLK33_UDMACMD370|UDMA_CYCLE370(11)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))
#define CLK33_370UDMA4   (CLK33_UDMACMD370|UDMA_CYCLE370(1)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))
//#define CLK33_370UDMA5    0x1a85f442
#define CLK33_370UDMA5   (CLK33_UDMACMD370|UDMA_CYCLE370(1)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH(1))
**/

/*
 * 366-368 timing 
 */

#define DATA_HIGH(x)  ((ULONG)x)
#define DATA_LOW(x)   ((ULONG)x << 4)
#define UDMA_CYCLE(x) ((ULONG)x << 16)
#define DATA_PRE(x)   ((ULONG)x << 19)
#define CTRL_ENA(x)   ((ULONG)x << 28)

#define CMD_HIGH(x)   ((ULONG)x << 8)
#define CMD_LOW(x)    ((ULONG)x << 12)
#define CMD_PRE(x)    ((ULONG)x << 22)

#define PIO_366MODE   8
#define DMA_366MODE   0xa
#define UDMA_366MODE  9

#define CLK33_PIOCMD  (CTRL_ENA(PIO_366MODE)|CMD_PRE(3)|CMD_LOW(10)|CMD_HIGH(7))
#define CLK33_366PIO0    (CLK33_PIOCMD|DATA_PRE(2)|DATA_LOW(10)|DATA_HIGH(10))
#define CLK33_366PIO1    (CLK33_PIOCMD|DATA_PRE(2)|DATA_LOW(10)|DATA_HIGH(3))
#define CLK33_366PIO2    (CLK33_PIOCMD|DATA_PRE(1)|DATA_LOW(5)|DATA_HIGH(3))
#define CLK33_366PIO3    (CLK33_PIOCMD|DATA_PRE(1)|DATA_LOW(4)|DATA_HIGH(2))
#define CLK33_366PIO4    (CLK33_PIOCMD|DATA_PRE(1)|DATA_LOW(3)|DATA_HIGH(1))

#define CLK33_DMACMD  (CTRL_ENA(DMA_366MODE)|CMD_PRE(3)|CMD_LOW(10)|CMD_HIGH(7))
#define CLK33_366DMA0    (CLK33_DMACMD|DATA_PRE(1)|DATA_LOW(9)|DATA_HIGH(7))
#define CLK33_366DMA1    (CLK33_DMACMD|DATA_PRE(1)|DATA_LOW(3)|DATA_HIGH(2))
#define CLK33_366DMA2    (CLK33_DMACMD|DATA_PRE(1)|DATA_LOW(3)|DATA_HIGH(1))

#define CLK33_UDMACMD (CTRL_ENA(UDMA_366MODE)|CMD_PRE(3)|CMD_LOW(10)|CMD_HIGH(7))
#define CLK33_366UDMA0   (CLK33_UDMACMD|UDMA_CYCLE(0)|DATA_PRE(1)|DATA_LOW(5)|DATA_HIGH(3))
#define CLK33_366UDMA1   (CLK33_UDMACMD|UDMA_CYCLE(3)|DATA_PRE(1)|DATA_LOW(4)|DATA_HIGH(2))
#define CLK33_366UDMA2   (CLK33_UDMACMD|UDMA_CYCLE(2)|DATA_PRE(1)|DATA_LOW(3)|DATA_HIGH(1))
#define CLK33_366UDMA3   (CLK33_UDMACMD|UDMA_CYCLE(7)|DATA_PRE(1)|DATA_LOW(3)|DATA_HIGH(1))
#define CLK33_366UDMA4   (CLK33_UDMACMD|UDMA_CYCLE(1)|DATA_PRE(1)|DATA_LOW(3)|DATA_HIGH(1))


#include <poppack.h>
#endif //_HPTCHIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\hsutil.c ===
/***************************************************************************
 * File:          hsutil.c
 * Description:   This module include the system functions for NT device
 *				  drivers, These functions is OS dependent.
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/08/2000	HS.Zhang	Added this header
 *		2/16/2001	gmm			modify PrepareForNotification() call
 *
 ***************************************************************************/
#ifndef	WIN95				  

#include <ntddk.h>

BOOLEAN g_bNotifyEvent = FALSE;

HANDLE PrepareForNotification(HANDLE hEvent)
{
	g_bNotifyEvent = FALSE;
	return (HANDLE)&g_bNotifyEvent;
}

void NotifyApplication(HANDLE hEvent)
{
	*(BOOLEAN *)hEvent = TRUE;
}

void CloseNotifyEventHandle(HANDLE hEvent)
{						
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\global.h ===
/***************************************************************************
 * File:          Global.h
 * Description:   This file include major constant definition and global
 *                functions and data.
 *                (1) Array Information in disk.
 *                (2) Srb Extension for array operation 
 *                (3) Virtual disk informatiom
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		05/10/2000	DH.Huang	initial code
 *		11/06/2000	HS.Zhang	change the parameter in IdeHardReset
 *								routin.
 *		11/09/2000	GengXin(GX) add function declare for display flash
 *                              character in biosinit.c
 *		11/14/2000	HS.Zhang	Change the FindDevice function's
 *								Arguments
 ***************************************************************************/


#ifndef _GLOBAL_H_
#define _GLOBAL_H_

/***************************************************************************
 * Description: Function Selection
 ***************************************************************************/

#define USE_MULTIPLE           // Support Read/Write Multiple command
#define USE_DMA                // Support DMA operation
#define SUPPORT_ARRAY          // Support Array Function


/***************************************************************************
 * Description: 
 ***************************************************************************/

#define MAX_MEMBERS       7    // Maximum members in an array 

#define MAX_HPT_BOARD     2    // Max Board we can supported in system
#define MAX_ADAPTERS      (MAX_HPT_BOARD * 2) // Each board has two channels
#define MAX_DEVICES       (MAX_HPT_BOARD * 4) // Each board has four device

#define MAX_V_DEVICE   6

#define DEFAULT_TIMING    0	 // Use Mode-0 as default timing

/************************************************************************
**                  Constat definition                                  *
*************************************************************************/

#define TRUE             1
#define FALSE            0
#define SUCCESS          0
#define FAILED          -1

/* pasrameter for MaptoSingle */
#define REMOVE_TMP        0    // Remove this array temp
#define REMOVE_ARRAY      1    // Remove this array forever
#define REMOVE_DISK       2    // Remove mirror disk from the array

/* return for CreateArray */
#define RELEASE_TABLE     0	 // Create array success and release array table
#define KEEP_TABLE        1    // Create array success and keep array table
#define MIRROR_SMALL_SIZE 2    // Create array failure and release array table

/* excluded_flags */
#define EXCLUDE_HPT366    0
#define EXCLUDE_BUFFER    15

/***************************************************************************
 * Description: include
 ***************************************************************************/

#include  "ver.h"
#ifdef _BIOS_
#include  "fordos.h"
#define DisableBoardInterrupt(x) 
#define EnableBoardInterrupt(x)	
#else
#include  "forwin.h" 
#define DisableBoardInterrupt(x) OutPort(x+0x7A, 0x10)
#define EnableBoardInterrupt(x)	OutPort(x+0x7A, 0x0)
#endif

/***************************************************************************
 * Global Data
 ***************************************************************************/

/* see data.c */

extern ULONG setting370_50[];
extern ULONG setting370_33[];
extern ULONG setting366[];
extern PVirtualDevice  pLastVD;
extern UINT  Hpt_Slot;
extern UINT  Hpt_Bus;
extern UINT exlude_num;

/***************************************************************************
 * Function prototype
 ***************************************************************************/


/*
 * ata.c 
 */
BOOLEAN AtaPioInterrupt(PDevice pDevice);
void StartIdeCommand(PDevice pDevice DECL_SRB);
void NewIdeCommand(PDevice pDevice DECL_SRB);
void NewIdeIoCommand(PDevice pDevice DECL_SRB);

/* atapi.c */
void AtapiCommandPhase(PDevice pDevice DECL_SRB);
void StartAtapiCommand(PDevice pDevice DECL_SRB);
void AtapiInterrupt(PDevice pDev);

/* finddev.c */
/*
 *Changed By HS.Zhang
 *Added a parameter for windows driver dma settings
 */
int FindDevice(PDevice pDev, ST_XFER_TYPE_SETTING osAllowedDeviceXferMode);

/*
 * io.c
 */
UCHAR WaitOnBusy(PIDE_REGISTERS_2 BaseIoAddress) ;
UCHAR  WaitOnBaseBusy(PIDE_REGISTERS_1 BaseIoAddress);
UCHAR WaitForDrq(PIDE_REGISTERS_2 BaseIoAddress) ;
void AtapiSoftReset(PIDE_REGISTERS_1 BaseIoAddress, 
     PIDE_REGISTERS_2 BaseIoAddress2, UCHAR DeviceNumber) ;
/*
 * Changed by HS.Zhang
 * It's better that we check the DriveSelect register in reset flow.
 * That will make the reset process more safe.
 * 
 * int  IdeHardReset(PIDE_REGISTERS_1 IoAddr1, PIDE_REGISTERS_2 BaseIoAddress);
 */

int  IdeHardReset(PIDE_REGISTERS_2 BaseIoAddress);

UINT GetMediaStatus(PDevice pDev);
UCHAR NonIoAtaCmd(PDevice pDev, UCHAR cmd);
UCHAR SetAtaCmd(PDevice pDev, UCHAR cmd);
int ReadWrite(PDevice pDev, ULONG Lba, UCHAR Cmd DECL_BUFFER);
UCHAR StringCmp (PUCHAR FirstStr, PUCHAR SecondStr, UINT Count);
int IssueIdentify(PDevice pDev, UCHAR Cmd DECL_BUFFER);
void DeviceSelectMode(PDevice pDev, UCHAR NewMode);
void SetDevice(PDevice pDev);
void IdeResetController(PChannel pChan);
void Prepare_Shutdown(PDevice pDev);
void DeviceSetting(PChannel pChan, ULONG devID);
void ArraySetting(PVirtualDevice pArray);

/*
 * hptchip.c
 */
UCHAR Check_suppurt_Ata100(PDevice pDev, UCHAR mode);
PBadModeList check_bad_disk(char *ModelNumber, PChannel pChan);
PUCHAR ScanHptChip(IN PChannel deviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo);
void SetHptChip(PChannel Primary, PUCHAR BMI);


/* array.c */
BOOLEAN ArrayInterrupt(PDevice pDev);
void StartArrayIo(PVirtualDevice pArray DECL_SRB);
void CheckArray(IN PDevice pDevice);
void MaptoSingle(PVirtualDevice pArray, int flag) ;
void DeleteArray(PVirtualDevice pArray);
int  CreateArray(PVirtualDevice pArray, int flags);
void CreateSpare(PVirtualDevice pArray, PDevice pDev);
void Final_Array_Check();
void AdjustRAID10Array(PVirtualDevice pArray);
PVirtualDevice Array_alloc();
void Array_free(PVirtualDevice pArray);
PVirtualDevice CreateRAID10(PVirtualDevice FAR* pArrays, BYTE nArray, BYTE nBlockSizeShift);
void DeleteRAID10(PVirtualDevice pArray);

/* stripe.c */
void Stripe_SG_Table(PDevice pDevice, PSCAT_GATH p DECL_SRBEXT_PTR);
void Stripe_Prepare(PVirtualDevice pArray DECL_SRBEXT_PTR);
void Stripe_Lba_Sectors(PDevice pDevice DECL_SRBEXT_PTR);

/* span.c */
void Span_SG_Table(PDevice pDevice, PSCAT_GATH p DECL_SRBEXT_PTR);
void Span_Prepare(PVirtualDevice pArray DECL_SRBEXT_PTR);
void Span_Lba_Sectors(PDevice pDevice DECL_SRBEXT_PTR);


/*  interrupt.c */
UCHAR DeviceInterrupt(PDevice pDev, UINT flags);

/* OS Functions */
int   BuildSgl(PDevice pDev, PSCAT_GATH p DECL_SRB);
UCHAR MapAtaErrorToOsError(UCHAR errorcode DECL_SRB);
UCHAR MapAtapiErrorToOsError(UCHAR errorcode DECL_SRB);
BOOLEAN Atapi_End_Interrupt(PDevice pDevice DECL_SRB);

/*  biosutil.c */
//Add by GX, for display character in biosinit.c
void GD_Text_show_EnableFlash( int x, int y,char * szStr, int width, int color );

/* Minimum and maximum macros */
#define MAX(a, b)	(((a) > (b)) ? (a) : (b))
#define MIN(a, b)	(((a) < (b)) ? (a) : (b))  

/***************************************************************************
 * Define for beatufy
 ***************************************************************************/

#define GetStatus(IOPort2)           (UCHAR)InPort(&IOPort2->AlternateStatus)
#define UnitControl(IOPort2, Value)  OutPort(&IOPort2->AlternateStatus,(UCHAR)(Value))

#define GetErrorCode(IOPort)         (UCHAR)InPort((PUCHAR)&IOPort->Data+1)
#define SetFeaturePort(IOPort,x)     OutPort((PUCHAR)&IOPort->Data+1, x)
#define SetBlockCount(IOPort,x)      OutPort(&IOPort->BlockCount, x)
#define GetInterruptReason(IOPort)   (UCHAR)InPort(&IOPort->BlockCount)
#define SetBlockNumber(IOPort,x)     OutPort(&IOPort->BlockNumber, x)
#define GetBlockNumber(IOPort)       (UCHAR)InPort((PUCHAR)&IOPort->BlockNumber)
#define GetByteLow(IOPort)           (UCHAR)InPort(&IOPort->CylinderLow)
#define SetCylinderLow(IOPort,x)         OutPort(&IOPort->CylinderLow, x)
#define GetByteHigh(IOPort)          (UCHAR)InPort(&IOPort->CylinderHigh)
#define SetCylinderHigh(IOPort,x)    OutPort(&IOPort->CylinderHigh, x)
#define GetBaseStatus(IOPort)        (UCHAR)InPort(&IOPort->Command)
#define SelectUnit(IOPort,UnitId)    OutPort(&IOPort->DriveSelect, (UCHAR)(UnitId))
#define GetCurrentSelectedUnit(IOPort) (UCHAR)InPort(&IOPort->DriveSelect)
#define IssueCommand(IOPort,Cmd)     OutPort(&IOPort->Command, (UCHAR)Cmd)

/******************************************************************
 * Reset IDE
 *******************************************************************/
#ifndef NOT_ISSUE_37
#ifdef  ISSUE_37_ONLY
#define Reset370IdeEngine(pChan) if(pChan->ChannelFlags & IS_HPT_370) \
								 OutPort(pChan->BMI + (((UINT)pChan->BMI & 0xF)? 0x6C : 0x70), 0x37);
#else //ISSUE_37_ONLY
void __inline Reset370IdeEngine(PChannel pChan)
{
	if(pChan->ChannelFlags & IS_HPT_370) {
		PUCHAR tmpBMI = pChan->BMI + (((UINT)pChan->BMI & 0xF)? 0x6C : 0x70);
		PUCHAR tmpBaseBMI = pChan->BaseBMI+0x79;
		OutPort(tmpBMI+3, 0x80);
		OutPort(tmpBaseBMI, (UCHAR)(((UINT)tmpBMI & 0xF)? 0x80 : 0x40));
		OutPort(tmpBMI, 0x37);
		OutPort(tmpBaseBMI, 0);
		OutPort(tmpBMI+3, 0);
	}		
}

#endif //ISSUE_37_ONLY

void __inline Switching370Clock(PChannel pChan, UCHAR ucClockValue)
{
	if(pChan->ChannelFlags & IS_HPT_370){
		if((InPort(pChan->NextChannelBMI + BMI_STS) & BMI_STS_ACTIVE) == 0){
			PUCHAR PrimaryMiscCtrlRegister = pChan->BaseBMI + 0x70;
			PUCHAR SecondaryMiscCtrlRegister = pChan->BaseBMI + 0x74;

			OutPort(PrimaryMiscCtrlRegister+3, 0x80); // tri-state the primary channel
			OutPort(SecondaryMiscCtrlRegister+3, 0x80); // tri-state the secondary channel
			
			OutPort((PUCHAR)((ULONG)pChan->BaseBMI+0x7B), ucClockValue); // switching the clock
			
			OutPort((PUCHAR)((ULONG)pChan->BaseBMI+0x79), 0xC0); // reset two channels begin	  
			
			OutPort(PrimaryMiscCtrlRegister, 0x37); // reset primary channel state machine
			OutPort(SecondaryMiscCtrlRegister, 0x37); // reset secordary channel state machine

			OutPort((PUCHAR)((ULONG)pChan->BaseBMI+0x79), 0x00); // reset two channels finished
			
			OutPort(PrimaryMiscCtrlRegister+3, 0x00); // normal-state the primary channel
			OutPort(SecondaryMiscCtrlRegister+3, 0x00); // normal-state the secondary channel
		}
	}
}
#endif //NOT_ISSUE_37

// The timer counter used by function MonitorDisk(5000000us = 5000ms = 5s)
#define	MONTOR_TIMER_COUNT		5000000

#endif //_GLOBAL_H_




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\io.c ===
/***************************************************************************
 * File:          Global.h
 * Description:   Basic function for device I/O request.
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/06/2000	HS.Zhang	Changed the IdeHardReset flow
 *		11/08/2000	HS.Zhang	Added this header
 *	   11/28/2000  SC       add RAID 0+1 condition in "IdeHardReset"
 *                         during one of hard disk is removed
 ***************************************************************************/
#include "global.h"

/******************************************************************
 * Wait Device Busy off
 *******************************************************************/

UCHAR WaitOnBusy(PIDE_REGISTERS_2 BaseIoAddress) 
{ 
	UCHAR Status;
	ULONG i; 

	for (i=0; i<20000; i++) { 
		Status = GetStatus(BaseIoAddress); 
		if ((Status & IDE_STATUS_BUSY) == 0 || Status == 0xFF) 
			break;
		StallExec(150); 
	} 
	return(Status);
}

/******************************************************************
 * Wait Device Busy off (Read status from base port)
 *******************************************************************/

UCHAR  WaitOnBaseBusy(PIDE_REGISTERS_1 BaseIoAddress) 
{ 
	UCHAR Status;
	ULONG i; 

	for (i=0; i<20000; i++) { 
		Status = GetBaseStatus(BaseIoAddress); 
		if ((Status & IDE_STATUS_BUSY)  == 0)
			break;
		StallExec(150); 
	}
	return(Status); 
}

/******************************************************************
 * Wait Device DRQ on
 *******************************************************************/

UCHAR WaitForDrq(PIDE_REGISTERS_2 BaseIoAddress) 
{ 
	UCHAR Status;
	int  i; 

	for (i=0; i<1000; i++) { 
		Status = GetStatus(BaseIoAddress); 
		if ((Status & (IDE_STATUS_BUSY | IDE_STATUS_DRQ)) == IDE_STATUS_DRQ)
			break; 
		StallExec(150); 
	} 
	return(Status);
}


/******************************************************************
 * Reset Atapi Device
 *******************************************************************/

void AtapiSoftReset(
					PIDE_REGISTERS_1 IoPort, 
					PIDE_REGISTERS_2 ControlPort, 
					UCHAR DeviceNumber) 
{
	SelectUnit(IoPort,DeviceNumber); 
	StallExec(500);
	IssueCommand(IoPort, IDE_COMMAND_ATAPI_RESET); 
	StallExec((ULONG)1000000);
	SelectUnit(IoPort,DeviceNumber); 
	WaitOnBusy(ControlPort); 
	StallExec(500);
}

/******************************************************************
 * Reset IDE Channel
 *******************************************************************/

int IdeHardReset(
    PIDE_REGISTERS_2 ControlPort) 
{
    UCHAR statusByte;
    ULONG i;
	
    UnitControl(ControlPort,IDE_DC_RESET_CONTROLLER );
    StallExec(50000L);
    UnitControl(ControlPort,IDE_DC_REENABLE_CONTROLLER);
    for (i = 0; i < 1000000L; i++) {
        statusByte = GetStatus(ControlPort);
        if (statusByte != IDE_STATUS_IDLE && statusByte != 0x0) {
			
			/// 
			if((statusByte & 0x7e)== 0x7e || (statusByte & 0x40)== 0)
				return(FALSE);
			
            StallExec(50);
        } else {
            break;
        }
    }
    return((i == 1000000L)? FALSE : TRUE);
}

// mark out the new changes
//int IdeHardReset(	 
//				 PIDE_REGISTERS_1 DataPort,
//				 PIDE_REGISTERS_2 ControlPort) 
//{
//	UCHAR statusByte;
//	ULONG i;
//
//	UnitControl(ControlPort,IDE_DC_RESET_CONTROLLER|IDE_DC_DISABLE_INTERRUPTS );
//	StallExec(10);						// at lease delay 5us before clear the reset
//	UnitControl(ControlPort,IDE_DC_REENABLE_CONTROLLER);
//	StallExec(4*1000);					// at lease delay 2ms before polling status register
//
//	statusByte = 0xA0;
//	for( i = 0; i < 100; ){
//		SelectUnit(DataPort, statusByte);															   
//		/*
//		 * our adapter need a wait if no device connect on master,
//		 * the pull down resistance can't pull down the power at once. 
//		 */
//		StallExec(10);
//
//		if(GetCurrentSelectedUnit(DataPort) == statusByte){
//			break;
//		}
//		StallExec(1000);
//		i ++;
//		if(( i == 100)&&(statusByte == 0xA0)){
//			i = 0;
//			statusByte = 0xB0;
//		}
//	}
//
//	if(i == 100){
//		return FALSE;
//	}
//
//	for (i = 0; i < 1000000L; i++) {
//		statusByte = GetStatus(ControlPort);
//
//		/// add on 11/28/00
//      if((statusByte & 0x7e)== 0x7e && (statusByte & 0x40)== 0)
//                  return(FALSE);
//
//		if((statusByte == 0xFF)||(statusByte == 0x7F)){
//			return FALSE;
//		}
//
//		if(!(statusByte & IDE_STATUS_BUSY)){
//			break;
//		}else{
//			StallExec(50);
//		}
//	}
//	return (!(statusByte & IDE_STATUS_BUSY));
//}
///

/******************************************************************
 * IO ATA Command
 *******************************************************************/

int ReadWrite(PDevice pDev, ULONG Lba, UCHAR Cmd DECL_BUFFER)
{
	PChannel   pChan = pDev->pChannel;
	PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2  ControlPort = pChan->BaseIoAddress2;
	UCHAR      statusByte;
	UINT       i;
	PULONG     SettingPort;
	ULONG      OldSettings;

	// gmm: save old mode
	// if interrupt is enabled we will disable and then re-enable it
	//
	UCHAR old_mode = pDev->DeviceModeSetting;
	UCHAR intr_enabled = !(InPort(pChan->BaseBMI+0x7A) & 0x10);
	if (intr_enabled) DisableBoardInterrupt(pChan->BaseBMI);
	DeviceSelectMode(pDev, 0);
	//
	/*
	SettingPort = (PULONG)(pChan->BMI+ ((pDev->UnitId & 0x10)>> 2) + 0x60);
	OldSettings = InDWord(SettingPort);
	OutDWord(SettingPort, pChan->Setting[DEFAULT_TIMING]);
	*/
	
	SelectUnit(IoPort, pDev->UnitId);
	WaitOnBusy(ControlPort);

	if(pDev->DeviceFlags & DFLAGS_LBA) 
		Lba |= 0xE0000000;
	else 
		Lba = MapLbaToCHS(Lba, pDev->RealHeadXsect, pDev->RealSector);


	SetBlockCount(IoPort, 1);
	SetBlockNumber(IoPort, (UCHAR)(Lba & 0xFF));
	SetCylinderLow(IoPort, (UCHAR)((Lba >> 8) & 0xFF));
	SetCylinderHigh(IoPort,(UCHAR)((Lba >> 16) & 0xFF));
	SelectUnit(IoPort,(UCHAR)((Lba >> 24) | (pDev->UnitId)));

	WaitOnBusy(ControlPort);

	IssueCommand(IoPort, Cmd);

	for(i = 0; i < 5; i++)	{
		statusByte = WaitOnBusy(ControlPort);
		if((statusByte & (IDE_STATUS_BUSY | IDE_STATUS_ERROR)) == 0)
			goto check_drq;
	}
out:
	/* gmm:
	 *
	 */
	DeviceSelectMode(pDev, old_mode);
	if (intr_enabled) EnableBoardInterrupt(pChan->BaseBMI);
	//OutDWord(SettingPort, OldSettings);
	//-*/
	return(FALSE);

check_drq:
	if((statusByte & IDE_STATUS_DRQ) == 0) {
		statusByte = WaitForDrq(ControlPort);
		if((statusByte & IDE_STATUS_DRQ) == 0)	{
			GetBaseStatus(IoPort); //Clear interrupt
			goto out;
		}
	}
	GetBaseStatus(IoPort); //Clear interrupt

//	 if(pChan->ChannelFlags & IS_HPT_370)
//	     OutPort(pChan->BMI + (((UINT)pChan->BMI & 0xF)? 0x6C : 0x70), 0x25);

	if(Cmd == IDE_COMMAND_READ)
		RepINS(IoPort, (ADDRESS)tmpBuffer, 256);
	else
		RepOUTS(IoPort, (ADDRESS)tmpBuffer, 256);

	/* gmm:
	 *
	 */
	DeviceSelectMode(pDev, old_mode);
	if (intr_enabled) EnableBoardInterrupt(pChan->BaseBMI);
	// OutDWord(SettingPort, OldSettings);
	//-*/
	return(TRUE);
}


/******************************************************************
 * Non IO ATA Command
 *******************************************************************/

UCHAR NonIoAtaCmd(PDevice pDev, UCHAR cmd)
{
	PChannel   pChan = pDev->pChannel;
	PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
	UCHAR   state;

	SelectUnit(IoPort, pDev->UnitId);
	WaitOnBusy(pChan->BaseIoAddress2);
	IssueCommand(IoPort, cmd);
	StallExec(1000);
	WaitOnBusy(pChan->BaseIoAddress2);
	state = GetBaseStatus(IoPort);//clear interrupt
	OutPort(pChan->BMI + BMI_STS, BMI_STS_ERROR|BMI_STS_INTR);
	return state;
}


UCHAR SetAtaCmd(PDevice pDev, UCHAR cmd)
{
	PChannel   pChan = pDev->pChannel;
	PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
	UCHAR   state;

	IssueCommand(IoPort, cmd);
	StallExec(1000);
	WaitOnBusy(pChan->BaseIoAddress2);
	state = GetBaseStatus(IoPort);//clear interrupt
	OutPort(pChan->BMI + BMI_STS, BMI_STS_ERROR|BMI_STS_INTR);
	return state;
}

/******************************************************************
 * Get Media Status
 *******************************************************************/

UINT GetMediaStatus(PDevice pDev)
{
	return ((NonIoAtaCmd(pDev, IDE_COMMAND_GET_MEDIA_STATUS) << 8) | 
			GetErrorCode(pDev->pChannel->BaseIoAddress1));
}

/******************************************************************
 * Strncmp
 *******************************************************************/

UCHAR StringCmp (PUCHAR FirstStr, PUCHAR SecondStr, UINT Count )
{
	while(Count-- > 0) {
		if (*FirstStr++ != *SecondStr++) 
			return 1;
	}
	return 0;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\stypes.h ===
#ifndef __S_TYPES_H__
#define __S_TYPES_H__

/************************************************************************
**                  Type definition                                     *
*************************************************************************/

#ifdef _FORDOS_H_

	typedef unsigned char  UCHAR;
	typedef unsigned short USHORT;
	typedef unsigned long  ULONG;
	typedef unsigned long  LONG;
	typedef unsigned char  *PUCHAR;
	typedef unsigned short *PUSHORT;
	typedef unsigned long  *PULONG;
	typedef void           VOID;
	typedef UCHAR          BOOLEAN;
	
#else
	
	typedef unsigned long  DWORD;
	
#endif

typedef int            BOOL;
typedef unsigned short WORD;
typedef unsigned int   UINT;
typedef unsigned char  BYTE;
typedef unsigned char FAR *ADDRESS ;

#ifndef INVALID_HANDLE_VALUE
	#define INVALID_HANDLE_VALUE (HANDLE)-1
#endif		// INVALID_HANDLE_VALUE

#ifndef NULL
	#define NULL	(void*)0
#endif

#endif									// __S_TYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\stripe.c ===
#include "global.h"


/******************************************************************
 * Build the member's SG table
 *******************************************************************/

void Stripe_SG_Table(
    PDevice     pDevice,
    PSCAT_GATH  pArraySg
    DECL_SRBEXT_PTR)
{
    PVirtualDevice pArray = pDevice->pArray;
    UCHAR       Member = pDevice->ArrayNum;
    PSCAT_GATH  pDevSg = pDevice->pChannel->pSgTable;
    ULONG       sgSize, min, i, sgAddress;
    UCHAR       who;


    i = (ULONG)pSrbExt->FirstSectors << 9;
    who = pSrbExt->FirstMember;

    for ( ; ; ) {
        if(pArraySg->SgSize)
             sgSize = (ULONG)pArraySg->SgSize;
        else
             sgSize = 0x10000L;

        sgAddress = pArraySg->SgAddress;
        do {
            min = MIN(sgSize, i);
            if(who == Member) {
                 *(ULONG *)&pDevSg->SgSize = (ULONG)min;
                 pDevSg->SgAddress = sgAddress;
                 pDevSg++;
            }
            i -= min;
            sgSize -= min;
            sgAddress += min;
            if(i == 0) {
                 if((++who) == pArray->nDisk)
                      who = 0;
                 i = (ULONG)pArray->ArrayNumBlock << 9;
            }
        } while(sgSize);

        if(pArraySg->SgFlag == SG_FLAG_EOT)
            break;
        pArraySg++;
    } 

    pDevSg[-1].SgFlag = SG_FLAG_EOT;
}

/******************************************************************
 * Get Stripe disk LBA and sectors
 *******************************************************************/

void Stripe_Lba_Sectors(
    PDevice  pDevice
    DECL_SRBEXT_PTR)
{
    PVirtualDevice pArray = pDevice->pArray;
    PChannel  pChan = pDevice->pChannel;
    ULONG    Lba = pSrbExt->StartLBA;
    UCHAR    Member;
    UCHAR    Sectors = pSrbExt->AllMemberBlocks;

    Member = pDevice->ArrayNum;
    if(Member == pSrbExt->FirstMember)
         Lba += pSrbExt->FirstOffset;
    else if(Member < pSrbExt->FirstMember)
         Lba += pArray->ArrayNumBlock;

    if(Member == pSrbExt->FirstMember)
        Sectors += pSrbExt->FirstSectors;
    if(Member == pSrbExt->LastMember)
        Sectors += pSrbExt->LastSectors;

    if(pSrbExt->InSameLine) {
        if(Member > pSrbExt->FirstMember && 
            Member < pSrbExt->LastMember)
            goto add_blksz;
    } else {
        if(Member > pSrbExt->FirstMember)
            Sectors += pArray->ArrayNumBlock;
        if(Member < pSrbExt->LastMember)
add_blksz:
            Sectors += pArray->ArrayNumBlock;
    }
    pChan->nSector = Sectors;
    pChan->Lba = Lba;
}

/******************************************************************
 * Start Stripe Command
 *******************************************************************/

void Stripe_Prepare(PVirtualDevice pArray DECL_SRBEXT_PTR)
{
	  register PSrbExtension pSrbx = pSrbExt;
     ULONG  Lba = pSrbx->Lba;
     ULONG  BlksNum = LongRShift(Lba, pArray->BlockSizeShift);
     UCHAR  Sectors = pSrbx->nSector;
     UCHAR  i;

     pSrbx->AllMemberBlocks = 0;
     pSrbx->InSameLine = TRUE;
     pSrbx->StartLBA = LongDivLShift(BlksNum, pArray->nDisk, pArray->BlockSizeShift);
     i = pSrbx->FirstMember = (UCHAR)LongRem(BlksNum, pArray->nDisk);
     pSrbx->FirstOffset = ((UCHAR)Lba & (UCHAR)(pArray->ArrayNumBlock - 1));
     pSrbx->FirstSectors = pArray->ArrayNumBlock - pSrbx->FirstOffset;

     if(pSrbx->FirstSectors >= Sectors) {
         pSrbx->FirstSectors = Sectors;
         Sectors = 0;
         goto last_one;
     }
     Sectors -= pSrbx->FirstSectors;

     for ( ; ; ) {
         pSrbx->JoinMembers |= (1 << i);

         i++;
         if(i == pArray->nDisk) {
             i = 0;
             if(pSrbx->InSameLine)
                 pSrbx->InSameLine = FALSE;
             else
                 pSrbx->AllMemberBlocks += pArray->ArrayNumBlock;
         }

         if(Sectors <= pArray->ArrayNumBlock) {
last_one:
             pSrbx->JoinMembers |= (1 << i);
             pSrbx->LastMember = i;
             pSrbx->LastSectors = Sectors;
             break;
          }

          Sectors -= pArray->ArrayNumBlock;
     }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\ver.h ===
/* select one company !! */
#define HPT3XX
//#define IWILL_
//#define ABIT_
//#define ASHTON_
//#define JAPAN_

#ifdef  IWILL
#define COMPANY      "Iwill"
#define PRODUCT_NAME "SIDE RAID100 "
#define UTILITY      "ROMBSelect(TM) Utility"
#define WWW_ADDRESS  "www.iwill.net"
#define SHOW_LOGO
#endif

#ifdef HPT3XX
#define COMPANY      "HighPoint Technologies, Inc."
#define PRODUCT_NAME "HPT370 "
#define COPYRIGHT    "(c) 1999-2001. HighPoint Technologies, Inc." 
#define UTILITY      "BIOS Setting Utility"
#define WWW_ADDRESS  "www.highpoint-tech.com"
#define SHOW_LOGO
#endif

#ifdef JAPAN
#define COMPANY      "System TALKS Inc."
#define PRODUCT_NAME "UA-HD100C "
#define UTILITY      "UA-HD100C BIOS Settings Menu"
#define WWW_ADDRESS  "www.system-talks.co.jp"
#define SHOW_LOGO
#endif

#ifdef CENTOS
#define COMPANY      "         "
#define PRODUCT_NAME "CI-1520U10 "
#define UTILITY      "CI-1520U10 BIOS Settings Menu"
#define WWW_ADDRESS  "www.centos.com.tw"
#endif


#ifdef ASHTON
#define COMPANY      "Ashton Periperal Computer"
#define PRODUCT_NAME "In & Out "
#define UTILITY      "In & Out ATA-100 BIOS Settings Menu"
#define WWW_ADDRESS  "www.ashtondigital.com"
#endif


#ifndef VERSION_STR						// this version str macro can be defined in makefile
#define VERSION_STR ""
#endif									// VERSION_STR

#define VERSION    "v1.0.5"		// VERSION

#define BUILT_DATE __DATE__

/***************************************************************************
 * Description:  Version history
 ***************************************************************************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\span.c ===
#include "global.h"


/******************************************************************
 * Build the member's SG table
 *******************************************************************/

void Span_SG_Table(
    PDevice     pDevice,
    PSCAT_GATH  ArraySg
    DECL_SRBEXT_PTR)
{
    register PSCAT_GATH pArraySg = ArraySg;
    register PSCAT_GATH  pDevSg = pDevice->pChannel->pSgTable;
    ULONG    i;
    UINT     numSg = MAX_SG_DESCRIPTORS;

    if(pSrbExt->LastMember != 0xFF){
		
		i = (ULONG)pSrbExt->FirstSectors << 9;
		
		while(pArraySg->SgSize && i > (ULONG)pArraySg->SgSize) {
			if(pDevice->ArrayNum == pSrbExt->FirstMember){
				*pDevSg = *pArraySg;						  
				pDevSg++;
			}
			i -= (ULONG)pArraySg->SgSize;
			pArraySg++;
			numSg--;
		}

		if(pDevice->ArrayNum == pSrbExt->FirstMember) {
			pDevSg->SgAddress = pArraySg->SgAddress;
			pDevSg->SgSize = (USHORT)i;
			pDevSg->SgFlag = SG_FLAG_EOT;
			return;
		}
	  
		if((ULONG)pArraySg->SgSize > i) {
			pDevSg->SgAddress = pArraySg->SgAddress + i;
			pDevSg->SgSize = (USHORT)(pArraySg->SgSize - i);
			pDevSg->SgFlag = 0;
		}

		if(pArraySg->SgFlag == SG_FLAG_EOT){
			pDevSg->SgFlag = SG_FLAG_EOT;
			return;
		}
		
		pDevSg++;
		pArraySg++;
		numSg--;
	}
	
	MemoryCopy(pDevSg, pArraySg, numSg << 3);
}

/******************************************************************
 * Get Stripe disk LBA and sectors
 *******************************************************************/

void Span_Lba_Sectors(
    PDevice  pDevice
    DECL_SRBEXT_PTR)
{
    PVirtualDevice pArray = pDevice->pArray;
    PChannel  pChan = pDevice->pChannel;
    ULONG    Lba = pSrbExt->StartLBA;

    if(pDevice->ArrayNum == pSrbExt->FirstMember) {
        pChan->nSector = pSrbExt->FirstSectors ;
        pChan->Lba = pSrbExt->StartLBA;
    } else {
        pChan->nSector = pSrbExt->LastSectors;
        pChan->Lba = 0;
    }
}

/******************************************************************
 * Start Stripe Command
 *******************************************************************/

void Span_Prepare(PVirtualDevice pArray DECL_SRBEXT_PTR)
{
     register PSrbExtension pSrbx = pSrbExt;
     PDevice  pDev;
     ULONG    Lba = pSrbx->Lba, i;


     for (i = 0; i < pArray->nDisk; i++) {
         pDev = pArray->pDevice[i];
         if(Lba >= pDev->capacity) {
             Lba -= pDev->capacity;
             continue;
         }

         pSrbx->StartLBA = Lba;
         pSrbx->FirstMember = (UCHAR)i;

         pSrbx->JoinMembers |= (1 << i);
         if(Lba + pSrbx->nSector > pDev->capacity) {
				  pSrbx->LastMember = (UCHAR)(i + 1);
              pSrbx->JoinMembers |= (1 << (i + 1));
              pSrbx->FirstSectors = (UCHAR)(pDev->capacity - Lba);
              pSrbx->LastSectors = pSrbx->nSector - pSrbx->FirstSectors;
         } else {
              pSrbx->LastMember = 0xFF;
              pSrbx->FirstSectors =	pSrbx->nSector;
         }

         break;
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\ioctrl.c ===
/*++
Copyright (c) 1999, HighPoint Technologies, Inc.

Module Name:
	IoCtrl.c: Miniport I/O ctrl code dispatch routine

Abstract:

Author:
    HongSheng Zhang (HS)

Environment:
	Windows NT Kernel mode
Notes:

Revision History:
    12-07-99    Created initially
    11/08/2000	HS.Zhang	Updated the header information
	11/20/2000	SLeng		Added code to Enable/Disable a device
	11/23/2000  SLeng		Added code to add/del a spare disk to/from a mirror
	11/29/2000  SLeng		Added code to add a mirror disk to a mirror array
--*/
#include "global.h"	
#include "DevMgr.h"

#include "HptIoctl.h"                       // MINIPORT IOCTL code
#include "HptVer.h"
//#include "..\inc\hptenum.h"

/*++
 Function:
	 HptUtLockDeviceBlock
	 
 Description:
 	 Lock a block on harddisk to prevent the READ/WRITE operation on
 	 it, all READ/WRITE operation on this block will be hold in SRB
 	 queue.
 	 
 Argument:
	 pChannel - channel struct of the hard disk
	 nTarget - device id of the hard disk
	 nStartLbaAddress - the start LBA address want to be locked
	 nBlockSize - the block size

 Return:
	 ULONG SRB_STATUS
++*/  

ULONG
   HptUtLockDeviceBlock(
					  IN PChannel	pChannel,
					  IN ULONG		nTargetId,
					  IN ULONG		nStartLbaAddress,
					  IN ULONG		nBlockSize
					 )
{							  
	PDevice  pDevice;

	if(nTargetId > 1){
		return SRB_STATUS_INVALID_REQUEST;
	}									  

	pDevice = pChannel->pDevice[nTargetId];

	if(pDevice == NULL){
		return SRB_STATUS_SELECTION_TIMEOUT;
	}										
	
	if(pDevice->DeviceFlags & DFLAGS_HAS_LOCKED){
		// already present a locked block, return error
		return SRB_STATUS_INVALID_REQUEST;
	}									  

	pDevice->nLockedLbaStart = nStartLbaAddress;
	pDevice->nLockedLbaEnd = nStartLbaAddress + nBlockSize;

	pDevice->DeviceFlags |= DFLAGS_HAS_LOCKED;
	
	return SRB_STATUS_SUCCESS;
}	 

/*++
 Function:
	 HptUtUnlockDeviceBlock

 Description:
	 Unlock a block on hard disk which was locked previous to allow the
	 READ/WRITE operation on it again.

 Argument:
	 pChannel - channel struct of the hard disk
	 nTarget - device id of the hard disk
	 nStartLbaAddress - the start LBA address want to be unlocked
	 nBlockSize - the block size

 Return:
	 ULONG SRB_STATUS
++*/

ULONG
   HptUtUnlockDeviceBlock(
						  IN PChannel	pChannel,
						  IN ULONG		nTargetId,
						  IN ULONG		nStartLbaAddress,
						  IN ULONG		nBlockSize
						 )
{
	PDevice pDevice;

	if(nTargetId > 1){
		return SRB_STATUS_INVALID_REQUEST;
	}									  

	pDevice = pChannel->pDevice[nTargetId];

	if(pDevice == NULL){
		return SRB_STATUS_SELECTION_TIMEOUT;
	}										

	if((pDevice->nLockedLbaStart != nStartLbaAddress)&&
	   (pDevice->nLockedLbaEnd != nStartLbaAddress + nBlockSize)){

		return SRB_STATUS_INVALID_REQUEST;
	}									  

	pDevice->DeviceFlags &= ~DFLAGS_HAS_LOCKED;
	pDevice->nLockedLbaStart = -1;
	pDevice->nLockedLbaEnd = 0;

	return SRB_STATUS_SUCCESS;
}
/*++
Function:
    HptUtGetIdentifyData

Description:
    Get identify data for specify device

Arguments:
    HwDeviceExtension - HBA miniport driver's adapter data storage
	nTargetId - id for target device
	pIdentifyData - data buffer for store indentify data

Returns:
	ULONG	SRB_STATUS
--*/

ULONG
   HptUtGetIdentifyData(
						IN PChannel pChannel,				// HW_DEVICE_EXTENSION
						IN ULONG nTargetId,					// Id for target device
						OUT PSt_IDENTIFY_DATA	pIdentifyData // data buffer for store indentify data
					   )
{
	int i;
	WORD Tmp;

	PDevice pDev;
	PIDENTIFY_DATA2 pIdentifyOfDevice;
	//
	// Target id should only between 0 and 1
	//
	if(nTargetId > 1){
		return SRB_STATUS_INVALID_REQUEST;
	}

	pDev = pChannel->pDevice[nTargetId];

	if(pDev == NULL){
		return SRB_STATUS_SELECTION_TIMEOUT;
	}

	pIdentifyOfDevice = &pDev->IdentifyData;

	pIdentifyData->nNumberOfCylinders = pIdentifyOfDevice->NumberOfCylinders;
	pIdentifyData->nNumberOfHeads = pIdentifyOfDevice->NumberOfHeads;
	pIdentifyData->nSectorsPerTrack = pIdentifyOfDevice->SectorsPerTrack;
	pIdentifyData->nBytesPerSector = 512; // physical sector size
	pIdentifyData->nUserAddressableSectors = pIdentifyOfDevice->UserAddressableSectors;

	for(i = 0; i < 10; i++){																
		Tmp = pIdentifyOfDevice->SerialNumber[i];
		pIdentifyData->st20_SerialNumber[i*2 + 1] = (UCHAR)(Tmp);
		pIdentifyData->st20_SerialNumber[i*2] = (UCHAR)(Tmp >> 8);
	}

	for(i = 0; i < 4; i++){																
		Tmp = pIdentifyOfDevice->FirmwareRevision[i];
		pIdentifyData->st8_FirmwareRevision[i*2 + 1] = (UCHAR)(Tmp);
		pIdentifyData->st8_FirmwareRevision[i*2] = (UCHAR)(Tmp >> 8);
	}
	memcpy(&pIdentifyData->st40_ModelNumber,
		   pIdentifyOfDevice->ModelNumber,
		   sizeof(pIdentifyData->st40_ModelNumber));

	return SRB_STATUS_SUCCESS;
}

/*++
Function:
    HptUtGetRaidInfo

Description:
    Get RAID info stored on disk

Arguments:
    pChannel - channel relate info
	nTargetId - id for target device
	pDiskArrayInfo - data buffer for store disk array info

Note:
	To call this function, be sure the device is connected.
Returns:
	ULONG	SRB_STATUS
--*/
ULONG
   HptUtGetRaidInfo(
					IN PChannel pChannel,				// pChannel
					IN ULONG nTargetId,					// Id for target device
					OUT PSt_DISK_ARRAY_INFO	pDiskArrayInfo // data buffer for store disk array info
				   )
{	   
	PDevice	pDevSource, pDevTarget;
	PVirtualDevice pArraySource, pArrayTarget;
	

	pDevSource = pChannel->pDevice[nTargetId];							  

	memset(pDiskArrayInfo, 0, sizeof(St_DISK_ARRAY_INFO));

	if(pDevSource == NULL){
		return SRB_STATUS_INVALID_REQUEST;
	}

	pArraySource = pDevSource->pArray;

	if(pArraySource != NULL){
		
		pDiskArrayInfo->uliGroupNumber.LowPart = pArraySource->Stamp;
		pDiskArrayInfo->uliGroupNumber.HighPart = (ULONG)pArraySource;
		pDiskArrayInfo->nMemberCount = pArraySource->nDisk;
		
		pDiskArrayInfo->nCylinders = 0;
		pDiskArrayInfo->nHeads = 0;
		pDiskArrayInfo->nSectorsPerTrack = 0;
		pDiskArrayInfo->nBytesPerSector = 512;
		pDiskArrayInfo->nCapacity = pArraySource->capacity;

		switch(pArraySource->arrayType){
			case VD_SPAN:
			{	  
				pDiskArrayInfo->nDiskSets = pDevSource->ArrayNum + 4;
			}
			break;
			case VD_RAID_0_STRIPE:
			{
				pDiskArrayInfo->nDiskSets = pDevSource->ArrayNum * 2;
			}
			break;
			case VD_RAID_01_2STRIPE:
			{													  
				pDevTarget = pArraySource->pDevice[MIRROR_DISK];
				if(pDevTarget != NULL){
					pArrayTarget = pDevTarget->pArray;
					pDiskArrayInfo->nMemberCount = pArraySource->nDisk + pArrayTarget->nDisk;
				}else{		 
					pDiskArrayInfo->nMemberCount = pArraySource->nDisk;
				}
				pDiskArrayInfo->nDiskSets = pDevSource->ArrayNum * 2;
			}
			break;

			case VD_RAID_1_MIRROR:						   
			{
				pDiskArrayInfo->nMemberCount = 2;
				if(pDevSource->ArrayNum == MIRROR_DISK){
					pDiskArrayInfo->nDiskSets = 1;
				}else if(pDevSource->ArrayNum == SPARE_DISK){
					pDiskArrayInfo->nDiskSets = 7;
				}else{
					pDiskArrayInfo->nDiskSets = 0;
				}
			}
			break;

			case VD_RAID01_MIRROR:
			{
				pDevTarget = pArraySource->pDevice[MIRROR_DISK];
				if(pDevTarget != NULL){
					pArrayTarget = pDevTarget->pArray;
					pDiskArrayInfo->nMemberCount = pArraySource->nDisk + pArrayTarget->nDisk;
					pDiskArrayInfo->uliGroupNumber.LowPart = pArrayTarget->Stamp;
					pDiskArrayInfo->uliGroupNumber.HighPart = (ULONG)pArrayTarget;
					pDiskArrayInfo->nDiskSets = (pDevSource->ArrayNum * 2) + 1;
				}else{		 
					pDiskArrayInfo->uliGroupNumber.LowPart = pArraySource->Stamp;
					pDiskArrayInfo->uliGroupNumber.HighPart = (ULONG)pArraySource;
					pDiskArrayInfo->nMemberCount = pArraySource->nDisk;
					pDiskArrayInfo->nDiskSets = pDevSource->ArrayNum * 2;
				}
			}
			break;

			case VD_RAID_01_1STRIPE:
			{
				pDevTarget = pArraySource->pDevice[MIRROR_DISK];
				if(pDevTarget != NULL){
					pArrayTarget = pDevTarget->pArray;
					pDiskArrayInfo->nMemberCount = pArraySource->nDisk + 1;
					pDiskArrayInfo->uliGroupNumber.LowPart = pArrayTarget->Stamp;
					pDiskArrayInfo->uliGroupNumber.HighPart = (ULONG)pArrayTarget;
					if(pDevSource == pDevTarget){
						pDiskArrayInfo->nDiskSets = 1;
					}else{
						pDiskArrayInfo->nDiskSets = pDevSource->ArrayNum * 2;
					}
				}else{		 
					pDiskArrayInfo->uliGroupNumber.LowPart = pArraySource->Stamp;
					pDiskArrayInfo->uliGroupNumber.HighPart = (ULONG)pArraySource;
					pDiskArrayInfo->nMemberCount = pArraySource->nDisk;
					pDiskArrayInfo->nDiskSets = pDevSource->ArrayNum * 2;
				}
			}
			break;

			default:
				memset(pDiskArrayInfo, 0, sizeof(St_DISK_ARRAY_INFO));
				break;
		}
	}

	return SRB_STATUS_SUCCESS;
}

/*++
Function:
    HptUtFillPhysicalInfo

Description:
    Fill the physical device specified by "nTargetId" to buffer "pPhysDevInfo"

Arguments:
	pChannel - channal related data
	nTargetId - id for target device
	pPhysDevInfo - data buffer for store disk physical info

Note:

Returns:
	ULONG	SRB_STATUS
--*/		  
ULONG
   HptUtFillPhysicalInfo(
						 IN PChannel	pChannel,				// pChannel data
						 IN ULONG	nTargetId,				// Id for target device
						 OUT PSt_PHYSICAL_DEVINFO	pPhysDevInfo // data buffer for store the array
						)
{ 

	pPhysDevInfo->nSize = sizeof(St_PHYSICAL_DEVINFO);

	//
	// Fill the identify info
	//
	HptUtGetIdentifyData(pChannel,
						 nTargetId,
						 &pPhysDevInfo->IdentifyData);

	//
	// Fill the capability data structure
	//
	pPhysDevInfo->CapabilityData.DeviceType = DEVTYPE_DIRECT_ACCESS_DEVICE;
	if(pChannel->pDevice[nTargetId]->DeviceFlags & DFLAGS_REMOVABLE_DRIVE){
		pPhysDevInfo->CapabilityData.RemovableMedia = 1;
	}

	//
	// Fill the RAID info
	//
	HptUtGetRaidInfo(pChannel,
					 nTargetId,
					 &pPhysDevInfo->DiskArrayInfo);

	return SRB_STATUS_SUCCESS;

}						  

ULONG
   HptUtGetLastError(
					 IN PChannel pChannel,
					 IN ULONG nTargetId,
					 OUT PSt_HPT_ERROR_RECORD pErrorRecord
					)
{
	PDevice	pDev;
	
	memset(pErrorRecord, 0, sizeof(St_HPT_ERROR_RECORD));
	
	pDev = pChannel->pDevice[nTargetId];

	pErrorRecord->nLastError = pDev->stErrorLog.nLastError;
	
	return SRB_STATUS_SUCCESS;
}
/*
 * HptUtGetLastErrorDevice
 * this function check and return the device which occurs error most
 * recently, and return the CDB code in pDeviceErrorRecord stucture.
 */																	
ULONG
   HptUtGetLastErrorDevice(
						   IN	PHW_DEVICE_EXTENSION	pHwDeviceExtension,
						   OUT	PSt_DiskFailure	pDeviceErrorRecord
						  )
{		
	PDevice	*ppErrorDevice;
	memset(pDeviceErrorRecord, 0, sizeof(St_DiskFailure));
						 
	ppErrorDevice = &pHwDeviceExtension->m_pErrorDevice;
	if(*ppErrorDevice == NULL){
		pDeviceErrorRecord->hDisk = INVALID_HANDLE_VALUE;
	}else{
		memcpy(&pDeviceErrorRecord->vecCDB, &(*ppErrorDevice)->stErrorLog.Cdb, sizeof(pDeviceErrorRecord->vecCDB));
		pDeviceErrorRecord->hDisk = Device_GetHandle(*ppErrorDevice);

/////////////// Added by SLeng
		if((*ppErrorDevice)->stErrorLog.nLastError == DEVICE_PLUGGED)
		{
			pDeviceErrorRecord->HotPlug = 0x01;
		}
///////////////

		if((*ppErrorDevice)->pArray != NULL){
			pDeviceErrorRecord->bNeedRebuild = (((*ppErrorDevice)->pArray->RaidFlags & RAID_FLAGS_NEED_REBUILD) != 0);
			//(*ppErrorDevice)->pArray->RaidFlags &= ~RAID_FLAGS_NEED_REBUILD;
		}

		*ppErrorDevice = (*ppErrorDevice)->stErrorLog.pNextErrorDevice;
	}
	
	return SRB_STATUS_SUCCESS;
}

/*++
Function:
    ULONG   HptIsValidDeviceSpecifiedIoControl

Description:
	Check the Srb is whether a device specified IO control, if so,
	update the SRB data field to correct value.

Arguments:
    Srb - IO request packet

Returns:
	TRUE:	is a vaild device specified IO control
	FALSE:	not a vaild device specified IO control
--*/
												   
BOOLEAN
   HptIsValidDeviceSpecifiedIoControl(IN PSCSI_REQUEST_BLOCK pSrb)
{
	PSt_HPT_LUN	pLun;
	PSrbExtension pSrbExt;

	PSRB_IO_CONTROL pSrbIoCtl = (PSRB_IO_CONTROL)(pSrb->DataBuffer);
	pLun = (PSt_HPT_LUN)(pSrbIoCtl + 1);

	if((pSrbIoCtl->ControlCode == IOCTL_HPT_MINIPORT_EXECUTE_CDB)||
	   (pSrbIoCtl->ControlCode == IOCTL_HPT_MINIPORT_SCSI_PASSTHROUGH)){

		pSrbExt = (PSrbExtension)pSrb->SrbExtension;

		pSrbExt->OriginalPathId = pSrb->PathId;
		pSrbExt->OriginalTargetId = pSrb->TargetId;
		pSrbExt->OriginalLun = pSrb->Lun;
		
		pSrb->PathId = (CHAR)(pLun->nPathId);
		pSrb->TargetId = (CHAR)(pLun->nTargetId);
		pSrb->Lun = (CHAR)(pLun->nLun);
		
		return TRUE;
	}
	return FALSE;
}

/*
 * HptDeviceExecuteCDBCallBack
 * 
 * This call back routine will be called before call
 * ScsiPortNotification with RequestComplete notification. these
 * protocol let device driver can restore the change of SRB it make
 * before the system refer it again
 */								   
void HptDeviceExecuteCDBCallBack( IN PHW_DEVICE_EXTENSION pHwDeviceExtension,
								  IN PSCSI_REQUEST_BLOCK pSrb)
{
	PSrbExtension pSrbExt;
	PULONG	pSource;
	PULONG	pTarget;

	// we assume the data transfer lenght should be a multiple of ULONG
	ULONG	nLength = pSrb->DataTransferLength;
	pSource = (PULONG)pSrb->DataBuffer;
	pTarget = (PULONG)(((PCHAR)pSrb->DataBuffer)+
					   sizeof(SRB_IO_CONTROL)+
					   sizeof(St_HPT_LUN)+
					   sizeof(St_HPT_EXECUTE_CDB));
	if(pSrb->SrbFlags & SRB_FLAGS_DATA_IN){
		_asm{
			pushf;
			pusha;
			mov		esi, pSource;
			mov		edi, pTarget;
			mov		ecx, nLength;
			mov		ebx, ecx;

			add		esi, ecx;
			add		edi, ecx;
			sub		esi, 4;
			sub		edi, 4;
			shr		ecx, 2;
			std;
			rep		movsd;
			mov		ecx, ebx;
			and		ecx, 3;
			std;
			rep		movsb;

			popa;
			popf;
		}									   
	}

	pSrb->DataTransferLength += sizeof(SRB_IO_CONTROL) + sizeof(St_HPT_LUN) + sizeof(St_HPT_EXECUTE_CDB);
	
	pSrbExt = (PSrbExtension)pSrb->SrbExtension;
	pSrb->PathId = pSrbExt->OriginalPathId;
	pSrb->TargetId = pSrbExt->OriginalTargetId;
	pSrb->Lun = pSrbExt->OriginalLun;
}
/*++
Function:
    VOID   HptDeviceSpecifiedIoControl

Description:
    Process private device specified IO controls sent down directly
    from an application, the device specified IO controls mean the IO
    control need a device to work, just like CDB_EXECUTE

Arguments:
    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Returns:
    SRB_STATUS_SUCCESS if the IO control supported
    SRB_STATUS_INVALID_REQUEST if the IO control not supported
--*/
VOID
   HptDeviceSpecifiedIoControl(
							   IN PDevice pDevice,
							   IN PSCSI_REQUEST_BLOCK pSrb
							  )
{
	PSt_HPT_LUN	pLun;
	PSrbExtension pSrbExtension;
	
	PSRB_IO_CONTROL pSrbIoCtl = (PSRB_IO_CONTROL)(pSrb->DataBuffer);
	pLun = (PSt_HPT_LUN)(pSrbIoCtl + 1);


	pSrbExtension = (PSrbExtension)pSrb->SrbExtension;

	switch(pSrbIoCtl->ControlCode){
		case IOCTL_HPT_MINIPORT_EXECUTE_CDB:
		{					  
			PSt_HPT_EXECUTE_CDB	pExecuteCdb;
			pExecuteCdb = (PSt_HPT_EXECUTE_CDB)(pLun + 1);
			
			pSrbExtension->WorkingFlags |= SRB_WFLAGS_IGNORE_ARRAY|SRB_WFLAGS_HAS_CALL_BACK|SRB_WFLAGS_MUST_DONE;

			pSrb->CdbLength = pExecuteCdb->CdbLength;
			
			memcpy(&pSrb->Cdb, &pExecuteCdb->Cdb, pExecuteCdb->CdbLength);

			pSrb->DataTransferLength -= sizeof(SRB_IO_CONTROL) + sizeof(St_HPT_LUN) + sizeof(St_HPT_EXECUTE_CDB);

			if(pExecuteCdb->OperationFlags & OPERATION_FLAGS_DATA_IN){
				pSrb->SrbFlags = (pSrb->SrbFlags & ~SRB_FLAGS_DATA_OUT) | SRB_FLAGS_DATA_IN;
			}else{
				pSrb->SrbFlags = (pSrb->SrbFlags & ~SRB_FLAGS_DATA_IN) | SRB_FLAGS_DATA_OUT;
				memcpy(pSrb->DataBuffer, (pExecuteCdb + 1), pSrb->DataTransferLength);
			}															  
			
			pSrbExtension->pfnCallBack = HptDeviceExecuteCDBCallBack;
		}
		break;

		case IOCTL_HPT_MINIPORT_SCSI_PASSTHROUGH:
		{	  
			PSt_HPT_EXECUTE_CDB pExecuteCdb;
			pExecuteCdb = (PSt_HPT_EXECUTE_CDB)(pLun + 1);
			pSrbExtension->WorkingFlags |= SRB_WFLAGS_HAS_CALL_BACK|SRB_WFLAGS_MUST_DONE;

			pSrb->CdbLength = pExecuteCdb->CdbLength;
			
			if(pExecuteCdb->OperationFlags & OPERATION_FLAGS_ON_MIRROR_DISK){
				pSrbExtension->WorkingFlags |= SRB_WFLAGS_ON_MIRROR_DISK;
			}
			if(pExecuteCdb->OperationFlags & OPERATION_FLAGS_ON_SOURCE_DISK){
				pSrbExtension->WorkingFlags |= SRB_WFLAGS_ON_SOURCE_DISK;
			}

			memcpy(&pSrb->Cdb, &pExecuteCdb->Cdb, pExecuteCdb->CdbLength);

			pSrb->DataTransferLength -= sizeof(SRB_IO_CONTROL) + sizeof(St_HPT_LUN) + sizeof(St_HPT_EXECUTE_CDB);
			
			if(pExecuteCdb->OperationFlags & OPERATION_FLAGS_DATA_IN){
				pSrb->SrbFlags = (pSrb->SrbFlags & ~SRB_FLAGS_DATA_OUT) | SRB_FLAGS_DATA_IN;
			}else{
				pSrb->SrbFlags = (pSrb->SrbFlags & ~SRB_FLAGS_DATA_IN) | SRB_FLAGS_DATA_OUT;
				memcpy(pSrb->DataBuffer, (pExecuteCdb + 1), pSrb->DataTransferLength);
			}

			pSrbExtension->pfnCallBack = HptDeviceExecuteCDBCallBack;
		}
		break;

		default:
		{	  
		}	  
		break;
	}
}
/*++
Function:
    ULONG   HptIoControl

Description:
    Process private IO controls sent down directly from an application

Arguments:
    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Returns:
    SRB_STATUS_SUCCESS if the IO control supported
    SRB_STATUS_INVALID_REQUEST if the IO control not supported
--*/
ULONG
HptIoControl(
	IN PHW_DEVICE_EXTENSION HwDeviceExtension,
	IN PSCSI_REQUEST_BLOCK	pSrb
	)
{
	ULONG	status;
	PSt_HPT_LUN pLun;
	PSRB_IO_CONTROL pSrbIoCtl = (PSRB_IO_CONTROL)(pSrb->DataBuffer);
	pLun = (PSt_HPT_LUN)(pSrbIoCtl + 1);

	switch(pSrbIoCtl->ControlCode){
		case IOCTL_HPT_MINIPORT_GET_VERSION:
		{
			PSt_HPT_VERSION_INFO pHptVerInfo;
			if(pSrbIoCtl->Length < (sizeof(St_HPT_VERSION_INFO) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pHptVerInfo = (PSt_HPT_VERSION_INFO)(pLun+1);
			memset(pHptVerInfo, 0, sizeof(St_HPT_VERSION_INFO));
			pHptVerInfo->dwVersionInfoSize = sizeof(St_HPT_VERSION_INFO);
			pHptVerInfo->dwDriverVersion = VERSION_NUMBER;
			pHptVerInfo->dwPlatformId = PLATFORM_ID_WIN32_NT;
			pHptVerInfo->dwSupportFunction |= HPT_FUNCTION_RAID;

			status = SRB_STATUS_SUCCESS;
		}
		break;
									 
		case IOCTL_HPT_MINIPORT_GET_IDENTIFY_INFO:
		{
			PSt_IDENTIFY_DATA	pIdentifyData;
			if(pSrbIoCtl->Length < (sizeof(St_HPT_LUN)+sizeof(St_IDENTIFY_DATA))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}				 
									
			if((pLun->nPathId > 1)||(pLun->nTargetId > 1)){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			pIdentifyData = (PSt_IDENTIFY_DATA)(pLun+1);
			
			status = HptUtGetIdentifyData(
										  &(HwDeviceExtension->IDEChannel[pLun->nPathId]),
										  pLun->nTargetId,
										  pIdentifyData
										 );
			
		}
		break;								

		case IOCTL_HPT_MINIPORT_GET_RAID_INFO:
		{									   
			PSt_DISK_ARRAY_INFO	pDiskArrayInfo;
			
			if(pSrbIoCtl->Length < (sizeof(St_HPT_LUN)+sizeof(St_DISK_ARRAY_INFO))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			if((pLun->nPathId > 1)||(pLun->nTargetId > 1)){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			pDiskArrayInfo = (PSt_DISK_ARRAY_INFO)(pLun + 1);
			status = HptUtGetRaidInfo(
									  &(HwDeviceExtension->IDEChannel[pLun->nPathId]),
									  pLun->nTargetId,
									  pDiskArrayInfo
									 );
			
		}
		break;

		case IOCTL_HPT_MINIPORT_GET_LAST_ERROR:
		{	 
			PSt_HPT_ERROR_RECORD pErrorRecord;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_LUN) + sizeof(St_HPT_ERROR_RECORD))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  


			if((pLun->nPathId > 1)||(pLun->nTargetId > 1)){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pErrorRecord = (PSt_HPT_ERROR_RECORD)(pLun+1);

			status = HptUtGetLastError(
									   &(HwDeviceExtension->IDEChannel[pLun->nPathId]),
									   pLun->nTargetId,
									   pErrorRecord
									  );

		}
		break;

		case IOCTL_HPT_MINIPORT_GET_LAST_ERROR_DEVICE:
		{	  
			PSt_DiskFailure pDeviceErrorRecord;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_LUN) + sizeof(St_DiskFailure))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pDeviceErrorRecord = (PSt_DiskFailure)(pLun+1);

			status = HptUtGetLastErrorDevice(
									   HwDeviceExtension,
									   pDeviceErrorRecord
									  );
		}
		break;

		case IOCTL_HPT_MINIPORT_SET_NOTIFY_EVENT:
		{							  
			PSt_HPT_NOTIFY_EVENT	pNotifyEvent;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_LUN) + sizeof(St_HPT_NOTIFY_EVENT))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  
						  
			pNotifyEvent = (PSt_HPT_NOTIFY_EVENT)(pLun + 1);
			
			HwDeviceExtension->m_hAppNotificationEvent = PrepareForNotification(pNotifyEvent->hEvent);
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_REMOVE_NOTIFY_EVENT:
		{					 
			CloseNotifyEventHandle(HwDeviceExtension->m_hAppNotificationEvent);
			HwDeviceExtension->m_hAppNotificationEvent = NULL;
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_INFO:
		{
			PSt_HPT_ENUM_GET_DEVICE_INFO pEnumDeviceInfo;
			if(pSrbIoCtl->Length < (sizeof(St_HPT_ENUM_GET_DEVICE_INFO) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pEnumDeviceInfo = (PSt_HPT_ENUM_GET_DEVICE_INFO)(pLun + 1);

			status = SRB_STATUS_SUCCESS;

			if(!Device_GetInfo(
							   pEnumDeviceInfo->hDeviceNode,
							   &pEnumDeviceInfo->DiskStatus
							  )){
				status = SRB_STATUS_INVALID_REQUEST;
			}
		}
		break;

		case IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_CHILD:
		{	 
			PSt_HPT_ENUM_DEVICE_RELATION pEnumDeviceRelation;
			if(pSrbIoCtl->Length < (sizeof(St_HPT_ENUM_DEVICE_RELATION) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pEnumDeviceRelation = (PSt_HPT_ENUM_DEVICE_RELATION)(pLun + 1);

			status = SRB_STATUS_SUCCESS;

			if(!Device_GetChild(
								pEnumDeviceRelation->hNode,
								&pEnumDeviceRelation->hRelationNode
							   )){
				status = SRB_STATUS_INVALID_REQUEST;
			}
		}
		break;

		case IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_SIBLING:
		{
			PSt_HPT_ENUM_DEVICE_RELATION pEnumDeviceRelation;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_ENUM_DEVICE_RELATION) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pEnumDeviceRelation = (PSt_HPT_ENUM_DEVICE_RELATION)(pLun + 1);

			status = SRB_STATUS_SUCCESS;

			if(!Device_GetSibling(
								  pEnumDeviceRelation->hNode,
								  &pEnumDeviceRelation->hRelationNode
								 )){
				status = SRB_STATUS_INVALID_REQUEST;
			}
		}
		break;								   

		case IOCTL_HPT_MINIPORT_ENUM_GET_CONTROLLER_NUMBER:
		{													 
			PSt_HPT_ENUM_GET_CONTROLLER_NUMBER pControllerNumber;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_ENUM_GET_CONTROLLER_NUMBER) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pControllerNumber = (PSt_HPT_ENUM_GET_CONTROLLER_NUMBER)(pLun + 1);

			pControllerNumber->nControllerNumber = RAIDController_GetNum();
			
			status = SRB_STATUS_SUCCESS;
			
		}												  
		break;

		case IOCTL_HPT_MINIPORT_ENUM_GET_CONTROLLER_INFO:
		{
			PSt_HPT_ENUM_GET_CONTROLLER_INFO pControllerInfo;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_ENUM_GET_CONTROLLER_INFO) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pControllerInfo = (PSt_HPT_ENUM_GET_CONTROLLER_INFO)(pLun + 1);
			
			status = SRB_STATUS_SUCCESS;

			if( !RAIDController_GetInfo(
									   pControllerInfo->iController,
									   &pControllerInfo->stControllerInfo
									 ) ){
				status = SRB_STATUS_INVALID_REQUEST;
			}
		}
		break;

		case IOCTL_HPT_MINIPORT_LOCK_BLOCK:
		{
			PSt_HPT_BLOCK pLockBlock;  

			if(pSrbIoCtl->Length < (sizeof(St_HPT_BLOCK) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pLockBlock = (PSt_HPT_BLOCK)(pLun + 1);

			status = HptUtLockDeviceBlock(
										  &(HwDeviceExtension->IDEChannel[pLun->nPathId]),
										  pLun->nTargetId,
										  pLockBlock->nStartLbaAddress,
										  pLockBlock->nBlockSize
										 );
		}
		break;

		case IOCTL_HPT_MINIPORT_UNLOCK_BLOCK:
		{							 
			PSt_HPT_BLOCK pLockBlock;  

			if(pSrbIoCtl->Length < (sizeof(St_HPT_BLOCK) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pLockBlock = (PSt_HPT_BLOCK)(pLun + 1);

			status = HptUtUnlockDeviceBlock(
											&(HwDeviceExtension->IDEChannel[pLun->nPathId]),
											pLun->nTargetId,
											pLockBlock->nStartLbaAddress,
											pLockBlock->nBlockSize
										   );
		}
		break;

		case IOCTL_HPT_MINIPORT_CREATE_MIRROR:
		{
			PSt_HPT_CREATE_RAID	pstCreateRaid;

			pstCreateRaid = (PSt_HPT_CREATE_RAID)(pLun + 1);

			if(pSrbIoCtl->Length < (sizeof(St_HPT_CREATE_RAID)+
									sizeof(St_HPT_LUN)+
									pstCreateRaid->nDisks*sizeof(HDISK))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pstCreateRaid->hRaidDisk = Device_CreateMirror(
				&pstCreateRaid->aryhDisks[0],
				pstCreateRaid->nDisks
				);
			
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_CREATE_STRIPE:
		{
			PSt_HPT_CREATE_RAID	pstCreateRaid;

			pstCreateRaid = (PSt_HPT_CREATE_RAID)(pLun + 1);

			if(pSrbIoCtl->Length < (sizeof(St_HPT_CREATE_RAID)+
									sizeof(St_HPT_LUN)+
									pstCreateRaid->nDisks*sizeof(HDISK))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pstCreateRaid->hRaidDisk = Device_CreateStriping(
				&pstCreateRaid->aryhDisks[0],
				pstCreateRaid->nDisks,
				pstCreateRaid->nStripeBlockSizeShift
				);
			
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_CREATE_RAID10:
		{
			PSt_HPT_CREATE_RAID	pstCreateRaid;

			pstCreateRaid = (PSt_HPT_CREATE_RAID)(pLun + 1);

			if(pSrbIoCtl->Length < (sizeof(St_HPT_CREATE_RAID)+
									sizeof(St_HPT_LUN)+
									pstCreateRaid->nDisks*sizeof(HDISK))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pstCreateRaid->hRaidDisk = Device_CreateRAID10(
				&pstCreateRaid->aryhDisks[0],
				pstCreateRaid->nDisks,
				pstCreateRaid->nStripeBlockSizeShift
				);
			
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_CREATE_SPAN:
		{
			PSt_HPT_CREATE_RAID	pstCreateRaid;

			pstCreateRaid = (PSt_HPT_CREATE_RAID)(pLun + 1);

			if(pSrbIoCtl->Length < (sizeof(St_HPT_CREATE_RAID)+
									sizeof(St_HPT_LUN)+
									pstCreateRaid->nDisks*sizeof(HDISK))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pstCreateRaid->hRaidDisk = Device_CreateSpan(
				&pstCreateRaid->aryhDisks[0],
				pstCreateRaid->nDisks);	
			
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_REMOVE_RAID:
		{
			PSt_HPT_REMOVE_RAID	pstRemoveRaid;
															
			if(pSrbIoCtl->Length < (sizeof(St_HPT_REMOVE_RAID)+sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			pstRemoveRaid = (PSt_HPT_REMOVE_RAID)(pLun + 1);

			if(!Device_Remove(pstRemoveRaid->hDisk)){
				status = SRB_STATUS_INVALID_REQUEST;
			}else{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;
		
		case IOCTL_HPT_MINIPORT_ABORT_MIRROR_REBUILDING:
		{
			HDISK *	phMirror;
															
			if(pSrbIoCtl->Length < (sizeof(HDISK)+sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			phMirror = (HDISK *)(pLun + 1);

			if( !Device_AbortMirrorBuilding( *phMirror ) )
			{
				status = SRB_STATUS_INVALID_REQUEST;
			}else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;
		
		case IOCTL_HPT_MINIPORT_BEGIN_REBUILDING_MIRROR:
		{
			HDISK *	phMirror;
															
			if(pSrbIoCtl->Length < (sizeof(HDISK)+sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			phMirror = (HDISK *)(pLun + 1);

			if( !Device_BeginRebuildingMirror( *phMirror ) )
			{
				status = SRB_STATUS_INVALID_REQUEST;
			}else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;
		
		case IOCTL_HPT_MINIPORT_VALIDATE_MIRROR:
		{
			HDISK *	phMirror;
															
			if(pSrbIoCtl->Length < (sizeof(HDISK)+sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			phMirror = (HDISK *)(pLun + 1);

			if( !Device_ValidateMirror( *phMirror ) )
			{
				status = SRB_STATUS_INVALID_REQUEST;
			}else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;
		
		case IOCTL_HPT_MINIPORT_DIAG_RAISE_ERROR:
		{
		    SCSI_REQUEST_BLOCK Srb;
			BYTE * pCdb;
			PDevice pDev;
			
			if( pSrbIoCtl->Length < (16+sizeof(St_HPT_LUN)) ||
			    pLun->nPathId > 1 || 
			    pLun->nTargetId > 1 )
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			pDev = HwDeviceExtension->IDEChannel[pLun->nPathId].pDevice[pLun->nTargetId];
			
			if( !pDev )
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pCdb = (BYTE *)(pLun + 1);
			memcpy( Srb.Cdb, pCdb, sizeof(Srb.Cdb) );
			
			ReportError(pDev, DEVICE_REMOVED, &Srb);
			status = SRB_STATUS_SUCCESS;
		}
		break;

#ifdef SUPPORT_XPRO
////////////////////
		case IOCTL_HPT_MINIPORT_SET_XPRO:
		{
			extern DWORD	dwEnable;
			extern DWORD	Api_mem_Sz;
			extern DWORD	Masks;
			DWORD	*pdwXpro;
			
			if(pSrbIoCtl->Length < (8 + sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			pdwXpro    = (DWORD *)(pLun + 1);
			dwEnable   = *pdwXpro;
			Api_mem_Sz = *(pdwXpro + 1);
			Masks      = ~(Api_mem_Sz - 1);

			status = SRB_STATUS_SUCCESS;
		}
		break;
////////////////////
#endif									// SUPPORT_XPRO

////////////////////
				  // Added by SLeng, 11/20/2000
				  //
		case IOCTL_HPT_MINIPORT_ENABLE_DEVICE:
		{
			PDevice  pDev;
			PChannel pChan;
			if(pSrbIoCtl->Length < sizeof(St_HPT_LUN))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			if((pLun->nPathId > 1)||(pLun->nTargetId > 1))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pChan = &(HwDeviceExtension->IDEChannel[pLun->nPathId]);
			pDev  = &(pChan->Devices[pLun->nTargetId]);
			pDev->DeviceFlags2 &= ~DFLAGS_DEVICE_DISABLED;

		}
		break;

		case IOCTL_HPT_MINIPORT_DISABLE_DEVICE:
		{
			PDevice  pDev;
			PChannel pChan;
			if(pSrbIoCtl->Length < sizeof(St_HPT_LUN))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			if((pLun->nPathId > 1)||(pLun->nTargetId > 1))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			pChan = &(HwDeviceExtension->IDEChannel[pLun->nPathId]);
			pDev  = &(pChan->Devices[pLun->nTargetId]);
			pDev->DeviceFlags2 |= DFLAGS_DEVICE_DISABLED;

		}
		break;

		case IOCTL_HPT_MINIPORT_ADD_SPARE_DISK:
		{	
			// Add spare disk to a mirror array
			PSt_HPT_ADD_DISK	pstAddDisk;
															
			if(pSrbIoCtl->Length < (sizeof(St_HPT_ADD_DISK)+sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			pstAddDisk = (PSt_HPT_ADD_DISK)(pLun + 1);

			if(!Device_AddSpare(pstAddDisk->hArray, pstAddDisk->hDisk))
			{
				status = SRB_STATUS_INVALID_REQUEST;
			}
			else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;

		case IOCTL_HPT_MINIPORT_DEL_SPARE_DISK:
		{	
			// Del spare disk from a mirror array
			PSt_HPT_REMOVE_RAID	pstDelDisk;
															
			if(pSrbIoCtl->Length < (sizeof(St_HPT_REMOVE_RAID)+sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			pstDelDisk = (PSt_HPT_REMOVE_RAID)(pLun + 1);

			if(!Device_DelSpare(pstDelDisk->hDisk))
			{
				status = SRB_STATUS_INVALID_REQUEST;
			}
			else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;

		case IOCTL_HPT_MINIPORT_ADD_MIRROR_DISK:
		{	
			// Add mirror disk to a mirror array
			PSt_HPT_ADD_DISK	pstAddDisk;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_ADD_DISK)+sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pstAddDisk = (PSt_HPT_ADD_DISK)(pLun + 1);			
			
			if(!Device_AddMirrorDisk( pstAddDisk->hArray, pstAddDisk->hDisk ))
			{
				status = SRB_STATUS_INVALID_REQUEST;
			}
			else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;
/*
		case IOCTL_HPT_MINIPORT_CHECK_RAID_LIST:
		{		
			PDevice pDev;
			int i;
			PChannel pChan=&HwDeviceExtension->IDEChannel[0];

			status = SRB_STATUS_SUCCESS;
			for(i=0;i<2;i++) {
				  pDev=&pChan->Devices[i];
              if(pDev && pDev->pArray) goto _done_;
			}
			pChan++;
			for(i=0;i<2;i++) {
				  pDev=&pChan->Devices[i];
              if(pDev && pDev->pArray) goto _done_;
			}
			status = SRB_STATUS_INVALID_REQUEST;
		}
*/
      break; 

		case IOCTL_HPT_MINIPORT_SET_ARRAY_NAME:	//added by wx 12/26/00
		{
			BYTE* pInfo = (BYTE*)(pLun +1);
		
			if(pSrbIoCtl->Length != (20 + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			Device_SetArrayName(*((HDISK*)pInfo), (char*)((HDISK*)(pInfo+4)));
			
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_RESCAN_ALL:	//ldx added 
		{
			if (Device_RescanAll())
				status = SRB_STATUS_SUCCESS;
			else
				status = SRB_STATUS_INVALID_REQUEST;
		}
		break;
#ifndef WIN95
		case IOCTL_HPT_CHECK_NOTIFY_EVENT:
		{
			extern BOOLEAN g_bNotifyEvent;
			if (g_bNotifyEvent) {
				g_bNotifyEvent = FALSE;
				status = SRB_STATUS_SUCCESS;
			}
			else
				status = SRB_STATUS_ERROR;
			break;
		}
#endif
		default:
		{
			status = SRB_STATUS_INVALID_REQUEST;
		}
		break;
	}
	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\win98.c ===
/***************************************************************************
 * File:          win98.c
 * Description:   Subroutines in the file are used to atapi device in
 *				  win98 platform
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:     
 *		11/06/2000	HS.Zhang	Added this head
 *		11/10/2000	HS.Zhang	Added a micro define NO_DMA_ON_ATAPI in
 *								Start_Atapi routine
 *
 ***************************************************************************/
#include "global.h"

#if  defined(WIN95) && !defined(_BIOS_)

/******************************************************************
 * "Eat" Bios interrupt
 *******************************************************************/

typedef struct _Adapter	 {
	PChannel             pExtension;
	PUCHAR               BMI;
	PIDE_REGISTERS_1	    IoPort;
} Adapter;
Adapter Adapters[8] = { {0, }, };
int f_CheckAllChip = 0;

VOID w95_initialize(VOID)
{
	ZeroMemory(Adapters, sizeof(Adapters));
	f_CheckAllChip = 0;
}

VOID w95_scan_all_adapters(VOID)
{
	PCI1_CFG_ADDR pci1_cfg = {0,};
	ULONG  i, bus;
	PUCHAR  BMI;
	Adapter *pAdap = Adapters;

	if(f_CheckAllChip)
		return;

	pci1_cfg.enable = 1;

	for(bus=0;bus<MAX_PCI_BUS_NUMBER;bus++)
		for(i = 0; i < MAX_PCI_DEVICE_NUMBER; i++) {
			pci1_cfg.dev_num = (USHORT)i;
			pci1_cfg.fun_num= 0;
			pci1_cfg.reg_num = 0;
			pci1_cfg.bus_num = (USHORT)bus;
			ScsiPortWritePortUlong((PULONG)0xCF8, *((PULONG)&pci1_cfg));

			if (ScsiPortReadPortUlong((PULONG)0xCFC) != SIGNATURE_366)
				continue;

			pci1_cfg.reg_num = REG_BMIBA;
			ScsiPortWritePortUlong((PULONG)0xCF8, *((PULONG)&pci1_cfg));
			BMI = (PUCHAR)(ScsiPortReadPortUlong((PULONG)0xCFC) & ~1);
			pAdap->BMI = BMI;
			pAdap->IoPort = (PIDE_REGISTERS_1)
							(ScsiPortReadPortUlong((PULONG)(pAdap->BMI+REG_IOPORT0)) & ~1);
			pAdap++;

			if(ScsiPortReadPortUchar(pAdap->BMI+0x2E)) {
				pci1_cfg.fun_num= 1;
				pci1_cfg.reg_num = REG_BMIBA;
				ScsiPortWritePortUlong((PULONG)0xCF8, *((PULONG)&pci1_cfg));
				pAdap->BMI = (PUCHAR)(ScsiPortReadPortUlong((PULONG)0xCFC) & ~1);
				pAdap->IoPort = (PIDE_REGISTERS_1)
								(ScsiPortReadPortUlong((PULONG)(pAdap->BMI+REG_IOPORT0)) & ~1);
			} else {
				pAdap->BMI = BMI + 8;
				pAdap->IoPort = (PIDE_REGISTERS_1)
								(ScsiPortReadPortUlong((PULONG)(BMI+0x18)) & ~1);
			}
			pAdap++;
		}

	f_CheckAllChip = pAdap - Adapters;
}

void Win98HwInitialize(PChannel pChan)
{
	int i;

	for(i = 0; i < f_CheckAllChip; i++)
		if(Adapters[i].BMI == pChan->BMI) {
			Adapters[i].pExtension = pChan;
			break;
		}
}

void Win95CheckBiosInterrupt(void)
{
	int i;

	for(i = 0; i < f_CheckAllChip; i++)
		if(Adapters[i].pExtension == 0 && 
		   (ScsiPortReadPortUchar(Adapters[i].BMI + BMI_STS) & BMI_STS_INTR)) {
			GetBaseStatus(Adapters[i].IoPort);
			break;
		}
}

/******************************************************************
 *  Build Scatter/Gather List
 *******************************************************************/

int BuildSgl(IN PDevice pDev, IN PSCAT_GATH pSG,
			IN PSCSI_REQUEST_BLOCK Srb)
{
	PChannel pChan = pDev->pChannel;
	PSCAT_GATH psg = pSG;
	PVOID   dataPointer = Srb->DataBuffer;
	ULONG   bytesLeft   = Srb->DataTransferLength;
	ULONG   physicalAddress[MAX_SG_DESCRIPTORS];
	ULONG   addressLength[MAX_SG_DESCRIPTORS];
	ULONG   addressCount = 0;
	ULONG   sgEnteries = 0;

	ULONG   length;
	ULONG   i;

	if((int)dataPointer	& 0xF)
		goto use_internel;

	//
	// Create SDL segment descriptors.
	//
	do {
		//
		// Get physical address and length of contiguous physical buffer.
		//
		physicalAddress[addressCount] =
									   ScsiPortConvertPhysicalAddressToUlong(
			ScsiPortGetPhysicalAddress(pChan->HwDeviceExtension,
									   Srb,
									   dataPointer,
									   &length));

		//
		// If length of physical memory is more than bytes left
		// in transfer, use bytes left as final length.
		//
		if (length > bytesLeft)
			length = bytesLeft;

		addressLength[addressCount] = length;

		//
		// Adjust counts.
		//
		dataPointer = (PUCHAR)dataPointer + length;
		bytesLeft  -= length;
		addressCount++;

	} while (bytesLeft);

#ifdef BUFFER_CHECK									   
	if(psg == &(((PSrbExtension)(Srb->SrbExtension))->ArraySg[0])){
		if(((PSrbExtension)(Srb->SrbExtension))->WorkingFlags){
			__asm{
				int	3;
			}													   
		}
	}
#endif									// BUFFER_CHECK

	//
	// Create Scatter/Gather List
	//
	for (i = 0; i < addressCount; i++) {
		psg->SgAddress = physicalAddress[i];
		length = addressLength[i];

		// In Win95, ScsiPortGetPhysicalAddress() often returns small pieces
		// of memory blocks which are really contiguous physical memory.
		// Let's merge any contiguous addresses into one SG entry. This will
		// increase the performance a lot.
		//
		while ((i+1 < addressCount) &&
			   (psg->SgAddress+length == physicalAddress[i+1])) {
			i++;
			length += addressLength[i];
		}

		//
		// If contiguous physical memory skips 64K boundary, we split it.
		// Hpt366 don't support physical memory skipping 64K boundary in
		// one SG entry.
		//
		if ((psg->SgAddress & 0xFFFF0000) !=
			  ((psg->SgAddress+length-1) & 0xFFFF0000)) {
			ULONG firstPart;

			firstPart = 0x10000 - (psg->SgAddress & 0xFFFF);
			psg->SgSize = (USHORT)firstPart;
			psg->SgFlag = 0;

			sgEnteries++;
			psg++;

			psg->SgAddress = (psg-1)->SgAddress + firstPart;
			length -= firstPart;
		} // skip 64K boundary

		psg->SgSize = (USHORT)length;

		if((length & 3) || (length < 8))
use_internel:
			return Use_Internal_Buffer(pSG, Srb);

			psg->SgFlag = (i < addressCount-1) ? 0 : SG_FLAG_EOT;

			sgEnteries++;
			psg++;
	} // for each memory segment

	return(1);

} // BuildSgl()


/******************************************************************
 *  
 *******************************************************************/

void Start_Atapi(PDevice pDevice, PSCSI_REQUEST_BLOCK Srb)
{
	PChannel  pChan= pDevice->pChannel;
	PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	int    i;
	UCHAR   ScsiStatus, statusByte;

	//
	// Make sure command is to ATAPI device.
	//
	if (Srb->Lun || !(pDevice->DeviceFlags & DFLAGS_ATAPI)) {
		ScsiStatus = SRB_STATUS_SELECTION_TIMEOUT; //no device at this address
		goto out;
	}
	// Added by HS.Zhang
	// Added macro define check to let us change the DMA by set the
	// macro in forwin.h
#ifdef NO_DMA_ON_ATAPI	
	// no ultra DMA or DMA on ATAPI devices
	//				  
	if(pDevice->DeviceFlags & DFLAGS_ATAPI) {
		pDevice->DeviceFlags &= ~(DFLAGS_DMA | DFLAGS_ULTRA);
	}  
#endif									// NO_DMA_ON_ATAPI
	//
	// For some commands, we need to filter the CDB in Win95
	//
	for (i = Srb->CdbLength; i < MAXIMUM_CDB_SIZE; Srb->Cdb[i++] = 0);


	//
	// Deal with wrong DataTransferLength
	//
	if(Srb->Cdb[0] == 0x12) 
		Srb->DataTransferLength = (ULONG)Srb->Cdb[4];

	if (Srb->Cdb[0] == 0x5A && Srb->Cdb[2] != 5 &&
		  Srb->Cdb[8] > (UCHAR)Srb->DataTransferLength)
		Srb->DataTransferLength = (ULONG)Srb->Cdb[8];

	if (Srb->Cdb[0] == 0x28 && (Srb->DataTransferLength % 2352)==0) {
		Srb->Cdb[0] = 0xBE;
		Srb->Cdb[9] = 0xf8;
	}


	//
	// Select device 0 or 1.
	//
	SelectUnit(IoPort, pDevice->UnitId);

	//
	// When putting a MITSUBISHI LS120 with other device on a same channel,
	// the other device strangely is offten busy.
	//
	statusByte = WaitOnBusy(ControlPort);

	if (statusByte & IDE_STATUS_BUSY) {
		ScsiStatus = SRB_STATUS_BUSY;
		goto out;
	}

	if ((statusByte & IDE_STATUS_ERROR) &&
		  (Srb->Cdb[0] != SCSIOP_REQUEST_SENSE) && 
		  (Srb->Cdb[0] != SCSIOP_INQUIRY)) {
		ScsiStatus = MapAtapiErrorToOsError(GetErrorCode(IoPort), Srb);
		goto out;
	}

	//
	// If a tape drive doesn't have DSC set and the last command is
	// restrictive, don't send the next command. See discussion of
	// Restrictive Delayed Process commands in QIC-157.
	//
	if ((!(statusByte & IDE_STATUS_DSC)) &&
		  (pDevice->DeviceFlags & (DFLAGS_TAPE_RDP | DFLAGS_TAPE_RDP))) {
		ScsiPortStallExecution(1000);
		ScsiStatus =  SRB_STATUS_BUSY;
		goto out;
	}

	if (IS_RDP(Srb->Cdb[0])) 
		pDevice->DeviceFlags |= DFLAGS_TAPE_RDP;
	else
		pDevice->DeviceFlags &= ~DFLAGS_TAPE_RDP;


	if (statusByte & IDE_STATUS_DRQ) {
		//
		// Try to drain the data that one preliminary device thinks that it has
		// to transfer. Hopefully this random assertion of DRQ will not be present
		// in production devices.
		//
		for (i = 0; i < 0x10000; i++) {
			statusByte = GetStatus(ControlPort);

			if (statusByte & IDE_STATUS_DRQ)
				ScsiPortReadPortUshort(&IoPort->Data);
			else
				break;
		}

		if (i == 0x10000) {
			LOC_IDENTIFY

			AtapiSoftReset(IoPort,ControlPort,Srb->TargetId);

			//
			// Re-initialize Atapi device.
			//
			IssueIdentify(pDevice, IDE_COMMAND_ATAPI_IDENTIFY ARG_IDENTIFY );

			//
			// Inform the port driver that the bus has been reset.
			//
			ScsiPortNotification(ResetDetected, pChan->HwDeviceExtension, 0);

			//
			// Clean up device extension fields that AtapiStartIo won't.
			//
			ScsiStatus = SRB_STATUS_BUS_RESET;
out:
			//Srb->ScsiStatus = ScsiStatus;
			Srb->SrbStatus = ScsiStatus;
			return;
		}
	}


	//
	// Convert SCSI to ATAPI commands if needed
	//
	if (!(pDevice->DeviceFlags & DFLAGS_TAPE_DEVICE)) {

		Srb->CdbLength = 12;

		//
		// Save the original CDB
		//
		for (i = 0; i < MAXIMUM_CDB_SIZE; i++) 
			pChan->OrgCdb[i] = Srb->Cdb[i];

		switch (Srb->Cdb[0]) {
			case SCSIOP_MODE_SENSE: {
										PMODE_SENSE_10 modeSense10 = (PMODE_SENSE_10)Srb->Cdb;
										UCHAR PageCode = ((PCDB)Srb->Cdb)->MODE_SENSE.PageCode;
										UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SENSE.AllocationLength;

										ZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

										modeSense10->OperationCode = ATAPI_MODE_SENSE;
										modeSense10->PageCode = PageCode;
										modeSense10->ParameterListLengthMsb = 0;
										modeSense10->ParameterListLengthLsb = Length;

										pDevice->DeviceFlags |= DFLAGS_OPCODE_CONVERTED;
										break;
									}

			case SCSIOP_MODE_SELECT: {
										 PMODE_SELECT_10 modeSelect10 = (PMODE_SELECT_10)Srb->Cdb;
										 UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SELECT.ParameterListLength;

			//
			// Zero the original cdb
			//
										 ZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

										 modeSelect10->OperationCode = ATAPI_MODE_SELECT;
										 modeSelect10->PFBit = 1;
										 modeSelect10->ParameterListLengthMsb = 0;
										 modeSelect10->ParameterListLengthLsb = Length;

										 pDevice->DeviceFlags |= DFLAGS_OPCODE_CONVERTED;
										 break;
									 }

			case SCSIOP_FORMAT_UNIT:
			// DON'T DO THIS FOR LS-120!!!

			//Srb->Cdb[0] = ATAPI_FORMAT_UNIT;
			//pDevice->Flag |= DFLAGS_OPCODE_CONVERTED;
				break;
		}
	}


	if((pDevice->DeviceFlags & (DFLAGS_DMA|DFLAGS_ULTRA)) &&
	   (pDevice->DeviceFlags & DFLAGS_FORCE_PIO) == 0 &&
	   (Srb->Cdb[0] == 0x28 || Srb->Cdb[0] == 0x2A ||
		  Srb->Cdb[0] == 0x8 || Srb->Cdb[0] == 0xA) &&
	   BuildSgl(pDevice, pChan->pSgTable, Srb)) 
		pDevice->DeviceFlags |= DFLAGS_REQUEST_DMA;
	else
		pDevice->DeviceFlags &= ~DFLAGS_REQUEST_DMA;

	StartAtapiCommand(pDevice ARG_SRB);
}


/******************************************************************
 *  
 *******************************************************************/

BOOLEAN Atapi_End_Interrupt(PDevice pDevice , PSCSI_REQUEST_BLOCK Srb)
{
	PChannel  pChan= pDevice->pChannel;
	PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	LONG    i;
	UCHAR  status = Srb->ScsiStatus, statusByte;
	pIOP    pIop;
	DCB*    pDcb;


	//
	// For some opcodes, we cannot report OVERRUN
	//
	if (status == SRB_STATUS_DATA_OVERRUN) {
		//
		// Don't report OVERRUN error for READ TOC to let CD AUDIO work.
		// (and also 0x5A)
		//
		if (Srb->Cdb[0] == 0x43 || Srb->Cdb[0] == 0x5A) {
			pChan->WordsLeft = 0;
			status = SRB_STATUS_SUCCESS;
		}
	}

	//
	// Translate ATAPI data back to SCSI data if needed
	//
	if (pDevice->DeviceFlags & DFLAGS_OPCODE_CONVERTED) {
		LONG    byteCount = Srb->DataTransferLength;
		char    *dataBuffer = Srb->DataBuffer;

		switch (Srb->Cdb[0]) {
			case ATAPI_MODE_SENSE:
			{
				PMODE_SENSE_10 modeSense10 = (PMODE_SENSE_10)Srb->Cdb;
				PMODE_PARAMETER_HEADER_10 header_10 = (PMODE_PARAMETER_HEADER_10)dataBuffer;
				PMODE_PARAMETER_HEADER header = (PMODE_PARAMETER_HEADER)dataBuffer;

				header->ModeDataLength = header_10->ModeDataLengthLsb;
				header->MediumType = header_10->MediumType;

			//
			// ATAPI Mode Parameter Header doesn't have these fields.
			//
				header->DeviceSpecificParameter = header_10->Reserved[0];
				header->BlockDescriptorLength = header_10->Reserved[1];

				byteCount -= sizeof(MODE_PARAMETER_HEADER_10);

				if (byteCount > 0)
					ScsiPortMoveMemory(
									   dataBuffer+sizeof(MODE_PARAMETER_HEADER),
									   dataBuffer+sizeof(MODE_PARAMETER_HEADER_10),
									   byteCount);

			//
			// Insert a block descriptor for Audio Control Mode Page
			// for AUDIO to work
			//
				if (modeSense10->PageCode == 0x0E) {
					for (i = byteCount-1; i >= 0; i--)
						dataBuffer[sizeof(MODE_PARAMETER_HEADER) + i + 8] =
							dataBuffer[sizeof(MODE_PARAMETER_HEADER) + i];

					for (i = 0; i < 8; i++)
						dataBuffer[4 + i]  = 0;

					header->BlockDescriptorLength = 8;
					dataBuffer[10] = 8;
				}

			//
			// Change ATAPI_MODE_SENSE opcode back to SCSIOP_MODE_SENSE
			//
				Srb->Cdb[0] = SCSIOP_MODE_SENSE;
				break;
			}

			case ATAPI_MODE_SELECT:
				Srb->Cdb[0] = SCSIOP_MODE_SELECT;
				break;

			case ATAPI_FORMAT_UNIT:
			//Srb->Cdb[0] = SCSIOP_FORMAT_UNIT;
				break;
		}
	}


	if (status != SRB_STATUS_ERROR) {
		if(pDevice->DeviceFlags & DFLAGS_CDROM_DEVICE) {
			//
			// Work around to make many atapi devices return correct 
			// sector size of 2048. Also certain devices will have 
			// sector count == 0x00, check for that also.
			//
			if (Srb->Cdb[0] == 0x25) {
				((PULONG)Srb->DataBuffer)[1] = 0x00080000;

				if (((PULONG)Srb->DataBuffer)[0] == 0x00)
					((PULONG)Srb->DataBuffer)[0] = 0xFFFFFF7F;
			}
		}

		//
		// Wait for busy to drop.
		//

		for (i = 0; i < 30; i++) {
			statusByte = GetStatus(ControlPort);
			if (!(statusByte & IDE_STATUS_BUSY)) 
				break;
			ScsiPortStallExecution(500);
		}

		if (i == 30) 
			goto reset;

		//
		// Check to see if DRQ is still up.
		//

		if (statusByte & IDE_STATUS_DRQ) {

			for (i = 0; i < 2048; i++) {
				statusByte = GetStatus(ControlPort);
				if (!(statusByte & IDE_STATUS_DRQ)) 
					break;

				ScsiPortReadPortUshort(&IoPort->Data);
				ScsiPortStallExecution(50);

			}

			if (i == 2048) {
reset:
				//
				// reset the controller.
				//
				AtapiResetController(pChan->HwDeviceExtension,Srb->PathId);
				return TRUE;
			}

		}
	}

	//
	// Sanity check that there is a current request.
	//
	if (Srb != NULL) {
		//
		// Check for underflow.
		//
		if (pChan->WordsLeft) {
			//
			// Subtract out residual words.
			//
			Srb->DataTransferLength -= pChan->WordsLeft;
		}

		//
		// Indicate command complete.
		//
		if (!(pDevice->DeviceFlags & DFLAGS_TAPE_RDP)) {
			DeviceInterrupt(pDevice, 1);
		}
		else {
			OS_Busy_Handle(pChan, pDevice)
					return TRUE;
		}
	}


	pIop = *(pIOP *)((int)Srb+0x40);
	pDcb = (DCB*)pIop->IOP_physical_dcb;

	if(Srb->Cdb[0] == 0x12) {
		pDcb->DCB_cmn.DCB_device_flags2 |= DCB_DEV2_ATAPI_DEVICE;
		if(pDevice->DeviceFlags & DFLAGS_LS120) 
			pDcb->DCB_cmn.DCB_device_flags2 |= 0x40;
	}

	if(Srb->SrbStatus == SRB_STATUS_SUCCESS &&
	   Srb->ScsiStatus== SCSISTAT_GOOD &&
	   (Srb->Cdb[0] == 0x5A || Srb->Cdb[0] == 0x1A) &&
	   Srb->Cdb[2] == 0x2A) {
		PUCHAR pData = (Srb->DataBuffer)?
					   (PUCHAR)Srb->DataBuffer:
					   (PUCHAR)pIop->IOP_ior.IOR_buffer_ptr;
		if (!(pData[((Srb->Cdb[0] == 0x5A)? 8 : 4+pData[3]) + 2] & 8)) 
			pDcb->DCB_cmn.DCB_device_flags2 |= DCB_DEV2_ATAPI_DEVICE;
		else 
			pDcb->DCB_cmn.DCB_device_flags2 &= ~DCB_DEV2_ATAPI_DEVICE;

	}

	return TRUE;
}

/******************************************************************
 * Get Stamps 
 *******************************************************************/
DWORD __stdcall LOCK_VTD_Get_Date_And_Time (DWORD* pDate);

ULONG GetStamp(void)
{
	ULONG Date, Time;
	Time = LOCK_VTD_Get_Date_And_Time(&Date);
	return((Time >> 4) | (Date << 28));
}

#ifdef SUPPORT_HOTSWAP

void CheckDeviceReentry(PChannel pChan, PSCSI_REQUEST_BLOCK Srb)
{

	if(Srb->Cdb[0]==0x12 && Srb->Lun == 0 && 
	   pChan->pDevice[0] == 0 && pChan->pDevice[1] == 0) {
		PDevice pDevice = &pChan->Devices[Srb->TargetId];
		HKEY    hKey;
		DWORD   ret, len;
		UCHAR   chnlstr[10]= {0,};
		DWORD   dwType;
		DWORD   szbuf;

		ret = RegOpenKey(
						 HKEY_LOCAL_MACHINE,     // Key handle at root level.
						 "SOFTWARE\\HighPoint\\Swap-n-Go",
						 &hKey);                 // Address of key to be returned.

		if(ret == ERROR_SUCCESS ) 
		{
			strcat(chnlstr, "Unplug");

			len= 4;
			dwType= REG_BINARY;

		  // Get key value
		  //
			RegQueryValueEx(
							hKey,       // Key handle.
							chnlstr,    // Buffer for class name.
							NULL,       // Length of class string.
							&dwType,    // address of buffer for value type
							(CHAR *)&szbuf,     // address of data buffer
							&len);      // address of data buffer size

			RegCloseKey(hKey);
			if(szbuf != 0)
				return;

		}

		for(i = 0; i < 10; i++) {
			ScsiPortStallExecution(1000*1000);
			AtapiHwInitialize(pChan);
			if(pChan->pDevice[0] != 0 || pChan->pDevice[1] != 0)
				break;
		}
	}
#endif //SUPPORT_HOTSWAP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\winio.c ===
/***************************************************************************
 * File:          winio.c
 * Description:   include routine for windows platform
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/08/2000	HS.Zhang	Added this header
 *
 ***************************************************************************/
#include "global.h"

#ifndef _BIOS_

VOID
   HptDeviceSpecifiedIoControl(
							   IN PDevice pDevice,
							   IN PSCSI_REQUEST_BLOCK pSrb
							  );


/******************************************************************
 * Start Windows Command
 *******************************************************************/


void WinStartCommand(
    IN PDevice pDev, 
    IN PSCSI_REQUEST_BLOCK Srb)
{
	PChannel pChan = pDev->pChannel;
	pChan->pWorkDev = pDev;
	pChan->CurrentSrb = Srb;

	if((Srb->Function == SRB_FUNCTION_IO_CONTROL)&&
	   (!StringCmp(((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature, "SCSIDISK", 8))){
		
#ifndef WIN95
			IdeSendSmartCommand(pDev, Srb);
#endif									// WIN95
			
	} else {
		if(Srb->Function == SRB_FUNCTION_IO_CONTROL){
			HptDeviceSpecifiedIoControl(pDev, Srb);
		}
#ifdef WIN95
		else{
			pIOP  pIop;
			DCB*  pDcb;

			pDev = pChan->pDevice[Srb->TargetId];
			pIop = *(pIOP *)((int)Srb+0x40);
			pDcb = (DCB*)pIop->IOP_physical_dcb;

			if(pDev->DeviceFlags & DFLAGS_LS120)  
				pIop->IOP_timer_orig = pIop->IOP_timer = 31;

			Srb->ScsiStatus = SCSISTAT_GOOD;
			pIop->IOP_ior.IOR_status = IORS_SUCCESS;
			Srb->PathId   = pDcb->DCB_bus_number;
			Srb->TargetId = pDcb->DCB_scsi_target_id;
			Srb->Lun      = pDcb->DCB_scsi_lun;
		}											 
#endif												 
		if(pDev->DeviceFlags & DFLAGS_ATAPI){ 
			Start_Atapi(pDev, Srb);
		}else{
			IdeSendCommand(pDev, Srb);
		}
	}

	if(Srb->SrbStatus != SRB_STATUS_PENDING){
		DeviceInterrupt(pDev, 1);			 
	}
}



/******************************************************************
 * Check Next Request
 *******************************************************************/

void Prepare_Shutdown(PDevice pDev)
{
     PVirtualDevice  pArray = pDev->pArray;
     int flag = pDev->DeviceFlags & (DFLAGS_WIN_FLUSH | DFLAGS_WIN_SHUTDOWN);
     int   j;


	  pDev->DeviceFlags &= ~(DFLAGS_WIN_FLUSH | DFLAGS_WIN_SHUTDOWN);

	  if(pArray == 0) {
          NonIoAtaCmd(pDev, IDE_COMMAND_FLUSH_CACHE);

			 // 10/26/00 OS will handle this
          //if(flag & DFLAGS_WIN_SHUTDOWN) 
          //    NonIoAtaCmd(pDev, IDE_COMMAND_STANDBY_IMMEDIATE);
          return;
	  }

loop:
	  for(j = 0; j < pArray->nDisk; j++) {
mirror:
         if((pDev = pArray->pDevice[j]) != 0) {
              NonIoAtaCmd(pDev, IDE_COMMAND_FLUSH_CACHE);

				  // 10/26/00 OS will take care of power off
              //if(flag & DFLAGS_WIN_SHUTDOWN) 
              //    NonIoAtaCmd(pDev, IDE_COMMAND_STANDBY_IMMEDIATE);
			 }
     }

	  if(j < MIRROR_DISK) {
         switch(pArray->arrayType) {
         case VD_RAID_1_MIRROR:
         case VD_RAID_01_1STRIPE:
				j = MIRROR_DISK;
            goto mirror;

         case VD_RAID_01_2STRIPE:
            if(pArray->pDevice[MIRROR_DISK]) {
                pArray = pArray->pDevice[MIRROR_DISK]->pArray;
                goto loop;
            }
            break;

         case VD_RAID_10_SOURCE:
            if((pArray = pArray->pRAID10Mirror) != 0) 
                goto loop;
         }
     }
}

/******************************************************************
 * Check Next Request
 *******************************************************************/

void CheckNextRequest(PChannel pChan)
{
	PDevice pDev;
	PSCSI_REQUEST_BLOCK Srb;
	PSrbExtension pSrbExt;
	int i;
	OLD_IRQL

	for(i = 0; i < 2; i++) {
		if ((pDev = pChan->pDevice[i]) == 0){
			continue;						 
		}

#ifdef SUPPORT_TCQ

		if(pDev->MaxQueue) {
			SelectUnit(IoPort, pDevice->UnitId);
		}

#endif //SUPPORT_TCQ

		if (btr(pChan->exclude_index) == 0){
			continue;						
		}

		if (pDev->DeviceFlags & DFLAGS_ARRAY_WAIT_EXEC) {
			PVirtualDevice    pArray = pDev->pArray;
			pDev->DeviceFlags &= ~DFLAGS_ARRAY_WAIT_EXEC;

			if((Srb = pArray->Srb) != 0) {
				pSrbExt = Srb->SrbExtension;

				if(pSrbExt->JoinMembers & pDev->ArrayMask) {
					pSrbExt->JoinMembers &= ~pDev->ArrayMask;

					if (pDev->DeviceFlags & DFLAGS_ARRAY_DISK) {
						if(pArray->arrayType == VD_SPAN){ 
							Span_Lba_Sectors(pDev, pSrbExt);
						}else{
							Stripe_Lba_Sectors(pDev, pSrbExt);
						}
					} else {
						pChan->Lba = pSrbExt->Lba;
						pChan->nSector = pSrbExt->nSector;
					}

					Srb->SrbStatus = SRB_STATUS_PENDING;
					StartIdeCommand(pDev ARG_SRB);

					if(Srb->SrbStatus != SRB_STATUS_PENDING){ 
						DeviceInterrupt(pDev, 1);			 
					}

					return;
				}
			}	
		}

		if((Srb = pDev->CurrentList) == 0) {
			if(pDev->DeviceFlags & (DFLAGS_WIN_FLUSH | DFLAGS_WIN_SHUTDOWN))
				Prepare_Shutdown(pDev);

			excluded_flags |= (1 << pChan->exclude_index);
			continue;
		}

		DISABLE		 

		/* Bugfix: by HS.Zhang
		 * We also need check the queue when device is an ATAPI device.
		 */

		if((pDev->DeviceFlags & DFLAGS_HARDDISK)){
		   if((pDev->CurrentList = Srb->NextSrb) == 0) {
			   pDev->DeviceFlags ^= DFLAGS_SORT_UP;
			   pDev->CurrentList = pDev->NextList;
			   pDev->NextList = 0;						 
		   }
		}else{
			if(Srb->NextSrb != NULL){
				pDev->CurrentList = Srb->NextSrb;
			}else{
				pDev->CurrentList = pDev->NextList;
				pDev->NextList = NULL;
			}
		}

		ENABLE

		WinStartCommand(pDev, Srb);
		return;
	}	
}

/******************************************************************
 * Put into queue
 *******************************************************************/

void PutQueue(PDevice pDevice, PSCSI_REQUEST_BLOCK Srb)
{
#define SrbLBA(x) ((PSrbExtension)x->SrbExtension)->Lba
	PSCSI_REQUEST_BLOCK pSrb, pSrb2;
	ULONG  startingSector;
	int  sort_up;

	if(pDevice->DeviceFlags & DFLAGS_HARDDISK){
		Srb->NextSrb = 0;

		if((pSrb = pDevice->CurrentList) == 0) {
			pDevice->CurrentList = Srb;
			return;
		}

		if(Srb->Function == SRB_FUNCTION_IO_CONTROL ||
		   (Srb->SrbFlags & (SRB_FLAGS_DATA_OUT | SRB_FLAGS_DATA_IN)) == 0) {
			Srb->NextSrb = pDevice->CurrentList;
			pDevice->CurrentList = Srb;
			return;
		}

		sort_up = (int)(pDevice->DeviceFlags & DFLAGS_SORT_UP);
		startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
						 ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
						 ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
						 ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

		SrbLBA(Srb) = startingSector;

		if(sort_up) {

			if(startingSector > SrbLBA(pSrb) || (pSrb = pDevice->NextList) != 0){
				goto sort;														 
			}
			goto put_first;

		} else if(startingSector < SrbLBA(pSrb) || 
				  (pSrb = pDevice->NextList) != 0) {
sort:
			pSrb2 = 0;
			do {
				if(sort_up)    {
					if(startingSector < SrbLBA(pSrb)){
						break;						  
					}
				} else if(startingSector > SrbLBA(pSrb)){
					break;								 
				}
				pSrb2 = pSrb;
			} while ((Srb = Srb->NextSrb) != 0);

			if(pSrb2) {
				Srb->NextSrb = pSrb2->NextSrb;
				pSrb2->NextSrb = Srb;
			} else {
				Srb->NextSrb = pSrb;
				if(pSrb == pDevice->NextList){
					pDevice->NextList = Srb;  
				}else{
					pDevice->CurrentList = Srb;
				}
			}
		}else{
put_first:
			pDevice->NextList = Srb;
		}
	}else{
		if(pDevice->CurrentList){
			if(pDevice->NextList != NULL){
				PSCSI_REQUEST_BLOCK pSrbTmp;

				pSrbTmp = pDevice->NextList;
				while(pSrbTmp->NextSrb != NULL){
					pSrbTmp = pSrbTmp->NextSrb;
				}
				pSrbTmp->NextSrb = Srb;
			}else{
				pDevice->NextList = Srb;
			}
		}else{
			pDevice->CurrentList = Srb;
		}
		/*  Bugfix: by HS.Zhang
		 *  We don't need this statement, because NextList has already
		 *  been assigned value before.
		 */
//		pDevice->NextList = Srb;
	}
}

/******************************************************************
 * exclude
 *******************************************************************/

int __declspec(naked) __fastcall btr (ULONG locate)
{
   _asm {
       xor  eax,  eax
       btr  excluded_flags, ecx
       adc  eax, eax
       ret
   }
}     


/******************************************************************
 * Map Lba to CHS
 *******************************************************************/

ULONG __declspec(naked) __fastcall MapLbaToCHS(ULONG Lba, WORD sectorXhead, BYTE head)
{
	 _asm	{
		  xchg    ecx, edx
        mov     eax, edx
        shr     edx, 16
        div     cx
        xchg    eax, edx
        div     byte ptr [esp+4]
        and     ax, 3F0Fh
        inc     ah
        xchg    al, ah
        xchg    dl, dh
        xchg    dh, ah
        ret
    } 
}

/******************************************************************
 * Ide Send command
 *******************************************************************/

void
IdeSendCommand(IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb)
{
	PChannel             pChan = pDev->pChannel;
	PIDE_REGISTERS_1     IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2     ControlPort = pChan->BaseIoAddress2;
	LONG                 MediaStatus;
	UCHAR	status;
	ULONG   i;
	PCDB    cdb = (PCDB)Srb->Cdb;
	PMODE_PARAMETER_HEADER   modeData;

	if ((pDev->DeviceFlags & DFLAGS_REMOVABLE_DRIVE) == 0){
		goto general;									   
	}

	if(pDev->ReturningMediaStatus & IDE_ERROR_END_OF_MEDIA) {
		Srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
		status = SRB_STATUS_ERROR;
		goto out;
	}

	if(Srb->Cdb[0] == SCSIOP_START_STOP_UNIT) {
		if (cdb->START_STOP.LoadEject == 1){
			OutPort(pChan->BaseBMI+0x7A, 0x10);
			NonIoAtaCmd(pDev, IDE_COMMAND_MEDIA_EJECT);
			OutPort(pChan->BaseBMI+0x7A, 0);
         goto good;
		}
	}

	if((pDev->DeviceFlags & DFLAGS_MEDIA_STATUS_ENABLED) != 0) {

		if(Srb->Cdb[0] == SCSIOP_REQUEST_SENSE) {
			status = IdeBuildSenseBuffer(pDev, Srb);
			goto out;
		}

		if(Srb->Cdb[0] == SCSIOP_MODE_SENSE || 
		   Srb->Cdb[0] == SCSIOP_TEST_UNIT_READY) {

			OutPort(pChan->BaseBMI+0x7A, 0x10);
			MediaStatus = GetMediaStatus(pDev);
			OutPort(pChan->BaseBMI+0x7A, 0);

			if ((MediaStatus & (IDE_STATUS_ERROR << 8)) == 0){ 
				pDev->ReturningMediaStatus = 0;				  
			}else{

				if(Srb->Cdb[0] == SCSIOP_MODE_SENSE) {
					if (MediaStatus & IDE_ERROR_DATA_ERROR) {
						//
						// media is write-protected, set bit in mode sense buffer
						//
						modeData = (PMODE_PARAMETER_HEADER)Srb->DataBuffer;

						Srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER);
						modeData->DeviceSpecificParameter |= MODE_DSP_WRITE_PROTECT;
					}
				} else{

					if ((UCHAR)MediaStatus != IDE_ERROR_DATA_ERROR) {
						//
						// Request sense buffer to be build
						//
						status = MapAtaErrorToOsError((UCHAR)MediaStatus, Srb);
						goto out;
					}  
				}
			}
		}
		goto good;
	}


general:
	switch (Srb->Cdb[0]) {
		case SCSIOP_INQUIRY:
		//
		// Filter out all TIDs but 0 and 1 since this is an IDE interface
		// which support up to two devices.
		//
			if (Srb->Lun != 0) {
				//
				// Indicate no device found at this address.
				//
				status = SRB_STATUS_SELECTION_TIMEOUT;
				break;
			}else {
				PINQUIRYDATA inquiryData = Srb->DataBuffer;
#ifdef WIN95
				DCB_COMMON* pDcb=(*(IOP**)((int)Srb+0x40))->IOP_physical_dcb;
				pDcb->DCB_device_flags |= DCB_DEV_SPINDOWN_SUPPORTED;
				if(pDev->DeviceFlags & DFLAGS_LS120) 
					pDcb->DCB_device_flags2 |= 0x40;
#endif
				//
				// Zero INQUIRY data structure.
				//
				ZeroMemory(Srb->DataBuffer, Srb->DataTransferLength);

				//
				// Standard IDE interface only supports disks.
				//
				inquiryData->DeviceType = DIRECT_ACCESS_DEVICE;

				//
				// Set the removable bit, if applicable.
				//
				if ((pDev->DeviceFlags & DFLAGS_REMOVABLE_DRIVE) || 
					  (pDev->IdentifyData.GeneralConfiguration & 0x80))
					inquiryData->RemovableMedia = 1;

				//
				// Fill in vendor identification fields.
				//
				for (i = 0; i < 20; i += 2) {
					inquiryData->VendorId[i] =
											  ((PUCHAR)pDev->IdentifyData.ModelNumber)[i + 1];
					inquiryData->VendorId[i+1] =
												((PUCHAR)pDev->IdentifyData.ModelNumber)[i];
				}

				//
				// Initialize unused portion of product id.
				//
				for (i = 0; i < 4; i++){
					inquiryData->ProductId[12+i] = ' ';
				}

				//
				// Move firmware revision from IDENTIFY data to
				// product revision in INQUIRY data.
				//
				for (i = 0; i < 4; i += 2) {
					inquiryData->ProductRevisionLevel[i] =
						((PUCHAR)pDev->IdentifyData.FirmwareRevision)[i+1];
					inquiryData->ProductRevisionLevel[i+1] =
						((PUCHAR)pDev->IdentifyData.FirmwareRevision)[i];
				}
				goto good;
			}

			break;

		case SCSIOP_READ_CAPACITY:
			//
			// Claim 512 byte blocks (big-endian).
			//
			((PREAD_CAPACITY_DATA)Srb->DataBuffer)->BytesPerBlock = 0x20000;
			i = (pDev->pArray)? pDev->pArray->capacity : pDev->capacity;

			((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress =
				(((PUCHAR)&i)[0] << 24) |  (((PUCHAR)&i)[1] << 16) |
				(((PUCHAR)&i)[2] << 8) | ((PUCHAR)&i)[3];

		case SCSIOP_START_STOP_UNIT:
		case SCSIOP_TEST_UNIT_READY:
good:
			status = SRB_STATUS_SUCCESS;
			break;

		case SCSIOP_READ:
#ifdef SUPPORT_XPRO
			if(Srb->Function != SRB_FUNCTION_IO_CONTROL){
				need_read_ahead = 1;
			}
#endif
		case SCSIOP_WRITE:
		case SCSIOP_VERIFY:
			pChan->Lba = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
						 ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
						 ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
						 ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;			 
			
			pChan->nSector = (UCHAR)(((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb |
									 ((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8);
			
//			pChan->nSector = (UCHAR)((Srb->DataTransferLength + 0x1FF) / 0x200);

  			if((pDev->DeviceFlags & DFLAGS_HAS_LOCKED)&&
			   (((((PSrbExtension)(Srb->SrbExtension))->WorkingFlags) & SRB_WFLAGS_MUST_DONE) == 0)){
				if(MAX(pChan->Lba, pDev->nLockedLbaStart) <=
				   MIN(pChan->Lba+pChan->nSector, pDev->nLockedLbaEnd)){

					PutQueue(pDev, Srb);
					excluded_flags |= (1 << pChan->exclude_index);
					return;
				}
			}
			
			NewIdeIoCommand(pDev, Srb);
			return;

		default:

			status = SRB_STATUS_INVALID_REQUEST;

	} // end switch
out:
	if(pDev->pArray) {
		LOC_SRBEXT_PTR
		pSrbExt->WaitInterrupt = pSrbExt->JoinMembers = 0;
	}

	Srb->SrbStatus = status;

} // end IdeSendCommand()


/******************************************************************
 * global data
 *******************************************************************/

VOID
IdeMediaStatus(BOOLEAN EnableMSN, IN PDevice pDev)
{
    PChannel             pChan = pDev->pChannel;
    PIDE_REGISTERS_1     IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2     ControlPort = pChan->BaseIoAddress2;

    if (EnableMSN == TRUE){
        //
        // If supported enable Media Status Notification support
        //
		SelectUnit(IoPort, pDev->UnitId);
        ScsiPortWritePortUchar((PUCHAR)IoPort + 1, (UCHAR)0x95);

        if ((NonIoAtaCmd(pDev, IDE_COMMAND_ENABLE_MEDIA_STATUS) 
             & (IDE_STATUS_ERROR << 8)) == 0) {
            pDev->DeviceFlags |= DFLAGS_MEDIA_STATUS_ENABLED;
            pDev->ReturningMediaStatus = 0;
        }
    }
    else 

    if (pDev->DeviceFlags & DFLAGS_MEDIA_STATUS_ENABLED) {
        //
        // disable if previously enabled
        //
		SelectUnit(IoPort, pDev->UnitId);
        ScsiPortWritePortUchar((PUCHAR)IoPort + 1, (UCHAR)0x31);
        NonIoAtaCmd(pDev, IDE_COMMAND_ENABLE_MEDIA_STATUS);

       pDev->DeviceFlags &= ~DFLAGS_MEDIA_STATUS_ENABLED;
    }
}


/******************************************************************
 * 
 *******************************************************************/

UCHAR
IdeBuildSenseBuffer(IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb)

/*++
    Builts an artificial sense buffer to report the results of a
    GET_MEDIA_STATUS command. This function is invoked to satisfy
    the SCSIOP_REQUEST_SENSE.
++*/
{
    PSENSE_DATA senseBuffer = (PSENSE_DATA)Srb->DataBuffer;

    if (senseBuffer) {
        if (pDev->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE) {
            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey  = SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }
        else if (pDev->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE_REQ) {
            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey  = SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }
        else if (pDev->ReturningMediaStatus & IDE_ERROR_END_OF_MEDIA) {
            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey  = SCSI_SENSE_NOT_READY;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }
        else if (pDev->ReturningMediaStatus & IDE_ERROR_DATA_ERROR) {
            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey  = SCSI_SENSE_DATA_PROTECT;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }

        return SRB_STATUS_SUCCESS;
    }

    return SRB_STATUS_ERROR;

}// End of IdeBuildSenseBuffer

/******************************************************************
 * Map Ata Error To Windows Error
 *******************************************************************/

UCHAR
MapAtapiErrorToOsError(IN UCHAR errorByte, IN PSCSI_REQUEST_BLOCK Srb)
{
    UCHAR srbStatus;
    UCHAR scsiStatus;

    switch (errorByte >> 4) {
    case SCSI_SENSE_NO_SENSE:

        scsiStatus = 0;

        // OTHERWISE, THE TAPE WOULDN'T WORK
        scsiStatus = SCSISTAT_CHECK_CONDITION;

        srbStatus = SRB_STATUS_ERROR;
        break;

    case SCSI_SENSE_RECOVERED_ERROR:

        scsiStatus = 0;
        srbStatus = SRB_STATUS_SUCCESS;
        break;

    case SCSI_SENSE_NOT_READY:

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
        break;

    case SCSI_SENSE_MEDIUM_ERROR:

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
        break;

    case SCSI_SENSE_HARDWARE_ERROR:

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
        break;

    case SCSI_SENSE_ILLEGAL_REQUEST:

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
        break;

    case SCSI_SENSE_UNIT_ATTENTION:

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
        break;

    default:
        scsiStatus = 0;

        // OTHERWISE, THE TAPE WOULDN'T WORK
        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
        break;
    }

    Srb->ScsiStatus = scsiStatus;

    return srbStatus;
}


UCHAR
MapAtaErrorToOsError(IN UCHAR errorByte, IN PSCSI_REQUEST_BLOCK Srb)
{
    UCHAR srbStatus;
    UCHAR scsiStatus;

    scsiStatus = 0;

    if (errorByte & IDE_ERROR_MEDIA_CHANGE_REQ) {

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
    }

    else if (errorByte & IDE_ERROR_COMMAND_ABORTED) {

        srbStatus = SRB_STATUS_ABORTED;
        scsiStatus = SCSISTAT_CHECK_CONDITION;

        if (Srb->SenseInfoBuffer) {
            PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey = SCSI_SENSE_ABORTED_COMMAND;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;

            srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        }
    }

    else if (errorByte & IDE_ERROR_END_OF_MEDIA) {

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
    }

    else if (errorByte & IDE_ERROR_ILLEGAL_LENGTH) {

        srbStatus = SRB_STATUS_INVALID_REQUEST;
    }

    else if (errorByte & IDE_ERROR_BAD_BLOCK) {

        srbStatus = SRB_STATUS_ERROR;
        scsiStatus = SCSISTAT_CHECK_CONDITION;

        if (Srb->SenseInfoBuffer) {
            PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey = SCSI_SENSE_MEDIUM_ERROR;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;

            srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        }
    }

    else if (errorByte & IDE_ERROR_ID_NOT_FOUND) {

        srbStatus = SRB_STATUS_ERROR;
        scsiStatus = SCSISTAT_CHECK_CONDITION;

        if (Srb->SenseInfoBuffer) {
            PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey = SCSI_SENSE_MEDIUM_ERROR;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;

            srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        }
    }

    else if (errorByte & IDE_ERROR_MEDIA_CHANGE) {

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;

        if (Srb->SenseInfoBuffer) {
            PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey = SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;

            srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        }
    }

    else if (errorByte & IDE_ERROR_DATA_ERROR) {

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;

        //
        // Build sense buffer
        //
        if (Srb->SenseInfoBuffer) {
            PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey = SCSI_SENSE_MEDIUM_ERROR;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;

            srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        }
    }
    

    //
    // Set SCSI status to indicate a check condition.
    //
    Srb->ScsiStatus = scsiStatus;

    return srbStatus;

} // end MapError()

#endif // not _BIOS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\win.c ===
/***************************************************************************
 * File:          Win.c
 * Description:   The OS depended interface routine for win9x & winNT
 * Author:        DaHai Huang    (DH)
 *                Steve Chang		(SC)
 *                HS  Zhang      (HZ)
 *   					SLeng          (SL)
 *
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/03/2000	HS.Zhang	Remove some unuse local variables.
 *		11/06/2000	HS.Zhang	Added this header
 *		11/14/2000	HS.Zhang	Added ParseArgumentString functions
 *		11/16/2000	SLeng		Added MointerDisk function
 *		11/20/2000	SLeng		Forbid user's operation before array become usable
 *		11/28/2000  SC			modify to fix removing any hard disk on a RAID 0+1 case 
 *		12/04/2000	SLeng		Added code to check excluded_flags in MointerDisk
 *		2/16/2001	gmm			Add PrepareForNotification() call in DriverEntry()
 *		2/21/2001	gmm			call SrbExt->pfnCallback in AtapiResetController()
 ***************************************************************************/
#include "global.h"
#include "devmgr.h"
#include "hptioctl.h"
#include "limits.h"

#ifndef _BIOS_


/////////////////
              // Added by SLeng
              //
#define INTEL_815_CHIPSET	0x11308086	// VenderID & DeviceID

#if defined(SUPPORT_XPRO)
/*++
Function:
	ULONG ScanBadChipset(void)

Description:
	Check the chipset whether is Intel 815 chipset

Arguments:
	none

Return:
	ULONG -- 0: The Intel 815 chipset has not be detected
	         1: The Intel 815 chipset has be detected
--*/
ULONG ScanBadChipset(void)
{
	PCI1_CFG_ADDR	pci1_cfg = {0,};
	USHORT			iDev, iBus, iFun;

	pci1_cfg.enable  = 1;
	pci1_cfg.reg_num = 0;

	for(iBus = 0; iBus < MAX_PCI_BUS_NUMBER; iBus++)
	{
		for(iDev = 0; iDev < PCI_MAX_DEVICES; iDev++)
		{
			for(iFun = 0; iFun < PCI_MAX_FUNCTION; iFun++)
			{
				pci1_cfg.bus_num = iBus;
				pci1_cfg.dev_num = iDev;
				pci1_cfg.fun_num = iFun;
				
				ScsiPortWritePortUlong((PULONG)CFG_INDEX, *((PULONG)&pci1_cfg));

				if(ScsiPortReadPortUlong((PULONG)CFG_DATA) == INTEL_815_CHIPSET)
				{	return 1; }

			}
		}
	}

	return 0;
}
#endif // SUPPORT_XPRO

int		DiskRemoved = 0;		// The number of removed disk
/*++
Function:
	MonitorDisk

Description:
	Detect whether the removed disk has been added by hot plug

Arguments:
	pChan

Return:
	void
--*/
void MonitorDisk(IN PChannel pChan)
{
	extern	USHORT		pioTiming[6];
	ST_XFER_TYPE_SETTING osAllowedMaxXferMode;
	LOC_IDENTIFY
	PDevice				pDevMon;
	PChannel			pChanMon;
	PIDE_REGISTERS_1	IoPort;
	PIDE_REGISTERS_2	ControlPort;
	UCHAR				statusByte, mod;
	int					nChan, nDev;
    PBadModeList		pbd;

	// Check if any disk inserted
	for(nChan = 0; nChan < 2; nChan++)
	{
		pChanMon = &pChan->HwDeviceExtension->IDEChannel[nChan];
		IoPort	 = pChanMon->BaseIoAddress1;
		ControlPort = pChanMon->BaseIoAddress2;

		for(nDev = 0; nDev < 2; nDev++)
		{
			if (pChanMon->pDevice[nDev] != 0)	// If the device present already
			{	
				pDevMon = &pChanMon->Devices[nDev];
				if( pDevMon->stErrorLog.nLastError != DEVICE_REMOVED)
				{	continue;	}
			}
			pDevMon = &pChanMon->Devices[nDev];
			pDevMon->UnitId = (nDev) ? 0xB0 : 0xA0;

			// Check if the channel busy
			if( btr(pChanMon->exclude_index) == 0 )
			{
				goto _NEXT_DEV_;
			}

			/*===========================================================
			 * Check if the device present
			 *===========================================================*/
			SelectUnit(IoPort, pDevMon->UnitId);
			statusByte = GetStatus(ControlPort);
			if(statusByte != IDE_STATUS_IDLE)	// If the Device isn't idle
			{
				goto _NEXT_DEV_;
			}

			SetBlockNumber(IoPort, 0x55);
			SetBlockCount(IoPort, 0);
			if(GetBlockNumber(IoPort) != 0x55)
			{	
				goto _NEXT_DEV_;
			}
			SetBlockNumber(IoPort, 0xAA);
			if(GetBlockNumber(IoPort) != 0xAA)
			{
				goto _NEXT_DEV_;
			}

			// Check if the device is a ATAPI one
			if( GetByteLow(IoPort) == 0x14 && GetByteHigh(IoPort) == 0xEB )
			{
				goto _NEXT_DEV_;
			}
			
			// Read identification data for the device
			if(IssueIdentify(pDevMon, IDE_COMMAND_IDENTIFY ARG_IDENTIFY) == FALSE)
			{
				goto _NEXT_DEV_;
			}

			pDevMon->DeviceFlags = DFLAGS_HARDDISK;	// Hard disk
			pDevMon->DeviceFlags2 = 0; 

			/*===========================================================
			 * Copy Basic Info
			 *===========================================================*/
			SetMaxCmdQueue(pDevMon, Identify.MaxQueueDepth & 0x1F);

			pDevMon->DeviceFlags |= (UCHAR)((Identify.Capabilities  >> 9) & 1);
			pDevMon->MultiBlockSize = Identify.MaximumBlockTransfer << 7;
			
			if( Identify.TranslationFieldsValid & 1 )
			{
				pDevMon->RealHeader = (UCHAR)Identify.NumberOfCurrentHeads;
				pDevMon->RealSector = (UCHAR)Identify.CurrentSectorsPerTrack;
				pDevMon->capacity = ( (Identify.CurrentSectorCapacity < Identify.UserAddressableSectors) 
									 ? Identify.UserAddressableSectors : Identify.CurrentSectorCapacity
								 ) - 1;
			}
			else
			{
				pDevMon->RealHeader = (UCHAR)Identify.NumberOfHeads;
				pDevMon->RealSector = (UCHAR)Identify.SectorsPerTrack;
				pDevMon->capacity   = Identify.UserAddressableSectors - 1;
			}

			pDevMon->RealHeadXsect = pDevMon->RealSector * pDevMon->RealHeader;
			
			/*===========================================================
			 * Select Best PIO mode
			 *===========================================================*/   
			if((mod = Identify.PioCycleTimingMode) > 4)
			{	mod = 0;	}
			if((Identify.TranslationFieldsValid & 2) &&
			   (Identify.Capabilities & 0x800) && (Identify.AdvancedPIOModes))
			{
				if(Identify.MinimumPIOCycleTime > 0)
				{
					for (mod = 5; mod > 0 &&
							   Identify.MinimumPIOCycleTime > pioTiming[mod]; mod-- )
					{   ;	}
				}
				else
				{
					mod = (UCHAR)((Identify.AdvancedPIOModes & 0x1) ? 3 :
								  (Identify.AdvancedPIOModes & 0x2) ? 4 :
								  (Identify.AdvancedPIOModes & 0x4) ? 5 : mod);
				}

			}
			osAllowedMaxXferMode.Mode = pChan->HwDeviceExtension->m_rgWinDeviceXferModeSettings[nChan][nDev].Mode;
			if(osAllowedMaxXferMode.XferType == XFER_TYPE_PIO)
			{
				mod = MIN(osAllowedMaxXferMode.XferMode, mod);
			}
			pDevMon->bestPIO = (UCHAR)mod;

			/*===========================================================
			 * Select Best Multiword DMA mode
			 *===========================================================*/   
#ifdef USE_DMA
			// Check mw dma
			if( (Identify.Capabilities & 0x100) && (Identify.MultiWordDMASupport & 6) )
			{
				pDevMon->bestDMA = (UCHAR)((Identify.MultiWordDMASupport & 4) ? 2 : 1);
				if(osAllowedMaxXferMode.XferType == XFER_TYPE_MDMA)
				{
					pDevMon->bestDMA = MIN(osAllowedMaxXferMode.XferMode, pDevMon->bestDMA);
				}
				else if(osAllowedMaxXferMode.XferType < XFER_TYPE_MDMA)
				{
					pDevMon->bestDMA = 0xFF;
				}
			}
			else
#endif	// USE_DMA
				pDevMon->bestDMA = 0xFF;

			/*===========================================================
			 * Select Best Ultra DMA mode
			 *===========================================================*/   
			if((pChanMon->ChannelFlags & IS_80PIN_CABLE) &&
				((InPort(pChanMon->BaseBMI + 0x7A) << 4) & pChanMon->ChannelFlags))
			{	pChanMon->ChannelFlags &= ~IS_80PIN_CABLE;	}

#ifdef USE_DMA
			if(Identify.TranslationFieldsValid & 0x4)
			{
				mod = (UCHAR)((Identify.UtralDmaMode & 0x20) ? 5 :
							  (Identify.UtralDmaMode & 0x08) ? 4 :
							  (Identify.UtralDmaMode & 0x10) ? 3 :
							  (Identify.UtralDmaMode & 0x04) ? 2 :		// Ultra DMA Mode 2
							  (Identify.UtralDmaMode & 0x02) ? 1 : 0);	// Ultra DMA Mode 1

				if((pChanMon->ChannelFlags & IS_80PIN_CABLE) == 0 && mod > 2)
				{	mod = 2;	}

				if(osAllowedMaxXferMode.XferType == XFER_TYPE_UDMA)
				{
					mod = MIN(osAllowedMaxXferMode.XferMode, mod);
				}
				else if(osAllowedMaxXferMode.XferType < XFER_TYPE_MDMA)
				{
					mod = 0xFF;
				}
				pDevMon->bestUDMA = (UCHAR)mod;

			}
			else
#endif	//USE_DMA
				pDevMon->bestUDMA = 0xFF;

			/*===========================================================
			 * Select Best mode 
			 *===========================================================*/   
			pbd = check_bad_disk((PUCHAR)&Identify.ModelNumber, pChanMon);

			if((pbd->UltraDMAMode | pDevMon->bestUDMA) != 0xFF)
			{
				pDevMon->Usable_Mode = (UCHAR)((MIN(pbd->UltraDMAMode, pDevMon->bestUDMA)) + 8);
			}
			else if((pbd->DMAMode | pDevMon->bestDMA) != 0xFF)
			{ 
				pDevMon->Usable_Mode = (UCHAR)((MIN(pbd->DMAMode, pDevMon->bestDMA)) + 5);
			}
			else
			{
				pDevMon->Usable_Mode = MIN(pbd->PIOMode, pDevMon->bestPIO);
			}
			
			OS_Identify(pDevMon);

			if((pDevMon->DeviceFlags & DFLAGS_ATAPI) == 0)
			{	SetDevice(pDevMon);	}

#ifdef DPLL_SWITCH
			if((pChanMon->ChannelFlags & IS_HPT_370) && pDevMon->Usable_Mode == 13)
			{
				if(pChanMon->ChannelFlags & IS_DPLL_MODE)
				{	pDevMon->DeviceFlags |= DFLAGS_NEED_SWITCH;	}
			}
#endif
			DeviceSelectMode(pDevMon, pDevMon->Usable_Mode);

			if(pChanMon->pSgTable == NULL)
			{
				pDevMon->DeviceFlags &= ~(DFLAGS_DMA | DFLAGS_ULTRA);
			}

			// Notify the utility that a disk added by hot plug
			DiskRemoved--;
			//pDevMon->pArray->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
			pDevMon->DeviceFlags2 |= DFLAGS_NEW_ADDED;
			ReportError(pDevMon, DEVICE_PLUGGED, pChanMon->CurrentSrb);
_NEXT_DEV_:
			excluded_flags |= (1 << pChanMon->exclude_index);
		}
	}

	// Check if any disks removed
	if(DiskRemoved > 0)
	{
		// Continue Monitoring
		ScsiPortNotification( RequestTimerCall,
							  pDevMon->pChannel->HwDeviceExtension,
							  pDevMon->pChannel->CallBack,
							  MONTOR_TIMER_COUNT
							 );
	}

}
/////////////////


BOOLEAN
   HptIsValidDeviceSpecifiedIoControl(IN PSCSI_REQUEST_BLOCK pSrb);
   
ULONG
   HptIoControl(
				IN PHW_DEVICE_EXTENSION HwDeviceExtension,
				IN PSCSI_REQUEST_BLOCK	pSrb
			   );

/******************************************************************
 * global data
 *******************************************************************/

ULONG setting370_50[] = {
	CLK50_370PIO0, CLK50_370PIO1, CLK50_370PIO2, CLK50_370PIO3, CLK50_370PIO4,
	CLK50_370DMA0, CLK50_370DMA1, CLK50_370DMA2, 
	CLK50_370UDMA0, CLK50_370UDMA1, CLK50_370UDMA2, CLK50_370UDMA3,
	CLK50_370UDMA4, CLK50_370UDMA5, 0xad9f50bL
};    

ULONG setting370_33[] = {
	CLK33_370PIO0, CLK33_370PIO1, CLK33_370PIO2, CLK33_370PIO3, CLK33_370PIO4,
	CLK33_370DMA0, CLK33_370DMA1, CLK33_370DMA2, 
	CLK33_370UDMA0, CLK33_370UDMA1, CLK33_370UDMA2, CLK33_370UDMA3,
	CLK33_370UDMA4, CLK33_370UDMA5, 0xad9f50bL
};

ULONG setting366[] = {
	CLK33_366PIO0, CLK33_366PIO1, CLK33_366PIO2, CLK33_366PIO3, CLK33_366PIO4,
	CLK33_366DMA0, CLK33_366DMA1, CLK33_366DMA2, 
	CLK33_366UDMA0, CLK33_366UDMA1, CLK33_366UDMA2, CLK33_366UDMA3,
	CLK33_366UDMA4, 0, 0x120a7a7L
};

VirtualDevice   VirtualDevices[MAX_V_DEVICE];

PVirtualDevice  pLastVD = VirtualDevices;
UINT            Hpt_Slot = 0;
UINT            Hpt_Bus = 0;
ULONG           excluded_flags = 0xFFFFFFFF;

BOOLEAN
   HwInitializeWrapper(IN PHW_DEVICE_EXTENSION HwDeviceExtension)
{																	  
	return HwDeviceExtension->HwInitialize(HwDeviceExtension);
}  

BOOLEAN
   HwInterruptWrapper(IN PHW_DEVICE_EXTENSION HwDeviceExtension)
{
	return HwDeviceExtension->HwInterrupt(HwDeviceExtension);
}						  
	
// a function to initilalize all globle vars
void InitializeGlobalVar()
{
	w95_initialize();
}
/******************************************************************
 * Driver Entry
 *******************************************************************/
ULONG
   DriverEntry(IN PVOID DriverObject, IN PVOID Argument2)
{
	HW_INITIALIZATION_DATA hwInitializationData;
	HPT_FIND_CONTEXT	hptContext;
	ULONG   status = 0;
	ULONG   VendorStr = '3011';
	ULONG   DeviceStr = '4000';

	excluded_flags = 0xFFFFFFFF;
	pLastVD = VirtualDevices;
	exlude_num = EXCLUDE_HPT366;
	Hpt_Slot = 0;
	Hpt_Bus = 0;			

	InitializeGlobalVar();
#ifndef WIN95
	PrepareForNotification(NULL);
#endif
/////////////////
              // Modified by SLeng, 2000-10-10
              //
#if defined(SUPPORT_XPRO)
	// If the Intel 815 chipset has not be detected
	if(!ScanBadChipset())
	{	
		start_ifs_hook((PCHAR)Argument2);
	}
#endif // SUPPORT_XPRO
/////////////////

	w95_scan_all_adapters();

	//
	// Zero out structure.
	//
	ZeroMemory((PUCHAR)&hwInitializationData, sizeof(HW_INITIALIZATION_DATA));

	ZeroMemory((PUCHAR)&hptContext, sizeof(hptContext));

	//
	// Set size of hwInitializationData.
	//
	hwInitializationData.HwInitializationDataSize =	sizeof(HW_INITIALIZATION_DATA);

	//
	// Set entry points.
	//
	hwInitializationData.HwResetBus  = AtapiResetController;
	hwInitializationData.HwStartIo   = AtapiStartIo;
	hwInitializationData.HwAdapterState = AtapiAdapterState;
	hwInitializationData.SrbExtensionSize = sizeof(SrbExtension);

///#ifdef WIN95
	// Indicate need physical addresses.
	// NOTE: In NT, if set NeedPhysicalAddresses to TRUE, PIO will not work.
	// Win95 requires these
	// (We can and must set NeedPhysicalAddresses to TRUE in Win 95)
	//
	hwInitializationData.NeedPhysicalAddresses = TRUE;
///#endif //WIN95

#ifdef WIN2000
	hwInitializationData.HwAdapterControl = AtapiAdapterControl;
#endif //WIN2000


	//
	// Specify size of extensions.
	//
	hwInitializationData.SpecificLuExtensionSize = 0;

	//
	// Indicate PIO device (It is possible to use PIO operation)
	//
	hwInitializationData.MapBuffers = TRUE;

	//
	// Indicate bustype.
	//
	hwInitializationData.AdapterInterfaceType = PCIBus;

	hwInitializationData.VendorIdLength = 4;
	hwInitializationData.VendorId = &VendorStr;
	hwInitializationData.DeviceIdLength = 4;
	hwInitializationData.DeviceId = &DeviceStr;

	//
	// Call initialization for the bustype.
	//
	hwInitializationData.HwInitialize = HwInitializeWrapper;
	hwInitializationData.HwInterrupt = HwInterruptWrapper;
	hwInitializationData.HwFindAdapter = AtapiFindController;
	hwInitializationData.NumberOfAccessRanges = 5;
	hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

	status = ScsiPortInitialize(
								 DriverObject,
								 Argument2,
								 &hwInitializationData,
								 &hptContext
							   );

	return status;

} // end DriverEntry()


/*++
Function:
    BOOLEAN FindPnpAdapter

Description:
	Check the device passed by scsiport whether is our adapter

Arguments:
    deviceExtension - HBA miniport driver's adapter data storage
	ConfigInfo - Port config info passed form scsiport

Returns:
	SP_RETURN_FOUND :	The adapter is our adapter
	SP_RETURN_BAD_CONFIG: The config info passed form scsiport is invalid
	SP_RETURN_NOT_FOUND: The adapter is not out adapter
--*/
ULONG
   FindPnpAdapter(
				  IN PHW_DEVICE_EXTENSION	deviceExtension,
				  IN OUT PPORT_CONFIGURATION_INFORMATION	ConfigInfo
				 )
{
	PCI_COMMON_CONFIG	pciConfig;
	ULONG	nStatus = SP_RETURN_NOT_FOUND;

	if(ScsiPortGetBusData(deviceExtension,
						  PCIConfiguration,
						  ConfigInfo->SystemIoBusNumber,
						  ConfigInfo->SlotNumber,
						  &pciConfig,
						  PCI_COMMON_HDR_LENGTH) == PCI_COMMON_HDR_LENGTH){

		if(*(PULONG)(&pciConfig.VendorID) == SIGNATURE_366){
			if((pciConfig.RevisionID == 0x03)||(pciConfig.RevisionID == 0x04)){ // 370 & 370A
				if(((*ConfigInfo->AccessRanges)[0].RangeInMemory == TRUE)||
				   ((*ConfigInfo->AccessRanges)[1].RangeInMemory == TRUE)||
				   ((*ConfigInfo->AccessRanges)[2].RangeInMemory == TRUE)||
				   ((*ConfigInfo->AccessRanges)[3].RangeInMemory == TRUE)||
				   ((*ConfigInfo->AccessRanges)[4].RangeInMemory == TRUE)||
				   ((*ConfigInfo->AccessRanges)[0].RangeLength < 8)||
				   ((*ConfigInfo->AccessRanges)[1].RangeLength < 4)||
				   ((*ConfigInfo->AccessRanges)[2].RangeLength < 8)||
				   ((*ConfigInfo->AccessRanges)[3].RangeLength < 4)||
				   ((*ConfigInfo->AccessRanges)[4].RangeLength < 0x100)
				  ){
					nStatus = SP_RETURN_BAD_CONFIG;
				}else{
					nStatus = SP_RETURN_FOUND;
				}
			}
/*** mark out ****
			else if(pciConfig.RevisionID == 0x02){ // 368
				if(((*ConfigInfo->AccessRanges)[0].RangeInMemory == TRUE)||
				   ((*ConfigInfo->AccessRanges)[1].RangeInMemory == TRUE)||
				   ((*ConfigInfo->AccessRanges)[2].RangeInMemory == TRUE)||
				   ((*ConfigInfo->AccessRanges)[0].RangeLength < 8)||
				   ((*ConfigInfo->AccessRanges)[1].RangeLength < 4)||
				   ((*ConfigInfo->AccessRanges)[2].RangeLength < 0x100)
				  ){
					nStatus = SP_RETURN_BAD_CONFIG;
				}else{
					ConfigInfo->NumberOfAccessRanges = 3;
					nStatus = SP_RETURN_FOUND;
				}
			}
***/
		}
	}

	return nStatus;
}
/*++
Function:
    BOOLEAN FindLegacyAdapter

Description:
	Searching the bus for looking for our adapter

Arguments:
    deviceExtension - HBA miniport driver's adapter data storage
	ConfigInfo - Port config info passed form scsiport
	pHptContext - Our searching structure

Returns:
	SP_RETURN_FOUND :	The adapter is our adapter
	SP_RETURN_NOT_FOUND: The adapter is not out adapter
--*/
ULONG
   FindLegacyAdapter(
					 IN PHW_DEVICE_EXTENSION	deviceExtension,
					 IN OUT PPORT_CONFIGURATION_INFORMATION	ConfigInfo,
					 IN OUT PHPT_FIND_CONTEXT	pHptContext
					)
{
	PCI_COMMON_CONFIG   pciConfig;
	//
	// check every slot & every function
	// because our adapter only have two functions, so we just need check two functions
	//
	while(TRUE){
		while(pHptContext->nSlot.u.bits.FunctionNumber < 1){
			if(ScsiPortGetBusData(deviceExtension,
								  PCIConfiguration,
								  ConfigInfo->SystemIoBusNumber,
								  pHptContext->nSlot.u.AsULONG,
								  &pciConfig,
								  PCI_COMMON_HDR_LENGTH) == PCI_COMMON_HDR_LENGTH){
				//
				// Now check for the VendorID & Revision of PCI config,
				// to ensure it is whether out adapter.
				//
				if(*(PULONG)&pciConfig.VendorID == SIGNATURE_366){
					int i;
					switch(pciConfig.RevisionID){
						case 0x01:
						case 0x02:		// hpt368
							break;
							//ConfigInfo->NumberOfAccessRanges = 3;
						case 0x03:		// hpt370
						case 0x04:		// hpt370a
							i = ConfigInfo->NumberOfAccessRanges - 1;
							//
							// setup config I/O info's range BMI
							//
							(*ConfigInfo->AccessRanges)[i].RangeStart =
								ScsiPortConvertUlongToPhysicalAddress(pciConfig.u.type0.BaseAddresses[i] & ~1);
							(*ConfigInfo->AccessRanges)[i].RangeInMemory = FALSE;
							(*ConfigInfo->AccessRanges)[i].RangeLength = 0x100;

							i--;

							while( i > 0 ){
								//
								// setup config I/O info's range ATAPI io space
								// 
								(*ConfigInfo->AccessRanges)[i-1].RangeStart =
									ScsiPortConvertUlongToPhysicalAddress(pciConfig.u.type0.BaseAddresses[i-1] & ~1);
								(*ConfigInfo->AccessRanges)[i-1].RangeInMemory = FALSE;
								(*ConfigInfo->AccessRanges)[i-1].RangeLength = 8;
								//
								// setup config I/O info's range ATAPI io space
								//
								(*ConfigInfo->AccessRanges)[i].RangeStart =
									ScsiPortConvertUlongToPhysicalAddress(pciConfig.u.type0.BaseAddresses[i] & ~1);
								(*ConfigInfo->AccessRanges)[i].RangeInMemory = FALSE;
								(*ConfigInfo->AccessRanges)[i].RangeLength = 4;

								i = i - 2;
							}

							ConfigInfo->BusInterruptLevel = pciConfig.u.type0.InterruptLine;

							ConfigInfo->InterruptMode = LevelSensitive;

							ConfigInfo->SlotNumber = pHptContext->nSlot.u.AsULONG;

							pHptContext->nSlot.u.bits.FunctionNumber ++;
							return SP_RETURN_FOUND;
					}
				}
			}	  
			//
			// if the adapter not present in first function,
			// it should not present in next function too.
			// so just break out this loop, continue search next slot.
			//
			break;									  
		} 
		// next slot
		pHptContext->nSlot.u.bits.FunctionNumber = 0;
		if(pHptContext->nSlot.u.bits.DeviceNumber < 0x1F){
			pHptContext->nSlot.u.bits.DeviceNumber ++;
		}else{
			break;
		}
	}				
	return SP_RETURN_NOT_FOUND;
}
				
/***
 *my_strtoul(nptr) - Convert ascii string to long unsigned int.
 *
 *Purpose:
 *       Convert an ascii string to a long 32-bit value.  The base
 *       is determine by:
 *               (a) First char = '0', second char = 'x' or 'X',
 *                   use base 16.
 *               (b) First char = '0', use base 8
 *               (c) First char in range '1' - '9', use base 10.
 *
 *       See ANSI standard for details
 *
 *Entry:
 *       nptr == NEAR/FAR pointer to the start of string.
 *
 *       string format: [whitespace] [sign] [0] [x] [digits/letters]
 *
 *Exit:
 *       Good return:
 *               result
 *
 *       Overflow return:
 *				0
 *       No digits or bad base return:
 *              0
 *Exceptions:
 *       None.
 *******************************************************************************/

unsigned long my_strtoul (
   const char *nptr
   )
{			
	const char *p;
	char c;
	unsigned long number;
	unsigned digval;
	unsigned long maxval;
	int ibase;

	p = nptr;                       /* p is our scanning pointer */
	number = 0;                     /* start with zero */

	c = *p++;                       /* read char */
	
	while ((c == ' ')||(c == 0x9)){
		c = *p++;               /* skip whitespace */
	}

	/* determine base free-lance, based on first two chars of
	string */
	if (c != '0')
		ibase = 10;
	else if (*p == 'x' || *p == 'X')
		ibase = 16;
	else
		ibase = 8;

	if (ibase == 16) {
		/* we might have 0x in front of number; remove if there */
		if (c == '0' && (*p == 'x' || *p == 'X')) {
			++p;
			c = *p++;       /* advance past prefix */
		}
	}
	
	/* if our number exceeds this, we will overflow on multiply */
	maxval = ULONG_MAX / ibase;

	for (;;) {      /* exit in middle of loop */
		   
		if(((unsigned char)c >= 'A') && ((unsigned char)c <= 'Z')){
			c = c + ('a' - 'A');
		}
		/* convert c to value */
		if (((unsigned char)c >= '0') && ((unsigned char)c <= '9')){
			digval = c - '0';				  
		}else if (((unsigned char)c >= 'a') && ((unsigned char)c <= 'z')){
			digval = c - 'a' + 10;			
		}else{
			break;
		}
		if (digval >= (unsigned)ibase){
			break;          /* exit loop if bad digit found */
		}

		/* we now need to compute number = number * base + digval,
		but we need to know if overflow occured.  This requires
		a tricky pre-check. */

		if (number < maxval || (number == maxval &&
			(unsigned long)digval <= ULONG_MAX % ibase)) {
			/* we won't overflow, go ahead and multiply */
			number = number * ibase + digval;
		}
		else {
			/* we would have overflowed -- set the overflow flag */
			number = 0L;
			break;
		}

		c = *p++;               /* read next digit */
	}
	
	return number;                  /* done. */
}

/*
 *	Function:
 *		ULONG ParseArgumentString
 *		
 *	Routine Description:
 *		This function is called when driver want parse the argument
 *		string which stored in system registry.
 *		In NT/2K, this string is stored under
 *		\HKLM\System\CurrentControlSet\Services\xxx\Parameters\Device?\DriverParameters.
 *		It's a string value, every argument are divided by semicolon.
 *
 *	Arguments:
 *		pArgumentString: the string store in registry
 *		pParseString: the argument want to parse
 *
 *	Return value:
 *		ULONG, the settings
 */
ULONG
   ParseArgumentString(
	   IN PCHAR pArgumentString,
	   IN PCHAR	pParseString
   )
{							 
	ULONG	nResult;	   
	char	c;
	int iLengthArgument, iLengthId;
		 
	nResult = 0;
	
	if((pArgumentString == NULL)||(pParseString == NULL)){
		return 0;
	}			 
	
	iLengthArgument = 0;
	while((c = pArgumentString[iLengthArgument]) != 0){
		if((c >='A') && (c <= 'Z')){
			pArgumentString[iLengthArgument] = c + ('a' - 'A');
		}		   
		iLengthArgument++;
	}
	iLengthId = 0;
	
	while((c = pParseString[iLengthId]) != 0){
		if((c >='A') && (c <= 'Z')){
			pParseString[iLengthId] = c + ('a' - 'A');
		}
		iLengthId++;
	}				

	if( iLengthId < iLengthArgument){
		while(*pArgumentString != 0){
			if(memcmp(pArgumentString, pParseString, iLengthId) != 0){
				while((*pArgumentString != 0)&&(*pArgumentString != ';')){
					pArgumentString ++;
				}
			}else{
				pArgumentString = pArgumentString + iLengthId;
				while((*pArgumentString != 0)&&
					(*pArgumentString != ';')&&
					(*pArgumentString != '=')){
					pArgumentString ++;
				}
				if(*pArgumentString == '='){
					pArgumentString ++;
					nResult = my_strtoul(pArgumentString);
					break;
				}					   
			}
		}
	}
	return nResult;
}
   
ULONG
   AtapiFindController(
						  IN PHW_DEVICE_EXTENSION HwDeviceExtension,
						  IN PVOID Context,
						  IN PVOID BusInformation,
						  IN PCHAR ArgumentString,
						  IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
						  OUT PBOOLEAN Again
						 )
/*++

Function:
    ULONG AtapiFindController

Routine Description:

    This function is called by the OS-specific port driver after
    the necessary storage has been allocated, to gather information
    about the adapter's configuration.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Context - Address of adapter count
    BusInformation - Indicates whether or not driver is client of crash dump utility.
    ArgumentString - Used to determine whether driver is client of ntldr.
    ConfigInfo - Configuration information structure describing HBA
    Again - Indicates search for adapters to continue

Return Value:

    ULONG

--*/

{
	PChannel pChan = HwDeviceExtension->IDEChannel;
	PUCHAR  BMI;
	int     i;
	ULONG	nStatus = SP_RETURN_NOT_FOUND;

	*Again = FALSE;

	if((*ConfigInfo->AccessRanges)[0].RangeLength != 0){
		nStatus = FindPnpAdapter(HwDeviceExtension, ConfigInfo);
	}else{
		if(Context != NULL){
			nStatus = FindLegacyAdapter(HwDeviceExtension, ConfigInfo, (PHPT_FIND_CONTEXT)Context);
		}
	}

	if(nStatus == SP_RETURN_FOUND){
		*Again = TRUE;
		ZeroMemory(pChan, sizeof(HW_DEVICE_EXTENSION));
		
		(BMI = (PUCHAR)ScsiPortConvertPhysicalAddressToUlong(
			(*ConfigInfo->AccessRanges)[ConfigInfo->NumberOfAccessRanges - 1].RangeStart));

		SetHptChip(pChan, BMI);

		Create_Internal_Buffer(HwDeviceExtension);

		//
		// Indicate maximum transfer length is 64k.
		//
		ConfigInfo->MaximumTransferLength = 0x10000;
		ConfigInfo->AlignmentMask = 0x00000003;

      //
      //  Enable system flush data (9/18/00)
      //
		ConfigInfo->CachesData = TRUE;

		//
		// Indicate it is a bus master
		//
		ConfigInfo->Master = TRUE;
		ConfigInfo->Dma32BitAddresses = TRUE;
		ConfigInfo->NumberOfPhysicalBreaks = MAX_SG_DESCRIPTORS - 1;
		ConfigInfo->ScatterGather = TRUE;
		
		if(ConfigInfo->NumberOfAccessRanges == 3){
			pChan->HwDeviceExtension = (PHW_DEVICE_EXTENSION)pChan;
			pChan->CallBack = AtapiCallBack;
			
			//
			// Indicate 2 buses.
			//
			ConfigInfo->NumberOfBuses = 3;
			HwDeviceExtension->m_nChannelNumber = 1;

			//
			// Indicate only two devices can be attached to the adapter.
			//
			ConfigInfo->MaximumNumberOfTargets = 2;

			//
			// Allocate a Noncached Extension to use for scatter/gather list
			//
			if((pChan->pSgTable = (PSCAT_GATH)ScsiPortGetUncachedExtension(
				HwDeviceExtension,
				ConfigInfo,
				sizeof(SCAT_GATH) * MAX_SG_DESCRIPTORS)) != 0){

				//
				// Convert virtual address to physical address.
				//
				i = sizeof(SCAT_GATH) * MAX_SG_DESCRIPTORS;
				pChan->SgPhysicalAddr = ScsiPortConvertPhysicalAddressToUlong(
					ScsiPortGetPhysicalAddress(HwDeviceExtension,
											   NULL,
											   pChan->pSgTable,
											   &i)
					);
			}
			HwDeviceExtension->HwInitialize = AtapiHwInitialize;
			HwDeviceExtension->HwInterrupt = AtapiHwInterrupt;
		}else{
			pChan->HwDeviceExtension = (PHW_DEVICE_EXTENSION)pChan;
			pChan->CallBack = AtapiCallBack;
			pChan[1].HwDeviceExtension = (PHW_DEVICE_EXTENSION)pChan;
			pChan[1].CallBack = AtapiCallBack370;

			//
			// Indicate 2 buses.
			//
			ConfigInfo->NumberOfBuses = 3;
			HwDeviceExtension->m_nChannelNumber = 2;

			//
			// Indicate only two devices can be attached to the adapter.
			//
			ConfigInfo->MaximumNumberOfTargets = 2;
			
			//
			// Allocate a Noncached Extension to use for scatter/gather list
			//
			if((pChan->pSgTable = (PSCAT_GATH)ScsiPortGetUncachedExtension(
				HwDeviceExtension,
				ConfigInfo,
				sizeof(SCAT_GATH) * MAX_SG_DESCRIPTORS * 2)) != 0) {

				//
				// Convert virtual address to physical address.
				//
				i = sizeof(SCAT_GATH) * MAX_SG_DESCRIPTORS * 2;
				pChan->SgPhysicalAddr = ScsiPortConvertPhysicalAddressToUlong(
					ScsiPortGetPhysicalAddress(HwDeviceExtension,
											   NULL,
											   pChan->pSgTable,
											   &i)
					);


				pChan[1].pSgTable = (PSCAT_GATH)
									((ULONG)pChan->pSgTable + 
									 sizeof(SCAT_GATH) * MAX_SG_DESCRIPTORS);
				pChan[1].SgPhysicalAddr = pChan->SgPhysicalAddr
										 + sizeof(SCAT_GATH) * MAX_SG_DESCRIPTORS;
			}
			HwDeviceExtension->HwInitialize = AtapiHwInitialize370;
			HwDeviceExtension->HwInterrupt = AtapiHwInterrupt370;
							 
			/*
			 *Changed by HS.Zhang
			 *The ParseArguemtString request lowercase string to
			 *compare, if there are any chars in uppercase, it will
			 *write lowercase char back, these may cause system crash
			 *because the string is stored in code segment, it's setted
			 *as read only.
			 */
			HwDeviceExtension->m_nWinXferModeSetting =
				ParseArgumentString( ArgumentString, "adapterxfermodesetting" );

			if(HwDeviceExtension->m_nWinXferModeSetting == 0){
				HwDeviceExtension->m_nWinXferModeSetting = 0xEFEFEFEF;
			}
		}													  
	}
	
	return nStatus;
} // end AtapiFindController()


/******************************************************************
 * Initial Channel
 *******************************************************************/

BOOLEAN
   AtapiHwInitialize(IN PChannel pChan)
{
	int i;
	PDevice pDevice;
	ST_XFER_TYPE_SETTING	osAllowedDeviceXferMode;

	OutPort(pChan->BaseBMI+0x7A, 0x10);
	for(i = 0; i <2; i++) {
		pDevice = &pChan->Devices[i];
		pDevice->UnitId = (i)? 0xB0 : 0xA0;
		pDevice->pChannel = pChan;

		if(pChan == &pChan->HwDeviceExtension->IDEChannel[0]){
			osAllowedDeviceXferMode.Mode = pChan->HwDeviceExtension->m_rgWinDeviceXferModeSettings[0][i].Mode;
		}else{
			osAllowedDeviceXferMode.Mode = pChan->HwDeviceExtension->m_rgWinDeviceXferModeSettings[1][i].Mode;
		}

		if(FindDevice(pDevice,osAllowedDeviceXferMode)) {
			pChan->pDevice[i] = pDevice;

			if (pChan->pSgTable == NULL) 
				pDevice->DeviceFlags &= ~(DFLAGS_DMA | DFLAGS_ULTRA);

			if(pDevice->DeviceFlags & DFLAGS_HARDDISK) {
				StallExec(1000000);
				CheckArray(pDevice);
         }

			if((pDevice->DeviceFlags & DFLAGS_ATAPI) == 0 && 
			   (pDevice->DeviceFlags & DFLAGS_REMOVABLE_DRIVE))
				IdeMediaStatus(TRUE, pDevice);

			Nt2kHwInitialize(pDevice);
		} 
	}

	Win98HwInitialize(pChan);

	OutPort(pChan->BaseBMI+0x7A, 0);
	return TRUE;

} // end AtapiHwInitialize()

int num_adapters=0;
PHW_DEVICE_EXTENSION hpt_adapters[MAX_HPT_BOARD];

BOOLEAN
   AtapiHwInitialize370(IN PHW_DEVICE_EXTENSION HwDeviceExtension)
{
	BOOLEAN	bResult;
	PVirtualDevice pArray;

#ifndef WIN95
	HwDeviceExtension->m_hAppNotificationEvent = PrepareForNotification(NULL);
#endif
	bResult = (AtapiHwInitialize(&HwDeviceExtension->IDEChannel[0])&&
			   AtapiHwInitialize(&HwDeviceExtension->IDEChannel[1]));

	hpt_adapters[num_adapters++] = HwDeviceExtension;

	Final_Array_Check();

	return bResult;
}


/******************************************************************
 * Reset Controller
 *******************************************************************/

void ResetArray(PVirtualDevice  pArray)
{
	PDevice pDev;
	PChannel pChan;
	int mirror_stripe = (pArray->arrayType == VD_RAID_01_2STRIPE ||
						 pArray->arrayType == VD_RAID01_MIRROR);
	int i, j;


	for(j = 0; j < 2; j++) {

		for(i = 0; i < MAX_MEMBERS; i++) {
			pDev = pArray->pDevice[i];
			if(pDev == 0)
				continue;

			if(i == MIRROR_DISK && mirror_stripe)
				break;

			pChan = pDev->pChannel;
			if(pChan->pWorkDev == pDev)  {
				ScsiPortWritePortUchar(pChan->BMI, BMI_CMD_STOP);

				IdeResetController(pChan);

				excluded_flags |= (1 << pChan->exclude_index);

				pDev->DeviceFlags &= ~(DFLAGS_DMAING | DFLAGS_REQUEST_DMA |
									   DFLAGS_TAPE_RDP | DFLAGS_SET_CALL_BACK);

				pChan->pWorkDev = 0;

				CheckNextRequest(pChan);
			}
		}

		pArray->Srb = NULL;

		if (pArray->arrayType==VD_RAID_10_MIRROR ||
			pArray->arrayType==VD_RAID_10_SOURCE)
		{
			pArray = pArray->pRAID10Mirror;
			continue;
		}

		if (mirror_stripe == 0) break;
		if (!pDev) break;

		pArray = pDev->pArray;
	}
}


BOOLEAN
   AtapiResetController(
						IN PHW_DEVICE_EXTENSION HwDeviceExtension, 
						IN ULONG PathId)
{
	PChannel pChan = HwDeviceExtension->IDEChannel;
	PDevice  pDev = NULL;
	PSCSI_REQUEST_BLOCK Srb = NULL;
	PVirtualDevice pArray = NULL;
	PSrbExtension  pSrbExt = NULL;

	if(PathId)
		pChan++;

	ScsiPortWritePortUchar(pChan->BMI, BMI_CMD_STOP);
	
	if((pChan->pWorkDev) != 0) {
		pDev = pChan->pWorkDev;
		pArray = pDev->pArray;

		///// modified
		if(pArray && pArray->nDisk ==0) {
//			 if(pArray->arrayType == VD_RAID_01_2STRIPE ) {
				 pDev= pArray->pDevice[MIRROR_DISK];
				 if(pDev !=0) pArray= pDev->pArray;
//			 }
		}
	  ////////////
	} else {
		int i;
		for( i = 0; i < 2; i++){ 
			if((pDev = pChan->pDevice[i]) != 0){
				pArray = pDev->pArray;
				if(pArray && (Srb=pArray->Srb) && pArray->nDisk)
					goto out;											 
				else if(pArray && pArray->Srb==0)
					goto _rst_chip;
			}
		}
		return TRUE;
	}

out:
	if(pArray && (pArray->Srb != NULL)){
		Srb = pArray->Srb;
		pSrbExt = (PSrbExtension)Srb->SrbExtension;
		if(pSrbExt->JoinMembers ^ pSrbExt->WaitInterrupt) {
			ResetArray(pArray);
			pDev = pSrbExt->pMaster;
		}
		pArray->Srb = 0;
	}else{
_rst_chip:
		excluded_flags |= (1 << pChan->exclude_index);

		if (pDev)
			pDev->DeviceFlags &= ~(DFLAGS_DMAING | DFLAGS_REQUEST_DMA |
							   DFLAGS_TAPE_RDP | DFLAGS_SET_CALL_BACK);

		pChan->pWorkDev = 0;

		IdeResetController(pChan);

		Srb = pChan->CurrentSrb;
	}
	
	//
	// Check if request is in progress.
	//

	if (Srb != 0) {
		//
		// Complete outstanding request with SRB_STATUS_BUS_RESET.
		//
		PSrbExtension pSrbExt = (PSrbExtension)Srb->SrbExtension;
		if(pSrbExt!=0 && pSrbExt->WorkingFlags & SRB_WFLAGS_USE_INTERNAL_BUFFER){
			excluded_flags |= (1 << EXCLUDE_BUFFER);
			pSrbExt->WorkingFlags &= ~SRB_WFLAGS_USE_INTERNAL_BUFFER;
		}
		// gmm: restore Srb members in case of SRB_FUNCTION_IOCONTROL
		if(pSrbExt!=0 && (pSrbExt->WorkingFlags & SRB_WFLAGS_HAS_CALL_BACK)){
			pSrbExt->pfnCallBack(pChan->HwDeviceExtension, Srb);
		}
		//
		ScsiPortCompleteRequest(
								HwDeviceExtension,
								Srb->PathId,
								Srb->TargetId,
								Srb->Lun,
								(ULONG)SRB_STATUS_BUS_RESET);
		if(pDev)
       		pDev->CurrentList = pDev->NextList = 0;
		WIN_NextRequest(pChan);			// clean CurrentSrb and check next request.
		ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
	}

	return TRUE;

} // end AtapiResetController()


/******************************************************************
 * Start Io
 *******************************************************************/

const char HPT_DEVICE[] = {'H','P','T',' ',' ',' ',' ',' ','R','C','M',' ','D','E','V','I','C','E'};
char HPT_SIGNATURE[8] = {'H','P','T','-','C','T','R','L'};
char S3_shutdown = 0;

BOOLEAN
   AtapiStartIo(
				IN PHW_DEVICE_EXTENSION HwDeviceExtension, 
				IN PSCSI_REQUEST_BLOCK Srb)

/*++

Function:
    BOOLEAN AtapiStartIo

Routine Description:

    This routine is called from the SCSI port driver synchronized
    with the kernel to start an IO request.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    TRUE

--*/

{
	PChannel pChan = HwDeviceExtension->IDEChannel;
	PDevice pDev;
	PVirtualDevice pArray;
	ULONG   status;
	PCDB    cdb = (PCDB)Srb->Cdb;

	if(Srb->PathId)
		pChan++;

	ZeroMemory(Srb->SrbExtension, sizeof(SrbExtension));
	((PSrbExtension)Srb->SrbExtension)->StartChannel = pChan;
	//
	// Determine which function.
	//
	switch (Srb->Function) {

		case SRB_FUNCTION_EXECUTE_SCSI:

////////////////
			// handle S3 mode in Windows 2000
			//
			if(Srb->Cdb[0]== SCSIOP_START_STOP_UNIT  &&
			   cdb->START_STOP.LoadEject == 0) {

				pDev=  pChan->pDevice[Srb->TargetId];

				if(cdb->START_STOP.Start==1) {
					PUCHAR BMI= pChan->BMI;
					UCHAR  target=Srb->TargetId;

				//if(S3_shutdown) {
					S3_shutdown = 0;
					SetHptChip((PChannel)HwDeviceExtension,
							   (PUCHAR)-3);

					 //Reset370IdeEngine(pChan);
					 //Reset370IdeEngine(&HwDeviceExtension->IDEChannel[1]);
					  //}
					if(pDev->pArray)
						ArraySetting(pDev->pArray);
					else {
						OutDWord((PULONG)(pChan->BMI+ 0x60+ target * 4), 
								 pChan->Setting[(pDev->DeviceFlags & DFLAGS_ATAPI)?DEFAULT_TIMING : pDev->DeviceModeSetting]);
						DeviceSetting(pChan, (DWORD)target);
					}
				} else
					if(cdb->START_STOP.Start== 0) {
						S3_shutdown = 1;
						Prepare_Shutdown(pChan->pDevice[Srb->TargetId]);
					}
				status = SRB_STATUS_SUCCESS;
				break;
			};	 // end of 0x1B
/////////////////

			if(Srb->PathId == 2){

				if((Srb->TargetId != 0)||
				   (Srb->Lun != 0)||
				   (Srb->Cdb[0] != SCSIOP_INQUIRY)){

					status = SRB_STATUS_SELECTION_TIMEOUT;

				}else{

					UINT i;
					PINQUIRYDATA pInquiryData;

					pInquiryData = Srb->DataBuffer;

					ZeroMemory(Srb->DataBuffer, Srb->DataTransferLength);

					pInquiryData->DeviceType = PROCESSOR_DEVICE;
					pInquiryData->Versions = 1;
					pInquiryData->AdditionalLength = 0x20;

					memcpy(&pInquiryData->VendorId, &HPT_DEVICE, sizeof(HPT_DEVICE));

					for(i = (offsetof(INQUIRYDATA, VendorId) + sizeof(HPT_DEVICE)); i < Srb->DataTransferLength; i++){
						((PCHAR)pInquiryData)[i] = 0x20;
					}

					status = SRB_STATUS_SUCCESS;
				}

			}else if(Srb->PathId < HwDeviceExtension->m_nChannelNumber){

				CheckDeviceReentry(pChan, Srb);
SubmitCommand:
				pDev = pChan->pDevice[Srb->TargetId];

				if (pDev == 0) {
no_device:
					status = SRB_STATUS_NO_DEVICE;
					break;
				}

				/* gmm
				 *  Ignore array on inquiry command.
				 * This will let the OS show all hard disks connected to the controller.
				 */
				if (Srb->Cdb[0]==SCSIOP_INQUIRY)
					goto SubmitCommandWithoutRaidCheck;
				//-*/

				pArray=pDev->pArray;
				// handle RAID1+0 case
				if (pArray && pArray->arrayType==VD_RAID_10_MIRROR) {
					/*
					 * check if it's the swapped source disk.
					 */
					if (pDev==pArray->pDevice[0]) {
						pArray = pArray->pRAID10Mirror;
						pDev = pArray->pDevice[0];
						if (pDev && (pDev->DeviceFlags2 & DFLAGS_DEVICE_SWAPPED))
							goto SubmitCommandWithoutRaidCheck;
					}
					goto no_device;
				}

				if (pDev->DeviceFlags & DFLAGS_HIDEN_DISK) {
					// If a mirror lost source disk will have to use the mirror
					if (pArray) {
						switch(pArray->arrayType) {
						case VD_RAID_1_MIRROR:
						case VD_RAID_01_1STRIPE:
							if (pArray->nDisk==0 && pDev==pArray->pDevice[MIRROR_DISK]) {
								/*
								 * Unhide it. Otherwise SRB_FUNCTION_FLUSH and 
								 * SRB_FUNCTION_SHUTDOWN can't be done
								 */
								pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
								goto SubmitCommandWithoutRaidCheck;
							}
							break;
						}
					}
					goto no_device; 
				}			  

//////////////////

SubmitCommandWithoutRaidCheck:
				Srb->SrbStatus = SRB_STATUS_PENDING;

				if(((pDev->pArray != NULL)&&(pDev->pArray->Srb != NULL)) ||
				   (btr(pChan->exclude_index) == 0)){

					OLD_IRQL
					DISABLE

					PutQueue(pDev, Srb);

					ENABLE

				} else{  
					WinStartCommand(pDev, Srb);
				}	  
					goto ask_for_next;

			}else{
null_bus:		   
				status = SRB_STATUS_SELECTION_TIMEOUT;
//				Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT; 
//				ScsiPortNotification(RequestComplete, HwDeviceExtension, Srb);
			}
			break;

		case SRB_FUNCTION_IO_CONTROL:			
			if(memcmp(((PSRB_IO_CONTROL)Srb->DataBuffer)->Signature, HPT_SIGNATURE, sizeof(HPT_SIGNATURE)) == 0){
				if(HptIsValidDeviceSpecifiedIoControl(Srb)){
					pChan = &HwDeviceExtension->IDEChannel[Srb->PathId];
					pDev = pChan->pDevice[Srb->TargetId];
					if (pDev)
						goto SubmitCommandWithoutRaidCheck;
					else
						status = SRB_STATUS_SELECTION_TIMEOUT;
				}
				status = HptIoControl(HwDeviceExtension, Srb);
			}else if(memcpy(((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature, "SCSIDISK", 8) == 0){
				goto SubmitCommand;
			}else{
				status = SRB_STATUS_INVALID_REQUEST;
			}
			break;

		case SRB_FUNCTION_ABORT_COMMAND:

		//
		// Verify that SRB to abort is still outstanding.
		//
			if (!pChan->CurrentSrb) {
			//
			// Complete abort SRB.
			//
				status = SRB_STATUS_ABORT_FAILED;
				break;
			}

		//
		// Abort function indicates that a request timed out.
		// Call reset routine. Card will only be reset if
		// status indicates something is wrong.
		// Fall through to reset code.
		//

		case SRB_FUNCTION_RESET_BUS:

		//
		// Reset Atapi and SCSI bus.
		//
			if (!AtapiResetController(HwDeviceExtension, Srb->PathId)) {

			//
			// Log reset failure.
			//
				ScsiPortLogError(
								 HwDeviceExtension,
								 NULL,
								 0,
								 0,
								 0,
								 SP_INTERNAL_ADAPTER_ERROR,
								 5 << 8);

				status = SRB_STATUS_ERROR;
			}
			else
				status = SRB_STATUS_SUCCESS;

			break;

		case SRB_FUNCTION_FLUSH:
		case SRB_FUNCTION_SHUTDOWN:
			if(Srb->PathId >= HwDeviceExtension->m_nChannelNumber) 
				goto null_bus;

			pDev = pChan->pDevice[Srb->TargetId];
			if((pDev == 0) ||
			   (pDev->DeviceFlags & DFLAGS_HIDEN_DISK) != 0) {
				status = SRB_STATUS_SELECTION_TIMEOUT; 
				break;
			}

			status = SRB_STATUS_SUCCESS;

			if(pDev->DeviceFlags & DFLAGS_TAPE_DEVICE)
				break;

			pDev->DeviceFlags |= ((Srb->Function == SRB_FUNCTION_FLUSH)?
								DFLAGS_WIN_FLUSH : DFLAGS_WIN_SHUTDOWN);

			if(pChan->CurrentSrb == 0) 
				Prepare_Shutdown(pDev);
			break;		   


		default:

		//
		// Indicate unsupported command.
		//
			status = SRB_STATUS_INVALID_REQUEST;

			break;

	} // end switch

	//
	// Check if command complete.
	//
	if (status != SRB_STATUS_PENDING) {

		// Set status in SRB.
		//
		Srb->SrbStatus = (UCHAR)status;

		OS_EndCmd_Interrupt(pChan, Srb);
	}

ask_for_next:
#ifdef	SERIAL_CMD
	//
	// if user need serial excute command
	//
	;		  
#else
	//
	// Indicate ready for next request.
	//
	ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
#endif									// SERIAL_CMD

	return TRUE;

} // end AtapiStartIo()

////////
void DeviceSetting(PChannel pChan, DWORD devID)
{
	 PDevice  pDev = &pChan->Devices[devID];
    PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2  IoPort2 = pChan->BaseIoAddress2;
	 BYTE     DevNum = (BYTE)((devID << 4) | 0xA0);
	 BYTE     Feature, NewMode = pDev->DeviceModeSetting;
    #define  identifyData   pDev->IdentifyData
	 LOC_IDENTIFY


    OutPort(pChan->BaseBMI+0x7A, 0x10);

    OutPort(&IoPort2, 0);

    IssueIdentify(pDev, IDE_COMMAND_IDENTIFY ARG_IDENTIFY);

	 if(!(pDev->DeviceFlags & DFLAGS_ATAPI)) {
        SelectUnit(IoPort, pDev->UnitId);
        SelectUnit(IoPort, (BYTE)(DevNum | (identifyData.NumberOfHeads-1)));
        SetBlockCount(IoPort,  (BYTE)identifyData.SectorsPerTrack);
        IssueCommand(IoPort, IDE_COMMAND_SET_DRIVE_PARAMETER);
        StallExec(2000);
        //WaitOnBusy(IoPort2);
        GetBaseStatus(IoPort);
	     OutPort(pChan->BMI + BMI_STS, BMI_STS_ERROR|BMI_STS_INTR);
	 }

    SelectUnit(IoPort, DevNum);

	 if(NewMode < 5) {
        pDev->DeviceFlags &= ~(DFLAGS_DMA | DFLAGS_ULTRA);
		  Feature = (UCHAR)(NewMode | FT_USE_PIO);
	 } else if(NewMode < 8) {
        pDev->DeviceFlags |= DFLAGS_DMA;
		  Feature = (UCHAR)((NewMode - 5)| FT_USE_MWDMA);
	 } else {
        pDev->DeviceFlags |= DFLAGS_DMA | DFLAGS_ULTRA;
		  Feature = (UCHAR)((NewMode - 8) | FT_USE_ULTRA);
    }

    SetBlockCount(IoPort, Feature);
    SetFeaturePort(IoPort, 3);
    IssueCommand(IoPort, IDE_COMMAND_SET_FEATURES);
    StallExec(2000);
    //WaitOnBusy(IoPort2);
    GetBaseStatus(IoPort);//clear interrupt
	 OutPort(pChan->BMI + BMI_STS, BMI_STS_ERROR|BMI_STS_INTR);

	 OutPort(pChan->BaseBMI+0x7A, 0);
}

//////
void ArraySetting(PVirtualDevice pArray)
{
	 int i;
	 PDevice  pDev;
	 PChannel pChan;

loop:
	 for(i = 0; i < MAX_MEMBERS; i++) {
		  if((pDev = pArray->pDevice[i]) == 0)
           continue;
        if(i == MIRROR_DISK) {
            if(pArray->arrayType == VD_RAID01_MIRROR)
                 return;
            if(pArray->arrayType == VD_RAID_01_2STRIPE) {
                 pArray = pDev->pArray;
                 goto loop;
            }
        }
		  pChan = pDev->pChannel;

        _outpd((WORD)(pChan->BMI + 0x60+ ((pDev->UnitId & 0x10) >> 2)), 
             pChan->Setting[(pDev->DeviceFlags & DFLAGS_ATAPI)? 
             DEFAULT_TIMING : pDev->DeviceModeSetting]);
		  DeviceSetting(pChan, (DWORD)((pDev->UnitId & 0x10) >> 4));
	}
}


/******************************************************************
 * Interrupt
 *******************************************************************/

BOOLEAN
   AtapiHwInterrupt(
					IN PChannel pChan
				   )

{
	PATAPI_REGISTERS_1  baseIoAddress1;
	PUCHAR BMI = pChan->BMI;
	PDevice   pDev;

	if((ScsiPortReadPortUchar(BMI + BMI_STS) & BMI_STS_INTR) == 0) {
		Win95CheckBiosInterrupt();
		return FALSE;
	}

	if((pDev = pChan->pWorkDev) != 0)
		return DeviceInterrupt(pDev, 0);

	baseIoAddress1 = (PATAPI_REGISTERS_1)pChan->BaseIoAddress1;
	if(pChan->pDevice[0]) 
		ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect, 0xA0);
	if(pChan->pDevice[1]) {
		GetBaseStatus(baseIoAddress1);
		ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect, 0xB0);
	}
	GetBaseStatus(baseIoAddress1);
	ScsiPortWritePortUchar(BMI + BMI_STS, BMI_STS_INTR);

	pChan->ChannelFlags &= ~PF_ACPI_INTR;

	return TRUE;
}


BOOLEAN
   AtapiHwInterrupt370(
					   IN PChannel pChan
					  )
{	
	BOOLEAN	bResult1, bResult2;
	bResult1 = AtapiHwInterrupt(pChan);
	bResult2 = AtapiHwInterrupt(pChan+1);

	return (bResult1||bResult2);
} 


/******************************************************************
 * Call Back
 *******************************************************************/

void AtapiCallBack(
				   IN PChannel pChan
				  )
{
	PDevice              pDev = pChan->pWorkDev;
	PSCSI_REQUEST_BLOCK  Srb;
	PATAPI_REGISTERS_2   ControlPort;
	UCHAR statusByte;

/////////////////
               // Added by SLeng
               //
	// Detect whether removed disks added by hot plug
	if(DiskRemoved > 0)
	{
		MonitorDisk(pChan);
	}

/////////////////

	if(pDev == 0 || (pDev->DeviceFlags & DFLAGS_SET_CALL_BACK) == 0)
		return;
	//
	// If the last command was DSC restrictive, see if it's set. If so, the device is
	// ready for a new request. Otherwise, reset the timer and come back to here later.
	//

	Srb = pChan->CurrentSrb;
	if (Srb) {

		ControlPort = (PATAPI_REGISTERS_2)pChan->BaseIoAddress2;
		if (pDev->DeviceFlags & DFLAGS_TAPE_RDP) {
			statusByte = GetStatus(ControlPort);
			if (statusByte & IDE_STATUS_DSC) 
				DeviceInterrupt(pDev, 1);
			else 
				OS_Busy_Handle(pChan, pDev);
			return;
		}
	}

	DeviceInterrupt(pDev, 0);
}


void AtapiCallBack370(
					  IN PChannel pChan
					 )
{
	AtapiCallBack(&pChan[1]);
}


/******************************************************************
 * Adapter Status
 *******************************************************************/


BOOLEAN
   AtapiAdapterState(IN PVOID HwDeviceExtension, IN PVOID Context, IN BOOLEAN SaveState)
{
	return TRUE;
}

#endif // not _BIOS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\winlog.c ===
/***************************************************************************
 * File:          Winlog.c
 * Description:   The ReportError routine for win9x & winNT
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/16/2000	SLeng	Added code to handle removed disk added by hotplug
 *
 ***************************************************************************/
#include "global.h"
#include "devmgr.h"

extern int DiskRemoved;

BOOL IsCriticalError(
					 PDevice pDev,
					 BYTE bErrorCode,
					 PSCSI_REQUEST_BLOCK pSrb
					)
{										
	if(bErrorCode == DEVICE_REMOVED) return TRUE;
	if(bErrorCode == DEVICE_PLUGGED) return FALSE;
	
	if (!pSrb) return FALSE;

	if(pSrb->Function == SRB_FUNCTION_IO_CONTROL){
		if(pDev->stErrorLog.nLastError != 0){
			return FALSE;
		}
	}

	if(pSrb->CdbLength != 0){
		if((pSrb->Cdb[0] == SCSIOP_READ)||
		   (pSrb->Cdb[0] == SCSIOP_WRITE)){
			return TRUE;
		}
	}
	return FALSE;
}

BOOL Disk_PutBack(PDevice pDev)
{
	PVirtualDevice pArray = pDev->pArray;
	PVirtualDevice pMirror;
	int i, nDisk;	
	
	if (!pArray) return FALSE;

	switch(pArray->arrayType){		
	case VD_RAID_1_MIRROR:
		// If the capacity of mirror disk is less than the array
		if(pDev->capacity < pArray->capacity ) return FALSE;

		if (pArray->nDisk == 0 && pArray->pDevice[MIRROR_DISK])
		{
			// move mirror to pDevice[0]
			pArray->pDevice[0] = pArray->pDevice[MIRROR_DISK];
			pArray->nDisk = 1;
			// add as mirror disk
			pDev->ArrayNum  = MIRROR_DISK;
			pArray->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
		}
		else if (!pArray->pDevice[MIRROR_DISK])
		{
			// add as mirror disk
			pDev->ArrayNum  = MIRROR_DISK;
			pArray->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
		}
		else if (!pArray->pDevice[SPARE_DISK])
		{
			// add as spare disk
			pDev->ArrayNum  = SPARE_DISK;
		}
		else
			return FALSE;

		pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
		pDev->ArrayMask = (1<<pDev->ArrayNum);
		pDev->pArray = pArray;
		pArray->pDevice[pDev->ArrayNum] = pDev;
		pArray->BrokenFlag = FALSE;
		return TRUE;

	case VD_RAID_01_2STRIPE:
		pMirror = pArray->pDevice[MIRROR_DISK]->pArray;
		if (pMirror->BrokenFlag) return FALSE;
		nDisk=0;
		while (pArray->pDevice[nDisk] && (nDisk<SPARE_DISK)) nDisk++;
		if (pDev->ArrayNum && !pDev->HidenLBA) {
            pDev->HidenLBA = (RECODR_LBA + 1);
            pDev->capacity -= (RECODR_LBA + 1);
		}
		if (pDev->capacity * nDisk < pArray->capacity) return FALSE;
		// ok to put it back
		pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
		for (i=0; i<nDisk; i++) {
			if (!pArray->pDevice[i] || 
				(pArray->pDevice[i]->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)) {
				return TRUE;
			}
		}
		pArray->BrokenFlag = FALSE;
		pArray->nDisk = (UCHAR)nDisk;
		pArray->RaidFlags &= ~RAID_FLAGS_DISABLED;
		pArray->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
		// swap source/mirror
		pArray->arrayType = VD_RAID01_MIRROR;
		pMirror->arrayType = VD_RAID_01_2STRIPE;
		pMirror->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
		return TRUE;

	case VD_RAID01_MIRROR:
		pMirror = pArray->pDevice[MIRROR_DISK]->pArray;
		if (pMirror->BrokenFlag) return FALSE;
		nDisk=0;
		while (pArray->pDevice[nDisk] && (nDisk<SPARE_DISK)) nDisk++;
		if (pDev->ArrayNum && !pDev->HidenLBA) {
            pDev->HidenLBA = (RECODR_LBA + 1);
            pDev->capacity -= (RECODR_LBA + 1);
		}
		if (pDev->capacity * nDisk < pArray->capacity) return FALSE;
		// ok to put it back
		pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
		for (i=0; i<nDisk; i++) {
			if (!pArray->pDevice[i] || 
				(pArray->pDevice[i]->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)) {
				return TRUE;
			}
		}
		pArray->BrokenFlag = FALSE;
		pArray->nDisk = (UCHAR)nDisk;
		pArray->RaidFlags &= ~RAID_FLAGS_DISABLED;
		pMirror->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
		return TRUE;
	}
	return FALSE;
}

PDevice ReportError(PDevice pDev, BYTE error DECL_SRB)
{
	PVirtualDevice pArray = pDev->pArray;

	if(((pDev->stErrorLog.nLastError == error)&&
		  (memcmp(&(pDev->stErrorLog.Cdb), &Srb->Cdb, Srb->CdbLength)==0))){
		return (NULL);
	}
	
	if (error == DEVICE_PLUGGED) {
		pDev->DeviceFlags2 &= ~DFLAGS_DEVICE_DISABLED;
		// if pDev belongs to an array before it fails we'll put it back.
		// In this case GUI should not popup a dialog to let user add this
		// disk to an array.
		// If pDev is the visible disk of an array, there will be some problem.
		// What should we set pDev->pArray to?
		// If pDev is the visible disk of an RAID1 array and now become a spare
		// disk, GUI remove spare disk function will cause error.
		// And what to do if the capacity does not match?
		// Now we just disable this device again, as if it's not detected.
		if (pArray){
#if 0
			if (!Disk_PutBack(pDev)){
				// let GUI popup the dialog.
				// Although it will fail.
#if 0
				pDev->DeviceFlags2 |= DFLAGS_DEVICE_DISABLED;
				// continue polling.
				DiskRemoved++;	// Increase the number of removed disk
				// Set a Timer to detect if the removed disk added by hot plug
				ScsiPortNotification( RequestTimerCall,
									  pDev->pChannel->HwDeviceExtension,
									  pDev->pChannel->CallBack,
									  MONTOR_TIMER_COUNT
									 );
				return;
#endif
			}
#endif
		}
		goto record_error;
	}
	else {
		pDev->DeviceFlags2 |= DFLAGS_DEVICE_DISABLED;
	}
	
	if(pArray) {
		if(IsCriticalError(pDev, error, Srb)) {
			switch(pArray->arrayType) {
				case VD_RAID01_MIRROR:
					{
						PDevice pMirrorDev;
						pArray->nDisk = 0;
						pArray->BrokenFlag = TRUE;
						pArray->RaidFlags |= RAID_FLAGS_DISABLED;
						pMirrorDev = pArray->pDevice[MIRROR_DISK];
						/*
						 Don't set here otherwise ResetArray and GUI will not work
						pArray->arrayType = VD_RAID_0_STRIPE;
						pArray->pDevice[MIRROR_DISK] = NULL;
						*/
						pArray = pMirrorDev->pArray;
					}
single_stripe:
					if(pArray->nDisk !=0) {
						/*
						pArray->arrayType = VD_RAID_0_STRIPE;
						pArray->pDevice[MIRROR_DISK] = 0;	  // remove the second RAID0
						*/
					} else {
						pArray->BrokenFlag = TRUE;
						pArray->RaidFlags |= RAID_FLAGS_DISABLED;
					}
					DiskRemoved++;	// Increase the number of removed disk
					// Set a Timer to detect if the removed disk added by hot plug
					ScsiPortNotification( RequestTimerCall,
										  pDev->pChannel->HwDeviceExtension,
										  pDev->pChannel->CallBack,
										  MONTOR_TIMER_COUNT
										 );
					break;

				case VD_RAID_01_1STRIPE:
					if(pDev == pArray->pDevice[MIRROR_DISK]) 
						goto single_stripe;

				case VD_RAID_01_2STRIPE:
					pArray->BrokenFlag = TRUE;
					pArray->nDisk = 0;
					DiskRemoved++;	// Increase the number of removed disk
					// Set a Timer to detect if the removed disk added by hot plug
					ScsiPortNotification( RequestTimerCall,
										  pDev->pChannel->HwDeviceExtension,
										  pDev->pChannel->CallBack,
										  MONTOR_TIMER_COUNT
										 );
					break;

				case VD_RAID_1_MIRROR:
				{
					PDevice pSpareDevice, pMirrorDevice;

					// the disk has already removed from RAID group,
					// just report the error.
					if((pDev != pArray->pDevice[0])&&
					   (pDev != pArray->pDevice[MIRROR_DISK])&&
					   (pDev != pArray->pDevice[SPARE_DISK])){
						break;
					}

					pSpareDevice = pArray->pDevice[SPARE_DISK];
					pArray->pDevice[SPARE_DISK] = NULL;
					pMirrorDevice = pArray->pDevice[MIRROR_DISK];

					if (pDev==pSpareDevice) {
						// spare disk fails. just remove it.
						pSpareDevice->pArray = NULL;
					}
					else if(pDev == pArray->pDevice[MIRROR_DISK]){
						// mirror disk fails
						if(pSpareDevice != NULL){
							pSpareDevice->ArrayMask = pMirrorDevice->ArrayMask;
							pSpareDevice->ArrayNum = pMirrorDevice->ArrayNum;
							pArray->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
							pArray->pDevice[MIRROR_DISK] = pSpareDevice;
						} 
						else
						{
							pArray->pDevice[MIRROR_DISK] = 0;
							pArray->BrokenFlag = TRUE;
						}
					}else{
						// source disk fails
						if(pSpareDevice != NULL){
							pSpareDevice->ArrayMask = pMirrorDevice->ArrayMask;
							pSpareDevice->ArrayNum = pMirrorDevice->ArrayNum;
							pMirrorDevice->ArrayMask = pDev->ArrayMask;
							pMirrorDevice->ArrayNum = pDev->ArrayNum;

							pArray->pDevice[pDev->ArrayNum] = pMirrorDevice;
							pArray->pDevice[MIRROR_DISK] = pSpareDevice;
							pArray->RaidFlags |= RAID_FLAGS_NEED_REBUILD;
						}
						else
						{
							if (!pMirrorDevice)
							{
								pArray->nDisk = 0;
								pArray->pDevice[0] = 0;
								pArray->RaidFlags |= RAID_FLAGS_DISABLED;
							}
							else 
							{
								pArray->pDevice[0] = pMirrorDevice;
								pMirrorDevice->ArrayMask = 1;
								pMirrorDevice->ArrayNum = 0;
								pArray->pDevice[MIRROR_DISK] = 0;
							}
							pArray->BrokenFlag = TRUE;
						}
					}					  

//////////////////////
					// Added by SLeng
					//
					DiskRemoved++;	// Increase the number of removed disk
					// Set a Timer to detect if the removed disk added by hot plug
					ScsiPortNotification( RequestTimerCall,
										  pDev->pChannel->HwDeviceExtension,
										  pDev->pChannel->CallBack,
										  MONTOR_TIMER_COUNT
										 );
//////////////////////

				}
				break;

				/*
				 * RAID 1+0 case
				 */
				case VD_RAID_10_MIRROR:
					pArray = pArray->pRAID10Mirror;
				case VD_RAID_10_SOURCE:
					AdjustRAID10Array(pArray);
					DiskRemoved++;	// Increase the number of removed disk
					// Set a Timer to detect if the removed disk added by hot plug
					ScsiPortNotification( RequestTimerCall,
										  pDev->pChannel->HwDeviceExtension,
										  pDev->pChannel->CallBack,
										  MONTOR_TIMER_COUNT
										 );
					break;
				default:
					pArray->nDisk = 0;
					pArray->BrokenFlag = TRUE;
					pArray->RaidFlags |= RAID_FLAGS_DISABLED;
					break;
			}
		}
	}

	if (Srb)
		memcpy(&(pDev->stErrorLog.Cdb), &Srb->Cdb, sizeof(pDev->stErrorLog.Cdb));

record_error:
	pDev->stErrorLog.nLastError = error;
	{
		PDevice *ppTmpDevice;
		ppTmpDevice = &(pDev->pChannel->HwDeviceExtension->m_pErrorDevice);

		while(*ppTmpDevice != NULL){
			if(*ppTmpDevice == pDev){
				break;
			}
			ppTmpDevice = &((*ppTmpDevice)->stErrorLog.pNextErrorDevice);
		}			  

		*ppTmpDevice = pDev;
	}
	pDev->pChannel->HwDeviceExtension->m_pErrorDevice = pDev;				 
//						if (pDev->pArray==pArray)
//						pDev->pArray=0;
	
	/*
	 * gmm: We should call NotifyApplication() after Device_ReportFailure().
	 */
	Device_ReportFailure( pDev );
	NotifyApplication(pDev->pChannel->HwDeviceExtension->m_hAppNotificationEvent);
			
	return(NULL);
}

int GetUserResponse(PDevice pDevice)
{
	return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\winnt2k.c ===
/***************************************************************************
 * File:          winnt2k.c
 * Description:   Subroutines in the file are used to NT/2K platform
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:     
 *		11/06/2000	HS.Zhang	Added this head
 *		11/10/2000	HS.Zhang	Added a micro define NO_DMA_ON_ATAPI in
 *								Start_Atapi routine
 *
 ***************************************************************************/
#include "global.h"

#if  !defined(WIN95) && !defined(_BIOS_)

#define MAX_CONTROL_TYPE	5

/*++
Function:
    VOID H366BuildSgl

Description:
    This routine builds a scatter/gather descriptor list.
    The user's buffer is already locked down before AtapiStartIo was called.
    So we don't do anything to lock the buffer.

    Suppose that we should have not written a routine like this, but we
    have no way to go if there is a device connected which only supports
    PIO. PIO needs the data buffer pointer is an address in system address
    space.

Arguments:
    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Returns:
    Number of SG entries
--*/
int
   BuildSgl(IN PDevice pDev, IN PSCAT_GATH pSG,
			IN PSCSI_REQUEST_BLOCK Srb)
{
	PChannel pChan = pDev->pChannel;
	PSCAT_GATH psg = pSG;
	PVOID   dataPointer = Srb->DataBuffer;
	ULONG   bytesLeft   = Srb->DataTransferLength;
	ULONG   physicalAddress[MAX_SG_DESCRIPTORS];
	ULONG   addressLength[MAX_SG_DESCRIPTORS];
	ULONG   addressCount = 0;
	ULONG   sgEnteries = 0;
	ULONG   length, delta, pageSize;
	ULONG   i = 0;

	if((int)dataPointer	& 1)
		return FALSE;

	//
	// The start address maybe is not at the boundary of a page.
	// So the first page maybe is not a full page.
	//
	pageSize = 0x1000 - (((ULONG)dataPointer) & 0xFFF);

	//
	// Get physical address of each page
	//
	while (bytesLeft) {
		physicalAddress[addressCount] =
									   ScsiPortConvertPhysicalAddressToUlong(
			ScsiPortGetPhysicalAddress(pChan->HwDeviceExtension,
									   Srb,
									   dataPointer,
									   &length));

		addressLength[addressCount] =
									 (bytesLeft > pageSize) ? pageSize : bytesLeft;


		bytesLeft -= addressLength[addressCount];
		dataPointer = (PUCHAR)dataPointer + pageSize;
		addressCount++;

		//
		// Set pageSize to a full page size
		//
		pageSize = 0x1000;
	}

	//
	// Create Scatter/Gather List
	//
	i = 0;
	do {
		psg->SgAddress = physicalAddress[i];
		length = addressLength[i];

		//
		// Get the length of contiguous physical memory
		// NOTE:
		//  If contiguous physical memory skips 64K boundary, we split it.
		//
		i++;

		while (i < addressCount) {
			delta = physicalAddress[i] - physicalAddress[i-1];

			if (delta > 0 && delta <= pageSize &&
				  (physicalAddress[i] & 0xFFFF) ) {
				length += addressLength[i];
				i++;
			}
			else
				break;
		}

		psg->SgSize = (USHORT)length;
		if((length & 3) || (length < 8))
			return FALSE;
		psg->SgFlag = (i < addressCount) ? 0 : SG_FLAG_EOT;

		sgEnteries++;
		psg++;

	} while (i < addressCount);

	return (TRUE);
} // BuildSgl()


PUCHAR
   ScanHptChip(
			   IN PChannel deviceExtension,
			   IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
			  )
{
	PCI_COMMON_CONFIG   Hpt366Conf;
	int                 i;

	while (Hpt_Bus < 4) {
		i = ScsiPortGetBusData(
							   deviceExtension,
							   PCIConfiguration,
							   Hpt_Bus,
							   Hpt_Slot,
							   &Hpt366Conf,
							   sizeof(PCI_COMMON_CONFIG));

		ConfigInfo->SystemIoBusNumber = Hpt_Bus;
		ConfigInfo->SlotNumber = Hpt_Slot;

		if(Hpt_Slot == 0x3F) {
			Hpt_Bus++;
			Hpt_Slot = 0;
		} else 
			Hpt_Slot++;

		if(i == 0 || *(PULONG)&Hpt366Conf.VendorID != SIGNATURE_366)
			continue;
		if(*(PUCHAR)&Hpt366Conf.RevisionID <3) return (0);

		return((PUCHAR)(Hpt366Conf.u.type0.BaseAddresses[4] & ~1));
	}
	return (0);
}

/******************************************************************
 *  
 *******************************************************************/

void Nt2kHwInitialize(
					  IN PDevice pDevice
					 )
{
	PChannel             pChan = pDevice->pChannel;
	PIDE_REGISTERS_1     IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2     ControlPort = pChan->BaseIoAddress2;
	ULONG waitCount;
	ULONG i, j;
	UCHAR statusByte, errorByte;
	UCHAR vendorId[26];


	if (pDevice->DeviceFlags & DFLAGS_ATAPI) {
		//
		// We need to get our device ready for action before
		// returning from this function
		//
		// According to the atapi spec 2.5 or 2.6, an atapi device
		// clears its status BSY bit when it is ready for atapi commands.
		// However, some devices (Panasonic SQ-TC500N) are still
		// not ready even when the status BSY is clear.  They don't react
		// to atapi commands.
		//
		// Since there is really no other indication that tells us
		// the drive is really ready for action.  We are going to check BSY
		// is clear and then just wait for an arbitrary amount of time!
		//

		// have to get out of the loop sometime!
		// 10000 * 100us = 1000,000us = 1000ms = 1s
		for(waitCount = 10000; waitCount != 0; waitCount--) {
			if((GetStatus(ControlPort) & IDE_STATUS_BUSY) == 0)
				break;
			//
			// Wait for Busy to drop.
			//
			ScsiPortStallExecution(100);
		}

		// 5000 * 100us = 500,000us = 500ms = 0.5s
		for(waitCount = 5000; waitCount != 0; waitCount--){
			ScsiPortStallExecution(100);					 
		}

		// Added by HS.Zhang
		// Added macro define check to let us change the DMA by set the
		// macro in forwin.h
#ifdef NO_DMA_ON_ATAPI	
		pDevice->DeviceFlags &= ~(DFLAGS_DMA | DFLAGS_ULTRA);
#endif									// NO_DMA_ON_ATAPI
	}

	if(!(pDevice->DeviceFlags & DFLAGS_CHANGER_INITED)) {
		  //
		// Attempt to identify any special-case devices - psuedo-atapi changers, atapi changers, etc.
		//

		for (j = 0; j < 13; j += 2) {

			//
			// Build a buffer based on the identify data.
			//

			vendorId[j] = ((PUCHAR)pDevice->IdentifyData.ModelNumber)[j + 1];
			vendorId[j+1] = ((PUCHAR)pDevice->IdentifyData.ModelNumber)[j];
		}

		if (!StringCmp (vendorId, "CD-ROM  CDR", 11)) {

			//
			// Inquiry string for older model had a '-', newer is '_'
			//

			if (vendorId[12] == 'C') {

				//
				// Torisan changer. Set the bit. This will be used in several places
				// acting like 1) a multi-lun device and 2) building the 'special' TUR's.
				//

				pDevice->DeviceFlags |= (DFLAGS_CHANGER_INITED | DFLAGS_SANYO_ATAPI_CHANGER);
				pDevice->DiscsPresent = 3;
			}
		}

	}

} // end Nt2kHwInitialize()


/******************************************************************
 *  
 *******************************************************************/

VOID
   AtapiHwInitializeChanger (
							 IN PDevice pDevice,
							 IN PMECHANICAL_STATUS_INFORMATION_HEADER MechanismStatus)
{
	if (MechanismStatus) {
		pDevice->DiscsPresent = MechanismStatus->NumberAvailableSlots;
		if (pDevice->DiscsPresent > 1) {
			pDevice->DeviceFlags |= DFLAGS_ATAPI_CHANGER;
		}
	}
	return;
}


/******************************************************************
 *  
 *******************************************************************/

void Start_Atapi(PDevice pDev, PSCSI_REQUEST_BLOCK Srb)
{
	LOC_IDENTIFY
			PChannel  pChan = pDev->pChannel;
	PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	PSCSI_REQUEST_BLOCK NewSrb;
	int    i, flags;
	BYTE   statusByte;

	//
	// We need to know how many platters our atapi cd-rom device might have.
	// Before anyone tries to send a srb to our target for the first time,
	// we must "secretly" send down a separate mechanism status srb in order to
	// initialize our device extension changer data.  That's how we know how
	// many platters our target has.
	//
	if (!(pDev->DeviceFlags & DFLAGS_CHANGER_INITED) &&
		  !pChan->OriginalSrb) {

		ULONG srbStatus;

		//
		// Set this flag now. If the device hangs on the mech. status
		// command, we will not have the change to set it.
		//
		pDev->DeviceFlags |= DFLAGS_CHANGER_INITED;

		pChan->MechStatusRetryCount = 3;
		NewSrb = BuildMechanismStatusSrb (
										  pChan,
										  Srb->PathId,
										  Srb->TargetId);
		pChan->OriginalSrb = Srb;

		StartAtapiCommand(pDev, NewSrb);
		if (NewSrb->SrbStatus == SRB_STATUS_PENDING) {
			return;
		} else {
			pChan->CurrentSrb = pChan->OriginalSrb;
			pChan->OriginalSrb = NULL;
			AtapiHwInitializeChanger (pDev,
									  (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);
			// fall out
		}
	}

	//
	// Make sure command is to ATAPI device.
	//

	flags = (int)pDev->DeviceFlags;
	if (flags & (DFLAGS_SANYO_ATAPI_CHANGER | DFLAGS_ATAPI_CHANGER)) {
		if ((Srb->Lun) > (pDev->DiscsPresent - 1)) {

			//
			// Indicate no device found at this address.
			//
no_device:
			Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
			return;
		}
	} else if (Srb->Lun > 0) 
		goto no_device;

	if (!(flags & DFLAGS_ATAPI)) 
		goto no_device;

	//
	// Select device 0 or 1.
	//

	ScsiPortWritePortUchar(&IoPort->DriveSelect,
						   (UCHAR)(((Srb->TargetId) << 4) | 0xA0));

	//
	// Verify that controller is ready for next command.
	//

	statusByte = GetStatus(ControlPort);

	if (statusByte & IDE_STATUS_BUSY) {
busy:
		Srb->SrbStatus = SRB_STATUS_BUSY;
		return;

	}

	if (statusByte & IDE_STATUS_ERROR) {
		if (Srb->Cdb[0] != SCSIOP_REQUEST_SENSE) {

			//
			// Read the error reg. to clear it and fail this request.
			//

			Srb->SrbStatus = MapAtapiErrorToOsError(GetErrorCode(IoPort), Srb);
			return;
		}
	}

	//
	// If a tape drive has doesn't have DSC set and the last command is restrictive, don't send
	// the next command. See discussion of Restrictive Delayed Process commands in QIC-157.
	//

	if ((!(statusByte & IDE_STATUS_DSC)) &&
		  (flags & DFLAGS_TAPE_DEVICE) && (flags & DFLAGS_TAPE_RDP)) {

		ScsiPortStallExecution(1000);
		goto busy;
	}

	if(IS_RDP(Srb->Cdb[0]))
		pDev->DeviceFlags |= DFLAGS_TAPE_RDP;
	else
		pDev->DeviceFlags &= ~DFLAGS_TAPE_RDP;

	if (statusByte & IDE_STATUS_DRQ) {

		// Try to drain the data that one preliminary device thinks that it has
		// to transfer. Hopefully this random assertion of DRQ will not be present
		// in production devices.
		//

		for (i = 0; i < 0x10000; i++) {

			statusByte = GetStatus(ControlPort);

			if (statusByte & IDE_STATUS_DRQ) {

				ScsiPortReadPortUshort(&IoPort->Data);

			} else {

				break;
			}
		}

		if (i == 0x10000) {

			AtapiSoftReset(IoPort,ControlPort,pDev->UnitId);

			//
			// Re-initialize Atapi device.
			//

			IssueIdentify(pDev,
						  IDE_COMMAND_ATAPI_IDENTIFY,
						  (PUSHORT)&Identify);
			//
			// Inform the port driver that the bus has been reset.
			//

			ScsiPortNotification(ResetDetected, pChan->HwDeviceExtension, 0);

			//
			// Clean up device extension fields that AtapiStartIo won't.
			//
			Srb->SrbStatus = SRB_STATUS_BUS_RESET;
			return;
		}
	}

	if (flags & (DFLAGS_SANYO_ATAPI_CHANGER | DFLAGS_ATAPI_CHANGER)) {

		//
		// As the cdrom driver sets the LUN field in the cdb, it must be removed.
		//

		Srb->Cdb[1] &= ~0xE0;

		if ((Srb->Cdb[0] == SCSIOP_TEST_UNIT_READY) && (flags & DFLAGS_SANYO_ATAPI_CHANGER)) {

			//
			// Torisan changer. TUR's are overloaded to be platter switches.
			//

			Srb->Cdb[7] = Srb->Lun;

		}
	}

	//
	// Convert SCSI to ATAPI commands if needed
	//
	if (flags & DFLAGS_TAPE_DEVICE)
		goto no_convert;

	switch (Srb->Cdb[0]) {
		case SCSIOP_MODE_SENSE: {
									PMODE_SENSE_10 modeSense10 = (PMODE_SENSE_10)Srb->Cdb;
									UCHAR PageCode = ((PCDB)Srb->Cdb)->MODE_SENSE.PageCode;
									UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SENSE.AllocationLength;

									ZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

									modeSense10->OperationCode = ATAPI_MODE_SENSE;
									modeSense10->PageCode = PageCode;
									modeSense10->ParameterListLengthMsb = 0;
									modeSense10->ParameterListLengthLsb = Length;
									break;
								}

		case SCSIOP_MODE_SELECT: {
									 PMODE_SELECT_10 modeSelect10 = (PMODE_SELECT_10)Srb->Cdb;
									 UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SELECT.ParameterListLength;

			//
			// Zero the original cdb
			//

									 ZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

									 modeSelect10->OperationCode = ATAPI_MODE_SELECT;
									 modeSelect10->PFBit = 1;
									 modeSelect10->ParameterListLengthMsb = 0;
									 modeSelect10->ParameterListLengthLsb = Length;
									 break;
								 }

		case SCSIOP_FORMAT_UNIT:
			Srb->Cdb[0] = ATAPI_FORMAT_UNIT;
			break;
	}

no_convert:

	if((pDev->DeviceFlags & (DFLAGS_DMA|DFLAGS_ULTRA)) &&
	   (pDev->DeviceFlags & DFLAGS_FORCE_PIO) == 0 &&
	   (Srb->Cdb[0] == 0x28 || Srb->Cdb[0] == 0x2A ||
		  Srb->Cdb[0] == 0x8 || Srb->Cdb[0] == 0xA) &&
	   BuildSgl(pDev, pChan->pSgTable, Srb)) 
		pDev->DeviceFlags |= DFLAGS_REQUEST_DMA;
	else
		pDev->DeviceFlags &= ~DFLAGS_REQUEST_DMA;

	StartAtapiCommand(pDev ARG_SRB);
}



/******************************************************************
 *  
 *******************************************************************/

void WINNT_Check_Smart_Cmd(PDevice pDev, PSCSI_REQUEST_BLOCK Srb)
{
	PChannel  pChan = pDev->pChannel;	 
	PATAPI_REGISTERS_1 IoPort = (PATAPI_REGISTERS_1)pChan->BaseIoAddress1;
	PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
	UCHAR             error = 0;
	UCHAR  status = Srb->SrbStatus, statusByte;

	if (status != SRB_STATUS_SUCCESS) {
		error = ScsiPortReadPortUchar((PUCHAR)IoPort + 1);
	}

	//
	// Build the SMART status block depending upon the completion status.
	//

	cmdOutParameters->cBufferSize = 0; //wordCount;
	cmdOutParameters->DriverStatus.bDriverError = (error) ? SMART_IDE_ERROR : 0;
	cmdOutParameters->DriverStatus.bIDEError = error;

	//
	// If the sub-command is return smart status, jam the value from cylinder low and high, into the
	// data buffer.
	//

	if (pDev->SmartCommand == RETURN_SMART_STATUS) {
		cmdOutParameters->bBuffer[0] = RETURN_SMART_STATUS;
		cmdOutParameters->bBuffer[1] = ScsiPortReadPortUchar(&IoPort->InterruptReason);
		cmdOutParameters->bBuffer[2] = ScsiPortReadPortUchar(&IoPort->Unused1);
		cmdOutParameters->bBuffer[3] = ScsiPortReadPortUchar(&IoPort->ByteCountLow);
		cmdOutParameters->bBuffer[4] = ScsiPortReadPortUchar(&IoPort->ByteCountHigh);
		cmdOutParameters->bBuffer[5] = ScsiPortReadPortUchar(&IoPort->DriveSelect);
		cmdOutParameters->bBuffer[6] = SMART_CMD;
		cmdOutParameters->cBufferSize = 8;
	}

	//
	// Indicate command complete.
	//

	ScsiPortNotification(RequestComplete,
						 pChan->HwDeviceExtension,
						 Srb);

}

/******************************************************************
 *  
 *******************************************************************/


BOOLEAN Atapi_End_Interrupt(PDevice pDev , PSCSI_REQUEST_BLOCK Srb)
{
	PChannel  pChan = pDev->pChannel;	 
	PIDE_REGISTERS_1     IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	UCHAR  status = Srb->SrbStatus, statusByte;
	ULONG  i;

	if((pDev->DeviceFlags & DFLAGS_DMAING) == 0 && pChan->WordsLeft)
		status = SRB_STATUS_DATA_OVERRUN;
	else if(Srb->SrbStatus == SRB_STATUS_PENDING)
		status = SRB_STATUS_SUCCESS;


	// Check and see if we are processing our secret (mechanism status/request sense) Srb
	//
	if (pChan->OriginalSrb) {

		if (Srb->Cdb[0] == SCSIOP_MECHANISM_STATUS) {

			if (status == SRB_STATUS_SUCCESS) {
				// Bingo!!
				AtapiHwInitializeChanger (pDev,
										  (PMECHANICAL_STATUS_INFORMATION_HEADER) Srb->DataBuffer);

				// Get ready to issue the original Srb
				Srb = pChan->CurrentSrb = pChan->OriginalSrb;
				pChan->OriginalSrb = NULL;

			} else {
				// failed!  Get the sense key and maybe try again
				Srb = pChan->CurrentSrb = BuildRequestSenseSrb (
					pChan,
					pChan->OriginalSrb->PathId,
					pChan->OriginalSrb->TargetId);
			}

			Start_Atapi(pDev, pChan->CurrentSrb);
			if (Srb->SrbStatus == SRB_STATUS_PENDING) {
				return TRUE;
			}

		} else { // Srb->Cdb[0] == SCSIOP_REQUEST_SENSE)

			PSENSE_DATA senseData = (PSENSE_DATA) Srb->DataBuffer;

			if (status == SRB_STATUS_DATA_OVERRUN) {
				// Check to see if we at least get mininum number of bytes
				if ((Srb->DataTransferLength - pChan->WordsLeft) >
					  (offsetof (SENSE_DATA, AdditionalSenseLength) + sizeof(senseData->AdditionalSenseLength))) {
					status = SRB_STATUS_SUCCESS;
				}
			}

			if (status == SRB_STATUS_SUCCESS) {
				if ((senseData->SenseKey != SCSI_SENSE_ILLEGAL_REQUEST) &&
					  pChan->MechStatusRetryCount) {

					// The sense key doesn't say the last request is illegal, so try again
					pChan->MechStatusRetryCount--;
					Srb = pChan->CurrentSrb = BuildMechanismStatusSrb (
						pChan,
						pChan->OriginalSrb->PathId,
						pChan->OriginalSrb->TargetId);
				} else {

					// last request was illegal.  No point trying again

					AtapiHwInitializeChanger (pDev,
											  (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);

					// Get ready to issue the original Srb
					Srb = pChan->CurrentSrb = pChan->OriginalSrb;
					pChan->OriginalSrb = NULL;
				}

				Start_Atapi(pDev, pChan->CurrentSrb);
				if (Srb->SrbStatus == SRB_STATUS_PENDING) {
					return TRUE;
				}
			}
		}

		// If we get here, it means AtapiSendCommand() has failed
		// Can't recover.  Pretend the original Srb has failed and complete it.

		if (pChan->OriginalSrb) {
			AtapiHwInitializeChanger (pDev,
									  (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);
			Srb = pChan->CurrentSrb = pChan->OriginalSrb;
			pChan->OriginalSrb = NULL;
		}

		// fake an error and read no data
		status = SRB_STATUS_ERROR;
		Srb->ScsiStatus = 0;
		pChan->BufferPtr = Srb->DataBuffer;
		pChan->WordsLeft = Srb->DataTransferLength;
		pDev->DeviceFlags &= ~DFLAGS_TAPE_RDP;

	} else if (status != SRB_STATUS_SUCCESS) {

		pDev->DeviceFlags &= ~DFLAGS_TAPE_RDP;

	} else {

		//
		// Wait for busy to drop.
		//

		for (i = 0; i < 30; i++) {
			statusByte = GetStatus(ControlPort);
			if (!(statusByte & IDE_STATUS_BUSY)) {
				break;
			}
			ScsiPortStallExecution(500);
		}

		if (i == 30) {

			//
			// reset the controller.
			AtapiResetController(
								 pChan->HwDeviceExtension,Srb->PathId);
			return TRUE;
		}

		//
		// Check to see if DRQ is still up.
		//

		if (statusByte & IDE_STATUS_DRQ) {

			for (i = 0; i < 500; i++) {
				statusByte = GetStatus(ControlPort);
				if (!(statusByte & IDE_STATUS_DRQ)) {
					break;
				}
				ScsiPortStallExecution(100);

			}

			if (i == 500) {

				//
				// reset the controller.
				//
				AtapiResetController(pChan->HwDeviceExtension,Srb->PathId);
				return TRUE;
			}

		}
	}

	//
	// Sanity check that there is a current request.
	//

	if (Srb != NULL) {

		//
		// Set status in SRB.
		//

		Srb->SrbStatus = (UCHAR)status;

		//
		// Check for underflow.
		//

		if (pChan->WordsLeft) {

			//
			// Subtract out residual words and update if filemark hit,
			// setmark hit , end of data, end of media...
			//

			if (!(pDev->DeviceFlags & DFLAGS_TAPE_DEVICE)) {
				if (status == SRB_STATUS_DATA_OVERRUN) {
					Srb->DataTransferLength -= pChan->WordsLeft;
				} else {
					Srb->DataTransferLength = 0;
				}
			} else {
				Srb->DataTransferLength -= pChan->WordsLeft;
			}
		}

	} 

	//
	// Indicate ready for next request.
	//
	if (!(pDev->DeviceFlags & DFLAGS_TAPE_RDP)) 
		DeviceInterrupt(pDev, 1);
	else 
		OS_Busy_Handle(pChan, pDev);
	return TRUE;

} // end AtapiInterrupt()


void
   IdeSendSmartCommand(
					   IN PDevice pDev,
					   IN PSCSI_REQUEST_BLOCK Srb
					  )

/*++

Routine Description:

    This routine handles SMART enable, disable, read attributes and threshold commands.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
	PChannel             pChan = pDev->pChannel;
	PIDE_REGISTERS_1     IoPort  = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2     ControlPort  = pChan->BaseIoAddress2;
	PSENDCMDOUTPARAMS    cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
	SENDCMDINPARAMS      cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
	PIDEREGS             regs = &cmdInParameters.irDriveRegs;
	ULONG                i;
	UCHAR                statusByte,targetId, status;


	switch (((PSRB_IO_CONTROL)(Srb->DataBuffer))->ControlCode) {

		case IOCTL_SCSI_MINIPORT_SMART_VERSION: {

													PGETVERSIONINPARAMS versionParameters = (PGETVERSIONINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
													UCHAR deviceNumber;

			//
			// Version and revision per SMART 1.03
			//

													versionParameters->bVersion = 1;
													versionParameters->bRevision = 1;
													versionParameters->bReserved = 0;

			//
			// Indicate that support for IDE IDENTIFY, ATAPI IDENTIFY and SMART commands.
			//

													versionParameters->fCapabilities = (CAP_ATA_ID_CMD | CAP_ATAPI_ID_CMD | CAP_SMART_CMD);

			//
			// This is done because of how the IOCTL_SCSI_MINIPORT
			// determines 'targetid's'. Disk.sys places the real target id value
			// in the DeviceMap field. Once we do some parameter checking, the value passed
			// back to the application will be determined.
			//

													deviceNumber = versionParameters->bIDEDeviceMap;

													if (pDev->DeviceFlags & DFLAGS_ATAPI) {

														status = SRB_STATUS_SELECTION_TIMEOUT;
														goto out;
													}


													versionParameters->bIDEDeviceMap = (1 << Srb->TargetId);

													status = SRB_STATUS_SUCCESS;
													goto out;
												}

		case IOCTL_SCSI_MINIPORT_IDENTIFY: {

											   PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
											   SENDCMDINPARAMS   cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
											   ULONG             i;
											   UCHAR             targetId;


											   if (cmdInParameters.irDriveRegs.bCommandReg == ID_CMD) {

				//
				// Extract the target.
				//

												   targetId = cmdInParameters.bDriveNumber;

												   if (pDev->DeviceFlags & DFLAGS_ATAPI) {
timeout:
													   status = SRB_STATUS_SELECTION_TIMEOUT;
													   goto out;
												   }

				//
				// Zero the output buffer
				//

												   for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE - 1); i++) {
													   ((PUCHAR)cmdOutParameters)[i] = 0;
												   }

				//
				// Build status block.
				//

												   cmdOutParameters->cBufferSize = IDENTIFY_BUFFER_SIZE;
												   cmdOutParameters->DriverStatus.bDriverError = 0;
												   cmdOutParameters->DriverStatus.bIDEError = 0;

				//
				// Extract the identify data from the device extension.
				//

												   ZeroMemory(cmdOutParameters->bBuffer, 512);
												   ScsiPortMoveMemory (cmdOutParameters->bBuffer, &pDev->IdentifyData, IDENTIFY_DATA_SIZE);

												   status = SRB_STATUS_SUCCESS;


											   } else {
												   status = SRB_STATUS_INVALID_REQUEST;
											   }
											   goto out;
										   }

		case  IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS:
		case  IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS:
		case  IOCTL_SCSI_MINIPORT_ENABLE_SMART:
		case  IOCTL_SCSI_MINIPORT_DISABLE_SMART:
		case  IOCTL_SCSI_MINIPORT_RETURN_STATUS:
		case  IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE:
		case  IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES:
		case  IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS:
			break;

		default :

			status = SRB_STATUS_INVALID_REQUEST;
			goto out;
	}


	Srb->SrbStatus = SRB_STATUS_PENDING;

	if (cmdInParameters.irDriveRegs.bCommandReg == SMART_CMD) {

		targetId = cmdInParameters.bDriveNumber;

		//TODO optimize this check

		if (pDev->DeviceFlags & DFLAGS_ATAPI) {

			goto timeout;
		}

		pDev->SmartCommand = cmdInParameters.irDriveRegs.bFeaturesReg;

		//
		// Determine which of the commands to carry out.
		//

		if ((cmdInParameters.irDriveRegs.bFeaturesReg == READ_ATTRIBUTES) ||
			  (cmdInParameters.irDriveRegs.bFeaturesReg == READ_THRESHOLDS)) {

			statusByte = WaitOnBusy(ControlPort);

			if (statusByte & IDE_STATUS_BUSY) {
busy:
				status = SRB_STATUS_BUSY;
				goto out;
			}

			//
			// Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
			//

			for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + READ_ATTRIBUTE_BUFFER_SIZE - 1); i++) {
				((PUCHAR)cmdOutParameters)[i] = 0;
			}

			//
			// Set data buffer pointer and words left.
			//

			pChan->BufferPtr = (ADDRESS)cmdOutParameters->bBuffer;
			pChan->WordsLeft = READ_ATTRIBUTE_BUFFER_SIZE / 2;

			ScsiPortWritePortUchar(&IoPort->DriveSelect,(UCHAR)((targetId << 4) | 0xA0));
			ScsiPortWritePortUchar((PUCHAR)IoPort + 1,regs->bFeaturesReg);
			ScsiPortWritePortUchar(&IoPort->BlockCount,regs->bSectorCountReg);
			ScsiPortWritePortUchar(&IoPort->BlockNumber,regs->bSectorNumberReg);
			ScsiPortWritePortUchar(&IoPort->CylinderLow,regs->bCylLowReg);
			ScsiPortWritePortUchar(&IoPort->CylinderHigh,regs->bCylHighReg);
			ScsiPortWritePortUchar(&IoPort->Command,regs->bCommandReg);

			//
			// Wait for interrupt.
			//

			return;

		} else if ((cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_SMART) ||
				   (cmdInParameters.irDriveRegs.bFeaturesReg == DISABLE_SMART) ||
				   (cmdInParameters.irDriveRegs.bFeaturesReg == RETURN_SMART_STATUS) ||
				   (cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_DISABLE_AUTOSAVE) ||
				   (cmdInParameters.irDriveRegs.bFeaturesReg == EXECUTE_OFFLINE_DIAGS) ||
				   (cmdInParameters.irDriveRegs.bFeaturesReg == SAVE_ATTRIBUTE_VALUES)) {

			statusByte = WaitOnBusy(ControlPort);

			if (statusByte & IDE_STATUS_BUSY) {
				goto busy;
			}

			//
			// Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
			//

			for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) - 1); i++) {
				((PUCHAR)cmdOutParameters)[i] = 0;
			}

			//
			// Set data buffer pointer and indicate no data transfer.
			//

			pChan->BufferPtr = (ADDRESS)cmdOutParameters->bBuffer;
			pChan->WordsLeft = 0;

			//
			// Indicate expecting an interrupt.
			//

			ScsiPortWritePortUchar(&IoPort->DriveSelect,(UCHAR)((targetId << 4) | 0xA0));
			ScsiPortWritePortUchar((PUCHAR)IoPort + 1,regs->bFeaturesReg);
			ScsiPortWritePortUchar(&IoPort->BlockCount,regs->bSectorCountReg);
			ScsiPortWritePortUchar(&IoPort->BlockNumber,regs->bSectorNumberReg);
			ScsiPortWritePortUchar(&IoPort->CylinderLow,regs->bCylLowReg);
			ScsiPortWritePortUchar(&IoPort->CylinderHigh,regs->bCylHighReg);
			ScsiPortWritePortUchar(&IoPort->Command,regs->bCommandReg);

			//
			// Wait for interrupt.
			//

			return ;
		}
	}

	status = SRB_STATUS_INVALID_REQUEST;
out:
	Srb->SrbStatus = status;


} // end IdeSendSmartCommand()

PSCSI_REQUEST_BLOCK
   BuildMechanismStatusSrb (
							IN PChannel pChan,
							IN ULONG PathId,
							IN ULONG TargetId
						   )
{
	PSCSI_REQUEST_BLOCK Srb;
	PCDB cdb;

	Srb = &pChan->InternalSrb;

	ZeroMemory((PUCHAR) Srb, sizeof(SCSI_REQUEST_BLOCK));

	Srb->PathId     = (UCHAR) PathId;
	Srb->TargetId   = (UCHAR) TargetId;
	Srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
	Srb->Length     = sizeof(SCSI_REQUEST_BLOCK);

	//
	// Set flags to disable synchronous negociation.
	//
	Srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

	//
	// Set timeout to 2 seconds.
	//
	Srb->TimeOutValue = 4;

	Srb->CdbLength          = 6;
	Srb->DataBuffer         = &pChan->MechStatusData;
	Srb->DataTransferLength = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

	//
	// Set CDB operation code.
	//
	cdb = (PCDB)Srb->Cdb;
	cdb->MECH_STATUS.OperationCode       = SCSIOP_MECHANISM_STATUS;
	cdb->MECH_STATUS.AllocationLength[1] = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

	return Srb;
}

PSCSI_REQUEST_BLOCK
   BuildRequestSenseSrb (
						 IN PChannel pChan,
						 IN ULONG PathId,
						 IN ULONG TargetId
						)
{
	PSCSI_REQUEST_BLOCK Srb;
	PCDB cdb;

	Srb = &pChan->InternalSrb;

	ZeroMemory((PUCHAR) Srb, sizeof(SCSI_REQUEST_BLOCK));

	Srb->PathId     = (UCHAR) PathId;
	Srb->TargetId   = (UCHAR) TargetId;
	Srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
	Srb->Length     = sizeof(SCSI_REQUEST_BLOCK);

	//
	// Set flags to disable synchronous negociation.
	//
	Srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

	//
	// Set timeout to 2 seconds.
	//
	Srb->TimeOutValue = 4;

	Srb->CdbLength          = 6;
	Srb->DataBuffer         = &pChan->MechStatusSense;
	Srb->DataTransferLength = sizeof(SENSE_DATA);

	//
	// Set CDB operation code.
	//
	cdb = (PCDB)Srb->Cdb;
	cdb->CDB6INQUIRY.OperationCode    = SCSIOP_REQUEST_SENSE;
	cdb->CDB6INQUIRY.AllocationLength = sizeof(SENSE_DATA);

	return Srb;
}


#ifdef WIN2000

SCSI_ADAPTER_CONTROL_STATUS
   AtapiAdapterControl(
					   IN PHW_DEVICE_EXTENSION deviceExtension,
					   IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
					   IN PVOID Parameters
					  )

/*++

Routine Description:

    This routine is called at various time's by SCSIPort and is used
    to provide a control function over the adapter. Most commonly, NT
    uses this entry point to control the power state of the HBA during
    a hibernation operation.

Arguments:

    HwDeviceExtension - HBA miniport driver's per adapter storage
    Parameters  - This varies by control type, see below.
    ControlType - Indicates which adapter control function should be 
                  executed. Conrol Types are detailed below.

Return Value:

    ScsiAdapterControlSuccess - requested ControlType completed successfully
    ScsiAdapterControlUnsuccessful - requested ControlType failed

--*/


{
	PChannel    pChan;
	PSCSI_SUPPORTED_CONTROL_TYPE_LIST ControlTypeList;
	ULONG AdjustedMaxControlType, i;

	ULONG Index;
	UCHAR statusByte;
	//
	// Default Status
	//
	SCSI_ADAPTER_CONTROL_STATUS Status = ScsiAdapterControlSuccess;

	//
	// Structure defining which functions this miniport supports
	//

	BOOLEAN SupportedConrolTypes[MAX_CONTROL_TYPE] = {
		TRUE,   // ScsiQuerySupportedControlTypes
		TRUE,   // ScsiStopAdapter
		TRUE,   // ScsiRestartAdapter
		FALSE,  // ScsiSetBootConfig
		FALSE   // ScsiSetRunningConfig
	};

	//
	// Execute the correct code path based on ControlType
	//
	switch (ControlType) {

		case ScsiQuerySupportedControlTypes:
			//
			// This entry point provides the method by which SCSIPort determines the
			// supported ControlTypes. Parameters is a pointer to a
			// SCSI_SUPPORTED_CONTROL_TYPE_LIST structure. Fill in this structure
			// honoring the size limits.
			//
			ControlTypeList = Parameters;
			AdjustedMaxControlType = 
									(ControlTypeList->MaxControlType < MAX_CONTROL_TYPE) ? 
									ControlTypeList->MaxControlType : MAX_CONTROL_TYPE;

			for (Index = 0; Index < AdjustedMaxControlType; Index++) {
				ControlTypeList->SupportedTypeList[Index] = 
					SupportedConrolTypes[Index];
			};
			break;

		case ScsiStopAdapter:
			//
			// This entry point is called by SCSIPort when it needs to stop/disable
			// the HBA. Parameters is a pointer to the HBA's HwDeviceExtension. The adapter
			// has already been quiesced by SCSIPort (i.e. no outstanding SRBs). Hence the adapter
			// should abort/complete any internally generated commands, disable adapter interrupts
			// and optionally power down the adapter.
			//

			//
			// Before we stop the adapter, we need to save the adapter's state
			// information for reinitialization purposes. For this adpater the
			// HwSaveState entry point will suffice.
			//
			if (AtapiAdapterState(deviceExtension, NULL, TRUE) == FALSE) {
				//
				// Adapter is unable to save it's state information, we must fail this
				// request since the process of restarting the adapter will not succeed.
				//
				return ScsiAdapterControlUnsuccessful;
			}

			//
			// Reset the adapter
			//
			for(i = 0, pChan = deviceExtension->IDEChannel; i < 2; i++, pChan++){
				if((pChan->pWorkDev != NULL)&&
				   (pChan->pWorkDev->DeviceFlags & DFLAGS_DMAING)) {
				  //
				  // Stop the DMA
				  //
					ScsiPortWritePortUchar(pChan->BMI, BMI_CMD_STOP);
					pChan->pWorkDev->DeviceFlags &= ~DFLAGS_DMAING;
				}																 
			}

			break;

		case ScsiRestartAdapter:
				//
				// This entry point is called by SCSIPort when it needs to re-enable
				// a previously stopped adapter. In the generic case, previously
				// suspended IO operations should be restarted and the adapter's
				// previous configuration should be reinstated. Our hardware device
				// extension and uncached extensions have been preserved so no
				// actual driver software reinitialization is necesarry.
				//

				//
				// The adapter's firmware configuration is returned via HwAdapterState.
				//
			if (AtapiAdapterState(deviceExtension, NULL, FALSE) == FALSE) {
					//
					// Adapter is unable to restore it's state information, we must fail this
					// request since the process of restarting the adapter will not succeed.
					//
				Status = ScsiAdapterControlUnsuccessful;
			}

			Status = ScsiAdapterControlSuccess;

			break;

		case ScsiSetBootConfig:
			Status = ScsiAdapterControlUnsuccessful;
			break;

		case ScsiSetRunningConfig:
			Status = ScsiAdapterControlUnsuccessful;
			break;

		case ScsiAdapterControlMax:
			Status = ScsiAdapterControlUnsuccessful;
			break;

		default:
			Status = ScsiAdapterControlUnsuccessful;
			break;
	}

	return Status;
}
#endif //WIN2000

/******************************************************************
 * Get Stamps 
 *******************************************************************/

ULONG GetStamp(void)
{
	static ULONG last_stamp = 0x1ABCDEF2;
	return ++last_stamp;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\xpro.c ===
//#define   DEVICE_MAIN
#include  "vtoolsc.h"
//#include "vmm.h"
//#include "ifs.h"
//#include "isp.h"
//#include "ilb.h"
//#include "drp.h"
#include "dcb.h"
//#undef    DEVICE_MAIN

LONG __stdcall GetCurrentTime()
{
	ALLREGS regs;
	memset(&regs, 0, sizeof(regs));

	regs.REAX = 0x200;
	Exec_VxD_Int(0x1A, &regs);			// Invoke interrupt 1Ah to get current time in BCD code
	return ((regs.RECX << 8)|((regs.REDX>>8)&(0xFF)));
}

LONG __stdcall GetCurrentDate()
{
	ALLREGS regs;
	memset(&regs, 0, sizeof(regs));
	regs.REAX = 0x400;
	Exec_VxD_Int(0x1A, &regs);
	return ((regs.RECX << 16)|(regs.REDX&0xFFFF));
}

HANDLE __stdcall PrepareForNotification(HANDLE hEvent)
{	  
	return hEvent;
}

void __stdcall NotifyApplication(HANDLE hEvent)
{						  
	if(hEvent != NULL){
		_VWIN32_SetWin32Event(hEvent);
	}
}

void __stdcall CloseNotifyEventHandle(HANDLE hEvent)
{								
	if(hEvent != NULL){
		_VWIN32_CloseVxDHandle(hEvent);
	}
}

#define SUPPORT_XPRO	
#ifdef SUPPORT_XPRO

//
// Registry key
//
#define KEY_XPRO		"SOFTWARE\\HighPoint\\XPro"		// Registry key to store the option
#define VAL_ENABLE		"Enable"						// Value to store the Enable flag
#define VAL_CACHESIZE	"CacheSize"						// Value to store the Cache size

//*************************************************************************
// read ahead
//*************************************************************************
int     need_read_ahead = 0;
DWORD	dwEnable = 1;					// Enable flag of Read Ahead
DWORD   Api_mem_Sz = (1 << 20);         // 1M bufffer
DWORD   Masks      = ~((1 << 20) - 1);  // 1M Mask
int     pBuffer = 0;
int     excluded = 0;
char    is_disk[32] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        };

char	chgHookDrive[8];

ppIFSFileHookFunc PrevHook;


int _cdecl MyIfsHook(pIFSFunc pfn, int fn, int Drive, int ResType,
 		int CodePage, pioreq pir)
{
   int error;
   struct ioreq ioreq_buf;

   need_read_ahead= 0;

   if((error = (*PrevHook)(pfn, fn, Drive, ResType, CodePage, pir)) != 0)
		return(error);

   if(fn == IFSFN_READ && dwEnable &&
      need_read_ahead && pir->ir_options == 0 && pir->ir_length > 512 &&
      pir->ir_length <= (Api_mem_Sz  >> 1) && is_disk[Drive] && 
      excluded++ == 0) {
         ioreq_buf = *pir;
         ioreq_buf.ir_pos &= Masks;
         ioreq_buf.ir_length = Api_mem_Sz;
         *(int *)&ioreq_buf.ir_data = (int)pBuffer;
         (*pfn)(&ioreq_buf);
         excluded = 0;
      }

	return(0);
}

//*************************************************************************
// system hook
//*************************************************************************

int hooked = 0;
void ifs_hook(PVOID pvoid, DWORD d)
{
   struct DemandInfoStruc mem_info;
   ISP_GET_FRST_NXT_DCB fn_dcb;
   DCB_COMMON*   pDcb;
	PILB          pIlb;
	PDRP          pDrp;
	struct tagDDB*	pDdb;

	pDdb = (struct tagDDB*)Get_DDB(0, "SCSIPORT");
	pDrp = (PDRP)(pDdb->DDB_Reference_Data);
	pIlb = (PILB)(pDrp->DRP_ilb);

   fn_dcb.ISP_gfnd_hdr.ISP_func = ISP_GET_FIRST_NEXT_DCB;
   fn_dcb.ISP_gfnd_dcb_offset = 0;
   fn_dcb.ISP_gfnd_dcb_type = DCB_type_disk;
   for( ; ; ) {
      pIlb->ILB_service_rtn((PISP)&fn_dcb);
      if(fn_dcb.ISP_gfnd_hdr.ISP_result ||
          (pDcb = fn_dcb.ISP_gfnd_found_dcb) == 0)
          break;

      if((pDcb->DCB_device_flags & DCB_DEV_LOGICAL) != 0) {
          PDCB pPhyDCB = (PDCB)pDcb->DCB_physical_dcb;

//          if((*(DWORD*)&pPhyDCB->DCB_port_name[0] == '3tph'||
//          *(DWORD*)&pPhyDCB->DCB_port_name[0] == 'giis') &&
//          *(WORD*)&pPhyDCB->DCB_port_name[4] == '07' &&
//          pDcb->DCB_device_type == DCB_type_disk &&
//          pDcb->DCB_drive_lttr_equiv < 31)

		  if((memcmp(pPhyDCB->DCB_port_name, chgHookDrive, sizeof(pPhyDCB->DCB_port_name))==0)&&
			 (pDcb->DCB_device_type == DCB_type_disk)&&
			 (pDcb->DCB_drive_lttr_equiv < 31)){
			  is_disk[pDcb->DCB_drive_lttr_equiv + 1] = 1;
		  }
      }

      fn_dcb.ISP_gfnd_dcb_offset = (DWORD)pDcb;
   }

   GetDemandPageInfo(&mem_info, 0);

   if(mem_info.DIPhys_Count > 0x1000) {
      if(mem_info.DIPhys_Count < 0x2000) {
         Api_mem_Sz =  (1 << 17);
         Masks = ~((1 << 17) - 1);
      }
      if((pBuffer = (int)HeapAllocate(Api_mem_Sz, 0)) != 0)  
        PrevHook = IFSMgr_InstallFileSystemApiHook(MyIfsHook);
   }

}

VOID start_ifs_hook(PCHAR pchDriveName)
{										  
	int nLength;


////////////////////////////////////////////////////////////
// Load option from Registry
////////////////////////////////////////////////////////////
	HKEY		hResult;
	DWORD		dwType = REG_DWORD;
	DWORD		dwSize = sizeof(REG_DWORD);
	DWORD		dwCacheSize;

	// Open the Registry key
	_RegOpenKey( HKEY_LOCAL_MACHINE,
				(LPTSTR)KEY_XPRO,
				(PHKEY)&hResult );

	// Read the value of Enable flag
	if( _RegQueryValueEx( hResult,
						 VAL_ENABLE,
						 NULL,
						 &dwType,
						 (unsigned char *)&dwEnable,
						 &dwSize
						) != ERROR_SUCCESS )
	{
		dwEnable = 1;
	}
	
	// Read the value of CacheSize
	if(_RegQueryValueEx( hResult,
						 VAL_CACHESIZE,
						 NULL,
						 &dwType,
						 (unsigned char *)&dwCacheSize,
						 &dwSize
						) != ERROR_SUCCESS )
	{
		dwCacheSize = 1024;
	}
	
	if((dwCacheSize <= 1024) && (dwCacheSize > 0))
	{
		Api_mem_Sz = dwCacheSize * 1024;
	}
	else
	{
		Api_mem_Sz = (1 << 20);	// 1MB
	}

	Masks = ~(Api_mem_Sz - 1);

	// Close the Registry key
	_RegCloseKey(hResult);
////////////////////

	memset(&chgHookDrive, 0, sizeof(chgHookDrive));
	if(pchDriveName != NULL){
		nLength = strlen(pchDriveName);
		if(!(nLength > sizeof(chgHookDrive))){
			memcpy(&chgHookDrive, pchDriveName, strlen(pchDriveName));
		}
	}
	if(hooked++ == 0)
		SHELL_CallAtAppyTime(ifs_hook, 0, 0, -1);
}

#endif //SUPPORT_XPRO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\ibm\cbidf\atapi.c ===
/*++

Copyright (c) 1993-4  Microsoft Corporation

Module Name:

    atapi.c

Abstract:

    This is the miniport driver for ATAPI IDE controllers.

Author:

    Mike Glass (MGlass)
    Chuck Park (ChuckP)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ntddk.h"
// #include "miniport.h"
#include "atapi.h"               // includes scsi.h
#include "ntdddisk.h"
#include "ntddscsi.h"

//
// Device extension
//

typedef struct _HW_DEVICE_EXTENSION {

    //
    // Current request on controller.
    //

    PSCSI_REQUEST_BLOCK CurrentSrb;

    //
    // Base register locations
    //

    PIDE_REGISTERS_1 BaseIoAddress1[2];
    PIDE_REGISTERS_2 BaseIoAddress2[2];

    //
    // Interrupt level
    //

    ULONG InterruptLevel;

    //
    // Interrupt Mode (Level or Edge)
    //

    ULONG InterruptMode;

    //
    // Data buffer pointer.
    //

    PUSHORT DataBuffer;

    //
    // Data words left.
    //

    ULONG WordsLeft;

    //
    // Number of channels being supported by one instantiation
    // of the device extension. Normally (and correctly) one, but
    // with so many broken PCI IDE controllers being sold, we have
    // to support them.
    //

    ULONG NumberChannels;

    //
    // Count of errors. Used to turn off features.
    //

    ULONG ErrorCount;

    //
    // Indicates number of platters on changer-ish devices.
    //

    ULONG DiscsPresent[4];

    //
    // Flags word for each possible device.
    //

    USHORT DeviceFlags[4];

    //
    // Indicates the number of blocks transferred per int. according to the
    // identify data.
    //

    UCHAR MaximumBlockXfer[4];

    //
    // Indicates expecting an interrupt
    //

    BOOLEAN ExpectingInterrupt;

    //
    // Indicate last tape command was DSC Restrictive.
    //

    BOOLEAN RDP;

    //
    // Driver is being used by the crash dump utility or ntldr.
    //

    BOOLEAN DriverMustPoll;

    //
    // Indicates use of 32-bit PIO
    //

    BOOLEAN DWordIO;

    //
    // Indicates whether '0x1f0' is the base address. Used
    // in SMART Ioctl calls.
    //

    BOOLEAN PrimaryAddress;

    //
    // Placeholder for the sub-command value of the last
    // SMART command.
    //

    UCHAR SmartCommand;

    //
    // Placeholder for status register after a GET_MEDIA_STATUS command
    //

    UCHAR ReturningMediaStatus;

    //
    // Indicate support irq sharing
    //

    BOOLEAN IrqSharing;

    //
    // Identify data for device
    //

    IDENTIFY_DATA FullIdentifyData;
    IDENTIFY_DATA2 IdentifyData[4];

    //
    // Mechanism Status Srb Data
    //
    PSCSI_REQUEST_BLOCK OriginalSrb;
    SCSI_REQUEST_BLOCK InternalSrb;
    MECHANICAL_STATUS_INFORMATION_HEADER MechStatusData;
    SENSE_DATA MechStatusSense;
    ULONG MechStatusRetryCount;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// Logical unit extension
//

typedef struct _HW_LU_EXTENSION {
   ULONG Reserved;
} HW_LU_EXTENSION, *PHW_LU_EXTENSION;

PSCSI_REQUEST_BLOCK
BuildMechanismStatusSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    );

PSCSI_REQUEST_BLOCK
BuildRequestSenseSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    );

VOID
AtapiHwInitializeChanger (
    IN PVOID HwDeviceExtension,
    IN ULONG TargetId,
    IN PMECHANICAL_STATUS_INFORMATION_HEADER MechanismStatus
    );

ULONG
AtapiSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
AtapiZeroMemory(
    IN PCHAR Buffer,
    IN ULONG Count
    );

VOID
AtapiHexToString (
    ULONG Value,
    PCHAR *Buffer
    );

LONG
AtapiStringCmp (
    PCHAR FirstStr,
    PCHAR SecondStr,
    ULONG Count
    );

BOOLEAN
AtapiInterrupt(
    IN PVOID HwDeviceExtension
    );

BOOLEAN
AtapiHwInitialize(
    IN PVOID HwDeviceExtension
        );

ULONG
IdeBuildSenseBuffer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
IdeMediaStatus(
    IN BOOLEAN EnableMSN,
    IN PVOID HwDeviceExtension,
    IN ULONG Channel
    );

ULONG
AtapiParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    );



BOOLEAN
IssueIdentify(
    IN PVOID HwDeviceExtension,
    IN ULONG DeviceNumber,
    IN ULONG Channel,
    IN UCHAR Command
    )

/*++

Routine Description:

    Issue IDENTIFY command to a device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    DeviceNumber - Indicates which device.
    Command - Either the standard (EC) or the ATAPI packet (A1) IDENTIFY.

Return Value:

    TRUE if all goes well.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[Channel] ;
    PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[Channel];
    ULONG                waitCount = 20000;
    ULONG                i,j;
    UCHAR                statusByte;
    UCHAR                signatureLow,
                         signatureHigh;

    //
    // Select device 0 or 1.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                           (UCHAR)((DeviceNumber << 4) | 0xA0));

    //
    // Check that the status register makes sense.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    if (Command == IDE_COMMAND_IDENTIFY) {

        //
        // Mask status byte ERROR bits.
        //

        statusByte &= ~(IDE_STATUS_ERROR | IDE_STATUS_INDEX);

        DebugPrint((1,
                    "IssueIdentify: Checking for IDE. Status (%x)\n",
                    statusByte));

        //
        // Check if register value is reasonable.
        //

        if (statusByte != IDE_STATUS_IDLE) {

            //
            // Reset the controller.
            //

            AtapiSoftReset(baseIoAddress1,baseIoAddress2,DeviceNumber);

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                   (UCHAR)((DeviceNumber << 4) | 0xA0));

            WaitOnBusy(baseIoAddress2,statusByte);

            signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
            signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

            if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                //
                // Device is Atapi.
                //

                return FALSE;
            }

            DebugPrint((1,
                        "IssueIdentify: Resetting controller.\n"));

            ScsiPortWritePortUchar(&baseIoAddress2->AlternateStatus,IDE_DC_RESET_CONTROLLER );
            ScsiPortStallExecution(500 * 1000);
            ScsiPortWritePortUchar(&baseIoAddress2->AlternateStatus,IDE_DC_REENABLE_CONTROLLER);


            // We really should wait up to 31 seconds
            // The ATA spec. allows device 0 to come back from BUSY in 31 seconds!
            // (30 seconds for device 1)
            do {

                //
                // Wait for Busy to drop.
                //

                ScsiPortStallExecution(100);
                GetStatus(baseIoAddress2, statusByte);

            } while ((statusByte & IDE_STATUS_BUSY) && waitCount--);

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                   (UCHAR)((DeviceNumber << 4) | 0xA0));

            //
            // Another check for signature, to deal with one model Atapi that doesn't assert signature after
            // a soft reset.
            //

            signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
            signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

            if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                //
                // Device is Atapi.
                //

                return FALSE;
            }

            statusByte &= ~IDE_STATUS_INDEX;

            if (statusByte != IDE_STATUS_IDLE) {

                //
                // Give up on this.
                //

                return FALSE;
            }

        }

    } else {

        DebugPrint((1,
                    "IssueIdentify: Checking for ATAPI. Status (%x)\n",
                    statusByte));

    }

    //
    // Load CylinderHigh and CylinderLow with number bytes to transfer.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, (0x200 >> 8));
    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,  (0x200 & 0xFF));

    for (j = 0; j < 2; j++) {

        //
        // Send IDENTIFY command.
        //

        WaitOnBusy(baseIoAddress2,statusByte);

        ScsiPortWritePortUchar(&baseIoAddress1->Command, Command);

        //
        // Wait for DRQ.
        //

        for (i = 0; i < 4; i++) {

            WaitForDrq(baseIoAddress2, statusByte);

            if (statusByte & IDE_STATUS_DRQ) {

                //
                // Read status to acknowledge any interrupts generated.
                //

                GetBaseStatus(baseIoAddress1, statusByte);

                //
                // One last check for Atapi.
                //


                signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    //
                    // Device is Atapi.
                    //

                    return FALSE;
                }

                break;
            }

            if (Command == IDE_COMMAND_IDENTIFY) {

                //
                // Check the signature. If DRQ didn't come up it's likely Atapi.
                //

                signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    //
                    // Device is Atapi.
                    //

                    return FALSE;
                }
            }

            WaitOnBusy(baseIoAddress2,statusByte);
        }

        if (i == 4 && j == 0) {

            //
            // Device didn't respond correctly. It will be given one more chances.
            //

            DebugPrint((1,
                        "IssueIdentify: DRQ never asserted (%x). Error reg (%x)\n",
                        statusByte,
                         ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1)));

            AtapiSoftReset(baseIoAddress1,baseIoAddress2,DeviceNumber);

            GetStatus(baseIoAddress2,statusByte);

            DebugPrint((1,
                       "IssueIdentify: Status after soft reset (%x)\n",
                       statusByte));

        } else {

            break;

        }
    }

    //
    // Check for error on really stupid master devices that assert random
    // patterns of bits in the status register at the slave address.
    //

    if ((Command == IDE_COMMAND_IDENTIFY) && (statusByte & IDE_STATUS_ERROR)) {
        return FALSE;
    }

    DebugPrint((1,
               "IssueIdentify: Status before read words %x\n",
               statusByte));

    //
    // Suck out 256 words. After waiting for one model that asserts busy
    // after receiving the Packet Identify command.
    //

    WaitOnBusy(baseIoAddress2,statusByte);

    if (!(statusByte & IDE_STATUS_DRQ)) {
        return FALSE;
    }

    ReadBuffer(baseIoAddress1,
               (PUSHORT)&deviceExtension->FullIdentifyData,
               256);

    //
    // Check out a few capabilities / limitations of the device.
    //

    if (Command == IDE_COMMAND_IDENTIFY ||
        (deviceExtension->FullIdentifyData.GeneralConfiguration & 0x1F00) != 0x0500)
    {
        //
        // Determine this drive is removable
        //

        DebugPrint((1,
                    "IssueIdentify: Device is a ATA or ATAPI disk drive (type %x).\n",
                    (UCHAR)(deviceExtension->FullIdentifyData.GeneralConfiguration >> 8)));

        if (Command == IDE_COMMAND_IDENTIFY
            && deviceExtension->FullIdentifyData.GeneralConfiguration & 0x0080)
        {
            deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_REMOVABLE_DRIVE;

            DebugPrint((1,
                        "IssueIdentify: Marking ATA drive as removable. (%x)\n",
                        (UCHAR)(deviceExtension->FullIdentifyData.GeneralConfiguration & 0xff)));
        }
        /*
        else if (Command != IDE_COMMAND_IDENTIFY)
        {
            deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_REMOVABLE_DRIVE;

            DebugPrint((1,
                        "IssueIdentify: Marking ATAPI drive as removable. (%x)\n",
                        (UCHAR)(deviceExtension->FullIdentifyData.GeneralConfiguration & 0xff)));
        }
        */
    }

    if (deviceExtension->FullIdentifyData.MaximumBlockTransfer) {

        //
        // Determine max. block transfer for this device.
        //

        deviceExtension->MaximumBlockXfer[(Channel * 2) + DeviceNumber] =
            (UCHAR)(deviceExtension->FullIdentifyData.MaximumBlockTransfer & 0xFF);
    }

    ScsiPortMoveMemory(&deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber],&deviceExtension->FullIdentifyData,sizeof(IDENTIFY_DATA2));

    if (deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber].GeneralConfiguration & 0x20 &&
        Command != IDE_COMMAND_IDENTIFY) {

        //
        // This device interrupts with the assertion of DRQ after receiving
        // Atapi Packet Command
        //

        deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_INT_DRQ;

        DebugPrint((1,
                    "IssueIdentify: Device interrupts on assertion of DRQ.\n"));

    } else {

        DebugPrint((1,
                    "IssueIdentify: Device does not interrupt on assertion of DRQ.\n"));
    }

    if (((deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber].GeneralConfiguration & 0xF00) == 0x100) &&
        Command != IDE_COMMAND_IDENTIFY) {

        //
        // This is a tape.
        //

        deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_TAPE_DEVICE;

        DebugPrint((2,
                    "IssueIdentify: Device is a tape drive.\n"));

    } else {

        DebugPrint((2,
                    "IssueIdentify: Device is not a tape drive.\n"));
    }

    //
    // Work around for some IDE and one model Atapi that will present more than
    // 256 bytes for the Identify data.
    //

    WaitOnBusy(baseIoAddress2,statusByte);

    for (i = 0; i < 0x10000; i++) {

        GetStatus(baseIoAddress2,statusByte);

        if (statusByte & IDE_STATUS_DRQ) {

            //
            // Suck out any remaining bytes and throw away.
            //

            ScsiPortReadPortUshort(&baseIoAddress1->Data);

        } else {

            break;

        }
    }

    DebugPrint((1,
               "IssueIdentify: Status after read words (%x)\n",
               statusByte));

    return TRUE;

} // end IssueIdentify()


BOOLEAN
AtapiResetController(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    )

/*++

Routine Description:

    Reset IDE controller and/or Atapi device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Nothing.


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG                numberChannels  = deviceExtension->NumberChannels;
    PIDE_REGISTERS_1 baseIoAddress1;
    PIDE_REGISTERS_2 baseIoAddress2;
    BOOLEAN result = FALSE;
    ULONG i,j;
    UCHAR statusByte;

    DebugPrint((2,"AtapiResetController: Reset IDE\n"));

    //
    // Check and see if we are processing an internal srb
    //
    if (deviceExtension->OriginalSrb) {
        deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
        deviceExtension->OriginalSrb = NULL;
    }

    //
    // Check if request is in progress.
    //

    if (deviceExtension->CurrentSrb) {

        //
        // Complete outstanding request with SRB_STATUS_BUS_RESET.
        //

        ScsiPortCompleteRequest(deviceExtension,
                                deviceExtension->CurrentSrb->PathId,
                                deviceExtension->CurrentSrb->TargetId,
                                deviceExtension->CurrentSrb->Lun,
                                (ULONG)SRB_STATUS_BUS_RESET);

        //
        // Clear request tracking fields.
        //

        deviceExtension->CurrentSrb = NULL;
        deviceExtension->WordsLeft = 0;
        deviceExtension->DataBuffer = NULL;

        //
        // Indicate ready for next request.
        //

        ScsiPortNotification(NextRequest,
                             deviceExtension,
                             NULL);
    }

    // suppress the interrupt unitl AtapiStartIo()
    if (deviceExtension->IrqSharing)
        ScsiPortWritePortUchar(&deviceExtension->BaseIoAddress1[0]->DmaReg, 0x20);

    //
    // Clear expecting interrupt flag.
    //

    deviceExtension->ExpectingInterrupt = FALSE;
    deviceExtension->RDP = FALSE;

    for (j = 0; j < numberChannels; j++) {

        baseIoAddress1 = deviceExtension->BaseIoAddress1[j];
        baseIoAddress2 = deviceExtension->BaseIoAddress2[j];

        //
        // Do special processing for ATAPI and IDE disk devices.
        //

        for (i = 0; i < 2; i++) {

            //
            // Check if device present.
            //

            if (deviceExtension->DeviceFlags[i + (j * 2)] & DFLAGS_DEVICE_PRESENT) {

                //
                // Check for ATAPI disk.
                //

                if (deviceExtension->DeviceFlags[i + (j * 2)] & DFLAGS_ATAPI_DEVICE) {

                    //
                    // Issue soft reset and issue identify.
                    //

                    GetStatus(baseIoAddress2,statusByte);
                    DebugPrint((1,
                                "AtapiResetController: Status before Atapi reset (%x).\n",
                                statusByte));

                    AtapiSoftReset(baseIoAddress1,baseIoAddress2,i);

                    GetStatus(baseIoAddress2,statusByte);

                    if (statusByte == 0x0) {

                        IssueIdentify(HwDeviceExtension,
                                      i,
                                      j,
                                      IDE_COMMAND_ATAPI_IDENTIFY);
                    } else {

                        DebugPrint((1,
                                   "AtapiResetController: Status after soft reset %x\n",
                                   statusByte));
                    }

                } else {

                    //
                    // Write IDE reset controller bits.
                    //

                    IdeHardReset(baseIoAddress2,result);

                    if (!result) {
                        return FALSE;
                    }
                }
            }
        }
    }

    //
    // Call the HwInitialize routine to setup multi-block.
    //

    AtapiHwInitialize(HwDeviceExtension);

    return TRUE;

} // end AtapiResetController()



ULONG
MapError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine maps ATAPI and IDE errors to specific SRB statuses.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG i;
    UCHAR errorByte;
    UCHAR srbStatus;
    UCHAR scsiStatus;

    //
    // Read the error register.
    //

    errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
    DebugPrint((1,
               "MapError: Error register is %x\n",
               errorByte));

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

        switch (errorByte >> 4) {
        case SCSI_SENSE_NO_SENSE:

            DebugPrint((1,
                       "ATAPI: No sense information\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_RECOVERED_ERROR:

            DebugPrint((1,
                       "ATAPI: Recovered error\n"));

            // fix MATSUSHITA SR-8175 bug
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_NOT_READY:

            DebugPrint((1,
                       "ATAPI: Device not ready\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_MEDIUM_ERROR:

            DebugPrint((1,
                       "ATAPI: Media error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_HARDWARE_ERROR:

            DebugPrint((1,
                       "ATAPI: Hardware error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:

            DebugPrint((1,
                       "ATAPI: Illegal request\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_UNIT_ATTENTION:

            DebugPrint((1,
                       "ATAPI: Unit attention\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_DATA_PROTECT:

            DebugPrint((1,
                       "ATAPI: Data protect\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_BLANK_CHECK:

            DebugPrint((1,
                       "ATAPI: Blank check\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_ABORTED_COMMAND:
            DebugPrint((1,
                        "Atapi: Command Aborted\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        default:

            DebugPrint((1,
                       "ATAPI: Invalid sense information\n"));
            scsiStatus = 0;
            srbStatus = SRB_STATUS_ERROR;
            break;
        }

    } else {

        scsiStatus = 0;

        //
        // Save errorByte,to be used by SCSIOP_REQUEST_SENSE.
        //

        deviceExtension->ReturningMediaStatus = errorByte;

        if (errorByte & IDE_ERROR_MEDIA_CHANGE_REQ) {
            DebugPrint((1,
                       "IDE: Media change\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

        } else if (errorByte & IDE_ERROR_COMMAND_ABORTED) {
            DebugPrint((1,
                       "IDE: Command abort\n"));
            srbStatus = SRB_STATUS_ABORTED;
            scsiStatus = SCSISTAT_CHECK_CONDITION;

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_ABORTED_COMMAND;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

            deviceExtension->ErrorCount++;

        } else if (errorByte & IDE_ERROR_END_OF_MEDIA) {

            DebugPrint((1,
                       "IDE: End of media\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)){
                deviceExtension->ErrorCount++;
            }

        } else if (errorByte & IDE_ERROR_ILLEGAL_LENGTH) {

            DebugPrint((1,
                       "IDE: Illegal length\n"));
            srbStatus = SRB_STATUS_INVALID_REQUEST;

        } else if (errorByte & IDE_ERROR_BAD_BLOCK) {

            DebugPrint((1,
                       "IDE: Bad block\n"));
            srbStatus = SRB_STATUS_ERROR;
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_ID_NOT_FOUND) {

            DebugPrint((1,
                       "IDE: Id not found\n"));
            srbStatus = SRB_STATUS_ERROR;
            scsiStatus = SCSISTAT_CHECK_CONDITION;

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

            deviceExtension->ErrorCount++;

        } else if (errorByte & IDE_ERROR_MEDIA_CHANGE) {

            DebugPrint((1,
                       "IDE: Media change\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
                senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_DATA_ERROR) {

            DebugPrint((1,
                   "IDE: Data error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)){
                deviceExtension->ErrorCount++;
            }

            //
            // Build sense buffer
            //

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }
        }

        if (deviceExtension->ErrorCount >= MAX_ERRORS) {
            deviceExtension->MaximumBlockXfer[Srb->TargetId] = 0;

            DebugPrint((1,
                        "MapError: Disabling Multi-sector\n"));

            //
            // Log the error.
            //

            ScsiPortLogError( HwDeviceExtension,
                              Srb,
                              Srb->PathId,
                              Srb->TargetId,
                              Srb->Lun,
                              SP_BAD_FW_WARNING,
                              4);
            //
            // Reprogram to not use Multi-sector.
            //

            for (i = 0; i < 4; i++) {
                UCHAR statusByte;

                if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT &&
                     !(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                    // disable the interrupt
                    if (deviceExtension->IrqSharing)
                        ScsiPortWritePortUchar(&baseIoAddress1->DmaReg, 0x20);

                    //
                    // Select the device.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                           (UCHAR)(((i & 0x1) << 4) | 0xA0));

                    //
                    // Setup sector count to reflect the # of blocks.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                                           0);

                    //
                    // Issue the command.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress1->Command,
                                           IDE_COMMAND_SET_MULTIPLE);

                    //
                    // Wait for busy to drop.
                    //

                    WaitOnBaseBusy(baseIoAddress1,statusByte);

                    // enable the interrupt
                    if (deviceExtension->IrqSharing)
                        ScsiPortWritePortUchar(&baseIoAddress1->DmaReg, 0x00);

                    //
                    // Check for errors. Reset the value to 0 (disable MultiBlock) if the
                    // command was aborted.
                    //

                    if (statusByte & IDE_STATUS_ERROR) {

                        //
                        // Read the error register.
                        //

                        errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);

                        DebugPrint((1,
                                    "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
                                    statusByte,
                                    errorByte));
                        //
                        // Adjust the devExt. value, if necessary.
                        //

                        deviceExtension->MaximumBlockXfer[i] = 0;

                    }
                }
            }
        }
    }


    //
    // Set SCSI status to indicate a check condition.
    //

    Srb->ScsiStatus = scsiStatus;

    return srbStatus;

} // end MapError()


BOOLEAN
AtapiHwInitialize(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress;
    ULONG i;
    UCHAR statusByte, errorByte;


    for (i = 0; i < 4; i++) {
        if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT) {

            if (!(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                //
                // Enable media status notification
                //

                baseIoAddress = deviceExtension->BaseIoAddress1[i >> 1];

                // ATA drive, assume no media status
                IdeMediaStatus(FALSE,HwDeviceExtension,i);

                //
                // If supported, setup Multi-block transfers.
                //
                if (deviceExtension->MaximumBlockXfer[i]) {

                    //
                    // Select the device.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress->DriveSelect,
                                           (UCHAR)(((i & 0x1) << 4) | 0xA0));

                    //
                    // Setup sector count to reflect the # of blocks.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress->BlockCount,
                                           deviceExtension->MaximumBlockXfer[i]);

                    //
                    // Issue the command.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress->Command,
                                           IDE_COMMAND_SET_MULTIPLE);

                    //
                    // Wait for busy to drop.
                    //

                    WaitOnBaseBusy(baseIoAddress,statusByte);

                    //
                    // Check for errors. Reset the value to 0 (disable MultiBlock) if the
                    // command was aborted.
                    //

                    if (statusByte & IDE_STATUS_ERROR) {

                        //
                        // Read the error register.
                        //

                        errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress + 1);

                        DebugPrint((1,
                                    "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
                                    statusByte,
                                    errorByte));
                        //
                        // Adjust the devExt. value, if necessary.
                        //

                        deviceExtension->MaximumBlockXfer[i] = 0;

                    } else {
                        DebugPrint((1,
                                    "AtapiHwInitialize: Using Multiblock on Device %d. Blocks / int - %d\n",
                                    i,
                                    deviceExtension->MaximumBlockXfer[i]));
                    }
                }
            } else if (!(deviceExtension->DeviceFlags[i] & DFLAGS_CHANGER_INITED)){

                ULONG j;
                BOOLEAN isSanyo = FALSE;
                UCHAR vendorId[26];

                //
                // Attempt to identify any special-case devices - psuedo-atapi changers, atapi changers, etc.
                //

                for (j = 0; j < 13; j += 2) {

                    //
                    // Build a buffer based on the identify data.
                    //

                    vendorId[j] = ((PUCHAR)deviceExtension->IdentifyData[i].ModelNumber)[j + 1];
                    vendorId[j+1] = ((PUCHAR)deviceExtension->IdentifyData[i].ModelNumber)[j];
                }

                if (!AtapiStringCmp (vendorId, "CD-ROM  CDR", 11)) {

                    //
                    // Inquiry string for older model had a '-', newer is '_'
                    //

                    if (vendorId[12] == 'C') {

                        //
                        // Torisan changer. Set the bit. This will be used in several places
                        // acting like 1) a multi-lun device and 2) building the 'special' TUR's.
                        //

                        deviceExtension->DeviceFlags[i] |= (DFLAGS_CHANGER_INITED | DFLAGS_SANYO_ATAPI_CHANGER);
                        deviceExtension->DiscsPresent[i] = 3;
                        isSanyo = TRUE;
                    }
                }
            }

            //
            // We need to get our device ready for action before
            // returning from this function
            //
            // According to the atapi spec 2.5 or 2.6, an atapi device
            // clears its status BSY bit when it is ready for atapi commands.
            // However, some devices (Panasonic SQ-TC500N) are still
            // not ready even when the status BSY is clear.  They don't react
            // to atapi commands.
            //
            // Since there is really no other indication that tells us
            // the drive is really ready for action.  We are going to check BSY
            // is clear and then just wait for an arbitrary amount of time!
            //
            if (deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE) {
                PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[i >> 1];
                PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[i >> 1];
                ULONG waitCount;

                // have to get out of the loop sometime!
                // 10000 * 100us = 1000,000us = 1000ms = 1s
                waitCount = 10000;
                GetStatus(baseIoAddress2, statusByte);
                while ((statusByte & IDE_STATUS_BUSY) && waitCount) {
                    //
                    // Wait for Busy to drop.
                    //
                    ScsiPortStallExecution(100);
                    GetStatus(baseIoAddress2, statusByte);
                    waitCount--;
                }

                // 5000 * 100us = 500,000us = 500ms = 0.5s
                waitCount = 5000;
                do {
                    ScsiPortStallExecution(100);
                } while (waitCount--);
            }
        }
    }

    return TRUE;

} // end AtapiHwInitialize()


VOID
AtapiHwInitializeChanger (
    IN PVOID HwDeviceExtension,
    IN ULONG TargetId,
    IN PMECHANICAL_STATUS_INFORMATION_HEADER MechanismStatus)
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;

    if (MechanismStatus) {
        deviceExtension->DiscsPresent[TargetId] = MechanismStatus->NumberAvailableSlots;
        if (deviceExtension->DiscsPresent[TargetId] > 1) {
            deviceExtension->DeviceFlags[TargetId] |= DFLAGS_ATAPI_CHANGER;
        }
    }
    return;
}



BOOLEAN
FindDevices(
    IN PVOID HwDeviceExtension,
    IN BOOLEAN AtapiOnly,
    IN ULONG   Channel
    )

/*++

Routine Description:

    This routine is called from AtapiFindController to identify
    devices attached to an IDE controller.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    AtapiOnly - Indicates that routine should return TRUE only if
        an ATAPI device is attached to the controller.

Return Value:

    TRUE - True if devices found.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[Channel];
    PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[Channel];
    BOOLEAN              deviceResponded = FALSE,
                         skipSetParameters = FALSE;
    ULONG                waitCount = 10000;
    ULONG                deviceNumber;
    ULONG                i;
    UCHAR                signatureLow,
                         signatureHigh;
    UCHAR                statusByte;
    UCHAR                NumDrive = 0; // default

    //
    // Clear expecting interrupt flag and current SRB field.
    //

    deviceExtension->ExpectingInterrupt = FALSE;
    deviceExtension->CurrentSrb = NULL;

    //
    // Search for devices.
    //

    for (deviceNumber = 0; deviceNumber < 2; deviceNumber++) {

        //
        // Select the device.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR)((deviceNumber << 4) | 0xA0));

        //
        // Check here for some SCSI adapters that incorporate IDE emulation.
        //

        GetStatus(baseIoAddress2, statusByte);
        if (statusByte == 0xFF) {
            continue;
        }

        // wait device become ready (not busy)

        DebugPrint((1,
                    "FindDevices: Status %x first read on device %d\n",
                    statusByte, deviceNumber));

        if ((deviceNumber == 0) && (statusByte == 0x80)) {

            WaitOnBusy(baseIoAddress2,statusByte);
        }

#if 1   // not neccessary to do soft reset before read signature
        AtapiSoftReset(baseIoAddress1,baseIoAddress2,deviceNumber);
        WaitOnBusy(baseIoAddress2,statusByte);
#endif

        signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
        signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

        DebugPrint((1,
                    "FindDevices: Signature read on device %d is %x, %x\n",
                    deviceNumber,
                    signatureLow,
                    signatureHigh));

        // check slave drive signature in beginning
        if ((deviceNumber == 0) && (NumDrive == 0)) {

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect, 0xB0);

            GetStatus(baseIoAddress2, statusByte);

            if (statusByte != 0xFF) {

#ifdef  DBG
             // _asm int 3;
#endif
                if (ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow) == 0x14 &&
                    ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh) == 0xEB) {

                    DebugPrint((1,
                                "FindDevices: Signature read from slave is 0x14EB\n"));

                    NumDrive = 2;
                }
            }

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect, 0xA0);
        }

        if (signatureLow == 0x14 && signatureHigh == 0xEB) {

            //
            // ATAPI signature found.
            // Issue the ATAPI identify command if this
            // is not for the crash dump utility.
            //

atapiIssueId:

            if (!deviceExtension->DriverMustPoll) {

                //
                // Issue ATAPI packet identify command.
                //

                if (IssueIdentify(HwDeviceExtension,
                                  deviceNumber,
                                  Channel,
                                  IDE_COMMAND_ATAPI_IDENTIFY)) {

                    //
                    // Indicate ATAPI device.
                    //

                    DebugPrint((1,
                               "FindDevices: Device %x is ATAPI\n",
                               deviceNumber));

                    deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] |= DFLAGS_ATAPI_DEVICE;
                    deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] |= DFLAGS_DEVICE_PRESENT;

                    deviceResponded = TRUE;

                    GetStatus(baseIoAddress2, statusByte);
                    if (statusByte & IDE_STATUS_ERROR) {
                        AtapiSoftReset(baseIoAddress1, baseIoAddress2, deviceNumber);
                    }


                } else {

                    //
                    // Indicate no working device.
                    //

                    DebugPrint((1,
                               "FindDevices: Device %x not responding\n",
                               deviceNumber));

                    deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] &= ~DFLAGS_DEVICE_PRESENT;
                }

            }

        } else if ((deviceNumber == 0) || (NumDrive == 2)) {

            // if master drive signature is not ATAPI, issue IDE identify first,
            //    if not IDE, reset then it, then check signature again
            // if make sure there is a slave drive (NumDrive = 2),
            //    reset it, then check signature again

            //
            // Issue IDE Identify. If an Atapi device is actually present, the signature
            // will be asserted, and the drive will be recognized as such.
            //

            if ((deviceNumber == 0) // only master drive can be IDE

                && IssueIdentify(HwDeviceExtension,
                                 deviceNumber,
                                 Channel,
                                 IDE_COMMAND_IDENTIFY)) {

                //
                // IDE drive found.
                //

                DebugPrint((1,
                           "FindDevices: Device %x is IDE\n",
                           deviceNumber));

                deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] |= DFLAGS_DEVICE_PRESENT;

                if (!AtapiOnly) {
                    deviceResponded = TRUE;
                }

                //
                // Indicate IDE - not ATAPI device.
                //

                deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] &= ~DFLAGS_ATAPI_DEVICE;

            } else {

                //
                // Look to see if an Atapi device is present.
                //

                AtapiSoftReset(baseIoAddress1,baseIoAddress2,deviceNumber);

                WaitOnBusy(baseIoAddress2,statusByte);

                signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    DebugPrint((1,
                                "FindDevices: Signature read 0x14EB after soft reset.\n"));

                    goto atapiIssueId;
                }
            }
        }

        if (NumDrive == 1)
            break;
    }

    for (i = 0; i < 2; i++) {
        if ((deviceExtension->DeviceFlags[i + (Channel * 2)] & DFLAGS_DEVICE_PRESENT) &&
            (!(deviceExtension->DeviceFlags[i + (Channel * 2)] & DFLAGS_ATAPI_DEVICE)) && deviceResponded) {

            if (deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] & DFLAGS_REMOVABLE_DRIVE) {

                //
                // Pick up ALL IDE removable drives that conform to Yosemite V0.2...
                //

                AtapiOnly = FALSE;
            }


            //
            // Indicate that a device was found.
            //

            if (!AtapiOnly) {
                deviceResponded = TRUE;
            }
        }
    }

    //
    // Make sure master device is selected on exit.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect, 0xA0);

    //
    // Reset the controller. This is a feeble attempt to leave the ESDI
    // controllers in a state that ATDISK driver will recognize them.
    // The problem in ATDISK has to do with timings as it is not reproducible
    // in debug. The reset should restore the controller to its poweron state
    // and give the system enough time to settle.
    //

    if (!deviceResponded) {

        ScsiPortWritePortUchar(&baseIoAddress2->AlternateStatus,IDE_DC_RESET_CONTROLLER );
        ScsiPortStallExecution(50 * 1000);
        ScsiPortWritePortUchar(&baseIoAddress2->AlternateStatus,IDE_DC_REENABLE_CONTROLLER);
    }

    return deviceResponded;

} // end FindDevices()



ULONG
AtapiFindController(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
/*++

Routine Description:

    This function is called by the OS-specific port driver after
    the necessary storage has been allocated, to gather information
    about the adapter's configuration.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Context - Address of adapter count
    ArgumentString - Used to determine whether driver is client of ntldr or crash dump utility.
    ConfigInfo - Configuration information structure describing HBA
    Again - Indicates search for adapters to continue

Return Value:

    ULONG

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PUCHAR               ioSpace, ioSpace2;
    ULONG                i,j;
    ULONG                irq;
    ULONG                portBase;
    ULONG                retryCount;
    UCHAR                statusByte;
    BOOLEAN              pwr_feature;

    if (!deviceExtension) {
        return SP_RETURN_ERROR;
    }

    *Again = FALSE;

    //
    // Check to see if this is a special configuration environment.
    //

    portBase = ScsiPortConvertPhysicalAddressToUlong((*ConfigInfo->AccessRanges)[0].RangeStart);

    if (!portBase) {
        return(SP_RETURN_NOT_FOUND);
    }

    //
    // Get the system physical address for this IO range.
    //

    ioSpace =  ScsiPortGetDeviceBase(HwDeviceExtension,
                                     ConfigInfo->AdapterInterfaceType,
                                     ConfigInfo->SystemIoBusNumber,
                                     (*ConfigInfo->AccessRanges)[0].RangeStart,
                                     ((*ConfigInfo->AccessRanges)[0].RangeLength <= 8 ? 8 : 16),
                                     (BOOLEAN) !((*ConfigInfo->AccessRanges)[0].RangeInMemory));

    //
    // Check if ioSpace accessible.
    //

    if (!ioSpace) {
        return(SP_RETURN_NOT_FOUND);
    }

    // set power feature if CHARGE parameter is set to 1

    pwr_feature = FALSE;

    if (ArgumentString != NULL) {

        pwr_feature = (AtapiParseArgumentString(ArgumentString, "charge") == 1);
    }

    if (pwr_feature) {

        for (i=0; i<50000; i++) {

            if ((ScsiPortReadPortUchar(&((PIDE_REGISTERS_1)ioSpace)->DmaReg) & 0x08)) {

                break;

            } else {

                ScsiPortStallExecution(1000);
            }
        }
        ScsiPortStallExecution(3000*1000);

        DebugPrint((1, "Container charged completed.\n"));

#ifdef  DBG
     // _asm int 3;
#endif
    }

    retryCount = 4;

    for (i = 0; i < 4; i++) {

        //
        // Zero device fields to ensure that if earlier devices were found,
        // but not claimed, the fields are cleared.
        //

        deviceExtension->DeviceFlags[i] &= ~(DFLAGS_ATAPI_DEVICE | DFLAGS_DEVICE_PRESENT | DFLAGS_TAPE_DEVICE);
    }

//retryIdentifier:

    //
    // Select master.
    //

    ScsiPortWritePortUchar(&((PIDE_REGISTERS_1)ioSpace)->DriveSelect, 0xA0);

    //
    // Check if card at this address.
    //

    ScsiPortWritePortUchar(&((PIDE_REGISTERS_1)ioSpace)->BlockCount, 0xAA);

    //
    // Check if indentifier can be read back.
    //

    if ((statusByte = ScsiPortReadPortUchar(&((PIDE_REGISTERS_1)ioSpace)->BlockCount)) != 0xAA) {

        DebugPrint((1,
                    "AtapiFindController: Identifier read back from Master (%x)\n",
                    statusByte));

        // if master drive not detected, check slave
        // ATA drive may report statusByte 0x80 when spin up

        if (statusByte != 0x01 && statusByte != 0x80) {

            //
            // Select slave.
            //

            ScsiPortWritePortUchar(&((PIDE_REGISTERS_1)ioSpace)->DriveSelect, 0xB0);

            //
            // See if slave is present.
            //

            ScsiPortWritePortUchar(&((PIDE_REGISTERS_1)ioSpace)->BlockCount, 0xAA);

            if ((statusByte = ScsiPortReadPortUchar(&((PIDE_REGISTERS_1)ioSpace)->BlockCount)) != 0xAA) {

                DebugPrint((1,
                            "AtapiFindController: Identifier read back from Slave (%x)\n",
                            statusByte));

                // if slave drive not detected, abort

                if (statusByte != 0x01 && statusByte != 0x80) {

                    //
                    //
                    // No controller at this base address.
                    //

                    ScsiPortFreeDeviceBase(HwDeviceExtension,
                                           ioSpace);

                    return(SP_RETURN_NOT_FOUND);
                }
            }
        }
    }

    //
    // Enable DWordIO by default.  Then check for an PIO parameter.
    // if PIO set to 16, disable DWordIO
    //

    deviceExtension->DWordIO = TRUE;

    if (ArgumentString != NULL) {

        ULONG pio = AtapiParseArgumentString(ArgumentString, "pio");

        if (pio == 16) {

            deviceExtension->DWordIO = FALSE;
        }
    }

    //
    // Record base IO address.
    //

    deviceExtension->BaseIoAddress1[0] = (PIDE_REGISTERS_1)(ioSpace);

    //
    // Get the system physical address for the second IO range.
    //

    // if not power feature and not 32-bit PIO, then check if standard IDE

    if (!pwr_feature && !deviceExtension->DWordIO &&
        ((*ConfigInfo->AccessRanges)[0].RangeLength <= 8)) {

        // stardard IDE has two I/O port ranges

        ioSpace2 = ScsiPortGetDeviceBase(HwDeviceExtension,
                                         ConfigInfo->AdapterInterfaceType,
                                         ConfigInfo->SystemIoBusNumber,
                                         ScsiPortConvertUlongToPhysicalAddress(portBase + 0x206),
                                         1,
                                         TRUE);

        if (!ioSpace2) {

            ScsiPortFreeDeviceBase(HwDeviceExtension,
                                   ioSpace);

            return(SP_RETURN_NOT_FOUND);
        }

        deviceExtension->BaseIoAddress2[0] = (PIDE_REGISTERS_2)(ioSpace2);

        (*ConfigInfo->AccessRanges)[0].RangeLength = 8;
        (*ConfigInfo->AccessRanges)[1].RangeLength = 2;

        // standard IDE dose not support irq sharing
        deviceExtension->IrqSharing = FALSE;

    } else {

        (*ConfigInfo->AccessRanges)[0].RangeLength = 16;

        deviceExtension->BaseIoAddress2[0] = (PIDE_REGISTERS_2)((PUCHAR)ioSpace + 0x00e);

        deviceExtension->IrqSharing = TRUE; // support irq sharing
    }

    deviceExtension->NumberChannels = 1;

    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->MaximumNumberOfTargets = 2;

    //
    // Indicate maximum transfer length is 64k.
    //

    ConfigInfo->MaximumTransferLength = 0x10000;

    DebugPrint((1,
               "AtapiFindController: Found IDE at %x\n",
               deviceExtension->BaseIoAddress1[0]));


    deviceExtension->DriverMustPoll = FALSE;

    //
    // Save the Interrupe Mode for later use
    //
    deviceExtension->InterruptMode = ConfigInfo->InterruptMode;

    // suppress the interrupt unitl AtapiStartIo()
    if (deviceExtension->IrqSharing)
        ScsiPortWritePortUchar(&deviceExtension->BaseIoAddress1[0]->DmaReg, 0x20);

    //
    // Search for devices on this controller.
    //

    if (FindDevices(HwDeviceExtension,
                    FALSE,
                    0)) {

        // if standard secondary IDE, claim it

        if (portBase == 0x170) {
            ConfigInfo->AtdiskSecondaryClaimed = TRUE;
            deviceExtension->PrimaryAddress = FALSE;
        }

        return(SP_RETURN_FOUND);
    }

    return(SP_RETURN_NOT_FOUND);

} // end AtapiFindController()





ULONG
Atapi2Scsi(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN char *DataBuffer,
    IN ULONG ByteCount
    )
{
    ULONG bytesAdjust = 0;
    if (Srb->Cdb[0] == ATAPI_MODE_SENSE) {

        PMODE_PARAMETER_HEADER_10 header_10 = (PMODE_PARAMETER_HEADER_10)DataBuffer;
        PMODE_PARAMETER_HEADER header = (PMODE_PARAMETER_HEADER)DataBuffer;

        header->ModeDataLength = header_10->ModeDataLengthLsb;
        header->MediumType = header_10->MediumType;

        //
        // ATAPI Mode Parameter Header doesn't have these fields.
        //

        header->DeviceSpecificParameter = header_10->Reserved[0];
        header->BlockDescriptorLength = header_10->Reserved[1];

        ByteCount -= sizeof(MODE_PARAMETER_HEADER_10);
        if (ByteCount > 0)
            ScsiPortMoveMemory(DataBuffer+sizeof(MODE_PARAMETER_HEADER),
                               DataBuffer+sizeof(MODE_PARAMETER_HEADER_10),
                               ByteCount);

        //
        // Change ATAPI_MODE_SENSE opcode back to SCSIOP_MODE_SENSE
        // so that we don't convert again.
        //

        Srb->Cdb[0] = SCSIOP_MODE_SENSE;

        bytesAdjust = sizeof(MODE_PARAMETER_HEADER_10) -
                      sizeof(MODE_PARAMETER_HEADER);


    }

    //
    // Convert to words.
    //

    return bytesAdjust >> 1;
}


VOID
AtapiCallBack(
    IN PVOID HwDeviceExtension
    )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK  srb = deviceExtension->CurrentSrb;
    PATAPI_REGISTERS_2   baseIoAddress2;
    UCHAR statusByte;

    //
    // If the last command was DSC restrictive, see if it's set. If so, the device is
    // ready for a new request. Otherwise, reset the timer and come back to here later.
    //

    if (srb && (!(deviceExtension->ExpectingInterrupt))) {
#if DBG
        if (!IS_RDP((srb->Cdb[0]))) {
            DebugPrint((1,
                        "AtapiCallBack: Invalid CDB marked as RDP - %x\n",
                        srb->Cdb[0]));
        }
#endif

        baseIoAddress2 = (PATAPI_REGISTERS_2)deviceExtension->BaseIoAddress2[srb->TargetId >> 1];
        if (deviceExtension->RDP) {
            GetStatus(baseIoAddress2, statusByte);
            if (statusByte & IDE_STATUS_DSC) {

                ScsiPortNotification(RequestComplete,
                                     deviceExtension,
                                     srb);

                //
                // Clear current SRB.
                //

                deviceExtension->CurrentSrb = NULL;
                deviceExtension->RDP = FALSE;

                //
                // Ask for next request.
                //

                ScsiPortNotification(NextRequest,
                                     deviceExtension,
                                     NULL);


                return;

            } else {

                DebugPrint((3,
                            "AtapiCallBack: Requesting another timer for Op %x\n",
                            deviceExtension->CurrentSrb->Cdb[0]));

                ScsiPortNotification(RequestTimerCall,
                                     HwDeviceExtension,
                                     AtapiCallBack,
                                     1000);
                return;
            }
        }
    }

    DebugPrint((2,
                "AtapiCallBack: Calling ISR directly due to BUSY\n"));
    AtapiInterrupt(HwDeviceExtension);
}


BOOLEAN
AtapiInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This is the interrupt service routine for ATAPI IDE miniport driver.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE if expecting an interrupt.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb              = deviceExtension->CurrentSrb;
    PATAPI_REGISTERS_1 baseIoAddress1;
    PATAPI_REGISTERS_2 baseIoAddress2;
    ULONG wordCount = 0, wordsThisInterrupt = 256;
    ULONG status;
    ULONG i;
    UCHAR statusByte,interruptReason;
    BOOLEAN commandComplete = FALSE;
    BOOLEAN atapiDev = FALSE;

    // check if interrupt is ours
    if (deviceExtension->IrqSharing) {

        if (!(ScsiPortReadPortUchar(&deviceExtension->BaseIoAddress1[0]->DmaReg) & 0x20)) {

            DebugPrint((2,
                        "AtapiInterrupt: Unexpected interrupt (irq sharing).\n"));

            return FALSE;
        }
    }

    if (srb) {
        baseIoAddress1 =    (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[srb->TargetId >> 1];
        baseIoAddress2 =    (PATAPI_REGISTERS_2)deviceExtension->BaseIoAddress2[srb->TargetId >> 1];
    } else {
        DebugPrint((2,
                    "AtapiInterrupt: CurrentSrb is NULL\n"));
        //
        // We can only support one ATAPI IDE master on Carolina, so find
        // the base address that is non NULL and clear its interrupt before
        // returning.
        //

#ifdef _PPC_

        if ((PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[0] != NULL) {
           baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[0];
        } else {
           baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[1];
        }

        GetBaseStatus(baseIoAddress1, statusByte);
#else

        if (deviceExtension->InterruptMode == LevelSensitive) {
            if (deviceExtension->BaseIoAddress1[0] != NULL) {
               baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[0];
               GetBaseStatus(baseIoAddress1, statusByte);
            }
            if (deviceExtension->BaseIoAddress1[1] != NULL) {
               baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[1];
               GetBaseStatus(baseIoAddress1, statusByte);
            }
        }
#endif
        return FALSE;
    }

    if (!(deviceExtension->ExpectingInterrupt)) {

        DebugPrint((3,
                    "AtapiInterrupt: Unexpected interrupt.\n"));
        return FALSE;
    }

    //
    // Clear interrupt by reading status.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    DebugPrint((3,
                "AtapiInterrupt: Entered with status (%x)\n",
                statusByte));


    if (statusByte & IDE_STATUS_BUSY) {
        if (deviceExtension->DriverMustPoll) {

            //
            // Crashdump is polling and we got caught with busy asserted.
            // Just go away, and we will be polled again shortly.
            //

            DebugPrint((3,
                        "AtapiInterrupt: Hit BUSY while polling during crashdump.\n"));

            return TRUE;
        }

        //
        // Ensure BUSY is non-asserted.
        //

        for (i = 0; i < 10; i++) {

            GetBaseStatus(baseIoAddress1, statusByte);
            if (!(statusByte & IDE_STATUS_BUSY)) {
                break;
            }
            ScsiPortStallExecution(5000);
        }

        if (i == 10) {

            DebugPrint((2,
                        "AtapiInterrupt: BUSY on entry. Status %x, Base IO %x\n",
                        statusByte,
                        baseIoAddress1));

            ScsiPortNotification(RequestTimerCall,
                                 HwDeviceExtension,
                                 AtapiCallBack,
                                 500);
            return TRUE;
        }
    }


    //
    // Check for error conditions.
    //

    if (statusByte & IDE_STATUS_ERROR) {

        if (srb->Cdb[0] != SCSIOP_REQUEST_SENSE) {

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }
    }

    //
    // check reason for this interrupt.
    //

    if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

        interruptReason = (ScsiPortReadPortUchar(&baseIoAddress1->InterruptReason) & 0x3);
        atapiDev = TRUE;
        wordsThisInterrupt = 256;

    } else {

        if (statusByte & IDE_STATUS_DRQ) {

            if (deviceExtension->MaximumBlockXfer[srb->TargetId]) {
                wordsThisInterrupt = 256 * deviceExtension->MaximumBlockXfer[srb->TargetId];

            }

            if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

                interruptReason =  0x2;

            } else if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {
                interruptReason = 0x0;

            } else {
                status = SRB_STATUS_ERROR;
                goto CompleteRequest;
            }

        } else if (statusByte & IDE_STATUS_BUSY) {

            return FALSE;

        } else {

            if (deviceExtension->WordsLeft) {

                ULONG k;

                //
                // Funky behaviour seen with PCI IDE (not all, just one).
                // The ISR hits with DRQ low, but comes up later.
                //

                for (k = 0; k < 5000; k++) {
                    GetStatus(baseIoAddress2,statusByte);
                    if (!(statusByte & IDE_STATUS_DRQ)) {
                        ScsiPortStallExecution(100);
                    } else {
                        break;
                    }
                }

                if (k == 5000) {

                    //
                    // reset the controller.
                    //

                    DebugPrint((1,
                                "AtapiInterrupt: Resetting due to DRQ not up. Status %x, Base IO %x\n",
                                statusByte,
                                baseIoAddress1));

                    AtapiResetController(HwDeviceExtension,srb->PathId);
                    return TRUE;
                } else {

                    interruptReason = (srb->SrbFlags & SRB_FLAGS_DATA_IN) ? 0x2 : 0x0;
                }

            } else {

                //
                // Command complete - verify, write, or the SMART enable/disable.
                //
                // Also get_media_status

                interruptReason = 0x3;
            }
        }
    }

    if (interruptReason == 0x1 && (statusByte & IDE_STATUS_DRQ)) {

        //
        // Write the packet.
        //

        DebugPrint((2,
                    "AtapiInterrupt: Writing Atapi packet.\n"));

        //
        // Send CDB to device.
        //

        WriteBuffer(baseIoAddress1,
                    (PUSHORT)srb->Cdb,
                    6);

        return TRUE;

    } else if (interruptReason == 0x0 && (statusByte & IDE_STATUS_DRQ)) {

        //
        // Write the data.
        //

        if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

            //
            // Pick up bytes to transfer and convert to words.
            //

            wordCount =
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountLow);

            wordCount |=
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountHigh) << 8;

            //
            // Covert bytes to words.
            //

            wordCount >>= 1;

            if (wordCount != deviceExtension->WordsLeft) {
                DebugPrint((3,
                           "AtapiInterrupt: %d words requested; %d words xferred\n",
                           deviceExtension->WordsLeft,
                           wordCount));
            }

            //
            // Verify this makes sense.
            //

            if (wordCount > deviceExtension->WordsLeft) {
                wordCount = deviceExtension->WordsLeft;
            }

        } else {

            //
            // IDE path. Check if words left is at least 256.
            //

            if (deviceExtension->WordsLeft < wordsThisInterrupt) {

               //
               // Transfer only words requested.
               //

               wordCount = deviceExtension->WordsLeft;

            } else {

               //
               // Transfer next block.
               //

               wordCount = wordsThisInterrupt;
            }
        }

        //
        // Ensure that this is a write command.
        //

        if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {

           DebugPrint((3,
                      "AtapiInterrupt: Write interrupt\n"));

           WaitOnBusy(baseIoAddress2,statusByte);

           if (deviceExtension->DWordIO && wordCount >= 256 && (wordCount & 1) == 0) {

               WriteBuffer32(baseIoAddress1,
                             (PULONG)deviceExtension->DataBuffer,
                             wordCount >> 1);
           } else {

               WriteBuffer(baseIoAddress1,
                           deviceExtension->DataBuffer,
                           wordCount);
           }

        } else {

            DebugPrint((1,
                        "AtapiInterrupt: Int reason %x, but srb is for a write %x.\n",
                        interruptReason,
                        srb));

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }


        //
        // Advance data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer += wordCount;
        deviceExtension->WordsLeft -= wordCount;

        return TRUE;

    } else if (interruptReason == 0x2 && (statusByte & IDE_STATUS_DRQ)) {


        if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

            //
            // Pick up bytes to transfer and convert to words.
            //

            wordCount =
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountLow);

            wordCount |=
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountHigh) << 8;

            //
            // Covert bytes to words.
            //

            wordCount >>= 1;

            if (wordCount != deviceExtension->WordsLeft) {
                DebugPrint((3,
                           "AtapiInterrupt: %d words requested; %d words xferred\n",
                           deviceExtension->WordsLeft,
                           wordCount));
            }

            //
            // Verify this makes sense.
            //

            if (wordCount > deviceExtension->WordsLeft) {
                wordCount = deviceExtension->WordsLeft;
            }

        } else {

            //
            // Check if words left is at least 256.
            //

            if (deviceExtension->WordsLeft < wordsThisInterrupt) {

               //
               // Transfer only words requested.
               //

               wordCount = deviceExtension->WordsLeft;

            } else {

               //
               // Transfer next block.
               //

               wordCount = wordsThisInterrupt;
            }
        }

        //
        // Ensure that this is a read command.
        //

        if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

           DebugPrint((3,
                      "AtapiInterrupt: Read interrupt\n"));

           WaitOnBusy(baseIoAddress2,statusByte);

           if (deviceExtension->DWordIO && wordCount >= 256 && (wordCount & 1) == 0) {

               ReadBuffer32(baseIoAddress1,
                            (PULONG)deviceExtension->DataBuffer,
                            wordCount >> 1);
           } else {

               ReadBuffer(baseIoAddress1,
                         deviceExtension->DataBuffer,
                         wordCount);
           }

        } else {

            DebugPrint((1,
                        "AtapiInterrupt: Int reason %x, but srb is for a read %x.\n",
                        interruptReason,
                        srb));

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }

        //
        // Translate ATAPI data back to SCSI data if needed
        //

        if (srb->Cdb[0] == ATAPI_MODE_SENSE &&
            deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

            //
            //convert and adjust the wordCount
            //

            wordCount -= Atapi2Scsi(srb, (char *)deviceExtension->DataBuffer,
                                     wordCount << 1);
        }
        //
        // Advance data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer += wordCount;
        deviceExtension->WordsLeft -= wordCount;

        //
        // Check for read command complete.
        //

        if (deviceExtension->WordsLeft == 0) {

            if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

                //
                // Work around to make many atapi devices return correct sector size
                // of 2048. Also certain devices will have sector count == 0x00, check
                // for that also.
                //

                if ((srb->Cdb[0] == 0x25) &&
                    ((deviceExtension->IdentifyData[srb->TargetId].GeneralConfiguration >> 8) & 0x1f) == 0x05) {

                    deviceExtension->DataBuffer -= wordCount;
                    if (deviceExtension->DataBuffer[0] == 0x00) {

                        *((ULONG *) &(deviceExtension->DataBuffer[0])) = 0xFFFFFF7F;

                    }

                    // default sector size set to 2048 (0x800) for non-removable drive
                    if (!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_REMOVABLE_DRIVE))

                        *((ULONG *) &(deviceExtension->DataBuffer[2])) = 0x00080000;

                    deviceExtension->DataBuffer += wordCount;
                }
            } else {

                //
                // Completion for IDE drives.
                //


                if (deviceExtension->WordsLeft) {

                    status = SRB_STATUS_DATA_OVERRUN;

                } else {

                    status = SRB_STATUS_SUCCESS;

                }

                goto CompleteRequest;

            }
        }

        return TRUE;

    } else if (interruptReason == 0x3  && !(statusByte & IDE_STATUS_DRQ)) {

        //
        // Command complete.
        //

        if (deviceExtension->WordsLeft) {

            status = SRB_STATUS_DATA_OVERRUN;

        } else {

            status = SRB_STATUS_SUCCESS;

        }

CompleteRequest:

        //
        // Check and see if we are processing our secret (mechanism status/request sense) srb
        //
        if (deviceExtension->OriginalSrb) {

            ULONG srbStatus;

            if (srb->Cdb[0] == SCSIOP_MECHANISM_STATUS) {

                if (status == SRB_STATUS_SUCCESS) {
                    // Bingo!!
                    AtapiHwInitializeChanger (HwDeviceExtension,
                                              srb->TargetId,
                                              (PMECHANICAL_STATUS_INFORMATION_HEADER) srb->DataBuffer);

                    // Get ready to issue the original srb
                    srb = deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
                    deviceExtension->OriginalSrb = NULL;

                } else {
                    // failed!  Get the sense key and maybe try again
                    srb = deviceExtension->CurrentSrb = BuildRequestSenseSrb (
                                                          HwDeviceExtension,
                                                          deviceExtension->OriginalSrb->PathId,
                                                          deviceExtension->OriginalSrb->TargetId);
                }

                srbStatus = AtapiSendCommand(HwDeviceExtension, deviceExtension->CurrentSrb);
                if (srbStatus == SRB_STATUS_PENDING) {
                    return TRUE;
                }

            } else { // srb->Cdb[0] == SCSIOP_REQUEST_SENSE)

                PSENSE_DATA senseData = (PSENSE_DATA) srb->DataBuffer;

                if (status == SRB_STATUS_DATA_OVERRUN) {
                    // Check to see if we at least get mininum number of bytes
                    if ((srb->DataTransferLength - deviceExtension->WordsLeft) >
                        (offsetof (SENSE_DATA, AdditionalSenseLength) + sizeof(senseData->AdditionalSenseLength))) {
                        status = SRB_STATUS_SUCCESS;
                    }
                }

                if (status == SRB_STATUS_SUCCESS) {
                    if ((senseData->SenseKey != SCSI_SENSE_ILLEGAL_REQUEST) &&
                        deviceExtension->MechStatusRetryCount) {

                        // The sense key doesn't say the last request is illegal, so try again
                        deviceExtension->MechStatusRetryCount--;
                        srb = deviceExtension->CurrentSrb = BuildMechanismStatusSrb (
                                                              HwDeviceExtension,
                                                              deviceExtension->OriginalSrb->PathId,
                                                              deviceExtension->OriginalSrb->TargetId);
                    } else {

                        // last request was illegal.  No point trying again

                        AtapiHwInitializeChanger (HwDeviceExtension,
                                                  srb->TargetId,
                                                  (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);

                        // Get ready to issue the original srb
                        srb = deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
                        deviceExtension->OriginalSrb = NULL;
                    }

                    srbStatus = AtapiSendCommand(HwDeviceExtension, deviceExtension->CurrentSrb);
                    if (srbStatus == SRB_STATUS_PENDING) {
                        return TRUE;
                    }
                }
            }

            // If we get here, it means AtapiSendCommand() has failed
            // Can't recover.  Pretend the original srb has failed and complete it.

            if (deviceExtension->OriginalSrb) {
                AtapiHwInitializeChanger (HwDeviceExtension,
                                          srb->TargetId,
                                          (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);
                srb = deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
                deviceExtension->OriginalSrb = NULL;
            }

            // fake an error and read no data
            status = SRB_STATUS_ERROR;
            srb->ScsiStatus = 0;
            deviceExtension->DataBuffer = srb->DataBuffer;
            deviceExtension->WordsLeft = srb->DataTransferLength;
            deviceExtension->RDP = FALSE;

        } else if (status == SRB_STATUS_ERROR) {

            //
            // Map error to specific SRB status and handle request sense.
            //

            status = MapError(deviceExtension,
                              srb);

            deviceExtension->RDP = FALSE;

        } else {

            //
            // Wait for busy to drop.
            //

            for (i = 0; i < 30; i++) {
                GetStatus(baseIoAddress2,statusByte);
                if (!(statusByte & IDE_STATUS_BUSY)) {
                    break;
                }
                ScsiPortStallExecution(500);
            }

            if (i == 30) {

                //
                // reset the controller.
                //

                DebugPrint((1,
                            "AtapiInterrupt: Resetting due to BSY still up - %x. Base Io %x\n",
                            statusByte,
                            baseIoAddress1));
                AtapiResetController(HwDeviceExtension,srb->PathId);
                return TRUE;
            }

            //
            // Check to see if DRQ is still up.
            //

            if (statusByte & IDE_STATUS_DRQ) {

                for (i = 0; i < 500; i++) {
                    GetStatus(baseIoAddress2,statusByte);
                    if (!(statusByte & IDE_STATUS_DRQ)) {
                        break;
                    }
                    ScsiPortStallExecution(100);

                }

                if (i == 500) {

                    //
                    // reset the controller.
                    //

                    DebugPrint((1,
                                "AtapiInterrupt: Resetting due to DRQ still up - %x\n",
                                statusByte));
                    AtapiResetController(HwDeviceExtension,srb->PathId);
                    return TRUE;
                }

            }
        }


        //
        // Clear interrupt expecting flag.
        //

        deviceExtension->ExpectingInterrupt = FALSE;

        //
        // Sanity check that there is a current request.
        //

        if (srb != NULL) {

            //
            // Set status in SRB.
            //

            srb->SrbStatus = (UCHAR)status;

            //
            // Check for underflow.
            //

            if (deviceExtension->WordsLeft) {

                //
                // Subtract out residual words and update if filemark hit,
                // setmark hit , end of data, end of media...
                //

                if (!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_TAPE_DEVICE)) {
                if (status == SRB_STATUS_DATA_OVERRUN) {
                    srb->DataTransferLength -= deviceExtension->WordsLeft;
                } else {
                    srb->DataTransferLength = 0;
                }
                } else {
                    srb->DataTransferLength -= deviceExtension->WordsLeft;
                }
            }

            if (srb->Function != SRB_FUNCTION_IO_CONTROL) {

                //
                // Indicate command complete.
                //

                if (!(deviceExtension->RDP)) {
                    ScsiPortNotification(RequestComplete,
                                         deviceExtension,
                                         srb);

                }
            } else {

                PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                UCHAR             error = 0;

                if (status != SRB_STATUS_SUCCESS) {
                    error = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
                }

                //
                // Build the SMART status block depending upon the completion status.
                //

                cmdOutParameters->cBufferSize = wordCount;
                cmdOutParameters->DriverStatus.bDriverError = (error) ? SMART_IDE_ERROR : 0;
                cmdOutParameters->DriverStatus.bIDEError = error;

                //
                // If the sub-command is return smart status, jam the value from cylinder low and high, into the
                // data buffer.
                //

                if (deviceExtension->SmartCommand == RETURN_SMART_STATUS) {
                    cmdOutParameters->bBuffer[0] = RETURN_SMART_STATUS;
                    cmdOutParameters->bBuffer[1] = ScsiPortReadPortUchar(&baseIoAddress1->InterruptReason);
                    cmdOutParameters->bBuffer[2] = ScsiPortReadPortUchar(&baseIoAddress1->Unused1);
                    cmdOutParameters->bBuffer[3] = ScsiPortReadPortUchar(&baseIoAddress1->ByteCountLow);
                    cmdOutParameters->bBuffer[4] = ScsiPortReadPortUchar(&baseIoAddress1->ByteCountHigh);
                    cmdOutParameters->bBuffer[5] = ScsiPortReadPortUchar(&baseIoAddress1->DriveSelect);
                    cmdOutParameters->bBuffer[6] = SMART_CMD;
                    cmdOutParameters->cBufferSize = 8;
                }

                //
                // Indicate command complete.
                //

                ScsiPortNotification(RequestComplete,
                                     deviceExtension,
                                     srb);

            }

        } else {

            DebugPrint((1,
                       "AtapiInterrupt: No SRB!\n"));
        }

        //
        // Indicate ready for next request.
        //

        if (!(deviceExtension->RDP)) {

            //
            // Clear current SRB.
            //

            deviceExtension->CurrentSrb = NULL;

            ScsiPortNotification(NextRequest,
                                 deviceExtension,
                                 NULL);
        } else {

            ScsiPortNotification(RequestTimerCall,
                                 HwDeviceExtension,
                                 AtapiCallBack,
                                 2000);
        }

        return TRUE;

    } else {

        //
        // Unexpected int.
        //

        DebugPrint((3,
                    "AtapiInterrupt: Unexpected interrupt. InterruptReason %x. Status %x.\n",
                    interruptReason,
                    statusByte));
        return FALSE;
    }

    return TRUE;

} // end AtapiInterrupt()


ULONG
IdeSendSmartCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles SMART enable, disable, read attributes and threshold commands.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    PSENDCMDOUTPARAMS    cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    SENDCMDINPARAMS      cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    PIDEREGS             regs = &cmdInParameters.irDriveRegs;
    ULONG                i;
    UCHAR                statusByte,targetId;


    if (cmdInParameters.irDriveRegs.bCommandReg == SMART_CMD) {

        targetId = cmdInParameters.bDriveNumber;

        //TODO optimize this check

        if ((!(deviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT)) ||
             (deviceExtension->DeviceFlags[targetId] & DFLAGS_ATAPI_DEVICE)) {

            return SRB_STATUS_SELECTION_TIMEOUT;
        }

        deviceExtension->SmartCommand = cmdInParameters.irDriveRegs.bFeaturesReg;

        //
        // Determine which of the commands to carry out.
        //

        if ((cmdInParameters.irDriveRegs.bFeaturesReg == READ_ATTRIBUTES) ||
            (cmdInParameters.irDriveRegs.bFeaturesReg == READ_THRESHOLDS)) {

            WaitOnBusy(baseIoAddress2,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

            //
            // Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
            //

            for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + READ_ATTRIBUTE_BUFFER_SIZE - 1); i++) {
                ((PUCHAR)cmdOutParameters)[i] = 0;
            }

            //
            // Set data buffer pointer and words left.
            //

            deviceExtension->DataBuffer = (PUSHORT)cmdOutParameters->bBuffer;
            deviceExtension->WordsLeft = READ_ATTRIBUTE_BUFFER_SIZE / 2;

            //
            // Indicate expecting an interrupt.
            //

            deviceExtension->ExpectingInterrupt = TRUE;

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,(UCHAR)(((targetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,regs->bFeaturesReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,regs->bSectorCountReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,regs->bCylLowReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            ScsiPortWritePortUchar(&baseIoAddress1->Command,regs->bCommandReg);

            //
            // Wait for interrupt.
            //

            return SRB_STATUS_PENDING;

        } else if ((cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_SMART) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == DISABLE_SMART) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == RETURN_SMART_STATUS) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_DISABLE_AUTOSAVE) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == EXECUTE_OFFLINE_DIAGS) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == SAVE_ATTRIBUTE_VALUES)) {

            WaitOnBusy(baseIoAddress2,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

            //
            // Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
            //

            for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) - 1); i++) {
                ((PUCHAR)cmdOutParameters)[i] = 0;
            }

            //
            // Set data buffer pointer and indicate no data transfer.
            //

            deviceExtension->DataBuffer = (PUSHORT)cmdOutParameters->bBuffer;
            deviceExtension->WordsLeft = 0;

            //
            // Indicate expecting an interrupt.
            //

            deviceExtension->ExpectingInterrupt = TRUE;

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,(UCHAR)(((targetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,regs->bFeaturesReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,regs->bSectorCountReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,regs->bCylLowReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            ScsiPortWritePortUchar(&baseIoAddress1->Command,regs->bCommandReg);

            //
            // Wait for interrupt.
            //

            return SRB_STATUS_PENDING;
        }
    }

    return SRB_STATUS_INVALID_REQUEST;

} // end IdeSendSmartCommand()


ULONG
IdeReadWrite(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles IDE read and writes.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG                startingSector,i;
    ULONG                wordCount;
    UCHAR                statusByte,statusByte2;
    UCHAR                cylinderHigh,cylinderLow,drvSelect,sectorNumber;

    //
    // Select device 0 or 1.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                            (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));

    WaitOnBusy(baseIoAddress2,statusByte2);

    if (statusByte2 & IDE_STATUS_BUSY) {
        DebugPrint((1,
                    "IdeReadWrite: Returning BUSY status\n"));
        return SRB_STATUS_BUSY;
    }

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
    deviceExtension->WordsLeft = Srb->DataTransferLength / 2;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;

    //
    // Set up sector count register. Round up to next block.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                           (UCHAR)((Srb->DataTransferLength + 0x1FF) / 0x200));

    //
    // Get starting sector number from CDB.
    //

    startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((1,
               "IdeReadWrite: Starting sector is %x, Number of bytes %x\n",
               startingSector,
               Srb->DataTransferLength));

    //
    // Set up sector number register.
    //

    sectorNumber = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3;      // LBA mode
                 // (UCHAR)((startingSector % deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) + 1);
    ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,sectorNumber);

    //
    // Set up cylinder low register.
    //

    cylinderLow = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2;      // LBA mode
                // (UCHAR)(startingSector / (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                //         deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads));
    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,cylinderLow);

    //
    // Set up cylinder high register.
    //

    cylinderHigh = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1;      // LBA mode
                // (UCHAR)((startingSector / (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                //         deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads)) >> 8);
    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,cylinderHigh);

    //
    // Set up head and drive select register.
    //

    drvSelect = (UCHAR)(((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 |      // LBA mode
                ((Srb->TargetId & 0x1) << 4) | 0xE0);
             // (UCHAR)(((startingSector / deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
             //       deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads) |((Srb->TargetId & 0x1) << 4) | 0xA0);
    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,drvSelect);

 // DebugPrint((2,
 //            "IdeReadWrite: Cylinder %x Head %x Sector %x\n",
 //            startingSector /
 //            (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
 //            deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads),
 //            (startingSector /
 //            deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
 //            deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads,
 //            startingSector %
 //            deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack + 1));

    //
    // Check if write request.
    //

    if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {

        //
        // Send read command.
        //

        if (deviceExtension->MaximumBlockXfer[Srb->TargetId]) {
            ScsiPortWritePortUchar(&baseIoAddress1->Command,
                                   IDE_COMMAND_READ_MULTIPLE);

        } else {
            ScsiPortWritePortUchar(&baseIoAddress1->Command,
                                   IDE_COMMAND_READ);
        }
    } else {


        //
        // Send write command.
        //

        if (deviceExtension->MaximumBlockXfer[Srb->TargetId]) {
            wordCount = 256 * deviceExtension->MaximumBlockXfer[Srb->TargetId];

            if (deviceExtension->WordsLeft < wordCount) {

               //
               // Transfer only words requested.
               //

               wordCount = deviceExtension->WordsLeft;

            }
            ScsiPortWritePortUchar(&baseIoAddress1->Command,
                                   IDE_COMMAND_WRITE_MULTIPLE);

        } else {
            wordCount = 256;
            ScsiPortWritePortUchar(&baseIoAddress1->Command,
                                   IDE_COMMAND_WRITE);
        }

        //
        // Wait for BSY and DRQ.
        //

        WaitOnBaseBusy(baseIoAddress1,statusByte);

        if (statusByte & IDE_STATUS_BUSY) {

            DebugPrint((1,
                        "IdeReadWrite 2: Returning BUSY status %x\n",
                        statusByte));
            return SRB_STATUS_BUSY;
        }

        for (i = 0; i < 1000; i++) {
            GetBaseStatus(baseIoAddress1, statusByte);
            if (statusByte & IDE_STATUS_DRQ) {
                break;
            }
            ScsiPortStallExecution(200);

        }

        if (!(statusByte & IDE_STATUS_DRQ)) {

            DebugPrint((1,
                       "IdeReadWrite: DRQ never asserted (%x) original status (%x)\n",
                       statusByte,
                       statusByte2));

            deviceExtension->WordsLeft = 0;

            //
            // Clear interrupt expecting flag.
            //

            deviceExtension->ExpectingInterrupt = FALSE;

            //
            // Clear current SRB.
            //

            deviceExtension->CurrentSrb = NULL;

            return SRB_STATUS_TIMEOUT;
        }

        //
        // Write next 256 words.
        //

        if (deviceExtension->DWordIO) {

            WriteBuffer32(baseIoAddress1,
                          (PULONG)deviceExtension->DataBuffer,
                          wordCount >> 1);
        } else {

            WriteBuffer(baseIoAddress1,
                        deviceExtension->DataBuffer,
                        wordCount);
        }

        //
        // Adjust buffer address and words left count.
        //

        deviceExtension->WordsLeft -= wordCount;
        deviceExtension->DataBuffer += wordCount;

    }

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeReadWrite()



ULONG
IdeVerify(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles IDE Verify.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG                startingSector;
    ULONG                sectors;
    ULONG                endSector;
    USHORT               sectorCount;

    //
    // Drive has these number sectors.
    //

    sectors = deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
              deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads *
              deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders;

    DebugPrint((3,
                "IdeVerify: Total sectors %x\n",
                sectors));

    //
    // Get starting sector number from CDB.
    //

    startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((3,
                "IdeVerify: Starting sector %x. Number of blocks %x\n",
                startingSector,
                ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb));

    sectorCount = (USHORT)(((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8 |
                           ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb );
    endSector = startingSector + sectorCount;

    DebugPrint((3,
                "IdeVerify: Ending sector %x\n",
                endSector));

    if (endSector > sectors) {

        //
        // Too big, round down.
        //

        DebugPrint((1,
                    "IdeVerify: Truncating request to %x blocks\n",
                    sectors - startingSector - 1));

        ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                               (UCHAR)(sectors - startingSector - 1));

    } else {

        //
        // Set up sector count register. Round up to next block.
        //

        if (sectorCount > 0xFF) {
            sectorCount = (USHORT)0xFF;
        }

        ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,(UCHAR)sectorCount);
    }

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
    deviceExtension->WordsLeft = Srb->DataTransferLength / 2;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;

    //
    // Set up sector number register.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,
                ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3);      // LBA mode
                //         (UCHAR)((startingSector %
                //         deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) + 1));

    //
    // Set up cylinder low register.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,
                ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2);      // LBA mode
                //         (UCHAR)(startingSector /
                //         (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                //         deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads)));

    //
    // Set up cylinder high register.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,
                ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1);      // LBA mode
                //         (UCHAR)((startingSector /
                //         (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                //         deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads)) >> 8));

    //
    // Set up head and drive select register.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                (UCHAR)(((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 |      // LBA mode
                ((Srb->TargetId & 0x1) << 4) | 0xE0));
                //         (UCHAR)(((startingSector /
                //         deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
                //         deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads) |
                //         ((Srb->TargetId & 0x1) << 4) | 0xA0));

    DebugPrint((2,
               "IdeVerify: Cylinder %x Head %x Sector %x\n",
               startingSector /
               (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads),
               (startingSector /
               deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads,
               startingSector %
               deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack + 1));


    //
    // Send verify command.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->Command,
                           IDE_COMMAND_VERIFY);

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeVerify()


VOID
Scsi2Atapi(
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Convert SCSI packet command to Atapi packet command.

Arguments:

    Srb - IO request packet

Return Value:

    None

--*/
{
    //
    // Change the cdb length
    //

    Srb->CdbLength = 12;

    switch (Srb->Cdb[0]) {
        case SCSIOP_MODE_SENSE: {
            PMODE_SENSE_10 modeSense10 = (PMODE_SENSE_10)Srb->Cdb;
            UCHAR PageCode = ((PCDB)Srb->Cdb)->MODE_SENSE.PageCode;
            UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SENSE.AllocationLength;

            AtapiZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

            modeSense10->OperationCode = ATAPI_MODE_SENSE;
            modeSense10->PageCode = PageCode;
            modeSense10->ParameterListLengthMsb = 0;
            modeSense10->ParameterListLengthLsb = Length;
            break;
        }

        case SCSIOP_MODE_SELECT: {
            PMODE_SELECT_10 modeSelect10 = (PMODE_SELECT_10)Srb->Cdb;
            UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SELECT.ParameterListLength;

            //
            // Zero the original cdb
            //

            AtapiZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

            modeSelect10->OperationCode = ATAPI_MODE_SELECT;
            modeSelect10->PFBit = 1;
            modeSelect10->ParameterListLengthMsb = 0;
            modeSelect10->ParameterListLengthLsb = Length;
            break;
        }

        /*
        case SCSIOP_FORMAT_UNIT:
        Srb->Cdb[0] = ATAPI_FORMAT_UNIT;
        break;
        */
    }
}



ULONG
AtapiSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Send ATAPI packet command to device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PATAPI_REGISTERS_1   baseIoAddress1  = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PATAPI_REGISTERS_2   baseIoAddress2 =  (PATAPI_REGISTERS_2)deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG i;
    ULONG flags;
    UCHAR statusByte,byteCountLow,byteCountHigh;

    //
    // We need to know how many platters our atapi cd-rom device might have.
    // Before anyone tries to send a srb to our target for the first time,
    // we must "secretly" send down a separate mechanism status srb in order to
    // initialize our device extension changer data.  That's how we know how
    // many platters our target has.
    //
    if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_CHANGER_INITED) &&
        !deviceExtension->OriginalSrb) {

        ULONG srbStatus;

        //
        // Set this flag now. If the device hangs on the mech. status
        // command, we will not have the change to set it.
        //
        deviceExtension->DeviceFlags[Srb->TargetId] |= DFLAGS_CHANGER_INITED;

        deviceExtension->MechStatusRetryCount = 3;
        deviceExtension->CurrentSrb = BuildMechanismStatusSrb (
                                        HwDeviceExtension,
                                        Srb->PathId,
                                        Srb->TargetId);
        deviceExtension->OriginalSrb = Srb;

        srbStatus = AtapiSendCommand(HwDeviceExtension, deviceExtension->CurrentSrb);
        if (srbStatus == SRB_STATUS_PENDING) {
            return srbStatus;
        } else {
            deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
            deviceExtension->OriginalSrb = NULL;
            AtapiHwInitializeChanger (HwDeviceExtension,
                                      Srb->TargetId,
                                      (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);
            // fall out
        }
    }

    DebugPrint((2,
               "AtapiSendCommand: Command %x to TargetId %d lun %d\n",
               Srb->Cdb[0],
               Srb->TargetId,
               Srb->Lun));

    if (Srb->Cdb[0] == SCSIOP_READ || Srb->Cdb[0] == SCSIOP_READ_CD || Srb->Cdb[0] == SCSIOP_WRITE) {

        DebugPrint((1,
                   "AtapiSendCommand: Command is %x, Number of bytes %x\n",
                   Srb->Cdb[0],
                   Srb->DataTransferLength));
    }

    //
    // Make sure command is to ATAPI device.
    //

    flags = deviceExtension->DeviceFlags[Srb->TargetId];
    if (flags & (DFLAGS_SANYO_ATAPI_CHANGER | DFLAGS_ATAPI_CHANGER)) {
        if ((Srb->Lun) > (deviceExtension->DiscsPresent[Srb->TargetId] - 1)) {

            //
            // Indicate no device found at this address.
            //

            return SRB_STATUS_SELECTION_TIMEOUT;
        }
    } else if (Srb->Lun > 0) {
        return SRB_STATUS_SELECTION_TIMEOUT;
    }

    if (!(flags & DFLAGS_ATAPI_DEVICE)) {
        return SRB_STATUS_SELECTION_TIMEOUT;
    }

    //
    // Select device 0 or 1.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                           (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));

    //
    // Verify that controller is ready for next command.
    //

    GetStatus(baseIoAddress2,statusByte);

    DebugPrint((2,
                "AtapiSendCommand: Entered with status %x\n",
                statusByte));

    if (statusByte & IDE_STATUS_BUSY) {
        DebugPrint((1,
                    "AtapiSendCommand: Device busy (%x)\n",
                    statusByte));
        return SRB_STATUS_BUSY;

    }

    if (statusByte & IDE_STATUS_ERROR) {
        if (Srb->Cdb[0] != SCSIOP_REQUEST_SENSE) {

            DebugPrint((1,
                        "AtapiSendCommand: Error on entry: (%x)\n",
                        statusByte));
            //
            // Read the error reg. to clear it and fail this request.
            //

            return MapError(deviceExtension,
                            Srb);
        }
    }

    //
    // If a tape drive has doesn't have DSC set and the last command is restrictive, don't send
    // the next command. See discussion of Restrictive Delayed Process commands in QIC-157.
    //

    if ((!(statusByte & IDE_STATUS_DSC)) &&
          (flags & DFLAGS_TAPE_DEVICE) && deviceExtension->RDP) {
        ScsiPortStallExecution(1000);
        DebugPrint((2,"AtapiSendCommand: DSC not set. %x\n",statusByte));
        return SRB_STATUS_BUSY;
    }

    if (IS_RDP(Srb->Cdb[0])) {

        deviceExtension->RDP = TRUE;

        DebugPrint((3,
                    "AtapiSendCommand: %x mapped as DSC restrictive\n",
                    Srb->Cdb[0]));

    } else {

        deviceExtension->RDP = FALSE;
    }

    if (statusByte & IDE_STATUS_DRQ) {

        DebugPrint((1,
                    "AtapiSendCommand: Entered with status (%x). Attempting to recover.\n",
                    statusByte));
        //
        // Try to drain the data that one preliminary device thinks that it has
        // to transfer. Hopefully this random assertion of DRQ will not be present
        // in production devices.
        //

        for (i = 0; i < 0x10000; i++) {

           GetStatus(baseIoAddress2, statusByte);

           if (statusByte & IDE_STATUS_DRQ) {

              ScsiPortReadPortUshort(&baseIoAddress1->Data);

           } else {

              break;
           }
        }

        if (i == 0x10000) {

            DebugPrint((1,
                        "AtapiSendCommand: DRQ still asserted.Status (%x)\n",
                        statusByte));

            // disable the interrupt
            if (deviceExtension->IrqSharing)
                ScsiPortWritePortUchar(&baseIoAddress1->DmaReg, 0x20);

            AtapiSoftReset(baseIoAddress1,baseIoAddress2,Srb->TargetId);

            DebugPrint((1,
                         "AtapiSendCommand: Issued soft reset to Atapi device. \n"));

            //
            // Re-initialize Atapi device.
            //

            IssueIdentify(HwDeviceExtension,
                          (Srb->TargetId & 0x1),
                          (Srb->TargetId >> 1),
                          IDE_COMMAND_ATAPI_IDENTIFY);

            // enable the interrupt
            if (deviceExtension->IrqSharing)
                ScsiPortWritePortUchar(&baseIoAddress1->DmaReg, 0x00);

            //
            // Inform the port driver that the bus has been reset.
            //

            ScsiPortNotification(ResetDetected, HwDeviceExtension, 0);

            //
            // Clean up device extension fields that AtapiStartIo won't.
            //

            deviceExtension->ExpectingInterrupt = FALSE;
            deviceExtension->RDP = FALSE;

            return SRB_STATUS_BUS_RESET;

        }
    }

    if (flags & (DFLAGS_SANYO_ATAPI_CHANGER | DFLAGS_ATAPI_CHANGER)) {

        //
        // As the cdrom driver sets the LUN field in the cdb, it must be removed.
        //

        Srb->Cdb[1] &= ~0xE0;

        if ((Srb->Cdb[0] == SCSIOP_TEST_UNIT_READY) && (flags & DFLAGS_SANYO_ATAPI_CHANGER)) {

            //
            // Torisan changer. TUR's are overloaded to be platter switches.
            //

            Srb->Cdb[7] = Srb->Lun;

        }
    }

    //
    // Convert SCSI to ATAPI commands if needed
    //

    switch (Srb->Cdb[0]) {
        case SCSIOP_MODE_SENSE:
        case SCSIOP_MODE_SELECT:
        /* case SCSIOP_FORMAT_UNIT: */
            if (!(flags & DFLAGS_TAPE_DEVICE)) {
                Scsi2Atapi(Srb);
            }

            break;
    }

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
    deviceExtension->WordsLeft = Srb->DataTransferLength / 2;

    WaitOnBusy(baseIoAddress2,statusByte);

    //
    // Write transfer byte count to registers.
    //

    byteCountLow = (UCHAR)(Srb->DataTransferLength & 0xFF);
    byteCountHigh = (UCHAR)(Srb->DataTransferLength >> 8);

    if (Srb->DataTransferLength >= 0x10000) {
        byteCountLow = byteCountHigh = 0xFF;
    }

    ScsiPortWritePortUchar(&baseIoAddress1->ByteCountLow,byteCountLow);
    ScsiPortWritePortUchar(&baseIoAddress1->ByteCountHigh, byteCountHigh);

    ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,0);


    if (flags & DFLAGS_INT_DRQ) {

        //
        // This device interrupts when ready to receive the packet.
        //
        // Write ATAPI packet command.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->Command,
                               IDE_COMMAND_ATAPI_PACKET);

        DebugPrint((3,
                   "AtapiSendCommand: Wait for int. to send packet. Status (%x)\n",
                   statusByte));

        deviceExtension->ExpectingInterrupt = TRUE;

        return SRB_STATUS_PENDING;

    } else {

        //
        // Write ATAPI packet command.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->Command,
                               IDE_COMMAND_ATAPI_PACKET);

        //
        // Wait for DRQ.
        //

        WaitOnBusy(baseIoAddress2, statusByte);
        WaitForDrq(baseIoAddress2, statusByte);

        if (!(statusByte & IDE_STATUS_DRQ)) {

            DebugPrint((1,
                       "AtapiSendCommand: DRQ never asserted (%x)\n",
                       statusByte));
            return SRB_STATUS_ERROR;
        }
    }

    //
    // Need to read status register.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    //
    // Send CDB to device.
    //

    WaitOnBusy(baseIoAddress2,statusByte);

    WriteBuffer(baseIoAddress1,
                (PUSHORT)Srb->Cdb,
                6);

    //
    // Indicate expecting an interrupt and wait for it.
    //

    deviceExtension->ExpectingInterrupt = TRUE;

    return SRB_STATUS_PENDING;

} // end AtapiSendCommand()

ULONG
IdeSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Program ATA registers for IDE disk transfer.

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    PCDB cdb;

    UCHAR statusByte,errorByte;
    ULONG status;
    ULONG i;
    PMODE_PARAMETER_HEADER   modeData;

    DebugPrint((2,
               "IdeSendCommand: Command %x to device %d\n",
               Srb->Cdb[0],
               Srb->TargetId));



    switch (Srb->Cdb[0]) {
    case SCSIOP_INQUIRY:

        //
        // Filter out all TIDs but 0 and 1 since this is an IDE interface
        // which support up to two devices.
        //

        if ((Srb->Lun != 0) ||
            (!deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT)) {

            //
            // Indicate no device found at this address.
            //

            status = SRB_STATUS_SELECTION_TIMEOUT;
            break;

        } else {

            PINQUIRYDATA    inquiryData  = Srb->DataBuffer;
            PIDENTIFY_DATA2 identifyData = &deviceExtension->IdentifyData[Srb->TargetId];

            //
            // Zero INQUIRY data structure.
            //

            for (i = 0; i < Srb->DataTransferLength; i++) {
               ((PUCHAR)Srb->DataBuffer)[i] = 0;
            }

            //
            // Standard IDE interface only supports disks.
            //

            inquiryData->DeviceType = DIRECT_ACCESS_DEVICE;

            //
            // Set the removable bit, if applicable.
            //

            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE) {
                inquiryData->RemovableMedia = 1;
            }

            //
            // Fill in vendor identification fields.
            //

            for (i = 0; i < 20; i += 2) {
               inquiryData->VendorId[i] =
                   ((PUCHAR)identifyData->ModelNumber)[i + 1];
               inquiryData->VendorId[i+1] =
                   ((PUCHAR)identifyData->ModelNumber)[i];
            }

            //
            // Initialize unused portion of product id.
            //

            for (i = 0; i < 4; i++) {
               inquiryData->ProductId[12+i] = ' ';
            }

            //
            // Move firmware revision from IDENTIFY data to
            // product revision in INQUIRY data.
            //

            for (i = 0; i < 4; i += 2) {
               inquiryData->ProductRevisionLevel[i] =
                   ((PUCHAR)identifyData->FirmwareRevision)[i+1];
               inquiryData->ProductRevisionLevel[i+1] =
                   ((PUCHAR)identifyData->FirmwareRevision)[i];
            }

            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SCSIOP_MODE_SENSE:

        //
        // This is used to determine of the media is write-protected.
        // Since IDE does not support mode sense then we will modify just the portion we need
        // so the higher level driver can determine if media is protected.
        //

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                             (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_GET_MEDIA_STATUS);
            WaitOnBusy(baseIoAddress2,statusByte);

            if (!(statusByte & IDE_STATUS_ERROR)){

                //
                // no error occured return success, media is not protected
                //

                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;

            } else {

                //
                // error occured, handle it locally, clear interrupt
                //

                errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);

                GetBaseStatus(baseIoAddress1, statusByte);
                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;

                if (errorByte & IDE_ERROR_DATA_ERROR) {

                   //
                   //media is write-protected, set bit in mode sense buffer
                   //

                   modeData = (PMODE_PARAMETER_HEADER)Srb->DataBuffer;

                   Srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER);
                   modeData->DeviceSpecificParameter |= MODE_DSP_WRITE_PROTECT;
                }
            }
            status = SRB_STATUS_SUCCESS;
        } else {
            status = SRB_STATUS_INVALID_REQUEST;
        }
        break;

    case SCSIOP_TEST_UNIT_READY:

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE) {

            //
            // Select device 0 or 1.
            //

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                            (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_GET_MEDIA_STATUS);

            //
            // Wait for busy. If media has not changed, return success
            //

            WaitOnBusy(baseIoAddress2,statusByte);

            if (!(statusByte & IDE_STATUS_ERROR)){
                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;
            } else {
                errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
                if (errorByte == IDE_ERROR_DATA_ERROR){

                    //
                    // Special case: If current media is write-protected,
                    // the 0xDA command will always fail since the write-protect bit
                    // is sticky,so we can ignore this error
                    //

                   GetBaseStatus(baseIoAddress1, statusByte);
                   deviceExtension->ExpectingInterrupt = FALSE;
                   status = SRB_STATUS_SUCCESS;

                } else {

                    //
                    // Request sense buffer to be build
                    //
                    deviceExtension->ExpectingInterrupt = TRUE;
                    status = SRB_STATUS_PENDING;
               }
            }
        } else {
            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SCSIOP_READ_CAPACITY:

        //
        // Claim 512 byte blocks (big-endian).
        //

        ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->BytesPerBlock = 0x20000;

       //
       // Calculate last sector.
       //


       i = (deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads *
            deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders *
            deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) - 1;

       if ((deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads == 16
            || deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads == 15)
           && deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders == 16383
           && deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors
           && deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors > (i + 1))
       {
           i = deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors - 1;

           DebugPrint((1,
                      "IDE disk %x - using user addressable sectors (%x) instead of CHS. (sizeof IdentifyData = %d)\n",
                      Srb->TargetId,
                      deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors,
                      sizeof(IDENTIFY_DATA2)));
       }

       ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress =
           (((PUCHAR)&i)[0] << 24) |  (((PUCHAR)&i)[1] << 16) |
           (((PUCHAR)&i)[2] << 8) | ((PUCHAR)&i)[3];

       DebugPrint((1,
                  "IDE disk %x - #sectors %x, #heads %x, #cylinders %x\n",
                  Srb->TargetId,
                  deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack,
                  deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads,
                  deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders));


       status = SRB_STATUS_SUCCESS;
       break;

    case SCSIOP_VERIFY:
       status = IdeVerify(HwDeviceExtension,Srb);

       break;

    case SCSIOP_READ:
    case SCSIOP_WRITE:

       status = IdeReadWrite(HwDeviceExtension,
                                  Srb);
       break;

    case SCSIOP_START_STOP_UNIT:

       //
       //Determine what type of operation we should perform
       //
       cdb = (PCDB)Srb->Cdb;

       if (cdb->START_STOP.LoadEject == 1){

           //
           // Eject media,
           // first select device 0 or 1.
           //
           ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                            (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
           ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_MEDIA_EJECT);
       }
       status = SRB_STATUS_SUCCESS;
       break;

    case SCSIOP_REQUEST_SENSE:
       // this function makes sense buffers to report the results
       // of the original GET_MEDIA_STATUS command

       if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE) {

           status = IdeBuildSenseBuffer(HwDeviceExtension,Srb);
           break;
       }

    default:

       DebugPrint((1,
                  "IdeSendCommand: Unsupported command %x\n",
                  Srb->Cdb[0]));

       status = SRB_STATUS_INVALID_REQUEST;

    } // end switch

    return status;

} // end IdeSendCommand()

VOID
IdeMediaStatus(
    BOOLEAN EnableMSN,
    IN PVOID HwDeviceExtension,
    ULONG Channel
    )
/*++

Routine Description:

    Enables disables media status notification

Arguments:

HwDeviceExtension - ATAPI driver storage.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress = deviceExtension->BaseIoAddress1[Channel >> 1];
    UCHAR statusByte,errorByte;


    if (EnableMSN == TRUE){

        //
        // If supported enable Media Status Notification support
        //

        if ((deviceExtension->DeviceFlags[Channel] & DFLAGS_REMOVABLE_DRIVE)) {

            //
            // enable
            //
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1,(UCHAR) (0x95));
            ScsiPortWritePortUchar(&baseIoAddress->Command,
                                   IDE_COMMAND_ENABLE_MEDIA_STATUS);

            WaitOnBaseBusy(baseIoAddress,statusByte);

            if (statusByte & IDE_STATUS_ERROR) {
                //
                // Read the error register.
                //
                errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress + 1);

                DebugPrint((1,
                            "IdeMediaStatus: Error enabling media status. Status %x, error byte %x\n",
                             statusByte,
                             errorByte));
            } else {
                deviceExtension->DeviceFlags[Channel] |= DFLAGS_MEDIA_STATUS_ENABLED;
                DebugPrint((1,"IdeMediaStatus: Media Status Notification Supported\n"));
                deviceExtension->ReturningMediaStatus = 0;

            }

        }
    } else { // end if EnableMSN == TRUE

        //
        // disable if previously enabled
        //
        if ((deviceExtension->DeviceFlags[Channel] & DFLAGS_MEDIA_STATUS_ENABLED)) {

            ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1,(UCHAR) (0x31));
            ScsiPortWritePortUchar(&baseIoAddress->Command,
                                   IDE_COMMAND_ENABLE_MEDIA_STATUS);

            WaitOnBaseBusy(baseIoAddress,statusByte);
            deviceExtension->DeviceFlags[Channel] &= ~DFLAGS_MEDIA_STATUS_ENABLED;
        }


    }



}

ULONG
IdeBuildSenseBuffer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Builts an artificial sense buffer to report the results of a GET_MEDIA_STATUS
    command. This function is invoked to satisfy the SCSIOP_REQUEST_SENSE.
Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (ALWAYS SUCCESS).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG status;
    PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->DataBuffer;


    if (senseBuffer){


        if(deviceExtension->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if(deviceExtension->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE_REQ) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if(deviceExtension->ReturningMediaStatus & IDE_ERROR_END_OF_MEDIA) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_NOT_READY;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if(deviceExtension->ReturningMediaStatus & IDE_ERROR_DATA_ERROR) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_DATA_PROTECT;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }
        return SRB_STATUS_SUCCESS;
    }
    return SRB_STATUS_ERROR;

}// End of IdeBuildSenseBuffer




BOOLEAN
AtapiStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine is called from the SCSI port driver synchronized
    with the kernel to start an IO request.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    TRUE

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG status;

    // enable interrupt
    if (deviceExtension->IrqSharing)
        ScsiPortWritePortUchar(&deviceExtension->BaseIoAddress1[0]->DmaReg, 0x00);

    //
    // Determine which function.
    //

    switch (Srb->Function) {

    case SRB_FUNCTION_EXECUTE_SCSI:

        //
        // Sanity check. Only one request can be outstanding on a
        // controller.
        //

        if (deviceExtension->CurrentSrb) {

            DebugPrint((1,
                       "AtapiStartIo: Already have a request!\n"));
            Srb->SrbStatus = SRB_STATUS_BUSY;
            ScsiPortNotification(RequestComplete,
                                 deviceExtension,
                                 Srb);
            return FALSE;
        }

        //
        // Indicate that a request is active on the controller.
        //

        deviceExtension->CurrentSrb = Srb;

        //
        // Send command to device.
        //

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

           status = AtapiSendCommand(HwDeviceExtension,
                                     Srb);

        } else if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) {

           status = IdeSendCommand(HwDeviceExtension,
                                   Srb);
        } else {

            status = SRB_STATUS_SELECTION_TIMEOUT;
        }

        break;

    case SRB_FUNCTION_ABORT_COMMAND:

        //
        // Verify that SRB to abort is still outstanding.
        //

        if (!deviceExtension->CurrentSrb) {

            DebugPrint((1, "AtapiStartIo: SRB to abort already completed\n"));

            //
            // Complete abort SRB.
            //

            status = SRB_STATUS_ABORT_FAILED;

            break;
        }

        //
        // Abort function indicates that a request timed out.
        // Call reset routine. Card will only be reset if
        // status indicates something is wrong.
        // Fall through to reset code.
        //

    case SRB_FUNCTION_RESET_BUS:

        //
        // Reset Atapi and SCSI bus.
        //

        DebugPrint((1, "AtapiStartIo: Reset bus request received\n"));

        if (!AtapiResetController(deviceExtension,
                             Srb->PathId)) {

              DebugPrint((1,"AtapiStartIo: Reset bus failed\n"));

            //
            // Log reset failure.
            //

            ScsiPortLogError(
                HwDeviceExtension,
                NULL,
                0,
                0,
                0,
                SP_INTERNAL_ADAPTER_ERROR,
                5 << 8
                );

              status = SRB_STATUS_ERROR;

        } else {

              status = SRB_STATUS_SUCCESS;
        }

        break;

    case SRB_FUNCTION_IO_CONTROL:

        if (deviceExtension->CurrentSrb) {

            DebugPrint((1,
                       "AtapiStartIo: Already have a request!\n"));
            Srb->SrbStatus = SRB_STATUS_BUSY;
            ScsiPortNotification(RequestComplete,
                                 deviceExtension,
                                 Srb);
            return FALSE;
        }

        //
        // Indicate that a request is active on the controller.
        //

        deviceExtension->CurrentSrb = Srb;

        if (AtapiStringCmp( ((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature,"SCSIDISK",strlen("SCSIDISK"))) {

            DebugPrint((1,
                        "AtapiStartIo: IoControl signature incorrect. Send %s, expected %s\n",
                        ((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature,
                        "SCSIDISK"));

            status = SRB_STATUS_INVALID_REQUEST;
            break;
        }

        switch (((PSRB_IO_CONTROL)(Srb->DataBuffer))->ControlCode) {

            case IOCTL_SCSI_MINIPORT_SMART_VERSION: {

                PGETVERSIONINPARAMS versionParameters = (PGETVERSIONINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                UCHAR deviceNumber;

                //
                // Version and revision per SMART 1.03
                //

                versionParameters->bVersion = 1;
                versionParameters->bRevision = 1;
                versionParameters->bReserved = 0;

                //
                // Indicate that support for IDE IDENTIFY, ATAPI IDENTIFY and SMART commands.
                //

                versionParameters->fCapabilities = (CAP_ATA_ID_CMD | CAP_ATAPI_ID_CMD | CAP_SMART_CMD);

                //
                // This is done because of how the IOCTL_SCSI_MINIPORT
                // determines 'targetid's'. Disk.sys places the real target id value
                // in the DeviceMap field. Once we do some parameter checking, the value passed
                // back to the application will be determined.
                //

                deviceNumber = versionParameters->bIDEDeviceMap;

                if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) ||
                    (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE)) {

                    status = SRB_STATUS_SELECTION_TIMEOUT;
                    break;
                }

                //
                // NOTE: This will only set the bit
                // corresponding to this drive's target id.
                // The bit mask is as follows:
                //
                //     Sec Pri
                //     S M S M
                //     3 2 1 0
                //

                if (deviceExtension->NumberChannels == 1) {
                    if (deviceExtension->PrimaryAddress) {
                        deviceNumber = 1 << Srb->TargetId;
                    } else {
                        deviceNumber = 4 << Srb->TargetId;
                    }
                } else {
                    deviceNumber = 1 << Srb->TargetId;
                }

                versionParameters->bIDEDeviceMap = deviceNumber;

                status = SRB_STATUS_SUCCESS;
                break;
            }

            case IOCTL_SCSI_MINIPORT_IDENTIFY: {

                PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                SENDCMDINPARAMS   cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                ULONG             i;
                UCHAR             targetId;


                if (cmdInParameters.irDriveRegs.bCommandReg == ID_CMD) {

                    //
                    // Extract the target.
                    //

                    targetId = cmdInParameters.bDriveNumber;

                if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) ||
                     (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE)) {

                        status = SRB_STATUS_SELECTION_TIMEOUT;
                        break;
                    }

                    //
                    // Zero the output buffer
                    //

                    for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE - 1); i++) {
                        ((PUCHAR)cmdOutParameters)[i] = 0;
                    }

                    //
                    // Build status block.
                    //

                    cmdOutParameters->cBufferSize = IDENTIFY_BUFFER_SIZE;
                    cmdOutParameters->DriverStatus.bDriverError = 0;
                    cmdOutParameters->DriverStatus.bIDEError = 0;

                    //
                    // Extract the identify data from the device extension.
                    //

                    ScsiPortMoveMemory (cmdOutParameters->bBuffer, &deviceExtension->IdentifyData[targetId], IDENTIFY_DATA_SIZE);

                    status = SRB_STATUS_SUCCESS;


                } else {
                    status = SRB_STATUS_INVALID_REQUEST;
                }
                break;
            }

            case  IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS:
            case  IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS:
            case  IOCTL_SCSI_MINIPORT_ENABLE_SMART:
            case  IOCTL_SCSI_MINIPORT_DISABLE_SMART:
            case  IOCTL_SCSI_MINIPORT_RETURN_STATUS:
            case  IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE:
            case  IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES:
            case  IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS:

                status = IdeSendSmartCommand(HwDeviceExtension,Srb);
                break;

            default :

                status = SRB_STATUS_INVALID_REQUEST;
                break;

        }

        break;

    default:

        //
        // Indicate unsupported command.
        //

        status = SRB_STATUS_INVALID_REQUEST;

        break;

    } // end switch

    //
    // Check if command complete.
    //

    if (status != SRB_STATUS_PENDING) {

        DebugPrint((2,
                   "AtapiStartIo: Srb %x complete with status %x\n",
                   Srb,
                   status));

        //
        // Clear current SRB.
        //

        deviceExtension->CurrentSrb = NULL;

        //
        // Set status in SRB.
        //

        Srb->SrbStatus = (UCHAR)status;

        //
        // Indicate command complete.
        //

        ScsiPortNotification(RequestComplete,
                             deviceExtension,
                             Srb);

        //
        // Indicate ready for next request.
        //

        ScsiPortNotification(NextRequest,
                             deviceExtension,
                             NULL);
    }

    return TRUE;

} // end AtapiStartIo()


SCSI_ADAPTER_CONTROL_STATUS
AtapiAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )

/*++

Routine Description:

    This routine is called at various time's by SCSIPort and is used
        to provide a control function over the adapter. Most commonly, NT
        uses this entry point to control the power state of the HBA during
        a hibernation operation.

Arguments:

    HwDeviceExtension - HBA miniport driver's per adapter storage
    Parameters  - This varies by control type, see below.
    ControlType - Indicates which adapter control function should be
                  executed. Conrol Types are detailed below.

Return Value:

     ScsiAdapterControlSuccess - requested ControlType completed successfully
     ScsiAdapterControlUnsuccessful - requested ControlType failed

--*/


{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_SUPPORTED_CONTROL_TYPE_LIST ControlTypeList;
    ULONG AdjustedMaxControlType;

    ULONG Index;

    //
    // Default Status
    //
    SCSI_ADAPTER_CONTROL_STATUS Status = ScsiAdapterControlSuccess;

    //
    // Structure defining which functions this miniport supports
    //

#define Atapi_TYPE_MAX  5

    BOOLEAN SupportedConrolTypes[Atapi_TYPE_MAX] = {
        TRUE,   // ScsiQuerySupportedControlTypes
        TRUE,   // ScsiStopAdapter
        TRUE,   // ScsiRestartAdapter
        FALSE,  // ScsiSetBootConfig
        FALSE   // ScsiSetRunningConfig
        };

    //
    // Execute the correct code path based on ControlType
    //
    switch (ControlType) {

        case ScsiQuerySupportedControlTypes:

            DebugPrint((1,"AtapiAdapterControl: Query supported control types\n"));

            //
            // This entry point provides the method by which SCSIPort determines the
            // supported ControlTypes. Parameters is a pointer to a
            // SCSI_SUPPORTED_CONTROL_TYPE_LIST structure. Fill in this structure
            // honoring the size limits.
            //
            ControlTypeList = Parameters;
            AdjustedMaxControlType =
                (ControlTypeList->MaxControlType < Atapi_TYPE_MAX) ?
                ControlTypeList->MaxControlType :
                Atapi_TYPE_MAX;
            for (Index = 0; Index < AdjustedMaxControlType; Index++) {
                ControlTypeList->SupportedTypeList[Index] =
                    SupportedConrolTypes[Index];
            }
            break;

        case ScsiStopAdapter:

            DebugPrint((1,"AtapiAdapterControl: Stop adapter\n"));

            //
            // This entry point  is called by SCSIPort when it needs to stop/disable
            // the HBA. Parameters is a pointer to the HBA's HwDeviceExtension. The adapter
            // has already been quiesced by SCSIPort (i.e. no outstanding SRBs). Hence the adapter
            // should abort/complete any internally generated commands, disable adapter interrupts
            // and optionally power down the adapter.
            //

            //
            // It is not possible to disable interrupts. The alternative is to
            // reset the adapter, clear any remaining interrupts and return success.
            //

            if (deviceExtension->CurrentSrb) {

#ifdef  DBG
             // _asm int 3;
#endif
                AtapiResetController(deviceExtension,deviceExtension->CurrentSrb->PathId);
            }

            break;


        case ScsiRestartAdapter:

            DebugPrint((1,"AtapiAdapterControl: Restart adapter\n"));

            //
            // This entry point is called by SCSIPort when it needs to re-enable
            // a previously stopped adapter. In the generic case, previously
            // suspended IO operations should be restarted and the adapter's
            // previous configuration should be reinstated. Our hardware device
            // extension and uncached extensions have been preserved so no
            // actual driver software reinitialization is necesarry.
            //

            AtapiResetController(deviceExtension,0);
            break;

        case ScsiSetBootConfig:

            DebugPrint((1,"AtapiAdapterControl: Set boot config\n"));

            Status = ScsiAdapterControlUnsuccessful;
            break;

        case ScsiSetRunningConfig:

            DebugPrint((1,"AtapiAdapterControl: Set running config\n"));

            Status = ScsiAdapterControlUnsuccessful;
            break;

        case ScsiAdapterControlMax:

            DebugPrint((1,"AtapiAdapterControl: Adapter control max\n"));

            Status = ScsiAdapterControlUnsuccessful;
            break;

        default:
            Status = ScsiAdapterControlUnsuccessful;
            break;
    }

    return Status;
}


ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Installable driver initialization entry point for system.

Arguments:

    Driver Object

Return Value:

    Status from ScsiPortInitialize()

--*/

{
    HW_INITIALIZATION_DATA hwInitializationData;
    ULONG                  adapterCount;
    ULONG                  isaStatus;
    ULONG                  pciStatus;


    DebugPrint((1,"\n\nCardBus/PCMCIA IDE Miniport Driver\n"));

    //
    // Zero out structure.
    //

    AtapiZeroMemory(((PUCHAR)&hwInitializationData), sizeof(HW_INITIALIZATION_DATA));

    //
    // Set size of hwInitializationData.
    //

    hwInitializationData.HwInitializationDataSize =
      sizeof(HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitializationData.HwInitialize = AtapiHwInitialize;
    hwInitializationData.HwResetBus = AtapiResetController;
    hwInitializationData.HwStartIo = AtapiStartIo;
    hwInitializationData.HwInterrupt = AtapiInterrupt;
    hwInitializationData.HwAdapterControl = AtapiAdapterControl;

    //
    // Specify size of extensions.
    //

    hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    hwInitializationData.SpecificLuExtensionSize = sizeof(HW_LU_EXTENSION);

    //
    // Indicate PIO device.
    //

    hwInitializationData.MapBuffers = TRUE;

    hwInitializationData.HwFindAdapter = AtapiFindController;
    hwInitializationData.NumberOfAccessRanges = 2;

    hwInitializationData.AdapterInterfaceType = Isa;
    adapterCount = 0;

    isaStatus = ScsiPortInitialize(DriverObject,
                                   Argument2,
                                   &hwInitializationData,
                                   &adapterCount);

    hwInitializationData.AdapterInterfaceType = PCIBus;
    adapterCount = 0;

    pciStatus = ScsiPortInitialize(DriverObject,
                                   Argument2,
                                   &hwInitializationData,
                                   &adapterCount);

    //
    // Return the smaller status.
    //

    return(pciStatus < isaStatus ? pciStatus : isaStatus);

} // end DriverEntry()



LONG
AtapiStringCmp (
    PCHAR FirstStr,
    PCHAR SecondStr,
    ULONG Count
    )
{
    UCHAR  first ,last;

    if (Count) {
        do {

            //
            // Get next char.
            //

            first = *FirstStr++;
            last = *SecondStr++;

            if (first != last) {

                //
                // If no match, try lower-casing.
                //

                if (first>='A' && first<='Z') {
                    first = first - 'A' + 'a';
                }
                if (last>='A' && last<='Z') {
                    last = last - 'A' + 'a';
                }
                if (first != last) {

                    //
                    // No match
                    //

                    return first - last;
                }
            }
        }while (--Count && first);
    }

    return 0;
}


VOID
AtapiZeroMemory(
    IN PCHAR Buffer,
    IN ULONG Count
    )
{
    ULONG i;

    for (i = 0; i < Count; i++) {
        Buffer[i] = 0;
    }
}


VOID
AtapiHexToString (
    IN ULONG Value,
    IN OUT PCHAR *Buffer
    )
{
    PCHAR  string;
    PCHAR  firstdig;
    CHAR   temp;
    ULONG i;
    USHORT digval;

    string = *Buffer;

    firstdig = string;

    for (i = 0; i < 4; i++) {
        digval = (USHORT)(Value % 16);
        Value /= 16;

        //
        // convert to ascii and store. Note this will create
        // the buffer with the digits reversed.
        //

        if (digval > 9) {
            *string++ = (char) (digval - 10 + 'a');
        } else {
            *string++ = (char) (digval + '0');
        }

    }

    //
    // Reverse the digits.
    //

    *string-- = '\0';

    do {
        temp = *string;
        *string = *firstdig;
        *firstdig = temp;
        --string;
        ++firstdig;
    } while (firstdig < string);
}



PSCSI_REQUEST_BLOCK
BuildMechanismStatusSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;

    srb = &deviceExtension->InternalSrb;

    AtapiZeroMemory((PUCHAR) srb, sizeof(SCSI_REQUEST_BLOCK));

    srb->PathId     = (UCHAR) PathId;
    srb->TargetId   = (UCHAR) TargetId;
    srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
    srb->Length     = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set flags to disable synchronous negociation.
    //
    srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set timeout to 2 seconds.
    //
    srb->TimeOutValue = 4;

    srb->CdbLength          = 6;
    srb->DataBuffer         = &deviceExtension->MechStatusData;
    srb->DataTransferLength = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

    //
    // Set CDB operation code.
    //
    cdb = (PCDB)srb->Cdb;
    cdb->MECH_STATUS.OperationCode       = SCSIOP_MECHANISM_STATUS;
    cdb->MECH_STATUS.AllocationLength[1] = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

    return srb;
}


PSCSI_REQUEST_BLOCK
BuildRequestSenseSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;

    srb = &deviceExtension->InternalSrb;

    AtapiZeroMemory((PUCHAR) srb, sizeof(SCSI_REQUEST_BLOCK));

    srb->PathId     = (UCHAR) PathId;
    srb->TargetId   = (UCHAR) TargetId;
    srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
    srb->Length     = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set flags to disable synchronous negociation.
    //
    srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set timeout to 2 seconds.
    //
    srb->TimeOutValue = 4;

    srb->CdbLength          = 6;
    srb->DataBuffer         = &deviceExtension->MechStatusSense;
    srb->DataTransferLength = sizeof(SENSE_DATA);

    //
    // Set CDB operation code.
    //
    cdb = (PCDB)srb->Cdb;
    cdb->CDB6INQUIRY.OperationCode    = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.AllocationLength = sizeof(SENSE_DATA);

    return srb;
}


ULONG
AtapiParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    )

/*++

Routine Description:

    This routine will parse the string for a match on the keyword, then
    calculate the value for the keyword and return it to the caller.

Arguments:

    String - The ASCII string to parse.
    KeyWord - The keyword for the value desired.

Return Values:

    Zero if value not found
    Value converted from ASCII to binary.

--*/

{
    PCHAR cptr;
    PCHAR kptr;
    ULONG value;
    ULONG stringLength = 0;
    ULONG keyWordLength = 0;
    ULONG index;

    //
    // Calculate the string length and lower case all characters.
    //
    cptr = String;
    while (*cptr) {

        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        stringLength++;
    }

    //
    // Calculate the keyword length and lower case all characters.
    //
    cptr = KeyWord;
    while (*cptr) {

        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        keyWordLength++;
    }

    if (keyWordLength > stringLength) {

        //
        // Can't possibly have a match.
        //
        return 0;
    }

    //
    // Now setup and start the compare.
    //
    cptr = String;

ContinueSearch:
    //
    // The input string may start with white space.  Skip it.
    //
    while (*cptr == ' ' || *cptr == '\t') {
        cptr++;
    }

    if (*cptr == '\0') {

        //
        // end of string.
        //
        return 0;
    }

    kptr = KeyWord;
    while (*cptr++ == *kptr++) {

        if (*(cptr - 1) == '\0') {

            //
            // end of string
            //
            return 0;
        }
    }

    if (*(kptr - 1) == '\0') {

        //
        // May have a match backup and check for blank or equals.
        //

        cptr--;
        while (*cptr == ' ' || *cptr == '\t') {
            cptr++;
        }

        //
        // Found a match.  Make sure there is an equals.
        //
        if (*cptr != '=') {

            //
            // Not a match so move to the next semicolon.
            //
            while (*cptr) {
                if (*cptr++ == ';') {
                    goto ContinueSearch;
                }
            }
            return 0;
        }

        //
        // Skip the equals sign.
        //
        cptr++;

        //
        // Skip white space.
        //
        while ((*cptr == ' ') || (*cptr == '\t')) {
            cptr++;
        }

        if (*cptr == '\0') {

            //
            // Early end of string, return not found
            //
            return 0;
        }

        if (*cptr == ';') {

            //
            // This isn't it either.
            //
            cptr++;
            goto ContinueSearch;
        }

        value = 0;
        if ((*cptr == '0') && (*(cptr + 1) == 'x')) {

            //
            // Value is in Hex.  Skip the "0x"
            //
            cptr += 2;
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                     break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (16 * value) + (*(cptr + index) - '0');
                } else {
                    if ((*(cptr + index) >= 'a') && (*(cptr + index) <= 'f')) {
                        value = (16 * value) + (*(cptr + index) - 'a' + 10);
                    } else {

                        //
                        // Syntax error, return not found.
                        //
                        return 0;
                    }
                }
            }
        } else {

            //
            // Value is in Decimal.
            //
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                    break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (10 * value) + (*(cptr + index) - '0');
                } else {

                    //
                    // Syntax error return not found.
                    //
                    return 0;
                }
            }
        }

        return value;
    } else {

        //
        // Not a match check for ';' to continue search.
        //
        while (*cptr) {
            if (*cptr++ == ';') {
                goto ContinueSearch;
            }
        }

        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\ibm\cd20xrnt\debug.h ===
ULONG PC2xDebug = ( 0xFFF );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\ibm\cd20xrnt\cdbatapi.h ===
/****************************************************************************/
/*                                                                          */
/* Driver Name: PCMCIA ATAPI CDROM Device Driver                            */
/*              --------------------------------                            */
/*                                                                          */
/* Source File Name: CDBATAPI.C                                             */
/*                                                                          */
/* Descriptive Name: ATAPI packet command structure definition              */
/*                                                                          */
/* Function:                                                                */
/*                                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/*                                                                          */
/* Copyright (C) 1994 IBM Corporation                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/*                                                                          */
/* Change Log                                                               */
/*                                                                          */
/* Mark    Date      Programmer  Comment                                    */
/* ----    ----      ----------  -------                                    */
/*                                                                          */
/****************************************************************************/

#pragma pack(push, 1)

/*==========================================================================*/
/* ATAPI Packet Identify Data Structure                                     */
/*==========================================================================*/
typedef struct _PacketID {
   USHORT  Config ;                    /* Word 0 .. General Configuration   */
   USHORT  reserved_1[22] ;            /* Word 1-22 .. Reserved             */
   UCHAR   FWrevision[8] ;             /* Word 23-26 .. Firmware revision   */
   UCHAR   ModelNO[40] ;               /* Word 27-46 .. Model Number        */
   USHORT  reserved_2[2] ;             /* Word 47-48 .. Reserved            */
   USHORT  Capability ;                /* Word 49 .. Capabilities           */
} PacketID,  *pPacketID ;

/*==========================================================================*/
/* ATAPI packet commands for CD-ROM                                         */
/*==========================================================================*/

#define  ATAPI_RESET           0x08

#define  ATAPI_TEST_UNIT_READY 0x00
#define  ATAPI_REQUEST_SENSE   0x03
#define  ATAPI_STARTSTOP       0x1B
#define  ATAPI_PREV_REMOVE     0x1E
#define  ATAPI_INQUIRY         0x12
#define  ATAPI_READCAPACITY    0x25
#define  ATAPI_SEEK            0x2B
#define  ATAPI_READSUBCHANNEL  0x42
#define  ATAPI_READ_TOC        0x43
#define  ATAPI_READ_HEADER     0x44
#define  ATAPI_MODE_SELECT     0x55
#define  ATAPI_MODE_SENSE      0x5A
#define  ATAPI_READ_10         0x28
#define  ATAPI_READ_12         0xA8
//#define  ATAPI_READ_CD         0xD4
#define  ATAPI_READ_CD         0xBE
#define  ATAPI_PLAY_10         0x45
#define  ATAPI_PLAY_MSF        0x47
#define  ATAPI_PLAY_12         0xA5
#define  ATAPI_PAUSE_RESUME    0x4B

/*--------------------------------------------------------------------------*/
/*  Test Unit Ready Command 0x00                                            */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_TestUnitReady {

   UCHAR   OpCode;

   UCHAR   reserved[11];
} ACDB_TestUnitReady, *PACDB_TestUnitReady;

/*--------------------------------------------------------------------------*/
/*  Request Sense Command 0x03                                              */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_RequestSense {

   UCHAR   OpCode;

   UCHAR   reserved_1[3];
   UCHAR   alloc_length;
   UCHAR   reserved_2[7];
} ACDB_RequestSense,  *PACDB_RequestSense ;

/*--------------------------------------------------------------------------*/
/*  Inquiry Command 0x12                                                    */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_Inquiry {

   UCHAR   OpCode;

   UCHAR   EVPD       : 1;
   UCHAR   reserved_1 : 7;

   UCHAR   page_code;
   UCHAR   reserved_2;
   UCHAR   alloc_length;
   UCHAR   reserved_3[7];
} ACDB_Inquiry, *PACDB_Inquiry;

/*--------------------------------------------------------------------------*/
/*  Start/Stop Unit Command 0x1B                                            */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_StartStopUnit {
   UCHAR   OpCode;                     /* = 0x1B                            */

   UCHAR   Immed     : 1;
   UCHAR   reserved_1: 7;

   UCHAR   reserved_2;
   UCHAR   reserved_3;

   UCHAR   start     : 1;
   UCHAR   LoEj      : 1;
   UCHAR   reserved_4: 6;

   UCHAR   reserved[7] ;
} ACDB_StartStopUnit,  *PACDB_StartStopUnit ;

/*--------------------------------------------------------------------------*/
/*  Prevent/Allow Medium Removal Command 0x1E                               */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_PreventAllowRemoval {
   UCHAR   OpCode;

   UCHAR   reserved_1[3] ;
   UCHAR   prevent       : 1;
   UCHAR   reserved_2    : 7;

   UCHAR   reserved_3[7] ;
} ACDB_PreventAllowRemoval,  *PACDB_PreventAllowRemoval ;


/*--------------------------------------------------------------------------*/
/*  Read CD-ROM Capacity Command 0x25                                       */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_ReadCapacity {

   UCHAR   OpCode;

   UCHAR   reserved[11];
} ACDB_ReadCapacity,  * PACDB_ReadCapacity;


/*--------------------------------------------------------------------------*/
/*  Seek Command 0x2B                                                       */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_Seek {
   UCHAR   OpCode;

   UCHAR   reserved_1 ;
   ULONGB  LBA;
   UCHAR   reserved_2[6];
} ACDB_Seek,  * PACDB_Seek ;

/*--------------------------------------------------------------------------*/
/*  Read Sub-Channel Command 0x42                                           */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_ReadSubChannel {

   UCHAR   OpCode;                     /* byte 0 */

   UCHAR   reserved_1  : 1;            /* byte 1 */
   UCHAR   MSF         : 1;
   UCHAR   reserved_2  : 6;

   UCHAR   reserved_3  : 6;            /* byte 2 */
   UCHAR   SubQ        : 1;
   UCHAR   reserved_4  : 1;

   UCHAR   data_format;                /* byte 3 */
   UCHAR   reserved_5;                 /* byte 4 */
   UCHAR   reserved_6;                 /* byte 5 */
   UCHAR   TNO;                        /* byte 6 */
   USHORTB alloc_length;               /* byte 7,8 */
   UCHAR   reserved_7;                 /* byte 9 */
   UCHAR   reserved_8;                 /* byte 10 */
   UCHAR   reserved_9;                 /* byte 11 */
} ACDB_ReadSubChannel,  *PACDB_ReadSubChannel;

/*--------------------------------------------------------------------------*/
/*  Read TOC Command 0x43                                                   */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_ReadTOC {

   UCHAR   OpCode;

   UCHAR   Reserved_1   : 1;
   UCHAR   MSF          : 1;
   UCHAR   Reserved_2   : 6;

   UCHAR   Reserved_3[4] ;

   UCHAR   starting_track;
   USHORTB alloc_length;
   UCHAR   reserved_4   : 6 ;
   UCHAR   format       : 2 ;
   UCHAR   Reserved_5[2] ;
} ACDB_ReadTOC,  *PACDB_ReadTOC ;

/*--------------------------------------------------------------------------*/
/*  Read Heder command 0x44                                                 */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_ReadHeader {
   UCHAR   OpCode;

   UCHAR   reserved_1   : 1;
   UCHAR   MSF          : 1;
   UCHAR   reserved_2   : 6;

   ULONGB  LBA;
   UCHAR   reserved_3;
   USHORTB alloc_length;
   UCHAR   reserved_4[3];
} ACDB_ReadHeader,  *PACDB_ReadHeader;


/*--------------------------------------------------------------------------*/
/*  Mode Select Command 0x55                                                */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_ModeSelect {
   UCHAR   OpCode;

   UCHAR   SP         : 1;
   UCHAR   reserved_1 : 3;
   UCHAR   PF         : 1;
   UCHAR   reserved_2 : 3;
   UCHAR   page_code ;
   UCHAR   reserved_3[4];
   USHORTB parm_length;
   UCHAR   reserved_4[3];
} ACDB_ModeSelect,  *PACDB_ModeSelect;

/*--------------------------------------------------------------------------*/
/*  Mode Sense Command 0x5A                                                 */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_ModeSense {

   UCHAR   OpCode;

   UCHAR   reserved_1 : 8;

   UCHAR   page_code  : 6;
   UCHAR   PC         : 2;

   UCHAR   reserved_2[4];

   USHORTB alloc_length;
   UCHAR   reserved_3[3];
} ACDB_ModeSense, *PACDB_ModeSense ;

/* page code field */
#define  PAGE_CAPABILITY         0x2A
#define  PAGE_AUDIO_CONTROL      0x0E

/*--------------------------------------------------------------------------*/
/*  Mode Parameter Header                                                   */
/*--------------------------------------------------------------------------*/
typedef struct _Mode_Hdr {
   USHORTB   mode_data_length;
   UCHAR     medium_type;
   UCHAR     reserved[5] ;
} Mode_Hdr;

/*--------------------------------------------------------------------------*/
/*  Read (10) Command 0x28                                                  */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_Read_10 {
   UCHAR   OpCode;

   UCHAR   reserved_1;
   ULONGB  LBA;
   UCHAR   reserved_2 ;
   USHORTB transfer_length;
   UCHAR   reserved_3[3];
} ACDB_Read_10,  *PACDB_Read_10 ;

/*--------------------------------------------------------------------------*/
/*  Read (12) Command 0xA8                                                  */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_Read_12 {
   UCHAR   OpCode;

   UCHAR   reserved_1;
   ULONGB  LBA;
   ULONGB  transfer_length;
   UCHAR   reserved_2[2];
} ACDB_Read_12;

/*--------------------------------------------------------------------------*/
/*  Read CD Command 0xD4                                                    */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_Read_CD {
   UCHAR   OpCode;

   UCHAR   reserved_1     : 2;
   UCHAR   user_data_type : 3;
   UCHAR   reserved_2     : 3;
   ULONGB  LBA;
   UCHAR   transfer_length_MSB ;
   USHORTB transfer_length;
   UCHAR   reserved_3  : 1;
   UCHAR   error_flags : 2;
   UCHAR   edc_ecc     : 1;
   UCHAR   user_data   : 1;
   UCHAR   header_code : 2;
   UCHAR   synch_field : 1;
   UCHAR   sub_chan_data : 3;
   UCHAR   reserved_4 : 5;
   UCHAR   reserved_5;
} ACDB_Read_CD,  *PACDB_Read_CD;

/*--------------------------------------------------------------------------*/
/*  Play Audio Command 0x45                                                 */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_PlayAudio_10 {
   UCHAR   OpCode;
   UCHAR   reserved_1 ;
   ULONGB  LBA;
   UCHAR   reserved_2;
   USHORTB transfer_length;
   UCHAR   reserved_3[3] ;
} ACDB_PlayAudio_10,  * PACDB_PlayAudio_10 ;

/*--------------------------------------------------------------------------*/
/*  Play Audio Command 0xA5                                                 */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_PlayAudio_12 {
   UCHAR   OpCode;
   UCHAR   reserved_1 ;
   ULONGB  LBA;
   ULONGB  transfer_length;
   UCHAR   reserved_2[2] ;
} ACDB_PlayAudio_12 ;

/*--------------------------------------------------------------------------*/
/*  Play Audio MSF Command 0x47                                             */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_PlayAudio_MSF {
   UCHAR   OpCode;

   UCHAR   reserved_1[2];
   UCHAR   starting_M;
   UCHAR   starting_S;
   UCHAR   starting_F;
   UCHAR   ending_M;
   UCHAR   ending_S;
   UCHAR   ending_F;
   UCHAR   reserved_2[3] ;
} ACDB_PlayAudio_MSF,  *PACDB_PlayAudio_MSF ;

/*--------------------------------------------------------------------------*/
/*  Pause/Resume Command 0x4Bh                                              */
/*--------------------------------------------------------------------------*/
typedef struct _ACDB_PauseResume {
   UCHAR   OpCode;
   UCHAR   reserved_1[7];
   UCHAR   resume     : 1;
   UCHAR   reserved_2 : 7;
   UCHAR   reserved_3[3] ;
} ACDB_PauseResume,  *PACDB_PauseResume ;

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\hp\fcmngr\fcinc\tach.h ===
#define uchar   unsigned char
#define ulong   unsigned long

#include "ports.h"
#include "tachlite.h"
//
//      Misc Defines
//
#define FCMNGR_VERSION          "0.35"
#define MAX_FC_CHIPS            0x02
#define MAX_INCOMING_DATA       (ulong)((MAX_SDB * SEST_BUFFER_LENGTH) - SEST_BUFFER_LENGTH)

//
// The maximum length an individual SG Write length can be.
//
#define MAX_TACHYON_SG_LENGTH           0xFFFC

//
// For each xid, there is a cmd/data IOP and a status IOP.
//
#ifdef PEGASUS
#define LS_IOPS                 QUEUE_DEPTH
#else
#define LS_IOPS                 32
#endif
#define FCMNGR_MAX_IOPS         (ulong)((QUEUE_DEPTH * 2) + LS_IOPS)
#define MAX_FCPS                (unsigned long)FCMNGR_MAX_IOPS

//
// For Initiators, the Outbound SEST FC Header will come from the FC Header
// in the Status IOP for that XID.
//
#define MAX_TACH_HEADERS        (ulong)(FCMNGR_MAX_IOPS)

#define MAX_DELAYED_LS_CMDS     QUEUE_DEPTH
//
// IOP FCMNGR_STATUS Values. Additional Values are in the Outbound Completion
// Message #defines.
//
#define IOP_STATUS              0x0001
#define IOP_FRAME_UNDERRUN      0x0002
#define IOP_FRAME_OVERRUN       0x0004
#define IOP_TARGET_ALPA_CHANGED 0x0008
#define IOP_TARGET_GONE         0x0020
#define IOP_NEW_ALPA            0x0040

//
//      Outbound Completion Message (Status Field)
//
#define CLASS_CONNECT_OPEN      0x0080
#define PROGRAMMING_ERROR       0x0100
#define RETRIES_EXCEEDED        0x0200
#define FRAME_REJECTED          0x0400
#define FRAME_TIME_OUT          0x0800
#define ACK_TIME_OUT            0x1000
#define ABORT_REQUESTED         0x2000
#define LINK_DOWN               0x4000
#define CLASS_1_ERROR           0x8000

#define IOP_ABORTED             0x00010000
#define IOP_ABORT_FAILED        0x00020000
#define TARGET_STATUS           0x00040000
#define TARGET_IS_RESET         0x00080000
#define IOP_STATUS_MASK         0xFFFFFFF0

//
// IOP FLAGS Values.
//
#define IOP_FREE                0x00000000
#define IOP_COMPLETE            0x00000001
#define IOP_IN_USE              0x00000002
#define IOP_NOT_COMPLETE        0x00000004
#define IOP_CHECK_DATA          0x00000008
#define IOP_ON_QUEUE            0x00000010
#define IOP_WAITING             0x00000020
#define IOP_INTR                0x00000040
#define IOP_ABORT               0x00000080
#define IOP_GONE                0x00000100
#define IOP_ABORT_PROCESSED     0x00000200
#define IOP_RESPONSE            0x00040000
#define IOP_LS_CMD              0x00080000
#define IOP_ANY_COMPLETE        0x000F0000

#define IOP_QUEUED_SAVED        0x00100000
#define IOP_QUEUED_SEND         0x00200000
#define IOP_QUEUED_WAIT         0x00400000

#define IOP_TASK_MANAGEMENT     0x01000000
#define IOP_TARGET_RESET        0x02000000


typedef enum {
    FCMNGR_SCSI = 0x00010000,
    FCMNGR_GENERIC = 0x00020000
} FRAME_TYPE, *PFRAME_TYPE;

//
// FCMNGR Error Codes
//
#define FCMNGR_SUCCESS          0x00
#define FCMNGR_INVALID_ADDR     0x01
#define FCMNGR_INVALID_ROOT     0x02
#define FCMNGR_INVALID_IOP      0x03
#define FCMNGR_INIT_NOT_COMPL   0x04
#define FCMNGR_NO_LOG           0x05
#define FCMNGR_IOP_BUSY         0x06
#define FCMNGR_FAILURE          0x0F
#define FCMNGR_NO_MEMORY        0x10
#define FCMNGR_MEMORY_ALIGNMENT 0x11
#define FCMNGR_HW_NOT_SUPPORTED 0x12
#define FCMNGR_INVALID_XFER     0x13
#define FCMNGR_INVALID_SG_SIZE  0x14
#define FCMNGR_NO_RESOURCES     0x15
#define FCMNGR_NOT_LOGGED_IN    0x16

//
// root phase defines
//
#define FCMNGR_NO_INIT          0x000020
#define FCMNGR_INIT_ROOT        0x000021
#define FCMNGR_GET_MEM_REQ      0x000022
#define FCMNGR_DEFINE_MEMORY    0x000023
#define FCMNGR_INIT_INTR        0x000024
#define FCMNGR_INIT_COMPLETE    0x000040

#define FCMNGR_FIRST_RESET      0x000080
#define FCMNGR_ID_CHANGE        0x010000
#define REESTABLISHING_LOGINS   0x020000
#define FCMNGR_OFFLINE          0x040000
#define FCMNGR_RESET            0x100000
#define INITIALIZATION          0x200000
#define ON_A_LOOP               0x400000
#define FINDING_OTHERS          0x800000
#define STATE_MASK              0xF00000

//
// Log Codes
//
#define FCMNGR_LOG_UNKNOWN_INTR         0x01
#define FCMNGR_LOG_BAD_SCSI_FRAME       0x04
#define FCMNGR_FATAL_ERROR              0x06
#define FCMNGR_HW_ERROR                 0x07
#define FCMNGR_WARNING                  0x09
#define FCMNGR_WARNING_LIP              0x109
#define FCMNGR_WARNING_E_STORE          0x209
#define FCMNGR_WARNING_OUT_SYNC         0x309
#define FCMNGR_WARNING_LASER_FAULT      0x409
#define FCMNGR_WARNING_LOOP_TIMEOUT     0x509
#define FCMNGR_WARNING_LOOP_FAILURE     0x609
#define FCMNGR_WARNING_OFFLINE          0x709
#define FCMNGR_LOGGED_IN                0x0A
#define FCMNGR_UNKNOWN_SFS_FRAME        0x0B
#define FCMNGR_SCSI_CMD                 0x0C
#define FCMNGR_SCSI_DATA                0x0D
#define FCMNGR_UNKNOWN_MFS_FRAME        0x0E
#define FCMNGR_ABORT_REQUEST            0x0F
#define FCMNGR_FREE_BUFFERS             0x10
#define FCMNGR_MY_ALPA                  0x20
#define FCMNGR_RESET_LOGINS             0x21
#define FCMNGR_TARGET_RESET_COMPLETE    0x22
#define FCMNGR_TARGET_RESET_FAILED      0x23
#define FCMNGR_LOGGED_OUT               0x24

//
// Reset Flags
//
#define FCMNGR_SOFT_RESET       0x01
#define FCMNGR_HARD_RESET       0x02
#define FCMNGR_TARGET_RESET     0x04

//
// Defines for returning the current Fibre Channel Loop Status
//
#define FULL_SPEED      0x30000000
#define LINK_UP         0x00
#define LOS             0x00
#define LOOP_PORT_STATE 0x00
#define LOOP_BYPASS     0x00
#define LOOP_ACCESS     0x00
#define DUPLEX          0x00
#define REPLICATE       0x00
//
// FCMNGR Interface Flags (For Target Code)
//
#define NEW_CDB                 0x01
#define FCMNGR_SEND_DATA        0x02
#define FCMNGR_GET_DATA         0x04
#define FCMNGR_SEND_STATUS      0x08

#define INITIATOR       0x00
#define TARGET          0x01

//
// Product ID's
//
#define JAGUAR          0xA0EC
#define JAGULAR         0xA0FB

#define SOFC1           0x030
#define SOFI1           0x050
#define SOFI2           0x060
#define SOFI3           0x070
#define SOFN1           0x090
#define SOFN2           0x0A0
#define SOFN3           0x0B0

#define EOFDT           0x01
#define EOFA            0x04
#define EOFN            0x05
#define EOFT            0x06

#define MAX_ALPA_VALUE  0xF0
//
//      Incoming Buffer Defines
//
#define FRAME_SIZE              0x3A0   // Maximum Frame Size. Per Bill
#define SFBQ_BUFFER_LENGTH      (ulong)0x200
#define MFSBQ_BUFFER_LENGTH     (ulong)0x200

//
//      Logical Drive defines
//
#define PERIPHERAL_DEVICE_ADDRESSING    0x00
#define VOLUME_SET_ADDRESSING           0x40
#define LOGICAL_UNIT_ADDRESSING         0x80

//
//      IMQ Interrupt Types
//
#define OUTBOUND_COMPLETE               0x000
#define OUTBOUND_COMPLETE_I             0x100
#define OUTBOUND_HI_PRI_COMPLETE        0x001
#define OUTBOUND_HI_PRI_COMPLETE_I      0x101

#define INBOUND_MFS_COMPLETE            0x002
#define INBOUND_OOO_COMPLETE            0x003
#define INBOUND_COMPLETION              0x004
#define INBOUND_C1_TIMEOUT              0x005
#define INBOUND_UNKNOWN_FRAME           0x006
#define INBOUND_BUSIED_FRAME            0x006

#define SFS_BUF_WARN                    0x007
#define MFS_BUF_WARN                    0x008
#define IMQ_BUF_WARN                    0x009

#define FRAME_MANAGER_INTR              0x00A
#define READ_STATUS                     0x00B
#define INBOUND_SCSI_DATA_COMPLETE      0x00C
#define INBOUND_SCSI_COMMAND            0x00D
#define BAD_SCSI_FRAME                  0x00E
#define INBOUND_SCSI_STAT_COMPLETE      0x00F

//
//      Queue Depths
//
#define HPCQ_DEPTH              (ulong)0x08
#define MFSBQ_DEPTH             (ulong)0x04
#define SEST_DEPTH              (ulong)QUEUE_DEPTH

//
// Tachyon Register Offsets
//
#define OCQ_BASE                0x00
#define OCQ_LENGTH              0x04
#define OCQ_PRODUCER_INDEX      0x08
#define OCQ_CONSUMER_INDEX      0x0C

#define HPCQ_BASE               0x40
#define HPCQ_LENGTH             0x44
#define HPCQ_PRODUCER_INDEX     0x48
#define HPCQ_CONSUMER_INDEX     0x4C

#define IMQ_BASE                0x80
#define IMQ_LENGTH              0x84
#define IMQ_CONSUMER_INDEX      0x88
#define IMQ_PRODUCER_INDEX      0x8C

#define MFSBQ_BASE              0xC0
#define MFSBQ_LENGTH            0xC4
#define MFSBQ_PRODUCER_INDEX    0xC8
#define MFSBQ_CONSUMER_INDEX    0xCC
#define MFSBQ_BUFFER_LENGTH_REG 0xD0

#define SFBQ_BASE               0x000
#define SFBQ_LENGTH             0x004
#define SFBQ_PRODUCER_INDEX     0x008
#define SFBQ_CONSUMER_INDEX     0x00C
#define SFBQ_BUFFER_LENGTH_REG  0x010

#define SEST_BASE               0x040
#define SEST_LENGTH             0x044
#define SEST_BUFFER_LENGTH_REG  0x048

#define TYCNTL_CONFIG           0x084
#define TYCNTL_CONTROL          0x088
#define TYCNTL_STATUS           0x08C
#define FLUSH_OXID              0x090
#define EE_CR0_TMR              0x094
#define BB_CR0_TMR              0x098
#define RX_FRAME_ERR            0x09C

#define FMCNTL_CONFIG           0x0C0
#define FMCNTL_CONTROL          0x0C4
#define FMCNTL_STATUS           0x0C8
#define FMCNTL_TOV              0x0CC
#define FMCNTL_LINK_STATUS1     0x0D0
#define FMCNTL_LINK_STATUS2     0x0D4
#define WWNAME_HI               0x0E0
#define WWNAME_LO               0x0E4
#define FMCNTL_AL_PA            0x0E8
#define FMCNTL_PRIMITIVE        0x0EC

//
//      ODB CONTROL Defines
//
#define ODB_CLASS_1             0x40000000
#define ODB_CLASS_2             0x80000000
#define ODB_CLASS_3             0xC0000000
#define XID_INTERLOCK           0x20000000
#define ODB_SOFC1               0x10000000
#define ODB_END_CONNECTION      0x8000000
#define ODB_NO_COMP             0x4000000
#define ODB_NO_INT              0x2000000
#define ODB_ACK0                0x1000000
#define FILL_BYTES_USED         0xC00000
#define ODB_CONT_SEQ            0x100000
#define ODB_EE_CREDIT           0x0F0000

//
//      SEST Defines
//

#define SCSI_VALID              0x80000000
#define SDB_ERROR               0x40000000
#define INBOUND_SCSI            0x20000000
#define X_ID_MASK               0xDFFF
#define INBOUND_SCSI_XID        0x4000
#define NOT_SCSI_XFER           0x8000

//
//      EDB Defines
//
#define EDB_END_BIT             0x80000000
#define EDB_HEADER_BIT          0x40000000
#define EDB_FRAME_BOUNDARY_BIT  0x20000000

//
//      Tachyon Header Defines
//
#define TACHYON_TS_VALID                0x100
#define TACHYON_LOOP_CREDIT_MASK        0x07
#define TACHYON_LOOP_CREDIT_SHIFT       0x0A
#define TACHYON_LOOP_CLOSE              0x2000
#define TACHYON_UNFAIR_ACCESS           0x4000
#define TACHYON_DISABLE_CRC             0x8000
//
//      Control Register Defines (TYCNTL)
//
//      TYCNTL Config Register Defines
//
#define SCSI_ASSIST             0x40000000
#define DISABLE_P_BSY           0x01000000

#define SCSI_AUTO_ACK           0x1000
#define OOO_DISABLE             0x40
#define ACK_DISABLE             0x20
#define RETRY_DISABLE           0x10
#define POINT_TO_POINT          0x08
#define PARITY_ENABLE           0x04
#define STACKED_CONNECTS        0x01

//
//      TYCNTL Control Register Defines
//
#define STATUS_REQUEST          0x01
#define ERROR_RELEASE           0x02
#define OCQ_RESET               0x04
#define SCSI_FREEZE             0x08
#define SOFTWARE_RESET          0x80000000

//
//      TYCNTL Status Register Defines
//
#define OSM_FROZEN              0x01
#define CHIP_REVISION_MASK      0x0E
#define RECEIVE_FIFO_EMPTY      0x10
#define OCQ_RESET_STATUS        0x20
#define SCSI_FREEZE_STATUS      0x40
#define TY_FATAL_ERROR          0xF80
#define SEND_FIFO_EMPTY         0x1000

//
//      TYCNTL Flush OX_ID Cache Entry Register Defines
//
#define FLUSH_IN_PROGRESS       0x80000000

//
//      TYCNTL EE Credit Zero Timer Register Defines
//
#define EE_CR0_TMR_MASK         0xFFFFFF

//
//      TYCNTL BB Credit Zero Timer Register Defines
//
#define BB_CR0_TMR_MASK         0xFFFFFF

//
//      TYCNTL Receive Frame Error Count Register Defines
//
#define RX_FRAME_ERR_MASK       0xFFFF0000

//
//      Frame Manager Register Defines (FMCNTL)
//
//      Frame Manager Configuration Register
//
#define FMCNTL_ALPA_MASK                0xFF000000
#define FMCNTL_BB_CREDIT_MASK           0x00FF0000
#define FMCNTL_N_PORT                   0x000   // x8000 to be an N-Port
#define FMCNTL_INTERNAL_LB              0x4000
#define FMCNTL_EXTERNAL_LB              0x2000
#define TIMER_DISABLE                   0x800
#define FMCNTL_FABRIC_ACQ_ADDR          0x400
#define PREV_ACQ_ADDR                   0x200
#define PREFERRED_ADDR                  0x100
#define SOFT_ADDR                       0x80
#define RESP_FABRIC_ADDR                0x20
#define INIT_AS_FABRIC                  0x10
#define FMCNTL_LOGIN_REQ                0x08
#define NON_PARTICIPATING               0xFFFFF87F

//
//      Frame Manager Control Register
//
#define FMCNTL_PRIM_SEQ                 0x40
#define FMCNTL_SEND_PRIM_REG            0x20
#define FMCNTL_NO_CLOSE_LOOP            0x10
#define FMCNTL_CLOSE_LOOP               0x08
#define FMCNTL_NOP                      0x00
#define FMCNTL_HOST_CNTRL               0x02
#define FMCNTL_EXIT_HOST_CNTRL          0x03
#define FMCNTL_LINK_RESET               0x04
#define FMCNTL_OFFLINE                  0x05
#define FMCNTL_INIT                     0x06
#define FMCNTL_CLEAR_LF                 0x07

//
//      Frame Manager Status Register
//

#define FMCNTL_STATUS_LOOP              0x80000000
#define FMCNTL_TX_PAR_ERR               0x40000000
#define FMCNTL_NON_PARTICIPATE          0x20000000
#define FMCNTL_PARALLEL_ID              0x18000000

#define FMCNTL_STATUS_MASK              0x07FFFF00
#define LINK_FAULT                      0x04000000
#define OUT_OF_SYNC                     0x02000000
#define LOSS_SIGNAL                     0x01000000
#define NOS_OLS                         0x00080000
#define LOOP_TIMEOUT                    0x00040000
#define FMCNTL_LIPf                     0x00020000
#define BAD_ALPA                        0x00010000
#define FMCNTL_PRIM_REC                 0x00008000
#define FMCNTL_PRIM_SENT                0x00004000
#define FMCNTL_FABRIC_LOGIN_REQ         0x00002000
#define LINK_FAILURE                    0x00001000
#define FMCNTL_CREDIT_ERROR             0x00000800
#define ELASTIC_STORE_ERR               0x00000400
#define FMCNTL_LINK_UP                  0x00000200
#define FMCNTL_LINK_DOWN                0x00000100
#define FMCNTL_HOST_CONTROL             0x000000C0

#define LOOP_STATE_MASK                 0xF0
#define PORT_STATE_MASK                 0x0F

//
// Loop State Defines
//
#define MONITORING                      0x00000000
#define ARBITRATING                     0x00000010
#define ARBITRATION_WON                 0x00000020
#define LOOP_OPEN                       0x00000030
#define LOOP_OPENED                     0x00000040
#define XMITTED_CLOSE                   0x00000050
#define CLOSE_RECEIVED                  0x00000060
#define LOOP_TRANSFER                   0x00000070
#define INITIALIZING                    0x00000080
#define O_I_INIT_FINISH                 0x00000090
#define O_I_INIT_PROTOCOL               0x000000A0
#define O_I_LIP_RECEIVED                0x000000B0
#define HOST_CONTROL                    0x000000C0
#define LOOP_FAIL                       0x000000D0
#define OLD_PORT                        0x000000F0
//
//      Frame Manager Round Trip & Error Detect Time Out Register
//
#define FMCNTL_RT_TOV_MASK              0x1FF0000
#define FMCNTL_ED_TOV_MASK              0xFFFF

//
//      Frame Manager Link Error Status 1 Register
//
#define FMCNTL_STATUS1_LFC_MASK         0x0F            // Link Fail Count
#define FMCNTL_STATUS1_LSC_MASK         0xFF0           // Loss of Sync Count
#define FMCNTL_STATUS1_BCC_MASK         0xFF000         // Bad Tx Character Cnt
#define FMCNTL_STATUS1_LSS_MASK         0xFF00000       // Loss of Signal Count

//
//      Frame Manager Link Error Status 2 Register
//
#define FMCNTL_STATUS2_PEC_MASK         0x0F            // Protocol Error Count
#define FMCNTL_STATUS2_BAD_CRC          0xFF0           // Bad CRC Count
#define FMCNTL_STATUS2_GEN_EOFA         0xFF000         // Generated EOFa Count
#define FMCNTL_STATUS2_REC_EOFA         0xFF00000       // Received EOFa Count

//
//      Frame Manager Received AL_PA Register
//
#define FMCNTL_LIPf_ALPA                0xFF            // AL PA of last LIPf
#define BAD_AL_PA_MASK                  0xFF00          // AL PA Not Accepted

#define DOING_RESET     1

#include "taki.h"

//
// If MAX_ENTRIES exceeds 24, the "buffer" variable in init.c will need to be
// made larger.
//
#define MAX_ENTRIES     20              // Number of FC related structures
#define SDBS            0
#define SFBQ_BUFFERS    1
#define OCQ             2
#define IMQ             3
#define HPQ_CONS        4
#define SEST            5
#define MFSBQ_BUFFERS   6
#define OCQ_CONS        7
#define SFBQ            8
#define IMQ_PROD        9
#define MFSBQ           10
#define HPQ             11
#define LOGIN           12
#define PRLI            13
#define LOGOUT          14
#define IOP             15
#define HPFS_INDEX      16
#define PRLO            17
#define ADISC           18
#define STATUS_BUFFER   19
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\ibm\cd20xrnt\cd4xtype.h ===
/*****************************************************************************/
/*                                                                           */
/* Program Name: CD400.MPD : CD400 MiniPort Driver for CDROM Drive           */
/*              ---------------------------------------------------          */
/*                                                                           */
/* Source File Name: CD4XTYPE.H                                              */
/*                                                                           */
/* Descriptive Name: Type definition                                         */
/*                                                                           */
/* Function:                                                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Copyright (C) 1996 IBM Corporation                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Change Log                                                                */
/*                                                                           */
/* Mark Date      Programmer  Comment                                        */
/*  --- ----      ----------  -------                                        */
/*  000 01/01/96  S.Fujihara  Start Coding                                   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#pragma pack(push, 1)

#ifdef DBG

#define PC2DebugPrint(MASK, ARGS)   ScsiDebugPrint ARGS
//#define PC2DebugPrint(MASK, ARGS)    \
//       if (MASK & PC2xDebug) {    \
//       ScsiDebugPrint ARGS;    \
//       }

#else

#define PC2DebugPrint(MASK, ARGS)

#endif




typedef struct _CMD_FLAG {
               USHORT       dir : 2  ;
               USHORT   timeout : 1  ;
               USHORT         r : 13 ;
} CMD_FLAG;

typedef struct _CD400_LU_EXTENSION{
               ULONG   CurrentDataPointer;
               ULONG   CurrentDataLength;
               ULONG   SavedDataPointer;   //<<
               USHORT  CurrentBlockLength;
               PSCSI_REQUEST_BLOCK   pLuSrb;
               USHORT   AtapiCmd[12];
               UCHAR    AtapiBuffer[512];
               CMD_FLAG   CmdFlag;
               UCHAR   CmdMask;
               UCHAR   CmdErrorStatus;
               UCHAR   StatusReg;
               UCHAR   ErrorReg;
               UCHAR   CommandType;
} CD400_LU_EXTENSION, *PCD400_LU_EXTENSION;


typedef struct _CD400_DEV_EXTENSION {
               PUCHAR  BaseAddress;
               ULONG   IO_Ports[11];
               ULONG    DataPointer;
               ULONG    DataLength;
               UCHAR    PathId;
               CD400_LU_EXTENSION   LuExt;
} CD400_DEV_EXTENSION, *PCD400_DEV_EXTENSION;


#define IOBASE_OFFSET   0x10

#define ON  1
#define OFF 0

#define  CD_SUCCESS  0
#define  CD_FAILURE  1

//#define  MAX_TRANSFER_LENGTH  (2 * 2048)       /* 64K */
#define  MAX_TRANSFER_LENGTH  (64 * 1024)       /* 64K */
//#define  MAX_TRANSFER_LENGTH  0xFFFFFFFF       /* unlimited */
#define  SCSI_INITIATOR_ID    7


#define  TIMEOUT_FOR_READY    1 * 1000 * 1000       /*  1000 msec on 486DX2/50MHz*/
#define  INTERRUPT_TIMEOUT   10 * 1000 * 1000


#define  NORMAL_CMD          0
#define  IMMEDIATE_CMD       1

#define  DATA_REG        0
#define  FEATURE_REG     1
#define  INTREASON_REG   2
#define  BCLOW_REG       4
#define  BCHIGH_REG      5
#define  DVSEL_REG       6
#define  CMD_REG         7
#define  STATUS_REG      8
#define  ERROR_REG       9
#define  INTMASK_REG     10
#define  INTMASK_OFFSET  8
#define  CDMASK_ON       3      //<<
#define  CMD_ERROR       1      //<<

#define  COMMAND_SUCCESS          0
#define  DRIVE_NOT_READY          1
#define  COMMUNICATION_TIMEOUT    2
#define  PROTOCOL_ERROR           3
#define  ATAPI_COMMAND_ERROR      4


typedef union _ULONGB  {                           /* to pick apart a long */
   ULONG     dword;
   struct {
     USHORT  word_0;
     USHORT  word_1;
   } ulbwords;
   struct {
     UCHAR   byte_0;
     UCHAR   byte_1;
     UCHAR   byte_2;
     UCHAR   byte_3;
   } ulbytes;
} ULONGB ;


typedef union _ULONGW  {
   ULONG     dword;
   struct {
     USHORT  word_0;
     USHORT  word_1;
   } ulwords;
} ULONGW ;

typedef struct  _bytes {
   UCHAR     byte_0;
   UCHAR     byte_1;
} bytes ;

typedef union _USHORTB {
   USHORT          word;
   struct {
     UCHAR   byte_0;
     UCHAR   byte_1;
   } usbytes;
} USHORTB ;

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\ibm\cd20xrnt\exec_io.c ===
/*****************************************************************************/
/*                                                                           */
/* Program Name: CD400.MPD : CD400 MiniPort Driver for CDROM Drive           */
/*              ---------------------------------------------------          */
/*                                                                           */
/* Source File Name: EXEC_IO.C                                               */
/*                                                                           */
/* Descriptive Name: SCSI Request Block Handler                              */
/*                                                                           */
/* Function:                                                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Copyright (C) 1996 IBM Corporation                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Change Log                                                                */
/*                                                                           */
/* Mark Date      Programmer  Comment                                        */
/*  --- ----      ----------  -------                                        */
/*  000 01/01/96  S.Fujihara  Start Coding                                   */
/*                                                                           */
/*  300 03/30/99  S.Fujihara  For Win2000                                    */
/*  401 07/21/99  S.Fujihara  Evaluate actual transferred length             */
/*****************************************************************************/

//#define DBG 1

#include <ntddk.h>
//#include <miniport.h>
#include <scsi.h>

#include "debug.h"
#include "cd4xtype.h"
#include "cdbatapi.h"
#include "proto.h"



#if 0
ULONG CD400ParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    )

/*++

Routine Description:

    This routine will parse the string for a match on the keyword, then
    calculate the value for the keyword and return it to the caller.

Arguments:

    String - The ASCII string to parse.
    KeyWord - The keyword for the value desired.

Return Values:

    Zero if value not found
    Value converted from ASCII to binary.

--*/

{
    PCHAR cptr;
    PCHAR kptr;
    ULONG value;
    ULONG stringLength = 0;
    ULONG keyWordLength = 0;
    ULONG index;

    //
    // Calculate the string length and lower case all characters.
    //
    cptr = String;
    while (*cptr) {

        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        stringLength++;
    }

    //
    // Calculate the keyword length and lower case all characters.
    //
    cptr = KeyWord;
    while (*cptr) {

        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        keyWordLength++;
    }

    if (keyWordLength > stringLength) {

        //
        // Can't possibly have a match.
        //
        return 0;
    }

    //
    // Now setup and start the compare.
    //
    cptr = String;

ContinueSearch:
    //
    // The input string may start with white space.  Skip it.
    //
    while (*cptr == ' ' || *cptr == '\t') {
        cptr++;
    }

    if (*cptr == '\0') {

        //
        // end of string.
        //
        return 0;
    }

    kptr = KeyWord;
    while (*cptr++ == *kptr++) {

        if (*(cptr - 1) == '\0') {

            //
            // end of string
            //
            return 0;
        }
    }

    if (*(kptr - 1) == '\0') {

        //
        // May have a match backup and check for blank or equals.
        //

        cptr--;
        while (*cptr == ' ' || *cptr == '\t') {
            cptr++;
        }

        //
        // Found a match.  Make sure there is an equals.
        //
        if (*cptr != '=') {

            //
            // Not a match so move to the next semicolon.
            //
            while (*cptr) {
                if (*cptr++ == ';') {
                    goto ContinueSearch;
                }
            }
            return 0;
        }

        //
        // Skip the equals sign.
        //
        cptr++;

        //
        // Skip white space.
        //
        while ((*cptr == ' ') || (*cptr == '\t')) {
            cptr++;
        }

        if (*cptr == '\0') {

            //
            // Early end of string, return not found
            //
            return 0;
        }

        if (*cptr == ';') {

            //
            // This isn't it either.
            //
            cptr++;
            goto ContinueSearch;
        }

        value = 0;
        if ((*cptr == '0') && (*(cptr + 1) == 'x')) {

            //
            // Value is in Hex.  Skip the "0x"
            //
            cptr += 2;
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                     break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (16 * value) + (*(cptr + index) - '0');
                } else {
                    if ((*(cptr + index) >= 'a') && (*(cptr + index) <= 'f')) {
                        value = (16 * value) + (*(cptr + index) - 'a' + 10);
                    } else {

                        //
                        // Syntax error, return not found.
                        //
                        return 0;
                    }
                }
            }
        } else {

            //
            // Value is in Decimal.
            //
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                     break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (10 * value) + (*(cptr + index) - '0');
                } else {

                    //
                    // Syntax error return not found.
                    //
                    return 0;
                }
            }
        }

        return value;
    } else {

        //
        // Not a match check for ';' to continue search.
        //
        while (*cptr) {
            if (*cptr++ == ';') {
                goto ContinueSearch;
            }
        }

        return 0;
    }
}
#endif






/*************************************************************************
* Routine Name:
*
*    CD4xResetBus
*
* Routine Description:
*
*    Reset CD400 CDROM Drive by ATAPI Reset command, then reset
*    Interrupt Mask Regiter.
*
* Arguments:
*    Context -   The adapter specific information.
*    PathId  -   SCSI Bus ID.
*
* Return Value:
*
*    TRUE
*
*************************************************************************/

BOOLEAN  CD4xResetBus( IN PVOID Context, IN ULONG PathId )

{
   PCD400_DEV_EXTENSION pDevExt = Context;
   PULONG   IO_Ports = pDevExt->IO_Ports;

   PC2DebugPrint(0x800, (3, "CD4xResetBus  \n"));

   pDevExt->LuExt.CurrentBlockLength = 2048;
   ScsiPortWritePortUchar( (PUCHAR)IO_Ports[CMD_REG], ATAPI_RESET );
   ScsiPortWritePortUchar( (PUCHAR)IO_Ports[INTMASK_REG], CDMASK_ON );

   //
   // Complete all outstanding requests with SRB_STATUS_BUS_RESET.
   //
   ScsiPortCompleteRequest( pDevExt,
                           (UCHAR) PathId,
                           (UCHAR) -1,
                           (UCHAR) -1,
                           SRB_STATUS_BUS_RESET);

   ScsiPortNotification(  NextRequest,
                          pDevExt,
                          NULL      );
   return TRUE;

}

/*************************************************************************
* Routine Name:
*
*    CD4xInitialize
*
* Routine Description:
*
*    Initialize CD400 CDROM Drive with ATAPI_RESET command, then
*    reset InterruptMask register.
*
* Arguments:
*    Context -   The adapter specific information.
*
* Return Value:
*
*    TRUE
*
*************************************************************************/

BOOLEAN  CD4xInitialize( IN PVOID Context )
{
   PCD400_DEV_EXTENSION pDevExt = Context;
   PULONG   IO_Ports = pDevExt->IO_Ports;

   pDevExt->LuExt.CurrentBlockLength = 2048;
   ScsiPortWritePortUchar( (PUCHAR)IO_Ports[CMD_REG], ATAPI_RESET );
   ScsiPortWritePortUchar( (PUCHAR)IO_Ports[INTMASK_REG], CDMASK_ON );

   ScsiPortNotification(ResetDetected, (PVOID)pDevExt );

   return TRUE;
}

/*************************************************************************
* Routine Name:
*
*    CD4xFindAdapter
*
* Routine Description:
*    Called by the OS-specific port driver after the necessary storage has
*    been allocated, to gather information about the adapter's configuration.
*
* Arguments:
*
*    DeviceExtension -   The device specific context for the call.
*    Context   -         Passed through from the driver entry as additional
*                        context for the call.
*    BusInformation  -   Unused.
*    ArgumentString  -   Points to the potential IRQ for this adapter.
*    ConfigInfo      -   Pointer to the configuration information structure to
*                        be filled in.
*    Again           -   Returns back a request to call this function again.
*
* Return Value:
*
*    SP_RETURN_FOUND     - if an adapter is found.
*    SP_RETURN_NOT_FOUND - if no adapter is found.
*
*************************************************************************/
ULONG  CD4xFindAdapter(
              PCD400_DEV_EXTENSION pDevExt ,
              IN PVOID             Context,
              IN PVOID             BusInformation,
              IN PCHAR             ArgumentString,
              IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
              OUT PBOOLEAN         Again          )
{
   SHORT    i;
   PULONG   IO_Ports = pDevExt->IO_Ports;
   ULONG    basePort;
   ULONG    irq;


#if 0
   if (ArgumentString != NULL) {
      irq = CD400ParseArgumentString(ArgumentString, "irq");
      if( irq )
         ConfigInfo->BusInterruptLevel = irq;
   }
#endif


   if (ScsiPortConvertPhysicalAddressToUlong(
          (*ConfigInfo->AccessRanges)[0].RangeStart) != 0) {

            basePort = (ULONG)ScsiPortGetDeviceBase(
                   pDevExt,
                   ConfigInfo->AdapterInterfaceType,
                   ConfigInfo->SystemIoBusNumber,
                   (*ConfigInfo->AccessRanges)[0].RangeStart,
                   (*ConfigInfo->AccessRanges)[0].RangeLength,
                   (BOOLEAN) !((*ConfigInfo->AccessRanges)[0].RangeInMemory));
   }
   else{
      return( SP_RETURN_NOT_FOUND );
   }

   *Again = FALSE;

   if( basePort == 0 )
      return( SP_RETURN_NOT_FOUND );

   pDevExt->BaseAddress = (PUCHAR)basePort + IOBASE_OFFSET;

   for( i=0 ; i<8 ; i++ )
     IO_Ports[i] = (ULONG)(pDevExt->BaseAddress + i);
   IO_Ports[STATUS_REG]  = IO_Ports[CMD_REG];
   IO_Ports[ERROR_REG]   = IO_Ports[FEATURE_REG];
   IO_Ports[INTMASK_REG] = IO_Ports[DATA_REG]+INTMASK_OFFSET;

   ConfigInfo->InterruptMode = Latched;
   ConfigInfo->MaximumTransferLength = MAX_TRANSFER_LENGTH;
   ConfigInfo->NumberOfPhysicalBreaks = 1L;   // <<<<
   ConfigInfo->DmaChannel    = (unsigned long)-1L;
   ConfigInfo->DmaPort  = 0;
   ConfigInfo->AlignmentMask = 1;
   ConfigInfo->NumberOfBuses = 1;
   ConfigInfo->InitiatorBusId[0] = SCSI_INITIATOR_ID;
   ConfigInfo->ScatterGather = FALSE;
   ConfigInfo->Master = FALSE;
   ConfigInfo->AdapterScansDown = FALSE;
   ConfigInfo->AtdiskPrimaryClaimed = FALSE;
   ConfigInfo->AtdiskSecondaryClaimed = FALSE;
   ConfigInfo->Dma32BitAddresses = FALSE;
   ConfigInfo->DemandMode = FALSE;
   ConfigInfo->BufferAccessScsiPortControlled = TRUE;


   PC2DebugPrint(0x20, (2, "Exit FindAdapter.\n"));

   return(SP_RETURN_FOUND);

}

/*************************************************************************
* Routine Name:
*
*    CD4xAbort
*
* Routine Description:
*
*    Abort corrent CD400 Command Execution by ATAPI RESET command.
*
* Arguments:
*    Context -   The adapter specific information.
*
* Return Value:
*
*    TRUE
*
*************************************************************************/
BOOLEAN CD4xAbort( PCD400_DEV_EXTENSION pDevExt )
{
   PULONG   IO_Ports = pDevExt->IO_Ports;

   ScsiPortWritePortUchar( (PUCHAR)IO_Ports[CMD_REG], ATAPI_RESET );
   pDevExt->LuExt.pLuSrb->SrbStatus = SRB_STATUS_ABORT_FAILED;

   PC2DebugPrint(0x20, (3, "CD4xAbort.\n"));

   return TRUE;

}


/*==========================================================================*/
/*  CD4xTimer                                                               */
/*    Function  : Timer Service for Timeout                                 */
/*    Caller    :                                                           */
/*    Arguments :                                                           */
/*    Returns   :                                                           */
/*==========================================================================*/
VOID CD4xTimer( PCD400_DEV_EXTENSION pDevExt )
{
   PULONG   IO_Ports = pDevExt->IO_Ports;

   pDevExt->LuExt.CurrentBlockLength = 2048;
   ScsiPortWritePortUchar( (PUCHAR)IO_Ports[CMD_REG], ATAPI_RESET );
   ScsiPortWritePortUchar( (PUCHAR)IO_Ports[INTMASK_REG], CDMASK_ON );

   pDevExt->LuExt.pLuSrb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
   pDevExt->LuExt.pLuSrb->SrbStatus = SRB_STATUS_TIMEOUT;

   ScsiPortNotification(RequestComplete,
                        (PVOID) pDevExt,
                        pDevExt->LuExt.pLuSrb );

   ScsiPortNotification(NextRequest,
                        pDevExt,
                        NULL);

   return;

}


/*************************************************************************
* Routine Name:
*
*    CD4xStartExecution
*
* Routine Description:
*
*    This routine is called from the CD4xStartIo to execute SCSI command.
*
* Arguments:
*    pDevExt -   CD400 device specific extension.
*
* Return Value:
*
*    TRUE
*
*************************************************************************/
USHORT
CD4xStartExecution( PCD400_DEV_EXTENSION pDevExt )
{

   PCDB pCDB = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   USHORT  ret_code = CD_SUCCESS;
   pDevExt->LuExt.CmdErrorStatus = COMMAND_SUCCESS;

   switch( pCDB->CDB6READWRITE.OperationCode ){
     case SCSIOP_TEST_UNIT_READY :
        ret_code = TestUnitReady( pDevExt );
        break;
     case SCSIOP_REQUEST_SENSE :
        ret_code = RequestSense( pDevExt );
        break;
     case SCSIOP_READ6 :
        ret_code = Read6( pDevExt );
        break;
     case SCSIOP_READ  :
        ret_code = Read10( pDevExt );
        break;
     case SCSIOP_SEEK :
        ret_code = Seek( pDevExt );
        break;
     case SCSIOP_INQUIRY :
        ret_code = Inquiry( pDevExt );
        break;
     case SCSIOP_MODE_SELECT :
        ret_code = ModeSelect( pDevExt );
        break;
     case SCSIOP_MODE_SENSE :
        ret_code = ModeSense( pDevExt );
        break;
     case SCSIOP_START_STOP_UNIT :
        ret_code = StartStopUnit( pDevExt );
        break;
     case SCSIOP_MEDIUM_REMOVAL :
        ret_code = MediumRemoval( pDevExt );
        break;
     case SCSIOP_READ_CAPACITY :
        ret_code = ReadCapacity( pDevExt );
        break;
     case SCSIOP_READ_SUB_CHANNEL :
        ret_code = ReadSubChannel( pDevExt );
        break;
     case SCSIOP_READ_TOC :
        ret_code = ReadToc( pDevExt );
        break;
     case SCSIOP_READ_HEADER :
        ret_code = ReadHeader( pDevExt );
        break;
     case SCSIOP_PLAY_AUDIO :
        ret_code = PlayAudio( pDevExt );
        break;
     case SCSIOP_PLAY_AUDIO_MSF :
        ret_code = PlayAudioMsf( pDevExt );
        break;
     case SCSIOP_PAUSE_RESUME :
        ret_code = PauseResume( pDevExt );
        break;
     default :

        pDevExt->LuExt.pLuSrb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
        pDevExt->LuExt.pLuSrb->SrbStatus = SRB_STATUS_ERROR;

        ret_code = CD_FAILURE;
                                    // force unsupported command issued to
                                    // CD400 to generate ILLEGAL REQUEST
                                    // sense key and sense code for following
                                    // Request Sense command.
        break;
   }

   SetStatus( pDevExt );

   return( ret_code );

}

/*************************************************************************
* Routine Name:
*
*    CD4xStartIo
*
* Routine Description:
*
*    This routine is called from the SCSI port driver synchronized
*    with the kernel with a request to be executed.
*
* Arguments:
*    Context -   The adapter specific information.
*    Srb -       The Srb command to execute.
*
* Return Value:
*
*    TRUE
*
*************************************************************************/
BOOLEAN CD4xStartIo(
   IN PVOID               Context,
   IN PSCSI_REQUEST_BLOCK Srb
   )
{
   PCD400_DEV_EXTENSION  pDevExt = Context;


   PC2DebugPrint(0x10,
                 (1, "\nCD4xStartIo: Dev= %x, Srb = %x\n",
                 pDevExt,
                 Srb));

   //
   // Determine the logical unit that this request is for.
   //

   if( (Srb->TargetId == 0) && (Srb->Lun != 0) ){
      Srb->SrbStatus = SRB_STATUS_INVALID_LUN;
      ScsiPortNotification(RequestComplete,
                           (PVOID) pDevExt,
                           Srb);
      ScsiPortNotification(NextRequest,
                           pDevExt,
                           NULL);

      return TRUE;
   }
   if( Srb->TargetId != 0 ){
      Srb->SrbStatus = SRB_STATUS_INVALID_TARGET_ID;
      ScsiPortNotification(RequestComplete,
                           (PVOID) pDevExt,
                           Srb);
      ScsiPortNotification(NextRequest,
                           pDevExt,
                           NULL);

      return TRUE;
   }

/* if( (Srb->TargetId != 0) || (Srb->Lun != 0) ){
      Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
      ScsiPortNotification(RequestComplete,
                           (PVOID) pDevExt,
                           Srb);
      ScsiPortNotification(NextRequest,
                           pDevExt,
                           NULL);

      return TRUE;
   } */

   pDevExt->PathId = Srb->PathId;


   pDevExt->LuExt.pLuSrb = Srb;

   switch (Srb->Function) {

       case SRB_FUNCTION_ABORT_COMMAND:

           PC2DebugPrint(0x10, (3, "ABORT COMMAND.\n"));

           CD4xAbort( pDevExt );

           //
           // Adapter ready for next request.
           //

           ScsiPortNotification(NextRequest,
                                pDevExt,
                                NULL);
           break;

       case SRB_FUNCTION_RESET_BUS:

           PC2DebugPrint(0x10, (3, "RESET BUS.\n"));
           //
           // Reset PC2x and SCSI bus.
           //

           CD4xResetBus( pDevExt, pDevExt->LuExt.pLuSrb->PathId );
           Srb->SrbStatus = SRB_STATUS_SUCCESS;
           //
           // "next request" notification is handled in PC2xResetBus
           //

           break;

       case SRB_FUNCTION_EXECUTE_SCSI:

           PC2DebugPrint(0x10, (3, "EXECUTE SCSI.\n"));

           //
           // Setup the context for this target/lun.
           //
           pDevExt->LuExt.CurrentDataPointer = (ULONG) Srb->DataBuffer;
           pDevExt->LuExt.CurrentDataLength  = Srb->DataTransferLength;

           pDevExt->LuExt.CommandType = NORMAL_CMD;

           if( CD4xStartExecution( pDevExt ) == CD_FAILURE ||
               pDevExt->LuExt.CommandType == IMMEDIATE_CMD ){
              ScsiPortNotification( RequestTimerCall,
                                    pDevExt,
                                    CD4xTimer,
                                    0 );
              SetStatus( pDevExt );
              ScsiPortNotification(RequestComplete,
                                   (PVOID) pDevExt,
                                   Srb );

              ScsiPortNotification(NextRequest,
                                   pDevExt,
                                   NULL);

           }

           break;

       default:

           Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
           ScsiPortNotification(RequestComplete,
                                (PVOID) pDevExt,
                                Srb);
           //
           // Adapter ready for next request.
           //
           ScsiPortNotification(NextRequest,
                                pDevExt,
                                NULL);
           break;

   }

   return TRUE;

}

VOID SetStatus( PCD400_DEV_EXTENSION pDevExt )
{
   UCHAR cmdStatus = pDevExt->LuExt.CmdErrorStatus;

   if( cmdStatus == COMMAND_SUCCESS ){
     pDevExt->LuExt.pLuSrb->ScsiStatus = SCSISTAT_GOOD;
     pDevExt->LuExt.pLuSrb->SrbStatus  = SRB_STATUS_SUCCESS;
   }
   else {
     pDevExt->LuExt.pLuSrb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
     switch( pDevExt->LuExt.CmdErrorStatus ){
        case DRIVE_NOT_READY :
           pDevExt->LuExt.pLuSrb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
           break;
        case COMMUNICATION_TIMEOUT :
           pDevExt->LuExt.pLuSrb->SrbStatus = SRB_STATUS_TIMEOUT;
           break;
        case PROTOCOL_ERROR :
           pDevExt->LuExt.pLuSrb->SrbStatus = SRB_STATUS_TIMEOUT;
           break;
        case ATAPI_COMMAND_ERROR :
           pDevExt->LuExt.pLuSrb->SrbStatus = SRB_STATUS_ERROR;
           break;
        default :
           pDevExt->LuExt.pLuSrb->SrbStatus = SRB_STATUS_ERROR;
           break;
     }
   }
}


/***************************************************************************
*  CD4xInterrupt
*    Function  : Interrupt Handler
*    Caller    :
*    Arguments : Device Context
*    Returns   : TRUE
****************************************************************************/
BOOLEAN CD4xInterrupt ( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB pCDB = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PULONG   IO_Ports = pDevExt->IO_Ports;
   PUCHAR     buffer = (PUCHAR) pDevExt->LuExt.CurrentDataPointer;
   ULONG buffer_size = pDevExt->LuExt.CurrentDataLength;
   USHORT     notify_flag = FALSE;

   union {
     USHORT    byte_count ;
     UCHAR     bc[2] ;
   } bcreg ;


   if ( WaitBusyClear( pDevExt ) )    // StatusReg is set in it.
     notify_flag = TRUE ;

   if (pDevExt->LuExt.CmdFlag.dir == 0)
     notify_flag = TRUE ;
   if (!(pDevExt->LuExt.StatusReg & 0x08))
     notify_flag = TRUE ;

   if( notify_flag == FALSE ){
     bcreg.bc[0] = ScsiPortReadPortUchar( (PUCHAR)IO_Ports[BCLOW_REG] ) ;
     bcreg.bc[1] = ScsiPortReadPortUchar( (PUCHAR)IO_Ports[BCHIGH_REG] ) ;

     if( buffer_size < bcreg.byte_count ){         // 401
       bcreg.byte_count = (USHORT)buffer_size ;    // 401 Not beyond the buffer size
       notify_flag = TRUE;                         // 401 Abnormal Termination
     }

     if (pDevExt->LuExt.CmdFlag.dir == 1) {
       ScsiPortReadPortBufferUshort(  (PUSHORT)IO_Ports[DATA_REG],
                                      (PUSHORT)buffer,
                                      (ULONG)bcreg.byte_count/2 ) ;
       buffer += (ULONG)bcreg.byte_count ;
       buffer_size -= (ULONG)bcreg.byte_count ;
       pDevExt->LuExt.CurrentDataPointer = (ULONG)buffer;
       pDevExt->LuExt.CurrentDataLength = buffer_size;

     } else if (pDevExt->LuExt.CmdFlag.dir == 2) {
       ScsiPortWritePortBufferUshort( (PUSHORT)IO_Ports[DATA_REG],
                                      (PUSHORT)buffer,
                                      (ULONG)bcreg.byte_count/2 ) ;
       buffer += (ULONG)bcreg.byte_count ;
       buffer_size -= (ULONG)bcreg.byte_count ;
       pDevExt->LuExt.CurrentDataPointer = (ULONG)buffer;
       pDevExt->LuExt.CurrentDataLength = buffer_size;

     }
   }

   if (pDevExt->LuExt.StatusReg & CMD_ERROR) {
     pDevExt->LuExt.ErrorReg =
                   ScsiPortReadPortUchar((PUCHAR)IO_Ports[ERROR_REG]);
     pDevExt->LuExt.CmdErrorStatus = ATAPI_COMMAND_ERROR;
     notify_flag = TRUE;
   }


   if( notify_flag == TRUE ){           // Command Complete Interrupt
     if( pDevExt->LuExt.StatusReg & CMD_ERROR ){
       switch( pCDB->CDB6READWRITE.OperationCode ){
         case SCSIOP_TEST_UNIT_READY :
           pDevExt->LuExt.CurrentBlockLength=2048L;
           break;
         default :
           break;
       }
     }
     else{
       switch( pCDB->CDB6READWRITE.OperationCode ){
         case  SCSIOP_MODE_SENSE:
           ModifyModeData( pDevExt );
           break;
         case  SCSIOP_REQUEST_SENSE :
           CheckSenseData( pDevExt );
           break;
         default:
           break;
       }
     }

     SetStatus ( pDevExt );
     ScsiPortNotification( RequestTimerCall,
                           pDevExt,
                           CD4xTimer,
                           0 );

     ScsiPortNotification(RequestComplete,
                           (PVOID) pDevExt,
                           pDevExt->LuExt.pLuSrb );

     ScsiPortNotification(NextRequest,
                           pDevExt,
                           NULL);

   }

   return TRUE;
}




/*  300  */
/***************************************************************************
*  CD4xAdapterControl
*    Function  : Adapter Control for Win2000 PNP
*    Caller    :
*    Arguments : Device Context
*    Returns   : ScsiAdapterControlSuccess/ScsiAdapterControlUnsuccessful
****************************************************************************/

#define CD4X_TYPE_MAX   5

SCSI_ADAPTER_CONTROL_STATUS
CD4xAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )

{
   PCD400_DEV_EXTENSION pDevExt = HwDeviceExtension;
   PSCSI_SUPPORTED_CONTROL_TYPE_LIST ControlTypeList;
   ULONG    AdjustedMaxControlType;
   PULONG   IO_Ports = pDevExt->IO_Ports;
   ULONG    Index;

   SCSI_ADAPTER_CONTROL_STATUS Status = ScsiAdapterControlSuccess;

   BOOLEAN SupportedConrolTypes[CD4X_TYPE_MAX] = {
      TRUE,   // ScsiQuerySupportedControlTypes
      TRUE,   // ScsiStopAdapter
      TRUE,   // ScsiRestartAdapter
      FALSE,  // ScsiSetBootConfig
      FALSE   // ScsiSetRunningConfig
   };

   switch (ControlType) {

      case ScsiQuerySupportedControlTypes:
         ControlTypeList = (PSCSI_SUPPORTED_CONTROL_TYPE_LIST)Parameters;
         AdjustedMaxControlType =
            (ControlTypeList->MaxControlType < CD4X_TYPE_MAX) ?
                          ControlTypeList->MaxControlType : CD4X_TYPE_MAX;

         for (Index = 0; Index < AdjustedMaxControlType; Index++) {
            ControlTypeList->SupportedTypeList[Index] =
                                        SupportedConrolTypes[Index];
         }
         break;

      case ScsiStopAdapter:
         ScsiPortWritePortUchar( (PUCHAR)IO_Ports[INTMASK_REG], 0 );
         ScsiPortWritePortUchar( (PUCHAR)IO_Ports[CMD_REG], ATAPI_RESET );
         break;

      case ScsiRestartAdapter:
         ScsiPortWritePortUchar( (PUCHAR)IO_Ports[CMD_REG], ATAPI_RESET );
         ScsiPortWritePortUchar( (PUCHAR)IO_Ports[INTMASK_REG], CDMASK_ON );
         break;

      case ScsiSetBootConfig:
         Status = ScsiAdapterControlUnsuccessful;
         break;

      case ScsiSetRunningConfig:
         Status = ScsiAdapterControlUnsuccessful;
         break;

      case ScsiAdapterControlMax:
         Status = ScsiAdapterControlUnsuccessful;
         break;

      default:
         Status = ScsiAdapterControlUnsuccessful;
         break;
   }

   return Status;
}



/*************************************************************************
* Routine Name:
*
*    DriverEntry
*
* Routine Description:
*
*    Driver initialization entry point for system.
*
* Arguments:
*
*    DriverObject - The driver specific object pointer
*    Argument2    - not used.
*
* Return Value:
*
*    Status from ScsiPortInitialize()
*
*************************************************************************/
ULONG
DriverEntry(
   IN PVOID DriverObject,
   IN PVOID Argument2
   )
{
   HW_INITIALIZATION_DATA  hwInitializationData;
   ULONG                   i;
   ULONG                   rc;

   PC2DebugPrint(0x20, (0, "\nIBM CD400 Miniport Driver\n"));

   //
   // Zero out the hwInitializationData structure.
   //
   for (i = 0; i < sizeof(HW_INITIALIZATION_DATA); i++) {

       *(((PUCHAR)&hwInitializationData + i)) = 0;
   }

   hwInitializationData.HwInitializationDataSize = sizeof(HW_INITIALIZATION_DATA);

   //
   // Set entry points.
   //
   hwInitializationData.HwInitialize   = CD4xInitialize;
   hwInitializationData.HwStartIo      = CD4xStartIo;
   hwInitializationData.HwFindAdapter  = CD4xFindAdapter;
   hwInitializationData.HwResetBus     = CD4xResetBus;
   hwInitializationData.HwInterrupt    = CD4xInterrupt;

  /* 300 */
   hwInitializationData.HwAdapterControl = CD4xAdapterControl;



   //
   // Specify size of device extension.
   //
   hwInitializationData.DeviceExtensionSize = sizeof(CD400_DEV_EXTENSION);

   //
   // Specify size of logical unit extension.
   //
   hwInitializationData.SpecificLuExtensionSize = 0 ;

   hwInitializationData.NumberOfAccessRanges   = 1;

   hwInitializationData.MapBuffers             = TRUE;  // <<<

   hwInitializationData.NeedPhysicalAddresses  = FALSE;

   hwInitializationData.TaggedQueuing          = FALSE;
   hwInitializationData.AutoRequestSense       = FALSE;
   hwInitializationData.MultipleRequestPerLu   = FALSE;
   hwInitializationData.ReceiveEvent           = FALSE;

   //
   // The fourth parameter below (i.e., "i") will show up as the
   // "Context" parameter when FindAdapter() is called.
   //

   PC2DebugPrint(0x20, (3, "Trying PCMCIA...\n"));
   hwInitializationData.AdapterInterfaceType = Isa;

   i = 0;
   rc = ( ScsiPortInitialize(DriverObject,
                             Argument2,
                             &hwInitializationData,
                             &(i) ) );

   PC2DebugPrint(0x20, (3, "Exit DriverEntry. rc=%x\n", rc));

   return(rc);

} // end DriverEntry()

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\ibm\cbidf\atapi.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    atapi.h

Abstract:

    This module contains the structures and definitions for the ATAPI
    IDE miniport driver.

Author:

    Mike Glass


Revision History:

--*/

#include "scsi.h"
#include "stddef.h"
#include "stdio.h"
#include "string.h"
//
// IDE register definition
//

typedef struct _IDE_REGISTERS_1 {
    USHORT Data;
    UCHAR BlockCount;
    UCHAR BlockNumber;
    UCHAR CylinderLow;
    UCHAR CylinderHigh;
    UCHAR DriveSelect;
    UCHAR Command;
    ULONG Data32;
    UCHAR DmaReg;
} IDE_REGISTERS_1, *PIDE_REGISTERS_1;

typedef struct _IDE_REGISTERS_2 {
    UCHAR AlternateStatus;
    UCHAR DriveAddress;
} IDE_REGISTERS_2, *PIDE_REGISTERS_2;

typedef struct _IDE_REGISTERS_3 {
    ULONG Data;
    UCHAR Others[4];
} IDE_REGISTERS_3, *PIDE_REGISTERS_3;

//
// Device Extension Device Flags
//

#define DFLAGS_DEVICE_PRESENT        0x0001    // Indicates that some device is present.
#define DFLAGS_ATAPI_DEVICE          0x0002    // Indicates whether Atapi commands can be used.
#define DFLAGS_TAPE_DEVICE           0x0004    // Indicates whether this is a tape device.
#define DFLAGS_INT_DRQ               0x0008    // Indicates whether device interrupts as DRQ is set after
                                               // receiving Atapi Packet Command
#define DFLAGS_REMOVABLE_DRIVE       0x0010    // Indicates that the drive has the 'removable' bit set in
                                               // identify data (offset 128)
#define DFLAGS_MEDIA_STATUS_ENABLED  0x0020    // Media status notification enabled
#define DFLAGS_ATAPI_CHANGER         0x0040    // Indicates atapi 2.5 changer present.
#define DFLAGS_SANYO_ATAPI_CHANGER   0x0080    // Indicates multi-platter device, not conforming to the 2.5 spec.
#define DFLAGS_CHANGER_INITED        0x0100    // Indicates that the init path for changers has already been done.
//
// Used to disable 'advanced' features.
//

#define MAX_ERRORS                     4

//
// ATAPI command definitions
//

#define ATAPI_MODE_SENSE   0x5A
#define ATAPI_MODE_SELECT  0x55
#define ATAPI_FORMAT_UNIT  0x24

//
// ATAPI Command Descriptor Block
//

typedef struct _MODE_SENSE_10 {
        UCHAR OperationCode;
        UCHAR Reserved1;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved3[3];
} MODE_SENSE_10, *PMODE_SENSE_10;

typedef struct _MODE_SELECT_10 {
        UCHAR OperationCode;
        UCHAR Reserved1 : 4;
        UCHAR PFBit : 1;
        UCHAR Reserved2 : 3;
        UCHAR Reserved3[5];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved4[3];
} MODE_SELECT_10, *PMODE_SELECT_10;

typedef struct _MODE_PARAMETER_HEADER_10 {
    UCHAR ModeDataLengthMsb;
    UCHAR ModeDataLengthLsb;
    UCHAR MediumType;
    UCHAR Reserved[5];
}MODE_PARAMETER_HEADER_10, *PMODE_PARAMETER_HEADER_10;

//
// IDE command definitions
//

#define IDE_COMMAND_ATAPI_RESET      0x08
#define IDE_COMMAND_RECALIBRATE      0x10
#define IDE_COMMAND_READ             0x20
#define IDE_COMMAND_WRITE            0x30
#define IDE_COMMAND_VERIFY           0x40
#define IDE_COMMAND_SEEK             0x70
#define IDE_COMMAND_SET_DRIVE_PARAMETERS 0x91
#define IDE_COMMAND_ATAPI_PACKET     0xA0
#define IDE_COMMAND_ATAPI_IDENTIFY   0xA1
#define IDE_COMMAND_READ_MULTIPLE    0xC4
#define IDE_COMMAND_WRITE_MULTIPLE   0xC5
#define IDE_COMMAND_SET_MULTIPLE     0xC6
#define IDE_COMMAND_READ_DMA         0xC8
#define IDE_COMMAND_WRITE_DMA             0xCA
#define IDE_COMMAND_GET_MEDIA_STATUS      0xDA
#define IDE_COMMAND_ENABLE_MEDIA_STATUS   0xEF
#define IDE_COMMAND_IDENTIFY              0xEC
#define IDE_COMMAND_MEDIA_EJECT           0xED

//
// IDE status definitions
//

#define IDE_STATUS_ERROR             0x01
#define IDE_STATUS_INDEX             0x02
#define IDE_STATUS_CORRECTED_ERROR   0x04
#define IDE_STATUS_DRQ               0x08
#define IDE_STATUS_DSC               0x10
#define IDE_STATUS_DRDY              0x40
#define IDE_STATUS_IDLE              0x50
#define IDE_STATUS_BUSY              0x80

//
// IDE drive select/head definitions
//

#define IDE_DRIVE_SELECT_1           0xA0
#define IDE_DRIVE_SELECT_2           0x10

//
// IDE drive control definitions
//

#define IDE_DC_DISABLE_INTERRUPTS    0x02
#define IDE_DC_RESET_CONTROLLER      0x04
#define IDE_DC_REENABLE_CONTROLLER   0x00

//
// IDE error definitions
//

#define IDE_ERROR_BAD_BLOCK          0x80
#define IDE_ERROR_DATA_ERROR         0x40
#define IDE_ERROR_MEDIA_CHANGE       0x20
#define IDE_ERROR_ID_NOT_FOUND       0x10
#define IDE_ERROR_MEDIA_CHANGE_REQ   0x08
#define IDE_ERROR_COMMAND_ABORTED    0x04
#define IDE_ERROR_END_OF_MEDIA       0x02
#define IDE_ERROR_ILLEGAL_LENGTH     0x01

//
// ATAPI register definition
//

typedef struct _ATAPI_REGISTERS_1 {
    USHORT Data;
    UCHAR InterruptReason;
    UCHAR Unused1;
    UCHAR ByteCountLow;
    UCHAR ByteCountHigh;
    UCHAR DriveSelect;
    UCHAR Command;
    ULONG Data32;
    UCHAR DmaReg;
} ATAPI_REGISTERS_1, *PATAPI_REGISTERS_1;

typedef struct _ATAPI_REGISTERS_2 {
    UCHAR AlternateStatus;
    UCHAR DriveAddress;
} ATAPI_REGISTERS_2, *PATAPI_REGISTERS_2;

//
// ATAPI interrupt reasons
//

#define ATAPI_IR_COD 0x01
#define ATAPI_IR_IO  0x02

//
// IDENTIFY data
//

typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumberOfCylinders;               // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumberOfHeads;                   // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT SectorsPerTrack;                 // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    USHORT SerialNumber[10];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    USHORT FirmwareRevision[4];             // 2E  23-26
    USHORT ModelNumber[20];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:1;        // 6A  53
    USHORT Reserved3:15;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[2];                    //     69-70
    USHORT ReleaseTimeOverlapped;           //     71
    USHORT ReleaseTimeServiceCommand;       //     72
    USHORT MajorRevision;                   //     73
    USHORT MinorRevision;                   //     74
    USHORT Reserved6[50];                   //     75-126
    USHORT SpecialFunctionsEnabled;         //     127
    USHORT Reserved7[128];                  //     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;

//
// Identify data without the Reserved4.
//

typedef struct _IDENTIFY_DATA2 {
    USHORT GeneralConfiguration;            // 00
    USHORT NumberOfCylinders;               // 02
    USHORT Reserved1;                       // 04
    USHORT NumberOfHeads;                   // 06
    USHORT UnformattedBytesPerTrack;        // 08
    USHORT UnformattedBytesPerSector;       // 0A
    USHORT SectorsPerTrack;                 // 0C
    USHORT VendorUnique1[3];                // 0E
    USHORT SerialNumber[10];                // 14
    USHORT BufferType;                      // 28
    USHORT BufferSectorSize;                // 2A
    USHORT NumberOfEccBytes;                // 2C
    USHORT FirmwareRevision[4];             // 2E
    USHORT ModelNumber[20];                 // 36
    UCHAR  MaximumBlockTransfer;            // 5E
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60
    USHORT Capabilities;                    // 62
    USHORT Reserved2;                       // 64
    UCHAR  VendorUnique3;                   // 66
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:1;        // 6A
    USHORT Reserved3:15;
    USHORT NumberOfCurrentCylinders;        // 6C
    USHORT NumberOfCurrentHeads;            // 6E
    USHORT CurrentSectorsPerTrack;          // 70
    USHORT CurrentSectorCapacityLo;         // 72
    USHORT CurrentSectorCapacityHi;
    USHORT CurrentMultiSectorSetting;       // 76
    ULONG  UserAddressableSectors;          // 78
} IDENTIFY_DATA2, *PIDENTIFY_DATA2;

#define IDENTIFY_DATA_SIZE sizeof(IDENTIFY_DATA)

//
// IDENTIFY capability bit definitions.
//

#define IDENTIFY_CAPABILITIES_DMA_SUPPORTED 0x0100
#define IDENTIFY_CAPABILITIES_LBA_SUPPORTED 0x0200

//
// IDENTIFY DMA timing cycle modes.
//

#define IDENTIFY_DMA_CYCLES_MODE_0 0x00
#define IDENTIFY_DMA_CYCLES_MODE_1 0x01
#define IDENTIFY_DMA_CYCLES_MODE_2 0x02


typedef struct _BROKEN_CONTROLLER_INFORMATION {
    PCHAR   VendorId;
    ULONG   VendorIdLength;
    PCHAR   DeviceId;
    ULONG   DeviceIdLength;
}BROKEN_CONTROLLER_INFORMATION, *PBROKEN_CONTROLLER_INFORMATION;

BROKEN_CONTROLLER_INFORMATION const BrokenAdapters[] = {
    { "1095", 4, "0640", 4},
    { "1039", 4, "0601", 4}
};

#define BROKEN_ADAPTERS (sizeof(BrokenAdapters) / sizeof(BROKEN_CONTROLLER_INFORMATION))

typedef struct _NATIVE_MODE_CONTROLLER_INFORMATION {
    PCHAR   VendorId;
    ULONG   VendorIdLength;
    PCHAR   DeviceId;
    ULONG   DeviceIdLength;
}NATIVE_MODE_CONTROLLER_INFORMATION, *PNATIVE_MODE_CONTROLLER_INFORMATION;

NATIVE_MODE_CONTROLLER_INFORMATION const NativeModeAdapters[] = {
    { "10ad", 4, "0105", 4}
};
#define NUM_NATIVE_MODE_ADAPTERS (sizeof(NativeModeAdapters) / sizeof(NATIVE_MODE_CONTROLLER_INFORMATION))

//
// Beautification macros
//

#define GetStatus(BaseIoAddress, Status) \
    Status = ScsiPortReadPortUchar(&BaseIoAddress->AlternateStatus);

#define GetBaseStatus(BaseIoAddress, Status) \
    Status = ScsiPortReadPortUchar(&BaseIoAddress->Command);

#define WriteCommand(BaseIoAddress, Command) \
    ScsiPortWritePortUchar(&BaseIoAddress->Command, Command);



#define ReadBuffer(BaseIoAddress, Buffer, Count) \
    ScsiPortReadPortBufferUshort(&BaseIoAddress->Data, \
                                 Buffer, \
                                 Count);

#define WriteBuffer(BaseIoAddress, Buffer, Count) \
    ScsiPortWritePortBufferUshort(&BaseIoAddress->Data, \
                                  Buffer, \
                                  Count);

#define ReadBuffer32(BaseIoAddress, Buffer, Count) \
    ScsiPortReadPortBufferUlong((PULONG)&BaseIoAddress->Data32, \
                                Buffer, \
                                Count);

#define WriteBuffer32(BaseIoAddress, Buffer, Count) \
    ScsiPortWritePortBufferUlong((PULONG)&BaseIoAddress->Data32, \
                                 Buffer, \
                                 Count);

#define WaitOnBusy(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<20000; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(150); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WaitOnBaseBusy(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<20000; i++) { \
        GetBaseStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(150); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WaitForDrq(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<1000; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(200); \
        } \
    } \
}


#define WaitShortForDrq(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<2; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(100); \
        } \
    } \
}

#define AtapiSoftReset(BaseIoAddress,BaseIoAddress2,DeviceNumber) \
{\
    UCHAR statusByte; \
    ScsiPortWritePortUchar(&BaseIoAddress->DriveSelect,(UCHAR)(((DeviceNumber & 0x1) << 4) | 0xA0)); \
    ScsiPortStallExecution(500);\
    ScsiPortWritePortUchar(&BaseIoAddress->Command, IDE_COMMAND_ATAPI_RESET); \
    ScsiPortStallExecution(1000*1000);\
    ScsiPortWritePortUchar(&BaseIoAddress->DriveSelect,(UCHAR)((DeviceNumber << 4) | 0xA0)); \
    WaitOnBusy(BaseIoAddress2,statusByte); \
    ScsiPortStallExecution(500);\
}

#define IdeHardReset(BaseIoAddress,result) \
{\
    UCHAR statusByte;\
    ULONG i;\
    ScsiPortWritePortUchar(&BaseIoAddress->AlternateStatus,IDE_DC_RESET_CONTROLLER );\
    ScsiPortStallExecution(50 * 1000);\
    ScsiPortWritePortUchar(&BaseIoAddress->AlternateStatus,IDE_DC_REENABLE_CONTROLLER);\
    for (i = 0; i < 1000 * 1000; i++) {\
        statusByte = ScsiPortReadPortUchar(&BaseIoAddress->AlternateStatus);\
        if (statusByte != IDE_STATUS_IDLE && statusByte != 0x0) {\
            ScsiPortStallExecution(5);\
        } else {\
            break;\
        }\
    }\
    if (i == 1000*1000) {\
        result = FALSE;\
    }\
    result = TRUE;\
}

#define IS_RDP(OperationCode)\
    ((OperationCode == SCSIOP_ERASE)||\
    (OperationCode == SCSIOP_LOAD_UNLOAD)||\
    (OperationCode == SCSIOP_LOCATE)||\
    (OperationCode == SCSIOP_REWIND) ||\
    (OperationCode == SCSIOP_SPACE)||\
    (OperationCode == SCSIOP_SEEK)||\
    (OperationCode == SCSIOP_WRITE_FILEMARKS))


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\ibm\cd20xrnt\atapicmd.c ===
/*****************************************************************************/
/*                                                                           */
/* Program Name: CD400.MPD : CD400 MiniPort Driver for CDROM Drive           */
/*              ---------------------------------------------------          */
/*                                                                           */
/* Source File Name: ATAPICMD.C                                              */
/*                                                                           */
/* Descriptive Name: ATAPI Command Mapper                                    */
/*                                                                           */
/* Function:                                                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Copyright (C) 1996 IBM Corporation                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Change Log                                                                */
/*                                                                           */
/* Mark Date      Programmer  Comment                                        */
/*  --- ----      ----------  -------                                        */
/*  000 01/01/96  S.Fujihara  Start Coding                                   */
/*  001 03/11/96  S.Fujihara  For Page-01, not issue Mode Select             */
/*  401 07/21/99  S.Fujihara  Not modify CurrentDataLength                   */
/*****************************************************************************/

#include <miniport.h>
#include <scsi.h>
#include <srb.h>

#include "cd4xtype.h"
#include "cdbatapi.h"
#include "proto.h"


/*==========================================================================*/
/*  ClearAtapiPacket                                                        */
/*    Function  : Clear Atapi Packet                                        */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
VOID ClearAtapiPacket( PCD400_DEV_EXTENSION pDevExt )
{
   SHORT i;
   for( i=0 ; i<12 ; i++ )
     pDevExt->LuExt.AtapiCmd[i] = 0;
}

/*==========================================================================*/
/*  ModeSense                                                               */
/*    Function  : Convert Mode Sense (6byte) command                        */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  ModeSense( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_ModeSense  pAT = (PACDB_ModeSense)pDevExt->LuExt.AtapiCmd;


   USHORTB count ;

   count.word = 0;
   ClearAtapiPacket( pDevExt );
   pAT->OpCode    = ATAPI_MODE_SENSE ;
   pAT->page_code       = pSC->MODE_SENSE.PageCode ;
   pAT->PC              = pSC->MODE_SENSE.Pc ;
   count.usbytes.byte_1 = pSC->MODE_SENSE.AllocationLength;
   pAT->alloc_length    = count ;

   pDevExt->LuExt.SavedDataPointer   = pDevExt->LuExt.CurrentDataPointer;
   pDevExt->LuExt.CurrentDataPointer = (ULONG)pDevExt->LuExt.AtapiBuffer;
//401 pDevExt->LuExt.CurrentDataLength = (ULONG)count.word;
   pDevExt->LuExt.CmdFlag.dir = 1;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

VOID  ModifyModeData( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PUCHAR     pAtapiBuf = (PUCHAR)pDevExt->LuExt.AtapiBuffer;
   PUCHAR      pScsiBuf = (PUCHAR)pDevExt->LuExt.SavedDataPointer;

   USHORTB count ;
   USHORT i,j;

   count.word = 0;
   count.usbytes.byte_1 = pSC->MODE_SENSE.AllocationLength;

   pScsiBuf[0] = pAtapiBuf[1]+8-3;  // Add Dummy Block Descriptor
   pScsiBuf[1] = pAtapiBuf[2];      //  Header Length of Mode(10) is
   pScsiBuf[2] = 0;                 //  3 bytes bigger than Mode(6).

   pScsiBuf[3] = 8;                 // Set Dummy Block Descriptor
   for( i=4 ; i<12 && i<(USHORT)count.usbytes.byte_1 ; i++ )
     pScsiBuf[i] = 0;               // Fill it with 0

   for( i=12, j=8 ; i<(USHORT)count.usbytes.byte_1 ; i++, j++ )
     pScsiBuf[i] = pAtapiBuf[j];    // Copy Mode Page Data

   pDevExt->LuExt.pLuSrb->DataTransferLength = (ULONG)(pScsiBuf[0]+1);

}

/*==========================================================================*/
/*  ModeSelect                                                              */
/*    Function  : Convert Mode Select (6byte) command                       */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
#define SCSI_HEADER         4
#define BLOCK_DESCRIPTOR    8
#define ATAPI_HEADER        8

USHORT  ModeSelect( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_ModeSelect pAT = (PACDB_ModeSelect)pDevExt->LuExt.AtapiCmd;
   PUCHAR     pAtapiBuf = pDevExt->LuExt.AtapiBuffer;
   PUCHAR      pScsiBuf = (PUCHAR)pDevExt->LuExt.CurrentDataPointer;

   USHORT  i,j,count,offset ;
   ULONGB  blockLength;

   ClearAtapiPacket( pDevExt );

   count = pSC->MODE_SELECT.ParameterListLength;
   if( (SCSI_HEADER+BLOCK_DESCRIPTOR<=count) && (BLOCK_DESCRIPTOR==pScsiBuf[3]) ){
      blockLength.ulbytes.byte_3 = 0 ;
      blockLength.ulbytes.byte_2 = pScsiBuf[9];
      blockLength.ulbytes.byte_1 = pScsiBuf[10];
      blockLength.ulbytes.byte_0 = pScsiBuf[11];
      if( (blockLength.dword != 2048L) &&
          (blockLength.dword != 2352L) &&
          (blockLength.dword != 0    ) )
            return( CD_FAILURE );

      if( blockLength.dword == 0 )
         blockLength.dword = 2048L;
      pDevExt->LuExt.CurrentBlockLength = blockLength.ulbwords.word_0;
      offset = SCSI_HEADER+BLOCK_DESCRIPTOR;
      count -= offset;
   }
   else{
      if( count < SCSI_HEADER )
         return( CD_FAILURE );

      offset = SCSI_HEADER;
      count -= offset;
   }

   for( i=0 ; i<ATAPI_HEADER ; i++ )
     pAtapiBuf[i] = 0;

   for( i=ATAPI_HEADER, j=0 ; j<count ; i++, j++ )
     pAtapiBuf[i] = pScsiBuf[offset+j];

   pAT->OpCode    = ATAPI_MODE_SELECT ;
   pAT->SP        = pSC->MODE_SELECT.SPBit;
   pAT->PF        = 1;
   pAT->page_code     = pAtapiBuf[ATAPI_HEADER] ;
   pAT->parm_length.usbytes.byte_1 = (UCHAR)i ;

   if( pAT->page_code == MODE_PAGE_ERROR_RECOVERY ){  /* [001] */
     pDevExt->LuExt.CommandType = IMMEDIATE_CMD;
     return( CD_SUCCESS );                            /* [001] */
   }

   pDevExt->LuExt.CurrentDataPointer = (ULONG)pAtapiBuf;
//401 pDevExt->LuExt.CurrentDataLength = (ULONG)i;
   pDevExt->LuExt.CmdFlag.dir = 2;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}



/*==========================================================================*/
/*  Read6                                                                   */
/*    Function  : Convert Read(6) SCSI command to Read(10) ATAPI command    */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  Read6( PCD400_DEV_EXTENSION pDevExt )
{

   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_Read_10    pAT = (PACDB_Read_10)pDevExt->LuExt.AtapiCmd;
   USHORT      blocklen = pDevExt->LuExt.CurrentBlockLength;

   ULONGB  lba ;
   USHORTB count ;

   ClearAtapiPacket( pDevExt );
   lba.dword = 0L ;
   count.word = 0 ;
   lba.ulbytes.byte_1 = pSC->CDB6READWRITE.LogicalBlockMsb1 ;
   lba.ulbytes.byte_2 = pSC->CDB6READWRITE.LogicalBlockMsb0 ;
   lba.ulbytes.byte_3 = pSC->CDB6READWRITE.LogicalBlockLsb  ;
   count.usbytes.byte_1 = pSC->CDB6READWRITE.TransferBlocks ;
   if ( blocklen == 2048L) {
     pAT->OpCode = ATAPI_READ_10 ;
     pAT->LBA = lba ;
     pAT->transfer_length = count ;
   } else {
     ReadCD( lba, count, (PACDB_Read_CD)pAT) ;
   }

//401 pDevExt->LuExt.CurrentDataLength = (ULONG)count.word;
   pDevExt->LuExt.CmdFlag.dir = 1;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}



/*==========================================================================*/
/*  Read10                                                                  */
/*    Function  : Convert Read(10) SCSI command to Read(10) ATAPI command   */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  Read10( PCD400_DEV_EXTENSION pDevExt )
{

   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_Read_10    pAT = (PACDB_Read_10)pDevExt->LuExt.AtapiCmd;
   USHORT      blocklen = pDevExt->LuExt.CurrentBlockLength;

   ULONGB  lba ;
   USHORTB count ;

   ClearAtapiPacket( pDevExt );
   lba.dword = 0L ;
   count.word = 0 ;
   lba.ulbytes.byte_0 = pSC->CDB10.LogicalBlockByte0 ;
   lba.ulbytes.byte_1 = pSC->CDB10.LogicalBlockByte1 ;
   lba.ulbytes.byte_2 = pSC->CDB10.LogicalBlockByte2 ;
   lba.ulbytes.byte_3 = pSC->CDB10.LogicalBlockByte3 ;
   count.usbytes.byte_0 = pSC->CDB10.TransferBlocksMsb;
   count.usbytes.byte_1 = pSC->CDB10.TransferBlocksLsb ;
   if ( blocklen == 2048L) {
     pAT->OpCode = ATAPI_READ_10 ;
     pAT->LBA.dword = lba.dword ;
     pAT->transfer_length.word = count.word ;
   } else {
     ReadCD( lba, count, (PACDB_Read_CD)pAT) ;
   }

//401 pDevExt->LuExt.CurrentDataLength = (ULONG)count.word;
   pDevExt->LuExt.CmdFlag.dir = 1;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}


VOID  ReadCD( ULONGB lba, USHORTB count, PACDB_Read_CD pAT)
{
   pAT->OpCode = ATAPI_READ_CD ;
   pAT->LBA = lba ;
   pAT->transfer_length = count ;
   pAT->user_data = 1 ;
   pAT->header_code = 3 ;
   pAT->synch_field=1;
   pAT->edc_ecc = 1 ;
}


/*==========================================================================*/
/*  TestUnitReady                                                           */
/*    Function  : Convert Test Unit Ready command                           */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  TestUnitReady( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_TestUnitReady  pAT = (PACDB_TestUnitReady)pDevExt->LuExt.AtapiCmd;

   USHORT      blocklen = pDevExt->LuExt.CurrentBlockLength;

   ClearAtapiPacket( pDevExt );

   pAT->OpCode = ATAPI_TEST_UNIT_READY;

//401 pDevExt->LuExt.CurrentDataLength = 0 ;
   pDevExt->LuExt.CmdFlag.dir = 0;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

/*==========================================================================*/
/*  RequestSense                                                            */
/*    Function  : Convert Reqeust Sense command                             */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  RequestSense( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_RequestSense  pAT = (PACDB_RequestSense)pDevExt->LuExt.AtapiCmd;

   pDevExt->LuExt.SavedDataPointer   = pDevExt->LuExt.CurrentDataPointer; //<

   ClearAtapiPacket( pDevExt );
   pAT->OpCode = ATAPI_REQUEST_SENSE;
   pAT->alloc_length = pSC->CDB6GENERIC.CommandUniqueBytes[2];

//401 pDevExt->LuExt.CurrentDataLength = (ULONG)pAT->alloc_length;
   pDevExt->LuExt.CmdFlag.dir = 1;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

VOID CheckSenseData( PCD400_DEV_EXTENSION pDevExt )                      //<--
{                                                                        //
   PSENSE_DATA  pSense = (PSENSE_DATA)pDevExt->LuExt.SavedDataPointer ;  //
                                                                         //
   if( pSense->SenseKey == SCSI_SENSE_NOT_READY ||                       //
       pSense->SenseKey == SCSI_SENSE_UNIT_ATTENTION ||                  //
       pSense->SenseKey == SCSI_SENSE_ILLEGAL_REQUEST )                  //
     pDevExt->LuExt.CurrentBlockLength=2048L;                            //
                                                                         //-->
}

/*==========================================================================*/
/*  Seek                                                                    */
/*    Function  : Convert Seek SCSI command                                 */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  Seek( PCD400_DEV_EXTENSION pDevExt )
{

   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_Seek       pAT = (PACDB_Seek)pDevExt->LuExt.AtapiCmd;
   USHORT      blocklen = pDevExt->LuExt.CurrentBlockLength;

   ULONGB  lba ;

   ClearAtapiPacket( pDevExt );
   lba.dword = 0L ;
   lba.ulbytes.byte_0 = pSC->SEEK.LogicalBlockAddress[0];
   lba.ulbytes.byte_1 = pSC->SEEK.LogicalBlockAddress[1];
   lba.ulbytes.byte_2 = pSC->SEEK.LogicalBlockAddress[2];
   lba.ulbytes.byte_3 = pSC->SEEK.LogicalBlockAddress[3];
   pAT->OpCode = ATAPI_SEEK   ;
   pAT->LBA = lba ;

//401 pDevExt->LuExt.CurrentDataLength = 0  ;
   pDevExt->LuExt.CmdFlag.dir = 0;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

/*==========================================================================*/
/*  Inquiry                                                                 */
/*    Function  : Convert Inquiry SCSI command                              */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  Inquiry( PCD400_DEV_EXTENSION pDevExt )
{

   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_Inquiry    pAT = (PACDB_Inquiry)pDevExt->LuExt.AtapiCmd;

   ClearAtapiPacket( pDevExt );
   pAT->OpCode = ATAPI_INQUIRY;
   pAT->alloc_length = pSC->CDB6INQUIRY.AllocationLength;

//401 pDevExt->LuExt.CurrentDataLength = (ULONG)pAT->alloc_length;
   pDevExt->LuExt.CmdFlag.dir = 1;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

/*==========================================================================*/
/*  StartStopUnit                                                           */
/*    Function  : Convert Start/Stop Unit command                           */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  StartStopUnit( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_StartStopUnit pAT = (PACDB_StartStopUnit)pDevExt->LuExt.AtapiCmd;

   ClearAtapiPacket( pDevExt );
   pAT->OpCode = ATAPI_STARTSTOP ;
   pAT->Immed  = pSC->START_STOP.Immediate;
   pAT->start  = pSC->START_STOP.Start;
   pAT->LoEj   = pSC->START_STOP.LoadEject;

//401 pDevExt->LuExt.CurrentDataLength = 0 ;
   pDevExt->LuExt.CmdFlag.dir = 0;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

/*==========================================================================*/
/*  MediumRemoval                                                           */
/*    Function  : Convert Prevent/Allow Medium Removal                      */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  MediumRemoval( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_PreventAllowRemoval pAT =
                    (PACDB_PreventAllowRemoval)pDevExt->LuExt.AtapiCmd;

   ClearAtapiPacket( pDevExt );
   pAT->OpCode  = ATAPI_PREV_REMOVE ;
   pAT->prevent = pSC->MEDIA_REMOVAL.Prevent;

//401 pDevExt->LuExt.CurrentDataLength = 0 ;
   pDevExt->LuExt.CmdFlag.dir = 0;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

/*==========================================================================*/
/*  ReadCapacity                                                            */
/*    Function  : Convert Read Capacity command                             */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  ReadCapacity( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_ReadCapacity pAT = (PACDB_ReadCapacity)pDevExt->LuExt.AtapiCmd;

   ClearAtapiPacket( pDevExt );
   pAT->OpCode  = ATAPI_READCAPACITY;

//401 pDevExt->LuExt.CurrentDataLength = 8 ;
   pDevExt->LuExt.CmdFlag.dir = 1;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

/*==========================================================================*/
/*  ReadSubChannel                                                          */
/*    Function  : Convert Read Sub Channel command                          */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  ReadSubChannel( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_ReadSubChannel pAT = (PACDB_ReadSubChannel)pDevExt->LuExt.AtapiCmd;
   USHORTB count ;

   count.word = 0 ;
   ClearAtapiPacket( pDevExt );
   pAT->OpCode  = ATAPI_READSUBCHANNEL;
   pAT->MSF     = pSC->SUBCHANNEL.Msf ;
   pAT->SubQ    = pSC->SUBCHANNEL.SubQ;
   pAT->data_format  = pSC->SUBCHANNEL.Format;
   pAT->TNO          = pSC->SUBCHANNEL.TrackNumber;
   count.usbytes.byte_0 = pSC->SUBCHANNEL.AllocationLength[0] ;
   count.usbytes.byte_1 = pSC->SUBCHANNEL.AllocationLength[1] ;
   pAT->alloc_length = count;

//401 pDevExt->LuExt.CurrentDataLength = (ULONG)count.word ;
   pDevExt->LuExt.CmdFlag.dir = 1;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

/*==========================================================================*/
/*  ReadToc                                                                 */
/*    Function  : Convert Read TOC command                                  */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  ReadToc( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_ReadTOC    pAT = (PACDB_ReadTOC)pDevExt->LuExt.AtapiCmd;
   USHORTB      count;

   count.word = 0;
   ClearAtapiPacket( pDevExt );
   pAT->OpCode  = ATAPI_READ_TOC      ;
   pAT->MSF     = pSC->READ_TOC.Msf ;
   pAT->starting_track = pSC->READ_TOC.StartingTrack;
   count.usbytes.byte_0 = pSC->READ_TOC.AllocationLength[0];
   count.usbytes.byte_1 = pSC->READ_TOC.AllocationLength[1];

   pAT->alloc_length = count;
   pAT->format       = pSC ->READ_TOC.Format;
//401 pDevExt->LuExt.CurrentDataLength = (ULONG)count.word ;
   pDevExt->LuExt.CmdFlag.dir = 1;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

/*==========================================================================*/
/*  ReadHeader                                                              */
/*    Function  : Convert Read Header command                               */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  ReadHeader( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_ReadHeader pAT = (PACDB_ReadHeader)pDevExt->LuExt.AtapiCmd;
   ULONGB  lba ;
   USHORTB count;

   ClearAtapiPacket( pDevExt );
   pAT->OpCode  = ATAPI_READ_HEADER      ;
   pAT->MSF     = pSC->READ_TOC.Msf ;
   lba.ulbytes.byte_0 = pSC->CDB10.LogicalBlockByte0 ;
   lba.ulbytes.byte_1 = pSC->CDB10.LogicalBlockByte1 ;
   lba.ulbytes.byte_2 = pSC->CDB10.LogicalBlockByte2 ;
   lba.ulbytes.byte_3 = pSC->CDB10.LogicalBlockByte3 ;
   count.usbytes.byte_0 = pSC->CDB10.TransferBlocksMsb;
   count.usbytes.byte_1 = pSC->CDB10.TransferBlocksLsb ;

   pAT->LBA          = lba;
   pAT->alloc_length = count;

//401 pDevExt->LuExt.CurrentDataLength = (ULONG)count.word ;
   pDevExt->LuExt.CmdFlag.dir = 1;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

/*==========================================================================*/
/*  PlayAudio                                                               */
/*    Function  : Convert Play Audio command                                */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  PlayAudio( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_PlayAudio_10 pAT = (PACDB_PlayAudio_10)pDevExt->LuExt.AtapiCmd;
   ULONGB  lba;
   USHORTB count;

   ClearAtapiPacket( pDevExt );
   pAT->OpCode  = ATAPI_PLAY_10      ;
   lba.ulbytes.byte_0 = pSC->CDB10.LogicalBlockByte0 ;
   lba.ulbytes.byte_1 = pSC->CDB10.LogicalBlockByte1 ;
   lba.ulbytes.byte_2 = pSC->CDB10.LogicalBlockByte2 ;
   lba.ulbytes.byte_3 = pSC->CDB10.LogicalBlockByte3 ;
   count.usbytes.byte_0 = pSC->CDB10.TransferBlocksMsb ;
   count.usbytes.byte_1 = pSC->CDB10.TransferBlocksLsb ;

   pAT->LBA          = lba;
   pAT->transfer_length = count;

//401 pDevExt->LuExt.CurrentDataLength = 0 ;
   pDevExt->LuExt.CmdFlag.dir = 0;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

/*==========================================================================*/
/*  PlayAudioMsf                                                            */
/*    Function  : Convert Play Audio Msf command                            */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  PlayAudioMsf( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_PlayAudio_MSF pAT = (PACDB_PlayAudio_MSF)pDevExt->LuExt.AtapiCmd;

   ClearAtapiPacket( pDevExt );
   pAT->OpCode  = ATAPI_PLAY_MSF      ;
   pAT->starting_M = pSC->PLAY_AUDIO_MSF.StartingM;
   pAT->starting_S = pSC->PLAY_AUDIO_MSF.StartingS;
   pAT->starting_F = pSC->PLAY_AUDIO_MSF.StartingF;
   pAT->ending_M   = pSC->PLAY_AUDIO_MSF.EndingM;
   pAT->ending_S   = pSC->PLAY_AUDIO_MSF.EndingS;
   pAT->ending_F   = pSC->PLAY_AUDIO_MSF.EndingF;

//401 pDevExt->LuExt.CurrentDataLength = 0 ;
   pDevExt->LuExt.CmdFlag.dir = 0;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}

/*==========================================================================*/
/*  PauseResume                                                             */
/*    Function  : Convert Pause/Resume command                              */
/*    Caller    :                                                           */
/*    Arguments : SCSI and ATAPI command buffer pointers                    */
/*    Returns   : none                                                      */
/*--------------------------------------------------------------------------*/
/*==========================================================================*/
USHORT  PauseResume( PCD400_DEV_EXTENSION pDevExt )
{
   PCDB             pSC = (PCDB)pDevExt->LuExt.pLuSrb->Cdb;
   PACDB_PauseResume  pAT = (PACDB_PauseResume)pDevExt->LuExt.AtapiCmd;

   ClearAtapiPacket( pDevExt );

   pAT->OpCode = ATAPI_PAUSE_RESUME;
   pAT->resume = pSC->PAUSE_RESUME.Action;

//401 pDevExt->LuExt.CurrentDataLength = 0 ;
   pDevExt->LuExt.CmdFlag.dir = 0;

   if( Send_ATAPI_Cmd( pDevExt ) )
     return( CD_FAILURE );

   if( Get_ATAPI_Result( pDevExt ) )
     return( CD_FAILURE );

   return( CD_SUCCESS );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\ibm\cd20xrnt\proto.h ===
USHORT CD4xStartExecution( PCD400_DEV_EXTENSION pDevExt );
BOOLEAN CD4xInterrupt( PCD400_DEV_EXTENSION pDevExt );
VOID    CD4xTimer( PCD400_DEV_EXTENSION pDevExt );
VOID    SetStatus( PCD400_DEV_EXTENSION pDevExt );

USHORT ModeSelect( PCD400_DEV_EXTENSION pDevExt );
USHORT ModeSense( PCD400_DEV_EXTENSION pDevExt );
VOID   ModifyModeData( PCD400_DEV_EXTENSION pDevExt );
USHORT TestUnitReady( PCD400_DEV_EXTENSION pDevExt );
USHORT RequestSense( PCD400_DEV_EXTENSION pDevExt );
VOID   CheckSenseData( PCD400_DEV_EXTENSION pDevExt );
USHORT Read6( PCD400_DEV_EXTENSION pDevExt );
USHORT Read10( PCD400_DEV_EXTENSION pDevExt );
VOID   ReadCD( ULONGB, USHORTB, PACDB_Read_CD );
USHORT Seek( PCD400_DEV_EXTENSION pDevExt );
USHORT Inquiry( PCD400_DEV_EXTENSION pDevExt );
USHORT StartStopUnit( PCD400_DEV_EXTENSION pDevExt );
USHORT MediumRemoval( PCD400_DEV_EXTENSION pDevExt );
USHORT ReadCapacity( PCD400_DEV_EXTENSION pDevExt );
USHORT ReadSubChannel( PCD400_DEV_EXTENSION pDevExt );
USHORT ReadToc( PCD400_DEV_EXTENSION pDevExt );
USHORT ReadHeader( PCD400_DEV_EXTENSION pDevExt );
USHORT PlayAudio( PCD400_DEV_EXTENSION pDevExt );
USHORT PlayAudioMsf( PCD400_DEV_EXTENSION pDevExt );
USHORT PauseResume( PCD400_DEV_EXTENSION pDevExt );


VOID   ClearAtapiPacket( PCD400_DEV_EXTENSION pDevExt );
USHORT Send_ATAPI_Cmd( PCD400_DEV_EXTENSION pDevExt );
USHORT Send_ATA_Cmd( PCD400_DEV_EXTENSION pDevExt, PUCHAR ATACmd );
USHORT Get_ATAPI_Result( PCD400_DEV_EXTENSION pDevExt );
USHORT CheckReady( PCD400_DEV_EXTENSION pDevExt );
USHORT WaitRdyForPacket( PCD400_DEV_EXTENSION pDevExt );
USHORT WaitBusyClear( PCD400_DEV_EXTENSION pDevExt );
void IO_Delay( void );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaide\hddefs.h ===
#ifndef _HDDEFS_H_
#define _HDDEFS_H_


/**************************

  Change this Definition to build Win2k or WinNT and Win9x drivers

***************************/

#define HYPERDISK_WIN2K
//#define HYPERDISK_WINNT
//#define HYPERDISK_WIN98

//#define KEEP_LOG    // to keep note of log activity

// Use this for supplying a dummy IRCD to the Driver.
// See the definition of gucDummyIRCD variable for more information
// #define DUMMY_RAID10_IRCD

//
// System log error codes for some miniport error events.
//
#define HYPERDISK_RESET_DETECTED                0
#define HYPERDISK_DRIVE_LOST_POWER              HYPERDISK_RESET_DETECTED + 1
#define HYPERDISK_DRIVE_BUSY                    HYPERDISK_DRIVE_LOST_POWER + 1
#define HYPERDISK_ERROR_PENDING_SRBS_COUNT      HYPERDISK_DRIVE_BUSY + 1
#define HYPERDISK_ERROR_EXCEEDED_PDDS_PER_SRB	HYPERDISK_ERROR_PENDING_SRBS_COUNT + 1
#define HYPERDISK_RESET_BUS_FAILED              HYPERDISK_ERROR_EXCEEDED_PDDS_PER_SRB + 1
#define HYPERDISK_TOO_MANY_ERRORS               HYPERDISK_RESET_BUS_FAILED + 1


// #define FORCE_PIO

#define DRIVER_COMPILATION
#define INTERRUPT_LOOP          1

#ifdef HYPERDISK_WIN98

#define HD_ALLOCATE_SRBEXT_SEPERATELY

#endif // HYPERDISK_WIN98


#ifdef HYPERDISK_WIN2K

#define PNP_AND_POWER_MANAGEMENT

#endif // HYPERDISK_WIN2K


#endif // _HDDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\ibm\cd20xrnt\protocol.c ===
/*****************************************************************************/
/*                                                                           */
/* Program Name: CD400.MPD : CD400 MiniPort Driver for CDROM Drive           */
/*              ---------------------------------------------------          */
/*                                                                           */
/* Source File Name: PROTOCOL.C                                              */
/*                                                                           */
/* Descriptive Name: ATAPI Protocol Handler                                  */
/*                                                                           */
/* Function:                                                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Copyright (C) 1996 IBM Corporation                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Change Log                                                                */
/*                                                                           */
/* Mark Date      Programmer  Comment                                        */
/*  --- ----      ----------  -------                                        */
/*  000 01/01/96  S.Fujihara  Start Coding                                   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include <miniport.h>
#include <srb.h>

#include "cd4xtype.h"
#include "cdbatapi.h"
#include "proto.h"


/*==========================================================================*/
/*  Send_ATAPI_Cmd                                                          */
/*    Function  : Send ATAPI packet command                                 */
/*    Caller    :                                                           */
/*    Arguments : Command buffer                                            */
/*    Returns   : CD_SUCCESS or CD_FAILURE                                  */
/*==========================================================================*/
USHORT Send_ATAPI_Cmd( PCD400_DEV_EXTENSION pDevExt )
{

   PUSHORT    AtapiCmd = pDevExt->LuExt.AtapiCmd;
   ULONG  buffer_size = pDevExt->LuExt.CurrentDataLength;
   PULONG   IO_Ports = pDevExt->IO_Ports;
   UCHAR   ATACmd[8];
   USHORTB len ;
   USHORT  i ;

   pDevExt->LuExt.CmdMask = 0xF2 ;

   ATACmd[1] = 0 ;
   if (pDevExt->LuExt.CmdFlag.dir == 2) {
     len.word = (USHORT)buffer_size ;
     ATACmd[4] = len.usbytes.byte_0 ;
     ATACmd[5] = len.usbytes.byte_1 ;
   } else {
     if (pDevExt->LuExt.CmdFlag.dir == 1) {
       if (buffer_size > 2048L) {
         ATACmd[4] = 0 ;
         ATACmd[5] = 8 ;
       } else {
         len.word = (USHORT)buffer_size ;
         ATACmd[4] = len.usbytes.byte_0 ;
         ATACmd[5] = len.usbytes.byte_1 ;
       }
     } else {
       ATACmd[4] = 0 ;
       ATACmd[5] = 0 ;
     }
   }
   ATACmd[6] = 0xA0 ;
   ATACmd[7] = 0xA0 ;

   if ( Send_ATA_Cmd( pDevExt, ATACmd) ){       /* Send Packet ATA command 0xA0  */
     pDevExt->LuExt.CmdErrorStatus = DRIVE_NOT_READY;
     return (CD_FAILURE) ;
   }

   if ( WaitRdyForPacket( pDevExt ) ) {
     pDevExt->LuExt.CmdErrorStatus = COMMUNICATION_TIMEOUT;
     return (CD_FAILURE) ;             /* Time out error                  */
   }

   for (i = 0 ; i < 6 ; i++) {
     ScsiPortWritePortUshort( (PUSHORT)IO_Ports[DATA_REG], (USHORT)AtapiCmd[i] ) ;
   }

   ScsiPortNotification( RequestTimerCall,
                         pDevExt,
                         CD4xTimer,
                         INTERRUPT_TIMEOUT );

   return (CD_SUCCESS) ;
}

/*==========================================================================*/
/*  Send_ATA_Cmd                                                            */
/*    Function  : Send general ATA command                                  */
/*    Caller    : Send_ATAPI_Cmd                                            */
/*    Arguments : none                                                      */
/*    Returns   : CD_SUCCESS or CD_FAILURE                                  */
/*==========================================================================*/
USHORT Send_ATA_Cmd( PCD400_DEV_EXTENSION pDevExt, PUCHAR ATACmd )
{

   UCHAR     CmdMask = pDevExt->LuExt.CmdMask;
   PULONG   IO_Ports = pDevExt->IO_Ports;

   USHORT  i ;

   ScsiPortWritePortUchar( (PUCHAR)IO_Ports[INTMASK_REG], (UCHAR)CDMASK_ON );

   if (CmdMask & 0x40) {               /* Drive Select on                   */
     ScsiPortWritePortUchar((PUCHAR)IO_Ports[DVSEL_REG], ATACmd[6] ) ;     /* Write drive select                */
     CmdMask &= 0xBF ;
   }

   if ( CheckReady( pDevExt ) ) {      /* Check Drive Ready (Busy/Dreq Off) */
     pDevExt->LuExt.CmdErrorStatus = COMMUNICATION_TIMEOUT;
     return (CD_FAILURE) ;             /* Time out error                    */
   }

   for (i = 0 ; i < 7 ; i++) {         /* Write other required register     */
     if (CmdMask & 0x01) {
       ScsiPortWritePortUchar( (PUCHAR)IO_Ports[i], ATACmd[i] ) ;
     }
     CmdMask >>= 1 ;
   }
   ScsiPortWritePortUchar( (PUCHAR)IO_Ports[CMD_REG], ATACmd[7] ) ; /* Write command                  */
   return(CD_SUCCESS) ;
}


/*==========================================================================*/
/*  Get_ATAPI_Result                                                        */
/*    Function  : Get Result Status and Get Data from Device                */
/*    Caller    :                                                           */
/*    Arguments : Buffer address if data transfer is needed                 */
/*    Returns   : CD_SUCCESS or CD_FAILURE                                  */
/*==========================================================================*/
USHORT Get_ATAPI_Result( PCD400_DEV_EXTENSION pDevExt )
{
/*
*   PULONG   IO_Ports = pDevExt->IO_Ports;
*   PUCHAR     buffer = (PUCHAR) pDevExt->LuExt.CurrentDataPointer;
*   ULONG buffer_size = pDevExt->LuExt.CurrentDataLength;
*
*   union {
*     USHORT    byte_count ;
*     UCHAR     bc[2] ;
*   } bcreg ;
*   UCHAR  StatusReg ;
*
*   pDevExt->LuExt.TimerState = FALSE;
*
*   do {
*     if (WaitBusyClear( pDevExt )) {
*
*       ScsiPortNotification( RequestTimerCall,
*                             pDevExt,
*                             CD4xTimer,
*                             INT_INTERVAL );
*       pDevExt->LuExt.TimerState = TRUE;
*       return(CD_FAILURE) ;
*     }
*
*     if (pDevExt->LuExt.CmdFlag.dir == 0) break ;
*     if (!(pDevExt->LuExt.StatusReg & 0x08)) break ;
*
*
*     bcreg.bc[0] = ScsiPortReadPortUchar( (PUCHAR)IO_Ports[BCLOW_REG] ) ;
*     bcreg.bc[1] = ScsiPortReadPortUchar( (PUCHAR)IO_Ports[BCHIGH_REG] ) ;
*
*     if (pDevExt->LuExt.CmdFlag.dir == 1) {
*       ScsiPortReadPortBufferUshort(  (PUSHORT)IO_Ports[DATA_REG],
*                                      (PUSHORT)buffer,
*                                      (ULONG)bcreg.byte_count/2 ) ;
*       buffer += (ULONG)bcreg.byte_count ;
*       buffer_size -= (ULONG)bcreg.byte_count ;
*       pDevExt->LuExt.CurrentDataPointer = (ULONG)buffer;
*       pDevExt->LuExt.CurrentDataLength = buffer_size;
*
*     } else if (pDevExt->LuExt.CmdFlag.dir == 2) {
*       ScsiPortWritePortBufferUshort( (PUSHORT)IO_Ports[DATA_REG],
*                                      (PUSHORT)buffer,
*                                      (ULONG)bcreg.byte_count/2 ) ;
*       buffer += (ULONG)bcreg.byte_count ;
*       buffer_size -= (ULONG)bcreg.byte_count ;
*       pDevExt->LuExt.CurrentDataPointer = (ULONG)buffer;
*       pDevExt->LuExt.CurrentDataLength = buffer_size;
*
*     }
*
*   } while(1) ;
*
*   StatusReg = ScsiPortReadPortUchar( (PUCHAR)IO_Ports[STATUS_REG] ) ;
*   if (StatusReg & 0x01) {
*     pDevExt->LuExt.ErrorReg =
*                   ScsiPortReadPortUchar((PUCHAR)IO_Ports[ERROR_REG]);
*     pDevExt->LuExt.CmdErrorStatus = ATAPI_COMMAND_ERROR;
*     return(CD_FAILURE) ;
*   }
*/
   return(CD_SUCCESS) ;

}

/*==========================================================================*/
/*  CheckReady                                                              */
/*    Function  : Check device ready or not (Busy and Dreq bit Off)         */
/*    Caller    :                                                           */
/*    Arguments : none                                                      */
/*    Returns   : CD_SUCCESS or CD_FAILURE                                  */
/*==========================================================================*/
USHORT CheckReady( PCD400_DEV_EXTENSION pDevExt )
{

   PULONG  IO_Ports = pDevExt->IO_Ports;
   UCHAR   StatusReg;
   ULONG    j ;


   for( j=0 ; j<TIMEOUT_FOR_READY ; j++ ){
     StatusReg = ScsiPortReadPortUchar( (PUCHAR)IO_Ports[STATUS_REG] ) ;
//401   if( !(StatusReg & 0x88) )
        if( !(StatusReg & 0x80) )
        break;
   }

   pDevExt->LuExt.StatusReg = StatusReg;

//401return (!(StatusReg & 0x88) ? CD_SUCCESS : CD_FAILURE ) ;
   return (!(StatusReg & 0x80) ? CD_SUCCESS : CD_FAILURE ) ;
}

/*==========================================================================*/
/*  WaitRdyForPacket                                                        */
/*    Function  : Wait for Ready to send ATAPI packet command               */
/*    Caller    :                                                           */
/*    Arguments : none                                                      */
/*    Returns   : CD_SUCCESS or CD_FAILURE                                  */
/*==========================================================================*/
USHORT WaitRdyForPacket( PCD400_DEV_EXTENSION pDevExt )
{
   PULONG   IO_Ports = pDevExt->IO_Ports;
   UCHAR    data, StatusReg;
   USHORT   i ;
   ULONG    j ;


   for( j=0 ; j<TIMEOUT_FOR_READY ; j++ ){
     StatusReg = ScsiPortReadPortUchar( (PUCHAR)IO_Ports[STATUS_REG] ) ;
     if( !(StatusReg & 0x80) )
        break;
   }

   pDevExt->LuExt.StatusReg = StatusReg;

   if ((StatusReg & 0x08) != 0x08){    /* Check Dreq Bit on                 */
     pDevExt->LuExt.CmdErrorStatus = PROTOCOL_ERROR;
     return(CD_FAILURE) ;
   }


   i=0xFFFF;
   do {                                /* Check Interrupt Reason Register   */
     data = ScsiPortReadPortUchar( (PUCHAR)IO_Ports[INTREASON_REG] ) ;
     data &= 0x03;
     i-- ;
   } while ( ((data & 0x03) != 0x01) && (i!= 0)) ;

   if (data != 0x01){
     pDevExt->LuExt.CmdErrorStatus = PROTOCOL_ERROR;
     return(CD_FAILURE) ;
   }

   return(CD_SUCCESS) ;
}

/*==========================================================================*/
/*  WaitBusyClear                                                           */
/*    Function  : Wait for Busy bit clear                                   */
/*    Caller    :                                                           */
/*    Arguments : none                                                      */
/*    Returns   : CD_SUCCESS or CD_FAILURE                                  */
/*==========================================================================*/
USHORT WaitBusyClear( PCD400_DEV_EXTENSION pDevExt )
{
   PULONG  IO_Ports = pDevExt->IO_Ports;
   UCHAR   StatusReg;
   UCHAR   cardreg ;
   ULONG   j, limit ;

/*
*   switch( pDevExt->LuExt.CommandType ){
*     case FIRST_CMD :
*       limit = TIMEOUT_LONG;
*       break;
*     case IMMEDIATE_CMD :
*       limit = TIMEOUT_SHORT;
*       break;
*     default :
*       limit = TIMEOUT_FOR_INT;
*   }
*
*   if( pDevExt->LuExt.TimeOutCount != 0 )
*     limit = TIMEOUT_FOR_RETRY;
*
*   for( j=0 ; j<limit ; j++ ){
*     cardreg = ScsiPortReadPortUchar( (PUCHAR)IO_Ports[INTMASK_REG] );
*     if( cardreg & 0x01 )
*       break;
*   }
*
*   if ( !(cardreg & 0x01) ){
*     pDevExt->LuExt.CmdErrorStatus = COMMUNICATION_TIMEOUT;
*     return(CD_FAILURE) ;
*   }
*/

   for( j=0 ; j<TIMEOUT_FOR_READY ; j++ ){
     StatusReg = ScsiPortReadPortUchar( (PUCHAR)IO_Ports[STATUS_REG] ) ;
     if( !(StatusReg & 0x80) )
        break;
   }

   pDevExt->LuExt.StatusReg = StatusReg;

   if ( StatusReg & 0x80 ){
     pDevExt->LuExt.CmdErrorStatus = COMMUNICATION_TIMEOUT;
     return(CD_FAILURE) ;
   }

   return ( CD_SUCCESS ) ;
}

/*==========================================================================*/
/*  IO_Delay                                                                */
/*    Function  : Delay IO operation                                        */
/*    Caller    :                                                           */
/*    Arguments : none                                                      */
/*    Returns   : none                                                      */
/*==========================================================================*/
void IO_Delay( void )
{
   USHORT  i ;
   for (i = 0 ; i < 10 ; i++) ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaide\hyperdisk.c ===
/************************************************************************

Copyright (c) 1997-99  American Megatrends Inc.,

Module Name:

	HyperDisk.c

Abstract:

    Source for HyperDisk PCI IDERAID Controller.

Author:

	Neela Syam Kolli
    Eric Moore
    Vasudevan Srinivasan

Revision History:

    29 March 2000 - Vasudevan
    - Rewritten for Clarity
    - Removed ATAPI Stuff

    October 11 2000 - Syam
    - The problem of giving the Raid10 stripe size as zero to the utility is fixed.
    - The Maximum number of outstanding commands for Raid10 are made equal to the Raid0 (it was equal to Raid1)

**************************************************************************/

#include "HDDefs.h"

#include "devioctl.h"
#include "miniport.h"

#if defined(HYPERDISK_WINNT) || defined(HYPERDISK_WIN2K)

#include "ntdddisk.h"
#include "ntddscsi.h"

#endif // defined(HYPERDISK_WINNT) || defined(HYPERDISK_WIN2K)

#ifdef HYPERDISK_WIN98

#include "9xdddisk.h"
#include "9xddscsi.h"

#endif // HYPERDISK_WIN98

#include "RIIOCtl.h"
#include "ErrorLog.h"

#include "HyperDisk.h"
#include "raid.h"

#include "LocalFunctions.h"

UCHAR                   gucControllerCount = 0;
BOOLEAN                 gbFinishedScanning = FALSE;
CARD_INFO               gaCardInfo[MAX_CONTROLLERS];
UCHAR                   gaucIRCDData[IDE_SECTOR_SIZE];
BOOLEAN                 bFoundIRCD = FALSE;
LARGE_INTEGER           gIRCDLockTime;
UCHAR                   gcIRCDLocked;
ULONG                   gulIRCDUnlockKey;
UCHAR                   gucStatusChangeFlag;
BOOLEAN                 gbDoNotUnlockIRCD = FALSE;
IDE_VERSION	            gFwVersion = {0}; // version of hyperdsk card

#define                 DEFAULT_DISPLAY_VALUE       3

// Begin Vasu
// gucDummyIRCD variable to hold dummy IRCD Information.

#ifdef DUMMY_RAID10_IRCD

UCHAR gucDummyIRCD[512] = {

/*
    IRCD Structure

    Logical Drive:  RAID 10, with 2 Stripes and 4 Drives with Online Status.
                    
                    1st Mirror : Primary Master and Secondary Master.
                    2nd Mirror : Primary Slave and Secondary Slave.
*/

    0x24, 0x58, 0x49, 0x44, 0x45, 0x24, 0x10, 0x0F, 0x32, 0x30, 0x06, 0x01, 0x04, 0x00, 0x00, 0x00,
    0x03, 0x10, 0x80, 0x00, 0x02, 0x04, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0xC0, 0xFB, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // PM
    0x10, 0x10, 0xC0, 0xFB, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // SM
    0x01, 0x10, 0x30, 0x20, 0x30, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // PS
    0x11, 0x10, 0x30, 0x20, 0x30, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00      // SS

};

#endif // DUMMY_RAID10_IRCD

// End Vasu

#ifdef HYPERDISK_WINNT

UCHAR                   gucNextControllerInd = 0;
BOOLEAN                 gbManualScan = FALSE;
BOOLEAN                 gbFindRoutineVisited = FALSE;

#endif

ULONG                   gulChangeIRCDPending;
ULONG                   gulLockVal;
ULONG                   gulPowerFailedTargetBitMap;

#ifdef DBG

ULONG SrbCount = 0;

#endif // DBG

VOID
AtapiHexToString (
	IN ULONG Value,
	IN OUT PCHAR *Buffer
)

{
	PCHAR  string;
	PCHAR  firstdig;
	CHAR   temp;
	ULONG i;
	USHORT digval;

	string = *Buffer;

	firstdig = string;

	for (i = 0; i < 4; i++) 
    {
		digval = (USHORT)(Value % 16);
		Value /= 16;

		//
		// convert to ascii and store. Note this will create
		// the buffer with the digits reversed.
		//

		if (digval > 9) 
        {
			*string++ = (char) (digval - 10 + 'a');
		} 
        else 
        {
			*string++ = (char) (digval + '0');
		}
	}

	//
	// Reverse the digits.
	//

	*string-- = '\0';

	do 
    {
		temp = *string;
		*string = *firstdig;
		*firstdig = temp;
		--string;
		++firstdig;
	} while (firstdig < string);

} // end AtapiHexToString ()

BOOLEAN
AtapiHwInitialize(
	IN PHW_DEVICE_EXTENSION DeviceExtension
)

/*++

Routine Description:

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

	TRUE - if initialization successful.
	FALSE - if initialization unsuccessful.

--*/

{
	UCHAR maxDrives;
	UCHAR targetId;
	UCHAR channel;
	UCHAR statusByte, errorByte;
	UCHAR uchMRDMODE = 0;
	PBM_REGISTERS BMRegister = NULL;

#ifdef HYPERDISK_WIN2K

    if ( !DeviceExtension->bIsThruResetController )
    {
        //SetPCISpace(DeviceExtension);
        InitIdeRaidControllers(DeviceExtension);
    }

#endif // HYPERDISK_WIN2K

    //
    // Adjust SGL's buffer pointer for the physical drive
    //
    AssignSglPtrsForPhysicalCommands(DeviceExtension);

    EnableInterrupts (DeviceExtension);

    // Begin Vasu - 05 March 2001
    // Copied from the SetPCISpace function to here as SetPCISpace is not
    // called during initialization.
    BMRegister = DeviceExtension->BaseBmAddress[0];
    uchMRDMODE = ScsiPortReadPortUchar(((PUCHAR)BMRegister + 1));
    uchMRDMODE &= 0xF0; // Dont Clear Interrupt Pending Flags.
    uchMRDMODE |= 0x01; // Make it Read Multiple
    ScsiPortWritePortUchar(((PUCHAR)BMRegister + 1), uchMRDMODE);
    // End Vasu

    if ( !DeviceExtension->bIsThruResetController )
    {
        // Through the port driver directly... BIOS took care of everything... let us not worry anything about it
        return TRUE;
    }

	DebugPrint((3, "\nAtapiHwInitialize: Entering routine.\n"));

	for (targetId = 0; targetId < MAX_DRIVES_PER_CONTROLLER; targetId++) 
    {

        if ( DeviceExtension->PhysicalDrive[targetId].TimeOutErrorCount >= MAX_TIME_OUT_ERROR_COUNT )
        {
            continue;   // This drive has lost the power.... let us not do anything to this drive
        }

        DebugPrint((0,"AHI"));

		if (DeviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT) 
        {
			channel = targetId >> 1;

			if (!(DeviceExtension->DeviceFlags[targetId] & DFLAGS_ATAPI_DEVICE)) 
            {
				//
				// Enable media status notification
				//
				IdeMediaStatus(TRUE, DeviceExtension, targetId);

				//
				// If supported, setup Multi-block transfers.
				//

                SetMultiBlockXfers(DeviceExtension, targetId);
			} 
		}
	}

    DebugPrint((0,"AHI-D"));

	return TRUE;

} // end AtapiHwInitialize()


BOOLEAN
SetMultiBlockXfers( 
	IN PHW_DEVICE_EXTENSION DeviceExtension,
    UCHAR ucTargetId
        )
{
	PIDE_REGISTERS_1	    baseIoAddress;
    UCHAR                   statusByte, errorByte;

	baseIoAddress = DeviceExtension->BaseIoAddress1[ucTargetId>>1];
    //
    // If supported, setup Multi-block transfers.
    //

    if (DeviceExtension->MaximumBlockXfer[ucTargetId] != 0) 
    {
		//
		// Select the device.
		//

        SELECT_DEVICE(baseIoAddress, ucTargetId);

		//
		// Setup sector count to reflect the # of blocks.
		//

		ScsiPortWritePortUchar(&baseIoAddress->SectorCount,
				   DeviceExtension->MaximumBlockXfer[ucTargetId]);

		//
		// Issue the command.
		//

		ScsiPortWritePortUchar(&baseIoAddress->Command,
							   IDE_COMMAND_SET_MULTIPLE);

		//
		// Wait for busy to drop.
		//

		WAIT_ON_BASE_BUSY(baseIoAddress,statusByte);

		//
		// Check for errors. Reset the value to 0 (disable MultiBlock) if the
		// command was aborted.
		//

		if (statusByte & IDE_STATUS_ERROR) 
        {

            //
            // Read the error register.
            //

            errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress + 1);

            DebugPrint((0,
			            "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
			            statusByte,
			            errorByte));
            //
            // Adjust the devExt. value, if necessary.
            //

            DeviceExtension->MaximumBlockXfer[ucTargetId] = 0;

		} 
        else 
        {
			DebugPrint((2,
						"AtapiHwInitialize: Using Multiblock on TID %d. Blocks / int - %d\n",
			ucTargetId,
			DeviceExtension->MaximumBlockXfer[ucTargetId]));
	    }
    }

    return TRUE;
}

VOID
changePCIConfiguration(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
    ULONG ulUpdationLength,
    ULONG ulOffset,
    ULONG ulAndVal,
    ULONG ulOrVal,
    BOOLEAN bSetThisVal
)
{
    ULONG length;
    IDE_PCI_REGISTERS pciRegisters;
    PUCHAR  pucPCIVal = (PUCHAR)&pciRegisters;

	//
	// Get the PIIX4 IDE PCI registers.
	//

	length = ScsiPortGetBusData(
				DeviceExtension,
				PCIConfiguration,
				DeviceExtension->BusNumber,
				DeviceExtension->PciSlot.u.AsULONG,
				&pciRegisters,
				sizeof(IDE_PCI_REGISTERS)
				);

	if (length != sizeof(IDE_PCI_REGISTERS)) 
    {
		return;//(FALSE);
	}

    if ( bSetThisVal )
    {
        switch ( ulUpdationLength )
        {
            case 1:
                pucPCIVal[ulOffset] &= (UCHAR)ulAndVal;
                pucPCIVal[ulOffset] |= (UCHAR)ulOrVal;
                break;
            case 2:
                *((PUSHORT)(pucPCIVal+ulOffset)) &= (USHORT)ulAndVal;
                *((PUSHORT)(pucPCIVal+ulOffset)) |= (USHORT)ulOrVal;
                break;
            case 4:
                *((PULONG)(pucPCIVal+ulOffset)) = (ULONG)ulAndVal;
                *((PULONG)(pucPCIVal+ulOffset)) = (ULONG)ulOrVal;
                break;
        }
    }

	length = ScsiPortSetBusDataByOffset(
				DeviceExtension,
				PCIConfiguration,
				DeviceExtension->BusNumber,
				DeviceExtension->PciSlot.u.AsULONG,
                (PVOID)&(pucPCIVal[ulOffset]),
				ulOffset,
				ulUpdationLength
				);
    return;
}

ULONG
AtapiParseArgumentString(
	IN PCHAR String,
	IN PCHAR KeyWord
)

/*++

Routine Description:

	This routine will parse the string for a match on the keyword, then
	calculate the value for the keyword and return it to the caller.

Arguments:

	String - The ASCII string to parse.
	KeyWord - The keyword for the value desired.

Return Values:

	Zero if value not found
	Value converted from ASCII to binary.

--*/

{
	PCHAR cptr;
	PCHAR kptr;
	ULONG value;
	ULONG stringLength = 0;
	ULONG keyWordLength = 0;
	ULONG index;

	if (!String) 
    {
		return 0;
	}
	if (!KeyWord) 
    {
		return 0;
	}

	//
	// Calculate the string length and lower case all characters.
	//

	cptr = String;
	while (*cptr) 
    {
		if (*cptr >= 'A' && *cptr <= 'Z') 
        {
			*cptr = *cptr + ('a' - 'A');
		}
		cptr++;
		stringLength++;
	}

	//
	// Calculate the keyword length and lower case all characters.
	//

	cptr = KeyWord;
	while (*cptr) 
    {
		if (*cptr >= 'A' && *cptr <= 'Z') 
        {
			*cptr = *cptr + ('a' - 'A');
		}
		cptr++;
		keyWordLength++;
	}

	if (keyWordLength > stringLength) 
    {
		//
		// Can't possibly have a match.
		//

		return 0;
	}

	//
	// Now setup and start the compare.
	//

	cptr = String;

ContinueSearch:

	//
	// The input string may start with white space.	 Skip it.
	//

	while (*cptr == ' ' || *cptr == '\t') 
    {
		cptr++;
	}

	if (*cptr == '\0') 
    {
		//
		// end of string.
		//

		return 0;
	}

	kptr = KeyWord;
	while (*cptr++ == *kptr++) 
    {
		if (*(cptr - 1) == '\0') 
        {
			//
			// end of string
			//

			return 0;
		}
	}

	if (*(kptr - 1) == '\0') 
    {
		//
		// May have a match backup and check for blank or equals.
		//

		cptr--;
		while (*cptr == ' ' || *cptr == '\t') 
        {
			cptr++;
		}

		//
		// Found a match.  Make sure there is an equals.
		//

		if (*cptr != '=') 
        {
			//
			// Not a match so move to the next semicolon.
			//

			while (*cptr) 
            {
				if (*cptr++ == ';') 
                {
					goto ContinueSearch;
				}
			}
			return 0;
		}

		//
		// Skip the equals sign.
		//

		cptr++;

		//
		// Skip white space.
		//

		while ((*cptr == ' ') || (*cptr == '\t')) 
        {
			cptr++;
		}

		if (*cptr == '\0') 
        {

			//
			// Early end of string, return not found
			//

			return 0;
		}

		if (*cptr == ';') 
        {

			//
			// This isn't it either.
			//

			cptr++;
			goto ContinueSearch;
		}

		value = 0;
		if ((*cptr == '0') && (*(cptr + 1) == 'x')) 
        {

			//
			// Value is in Hex.	 Skip the "0x"
			//

			cptr += 2;
			for (index = 0; *(cptr + index); index++) 
            {

				if (*(cptr + index) == ' ' ||
					*(cptr + index) == '\t' ||
					*(cptr + index) == ';') 
                {
					 break;
				}

				if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) 
                {
					value = (16 * value) + (*(cptr + index) - '0');
				} 
                else 
                {
					if ((*(cptr + index) >= 'a') && (*(cptr + index) <= 'f')) 
                    {
						value = (16 * value) + (*(cptr + index) - 'a' + 10);
					} 
                    else 
                    {
						//
						// Syntax error, return not found.
						//
						return 0;
					}
				}
			}
		} 
        else 
        {
			//
			// Value is in Decimal.
			//

			for (index = 0; *(cptr + index); index++) 
            {
				if (*(cptr + index) == ' ' ||
					*(cptr + index) == '\t' ||
					*(cptr + index) == ';') 
                {
					 break;
				}

				if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) 
                {
					value = (10 * value) + (*(cptr + index) - '0');
				} 
                else 
                {
					//
					// Syntax error return not found.
					//
					return 0;
				}
			}
		}

		return value;
	} 
    else 
    {
		//
		// Not a match check for ';' to continue search.
		//

		while (*cptr) 
        {
			if (*cptr++ == ';') 
            {
				goto ContinueSearch;
			}
		}

		return 0;
	}

} // end AtapiParseArgumentString()

BOOLEAN
AtapiResetController(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN ULONG PathId
)

/*++

Routine Description:


	Reset IDE controller and/or Atapi device.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage

Return Value:

	Nothing.


--*/

{
	PIDE_REGISTERS_1 baseIoAddress1;
	PIDE_REGISTERS_2 baseIoAddress2;
	UCHAR statusByte, k;
	ULONG ulDeviceNum ;
	PCHANNEL channel;
	UCHAR drive;
    UCHAR ucTargetId;
    PPHYSICAL_DRIVE pPhysicalDrive;

    ScsiPortLogError(DeviceExtension,0,0,0,0,SP_BAD_FW_WARNING,HYPERDISK_RESET_DETECTED);

	DebugPrint((0,"RC"));

    StopBusMasterTransfers(DeviceExtension);    // Issues Stop Transfers to all the controllers

    for(ucTargetId=0;ucTargetId<MAX_DRIVES_PER_CONTROLLER;ucTargetId++) // let us flush cache before resetting the controller so that we will not get the 
    {                                           // data corruption in mirror (has seen when SRB Test going on and power has been taken out
        if ( !( IS_IDE_DRIVE(ucTargetId) ) )       
            continue;

        FlushCache(DeviceExtension, ucTargetId);
    }

    IssuePowerOnResetToDrives(DeviceExtension); // Issues a Power on Reset for each controller

	//
	// Complete all remaining SRBs.
	//

	CompleteOutstandingRequests(DeviceExtension);
    DebugPrint((0,"\nRC 1"));

	//
	// Cleanup internal queues and states.
	//

	for (k = 0; k < MAX_CHANNELS_PER_CONTROLLER; k++) 
    {

		channel = &(DeviceExtension->Channel[k]);

		DeviceExtension->ExpectingInterrupt[k] = 0;

		//
		// Reset ActivePdd.
		//
		channel->ActiveCommand = NULL;

		//
		// Clear request tracking fields.
		//

		DeviceExtension->TransferDescriptor[k].WordsLeft = 0;
		DeviceExtension->TransferDescriptor[k].DataBuffer = NULL;
		DeviceExtension->TransferDescriptor[k].StartSector = 0;
		DeviceExtension->TransferDescriptor[k].Sectors = 0;
		DeviceExtension->TransferDescriptor[k].SglPhysicalAddress = 0;

        for(ulDeviceNum=0;ulDeviceNum<MAX_DRIVES_PER_CHANNEL;ulDeviceNum++)
        {
            ucTargetId = (UCHAR)((k<<1) + ulDeviceNum);
            pPhysicalDrive = &(DeviceExtension->PhysicalDrive[ucTargetId]);
            pPhysicalDrive->ucHead = 0;
            pPhysicalDrive->ucTail = 0;

            if ( !IS_IDE_DRIVE(ucTargetId) )
                continue;

		    if (!DeviceExtension->bSkipSetParameters[ucTargetId]) 
            {
				if (!SetDriveParameters(DeviceExtension, k, (UCHAR)ulDeviceNum))
				{
					DebugPrint((1, "SetDriveParameters Command failed\n"));
                    continue;
				}
            }

			if (!SetDriveFeatures(DeviceExtension, ucTargetId))  
			{
				DebugPrint((1, "SetDriveFeatures Command failed\n"));
                continue;
			}
        }

	} // for (k = 0; k < MAX_CHANNELS_PER_CONTROLLER; k++)

    CheckDrivesResponse(DeviceExtension);

	//
	// Call the HwInitialize routine to setup multi-block.
	//

    DeviceExtension->bIsThruResetController = TRUE; 
    // Informing AtapiHwInitialize that we reset the drive and so it is our responsibility to reprogram the drive.
	AtapiHwInitialize(DeviceExtension);
    DeviceExtension->bIsThruResetController = FALSE;

	//
	// Indicate ready for next request.
	//
	
	ScsiPortNotification(NextRequest, DeviceExtension, NULL);

    DebugPrint((0,"\nRC-D"));

    return TRUE;

} // end AtapiResetController()

BOOLEAN StopBusMasterTransfers(PHW_DEVICE_EXTENSION DeviceExtension)    // Issues Stop Bus Master Transfers to all the controllers
{
	PIDE_REGISTERS_1 baseIoAddress1;
	PIDE_REGISTERS_2 baseIoAddress2;
    PBM_REGISTERS baseBm;
    ULONG ulChannel;
    UCHAR statusByte;

    for(ulChannel=0;ulChannel<MAX_CHANNELS_PER_CONTROLLER;ulChannel++)
    {
		baseIoAddress1 = (PIDE_REGISTERS_1) DeviceExtension->BaseIoAddress1[ulChannel];
		baseIoAddress2 = (PIDE_REGISTERS_2) DeviceExtension->BaseIoAddress2[ulChannel];
        baseBm = DeviceExtension->BaseBmAddress[ulChannel];

        if ( !baseBm )  // There is no Channel at this place
            continue;

		ScsiPortWritePortUchar(&(baseBm->Command.AsUchar), STOP_TRANSFER);

        CLEAR_BM_INT(baseBm, statusByte);

        ScsiPortWritePortUchar(&(baseBm->Status.AsUchar), 0);

        ScsiPortStallExecution(100);

        ScsiPortWritePortUchar(&(baseBm->Status.AsUchar), statusByte);

    }

    return TRUE;
}

BOOLEAN IssuePowerOnResetToDrives(PHW_DEVICE_EXTENSION DeviceExtension) // Issues a Power on Reset for each controller
{

	PIDE_REGISTERS_1 baseIoAddress1;
	PIDE_REGISTERS_2 baseIoAddress2;
    PBM_REGISTERS baseBm;
    ULONG ulController, ulTime, ulDrive, ulChannel;
    UCHAR statusByte;

    for(ulChannel=0;ulChannel<MAX_CHANNELS_PER_CONTROLLER;ulChannel++)
    {
        ULONG ulTargetId, ulWaitLoop;

		baseIoAddress1 = (PIDE_REGISTERS_1) DeviceExtension->BaseIoAddress1[ulChannel];
		baseIoAddress2 = (PIDE_REGISTERS_2) DeviceExtension->BaseIoAddress2[ulChannel];
        baseBm = DeviceExtension->BaseBmAddress[ulChannel];

        // Begin Vasu - 18 Aug 2000
        // Have modified in such a way that a soft reset is issued to the drive only
        // if a drive is identified in that channel.
        for (ulDrive = 0; ulDrive < MAX_DRIVES_PER_CHANNEL; ulDrive++)
        {
            ulTargetId = (ulChannel << 1) + ulDrive;

            if (!(DeviceExtension->DeviceFlags[ulTargetId] & DFLAGS_DEVICE_PRESENT))
                continue;   // Check Next Drive
            else
                break;      // Found atleast one drive, so now break out and reset the drive.
        }
        
        // No Drives are found in this channel if ulDrive equals MAX_DRIVES_PER_CHANNEL. 
        // So continue to the next channel.
        if (ulDrive == MAX_DRIVES_PER_CHANNEL)
            continue;

        // End Vasu.

        IDE_HARD_RESET(baseIoAddress1, baseIoAddress2, ulTargetId, statusByte); // issue soft reset to the drive

	    GET_STATUS(baseIoAddress1, statusByte);
        if ( !statusByte )
        {
	        GET_STATUS(baseIoAddress1, statusByte);
	        DebugPrint((0, "Hard Reset Failed. The Status %X on %ld\n\n\n",
		        (ULONG)statusByte, ulTargetId));
        }

        for(ulDrive=0;ulDrive<MAX_DRIVES_PER_CHANNEL;ulDrive++)
        {
            ulTargetId = (ulChannel << 1) + ulDrive;

            if ( !IS_IDE_DRIVE(ulTargetId) )
                continue;

            SELECT_DEVICE(baseIoAddress1, ulDrive);
            for(ulWaitLoop=0;ulWaitLoop<5;ulWaitLoop++) // total wait time is 5 seconds or till the Busy Bit Gets Cleared
            {
                WAIT_ON_BUSY(baseIoAddress1, statusByte);
                if ( statusByte & 0x80 )
                {
                    DebugPrint((0, "Busy : %X on drive %ld\n", statusByte, ulTargetId));
                }
                else
                {
                    break;
                }
            }
        }
    }

    return TRUE;
}

BOOLEAN CheckDrivesResponse(PHW_DEVICE_EXTENSION DeviceExtension)
{
	PIDE_REGISTERS_1 baseIoAddress1;
	PIDE_REGISTERS_2 baseIoAddress2;
    ULONG ulDriveNum;
    UCHAR statusByte;
    UCHAR aucIdentifyBuf[512];
    ULONG i;

    for(ulDriveNum=0;ulDriveNum<MAX_DRIVES_PER_CONTROLLER;ulDriveNum++)
    {
        if ( !IS_IDE_DRIVE(ulDriveNum) )
            continue;

		baseIoAddress1 = (PIDE_REGISTERS_1) DeviceExtension->BaseIoAddress1[(ulDriveNum>>1)];
		baseIoAddress2 = (PIDE_REGISTERS_2) DeviceExtension->BaseIoAddress2[(ulDriveNum>>1)];

	    //
	    // Select device 0 or 1.
	    //

	    SELECT_DEVICE(baseIoAddress1, ulDriveNum);

	    //
	    // Check that the status register makes sense.
	    //

        // The call came here since there is a drive ... so let us not worry about whether there is any drive at this place
	    GET_BASE_STATUS(baseIoAddress1, statusByte);    

	    //
	    // Load CylinderHigh and CylinderLow with number bytes to transfer.
	    //

	    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, (0x200 >> 8));
	    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,  (0x200 & 0xFF));

        WAIT_ON_BUSY(baseIoAddress1, statusByte);

	    //
	    // Send IDENTIFY command.
	    //
	    WAIT_ON_BUSY(baseIoAddress1,statusByte);

	    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_IDENTIFY);

	    WAIT_ON_BUSY(baseIoAddress1,statusByte);

        if ( ( !( statusByte & IDE_STATUS_BUSY ) ) && ( !( statusByte & IDE_STATUS_DRQ ) ) )
        {
            // this is an error... so let us not try any more.
            FailDrive(DeviceExtension, (UCHAR)ulDriveNum);
            continue;
        }

        WAIT_ON_BUSY(baseIoAddress1,statusByte);

	    //
	    // Wait for DRQ.
	    //

	    for (i = 0; i < 4; i++) 
        {
		    WAIT_FOR_DRQ(baseIoAddress1, statusByte);

		    if (statusByte & IDE_STATUS_DRQ)
            {
                break;
            }
        }

	    //
	    // Read status to acknowledge any interrupts generated.
	    //

	    GET_BASE_STATUS(baseIoAddress1, statusByte);

	    //
	    // Check for error on really stupid master devices that assert random
	    // patterns of bits in the status register at the slave address.
	    //

	    if ((statusByte & IDE_STATUS_ERROR)) 
        {
            FailDrive(DeviceExtension, (UCHAR)ulDriveNum);
            continue;
	    }

	    DebugPrint((1, "CheckDrivesResponse: Status before read words %x\n", statusByte));

	    //
	    // Suck out 256 words. After waiting for one model that asserts busy
	    // after receiving the Packet Identify command.
	    //

	    WAIT_ON_BUSY(baseIoAddress1,statusByte);

	    if ( (!(statusByte & IDE_STATUS_DRQ)) || (statusByte & IDE_STATUS_BUSY) ) 
        {
            FailDrive(DeviceExtension, (UCHAR)ulDriveNum);
            continue;
	    }

	    READ_BUFFER(baseIoAddress1, (PUSHORT)aucIdentifyBuf, 256);

	    //
	    // Work around for some IDE and one model Atapi that will present more than
	    // 256 bytes for the Identify data.
	    //

	    WAIT_ON_BUSY(baseIoAddress1,statusByte);

	    for (i = 0; i < 0x10000; i++) 
        {
		    GET_STATUS(baseIoAddress1,statusByte);

		    if (statusByte & IDE_STATUS_DRQ) 
            {
			    //
			    // Suck out any remaining bytes and throw away.
			    //

			    ScsiPortReadPortUshort(&baseIoAddress1->Data);

		    } 
            else 
            {
			    break;
		    }
        }
    }

    return TRUE;
}

VOID
AtapiStrCpy(
	IN PUCHAR Destination,
	IN PUCHAR Source
)

{
	// Begin Vasu - 03 January 2001
	// Sanity Check
	if ((Source == NULL) || (Destination == NULL))
		return;
	// End Vasu

	*Destination = *Source;

	while (*Source != '\0') 
    {
		*Destination++ = *Source++;
	}

	return;

} // end AtapiStrCpy()

LONG
AtapiStringCmp (
	PCHAR FirstStr,
	PCHAR SecondStr,
	ULONG Count
)

{
	UCHAR  first ,last;

	if (Count) 
    {
		do 
        {

			//
			// Get next char.
			//

			first = *FirstStr++;
			last = *SecondStr++;

			if (first != last) 
            {

				//
				// If no match, try lower-casing.
				//

				if (first>='A' && first<='Z') 
                {
					first = first - 'A' + 'a';
				}
				if (last>='A' && last<='Z') 
                {
					last = last - 'A' + 'a';
				}
				if (first != last) 
                {
					//
					// No match
					//

					return first - last;
				}
			}
		}while (--Count && first);
	}

	return 0;

} // end AtapiStringCmp()
PUCHAR
AtapiMemCpy(
            PUCHAR pDst,
            PUCHAR pSrc,
            ULONG ulCount
            )
{
    ULONG ulTemp = ulCount & 0x03;
    _asm
    {

        push esi
        push edi
        push ecx
        pushf
        cld

        mov ecx, ulCount
        mov esi, pSrc
        mov edi, pDst
        shr ecx, 2      ; Copy a DWORD At a Time
        rep movsd

        mov ecx, ulTemp
        rep movsb

        mov eax, pDst

        popf
        pop ecx
        pop edi
        pop esi
    }


//    for(ulTemp=0;ulTemp<ulCount;ulTemp++)
//        pDst[ulTemp] = pSrc[ulTemp];

}
        
VOID
AtapiFillMemory(
            PUCHAR pDst,
            ULONG ulCount,
            UCHAR ucFillChar
            )
{
    ULONG ulTemp = ulCount & 0x03;

    _asm
    {
        push edi
        push ecx
        push eax
        pushf
        cld

        mov   al, ucFillChar
        shl eax, 8
        mov   al, ucFillChar
        shl eax, 8
        mov   al, ucFillChar
        shl eax, 8
        mov   al, ucFillChar

        mov ecx, ulCount
        mov edi, pDst
        shr ecx, 2      ; Copy a DWORD At a Time
        rep stosd

        movzx ecx, ulTemp
        rep stosb

        popf
        pop eax
        pop ecx
        pop edi
    }

//    for(ulTemp=0;ulTemp<ulCount;ulTemp++)
//        pDst[ulTemp] = ucFillChar;



}


VOID
AtapiCopyString(
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Count
)
{
    ULONG i = 0;

	// Begin Vasu - 03 January 2001
	// Sanity Check
	if ((Source == NULL) || (Destination == NULL))
		return;
	// End Vasu

    for (i = 0; i < Count; i++)
    {
        if (Source[i] == '\0')
            break;
        Destination[i] = Source[i];
    }
} // end AtapiCopyString()

BOOLEAN
GetTransferMode(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR TargetId
)
{
	PIDENTIFY_DATA capabilities;
	CHAR message[16];
    capabilities = &(DeviceExtension->FullIdentifyData[TargetId]);

    DeviceExtension->TransferMode[TargetId] = PioMode0;    // By default assume this drive is PioMode 0

	if (capabilities->AdvancedPioModes != 0) 
    {

		if (capabilities->AdvancedPioModes & IDENTIFY_PIO_MODE4) 
        {
            DeviceExtension->TransferMode[TargetId] = PioMode4;
		} 
        else 
        {
            if (capabilities->AdvancedPioModes & IDENTIFY_PIO_MODE3) 
            {
                DeviceExtension->TransferMode[TargetId] = PioMode3;
		    } 
            else 
            {
                DeviceExtension->TransferMode[TargetId] = PioMode0;
            }
        }
    }

    if ( capabilities->MultiWordDmaActive )
    {
        switch ( capabilities->MultiWordDmaActive )
        {
            case 1:
                DeviceExtension->TransferMode[TargetId] = DmaMode0;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_DMA;
                break;

            case 2:
                DeviceExtension->TransferMode[TargetId] = DmaMode1;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_DMA;
                break;

            case 4:
                DeviceExtension->TransferMode[TargetId] = DmaMode2;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_DMA;
                break;
        }
    }

    if ( capabilities->UltraDmaActive )
    {
        switch ( capabilities->UltraDmaActive )
        {
            case 1:
                DeviceExtension->TransferMode[TargetId] = UdmaMode0;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_UDMA;
                break;

            case 2:
                DeviceExtension->TransferMode[TargetId] = UdmaMode1;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_UDMA;
                break;

            case 4:
                DeviceExtension->TransferMode[TargetId] = UdmaMode2;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_UDMA;
                break;
            case 8:
                DeviceExtension->TransferMode[TargetId] = UdmaMode3;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_UDMA;
                break;

            case 0x10:
                DeviceExtension->TransferMode[TargetId] = UdmaMode4;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_UDMA;
                break;
            case 0x20:
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_UDMA;
                if ( Udma100 == DeviceExtension->ControllerSpeed )
                    DeviceExtension->TransferMode[TargetId] = UdmaMode5;
                else
                    DeviceExtension->TransferMode[TargetId] = UdmaMode4;
                break;
        }
    }

    return  TRUE;
}

VOID
CompleteOutstandingRequests(
	PHW_DEVICE_EXTENSION DeviceExtension
)

{
	ULONG i;
	PSCSI_REQUEST_BLOCK srb;
	PSRB_EXTENSION SrbExtension;

	for (i = 0; (i < DeviceExtension->ucMaxPendingSrbs) && (DeviceExtension->PendingSrbs != 0); i++) 
    {
		if (DeviceExtension->PendingSrb[i] != NULL) 
        {
			srb = DeviceExtension->PendingSrb[i];

			srb->SrbStatus = SRB_STATUS_BUS_RESET;

			SrbExtension = srb->SrbExtension;

            if ( SCSIOP_INTERNAL_COMMAND == srb->Cdb[0] )
            {
               srb->TargetId = SrbExtension->ucOriginalId;
            }
            // It is an Internal Srb, so let us not post the completion status
			ScsiPortNotification(RequestComplete, DeviceExtension, srb);
		
			DeviceExtension->PendingSrb[i] = NULL;

			DeviceExtension->PendingSrbs--;
		}
	}

	return;

} // end CompleteOutstandingRequests()

ULONG
DriverEntry(
	IN PVOID DriverObject,
	IN PVOID Argument2
)

/*++

Routine Description:

	Installable driver initialization entry point for system.

Arguments:

	Driver Object

Return Value:

	Status from ScsiPortInitialize()

--*/

{
	HW_INITIALIZATION_DATA hwInitializationData;
	ULONG				   adapterCount;
	ULONG				   i;
	ULONG				   statusToReturn, newStatus, ulControllerType;

	DebugPrint((1,"\n\nATAPI IDE MiniPort Driver\n"));

	statusToReturn = 0xffffffff;

	//
	// Zero out structure.
	//

	AtapiFillMemory(((PUCHAR)&hwInitializationData), sizeof(HW_INITIALIZATION_DATA), 0);

	//
	// Set size of hwInitializationData.
	//

	hwInitializationData.HwInitializationDataSize = sizeof(HW_INITIALIZATION_DATA);

	//
	// Set entry points.
	//

	hwInitializationData.HwInitialize = AtapiHwInitialize;
	hwInitializationData.HwResetBus = AtapiResetController;
	hwInitializationData.HwStartIo = AtapiStartIo;
    hwInitializationData.HwInterrupt = AtapiInterrupt;
	hwInitializationData.HwFindAdapter = FindIdeRaidControllers;

#ifdef HYPERDISK_WIN2K
	hwInitializationData.HwAdapterControl = HyperDiskPnPControl;
#endif // HYPERDISK_WIN2K


    //
    // Specify size of extensions.
    //

    hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    hwInitializationData.SpecificLuExtensionSize =0;
    
#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY
    hwInitializationData.SrbExtensionSize = 0;
#else // HD_ALLOCATE_SRBEXT_SEPERATELY
    hwInitializationData.SrbExtensionSize = sizeof(SRB_EXTENSION);
#endif // HD_ALLOCATE_SRBEXT_SEPERATELY

	//
	// Indicate PIO device.
	//
	hwInitializationData.MapBuffers = TRUE;

    // Begin Vasu - 27 March 2001
    // Set NeedPhysicalAddresses to TRUE always as we use ScsiPort routines
    // now for memory related stuff.
    //
	// Indicate we'll call SCSI Port address conversion functions.
	//
	hwInitializationData.NeedPhysicalAddresses = TRUE;
    // End Vasu

    //
	// Enable multiple requests per LUN, since we do queuing.
	//
	hwInitializationData.MultipleRequestPerLu = TRUE;
	hwInitializationData.TaggedQueuing = TRUE;

	//
	// Pick just one adapter for this release.
	//
#ifdef HYPERDISK_WIN98
	hwInitializationData.NumberOfAccessRanges = 6;
#else
	hwInitializationData.NumberOfAccessRanges = 5;
#endif

	hwInitializationData.AdapterInterfaceType = PCIBus;

#ifdef HYPERDISK_WINNT
    gbFindRoutineVisited = FALSE;
#endif

    // let us try for different controllers
    for(ulControllerType=0;ulControllerType<NUM_NATIVE_MODE_ADAPTERS;ulControllerType++)
    {
        hwInitializationData.VendorId             = CMDAdapters[ulControllerType].VendorId;
        hwInitializationData.VendorIdLength       = (USHORT) CMDAdapters[ulControllerType].VendorIdLength;
        hwInitializationData.DeviceId             = CMDAdapters[ulControllerType].DeviceId;
        hwInitializationData.DeviceIdLength       = (USHORT) CMDAdapters[ulControllerType].DeviceIdLength;

        newStatus = ScsiPortInitialize(DriverObject,
                                           Argument2,
                                           &hwInitializationData,
                                           NULL);
	    if (newStatus < statusToReturn) 
        {
		    statusToReturn = newStatus;
	    }
    }

#ifdef HYPERDISK_WINNT
    if ( !gbFindRoutineVisited )
    {   // let us give it a last try ... for the machines like MegaPlex and FlexTel machines
        // for these type of machines the Port Driver somehow doesn't call our Find Routine if we
        // specify the Vendor Id and Device Id... so we will tell him zero for all the Ids and this 
        // will certainly cause the Port Driver to call our Find Routine whether card is present or not

        gbManualScan = TRUE;

        hwInitializationData.VendorId             = 0;
        hwInitializationData.VendorIdLength       = 0;
        hwInitializationData.DeviceId             = 0;
        hwInitializationData.DeviceIdLength       = 0;

        newStatus = ScsiPortInitialize(DriverObject,
                                           Argument2,
                                           &hwInitializationData,
                                           NULL);
	    if (newStatus < statusToReturn) 
        {
		    statusToReturn = newStatus;
	    }

        gbManualScan = FALSE;
    }
#endif

	return statusToReturn;

} // end DriverEntry() 

VOID
ExposeSingleDrives(
	IN PHW_DEVICE_EXTENSION DeviceExtension
)

{
	UCHAR targetId;
#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY
    DeviceExtension->ucMaxPendingSrbs   = MAX_PENDING_SRBS;
    DeviceExtension->ucOptMaxQueueSize  = OPT_QUEUE_MAX_SIZE;
    DeviceExtension->ucOptMinQueueSize  = OPT_QUEUE_MIN_SIZE;
#else
    DeviceExtension->ucMaxPendingSrbs   = STRIPING_MAX_PENDING_SRBS;
    DeviceExtension->ucOptMaxQueueSize  = STRIPING_OPT_QUEUE_MAX_SIZE;
    DeviceExtension->ucOptMinQueueSize  = STRIPING_OPT_QUEUE_MIN_SIZE;
#endif

	for (targetId = 0; targetId < MAX_DRIVES_PER_CONTROLLER; targetId++) 
    {
		if ((DeviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT) &&
			!DeviceExtension->PhysicalDrive[targetId].Hidden) 
        {
			DeviceExtension->IsSingleDrive[targetId] = TRUE;
		}

#ifndef HD_ALLOCATE_SRBEXT_SEPERATELY
        if ( ( Raid1  == DeviceExtension->LogicalDrive[targetId].RaidLevel ) || 
             ( Raid10 == DeviceExtension->LogicalDrive[targetId].RaidLevel ) 
           )
        {
            DeviceExtension->ucMaxPendingSrbs   = MIRROR_MAX_PENDING_SRBS;
            DeviceExtension->ucOptMaxQueueSize  = MIRROR_OPT_QUEUE_MAX_SIZE;
            DeviceExtension->ucOptMinQueueSize  = MIRROR_OPT_QUEUE_MIN_SIZE;
        }
#endif
	}

    // Begin Vasu - 16 December 2000
    // If there is a single drive in the system, then the MaxTransferLength 
    // must be made to 1, irrespective of whether there are any RAID arrays in
    // the system
    DeviceExtension->ulMaxStripesPerRow = (ULONG) 1;
    // End Vasu

	return;

} // end ExposeSingleDrives()

BOOLEAN
IsDrivePresent(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR ucTargetId
)
{
	PIDE_REGISTERS_1	 baseIoAddress1 = DeviceExtension->BaseIoAddress1[ucTargetId>>1];
	PIDE_REGISTERS_2	 baseIoAddress2 = DeviceExtension->BaseIoAddress2[ucTargetId>>1];
    UCHAR ucStatus, ucStatus2;
    ULONG ulCounter;
    UCHAR ucDrvSelVal, ucReadDrvNum;

    SELECT_DEVICE(baseIoAddress1, ucTargetId);

    GET_STATUS(baseIoAddress1, ucStatus);

    if ( 0xff == ucStatus )
        return FALSE;

    for(ulCounter=0;ulCounter<350;ulCounter++)  // 350 * 60us = 21000us = 21ms time out
    {
        ScsiPortStallExecution(60);

        GET_STATUS(baseIoAddress1, ucStatus2);

        ucStatus2 |= ucStatus;

        ucStatus2 &= 0xc9;

        if ( !( ucStatus2  & 0xc9 ) )
            return TRUE;
    }

    SELECT_DEVICE(baseIoAddress1, ucTargetId);

	ScsiPortWritePortUchar(&baseIoAddress1->SectorCount, 0xff);

    ScsiPortStallExecution(60);

    ucReadDrvNum = ScsiPortReadPortUchar(&baseIoAddress1->DriveSelect);

    ucDrvSelVal = IDE_CHS_MODE | ((ucTargetId & 0x01) << 4);

    if ( ucReadDrvNum == ucDrvSelVal )
        return TRUE;
    else
        return FALSE;
}

BOOLEAN
FindDevices(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR Channel
)

/*++

Routine Description:

	This routine is called from FindIDERAIDController to identify
	devices attached to an IDE controller.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	Channel	- The number of the channel to scan.

Return Value:

	TRUE - True if devices found.

--*/

{
	PIDE_REGISTERS_1	 baseIoAddress1 = DeviceExtension->BaseIoAddress1[Channel];
	PIDE_REGISTERS_2	 baseIoAddress2 = DeviceExtension->BaseIoAddress2[Channel];
	BOOLEAN				 deviceResponded = FALSE,
						 skipSetParameters = FALSE;
	ULONG				 waitCount = 10000;
	UCHAR				 deviceNumber;
	UCHAR				 i;
	UCHAR				 signatureLow,
						 signatureHigh;
	UCHAR				 statusByte;
	UCHAR				 targetId;

	//
	// Clear expecting interrupt flags.
	//

	DeviceExtension->ExpectingInterrupt[Channel] = 0;

	//
	// Search for devices.
	//

	for (deviceNumber = 0; deviceNumber < 2; deviceNumber++) 
    {
		targetId = (Channel << 1) + deviceNumber;

        if ( !IsDrivePresent(DeviceExtension, targetId) )
            continue;

		//
		// Issue IDE Identify. If an Atapi device is actually present, the signature
		// will be asserted, and the drive will be recognized as such.
		//

		if (IssueIdentify(DeviceExtension, deviceNumber, Channel, IDE_COMMAND_IDENTIFY)) 
        {
			//
			// IDE drive found.
			//

			DebugPrint((1, "FindDevices: TID %d is IDE\n", targetId));

			DeviceExtension->DeviceFlags[targetId] |= DFLAGS_DEVICE_PRESENT;

			deviceResponded = TRUE;

			//
			// Indicate IDE - not ATAPI device.
			//

			DeviceExtension->DeviceFlags[targetId] &= ~DFLAGS_ATAPI_DEVICE;

			DeviceExtension->PhysicalDrive[targetId].SectorSize = IDE_SECTOR_SIZE;

			DeviceExtension->PhysicalDrive[targetId].MaxTransferLength =
												MAX_BYTES_PER_IDE_TRANSFER;
		}
        else
        {
            // No device
            continue;
        }
	}

	for (i = 0; i < 2; i++) 
    {
		targetId = (Channel << 1) + i;

		if (DeviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT) 
        {
			//
			// Initialize LastDriveFed.
			//

			DeviceExtension->Channel[Channel].LastDriveFed = i;

			if (!(DeviceExtension->DeviceFlags[targetId] & DFLAGS_ATAPI_DEVICE) &&
				deviceResponded) 
            {

				//
				// This hideous hack is to deal with ESDI devices that return
				// garbage geometry in the IDENTIFY data.
				// This is ONLY for the crashdump environment as
				// these are ESDI devices.
				//
	
				if (DeviceExtension->IdentifyData[targetId].SectorsPerTrack == 0x35 &&
					DeviceExtension->IdentifyData[targetId].NumberOfHeads == 0x07) 
                {
	
					DebugPrint((1, "FindDevices: Found nasty Compaq ESDI!\n"));
	
					//
					// Change these values to something reasonable.
					//
	
					DeviceExtension->IdentifyData[targetId].SectorsPerTrack = 0x34;
					DeviceExtension->IdentifyData[targetId].NumberOfHeads = 0x0E;
				}
	
				if (DeviceExtension->IdentifyData[targetId].SectorsPerTrack == 0x35 &&
					DeviceExtension->IdentifyData[targetId].NumberOfHeads == 0x0F) 
                {
	
					DebugPrint((1, "FindDevices: Found nasty Compaq ESDI!\n"));
	
					//
					// Change these values to something reasonable.
					//
	
					DeviceExtension->IdentifyData[targetId].SectorsPerTrack = 0x34;
					DeviceExtension->IdentifyData[targetId].NumberOfHeads = 0x0F;
				}
	
	
				if (DeviceExtension->IdentifyData[targetId].SectorsPerTrack == 0x36 &&
					DeviceExtension->IdentifyData[targetId].NumberOfHeads == 0x07) 
                {
	
					DebugPrint((1, "FindDevices: Found nasty UltraStor ESDI!\n"));
	
					//
					// Change these values to something reasonable.
					//
	
					DeviceExtension->IdentifyData[targetId].SectorsPerTrack = 0x3F;
					DeviceExtension->IdentifyData[targetId].NumberOfHeads = 0x10;
					DeviceExtension->bSkipSetParameters[targetId] = TRUE;
				}

#ifdef HYPERDISK_WIN2K
                if (!( DeviceExtension->FullIdentifyData[targetId].CmdSupported1 & POWER_MANAGEMENT_SUPPORTED ))
                    continue;

                DeviceExtension->PhysicalDrive[targetId].bPwrMgmtSupported = TRUE;

                if (( DeviceExtension->FullIdentifyData[targetId].CmdSupported2 & POWER_UP_IN_STANDBY_FEATURE_SUPPORTED ))
                    DeviceExtension->PhysicalDrive[targetId].bPwrUpInStdBySupported = TRUE;
                else
                    DeviceExtension->bIsResetRequiredToGetActiveMode = TRUE;


                if (( DeviceExtension->FullIdentifyData[targetId].CmdSupported2 & SET_FEATURES_REQUIRED_FOR_SPIN_UP ))
                    DeviceExtension->PhysicalDrive[targetId].bSetFeatureReqForSpinUp = TRUE;
#endif // HYPERDISK_WIN2K
			}
        }
	}


	for (i = 0; i < 2; i++) 
    {
        targetId = (Channel << 1) + i;

        if (DeviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT) 
        {
        	SELECT_DEVICE(baseIoAddress1, targetId);    // select first available drive
            break;
        }
    }

	return deviceResponded;

} // end FindDevices()

VOID
GetDriveCapacity(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

{
	ULONG sectors;
	ULONG sectorSize;

	//
	// Claim 512 byte blocks (big-endian).
	//

	sectorSize = DeviceExtension->PhysicalDrive[Srb->TargetId].SectorSize;

	((PREAD_CAPACITY_DATA)Srb->DataBuffer)->BytesPerBlock = BIG_ENDIAN_ULONG(sectorSize);

	if (DeviceExtension->IsLogicalDrive[Srb->TargetId]) 
    {

		sectors = DeviceExtension->LogicalDrive[Srb->TargetId].Sectors;

	} 
    else 
    {

		sectors = DeviceExtension->PhysicalDrive[Srb->TargetId].Sectors;
	}

     sectors--;// Zero based Index

	((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress = BIG_ENDIAN_ULONG(sectors);

	DebugPrint((0,
	  "Atapi GetDriveCapacity: TID %d - capacity %ld MB (%lxh), sector size %ld (%lx BE)\n",
	  Srb->TargetId,
	  sectors / 2048,
	  sectors / 2048,
	  sectorSize,
	  BIG_ENDIAN_ULONG(sectorSize)
	  ));

	return;

} // end GetDriveCapacity()

SRBSTATUS
GetInquiryData(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

{
	PMODE_PARAMETER_HEADER modeData;
	ULONG i;
	PINQUIRYDATA inquiryData;
	PIDENTIFY_DATA2 identifyData;
	
	inquiryData = Srb->DataBuffer;
	identifyData = &DeviceExtension->IdentifyData[Srb->TargetId];

	//
	// Zero INQUIRY data structure.
	//
    AtapiFillMemory((PUCHAR)Srb->DataBuffer, Srb->DataTransferLength, 0);

	//
	// Standard IDE interface only supports disks.
	//

	inquiryData->DeviceType = DIRECT_ACCESS_DEVICE;
    inquiryData->DeviceTypeQualifier = DEVICE_CONNECTED;

	//
	// Set the removable bit, if applicable.
	//

	if (DeviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE) 
    {
		inquiryData->RemovableMedia = 1;
	}

	//
	// Fill in vendor identification fields.
	//

	for (i = 0; i < 20; i += 2) 
    {
	   inquiryData->VendorId[i] =
		   ((PUCHAR)identifyData->ModelNumber)[i + 1];
	   inquiryData->VendorId[i+1] =
		   ((PUCHAR)identifyData->ModelNumber)[i];
	}

	//
	// Initialize unused portion of product id.
	//

	for (i = 0; i < 4; i++) 
    {
	   inquiryData->ProductId[12+i] = ' ';
	}

	//
	// Move firmware revision from IDENTIFY data to
	// product revision in INQUIRY data.
	//

	for (i = 0; i < 4; i += 2) 
    {
	   inquiryData->ProductRevisionLevel[i] =
		   ((PUCHAR)identifyData->FirmwareRevision)[i+1];
	   inquiryData->ProductRevisionLevel[i+1] =
		   ((PUCHAR)identifyData->FirmwareRevision)[i];
	}

    if ( DeviceExtension->IsLogicalDrive[Srb->TargetId] )
    {
        // Zero up the information.... so that it doesn't show any junk.. Bug reported by Hitachi
        // Vendor Id 8 Chars, Product Id 16 Product Rivision Level 4 = 28 Chars....
        AtapiFillMemory(inquiryData->VendorId, 8, ' ');
        AtapiFillMemory(inquiryData->ProductId, 16, ' ');
        AtapiFillMemory(inquiryData->ProductRevisionLevel, 4, ' ');

        AtapiCopyString(inquiryData->VendorId, "AMI", 3);
        AtapiCopyString(inquiryData->ProductRevisionLevel, "1.0", 3);
		// Begin Vasu - 26 Dec 2000
		// Name Change
        AtapiCopyString(inquiryData->ProductId, "MegaIDE #", 11);
        inquiryData->ProductId[9] = (UCHAR) ( ((DeviceExtension->aulLogDrvId[Srb->TargetId] + (DeviceExtension->ucControllerId * MAX_DRIVES_PER_CONTROLLER)) / 10 )+ '0');
        inquiryData->ProductId[10] = (UCHAR) ( ((DeviceExtension->aulLogDrvId[Srb->TargetId] + (DeviceExtension->ucControllerId * MAX_DRIVES_PER_CONTROLLER)) % 10 )+ '0');
		// End Vasu
    }

	return(SRB_STATUS_SUCCESS);

} // end GetInquiryData()

BOOLEAN
GetConfigInfoAndErrorLogSectorInfo(
	PHW_DEVICE_EXTENSION DeviceExtension
)
{
	ULONG ulDevice = 0, ulCurLogDrv, ulLogDrvInd, ulInd;
    BOOLEAN bFoundRaid = FALSE;

    for (ulDevice = 0; ulDevice < MAX_DRIVES_PER_CONTROLLER; ulDevice++) 
    {

        if ( !IS_IDE_DRIVE(ulDevice) )
            continue;

        if ( !bFoundIRCD )
        {
            if ( GetRaidInfoSector(DeviceExtension, ulDevice, gaucIRCDData, &ulInd) )
                bFoundIRCD = TRUE;
        }

        InitErrorLogAndIRCDIndices(DeviceExtension, ulDevice);

	}

	return TRUE;

} // end GetRaidConfiguration()

BOOLEAN 
GetRaidInfoSector(
		PHW_DEVICE_EXTENSION pDE, 
		LONG lTargetId, 
		PUCHAR pRaidConfigSector,
        PULONG pulInd)
{
	ULONG		ulInd = 0;
    ULONG       ulSecInd;
    BOOLEAN     bFound = FALSE;

#ifdef DUMMY_RAID10_IRCD

    AtapiMemCpy( pRaidConfigSector,
                 gucDummyIRCD,
                 512
                );

    return TRUE;

#else // DUMMY_RAID10_IRCD

    for(ulInd=0;ulInd<MAX_IRCD_SECTOR;ulInd++)
    {
        if ( !pDE->PhysicalDrive[lTargetId].OriginalSectors )
            return FALSE;       // No drive there. So, nothing to read from.

        ulSecInd =     pDE->PhysicalDrive[lTargetId].OriginalSectors;
        ulSecInd--;        // It is a Zero Based Index so make it n-1 (becomes last sector)
        ulSecInd -= ulInd;

        PIOReadWriteSector(
				IDE_COMMAND_READ,
				pDE, 
				lTargetId, 
				ulSecInd,
				pRaidConfigSector);

        if ( IsRaidMember(pRaidConfigSector) )
        {
            *pulInd = ulInd;
            bFound = TRUE;
            break;
        }
    }

#endif // DUMMY_RAID10_IRCD

	return bFound;
}

BOOLEAN
InitErrorLogAndIRCDIndices(
	PHW_DEVICE_EXTENSION DeviceExtension,
    ULONG ulTargetId
)
{
    UCHAR aucInfoSector[IDE_SECTOR_SIZE];
    ULONG ulInd = 0;
    ULONG ulIrcdSecInd, ulErrLogSecInd, ulOriginalSectors;
	PERROR_LOG_HEADER pErrorLogHeader = (PERROR_LOG_HEADER)aucInfoSector;
    USHORT usMaxErrors;

    GetRaidInfoSector(DeviceExtension, ulTargetId, aucInfoSector,&ulInd);

    ulOriginalSectors = DeviceExtension->PhysicalDrive[ulTargetId].OriginalSectors;
    DeviceExtension->PhysicalDrive[ulTargetId].IrcdSectorIndex = ulOriginalSectors - ulInd - 1;
    ulIrcdSecInd = DeviceExtension->PhysicalDrive[ulTargetId].IrcdSectorIndex;

    // Error Log Sector will always be behind the last but one sector (minimum) ... just to allocate the room for
    //  IRCD (for future Use
    ulErrLogSecInd = ulIrcdSecInd - 1;

    PIOReadWriteSector(
			IDE_COMMAND_READ,
			DeviceExtension, 
			ulTargetId, 
			ulErrLogSecInd,  // Error Log will be the very next sector of the IRCD
			aucInfoSector);


	// if BIOS has not init yet
	if ( AtapiStringCmp( 
				pErrorLogHeader->Signature, 
                IDERAID_ERROR_LOG_SIGNATURE,
                IDERAID_ERROR_LOG_SIGNATURE_LENGTH) )
    {
		InitErrorLogSector (DeviceExtension, ulTargetId, ulErrLogSecInd, aucInfoSector);
    } 
    else 
    {
        usMaxErrors = (USHORT)( ( (ULONG)(pErrorLogHeader->ErrorLogSectors << 9) - 
                                (ULONG)sizeof(ERROR_LOG_HEADER) ) / (ULONG)sizeof(ERROR_LOG) );
        // assume the structure size is greater than the previous one
        if (pErrorLogHeader->MaxErrorCount > usMaxErrors)
    		InitErrorLogSector (DeviceExtension, ulTargetId, ulErrLogSecInd, aucInfoSector);
    }

	// init Error Reported count
	DeviceExtension->PhysicalDrive[ulTargetId].ErrorReported = 0;

	// init Error Found count
	DeviceExtension->PhysicalDrive[ulTargetId].ErrorFound = pErrorLogHeader->TotalErrorCount;

	// save error sector index
	DeviceExtension->PhysicalDrive[ulTargetId].ErrorLogSectorIndex = ulErrLogSecInd;

    // fill out the total number of visible sectors
    DeviceExtension->PhysicalDrive[ulTargetId].Sectors = ulErrLogSecInd - 1;

    return TRUE;
}

VOID
InitErrorLogSector (
		PHW_DEVICE_EXTENSION	pDE, 
		LONG					lTargetId, 
		ULONG					ulStartIndex,
		PUCHAR					pErrorLogSector)
{
	PERROR_LOG_HEADER pErrorLogHeader = (PERROR_LOG_HEADER)pErrorLogSector;

	// signature string
    AtapiCopyString(pErrorLogHeader->Signature, 
                    IDERAID_ERROR_LOG_SIGNATURE, 
                    IDERAID_ERROR_LOG_SIGNATURE_LENGTH);

	// size of this structure
	pErrorLogHeader->Size = (UCHAR)sizeof(ERROR_LOG_HEADER);

	// size of error log structure
	pErrorLogHeader->SizeErrorLogStruct = (UCHAR)sizeof(ERROR_LOG);

	// error log sector
	pErrorLogHeader->ErrorLogSectors = 1;

	// max error log count
	pErrorLogHeader->MaxErrorCount = (USHORT)( ( (ULONG)(pErrorLogHeader->ErrorLogSectors << 9) - 
											  (ULONG)sizeof(ERROR_LOG_HEADER) ) / (ULONG)sizeof(ERROR_LOG) );

	// total error log count
	pErrorLogHeader->TotalErrorCount = 0;

	// head pos
	pErrorLogHeader->Head = 0;

	// tail pos
	pErrorLogHeader->Tail = 0;

	// write to drive
	PIOReadWriteSector(
				IDE_COMMAND_WRITE,
				pDE, 
				lTargetId, 
				ulStartIndex,
				pErrorLogSector);

}

BOOLEAN ReadWriteSector(
				UCHAR					theCmd,	// IDE_COMMAND_READ or write
				PHW_DEVICE_EXTENSION	DeviceExtension, 
				LONG					lTargetId, 
				PULONG					pStartSector,
				PUCHAR					pSectorBuffer)
{
    ULONG ulSectors;
    ULONG ulChannel = lTargetId>>1;
	PIDE_REGISTERS_1 pBaseIoAddress1 = DeviceExtension->BaseIoAddress1[ulChannel];
    PIDE_REGISTERS_2 pBaseIoAddress2 = DeviceExtension->BaseIoAddress2[ulChannel];
    ULONG ulCount, ulSecCounter, ulValue;
    UCHAR ucStatus, ucTemp;
    ULONG ulSectorNumber, ulCylinderLow, ulCylinderHigh, ulHead;

	if ((*pStartSector) >= MAX_IRCD_SECTOR)
        return FALSE;	// goes beyond the margin

    if (!IS_IDE_DRIVE(lTargetId))
        return FALSE;

    if ( !DeviceExtension->PhysicalDrive[lTargetId].OriginalSectors )
        return FALSE;       // No drive there. So, nothing to read from.


    ulSectors =     DeviceExtension->PhysicalDrive[lTargetId].OriginalSectors;
    ulSectors--;        // It is a Zero Based Index so make it n-1 (becomes last sector)

	ulSectors -= (*pStartSector);
    ulSecCounter = 0;

    while ( ulSecCounter < MAX_IRCD_SECTOR )
    {
        ulValue = (ulSectors - ulSecCounter);

	    SELECT_LBA_DEVICE(pBaseIoAddress1, lTargetId, ulValue);

        ScsiPortStallExecution(1);  // we have to wait atleast 400 ns ( 1000 ns = 1 Micro Second ) to get the Busy Bit to set

        WAIT_ON_BUSY(pBaseIoAddress1, ucStatus);

        if ( ((ucStatus & IDE_STATUS_BUSY)) || (!(ucStatus & IDE_STATUS_DRDY)) )
        {
            DebugPrint((0,"\n\n\n\n\nAre Very B A D \n\n\n\n\n"));
        }

        ulSectorNumber = ulValue & 0x000000ff;
        ulCylinderLow = (ulValue & 0x0000ff00) >> 8;
        ulCylinderHigh = (ulValue & 0xff0000) >> 16;

	    ScsiPortWritePortUchar(&pBaseIoAddress1->SectorCount, 1);
	    ScsiPortWritePortUchar(&pBaseIoAddress1->SectorNumber, (UCHAR)ulSectorNumber);
	    ScsiPortWritePortUchar(&pBaseIoAddress1->CylinderLow,(UCHAR)ulCylinderLow);
	    ScsiPortWritePortUchar(&pBaseIoAddress1->CylinderHigh,(UCHAR)ulCylinderHigh);
        ScsiPortWritePortUchar(&pBaseIoAddress1->Command, theCmd);
        
        WAIT_ON_BUSY(pBaseIoAddress1, ucStatus);

        WAIT_FOR_DRQ(pBaseIoAddress1, ucStatus);

	    if (!(ucStatus & IDE_STATUS_DRQ)) 
        {
		    DebugPrint((0,"\nHaaa.... I couldn't read/write the sector..............1\n"));
		    return(FALSE);
	    }

        //
        // Read status to acknowledge any interrupts generated.
        //

        GET_BASE_STATUS(pBaseIoAddress1, ucStatus);

        //
        // Check for error on really stupid master devices that assert random
        // patterns of bits in the status register at the slave address.
        //
        if (ucStatus & IDE_STATUS_ERROR) 
        {
            DebugPrint((0,"\nHaaa.... I couldn't read/write the sector..............2\n"));
            return(FALSE);
        }

        WAIT_ON_BUSY(pBaseIoAddress1,ucStatus);

        WAIT_ON_BUSY(pBaseIoAddress1,ucStatus);

        WAIT_ON_BUSY(pBaseIoAddress1,ucStatus);

    	if ( (ucStatus & IDE_STATUS_DRQ) && (!(ucStatus & IDE_STATUS_BUSY)) )
        {
			if (theCmd == IDE_COMMAND_READ) 
            {
				READ_BUFFER(pBaseIoAddress1, (unsigned short *)pSectorBuffer, 256);
			}
			else
            {
			    if (theCmd == IDE_COMMAND_WRITE)
                {
                    ULONG ulCounter;
				    WRITE_BUFFER(pBaseIoAddress1, (unsigned short *)pSectorBuffer, 256);
                    WAIT_FOR_DRQ(pBaseIoAddress1, ucStatus);
	                if (ucStatus & IDE_STATUS_DRQ) 
                    {
		                DebugPrint((0,"\nHaaa.... I couldn't read/write the sector..............3\n"));
                        for(ulCounter=0;ulCounter<4;ulCounter++)
                        {
                            ScsiPortWritePortUchar((PUCHAR)&pBaseIoAddress1->Data, pSectorBuffer[ulCounter]);
                            ScsiPortStallExecution(1);  // we have to wait atleast 400 ns ( 1000 ns = 1 Micro Second ) to get the Busy Bit to set
                        }
	                }
                }
            }
            break;
        }

	    //
	    // Read status. This will clear the interrupt.
	    //
    	GET_BASE_STATUS(pBaseIoAddress1, ucStatus);

        ulSecCounter++; // This error has to be handled
    }

    DeviceExtension->bIntFlag = TRUE;

	(*pStartSector) += ulSecCounter;

	//
	// Read status. This will clear the interrupt.
	//

	GET_BASE_STATUS(pBaseIoAddress1, ucTemp);


	if ( ucStatus & IDE_STATUS_ERROR )
        return FALSE;
    else 
        return TRUE;
}

//
// ErrorLogErase
//
//  move tail
//  dec error reported
//  dec error found and total error count
//
BOOLEAN
ErrorLogErase (
		IN PHW_DEVICE_EXTENSION	pDE, 
		IN LONG					lTargetId, 
		IN PUCHAR				pErrorLogSector,
		IN USHORT				NumErrorLogs)
{
	PERROR_LOG_HEADER pErrorLogHeader = (PERROR_LOG_HEADER)pErrorLogSector;
	PERROR_LOG pErrorLog = (PERROR_LOG)(pErrorLogSector + sizeof(ERROR_LOG_HEADER));
	USHORT	index = pErrorLogHeader->Tail;
	USHORT	numToErase = NumErrorLogs;

	if (numToErase > pDE->PhysicalDrive[lTargetId].ErrorReported)
		numToErase = pDE->PhysicalDrive[lTargetId].ErrorReported;

	if (numToErase == 0)
		return FALSE;

	// find the new tail pos
	index = index + numToErase;
	if (index >= pErrorLogHeader->MaxErrorCount) // circled buffer
		index -= pErrorLogHeader->MaxErrorCount;
	pErrorLogHeader->Tail = index;

	// dec reported
	pDE->PhysicalDrive[lTargetId].ErrorReported -= numToErase;

	// dec error found and total count
	pDE->PhysicalDrive[lTargetId].ErrorFound -= numToErase;
	pErrorLogHeader->TotalErrorCount -= numToErase;

	return TRUE;
}

UCHAR
IdeBuildSenseBuffer(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

/*++
Routine Description:

	Builts an artificial sense buffer to report the results of a GET_MEDIA_STATUS
	command. This function is invoked to satisfy the SCSIOP_REQUEST_SENSE.
Arguments:

	DeviceExtension - ATAPI driver storage.
	Srb - System request block.

Return Value:

	SRB status (ALWAYS SUCCESS).

--*/

{
	PSENSE_DATA	 senseBuffer = (PSENSE_DATA)Srb->DataBuffer;


	if (senseBuffer)
    {
		if (DeviceExtension->ReturningMediaStatus[Srb->TargetId] & IDE_ERROR_MEDIA_CHANGE) {

			senseBuffer->ErrorCode = 0x70;
			senseBuffer->Valid	   = 1;
			senseBuffer->AdditionalSenseLength = 0xb;
			senseBuffer->SenseKey =	 SCSI_SENSE_UNIT_ATTENTION;
			senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
			senseBuffer->AdditionalSenseCodeQualifier = 0;

		} else if (DeviceExtension->ReturningMediaStatus[Srb->TargetId] &
					IDE_ERROR_MEDIA_CHANGE_REQ) {

			senseBuffer->ErrorCode = 0x70;
			senseBuffer->Valid	   = 1;
			senseBuffer->AdditionalSenseLength = 0xb;
			senseBuffer->SenseKey =	 SCSI_SENSE_UNIT_ATTENTION;
			senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
			senseBuffer->AdditionalSenseCodeQualifier = 0;

		} else if (DeviceExtension->ReturningMediaStatus[Srb->TargetId] & IDE_ERROR_END_OF_MEDIA) {

			senseBuffer->ErrorCode = 0x70;
			senseBuffer->Valid	   = 1;
			senseBuffer->AdditionalSenseLength = 0xb;
			senseBuffer->SenseKey =	 SCSI_SENSE_NOT_READY;
			senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
			senseBuffer->AdditionalSenseCodeQualifier = 0;

		} else if (DeviceExtension->ReturningMediaStatus[Srb->TargetId] & IDE_ERROR_DATA_ERROR) {

			senseBuffer->ErrorCode = 0x70;
			senseBuffer->Valid	   = 1;
			senseBuffer->AdditionalSenseLength = 0xb;
			senseBuffer->SenseKey =	 SCSI_SENSE_DATA_PROTECT;
			senseBuffer->AdditionalSenseCode = 0;
			senseBuffer->AdditionalSenseCodeQualifier = 0;
		}

		return SRB_STATUS_SUCCESS;
	}
	return SRB_STATUS_ERROR;

}// End of IdeBuildSenseBuffer

VOID
IdeMediaStatus(
	BOOLEAN EnableMSN,
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	ULONG TargetId
)
/*++

Routine Description:

	Enables disables media status notification

Arguments:

DeviceExtension - ATAPI driver storage.

--*/

{
	UCHAR channel;
	PIDE_REGISTERS_1 baseIoAddress;
	UCHAR statusByte,errorByte;


	channel = (UCHAR) (TargetId >> 1);

	baseIoAddress = DeviceExtension->BaseIoAddress1[channel];

    SELECT_DEVICE(baseIoAddress, TargetId);

	if (EnableMSN == TRUE)
    {

		//
		// If supported enable Media Status Notification support
		//

		if ((DeviceExtension->DeviceFlags[TargetId] & DFLAGS_REMOVABLE_DRIVE)) 
        {

			//
			// enable
			//
			ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1,(UCHAR) (0x95));
			ScsiPortWritePortUchar(&baseIoAddress->Command,
								   IDE_COMMAND_ENABLE_MEDIA_STATUS);

			WAIT_ON_BASE_BUSY(baseIoAddress,statusByte);

			if (statusByte & IDE_STATUS_ERROR) 
            {
				//
				// Read the error register.
				//
				errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress + 1);

				DebugPrint((1,
							"IdeMediaStatus: Error enabling media status. Status %x, error byte %x\n",
							 statusByte,
							 errorByte));
			} 
            else 
            {
				DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_MEDIA_STATUS_ENABLED;
				DebugPrint((1,"IdeMediaStatus: Media Status Notification Supported\n"));
				DeviceExtension->ReturningMediaStatus[TargetId] = 0;

			}

		}
	} 
    else 
    { // end if EnableMSN == TRUE

		//
		// disable if previously enabled
		//
		if ((DeviceExtension->DeviceFlags[TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)) 
        {
			ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1,(UCHAR) (0x31));
			ScsiPortWritePortUchar(&baseIoAddress->Command,
								   IDE_COMMAND_ENABLE_MEDIA_STATUS);

			WAIT_ON_BASE_BUSY(baseIoAddress,statusByte);
			DeviceExtension->DeviceFlags[TargetId] &= ~DFLAGS_MEDIA_STATUS_ENABLED;
		}


	}

} // end IdeMediaStatus()

BOOLEAN
IsRaidMember(
	IN PUCHAR pucIRCDSector
)

{
	PIRCD_HEADER pRaidHeader;

	pRaidHeader = (PIRCD_HEADER) pucIRCDSector;

	if (AtapiStringCmp(pRaidHeader->Signature, IDE_RAID_SIGNATURE, IDE_RAID_SIGNATURE_LENGTH - 1) == 0) 
    {
		//
		// Found RAID member signature.
		//

		return(TRUE);
	}

	return(FALSE);

} // end IsRaidMember()

BOOLEAN
IssueIdentify(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR DeviceNumber,
	IN UCHAR Channel,
	IN UCHAR Command
)
/*++

Routine Description:

	Issue IDENTIFY command to a device.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	DeviceNumber - Indicates which device.
	Command - Either the standard (EC) or the ATAPI packet (A1) IDENTIFY.

Return Value:

	TRUE if all goes well.

--*/
{
	PIDE_REGISTERS_1	 baseIoAddress1 = DeviceExtension->BaseIoAddress1[Channel] ;
	PIDE_REGISTERS_2	 baseIoAddress2 = DeviceExtension->BaseIoAddress2[Channel];
	ULONG				 waitCount = 20000;
	ULONG				 i,j;
	UCHAR				 statusByte;
	UCHAR				 signatureLow,
						 signatureHigh;
	UCHAR k;	// Channel number.
	UCHAR targetId;
    PUSHORT         puIdentifyData;

	//
	// Select device 0 or 1.
	//

	SELECT_DEVICE(baseIoAddress1, DeviceNumber);

	//
	// Check that the status register makes sense.
	//

    // The call came here since there is a drive ... so let us not worry about whether there is any drive at this place
	GET_BASE_STATUS(baseIoAddress1, statusByte);    

	//
	// Load CylinderHigh and CylinderLow with number bytes to transfer.
	//

	ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, (0x200 >> 8));
	ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,  (0x200 & 0xFF));

    WAIT_ON_BUSY(baseIoAddress1, statusByte);

	//
	// Send IDENTIFY command.
	//
	WAIT_ON_BUSY(baseIoAddress1,statusByte);

	ScsiPortWritePortUchar(&baseIoAddress1->Command, Command);

	WAIT_ON_BUSY(baseIoAddress1,statusByte);

    if ( ( !( statusByte & IDE_STATUS_BUSY ) ) && ( !( statusByte & IDE_STATUS_DRQ ) ) )
        // this is an error... so let us not try any more.
        return FALSE;

    WAIT_ON_BUSY(baseIoAddress1,statusByte);

	//
	// Wait for DRQ.
	//

	for (i = 0; i < 4; i++) 
    {
		WAIT_FOR_DRQ(baseIoAddress1, statusByte);

		if (statusByte & IDE_STATUS_DRQ)
        {
            break;
        }
    }

	//
	// Read status to acknowledge any interrupts generated.
	//

	GET_BASE_STATUS(baseIoAddress1, statusByte);

	//
	// Check for error on really stupid master devices that assert random
	// patterns of bits in the status register at the slave address.
	//

	if ((Command == IDE_COMMAND_IDENTIFY) && (statusByte & IDE_STATUS_ERROR)) 
    {
		return FALSE;
	}

	DebugPrint((1, "IssueIdentify: Status before read words %x\n", statusByte));

	//
	// Suck out 256 words. After waiting for one model that asserts busy
	// after receiving the Packet Identify command.
	//

	WAIT_ON_BUSY(baseIoAddress1,statusByte);

	if (!(statusByte & IDE_STATUS_DRQ)) 
    {
		return FALSE;
	}

	targetId = (Channel << 1) + DeviceNumber;

	READ_BUFFER(baseIoAddress1, (PUSHORT)&DeviceExtension->FullIdentifyData[targetId], 256);

	//
	// Check out a few capabilities / limitations of the device.
	//

	if (DeviceExtension->FullIdentifyData[targetId].MediaStatusNotification & 1) 
    {
		//
		// Determine if this drive supports the MSN functions.
		//

		DebugPrint((2,"IssueIdentify: Marking drive %d as removable. MSN = %d\n",
					Channel * 2 + DeviceNumber,
					DeviceExtension->FullIdentifyData[targetId].MediaStatusNotification));


		DeviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_REMOVABLE_DRIVE;
	}

	if (DeviceExtension->FullIdentifyData[targetId].MaximumBlockTransfer) 
    {
		//
		// Determine max. block transfer for this device.
		//

		DeviceExtension->MaximumBlockXfer[targetId] =
			(UCHAR)(DeviceExtension->FullIdentifyData[targetId].MaximumBlockTransfer & 0xFF);
	}

	AtapiMemCpy(
		(PUCHAR)&DeviceExtension->IdentifyData[targetId],
		(PUCHAR)&DeviceExtension->FullIdentifyData[targetId],
		sizeof(IDENTIFY_DATA2)
		);

    puIdentifyData = (PUSHORT) &(DeviceExtension->FullIdentifyData[targetId]);

	if (DeviceExtension->IdentifyData[targetId].GeneralConfiguration & 0x20 &&
		Command != IDE_COMMAND_IDENTIFY) 
    {
		//
		// This device interrupts with the assertion of DRQ after receiving
		// Atapi Packet Command
		//

		DeviceExtension->DeviceFlags[targetId] |= DFLAGS_INT_DRQ;

		DebugPrint((2, "IssueIdentify: Device interrupts on assertion of DRQ.\n"));

	} 
    else 
    {
		DebugPrint((2, "IssueIdentify: Device does not interrupt on assertion of DRQ.\n"));
	}

	if (((DeviceExtension->IdentifyData[targetId].GeneralConfiguration & 0xF00) == 0x100) &&
		Command != IDE_COMMAND_IDENTIFY) 
    {
		//
		// This is a tape.
		//

		DeviceExtension->DeviceFlags[targetId] |= DFLAGS_TAPE_DEVICE;

		DebugPrint((2, "IssueIdentify: Device is a tape drive.\n"));

	} 
    else 
    {
		DebugPrint((2, "IssueIdentify: Device is not a tape drive.\n"));
	}

	//
	// Work around for some IDE and one model Atapi that will present more than
	// 256 bytes for the Identify data.
	//

	WAIT_ON_BUSY(baseIoAddress1,statusByte);

	for (i = 0; i < 0x10000; i++) 
    {
		GET_STATUS(baseIoAddress1,statusByte);

		if (statusByte & IDE_STATUS_DRQ) 
        {
			//
			// Suck out any remaining bytes and throw away.
			//

			ScsiPortReadPortUshort(&baseIoAddress1->Data);

		} 
        else 
        {
			break;
		}
	}

	DebugPrint((3, "IssueIdentify: Status after read words (%x)\n", statusByte));

	return TRUE;

} // end IssueIdentify()


SRBSTATUS
PostPassThruCommand(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PPHYSICAL_COMMAND pPhysicalCommand
)
{
	PIDE_REGISTERS_1 baseIoAddress1;
    UCHAR statusByte = 0;
    PPHYSICAL_REQUEST_BLOCK pPrb = DeviceExtension->PhysicalDrive[pPhysicalCommand->TargetId].pPrbList[pPhysicalCommand->ucStartInd];
    PSCSI_REQUEST_BLOCK Srb = pPrb->pPdd->OriginalSrb;
    PPASS_THRU_DATA pPassThruData = (PPASS_THRU_DATA)
    (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);
    PUCHAR pucTaskFile = pPassThruData->aucTaskFile;
    UCHAR ucBitMapValue = pPassThruData->ucTaskFileBitMap;
    UCHAR ucChannel;

	DebugPrint((3, "\nSetDriveRegisters: Entering routine.\n"));

	ucChannel = GET_CHANNEL(pPhysicalCommand);

	baseIoAddress1 = DeviceExtension->BaseIoAddress1[ucChannel];

	WAIT_ON_BUSY(baseIoAddress1, statusByte);

	//
	// Check for erroneous IDE status.
	//
	if (statusByte & IDE_STATUS_BUSY)
    {
        DebugPrint((3, "S%x", (ULONG)statusByte));

        // Controller is not free for Accepting the command.
		return FALSE;
	}

    SELECT_LBA_DEVICE(baseIoAddress1, pPhysicalCommand->TargetId, 0);

	WAIT_ON_BUSY(baseIoAddress1, statusByte);

	//
	// Check for erroneous IDE status.
	//
	if (((statusByte & IDE_STATUS_BUSY)) || 
        (!(statusByte & IDE_STATUS_DRDY)))
    {
        // Drive is not Ready.
		return FALSE;
	}

    if ( 1  & ucBitMapValue )   // zero th byte in Task File
        ScsiPortWritePortUchar(&baseIoAddress1->SectorCount, pucTaskFile[0]);

    if ( (1 << 1) & ucBitMapValue )   // First byte in Task File
	    ScsiPortWritePortUchar(&baseIoAddress1->SectorNumber, pucTaskFile[1]);

    if ( ( (1 << (offsetof(IDE_REGISTERS_1, SectorCount) )) & ucBitMapValue ) )
        ScsiPortWritePortUchar(&baseIoAddress1->SectorCount, pucTaskFile[offsetof(IDE_REGISTERS_1, SectorCount)]);

    if ( ( (1 << (offsetof(IDE_REGISTERS_1, SectorNumber) )) & ucBitMapValue ) )
	    ScsiPortWritePortUchar(&baseIoAddress1->SectorNumber, pucTaskFile[offsetof(IDE_REGISTERS_1, SectorNumber)]);

    if ( ( (1 << (offsetof(IDE_REGISTERS_1, CylinderLow) )) & ucBitMapValue ) )
	    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow, pucTaskFile[offsetof(IDE_REGISTERS_1, CylinderLow)]);

    if ( ( (1 << (offsetof(IDE_REGISTERS_1, CylinderHigh) )) & ucBitMapValue ) )
	    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, pucTaskFile[offsetof(IDE_REGISTERS_1, CylinderHigh)]);

    if ( ( (1 << (offsetof(IDE_REGISTERS_1, Command) )) & ucBitMapValue ) )
        ScsiPortWritePortUchar(&baseIoAddress1->Command, pucTaskFile[offsetof(IDE_REGISTERS_1, Command)]);

	return TRUE;
}

SRBSTATUS
PostIdeCmd(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PPHYSICAL_COMMAND pPhysicalCommand
)

/*++

Routine Description:

	This routine starts IDE read, write, and verify operations.

	It supports single and RAID devices.

	It can be called multiple times for the same Pdd, in case
	the total transfer length exceeds that supported by the target
	device.

	The current transfer description and state are saved in the
	device extension, while the global transfer state is saved in
	the Pdd itself.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage.
	Pdd - Physical request packet.

Return Value:

	SRB status:

	SRB_STATUS_BUSY
	SRB_STATUS_TIMEOUT
	SRB_STATUS_PENDING

--*/
{
	PIDE_REGISTERS_1 baseIoAddress1;
	PIDE_REGISTERS_2 baseIoAddress2;
	PBM_REGISTERS bmBase;
	UCHAR bmCommand;
	UCHAR bmStatus;
	UCHAR channel;
	ULONG i;
	ULONG k;
	BOOLEAN read;
	UCHAR scsiCommand;
	UCHAR statusByte;
	PTRANSFER_DESCRIPTOR transferDescriptor;
	ULONG wordCount, ulStartSector;
    UCHAR ucCmd, ucTargetId;

	//
	// Check for possible failure of the SRB this Pdd is part of.
	//

    ucTargetId = pPhysicalCommand->TargetId;

    if (    DRIVE_IS_UNUSABLE_STATE(ucTargetId) || 
            (!DRIVE_PRESENT(ucTargetId)) )
    {
        // This drive may be a drive that responding even when power is not there
		DebugPrint((1, "PostIdeCmd: found BUSY status\n"));
        HandleError(DeviceExtension, pPhysicalCommand);
		return SRB_STATUS_ERROR;
    }

    channel = GET_CHANNEL(pPhysicalCommand);
	baseIoAddress1 = DeviceExtension->BaseIoAddress1[channel];
	baseIoAddress2 = DeviceExtension->BaseIoAddress2[channel];
    bmBase = DeviceExtension->BaseBmAddress[channel];
	transferDescriptor = &(DeviceExtension->TransferDescriptor[channel]);

	//
	// Get the SCSI command code.
	//

	scsiCommand = pPhysicalCommand->ucCmd;

    if ( pPhysicalCommand->ucCmd == SCSIOP_INTERNAL_COMMAND )
    {
        PSGL_ENTRY pSglEntry;
		//
		// PIO transfer or VERIFY.
		// Set transfer parameters taken from the current element of the
		// logical S/G list.
		//

        // No merging concept for PIO Transfers... so we will issue command by command
		// Set buffer address..... The SglBasePhysicalAddress will have Logical Buffer Address
		transferDescriptor->DataBuffer = (PUSHORT)pPhysicalCommand->SglBaseVirtualAddress;
        pSglEntry = (PSGL_ENTRY)transferDescriptor->DataBuffer;
        // only for this command the ulCount will be stored as bytes rather than sectors
		transferDescriptor->WordsLeft = pPhysicalCommand->ulCount / 2;  // word count
        transferDescriptor->pusCurBufPtr = pSglEntry[0].Logical.Address;
        transferDescriptor->ulCurBufLen = pSglEntry[0].Logical.Length;
        transferDescriptor->ulCurSglInd = 0;
		DeviceExtension->ExpectingInterrupt[channel] = IDE_PIO_INTERRUPT;
        PostPassThruCommand(DeviceExtension, pPhysicalCommand);
        return SRB_STATUS_PENDING;
    }

	//
	// Set up transfer parameters.
	//

	if (!USES_DMA(ucTargetId) || 
		scsiCommand == SCSIOP_VERIFY || 
		scsiCommand == SCSIOP_EXECUTE_SMART_COMMAND) 
    {
        if ( SCSIOP_VERIFY == scsiCommand )
        {
            // No Buffer for Verify Command
		    transferDescriptor->DataBuffer = NULL;

	        //
	        // Initialize the transfer info common to PIO and DMA modes.
	        // 1. Sart sector
	        // 2. Number of sectors.
	        //

	        transferDescriptor->StartSector = pPhysicalCommand->ulStartSector;

		    // Sectors for this transfer.
            if ( pPhysicalCommand->ulCount > MAX_SECTORS_PER_IDE_TRANSFER )
            {
                transferDescriptor->Sectors = MAX_SECTORS_PER_IDE_TRANSFER;
            }
            else
            {
                transferDescriptor->Sectors = pPhysicalCommand->ulCount;
            }

            pPhysicalCommand->ulStartSector += transferDescriptor->Sectors;
            pPhysicalCommand->ulCount -= transferDescriptor->Sectors;
        }
        else
        {
            PSGL_ENTRY pSglEntry;
		    //
		    // PIO transfer or VERIFY.
		    // Set transfer parameters taken from the current element of the
		    // logical S/G list.
		    //

            // No merging concept for PIO Transfers... so we will issue command by command
		    // Set buffer address..... The SglBasePhysicalAddress will have Logical Buffer Address
		    transferDescriptor->DataBuffer = (PUSHORT)pPhysicalCommand->SglBaseVirtualAddress;
	    
	        //
	        // Initialize the transfer info common to PIO and DMA modes.
	        // 1. Sart sector
	        // 2. Number of sectors.
	        //

	        transferDescriptor->StartSector = pPhysicalCommand->ulStartSector;
            transferDescriptor->Sectors = pPhysicalCommand->ulCount;

		    // Set transfer length.
		    transferDescriptor->WordsLeft = (transferDescriptor->Sectors * IDE_SECTOR_SIZE) / 2;


            pSglEntry = (PSGL_ENTRY)transferDescriptor->DataBuffer;
            transferDescriptor->pusCurBufPtr = pSglEntry[0].Logical.Address;
            transferDescriptor->ulCurBufLen = pSglEntry[0].Logical.Length;
            transferDescriptor->ulCurSglInd = 0;
        }

		DeviceExtension->ExpectingInterrupt[channel] = IDE_PIO_INTERRUPT;
	} 
    else 
    {
		//
		// DMA transfer. Retrieve transfer parameters from the SGL partition list.
		//

		// Set the physical address of the SGL partition to use for this transfer.
		transferDescriptor->SglPhysicalAddress = pPhysicalCommand->SglBasePhysicalAddress;

	    //
	    // Initialize the transfer info common to PIO and DMA modes.
	    // 1. Sart sector
	    // 2. Number of sectors.
	    //

	    transferDescriptor->StartSector = pPhysicalCommand->ulStartSector;
        transferDescriptor->Sectors = pPhysicalCommand->ulCount;

		DeviceExtension->ExpectingInterrupt[channel] = IDE_DMA_INTERRUPT;
	}

#ifdef DBG
    DebugPrint((3, "Drive : %ld\tAddress : %X\tStart : %X\tSectors : %X\n", 
                    ucTargetId,
                    transferDescriptor->SglPhysicalAddress,
                    transferDescriptor->StartSector,
                    transferDescriptor->Sectors
                    ));
#endif



    

	// added by Zhang 11/22/99
	// the header pos after this transfer
	DeviceExtension->PhysicalDrive[ucTargetId].CurrentHeaderPos = transferDescriptor->StartSector + transferDescriptor->Sectors;

    //
	// Program all I/O registers except for command.
	//
	if (! SetDriveRegisters(DeviceExtension, pPhysicalCommand))
    {
        // Drive Time Out 
        DeviceExtension->PhysicalDrive[ucTargetId].TimeOutErrorCount++;

        if ( DeviceExtension->PhysicalDrive[ucTargetId].TimeOutErrorCount >= MAX_TIME_OUT_ERROR_COUNT )
        {

            FailDrive(DeviceExtension, ucTargetId);
        }

		DebugPrint((1, "PostIdeCmd: found BUSY / ERROR status\n"));
        HandleError(DeviceExtension, pPhysicalCommand);
		return SRB_STATUS_BUSY;
	}

    //
	// Check if verify, read or write request.
	//
    switch (scsiCommand)
    {
        case SCSIOP_VERIFY:
        {
		    // Set transfer length.
		    DeviceExtension->ExpectingInterrupt[channel] = IDE_PIO_INTERRUPT;
		    transferDescriptor->WordsLeft = 0;
		    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_VERIFY);
            goto PostIdeCmdDone;    // for Verify Command nothing else to be done.  Just Wait for Interrupt
            break;
        }
        case SCSIOP_EXECUTE_SMART_COMMAND:
        {
		    DeviceExtension->ExpectingInterrupt[channel] = IDE_PIO_INTERRUPT;
            switch(DeviceExtension->uchSMARTCommand)
            {
            case HD_SMART_ENABLE:
            case HD_SMART_DISABLE:
            case HD_SMART_RETURN_STATUS:
		        transferDescriptor->WordsLeft = 0;
                break;
            case HD_SMART_READ_DATA:
                transferDescriptor->WordsLeft = 256;
                break;
            }
		    
            ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_EXECUTE_SMART);
            goto PostIdeCmdDone;
            break;
        }
        default:
        {
		    read = (SCSIOP_READ == pPhysicalCommand->ucCmd);
            break;
        }
    }

    if (USES_DMA(ucTargetId)) 
    {
		if (read) 
        {
			ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_READ_DMA);
			bmCommand = READ_TRANSFER;

		} 
        else 
        {
			ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_WRITE_DMA);
			bmCommand = WRITE_TRANSFER;
		}

        bmStatus = ScsiPortReadPortUchar(&(bmBase->Status.AsUchar));

		if (bmStatus & 1) 
        {
			DebugPrint((1, "PostIdeCmd: found Bus Master BUSY\n"));

			STOP;

            HandleError(DeviceExtension, pPhysicalCommand);
		    return SRB_STATUS_ERROR;
		}
			
        // Clear interrupt and error bits (if set).
		CLEAR_BM_INT(bmBase, statusByte);

		ScsiPortWritePortUlong(&(bmBase->SglAddress), transferDescriptor->SglPhysicalAddress);

		// Start transfer.
		ScsiPortWritePortUchar(&(bmBase->Command.AsUchar), (UCHAR)(bmCommand | START_TRANSFER));

        DebugPrint((3, "S1:%x", (ULONG)ScsiPortReadPortUchar(&(baseIoAddress2->AlternateStatus)) ));
	} 
    else 
    {
        if (read) 
        {

		    //
		    // Send read command in PIO mode.
		    //

		    if (DeviceExtension->MaximumBlockXfer[ucTargetId]) 
            {
			    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_READ_MULTIPLE);

		    } 
            else 
            {
			    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_READ);
		    }

	    } 
        else 
        {

		    //
		    // Send write command in PIO mode.
		    //

		    if (DeviceExtension->MaximumBlockXfer[ucTargetId] != 0) 
            {
			    //
			    // The device supports multi-sector transfers.
			    //

			    wordCount = (DeviceExtension->MaximumBlockXfer[ucTargetId] * IDE_SECTOR_SIZE) / 2;

				    //
				    // Transfer only words requested.
				    //

                wordCount = min(wordCount, transferDescriptor->WordsLeft);

                ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_WRITE_MULTIPLE);
		    } 
            else 
            {
			    //
			    // The device supports single-sector transfers.
			    //

			    wordCount = 256;
			    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_WRITE);
		    }

		    //
		    // Wait for BSY and DRQ.
		    //

		    WAIT_ON_ALTERNATE_STATUS_BUSY(baseIoAddress2, statusByte);

		    if ((statusByte & IDE_STATUS_BUSY) || (statusByte & IDE_STATUS_ERROR)) 
            {
			    DebugPrint((1, "PostIdeCmd 2: Pdd failed due to BUSY status %x\n", statusByte));

			    STOP;

                HandleError(DeviceExtension, pPhysicalCommand);
		        return SRB_STATUS_BUSY;
		    }

            WAIT_FOR_ALTERNATE_DRQ(baseIoAddress2, statusByte);

		    if (!(statusByte & IDE_STATUS_DRQ)) 
            {
			    DebugPrint((1,
				       "PostIdeCmd: [PIO write] Failure: DRQ never asserted (%x); original status (%x)\n",
				       statusByte,
				       statusByte));

                HandleError(DeviceExtension, pPhysicalCommand);
		        return SRB_STATUS_BUSY;
		    }

		    //
		    // Write next 256 words.
		    //
            RWBufferToTransferDescriptor( DeviceExtension, 
                                            transferDescriptor, 
                                            wordCount, 
                                            SCSIOP_WRITE, 
                                            ucTargetId, 
                                            DeviceExtension->DWordIO);

		    //
		    // Adjust words left count do not adjust buffer address 
            // since it is the starting point for the SGLs for that Command.
		    // Buffer adjustments are taken care of in RWBufferToTransferDescriptor()
            //

		    transferDescriptor->WordsLeft -= wordCount;
	    }
    }
PostIdeCmdDone:

    DebugPrint((DEFAULT_DISPLAY_VALUE," E%ld ", (channel | (DeviceExtension->ucControllerId << 1)) ));


	//
	// Wait for interrupt.
	//
	return SRB_STATUS_PENDING;

} // end PostIdeCmd()

VOID
PrintCapabilities(
	IN PIDENTIFY_DATA Capabilities,
	IN UCHAR TargetId
)

{
#ifndef HYPERDISK_WIN98

	DebugPrint((
				3,
				"Atapi: TID %d capabilities (transfer mode as programmed by the BIOS):\n"
				"\tAdvanced PIO modes supported (bit mask): %xh\n"
				"\tMinimum PIO cycle time w/ IORDY: %xh\n"
				"\tMultiword DMA modes supported (bit mask): %xh\n"
				"\tMultiword DMA mode active (bit mask): %xh\n"
				"\tUltra DMA modes supported (bit mask): %xh\n"
				"\tUltra DMA mode active (bit mask): %xh\n",
				TargetId,
				Capabilities->AdvancedPioModes,
				Capabilities->MinimumPioCycleTimeIordy,
				Capabilities->MultiWordDmaSupport,
				Capabilities->MultiWordDmaActive,
				Capabilities->UltraDmaSupport,
				Capabilities->UltraDmaActive
				));
#else

	//
	// Win98 dirties the stack when the above DebugPrint gets executed.
	// One format string per statement is safe.
	//

	DebugPrint((
				3,
				"Atapi: TID %d capabilities (transfer mode as programmed by the BIOS):\n",
				TargetId
				));

	DebugPrint((
				3,
				"\tAdvanced PIO modes supported (bit mask): %xh\n",
				Capabilities->AdvancedPioModes
				));

	DebugPrint((
				3,
				"\tMinimum PIO cycle time w/ IORDY: %xh\n",
				Capabilities->MinimumPioCycleTimeIordy
				));

	DebugPrint((
				3,
				"\tMultiword DMA modes supported (bit mask): %xh\n",
				Capabilities->MultiWordDmaSupport
				));

	DebugPrint((
				3,
				"\tMultiword DMA mode active (bit mask): %xh\n",
				Capabilities->MultiWordDmaActive
				));

	DebugPrint((
				3,
				"\tUltra DMA modes supported (bit mask): %xh\n",
				Capabilities->UltraDmaSupport
				));

	DebugPrint((
				3,
				"\tUltra DMA mode active (bit mask): %xh\n",
				Capabilities->UltraDmaActive
				));

#endif

	return;

} // end PrintCapabilities()

void FailDrive(PHW_DEVICE_EXTENSION DeviceExtension, UCHAR ucTargetId)
{
    UCHAR ucLogDrvId, ucPriDrvId, ucMirrorDrvId;
    ULONG ulTempInd;
    UCHAR ucIRCDLogDrvInd, ucPhyDrvInd, ucSpareDrvPoolInd, ucConnectionId;
    PIRCD_LOGICAL_DRIVE pLogDrive = NULL;
    PIRCD_PHYSICAL_DRIVE pPhyDrive = NULL;
    PIRCD_HEADER pHeader = NULL;
    UCHAR caConfigSector[512];
    ULONG ulDrvInd, ulSecInd;
    BOOLEAN bFoundIRCD;

    if ( DeviceExtension->PhysicalDrive[ucTargetId].TimeOutErrorCount >= ( MAX_TIME_OUT_ERROR_COUNT + 0x10 ) )
        // Failing of this drive is already done.... so don't do it again... it will be equal only if it is accumulated in PostIdeCmd
        return;

    ScsiPortLogError(DeviceExtension,0,0,0,0,SP_BAD_FW_WARNING,HYPERDISK_DRIVE_LOST_POWER);

    DebugPrint((0,"\nF%d", ucTargetId));

    // Begin Vasu - 18 Aug 2000
    // Code updated from Syam's Fix on 18 Aug
    // Moved out from the immediate if loop below.
    SetStatusChangeFlag(DeviceExtension, IDERAID_STATUS_FLAG_UPDATE_DRIVE_STATUS);
    // End Vasu

    ucLogDrvId = (UCHAR)DeviceExtension->PhysicalDrive[ucTargetId].ucLogDrvId;

    // Drive Time Out 
    DeviceExtension->PhysicalDrive[ucTargetId].TimeOutErrorCount = MAX_TIME_OUT_ERROR_COUNT + 0x10;

    // Begin Vasu - 18 Aug 2000
    // Code updated from Syam's Fix on 18 Aug
    // Doubt: This should be done to RAID10 drives as RAID10 primarily has two RAID1 arrays.

    // We should not do this failing of the drive if the Logical Drive type is Raid0 or Raid 10
    // We should decide only after initializing above variable since this will decide whether the commands
    // should go the drive or not (which will avoid the freezing of the system).
    // Begin Vasu - 28 Aug 2000
    // For RAID 10 also, the physical drive status should be changed to failed.
//    if (( Raid0 == DeviceExtension->LogicalDrive[ucLogDrvId].RaidLevel ) || 
//        ( Raid10 == DeviceExtension->LogicalDrive[ucLogDrvId].RaidLevel ) )
    if ( Raid0 == DeviceExtension->LogicalDrive[ucLogDrvId].RaidLevel )
    // End Vasu
    {
        return;
    }
    // End Vasu

    // Let us go ahead and fail this drive
    ChangeMirrorDriveStatus(
        DeviceExtension, 
        0,/*It doesn't matter ... 
          just for sake... inside the function we will find out the logical drive again
          */
        ucTargetId,
        PDS_Failed
        );

    for(ulTempInd=0;ulTempInd<DeviceExtension->LogicalDrive[ucLogDrvId].StripesPerRow;ulTempInd++)
    {
		// get the primary phy drive id and its mirror drive id
		ucPriDrvId = DeviceExtension->LogicalDrive[ucLogDrvId].PhysicalDriveTid[ulTempInd];
        ucMirrorDrvId = DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId & (~DRIVE_OFFLINE);

        if ( ( ucPriDrvId != ucTargetId )  && ( ucMirrorDrvId != ucTargetId ) ) // If this is not the drive... we just changed the status continue
            continue;

        // Begin Vasu - 09 Aug 2000
        // Added from Syam's Fix in the ATA100 Release 1.
        if (DeviceExtension->bInvalidConnectionIdImplementation)
        {
            DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId = INVALID_DRIVE_ID;
        }
        // End Vasu.

        // If any one drive has failed then Logical Drive should go to Degraded status
        if ( ( DeviceExtension->PhysicalDrive[ucPriDrvId].Status == PDS_Failed ) ||
            ( DeviceExtension->PhysicalDrive[ucMirrorDrvId].Status == PDS_Failed ) )
        {
            DeviceExtension->LogicalDrive[ucLogDrvId].Status = LDS_Degraded; 
        }

        // If any both drives has failed then Logical Drive should go to Failed status
        if ( ( DeviceExtension->PhysicalDrive[ucPriDrvId].Status == PDS_Failed ) &&
            ( DeviceExtension->PhysicalDrive[ucMirrorDrvId].Status == PDS_Failed ) )
        {
            DeviceExtension->LogicalDrive[ucLogDrvId].Status = LDS_OffLine;
        }
    }

    TryToUpdateIRCDOnAllControllers(DeviceExtension, (ULONG)ucTargetId);
	SetStatusChangeFlag(DeviceExtension, IDERAID_STATUS_FLAG_UPDATE_DRIVE_STATUS);

}

BOOLEAN
TryToUpdateIRCDOnAllControllers(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
    ULONG ulTargetId
    )
{
    ULONG ulBadDrvId;
    
    ulBadDrvId = (ULONG)(( ulTargetId ) | ( DeviceExtension->ucControllerId << 2));
    SetBadDriveInGlobalParameter(ulBadDrvId);
    gulLockVal = TryToLockIRCD(DeviceExtension);
    if ( !gulLockVal )
    {
        gulChangeIRCDPending = LOCK_IRCD_PENDING;
        return FALSE;
    }

    InformAllControllers();
    gulChangeIRCDPending = SET_IRCD_PENDING;


    return TRUE;
}


ULONG
TryToLockIRCD(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG ulTempLockVal = gulLockVal;

    if ( !ulTempLockVal )  // let us try to lock the IRCD (only if we didn't already lock it)
    {
        ulTempLockVal = LockIRCD(DeviceExtension, TRUE, 0);
    }

    return ulTempLockVal;
}

BOOLEAN
UpdateFinished()
{
    ULONG ulControllerInd;

    for(ulControllerInd=0;ulControllerInd<gucControllerCount;ulControllerInd++)
    {
        if (    ( gaCardInfo[ulControllerInd].pDE->Channel[0].bUpdateInfoPending ) || 
                ( gaCardInfo[ulControllerInd].pDE->Channel[1].bUpdateInfoPending ) )
                return FALSE;
    }

    return TRUE;
}

void
InformAllControllers()
{
    ULONG ulControllerInd;
    // We locked the IRCD... so let us go and inform all the controllers about this
    for(ulControllerInd=0;ulControllerInd<gucControllerCount;ulControllerInd++)
    {
        gaCardInfo[ulControllerInd].pDE->Channel[0].bUpdateInfoPending = TRUE;
        gaCardInfo[ulControllerInd].pDE->Channel[1].bUpdateInfoPending = TRUE;
    }

}

void
SetBadDriveInGlobalParameter(ULONG ulBadDrvId)
{
    ULONG ulBadDrvIdBitMap;
    ULONG ulTempPowerFailedTargetId;

    ulBadDrvIdBitMap = gulPowerFailedTargetBitMap | (1 << ulBadDrvId);

    do  // let us repeat the process of trying to set this bad drive Id
    {
        ulTempPowerFailedTargetId = gulPowerFailedTargetBitMap;
        ulBadDrvIdBitMap = gulPowerFailedTargetBitMap | (1 << ulBadDrvId);
        gulPowerFailedTargetBitMap = ulBadDrvIdBitMap;
    } while ( gulPowerFailedTargetBitMap != ulBadDrvIdBitMap );

    return;
}

void SetIRCDBufStatus(
    IN  PUCHAR pucIRCDBuf
    )
{
    UCHAR ucIRCDLogDrvInd, ucPhyDrvInd, ucSpareDrvPoolInd, ucConnectionId, ucLogDrvId;
    PIRCD_LOGICAL_DRIVE pLogDrive = NULL;
    PIRCD_PHYSICAL_DRIVE pPhyDrive = NULL;
    PIRCD_HEADER pHeader = NULL;
    ULONG ulDrvId, ulPowerFailedBitMap = gulPowerFailedTargetBitMap, ulTempPhyDrvId;
	PHW_DEVICE_EXTENSION pDE;

    DebugPrint((DEFAULT_DISPLAY_VALUE,"\nSIBS"));

    for(ulDrvId=0;ulPowerFailedBitMap;ulDrvId++, (ulPowerFailedBitMap>>=1))
    {
        if ( !( ulPowerFailedBitMap & 0x1 ) )
            continue;

        pDE = gaCardInfo[(ulDrvId>>2)].pDE;

        ucConnectionId = (UCHAR)TARGET_ID_2_CONNECTION_ID(ulDrvId);

        // Begin Vasu - 09 Aug 2000
        // Update from Syam's fix for ATA100 Release 1
        // Moved from inside the GetLogicalDriveId if loop.
        pHeader = (PIRCD_HEADER) pucIRCDBuf;
        pLogDrive = (PIRCD_LOGICAL_DRIVE) &pucIRCDBuf[sizeof(IRCD_HEADER)];
        // End Vasu.

        // Let us find out the PhysicalDrive location and change the physical and logical drive status
        if ( !GetIRCDLogicalDriveInd(pucIRCDBuf, ucConnectionId, &ucIRCDLogDrvInd, &ucPhyDrvInd, &ucSpareDrvPoolInd) )
        {
            DebugPrint((DEFAULT_DISPLAY_VALUE,"\nNF"));
            return;       // It is not a proper PhysicalDrive Id.. Something Terribly wrong
        }

        ucLogDrvId = (UCHAR)pDE->PhysicalDrive[TARGET_ID_WITHOUT_CONTROLLER_ID(ulDrvId)].ucLogDrvId;
        if ( ucLogDrvId < MAX_DRIVES_PER_CONTROLLER )
            pLogDrive[ucIRCDLogDrvInd].LogDrvStatus = (UCHAR)pDE->LogicalDrive[ucLogDrvId].Status;

        pPhyDrive = (PIRCD_PHYSICAL_DRIVE) &pucIRCDBuf[(sizeof(IRCD_HEADER) + 
                                                   (sizeof(IRCD_LOGICAL_DRIVE) * pHeader->NumberOfLogicalDrives))];
        for (ulTempPhyDrvId = 0; ulTempPhyDrvId < pHeader->NumberOfPhysicalDrives; ulTempPhyDrvId++)
        {
            if (pPhyDrive[ulTempPhyDrvId].ConnectionId == ucConnectionId)
            {
                DebugPrint((0,"\nFO1"));
                pPhyDrive[ulTempPhyDrvId].PhyDrvStatus = (UCHAR)pDE->PhysicalDrive[TARGET_ID_WITHOUT_CONTROLLER_ID(ulDrvId)].Status;
                    // Don't break as we need to take care of the drives in the spare drive pool also
                if ( pDE->bInvalidConnectionIdImplementation)
                    pPhyDrive[ulTempPhyDrvId].ConnectionId = INVALID_CONNECTION_ID;

                pDE->DeviceFlags[TARGET_ID_WITHOUT_CONTROLLER_ID(ulDrvId)] &= ~(DFLAGS_DEVICE_PRESENT);
            }
        }
    }
}

void SetOneDriveIRCD(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR ucTargetId
    )
{
    ULONG ulSecInd;
    UCHAR caConfigSector[512];

    if ( !IS_IDE_DRIVE(ucTargetId) )
        return;

    if ( DRIVE_IS_UNUSABLE_STATE(ucTargetId) )// This drive is bad... so let us not touch this....
        return;

    DebugPrint((DEFAULT_DISPLAY_VALUE,"\nSODI"));

    ulSecInd = DeviceExtension->PhysicalDrive[ucTargetId].IrcdSectorIndex;

#ifdef DUMMY_RAID10_IRCD

    AtapiMemCpy(caConfigSector, gucDummyIRCD, 512);

#else // DUMMY_RAID10_IRCD

	if ( PIOReadWriteSector(
				IDE_COMMAND_READ,
				DeviceExtension, 
				(ULONG)ucTargetId, 
				ulSecInd,
				caConfigSector))
    {

#endif // DUMMY_RAID10_IRCD

        SetIRCDBufStatus(caConfigSector);

#ifdef DUMMY_RAID10_IRCD

    AtapiMemCpy(gucDummyIRCD, caConfigSector, 512);

#else // DUMMY_RAID10_IRCD
	    if (PIOReadWriteSector(
				    IDE_COMMAND_WRITE,
				    DeviceExtension, 
                    (ULONG)ucTargetId, 
				    ulSecInd,
				    caConfigSector))
        {
		        // continue for the other drive
        }
    }

#endif // DUMMY_RAID10_IRCD

    DeviceExtension->PhysicalDrive[ucTargetId].bSetIRCDPending = FALSE;
}

BOOLEAN 
InSpareDrivePool(
                 IN PUCHAR RaidInfoSector,
                 IN UCHAR ucConnectionId)
{

    PIRCD_HEADER pRaidHeader = (PIRCD_HEADER)RaidInfoSector;
    PIRCD_LOGICAL_DRIVE pRaidLogDrive = (PIRCD_LOGICAL_DRIVE)GET_FIRST_LOGICAL_DRIVE(pRaidHeader);
    PIRCD_PHYSICAL_DRIVE pPhyDrive;
    ULONG ulLogDrvInd, ulDrvInd;

    for(ulLogDrvInd=0;ulLogDrvInd<pRaidHeader->NumberOfLogicalDrives;ulLogDrvInd++)
    {
        if ( SpareDrivePool == pRaidLogDrive[ulLogDrvInd].LogicalDriveType )
        {
	        pPhyDrive = (PIRCD_PHYSICAL_DRIVE)((char *)pRaidHeader + pRaidLogDrive[ulLogDrvInd].FirstStripeOffset);
			for(ulDrvInd=0;ulDrvInd<pRaidLogDrive[ulLogDrvInd].NumberOfDrives;ulDrvInd++)
            {
                if ( ucConnectionId == pPhyDrive[ulDrvInd].ConnectionId )
                    return TRUE;
            }
        }
    }

    return FALSE;
}

BOOLEAN
SetDriveFeatures(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR TargetId
)

/*++

Routine Description:

	This function sets the features of 'TargetId'.

Arguments:

	DeviceExtension		Pointer to miniport instance.
	TargetId			Target ID of the device whose features are to be set up.

Return Value:

	TRUE	Success.
	FALSE	Failure.

--*/

{
	PIDE_REGISTERS_1 baseIoAddress;
	UCHAR statusByte;
	UCHAR transferMode;


	baseIoAddress = DeviceExtension->BaseIoAddress1[TargetId >> 1];

    if ( DeviceExtension->bEnableRwCache ) 
    {
    	SELECT_DEVICE(baseIoAddress, TargetId);

		ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_ENABLE_WRITE_CACHE);

		ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);

		WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);
	}
    else
    {
    	SELECT_DEVICE(baseIoAddress, TargetId);

		ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_DISABLE_WRITE_CACHE);

		ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);

		WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);
    }

	SELECT_DEVICE(baseIoAddress, TargetId);

	ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_ENABLE_READ_CACHE);

	ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);

	WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);

    return ProgramTransferMode(DeviceExtension, TargetId);
}

BOOLEAN
ProgramTransferMode(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR TargetId
)

/*++

Routine Description:

	This function program the drive to work in the maximum possible transfer mode.

Arguments:

	DeviceExtension		Pointer to miniport instance.
	TargetId			Target ID of the device whose features are to be set up.

Return Value:

	TRUE	Success.
	FALSE	Failure.

--*/
{
	PIDE_REGISTERS_1 baseIoAddress;
	UCHAR statusByte;
	UCHAR transferMode;

	baseIoAddress = DeviceExtension->BaseIoAddress1[TargetId >> 1];

	switch(DeviceExtension->TransferMode[TargetId]) 
    {
		case PioMode0:
			transferMode = STM_PIO(0);
			break;

		case PioMode3:
			transferMode = STM_PIO(3);
			break;

		case PioMode4:
			transferMode = STM_PIO(4);
			break;

		case DmaMode0:
			transferMode = STM_MULTIWORD_DMA(0);
			break;

		case DmaMode1:
			transferMode = STM_MULTIWORD_DMA(1);
			break;

		case DmaMode2:
			transferMode = STM_MULTIWORD_DMA(2);
			break;

		case UdmaMode0:
			transferMode = STM_UDMA(0);
			break;

		case UdmaMode1:
			transferMode = STM_UDMA(1);
			break;

		case UdmaMode2:
			transferMode = STM_UDMA(2);
			break;

		case UdmaMode3:
            switch ( DeviceExtension->ControllerSpeed )
            {
                case Udma66:
                case Udma100:
    			    transferMode = STM_UDMA(3);
                    break;
                default:

    			    transferMode = STM_UDMA(2);
                    break;
            }
			break;

		case UdmaMode4:
            switch ( DeviceExtension->ControllerSpeed )
            {
                case Udma66:
                case Udma100:
			        transferMode = STM_UDMA(4);
                    break;
                default:
			        transferMode = STM_UDMA(2);
                    break;
            }
            break;
		case UdmaMode5:
            switch ( DeviceExtension->ControllerSpeed )
            {
                case Udma100:
			        transferMode = STM_UDMA(5);
                    break;
                case Udma66:
			        transferMode = STM_UDMA(4);
                    break;
                default:
			        transferMode = STM_UDMA(2);
                    break;
            }
            break;
		default:
			return(FALSE);
	}

	SELECT_DEVICE(baseIoAddress, TargetId);

	ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_SET_TRANSFER_MODE);

	ScsiPortWritePortUchar(&(baseIoAddress->SectorCount), transferMode);

	ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);
	
	WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);

	if ((statusByte & IDE_STATUS_ERROR) || (statusByte & IDE_STATUS_BUSY)) 
    {
		DebugPrint((1, "SetDriveFeatures on TID %d failed.\n", TargetId));

		return(FALSE);
	}

	return(TRUE);

} // end ProgramTransferMode()


BOOLEAN
SetDriveParameters(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR Channel,
	IN UCHAR DeviceNumber
)

/*++

Routine Description:

	Set drive parameters using the IDENTIFY data.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	DeviceNumber - Indicates which device.
	Channel - Indicates which channel.

Return Value:

	TRUE if all goes well.



--*/

{
	PIDE_REGISTERS_1	 baseIoAddress1 = DeviceExtension->BaseIoAddress1[Channel];
	PIDE_REGISTERS_2	 baseIoAddress2 = DeviceExtension->BaseIoAddress2[Channel];
	PIDENTIFY_DATA2		 identifyData	= &DeviceExtension->IdentifyData[(Channel * 2) + DeviceNumber];
	ULONG i;
	UCHAR statusByte;

	DebugPrint((3, "\nSetDriveParameters: Entering routine.\n"));

	DebugPrint((0, "SetDriveParameters: Drive : %ld Number of heads %x\n", DeviceNumber, identifyData->NumberOfHeads));

	DebugPrint((0, "SetDriveParameters: Sectors per track %x\n", identifyData->SectorsPerTrack));

    DebugPrint(( 0, "The value entering into the ports : %X\n", (ULONG)(((DeviceNumber << 4) | 0xA0) | (identifyData->NumberOfHeads - 1))) );

	//
	// Set up registers for SET PARAMETER command.
	//

	ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
						   (UCHAR)(((DeviceNumber << 4) | 0xA0) | (identifyData->NumberOfHeads - 1)));

    ScsiPortWritePortUchar(&baseIoAddress1->SectorCount, (UCHAR)identifyData->SectorsPerTrack);

	//
	// Send SET PARAMETER command.
	//

	ScsiPortWritePortUchar(&baseIoAddress1->Command,
						   IDE_COMMAND_SET_DRIVE_PARAMETERS);

    
	ScsiPortStallExecution(1000);

	//
	// Wait for up to 30 milliseconds for ERROR or command complete.
	//

	for (i = 0; i < 30 * 1000; i++) 
    {
		UCHAR errorByte;

//		GET_STATUS(baseIoAddress1, statusByte);
        statusByte = ScsiPortReadPortUchar(&baseIoAddress2->AlternateStatus);

		if (statusByte & IDE_STATUS_ERROR) 
        {
			errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);

			DebugPrint((0,
						"SetDriveParameters: Error bit set. Status %x, error %x\n",
						errorByte,
						statusByte));

			return FALSE;

		} else if ((statusByte & ~IDE_STATUS_INDEX ) == IDE_STATUS_IDLE) {

			break;

		} else {

			ScsiPortStallExecution(100);
		}
	}


    DebugPrint((0, "Status after setting Drive Parameters : %X\n", statusByte));

	//
	// Check for timeout.
	//

	GET_STATUS(baseIoAddress1, statusByte);

    if ((statusByte & ~IDE_STATUS_INDEX ) == IDE_STATUS_IDLE)
        return TRUE;
    else
        return FALSE;

} // end SetDriveParameters()

BOOLEAN
SetDriveRegisters(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PPHYSICAL_COMMAND pPhysicalCommand
)
{
	PIDE_REGISTERS_1 baseIoAddress1;
	UCHAR cylinderHigh;
	UCHAR cylinderLow;
	UCHAR headNumber;
	UCHAR sectors;
	UCHAR sectorNumber;
    USHORT heads;
	UCHAR k;
	USHORT sectorsPerTrack;
	ULONG startSector;
	UCHAR targetId;
    UCHAR statusByte = 0;

	DebugPrint((3, "\nSetDriveRegisters: Entering routine.\n"));

	k = GET_CHANNEL(pPhysicalCommand);
	targetId = pPhysicalCommand->TargetId;

	sectors = (UCHAR)DeviceExtension->TransferDescriptor[k].Sectors;
	startSector = DeviceExtension->TransferDescriptor[k].StartSector;

	baseIoAddress1 = DeviceExtension->BaseIoAddress1[k];

	WAIT_ON_BUSY(baseIoAddress1, statusByte);

	//
	// Check for erroneous IDE status.
	//
	if (statusByte & IDE_STATUS_BUSY)
    {
        DebugPrint((3, "S%x", (ULONG)statusByte));

        // Controller is not free for Accepting the command.
		return FALSE;
	}

    // Begin Vasu - 13 Feb 2001
    // Code to take care of Drive Removals
    if (statusByte & IDE_STATUS_ERROR)
    {
        DebugPrint((3, "S%x", (ULONG)statusByte));

        // Controller is not free for Accepting the command.
		return FALSE;
    }
    // End Vasu

	if (DeviceExtension->DeviceFlags[targetId] & DFLAGS_LBA) 
    {
        sectorNumber = (UCHAR) (startSector & 0x000000ff);
        cylinderLow = (UCHAR) ((startSector & 0x0000ff00) >> 8);
        cylinderHigh = (UCHAR) ((startSector & 0x00ff0000) >> 16);

        SELECT_LBA_DEVICE(baseIoAddress1, targetId, startSector);
	} 
    else 
    {
		sectorsPerTrack = DeviceExtension->IdentifyData[targetId].SectorsPerTrack;
		heads = DeviceExtension->IdentifyData[targetId].NumberOfHeads;

		// Calculate the start sector.
		sectorNumber = (UCHAR)((startSector % sectorsPerTrack) + 1);

		// Calculate the head number.
		headNumber = (UCHAR) ((startSector / sectorsPerTrack) % heads);

		// Calculate the low part of the cylinder number.
		cylinderLow =  (UCHAR)(startSector / (sectorsPerTrack * heads));

		// Calculate the high part of the cylinder number.
		cylinderHigh = (UCHAR)((startSector / (sectorsPerTrack * heads)) >> 8);

		// Program the device/head register.
		SELECT_CHS_DEVICE(baseIoAddress1, targetId, headNumber);
	}

	WAIT_ON_BUSY(baseIoAddress1, statusByte);

	//
	// Check for erroneous IDE status.
	//
	if (((statusByte & IDE_STATUS_BUSY)) || 
        (!(statusByte & IDE_STATUS_DRDY)))
    {
        // Drive is not Ready.
		return FALSE;
	}
   
    if (pPhysicalCommand->ucCmd == SCSIOP_EXECUTE_SMART_COMMAND)
    {
        ScsiPortWritePortUchar(((PUCHAR)baseIoAddress1 + 1), DeviceExtension->uchSMARTCommand);
	    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow, 0x4F);
	    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, 0xC2);
    }
    else
    {
    ScsiPortWritePortUchar(&baseIoAddress1->SectorCount, sectors);
	ScsiPortWritePortUchar(&baseIoAddress1->SectorNumber, sectorNumber);
	ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow, cylinderLow);
	ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, cylinderHigh);
    }

#ifdef DBG

	if (DeviceExtension->DeviceFlags[targetId] & DFLAGS_LBA) 
    {

		DebugPrint((
				1,
				"SetDriveRegisters: TID %d, Start sector %lxh, Sectors %xh\n",
				targetId,
				startSector,
				sectors
				));

	} 
    else 
    {

		DebugPrint((
				1,
				"SetDriveRegisters: TID %d, Cylinder %xh, Head %xh, Sector %xh\n",
				targetId,
				cylinderLow + (cylinderHigh << 8),
				headNumber,
				sectorNumber
				));
	}

#endif // ifdef DBG

	return TRUE;

} // end SetDriveRegisters()


BOOLEAN
GetIoMode(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR TargetId
)

{
	PIDENTIFY_DATA capabilities;
	ULONG sectors, length;
	BOOLEAN success = TRUE;
    IDE_PCI_REGISTERS pciRegisters;
    char *pcPciRegisters = (PUCHAR)&pciRegisters;

	capabilities = &(DeviceExtension->FullIdentifyData[TargetId]);
	
	// Calculate the total number of addressable sectors using CHS convention.
	sectors = capabilities->NumberOfCylinders * capabilities->NumberOfHeads *
			  capabilities->SectorsPerTrack;

	if (capabilities->TranslationFieldsValid & IDENTIFY_FAST_TRANSFERS_SUPPORTED) 
    {

#ifdef DBG
		PrintCapabilities(capabilities, TargetId);
#endif
		

		if ((capabilities->Capabilities & IDENTIFY_CAPABILITIES_LBA_SUPPORTED)) 
        {
			DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_LBA;

			// Get the total number of LBA-mode addressable sectors.
			sectors = capabilities->UserAddressableSectors;

        	DebugPrint((2, "GetIoMode:  TID %d supports LBA\n", TargetId));
		}
    }

	DeviceExtension->PhysicalDrive[TargetId].Sectors = sectors;


	DeviceExtension->PhysicalDrive[TargetId].OriginalSectors = sectors;

    GetTransferMode(DeviceExtension,TargetId);

	return(success);
}
BOOLEAN
TargetAccessible(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb

)

{
	if (
		Srb->PathId == 0 &&
		Srb->Lun == 0 &&
		(DeviceExtension->IsLogicalDrive[Srb->TargetId] ||
		DeviceExtension->IsSingleDrive[Srb->TargetId])
		)
    {
        return TRUE;
    }

    return FALSE;
} // end TargetAccessible()

void SynchronizeIRCD(
	IN PSCSI_REQUEST_BLOCK Srb
    )
{

    PIRCD_DATA pIrcdData = (PIRCD_DATA) (((PSRB_BUFFER)(Srb->DataBuffer))->caDataBuffer);
    PIRCD_HEADER pRaidHeader = (PIRCD_HEADER)(pIrcdData->caIRCDDataBuff);
    PIRCD_LOGICAL_DRIVE pRaidLogDrive = (PIRCD_LOGICAL_DRIVE)(GET_FIRST_LOGICAL_DRIVE(pRaidHeader));
    BOOLEAN bFound = FALSE;
    ULONG ulLogDrvInd, ulDrvInd;
    PIRCD_PHYSICAL_DRIVE pPhyDrive;
    UCHAR ucLocalLogDrvId;
    UCHAR ucLocalPhyDrvId;
    PHW_DEVICE_EXTENSION pDE;

    for(ulLogDrvInd=0;ulLogDrvInd<pRaidHeader->NumberOfLogicalDrives;ulLogDrvInd++)
    {
        pPhyDrive = (PIRCD_PHYSICAL_DRIVE)((char *)pRaidHeader + pRaidLogDrive[ulLogDrvInd].FirstStripeOffset);

        if ( !FoundValidDrive(pPhyDrive, pRaidLogDrive[ulLogDrvInd].NumberOfDrives) )
        {   // No valid Drive in this logical drive.. so let us not worry about this drive
            continue;
        }

        for(ulDrvInd=0;ulDrvInd<pRaidLogDrive[ulLogDrvInd].NumberOfDrives;ulDrvInd++)
        {
            if ( INVALID_CONNECTION_ID == pPhyDrive[ulDrvInd].ConnectionId )
                continue;
            ucLocalPhyDrvId = GET_TARGET_ID(pPhyDrive[ulDrvInd].ConnectionId);
        }

        pDE = gaCardInfo[(ucLocalPhyDrvId>>2)].pDE;

        if ( SpareDrivePool != pRaidLogDrive[ulLogDrvInd].LogicalDriveType )    // There is nothing like status for a Spare Drive Pool
        {
            ucLocalLogDrvId = pDE->PhysicalDrive[TARGET_ID_WITHOUT_CONTROLLER_ID(ucLocalPhyDrvId)].ucLogDrvId;
            if ( ucLocalLogDrvId < MAX_DRIVES_PER_CONTROLLER )   // Just a sanity check ... In case something goes wrong
                pRaidLogDrive[ulLogDrvInd].LogDrvStatus = (UCHAR)pDE->LogicalDrive[ucLocalLogDrvId].Status;
        }

        for(ulDrvInd=0;ulDrvInd<pRaidLogDrive[ulLogDrvInd].NumberOfDrives;ulDrvInd++)
        {   // let us change status of all the Physical Drives IN THIS LOGICAL DRIVE
            if ( INVALID_CONNECTION_ID == pPhyDrive[ulDrvInd].ConnectionId )    // no drive present at this place
                continue;
            ucLocalPhyDrvId = TARGET_ID_WITHOUT_CONTROLLER_ID((GET_TARGET_ID(pPhyDrive[ulDrvInd].ConnectionId)));
            pPhyDrive[ulDrvInd].PhyDrvStatus = (UCHAR)pDE->PhysicalDrive[ucLocalPhyDrvId].Status;
        }
    }
}

SRBSTATUS
DummySendRoutine(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{
    return SRB_STATUS_SELECTION_TIMEOUT;
}

SRBSTATUS
DummyPostRoutine(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PPHYSICAL_COMMAND pPhysicalCommand
)
{
    return SRB_STATUS_SELECTION_TIMEOUT;
}


BOOLEAN PIOReadWriteSector(
				UCHAR					theCmd,	// IDE_COMMAND_READ or write
				PHW_DEVICE_EXTENSION	DeviceExtension, 
				LONG					lTargetId, 
				ULONG					ulSectorInd,
				PUCHAR					pSectorBuffer)
{
    ULONG ulSectors;
    ULONG ulChannel = lTargetId>>1;
	PIDE_REGISTERS_1 pBaseIoAddress1 = DeviceExtension->BaseIoAddress1[ulChannel];
    PIDE_REGISTERS_2 pBaseIoAddress2 = DeviceExtension->BaseIoAddress2[ulChannel];
    ULONG ulCount, ulSecCounter, ulValue;
    UCHAR ucStatus, ucTemp;
    ULONG ulSectorNumber, ulCylinderLow, ulCylinderHigh, ulHead;

    if (!IS_IDE_DRIVE(lTargetId))
        return FALSE;

    // End Vasudevan

    if ( !DeviceExtension->PhysicalDrive[lTargetId].OriginalSectors )
    {
        DebugPrint((0," IF 1 "));
        return FALSE;       // No drive there. So, nothing to read from.
    }


	SELECT_LBA_DEVICE(pBaseIoAddress1, lTargetId, ulSectorInd);

	ScsiPortStallExecution(1);  // we have to wait atleast 400 ns ( 1000 ns = 1 Micro Second ) to get the Busy Bit to set

    WAIT_ON_BUSY(pBaseIoAddress1, ucStatus);

    if ( ((ucStatus & IDE_STATUS_BUSY)) || (!(ucStatus & IDE_STATUS_DRDY)) )
    {
        DebugPrint((0,"\n\n\n\n\nAre Very B A D \n\n\n\n\n"));
    }

    ulSectorNumber = ulSectorInd & 0x000000ff;
    ulCylinderLow = (ulSectorInd & 0x0000ff00) >> 8;
    ulCylinderHigh = (ulSectorInd & 0xff0000) >> 16;

	ScsiPortWritePortUchar(&pBaseIoAddress1->SectorCount, 1);
	ScsiPortWritePortUchar(&pBaseIoAddress1->SectorNumber, (UCHAR)ulSectorNumber);
	ScsiPortWritePortUchar(&pBaseIoAddress1->CylinderLow,(UCHAR)ulCylinderLow);
	ScsiPortWritePortUchar(&pBaseIoAddress1->CylinderHigh,(UCHAR)ulCylinderHigh);
    ScsiPortWritePortUchar(&pBaseIoAddress1->Command, theCmd);

    WAIT_ON_BUSY(pBaseIoAddress1, ucStatus);

    WAIT_FOR_DRQ(pBaseIoAddress1, ucStatus);

	if (!(ucStatus & IDE_STATUS_DRQ)) 
    {
		DebugPrint((0,"\nHaaa.... I couldn't read/write the sector..............1\n"));
		return(FALSE);
	}

	//
	// Read status to acknowledge any interrupts generated.
	//

	GET_BASE_STATUS(pBaseIoAddress1, ucStatus);

	//
	// Check for error on really stupid master devices that assert random
	// patterns of bits in the status register at the slave address.
	//

	if (ucStatus & IDE_STATUS_ERROR) 
    {
		DebugPrint((0,"\nHaaa.... I couldn't read/write the sector..............2\n"));
		return(FALSE);
	}

	WAIT_ON_BUSY(pBaseIoAddress1,ucStatus);

	WAIT_ON_BUSY(pBaseIoAddress1,ucStatus);

	WAIT_ON_BUSY(pBaseIoAddress1,ucStatus);

	if ( (ucStatus & IDE_STATUS_DRQ) && (!(ucStatus & IDE_STATUS_BUSY)) )
    {
		if (theCmd == IDE_COMMAND_READ) 
        {
			READ_BUFFER(pBaseIoAddress1, (unsigned short *)pSectorBuffer, 256);
		}
		else 
        {
			if (theCmd == IDE_COMMAND_WRITE)
            {
                ULONG ulCounter;
				WRITE_BUFFER(pBaseIoAddress1, (unsigned short *)pSectorBuffer, 256);
                WAIT_FOR_DRQ(pBaseIoAddress1, ucStatus);
	            if (ucStatus & IDE_STATUS_DRQ) 
                {
		            DebugPrint((0,"\nHaaa.... I couldn't read/write the sector..............3\n"));
                    for(ulCounter=0;ulCounter<4;ulCounter++)
                    {
                        ScsiPortWritePortUchar((PUCHAR)&pBaseIoAddress1->Data, pSectorBuffer[ulCounter]);
                        ScsiPortStallExecution(1);  // we have to wait atleast 400 ns ( 1000 ns = 1 Micro Second ) to get the Busy Bit to set
                    }
	            }
            }
		}

	    //
	    // Read status. This will clear the interrupt.
	    //
    	GET_BASE_STATUS(pBaseIoAddress1, ucStatus);
        return TRUE;
    }
    else
    {
	    //
	    // Read status. This will clear the interrupt.
	    //

        GET_BASE_STATUS(pBaseIoAddress1, ucStatus);
        DebugPrint((0," IF 2 "));
        return FALSE;
    }
}

ULONG LockIRCD(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN Lock,   
    IN ULONG UnlockKey)
/*
    Locks or Unlocks the Access to IRCD with the help of a variable.

    if Lock is aquired, then the return value will be a ULONG number which must be 
    returned again in the UnlockKey parameter for unlocking. If the given ULONG number
    does not match with what was returned before, then Unlock will fail.
*/
{
    LARGE_INTEGER liSysTime;
    PUCHAR puchCurrentTime = NULL;
    PUCHAR puchOldTime = NULL;

    AtapiFillMemory((PUCHAR)&liSysTime, sizeof(LARGE_INTEGER), 0);

    FillTimeStamp(&liSysTime);

    if (Lock)   // Lock Request
    {
        if (gcIRCDLocked)
        {

            puchCurrentTime = (UCHAR *) &(liSysTime.LowPart);
            puchOldTime = (UCHAR *) &((gIRCDLockTime).LowPart);

            if (puchCurrentTime[1] > puchOldTime[1])  // if the hours are changed
            {
                puchCurrentTime[2] += 60;
            }

            if (puchCurrentTime[2] == puchOldTime[2]) // if the two minutes are the same
            {
                // Locked by some other call and the TimeOut has not reached yet.!
                return 0;
            }

            if ( gbDoNotUnlockIRCD ) // No more changes to IRCD allowed... so donot try to unlock/unlock
                return 0;
        }

        gcIRCDLocked = TRUE;

        gIRCDLockTime.LowPart = liSysTime.LowPart;
        gIRCDLockTime.HighPart = liSysTime.HighPart;

        gulIRCDUnlockKey++;

        if ((LONG) gulIRCDUnlockKey <= 0)
            gulIRCDUnlockKey = 1;
    }
    else        // Unlock Request
    {
        if ( gbDoNotUnlockIRCD ) // No more changes to IRCD allowed... so donot try to unlock/unlock
            return 0;

        if (gulIRCDUnlockKey == UnlockKey)
        {
            gcIRCDLocked = FALSE;
            gIRCDLockTime.LowPart = 0;
            gIRCDLockTime.HighPart = 0;
            return 1;
        }
        else
            return 0;
    }
    
    return gulIRCDUnlockKey;
}

VOID
FillTimeStamp(
    IN OUT PLARGE_INTEGER pTimeStamp
)
{
    //
    // StampLowPart :  aa bb cc dd
    // StampHighPart : ee ff gg hh
    //
    // dd : Seconds
    // cc : Minutes
    // bb : Hours
    // aa : Day Of Week (Sunday = 0; Saturday = 6)
    //
    // hh : Date (0 to 31)
    // gg : Month (1 to 12)
    // ff : Year 
    // ee : Century
    //

    PUCHAR pTime = (PUCHAR) &(pTimeStamp->LowPart);
    PUCHAR pDate = (PUCHAR) &(pTimeStamp->HighPart);
    UCHAR uchData = 0;

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x0A);
    uchData = ScsiPortReadPortUchar((PUCHAR)0x71);

    if (uchData & 0x80)
        return;

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x00);
    pTime[3] = ScsiPortReadPortUchar((PUCHAR)0x71); // Seconds
    
    ScsiPortWritePortUchar((PUCHAR)0x70, 0x02);
    pTime[2] = ScsiPortReadPortUchar((PUCHAR)0x71); // Minutes

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x04);
    pTime[1] = ScsiPortReadPortUchar((PUCHAR)0x71); // Hours

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x06);
    pTime[0] = ScsiPortReadPortUchar((PUCHAR)0x71); // Day Of Week

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x07);
    pDate[3] = ScsiPortReadPortUchar((PUCHAR)0x71); // Date

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x08);
    pDate[2] = ScsiPortReadPortUchar((PUCHAR)0x71); // Month

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x09);
    pDate[1] = ScsiPortReadPortUchar((PUCHAR)0x71); // Year

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x32);
    pDate[0] = ScsiPortReadPortUchar((PUCHAR)0x71); // Century

    return;
} // end FillTimeStamp

BOOLEAN
AssignSglPtrsForPhysicalCommands
    (
        IN PHW_DEVICE_EXTENSION DeviceExtension
    )
{

    PPHYSICAL_DRIVE pPhysicalDrive;
    ULONG ulDrvInd;
    PSGL_ENTRY sgl;
    LONG lengthInNextBoundary;
    LONG lengthLeftInBoundary;
	ULONG maxSglEntries;
    ULONG sglBasePhysicalAddress, length;
    ULONG ulStartAddress, ulEndAddress, ulStartPage, ulEndPage;
    ULONG ulLengthReduced = 0;
    
    pPhysicalDrive = &(DeviceExtension->PhysicalDrive[0]);

    for(ulDrvInd=0;ulDrvInd<MAX_DRIVES_PER_CONTROLLER;ulDrvInd++)
    {
		sgl = &(pPhysicalDrive[ulDrvInd].PhysicalCommand.sglEntry[0]);

    	//
    	// Get physical SGL address.
    	//
        sglBasePhysicalAddress = ScsiPortConvertPhysicalAddressToUlong(
        				ScsiPortGetPhysicalAddress(DeviceExtension, NULL, sgl, &length));


		ASSERT(sglBasePhysicalAddress != NULL);

		if (sglBasePhysicalAddress == 0) 
        {
			return(FALSE);
		}

        if (length >= (MAX_SGL_ENTRIES_PER_PHYSICAL_DRIVE * sizeof(SGL_ENTRY)))
        {
            length = MAX_SGL_ENTRIES_PER_PHYSICAL_DRIVE * sizeof(SGL_ENTRY);
        }

        ulStartAddress = (ULONG)sglBasePhysicalAddress;
        ulEndAddress = ulStartAddress + length;


		//
    	// Check to see if SGL Pointer is DWORD Aligned and make it so.
    	// Remember we allocated an extra SGL entry for this purpose.
		//

    	if ((ULONG)sglBasePhysicalAddress & 3) 
        {
        	sglBasePhysicalAddress = (((ULONG)sglBasePhysicalAddress & 0xfffffffcL) + 4L); 
            ulLengthReduced = sglBasePhysicalAddress - ulStartAddress;
            ulStartAddress = (ULONG)sglBasePhysicalAddress;
            length -= ulLengthReduced;
            sgl += ulLengthReduced;
		}

        ASSERT(length < (MAX_SGL_ENTRIES_PER_PHYSICAL_DRIVE / 2));

#ifdef DBG
        if (length < (MAX_SGL_ENTRIES_PER_PHYSICAL_DRIVE / 2))
        {
            STOP;
        }
#endif // DBG

        ulStartPage = (ULONG)( ulStartAddress / SGL_HW_BOUNDARY );
        ulEndPage = (ULONG)( ulEndAddress / SGL_HW_BOUNDARY );

        if ( ulStartPage == ulEndPage )
        {   // all entries are in the same page
			maxSglEntries =   (length / sizeof(SGL_ENTRY));
        }
        else
        {
		    //
    	    // Make sure the SGL does NOT cross a 4K boundary.
		    //
    	    lengthLeftInBoundary = SGL_HW_BOUNDARY - ((ULONG)sglBasePhysicalAddress & (SGL_HW_BOUNDARY - 1));

    	    lengthInNextBoundary = length - lengthLeftInBoundary;

    	    if (lengthInNextBoundary > lengthLeftInBoundary) 
            {
			    //
			    // SGL crosses 4KB boundary and top portion is larger than bottom.
			    // Use top portion.
			    //
                sglBasePhysicalAddress = sglBasePhysicalAddress + lengthLeftInBoundary;
        	    sgl = (PSGL_ENTRY) ((ULONG)sgl + lengthLeftInBoundary); 
			    maxSglEntries =  lengthInNextBoundary / sizeof(SGL_ENTRY);

		    } 
            else 
            {
			    maxSglEntries =  lengthLeftInBoundary / sizeof(SGL_ENTRY);
		    }
        }

        DebugPrint((0, "        SGL physical address = %lxh for %ld\n", sglBasePhysicalAddress, ulDrvInd));
		DebugPrint((0, "             Max SGL entries = %lxh for %ld\n", maxSglEntries, ulDrvInd));

		//
		// Save SGL info for next call.
		//
		pPhysicalDrive[ulDrvInd].PhysicalCommand.SglBaseVirtualAddress = (PSGL_ENTRY) sgl;
		pPhysicalDrive[ulDrvInd].PhysicalCommand.SglBasePhysicalAddress = sglBasePhysicalAddress;
		pPhysicalDrive[ulDrvInd].PhysicalCommand.MaxSglEntries = maxSglEntries;
    }
    return TRUE;
}

BOOLEAN
DisableInterrupts(
    IN PHW_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG ulController;
    PBM_REGISTERS         BMRegister = NULL;
    UCHAR opcimcr;

    BMRegister = DeviceExtension->BaseBmAddress[0];
    //
    // Enable the Interrupt notification so that further interrupts are got.
    // This is done because, there is no interrupt handler at the time
    // before the actual registration of the Int. handler..
    //
    opcimcr = ScsiPortReadPortUchar(((PUCHAR)BMRegister + 1));
    opcimcr |= 0x30;
    // Begin Vasu - 7 Feb 2001
    // Enable Read Multiple here as this is the place where we write this register back.
    opcimcr &= 0xF0; // Dont Clear Interrupt Pending Flags.
    opcimcr |= 0x01;
    // End Vasu
    ScsiPortWritePortUchar(((PUCHAR)BMRegister + 1), opcimcr);

    return TRUE;
}

BOOLEAN
EnableInterrupts(
    IN PHW_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG ulController;
    PBM_REGISTERS         BMRegister = NULL;
    UCHAR opcimcr;

    BMRegister = DeviceExtension->BaseBmAddress[0];
    //
    // Enable the Interrupt notification so that further interrupts are got.
    // This is done because, there is no interrupt handler at the time
    // before the actual registration of the Int. handler..
    //
    opcimcr = ScsiPortReadPortUchar(((PUCHAR)BMRegister + 1));
    opcimcr &= 0xCF;
    // Begin Vasu - 7 Feb 2001
    // Enable Read Multiple here as this is the place where we write this register back.
    opcimcr &= 0xF0; // Dont Clear Interrupt Pending Flags.
    opcimcr |= 0x01;
    // End Vasu
    ScsiPortWritePortUchar(((PUCHAR)BMRegister + 1), opcimcr);

    return TRUE;
}

BOOLEAN
InitDriveFeatures(
    IN OUT PHW_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Initialize some features on drive (which are required at the initialization time)
    Right now we are enabling Cache implementation features... (this is to resolve the bug of 
    bad performance on some IBM Drives)

Arguments:

    DeviceExtension - HBA miniport driver's adapter data storage
Return Value:

    BOOLEAN
--*/
{
    PIDE_REGISTERS_1  baseIoAddress;
    UCHAR ucDrvInd;
    UCHAR statusByte;

    for(ucDrvInd=0;ucDrvInd<MAX_DRIVES_PER_CONTROLLER;ucDrvInd++)
    {
        if ( !IS_IDE_DRIVE(ucDrvInd) )
            continue;

        baseIoAddress = DeviceExtension->BaseIoAddress1[ucDrvInd >> 1];

        if ( DeviceExtension->bEnableRwCache ) 
        {

            SELECT_DEVICE(baseIoAddress, ucDrvInd);

            ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_ENABLE_WRITE_CACHE);

            ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);

            WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);
        }
        else
        {
    	    SELECT_DEVICE(baseIoAddress, ucDrvInd);

		    ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_DISABLE_WRITE_CACHE);

		    ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);

		    WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);
        }

        SELECT_DEVICE(baseIoAddress, ucDrvInd);

        ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_ENABLE_READ_CACHE);

        ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);

        WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);

        SetMultiBlockXfers( DeviceExtension, ucDrvInd);
    }

    return TRUE;
}

BOOLEAN
SupportedController(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    USHORT VendorId,
    USHORT DeviceId
)

{
    BOOLEAN found;

    if (VendorId == 0x1095) 
    {
        switch (DeviceId)
        {
            case 0x648:
			    found = TRUE;
                break;
            case 0x649:
			    found = TRUE;
                break;
            default:
                found = FALSE;
                break;
        }
    }
    else
    {
	    // Assume failure.
	    found = FALSE;
    }

    return(found);

} // end SupportedController()

#define PCI_MAX_BUS	0xFF

BOOLEAN ScanPCIBusForHyperDiskControllers(
    IN PHW_DEVICE_EXTENSION DeviceExtension
    )
{
	PCI_SLOT_NUMBER slot;
    UCHAR   pciBus, pciDevice, pciFunction;
    ULONG ulLength, ulPCICode;

    if ( gbFinishedScanning )
        return TRUE;

	slot.u.AsULONG = 0;

    gbFinishedScanning = TRUE;

    for(pciBus = 0;pciBus < PCI_MAX_BUS;pciBus++)
    {
	    //
	    // Look at each device.
	    //
	    for (pciDevice = 0; pciDevice < PCI_MAX_DEVICES; pciDevice++) 
        {
            slot.u.bits.DeviceNumber = pciDevice;

            //
            // Look at each function.
            //
            for (pciFunction = 0; pciFunction < PCI_MAX_FUNCTION; pciFunction++) 
            {
	            slot.u.bits.FunctionNumber = pciFunction;

                ulPCICode = 0x80000000 | (pciFunction<<0x8) | (pciDevice<<0xb) | (pciBus<<0x10);

                _asm 
                {
                    push eax
                    push edx
                    push ebx

                    mov edx, 0cf8h
                    mov eax, ulPCICode
                    out dx, eax

                    add dx, 4
                    in eax, dx

                    mov ulPCICode, eax

                    pop ebx
                    pop edx
                    pop eax
                }

	            if ( PCI_INVALID_VENDORID == (ulPCICode & 0xffff) ) 
                {
		            //
		            // No PCI device, or no more functions on device.
		            // Move to next PCI device.
		            //
		            continue;
	            }

			    //
			    // Find out if the controller is supported.
			    //

			    if (!SupportedController(
                                        DeviceExtension,
                                        (USHORT)(ulPCICode & 0xffff),
                                        (USHORT)(ulPCICode >> 0x10)
                                        )
				    ) 
                {

				    //
				    // Not our PCI device. Try next device/function
				    //

				    continue;
			    }

                if ( !ShouldThisCardBeHandledByUs(pciBus, pciDevice, pciFunction) )
                {
                    continue;       // looks like it is should not be handled by us
                }

                // Let us store the info in the array
                gaCardInfo[gucControllerCount].ucPCIBus = pciBus;
                gaCardInfo[gucControllerCount].ucPCIDev = pciDevice;
                gaCardInfo[gucControllerCount].ucPCIFun = pciFunction;
                gaCardInfo[gucControllerCount].ulDeviceId = ulPCICode >> 0x10;
                gaCardInfo[gucControllerCount].ulVendorId = ulPCICode & 0xffff;
                gaCardInfo[gucControllerCount++].pDE = NULL;

                DebugPrint((0, "Found Card at %x:%x:%x\n", pciBus, pciDevice, pciFunction));

		    }	// next PCI function

        }	// next PCI device

    } // next PCI Bus

    return TRUE;
}


#define COMPAQ_VENDOR_ID        0x0e11
#define COMPAQ_DEVICE_ID        0x005d
    

BOOLEAN ShouldThisCardBeHandledByUs(UCHAR pciBus, UCHAR pciDevice, UCHAR pciFunction)
{
    ULONG ulSubSysId, ulPCICode;
    USHORT usSubVenId, usSubDevId;

    ulPCICode = 0x80000000 | (pciFunction<<0x8) | (pciDevice<<0xb) | (pciBus<<0x10) | 0x8c; // SubSysId Offset

    _asm 
    {
        push eax
        push edx
        push ebx

        mov edx, 0cf8h
        mov eax, ulPCICode
        out dx, eax

        add dx, 4
        in eax, dx

        mov ulSubSysId, eax

        pop ebx
        pop edx
        pop eax
    }


    usSubVenId = (USHORT)(ulSubSysId & 0xffff);
    usSubDevId = (USHORT)(ulSubSysId >> 16);

    if ( COMPAQ_VENDOR_ID  == usSubVenId  )
    {
        if ( COMPAQ_DEVICE_ID == usSubDevId  )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {   // if it is a NON COMPAQ card we will boot by default
        return TRUE;
    }
}

#ifdef HYPERDISK_WINNT
BOOLEAN 
AssignDeviceInfo(
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )
{
	PCI_SLOT_NUMBER PCISlot;

    if ( gucNextControllerInd >= gucControllerCount )
        return FALSE;


    PCISlot.u.AsULONG = 0;

    ConfigInfo->SystemIoBusNumber = gaCardInfo[gucNextControllerInd].ucPCIBus;
    PCISlot.u.bits.DeviceNumber = gaCardInfo[gucNextControllerInd].ucPCIDev;
    PCISlot.u.bits.FunctionNumber = gaCardInfo[gucNextControllerInd].ucPCIFun;

    ConfigInfo->SlotNumber = PCISlot.u.AsULONG;

    gucNextControllerInd++;
    return TRUE;
}

#endif

#include "Init.c"
#include "IOCTL.C"
#include "StartIO.C"
#include "ISR.C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaide\hyperdisk.h ===
/*********************************************************

  HyperDisk.h

  Main Header File for HyperDisk

*********************************************************/

#ifndef _HYPERDISK_H_
#define _HYPERDISK_H_

#ifndef HYPERDISK_WIN98
#include "scsi.h"
#else   // HYPERDISK_WIN98
#include "Scsi9x.h"
#endif  // HYPERDISK_WIN98

#include "stdio.h"
#include "string.h"

#include "raid.h"

//
// Quick way to break into the debugger while keeping
// the local context active.
//
#ifdef DBG
#define STOP	_asm {int 3}
#else
#define STOP
#endif

// Interrupt Status Bits to be read from either 71h of PCI Config Space 
// or In (BM Base Register + 1) for Primary Channel 
#define PRIMARY_CHANNEL_INTERRUPT       0x04
#define SECONDARY_CHANNEL_INTERRUPT     0x08

#define ANY_CHANNEL_INTERRUPT           (PRIMARY_CHANNEL_INTERRUPT | SECONDARY_CHANNEL_INTERRUPT)


// Power on Reset Bits to be read from either 71h of PCI Config Space 
// or In (BM Base Register + 1) for Primary Channel
#define POWER_ON_RESET_FOR_PRIMARY_CHANNEL            0x40
#define POWER_ON_RESET_FOR_SECONDARY_CHANNEL          0x80

#define POWER_ON_RESET_FOR_BOTH_CHANNEL           (POWER_ON_RESET_FOR_PRIMARY_CHANNEL | POWER_ON_RESET_FOR_SECONDARY_CHANNEL)

#pragma pack(1)

typedef struct _PACKED_ACCESS_RANGE {

	SCSI_PHYSICAL_ADDRESS RangeStart;
	ULONG RangeLength;
	BOOLEAN RangeInMemory;

} PACKED_ACCESS_RANGE, *PPACKED_ACCESS_RANGE;

#pragma pack()

//
// IDE register definition
//
typedef struct _IDE_REGISTERS_1 {
    USHORT Data;
    UCHAR SectorCount;
    UCHAR SectorNumber;
    UCHAR CylinderLow;
    UCHAR CylinderHigh;
    UCHAR DriveSelect;
    UCHAR Command;
} IDE_REGISTERS_1, *PIDE_REGISTERS_1;

typedef struct _IDE_REGISTERS_2 {
    UCHAR ucReserved1;
    UCHAR ucReserved2;
    UCHAR AlternateStatus;  // This will itself behave as "DriveAddress" when it is used as out port
    UCHAR ucReserved3;
} IDE_REGISTERS_2, *PIDE_REGISTERS_2;

typedef struct _IDE_REGISTERS_3 {
    ULONG Data;
    UCHAR Others[4];
} IDE_REGISTERS_3, *PIDE_REGISTERS_3;

//
// ATAPI register definition
//

typedef struct _ATAPI_REGISTERS_1 {
    USHORT Data;
    UCHAR InterruptReason;
    UCHAR Unused1;
    UCHAR ByteCountLow;
    UCHAR ByteCountHigh;
    UCHAR DriveSelect;
    UCHAR Command;
} ATAPI_REGISTERS_1, *PATAPI_REGISTERS_1;

typedef struct _ATAPI_REGISTERS_2 {
    UCHAR AlternateStatus;
    UCHAR DriveAddress;
} ATAPI_REGISTERS_2, *PATAPI_REGISTERS_2;

//
// Device selection constants used for programming the device/head register.
//
#define IDE_LBA_MODE		0xE0
#define IDE_CHS_MODE		0xA0

//
// Device Extension Device Flags
//
#define DFLAGS_DEVICE_PRESENT        (1 << 0)    // Indicates that some device is present.
#define DFLAGS_ATAPI_DEVICE          (1 << 1)    // Indicates whether Atapi commands can be used.
#define DFLAGS_TAPE_DEVICE           (1 << 2)    // Indicates whether this is a tape device.
#define DFLAGS_INT_DRQ               (1 << 3)    // Indicates whether device interrupts as DRQ
												 // is set after receiving Atapi Packet Command.
#define DFLAGS_REMOVABLE_DRIVE       (1 << 4)    // Indicates that the drive has the 'removable'
												 // bit set in identify data (offset 128).
#define DFLAGS_MEDIA_STATUS_ENABLED  (1 << 5)    // Media status notification enabled

#define DFLAGS_USE_DMA               (1 << 9)    // Indicates whether device can use DMA
#define DFLAGS_LBA                   (1 << 10)   // support LBA addressing
#define DFLAGS_MULTI_LUN_INITED      (1 << 11)   // Indicates that the init path for multi-lun
												 // has already been done.
#define DFLAGS_MSN_SUPPORT           (1 << 12)   // Device support media status notification
#define DFLAGS_AUTO_EJECT_ZIP        (1 << 13)   // bootup default enables auto eject
#define DFLAGS_WD_MODE               (1 << 14)   // Indicates that unit is WD-Mode(not SFF-Mode).
#define DFLAGS_LS120_FORMAT          (1 << 15)   // Indicates that unit uses
												 // ATAPI_LS120_FORMAT_UNIT to format.
#define DFLAGS_USE_UDMA              (1 << 16)   // Indicates whether device can use UDMA

#define DFLAGS_ATAPI_CHANGER         (1 << 29)	 // Indicates atapi 2.5 changer present.
#define DFLAGS_SANYO_ATAPI_CHANGER   (1 << 30)   // Indicates multi-platter device, not
												 // conforming to the 2.5 spec.
#define DFLAGS_CHANGER_INITED        (1 << 31)   // Indicates that the init path for changers has
												 // already been done.

#define DFLAGS_USES_EITHER_DMA      0x10200

//
// Types of interrupts expected.
//
#define IDE_SEEK_INTERRUPT	(1 << 0)
#define IDE_PIO_INTERRUPT	(1 << 1)
#define IDE_DMA_INTERRUPT	(1 << 2)
#define ANY_DMA_INTERRUPT   (IDE_DMA_INTERRUPT)

//
// Used to disable 'advanced' features.
//
#define MAX_ERRORS                     4


//
// Types of DMA operation.
//
#define READ_OPERATION	0
#define WRITE_OPERATION	1

//
// DMA transfer control.
//
#define READ_TRANSFER		    0x08
#define WRITE_TRANSFER	        0x00
#define STOP_TRANSFER			0x00
#define START_TRANSFER          0x01

//
// ATAPI command definitions
//
#define ATAPI_MODE_SENSE   0x5A
#define ATAPI_MODE_SELECT  0x55
#define ATAPI_FORMAT_UNIT  0x24

//
// IDE controller speed definition.
//

typedef enum {

	Udma33,
	Udma66,
    Udma100

} CONTROLLER_SPEED, *PCONTROLLER_SPEED;


//
// IDE command definitions
//
#define IDE_COMMAND_ATAPI_RESET             0x08
#define IDE_COMMAND_RECALIBRATE             0x10
#define IDE_COMMAND_READ                    0x20
#define IDE_COMMAND_WRITE                   0x30
#define IDE_COMMAND_VERIFY                  0x40
#define IDE_COMMAND_SEEK                    0x70
#define IDE_COMMAND_SET_DRIVE_PARAMETERS    0x91
#define IDE_COMMAND_ATAPI_PACKET            0xA0
#define IDE_COMMAND_ATAPI_IDENTIFY          0xA1
// Begin Vasu - SMART Command
#define IDE_COMMAND_EXECUTE_SMART           0xB0
// End Vasu
#define IDE_COMMAND_READ_MULTIPLE           0xC4
#define IDE_COMMAND_WRITE_MULTIPLE          0xC5
#define IDE_COMMAND_SET_MULTIPLE            0xC6
#define IDE_COMMAND_READ_DMA                0xC8
#define IDE_COMMAND_WRITE_DMA               0xCA
#define IDE_COMMAND_GET_MEDIA_STATUS        0xDA
#define IDE_COMMAND_ENABLE_MEDIA_STATUS     0xEF
#define IDE_COMMAND_IDENTIFY                0xEC
#define IDE_COMMAND_MEDIA_EJECT             0xED
#define IDE_COMMAND_SET_FEATURES	        0xEF
#define IDE_COMMAND_FLUSH_CACHE             0xE7

#ifdef HYPERDISK_WIN2K
#define IDE_COMMAND_STANDBY_IMMEDIATE       0xE0
#endif // HYPERDISK_WIN2K

//
// Set Features register definitions.
//
#define FEATURE_ENABLE_WRITE_CACHE			0x02
#define FEATURE_SET_TRANSFER_MODE			0x03
#define FEATURE_KEEP_CONFIGURATION_ON_RESET	0x66
#define FEATURE_ENABLE_READ_CACHE			0xAA
#define FEATURE_DISABLE_WRITE_CACHE			0x82
#define FEATURE_DISABLE_READ_CACHE			0x55

// Power Management Stuff
#ifdef HYPERDISK_WIN2K
#define FEATURE_ENABLE_POWER_UP_IN_STANDBY      0x06
#define FEATURE_SPIN_AFTER_POWER_UP             0x07
#define POWER_MANAGEMENT_SUPPORTED              0x08    // Bit 3 of 82nd Word of Identify Data
#define POWER_UP_IN_STANDBY_FEATURE_SUPPORTED   0x20    // Bit 5 of 83rd Word of Identify Dataa
#define SET_FEATURES_REQUIRED_FOR_SPIN_UP       0x40    // Bit 6 of 83rd Word of Identify Dataa
#endif // HYPERDISK_WIN2K

//
// Set Features/Set Transfer Mode subcommand definitions.
//
#define STM_PIO(mode)				((UCHAR) ((1 << 3) | (mode)))
#define STM_MULTIWORD_DMA(mode)		((UCHAR) ((1 << 5) | (mode)))
#define STM_UDMA(mode)				((UCHAR) ((1 << 6) | (mode)))

//
// IDE status definitions
//
#define IDE_STATUS_ERROR             0x01
#define IDE_STATUS_INDEX             0x02
#define IDE_STATUS_CORRECTED_ERROR   0x04
#define IDE_STATUS_DRQ               0x08
#define IDE_STATUS_DSC               0x10
#define IDE_STATUS_DRDY              0x40
#define IDE_STATUS_IDLE              0x50
#define IDE_STATUS_BUSY              0x80

//
// IDE drive select/head definitions
//
#define IDE_DRIVE_SELECT_1           0xA0
#define IDE_DRIVE_SELECT_2           0x10

//
// IDE drive control definitions
//
#define IDE_DC_DISABLE_INTERRUPTS    0x02
#define IDE_DC_RESET_CONTROLLER      0x04
#define IDE_DC_REENABLE_CONTROLLER   0x00

//
// IDE error definitions
//
#define IDE_ERROR_BAD_BLOCK          0x80
#define IDE_ERROR_DATA_ERROR         0x40
#define IDE_ERROR_MEDIA_CHANGE       0x20
#define IDE_ERROR_ID_NOT_FOUND       0x10
#define IDE_ERROR_MEDIA_CHANGE_REQ   0x08
#define IDE_ERROR_COMMAND_ABORTED    0x04
#define IDE_ERROR_END_OF_MEDIA       0x02
#define IDE_ERROR_ILLEGAL_LENGTH     0x01

//
// IDENTIFY data.
//

#pragma pack (1)
typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumberOfCylinders;               // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumberOfHeads;                   // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT SectorsPerTrack;                 // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    UCHAR  SerialNumber[20];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    UCHAR  FirmwareRevision[8];             // 2E  23-26
    UCHAR  ModelNumber[40];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:3;        // 6A  53
    USHORT Reserved3:13;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDmaSupport : 8;        //     62
    USHORT SingleWordDmaActive : 8;
    USHORT MultiWordDmaSupport : 8;         //     63
    USHORT MultiWordDmaActive : 8;
    USHORT AdvancedPioModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMwXferCycleTime;          //     65
    USHORT RecommendedMwXferCycleTime;      //     66
    USHORT MinimumPioCycleTime;             //     67
    USHORT MinimumPioCycleTimeIordy;        //     68
    USHORT Reserved5[11];                   //     69-79
    USHORT MajorRevision;                   //     80
    USHORT MinorRevision;                   //     81

    USHORT CmdSupported1;                   //     82
    USHORT CmdSupported2;                   //     83
    USHORT FtrSupported;                    //     84

    USHORT CmdEnabled1;                     //     85
    USHORT CmdEnabled2;                     //     86
    USHORT FtrEnabled;                      //     87


    USHORT UltraDmaSupport : 8;             //     88
    USHORT UltraDmaActive  : 8;             //
    USHORT Reserved7[37];                   //     89-125
    USHORT LastLun:3;                       //     126
    USHORT Reserved8:13;
    USHORT MediaStatusNotification:2;       //     127
    USHORT Reserved9:6;
    USHORT DeviceWriteProtect:1;
    USHORT Reserved10:7;
    USHORT Reserved11[128];                  //     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;


//
// Identify data without the Reserved4.
//

typedef struct _IDENTIFY_DATA2 {
    USHORT GeneralConfiguration;            // 00
    USHORT NumberOfCylinders;               // 02
    USHORT Reserved1;                       // 04
    USHORT NumberOfHeads;                   // 06
    USHORT UnformattedBytesPerTrack;        // 08
    USHORT UnformattedBytesPerSector;       // 0A
    USHORT SectorsPerTrack;                 // 0C
    USHORT VendorUnique1[3];                // 0E
    USHORT SerialNumber[10];                // 14
    USHORT BufferType;                      // 28
    USHORT BufferSectorSize;                // 2A
    USHORT NumberOfEccBytes;                // 2C
    USHORT FirmwareRevision[4];             // 2E
    USHORT ModelNumber[20];                 // 36
    UCHAR  MaximumBlockTransfer;            // 5E
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60
    USHORT Capabilities;                    // 62
    USHORT Reserved2;                       // 64
    UCHAR  VendorUnique3;                   // 66
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:1;        // 6A
    USHORT Reserved3:15;
    USHORT NumberOfCurrentCylinders;        // 6C
    USHORT NumberOfCurrentHeads;            // 6E
    USHORT CurrentSectorsPerTrack;          // 70
    ULONG  CurrentSectorCapacity;           // 72
} IDENTIFY_DATA2, *PIDENTIFY_DATA2;

#pragma pack()

#define IDENTIFY_DATA_SIZE sizeof(IDENTIFY_DATA)

//
// Value of bit 1 of TranslationFieldsValid in the IDENTIFY_DATA structure.
//

#define IDENTIFY_FAST_TRANSFERS_SUPPORTED	2	// PIO mode 3+ or DMA modes supported.

//
// IDENTIFY capability bit definitions.
//

#define IDENTIFY_CAPABILITIES_DMA_SUPPORTED 0x0100
#define IDENTIFY_CAPABILITIES_LBA_SUPPORTED 0x0200

//
// I/O Timing table values for Intel PIIX4.
//
// Legend:
//	ISP: IORDY Sample Point
//	RCT: Recovery Time
//	IDETIM: Master IDE Timing
//	SIDETIM: Slave IDE Timing
//

#define IO_TIMING_TABLE_VALUES  {\
\
	/* Cycle								Cycle					*/ \
	/* Time		PIO MODE	DMA MODE		Time	ISP		RCT		*/ \
\
	/* 900ns	PIO_MODE0,	N/A       */	{900,	0,		0},\
	/* ********************************/	{900,	0,		0},\
	/* 240ns	PIO_MODE2,	DMA_MODE0 */	{240,	1,		0},\
	/* 180ns	PIO_MODE3,	DMA_MODE1 */	{180,	2,		1},\
	/* 120ns	PIO_MODE4,	DMA_MODE2 */	{120,	2,		3}\
}

//
// UDMA Timing values for Intel PIIX4.
// To be programmed in the UDMA Timing Register.
//
#define UDMA_MODE0_TIMING	0
#define UDMA_MODE1_TIMING	1
#define UDMA_MODE2_TIMING	2
#define UDMA_MODE3_TIMING	3
#define UDMA_MODE4_TIMING	4

//
// DMA modes to be used as index into the IO_TIMING_TABLE.
//
#define DMA_MODE0	2
#define DMA_MODE1	3
#define DMA_MODE2	4
#define DMA_MODE3	4       // Not sure what to fill with
#define DMA_MODE4	4       // Not sure what to fill with

//
// Advanced PIO modes to be used as index into the IO_TIMING_TABLE.
//
#define PIO_MODE0	0
#define PIO_MODE2	2
#define PIO_MODE3	3
#define PIO_MODE4	4

//
// PIO_MODE0 timing.
//
#define PIO_MODE0_TIMING	900

//
// IDENTIFY Advanced PIO Modes.
//
#define IDENTIFY_PIO_MODE3		(1 << 0)
#define IDENTIFY_PIO_MODE4		(1 << 1)

//
// IDENTIFY Multi-word DMA modes.
//
#define IDENTIFY_DMA_MODE0		(1 << 0)
#define IDENTIFY_DMA_MODE1		(1 << 1)
#define IDENTIFY_DMA_MODE2		(1 << 2)
#define IDENTIFY_DMA_MODE3		(1 << 3)
#define IDENTIFY_DMA_MODE4		(1 << 4)


//
// IDENTIFY UDMA modes.
//
#define IDENTIFY_UDMA_MODE0		(1 << 0)
#define IDENTIFY_UDMA_MODE1		(1 << 1)
#define IDENTIFY_UDMA_MODE2		(1 << 2)
#define IDENTIFY_UDMA_MODE3		(1 << 3)
#define IDENTIFY_UDMA_MODE4		(1 << 4)


//
// IDENTIFY DMA timing cycle modes.
//
#define IDENTIFY_DMA_MODE0_TIMING 0x00
#define IDENTIFY_DMA_MODE1_TIMING 0x01
#define IDENTIFY_DMA_MODE2_TIMING 0x02
#define IDENTIFY_DMA_MODE3_TIMING 0x03
#define IDENTIFY_DMA_MODE4_TIMING 0x04

//
// I/O Timing table entry for PIIX4. Works for PIO and DMA modes.
//
typedef struct _IO_TIMING_TABLE_ENTRY {

	USHORT CycleTime;
	UCHAR Isp;	// IORDY Sample Point.
	UCHAR Rct;	// Recovery Time.

} IO_TIMING_TABLE_ENTRY, *PIO_TIMING_TABLE_ENTRY;


//
// PIIX4 IDETIM - IDE Timing Register.
//
// PCI Configuration Space offset: 40-41h (Primary Channel), 42-42h (Secondar Channely)
// Default value: 0000h
// Attribute: R/W only
//
typedef union _IDE_PCI_TIMING_REGISTER {

	struct {

		USHORT FastTimingEnableDrive0:1;		// 0 = disabled (compatible timing-slowest).
												// 1 = enabled.
	
		USHORT IordySamplePointEnableDrive0:1;	// 0 = IORDY sampling disabled.
												// 1 = IORDY sampling enabled.
	
		USHORT PrefetchAndPostingEnableDrive0:1;	// 0 = disabled.
													// 1 = enabled.
	
		USHORT DmaOnlyTimingEnableDrive0:1;		// 0 = both DMA and PIO use fast timing mode.
												// 1 = DMA uses fast timing, PIO uses
												//		compatible timing.
	
		USHORT FastTimingEnableDrive1:1;		// 0 = disabled (compatible timing-slowest).
												// 1 = enabled.
	
		USHORT IordySamplePointEnableDrive1:1;	// 0 = IORDY sampling disabled.
												// 1 = IORDY sampling enabled.
	
		USHORT PrefetchAndPostingEnableDrive1:1;// 0 = disabled.
												// 1 = enabled.
	
		USHORT DmaOnlyTimingEnableDrive1:1;		// 0 = both DMA and PIO use fast timing mode.
												// 1 = DMA uses fast timing, PIO uses
												//		compatible timing.
	
		USHORT RecoveryTime:2;					// RTC - Selects the minimum number of PCI clocks
												// between the last IORDY# sample point and the
												// DIOx# strobe of the next cycle.
												//
												// Bits[1:0]	Number of Clocks
												// -----------------------------
												// 		00			4
												// 		01			3
												// 		10			2
												// 		11			1
	
		USHORT Reserved:2;
	
		USHORT IordySamplePoint:2;				// ISP - Selects the number of PCI clocks
												// between the last DIOx# assertion and the first
												// IORDY sample point.
												//
												// Bits[1:0]	Number of Clocks
												// -----------------------------
												// 		00			5
												// 		01			4
												// 		10			3
												// 		11			2
	
		USHORT SlaveIdeTimingRegisterEnable:1;	// (SITRE)
												// 0 = disable SIDETIM.
												// 1 = enable SIDETIM.
	
		USHORT IdeDecodeEnable:1;				// (IDE)
												// 0 = disable (IDE accesses are decoded on ISA).
												// 1 = enable (IDE accesses are decoded on PCI).
	};

	USHORT AsUshort;

} IDE_PCI_TIMING_REGISTER, *PIDE_PCI_TIMING_REGISTER;


//
// PIIX4 SIDETIM - Slave IDE Timing Register.
//
// PCI Configuration Space offset: 44h
// Default value: 00h
// Attribute: R/W only
//
typedef union _IDE_PCI_SLAVE_TIMING_REGISTER {

	struct {

		UCHAR PrimaryDrive1RecoveryTime:2;		// PRTC1 - Selects the minimum number of PCI clocks
												// between the last PIORDY# sample point and the
												// PDIOx# strobe of the next cycle of the slave
												// drive on the primary channel.
												//
												// Bits[1:0]	Number of Clocks
												// -----------------------------
												// 		00			4
												// 		01			3
												// 		10			2
												// 		11			1
	
		UCHAR PrimaryDrive1IordySamplePoint:2;	// PISP1 - Selects the number of PCI clocks
												// between the PDIOx# assertion and the first
												// PIORDY sample point of the slave drive on
												// the primary channel.
												//
												// Bits[1:0]	Number of Clocks
												// -----------------------------
												// 		00			5
												// 		01			4
												// 		10			3
												// 		11			2
	
		UCHAR SecondaryDrive1RecoveryTime:2;	// SRTC1 - Selects the minimum number of PCI clocks
												// between the last SIORDY# sample point and the
												// SDIOx# strobe of the next cycle of the slave
												// drive on the secondary channel.
												//
												// Bits[1:0]	Number of Clocks
												// -----------------------------
												// 		00			4
												// 		01			3
												// 		10			2
												// 		11			1
	
		UCHAR SecondaryDrive1IordySamplePoint:2;// SISP1 - Selects the number of PCI clocks
												// between the SDIOx# assertion and the first
												// SIORDY sample point of the slave drive on
												// the secondary channel.
												//
												// Bits[1:0]	Number of Clocks
												// -----------------------------
												// 		00			5
												// 		01			4
												// 		10			3
												// 		11			2
	};

	UCHAR AsUchar;

} IDE_PCI_SLAVE_TIMING_REGISTER, *PIDE_PCI_SLAVE_TIMING_REGISTER;


//
// PIIX4 PCI Configuration Space - Command Register.
//

typedef union _IDE_PCI_COMMAND_REGISTER {

	struct {

	    USHORT IoSpaceEnable:1; 			// (r/w)
		USHORT Ignore:1;
		USHORT BusMasterFunctionEnable:1;	// (r/w) 0 = disable, 1 = enable.
		USHORT Ignore2:13;
	};

	USHORT AsUshort;

} IDE_PCI_COMMAND_REGISTER, *PIDE_PCI_COMMAND_REGISTER;

	
//
// PIIX4 UDMACTL - IDE Ultra DMA/33 Control Register.
//
// PCI Configuration Space offset: 48h
// Default value: 00h
// Attribute: R/W
//

typedef union _IDE_PCI_UDMA_CONTROL_REGISTER {

	struct {

		UCHAR PrimaryDrive0UdmaEnable:1;		// 0 = disable.
												// 1 = enable.
	
		UCHAR PrimaryDrive1UdmaEnable:1;		// 0 = disable.
												// 1 = enable.
	
		UCHAR SecondaryDrive0UdmaEnable:1;		// 0 = disable.
												// 1 = enable.
	
		UCHAR SecondaryDrive1UdmaEnable:1;		// 0 = disable.
												// 1 = enable.
	
		UCHAR Reserved:4;
	};

	UCHAR AsUchar;

} IDE_PCI_UDMA_CONTROL_REGISTER, *PIDE_PCI_UDMA_CONTROL_REGISTER;

//
// PIIX4 UDMACTL - IDE Ultra DMA/33 Timing Register.
//
// PCI Configuration Space offset: 4A-4Bh
// Default value: 0000h
// Attribute: R/W only
//

typedef union _IDE_PCI_UDMA_TIMING_REGISTER {

	struct {

		USHORT PrimaryDrive0CycleTime:2;		// PCT0 - Selects the minimum data write strobe
												// cycle time (CT) and minimum ready to pause (RP)
												// time (in PCI clocks).
												//
												// Bits[1:0]	Time
												// ------------------------------------
												//		00		CT=4, RP=6
												//		01		CT=3, RP=5
												//		10		CT=2, RP=4
												//		11		Reserved
	
		USHORT Reserved:2;
	
		USHORT PrimaryDrive1CycleTime:2;		// PCT1 - Selects the minimum data write strobe
												// cycle time (CT) and minimum ready to pause (RP)
												// time (in PCI clocks).
												//
												// Bits[1:0]	Time
												// ------------------------------------
												//		00		CT=4, RP=6
												//		01		CT=3, RP=5
												//		10		CT=2, RP=4
												//		11		Reserved
	
		USHORT Reserved2:2;
	
	
		USHORT SecondaryDrive0CycleTime:2;		// SCT0 - Selects the minimum data write strobe
												// cycle time (CT) and minimum ready to pause (RP)
												// time (in PCI clocks).
												//
												// Bits[1:0]	Time
												// ------------------------------------
												//		00		CT=4, RP=6
												//		01		CT=3, RP=5
												//		10		CT=2, RP=4
												//		11		Reserved
	
		USHORT Reserved3:2;
	
		USHORT SecondaryDrive1CycleTime:2;		// SCT1 - Selects the minimum data write strobe
												// cycle time (CT) and minimum ready to pause (RP)
												// time (in PCI clocks).
												//
												// Bits[1:0]	Time
												// ------------------------------------
												//		00		CT=4, RP=6
												//		01		CT=3, RP=5
												//		10		CT=2, RP=4
												//		11		Reserved
	
		USHORT Reserved4:2;
	};

	USHORT AsUshort;

} IDE_PCI_UDMA_TIMING_REGISTER, *PIDE_PCI_UDMA_TIMING_REGISTER;





//
// CAMINO chipset UDMACTL - IDE Ultra DMA/33/66 IDE_CONFIG
//
// PCI Configuration Space offset: 54-55
// Default value: 0000h
// Attribute: R/W only
//
typedef union _IDE_PCI_UDMA_CONFIG_REGISTER {

	struct {
        USHORT BaseClkPriMaster:1;      // 0 1=66MHz 0=33MHz
        USHORT BaseClkPriSlave:1;       // 1 1=66MHz 0=33MHz
        USHORT BaseClkSecMaster:1;      // 2 1=66MHz 0=33MHz
        USHORT BaseClkSecSlave:1;       // 3 1=66MHz 0=33MHz

        USHORT CableRepPriMaster:1;     // 4 1=80 conductors 0=40 conductors
        USHORT CableRepPriSlave:1;      // 5 1=80 conductors 0=40 conductors
        USHORT CableRepSecMaster:1;     // 6 1=80 conductors 0=40 conductors
        USHORT CableRepSecSlave:1;      // 7 1=80 conductors 0=40 conductors
        
		USHORT Reserved2:2;             // 9:8 Reserved
	
		USHORT WRPingPongEnabled:1;     // 10 th Bit 1 = Enables the write buffer to be used in a split(ping/pong) manner
                                        // 0 = Disabled. The buffer will behave similar to PIIX 4

		USHORT Reserved1:5;             // Reserved 15:11
	};

	USHORT AsUshort;

} IDE_PCI_UDMA_CONFIG_REGISTER, *PIDE_PCI_UDMA_CONFIG_REGISTER;



//
// PIIX4 PCI Configuration Registers.
//
typedef struct _IDE_PCI_REGISTERS {

    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
	IDE_PCI_COMMAND_REGISTER Command;	// (r/w) device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    ULONG   BaseAddress1;
    ULONG   BaseAddress2;
    ULONG   BaseAddress3;
    ULONG   BaseAddress4;
	ULONG	BaseBmAddress;	// PIIX4-specific. Offset 20-23h.
    ULONG   BaseAddress6;
    ULONG   CIS;
    USHORT  SubVendorID;
    USHORT  SubSystemID;
    ULONG   ROMBaseAddress;
    ULONG   Reserved2[2];

    UCHAR   InterruptLine;      //
    UCHAR   InterruptPin;       // (ro)
    UCHAR   MinimumGrant;       // (ro)
    UCHAR   MaximumLatency;     // (ro)

	//
	// Offset 40h - Vendor-specific registers.
	//

	IDE_PCI_TIMING_REGISTER	PrimaryIdeTiming;		// 40-41h
	IDE_PCI_TIMING_REGISTER	SecondaryIdeTiming;		// 42-43h
	IDE_PCI_SLAVE_TIMING_REGISTER SlaveIdeTiming;	// 44h
	UCHAR Reserved3[3];
	IDE_PCI_UDMA_CONTROL_REGISTER UdmaControl;		// 48h
	UCHAR Reserved4;
	IDE_PCI_UDMA_TIMING_REGISTER UdmaTiming;		// 4A-4Bh

    ULONG   unknown1;                               // 4c-4f
    ULONG   unknown2;                               // 50-53
    IDE_PCI_UDMA_CONFIG_REGISTER UDMAConfig;        // 54-55    
    UCHAR Unknown[170]; // Was 180

} IDE_PCI_REGISTERS, *PIDE_PCI_REGISTERS;

//
// PIIX4 BMICX - Bus Master IDE Command Register.
//
// IDE Controller I/O Space offset: Primary Channel Base + 00h, Secondary Channel Base + 08h
// Default value: 00h
// Attribute: R/W
//
typedef union _BM_COMMAND_REGISTER {

	struct {

		UCHAR StartStopBm:1;					// SSMB
												// 0 = stop
												// 1 = start
												// Intended to be set to 0 after data transfer is
												// complete, as indicated by either bit 0 or bit 2
												// being set in the IDE Channel's Bus Master IDE
												// Status Register.
	
		UCHAR Reserved:2;
	
		UCHAR BmReadWriteControl:1;				// RWCON - Indicates the direction of a DMA
												//			transfer.
												// 0 = reads
												// 1 = writes
	
		UCHAR Reserved2:4;
	};

	UCHAR AsUchar;

} BM_COMMAND_REGISTER, *PBM_COMMAND_REGISTER;

//
// PIIX4 BMISX - Bus Master IDE Status Register.
//
// IDE Controller I/O Space offset: Primary Channel Base + 02h, Secondary Channel Base + 0Ah
// Default value: 00h
// Attribute: R/W Clear
//
typedef union _BM_STATUS_REGISTER {

	struct {

		UCHAR BmActive:1;			// BMIDEA - Read-Only
									// PIIX4 sets this bit to 1 when a BM operation is started
									// (when SSBM in BMICx is set to 1). PIIX4 sets this bit to 0
									// when the last transfer of a region is performed or when SSBM
									// is set to 0.
	
		UCHAR DmaError:1;			// (Read/Write-Clear)
									// Indicates a target or master abort. Software sets this bit
									// to 0 by writing a 1 to it.
	
		UCHAR InterruptStatus:1;	// IDEINTS - Read/Write-Clear
									// When set to 1, it indicates that an IDE device has asserted
									// its interrupt line (i.e., all data have been transferred).
									// Software clears this bit by writing a 1 to it.
	
		UCHAR Reserved:2;
	
		UCHAR Drive0DmaCapable:1;	// DMA0CAP - R/W - Software controlled.
									// 1 = capable
	
		UCHAR Drive1DmaCapable:1;	// DMA1CAP - R/W - Software controlled.
									// 1 = capable
	
		UCHAR Reserved2:1;
	};

	UCHAR AsUchar;

} BM_STATUS_REGISTER, *PBM_STATUS_REGISTER;

//
// PIIX4 BMIDTPX - Bus Master IDE Descriptor Table Pointer Register.
//
// IDE Controller I/O Space offset: Primary Channel Base + 04h, Secondary Channel Base + 0Ch
// Default value: 00000000h
// Attribute: R/W
//
typedef union _BM_SGL_REGISTER {

	struct {

		ULONG Reserved:2;

		ULONG SglAddress:30;		// Address of the Scatter/Gather List. The list must
									// not cross a 4-KB boundary in memory.
	};

	ULONG AsUlong;

} BM_SGL_REGISTER, *PBM_SGL_REGISTER;

//
// Bus Master Registers.
//
typedef struct _BM_REGISTERS {

	BM_COMMAND_REGISTER Command;

	UCHAR Reserved;

	BM_STATUS_REGISTER Status;

	UCHAR Reserved2;

	ULONG SglAddress;

} BM_REGISTERS, *PBM_REGISTERS;

typedef struct _CMD__CONTROLLER_INFORMATION {

    PCHAR   VendorId;
    ULONG   VendorIdLength;
    PCHAR   DeviceId;
    ULONG   ulDeviceId;
    ULONG   DeviceIdLength;

} CMD_CONTROLLER_INFORMATION, *PCMD_CONTROLLER_INFORMATION;

CMD_CONTROLLER_INFORMATION const CMDAdapters[] = {
    {"1095", 4, "0648", 0x648, 4},
    {"1095", 4, "0649", 0x649, 4}
};

#define NUM_NATIVE_MODE_ADAPTERS (sizeof(CMDAdapters) / sizeof(CMD_CONTROLLER_INFORMATION))

//
// Beautification macros
//
#define USES_DMA(TargetId) \
	((DeviceExtension->DeviceFlags[TargetId] & DFLAGS_USES_EITHER_DMA) != 0)

#define SELECT_DEVICE(BaseIoAddress, TargetId) \
	ScsiPortWritePortUchar(\
		&(BaseIoAddress)->DriveSelect, \
		(UCHAR)((((TargetId) & 1) << 4) | IDE_CHS_MODE)\
		);\
    ScsiPortStallExecution(60)

#define SELECT_CHS_DEVICE(BaseIoAddress, TargetId, HeadNumber) \
	ScsiPortWritePortUchar(\
		&(BaseIoAddress)->DriveSelect, \
		(UCHAR)((((TargetId) & 1) << 4) | IDE_CHS_MODE | (HeadNumber & 15))\
		);\
    ScsiPortStallExecution(60)

#define SELECT_LBA_DEVICE(BaseIoAddress, TargetId, Lba) \
	ScsiPortWritePortUchar(\
		&(BaseIoAddress)->DriveSelect, \
		(UCHAR)((((TargetId) & 1) << 4) | IDE_LBA_MODE | (Lba & 0x0f000000) >> 24)\
		);\
    ScsiPortStallExecution(60)

#define GET_STATUS(BaseIoAddress1, Status) \
    Status = ScsiPortReadPortUchar(&BaseIoAddress1->Command);

#define GET_BASE_STATUS(BaseIoAddress, Status) \
    Status = ScsiPortReadPortUchar(&BaseIoAddress->Command);

#define WRITE_COMMAND(BaseIoAddress, Command) \
    ScsiPortWritePortUchar(&BaseIoAddress->Command, Command);



#define READ_BUFFER(BaseIoAddress, Buffer, Count) \
    ScsiPortReadPortBufferUshort(&BaseIoAddress->Data, \
                                 Buffer, \
                                 Count);

#define WRITE_BUFFER(BaseIoAddress, Buffer, Count) \
    ScsiPortWritePortBufferUshort(&BaseIoAddress->Data, \
                                  Buffer, \
                                  Count);

#define READ_BUFFER2(BaseIoAddress, Buffer, Count) \
    ScsiPortReadPortBufferUlong(&BaseIoAddress->Data, \
                             Buffer, \
                             Count);

#define WRITE_BUFFER2(BaseIoAddress, Buffer, Count) \
    ScsiPortWritePortBufferUlong(&BaseIoAddress->Data, \
                              Buffer, \
                              Count);

//
// WAIT_IN_BUSY waits for up to 1 s.
//

#define WAIT_ON_BUSY(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i = 0; i < 200000; i++) { \
        GET_STATUS(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(5); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WAIT_ON_ALTERNATE_STATUS_BUSY(BaseIoAddress2, Status) \
{ \
    ULONG i; \
    for (i = 0; i < 200000; i++) { \
		Status = ScsiPortReadPortUchar(&(baseIoAddress2->AlternateStatus)); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(5); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WAIT_ON_BASE_BUSY(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i = 0; i < 200000; i++) { \
        GET_BASE_STATUS(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(5); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WAIT_FOR_DRQ(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i = 0; i < 200000; i++) { \
        GET_STATUS(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(5); \
        } \
    } \
}

#define WAIT_FOR_ALTERNATE_DRQ(baseIoAddress2, Status) \
{ \
    ULONG i; \
    for (i = 0; i < 200000; i++) { \
		Status = ScsiPortReadPortUchar(&(baseIoAddress2->AlternateStatus)); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(5); \
        } \
    } \
}


#define WAIT_SHORT_FOR_DRQ(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i = 0; i < 40; i++) { \
        GET_STATUS(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(5); \
        } \
    } \
}

#define IDE_HARD_RESET(BaseIoAddress1, BaseIoAddress2, ucTargetId, result) \
{\
    UCHAR statusByte;\
    ULONG i;\
    ScsiPortWritePortUchar(&BaseIoAddress2->AlternateStatus,IDE_DC_RESET_CONTROLLER );\
    ScsiPortStallExecution(1000);\
    ScsiPortStallExecution(1000);\
    ScsiPortStallExecution(1000);\
    ScsiPortWritePortUchar(&BaseIoAddress2->AlternateStatus,IDE_DC_REENABLE_CONTROLLER);\
    ScsiPortStallExecution(1000);\
    ScsiPortStallExecution(1000);\
    ScsiPortStallExecution(1000);\
    ScsiPortStallExecution(1000);\
    ScsiPortStallExecution(1000);\
    SELECT_DEVICE(BaseIoAddress1, ucTargetId);\
    for (i = 0; i < 1000; i++) {\
        statusByte = ScsiPortReadPortUchar(&BaseIoAddress1->Command);\
        if (statusByte != IDE_STATUS_IDLE && statusByte != 0x0) {\
            ScsiPortStallExecution(1000);\
        } else {\
            break;\
        }\
    }\
    if (i == 1000) {\
        result = FALSE;\
    }\
    result = TRUE;\
}

#define IS_RDP(OperationCode)\
    ((OperationCode == SCSIOP_ERASE)||\
    (OperationCode == SCSIOP_LOAD_UNLOAD)||\
    (OperationCode == SCSIOP_LOCATE)||\
    (OperationCode == SCSIOP_REWIND) ||\
    (OperationCode == SCSIOP_SPACE)||\
    (OperationCode == SCSIOP_SEEK)||\
    (OperationCode == SCSIOP_WRITE_FILEMARKS))

#define SET_BM_COMMAND_REGISTER(Base, Field, Value) \
	{\
		BM_COMMAND_REGISTER buffer;\
\
		buffer.AsUchar = ScsiPortReadPortUchar(&(Base->Command.AsUchar));\
\
		buffer.Field = Value;\
\
		ScsiPortWritePortUchar(&(Base->Command.AsUchar), buffer.AsUchar);\
	}

#define SET_BM_STATUS_REGISTER(Base, Field, Value) \
	{\
		BM_STATUS_REGISTER buffer;\
\
		buffer.AsUchar = ScsiPortReadPortUchar(&(Base->Status.AsUchar));\
\
		buffer.Field = Value;\
\
		ScsiPortWritePortUchar(&(Base->Status.AsUchar), buffer.AsUchar);\
	}

#define CLEAR_BM_INT(Base, StatusByte) \
	StatusByte = ScsiPortReadPortUchar(&(Base->Status.AsUchar));\
	StatusByte |= 0x06; \
	ScsiPortWritePortUchar(&(Base->Status.AsUchar), StatusByte)

#define DRIVE_PRESENT(TargetId)                                         \
    ( DeviceExtension->DeviceFlags[TargetId] & DFLAGS_DEVICE_PRESENT )

#define IS_IDE_DRIVE(TargetId) \
	((DeviceExtension->DeviceFlags[TargetId] & DFLAGS_DEVICE_PRESENT) && \
	!(DeviceExtension->DeviceFlags[TargetId] & DFLAGS_ATAPI_DEVICE))

#define IS_ATAPI_DRIVE(TargetId) \
	((DeviceExtension->DeviceFlags[TargetId] & DFLAGS_DEVICE_PRESENT) && \
	(DeviceExtension->DeviceFlags[TargetId] & DFLAGS_ATAPI_DEVICE))

//
// Generic I/O transfer descriptor for PIO and DMA operations to/from IDE and ATAPI
// devices.
//

typedef struct _TRANSFER_DESCRIPTOR {

	//
	// Common section.
	//
	ULONG StartSector;
	ULONG Sectors;

	//
	// PIO section.
	//
    PUSHORT DataBuffer;
	ULONG WordsLeft;

    PUSHORT pusCurBufPtr;
    ULONG   ulCurBufLen;
    ULONG   ulCurSglInd;

	//
	// DMA section.
	//
	ULONG SglPhysicalAddress;

} TRANSFER_DESCRIPTOR, *PTRANSFER_DESCRIPTOR;

//
// SRB Extension.
//
typedef struct _SRB_EXTENSION {

    UCHAR SrbStatus;

	UCHAR NumberOfPdds;

	//
	// Scatter/Gather list. In PIO mode, this list contains
	// virtual addresses, while in DMA mode it contains
	// physical addresses.
	// 
	SGL_ENTRY aSglEntry[MAX_SGL_ENTRIES_PER_SRB];

    ULONG ulSglInsertionIndex;

	//
	// List of descriptors of DMA transfers. Each entry describes
	// a portion of the SGL. The SGL is logically partitioned
	// to support SCSI Port request sizes that exceed the physical
	// limit of individual drives. For example, each partition in an SGL
	// for an IDE disk defines a transfer not to exceed 128KB (256 sectors).
	// Single IDE drives, when a stripe-set is present, may be targeted
	// with large transfers by the SCSI Port, because the miniport
	// set the max transfer length to that (at least double) for the stripe-set.
	// Large transfers are split in smaller portions whose lengths do not
	// exceed the maximum accepted by the specific device.
	// 
	PHYSICAL_REQUEST_BLOCK Prb[MAX_PHYSICAL_REQUEST_BLOCKS];

    ULONG ulPrbInsertionIndex;

	PHYSICAL_DRIVE_DATA PhysicalDriveData[MAX_PDDS_PER_SRB];

    UCHAR RebuildTargetId;

    UCHAR RebuildSourceId;

    BOOLEAN IsWritePending;

    BOOLEAN IsNewOnly;	

    USHORT usNumError;	
						
    UCHAR ucOpCode;

    UCHAR ucOriginalId;

    UCHAR SrbInd;

#ifdef DBG
	ULONG SrbId;
#endif

} SRB_EXTENSION, *PSRB_EXTENSION;

#define MAX_DRIVE_TYPES         2       // We support Logical, Physical
#define MAX_DEVICE_TYPES        2       // We support NO_DRIVE and ATA

typedef struct PHW_DEVICE_EXTENSION;
typedef SRBSTATUS (*SEND_COMMAND)(IN PHW_DEVICE_EXTENSION DeviceExtension, IN PSCSI_REQUEST_BLOCK Srb );
typedef SRBSTATUS (*SPLIT_SRB_ENQUEQUE_SRB)(IN PHW_DEVICE_EXTENSION DeviceExtension,IN PSCSI_REQUEST_BLOCK Srb);
typedef VOID (*COMPLETION_ROUTINES)(IN PHW_DEVICE_EXTENSION DeviceExtension,IN PPHYSICAL_DRIVE_DATA Prb);
typedef SRBSTATUS   (*POST_ROUTINES)(IN PHW_DEVICE_EXTENSION DeviceExtension,IN PPHYSICAL_COMMAND pPhysicalCommand);

#define NO_DRIVE                0
#define IDE_DRIVE               1

#define LOGICAL_DRIVE_TYPE      1
#define PHYSICAL_DRIVE_TYPE     0

#define SET_IRCD_PENDING        1
#define GET_IRCD_PENDING        2
#define LOCK_IRCD_PENDING       4

#define IRCD_MAX_LOCK_TIME      (10000000 * 60)

#ifdef HYPERDISK_WIN2K

#define PCI_DATA_TO_BE_UPDATED  5

typedef struct _PCI_BIT_MASK
{
    ULONG ulOffset;
    ULONG ulLength;
    ULONG ulAndMask;
} PCI_BIT_MASK;

PCI_BIT_MASK aPCIDataToBeStored[PCI_DATA_TO_BE_UPDATED] = 
{ // right now the WriteToPCISpace, ReadFromPCI functions are capable of handling only dwords at a time
    {0x50, 4, 0x0f3300bb},
    {0x54, 4, 0x41000f00}, 
    {0x58, 4, 0x00ffff00}, 
    {0x70, 4, 0x001800ff}, 
    {0x78, 4, 0x00180cff} 
};

#endif

//
// Device extension.
//

typedef struct _HW_DEVICE_EXTENSION {
    UCHAR ucControllerId;

	LOGICAL_DRIVE LogicalDrive[MAX_DRIVES_PER_CONTROLLER];	
	// PHYSICAL_DRIVE PhysicalDrive[MAX_DRIVES_PER_CONTROLLER];
    PPHYSICAL_DRIVE PhysicalDrive;
	BOOLEAN IsSingleDrive[MAX_DRIVES_PER_CONTROLLER];
	BOOLEAN IsLogicalDrive[MAX_DRIVES_PER_CONTROLLER];

	CHANNEL Channel[MAX_CHANNELS_PER_CONTROLLER];

	//
	// Transfer descriptor.
	//
	TRANSFER_DESCRIPTOR TransferDescriptor[MAX_CHANNELS_PER_CONTROLLER];

    //
    // List of pending SRBs.
    //
#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY
	PSCSI_REQUEST_BLOCK PendingSrb[MAX_PENDING_SRBS];  // Striping will have the maximum pending srbs
#else
	PSCSI_REQUEST_BLOCK PendingSrb[STRIPING_MAX_PENDING_SRBS];  // Striping will have the maximum pending srbs
#endif

	//
	// Number of pending SRBs.
	//
	ULONG PendingSrbs;

    //
    // Base register locations.
    //
    PIDE_REGISTERS_1 BaseIoAddress1[MAX_CHANNELS_PER_CONTROLLER];
    PIDE_REGISTERS_2 BaseIoAddress2[MAX_CHANNELS_PER_CONTROLLER];
	PBM_REGISTERS BaseBmAddress[MAX_CHANNELS_PER_CONTROLLER];

	//
	// PCI Slot information for the IDE controller.
	//
	PCI_SLOT_NUMBER PciSlot;

	//
	// System I/O Bus Number for this controller.
    //
	ULONG BusNumber;

	//
	// Interface type.
	//
	INTERFACE_TYPE AdapterInterfaceType;

	//
	// Transfer Mode.
	//
	TRANSFER_MODE TransferMode[MAX_DRIVES_PER_CONTROLLER];

    //
    // Interrupt level.
    //
    ULONG ulIntLine;

    //
    // Interrupt Mode (Level or Edge)
    //
    ULONG InterruptMode;

	//
	// Controller speed (UDMA/33, UDMA/66, etc.)
	//
    CONTROLLER_SPEED ControllerSpeed;

	//
	// Copy of PCI timing registers.
	//
	IDE_PCI_TIMING_REGISTER IdeTimingRegister[MAX_CHANNELS_PER_CONTROLLER];

	//
	// Copy of UDMA Control register.
	//
	IDE_PCI_UDMA_CONTROL_REGISTER UdmaControlRegister;

	//
	// Copy of UDMA Timing register.
	//
	IDE_PCI_UDMA_TIMING_REGISTER UdmaTimingRegister;

    //
    // Count of errors. Used to turn off features.
    //
    ULONG ErrorCount[MAX_DRIVES_PER_CONTROLLER];

    //
    // Indicates number of platters on changer-ish devices.
    //
    ULONG DiscsPresent[MAX_DRIVES_PER_CONTROLLER];

    //
    // Flags dword for each possible device.
    //
    ULONG DeviceFlags[MAX_DRIVES_PER_CONTROLLER];

    //
    // Indicates the number of blocks transferred per int. according to the
    // identify data.
    //
    UCHAR MaximumBlockXfer[MAX_DRIVES_PER_CONTROLLER];

    //
    // Indicates expecting an interrupt.
    //
	UCHAR ExpectingInterrupt[MAX_CHANNELS_PER_CONTROLLER];

    //
    // Driver is being used by the crash dump utility or ntldr.
    //
    BOOLEAN DriverMustPoll;

    //
    // Indicates use of 32-bit PIO
    //
    BOOLEAN DWordIO;

    //
    // Placeholder for status register after a GET_MEDIA_STATUS command
    //

    UCHAR ReturningMediaStatus[MAX_DRIVES_PER_CONTROLLER];
    
    //
    // Identify data for device
    //
    IDENTIFY_DATA FullIdentifyData[MAX_DRIVES_PER_CONTROLLER];
    IDENTIFY_DATA2 IdentifyData[MAX_DRIVES_PER_CONTROLLER];

    ULONG aulDrvList[MAX_DRIVES_PER_CONTROLLER];
    UCHAR aucDevType[MAX_DRIVES_PER_CONTROLLER];
    SEND_COMMAND SendCommand[MAX_DEVICE_TYPES];

    SPLIT_SRB_ENQUEQUE_SRB SrbHandlers[MAX_DRIVE_TYPES];

    POST_ROUTINES PostRoutines[MAX_DEVICE_TYPES];

    UCHAR RebuildInProgress;
    ULONG RebuildWaterMarkSector;
    ULONG RebuildWaterMarkLength;
    ULONG RebuildTargetDrive;

    UCHAR   ulMaxStripesPerRow; 

    BOOLEAN bIntFlag;

    UCHAR IsSpareDrive[MAX_DRIVES_PER_CONTROLLER];

    BOOLEAN bEnableRwCache;

    BOOLEAN bSkipSetParameters[MAX_DRIVES_PER_CONTROLLER];

    BOOLEAN bIsThruResetController;

    ULONG   aulLogDrvId[MAX_DRIVES_PER_CONTROLLER];

    ULONG   ulFlushCacheCount;

#ifdef HYPERDISK_WIN2K
    BOOLEAN bIsResetRequiredToGetActiveMode;
    ULONG aulPCIData[PCI_DATA_TO_BE_UPDATED];
#endif // HYPERDISK_WIN2K

#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY
    PSRB_EXTENSION  pSrbExtension;
#endif // HYPERDISK_WIN98

    BOOLEAN bInvalidConnectionIdImplementation;

    // plays the same role as MAX_PENDING_SRBS
    UCHAR   ucMaxPendingSrbs ;
    UCHAR   ucOptMaxQueueSize;
    UCHAR   ucOptMinQueueSize;

    // For SMART Implementation
    UCHAR uchSMARTCommand;
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


typedef struct _CARD_INFO
{
    PHW_DEVICE_EXTENSION pDE;
    UCHAR   ucPCIBus;
    UCHAR   ucPCIDev;
    UCHAR   ucPCIFun;
    ULONG   ulDeviceId;
    ULONG   ulVendorId;
}CARD_INFO, *PCARD_INFO;


#define GET_TARGET_ID(ConnectionId) ((ConnectionId & 0x0f ) + ((ConnectionId >> 4) * 2))
#define GET_TARGET_ID_WITHOUT_CONTROLLER_INFO(ConnectionId) ( ((ConnectionId & 0x0f ) + ((ConnectionId >> 4) * 2)) & 0x3)
#define GET_FIRST_LOGICAL_DRIVE(pRaidHeader) ((char *)pRaidHeader + pRaidHeader->HeaderSize)
#define TARGET_ID_2_CONNECTION_ID(ulDrvInd) ((ulDrvInd & 0x1) + ((ulDrvInd & 0xfe) << 3))
#define TARGET_ID_WITHOUT_CONTROLLER_ID(ulDrvInd)   (ulDrvInd & 0x03)

#define IS_CHANNEL_BUSY(DeviceExtension, ulChannel) ( DeviceExtension->Channel[ulChannel].ActiveCommand )

#define DRIVE_HAS_COMMANDS(PhysicalDrive)   \
        (PhysicalDrive->ucHead != PhysicalDrive->ucTail)

#define ACTIVE_COMMAND_PRESENT(Channel) (Channel->ActiveCommand)

#define FEED_ALL_CHANNELS(DeviceExtension)                              \
            {                                                           \
                ULONG ulChannel;                                        \
                for(ulChannel=0;ulChannel<MAX_CHANNELS_PER_CONTROLLER;ulChannel++)     \
                    StartChannelIo(DeviceExtension, ulChannel);         \
            }

#define CLEAR_AND_POST_COMMAND(DeviceExtension, ulChannel)              \
            {                                                           \
                MarkChannelFree(DeviceExtension, ulChannel);            \
                StartChannelIo(DeviceExtension, ulChannel);             \
            }

#define DRIVE_IS_UNUSABLE_STATE(TargetId)                               \
        ( DeviceExtension->PhysicalDrive[TargetId].TimeOutErrorCount >= MAX_TIME_OUT_ERROR_COUNT )

#define MAX_TIME_OUT_ERROR_COUNT    5


#endif // _HYPERDISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaraid\adapter.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = Adapter.H                                    */
/* FUNCTION         = Header file of Adapter Version Information;  */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = American MegaTrends Inc. All rights reserved;*/
/*                                                                 */
/*******************************************************************/

#ifndef _ADAPTER_H
#define _ADAPTER_H

/*
	Define Vendor here
*/
#define MEGARAID  1

#undef VER_PRODUCTNAME_STR
#undef VER_PRODUCTVERSION_STR
#undef VER_COMPANYNAME_STR

#define VER_PRODUCTVERSION_STR  "6.19"


/*
  MegaRAID Version Information
*/

#define VER_LEGALCOPYRIGHT_YEARS    "         "
#define VER_LEGALCOPYRIGHT_STR      "Copyright \251 American Megatrends Inc." VER_LEGALCOPYRIGHT_YEARS
#define VER_COMPANYNAME_STR         "American Megatrends Inc."      
#ifdef _WIN64
#define VER_PRODUCTNAME_STR         "MegaRAID Miniport Driver for IA64"
#define VER_FILEDESCRIPTION_STR     "MegaRAID RAID Controller Driver for IA64"
#else
#define VER_PRODUCTNAME_STR         "MegaRAID Miniport Driver for Windows Whistler 32"
#define VER_FILEDESCRIPTION_STR     "MegaRAID RAID Controller Driver for Windows Whistler 32"
#endif
#define VER_ORIGINALFILENAME_STR    "mraid35x.sys"
#define VER_INTERNALNAME_STR        "mraid35x.sys"




#define RELEASE_DATE "03-09-2001"

#ifdef _WIN64
#define OS_NAME      "Whistler 64"
#else
#define OS_NAME      "Whistler 32"
#endif
#define OS_VERSION   "5.00"


#endif //_ADAPTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaide\init.c ===
ULONG
FindIdeRaidControllers(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PVOID Context,
	IN PVOID BusInformation,
	IN PCHAR ArgumentString,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
	OUT PBOOLEAN Again
)

/*++

Routine Description:

	This function scans the PCI bus containing the main IDE controller
	to find the PIIX4 IDE function. Once found it, it maps the Base
	Address of the Bus Master Registers and saves it in the DeviceExtension.

	The Bus Master Address of both channels is mapped and saved.

Arguments:

	DeviceExtension		Pointer to miniport instance.
	ConfigInfo			Pointer to configuration data from the Port driver.

Return Value:

	TRUE	Found PIIX4 IDE controller and mapped base address of Bus Master
			Registers.

	FALSE	Failure.


--*/
{
    ScanPCIBusForHyperDiskControllers(DeviceExtension);

#ifdef HYPERDISK_WINNT
    gbFindRoutineVisited = TRUE;
    if (gbManualScan)
    {
        if ( !AssignDeviceInfo(ConfigInfo) )
        {// probably we already reported all the cards
            *Again = FALSE;
            return SP_RETURN_NOT_FOUND;
        }
    }
#endif

    // Assigns controller Id for this controller
    //  done by comparing the Global Array of PCI Cards' PCI info 
    //  with the current PCI Card's Info
    if ( !AssignControllerId(DeviceExtension, ConfigInfo) )
    {
        *Again = TRUE;  // let us see if we found it out
        return SP_RETURN_NOT_FOUND;
    }


    FindResourcesInfo(DeviceExtension, ConfigInfo);

    DeviceExtension->ulMaxStripesPerRow = ~0;

    // for Clearing parity error, FIFO Enable
    SetInitializationSettings(DeviceExtension);

    // Fill ConfigInfo Structure
	ConfigInfo->InterruptMode = LevelSensitive;

    ConfigInfo->CachesData = TRUE;

    //
    // Indicate one bus.
    //

    ConfigInfo->NumberOfBuses = 1;

	//
	// Indicate the total number of devices that can be attached to the adapter.
	//

	ConfigInfo->MaximumNumberOfTargets = (UCHAR) MAX_DRIVES_PER_CONTROLLER;

	//
	// Indicate that the miniport always calls ScsiPortxxx to access
	// data buffers.
	//

	ConfigInfo->BufferAccessScsiPortControlled = TRUE;

	//
	// Indicate use of S/G list for transfers.
	//
	
	ConfigInfo->ScatterGather = TRUE;

	//
	// Indicate maximum number of SGL entries supported.
	//
	
	ConfigInfo->NumberOfPhysicalBreaks = (MAX_SGL_ENTRIES_PER_SRB / 2) - 1;
	
    ConfigInfo->NeedPhysicalAddresses = TRUE;

    ConfigInfo->TaggedQueuing = TRUE;
	ConfigInfo->MultipleRequestPerLu = TRUE;

	//
	// Indicate DMA master capability.
	//
	
	ConfigInfo->Master = TRUE;
	
	//
	// Indicate 32-bit memory region addresses.
	//

	ConfigInfo->Dma32BitAddresses = TRUE;

    //
	// Indicate 32-bit (DWORD) alignment requirement for data buffers.
	//
	ConfigInfo->AlignmentMask = 3;

    
    DeviceExtension->PhysicalDrive = (PPHYSICAL_DRIVE) 
                                     ScsiPortGetUncachedExtension (
                                        DeviceExtension,
                                        ConfigInfo,
                                        (sizeof (PHYSICAL_DRIVE) * MAX_DRIVES_PER_CONTROLLER) 
                                        );
    
#ifndef HYPERDISK_W2K
    InitIdeRaidControllers(DeviceExtension);
#endif

#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY

        if (! AllocateSRBExtMemory(DeviceExtension, ConfigInfo))
        {
            *Again = FALSE;
            return SP_RETURN_NOT_FOUND;
        }

#endif // HD_ALLOCATE_SRBEXT_SEPERATELY

	//
	// Indicate maximum transfer length.
	//
	ConfigInfo->MaximumTransferLength = DeviceExtension->ulMaxStripesPerRow * MAX_SECTORS_PER_IDE_TRANSFER * IDE_SECTOR_SIZE;

    //
	// Look for other adapters at the moment.
	//
	*Again = TRUE;
	return SP_RETURN_FOUND;
}

BOOLEAN
InitIdeRaidControllers(
	IN PHW_DEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

	This function is called by the OS-specific port driver after
	the necessary storage has been allocated, to gather information
	about the adapter's configuration. In particular, it determines
	whether a RAID is present.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	Context - Address of adapter count
	BusInformation -
	ArgumentString - Used to determine whether driver is client of ntldr or crash dump utility.
	ConfigInfo - Configuration information structure describing HBA
	Again - Indicates search for adapters to continue

Return Value:

	ULONG

--*/
{
	BOOLEAN foundDevices;
	PHW_DEVICE_EXTENSION  e = DeviceExtension;
	SCSI_PHYSICAL_ADDRESS ioBasePort3;
	UCHAR				  channel;
	PUCHAR				  ioSpace;
	UCHAR				  statusByte;
	SCSI_PHYSICAL_ADDRESS ioBasePort1;
	SCSI_PHYSICAL_ADDRESS ioBasePort2;
	UCHAR targetId;

	foundDevices = FALSE;

	// Begin Vasu - 03 January 2001
	// Disable Interrupts if Windows 98
	// Better we do it no matter what BIOS does.
#ifdef HYPERDISK_WIN98
	DisableInterrupts(DeviceExtension);
#endif
	// End Vasu

	for (channel = 0; channel < MAX_CHANNELS_PER_CONTROLLER; channel++) 
    {
		//
		// Search for devices on this controller.
		//

        if (FindDevices(DeviceExtension, channel)) 
        {
            //
            // Remember that some devices were found.
            //

            foundDevices = TRUE;

            if ((DeviceExtension->DeviceFlags[channel << 1] & DFLAGS_DEVICE_PRESENT) &&
		            (DeviceExtension->DeviceFlags[(channel << 1) + 1] & DFLAGS_DEVICE_PRESENT)) 
            {

                //
                // If 2 drives are present, set SwitchDrive to 1 (default is 0).
                // SwitchDrive is used to toggle bewteen the two drives' work queues,
                // to keep the drives fed in a fair fashion. See StartChannelIo().
                //

	            DeviceExtension->Channel[channel].SwitchDrive = 1;
            }
        }

	}

	if (foundDevices) 
    {

		//
		// Program I/O mode for each drive.
		//

		for (targetId = 0; targetId < MAX_DRIVES_PER_CONTROLLER; targetId++) 
        {

			if (IS_IDE_DRIVE(targetId)) 
            {

				BOOLEAN success;

				success = GetIoMode(DeviceExtension, targetId);

				if (!success) {

					//
					// Disable device.
					//

					DeviceExtension->DeviceFlags[targetId] &= ~DFLAGS_DEVICE_PRESENT;
				}
                else {
                    DeviceExtension->aucDevType[targetId] = IDE_DRIVE;
				}    

			}
        }

        DeviceExtension->SendCommand[NO_DRIVE]      = DummySendRoutine;
        DeviceExtension->SendCommand[IDE_DRIVE]     = IdeSendCommand;

        DeviceExtension->SrbHandlers[LOGICAL_DRIVE_TYPE] = SplitSrb;
        DeviceExtension->SrbHandlers[PHYSICAL_DRIVE_TYPE] = EnqueueSrb;

        DeviceExtension->PostRoutines[NO_DRIVE] = DummyPostRoutine;
        DeviceExtension->PostRoutines[IDE_DRIVE] = PostIdeCmd;
	}

    GetConfigInfoAndErrorLogSectorInfo(DeviceExtension);

	//
	// Get RAID configuration for both channels.
	//
    if (IsRaidMember(gaucIRCDData)) // Try to do this configuration only if the IRCD Data is valid
    {
	    PIRCD_HEADER pRaidHeader;

	    pRaidHeader = (PIRCD_HEADER) gaucIRCDData;

        if (    ( pRaidHeader->MajorVersionNumber == 1) &&
                ( pRaidHeader->MinorVersionNumber == 0)
        )
        {
            DeviceExtension->bInvalidConnectionIdImplementation = FALSE;
        }
        else
        {
            DeviceExtension->bInvalidConnectionIdImplementation = TRUE;
        }

        gFwVersion.Build = 0;   // how to find this????
        gFwVersion.MajorVer = pRaidHeader->MajorVersionNumber;
        gFwVersion.MinorVer = pRaidHeader->MinorVersionNumber;

	    ConfigureRaidDrives(DeviceExtension);
    }

	//
	// Expose single drives.
	//
	ExposeSingleDrives(DeviceExtension);

    AssignLogicalDriveIds(DeviceExtension);

    // Initialize some features on drive (which are required at the initialization time)
    // Right now we are enabling Cache implementation features... (this is to resolve the bug of 
    // bad performance on some IBM Drives)
    InitDriveFeatures(DeviceExtension);

    return TRUE;
} // end InitIdeRaidControllers()

BOOLEAN
AssignLogicalDriveIds(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension
)
{
    ULONG ulCurLogDrv, ulLogDrvInd;

    for(ulCurLogDrv=0, ulLogDrvInd=0;ulLogDrvInd<MAX_DRIVES_PER_CONTROLLER;ulLogDrvInd++)
    {
        if ( DeviceExtension->IsLogicalDrive[ulLogDrvInd] || DeviceExtension->IsSingleDrive[ulLogDrvInd] )
        {
            DeviceExtension->aulLogDrvId[ulLogDrvInd] = ulCurLogDrv;
            DeviceExtension->aulDrvList[ulCurLogDrv++] = ulLogDrvInd;
        }
    }
    // Begin Vasu - 16 January 2001
    // Fixed prob. with Inquiry Command returning MegaIDE #00 always.
    return TRUE;
    // End Vasu.
}

BOOLEAN
ConfigureRaidDrives(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension
)
// Find out the Logical Drive that is related to this controller
{
    UCHAR ucControllerId, ucMirrorDrvId;
    PIRCD_HEADER pRaidHeader = (PIRCD_HEADER)gaucIRCDData;
    PIRCD_LOGICAL_DRIVE pRaidLogDrive = (PIRCD_LOGICAL_DRIVE)GET_FIRST_LOGICAL_DRIVE(pRaidHeader);
    PIRCD_PHYSICAL_DRIVE pPhyDrive;
    ULONG ulLogDrvInd, ulDrvInd, ulArrayId, ulCurLogDrv, ulLastDrvInd, ulMinSize, ulDrvInd2, ulPhyDrvInd;
    ULONG ulTemp;

    DeviceExtension->bEnableRwCache = (BOOLEAN)(pRaidHeader->Features & 0x01); // First bit is for Write Cache Enable 

    //
	// hide all of phy drives in spare drive list
	//
    for(ulLogDrvInd=0;ulLogDrvInd<pRaidHeader->NumberOfLogicalDrives;ulLogDrvInd++)
    {
        if ( SpareDrivePool == pRaidLogDrive[ulLogDrvInd].LogicalDriveType )
        {
	        pPhyDrive = (PIRCD_PHYSICAL_DRIVE)((char *)pRaidHeader + pRaidLogDrive[ulLogDrvInd].FirstStripeOffset);

			for(ulDrvInd=0;ulDrvInd<pRaidLogDrive[ulLogDrvInd].NumberOfDrives;ulDrvInd++)
			{
                if ( INVALID_CONNECTION_ID == pPhyDrive[ulDrvInd].ConnectionId )
                    continue;

				ulPhyDrvInd = GET_TARGET_ID((pPhyDrive[ulDrvInd].ConnectionId));

                if ( DeviceExtension->ucControllerId != (ulPhyDrvInd>>2) )
                    continue;   // this does not belong to this controller

                ulPhyDrvInd &= 0x3; // We need only the info about the current controller ... so strip out the 
                // controller Info

				DeviceExtension->IsSingleDrive[ulPhyDrvInd] = FALSE;

				DeviceExtension->PhysicalDrive[ulPhyDrvInd].Hidden = TRUE;

                DeviceExtension->IsSpareDrive[ulPhyDrvInd] = (UCHAR) 1;

                DeviceExtension->PhysicalDrive[ulPhyDrvInd].ucLogDrvId = INVALID_DRIVE_ID;
			}
    		// since there are only one spare drive list, jump out of loop
            break;
        }
    }


    for(ulLogDrvInd=0, ulArrayId=0;ulLogDrvInd<pRaidHeader->NumberOfLogicalDrives;ulLogDrvInd++, ulArrayId++)
    {
        if ( SpareDrivePool == pRaidLogDrive[ulLogDrvInd].LogicalDriveType )
            continue;

        // Here for every Raid Drive the target ID will be equal to the first GOOD Physical Drive in the array
        pPhyDrive = (PIRCD_PHYSICAL_DRIVE)((char *)pRaidHeader + pRaidLogDrive[ulLogDrvInd].FirstStripeOffset);

        if ( !FoundValidDrive(pPhyDrive, pRaidLogDrive[ulLogDrvInd].NumberOfDrives) )
        {   // No valid Drive in this logical drive.. so let us not consider this drive at all
            continue;
        }

        ulCurLogDrv = CoinLogicalDriveId(&(pRaidLogDrive[ulLogDrvInd]), pPhyDrive);
        DeviceExtension->LogicalDrive[ulCurLogDrv].ulArrayId = ulArrayId;

        // Check if this logical drive belongs to this controller at all
        for(ulDrvInd=0;ulDrvInd<pRaidLogDrive->NumberOfDrives;ulDrvInd++)
        {
            if ( INVALID_CONNECTION_ID == pPhyDrive[ulDrvInd].ConnectionId )
                continue;

            ulTemp = GET_TARGET_ID(pPhyDrive[ulDrvInd].ConnectionId);
            break;
        }

        if ( DeviceExtension->ucControllerId != (ulTemp>>2) )
            continue;   // this drive does not belong to this controller

        FillLogicalDriveInfo(DeviceExtension, ulCurLogDrv, &(pRaidLogDrive[ulLogDrvInd]), gaucIRCDData );
    }

    return TRUE;
}


BOOLEAN
FoundValidDrive(
                PIRCD_PHYSICAL_DRIVE pPhyDrv,
                UCHAR ucDrvCount
                )
{
   UCHAR ucDrvInd;

   for(ucDrvInd=0;ucDrvInd<ucDrvCount;ucDrvInd++)
   {
       if ( INVALID_CONNECTION_ID != pPhyDrv[ucDrvInd].ConnectionId ) // this drive is not present
       {
           return TRUE;
       }
   }
   return FALSE;
}

#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY

BOOLEAN AllocateSRBExtMemory(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo
)
{
    DeviceExtension->pSrbExtension = 
        ScsiPortGetUncachedExtension (DeviceExtension,
                                      ConfigInfo,
                                      (sizeof(SRB_EXTENSION) * MAX_PENDING_SRBS));

    if (DeviceExtension->pSrbExtension == NULL)
    {
        return FALSE;
    }

    return TRUE;
}

#endif // HD_ALLOCATE_SRBEXT_SEPERATELY

BOOLEAN
FillLogicalDriveInfo(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
    ULONG ulLogDrvId,
    PIRCD_LOGICAL_DRIVE pRaidLogDrive,
    PUCHAR  pucIRCDData
    )
{
    PLOGICAL_DRIVE pCurLogDrv;
    PPHYSICAL_DRIVE pPhyDrv;
    PIRCD_PHYSICAL_DRIVE pIRCDPhyDrv;
    IRCD_PHYSICAL_DRIVE TempPhysicalDrive;
    ULONG ulTempInd, ulLastDrvInd, ulMinSize, ulDrvInd, ulDrvInd2, ulPhyDrvInd;
    UCHAR ucMirrorDrvId;
    PIRCD_HEADER pRaidHeader = (PIRCD_HEADER)pucIRCDData;

    pCurLogDrv = &(DeviceExtension->LogicalDrive[ulLogDrvId]);
    pPhyDrv = DeviceExtension->PhysicalDrive;

    // Store the Logical Drive Information
    pCurLogDrv->RaidLevel          = pRaidLogDrive->LogicalDriveType;
    DeviceExtension->IsLogicalDrive[ulLogDrvId]                  = TRUE;
    pCurLogDrv->StripeSize         = pRaidLogDrive->StripeSize;		// In 512-byte units.
    pCurLogDrv->StripesPerRow      = pRaidLogDrive->NumberOfStripes;
    pCurLogDrv->PhysicalDriveCount = pRaidLogDrive->NumberOfDrives;
    pCurLogDrv->TargetId           = (UCHAR)ulLogDrvId;
    pCurLogDrv->Status             = pRaidLogDrive->LogDrvStatus;
        // NextLogicalDrive fields of "DeviceExtension->LogicalDrive[pRaidLogDrive]" are TO BE FILLED YET

    if ( DeviceExtension->ulMaxStripesPerRow > pCurLogDrv->StripesPerRow ) 
    {
        DeviceExtension->ulMaxStripesPerRow = pCurLogDrv->StripesPerRow;
    }

    // Fill in the Physical Drive Information
    ulLastDrvInd = EOL;
    ulMinSize = ~0; // keep the maximum possible value in this

    pIRCDPhyDrv = (PIRCD_PHYSICAL_DRIVE)((char *)pRaidHeader + pRaidLogDrive->FirstStripeOffset);

    if ( ( Raid1 == pCurLogDrv->RaidLevel ) || ( Raid10 == pCurLogDrv->RaidLevel ) )
    {
        for(ulDrvInd=0;ulDrvInd<pRaidLogDrive->NumberOfStripes;ulDrvInd++)
        {   // atleast one drive will be a valid drive id other wise it would have been skipped in the above
            // for loop ... Yet to put some more thoughts on Raid10
            if ( INVALID_CONNECTION_ID == pIRCDPhyDrv[ulDrvInd*2].ConnectionId )
            {   // swap them so that the good drive is in the first place
                AtapiMemCpy((PUCHAR)&TempPhysicalDrive, (PUCHAR)(&(pIRCDPhyDrv[ulDrvInd*2])), sizeof(IRCD_PHYSICAL_DRIVE));
                AtapiMemCpy((PUCHAR)(&(pIRCDPhyDrv[ulDrvInd*2])), (PUCHAR)(&(pIRCDPhyDrv[(ulDrvInd*2) + 1])), sizeof(IRCD_PHYSICAL_DRIVE));
                AtapiMemCpy((PUCHAR)(&(pIRCDPhyDrv[(ulDrvInd*2) + 1])), (PUCHAR)&TempPhysicalDrive, sizeof(IRCD_PHYSICAL_DRIVE));
            }
        }
    }

    for(ulDrvInd=0, ulDrvInd2=0;ulDrvInd<pRaidLogDrive->NumberOfDrives;ulDrvInd++, ulDrvInd2++)
    {
        if ( INVALID_CONNECTION_ID == pIRCDPhyDrv[ulDrvInd].ConnectionId )
        {   // this should never happen as we will be making sure that the good drive is in the first place
            continue;
        }

        ulPhyDrvInd = GET_TARGET_ID_WITHOUT_CONTROLLER_INFO((pIRCDPhyDrv[ulDrvInd].ConnectionId));

        if ( ulMinSize > pIRCDPhyDrv[ulDrvInd].Capacity )
            ulMinSize = pIRCDPhyDrv[ulDrvInd].Capacity;

        if ( ! InSpareDrivePool(pucIRCDData, pIRCDPhyDrv[ulDrvInd].ConnectionId) )
        { // This drive is not spare drive pool... if it is in Spare Drive Pool also then it is a Drive Replacement Case
            // then we are in trouble of showing wrong Logical Drive Size.. if we look in DeviceExtension
			// take care of IRCD and Error Log sectors
			//
			
            if ( ulMinSize > pPhyDrv[ulPhyDrvInd].Sectors) 
                ulMinSize = pPhyDrv[ulPhyDrvInd].Sectors;
        }
        else
        {
            
        }

        // Store the status.
        pPhyDrv[ulPhyDrvInd].Status = pIRCDPhyDrv[ulDrvInd].PhyDrvStatus;

        DeviceExtension->IsSingleDrive[ulPhyDrvInd] = FALSE;

        // This is part of Raid so mark it as HIDDEN
        pPhyDrv[ulPhyDrvInd].Hidden = TRUE;

		pPhyDrv[ulPhyDrvInd].ucMirrorDriveId = INVALID_DRIVE_ID;	// init mirror drive id
		pPhyDrv[ulPhyDrvInd].ucLogDrvId = (UCHAR)ulLogDrvId;	// init mirror drive id

        pCurLogDrv->PhysicalDriveTid[ulDrvInd2] = (UCHAR)ulPhyDrvInd;

        pPhyDrv[ulPhyDrvInd].Next = EOL;
        if ( EOL != ulLastDrvInd )
            pPhyDrv[ulLastDrvInd].Next = (UCHAR)ulPhyDrvInd;

        ulLastDrvInd = ulPhyDrvInd;

        if ( ( Raid1 == pCurLogDrv->RaidLevel ) || ( Raid10 == pCurLogDrv->RaidLevel ) )
        {
			++ulDrvInd;
            if ( INVALID_CONNECTION_ID == pIRCDPhyDrv[ulDrvInd].ConnectionId )
            {
				DeviceExtension->PhysicalDrive[ulPhyDrvInd].ucMirrorDriveId = INVALID_DRIVE_ID;      // Let the mirror drives point to each other
            }
            else
            {
                // Begin Vasu - 18 Aug 2000
                // Removed one redundant if loop.
    		    if (ulDrvInd < pRaidLogDrive->NumberOfDrives) 
                {
				        ucMirrorDrvId = GET_TARGET_ID_WITHOUT_CONTROLLER_INFO((pIRCDPhyDrv[ulDrvInd].ConnectionId));

				        pPhyDrv[ulPhyDrvInd].ucMirrorDriveId = ucMirrorDrvId;      // Let the mirror drives point to each other
				        pPhyDrv[ucMirrorDrvId].ucMirrorDriveId = (UCHAR)ulPhyDrvInd;
                        pPhyDrv[ucMirrorDrvId].ucLogDrvId = (UCHAR)ulLogDrvId;	// init mirror drive id


				        if ( ulMinSize > pIRCDPhyDrv[ulDrvInd].Capacity )
					        ulMinSize = pIRCDPhyDrv[ulDrvInd].Capacity;

                        if ( ! InSpareDrivePool(gaucIRCDData, pIRCDPhyDrv[ulDrvInd].ConnectionId) )
                        { // This drive is not spare drive pool... if it is in Spare Drive Pool also then it is a Drive Replacement Case
                            // then we are in trouble of showing wrong Logical Drive Size.. if we look in DeviceExtension
					        // take care of IRCD and Error Log sectors
					        //
					        
					        if ( ulMinSize > pPhyDrv[ucMirrorDrvId].Sectors) 
						        ulMinSize = pPhyDrv[ucMirrorDrvId].Sectors;
                        }

				        // Store the status.
				        pPhyDrv[ucMirrorDrvId].Status = pIRCDPhyDrv[ulDrvInd].PhyDrvStatus;

				        // mark the drive type
				        DeviceExtension->IsSingleDrive[ucMirrorDrvId] = FALSE;

				        // This is part of Raid so mark it as HIDDEN
				        pPhyDrv[ucMirrorDrvId].Hidden = TRUE;
			        }
                // End Vasu.
            }
		}
    }   // END OF for(ulDrvInd=0, ulDrvInd2=0;ulDrvInd<pRaidLogDrive->.NumberOfDrives;ulDrvInd++, ulDrvInd2++)

	switch (pCurLogDrv->RaidLevel) 
    {
		case Raid0:				// striping
			break;

		case Raid10:            // Striping over Mirrorring
			break;

		case Raid1:				// mirroring
            // If it is a raid1 then at the mostwe can transfer on a drive is 256 Sectors (MAXimum transfer possible for Transfer)
		    pCurLogDrv->StripesPerRow  = 1;	// bios should set this value to 1 already
            pCurLogDrv->StripeSize = ulMinSize;    // For Mirroring case the stripe size is 
                                        // equal to the size of the drive
		    break;
	}

    // Each Drive size should be multiple of Stripe Size
    if ((pCurLogDrv->RaidLevel == Raid0) ||
		(pCurLogDrv->RaidLevel == Raid10)) 
    {
            ulMinSize = ulMinSize - (ulMinSize % pCurLogDrv->StripeSize);
    }

    pCurLogDrv->Sectors = pCurLogDrv->StripesPerRow * ulMinSize;

	// set all phy drives' useable size 
    for(ulTempInd=0;ulTempInd<pCurLogDrv->StripesPerRow;ulTempInd++)
    {
		ulPhyDrvInd = pCurLogDrv->PhysicalDriveTid[ulTempInd];
        pPhyDrv[ulPhyDrvInd].Sectors = ulMinSize;

		// check if mirror drive exists or not
        ucMirrorDrvId = pPhyDrv[ulPhyDrvInd].ucMirrorDriveId;
		if (!IS_DRIVE_OFFLINE(ucMirrorDrvId)) 
        {
			pPhyDrv[ucMirrorDrvId].Sectors = ulMinSize;
		}
    }


	// if Raid1 or Raid10, always put the good drive in the mirroring to the first position
    if ((pCurLogDrv->RaidLevel == Raid1) ||
		(pCurLogDrv->RaidLevel == Raid10)) 
    {
		
		for(ulTempInd=0;ulTempInd<pCurLogDrv->StripesPerRow;ulTempInd++)
        {
			// get the first phy drive id (from the mirror pair)
			ulPhyDrvInd = pCurLogDrv->PhysicalDriveTid[ulTempInd];
            ucMirrorDrvId = pPhyDrv[ulPhyDrvInd].ucMirrorDriveId;

			// if no mirror drv, try next
			if (IS_DRIVE_OFFLINE(ucMirrorDrvId))
				continue;

			//
			// check if any of them Failed or Rebuilding in both cases the we should mark drives as offline
            // so that in normal read or write path we will not use the mirror drive
			//
			if  (   (pPhyDrv[ulPhyDrvInd].Status == PDS_Failed) ||
                    (pPhyDrv[ulPhyDrvInd].Status == PDS_Rebuilding) 
                )
				pPhyDrv[ucMirrorDrvId].ucMirrorDriveId |= DRIVE_OFFLINE;

			if  (   (pPhyDrv[ucMirrorDrvId].Status == PDS_Failed) ||
                    (pPhyDrv[ucMirrorDrvId].Status == PDS_Rebuilding)
                )
				pPhyDrv[ulPhyDrvInd].ucMirrorDriveId |= DRIVE_OFFLINE;

			if (
                (pPhyDrv[ulPhyDrvInd].Status == PDS_Failed) ||
                (pPhyDrv[ulPhyDrvInd].Status == PDS_Rebuilding)
                )
            {   // let us make sure that the first physical drive is the good drive
    			pCurLogDrv->PhysicalDriveTid[ulTempInd] = ucMirrorDrvId;
            }

			//
			// if both drives offline, set this logical drive offline
			//
			if (IS_DRIVE_OFFLINE((pPhyDrv[ulPhyDrvInd].ucMirrorDriveId)) &&
				IS_DRIVE_OFFLINE((pPhyDrv[ucMirrorDrvId].ucMirrorDriveId))) 
            {
					pCurLogDrv->Status = LDS_OffLine;
			} else
            {
				// if the first drive failed, swap it
				if (IS_DRIVE_OFFLINE((pPhyDrv[ucMirrorDrvId].ucMirrorDriveId))) 
                {
					pCurLogDrv->PhysicalDriveTid[ulTempInd] = ucMirrorDrvId;
				} // end if
            }
		} // END OF for(ulTempInd=0;ulTempInd<pCurLogDrv->StripesPerRow;ulTempInd++)

	} // end if raid1 or raid10


    if ( Raid10 == pCurLogDrv->RaidLevel )
    {   // make sure that the Physical Drive list in this Logical Drive are in different channels 
        // (so that the Reads will be in optimum mode)
        UCHAR ucFirstStripe, ucSecondStripe, ucMirrorOfFirstStripe, ucMirrorOfSecondStripe;

        ucFirstStripe  = DeviceExtension->LogicalDrive[ulLogDrvId].PhysicalDriveTid[0];
        ucMirrorOfFirstStripe = DeviceExtension->PhysicalDrive[ucFirstStripe].ucMirrorDriveId;
        ucSecondStripe = DeviceExtension->LogicalDrive[ulLogDrvId].PhysicalDriveTid[1];
        ucMirrorOfSecondStripe = DeviceExtension->PhysicalDrive[ucSecondStripe].ucMirrorDriveId;

        if ( (ucFirstStripe>>1) == (ucSecondStripe>>1) )
        {
            if ( !IS_DRIVE_OFFLINE(ucMirrorOfSecondStripe) )
            {   // Mirror Drive is good and we can use this as a primary drive for the second stripe
                DeviceExtension->LogicalDrive[ulLogDrvId].PhysicalDriveTid[1] = ucMirrorOfSecondStripe;
            }
            else
            {
                if ( !IS_DRIVE_OFFLINE(ucMirrorOfFirstStripe) )
                {
                    DeviceExtension->LogicalDrive[ulLogDrvId].PhysicalDriveTid[0] = ucMirrorOfFirstStripe;
                }
                else
                {
                    // we cannot do anything... we have to survive with this... as the remaining drives are offline
                }
            }
        }
        else
        {
            // nothing to be done ... both the drives are in different channels....
        }
    }

    return TRUE;
}

ULONG
CoinLogicalDriveId(
    PIRCD_LOGICAL_DRIVE pRaidLogDrive,
    PIRCD_PHYSICAL_DRIVE pPhyDrive
    )
{
    ULONG ulDrvInd, ulCurLogDrv;
    BOOLEAN bFoundGoodDrive = FALSE;

    for(ulDrvInd=0;ulDrvInd<pRaidLogDrive->NumberOfDrives;ulDrvInd++)
    {
        if ( INVALID_CONNECTION_ID == pPhyDrive[ulDrvInd].ConnectionId )
            continue;

        if ( PDS_Online == pPhyDrive[ulDrvInd].PhyDrvStatus )
        {
            ulCurLogDrv = GET_TARGET_ID_WITHOUT_CONTROLLER_INFO((pPhyDrive[ulDrvInd].ConnectionId)); // The target Id is equal to the first GOOD PhysicalDrive
            bFoundGoodDrive = TRUE;
            break;
        }
    }

    if ( !bFoundGoodDrive )    
        // all the drives in this logical drives are failed... so, 
        // let's assign the logical drive number as the first valid physical drive...
    {
        // find out a valid drive number now it is possible that invalid drive id can be first one also
        // so ....
        for(ulDrvInd=0;ulDrvInd<pRaidLogDrive->NumberOfDrives;ulDrvInd++)
        {
            if ( INVALID_CONNECTION_ID == pPhyDrive[ulDrvInd].ConnectionId ) // this drive is not present
                continue;

            ulCurLogDrv = GET_TARGET_ID_WITHOUT_CONTROLLER_INFO((pPhyDrive[ulDrvInd].ConnectionId)); 
            break;
        }
    }

    return ulCurLogDrv;
}

BOOLEAN
SetInitializationSettings(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension
)
// for parity error, FIFO Enable
{
    changePCIConfiguration(DeviceExtension,4,0x04,0,0,FALSE);// Clear Master Abort/Parity Error etc... Just Read and Write the Value
    changePCIConfiguration(DeviceExtension,1,0x79,0xcf,0x20,TRUE);//Set the controller to 1/2 Full FIFO Threshold

    return TRUE;
}

BOOLEAN
AssignControllerId(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
)
{
    ULONG ulControllerId;
    PCI_SLOT_NUMBER PciSlot;

    PciSlot.u.AsULONG = ConfigInfo->SlotNumber;

    DebugPrint((0, "looking for %x:%x:%x\n", ConfigInfo->SystemIoBusNumber, PciSlot.u.bits.DeviceNumber, PciSlot.u.bits.FunctionNumber));
    for(ulControllerId=0;ulControllerId<gucControllerCount;ulControllerId++)
    {
        if  ( 
                ( ConfigInfo->SystemIoBusNumber == gaCardInfo[ulControllerId].ucPCIBus ) &&
                ( PciSlot.u.bits.DeviceNumber == gaCardInfo[ulControllerId].ucPCIDev ) &&
                ( PciSlot.u.bits.FunctionNumber == gaCardInfo[ulControllerId].ucPCIFun ) 
            )
        {   // Yes... this is the card we are looking for ... so let us fill the ControllerId
            DebugPrint((0, "Controller ID : %x\n", ulControllerId));
            DeviceExtension->ucControllerId = (UCHAR)ulControllerId;
            gaCardInfo[ulControllerId].pDE = DeviceExtension;   // Store the Device Extension for further usage (helps in looking at a global picture)
            switch (gaCardInfo[ulControllerId].ulDeviceId)
            {
            case 0x648:
			    DeviceExtension->ControllerSpeed = Udma66;
                break;
            case 0x649:
			    DeviceExtension->ControllerSpeed = Udma100;
                break;
            }
            return TRUE;
            break;
        }
    }

    return FALSE;   // we didn't find the controller that can be controlled by us at this slot 
}
#define MAX_PORTS       6
BOOLEAN
FindResourcesInfo(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
)
{
	ULONG length, ulTempRange;
	PCI_SLOT_NUMBER slot;
    ULONG ulRangeInd, ulStartInd;
    ULONG aulPorts[MAX_PORTS];
    ULONG aulPCIBuf[sizeof(IDE_PCI_REGISTERS)];
	PIDE_PCI_REGISTERS pciRegisters = (PIDE_PCI_REGISTERS)aulPCIBuf;

#ifdef HYPERDISK_WIN98
    PPACKED_ACCESS_RANGE pAccessRange;
#else
    PACCESS_RANGE pAccessRange;
#endif

#ifdef HYPERDISK_WIN2K
    ULONG ulPCIDataCount;
#endif

	length = ScsiPortGetBusData(
							DeviceExtension,
							PCIConfiguration,
							ConfigInfo->SystemIoBusNumber,
							ConfigInfo->SlotNumber,
                            pciRegisters,
							sizeof(IDE_PCI_REGISTERS)
							);

	if (length < sizeof(IDE_PCI_REGISTERS)) 
    {
        DebugPrint((1,"GBMA1\n"));

		//
		// Invalid bus number.
		//

		return FALSE;
	}

#ifdef HYPERDISK_WIN98
    pAccessRange = (PPACKED_ACCESS_RANGE)*ConfigInfo->AccessRanges;
    ulTempRange = sizeof(PPACKED_ACCESS_RANGE);
#else
    pAccessRange = *ConfigInfo->AccessRanges;
    ulTempRange = sizeof(PACCESS_RANGE);
#endif

#ifdef HYPERDISK_WINNT
    if (gbManualScan) // for the boards like MegaPlex and Flextel Boards
    {
        ulRangeInd = 0;
        pAccessRange[ulRangeInd].RangeStart.LowPart = pciRegisters->BaseAddress1 & 0xfffffffe;
        pAccessRange[ulRangeInd].RangeStart.HighPart = 0;
        pAccessRange[ulRangeInd].RangeLength = 8;
        pAccessRange[ulRangeInd++].RangeInMemory = FALSE;

        pAccessRange[ulRangeInd].RangeStart.LowPart = pciRegisters->BaseAddress2 & 0xfffffffe;
        pAccessRange[ulRangeInd].RangeStart.HighPart = 0;
        pAccessRange[ulRangeInd].RangeLength = 4;
        pAccessRange[ulRangeInd++].RangeInMemory = FALSE;

        pAccessRange[ulRangeInd].RangeStart.LowPart = pciRegisters->BaseAddress3 & 0xfffffffe;
        pAccessRange[ulRangeInd].RangeStart.HighPart = 0;
        pAccessRange[ulRangeInd].RangeLength = 8;
        pAccessRange[ulRangeInd++].RangeInMemory = FALSE;

        pAccessRange[ulRangeInd].RangeStart.LowPart = pciRegisters->BaseAddress4 & 0xfffffffe;
        pAccessRange[ulRangeInd].RangeStart.HighPart = 0;
        pAccessRange[ulRangeInd].RangeLength = 4;
        pAccessRange[ulRangeInd++].RangeInMemory = FALSE;

        pAccessRange[ulRangeInd].RangeStart.LowPart = pciRegisters->BaseBmAddress & 0xfffffffe;
        pAccessRange[ulRangeInd].RangeStart.HighPart = 0;
        pAccessRange[ulRangeInd].RangeLength = 0x10;
        pAccessRange[ulRangeInd++].RangeInMemory = FALSE;

	    ConfigInfo->BusInterruptLevel = pciRegisters->InterruptLine;
	    ConfigInfo->InterruptMode = LevelSensitive;
    }
#endif


    for(ulRangeInd=0;
        ((ulRangeInd<ConfigInfo->NumberOfAccessRanges) && (pAccessRange[ulRangeInd].RangeStart.LowPart));
        ulRangeInd++)
    {
        aulPorts[ulRangeInd] = (ULONG)ScsiPortGetDeviceBase(
										DeviceExtension,
										ConfigInfo->AdapterInterfaceType,
										ConfigInfo->SystemIoBusNumber,
                                        pAccessRange[ulRangeInd].RangeStart,
                                        pAccessRange[ulRangeInd].RangeLength,
										TRUE	// I/O space.
										);
        if (!aulPorts[ulRangeInd])
        {
            DebugPrint((0,"\nUnable to Convert Ports\n\n"));
            return FALSE;
        }
	}

    ulStartInd = 0;

    ulRangeInd = 0;
	DeviceExtension->BaseIoAddress1[ulStartInd]     = (PIDE_REGISTERS_1)aulPorts[ulRangeInd++];
	DeviceExtension->BaseIoAddress2[ulStartInd]     = (PIDE_REGISTERS_2)aulPorts[ulRangeInd++];
	DeviceExtension->BaseIoAddress1[ulStartInd+1]   = (PIDE_REGISTERS_1)aulPorts[ulRangeInd++];
	DeviceExtension->BaseIoAddress2[ulStartInd+1]   = (PIDE_REGISTERS_2)aulPorts[ulRangeInd++];
	DeviceExtension->BaseBmAddress[ulStartInd]      = (PBM_REGISTERS)aulPorts[ulRangeInd];
	DeviceExtension->BaseBmAddress[ulStartInd + 1]  = (PBM_REGISTERS)(aulPorts[ulRangeInd] + sizeof(BM_REGISTERS));

    DeviceExtension->BusNumber = ConfigInfo->SystemIoBusNumber;
    DeviceExtension->PciSlot.u.AsULONG = ConfigInfo->SlotNumber;
    DebugPrint((0, 
        "Bus:%x:Device:%x:Function:%x\t", 
        DeviceExtension->BusNumber, 
        DeviceExtension->PciSlot.u.bits.DeviceNumber, 
        DeviceExtension->PciSlot.u.bits.FunctionNumber
        ));

	// Begin Vasu - 25 Aug 2000
	// ConfigInfo->BusInterruptVector is valid only in WinNT and not in Win98
	// ConfigInfo->BusInterruptLevel is valid in both WinNT and Win98.
	// Anyway, use ConfigInfo->BusInterruptLevel in 98 and
	// ConfigInfo->BusInterruptVector in NT/2K
#ifndef HYPERDISK_WIN98
	DeviceExtension->ulIntLine = ConfigInfo->BusInterruptVector;	// For WinNT and Win2K
#else // HYPERDISK_WIN98
	DeviceExtension->ulIntLine = ConfigInfo->BusInterruptLevel;		// For Win98
#endif // HYPERDISK_WIN98
	// End Vasu

#ifdef HYPERDISK_WIN2K
    for(ulPCIDataCount=0;ulPCIDataCount<PCI_DATA_TO_BE_UPDATED;ulPCIDataCount++)
    {   // take a copy of the data space that is required to restore when we come back from Standby
        length = ReadFromPCISpace(
						DeviceExtension,
                        &(DeviceExtension->aulPCIData[ulPCIDataCount]),
                        aPCIDataToBeStored[ulPCIDataCount].ulOffset,
						aPCIDataToBeStored[ulPCIDataCount].ulLength
						);
    }
#endif

	return TRUE;
}

#ifdef HYPERDISK_WIN2K
SCSI_ADAPTER_CONTROL_STATUS HyperDiskPnPControl(IN PVOID HwDeviceExtension,
			IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
			IN PVOID Parameters)
{
	PHW_DEVICE_EXTENSION DeviceExtension = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
	ULONG ulDrvInd, ulIndex;
    SCSI_ADAPTER_CONTROL_STATUS ucSCSIStatus;
    UCHAR ucTargetId;

    BOOLEAN baSupportList[ScsiAdapterControlMax] = 
    {
            TRUE,        // ScsiQuerySupportedControlTypes
#ifdef PNP_AND_POWER_MANAGEMENT
            TRUE,        // ScsiStopAdapter
            TRUE,       // ScsiRestartAdapter
            TRUE,       // ScsiSetBootConfig
            TRUE        // ScsiSetRunningConfig
#else
            FALSE,        // ScsiStopAdapter
            FALSE,       // ScsiRestartAdapter
            FALSE,       // ScsiSetBootConfig
            FALSE        // ScsiSetRunningConfig
#endif
    };

    ucSCSIStatus = ScsiAdapterControlUnsuccessful;

	DebugPrint((0, "\nIn AdapterControl\t: %X\n", ControlType));

	switch (ControlType)
	{
		case ScsiQuerySupportedControlTypes:
			{
                PSCSI_SUPPORTED_CONTROL_TYPE_LIST controlTypeList =
	                (PSCSI_SUPPORTED_CONTROL_TYPE_LIST)Parameters;
                for(ulIndex = 0; ulIndex < controlTypeList->MaxControlType; ulIndex++)
                    controlTypeList->SupportedTypeList[ulIndex] = baSupportList[ulIndex];
			}
            ucSCSIStatus = ScsiAdapterControlSuccess;
			break;
#ifdef PNP_AND_POWER_MANAGEMENT
        case ScsiStopAdapter:
            StopDrives(DeviceExtension);
            DisableInterrupts(DeviceExtension);// Win2000 should call for each controller check it out
            ucSCSIStatus = ScsiAdapterControlSuccess;
            break;

        case ScsiRestartAdapter:
            for(ucTargetId=0;ucTargetId<MAX_DRIVES_PER_CONTROLLER;ucTargetId++)
            {
                if ( !IS_IDE_DRIVE(ucTargetId) )
                    continue;
                SetDriveFeatures(DeviceExtension, ucTargetId);
            }
            SetPCISpace(DeviceExtension);   // The PCI Space that we stored will have the interrupts disabled as part of PCI Space
            EnableInterrupts(DeviceExtension);
            ucSCSIStatus = ScsiAdapterControlSuccess;
            break;

		case ScsiSetBootConfig:
            ucSCSIStatus = ScsiAdapterControlSuccess;
            break;
		case ScsiSetRunningConfig:
            ucSCSIStatus = ScsiAdapterControlSuccess;
            break;
#endif
		default:
			break;
	}

	return ucSCSIStatus;
}

BOOLEAN SetPCISpace(PHW_DEVICE_EXTENSION DeviceExtension)
{
    ULONG ulPCIDataCount;
    UCHAR uchMRDMODE = 0;
    PBM_REGISTERS BMRegister = NULL;

    for(ulPCIDataCount=0;ulPCIDataCount<PCI_DATA_TO_BE_UPDATED;ulPCIDataCount++)
    {   // Restore the PCI Space (only the bytes that were changed
        WriteToPCISpace(DeviceExtension, 
                        DeviceExtension->aulPCIData[ulPCIDataCount],
                        aPCIDataToBeStored[ulPCIDataCount].ulAndMask,
                        aPCIDataToBeStored[ulPCIDataCount].ulOffset,
                        aPCIDataToBeStored[ulPCIDataCount].ulLength
                        );
    }

    // Begin Vasu - 02 March 2001
    BMRegister = DeviceExtension->BaseBmAddress[0];
    uchMRDMODE = ScsiPortReadPortUchar(((PUCHAR)BMRegister + 1));
    uchMRDMODE &= 0xF0; // Dont Clear Interrupt Pending Flags.
    uchMRDMODE |= 0x01; // Make it Read Multiple
    ScsiPortWritePortUchar(((PUCHAR)BMRegister + 1), uchMRDMODE);
    // End Vasu

#ifdef DBG
    {
        ULONG length;
        for(ulPCIDataCount=0;ulPCIDataCount<PCI_DATA_TO_BE_UPDATED;ulPCIDataCount++)
        {   // take a copy of the data space that is required to restore when we come back from Standby
            length = ReadFromPCISpace(
						    DeviceExtension,
                            &(DeviceExtension->aulPCIData[ulPCIDataCount]),
                            aPCIDataToBeStored[ulPCIDataCount].ulOffset,
						    aPCIDataToBeStored[ulPCIDataCount].ulLength
						    );
        }
    }




    {
        PIDE_REGISTERS_1 baseIoAddress1;
        PIDE_REGISTERS_2 baseIoAddress2;
        ULONG ulDriveNum;
        UCHAR statusByte;
        UCHAR aucIdentifyBuf[512];
        ULONG i;
    	PIDENTIFY_DATA capabilities = (PIDENTIFY_DATA)aucIdentifyBuf;

        for(ulDriveNum=0;ulDriveNum<MAX_DRIVES_PER_CONTROLLER;ulDriveNum++)
        {
            if ( !IS_IDE_DRIVE(ulDriveNum) )
                continue;

		    baseIoAddress1 = (PIDE_REGISTERS_1) DeviceExtension->BaseIoAddress1[(ulDriveNum>>1)];
		    baseIoAddress2 = (PIDE_REGISTERS_2) DeviceExtension->BaseIoAddress2[(ulDriveNum>>1)];

	        //
	        // Select device 0 or 1.
	        //

	        SELECT_DEVICE(baseIoAddress1, ulDriveNum);

	        //
	        // Check that the status register makes sense.
	        //

            // The call came here since there is a drive ... so let us not worry about whether there is any drive at this place
	        GET_BASE_STATUS(baseIoAddress1, statusByte);    

	        //
	        // Load CylinderHigh and CylinderLow with number bytes to transfer.
	        //

	        ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, (0x200 >> 8));
	        ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,  (0x200 & 0xFF));

            WAIT_ON_BUSY(baseIoAddress1, statusByte);

	        //
	        // Send IDENTIFY command.
	        //
	        WAIT_ON_BUSY(baseIoAddress1,statusByte);

	        ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_IDENTIFY);

	        WAIT_ON_BUSY(baseIoAddress1,statusByte);

            if ( ( !( statusByte & IDE_STATUS_BUSY ) ) && ( !( statusByte & IDE_STATUS_DRQ ) ) )
            {
                // this is an error... so let us not try any more.
                FailDrive(DeviceExtension, (UCHAR)ulDriveNum);
                continue;
            }

            WAIT_ON_BUSY(baseIoAddress1,statusByte);

	        //
	        // Wait for DRQ.
	        //

	        for (i = 0; i < 4; i++) 
            {
		        WAIT_FOR_DRQ(baseIoAddress1, statusByte);

		        if (statusByte & IDE_STATUS_DRQ)
                {
                    break;
                }
            }

	        //
	        // Read status to acknowledge any interrupts generated.
	        //

	        GET_BASE_STATUS(baseIoAddress1, statusByte);

	        //
	        // Check for error on really stupid master devices that assert random
	        // patterns of bits in the status register at the slave address.
	        //

	        if ((statusByte & IDE_STATUS_ERROR)) 
            {
                FailDrive(DeviceExtension, (UCHAR)ulDriveNum);
                continue;
	        }

	        DebugPrint((1, "CheckDrivesResponse: Status before read words %x\n", statusByte));

	        //
	        // Suck out 256 words. After waiting for one model that asserts busy
	        // after receiving the Packet Identify command.
	        //

	        WAIT_ON_BUSY(baseIoAddress1,statusByte);

	        if ( (!(statusByte & IDE_STATUS_DRQ)) || (statusByte & IDE_STATUS_BUSY) ) 
            {
                FailDrive(DeviceExtension, (UCHAR)ulDriveNum);
                continue;
	        }

	        READ_BUFFER(baseIoAddress1, (PUSHORT)aucIdentifyBuf, 256);

            DebugPrint((0, "capabilities->AdvancedPioModes : %x on ulDriveNum : %ld\n", (ULONG)capabilities->AdvancedPioModes, ulDriveNum ));
            DebugPrint((0, "capabilities->MultiWordDmaSupport : %x\n", (ULONG)capabilities->MultiWordDmaSupport ));
            DebugPrint((0, "capabilities->MultiWordDmaActive : %x\n", (ULONG)capabilities->MultiWordDmaActive ));
            DebugPrint((0, "capabilities->UltraDmaSupport : %x\n", (ULONG)capabilities->UltraDmaSupport ));
            DebugPrint((0, "capabilities->UltraDmaActive : %x\n", (ULONG)capabilities->UltraDmaActive ));

	        //
	        // Work around for some IDE and one model Atapi that will present more than
	        // 256 bytes for the Identify data.
	        //

	        WAIT_ON_BUSY(baseIoAddress1,statusByte);

	        for (i = 0; i < 0x10000; i++) 
            {
		        GET_STATUS(baseIoAddress1,statusByte);

		        if (statusByte & IDE_STATUS_DRQ) 
                {
			        //
			        // Suck out any remaining bytes and throw away.
			        //

			        ScsiPortReadPortUshort(&baseIoAddress1->Data);

		        } 
                else 
                {
			        break;
		        }
            }
    }

    return TRUE;

    }

#endif

    return TRUE;
}


BOOLEAN StopDrives(PHW_DEVICE_EXTENSION DeviceExtension)
{
	PIDE_REGISTERS_1 baseIoAddress1;
    ULONG ulDrvInd;
    UCHAR ucStatus;

	for(ulDrvInd=0;ulDrvInd<MAX_DRIVES_PER_CONTROLLER;ulDrvInd++)
	{
        if ( IS_IDE_DRIVE(ulDrvInd) )
        {
            FlushCache(DeviceExtension, (UCHAR)ulDrvInd);

            if (DeviceExtension->PhysicalDrive[ulDrvInd].bPwrMgmtSupported)
            {
        	    baseIoAddress1 = DeviceExtension->BaseIoAddress1[ulDrvInd>>1];

                // Issue Stand By Immediate
                SELECT_DEVICE(baseIoAddress1, ulDrvInd);
                WAIT_ON_BASE_BUSY(baseIoAddress1, ucStatus);
    		    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_STANDBY_IMMEDIATE);
                WAIT_ON_BASE_BUSY(baseIoAddress1, ucStatus);
                WAIT_ON_BASE_BUSY(baseIoAddress1, ucStatus);
            }
        }
	}
    return TRUE;
}

BOOLEAN
EnableInterruptsOnAllChannels(
    IN PHW_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG ulController;
    PBM_REGISTERS         BMRegister = NULL;
    UCHAR opcimcr;

    for(ulController=0;ulController<gucControllerCount;ulController++)
    {
         // always take first channels base bm address register
        BMRegister = (gaCardInfo[ulController].pDE)->BaseBmAddress[0];

        //
        // Enable the Interrupt notification so that further interrupts are got.
        // This is done because, there is no interrupt handler at the time
        // before the actual registration of the Int. handler..
        //
        opcimcr = ScsiPortReadPortUchar(((PUCHAR)BMRegister + 1));
        opcimcr &= 0xCF;
        // Begin Vasu - 7 Feb 2001
        // Enable Read Multiple here as this is the place where we write this register back.
        opcimcr &= 0xF0; // Dont Clear Interrupt Pending Flags.
        opcimcr |= 0x01;
        // End Vasu
        ScsiPortWritePortUchar(((PUCHAR)BMRegister + 1), opcimcr);
    }

    return TRUE;
}

BOOLEAN
DisableInterruptsOnAllChannels(
    IN PHW_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG ulController;
    PBM_REGISTERS         BMRegister = NULL;
    UCHAR opcimcr;

    for(ulController=0;ulController<gucControllerCount;ulController++)
    {
         // always take first channels base bm address register
        BMRegister = (gaCardInfo[ulController].pDE)->BaseBmAddress[0];
        //
        // Enable the Interrupt notification so that further interrupts are got.
        // This is done because, there is no interrupt handler at the time
        // before the actual registration of the Int. handler..
        //
        opcimcr = ScsiPortReadPortUchar(((PUCHAR)BMRegister + 1));
        opcimcr |= 0x30;
        // Begin Vasu - 7 Feb 2001
        // Enable Read Multiple here as this is the place where we write this register back.
        opcimcr &= 0xF0; // Dont Clear Interrupt Pending Flags.
        opcimcr |= 0x01;
        // End Vasu
        ScsiPortWritePortUchar(((PUCHAR)BMRegister + 1), opcimcr);
    }

    return TRUE;
}

ULONG ReadFromPCISpace
            (
                PHW_DEVICE_EXTENSION DeviceExtension,
                PULONG pulData,
                ULONG ulPCIConfigIndex,
                ULONG ulLength
            )
// Right now this function can read only DWORDS from PCI Space
{
    ULONG ulPCICode, ulPCIValue;
    ULONG  ulpciBus, ulpciDevice, ulpciFunction;

    ulpciBus = DeviceExtension->BusNumber;
    ulpciDevice = DeviceExtension->PciSlot.u.bits.DeviceNumber;
    ulpciFunction = DeviceExtension->PciSlot.u.bits.FunctionNumber;

    ulPCICode = 0x80000000 | (ulpciFunction<<0x8) | (ulpciDevice<<0xb) | (ulpciBus<<0x10) | (ulPCIConfigIndex);
    _asm 
    {
        push eax
        push edx
        push ebx

        mov edx, 0cf8h
        mov eax, ulPCICode
        out dx, eax

        add dx, 4
        in eax, dx
        mov ulPCIValue, eax

        pop ebx
        pop edx
        pop eax
    }

    DebugPrint((0, "\tRead %x:%x:", ulPCICode, ulPCIValue));

    *pulData = ulPCIValue;

    return ulLength;
}

ULONG WriteToPCISpace
            (
                PHW_DEVICE_EXTENSION DeviceExtension,
                ULONG ulPCIValue,
                ULONG ulAndMask,
                ULONG ulPCIConfigIndex,
                ULONG ulLength
            )
// Right now this function can read only DWORDS from PCI Space
{
    ULONG ulPCICode;
    ULONG ulpciBus, ulpciDevice, ulpciFunction;

    ulpciBus = DeviceExtension->BusNumber;
    ulpciDevice = DeviceExtension->PciSlot.u.bits.DeviceNumber;
    ulpciFunction = DeviceExtension->PciSlot.u.bits.FunctionNumber;

    ulPCICode = 0x80000000 | (ulpciFunction<<0x8) | (ulpciDevice<<0xb) | (ulpciBus<<0x10) | (ulPCIConfigIndex);

    switch (ulPCIConfigIndex)
    {
    case 0x70:
    case 0x78:
        ulAndMask = ulAndMask & (~0xff);
        break;
    }

    DebugPrint((0, "\tWritting %x:%x:", ulPCICode, ulPCIValue));

    _asm 
    {
        push eax
        push edx
        push ebx

        mov edx, 0cf8h
        mov eax, ulPCICode
        out dx, eax

        mov eax, ulPCIValue
        add dx, 4
        in eax, dx

        and eax, ulAndMask
        or eax, ulPCIValue      // read the current value and restore the reserve values
        mov ebx, eax            // take a back up

        sub dx, 4   
        mov eax, ulPCICode      // Select the register again
        out dx, eax

        add dx, 4
        mov eax, ebx
        out dx, eax             // Write the desired value

        pop ebx
        pop edx
        pop eax
    }

    return ulLength;
}

#endif  // #ifdef HYPERDISK_WIN2K
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaraid\bios.h ===
/*
 ****************************************************************************
 *
 * BIOSPROT.H - Defines constants/structures used Megaraid BIOS to pass
 * PCI configuration information to the firmware
 *
 * Written by Adam Weiner
 *
 */

#ifndef  _INCL_BIOSPROT
#define  _INCL_BIOSPROT

/*
//
// type used to represent the 16-bit bit-packed value that
// represents a PCI device's location. This is the same
// format used by the x86 PCI BIOS specification:
//
//  bits 0..2  = Function Number
//  bits 3..7  = Device Number
//  bits 8..15 = Bus Number
//
*/
#ifndef _DEFINED_PCI_LOCATION
#define  _DEFINED_PCI_LOCATION

typedef USHORT t_pcilocation;

/*
//
// these are macros to extract the various PCI location
// fields from a t_pcilocation
//  
*/
#define  PCI_LOCATION_BUS_NUMBER(pciLocation) (pciLocation>>8)
#define  PCI_LOCATION_DEV_NUMBER(pciLocation) (pciLocation>>3 & 0x1F)
#define  PCI_LOCATION_FUNC_NUMBER(pciLocation) (pciLocation & 0x07)

#endif

/*
// These are the two PCI configuration addresses used in the
// BIOS <-> Firmware startup protocol
//
*/
#define  MEGARAID_PROTOCOL_PORT_0xA0    (0xa0)
#define  MEGARAID_PROTOCOL_PORT_0x64    (0x64)


/*
// These are the possible ID's stored by the firmware in 
// MEGARAID_PROTOCOL_PORT_0xA0 during startup. They are used
// by the BIOS to determine the general class of adapter
*/
#define  MEGARAID_BOOT_ID_TRANSPARENT_BRIDGE_ADAPTER    (0xbbbb)
#define  MEGARAID_BOOT_ID_NON_TRANSPARENT_BRIDGE_ADAPTER  (0x3344)

  

/*
// These are the values moved between the BIOS and the firmware to
// signal the various stages of the protocol
//
*/
#define  BIOS_STARTUP_PROTOCOL_NEXT_STRUCTURE_READY          (0x5555)
#define  BIOS_STARTUP_PROTOCOL_FIRMWARE_DONE_PROCESSING_STRUCTURE  (0xAAAA)
#define  BIOS_STARTUP_PROTOCOL_END_OF_BIOS_STRUCTURES        (0x1122)
#define  BIOS_STARTUP_PROTOCOL_FIRMWARE_DONE_SUCCESFUL        (0x4000)
#define  BIOS_STARTUP_PROTOCOL_FIRMWARE_DONE_PCI_CFG_ERROR      (0x4001)

/*
//
// MEGARAID_BIOS_STARTUP_INFO_HEADER.structureId values
//
*/
#define  MEGARAID_STARTUP_STRUCTYPE_PCI      (0x01)  /* MEGARAID_BIOS_STARTUP_INFO_PCI */

typedef  struct _MEGARAID_BIOS_STARTUP_INFO_HEADER {
  USHORT  structureId;            /* 0x00 - constant describing the type of structure that follows header */
  USHORT  structureRevision;          /* 0x02 - revision of the specific structure type */
  USHORT  structureLength;          /* 0x04 - length of the structure (including this header) */
  USHORT  reserved;              /* 0x06 - reserved */
} MEGARAID_BIOS_STARTUP_INFO_HEADER, *PMEGARAID_BIOS_STARTUP_INFO_HEADER;


/*
//
// structure built by the Megaraid BIOS, containing the
// PCI configuration of the i960 ATU and the SCSI chips
// on the board. The SCSI chips in 'scsiChipInfo[]'
// are guaranteed to be in ascending order of device
// ID
//
*/
#define  MEGARAID_STARTUP_PCI_INFO_STRUCTURE_REVISION  (0)  /* MEGARAID_BIOS_STARTUP_INFO_PCI.h.structureRevision */
#define  COUNT_PCI_BASE_ADDR_REGS      (6)  /* per PCI spec */

typedef struct _MEGARAID_BIOS_STARTUP_INFO_PCI {/* MEGARAID_STARTUP_STRUCTYPE_PCI */

  MEGARAID_BIOS_STARTUP_INFO_HEADER  h;    /* 0x00 - header */
  t_pcilocation  atuPciLocation;        /* 0x08 - PCI location of ATU */
  USHORT      atuSubSysDeviceId;      /* 0x0A - subsystem device ID of the ATU */
  USHORT      scsiChipCount;        /* 0x0C - number of SCSI chips located on this board */
  UCHAR      reserved2[34];        /* 0x0E - reserved for future use */
  struct _MEGARAID_PCI_SCSI_CHIP_INFO {    /* 0x30, 0x60, 0x90, etc... */
    USHORT    vendorId;        /* 0x30 - vendor ID of SCSI chip */
    USHORT    deviceId;        /* 0x32 - device ID of SCSI chip */
    t_pcilocation  pciLocation;      /* 0x34 - PCI location of SCSI CHIP (0..2 = Function #, 3..7 = Device #, 8..15 = Bus #) */
    USHORT    reserved3;      /* 0x36 - reserved/padding */
    ULONG    baseAddrRegs[COUNT_PCI_BASE_ADDR_REGS];  /* 0x38 - base address regsiters (PCI config locations 0x10-0x28) */
    UCHAR    reserved[16];      /* 0x50 - reserved */
  } scsiChipInfo[4];              /* 0x60 */
} MEGARAID_BIOS_STARTUP_INFO_PCI, *PMEGARAID_BIOS_STARTUP_INFO_PCI;


#endif /* #ifndef _INCL_BIOSPROT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaide\ioctl.c ===
#ifndef _IOCTL_IMPLEMENTATION_
#define _IOCTL_IMPLEMENTATION_

#define     DRIVER_COMPILATION

extern LONG
AtapiStringCmp (
	PCHAR FirstStr,
	PCHAR SecondStr,
	ULONG Count
);

#include "RIIOCtl.h"
#include "ErrorLog.h"
#include "Raid.h"
#include "HyperDisk.h"

#define DRIVER_MAJOR_VERSION        1
#define DRIVER_MINOR_VERSION        1

#define HYPERDSK_MAJOR_VERSION        2
#define HYPERDSK_MINOR_VERSION        5
#define HYPERDSK_BUILD_VERSION        20010328


ULONG
FillRaidInfo(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG ulStatus, ulDriveNum, ulLInd, ulPInd, ulDrvInd, ulTemp, ulOutDrvInd, ulDrvCounter;
    BOOLEAN bFound;
    PSRB_IO_CONTROL pSrb = (PSRB_IO_CONTROL)(Srb->DataBuffer);
    PIDE_RAID_INFO pInOutInfo = (PIDE_RAID_INFO)((PSRB_BUFFER)(Srb->DataBuffer))->caDataBuffer;

    if ( AtapiStringCmp( 
                pSrb->Signature, 
                IDE_RAID_SIGNATURE,
                strlen(IDE_RAID_SIGNATURE))) 
    {
        ulStatus = SRB_STATUS_ERROR;
        goto FillRaidInfoDone;
    }

    ulDriveNum = pInOutInfo->ulTargetId;

    if ( ulDriveNum >= MAX_DRIVES_PER_CONTROLLER )
    {
        ulStatus = SRB_STATUS_ERROR;
        goto FillRaidInfoDone;
    }

    AtapiFillMemory((PCHAR)pInOutInfo, sizeof(IDE_RAID_INFO), 0);

    if ( !DeviceExtension->IsLogicalDrive[ulDriveNum] )
    {
        if ( DeviceExtension->IsSingleDrive[ulDriveNum] )
        {
            pInOutInfo->cMajorVersion       = DRIVER_MAJOR_VERSION;
            pInOutInfo->cMinorVersion       = DRIVER_MINOR_VERSION;
            pInOutInfo->ulDriveSize         = DeviceExtension->PhysicalDrive[ulDriveNum].Sectors / 2;
            pInOutInfo->ulMode              = None;
            pInOutInfo->ulTotalSize         = DeviceExtension->PhysicalDrive[ulDriveNum].Sectors / 2;
            pInOutInfo->ulStripeSize        = 0;
            pInOutInfo->ulStripesPerRow     = 1;
            pInOutInfo->ulTotDriveCnt       = 1;
		    pInOutInfo->ulStatus            = 0;
            pInOutInfo->ulArrayId           = INVALID_ARRAY_ID;
// edm June 8, 2000 start
			pInOutInfo->ulTargetId			= Srb->TargetId;
// edm June 8,, 2000 add
            ulStatus                        = SRB_STATUS_SUCCESS;

            ulDrvInd = ulDriveNum;
            ulOutDrvInd = 0;

            for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_MODEL_LENGTH;ulTemp+=2)
            {
                pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[ulTemp] = 
				               ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].ModelNumber)[ulTemp+1];

                pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[ulTemp+1] = 
				               ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].ModelNumber)[ulTemp];
            }

            pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[PHYSICAL_DRIVE_MODEL_LENGTH - 1] = '\0';

            for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_SERIAL_NO_LENGTH;ulTemp+=2)
            {
                pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[ulTemp] = 
				               ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].SerialNumber)[ulTemp+1];

                pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[ulTemp+1] = 
				               ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].SerialNumber)[ulTemp];
            }

            pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[PHYSICAL_DRIVE_SERIAL_NO_LENGTH - 1] = '\0';

            pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR)( (TARGET_ID_2_CONNECTION_ID(ulDrvInd)) | (DeviceExtension->ucControllerId << 5) );
            pInOutInfo->phyDrives[ulOutDrvInd].TransferMode = DeviceExtension->TransferMode[ulDrvInd];

		    pInOutInfo->phyDrives[ulOutDrvInd].ulPhySize           = DeviceExtension->PhysicalDrive[ulDriveNum].OriginalSectors / 2; // In KB
		    pInOutInfo->phyDrives[ulOutDrvInd].ucIsPhyDrvPresent   = TRUE;

            // Begin Vasu 09 Aug 2000
            // Updated Fix from Syam's Fix for ATA100 Release 1
            if ( DeviceExtension->PhysicalDrive[ulDriveNum].TimeOutErrorCount < MAX_TIME_OUT_ERROR_COUNT )
            {
    		    pInOutInfo->phyDrives[ulOutDrvInd].ucIsPowerConnected  = TRUE;
            }
            else
            {
                if (DeviceExtension->bInvalidConnectionIdImplementation)
                {
                    pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR) INVALID_CHANNEL_ID;
                }
            }
            // End Vasu.

            if ( DeviceExtension->TransferMode[ulDriveNum] >= UdmaMode3 )
		        pInOutInfo->phyDrives[ulOutDrvInd].ucIs80PinCable      = TRUE;

		    pInOutInfo->phyDrives[ulOutDrvInd].ulBaseAddress1 = (ULONG)DeviceExtension->BaseIoAddress1[ulDriveNum>>1];
		    pInOutInfo->phyDrives[ulOutDrvInd].ulAltAddress2 = (ULONG)DeviceExtension->BaseIoAddress2[ulDriveNum>>1];
		    pInOutInfo->phyDrives[ulOutDrvInd].ulbmAddress = (ULONG)DeviceExtension->BaseBmAddress[ulDriveNum>>1];
		    pInOutInfo->phyDrives[ulOutDrvInd].ulIrq = DeviceExtension->ulIntLine;
            pInOutInfo->phyDrives[ulOutDrvInd].ucControllerId = DeviceExtension->ucControllerId;

        }
        else
            ulStatus = SRB_STATUS_ERROR; // Hey there is no drive with this Target Id
    }
    else
    {
        pInOutInfo->cMajorVersion       = DRIVER_MAJOR_VERSION;
        pInOutInfo->cMinorVersion       = DRIVER_MINOR_VERSION;
        pInOutInfo->ulDriveSize         = DeviceExtension->LogicalDrive[ulDriveNum].Sectors / 
                                    ( 2 * DeviceExtension->LogicalDrive[ulDriveNum].StripesPerRow );
        pInOutInfo->ulMode              = DeviceExtension->LogicalDrive[ulDriveNum].RaidLevel;
        pInOutInfo->ulTotalSize         = DeviceExtension->LogicalDrive[ulDriveNum].Sectors / 2;
        pInOutInfo->ulStripeSize        = DeviceExtension->LogicalDrive[ulDriveNum].StripeSize;
        pInOutInfo->ulStripesPerRow     = DeviceExtension->LogicalDrive[ulDriveNum].StripesPerRow;
        pInOutInfo->ulTotDriveCnt       = DeviceExtension->LogicalDrive[ulDriveNum].PhysicalDriveCount;
		pInOutInfo->ulStatus            = DeviceExtension->LogicalDrive[ulDriveNum].Status;
        pInOutInfo->ulArrayId           = DeviceExtension->LogicalDrive[ulDriveNum].ulArrayId;
// edm June 8, 2000 start
		pInOutInfo->ulTargetId			= Srb->TargetId;
// edm June 8, 2000 end
        ulStatus                        = SRB_STATUS_SUCCESS;
    }

    ulOutDrvInd = 0;

    for(ulDrvCounter=0;ulDrvCounter<DeviceExtension->LogicalDrive[ulDriveNum].StripesPerRow;ulDrvCounter++)
    {
        ULONG ulTempId;

        ulTempId = ulDrvInd = DeviceExtension->LogicalDrive[ulDriveNum].PhysicalDriveTid[ulDrvCounter];

        pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR)( (TARGET_ID_2_CONNECTION_ID(ulDrvInd)) | (DeviceExtension->ucControllerId << 5) );

        for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_MODEL_LENGTH;ulTemp+=2)
        {
            pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[ulTemp] = 
						   ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].ModelNumber)[ulTemp+1];

            pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[ulTemp+1] = 
						   ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].ModelNumber)[ulTemp];
        }

        pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[PHYSICAL_DRIVE_MODEL_LENGTH - 1] = '\0';

        for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_SERIAL_NO_LENGTH;ulTemp+=2)
        {
            pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[ulTemp] = 
						   ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].SerialNumber)[ulTemp+1];

            pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[ulTemp+1] = 
						   ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].SerialNumber)[ulTemp];
        }

        pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[PHYSICAL_DRIVE_SERIAL_NO_LENGTH - 1] = '\0';

        pInOutInfo->phyDrives[ulOutDrvInd].ulPhyStatus = DeviceExtension->PhysicalDrive[ulDrvInd].Status;

        pInOutInfo->phyDrives[ulOutDrvInd].TransferMode = DeviceExtension->TransferMode[ulDrvInd];

		pInOutInfo->phyDrives[ulOutDrvInd].ulPhySize           = DeviceExtension->PhysicalDrive[ulDrvInd].OriginalSectors / 2;  // In KB
		pInOutInfo->phyDrives[ulOutDrvInd].ucIsPhyDrvPresent   = TRUE;

        // Begin Vasu 09 Aug 2000
        // Updated Fix from Syam's Fix for ATA100 Release 1
        if ( DeviceExtension->PhysicalDrive[ulDrvInd].TimeOutErrorCount < MAX_TIME_OUT_ERROR_COUNT )
        {
    		pInOutInfo->phyDrives[ulOutDrvInd].ucIsPowerConnected  = TRUE;
        }
        else
        {
            if (DeviceExtension->bInvalidConnectionIdImplementation)
            {
                pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR) INVALID_CHANNEL_ID;
            }
        }
        // End Vasu.

        if ( DeviceExtension->TransferMode[ulDrvInd] >= UdmaMode3 )
		    pInOutInfo->phyDrives[ulOutDrvInd].ucIs80PinCable      = TRUE;

        pInOutInfo->phyDrives[ulOutDrvInd].ulBaseAddress1 = (ULONG)DeviceExtension->BaseIoAddress1[ulDrvInd>>1];
		pInOutInfo->phyDrives[ulOutDrvInd].ulAltAddress2 = (ULONG)DeviceExtension->BaseIoAddress2[ulDrvInd>>1];
		pInOutInfo->phyDrives[ulOutDrvInd].ulbmAddress = (ULONG)DeviceExtension->BaseBmAddress[ulDrvInd>>1];
		pInOutInfo->phyDrives[ulOutDrvInd].ulIrq = DeviceExtension->ulIntLine;

        if  ((Raid1 == DeviceExtension->LogicalDrive[ulDriveNum].RaidLevel) ||
             (Raid10 == DeviceExtension->LogicalDrive[ulDriveNum].RaidLevel))
        {
            if  (   (DeviceExtension->PhysicalDrive[ulDrvInd].ucMirrorDriveId != INVALID_DRIVE_ID) && 
                    ( (DeviceExtension->PhysicalDrive[ulDrvInd].ucMirrorDriveId & (~DRIVE_OFFLINE)) < MAX_DRIVES_PER_CONTROLLER )
                )
            {
                if (Raid1 == DeviceExtension->LogicalDrive[ulDriveNum].RaidLevel)
                    pInOutInfo->ulStripeSize = 0;

                ulTempId = ulDrvInd = (DeviceExtension->PhysicalDrive[ulDrvInd].ucMirrorDriveId) & 0x7f;
                ulOutDrvInd++;

                pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR)( (TARGET_ID_2_CONNECTION_ID(ulDrvInd)) | (DeviceExtension->ucControllerId << 5) );

                for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_MODEL_LENGTH;ulTemp+=2)
                {
                    pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[ulTemp] = 
						           ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].ModelNumber)[ulTemp+1];

                    pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[ulTemp+1] = 
						           ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].ModelNumber)[ulTemp];
                }

                pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[PHYSICAL_DRIVE_MODEL_LENGTH - 1] = '\0';

                for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_SERIAL_NO_LENGTH;ulTemp+=2)
                {
                    pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[ulTemp] = 
						           ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].SerialNumber)[ulTemp+1];

                    pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[ulTemp+1] = 
						           ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].SerialNumber)[ulTemp];
                }

                pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[PHYSICAL_DRIVE_SERIAL_NO_LENGTH - 1] = '\0';

                pInOutInfo->phyDrives[ulOutDrvInd].ulPhyStatus = DeviceExtension->PhysicalDrive[ulDrvInd].Status;

                pInOutInfo->phyDrives[ulOutDrvInd].TransferMode = DeviceExtension->TransferMode[ulDrvInd];

		        pInOutInfo->phyDrives[ulOutDrvInd].ulPhySize           = DeviceExtension->PhysicalDrive[ulDrvInd].OriginalSectors / 2; // In KB
		        pInOutInfo->phyDrives[ulOutDrvInd].ucIsPhyDrvPresent   = TRUE;

                // Begin Vasu 09 Aug 2000
                // Updated Fix from Syam's Fix for ATA100 Release 1
                if ( DeviceExtension->PhysicalDrive[ulDrvInd].TimeOutErrorCount < MAX_TIME_OUT_ERROR_COUNT )
                {
    		        pInOutInfo->phyDrives[ulOutDrvInd].ucIsPowerConnected  = TRUE;
                }
                else
                {
                    if (DeviceExtension->bInvalidConnectionIdImplementation)
                    {
                        pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR) INVALID_CHANNEL_ID;
                    }
                }
                // End Vasu.

                if ( DeviceExtension->TransferMode[ulDrvInd] >= UdmaMode3 )
		            pInOutInfo->phyDrives[ulOutDrvInd].ucIs80PinCable      = TRUE;

                pInOutInfo->phyDrives[ulOutDrvInd].ulBaseAddress1 = (ULONG)DeviceExtension->BaseIoAddress1[ulDrvInd>>1];
		        pInOutInfo->phyDrives[ulOutDrvInd].ulAltAddress2 = (ULONG)DeviceExtension->BaseIoAddress2[ulDrvInd>>1];
		        pInOutInfo->phyDrives[ulOutDrvInd].ulbmAddress = (ULONG)DeviceExtension->BaseBmAddress[ulDrvInd>>1];
		        pInOutInfo->phyDrives[ulOutDrvInd].ulIrq = DeviceExtension->ulIntLine;

            }
            else
            {
                if ((Raid1 == DeviceExtension->LogicalDrive[ulDriveNum].RaidLevel) ||
                    (Raid10 == DeviceExtension->LogicalDrive[ulDriveNum].RaidLevel))
                {
                    ++ulOutDrvInd;
                    pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR)INVALID_CONNECTION_ID;
                    pInOutInfo->phyDrives[ulOutDrvInd].ulPhyStatus = PDS_Failed;
                }
            }
        }

        ulOutDrvInd++;
    }

    for (ulPInd = 0; ulPInd < pInOutInfo->ulTotDriveCnt; ulPInd++)
    {
        ulDrvInd = GET_TARGET_ID(pInOutInfo->phyDrives[ulPInd].cChannelID);

        if (DeviceExtension->IsSpareDrive[ulDrvInd])
        {
            UCHAR uchChannelID = pInOutInfo->phyDrives[ulPInd].cChannelID;
            ULONG ulStatus = pInOutInfo->phyDrives[ulPInd].ulPhyStatus;
            AtapiFillMemory((PUCHAR)&(pInOutInfo->phyDrives[ulPInd]), sizeof(PHY_DRIVE_INFO), 0);
            pInOutInfo->phyDrives[ulPInd].ulPhyStatus = ulStatus;
            pInOutInfo->phyDrives[ulPInd].cChannelID = uchChannelID;
        }
    }

FillRaidInfoDone:
    return ulStatus;
}   // FillRaidInfo


ULONG SetLogicalDriveStatus(IN PHW_DEVICE_EXTENSION DeviceExtension,
                            IN UCHAR LogDrvId,
                            IN UCHAR PhyDrvId,
                            IN UCHAR LogDrvStatus,
                            IN UCHAR PhyDrvStatus,
                            IN UCHAR Flags)
/*++


SetLogicalDriveStatus

Set logical and/or physical drive status based on flag as fellow:
 Flags: 
     0: logical drive
     1: physical drive
     2: both

--*/
{
	SET_DRIVE_STATUS_TYPE type = Flags;
	int i;

    LogDrvId = (UCHAR)DeviceExtension->PhysicalDrive[PhyDrvId].ucLogDrvId;
    // Logical Drive Id may get changed since the Application will not be 
    // active always and when parsing IRCD the LogicalDrive Id will be
    // decided based on the first GOOD physical Drive Id... So application 
    // and Driver will think in different way.

	// set logical drive status
    if ( LogDrvId < MAX_DRIVES_PER_CONTROLLER )
    {
	    // set logical drive status
	    if ((SDST_Both == type) || (SDST_Logical == type)) 
        {
            DeviceExtension->LogicalDrive[LogDrvId].Status = LogDrvStatus;
	    }
    }

	// set physical drive status
	if ((SDST_Both == type) || (SDST_Physical == type)) {
	    DeviceExtension->PhysicalDrive[PhyDrvId].Status = PhyDrvStatus;
	}

	if (LDS_Degraded == LogDrvStatus)
	{
        DeviceExtension->RebuildInProgress = 1;
	}

	if (LDS_Online == LogDrvStatus)
	{
        DeviceExtension->RebuildInProgress = 0;
        DeviceExtension->RebuildWaterMarkSector = 0;
        DeviceExtension->RebuildWaterMarkLength = 0;
	}

	//
	// set error flag
	//
	SetStatusChangeFlag(DeviceExtension, IDERAID_STATUS_FLAG_UPDATE_DRIVE_STATUS);

    return SRB_STATUS_SUCCESS;
}

/////////////////////////////////////////////////////////////////
//
// ChangeMirrorDrive
//
// Bad drive to failed
// Good drive to rebuilding
//
// Assumption: always replace the mirroring drive
//
/////////////////////////////////////////////////////////////////
ULONG ChangeMirrorDrive(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR LogDrvId,
    IN UCHAR BadPhyDrvId,
    IN UCHAR GoodPhyDrvId
)
{
    ULONG ulTempInd;
    UCHAR ucPriDrvId, ucMirrorDrvId;

    LogDrvId = (UCHAR)DeviceExtension->PhysicalDrive[LogDrvId].ucLogDrvId;
    // anyway hyper rebuild application is sending physical drive id of good drive id
    // let us use this for finding out the logical drive information

    // Logical Drive Id may get changed since the Application will 
    // not be active always and when parsing IRCD the LogicalDrive Id will be
    // decided based on the first GOOD physical Drive Id... So application 
    // and Driver will think in different way.
    
    for(ulTempInd=0;ulTempInd<DeviceExtension->LogicalDrive[LogDrvId].StripesPerRow;ulTempInd++) 
    {
		// get the primary phy drive id and its mirror drive id
		ucPriDrvId = DeviceExtension->LogicalDrive[LogDrvId].PhysicalDriveTid[ulTempInd];
        ucMirrorDrvId = DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId & (~DRIVE_OFFLINE);

		if ((ucMirrorDrvId >= MAX_DRIVES_PER_CONTROLLER) ||
			(BadPhyDrvId == ucMirrorDrvId)) 
        {
            // set the primary drive's mirror drive id to GoodDrv Id
            DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId = GoodPhyDrvId;

            // set the good drvs's mirror drive as primary drive
            DeviceExtension->PhysicalDrive[GoodPhyDrvId].ucMirrorDriveId = ucPriDrvId;

            DeviceExtension->PhysicalDrive[GoodPhyDrvId].ucLogDrvId = DeviceExtension->PhysicalDrive[ucPriDrvId].ucLogDrvId;

            if ( BadPhyDrvId < MAX_DRIVES_PER_CONTROLLER)
                DeviceExtension->PhysicalDrive[BadPhyDrvId].ucLogDrvId = INVALID_CONNECTION_ID;

			if (ucMirrorDrvId < MAX_DRIVES_PER_CONTROLLER)
	            // set the bad drive's status to FAILED
	            DeviceExtension->PhysicalDrive[ucMirrorDrvId].Status = PDS_Failed;

            // set the good drvs's status to REBUILDING
            DeviceExtension->PhysicalDrive[GoodPhyDrvId].Status = PDS_Rebuilding;
            DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId |= DRIVE_OFFLINE;

            break;
		}
    } // end for loop

    return SRB_STATUS_SUCCESS;
}

/////////////////////////////////////////////////////////////////
//
//  ChangeMirrorDriveStatus
//  
//  If setting the primary drive to non working condition
//      swaps the drives and set the mirror drive to offline
//  If setting the mirror drive
//      set its status and online flags respectively
//
//  Assumption: at least one drive must be in working condition
//
/////////////////////////////////////////////////////////////////
ULONG ChangeMirrorDriveStatus(  
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR LogDrvId,
    IN UCHAR PhyDrvId,
    IN UCHAR PhyDrvStatus
)
{
    ULONG ulTempInd;
    UCHAR ucPriDrvId, ucMirrorDrvId;

    if ( PhyDrvId >= MAX_DRIVES_PER_CONTROLLER )   // may be a drive id that is not present in the system (like INVALID_CONNECTION_ID)
        return SRB_STATUS_SUCCESS; 

    LogDrvId = (UCHAR)DeviceExtension->PhysicalDrive[PhyDrvId].ucLogDrvId;
    // Logical Drive Id may get changed since the Application will not be 
    // active always and when parsing IRCD the LogicalDrive Id will be
    // decided based on the first GOOD physical Drive Id... So application 
    // and Driver will think in different way.

    // Set status
    DeviceExtension->PhysicalDrive[PhyDrvId].Status = PhyDrvStatus;
    
    
    for(ulTempInd=0;ulTempInd<DeviceExtension->LogicalDrive[LogDrvId].StripesPerRow;ulTempInd++) 
    {
		// get the primary phy drive id and its mirror drive id
		ucPriDrvId = DeviceExtension->LogicalDrive[LogDrvId].PhysicalDriveTid[ulTempInd];
        ucMirrorDrvId = (DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId) & (~DRIVE_OFFLINE);

        // if setting the primary drive to non working condition
        if ((PhyDrvId == ucPriDrvId) &&
            (PDS_Online != PhyDrvStatus) && (PDS_Critical != PhyDrvStatus)) 
        {
            if ( INVALID_DRIVE_ID != DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId )
            {   // if the mirror drive exists
                // put the mirror drive to the primary position
                // set the new primary's mirror drive to offline flag
                //
                DeviceExtension->LogicalDrive[LogDrvId].PhysicalDriveTid[ulTempInd] = ucMirrorDrvId;
			    DeviceExtension->PhysicalDrive[ucMirrorDrvId].ucMirrorDriveId |= DRIVE_OFFLINE;
                break;
            }
        } 
        else
        {
            // if setting the mirror drive status
            if (PhyDrvId == ucMirrorDrvId) 
            {
                if ((PDS_Online == PhyDrvStatus) ||
				    (PDS_Critical == PhyDrvStatus))
				    // if setting the status to working condition
        		    DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId &= ~DRIVE_OFFLINE;

                else
				    // setting the status to non-working condition
        		    DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId |= DRIVE_OFFLINE;

                break;
             } 
        }
    }

	//
	// set error flag
	//
	SetStatusChangeFlag(DeviceExtension, IDERAID_STATUS_FLAG_UPDATE_DRIVE_STATUS);

    return SRB_STATUS_SUCCESS;
}

ULONG
GetRAIDDriveCapacity(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK  Srb
)
/*++

Routine Description:

    This routine returns the drive capacity in the form of the Last accessible
    sector number.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	Srb - IO request packet

Return Value:

    SRB Status as ULONG.

--*/
{
    ULONG ulStatus = SRB_STATUS_SUCCESS;

    PIDERAID_DISK_CAPACITY_INFO pDataBuffer = NULL;
    PSRB_IO_CONTROL pSrb = NULL;

    DebugPrint((1, "Entering GetRAIDDriveCapacity routine\n"));

    pSrb = (PSRB_IO_CONTROL)(Srb->DataBuffer);
    pDataBuffer = (PIDERAID_DISK_CAPACITY_INFO)(((PSRB_BUFFER)(Srb->DataBuffer))->caDataBuffer);

    if ( AtapiStringCmp( 
                pSrb->Signature, 
                IDE_RAID_SIGNATURE,
                strlen(IDE_RAID_SIGNATURE))) 
    {
        ulStatus = SRB_STATUS_ERROR;
    }
    else
    {
        if ((pDataBuffer->uchTargetID < 0) ||     // Cannot exceed max. drives
            (pDataBuffer->uchTargetID > MAX_DRIVES_PER_CONTROLLER)) // supported.
        {
            // Capacity for a drive that is not present is asked.
            ulStatus = SRB_STATUS_NO_DEVICE;
        }
        else
        {
            pDataBuffer->ulLastSector = 
                (DeviceExtension->PhysicalDrive[pDataBuffer->uchTargetID]).Sectors;
            ulStatus = SRB_STATUS_SUCCESS;
        }

        DebugPrint((1, "GetRAIDDriveCapacity : LastSector : %d\n", pDataBuffer->ulLastSector));
    }
       
    return ulStatus;
}

ULONG
GetStatusChangeFlag(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK  Srb
)
/*++

Routine Description:

    This routine returns the driver status flag which includes error logs and drive status changes.
	After fetching the flag, this routine resets the flag.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	Srb - IO request packet

Return Value:

    SRB Status as ULONG.

--*/
{
    PGET_STATUS_CHANGE_FLAG pData;

    DebugPrint((3, "Entering GetStatusChangeFlag routine\n"));

    pData = (PGET_STATUS_CHANGE_FLAG) (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

    pData->ulUpdateFlag = (ULONG) gucStatusChangeFlag;

	// reset the update flag
	gucStatusChangeFlag = 0x0;

    return SRB_STATUS_SUCCESS;
}


VOID
SetStatusChangeFlag(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR			    TheNewStatus
)
{
    DebugPrint((3, "Entering SetStatusChangeFlag routine\n"));
    gucStatusChangeFlag |= TheNewStatus;
}


BOOLEAN
GetIRCDLogicalDriveInd(
    PUCHAR RaidInfoSector,
    UCHAR ucPhyDrvId,
    PUCHAR pucLogDrvInd,
    PUCHAR pucPhyDrvInd,
    PUCHAR pucSpareDrvPoolInd
)
{
    PIRCD_HEADER pRaidHeader = (PIRCD_HEADER)RaidInfoSector;
    PIRCD_LOGICAL_DRIVE pRaidLogDrive = (PIRCD_LOGICAL_DRIVE)GET_FIRST_LOGICAL_DRIVE(pRaidHeader);
    BOOLEAN bFound = FALSE;
    ULONG ulLogDrvInd, ulDrvInd;
    PIRCD_PHYSICAL_DRIVE pPhyDrive;

    for(ulLogDrvInd=0;ulLogDrvInd<pRaidHeader->NumberOfLogicalDrives;ulLogDrvInd++)
    {
        if ( SpareDrivePool == pRaidLogDrive[ulLogDrvInd].LogicalDriveType )
        {
            *pucSpareDrvPoolInd = (UCHAR)ulLogDrvInd;
            continue;       // let us not worry about SpareDrivePool
        }

	    pPhyDrive = (PIRCD_PHYSICAL_DRIVE)((char *)pRaidHeader + pRaidLogDrive[ulLogDrvInd].FirstStripeOffset);

		for(ulDrvInd=0;ulDrvInd<pRaidLogDrive[ulLogDrvInd].NumberOfDrives;ulDrvInd++)
		{
            if (pPhyDrive[ulDrvInd].ConnectionId == (ULONG)ucPhyDrvId)
            {
                *pucPhyDrvInd = (UCHAR)ulDrvInd;
                *pucLogDrvInd = (UCHAR)ulLogDrvInd;
                bFound = TRUE;
                break;
            }
        }
    }

    return bFound;
}

#endif // _IOCTL_IMPLEMENTATION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaraid\const.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = Const.h                                      */
/* FUNCTION         = Header file all const value and flags;       */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = American MegaTrends Inc. All rights reserved;*/
/*                                                                 */
/*******************************************************************/
#ifndef _CONST_H
#define _CONST_H


#define MAX_RETRY    3
//
//define other options
//
#define CHEYENNE_BUG_CORRECTION	1

#define TOSHIBA						1
//#define MRAID_762					1
#define MRAID_SYNC				1

#define MRAID_TIMEOUT					1
// #define TOSHIBA_SFR				1 
// #define MRAID_SFR_DEBUG		1 

#define COALESE_COMMANDS				1

//#define AMILOGIC        				0


#define ONE_MEGA_BYTE							(1024L * 1024L)
#define FOUR_KILO_BYTE						(1024L * 4L)
#define FOUR_KB										(4 * 1024)

#define MAXIMUM_TRANSFER_LENGTH		(2L * ONE_MEGA_BYTE)
#define MAXIMUM_SGL_DESCRIPTORS   63

#ifdef  CHEYENNE_BUG_CORRECTION		
		#define DEFAULT_SGL_DESCRIPTORS					17
		#define DEFAULT_TRANSFER_LENGTH					(64L * 1024) //64k 
#else		
		#define DEFAULT_SGL_DESCRIPTORS					16
		#define DEFAULT_TRANSFER_LENGTH					0x0f000
#endif

#define MINIMUM_TRANSFER_LENGTH	(DEFAULT_SGL_DESCRIPTORS * FOUR_KILO_BYTE)

#define	FW_8SPAN_DEPTH				8
#define	FW_4SPAN_DEPTH				4
#define FW_UNKNOWNSPAN_DEPTH	0xff

#define MAX_DEVICE_DEPTH		8		/* Maximum device depth allowed */
//#define MAX_ROW_SIZE				8		/* Maximum number of stripes in a row */
#define MAX_STRIPES					8

#define STRIPE_SIZE_8K			16 //16 512byte blocks
#define STRIPE_SIZE_16K			32
#define STRIPE_SIZE_32K			64
#define STRIPE_SIZE_64K			128
#define STRIPE_SIZE_128K		0 //256 blocks 

#define STRIPE_SIZE_UNKNOWN 255


//
//structure update states
//
#define UPDATE_STATE_ADAPTER_INQUIRY		1
#define UPDATE_STATE_DISK_ARRAY					2
#define UPDATE_STATE_NONE								0


#define MAX_LOGICAL_DRIVES       40
#define MAX_SPAN_DEPTH           8
#define MAX_ROW_SIZE             32

#define MAX_ISP                  2
#define MAX_CHANNELS             16
#define MAX_TARGETS_PER_CHANNEL  16
#define MAX_PHYSICAL_DEVICES     256
#define MAX_LUN_PER_TARGET       8

#define MAX_ROW_SIZE_40LD              32

//currently = 256 . Defined in fw_struc.h
#define MAX_PHYSICAL_DEVICES_40LD     MAX_PHYSICAL_DEVICES 


#define MAX_LOGICAL_DRIVES_40	40
#define MAX_LOGICAL_DRIVES_8  8

#define MAX_ROW_SIZE_8LD             8

#define MAX_CHANNELS_8LD             5
#define MAX_TARGETS_PER_CHANNEL_8LD  16

//currently = 75
#define MAX_PHYSICAL_DEVICES_8LD     \
        ((MAX_CHANNELS_8LD * MAX_TARGETS_PER_CHANNEL_8LD)-(MAX_CHANNELS_8LD))

//READ64 and WRITE64
#define MRAID_READ_LARGE_MEMORY     (0xA7)
#define MRAID_WRITE_LARGE_MEMORY    (0xA8)

#define UNKNOWN_DEVICE              (0x1F)
#define UNKNOWN_DEVICE_TARGET_ID    (0x0F)
#define UNKNOWN_DEVICE_LUN          (0x00)

#define OEM_VENDOR_AMI    "MEGARAID"
#define OEM_VENDOR_HP     "HPNetRD "
#define OEM_VENDOR_SDI    "RAIDCard"
#define OEM_VENDOR_ADAC   "ADAC    "
#define OEM_VENDOR_TRAC   "TRAC    "
#define OEM_VENDOR_DELL   "PERC    "

#define OEM_PRODUCT_AMI    " LD XY MEGARAID "
#define OEM_PRODUCT_HP     " LD XY NetRAID  "
#define OEM_PRODUCT_DELL   " LD XY PERCRAID "
#define OEM_PRODUCT_ID     " LD XY RAID     "

#define SUBSYSTEM_VENDOR_AMI      (0x101E)
#define SUBSYSTEM_VENDOR_HP       (0x103C)
#define SUBSYSTEM_VENDOR_DELL     (0x1111)
#define SUBSYSTEM_VENDOR_EP_DELL  (0x1028)
#define OLD_DELL_DEVICE_ID        (0x09A0)


#define DEFAULT_INITIATOR_ID       (0x7)

#define MEGARAID_SUCCESS            (0x0)
#define MEGARAID_FAILURE            (0x1)

#define MRAID_SECTOR_SIZE           (512)

#define MRAID_INVALID_HOST_ADDRESS  (0xFFFFFFFF)

#define DEC_BRIDGE_DEVICE_ID  (0x0026)
#define DEC_BRIDGE_VENDOR_ID  (0x1011)

#define AMILOGIC_CHIP_DEVICE_ID  (0x1216)
#define AMILOGIC_CHIP_VENDOR_ID  (0x1077)
//New vendorID and deviceID of DEC Bridge 21154.
#define DEC_BRIDGE_VENDOR_ID2  (0x8086)
#define DEC_BRIDGE_DEVICE_ID2  (0xB154)

#define MAX_AMILOGIC_CHIP_COUNT   (2)

#define TWO                        2

#ifdef _WIN64
#define MEGARAID_PAGE_SIZE  0x2000
#else
#define MEGARAID_PAGE_SIZE  0x1000
#endif

#define SUBSYTEM_DEVICE_ID_ELITE1600       0x0493
#define SUBSYTEM_DEVICE_ID_ENTERPRISE1600  0x0471
#define SUBSYTEM_DEVICE_ID_EXPRESS500      0x0475






#endif //_CONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaide\startio.c ===
#ifdef KEEP_LOG
ULONG ulStartLog = 0;   // boolean variable to decide whether to start log or not

typedef struct _COMMAND_LOG
{
    ULONG ulCmd;
    ULONG ulStartSector;
    ULONG ulSectorCount;
}COMMAND_LOG;

#define MAX_LOG_COUNT   5000
ULONG ulStartInd = 0;

COMMAND_LOG CommandLog[MAX_LOG_COUNT];

#endif

BOOLEAN
AtapiStartIo(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

	This routine is called from the SCSI port driver synchronized
	with the kernel to start an IO request.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	Srb - IO request packet

Return Value:

	TRUE

--*/

{
	ULONG status, ulChannelId;
	UCHAR targetId;
	ULONG sectorsRequested = GET_SECTOR_COUNT(Srb);
	ULONG ulStartSector = GET_START_SECTOR(Srb);
    ULONG i = 0;

    PSRB_EXTENSION SrbExtension;

    i = AssignSrbExtension (DeviceExtension, Srb);

    if (i >= DeviceExtension->ucMaxPendingSrbs)
    {
        Srb->SrbStatus = SRB_STATUS_BUSY;
    	ScsiPortNotification(RequestComplete, DeviceExtension, Srb);
    }
	
	SrbExtension = Srb->SrbExtension;

    SrbExtension->SrbStatus = SRB_STATUS_SUCCESS;

    if ( SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0] )   
    // this is done only as a precaution since we will be refering to the Original Id 
    // when we need to complete the command
    {
        ((PSRB_EXTENSION)(Srb->SrbExtension))->ucOriginalId = Srb->TargetId;
    }

#ifdef DBG
	SrbExtension->SrbId = SrbCount;
	++SrbCount;
#endif

    DebugPrint((1, "%ld\t%ld\t\n", sectorsRequested, ulStartSector));

	targetId = Srb->TargetId;

    Srb->SrbStatus = SRB_STATUS_SUCCESS;    // by default the command is success

    //
	// Determine which function.
	//

	switch (Srb->Function) {

		case SRB_FUNCTION_EXECUTE_SCSI:

            //
            // Perform sanity checks.
            //

            if (!TargetAccessible(DeviceExtension, Srb)) {

	            status = SRB_STATUS_SELECTION_TIMEOUT;
	            break;
            }

            //
            // Send command to device.
            //
            status = (DeviceExtension->SendCommand[DeviceExtension->aucDevType[targetId]])(DeviceExtension, Srb);
            break;
	
        case SRB_FUNCTION_ABORT_COMMAND:
			//
			// Verify that SRB to abort is still outstanding.
			//
	
			if (!PendingSrb(DeviceExtension, Srb)) {
	
				DebugPrint((1, "AtapiStartIo: SRB to abort already completed\n"));
	
				//
				// Complete abort SRB.
				//
	
				status = SRB_STATUS_ABORT_FAILED;
	
				break;

			}
	
			//
			// Abort function indicates that a request timed out.
			// Call reset routine. Card will only be reset if
			// status indicates something is wrong.
			// Fall through to reset code.
			//
	
        case SRB_FUNCTION_RESET_BUS:
	
			//
			// Reset Atapi and SCSI bus.
			//
	
			DebugPrint((1, "AtapiStartIo: Reset bus request received\n"));
	
			if (!AtapiResetController(DeviceExtension, Srb->PathId)) {
	
				DebugPrint((1,"AtapiStartIo: Reset bus failed\n"));
	
				//
				// Log reset failure.
				//
	
                ScsiPortLogError(DeviceExtension, NULL, 0, 0, 0, SP_INTERNAL_ADAPTER_ERROR, HYPERDISK_RESET_BUS_FAILED);

                status = SRB_STATUS_ERROR;

			} else {
	
				  status = SRB_STATUS_SUCCESS;
			}
	
			break;

        case SRB_FUNCTION_FLUSH:
            // We are avoiding all the Flush commands since it is a time consuming process and 
            // it is not useful???!!!!
            // We are hoping that it is enough if we handle this only when shutdown time
            // To be checked for Win2000 sometimes the suspend or 
            // hibernation is not working properly... is it due to not flushing properly????? verify
            // Check this out
            status = SRB_STATUS_SUCCESS;
            break;

        case SRB_FUNCTION_SHUTDOWN:
            {
                UCHAR ucDrvId, ucStatus;
                PIDE_REGISTERS_2 baseIoAddress2;
                PIDE_REGISTERS_1 baseIoAddress1;
                ULONG ulWaitSec;

                for(ucDrvId=0;ucDrvId<MAX_DRIVES_PER_CONTROLLER;ucDrvId++)
                {
                    if ( !( IS_IDE_DRIVE(ucDrvId) ) )
                        continue;

                    if ( IS_CHANNEL_BUSY(DeviceExtension, (ucDrvId>>1) ) )
                    {
                        DeviceExtension->PhysicalDrive[ucDrvId].bFlushCachePending = TRUE;
                        DeviceExtension->ulFlushCacheCount++;
                        continue;
                    }

                    FlushCache(DeviceExtension, ucDrvId);
                    DisableRWBCache(DeviceExtension, ucDrvId); 
                }

                status = SRB_STATUS_SUCCESS;
            }
            break;
		default:
	
			//
			// Indicate unsupported command.
			//
	
			status = SRB_STATUS_INVALID_REQUEST;
	
			break;

	} // end switch

    FEED_ALL_CHANNELS(DeviceExtension);

	//
	// Check if command complete.
	//

	if (status != SRB_STATUS_PENDING) 
    {
		//
		// Indicate command complete.
		//
		DebugPrint((2,
				   "AtapiStartIo: Srb %lx complete with status %x\n",
				   Srb,
				   status));

		//
		// Set status in SRB.
		//
		Srb->SrbStatus = (UCHAR)status;

        if ( SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0] )
        {
            Srb->TargetId = ((PSRB_EXTENSION)(Srb->SrbExtension))->ucOriginalId;
        }

        // We already added this SRB in the Pending SRB Array... so we have to remove it
        RemoveSrbFromPendingList(DeviceExtension, Srb);

        // Complete the Command
    	ScsiPortNotification(RequestComplete, DeviceExtension, Srb);
	}

    if (DeviceExtension->PendingSrbs < DeviceExtension->ucMaxPendingSrbs) 
    {
        if ( ( !((ScsiPortReadPortUchar( &((DeviceExtension->BaseBmAddress[0])->Reserved) ) ) & ANY_CHANNEL_INTERRUPT) ) || 
                (DeviceExtension->PendingSrbs < 2) )
        
        { // Request for next command only if controller is not waiting on interrupt to be processed
		    //
		    // Indicate ready for next request.
		    //
		    ScsiPortNotification(NextLuRequest, DeviceExtension, 0, targetId, 0);
        }
	}

	return TRUE;

} // end AtapiStartIo()

VOID
StartChannelIo(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN ULONG ulChannelId
)

{
	UCHAR status;
    ULONG targetId;
    ULONG ulDrvCount;
    PPHYSICAL_COMMAND pPhysicalCommand;
    PPHYSICAL_DRIVE PhysicalDrive;

	// Init status to something impossible.
	status = SRB_STATUS_NO_DEVICE;

	//
	// If the channel is Busy, just return...
	//

    if ( IS_CHANNEL_BUSY(DeviceExtension,ulChannelId) )
        return;

    if ( gulChangeIRCDPending )
    {
        if ( LOCK_IRCD_PENDING == gulChangeIRCDPending  )
        {
            gulLockVal = LockIRCD(DeviceExtension, TRUE, 0);
            if ( gulLockVal )
            {
                gulChangeIRCDPending = SET_IRCD_PENDING;
                InformAllControllers();
            }
        }
        else
        {
            if ( DeviceExtension->Channel[ulChannelId].bUpdateInfoPending )
            {
                for(ulDrvCount=0;ulDrvCount<MAX_DRIVES_PER_CHANNEL;ulDrvCount++)
                {
                    targetId = (ulChannelId << 1) + ulDrvCount;
                    SetOneDriveIRCD(DeviceExtension, (UCHAR)targetId);
                }
                DeviceExtension->Channel[ulChannelId].bUpdateInfoPending = FALSE;
                if ( UpdateFinished() ) // if all the controllers finished the updation go ahead and unlock the ircd
                {
                    gulLockVal = LockIRCD(DeviceExtension, FALSE, gulLockVal);
                    gulPowerFailedTargetBitMap = 0; // reset the bit map so that we don't do this again and again
                    gulChangeIRCDPending = 0;
                }

            }
        }
    }

    if ( DeviceExtension->ulFlushCacheCount )
    {
        for(ulDrvCount=0;ulDrvCount<MAX_DRIVES_PER_CHANNEL;ulDrvCount++)
        {
            targetId = (ulChannelId << 1) + ulDrvCount;
            if ( DeviceExtension->PhysicalDrive[targetId].bFlushCachePending )
            {
                FlushCache(DeviceExtension, (UCHAR)targetId);
                DisableRWBCache(DeviceExtension, (UCHAR)targetId); 
                // We are handling only SHUTDOWN... so.. let us Disable the cache
                DeviceExtension->ulFlushCacheCount--;
                DeviceExtension->PhysicalDrive[targetId].bFlushCachePending = FALSE;
            }
        }
    }

	// Set TID of the next drive in the channel.
	targetId = (ulChannelId << 1) + (DeviceExtension->Channel[ulChannelId].LastDriveFed ^ DeviceExtension->Channel[ulChannelId].SwitchDrive);

    PhysicalDrive = &(DeviceExtension->PhysicalDrive[targetId]);
	// See if this drive's work queue is empty.
	if (!DRIVE_HAS_COMMANDS(PhysicalDrive)) {

		if (DeviceExtension->Channel[ulChannelId].SwitchDrive == 0) {
			return;
		}

		// Switch to other drive.
		targetId ^= DeviceExtension->Channel[ulChannelId].SwitchDrive;

        PhysicalDrive = &(DeviceExtension->PhysicalDrive[targetId]);
			// Check the other drive's work queue.
		if (!DRIVE_HAS_COMMANDS(PhysicalDrive)) {

			// No new work for this channel. Move to next channel.
			return;
		}
	}

	//
	// At least one drive on this channel has something to do.
	//

	// Next time, feed the other drive.
	DeviceExtension->Channel[ulChannelId].LastDriveFed = (UCHAR)targetId & 1;
    pPhysicalCommand = CreatePhysicalCommand(DeviceExtension, targetId);
    DeviceExtension->Channel[ulChannelId].ActiveCommand = pPhysicalCommand;

#ifdef DBG
    if ( pPhysicalCommand )
    {
        PrintPhysicalCommandDetails(pPhysicalCommand);
    }
#endif

    status = (DeviceExtension->PostRoutines[DeviceExtension->aucDevType[targetId]])(DeviceExtension, pPhysicalCommand);

	if (status != SRB_STATUS_PENDING) {
        MarkChannelFree(DeviceExtension, (targetId>>1));    // free the channel
	}

    pPhysicalCommand->SrbStatus = SRB_STATUS_SUCCESS;
    return;
}

BOOLEAN
MarkChannelFree(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	ULONG ulChannel
)
{

    DeviceExtension->Channel[ulChannel].ActiveCommand = NULL;
    DeviceExtension->ExpectingInterrupt[ulChannel] = 0;

    return TRUE;
}

PPHYSICAL_COMMAND 
CreatePhysicalCommand(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	ULONG ulTargetId
    )
/*++


 This function will be used by both PIO and UDMA Transfers

 This function tries to merge the commands.... Done for both PIO and UDMA


--*/
{
    PPHYSICAL_DRIVE     pPhysicalDrive = &(DeviceExtension->PhysicalDrive[ulTargetId]);
    PPHYSICAL_COMMAND   pPhysicalCommand = &(pPhysicalDrive->PhysicalCommand);
    PPHYSICAL_REQUEST_BLOCK      *ppPrbList = pPhysicalDrive->pPrbList;
    UCHAR               ucHead = pPhysicalDrive->ucHead;
    UCHAR               ucTail = pPhysicalDrive->ucTail;
    UCHAR               ucStartInd, ucEndInd, ucCurInd, ucNextCurInd, ucCmd, ucCmdCount, ucCounter;
    ULONG               ulCurXferLength = 0, ulGlobalSglCount, ulSglCount, ulSglInd;
    PVOID               pvGlobalSglBufPtr, pvCurPartSglBufPtr;
    PSGL_ENTRY          pSglPtr;

#ifdef DBG
    ULONG               ulTotSglCount = 0;
#endif

    if ( ucHead == ucTail ) // No commands in the queue ...
        return NULL;

    ucCurInd = ucHead;
    ucNextCurInd = ((ucCurInd + 1)%MAX_NUMBER_OF_PHYSICAL_REQUEST_BLOCKS_PER_DRIVE);
    ulCurXferLength = ppPrbList[ucCurInd]->ulSectors;
    ucCmd = ppPrbList[ucCurInd]->ucCmd;
    ucCmdCount=1;

    if ( SCSIOP_VERIFY == ucCmd )
    {   // No merging for Verify Command ... it is possible that we will get even 0x2000 sectors for one command
        // and we are going to reuse the same prb

        // form the PhysicalCommand
        pPhysicalCommand->ucCmd = ucCmd;
        pPhysicalCommand->TargetId = (UCHAR)ulTargetId;

        // Number of commands merged
        pPhysicalCommand->ucStartInd = ucHead;
        pPhysicalCommand->ucCmdCount = 1;
        DeviceExtension->PhysicalDrive[ulTargetId].ucCommandCount -= 1;

        // Total number of sectors..
        pPhysicalCommand->ulStartSector = ppPrbList[ucHead]->ulStartSector;
        pPhysicalCommand->ulCount = ppPrbList[ucHead]->ulSectors;

        DeviceExtension->PhysicalDrive[ulTargetId].ucHead = ucNextCurInd;
        return pPhysicalCommand;
    }

#ifdef DBG
    ulTotSglCount = ppPrbList[ucCurInd]->ulSglCount;
#endif

    for(;ucNextCurInd!=ucTail;ucCurInd=ucNextCurInd, (ucNextCurInd=(ucNextCurInd+1)%MAX_NUMBER_OF_PHYSICAL_REQUEST_BLOCKS_PER_DRIVE))
    {
        // Is Next Command is not same as the current Command?
        if ( ucCmd != ppPrbList[ucNextCurInd]->ucCmd )
            break;

        // Is the length is going beyond the limit of the IDE Xfer?
        if ( ( ulCurXferLength + ppPrbList[ucNextCurInd]->ulSectors ) > MAX_SECTORS_PER_IDE_TRANSFER )
            break;

        // Is Next Command is consecutive location of the current Command?
        if ( (ppPrbList[ucCurInd]->ulStartSector+ppPrbList[ucCurInd]->ulSectors) != 
                    ppPrbList[ucNextCurInd]->ulStartSector )
            break;

        ulCurXferLength += ppPrbList[ucNextCurInd]->ulSectors;
        ucCmdCount++;
#ifdef DBG
        ulTotSglCount += ppPrbList[ucNextCurInd]->ulSglCount;
#endif
    }


#ifdef DBG
    DebugPrint((DEFAULT_DISPLAY_VALUE," MS:%x ", ulTotSglCount));
    if ( ulTotSglCount > pPhysicalCommand->MaxSglEntries )
    {
        STOP;
    }
#endif

    ucStartInd = ucHead;
    ucEndInd = ucCurInd;
    pPhysicalDrive->ucHead = ucNextCurInd;

    // form the PhysicalCommand
    pPhysicalCommand->ucCmd = ucCmd;
    pPhysicalCommand->TargetId = (UCHAR)ulTargetId;

    // Number of commands merged
    pPhysicalCommand->ucStartInd = ucStartInd;
    pPhysicalCommand->ucCmdCount = ucCmdCount;

    DeviceExtension->PhysicalDrive[ulTargetId].ucCommandCount -= ucCmdCount;

    // Total number of sectors..
    pPhysicalCommand->ulStartSector = ppPrbList[ucHead]->ulStartSector;
    if ( SCSIOP_INTERNAL_COMMAND == ucCmd )
    {
        PPASS_THRU_DATA pPassThruData = (PPASS_THRU_DATA)(((PSRB_BUFFER)(ppPrbList[ucHead]->pPdd->OriginalSrb->DataBuffer))->caDataBuffer);
        pPhysicalCommand->ulCount = pPassThruData->ulSize;
    }
    else
    {
        pPhysicalCommand->ulCount = ulCurXferLength;
    }

    pvGlobalSglBufPtr = pPhysicalCommand->SglBaseVirtualAddress;
    ulGlobalSglCount = 0;

    for(ucCounter=0;ucCounter<ucCmdCount;ucCounter++)
    {
        ucCurInd = ( ucHead + ucCounter ) % MAX_NUMBER_OF_PHYSICAL_REQUEST_BLOCKS_PER_DRIVE;

        pvCurPartSglBufPtr = (PVOID)ppPrbList[ucCurInd]->ulVirtualAddress;
        ulSglCount = ppPrbList[ucCurInd]->ulSglCount;

        AtapiMemCpy(pvGlobalSglBufPtr, pvCurPartSglBufPtr, ulSglCount * sizeof(SGL_ENTRY));

        ulGlobalSglCount = ulGlobalSglCount + ulSglCount;

        pvGlobalSglBufPtr = (PUCHAR)pvGlobalSglBufPtr + (ulSglCount * sizeof(SGL_ENTRY));
    }

    pSglPtr = (PSGL_ENTRY)pPhysicalCommand->SglBaseVirtualAddress;

    pSglPtr[ulGlobalSglCount-1].Physical.EndOfListFlag = 1; // Considering Zero Index... we have to keep the EOL in ulGlobalSglCount

#ifdef DBG
    pPhysicalCommand->ulTotSglCount = ulGlobalSglCount;
#endif

    return pPhysicalCommand;
}

//
// ATAPI Command Descriptor Block
//

typedef struct _MODE_SENSE_10 {
        UCHAR OperationCode;
        UCHAR Reserved1;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved3[3];
} MODE_SENSE_10, *PMODE_SENSE_10;

SRBSTATUS
IdeSendCommand(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

	Program ATA registers for IDE disk transfer.

Arguments:

	DeviceExtension - ATAPI driver storage.
	Srb - System request block.

Return Value:

	SRB status (pending if all goes well).

--*/

{
	UCHAR status = SRB_STATUS_SUCCESS;

    DebugPrint((DEFAULT_DISPLAY_VALUE,"ISC"));
    
    DebugPrint((3, "\nIdeSendCommand: Entering routine.\n"));

	DebugPrint((2,
			   "IdeSendCommand: Command %x to TID %d\n",
			   Srb->Cdb[0],
			   Srb->TargetId));

	switch(Srb->Cdb[0]) {

		case SCSIOP_READ:
		case SCSIOP_WRITE:
		case SCSIOP_VERIFY:
            status = DeviceExtension->SrbHandlers[DeviceExtension->IsLogicalDrive[Srb->TargetId]](DeviceExtension, Srb);
			break;

		case SCSIOP_INQUIRY:
			status = GetInquiryData(DeviceExtension, Srb);
			break;

		case SCSIOP_MODE_SELECT:
            status = SRB_STATUS_SUCCESS;
            break;

		case SCSIOP_SYNCHRONIZE_CACHE:
            {
                break;
            }
		case SCSIOP_MODE_SENSE:
            {
		        status = SRB_STATUS_INVALID_REQUEST;
		        break;
            }
		case SCSIOP_TEST_UNIT_READY:
            status = SRB_STATUS_SUCCESS;
			break;
		case SCSIOP_START_STOP_UNIT:
            status = SRB_STATUS_SUCCESS;
			break;
		case SCSIOP_READ_CAPACITY:
			GetDriveCapacity(DeviceExtension, Srb);
			status = SRB_STATUS_SUCCESS;
			break;
		case SCSIOP_REQUEST_SENSE:
			//
			// This function makes sense buffers to report the results
			// of the original GET_MEDIA_STATUS command.
			//
			if (DeviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {
				status = IdeBuildSenseBuffer(DeviceExtension, Srb);
				break;
			}
            status = SRB_STATUS_ERROR;
            break;
        case SCSIOP_INTERNAL_COMMAND:
            {
                // This is our internal Request... So let us call the function to Enqueue the request
                // The functions that are supported are GetErrorLog, EraseErrorLog, GetIRCD, SetIRCD
                // Probe HyperDisk, GetRaidInfo, GetStatus, LockUnlockIRCD, IOGetCapacity, ChangeMirrorDriveStatus,
                // ChangeMirrorDrive, ChangeDriveStatus, GetStatus
                PSRB_EXTENSION SrbExtension = Srb->SrbExtension;
                PSRB_IO_CONTROL pSrbIoc = (PSRB_IO_CONTROL) Srb->DataBuffer;
                UCHAR ucOpCode = (UCHAR) pSrbIoc->ControlCode;
                UCHAR ucOriginalId = Srb->TargetId;
                PCDB pCDB = NULL;
                pCDB = (PCDB)Srb->Cdb;

                switch ( ucOpCode )
                {
                    case IOC_PROBE_AMIRAID:
                    {
                        PPROBE_AMI_DRIVER pSrbProbe = (PPROBE_AMI_DRIVER) 
                                                      (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);
                        
                        AtapiMemCpy(pSrbProbe->aucAmiSig, "AMIRAID", sizeof("AMIRAID"));
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
                    case IOC_PASS_THRU_COMMAND:
                    {
                        ULONG ulStartSector;
                        PPASS_THRU_DATA pPassThruData = (PPASS_THRU_DATA)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        SrbExtension->ucOriginalId = ucOriginalId;
                        SrbExtension->ucOpCode = ucOpCode;
                        if (DRIVE_IS_UNUSABLE_STATE((pPassThruData->uchTargetID)) || 
                            (!DRIVE_PRESENT((pPassThruData->uchTargetID))))
                        {
                            // This drive may be a drive that responding 
                            // even when power is not there
		                    DebugPrint((1, "Failed Drive.... so failing command \n"));
                            status = SRB_STATUS_ERROR;
		                    break;
                        }

                        Srb->TargetId = pPassThruData->uchTargetID;
                        //
                        // Set the Transfer Length and Starting Transfer Sector (Block).
                        //
                        pCDB->CDB10.LogicalBlockByte0 = (UCHAR) 0;
                        pCDB->CDB10.LogicalBlockByte1 = (UCHAR) 0;
                        pCDB->CDB10.LogicalBlockByte2 = (UCHAR) 0;
                        pCDB->CDB10.LogicalBlockByte3 = (UCHAR) 0;

                        pCDB->CDB10.TransferBlocksMsb = (UCHAR) 0;
                        pCDB->CDB10.TransferBlocksLsb = (UCHAR) 1;

                        SrbExtension->RebuildSourceId = Srb->TargetId;
                        status = EnqueueSrb(DeviceExtension,Srb);
                        break;
                    }
				    case IOC_GET_CONTROLLER_INFO:
                    {
						PCONTROLLER_DATA pContrInfo = (PCONTROLLER_DATA) 
									 (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

						// get DeviceExtension for all controllers
						PHW_DEVICE_EXTENSION HwDeviceExtension = gaCardInfo[0].pDE;	

						// index - is being used for the controller index
						long index=0;

						while( HwDeviceExtension )
						{
							pContrInfo->Info[index].ControllerId = (USHORT)HwDeviceExtension->ucControllerId; 
							pContrInfo->Info[index].PrimaryBaseAddress = (ULONG)HwDeviceExtension->BaseIoAddress1[0];
							pContrInfo->Info[index].PrimaryControlAddress = (ULONG)HwDeviceExtension->BaseIoAddress2[0]; 
							pContrInfo->Info[index].SecondaryBaseAddress = (ULONG)HwDeviceExtension->BaseIoAddress1[1]; 
							pContrInfo->Info[index].SecondaryControllAddress = (ULONG)HwDeviceExtension->BaseIoAddress2[1]; 
							pContrInfo->Info[index].BusMasterBaseAddress = (ULONG)HwDeviceExtension->BaseBmAddress[0];
							pContrInfo->Info[index].IRQ = (USHORT)HwDeviceExtension->ulIntLine; 
							pContrInfo->Info[index].FwVersion.MajorVer=gFwVersion.MajorVer; // Info is filled in InitIdeRaidControllers
							pContrInfo->Info[index].FwVersion.MinorVer=gFwVersion.MinorVer; // Info is filled in InitIdeRaidControllers
							pContrInfo->Info[index].FwVersion.Build=gFwVersion.Build; // Info is filled in InitIdeRaidControllers......... Build doesn't know about this

							pContrInfo->Info[index].ChipsetInfo.VendorID=(USHORT)gaCardInfo[index].ulVendorId;
							pContrInfo->Info[index].ChipsetInfo.DeviceID=(USHORT)gaCardInfo[index].ulDeviceId;

                            pContrInfo->Info[index].ChipsetInfo.PciBus=(UCHAR)gaCardInfo[index].ucPCIBus;
                            pContrInfo->Info[index].ChipsetInfo.PciDevice=(UCHAR)gaCardInfo[index].ucPCIDev;
                            pContrInfo->Info[index].ChipsetInfo.PciFunction=(UCHAR)gaCardInfo[index].ucPCIFun;

							index++;

							HwDeviceExtension=gaCardInfo[index].pDE; // get next controller

							if( index >= MAX_CONTROLLERS )
								break;
						}
						pContrInfo->ControllerCount = index;
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
				    case IOC_GET_SPAREPOOL_INFO:
                    {

						PSPAREPOOL_DATA pSpareInfo = (PSPAREPOOL_DATA) 
									 (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

						// get DeviceExtension for all controllers
						PHW_DEVICE_EXTENSION HwDeviceExtension = gaCardInfo[0].pDE;	

						// index - is being used for the controller index
						long drvIndex,ulTemp,index=0,spareInd;

						while( HwDeviceExtension ) {

							for(drvIndex=0;drvIndex< ( MAX_DRIVES_PER_CONTROLLER ) ;drvIndex++) {
						
								if( HwDeviceExtension->IsSpareDrive[drvIndex] ) {
						
                                    pSpareInfo->Info[index].ulMode = SpareDrivePool;

									spareInd = pSpareInfo->Info[index].ulTotDriveCnt;

									for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_MODEL_LENGTH;ulTemp+=2) {

										pSpareInfo->Info[index].phyDrives[spareInd].sModelInfo[ulTemp] = 
													   ((UCHAR *)HwDeviceExtension->FullIdentifyData[drvIndex].ModelNumber)[ulTemp+1];

										pSpareInfo->Info[index].phyDrives[spareInd].sModelInfo[ulTemp+1] = 
													   ((UCHAR *)HwDeviceExtension->FullIdentifyData[drvIndex].ModelNumber)[ulTemp];
									}

									pSpareInfo->Info[index].phyDrives[spareInd].sModelInfo[PHYSICAL_DRIVE_MODEL_LENGTH - 1] = '\0';

									for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_SERIAL_NO_LENGTH;ulTemp+=2) {

										pSpareInfo->Info[index].phyDrives[spareInd].caSerialNumber[ulTemp] = 
													   ((UCHAR *)HwDeviceExtension->FullIdentifyData[drvIndex].SerialNumber)[ulTemp+1];

										pSpareInfo->Info[index].phyDrives[spareInd].caSerialNumber[ulTemp+1] = 
													   ((UCHAR *)HwDeviceExtension->FullIdentifyData[drvIndex].SerialNumber)[ulTemp];
									}

									pSpareInfo->Info[index].phyDrives[spareInd].caSerialNumber[PHYSICAL_DRIVE_SERIAL_NO_LENGTH - 1] = '\0';

                                    // Begin Vasu - 7 March 2001
                                    // Connection ID must be System Wide. Not Controller Specific.
                                    // Reported by Audrius
									pSpareInfo->Info[index].phyDrives[spareInd].cChannelID = (UCHAR)TARGET_ID_2_CONNECTION_ID((drvIndex + (index * MAX_DRIVES_PER_CONTROLLER)));
                                    // End Vasu
									
                                    pSpareInfo->Info[index].phyDrives[spareInd].TransferMode = HwDeviceExtension->TransferMode[drvIndex];

									pSpareInfo->Info[index].phyDrives[spareInd].ulPhySize           = HwDeviceExtension->PhysicalDrive[drvIndex].OriginalSectors / 2; // In KB
									pSpareInfo->Info[index].phyDrives[spareInd].ucIsPhyDrvPresent   = TRUE;

									if ( DeviceExtension->PhysicalDrive[drvIndex].TimeOutErrorCount < MAX_TIME_OUT_ERROR_COUNT )
    									pSpareInfo->Info[index].phyDrives[spareInd].ucIsPowerConnected  = TRUE;

									if ( DeviceExtension->TransferMode[drvIndex] >= UdmaMode3 )
										pSpareInfo->Info[index].phyDrives[spareInd].ucIs80PinCable      = TRUE;

									pSpareInfo->Info[index].phyDrives[spareInd].ulBaseAddress1 = (ULONG)HwDeviceExtension->BaseIoAddress1[drvIndex>>1];
									pSpareInfo->Info[index].phyDrives[spareInd].ulAltAddress2 = (ULONG)HwDeviceExtension->BaseIoAddress2[drvIndex>>1];
									pSpareInfo->Info[index].phyDrives[spareInd].ulbmAddress = (ULONG)HwDeviceExtension->BaseBmAddress[drvIndex>>1];
									pSpareInfo->Info[index].phyDrives[spareInd].ulIrq = HwDeviceExtension->ulIntLine;

									pSpareInfo->Info[index].ulTotDriveCnt++;

								}


							}


							index++;
							HwDeviceExtension=gaCardInfo[index].pDE; // get next controller

							if( index >= MAX_CONTROLLERS )
								break;

						}

						pSpareInfo->ControllerCount=index;
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
				    case IOC_GET_VERSION:
					{

						PIDE_VERSION pVersion = (PIDE_VERSION) 
									 (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

						// return's driver version
						
						pVersion->MajorVer = HYPERDSK_MAJOR_VERSION;
						pVersion->MinorVer = HYPERDSK_MINOR_VERSION;
						pVersion->Build = HYPERDSK_BUILD_VERSION;

                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
				    case IOC_LOCK_UNLOCK_IRCD_EX:
                    {

                        PLOCK_UNLOCK_DATA_EX pLockUnlockData = 
                            (PLOCK_UNLOCK_DATA_EX) (((PSRB_BUFFER) Srb->DataBuffer)->caDataBuffer);

					    ULONG ulTimeOut;

						// don't know what to do with timeout value, 
						// still need to implement this??
                        pLockUnlockData->ulUnlockKey = LockIRCD(DeviceExtension,
                                                                pLockUnlockData->uchLock,
                                                                pLockUnlockData->ulUnlockKey);

						if ( MAX_UNLOCK_TIME == pLockUnlockData->ulTimeOut )
                        {
                            gbDoNotUnlockIRCD = TRUE;
                        }

                        status = SRB_STATUS_SUCCESS;

                        break;
                    }
                    case IOC_GET_RAID_INFO:
                    {
                        status = (UCHAR) FillRaidInfo(DeviceExtension, Srb);
                        break;
                    }
                    case IOC_GET_STATUS:
                    {
                        status = (UCHAR) GetStatusChangeFlag(DeviceExtension, Srb);
                        break;
                    }
                    case IOC_GET_ERROR_LOG:
                    {
                        ULONG ulStartSector;
                        PERROR_LOG_REPORT pInOutInfo = (PERROR_LOG_REPORT) 
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer + 2);
                        
                        BOOLEAN bIsNewOnly = (BOOLEAN)pInOutInfo->IsNewOnly;
                        USHORT  usNumError = pInOutInfo->Offset;

                        // Begin Vasu - 14 Aug 2000
                        // Code from Syam's Update - Added
                        if (DRIVE_IS_UNUSABLE_STATE((pInOutInfo->DriveId)) || 
                            (!DRIVE_PRESENT((pInOutInfo->DriveId))))
                        {
                            // This drive may be a drive that responding 
                            // even when power is not there
                            SrbExtension->ucOriginalId = Srb->TargetId;
		                    DebugPrint((1, "Failed Drive.... so failing command \n"));
                            status = SRB_STATUS_ERROR;
		                    break;
                        }
                        // End Vasu.

                        Srb->TargetId = pInOutInfo->DriveId;

                        // if no new error
                        if (bIsNewOnly && 
                            (DeviceExtension->PhysicalDrive[Srb->TargetId].ErrorReported == 
                                DeviceExtension->PhysicalDrive[Srb->TargetId].ErrorFound))
                        {
                            pInOutInfo->DriveId = Srb->TargetId;  // the id user filled
                            pInOutInfo->Count = 0;
                            pInOutInfo->IsMore = FALSE;
                            pInOutInfo->IsNewOnly = bIsNewOnly;
                            pInOutInfo->Offset = usNumError;

                            Srb->TargetId = ucOriginalId;   // the id OS filled

                            status = SRB_STATUS_SUCCESS;
                            break;
                        }

                        ulStartSector = DeviceExtension->PhysicalDrive[Srb->TargetId].ErrorLogSectorIndex;
                        //
                        // Set the Transfer Length and Starting Transfer Sector (Block).
                        //
                        pCDB->CDB10.LogicalBlockByte0 = (UCHAR) (ulStartSector >> 24);
                        pCDB->CDB10.LogicalBlockByte1 = (UCHAR) (ulStartSector >> 16);
                        pCDB->CDB10.LogicalBlockByte2 = (UCHAR) (ulStartSector >> 8);
                        pCDB->CDB10.LogicalBlockByte3 = (UCHAR) (ulStartSector);

                        pCDB->CDB10.TransferBlocksMsb = (UCHAR) 0;
                        pCDB->CDB10.TransferBlocksLsb = (UCHAR) 1;

                        SrbExtension->IsNewOnly = bIsNewOnly;
                        SrbExtension->usNumError = usNumError;

                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->RebuildSourceId = Srb->TargetId;
                        SrbExtension->ucOriginalId = ucOriginalId;
                        status = EnqueueSrb(DeviceExtension, Srb);

                        break;
                    }
                    case IOC_ERASE_ERROR_LOG:
                    {
                        ULONG ulStartSector;
                        PERASE_ERROR_LOG peel = (PERASE_ERROR_LOG)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        if ( !IS_IDE_DRIVE((peel->DriveId)) ) 
                        {
                            Srb->TargetId = ucOriginalId;   // the ID OS Filled
                            status = SRB_STATUS_SUCCESS;
                            break;
                        }

                        // Begin Vasu - 14 Aug 2000
                        // Code from Syam's Update - Added
                        if (DRIVE_IS_UNUSABLE_STATE((peel->DriveId)) || 
                            (!DRIVE_PRESENT((peel->DriveId))))
                        {
                            // This drive may be a drive that responding 
                            // even when power is not there
                            SrbExtension->ucOriginalId = Srb->TargetId;
		                    DebugPrint((1, "Failed Drive.... so failing command \n"));
                            status = SRB_STATUS_ERROR;
		                    break;
                        }
                        // End Vasu.

                        Srb->TargetId = peel->DriveId;

                        ulStartSector = DeviceExtension->PhysicalDrive[Srb->TargetId].ErrorLogSectorIndex;

                        //
                        // Set the Transfer Length and Starting Transfer Sector (Block).
                        //
                        pCDB->CDB10.LogicalBlockByte0 = (UCHAR) (ulStartSector >> 24);
                        pCDB->CDB10.LogicalBlockByte1 = (UCHAR) (ulStartSector >> 16);
                        pCDB->CDB10.LogicalBlockByte2 = (UCHAR) (ulStartSector >> 8);
                        pCDB->CDB10.LogicalBlockByte3 = (UCHAR) (ulStartSector);

                        pCDB->CDB10.TransferBlocksMsb = (UCHAR) 0;
                        pCDB->CDB10.TransferBlocksLsb = (UCHAR) 1;

                        SrbExtension->RebuildSourceId = Srb->TargetId;
                        SrbExtension->IsWritePending = TRUE;
                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->usNumError = (USHORT) peel->Count;
                        SrbExtension->ucOriginalId = ucOriginalId;
                        status = EnqueueSrb(DeviceExtension, Srb);


                        break;
                    }
                    case IOC_LOCK_UNLOCK_IRCD:
                    {
                        PLOCK_UNLOCK_DATA pLockUnlockData = 
                            (PLOCK_UNLOCK_DATA) (((PSRB_BUFFER) Srb->DataBuffer)->caDataBuffer);

                        pLockUnlockData->ulUnlockKey = LockIRCD(DeviceExtension,
                                                                pLockUnlockData->uchLock,
                                                                pLockUnlockData->ulUnlockKey);

                        status = SRB_STATUS_SUCCESS;

                        break;
                    }
                    case IOC_GET_IRCD:
                    case IOC_SET_IRCD:
                    {
                        ULONG ulStartSector;
                        PIRCD_DATA pIrcdData = (PIRCD_DATA)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        // Begin Vasu - 14 Aug 2000
                        // Code from Syam's Update - Added
                        if (DRIVE_IS_UNUSABLE_STATE((pIrcdData->uchTargetID)) || 
                            (!DRIVE_PRESENT((pIrcdData->uchTargetID))))
                        {
                            // This drive may be a drive that responding 
                            // even when power is not there
                            SrbExtension->ucOriginalId = Srb->TargetId;
		                    DebugPrint((1, "Failed Drive.... so failing command \n"));
                            status = SRB_STATUS_ERROR;
		                    break;
                        }
                        // End Vasu.

                        Srb->TargetId = pIrcdData->uchTargetID;

                        ulStartSector = DeviceExtension->PhysicalDrive[Srb->TargetId].IrcdSectorIndex;

                        if ( !ulStartSector )
                        {
                            // There is no IRCD for this drive.... so fail this request
                            Srb->TargetId = ucOriginalId;      // the ID OS Filled
                            status = SRB_STATUS_ERROR;
                            break;
                        }

                        //
                        // Set the Transfer Length and Starting Transfer Sector (Block).
                        //
                        pCDB->CDB10.LogicalBlockByte0 = (UCHAR) (ulStartSector >> 24);
                        pCDB->CDB10.LogicalBlockByte1 = (UCHAR) (ulStartSector >> 16);
                        pCDB->CDB10.LogicalBlockByte2 = (UCHAR) (ulStartSector >> 8);
                        pCDB->CDB10.LogicalBlockByte3 = (UCHAR) (ulStartSector);

                        pCDB->CDB10.TransferBlocksMsb = (UCHAR) 0;
                        pCDB->CDB10.TransferBlocksLsb = (UCHAR) 1;

                        SrbExtension->RebuildSourceId = Srb->TargetId;
                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->ucOriginalId = ucOriginalId;
                        status = EnqueueSrb(DeviceExtension, Srb);
                        break;
                    }
                    case IOC_GET_SECTOR_DATA:
                    {
                        ULONG ulStartSector;
                        PSECTOR_DATA pSectorData = (PSECTOR_DATA)(((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        // Begin Vasu - 22 Aug 2000
                        // Code from Syam's Update - Added to Get Sector Data also.
                        if (DRIVE_IS_UNUSABLE_STATE((pSectorData->uchTargetID)) || 
                            (!DRIVE_PRESENT((pSectorData->uchTargetID))))
                        {
                            SrbExtension->ucOriginalId = Srb->TargetId;
		                    DebugPrint((1, "Failed Drive.... so failing command \n"));
                            status = SRB_STATUS_ERROR;
		                    break;
                        }
                        // End Vasu.

                        Srb->TargetId = pSectorData->uchTargetID;

                        ulStartSector = (ULONG) (pSectorData->caDataBuffer[0]);

                        //
                        // Set the Transfer Length and Starting Transfer Sector (Block).
                        //
                        pCDB->CDB10.LogicalBlockByte0 = (UCHAR) (ulStartSector >> 24);
                        pCDB->CDB10.LogicalBlockByte1 = (UCHAR) (ulStartSector >> 16);
                        pCDB->CDB10.LogicalBlockByte2 = (UCHAR) (ulStartSector >> 8);
                        pCDB->CDB10.LogicalBlockByte3 = (UCHAR) (ulStartSector);

                        pCDB->CDB10.TransferBlocksMsb = (UCHAR) 0;
                        pCDB->CDB10.TransferBlocksLsb = (UCHAR) 1;

                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->ucOriginalId = ucOriginalId;
                        status = EnqueueSrb(DeviceExtension, Srb);
                        break;
                    }
                    case IOC_SET_DRIVE_STATUS:
                    {
                        PSET_LOGICAL_DRIVE_STATUS pLogDrvStatus = (PSET_LOGICAL_DRIVE_STATUS) 
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        SetLogicalDriveStatus (DeviceExtension,
                                               pLogDrvStatus->ucLogDrvId,
                                               pLogDrvStatus->ucPhyDrvId,
                                               pLogDrvStatus->ucLogDrvStatus,
                                               pLogDrvStatus->ucPhyDrvStatus,
                                               pLogDrvStatus->ucFlags);
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
                    case IOC_CHANGE_MIRROR_DRIVE_STATUS:
                    {
                        PCHANGE_MIRROR_DRIVE_STATUS pMirrorDrvStatus = (PCHANGE_MIRROR_DRIVE_STATUS)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        ChangeMirrorDriveStatus (DeviceExtension,
                                                 pMirrorDrvStatus->ucLogDrvId,
                                                 pMirrorDrvStatus->ucPhyDrvId,
                                                 pMirrorDrvStatus->ucPhyDrvStatus);
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
                    case IOC_CHANGE_MIRROR_DRIVE_ID:
                    {
                        PCHANGE_MIRROR_DRIVE pMirrorDrv = (PCHANGE_MIRROR_DRIVE)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                            ChangeMirrorDrive (DeviceExtension,
                                               pMirrorDrv->ucLogDrvId,
                                               pMirrorDrv->ucBadPhyDrvId,
                                               pMirrorDrv->ucGoodPhyDrvId);
                            status = SRB_STATUS_SUCCESS;
                        break;
                    }
                    case IOC_GET_CAPACITY:
                    {
                        status = (UCHAR) GetRAIDDriveCapacity(DeviceExtension, Srb);
                        break;
                    }
                    case IOC_REBUILD:
                    {
                        // This is our internal Request... So let us call the function to Enqueue the request
                        // Let us store the information of the Rebuild Target Id
                        PREBUILD_CONSISTENCY_CHECK prcc = (PREBUILD_CONSISTENCY_CHECK)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        UCHAR ucTargetId = prcc->uchTargetID;

                        Srb->TargetId = prcc->uchSourceID;

                        SrbExtension->RebuildSourceId = Srb->TargetId;
                        SrbExtension->IsWritePending = TRUE;
                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->RebuildTargetId = ucTargetId;
                        SrbExtension->ucOriginalId = ucOriginalId;      
                        status = EnqueueSrb(DeviceExtension, Srb);
                    }
                    break;
                    case IOC_SET_CONSISTENCY_STATUS:
                    {
                        PSRB_IO_CONTROL pSrb = (PSRB_IO_CONTROL)(Srb->DataBuffer);
                        PSET_CONSISTENCY_STATUS pConsistencyStatus = (PSET_CONSISTENCY_STATUS) 
                            (((PSRB_BUFFER) Srb->DataBuffer)->caDataBuffer);

                        if ( AtapiStringCmp( 
                                    pSrb->Signature, 
                                    IDE_RAID_SIGNATURE,
                                    strlen(IDE_RAID_SIGNATURE))) 
                        {
                            status = SRB_STATUS_ERROR;
                            break;
                        }

                        if ((pConsistencyStatus->uchPhysicalDriveOne >= MAX_DRIVES_PER_CONTROLLER) ||
                            (pConsistencyStatus->uchPhysicalDriveTwo >= MAX_DRIVES_PER_CONTROLLER))
                        {
                            status = SRB_STATUS_ERROR;
                            break;
                        }

                        DeviceExtension->PhysicalDrive[pConsistencyStatus->uchPhysicalDriveOne].ConsistencyOn = 
                            pConsistencyStatus->uchConsistencyCheckFlag;
                        DeviceExtension->PhysicalDrive[pConsistencyStatus->uchPhysicalDriveTwo].ConsistencyOn = 
                            pConsistencyStatus->uchConsistencyCheckFlag;

                        status = SRB_STATUS_SUCCESS;

                        break;
                    }
                    case IOC_CONSISTENCY_CHECK:
                    {
                        // This is our internal Request... So let us call the function to Enqueue the request
                        // Let us store the information
                        PREBUILD_CONSISTENCY_CHECK prcc = (PREBUILD_CONSISTENCY_CHECK)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        UCHAR ucTargetId = prcc->uchTargetID;

                        Srb->TargetId = prcc->uchSourceID;

                        SrbExtension->RebuildSourceId = Srb->TargetId;
                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->RebuildTargetId = ucTargetId;
                        SrbExtension->ucOriginalId = ucOriginalId;      

                        EnqueueConsistancySrb(DeviceExtension, Srb);

                        status = SRB_STATUS_PENDING;
                        break;
                    }
                    case IOC_GET_DEVICE_FLAGS:
                    {
                        ULONG ulControllerInd;
                        PHW_DEVICE_EXTENSION pDE;
                        PUCHAR pucBuffer;

                        pucBuffer = (PUCHAR)((PSRB_BUFFER)(Srb->DataBuffer))->caDataBuffer;
                        for(ulControllerInd=0;ulControllerInd<gucControllerCount;ulControllerInd++)
                        {
                            pDE = gaCardInfo[ulControllerInd].pDE;
                            AtapiMemCpy(    pucBuffer,
                                            (PUCHAR)(pDE->DeviceFlags),
                                            (sizeof(ULONG) * MAX_DRIVES_PER_CONTROLLER)
                                        );
                            pucBuffer += (sizeof(ULONG) * MAX_DRIVES_PER_CONTROLLER);
                        }
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
                    case IOC_REMOVE_DRIVE_FROM_SPARE:
                    {
                        PREMOVE_DRIVE_FROM_SPARE prdfs = (PREMOVE_DRIVE_FROM_SPARE)
                            (((PSRB_BUFFER) Srb->DataBuffer)->caDataBuffer);

                        if (! IS_IDE_DRIVE(prdfs->uchPhysicalDriveTid))
                        {
                            status = SRB_STATUS_ERROR;
                            break;
                        }

                        DeviceExtension->IsSpareDrive[prdfs->uchPhysicalDriveTid] = FALSE;
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
                    case IOC_EXECUTE_SMART_COMMAND:
                    {
                        UCHAR uchPostSMARTCmd = 0;
                        PSRB_IO_CONTROL pSrb = (PSRB_IO_CONTROL)(Srb->DataBuffer);
                        PSMART_DATA pSD = (PSMART_DATA) 
                            (((PSRB_BUFFER) Srb->DataBuffer)->caDataBuffer);

                        if ( AtapiStringCmp( 
                                    pSrb->Signature, 
                                    IDE_RAID_SIGNATURE,
                                    strlen(IDE_RAID_SIGNATURE))) 
                        {
                            status = SRB_STATUS_ERROR;
                            break;
                        }

                        // Check for SMART Capability in the Specified Drive
                        if (!((DeviceExtension->FullIdentifyData[pSD->uchTargetID].CmdSupported1) & 0x01))
                        {
                            pSD->uchCommand = HD_SMART_ERROR_NOT_SUPPORTED;
                            // Begin Vasu - 23 Aug 2000
							// Changing Status from SRB_STATUS_INVALID_REQUEST to SRB_STATUS_ERROR
							// so that the call is getting completed.
							status = SRB_STATUS_ERROR;
							// End Vasu
                            break;
                        }

                        switch (pSD->uchCommand)
                        {
                        case HD_SMART_ENABLE:
                            if (((DeviceExtension->FullIdentifyData[pSD->uchTargetID].CmdEnabled1) & 0x01))
                            {
                                pSD->uchCommand = HD_SMART_ERROR_ENABLED;
                                status = SRB_STATUS_SUCCESS;
                                break;
                            }
                            uchPostSMARTCmd = 1;
                            break;
                        case HD_SMART_DISABLE:
                            if (!((DeviceExtension->FullIdentifyData[pSD->uchTargetID].CmdEnabled1) & 0x01))
                            {
                                pSD->uchCommand = HD_SMART_ERROR_DISABLED;
                                status = SRB_STATUS_SUCCESS;
                                break;
                            }
                            uchPostSMARTCmd = 1;
                            break;
                        case HD_SMART_RETURN_STATUS:
                        case HD_SMART_READ_DATA:
                            if (!((DeviceExtension->FullIdentifyData[pSD->uchTargetID].CmdEnabled1) & 0x01))
                            {
                                pSD->uchCommand = HD_SMART_ERROR_DISABLED;
                                status = SRB_STATUS_ERROR;
                                break;
                            }
                            uchPostSMARTCmd = 1;
                            break;
                        default:
                            status = SRB_STATUS_ERROR;
                            break;
                        }

                        // Post the Command to the drives only when SMART is 
                        // present and enabled.
                        if (uchPostSMARTCmd)
                        {
                        Srb->TargetId = pSD->uchTargetID;

                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->ucOriginalId = ucOriginalId;

                        status = EnqueueSMARTSrb(DeviceExtension, Srb);
                        }

                        break;
                    }
                // End Vasu
                    default:
                    {
                        Srb->TargetId = ucOriginalId;
                        status = SRB_STATUS_ERROR;
                        break;
                    }
                }
            }
            break;
		default:
		   DebugPrint((1,
			  "IdeSendCommand: Unsupported command %x\n",
			  Srb->Cdb[0]));

		   status = SRB_STATUS_INVALID_REQUEST;

	} // end switch
	return status;
} // end IdeSendCommand()

SRBSTATUS
EnqueueSMARTSrb(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{
	PSRB_EXTENSION SrbExtension;
	BOOLEAN success;
    PUCHAR  pucCurBufPtr;
    ULONG ulCurLength;
	PPHYSICAL_DRIVE_DATA Pdd;
    SRBSTATUS status = SRB_STATUS_PENDING;
    PSMART_DATA pSD = (PSMART_DATA) 
        (((PSRB_BUFFER) Srb->DataBuffer)->caDataBuffer);

	DebugPrint((3, "\nEnqueueSMARTSrb: Entering routine.\n"));

	if (DeviceExtension->PendingSrbs >= DeviceExtension->ucMaxPendingSrbs) 
    {
		return SRB_STATUS_BUSY;
	}

	//
	// Initializations.
	//

	success = TRUE;

	SrbExtension = Srb->SrbExtension;

	// Get pointer to the only Pdd we need.
	Pdd = &(SrbExtension->PhysicalDriveData[0]);

	// Save TID.
	Pdd->TargetId = Srb->TargetId;

	// Save pointer to SRB.
	Pdd->OriginalSrb = Srb;

	// Set number of Pdds.
	SrbExtension->NumberOfPdds = 1;

    Pdd->ulStartSglInd = SrbExtension->ulSglInsertionIndex;

    pucCurBufPtr = Srb->DataBuffer;
    
    // Hmmmm... the bug of forming improper SGLs when the transfer length > MAX_IDE_XFER_LENGTH 
    // has to be fixed here also... reproducable through IOMeter

    ulCurLength = 512;

	//
	// Use PIO.
	// Build S/G list using logical addresses.
	//
	success = BuildSgls(    DeviceExtension,
                            Srb,
                            SrbExtension->aSglEntry, &(SrbExtension->ulSglInsertionIndex), 
                            pucCurBufPtr, ulCurLength,
                            FALSE);

	if (!success) 
    {
		return SRB_STATUS_ERROR;
	}

    Pdd->ulSglCount = SrbExtension->ulSglInsertionIndex - Pdd->ulStartSglInd;

    // Store the SMART Command value here itself.
    DeviceExtension->uchSMARTCommand = pSD->uchCommand;

	EnqueuePdd(DeviceExtension, Srb, Pdd);

    return status;
}

SRBSTATUS
EnqueueSrb(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

	This function enqueues an SRB into the proper SINGLE device
	queue.

	Steps:

	1. Check if there's room for this request.
	2. Fill in Pdd.
	3. Build S/G list.
	4. Save SRB address in general list for use on abort request.
	5. Enqueue Pdd to device's work queue.

	DO NOT CALL THIS FUNCTION FOR LOGICAL DEVICES SRBs.

Arguments:

	DeviceExtension		Pointer to the device extension area for the HBA.
	Srb					Pointer to the SCSI request block.

Return Value:

	SRB_STATUS_INVALID_REQUEST	Could not build the S/G list.
	SRB_STATUS_PENDING			The Srb will cause an interrupt.
	SRB_STATUS_ERROR			Internal miniport error.
	SRB_STATUS_BUSY				Non more requests can be accepted
								(should not happen - internal error!)

--*/
{
	PPHYSICAL_DRIVE_DATA Pdd;
	USHORT sectorsRequested;
	PSRB_EXTENSION SrbExtension;
	ULONG startSector;
	SRBSTATUS status;
	BOOLEAN success, bISUdma;
    UCHAR uchRebuildTargetId;
    PUCHAR  pucCurBufPtr;
    ULONG ulBufLength, ulMaxIdeXferLength, ulCurLength;

	DebugPrint((3, "\nEnqueueSrb: Entering routine.\n"));

    if (DeviceExtension->PendingSrbs >= DeviceExtension->ucMaxPendingSrbs) 
    {
		return SRB_STATUS_BUSY;
	}

    if ( SCSIOP_VERIFY == Srb->Cdb[0] )
    {
        return EnqueueVerifySrb(DeviceExtension, Srb);
    }

    //
	// Initializations.
	//

	success = TRUE;

	SrbExtension = Srb->SrbExtension;

	sectorsRequested = GET_SECTOR_COUNT(Srb);

	startSector = GET_START_SECTOR(Srb);

	if ((sectorsRequested + startSector) > DeviceExtension->PhysicalDrive[Srb->TargetId].Sectors) {
        if ( ( ! (DeviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) ) && ( SCSIOP_INTERNAL_COMMAND != Srb->Cdb[0] ) )
            // Not sure about concept of Sectors in Atapi Device
            // so let me not checkup that for Atapi Devices.
            // Putting this checking outside of this if Condition will give an extra over head to the
            // IDE Drives
		    return SRB_STATUS_INVALID_REQUEST;
	}

	// Get pointer to the only Pdd we need.
	Pdd = &(SrbExtension->PhysicalDriveData[0]);

	// Save TID.
	Pdd->TargetId = Srb->TargetId;

	// Save start sector number.
	Pdd->ulStartSector = startSector;

	// Save pointer to SRB.
	Pdd->OriginalSrb = Srb;

	// Set number of Pdds.
	SrbExtension->NumberOfPdds = 1;

    Pdd->ulStartSglInd = SrbExtension->ulSglInsertionIndex;

    if ( ( SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0] ) && ( IOC_PASS_THRU_COMMAND == SrbExtension->ucOpCode ) )
    {   // At this moment only the Pass Thru command will come like this...
        PPASS_THRU_DATA pPassThruData = (PPASS_THRU_DATA)(((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

        pucCurBufPtr = pPassThruData->aucBuffer;
        ulBufLength = pPassThruData->ulSize;
    }
    else
    {
        pucCurBufPtr = Srb->DataBuffer;
        ulBufLength = sectorsRequested * IDE_SECTOR_SIZE;
    }
    
    ulMaxIdeXferLength = MAX_SECTORS_PER_IDE_TRANSFER * IDE_SECTOR_SIZE;

	if ( (USES_DMA(Srb->TargetId)) && (Srb->Cdb[0] != SCSIOP_VERIFY) )
    {
        if ( SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0] )
        {
            if ( IOC_PASS_THRU_COMMAND == SrbExtension->ucOpCode )
            {
                PPASS_THRU_DATA pPassThruData = (PPASS_THRU_DATA)(((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);
                if ( !pPassThruData->bIsPIO )
                {
                    bISUdma = TRUE;
                }
                else
                {
                    bISUdma = FALSE;
                }

            }
            else
            {
                bISUdma = TRUE;
            }
        }
        else
        {
            bISUdma = TRUE;
        }
    }
    else
    {
        bISUdma = FALSE;
    }

    // Hmmmm... the bug of forming improper SGLs when the transfer length > MAX_IDE_XFER_LENGTH 
    // has to be fixed here also... reproducable through IOMeter

    while ( ulBufLength )
    {
        ulCurLength = (ulBufLength>ulMaxIdeXferLength)?ulMaxIdeXferLength:ulBufLength;

		//
		// Use DMA.
		// Build S/G list using physical addresses.
		//

		success = BuildSgls(    DeviceExtension,
                                Srb,
                                SrbExtension->aSglEntry, &(SrbExtension->ulSglInsertionIndex), 
                                pucCurBufPtr, ulCurLength,
                                bISUdma);

        pucCurBufPtr += ulCurLength;
        ulBufLength -= ulCurLength;

	    if (!success) 
        {

		    return SRB_STATUS_ERROR;
	    }
    }


    Pdd->ulSglCount = SrbExtension->ulSglInsertionIndex - Pdd->ulStartSglInd;

	EnqueuePdd(DeviceExtension, Srb, Pdd);

	status = SRB_STATUS_PENDING;

	return(status);

} // end EnqueueSrb();

SRBSTATUS
EnqueueConsistancySrb(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
/*++

Routine Description:

	This function enqueues an SRB into the proper SINGLE device
	queue.

	Steps:

	1. Check if there's room for this request.
	2. Fill in Pdd.
	3. Build S/G list.
	4. Save SRB address in general list for use on abort request.
	5. Enqueue Pdd to device's work queue.

	DO NOT CALL THIS FUNCTION FOR LOGICAL DEVICES SRBs.

Arguments:

	DeviceExtension		Pointer to the device extension area for the HBA.
	Srb					Pointer to the SCSI request block.

Return Value:

	SRB_STATUS_INVALID_REQUEST	Could not build the S/G list.
	SRB_STATUS_PENDING			The Srb will cause an interrupt.
	SRB_STATUS_ERROR			Internal miniport error.
	SRB_STATUS_BUSY				Non more requests can be accepted
								(should not happen - internal error!)

--*/
{
	ULONG maxTransferLength, ulStartPrbInd;
	PPHYSICAL_DRIVE_DATA Pdd;
	USHORT sectorsRequested;
	PSRB_EXTENSION SrbExtension;
	ULONG startSector;
	SRBSTATUS status;
	BOOLEAN success;
    UCHAR uchRebuildTargetId, i;
    ULONG ulTargetId;

	DebugPrint((3, "\nEnqueueSrb: Entering routine.\n"));

    if (DeviceExtension->PendingSrbs >= DeviceExtension->ucMaxPendingSrbs) 
    {

		return SRB_STATUS_BUSY;
	}

	//
	// Initializations.
	//

	success = TRUE;

	SrbExtension = Srb->SrbExtension;

    sectorsRequested = GET_SECTOR_COUNT(Srb);

	startSector = GET_START_SECTOR(Srb);

	if ((sectorsRequested + startSector) > DeviceExtension->PhysicalDrive[Srb->TargetId].Sectors) {
        if ( ( ! (DeviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) ) && ( SCSIOP_INTERNAL_COMMAND != Srb->Cdb[0] ) )
            // Not sure about concept of Sectors in Atapi Device
            // so let me not checkup that for Atapi Devices.
            // Putting this checking outside of this if Condition will give an extra over head to the
            // IDE Drives
		    return SRB_STATUS_INVALID_REQUEST;
	}

	// Set number of Pdds.
	SrbExtension->NumberOfPdds = 2;

    for(i=0;i<2;i++)
    {
        PUCHAR DataBuffer;

	    // Get pointer to the only Pdd we need.
	    Pdd = &(SrbExtension->PhysicalDriveData[i]);

        if ( 0 == i )
        {
	        // Save TID.
	        Pdd->TargetId = SrbExtension->RebuildSourceId;
        }
        else
        {
	        // Save TID.
	        Pdd->TargetId = SrbExtension->RebuildTargetId;
        }

        ulTargetId = Pdd->TargetId;

	    // Save start sector number.
	    Pdd->ulStartSector = startSector;

	    // Save pointer to SRB.
	    Pdd->OriginalSrb = Srb;

	    maxTransferLength = DeviceExtension->PhysicalDrive[ulTargetId].MaxTransferLength;

        DataBuffer = 
            ((PUCHAR) Srb->DataBuffer) + (i * sectorsRequested * DeviceExtension->PhysicalDrive[ulTargetId].SectorSize);

        Pdd->ulStartSglInd = ((PSRB_EXTENSION)Pdd->OriginalSrb->SrbExtension)->ulSglInsertionIndex;

	    if (USES_DMA(ulTargetId) ) {
		    //
		    // Use DMA.
		    // Build S/G list using physical addresses.
		    //

		    success = BuildSgls(    DeviceExtension,
                                    Srb,
                                    SrbExtension->aSglEntry, &(SrbExtension->ulSglInsertionIndex), 
                                    Srb->DataBuffer, sectorsRequested * IDE_SECTOR_SIZE,
                                    TRUE);
	    } else {
		    //
		    // Use PIO.
		    // Build S/G list using logical addresses.
		    //
		    success = BuildSgls(    DeviceExtension,
                                    Srb,
                                    SrbExtension->aSglEntry, &(SrbExtension->ulSglInsertionIndex), 
                                    Srb->DataBuffer, sectorsRequested * IDE_SECTOR_SIZE,
                                    FALSE);
        }
	    if (!success) {

		    return SRB_STATUS_ERROR;
	    }

        Pdd->ulSglCount = SrbExtension->ulSglInsertionIndex - Pdd->ulStartSglInd;

    }

    ulStartPrbInd = SrbExtension->ulPrbInsertionIndex;
    ExportSglsToPrbs(DeviceExtension, &(SrbExtension->PhysicalDriveData[0]), (PSRB_EXTENSION)Pdd->OriginalSrb->SrbExtension);
    ExportSglsToPrbs(DeviceExtension, &(SrbExtension->PhysicalDriveData[1]), (PSRB_EXTENSION)Pdd->OriginalSrb->SrbExtension);
    Pdd->ulStartPrbInd = ulStartPrbInd;

	status = SRB_STATUS_PENDING;

	return(status);

} // end EnqueueConsistencySrb();

SRBSTATUS
SplitSrb(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG ulTargetId = Srb->TargetId;
    ULONG ulStripesPerRow, ulCurStripe, ulRaidMemberNumber;
    PSRB_EXTENSION pSrbExtension = (PSRB_EXTENSION)Srb->SrbExtension;
    ULONG ulLogDrvId;
    PPHYSICAL_DRIVE_DATA pMirrorPdd, Pdd;
    ULONG ulBufChunks, ulBufChunkInd;
    BOOLEAN success, bISUdma;
    UCHAR ucMirrorDriveId;

    if ( SCSIOP_VERIFY == Srb->Cdb[0] )
    {
        return EnqueueVerifySrb(DeviceExtension, Srb);
    }

    if ( SRB_STATUS_SUCCESS != SplitBuffers(DeviceExtension, Srb) )
    {   // may be the request is not a valid one
		return(SRB_STATUS_INVALID_REQUEST);
    }

	//
	// Initializations.
	//
    ulLogDrvId = Srb->TargetId;
    ulStripesPerRow = DeviceExtension->LogicalDrive[ulLogDrvId].StripesPerRow;
	pSrbExtension = Srb->SrbExtension;

	//
	// Enqueue the Pdds just filled in.
	//

	for (ulRaidMemberNumber = 0; ulRaidMemberNumber < ulStripesPerRow; ulRaidMemberNumber++) 
    {

		Pdd = &(pSrbExtension->PhysicalDriveData[ulRaidMemberNumber]);

		//
		// Check is this Pdd has been filled in.
		//

		if ( Pdd->ulBufChunkCount )
        {
            ulTargetId = Pdd->TargetId;
            ulBufChunks = Pdd->ulBufChunkCount;
            Pdd->ulStartSglInd = pSrbExtension->ulSglInsertionIndex;

	        if (USES_DMA(ulTargetId) && ((Srb->Cdb[0] == SCSIOP_READ) || (Srb->Cdb[0] == SCSIOP_WRITE) || (SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0] ) )) 
            {
                bISUdma = TRUE;
            }
            else
            {
                bISUdma = FALSE;
            }

            for(ulBufChunkInd=0;ulBufChunkInd<ulBufChunks;ulBufChunkInd++)
            {
		        //
		        // Use DMA.
		        // Build S/G list using physical addresses.
		        //
		        success = BuildSgls(    DeviceExtension,
                                        Srb,
                                        pSrbExtension->aSglEntry, 
                                        &(pSrbExtension->ulSglInsertionIndex), 
                                        Pdd->aBufChunks[ulBufChunkInd].pucBufPtr, 
                                        Pdd->aBufChunks[ulBufChunkInd].ulBufLength,
                                        bISUdma);

	            if (!success) 
                {
		            return SRB_STATUS_ERROR;
	            }
            }

            Pdd->ulSglCount = pSrbExtension->ulSglInsertionIndex - Pdd->ulStartSglInd;

			ucMirrorDriveId = DeviceExtension->PhysicalDrive[ulTargetId].ucMirrorDriveId;

			if (!IS_DRIVE_OFFLINE(ucMirrorDriveId)) 
            {   // mirror drive exists
                // Have a duplicate copy if SCSIOP_VERIFY / (SCSIOP_WRITE and the drive is not in rebuilding)
                // if the drive is in rebuilding state then the SCSIOP_WRITE command will be queued in TryToCompleteSrb
                switch (Srb->Cdb[0])
                {
                    case SCSIOP_WRITE:
                    {
                        {
                            ULONG ulPrbCount, ulPrbInd;
                            PPHYSICAL_REQUEST_BLOCK pPrb, pOriginalPrb;

                            // Enqueue Original Pdd
                            EnqueuePdd(DeviceExtension, Srb, Pdd);

                            // Make a duplicate Pdd
                            pMirrorPdd = &(pSrbExtension->PhysicalDriveData[ulRaidMemberNumber + ulStripesPerRow]);
                            pSrbExtension->NumberOfPdds++;
                            AtapiMemCpy((PUCHAR)pMirrorPdd, (PUCHAR)Pdd, sizeof(PHYSICAL_DRIVE_DATA));

                            pMirrorPdd->ulStartPrbInd = pSrbExtension->ulPrbInsertionIndex;
                            pMirrorPdd->TargetId = ucMirrorDriveId;
                            ulPrbCount = pMirrorPdd->ulPrbCount;

                            pOriginalPrb = &(pSrbExtension->Prb[Pdd->ulStartPrbInd]);
                            pPrb = &(pSrbExtension->Prb[pMirrorPdd->ulStartPrbInd]);
                            // Copy Prbs created for this Pdd
                            AtapiMemCpy((PUCHAR)pPrb, (PUCHAR)pOriginalPrb, (sizeof(PHYSICAL_REQUEST_BLOCK) * ulPrbCount) );
                            // Increment SRBExtension Ptrs
                            pSrbExtension->ulPrbInsertionIndex += ulPrbCount;

                            // Export all Pdds of mirror Drive to the physical Drive
                            for(ulPrbInd=0;ulPrbInd<ulPrbCount;ulPrbInd++)
                            {
                                pPrb[ulPrbInd].pPdd = pMirrorPdd;
                                ExportPrbToPhysicalDrive(  DeviceExtension, 
                                                            &(pPrb[ulPrbInd]), 
                                                            ucMirrorDriveId
                                                            );
                            }
                            continue;   // Go for the Next PDD
                        }
                        case SCSIOP_READ:
                        {
                            if ( PDS_Rebuilding == DeviceExtension->PhysicalDrive[ucMirrorDriveId].Status )
                                break;

                            if (Raid10 == DeviceExtension->LogicalDrive[Srb->TargetId].RaidLevel)
                                // for Raid10 there will not be any concept of load balancing... we 
                                // did the optimal configuration of the drives that are to be taken for reading
                                break;

                            if (DeviceExtension->PhysicalDrive[ulTargetId].QueueingFlag == 0) 
                            {	// fill into queue0
                                // if queue 0 is full and queue 1 is about empty, switch queue flag to 1
                                if ((DeviceExtension->PhysicalDrive[ulTargetId].ucCommandCount  >= DeviceExtension->ucOptMaxQueueSize) &&
                                (DeviceExtension->PhysicalDrive[ucMirrorDriveId].ucCommandCount  <= DeviceExtension->ucOptMinQueueSize)) 
                                {
                                    DeviceExtension->PhysicalDrive[ulTargetId].QueueingFlag = 1;
                                    DeviceExtension->PhysicalDrive[ucMirrorDriveId].QueueingFlag = 0;
                                }
                            } 
                            else 
                            { // fill into queue 1
                                // if queue 1 is full and queue 0 is about empty, switch queue flag to 0
                                if ((DeviceExtension->PhysicalDrive[ucMirrorDriveId].ucCommandCount  >= DeviceExtension->ucOptMaxQueueSize) &&
                                (DeviceExtension->PhysicalDrive[ulTargetId].ucCommandCount  <= DeviceExtension->ucOptMinQueueSize)) 
                                {
                                    DeviceExtension->PhysicalDrive[ulTargetId].QueueingFlag = 0;
                                    DeviceExtension->PhysicalDrive[ucMirrorDriveId].QueueingFlag = 1;
                                }
                                Pdd->TargetId = ucMirrorDriveId;
                            }

                        }
                        break;
                    }
			    } // mirror drive exists
            }

			//
			// Add Pdd to the drive queue.
			//
			EnqueuePdd(DeviceExtension, Srb, Pdd);
        } // if ( Pdd->ulBufChunkCount )
    } // for all stripes per row

	return(SRB_STATUS_PENDING);
} // end of SplitSrb()


SRBSTATUS
EnqueuePdd(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb,
	IN PPHYSICAL_DRIVE_DATA Pdd
)

/*++

Routine Description:

	This function enqueues 'Pdd' on the appropriate
	device queue, sorted by ascending start sector number.

Arguments:

	DeviceExtension		Pointer to miniport instance.
	Srb					Pointer to the SRB that was split into Pdds.
	Pdd					Pointer to a Pdd that's part of 'Srb'

Return Value:

	SRB_STATUS_PENDING		Success.
	SRB_INVALID_REQUEST		Could not build S/G list.

--*/
{

    if ( ExportSglsToPrbs(DeviceExtension, Pdd, (PSRB_EXTENSION)Pdd->OriginalSrb->SrbExtension) )
        return(SRB_STATUS_PENDING);
    else
        return(SRB_STATUS_ERROR);

} // end EnqueuePdd()

SRBSTATUS
SplitBuffers(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG ulLogDrvId, ulStripesPerRow;
    PSRB_EXTENSION pSrbExtension;
    PPHYSICAL_DRIVE_DATA Pdd;
    ULONG ulSectorsRequested;
    ULONG ulSectorsPerStripe, ulStartSector;
    ULONG ulEndStripeNumber, ulCurrentStripeNumber;
    ULONG ulRaidMemberNumber, ulSectorsToProcess, ulLogicalSectorStartAddress;
    ULONG ulTempStartSector, ulEndAddressOfcurrentStripe;
    PUCHAR pucBuffer, pucCurBufPtr;
    ULONG ulMaxIdeXferLength, ulBufLength, ulCurLength;


	//
	// Initializations.
	//
    ulLogDrvId = Srb->TargetId;
    ulStripesPerRow = DeviceExtension->LogicalDrive[ulLogDrvId].StripesPerRow;
	pSrbExtension = Srb->SrbExtension;

	//
	// the drive failed 
	//      RAID0:    one or both drives failed
	//		RAID1/10: one or more pair of mirroring drives failed
	//
	if (LDS_OffLine == DeviceExtension->LogicalDrive[ulLogDrvId].Status) {
		return(SRB_STATUS_ERROR);
	}

	ulSectorsRequested = GET_SECTOR_COUNT(Srb);

	ulStartSector = GET_START_SECTOR(Srb);

#ifdef KEEP_LOG
    if ( ulStartLog )
    {
        CommandLog[ulStartInd].ulCmd = (ULONG)Srb->Cdb[0];
        CommandLog[ulStartInd].ulStartSector = ulStartSector;
        CommandLog[ulStartInd].ulSectorCount = ulSectorsRequested;
        ulStartInd = (ulStartInd + 1 ) % MAX_LOG_COUNT;;
    }
#endif

	if ((ulSectorsRequested + ulStartSector) > DeviceExtension->LogicalDrive[ulLogDrvId].Sectors) {

		return(SRB_STATUS_INVALID_REQUEST);
	}

	ulSectorsPerStripe = DeviceExtension->LogicalDrive[ulLogDrvId].StripeSize;
	ulStripesPerRow = DeviceExtension->LogicalDrive[ulLogDrvId].StripesPerRow;

	//
	// Get the logical stripe number for the end sector.
	//

	ulEndStripeNumber = (ulStartSector + ulSectorsRequested - 1) / ulSectorsPerStripe;
	
	//
	// Get the logical stripe number for the start sector.
	//

	ulCurrentStripeNumber = ulStartSector / ulSectorsPerStripe;
	
	//
	// Get the address of the first logical sector.
	//

	ulLogicalSectorStartAddress = ulStartSector;
	
	ulMaxIdeXferLength = MAX_SECTORS_PER_IDE_TRANSFER * IDE_SECTOR_SIZE;

	pucBuffer = Srb->DataBuffer;

	//
	// While there are still sectors to be processed...
	//

	while (ulSectorsRequested != 0) 
    {
		ulEndAddressOfcurrentStripe = ((ulCurrentStripeNumber+1) * ulSectorsPerStripe) - 1;

		if (ulCurrentStripeNumber != ulEndStripeNumber) {

			ulSectorsToProcess =
				(USHORT)(ulEndAddressOfcurrentStripe - ulLogicalSectorStartAddress + 1);

		} else {

			ulSectorsToProcess = ulSectorsRequested;
		}

		//
		// Calculate the number of the RAID member that will handle this stripe.
		//

		ulRaidMemberNumber = (UCHAR)(ulCurrentStripeNumber % (ULONG)ulStripesPerRow);

		//
		// Get pointer to Pdd.
		//

		Pdd = &pSrbExtension->PhysicalDriveData[ulRaidMemberNumber];

        //
		// Start sector to be read/written in the physical drive.
		//

		ulTempStartSector = ((ulCurrentStripeNumber / ulStripesPerRow) *  ulSectorsPerStripe ) + 
			(ulLogicalSectorStartAddress - (ulCurrentStripeNumber * ulSectorsPerStripe));


        if ( !Pdd->ulBufChunkCount )
        {
			//Save start sector address.
			Pdd->ulStartSector = ulTempStartSector;

			// Save TID.
            //
            // Get TID of physical drive that will handle this stripe.
            //
			Pdd->TargetId = (UCHAR)DeviceExtension->LogicalDrive[ulLogDrvId].PhysicalDriveTid[ulRaidMemberNumber];

			// Save pointer to SRB.
			Pdd->OriginalSrb = Srb;

			// Update number of Pdds into which the SRB has been split.
			pSrbExtension->NumberOfPdds++;
        }

        // Split the buf chunks so that we can send them in a single transfer
        // if we don't do this we will be in the trouble of giving incorrect buffer
        // length since sometimes the scatter gather list elements will be split 
        // in such a way that forces the ExportSglsToPrbs function 
        // to split the sgls to non multiples of IDE_SECTOR_SIZE
		//
		// pucBuffer offset in the Srb->DataBuffer.
		//
        pucCurBufPtr = &(pucBuffer[((ulLogicalSectorStartAddress - ulStartSector) * IDE_SECTOR_SIZE)]);
        ulBufLength = ulSectorsToProcess * IDE_SECTOR_SIZE;

        while ( ulBufLength )
        {
            ulCurLength = (ulBufLength>ulMaxIdeXferLength)?ulMaxIdeXferLength:ulBufLength;
            Pdd->aBufChunks[Pdd->ulBufChunkCount].pucBufPtr     = pucCurBufPtr;
            Pdd->aBufChunks[Pdd->ulBufChunkCount++].ulBufLength = ulCurLength;
            pucCurBufPtr += ulCurLength;
            ulBufLength -= ulCurLength;
        }


		//
		// Increment ulLogicalSectorStartAddress and ulCurrentStripeNumber.
		//

		ulLogicalSectorStartAddress = ulEndAddressOfcurrentStripe + 1;
		ulCurrentStripeNumber++;

		//
		// Decrement the number of sectors left.
		//

		ulSectorsRequested -= ulSectorsToProcess;	

	}

    return SRB_STATUS_SUCCESS;
}


BOOLEAN
BuildSgls
(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PSGL_ENTRY pSglEntry,
	IN PULONG pulCurSglInd,
    IN PUCHAR pucBuffer,
	IN ULONG ulLength,
    IN BOOLEAN bPhysical
)
{
    ULONG ulCurLength = ulLength;
    ULONG ulTempLength, ulLengthLeftInBoundary;
    ULONG ulContiguousMemoryLength;
    ULONG physicalAddress;
    ULONG ulSglInsertionIndex = *pulCurSglInd;
    PSRB_BUFFER pSrbBuffer = (PSRB_BUFFER)pucBuffer;
    UCHAR ucSrbTargetId = 0;
#ifdef DBG
    BOOLEAN bPrintDetails = FALSE;
#endif

    if (SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0]) 
    {
        if ( IOC_PASS_THRU_COMMAND != ((PSRB_IO_CONTROL) Srb->DataBuffer)->ControlCode )    
            // for pass thru command it is not necessary to adjust the pointer ... caller will take care of this
            pucBuffer = ((PUCHAR) pSrbBuffer->caDataBuffer) + 2;
    }

    if ( !bPhysical )   // This is logical... so each contiguous virtual address will become one Sgl
    {
        pSglEntry[*pulCurSglInd].Logical.Address = pucBuffer;
        pSglEntry[*pulCurSglInd].Logical.Length = ulLength;
        *pulCurSglInd = *pulCurSglInd + 1;
        return TRUE;
    }

    // so this needs Physical Addresses
	do 
    {
        //
	    // Get physical address and length of contiguous
	    // physical buffer.
        //
        
        if (SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0])
        {
            ucSrbTargetId = Srb->TargetId;
            Srb->TargetId = ((PSRB_EXTENSION) (Srb->SrbExtension))->ucOriginalId;
        }

        physicalAddress = ScsiPortConvertPhysicalAddressToUlong(
	                		ScsiPortGetPhysicalAddress(
							DeviceExtension,
	                        Srb,
	                        pucBuffer,
	                        &ulContiguousMemoryLength));

        if (SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0])
        {
            Srb->TargetId = ucSrbTargetId;
        }

		if (physicalAddress == 0) {

			return(FALSE);
		}

#if DBG
	
		if (bPrintDetails) {

			DebugPrint((4, "-------------physicalAddress = %lxh\n", physicalAddress));
			DebugPrint((4, "------contiguousMemoryLength = %lxh\n", ulContiguousMemoryLength));
		}
#endif
	
		while (ulContiguousMemoryLength > 0 && ulCurLength > 0) {

			ulLength = ulContiguousMemoryLength;	  

#if DBG
			if (bPrintDetails) {

				DebugPrint((3, "---1------------------length = %lxh\n", ulLength));
			}
#endif
			//
			// Make sure that the physical region does not cross 64KB boundary.
			//

	    	ulLengthLeftInBoundary = REGION_HW_BOUNDARY -
									((ULONG)physicalAddress & (REGION_HW_BOUNDARY - 1));

			if (ulLength > (ULONG)ulLengthLeftInBoundary) {
				ulLength = ulLengthLeftInBoundary;
			}

#if DBG
			if (bPrintDetails) {

				DebugPrint((3, "---2------------------length = %lxh\n", ulLength));
			}
#endif

			//
		    // If length of physical memory is more
		    // than bytes left in transfer, use bytes
		    // left as final length.
		    //
	
		    if  (ulLength > ulCurLength) {
		        ulLength = ulCurLength;
		    }
#if DBG
	
			if (bPrintDetails) {

				DebugPrint((3, "---3------------------length = %lxh\n", ulLength));
			}
#endif
		
			// DWORD alignment check.
		    ASSERT(((ULONG)physicalAddress & 3) == 0);

#if DBG
	
			if (bPrintDetails) {

				DebugPrint((
						3,
						"--------------------&sgl[%ld] = %lxh\n",
						ulSglInsertionIndex,
						&(pSglEntry[ulSglInsertionIndex])
						));
			}

#endif

            if (physicalAddress & 0x01)
            {
                return FALSE;
            }

		    pSglEntry[ulSglInsertionIndex].Physical.Address = (PVOID)physicalAddress;
		    // Begin Parag, Vasu - 7 March 2001
			// Do not typecast this to USHORT as a 64K length will make it zero.
			// pSglEntry[ulSglInsertionIndex].Physical.Length = ulLength;
            // Vasu - This has been taken care now in ExportSglsToPrbs.
            // This assignment will make the left side 0 which is still taken care
            // at the ExportSglsToPrbs.
			pSglEntry[ulSglInsertionIndex].Physical.Length = (USHORT) ulLength;
			// End Parag, Vasu

		    //
		    // Adjust Counts and Pointers.
		    // 

		    pucBuffer = (PUCHAR)pucBuffer + ulLength;
		    ulContiguousMemoryLength -= ulLength;
		    ulCurLength -= ulLength;  
		    physicalAddress += ulLength;
		    ulSglInsertionIndex++;
		    
			//
		    // Check for SGL not too big.
			//

		    if (ulSglInsertionIndex >= MAX_SGL_ENTRIES_PER_SRB) {
		        return FALSE;
			}
		}
	
	} while (ulCurLength != 0);

    *pulCurSglInd = ulSglInsertionIndex;

    return TRUE;
}


VOID
DiscardResidualData(
	IN PATAPI_REGISTERS_1 BaseIoAddress
)

{
	LONG i;
	UCHAR statusByte;

	for (i = 0; i < 0x10000; i++) {
	
		GET_BASE_STATUS(BaseIoAddress, statusByte);
	
   		if (statusByte & IDE_STATUS_DRQ) {

      		WAIT_ON_BASE_BUSY(BaseIoAddress, statusByte);
	
			ScsiPortReadPortUshort(&BaseIoAddress->Data);
	
	    } else {
	
	    	break;
	    }
	}
	
	return;

} // end DiscardResidualData()

BOOLEAN
ExportSglsToPrbs(
            IN PHW_DEVICE_EXTENSION DeviceExtension,
            IN PPHYSICAL_DRIVE_DATA Pdd,
            IN PSRB_EXTENSION pSrbExtension
            )
{
	PSGL_ENTRY pSglEntry;
    ULONG ulMaxIdeXferLength, ulCurPrbInsInd, ulSglInd, ulCurXferLength, ulSglParts;
    ULONG ulSglCount, ulPrbInd;
    PPHYSICAL_REQUEST_BLOCK pPrb;
    UCHAR ucCmd;

	ulMaxIdeXferLength = MAX_SECTORS_PER_IDE_TRANSFER * IDE_SECTOR_SIZE;
	pSglEntry = &(pSrbExtension->aSglEntry[Pdd->ulStartSglInd]);
    pPrb = &(pSrbExtension->Prb[pSrbExtension->ulPrbInsertionIndex]);
    Pdd->ulStartPrbInd = pSrbExtension->ulPrbInsertionIndex;
    ulSglCount = Pdd->ulSglCount;
    ucCmd = Pdd->OriginalSrb->Cdb[0];

    if ( SCSIOP_INTERNAL_COMMAND == ucCmd )
    {
        switch ( pSrbExtension->ucOpCode )
        {
            case IOC_GET_ERROR_LOG:
                ucCmd = SCSIOP_READ;    // Just Read
                break;
            case IOC_ERASE_ERROR_LOG:   // Read and then write
                ucCmd = SCSIOP_READ;
                break;
            case IOC_GET_IRCD:          // Just Read
            case IOC_GET_SECTOR_DATA:
                ucCmd = SCSIOP_READ;
                break;
            case IOC_SET_IRCD:          // Just Write
                ucCmd = SCSIOP_WRITE;
                break;
            case IOC_REBUILD:           // Read and then Write
                ucCmd = SCSIOP_READ;
                break;
            case IOC_CONSISTENCY_CHECK:
                ucCmd = SCSIOP_READ;
                break;
            case IOC_EXECUTE_SMART_COMMAND:
                ucCmd = SCSIOP_EXECUTE_SMART_COMMAND;
                break;
            default:
                  // remaining Internal Commands will not come into this path
                  // nothing to be done
                break;
        }
    }


    // Begin Vasu - 21 January 2001
    // Code rewrite for Exporting SGLs to PRBs.
	ulCurPrbInsInd = 0;
    ulSglInd = 0;

    do
    {
        ulCurXferLength = 0;
        pPrb[ulCurPrbInsInd].ulVirtualAddress = (ULONG)(&pSglEntry[ulSglInd]);
        pPrb[ulCurPrbInsInd].ulSglCount = 0;

        while ( (ulCurXferLength < ulMaxIdeXferLength) &&
                (ulSglInd < ulSglCount) )
        {
            // Begin Vasu - 7 March 2001
            // Send 64K if SGL Entry has 0 in it.
            // SGL Entry should be 0 for 64K transfers. But for our calculation we
            // need 64K and not 0.
            // ulCurXferLength += pSglEntry[ulSglInd].Physical.Length;
            ulCurXferLength += 
                (pSglEntry[ulSglInd].Physical.Length ? 
                pSglEntry[ulSglInd].Physical.Length :
                REGION_HW_BOUNDARY);    // Return 64K
            // End Vasu
            pPrb[ulCurPrbInsInd].ulSglCount++;
            ulSglInd++;

        }

        if (ulCurXferLength > ulMaxIdeXferLength)
        {
            // Go back to prev. SGL Index to take that into account
            ulSglInd--;
            // if greater, then we must remove the last SGL Entry.
            // Vasu - 27 March 2001 - Missed this one on 7th.
            ulCurXferLength -= 
                (pSglEntry[ulSglInd].Physical.Length ? 
                pSglEntry[ulSglInd].Physical.Length :
                REGION_HW_BOUNDARY);    // Return 64K
            pPrb[ulCurPrbInsInd].ulSglCount--;
        }

        // Complete This PRB.
        pPrb[ulCurPrbInsInd].ucCmd = ucCmd;
        pPrb[ulCurPrbInsInd].pPdd = Pdd;
        pPrb[ulCurPrbInsInd].pSrbExtension = pSrbExtension;

        if ( (SCSIOP_INTERNAL_COMMAND == ucCmd) && (IOC_PASS_THRU_COMMAND == pSrbExtension->ucOpCode) )
        {
            pPrb[ulCurPrbInsInd].ulSectors = ulCurXferLength;
        }
        else
        {
            pPrb[ulCurPrbInsInd].ulSectors = ulCurXferLength / IDE_SECTOR_SIZE;
        }

        if ( ulCurPrbInsInd )
        {
            pPrb[ulCurPrbInsInd].ulStartSector = 
                pPrb[ulCurPrbInsInd - 1].ulStartSector + 
                pPrb[ulCurPrbInsInd - 1].ulSectors;
        }
        else
        {
            pPrb[ulCurPrbInsInd].ulStartSector = Pdd->ulStartSector;
        }
        
        // Goto Next PRB
        ulCurPrbInsInd ++;

    } while (ulSglInd < ulSglCount);
    // End Vasu

    for(ulPrbInd=0;ulPrbInd<ulCurPrbInsInd;ulPrbInd++)
    {
        ExportPrbToPhysicalDrive(  DeviceExtension, 
                                            &(pPrb[ulPrbInd]), 
                                            Pdd->TargetId
                                         );
    }

	pSrbExtension->ulPrbInsertionIndex += ulCurPrbInsInd;
    Pdd->ulPrbCount = ulCurPrbInsInd;
    Pdd->ulPrbsRemaining = ulCurPrbInsInd;
    DebugPrint((DEFAULT_DISPLAY_VALUE, "ESTP %X", ulCurPrbInsInd));

    return TRUE;
}

BOOLEAN ExportPrbToPhysicalDrive(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PPHYSICAL_REQUEST_BLOCK pSglpartition,
    IN ULONG ulTargetId
    )
/*++

To be Done
Yet to handle the case of the queue becoming full 

--*/
{
    UCHAR ucSglPartInd, ucHead, ucTail;
    PPHYSICAL_DRIVE pPhysicalDrive = &(DeviceExtension->PhysicalDrive[ulTargetId]);

    // Let us put the Physical Request Block's pointer in Physical Drive Array
    ucHead = DeviceExtension->PhysicalDrive[ulTargetId].ucHead;
    ucTail = DeviceExtension->PhysicalDrive[ulTargetId].ucTail;

    pPhysicalDrive->pPrbList[ucTail] = pSglpartition;
    ucTail = (ucTail + 1) % MAX_NUMBER_OF_PHYSICAL_REQUEST_BLOCKS_PER_DRIVE;
    pPhysicalDrive->ucTail = ucTail;

    pPhysicalDrive->ucCommandCount++;

#ifdef DBG
    if ( pPhysicalDrive->ucCommandCount > MAX_NUMBER_OF_PHYSICAL_REQUEST_BLOCKS_PER_DRIVE )
        STOP;
#endif

    return TRUE;
}


#ifdef DBG
void
PrintPhysicalCommandDetails(PPHYSICAL_COMMAND pPhysicalCommand)
{
    ULONG ulLength = 0, ulSglInd;
    PSGL_ENTRY pSglEntry;

    DebugPrint((3, "TargetId : %ld\tStart : %x\tSecCount : %ld\tStartIndex : %ld\tNumberOfCommand : %ld\n", 
                        (ULONG)pPhysicalCommand->TargetId, 
                        (ULONG)pPhysicalCommand->ulStartSector,
                        (ULONG)pPhysicalCommand->ulCount,
                        (ULONG)pPhysicalCommand->ucStartInd,
                        (ULONG)pPhysicalCommand->ucCmdCount));

    pSglEntry = (PSGL_ENTRY)pPhysicalCommand->SglBaseVirtualAddress;

    for(ulSglInd=0;ulSglInd<pPhysicalCommand->ulTotSglCount;ulSglInd++)
    {
        DebugPrint((3,"%x:%ld:%ld\n", 
                                (ULONG)pSglEntry[ulSglInd].Physical.Address, 
                                (ULONG)pSglEntry[ulSglInd].Physical.Length,
                                (ULONG)pSglEntry[ulSglInd].Physical.EndOfListFlag));
        ulLength += pSglEntry[ulSglInd].Physical.Length;
        if ( pSglEntry[ulSglInd].Physical.EndOfListFlag )
        {
            break;
        }
    }

    DebugPrint((3, "Total Xfer Length : %ld\n", ulLength));

#ifdef DBG
    if ( ( (pPhysicalCommand->ulCount * 512) != ulLength ) && ((pPhysicalCommand->ucCmd != SCSIOP_VERIFY) ) )
    {
        STOP;
    }
#endif

}
#endif

BOOLEAN
RemoveSrbFromPendingList(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{

	LONG i;
	BOOLEAN success = FALSE;
    PSRB_EXTENSION SrbExtension = Srb->SrbExtension;

	DebugPrint((3, "\nRemoveSrbFromPendingList: Entering routine.\n"));

    i = SrbExtension->SrbInd;

    DebugPrint((DEFAULT_DISPLAY_VALUE, " RSFB%ld ", i));

    if ( DeviceExtension->PendingSrb[i] != Srb)
    {
		ScsiPortLogError(   DeviceExtension, Srb, Srb->PathId, Srb->TargetId, Srb->Lun, SP_INTERNAL_ADAPTER_ERROR, 
                            HYPERDISK_ERROR_PENDING_SRBS_COUNT);

        success = FALSE;
    }
    else
    {
		DeviceExtension->PendingSrb[i] = NULL;
		DeviceExtension->PendingSrbs--;

        success = TRUE;
    }

	ASSERT(i < DeviceExtension->ucMaxPendingSrbs);

    return(success);

} // end RemoveSrbFromPendingList()

ULONG 
AssignSrbExtension(
    IN PHW_DEVICE_EXTENSION DeviceExtension, 
    IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG i = 0;
    PSRB_EXTENSION SrbExtension = NULL;


    for (i = 0; i < DeviceExtension->ucMaxPendingSrbs; i++) 
    {
        if (DeviceExtension->PendingSrb[i] == NULL) 
        {
            break;
        }
    }

    ASSERT( i < DeviceExtension->ucMaxPendingSrbs );

    if ( i < DeviceExtension->ucMaxPendingSrbs ) 
    {

        DebugPrint((3, "AssignSrbExtension: Adding SRB 0x%lx.\n", Srb));

#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY
        
        Srb->SrbExtension = &(DeviceExtension->pSrbExtension[i]);

#endif // HD_ALLOCATE_SRBEXT_SEPERATELY

        SrbExtension = Srb->SrbExtension;

        AtapiFillMemory((PUCHAR)SrbExtension, sizeof(SRB_EXTENSION), 0);

        SrbExtension->SrbInd = (UCHAR)i;

        DeviceExtension->PendingSrb[i] = Srb;

        DeviceExtension->PendingSrbs++;

#ifdef DBG
        if ( DeviceExtension->PendingSrbs > 1 )
            DebugPrint((DEFAULT_DISPLAY_VALUE, " MPS%ld ", DeviceExtension->PendingSrbs));
#endif

        DebugPrint((DEFAULT_DISPLAY_VALUE, " ASE%ld ", i));
    }

    return i;
}


UCHAR FlushCache(PHW_DEVICE_EXTENSION DeviceExtension, UCHAR ucTargetId)
{
    PIDE_REGISTERS_1 baseIoAddress1;
    PIDE_REGISTERS_2 baseIoAddress2;
    UCHAR ucStatus;
    ULONG ulWaitSec;

    baseIoAddress1 = DeviceExtension->BaseIoAddress1[(ucTargetId>>1)];
    baseIoAddress2 = DeviceExtension->BaseIoAddress2[(ucTargetId>>1)];

    SELECT_DEVICE(baseIoAddress1, ucTargetId);
    WAIT_ON_ALTERNATE_STATUS_BUSY(baseIoAddress2, ucStatus);
    SELECT_DEVICE(baseIoAddress1, ucTargetId);
    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_FLUSH_CACHE);

    // IDE Specs says this command can take more than most 30 Seconds
    // so we are awaiting one minute
    for(ulWaitSec=0;ulWaitSec<60;ulWaitSec++)
    {
        WAIT_ON_ALTERNATE_STATUS_BUSY(baseIoAddress2, ucStatus);    

        if ( !(ucStatus & IDE_STATUS_BUSY) )
            break;

        if ( ucStatus & IDE_STATUS_ERROR )  // there is no meaning waiting more time when error occured.
        {
            break;
        }
    }

    GET_STATUS(baseIoAddress1, ucStatus);  // Read the Base Status this will clear interrupt raised if any

    return ucStatus;
}

UCHAR DisableRWBCache(PHW_DEVICE_EXTENSION DeviceExtension, UCHAR ucTargetId)
{
    PIDE_REGISTERS_1 baseIoAddress1;
    PIDE_REGISTERS_2 baseIoAddress2;
    UCHAR ucStatus;
    ULONG ulWaitSec;

    baseIoAddress1 = DeviceExtension->BaseIoAddress1[(ucTargetId>>1)];
    baseIoAddress2 = DeviceExtension->BaseIoAddress2[(ucTargetId>>1)];

    SELECT_DEVICE(baseIoAddress1, ucTargetId);
    GET_STATUS(baseIoAddress1, ucStatus);
	ScsiPortWritePortUchar( (((PUCHAR)baseIoAddress1) + 1), FEATURE_DISABLE_WRITE_CACHE);
	ScsiPortWritePortUchar(&(baseIoAddress1->Command), IDE_COMMAND_SET_FEATURES);
	WAIT_ON_BASE_BUSY(baseIoAddress1, ucStatus);

    SELECT_DEVICE(baseIoAddress1, ucTargetId);
    GET_STATUS(baseIoAddress1, ucStatus);
	ScsiPortWritePortUchar( (((PUCHAR)baseIoAddress1) + 1), FEATURE_DISABLE_READ_CACHE);
	ScsiPortWritePortUchar(&(baseIoAddress1->Command), IDE_COMMAND_SET_FEATURES);
	WAIT_ON_BASE_BUSY(baseIoAddress1, ucStatus);

    return ucStatus;
}

SRBSTATUS
EnqueueVerifySrb
(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG ulStripesPerRow, ulRaidMemberNumber;
    PSRB_EXTENSION pSrbExtension = (PSRB_EXTENSION)Srb->SrbExtension;
    PPHYSICAL_DRIVE_DATA pMirrorPdd, Pdd;
    UCHAR ucMirrorDriveId;

    if ( SRB_STATUS_SUCCESS != SplitVerifyBuffers(DeviceExtension, Srb) )
    {   // may be the request is not a valid one
		return(SRB_STATUS_INVALID_REQUEST);
    }

    if ( DeviceExtension->IsSingleDrive[Srb->TargetId] )
    {
		Pdd = &(pSrbExtension->PhysicalDriveData[0]);
        Pdd->ulStartSglInd = 0;
        Pdd->ulSglCount = 0;
        ExportVerifySglsToPrbs(DeviceExtension, Pdd, pSrbExtension);
        return SRB_STATUS_PENDING;
    }

	//
	// Initializations.
	//
    ulStripesPerRow = DeviceExtension->LogicalDrive[Srb->TargetId].StripesPerRow;
	pSrbExtension = Srb->SrbExtension;

	//
	// Enqueue the Pdds just filled in.
	//
	for (ulRaidMemberNumber = 0; ulRaidMemberNumber < ulStripesPerRow; ulRaidMemberNumber++) 
    {

		Pdd = &(pSrbExtension->PhysicalDriveData[ulRaidMemberNumber]);

		//
		// Check is this Pdd has been filled in.
		//
		if ( Pdd->OriginalSrb == Srb )
        {
            Pdd->ulStartSglInd = 0;
            Pdd->ulSglCount = 0;

            ExportVerifySglsToPrbs(DeviceExtension, Pdd, pSrbExtension);

			ucMirrorDriveId = DeviceExtension->PhysicalDrive[Pdd->TargetId].ucMirrorDriveId;

			if (!IS_DRIVE_OFFLINE(ucMirrorDriveId)) 
            {   // mirror drive exists
                // Have a duplicate copy if SCSIOP_VERIFY / (SCSIOP_WRITE and the drive is not in rebuilding)
                // if the drive is in rebuilding state then the SCSIOP_WRITE command will be queued in TryToCompleteSrb
                pMirrorPdd = &(pSrbExtension->PhysicalDriveData[ulRaidMemberNumber + ulStripesPerRow]);
                pSrbExtension->NumberOfPdds++;
                AtapiMemCpy((PUCHAR)pMirrorPdd, (PUCHAR)Pdd, sizeof(PHYSICAL_DRIVE_DATA));
                pMirrorPdd->TargetId = ucMirrorDriveId;
                ExportVerifySglsToPrbs(DeviceExtension, pMirrorPdd, pSrbExtension);
            }

        } // if ( Pdd->OriginalSrb == Srb )

    } // for all stripes per row

	return(SRB_STATUS_PENDING);
} // end of EnqueueVerifySrb()


SRBSTATUS
SplitVerifyBuffers(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG ulLogDrvId, ulStripesPerRow;
    PSRB_EXTENSION pSrbExtension;
    PPHYSICAL_DRIVE_DATA Pdd;
    ULONG ulSectorsRequested;
    ULONG ulSectorsPerStripe, ulStartSector;
    ULONG ulEndStripeNumber, ulCurrentStripeNumber;
    ULONG ulRaidMemberNumber, ulSectorsToProcess, ulLogicalSectorStartAddress;
    ULONG ulTempStartSector, ulEndAddressOfcurrentStripe;


	//
	// Initializations.
	//
    ulLogDrvId = Srb->TargetId;
    ulStripesPerRow = DeviceExtension->LogicalDrive[ulLogDrvId].StripesPerRow;
	pSrbExtension = Srb->SrbExtension;

	ulSectorsRequested = GET_SECTOR_COUNT(Srb);

	ulStartSector = GET_START_SECTOR(Srb);

    if ( DeviceExtension->IsSingleDrive[ulLogDrvId] )
    {
	    if ((ulSectorsRequested + ulStartSector) > DeviceExtension->PhysicalDrive[ulLogDrvId].Sectors) 
        {
		    return(SRB_STATUS_INVALID_REQUEST);
	    }

		//
		// Get pointer to Pdd.
		//

		Pdd = &(pSrbExtension->PhysicalDriveData[0]);

		//Save start sector address.
		Pdd->ulStartSector = ulStartSector;

        //
        // Get TID of physical drive that will handle this stripe.
        //
		Pdd->TargetId = (UCHAR)ulLogDrvId;

		// Save pointer to SRB.
		Pdd->OriginalSrb = Srb;

		// Update number of Pdds into which the SRB has been split.
		pSrbExtension->NumberOfPdds++;

        // As this command is verify command we will 
        // use only ulsectorcount variable we will not use the BufChunk variables
        Pdd->ulSectorCount = ulSectorsRequested;

        return SRB_STATUS_SUCCESS;
    }

	//
	// the drive failed 
	//      RAID0:    one or both drives failed
	//		RAID1/10: one or more pair of mirroring drives failed
	//
	if (LDS_OffLine == DeviceExtension->LogicalDrive[ulLogDrvId].Status) 
    {
		return(SRB_STATUS_ERROR);
	}

	if ((ulSectorsRequested + ulStartSector) > DeviceExtension->LogicalDrive[ulLogDrvId].Sectors) 
    {
		return(SRB_STATUS_INVALID_REQUEST);
	}

#ifdef DBG
    if ( SCSIOP_VERIFY == Srb->Cdb[0] )
    {
        DebugPrint((0, "Start : %ld\tSecCnt : %ld\t", ulStartSector, ulSectorsRequested));

    }
#endif

	ulSectorsPerStripe = DeviceExtension->LogicalDrive[ulLogDrvId].StripeSize;
	ulStripesPerRow = DeviceExtension->LogicalDrive[ulLogDrvId].StripesPerRow;

	//
	// Get the logical stripe number for the end sector.
	//

	ulEndStripeNumber = (ulStartSector + ulSectorsRequested - 1) / ulSectorsPerStripe;
	
	//
	// Get the logical stripe number for the start sector.
	//

	ulCurrentStripeNumber = ulStartSector / ulSectorsPerStripe;
	
	//
	// Get the address of the first logical sector.
	//

	ulLogicalSectorStartAddress = ulStartSector;
	
	//
	// While there are still sectors to be processed...
	//

	while (ulSectorsRequested != 0) 
    {
		ulEndAddressOfcurrentStripe = ((ulCurrentStripeNumber+1) * ulSectorsPerStripe) - 1;

		if (ulCurrentStripeNumber != ulEndStripeNumber) 
        {
			ulSectorsToProcess =
				(USHORT)(ulEndAddressOfcurrentStripe - ulLogicalSectorStartAddress + 1);

		} 
        else 
        {
			ulSectorsToProcess = ulSectorsRequested;
		}

		//
		// Calculate the number of the RAID member that will handle this stripe.
		//

		ulRaidMemberNumber = (UCHAR)(ulCurrentStripeNumber % (ULONG)ulStripesPerRow);

		//
		// Get pointer to Pdd.
		//

		Pdd = &(pSrbExtension->PhysicalDriveData[ulRaidMemberNumber]);

        //
		// Start sector to be read/written in the physical drive.
		//

		ulTempStartSector = ( ( ulCurrentStripeNumber / ulStripesPerRow ) *  ulSectorsPerStripe ) + 
			( ulLogicalSectorStartAddress - ( ulCurrentStripeNumber * ulSectorsPerStripe ) );


        if ( Pdd->OriginalSrb != Srb )
        {
			//Save start sector address.
			Pdd->ulStartSector = ulTempStartSector;

            //
            // Get TID of physical drive that will handle this stripe.
            //
			Pdd->TargetId = (UCHAR)DeviceExtension->LogicalDrive[ulLogDrvId].PhysicalDriveTid[ulRaidMemberNumber];

			// Save pointer to SRB.
			Pdd->OriginalSrb = Srb;

			// Update number of Pdds into which the SRB has been split.
			pSrbExtension->NumberOfPdds++;

            Pdd->ulSectorCount = 0;
        }
        
        // As this command is verify command we will 
        // use only ulsectorcount variable we will not use the BufChunk variables
        Pdd->ulSectorCount += ulSectorsToProcess;

		//
		// Increment ulLogicalSectorStartAddress and ulCurrentStripeNumber.
		//

		ulLogicalSectorStartAddress = ulEndAddressOfcurrentStripe + 1;
		ulCurrentStripeNumber++;

		//
		// Decrement the number of sectors left.
		//

		ulSectorsRequested -= ulSectorsToProcess;	

	}

    return SRB_STATUS_SUCCESS;
}


BOOLEAN
ExportVerifySglsToPrbs(
            IN PHW_DEVICE_EXTENSION DeviceExtension,
            IN PPHYSICAL_DRIVE_DATA Pdd,
            IN PSRB_EXTENSION pSrbExtension
            )
{
    PPHYSICAL_REQUEST_BLOCK pPrb;

    pPrb = &(pSrbExtension->Prb[pSrbExtension->ulPrbInsertionIndex]);
    Pdd->ulStartPrbInd = pSrbExtension->ulPrbInsertionIndex;

    pPrb->ulVirtualAddress = 0;
    pPrb->ulSglCount = 0;
    pPrb->pPdd = Pdd;
    pPrb->pSrbExtension = pSrbExtension;
    pPrb->ucCmd = Pdd->OriginalSrb->Cdb[0];
    pPrb->ulStartSector = Pdd->ulStartSector;
    pPrb->ulSectors = Pdd->ulSectorCount;

    ExportPrbToPhysicalDrive( DeviceExtension, pPrb, Pdd->TargetId );

	pSrbExtension->ulPrbInsertionIndex += 1;
    Pdd->ulPrbCount = 1;
    Pdd->ulPrbsRemaining = 1;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaraid\extendedsgl.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = ExtendedSGL.H                                */
/* FUNCTION         = Header file of Extended SGL data stucture;   */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = American MegaTrends Inc. All rights reserved;*/
/*                                                                 */
/*******************************************************************/

#ifndef _EXTENDED_SGL_H
#define _EXTENDED_SGL_H

#define MAIN_MISC_OPCODE		0xA4
#define GET_MAX_SG_SUPPORT	0x1

typedef struct _MBOX_SG_SUPPORT{

		UCHAR   Opcode;
		UCHAR   Id;
		UCHAR		SubOpcode;
}MBOX_SG_SUPPORT, *PMBOX_SG_SUPPORT;


typedef struct _SG_ELEMENT_COUNT{

	ULONG32	AllowedBreaks;

}SG_ELEMENT_COUNT, *PSG_ELEMENT_COUNT;

//
//Functions prototype
//
void
GetAndSetSupportedScatterGatherElementCount(
    PHW_DEVICE_EXTENSION	DeviceExtension,
    PUCHAR								PciPortStart,
    UCHAR									RPFlag);


#endif //of _EXTENDED_SGL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaraid\fwdatastructure40.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = FwDataStructure40.h                          */
/* FUNCTION         = Structure Declarations for the Firmware      */
/*                    supporting 40 Logical Drives and 256         */
/*                    Physical Drives;                             */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = American MegaTrends Inc. All rights reserved;*/
/*                                                                 */
/*******************************************************************/

#ifndef _FW_DATA_STRUCTURE_40_H
#define _FW_DATA_STRUCTURE_40_H



/********************************************
 * PRODUCT_INFO Strucure
 ********************************************/
/* 
 * Utilities declare this strcture size as 1024 bytes. So more fields can
 * be added in future.
 */

struct MRaidProductInfo
{
    ULONG32   DataSize; /* current size in bytes (not including resvd) */
    ULONG32   ConfigSignature;
                         /* Current value is 0x00282008
                          * 0x28=MAX_LOGICAL_DRIVES, 
                          * 0x20=Number of stripes and 
                          * 0x08=Number of spans */
    UCHAR   FwVer[16];         /* printable ASCI string */
    UCHAR   BiosVer[16];       /* printable ASCI string */
    UCHAR   ProductName[80];   /* printable ASCI string */

    UCHAR   MaxConcCmds;       /* Max. concurrent commands supported */
    UCHAR   SCSIChanPresent;   /* Number of SCSI Channels detected */
    UCHAR   FCLoopPresent;     /* Number of Fibre Loops detected */
    UCHAR   memType;           /* EDO, FPM, SDRAM etc */

    ULONG32   signature;
    USHORT  DramSize;          /* In terms of MB */
    USHORT  subSystemID;

    USHORT  subSystemVendorID;
    UCHAR   numNotifyCounters;  /* Total counters in notify struc */
    /* 
    * Add reserved field so that total size is 1K 
    */
};

/********************************************
 * NOTIFICATION Strucure
 ********************************************/

#define MAX_NOTIFY_SIZE     0x80
#define CUR_NOTIFY_SIZE     sizeof(struct MegaRAID_Notify)

//#pragma noalign(MegaRAID_Notify)
/* 
 * Utilities declare this strcture size as ?? bytes. So more fields can
 * be added in future.
 */
struct MegaRAID_Notify
{
    ULONG32   globalCounter;  /* Any change increments this counter */

    UCHAR   paramCounter;   /* Indicates any params changed  */
    UCHAR   paramId;        /* Param modified - defined below */
    USHORT  paramVal;       /* New val of last param modified */

    UCHAR   writeConfigCounter; /* write config occurred */
    UCHAR   writeConfigRsvd[3];

    UCHAR   ldrvOpCounter;  /* Indicates ldrv op started/completed */
    UCHAR   ldrvOpId;       /* ldrv num */
    UCHAR   ldrvOpCmd;      /* ldrv operation - defined below */
    UCHAR   ldrvOpStatus;   /* status of the operation */

    UCHAR   ldrvStateCounter;   /* Indicates change of ldrv state */
    UCHAR   ldrvStateId;    /* ldrv num */
    UCHAR   ldrvStateNew;   /* New state */
    UCHAR   ldrvStateOld;   /* old state */

    UCHAR   pdrvStateCounter;   /* Indicates change of ldrv state */
    UCHAR   pdrvStateId;    /* pdrv id */
    UCHAR   pdrvStateNew;   /* New state */
    UCHAR   pdrvStateOld;   /* old state */

    UCHAR   pdrvFmtCounter; /* Indicates pdrv format started/over */
    UCHAR   pdrvFmtId;      /* pdrv id */
    UCHAR   pdrvFmtVal;     /* format started/over */
    UCHAR   pdrvFmtRsvd;

    UCHAR   targXferCounter;    /* Indicates SCSI-2 Xfer rate change */
    UCHAR   targXferId;     /* pdrv Id  */
    UCHAR   targXferVal;    /* new Xfer params of last pdrv */
    UCHAR   targXferRsvd;

    UCHAR   fcLoopIdChgCounter; /* Indicates loopid changed */
    UCHAR   fcLoopIdPdrvId; /* pdrv id */
    UCHAR   fcLoopId0;      /* loopid on fc loop 0 */
    UCHAR   fcLoopId1;      /* loopid on fc loop 1 */

    UCHAR   fcLoopStateCounter; /* Indicates loop state changed */
    UCHAR   fcLoopState0;   /* state of fc loop 0 */
    UCHAR   fcLoopState1;   /* state of fc loop 1 */
    UCHAR   fcLoopStateRsvd;
};

/********************************************
 * PARAM IDs in Notify struct
 ********************************************/
#define PARAM_RBLD_RATE                 0x01
    /*--------------------------------------
     * Param val = 
     *      byte 0: new rbld rate 
     *--------------------------------------*/
#define PARAM_CACHE_FLUSH_INTERVAL      0x02
    /*--------------------------------------
     * Param val = 
     *      byte 0: new cache flush interval
     *--------------------------------------*/
#define PARAM_SENSE_ALERT               0x03
    /*--------------------------------------
     * Param val = 
     *      byte 0: last pdrv id causing chkcond
     *--------------------------------------*/
#define PARAM_DRIVE_INSERTED            0x04
    /*--------------------------------------
     * Param val = 
     *      byte 0: last pdrv id inserted
     *--------------------------------------*/
#define PARAM_BATTERY_STATUS            0x05
    /*--------------------------------------
     * Param val = 
     *      byte 0: battery status
     *--------------------------------------*/

/********************************************
 * Ldrv operation cmd in Notify struct
 ********************************************/
#define LDRV_CMD_CHKCONSISTANCY         0x01
#define LDRV_CMD_INITIALIZE             0x02
#define LDRV_CMD_RECONSTRUCTION         0x03

/********************************************
 * Ldrv operation status in Notify struct
 ********************************************/
#define  LDRV_OP_SUCCESS                 0x00
#define  LDRV_OP_FAILED                  0x01
#define  LDRV_OP_ABORTED                 0x02
#define  LDRV_OP_CORRECTED               0x03
#define  LDRV_OP_STARTED                 0x04


/********************************************
 * Raid Logical drive states.
 ********************************************/
#define     RDRV_OFFLINE                0
#define     RDRV_DEGRADED               1
#define     RDRV_OPTIMAL                2
#define     RDRV_DELETED                3

/*******************************************
 * Physical drive states.
 *******************************************/
#define     PDRV_UNCNF                  0
#define     PDRV_ONLINE                 3
#define     PDRV_FAILED                 4
#define     PDRV_RBLD                   5
#define     PDRV_HOTSPARE               6

/*******************************************
 * Formal val in Notify struct
 *******************************************/
#define PDRV_FMT_START                  0x01
#define PDRV_FMT_OVER                   0x02

/********************************************
 * FC Loop State in Notify Struct
 ********************************************/
#define ENQ_FCLOOP_FAILED               0
#define ENQ_FCLOOP_ACTIVE               1
#define ENQ_FCLOOP_TRANSIENT            2



/********************************************
 * ENQUIRY3 Strucure
 ********************************************/
/* 
 * Utilities declare this strcture size as 1024 bytes. So more fields can
 * be added in future.
 */
struct MegaRAID_Enquiry3
{
   ULONG32   dataSize; /* current size in bytes (not including resvd) */

   struct MegaRAID_Notify   notify;

   UCHAR   notifyRsvd[MAX_NOTIFY_SIZE - CUR_NOTIFY_SIZE];

   UCHAR   rbldRate;     /* Rebuild rate (0% - 100%) */
   UCHAR   cacheFlushInterval; /* In terms of Seconds */
   UCHAR   senseAlert;
   UCHAR   driveInsertedCount; /* drive insertion count */

   UCHAR   batteryStatus;
   UCHAR   numLDrv;              /* No. of Log Drives configured */
   UCHAR   reconState[MAX_LOGICAL_DRIVES/8]; /* State of reconstruct */
   USHORT  lDrvOpStatus[MAX_LOGICAL_DRIVES/8]; /* log. Drv Status */

   ULONG32   lDrvSize[MAX_LOGICAL_DRIVES];  /* Size of each log. Drv */
   UCHAR   lDrvProp[MAX_LOGICAL_DRIVES];
   UCHAR   lDrvState[MAX_LOGICAL_DRIVES]; /* State of Logical Drives */
   UCHAR   pDrvState[MAX_PHYSICAL_DEVICES];  /* State of Phys. Drvs. */
   USHORT  physDrvFormat[MAX_PHYSICAL_DEVICES/16];

   UCHAR   targXfer[80];               /* phys device transfer rate */
   /* 
    * Add reserved field so that total size is 1K 
    */
};

/********************************************
 * Standard ENQUIRY Strucure
 ********************************************/
struct ADP_INFO
{
    UCHAR  MaxConcCmds;         /* Max. concurrent commands supported. */
    UCHAR  RbldRate;            /* Rebuild Rate. Varies from 0%-100% */
    UCHAR  MaxTargPerChan;      /* Max. Targets supported per chan. */
    UCHAR  ChanPresent;         /* No. of Chans present on this adapter. */
    UCHAR  FwVer[4];            /* Firmware version. */
    USHORT AgeOfFlash;          /* No. of times FW has been downloaded. */
    UCHAR  ChipSetValue;        /* Contents of 0xC0000832 */
    UCHAR  DramSize;            /* In terms of MB */
    UCHAR  CacheFlushInterval;  /* In terms of Seconds */
    UCHAR  BiosVersion[4];
    UCHAR  BoardType;
    UCHAR  sense_alert;
    UCHAR  write_config_count;   /* Increase with evry configuration change */
    UCHAR  drive_inserted_count; /* Increase with every drive inserted */
    UCHAR  inserted_drive;       /* Channel: Id of inserted drive */
    UCHAR  battery_status;
                           /*
                              BIT 0 : battery module missing
                              BIT 1 : VBAD
                              BIT 2 : temp high
                              BIT 3 : battery pack missing
                              BIT 4,5 : 00 - charge complete
                                        01 - fast charge in prog
                                        10 - fast charge fail
                                        11 - undefined
                              BIt 6 : counter > 1000
                              Bit 7 : undefined
                           */
    UCHAR  dec_fault_bus_info;   /* was resvd */
};

struct LDRV_INFO
{
    UCHAR  NumLDrv;      /* No. of Log. Drvs configured. */
    UCHAR  recon_state[MAX_LOGICAL_DRIVES/8];    
                                /* bit field for State of reconstruct */
    USHORT LDrvOpStatus[MAX_LOGICAL_DRIVES/8];   
                                /* bit field Status of Long Operations. */

    ULONG32  LDrvSize[MAX_LOGICAL_DRIVES];   /* Size of each log. Drv. */
    UCHAR  LDrvProp[MAX_LOGICAL_DRIVES];
    UCHAR  LDrvState[MAX_LOGICAL_DRIVES];  /* State of Logical Drives. */
};

#define PREVSTAT_MASK   0xf0
#define CURRSTAT_MASK   0x0f

struct PDRV_INFO
{
    UCHAR PDrvState[MAX_PHYSICAL_DEVICES]; /* State of Phys Drvs. */
};

typedef struct _MEGARaid_INQUIRY
{
    struct ADP_INFO    AdpInfo;
    struct LDRV_INFO   LogdrvInfo;
    struct PDRV_INFO   PhysdrvInfo;
}MEGARaid_INQUIRY, *PMEGARaid_INQUIRY;

/********************************************
 * Extended ENQUIRY Strucure
 ********************************************/
struct MRaid_Ext_Inquiry
{
    struct ADP_INFO  AdpInfo;
    struct LDRV_INFO LogdrvInfo;
    struct PDRV_INFO PhysdrvInfo;
    USHORT   PhysDrvFormat[MAX_CHANNELS];
    UCHAR    StackAttention;  /* customized for Core */
    UCHAR    ModemStatus;
    UCHAR    Reserved[2];
};

/********************************************
 * ENQUIRY2 Strucure
 ********************************************/
struct MRaid_Ext_Inquiry_2
{
    struct ADP_INFO   AdpInfo;
    struct LDRV_INFO  LogdrvInfo;
    struct PDRV_INFO  PhysdrvInfo;
    USHORT    PhysDrvFormat[MAX_CHANNELS];
    UCHAR     StackAttention;  /* customized for Core */
    UCHAR     ModemStatus;
    UCHAR     Reserved[4];
    ULONG32     extendedDataSize;
    USHORT    subSystemID;
    USHORT    subSystemVendorID;
    ULONG32     signature;
    UCHAR     targInfo[80];
    ULONG32     fcLoopIDChangeCount;
    UCHAR     fcLoopState[MAX_ISP];
    /* 
    * Add reserved field so that total size is 1K 
    */
};

/********************************************
 * DISK_ARRAY Strucure
 ********************************************/
struct APP_PHYS_DRV
{
    UCHAR  type;           /* Used for dedicated hotspare */
    UCHAR  curr_status;    /* Current configuration status */
    UCHAR  loopID[2];
    ULONG32  size;           /* Reserved Field. */
};

struct APP_DEVICE
{
    UCHAR channel;       /* This field is reserved */
    UCHAR target;        /* This is an index in the PHYS_DRV array */
};

struct APP_SPAN
{
    ULONG32     start_blk;              /* Starting Block */
    ULONG32     num_blks;               /* Number of blocks */
    struct APP_DEVICE device[MAX_ROW_SIZE];
};

struct APP_LOG_DRV
{
    UCHAR span_depth;        /* Total Number of Spans */
    UCHAR level;             /* RAID level */
    UCHAR read_ahead;        /* No READ_AHEAD or user opted for READ_AHEAD
                                     * or adaptive READ_AHEAD */
    UCHAR StripeSize;        /* Encoded Stripe Size */
    UCHAR status;            /* Status of the logical drive */
    UCHAR write_mode;        /* WRITE_THROUGH or WRITE_BACK */
    UCHAR direct_io;         /* DIRECT IO or through CACHE */
    UCHAR row_size;          /* Number of stripes in a row */
    struct APP_SPAN span[MAX_SPAN_DEPTH];
};

struct APP_DISK_ARRAY
{
    UCHAR  num_log_drives;        /* Number of logical drives */
    UCHAR  pad[3];
    struct APP_LOG_DRV log_drv[MAX_LOGICAL_DRIVES];
    struct APP_PHYS_DRV phys_drv[MAX_PHYSICAL_DEVICES];
};

/********************************************
 * NEW_DRVGROUP_INFO Strucure
 ********************************************/
struct NewDeviceInformation
{
    UCHAR newDevType;
    UCHAR newDevLoopID[2];
    UCHAR resvd;
};

struct NewDrvGroupInfo
{
    UCHAR numNewDevs;
    UCHAR numFailedDevs;
    struct NewDeviceInformation newDevInfo[MAX_SPAN_DEPTH * MAX_ROW_SIZE];
};

/********************************************
 * FAILED_DEV_LOOPID Strucure
 ********************************************/
struct FailedDevLoopID
{
    UCHAR numFailedDevs;
    UCHAR failedDevLoopID[MAX_SPAN_DEPTH][2];
};

/*****************************************************************************
    New Structure
*****************************************************************************/
struct FW_DEVICE_40LD
{
    UCHAR channel;
    UCHAR target;        /* LUN is always 0 for disk devices */
};

typedef struct _FW_SPAN_40LD
{
    ULONG32  start_blk;      /* Starting Block */
    ULONG32  total_blks;      /* Number of blocks */
  
    struct FW_DEVICE_40LD device[MAX_ROW_SIZE_40LD];//32

}FW_SPAN_40LD, *PFW_SPAN_40LD;

typedef struct _FW_LOG_DRV_4SPAN_40LD
{
    UCHAR  span_depth;
    UCHAR  raid;
    UCHAR  read_ahead;

    UCHAR  stripe_sz;
    UCHAR  status;
    UCHAR  write_policy;

    UCHAR  direct_io;
    UCHAR  no_stripes;
    FW_SPAN_40LD  span[FW_4SPAN_DEPTH];   /* 4 */

}FW_LOG_DRV_4SPAN_40LD, *PFW_LOG_DRV_4SPAN_40LD;

typedef struct _FW_LOG_DRV_8SPAN_40LD
{
    UCHAR  span_depth;
    UCHAR  raid;
    UCHAR  read_ahead  ;

    UCHAR  stripe_sz;
    UCHAR  status;
    UCHAR  write_policy;

    UCHAR  direct_io;
    UCHAR  no_stripes;
    FW_SPAN_40LD  span[FW_8SPAN_DEPTH];   /* 8 */

}FW_LOG_DRV_8SPAN_40LD, *PFW_LOG_DRV_8SPAN_40LD;

typedef struct _FW_PHYS_DRV_40LD
{
    UCHAR type;      /* type of device */
    UCHAR curr_status;  /* Current status of the drive */
    UCHAR tag_depth;  /* Level of tagging 0=>DEflt, 1=Disabled, 2,3,4=>Tag_depth*/
    UCHAR sync;      /*Sync 0=>default, 1=>Enabled, 2=>disabled */
    ULONG32  size;      /* Configuration size in terms of 512 byte blocks */

}FW_PHYS_DRV_40LD, *PFW_PHYS_DRV_40LD;

typedef struct _FW_ARRAY_4SPAN_40LD
{
    UCHAR num_log_drives;      /* Number of logical drives */
    UCHAR pad[3];

    FW_LOG_DRV_4SPAN_40LD  log_drv[MAX_LOGICAL_DRIVES_40];
    FW_PHYS_DRV_40LD      phys_drv[MAX_PHYSICAL_DEVICES_40LD];

}FW_ARRAY_4SPAN_40LD, *PFW_ARRAY_4SPAN_40LD;

typedef struct _FW_ARRAY_8SPAN_40LD
{
    UCHAR num_log_drives;      /* Number of logical drives */
    UCHAR pad[3];

    FW_LOG_DRV_8SPAN_40LD  log_drv[MAX_LOGICAL_DRIVES_40];
    FW_PHYS_DRV_40LD      phys_drv[MAX_PHYSICAL_DEVICES_40LD];

}FW_ARRAY_8SPAN_40LD, *PFW_ARRAY_8SPAN_40LD;


#endif //_FW_DATA_STRUCTURE_40_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaraid\fwdatastructure8.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = FwDataStructure8.h                           */
/* FUNCTION         = Structure Declarations for the Firmware      */
/*                    supporting 8  Logical Drives and 256         */
/*                    Physical Drives;                             */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = American MegaTrends Inc. All rights reserved;*/
/*                                                                 */
/*******************************************************************/
#ifndef _FW_DATA_STRUCTURE_8_H
#define _FW_DATA_STRUCTURE_8_H

/********************************************
 * Standard ENQUIRY Strucure
 ********************************************/
#pragma pack(1)
struct ADP_INFO_8
{
   UCHAR  MaxConcCmds;         /* Max. concurrent commands supported. */
   UCHAR  RbldRate;            /* Rebuild Rate. Varies from 0%-100% */
   UCHAR  MaxTargPerChan;      /* Max. Targets supported per chan. */
   UCHAR  ChanPresent;         /* No. of Chans present on this adapter. */
   UCHAR  FwVer[4];            /* Firmware version. */
   USHORT AgeOfFlash;          /* No. of times FW has been downloaded. */
   UCHAR  ChipSetValue;        /* Contents of 0xC0000832 */
   UCHAR  DramSize;            /* In terms of MB */
   UCHAR  CacheFlushInterval;  /* In terms of Seconds */
   UCHAR  BiosVersion[4];
   UCHAR  BoardType;
   UCHAR  sense_alert;
   UCHAR  write_config_count;   /* Increase with evry configuration change */
   UCHAR  drive_inserted_count; /* Increase with every drive inserted */
   UCHAR  inserted_drive;       /* Channel: Id of inserted drive */
   UCHAR  battery_status;
                           /*
                              BIT 0 : battery module missing
                              BIT 1 : VBAD
                              BIT 2 : temp high
                              BIT 3 : battery pack missing
                              BIT 4,5 : 00 - charge complete
                                        01 - fast charge in prog
                                        10 - fast charge fail
                                        11 - undefined
                              BIt 6 : counter > 1000
                              Bit 7 : undefined
                           */
   UCHAR  dec_fault_bus_info;   /* was resvd */
};

#pragma pack(1)
struct LDRV_INFO_8
{
   UCHAR  NumLDrv;      /* No. of Log. Drvs configured. */
   UCHAR  recon_state[MAX_LOGICAL_DRIVES_8/8];    
                             /* bit field for State of reconstruct */
   USHORT LDrvOpStatus[MAX_LOGICAL_DRIVES_8/8];   
                             /* bit field Status of Long Operations. */
   ULONG32  LDrvSize[MAX_LOGICAL_DRIVES_8];
                             /* Size of each log. Drv. */
   UCHAR  LDrvProp[MAX_LOGICAL_DRIVES_8];
   UCHAR  LDrvState[MAX_LOGICAL_DRIVES_8];  
                            /* State of Logical Drives. */
};

#pragma pack(1)
struct PDRV_INFO_8
{
   UCHAR PDrvState[MAX_PHYSICAL_DEVICES]; 
                              /* State of Phys Drvs. */
};

#pragma pack(1)
typedef struct _MEGARaid_INQUIRY_8
{
   struct ADP_INFO_8    AdpInfo;
   struct LDRV_INFO_8   LogdrvInfo;
   struct PDRV_INFO_8   PhysdrvInfo;
}MEGARaid_INQUIRY_8, *PMEGARaid_INQUIRY_8;


struct FW_DEVICE_8LD
{
    UCHAR channel;
    UCHAR target;       /* LUN is always 0 for disk devices */
};

typedef struct _FW_SPAN_8LD
{
    ULONG32  start_blk;       /* Starting Block */
    ULONG32  total_blks;      /* Number of blocks */

    struct FW_DEVICE_8LD device[MAX_ROW_SIZE_8LD];//8

}FW_SPAN_8LD, *PFW_SPAN_8LD;

typedef struct _FW_LOG_DRV_4SPAN_8LD
{
    UCHAR  span_depth;
    UCHAR	raid;
    UCHAR  read_ahead;

    UCHAR	stripe_sz;
    UCHAR	status;
    UCHAR	write_policy;

    UCHAR	direct_io;
    UCHAR	no_stripes;
    FW_SPAN_8LD	span[FW_4SPAN_DEPTH];   /* 4 */

}FW_LOG_DRV_4SPAN_8LD, *PFW_LOG_DRV_4SPAN_8LD;

typedef struct _FW_LOG_DRV_8SPAN_8LD
{
    UCHAR  span_depth;
    UCHAR  raid;
    UCHAR  read_ahead	;

    UCHAR  stripe_sz;
    UCHAR  status;
    UCHAR  write_policy;

    UCHAR  direct_io;
    UCHAR  no_stripes;
    FW_SPAN_8LD    span[FW_8SPAN_DEPTH];   /* 8 */

}FW_LOG_DRV_8SPAN_8LD, *PFW_LOG_DRV_8SPAN_8LD;

typedef struct _FW_PHYS_DRV_8LD
{
    UCHAR type;         /* type of device */
    UCHAR curr_status;  /* Current status of the drive */
    UCHAR tag_depth;    /* Level of tagging 0=>DEflt, 1=Disabled, 2,3,4=>Tag_depth*/
    UCHAR sync;         /*Sync 0=>default, 1=>Enabled, 2=>disabled */
    ULONG32  size;        /* Configuration size in terms of 512 byte blocks */

}FW_PHYS_DRV_8LD, *PFW_PHYS_DRV_8LD;

typedef struct _FW_ARRAY_4SPAN_8LD
{
    UCHAR num_log_drives; /* Number of logical drives */
    UCHAR pad[3];

    FW_LOG_DRV_4SPAN_8LD log_drv[MAX_LOGICAL_DRIVES_8];
    FW_PHYS_DRV_8LD      phys_drv[MAX_PHYSICAL_DEVICES_8LD];

}FW_ARRAY_4SPAN_8LD, *PFW_ARRAY_4SPAN_8LD;

typedef struct _FW_ARRAY_8SPAN_8LD
{
    UCHAR num_log_drives;   /* Number of logical drives */
    UCHAR pad[3];

    FW_LOG_DRV_8SPAN_8LD  log_drv[MAX_LOGICAL_DRIVES_8];
    FW_PHYS_DRV_8LD       phys_drv[MAX_PHYSICAL_DEVICES_8LD];

}FW_ARRAY_8SPAN_8LD, *PFW_ARRAY_8SPAN_8LD;


#endif //_FW_DATA_STRUCTURE_8_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaraid\extendedsgl.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = ExtendedSGL.C                                */
/* FUNCTION         = Implementation of Extended SGL;              */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = American MegaTrends Inc. All rights reserved;*/
/*                                                                 */
/*******************************************************************/
#include "includes.h"

/*
Function : GetAndSetSupportedScatterGatherElementCount
Description:
		Queries the controller for the maximum supported scatter gather 
		element count.The command is failed by the old firmwares.For them
		the driver sets the default values for the MaximumTransferLength
		and NumberOfPhysicalBreaks in the deviceExtension.If the call succeeds,
		the driver sets the values based on the allowed maximum.
Input Arguments:
		Pointer to the controller DeviceExtension
		Pointer to the mapped register space of the controller
		Boolean Flag (TRUE = RP Series Controller; FALSE= Non RP (428) )
Return Values:
			None
Output
		DeviceExtension->MaximumTransferLength
		DeviceExtension->NumberOfPhysicalBreaks
		set appropriate values.
*/
void
GetAndSetSupportedScatterGatherElementCount(
				PHW_DEVICE_EXTENSION	DeviceExtension,
				PUCHAR								PciPortStart,
				UCHAR									RPFlag
				)
{
	PUCHAR						dataBuffer;
	PSG_ELEMENT_COUNT	sgElementCount;

	ULONG32		count;
	ULONG32		maximumTransferLength;
	ULONG32		numberOfPhysicalBreaks;
	ULONG32		length;
	
	ULONG32		rpInterruptStatus;

	UCHAR		nonrpInterruptStatus;
	UCHAR		commandStatus;

	SCSI_PHYSICAL_ADDRESS	physicalAddress;
	FW_MBOX	mailBox;

	//
	//initialize the mailBox
	//
	MegaRAIDZeroMemory(&mailBox, sizeof(FW_MBOX));

	//
	//construct the command 
	//
  mailBox.Command = MAIN_MISC_OPCODE;
	//set the command id. 
  mailBox.CommandId = 0xFE;
  //Set the subcommand id
  mailBox.u.Flat2.Parameter[0] = GET_MAX_SG_SUPPORT;



	//
	//get the physical address of the data buffer
	//
	dataBuffer = DeviceExtension->NoncachedExtension->Buffer;

	physicalAddress = ScsiPortGetPhysicalAddress(DeviceExtension,
												                        NULL,
												                        dataBuffer,
												                        &length);
	
  //convert the physical address to ULONG32
	mailBox.u.Flat2.DataTransferAddress = ScsiPortConvertPhysicalAddressToUlong(physicalAddress);

	DebugPrint((0, "\nPAD[DataBuffer]=0x%0x PADLength=%d",
								mailBox.u.Flat2.DataTransferAddress,length));
	DebugPrint((0, "\n SizeofTransfer = %d", sizeof(SG_ELEMENT_COUNT)));
	
	//
	//reset the status byte in the mail box
	//
	DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus= 0;
  DeviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands = 0;
	
	//
	//fire the command to the firmware
	//	
	SendMBoxToFirmware(DeviceExtension, PciPortStart, &mailBox);
 
  //
  //wait for the completion of the command
	//

	if(WaitAndPoll(DeviceExtension->NoncachedExtension, PciPortStart, DEFAULT_TIMEOUT, TRUE)==FALSE)
  {
	 		commandStatus = 1; //COMMAND FAILED
			
			goto SET_VALUES;
  }
  
	//
	//check for the command status
	//
	commandStatus = DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus;

SET_VALUES:

	//TAKE ACTION based on success or failure of the command
	if(commandStatus != 0)
  {
			//command Failed by the firmware.
			//set default values.
			maximumTransferLength = DEFAULT_TRANSFER_LENGTH;
			numberOfPhysicalBreaks = DEFAULT_SGL_DESCRIPTORS;		
	}
	else
  {
		//command successfull.Cast the data buffer to SG_ELEMENT_COUNT structure.
		sgElementCount = (PSG_ELEMENT_COUNT)(dataBuffer);
	
		//check for the returned value with the allowed maximum by driver
		numberOfPhysicalBreaks = sgElementCount->AllowedBreaks-1;		

		if(numberOfPhysicalBreaks > MAXIMUM_SGL_DESCRIPTORS)
		{
			numberOfPhysicalBreaks = MAXIMUM_SGL_DESCRIPTORS;		
		}
	
		//set transfer length to allowed maximum
		maximumTransferLength = MAXIMUM_TRANSFER_LENGTH;
	}

	//
	//set the values in the DeviceExtension
	//
	DeviceExtension->MaximumTransferLength = maximumTransferLength;
	DeviceExtension->NumberOfPhysicalBreaks = numberOfPhysicalBreaks;

}//GetAndSetSupportedScatterGatherElementCount ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaraid\includes.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = INCLUDES.h                                   */
/* FUNCTION         = Header file for all include files;           */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = American MegaTrends Inc. All rights reserved;*/
/*                                                                 */
/*******************************************************************/
//
//include files
//

#include <miniport.h>
#include <scsi.h>



#include "Const.h"
#include "Adapter.h"
#include "Bios.h"


//
//force the byte alignment for the structure
//
#pragma pack(push,fwstruct_pack, 1)
#include "FwDataStructure8.h"
#include "FwDataStructure40.h"
#pragma pack(pop,fwstruct_pack, 1)

#include "MegaRAID.h"
#include "Miscellaneous.h"

#include "NewConfiguration.h"
#include "ReadConfiguration.h"


#include "MegaEnquiry.h"
#include "ExtendedSGL.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaraid\initialize.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = Initialize.C                                 */
/* FUNCTION         = Implementation of MegaRAIDInitialize routine;*/
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = American MegaTrends Inc. All rights reserved;*/
/*                                                                 */
/*******************************************************************/


#include "includes.h"


//
//Logical Drive Info struct (global)
//
extern LOGICAL_DRIVE_INFO  gLDIArray;
extern UCHAR               globalHostAdapterOrdinalNumber;


/*********************************************************************
Routine Description:
	Inititialize adapter.

Arguments:
	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:
	TRUE - if initialization successful.
	FALSE - if initialization unsuccessful.
**********************************************************************/
BOOLEAN
MegaRAIDInitialize(
	IN PVOID HwDeviceExtension
	)
{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	PNONCACHED_EXTENSION noncachedExtension;	

	PMEGARaid_INQUIRY_8  raidParamEnquiry_8ldrv;
	PMEGARaid_INQUIRY_40 raidParamEnquiry_40ldrv;
	PUCHAR							raidParamFlatStruct;

	PUCHAR pciPortStart;
	
	ULONG32  length;
	UCHAR  status;

	ULONG32	 raidParamStructLength =0;

	FW_MBOX mbox;

	DebugPrint((0, "\nEntering MegaRAIDInitialize\n"));

  noncachedExtension = deviceExtension->NoncachedExtension;
	pciPortStart = deviceExtension->PciPortStart;

	//Initialize the MailBox
  MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));
  
  //
	// We work in polled mode for Init, so disable Interrupts.
	//
	if (noncachedExtension->RPBoard == 0)
		ScsiPortWritePortUchar(pciPortStart+INT_ENABLE, MRAID_DISABLE_INTERRUPTS);

  if(!deviceExtension->IsFirmwareHanging)
  {
	  //
	  //check for the supported logical drive count. The disk array
	  //structures for the 8Log Drive & 40Log Drive firmware are different.
	  //Also, a 8/40Log Drive firmware may support 4SPAN or a 8SPAN device
	  //structure.
	  //A firmware will have ONLY ONE of the following combination:
	  //
	  //			LogicalDrive Support		SPAN
	  //						8										8
	  //						8										4
	  //						40									8
	  //						40									4
	  //Since only one of them is valid for a firmware there are four
	  //structures defined in a {union} in the NonCachedExtension structure.
	  //
	  if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
	  {
		  //
		  //get the span information along with the disk array structure.
		  //The span information is returned in 
		  //			DeviceExtension->NoncachedExtension->ArraySpanDepth 
		  //Possible values for ArraySpanDepth:FW_8SPAN_DEPTH (or) FW_4SPAN_DEPTH

		  Find8LDDiskArrayConfiguration(deviceExtension);						
	  }
	  else
	  {
		  //
		  //get the span information along with the disk array structure.
		  //The span information is returned in 
		  //			DeviceExtension->NoncachedExtension->ArraySpanDepth 
		  //Possible values for ArraySpanDepth:FW_8SPAN_DEPTH (or) FW_4SPAN_DEPTH
		  if( Find40LDDiskArrayConfiguration(deviceExtension) != 0)
		  {
			  //error in reading disk array config for 40logical drive.
			  //
			  return(FALSE);
		  }
    }


	  //
	  // Issue Adapter Enquiry command.
	  //
	  //mParam =(PMRAID_ENQ)&NoncachedExtension->MRAIDParams;
	  
	  //MRAIDParams is a UNION.It does not matter whether we set
	  //raidParamFlatStruct to MRAIDParams8 or MRAIDParams40.
	  //
	  raidParamFlatStruct =
		  (PUCHAR)&noncachedExtension->MRAIDParams.MRAIDParams8;

	  if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
	  {
			  raidParamStructLength = sizeof(MEGARaid_INQUIRY_8);
	  }
	  else
	  {
			  raidParamStructLength = sizeof(MEGARaid_INQUIRY_40);
	  }

	  mbox.u.Flat2.DataTransferAddress = MegaRAIDGetPhysicalAddressAsUlong(deviceExtension, 
														                          NULL, 
														                          raidParamFlatStruct, 
														                          &length);

	  //
	  // Check the contiguity of the physical region. Return Failure if the
	  // region is not contiguous.
	  //
	  if(length < raidParamStructLength)
    { 
      DebugPrint((0, "\n **** ERROR Buffer Length is less than required size, ERROR ****"));
		  //return(FALSE);
	  }

	  //
	  //CAST to MegaRAID_Enquiry_8 & MegaRAID_Enquiry3 structures
	  //
	  raidParamEnquiry_8ldrv  = (PMEGARaid_INQUIRY_8)raidParamFlatStruct;
	  raidParamEnquiry_40ldrv = (PMEGARaid_INQUIRY_40)raidParamFlatStruct;

	  //
	  // Initialize the number of logical drives found.
	  //
	  if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
	  {
		  //
		  // Fill the Mailbox for the normal Enquiry command. 40 logical
		  // drive firmwares do not support his opcode anymore.
		  //
		  //
		  mbox.Command   = MRAID_DEVICE_PARAMS;
		  mbox.CommandId = 0xFE;

		  raidParamEnquiry_8ldrv->LogdrvInfo.NumLDrv = 0;
	  }
	  else
    {

		  //
		  //send enquiry3 command to the firmware to get the logical
		  //drive information.The older enquiry command is no longer
		  //supported by the 40 logical drive firmware
		  //

		  mbox.Command   = NEW_CONFIG_COMMAND; //inquiry 3 [BYTE 0]
		  mbox.CommandId = 0xFE;//command id [BYTE 1]

		  mbox.u.Flat2.Parameter[0] = NC_SUBOP_ENQUIRY3;	//[BYTE 2]
		  mbox.u.Flat2.Parameter[1] = ENQ3_GET_SOLICITED_FULL;//[BYTE 3]

		  raidParamEnquiry_40ldrv->numLDrv = 0;
	  }

	  
	  deviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus = 0;
    deviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands = 0;
	  SendMBoxToFirmware(deviceExtension, pciPortStart, &mbox);

	  //
	  // Poll for completion for 60 seconds.
	  //
    if(WaitAndPoll(noncachedExtension, pciPortStart, SIXITY_SECONDS_TIMEOUT, TRUE) == FALSE)
    {
      DebugPrint((0, "\n **** ERROR timeout, ERROR ****"));

      return FALSE;
    }

    status  = deviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus;
    if(status)
    {
      DebugPrint((0, "\n **** status ERROR ERROR ****"));
      return FALSE;
    }
  }
	//
	// Enable interrupts on the Adapter. 
	//
	if (noncachedExtension->RPBoard == MRAID_NONRP_BOARD)
		ScsiPortWritePortUchar(pciPortStart+INT_ENABLE, MRAID_ENABLE_INTERRUPTS);

	if(noncachedExtension->RPBoard == MRAID_RX_BOARD)
	{
		ScsiPortWriteRegisterUshort((PUSHORT)(pciPortStart+0xA0), MRAID_RX_INTERRUPT_SIGNATURE);
		DebugPrint((0, "\nMRAID35x.sys :Interrupt Enabled"));

	}
   //
   //store the hostadapter number in the device extension.
   //THis is a zero base number indicating the ordinal number of the
   //recognized host adapters.
   //
   if(!deviceExtension->OrdinalNumberAssigned)
   {
         deviceExtension->HostAdapterOrdinalNumber = 
                     globalHostAdapterOrdinalNumber++;

         deviceExtension->OrdinalNumberAssigned = TRUE;
   }

   DebugPrint((0, "\nExiting MegaRAIDInitialize\n"));

	return(TRUE);
} // end MegaRAIDInitialize()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaraid\ioctl.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = IOCTL.C                                      */
/* FUNCTION         = Implementation of PowerConsole IOCTLs;       */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = American MegaTrends Inc. All rights reserved;*/
/*                                                                 */
/*******************************************************************/

#include "includes.h"

//defines

//
// Driver Data
//
DriverInquiry   DriverData = {"megaraid$",
											        OS_NAME,
											        OS_VERSION,
											        VER_ORIGINALFILENAME_STR,
											        VER_PRODUCTVERSION_STR,
											        RELEASE_DATE};

/*********************************************************************
Routine Description:
	This routines returns the statistics of the adapter.

Arguments:
		deviceExtension			-	Pointer to Device Extension.
		Srb							-  Pointer to request packet.

Return Value:
		REQUEST_DONE	
**********************************************************************/
ULONG32
MRaidStatistics(PHW_DEVICE_EXTENSION DeviceExtension,
						    PSCSI_REQUEST_BLOCK  Srb)
{
	PUCHAR    driverStatistics, 
						applicationStatistics;
	
	PIOCONTROL_MAIL_BOX ioctlMailBox =	(PIOCONTROL_MAIL_BOX)((PUCHAR)Srb->DataBuffer +	sizeof(SRB_IO_CONTROL));
	
	ULONG32		count;
	ULONG32		statisticsStructLength;

	//
	//get the statistics structure. Statistics8 & Statistics40 are in {union}
	//It doesn't matter, which we CAST to
	//
	driverStatistics  = (PUCHAR)&DeviceExtension->Statistics.Statistics8;

	if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
	{
			statisticsStructLength = sizeof(MegaRaidStatistics_8);
	}
	else
	{
			statisticsStructLength = sizeof(MegaRaidStatistics_40);
	}
	
	//
	//get the output buffer pointer
	//
	applicationStatistics   = (PUCHAR)(
															(PUCHAR)Srb->DataBuffer + 
															sizeof(SRB_IO_CONTROL) +
															APPLICATION_MAILBOX_SIZE
														);

	for ( count = 0 ; count < statisticsStructLength ; count++)
	{
		*((PUCHAR)applicationStatistics + count) = 
												*((PUCHAR)driverStatistics + count);
	}

	ioctlMailBox->IoctlSignatureOrStatus      = MEGARAID_SUCCESS;
  
	Srb->SrbStatus  = SRB_STATUS_SUCCESS;
	Srb->ScsiStatus = SCSISTAT_GOOD;

	return REQUEST_DONE;
}


/*********************************************************************
Routine Description:
	This routines returns the statistics of the Driver.

Arguments:
		deviceExtension			-	Pointer to Device Extension.
		Srb							-  Pointer to request packet.

Return Value:
		REQUEST_DONE	
**********************************************************************/
ULONG32
MRaidDriverData(
						PHW_DEVICE_EXTENSION    DeviceExtension,
						PSCSI_REQUEST_BLOCK     Srb)
{
	PUCHAR     dataPtr;
	PIOCONTROL_MAIL_BOX ioctlMailBox =	(PIOCONTROL_MAIL_BOX)((PUCHAR)Srb->DataBuffer +sizeof(SRB_IO_CONTROL));
	USHORT     count;

	dataPtr= ((PUCHAR)Srb->DataBuffer + sizeof(SRB_IO_CONTROL) +
					  APPLICATION_MAILBOX_SIZE);

	for ( count = 0 ; count < sizeof(DriverInquiry) ; count++)
		*((PUCHAR)dataPtr + count) = *((PUCHAR)&DriverData+count);

	ioctlMailBox->IoctlSignatureOrStatus = MEGARAID_SUCCESS;
	Srb->SrbStatus  = SRB_STATUS_SUCCESS;
	Srb->ScsiStatus = SCSISTAT_GOOD;
	
	return REQUEST_DONE;
}

/*********************************************************************
Routine Description:
	This routines returns the Baseport of the Controller.

Arguments:
		deviceExtension                 -       Pointer to Device Extension.
		Srb                                                     -  Pointer to request packet.

Return Value:
		REQUEST_DONE    
**********************************************************************/
ULONG32 MRaidBaseport(PHW_DEVICE_EXTENSION DeviceExtension,
							 PSCSI_REQUEST_BLOCK    Srb)
{
	PULONG  dataPtr;
	PIOCONTROL_MAIL_BOX ioctlMailBox =	(PIOCONTROL_MAIL_BOX)((PUCHAR)Srb->DataBuffer +sizeof(SRB_IO_CONTROL));

  if(DeviceExtension->BaseAddressRegister.QuadPart & 0x10) //64bit address
  {
    Srb->SrbStatus = SRB_STATUS_ERROR;
	  return REQUEST_DONE;
  }
  
  dataPtr = (PULONG) ((PUCHAR)Srb->DataBuffer + sizeof(SRB_IO_CONTROL) +
		APPLICATION_MAILBOX_SIZE);

	*dataPtr  = (ULONG32)DeviceExtension->BaseAddressRegister.LowPart;

  ioctlMailBox->IoctlSignatureOrStatus = MEGARAID_SUCCESS;
	
  Srb->SrbStatus = SRB_STATUS_SUCCESS;
	Srb->ScsiStatus = SCSISTAT_GOOD;

	return REQUEST_DONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\megaraid\interrupt.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = Interrupt.C                                  */
/* FUNCTION         = Implementation of MegaRAIDInterrupt routine; */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = American MegaTrends Inc. All rights reserved;*/
/*                                                                 */
/*******************************************************************/

#include "includes.h"

extern LOGICAL_DRIVE_INFO  gLDIArray;

/*********************************************************************
Routine Description:
	Interrupt Handler

Arguments:
	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:
	TRUE if we handled the interrupt
**********************************************************************/
BOOLEAN
MegaRAIDInterrupt(
	IN PVOID HwDeviceExtension
	)
{
	PHW_DEVICE_EXTENSION   deviceExtension = HwDeviceExtension;
	PSCSI_REQUEST_BLOCK    srb;
	UCHAR                  commandID;
	PUCHAR                 pciPortStart;
	UCHAR                  status, command;
	UCHAR                  nonrpInterruptStatus;
	ULONG32                index, rpInterruptStatus;
	UCHAR                  commandsCompleted;
	USHORT                 rxInterruptStatus;
	
	PSRB_EXTENSION				 srbExtension;


	pciPortStart       = deviceExtension->PciPortStart;

	if(deviceExtension->NoncachedExtension->RPBoard == MRAID_RX_BOARD)
  {
			//First Clean the interrupt line by writing same value what
			//we read from OUTBOUND DOORBELL REG. Beforeing writing back 
			//check interrupt is generated for us by our controller. If no
			//return as FALSE;
			rxInterruptStatus = ScsiPortReadRegisterUshort((PUSHORT)(pciPortStart+RX_OUTBOUND_DOORBELL_REG));
			
			if (rxInterruptStatus != MRAID_RX_INTERRUPT_SIGNATURE)      
				return FALSE;
			
			ScsiPortWriteRegisterUshort((PUSHORT)(pciPortStart+RX_OUTBOUND_DOORBELL_REG), rxInterruptStatus);
  }
	else if(deviceExtension->NoncachedExtension->RPBoard == MRAID_RP_BOARD)
	{
		rpInterruptStatus = 
			ScsiPortReadRegisterUlong(
			(PULONG)(pciPortStart+OUTBOUND_DOORBELL_REG));
		
		if (rpInterruptStatus != MRAID_RP_INTERRUPT_SIGNATURE)      
			return FALSE;

		
		ScsiPortWriteRegisterUlong(
			(PULONG)(pciPortStart+OUTBOUND_DOORBELL_REG), rpInterruptStatus);
		
	}
	else
	{
		nonrpInterruptStatus = ScsiPortReadPortUchar(pciPortStart+PCI_INT);
		//
		// Check if our interrupt. Return False otherwise.
		//
		if ((nonrpInterruptStatus & MRAID_NONRP_INTERRUPT_MASK) != MRAID_NONRP_INTERRUPT_MASK) 
			return FALSE;
		//
		// Acknowledge the interrupt on the adapter.
		//
		ScsiPortWritePortUchar(pciPortStart+PCI_INT, nonrpInterruptStatus);
	}

  //DebugPrint((0, "\nMegaRAIDInterrupt::DEV EX