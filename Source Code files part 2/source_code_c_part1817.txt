
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If SERVER or DEST are not specified, we need to run on TS
    // Check if we are running under Terminal Server
        if ( ( (!IsTokenPresent(ptm, TOKEN_SERVER) )
        || (!IsTokenPresent(ptm, TOKEN_DESTINATION)) )
        && (!AreWeRunningTerminalServices()) )
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }
    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     * Validate the source.
     */
    if ( !IsTokenPresent(ptm, TOKEN_SOURCE) ) {

        /*
         * No source specified; use current winstation.
         */
        SourceId = GetCurrentLogonId();

    } else if ( !iswdigit(*Source) ) {

        /*
         * Treat the source string as a WinStation name.
         */
        if ( !LogonIdFromWinStationName(hServerName, Source, &SourceId) ) {
            StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, Source);
            return(FAILURE);
        }

    } else {

        /*
         * Treat the source string as a LogonId.
         */
        SourceId = wcstoul(Source, &endptr, 10);
        if ( *endptr ) {
            StringErrorPrintf(IDS_ERROR_INVALID_LOGONID, Source);
            return(FAILURE);
        }
        if ( !WinStationNameFromLogonId(hServerName, SourceId, Source) ) {
            ErrorPrintf(IDS_ERROR_LOGONID_NOT_FOUND, SourceId);
            return(FAILURE);
        }
    }

    /*
     * Validate the destination.
     */
    if ( !IsTokenPresent(ptm, TOKEN_DESTINATION) ) {

        /*
         * No destination specified; use current winstation.
         */
        bCurrent = TRUE;
        DestId = GetCurrentLogonId();
        if ( !WinStationNameFromLogonId(hServerName, DestId, Destination) ) {
            ErrorPrintf(IDS_ERROR_CANT_GET_CURRENT_WINSTATION, GetLastError());
            PutStdErr(GetLastError(), 0);
            return(FAILURE);
        }

    } else {

        /*
         * Validate the destination WinStation name.
         */
        if ( !LogonIdFromWinStationName(hServerName, Destination, &DestId) ) {
            StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, Destination);
            return(FAILURE);
        }
    }

    /*
     * Perform the connect.
     */
    if ( v_flag )
        DwordStringMessage(IDS_WINSTATION_CONNECT, SourceId, Destination);

    if ( !WinStationConnect(hServerName, SourceId, DestId, Password, TRUE) ) {

        if ( bCurrent )
            ErrorPrintf(IDS_ERROR_WINSTATION_CONNECT_CURRENT,
                         SourceId, GetLastError());
        else
            ErrorPrintf(IDS_ERROR_WINSTATION_CONNECT,
                         SourceId, Destination, GetLastError());
        PutStdErr(GetLastError(), 0);
        return(FAILURE);
    }

    return(SUCCESS);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE_1);
        ErrorPrintf(IDS_USAGE_2);
        ErrorPrintf(IDS_USAGE_3);
        ErrorPrintf(IDS_USAGE_4);
        ErrorPrintf(IDS_USAGE_5);
        // ErrorPrintf(IDS_USAGE_6);
        ErrorPrintf(IDS_USAGE_7);
        ErrorPrintf(IDS_USAGE_8);
        ErrorPrintf(IDS_USAGE_9);
    }
    else{
        Message(IDS_USAGE_1);
        Message(IDS_USAGE_2);
        Message(IDS_USAGE_3);
        Message(IDS_USAGE_4);
        Message(IDS_USAGE_5);
        //Message(IDS_USAGE_6);
        Message(IDS_USAGE_7);
        Message(IDS_USAGE_8);
        Message(IDS_USAGE_9);
    }

} /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\connect\tscon.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  TSCON.H
*     This module contains typedefs and defines for the TSCON
*     WinStation utility.
*
*************************************************************************/

/*
 * Token string definitions.
 */
#define TOKEN_SOURCE                    L""
#define TOKEN_DESTINATION               L"/dest"
#define TOKEN_PASSWORD                  L"/password"
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_HELP                      L"/?"
#define TOKEN_SERVER                    L"/server"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_NOT_FOUND                  102
#define IDS_ERROR_INVALID_LOGONID                       103
#define IDS_ERROR_LOGONID_NOT_FOUND                     104
#define IDS_ERROR_WINSTATION_CONNECT                    105
#define IDS_ERROR_WINSTATION_CONNECT_CURRENT            106
#define IDS_ERROR_CANT_GET_CURRENT_WINSTATION           107
#define IDS_ERROR_SERVER                                108
#define IDS_USAGE_1                                     121
#define IDS_USAGE_2                                     122
#define IDS_USAGE_3                                     123
#define IDS_USAGE_4                                     124
#define IDS_USAGE_5                                     125
#define IDS_USAGE_6                                     126
#define IDS_USAGE_7                                     127
#define IDS_USAGE_8                                     128
#define IDS_USAGE_9                                     129
#define IDS_ERROR_NOT_TS                                130


#define IDS_WINSTATION_CONNECT                          200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\cnvrtuc\cnvrtuc.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  CNVRTUC
*
*  Convert WinFrame User Configuration
*
*  Copyright Citrix Systems Inc. 1997
*
*  Author:      BruceF
*
*  $Log:   U:\NT\PRIVATE\UTILS\citrix\cnvrtuc\VCS\CNVRTUC.C  $
*  
*     Rev 1.3   May 04 1998 18:03:04   bills
*  Fixes for MS bug #2109, OEM->ANSI conversion and moving strings to the rc file.
*  
*     Rev 1.2   Jun 26 1997 18:17:18   billm
*  move to WF40 tree
*  
*     Rev 1.1   23 Jun 1997 16:17:24   butchd
*  update
*  
*     Rev 1.0   15 Feb 1997 09:51:48   brucef
*  Initial revision.
*  
*
******************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>

#include <stdio.h>
#include <stdlib.h>

#include <hydra/regapi.h>
#include <hydra/winsta.h>

#include "resource.h"
#include <printfoa.h>
#include <utilsub.h>

#if MAX_COMPUTERNAME_LENGTH > DOMAIN_LENGTH
#define _COMPUTERNAME_LENGTH MAX_COMPUTER_NAME_LENGTH
#else
#define _COMPUTERNAME_LENGTH DOMAIN_LENGTH
#endif


ULONG fAll;
WCHAR UserName[ USERNAME_LENGTH + 1 ];
WCHAR DomainName[ _COMPUTERNAME_LENGTH + 1 ];

BOOLEAN ProcessCommandLine( int argc, char *argv[] );

void Print( int nResourceID, ... );


BOOLEAN
ConvertUserConfiguration(
    PWCHAR pUserName,
    PWCHAR pDomainName
    )
{
    HKEY ServerHandle, UCHandle;
    PWCHAR ServerName = NULL;
    USERCONFIG UserConfig;
    LONG Error;
    BOOLEAN fFound;
    WCHAR UserNameTemp[ USERNAME_LENGTH + 1 ];
    ULONG Index;
    WCHAR ComputerName[ _COMPUTERNAME_LENGTH + 1 ];
    ULONG CNLength = sizeof(ComputerName)/sizeof( WCHAR );

    if ( !GetComputerName( ComputerName, &CNLength ) ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
    }

    if ( !wcscmp( pDomainName, ComputerName ) ) {
        ServerName = NULL;
    } else {
        PWCHAR ServerNameTemp = NULL;

        /*
         *  Get the Server Name of the PDC
         */
        Error = NetGetDCName( NULL, pDomainName, (LPBYTE *)&ServerNameTemp );
        if ( Error != ERROR_SUCCESS ) {
            ErrorPrintf(IDS_ERR_GET_PDC, pDomainName, Error );
            goto exit;
        }
        wcscpy( ComputerName, ServerNameTemp );
        NetApiBufferFree( ServerNameTemp );
        ServerName = ComputerName;
    }

#ifdef DEBUG
    fprintf( stderr,
             "Using server %ws as PDC for Domain %ws\n", 
             ServerName ? ServerName : ComputerName,
             pDomainName );
#endif

    /*
     * Connect to registry of the PDC.
     */
    if ( (Error = RegConnectRegistry( ServerName,
                                      HKEY_LOCAL_MACHINE,
                                      &ServerHandle )) != ERROR_SUCCESS ) {
        ErrorPrintf(IDS_ERR_CONNECT_REG, Error );
        goto exit;
    }


    /*
     *  Open the UserConfiguration key
     */
    if ( (Error = RegOpenKeyEx( ServerHandle, USERCONFIG_REG_NAME, 0,
                                KEY_READ, &UCHandle )) != ERROR_SUCCESS ) {
        ErrorPrintf(IDS_ERR_OPEN_KEY,  Error );
        goto cleanupregconnect;
    }

    fFound = FALSE;
    for ( Index = 0 ; ; Index++ ) {
        ULONG UCLength;

        /*
         *  Enumerate next subkey - which is a user name
         */
        if ((Error = RegEnumKey( UCHandle, Index, UserNameTemp,
                                 sizeof(UserNameTemp)/sizeof(WCHAR))) != ERROR_SUCCESS ) {
            if ( Error != ERROR_NO_MORE_ITEMS ) {
                ErrorPrintf(IDS_ERR_ENUM_KEY, Error );
                break;
            }
            Error = ERROR_SUCCESS;
            break;
        }

        /*
         *  Get the configuration - it may already be in the SAM.
         *  The Query API is designed to look in the SAM first and then
         *  the Registry.
         */
        if ( !pUserName ) {

            Print(IDS_CONVERTING, UserNameTemp );
            UCLength = sizeof( UserConfig );
            Error = RegUserConfigQuery( ServerName,
                                        UserNameTemp,
                                        &UserConfig,
                                        sizeof( UserConfig ),
                                        &UCLength );
            if ( Error != ERROR_SUCCESS ) {
                Print( IDS_ERR_QUERY_CONFIG, Error );
                break;
            }
            /*
             *  Store the configuration in the SAM.
             */
            Error = RegUserConfigSet( ServerName,
                                      UserNameTemp,
                                      &UserConfig,
                                      sizeof(UserConfig) );
            if ( Error != ERROR_SUCCESS ) {
                Print( IDS_ERR_SET_CONFIG, 
                        Error );
            } else {
                Print( IDS_COMPLETE  );
            }

        } else if ( !wcscmp( pUserName, UserNameTemp ) ) {

            Print( IDS_CONVERTING, UserNameTemp );
            fFound = TRUE;
            UCLength = sizeof( UserConfig );
            Error = RegUserConfigQuery( ServerName,
                                        UserNameTemp,
                                        &UserConfig,
                                        sizeof( UserConfig ),
                                        &UCLength );
            if ( Error != ERROR_SUCCESS ) {
                Print( IDS_ERR_QUERY_CONFIG2, 
                        Error );
                break;
            }
            /*
             *  Store the configuration in the SAM.
             */
            Error = RegUserConfigSet( ServerName,
                                      UserNameTemp,
                                      &UserConfig,
                                      sizeof(UserConfig) );
            if ( Error != ERROR_SUCCESS ) {
                Print( IDS_ERR_SET_CONFIG, 
                        Error );
            } else {
                Print(IDS_COMPLETE);
            }
            break;
        }

    }

    /*
     * If a name was given and it wasn't found, then say so.
     */
    if ( !Error && !fFound && pUserName ) {
        ErrorPrintf(IDS_ERR_USER_NOT_FOUND, pUserName );
    }
        
    /*
     *  Close UserConfiguration key
     */
    RegCloseKey( UCHandle );

cleanupregconnect:
    /*
     *  Close connection to Registry on PDC
     */
    RegCloseKey( ServerHandle );

exit:

    return( Error == ERROR_SUCCESS );
}

__cdecl
main( int argc, char *argv[] )
{
    if ( !ProcessCommandLine( argc, argv ) ) {
        return( 1 );
    }

    if ( !ConvertUserConfiguration( fAll ? NULL : UserName,
                                    DomainName ) ) {
        return( 1 );
    }
}


/*******************************************************************************
 *
 *  print
 *      Display a message to stdout with variable arguments.  Message
 *      format string comes from the application resources.
 *
 *  ENTRY:
 *      nResourceID (input)
 *          Resource ID of the format string to use in the message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
Print( int nResourceID, ... )
{
    char sz1[256], sz2[512];
    va_list args;

    va_start( args, nResourceID );

    if ( LoadStringA( NULL, nResourceID, sz1, 256 ) ) {
        vsprintf( sz2, sz1, args );
        printf( sz2 );
    }

    va_end(args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\cprofile\precomp.h ===
#include <nt.h>
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>

#include <ntddmou.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\cprofile\file.c ===
/******************************************************************************
*
*  FILE.C
*
*  This file contains routines based off the User Profile Editor utility.
*
*  Copyright Citrix Systems, Inc.  1997
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*  Author:  Brad Anderson  1/20/97
*
*  $Log:   M:\nt\private\utils\citrix\cprofile\VCS\file.c  $
*
*     Rev 1.3   Jun 26 1997 18:18:38   billm
*  move to WF40 tree
*
*     Rev 1.2   23 Jun 1997 16:13:20   butchd
*  update
*
*     Rev 1.1   28 Jan 1997 20:06:34   BradA
*  Fixed up some problems related to WF 2.0 changes
*
*     Rev 1.0   27 Jan 1997 20:03:44   BradA
*  Initial Version
*
******************************************************************************/
/****************************** Module Header ******************************\
* Module Name: upesave.c
*
* Copyright (c) 1992, Microsoft Corporation
*
* Handles OPening and saving of Profiles: default, system, current and user
* profiles.
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifndef RC_INVOKED
#include <winstaw.h>
#include <syslib.h>
#include <tsappcmp.h>
#include <compatfl.h>
#include <utilsub.h>
#endif

#include "cprofile.h"

HKEY hkeyCurrentUser;

PSID gSystemSid;         // Initialized in 'InitializeGlobalSids'
PSID gAdminsLocalGroup;  // Initialized in 'InitializeGlobalSids
SID_IDENTIFIER_AUTHORITY gNtAuthority = SECURITY_NT_AUTHORITY;

#define  SYSTEM_DEFAULT_SUBKEY  TEXT(".DEFAULT")
#define  TEMP_USER_SUBKEY       TEXT("TEMP_USER")
#define  TEMP_USER_HIVE_PATH    TEXT("%systemroot%\\system32\\config\\")
#define  TEMP_SAVE_HIVE         TEXT("%systemroot%\\system32\\config\\HiveSave")

#define  CITRIX_CLASSES L"\\Registry\\Machine\\Software\\Classes"

LPTSTR lpTempUserHive = NULL;
LPTSTR lpTempUserHivePath = NULL;
LPTSTR lpTempHiveKey;
extern TCHAR szDefExt[];
extern PSID gSystemSid;

BOOL AllocAndExpandEnvironmentStrings(LPTSTR String, LPTSTR *lpExpandedString);
VOID GetRegistryKeyFromPath(LPTSTR lpPath, LPTSTR *lpKey);

NTSTATUS
CtxDeleteKeyTree( HANDLE hKeyRoot,
                  PKEY_BASIC_INFORMATION pKeyInfo,
                  ULONG ulInfoSize );

PSECURITY_DESCRIPTOR GetSecurityInfo( LPTSTR File );
void FreeSecurityInfo(PSECURITY_DESCRIPTOR);

/***************************************************************************\
* ClearTempUserProfile
*
* Purpose : unloads the temp user profile loaded from a file, and deletes
*           the temp file
*
* History:
* 11-20-92 JohanneC       Created.
\***************************************************************************/
BOOL APIENTRY ClearTempUserProfile()
{
    BOOL bRet;

    if (hkeyCurrentUser == HKEY_CURRENT_USER)
        return(TRUE);

    //
    // Close registry keys.
    //
    if (hkeyCurrentUser) {
        RegCloseKey(hkeyCurrentUser);
    }

    hkeyCurrentUser = HKEY_CURRENT_USER;

    bRet = (RegUnLoadKey(HKEY_USERS, lpTempHiveKey) == ERROR_SUCCESS);

    if (*lpTempUserHive) {
        DeleteFile(lpTempUserHive);
        lstrcat(lpTempUserHive, TEXT(".log"));
        DeleteFile(lpTempUserHive);
        LocalFree(lpTempUserHive);
        lpTempUserHive = NULL;
    }

    return(bRet);
}


/***************************************************************************\
* OpenUserProfile
*
* Purpose : Load an existing profile in the registry and unload previously
* loaded profile (and delete its tmp file).
*
* History:
* 11-20-92 JohanneC       Created.
\***************************************************************************/
BOOL APIENTRY OpenUserProfile(LPTSTR szFilePath, PSID *pUserSid)
{

    DWORD err;

    //
    // Copy the profile to a temp hive before loading it in the registry.
    //
    if (!lpTempUserHivePath) {
        if (!AllocAndExpandEnvironmentStrings(TEMP_USER_HIVE_PATH, &lpTempUserHivePath))
            return(FALSE);
    }

    lpTempUserHive = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) *
                              (lstrlen(lpTempUserHivePath) + 17));
    if (!lpTempUserHive) {
        return(FALSE);
    }

    if (!GetTempFileName(lpTempUserHivePath, TEXT("tmp"), 0, lpTempUserHive)) {
        lstrcpy(lpTempUserHive, lpTempUserHivePath);
        lstrcat(lpTempUserHive, TEXT("\\HiveOpen"));
    }

    if (CopyFile(szFilePath, lpTempUserHive, FALSE)) {
        GetRegistryKeyFromPath(lpTempUserHive, &lpTempHiveKey);
        if ((err = RegLoadKey(HKEY_USERS, lpTempHiveKey, lpTempUserHive)) == ERROR_SUCCESS) {
            if ((err = RegOpenKeyEx(HKEY_USERS, lpTempHiveKey, 0,
                                    MAXIMUM_ALLOWED,
                                    &hkeyCurrentUser)) != ERROR_SUCCESS) {
                //
                // Error, do not have access to the profile.
                //
                ErrorPrintf(IDS_ERROR_PROFILE_LOAD_ERR, err);
                ClearTempUserProfile();
                return(FALSE);
            }
        }
        else {
            DeleteFile(lpTempUserHive);
            lstrcat(lpTempUserHive, TEXT(".log"));
            DeleteFile(lpTempUserHive);
            LocalFree(lpTempUserHive);

            //
            // Could not load the user profile, check the error code
            //
            if (err == ERROR_BADDB) {
                // bad format: not a profile registry file
                ErrorPrintf(IDS_ERROR_BAD_PROFILE);
                return(FALSE);
            }
            else {
                // generic error message : Failed to load profile
                ErrorPrintf(IDS_ERROR_PROFILE_LOAD_ERR, err);
                return(FALSE);
            }
        }
    }
    else {
        //
        // An error occured trying to load the profile.
        //
        DeleteFile(lpTempUserHive);

        switch ( (err = GetLastError()) ) {
        case ERROR_SHARING_VIOLATION:
            ErrorPrintf(IDS_ERROR_PROFILE_INUSE);
            break;
        default:
            ErrorPrintf(IDS_ERROR_PROFILE_LOAD_ERR, err);
            break;
        }
        return(FALSE);
    }

    //
    // Get the permitted user
    //
    *pUserSid = NULL;
    return(TRUE);
}

/***************************************************************************\
* SaveUserProfile
*
* Purpose : Save the loaded profile as a file.  The registry should already
*    have the existing ACL's already set so nothing needs to change.  The
*    file ACL's do need to be copied from the original and applied to the
*    saved file.  This function assumes the orignal file exists.
*
\***************************************************************************/
BOOL APIENTRY SaveUserProfile(PSID pUserSid, LPTSTR lpFilePath)
{
    LPTSTR lpTmpHive = NULL;
    BOOL err = FALSE;


    //
    // Save the profile to a temp hive then copy it over.
    //

    if ( AllocAndExpandEnvironmentStrings(TEMP_SAVE_HIVE, &lpTmpHive) )
    {
        if( lpTmpHive != NULL )
        {
            DeleteFile(lpTmpHive);

            if(RegSaveKey(hkeyCurrentUser, lpTmpHive, NULL) != ERROR_SUCCESS)
            {
                LocalFree(lpTmpHive);
                lpTmpHive = NULL;
                err = TRUE;
            }
            else
            {
                PSECURITY_DESCRIPTOR pSecDesc;
                DWORD Attrib = GetFileAttributes(lpFilePath);

                pSecDesc = GetSecurityInfo(lpFilePath);
                SetFileAttributes(lpFilePath,FILE_ATTRIBUTE_ARCHIVE);
                if(CopyFile(lpTmpHive, lpFilePath, FALSE))
                {
                    DeleteFile(lpTmpHive);
                    LocalFree(lpTmpHive);
                    lpTmpHive = NULL;
                    if (pSecDesc)
                    {
                        SetFileSecurity(lpFilePath,
                                        DACL_SECURITY_INFORMATION,
                                        pSecDesc);
                        FreeSecurityInfo(pSecDesc);
                    }
                }
                else
                {
                    if(pSecDesc)
                    {
                        FreeSecurityInfo(pSecDesc);
                    }
                    err = TRUE;
                }
                if(0xffffffff != Attrib)
                {
                    SetFileAttributes(lpFilePath,Attrib);
                }
            }
        }
    }
    else
    {
        err = TRUE;
    }

    if( lpTmpHive != NULL )
    {
        LocalFree(lpTmpHive);
    }

    return(!err);
}


/***************************************************************************\
* EnablePrivilege
*
* Enables/disabled the specified well-known privilege in the
* current process context
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
BOOL
EnablePrivilege(
    DWORD Privilege,
    BOOL Enable
    )
{
    NTSTATUS Status;
#if 0
    BOOL WasEnabled;
    Status = RtlAdjustPrivilege(Privilege, Enable, TRUE, (PBOOLEAN)&WasEnabled);
    return(NT_SUCCESS(Status));
#else
    HANDLE ProcessToken;
    LUID LuidPrivilege;
    PTOKEN_PRIVILEGES NewPrivileges;
    DWORD Length;

    //
    // Open our own token
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_ADJUST_PRIVILEGES,
                 &ProcessToken
                 );
    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // Initialize the privilege adjustment structure
    //

    LuidPrivilege = RtlConvertLongToLuid(Privilege);

    NewPrivileges = (PTOKEN_PRIVILEGES) LocalAlloc(LPTR, sizeof(TOKEN_PRIVILEGES) +
                         (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if (NewPrivileges == NULL) {
        NtClose(ProcessToken);
        return(FALSE);
    }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    //
    // WORKAROUND: because of a bug in NtAdjustPrivileges which
    // returns an error when you try to enable a privilege
    // that is already enabled, we first try to disable it.
    // to be removed when api is fixed.
    //
    NewPrivileges->Privileges[0].Attributes = 0;

    Status = NtAdjustPrivilegesToken(
                 ProcessToken,                     // TokenHandle
                 (BOOLEAN)FALSE,                   // DisableAllPrivileges
                 NewPrivileges,                    // NewPrivileges
                 0,                                // BufferLength
                 NULL,                             // PreviousState (OPTIONAL)
                 &Length                           // ReturnLength
                 );

    NewPrivileges->Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;
    //
    // Enable the privilege
    //
    Status = NtAdjustPrivilegesToken(
                 ProcessToken,                     // TokenHandle
                 (BOOLEAN)FALSE,                   // DisableAllPrivileges
                 NewPrivileges,                    // NewPrivileges
                 0,                                // BufferLength
                 NULL,                             // PreviousState (OPTIONAL)
                 &Length                           // ReturnLength
                 );

    LocalFree(NewPrivileges);

    NtClose(ProcessToken);

    if (Status) {
        return(FALSE);
    }

    return(TRUE);
#endif
}


BOOL AllocAndExpandEnvironmentStrings(LPTSTR String, LPTSTR *lpExpandedString)
{
     LPTSTR lptmp = NULL;
     DWORD cchBuffer;

     // Get the number of characters needed.
     cchBuffer = ExpandEnvironmentStrings(String, lptmp, 0);
     if (cchBuffer) {
         cchBuffer++;  // for NULL terminator
         lptmp = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * cchBuffer);
         if (!lptmp) {
             return(FALSE);
         }
         cchBuffer = ExpandEnvironmentStrings(String, lptmp, cchBuffer);
     }
     *lpExpandedString = lptmp;
     return(TRUE);
}


VOID GetRegistryKeyFromPath(LPTSTR lpPath, LPTSTR *lpKey)
{
    LPTSTR lptmp;

    *lpKey = lpPath;

    for (lptmp = lpPath; *lptmp; lptmp++) {
        if (*lptmp == TEXT('\\')) {
            *lpKey = lptmp+1;
        }
    }

}


/***************************************************************************\
* InitializeGlobalSids
*
* Initializes the various global Sids used in this module.
*
* History:
* 04-28-93 JohanneC       Created
\***************************************************************************/
VOID InitializeGlobalSids()
{
    NTSTATUS Status;

    //
    // Build the admins local group SID
    //

    Status = RtlAllocateAndInitializeSid(
                 &gNtAuthority,
                 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS,
                 0, 0, 0, 0, 0, 0,
                 &gAdminsLocalGroup
                 );

    //
    // create System Sid
    //

    Status = RtlAllocateAndInitializeSid(
                   &gNtAuthority,
                   1,
                   SECURITY_LOCAL_SYSTEM_RID,
                   0, 0, 0, 0, 0, 0, 0,
                   &gSystemSid
                   );

}



/*****************************************************************************
 *
 *  ClearDisabledClasses
 *
 *  This routine will check the compatibility flags for the user's Classes
 *  registry key, and remove the keys if mapping is disabled.
 *
 * ENTRY:
 *
 * EXIT:
 *   No return value.
 *
 ****************************************************************************/

void ClearDisabledClasses(void)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulcnt = 0, ultemp = 0;
    UNICODE_STRING UniPath;
    OBJECT_ATTRIBUTES ObjAttr;
    PKEY_BASIC_INFORMATION pKeyUserInfo = NULL;
    HANDLE hKeyUser = NULL;
    NTSTATUS Status2;
    HANDLE hClassesKey;
    WCHAR wcuser[MAX_PATH];

    if ( ! hkeyCurrentUser) {
        return;
    }

    GetTermsrCompatFlags(CITRIX_CLASSES, &ultemp, CompatibilityRegEntry);
    if ( (ultemp & (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) !=
         (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) {
        return;
    }

    // Get a buffer for the key info
    ulcnt = sizeof(KEY_BASIC_INFORMATION) + MAX_PATH*sizeof(WCHAR) + sizeof(WCHAR);
    pKeyUserInfo = RtlAllocateHeap(RtlProcessHeap(),
                                   0,
                                   ulcnt);
    if (!pKeyUserInfo) {
        Status = STATUS_NO_MEMORY;
    }

    // We have the necessary buffers, start checking the keys
    if (NT_SUCCESS(Status)) {
        // Build up a string for this user's software section
        wcscpy(wcuser, L"Software");

        // Create a unicode string for the user key path
        RtlInitUnicodeString(&UniPath, wcuser);

        InitializeObjectAttributes(&ObjAttr,
                                   &UniPath,
                                   OBJ_CASE_INSENSITIVE,
                                   hkeyCurrentUser,
                                   NULL);

        Status = NtOpenKey(&hKeyUser,
                           KEY_READ | DELETE,
                           &ObjAttr);

        RtlInitUnicodeString(&UniPath, L"Classes");

        InitializeObjectAttributes(&ObjAttr,
                                   &UniPath,
                                   OBJ_CASE_INSENSITIVE,
                                   hKeyUser,
                                   NULL);
        Status2 = NtOpenKey(&hClassesKey, KEY_READ | DELETE, &ObjAttr);
        if ( NT_SUCCESS(Status2) ) {
            Status2 = CtxDeleteKeyTree(hClassesKey, pKeyUserInfo, ulcnt);

            if ( !NT_SUCCESS(Status2)) {
            }
                NtClose(hClassesKey);
        }

        // If we allocated the system key, close it
        if (hKeyUser) {
            NtClose(hKeyUser);
        }
    }

    // Free up any memory we allocated
    if (pKeyUserInfo) {
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyUserInfo);
    }
}




/*****************************************************************************
 *
 *  CtxDeleteKeyTree
 *
 *  Delete a subtree of registry keys
 *
 * ENTRY:
 *    hKeyRoot   is a handle to the root key that will be deleted along with
 *               its children
 *    pKeyInfo   is a pointer to a KEY_BASIC_INFORMATION buffer that is
 *               large enough to hold a MAX_PATH WCHAR string.  It is
 *               reused and destroyed by each recursive call.
 *    ulInfoSize is the size of the pKeyInfo buffer
 *
 * EXIT:
 *    Status
 *
 ****************************************************************************/

NTSTATUS
CtxDeleteKeyTree( HANDLE hKeyRoot,
                  PKEY_BASIC_INFORMATION pKeyInfo,
                  ULONG ulInfoSize )
{
    NTSTATUS Status = STATUS_SUCCESS, Status2;
    UNICODE_STRING UniPath;
    OBJECT_ATTRIBUTES ObjAttr;
    ULONG ulcnt = 0;
    ULONG ultemp;
    HANDLE hKey;

    // Go through each of the subkeys
    while (NT_SUCCESS(Status)) {

        Status = NtEnumerateKey(hKeyRoot,
                                ulcnt,
                                KeyBasicInformation,
                                pKeyInfo,
                                ulInfoSize,
                                &ultemp);

        // Delete sub keys
        if (NT_SUCCESS(Status)) {

            // Null terminate the key name
            pKeyInfo->Name[pKeyInfo->NameLength/sizeof(WCHAR)] = L'\0';

            // Create a unicode string for the key name
            RtlInitUnicodeString(&UniPath, pKeyInfo->Name);

            InitializeObjectAttributes(&ObjAttr,
                                       &UniPath,
                                       OBJ_CASE_INSENSITIVE,
                                       hKeyRoot,
                                       NULL);

            // Open up the child key
            Status2 = NtOpenKey(&hKey,
                                MAXIMUM_ALLOWED,
                                &ObjAttr);

            if ( NT_SUCCESS(Status2) ) {
                Status2 = CtxDeleteKeyTree ( hKey, pKeyInfo, ulInfoSize );
                NtClose(hKey);
                //  If the key was not successfully deleted, we need
                //  to increment the enumerate index to guarantee
                //  that the alogorithm will complete.
                if ( !NT_SUCCESS(Status2) ) {
                    ++ulcnt;
                }
            }
        }
    }

    // If we deleted all the sub-keys delete the curent key
    if ( !ulcnt ) {
        Status = NtDeleteKey(hKeyRoot);
    }
    else {
        Status = STATUS_CANNOT_DELETE;
    }
    return ( Status );
}


PSECURITY_DESCRIPTOR
GetSecurityInfo(LPTSTR lpFilePath)
{
    int SizeReq = 0;
    PSECURITY_DESCRIPTOR pSecDesc = NULL;

    GetFileSecurity(lpFilePath, DACL_SECURITY_INFORMATION, pSecDesc, 0,
                    &SizeReq);
    if ( !SizeReq ) {
        return (NULL);
    }

    pSecDesc = LocalAlloc(LPTR, SizeReq);
    if ( pSecDesc ) {
        if ( !GetFileSecurity(lpFilePath, DACL_SECURITY_INFORMATION, pSecDesc,
                        SizeReq, &SizeReq) ) {
            LocalFree(pSecDesc);
            pSecDesc = NULL;
        }
    }
    return (pSecDesc);
}

void
FreeSecurityInfo(PSECURITY_DESCRIPTOR pSecDesc)
{
    LocalFree(pSecDesc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\cprofile\cprofile.c ===
/******************************************************************************
*
*  CPROFILE.C
*
*  Text based utility to clean user profiles.  This utility will remove user
*  file associations if they are disabled for the system and re-write
*  the user profile truncating unused space.
*
*  Copyright Citrix Systems Inc. 1995
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*  Author:      Brad Anderson 01/20/97
*
*  $Log:   U:\NT\PRIVATE\UTILS\citrix\cprofile\VCS\cprofile.c  $
*
*     Rev 1.7   May 04 1998 18:06:14   bills
*  Fixes for MS bug #2109, OEM->ANSI conversion and moving strings to the rc file.
*
*     Rev 1.6   Feb 09 1998 19:37:00   yufengz
*  change user profile from directory to file
*
*     Rev 1.5   09 Oct 1997 19:04:14   scottn
*  Make help like MS.
*
*     Rev 1.4   Jun 26 1997 18:18:32   billm
*  move to WF40 tree
*
*     Rev 1.3   23 Jun 1997 16:13:18   butchd
*  update
*
*     Rev 1.2   19 Feb 1997 15:55:32   BradA
*  Allow only administrators to run CPROFILE
*
*     Rev 1.1   28 Jan 1997 20:06:28   BradA
*  Fixed up some problems related to WF 2.0 changes
*
*     Rev 1.0   27 Jan 1997 20:37:46   BradA
*  Initial Versions
*
*     Rev 1.0   27 Jan 1997 20:02:46   BradA
*  Initial Version
*
*     Rev 1.0   Jan 27 1997 19:51:12   KenB
*  Initial version
*
*
*******************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntddkbd.h>
#include <winstaw.h>
#include <syslib.h>
#include <assert.h>

#include <time.h>
#include <utilsub.h>
#include <utildll.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>

#include "cprofile.h"

#include <printfoa.h>

#define REG_PROFILELIST \
 L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"
#define USER_PROFILE    L"NTUSER.DAT"

FILELIST Files;

int LocalProfiles_flag = FALSE;
int Verbose_flag = FALSE;
int Query_flag;
int Help_flag  = FALSE;

TOKMAP ptm[] = {
      {L"/L", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &LocalProfiles_flag},
      {L"/V", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &Verbose_flag},
      {L"/I", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &Query_flag},
      {L"/?", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &Help_flag},
      {L"/H", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &Help_flag},
      {L" ",  TMFLAG_OPTIONAL, TMFORM_FILES, sizeof(Files),  &Files},
      {0, 0, 0, 0, 0}
};

#define INPUT_CONT  0
#define INPUT_SKIP  1
#define INPUT_QUIT  2

int QueryUserInput();
int ProcessFile( PWCHAR pFile );
void Usage( BOOL ErrorOccured );


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    WCHAR *CmdLine;
    WCHAR **argvW;
    ULONG rc;
    int i;
    BOOL Result;
    HANDLE hWin;
    int CurFile;
    int Abort_flag;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( Help_flag || (rc & ~PARSE_FLAG_NO_PARMS) ||
         (!LocalProfiles_flag && (Files.argc == 0)) ) {

        if ( !Help_flag ) {
            Usage(TRUE);
            return(FAILURE);
        }
        else {
            Usage(FALSE);
            return(SUCCESS);
        }
    }

    if (!TestUserForAdmin(FALSE)) {
        ErrorPrintf(IDS_ERROR_NOT_ADMIN);
        return(FAILURE);
    }

    InitializeGlobalSids();

    /*
     * Verify if the user  has the privilege to save the profile i.e.
     * SeBackupPrivilege
     */
    if (!EnablePrivilege(SE_BACKUP_PRIVILEGE, TRUE) ||
                  !EnablePrivilege(SE_RESTORE_PRIVILEGE, TRUE)) {
        ErrorPrintf(IDS_ERROR_PRIVILEGE_NOT_AVAILABLE);
        return(FAILURE);
    }

    CurFile = 0;
    Abort_flag = FALSE;
    while ( !Abort_flag && Files.argc && (CurFile < Files.argc) ) {
        if ( ProcessFile(Files.argv[CurFile]) ) {
            Abort_flag = TRUE;
            break;
        }
        CurFile++;
    }

    if ( !Abort_flag && LocalProfiles_flag ) {
        //  Enumerate local profiles
        LONG Status;
        HKEY hkeyProfileList;
        DWORD indx = 0;
        WCHAR wSubKeyName[MAX_PATH+sizeof(WCHAR)];
        DWORD Size;

        Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              REG_PROFILELIST,
                              0,
                              KEY_READ,
                              &hkeyProfileList);

        if ( Status != ERROR_SUCCESS ) {
            ErrorPrintf(IDS_ERROR_MISSING_PROFILE_LIST);
            Abort_flag = TRUE;
            hkeyProfileList = 0;
        }

        while ( !Abort_flag && (Status == ERROR_SUCCESS) ) {
            LONG Status2;

            Size = sizeof(wSubKeyName)/sizeof( WCHAR );
            Status = RegEnumKeyEx(hkeyProfileList,
                                  indx++,
                                  wSubKeyName,
                                  &Size,
                                  0,
                                  NULL,
                                  NULL,
                                  NULL );
            if ( Status == ERROR_SUCCESS ) {
                HKEY hkeyProfile;

                Status2 = RegOpenKeyEx(hkeyProfileList,
                                       wSubKeyName,
                                       0,
                                       KEY_READ,
                                       &hkeyProfile);

                if ( Status2 == ERROR_SUCCESS ) {
                    DWORD type;
                    WCHAR file[MAX_PATH], expandedFile[MAX_PATH];
                    DWORD filelen = sizeof(file);

                    Status2 = RegQueryValueExW(hkeyProfile,
                                            L"ProfileImagePath",
                                            0,
                                            &type,
                                            (PBYTE)file,
                                            &filelen );
                    if ( Status2 == ERROR_SUCCESS ) {
                        if ( ExpandEnvironmentStrings(file, expandedFile,
                             MAX_PATH) > 0) {
                                       //
                                       // Append the User Profile file "NTUSER.DAT"
                                       // to the end of the profile path.
                                       // Added by Yufeng Zheng
                                       //
                                       PWCHAR c;
                                       //
                                       // Find the trailing backslash '\' and
                                       // handle the appending according to the backslash.
                                       //
                                       if ((c = wcsrchr(expandedFile, L'\\')) == NULL) {
                                          wcscat(expandedFile, L"\\");
                                          wcscat(expandedFile, USER_PROFILE);
                                       }
                                       else if (c[1] == L'\0') {
                                          wcscat(expandedFile, USER_PROFILE);
                                       }
                                       else {
                                          wcscat(expandedFile, L"\\");
                                          wcscat(expandedFile, USER_PROFILE);
                                       }
                            if ( ProcessFile(expandedFile) ) {
                                Abort_flag = TRUE;
                            }
                        }
                    }
                    else {
                        StringErrorPrintf(IDS_ERROR_MISSING_LPROFILE, wSubKeyName);
                    }
                    RegCloseKey(hkeyProfile);
                }
                else {
                    StringErrorPrintf(IDS_ERROR_BAD_LPROFILE, wSubKeyName);
                }
            }
        }
        if ( hkeyProfileList ) {
            RegCloseKey(hkeyProfileList);
        }
    }

    return( Abort_flag );
}


/****************************************************************************
*
*  ProcessFile( PWCHAR pFile )
*       Read the specified profile, eliminate the Software\Classes registry
*       key if Classes are disabled, and resave the profile such that it
*       is truncated.
*
*  Arguments:
*       pFile   Filename to process
*
*  Returns:
*       FALSE   If completed successfully
*       TRUE    If there was an error, and the program should terminate.
*
****************************************************************************/
int
ProcessFile( PWCHAR pFile )
{
    PSID pUserSid;
    WCHAR tempbuf[100];
    int UserInput = INPUT_CONT;


    if ( Verbose_flag || Query_flag ) {
        StringMessage(IDS_MSG_PROCESSING, pFile );
    }

    if ( Query_flag ) {
        UserInput = QueryUserInput();
    }
    if ( UserInput == INPUT_CONT ) {
        if ( OpenUserProfile(pFile, &pUserSid) ) {
            ClearDisabledClasses();
            if ( ! SaveUserProfile(pUserSid, pFile) ) {
                StringErrorPrintf(IDS_ERROR_SAVING_PROFILE, pFile);
            }
            ClearTempUserProfile();
        }
        else {
            StringErrorPrintf(IDS_ERROR_OPENING_PROFILE, pFile);
        }
    }
    return ( UserInput == INPUT_QUIT );
}


int
QueryUserInput()
{
    WCHAR c, firstc;
    int Valid_flag = FALSE;
    int rc = INPUT_CONT;
    static int FirstTime = TRUE;
    static WCHAR yes[10], no[10], quit[10];

    if (FirstTime)
    {
        BOOLEAN error = FALSE;

        if ( !LoadString(NULL, IDS_UI_NO_CHAR, no, 2) ) {
            error = TRUE;
        }
        if ( !LoadString(NULL, IDS_UI_YES_CHAR, yes, 2) ) {
            error = TRUE;
        }
        if ( !LoadString(NULL, IDS_UI_QUIT_CHAR, quit, 2) ) {
            error = TRUE;
        }
        if ( error ) {
            ErrorPrintf(IDS_ERROR_MISSING_RESOURCES);
            return ( INPUT_QUIT );
        }

        FirstTime = FALSE;
    }

    fflush(stdin);
    Message(IDS_MSG_MODIFY_PROMPT);
    do {

        firstc = L'\0';
        while ( ((c = getwchar()) != L'\n') && (c != EOF) ) {
            if ( !firstc && !iswspace(c)) {
                firstc = c;
            }
        }

        if ( _wcsnicmp(yes, &firstc, 1) == 0 )
        {
            Valid_flag = TRUE;
        }
        else if ( _wcsnicmp(quit, &firstc, 1) == 0 ) {
            Valid_flag = TRUE;
            rc = INPUT_QUIT;
        }
        else if ( (_wcsnicmp(no, &firstc, 1) == 0) || (firstc == '\0') ) {
            rc = INPUT_SKIP;
            Valid_flag = TRUE;
        }
        else {
            ErrorPrintf(IDS_ERROR_INVALID_USER_RESP);
        }
    } while ( ! Valid_flag );

    return ( rc );
}

void Usage ( BOOL ErrorOccurred )
{
    if ( ErrorOccurred ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE_CMDLINE);
    } else {
        Message(IDS_USAGE_DESCR1);
        Message(IDS_USAGE_CMDLINE);
        Message(IDS_USAGE_DESCR2);
        Message(IDS_USAGE_OPTION_LIST);
        Message(IDS_USAGE_LOPTION);
        Message(IDS_USAGE_IOPTION);
        Message(IDS_USAGE_VOPTION);
        Message(IDS_USAGE_HOPTION);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\cprofile\cprofile.h ===
/***********************************************************************
*
*  CPROFILE.H
*     This module contains typedefs and defines required for
*     the CPROFILE utility.
*
*  Copyright Citrix Systems Inc. 1997
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*************************************************************************/

#ifndef RC_INVOKED
#include <ntlsa.h>
#include <ntmsv1_0.h>
#endif

#include <string.h>

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

/* StringTable Defines */
#define IDS_USAGE_CMDLINE       301
#define IDS_USAGE_DESCR1        302
#define IDS_USAGE_DESCR2        303
#define IDS_USAGE_OPTION_LIST   304
#define IDS_USAGE_LOPTION       305
#define IDS_USAGE_IOPTION       306
#define IDS_USAGE_VOPTION       307
#define IDS_USAGE_HOPTION       308

#define IDS_MSG_PROCESSING      310
#define IDS_MSG_MODIFY_PROMPT   311
#define IDS_UI_YES_CHAR         312
#define IDS_UI_NO_CHAR          313
#define IDS_UI_QUIT_CHAR        314

#define IDS_ERROR_INVALID_PARAMETERS       320
#define IDS_ERROR_MALLOC                   321
#define IDS_ERROR_PRIVILEGE_NOT_AVAILABLE  322
#define IDS_ERROR_MISSING_PROFILE_LIST     323
#define IDS_ERROR_MISSING_LPROFILE         324
#define IDS_ERROR_BAD_LPROFILE             325
#define IDS_ERROR_SAVING_PROFILE           326
#define IDS_ERROR_OPENING_PROFILE          327
#define IDS_ERROR_INVALID_USER_RESP        328
#define IDS_ERROR_MISSING_RESOURCES        330
#define IDS_ERROR_BAD_PROFILE              331
#define IDS_ERROR_PROFILE_LOAD_ERR         332
#define IDS_ERROR_PROFILE_INUSE            333
#define IDS_ERROR_NOT_ADMIN                334
#define IDS_ERROR_NOT_TS                   335

extern HKEY hkeyCurrentUser;

/*
 * Function prototypes
 */

BOOL APIENTRY EnablePrivilege(DWORD Privilege, BOOL Enable);

VOID InitializeGlobalSids();

void ClearDisabledClasses(void);

BOOL APIENTRY ClearTempUserProfile();

BOOL APIENTRY OpenUserProfile(LPTSTR szFileName, PSID *pUserSid);

BOOL APIENTRY SaveUserProfile(PSID UserSid, LPTSTR lpFilePath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\dbgtrace\dbgtrace.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  DBGTRACE.C
*
*  enable or disable tracing
*
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <winstaw.h>
#include <icadd.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>
#include <utilsub.h>

#include "dbgtrace.h"
#include "printfoa.h"

WCHAR CurDir[ 256 ];
WCHAR WinStation[MAX_IDS_LEN+1];
WCHAR TraceOption[MAX_OPTION];
int bTraceOption = FALSE;
int fDebugger  = FALSE;
int fTimestamp = FALSE;
int fHelp      = FALSE;
int fSystem    = FALSE;
int fAll       = FALSE;
ULONG TraceClass  = 0;
ULONG TraceEnable = 0;
ULONG LogonId;

TOKMAP ptm[] = {
      {L" ",      TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    WinStation},
      {L"/c",     TMFLAG_OPTIONAL, TMFORM_LONGHEX, sizeof(ULONG),  &TraceClass},
      {L"/e",     TMFLAG_OPTIONAL, TMFORM_LONGHEX, sizeof(ULONG),  &TraceEnable},
      {L"/d",     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int),    &fDebugger},
      {L"/t",     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int),    &fTimestamp},
      {L"/o",     TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_OPTION,     TraceOption},
      {L"/system", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int),   &fSystem},
      {L"/all",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int),    &fAll},
      {L"/?",     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fHelp},
      {0, 0, 0, 0, 0}
};


void SetSystemTrace( PICA_TRACE );
void SetStackTrace( PICA_TRACE );



/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
   WCHAR *CmdLine;
   WCHAR **argvW;
   ULONG rc;
   int i;
   ICA_TRACE Trace;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( fHelp || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !fHelp ) {

            ErrorPrintf(IDS_ERROR_PARAMS);
            ErrorPrintf(IDS_USAGE_1);
            ErrorPrintf(IDS_USAGE_2);
            return(FAILURE);

        } else {

            Message(IDS_USAGE_1);
            Message(IDS_USAGE_2);
            return(SUCCESS);
        }
    }

   //Check if we are running under Terminal Server
        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    if ( fAll ) {
        TraceClass  = 0xffffffff;
        TraceEnable = 0xffffffff;
    }

    /*
     *  Get current directory
     */
    (VOID) GetCurrentDirectory( 256, CurDir );

    /*
     *  Get the LogonId
     */
    if ( ptm[0].tmFlag & TMFLAG_PRESENT ) {

        if ( iswdigit( WinStation[0] ) ) {

            LogonId = (ULONG) wcstol( WinStation, NULL, 10 );

        } else {

            if ( !LogonIdFromWinStationName( SERVERNAME_CURRENT, WinStation, &LogonId ) ) {
                StringErrorPrintf( IDS_ERROR_SESSION, WinStation );
                return(-1);
            }
        }

        if ( fSystem )
            wsprintf( Trace.TraceFile, L"%s\\winframe.log", CurDir );
        else
            wsprintf( Trace.TraceFile, L"%s\\%s.log", CurDir, WinStation );

    } else {

        LogonId = GetCurrentLogonId();

        if ( fSystem )
            wsprintf( Trace.TraceFile, L"%s\\winframe.log", CurDir );
        else
            wsprintf( Trace.TraceFile, L"%s\\%u.log", CurDir, LogonId );
    }

    /*
     *  Build trace structure
     */
    Trace.fDebugger   = fDebugger ? TRUE : FALSE;
    Trace.fTimestamp  = fTimestamp ? FALSE : TRUE;
    Trace.TraceClass  = TraceClass;
    Trace.TraceEnable = TraceEnable;

    if ( TraceClass == 0 || TraceEnable == 0 )
        Trace.TraceFile[0] = '\0';

    /*
     * Fill in the trace option if any
     */
    bTraceOption = ptm[5].tmFlag & TMFLAG_PRESENT;
    if ( bTraceOption )
        memcpy(Trace.TraceOption, TraceOption, sizeof(TraceOption));
    else
        memset(Trace.TraceOption, 0, sizeof(TraceOption));

    /*
     *  Set trace information
     */
    if ( fSystem )
        SetSystemTrace( &Trace );
    else
        SetStackTrace( &Trace );

    return(0);
}


void
SetSystemTrace( PICA_TRACE pTrace )
{
    /*
     *  Set trace information
     */
    if ( !WinStationSetInformation( SERVERNAME_CURRENT,
                                    LogonId,
                                    WinStationSystemTrace,
                                    pTrace,
                                    sizeof(ICA_TRACE) ) ) {

        Message(IDS_ERROR_SET_TRACE, GetLastError());
        return;
    }

    if ( pTrace->TraceClass == 0 || pTrace->TraceEnable == 0 ) {
        Message( IDS_TRACE_DIS_LOG );
    } else {
        Message( IDS_TRACE_EN_LOG );
        wprintf( L"- %08x %08x [%s] %s\n", pTrace->TraceClass, pTrace->TraceEnable,
                pTrace->TraceFile, fDebugger ? TEXT("Debugger") : TEXT("") );
    }

}


void
SetStackTrace( PICA_TRACE pTrace )
{
    WINSTATIONINFOCLASS InfoClass;
    ULONG               InfoSize;

    /*
     *  Check for console
     */
    if ( LogonId == 0 ) {
        Message( IDS_TRACE_UNSUPP );
        return;
    }

    /*
     *  Set trace information
     */
    if ( !WinStationSetInformation( SERVERNAME_CURRENT,
                                    LogonId,
                                    WinStationTrace,
                                    pTrace,
                                                sizeof(ICA_TRACE))) {
        Message(IDS_ERROR_SET_TRACE, GetLastError());
        return;
    }

    if ( pTrace->TraceClass == 0 || pTrace->TraceEnable == 0 ) {
        Message( IDS_TRACE_DISABLED, LogonId );
    } else {
        Message( IDS_TRACE_ENABLED, LogonId );
        wprintf( L"- %08x %08x [%s] %s\n", pTrace->TraceClass, pTrace->TraceEnable,
                pTrace->TraceFile, fDebugger ? "Debugger" : "" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\dbgtrace\dbgtrace.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/***********************************************************************
*
*  DBGTRACE.H
*     This module contains typedefs and defines required for
*     the DBGTRACE utility.
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be
#define MAX_OPTION     64     // max length of winstation tracing option

#define DEBUGGER	L"Debugger"

/*
 * Resource String IDs
 */
#define IDS_ERROR_MALLOC                        100	 
#define IDS_ERROR_PARAMS                        101	
#define IDS_ERROR_SESSION                       102
#define IDS_ERROR_SET_TRACE                     103	

#define IDS_TRACE_DIS_LOG                       110 
#define IDS_TRACE_EN_LOG                        111
#define IDS_TRACE_UNSUPP                        112
#define IDS_TRACE_DISABLED                      113
#define IDS_TRACE_ENABLED                       114
#define IDS_USAGE_1                             121 
#define IDS_USAGE_2                             122
#define IDS_ERROR_NOT_TS                        123
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\doskbd\options.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*****************************************************************************
*
*  OPTIONS.H
*
*  Copyright Citrix Systems Inc. 1992
*
*  Author: Kurt Perry
*
*
****************************************************************************/


/*=============================================================================
==   Defines
=============================================================================*/
#define FALSE           0
#define TRUE            1
#define OP_BOOL         0x01
#define OP_UINT         0x02
#define OP_STRING       0x04


/*=============================================================================
==   Variables
=============================================================================*/
extern char bDefaults;
extern char bQ;
extern char bStartMonitor;
extern char bStopMonitor;
extern int dDetectProbationCount;
extern int dInProbationCount;
extern int dmsAllowed;
extern int dmsSleep;
extern int dBusymsAllowed;
extern int dmsProbationTrial;
extern int dmsGoodProbationEnd;
extern int dDetectionInterval;

char     fHelp = FALSE;

/*=============================================================================
==   Structures
=============================================================================*/
typedef struct _OPTION {
   char * option;
   int    optype;
   char * * string;
   char * bool;
   unsigned int * unint;
   char * help;
} OPTION, * POPTION;

/*
 *  Option array, all valid command line options.
 */
OPTION options[] = {

   { "?", OP_BOOL, NULL, &fHelp, NULL,
     "" },

   { "DEFAULTS", OP_BOOL, NULL, &bDefaults, NULL,
     "/DEFAULTS                Reset all tuning parameters to system defaults.\n" },

   { "Q", OP_BOOL, NULL, &bQ, NULL,
     "/Q                       Do not display any information.\n" },

   { "DETECTPROBATIONCOUNT:", OP_UINT, NULL, NULL, &dDetectProbationCount,
     "/DETECTPROBATIONCOUNT:nnn # of peeks in the detection interval required to force \
the application into the probation state and to sleep the application.\n" },

   { "INPROBATIONCOUNT:", OP_UINT, NULL, NULL, &dInProbationCount,
     "/INPROBATIONCOUNT:nnn    # of peeks in the detection interval required to sleep \
the application when the application is in probation. Should be <= DETECTPROBATIONCOUNT.\n" },

   { "MSALLOWED:", OP_UINT, NULL, NULL, &dmsAllowed,
     "/MSALLOWED:nnn           # of milliseconds the application is allowed \
to be in the probation state before the system starts sleeping the application.\n" },

   { "MSSLEEP:", OP_UINT, NULL, NULL, &dmsSleep,
     "/MSSLEEP:nnn             # of milliseconds that the application is put to sleep.\n" },

   { "BUSYMSALLOWED:", OP_UINT, NULL, NULL, &dBusymsAllowed,
     "/BUSYMSALLOWED:nnn       When the application is detected as 'busy' the \
application cannot be put into the probation state for this # of milliseconds.\n" },

   { "MSPROBATIONTRIAL:", OP_UINT, NULL, NULL, &dmsProbationTrial,
     "/MSPROBATIONTRIAL:nnn    When the application is in probation, \
DETECTPROBATIONCOUNT is used instead of INPROBATIONCOUNT every MSPROBATIONTRIAL milliseconds.\n" },

   { "MSGOODPROBATIONEND:", OP_UINT, NULL, NULL, &dmsGoodProbationEnd,
     "/MSGOODPROBATIONEND:nnn  When the application is in probation it must \
avoid being put to sleep for this # of milliseconds in order to be removed from probation.\n" },

   { "DETECTIONINTERVAL:", OP_UINT, NULL, NULL, &dDetectionInterval,
     "/DETECTIONINTERVAL:nnn  The length of time (in ticks) used to count up \
the number of polling events.\n" },

   { "STARTMONITOR", OP_BOOL, NULL, &bStartMonitor, NULL,
     "/STARTMONITOR [appname]  Start gathering polling statistics.\n"},

   { "STOPMONITOR", OP_BOOL, NULL, &bStopMonitor, NULL,
     "/STOPMONITOR  Stop gathering polling information and display statistics.\n"},

};

#define  ARG_COUNT   (int)(sizeof(options) / sizeof(OPTION))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\doskbd\options.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*******************************************************************************
*
*  OPTIONS.C
*     This module contains routines to parse the command line
*
*  Copyright Citrix Systems Inc. 1992
*
*  Author: Kurt Perry
*
*
*******************************************************************************/

/*  Get the standard C includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "options.h"


/*=============================================================================
==   Functions Defined
=============================================================================*/

int OptionsParse( int, char * [] );
static void OptionsHelp( char );


/*=============================================================================
==   Functions Used
=============================================================================*/


/*=============================================================================
==   External data
=============================================================================*/


/******************************************************************************
 *
 *  OptionsParse
 *
 *  ENTRY:
 *    argc (input)
 *       number of arguments
 *    argv (input)
 *       pointer to arguments
 *
 *  EXIT:
 *     nothing
 *
 *****************************************************************************/

int
OptionsParse( int argc, char * argv[] )
{
   int fBadParm = FALSE;
   int i, j;
   int len;
   char * p;
   int place = -1;
   unsigned int test;
   char foundq = FALSE;       //found the /Q switch
   char foundother = FALSE;   //found any of the integer switches
   char founddefaults = FALSE; //found the /Defaults switch
   char foundStartMon = FALSE; //found the /StartMonitor switch

   /*
    *  Look for command line switches
    */
   for ( i=1; (i < argc) && !foundStartMon; i++ ) {

      /*
       * A command line switch?
       */
      switch ( argv[i][0] ) {
      case '-':
      case '/':
         ++argv[i];
         if ( place != -1 )
            fBadParm = TRUE;
         place = -1;
         for ( j=0; j<ARG_COUNT; j++ ) {
            p = options[j].option;
            len = strlen(p);
            if ( !strnicmp( argv[i], p, len ) ) {

               // if args separated by blanks hold place
               if ( strlen( &argv[i][len] ) == 0 )
                  place = (options[j].optype & (OP_STRING|OP_UINT)) ? j : -1;

               // string option
               if ( (options[j].optype & OP_STRING) )
                  *(options[j].string) = &argv[i][len];

               // boolean option
               //add code to check for /q, /defaults, and /startmonitor switch
               if ( (options[j].optype & OP_BOOL) ) {
                  *(options[j].bool) = (char) TRUE;
                  if (!strnicmp(p,"Q",len)) {
                     foundq = TRUE;
                  }
                  else if (!strnicmp(p,"Defaults",len)) {
                     founddefaults = TRUE;
                  }
                  else if (!strnicmp(p,"StartMonitor",len)) {
                     foundStartMon = TRUE;
                  }
               }

               // int option
               if ( (options[j].optype & OP_UINT) ) {
//original code
//                  *(options[j].unint) = (unsigned int) atoi(&argv[i][len]);
//new code to check for out of bounds and to make sure
//that don't only use /Q switch
                  test = (unsigned int) atoi(&argv[i][len]);
                  if (test > 32767) {
                     fBadParm = TRUE;
                  }
                  *(options[j].unint) = test;
                  foundother = TRUE;
               }

               goto ok;
            }
         }
         fBadParm = TRUE;
ok:
         break;

      default:
         fBadParm = TRUE;

#if 0
         // options separated by space
         if ( place != -1 ) {
            if ( (options[place].optype & OP_STRING) )
               *(options[place].string) = argv[i];
            else
               *(options[place].unint) = (unsigned int) atoi(argv[i]);

            place = -1;
            break;
         }
//         free( pOptionEntry->pLabel );
//         pOptionEntry->pLabel = strdup( argv[i] );
#endif
         break;
      }

   }

//   printf("fHelp=%u,fBadParm=%u,place=%u\n",fHelp,fBadParm,place);
   /*
    *  Check for help or any detected command line errors
    */
   //change code to check consistancy of /q and /defaults
   if ( fHelp || fBadParm || (place != -1) ||
        (founddefaults && foundother) ||
        (foundq && !foundother && !founddefaults )  ) {
      OptionsHelp(fHelp);
      return(1);  //failure
   }
   return(0);

}


/******************************************************************************
 *
 *  OptionsHelp
 *
 *  Display help on command line options
 *
 *  ENTRY:
 *     nothing
 *
 *  EXIT:
 *     nothing
 *
 *****************************************************************************/

static void
OptionsHelp(char bVerbose)
{
   int i;

   /*
    *  Display help header
    */
   printf("DOSKBD is used to tune the DOS Keyboard Polling Detection Algorithm\n");
   printf("       for a specific DOS execution environment (window).\n");
   printf("DOSKBD\n");
   printf("DOSKBD /DEFAULTS [/Q]\n");
   printf("DOSKBD [/DETECTPROBATIONCOUNT:nnn] [/INPROBATIONCOUNT:nnn] [/MSALLOWED:nnn]\n");
   printf("       [/MSSLEEP:nnn] [/BUSYMSALLOWED:nnn] [/MSPROBATIONTRIAL:nnn]\n");
   printf("       [/MSGOODPROBATIONEND:nnn] [/DETECTIONINTERVAL:nnn]\n");
   printf("       [/STARTMONITOR [appname] | /STOPMONITOR] [/Q]\n\n");
   printf("DOSKBD displays new/current settings unless /Q is used.\n");
   printf("Valid range for all values (represented by nnn) is 0 to 32767.\n");

   if (bVerbose) {
      /*
       *  Display help message, pausing each page
       */
      for ( i=0; i<ARG_COUNT; i++ ) {

         // message
         printf( "%s\n", options[i].help );

      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\flattemp\flattemp.h ===
/***********************************************************************
*
*   FLATTEMP.H
*
*   This module contains typedefs and defines required for
*   the FLATTEMP utility.
*
*   Copyright Citrix Systems Inc. 1996
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_HELP_USAGE1                                 102
#define IDS_HELP_USAGE2                                 103
#define IDS_HELP_USAGE3                                 104
#define IDS_HELP_USAGE4                                 105
#define IDS_HELP_USAGE5                                 106
#define IDS_FLATTEMP_DISABLED                           107
#define IDS_FLATTEMP_ENABLED                            108
#define IDS_ACCESS_DENIED                               109
#define IDS_ACCESS_DENIED_ADMIN                         110
#define IDS_ERROR_NOT_TS                                111
#define IDS_ACCESS_DENIED_DUE_TO_GROUP_POLICY           112
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\disconn\tsdiscon.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  TSDISCON.H
*     This module contains typedefs and defines for the TSDISCON
*     WinStation utility.
*
*
*************************************************************************/

/*
 * Token string definitions.
 */
#define TOKEN_WS                        L""
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_HELP                      L"/?"
#define TOKEN_SERVER                    L"/server"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_NOT_FOUND                  102
#define IDS_ERROR_INVALID_LOGONID                       103
#define IDS_ERROR_LOGONID_NOT_FOUND                     104
#define IDS_ERROR_DISCONNECT                            105
#define IDS_ERROR_DISCONNECT_CURRENT                    106
#define IDS_ERROR_CANT_GET_CURRENT_WINSTATION           107
#define IDS_ERROR_SERVER                                108

#define IDS_USAGE_1                                     121
#define IDS_USAGE_2                                     122
#define IDS_USAGE_3                                     123
#define IDS_USAGE_4                                     124
#define IDS_USAGE_5                                     125
#define IDS_USAGE_6                                     126
#define IDS_ERROR_NOT_TS                                127

#define IDS_WINSTATION_DISCONNECT                       200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\disconn\tsdiscon.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  TSDISCON.C
*
*     This module is the TSDISCON utility code.
*
*
*************************************************************************/

#include <stdio.h>
#include <windows.h>
//#include <ntddkbd.h>
//#include <ntddmou.h>
#include <winstaw.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>

#include "tsdiscon.h"
#include "printfoa.h"

WINSTATIONNAME WSName;
USHORT help_flag = FALSE;
USHORT v_flag    = FALSE;
HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];

TOKMAP ptm[] =
{
#define TERM_PARM 0
   {TOKEN_WS,           TMFLAG_OPTIONAL, TMFORM_STRING,
                            WINSTATIONNAME_LENGTH, WSName},

   {TOKEN_SERVER,       TMFLAG_OPTIONAL, TMFORM_STRING,
                            MAX_IDS_LEN, ServerName},

   {TOKEN_HELP,         TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                            sizeof(USHORT), &help_flag},

   {TOKEN_VERBOSE,      TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                            sizeof(USHORT), &v_flag},

   {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );



/*************************************************************************
*
*  main
*     Main function and entry point of the TSDISCON
*     utility.
*
*  ENTRY:
*     argc  - count of the command line arguments.
*     argv  - vector of strings containing the command line arguments.
*
*  EXIT
*     Nothing.
*
*************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    BOOLEAN bCurrent = FALSE;
    int   rc, i;
    ULONG Error;
    WCHAR *CmdLine;
    WCHAR **argvW, *endptr;
    ULONG LogonId;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        //Check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, TOKEN_SERVER) ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     * Validate input string for WinStation or LogonId.
     */
    if ( !IsTokenPresent(ptm, TOKEN_WS) ) {

        /*
         * No string specified; use current WinStation / LogonId.
         */
        bCurrent = TRUE;
        LogonId = GetCurrentLogonId();
        if ( !WinStationNameFromLogonId(hServerName, LogonId, WSName) ) {
            ErrorPrintf(IDS_ERROR_CANT_GET_CURRENT_WINSTATION, GetLastError());
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }

    } else if ( !iswdigit(*WSName) ) {

        /*
         * Treat the string as a WinStation name.
         */
        if ( !LogonIdFromWinStationName(hServerName, WSName, &LogonId) ) {
            StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, WSName);
            return(FAILURE);
        }

    } else {

        /*
         * Treat the string as a LogonId.
         */
        LogonId = wcstoul(WSName, &endptr, 10);
        if ( *endptr ) {
            StringErrorPrintf(IDS_ERROR_INVALID_LOGONID, WSName);
            return(FAILURE);
        }
        if ( !WinStationNameFromLogonId(hServerName, LogonId, WSName) ) {
            ErrorPrintf(IDS_ERROR_LOGONID_NOT_FOUND, LogonId);
            return(FAILURE);
        }
    }

    /*
     * Perform the disconnect.
     */
    if ( v_flag )
        DwordStringMessage(IDS_WINSTATION_DISCONNECT, LogonId, WSName);

    if ( !WinStationDisconnect(hServerName, LogonId, TRUE) ) {

        if ( bCurrent )
            ErrorPrintf(IDS_ERROR_DISCONNECT_CURRENT,
                         GetLastError());
        else
            ErrorPrintf(IDS_ERROR_DISCONNECT,
                         LogonId, WSName, GetLastError());
        PutStdErr( GetLastError(), 0 );
        return(FAILURE);
    }

    return(SUCCESS);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {

        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE_1);
        ErrorPrintf(IDS_USAGE_2);
        ErrorPrintf(IDS_USAGE_3);
        ErrorPrintf(IDS_USAGE_4);
        ErrorPrintf(IDS_USAGE_5);
        ErrorPrintf(IDS_USAGE_6);

    } else {

        Message(IDS_USAGE_1);
        Message(IDS_USAGE_2);
        Message(IDS_USAGE_3);
        Message(IDS_USAGE_4);
        Message(IDS_USAGE_5);
        Message(IDS_USAGE_6);
    }

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\doskbd\doskbd.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation



/*  Get the standard C includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <process.h>
#include <dos.h>
#include <errno.h>

#define FALSE 0
#define TRUE  1
#define STARTMON "StartMonitor"

/*=============================================================================
==   External Functions Used
=============================================================================*/

int OptionsParse( int, char * [] );

/*=============================================================================
==   Local Functions Used
=============================================================================*/

char GetCommandLine(char *);

/*=============================================================================
==   Global data
=============================================================================*/

char  bQ = FALSE;
char  bDefaults = FALSE;
char  bStartMonitor = FALSE;
char  bStopMonitor = FALSE;
int   dDetectProbationCount = -1;
int   dInProbationCount = -1;
int   dmsAllowed = -1;
int   dmsSleep = -1;
int   dBusymsAllowed = -1;
int   dmsProbationTrial = -1;
int   dmsGoodProbationEnd = -1;
int   dDetectionInterval = -1;



typedef struct _DOSKBDIDLEKNOBS
{
   short int   DetectProbationCount;
   short int   InProbationCount;
   short int   BusymsAllowed;
   short int   msAllowed;
   short int   msGoodProbationEnd;
   short int   msProbationTrial;
   short int   msSleep;
   short int   msInSystemTick;
   short int   DetectionInterval;
} DOSKBDIDLEKNOBS, *PDOSKBDIDLEKNOBS;

typedef union {
   unsigned long longword;
   struct {
      unsigned short usloword;
      unsigned short ushiword;
   } words;
} LONGTYPE;


/*******************************************************************************
 *
 * main
 *
 * ENTRY:
 *     argc (input)
 *        number of arguments
 *     argv (input)
 *        pointer to arguments
 *
 * EXIT:
 *
 ******************************************************************************/

void
main( int argc, char * argv[] )
{
   LONGTYPE       totalticks;
   LONGTYPE       totalpolls;
   unsigned short usminpolls;
   unsigned short usmaxpolls;
   int            rc;
   char           bExec = FALSE;

   DOSKBDIDLEKNOBS data = {-1,-1,-1,-1,-1,-1,-1,-1,-1};

   //get command line options into global variables
   if (OptionsParse( argc, argv )) return;      //non zero return code is failure

   //if /Defaults then we do a special bop to reset everything
   //and then we continue as a display information only
   //dont worry about optimizing for the /q case

   if (bDefaults) {
      _asm {
         push  ax
         mov   al,3     ;for the set registry defaults subparm
         mov   ah,254   ;for the main pop parm

         mov   BYTE PTR cs:crap,0c4h
         mov   BYTE PTR cs:crap+1,0c4H
         mov   BYTE PTR cs:crap+2,16H
         ;we need to flush the prefetch buffer for self modifying code
         ;asm in c will not allow db directive
         jmp short crap
crap:
         nop
         nop
         nop

;        db    0c4H;,0c4H,16H        ;the bop

         pop   ax
      }
   }


   _asm {
      push  ax
      push  bx
      push  cx
      push  dx

      mov   al,0     ;for first BOP
      mov   ah,254   ;for first BOP
      mov   bx,WORD PTR dDetectProbationCount
      mov   cx,WORD PTR dInProbationCount
      mov   BYTE PTR cs:crap1,0c4h
      mov   BYTE PTR cs:crap1+1,0c4H
      mov   BYTE PTR cs:crap1+2,16H
      ;we need to flush the prefetch buffer for self modifying code
      ;asm in c will not allow db directive
      jmp short crap1
crap1:
      nop
      nop
      nop

;      db    0c4H;,0c4H,16H        ;the bop
      mov   WORD PTR data.DetectProbationCount,bx
      mov   WORD PTR data.InProbationCount,cx
      mov   WORD PTR data.msInSystemTick,dx

      mov   al,1     ;for second BOP
      mov   ah,254   ;for second BOP
      mov   bx,WORD PTR dBusymsAllowed
      mov   cx,WORD PTR dmsAllowed
      mov   dx,WORD PTR dmsSleep
      mov   BYTE PTR cs:crap2,0c4h
      mov   BYTE PTR cs:crap2+1,0c4H
      mov   BYTE PTR cs:crap2+2,16H
      ;we need to flush the prefetch buffer for self modifying code
      ;asm in c will not allow db directive
      jmp short crap2
crap2:
      nop
      nop
      nop
;     db    0c4H;,0c4H,16H        ;the BOP
      mov   WORD PTR data.BusymsAllowed,bx
      mov   WORD PTR data.msAllowed,cx
      mov   WORD PTR data.msSleep,dx

      mov   al,2
      mov   ah,254
      mov   bx,WORD PTR dmsGoodProbationEnd
      mov   cx,WORD PTR dmsProbationTrial
      mov   dx,WORD PTR dDetectionInterval

      mov   BYTE PTR cs:crap3,0c4h
      mov   BYTE PTR cs:crap3+1,0c4H
      mov   BYTE PTR cs:crap3+2,16H
      ;we need to flush the prefetch buffer for self modifying code
      ;asm in c will not allow db directive
      jmp short crap3
crap3:
      nop
      nop
      nop
;     db    0c4H;,0c4H,16H
      mov   WORD PTR data.msGoodProbationEnd,bx
      mov   WORD PTR data.msProbationTrial,cx
      mov   WORD PTR data.DetectionInterval,dx

      pop   dx
      pop   cx
      pop   bx
      pop   ax

   }

   // Turn on keyboard monitoring
   if (bStartMonitor) {

      _asm {
         mov   al,4
         mov   ah,254
   
         mov   BYTE PTR cs:crap4,0c4h
         mov   BYTE PTR cs:crap4+1,0c4H
         mov   BYTE PTR cs:crap4+2,16H
         ;we need to flush the prefetch buffer for self modifying code
         ;asm in c will not allow db directive
         jmp short crap4
crap4:
         nop
         nop
         nop
;        db    0c4H;,0c4H,16H
      }

      // If they specified the name of the app, try to exec it
      if (argc > 2) {
         char *pch = NULL;
         char bBatFile = FALSE;

         // If this is a batch file, pass to command processor
         if ((pch = strrchr(argv[2],'.')) && !stricmp(pch, ".bat")) {
            bBatFile = TRUE;
         } else {
            rc = spawnvp(P_WAIT, argv[2], &argv[2]);
         }
         bExec = TRUE;

         if ((rc == -1) || bBatFile) {
            // maybe they tried to run a batch file, so look for xxx.bat
            if ((errno == ENOENT) || (bBatFile)) {
               char pcmdline[256];

               if (GetCommandLine(pcmdline)) {
                  rc = system(pcmdline);
               }
            }
         }
      }
   }

   if (bStopMonitor || bExec) {
      _asm {
         push  di
         push  si
         mov   al,5
         mov   ah,254
   
         mov   BYTE PTR cs:crap5,0c4h
         mov   BYTE PTR cs:crap5+1,0c4H
         mov   BYTE PTR cs:crap5+2,16H
         ;we need to flush the prefetch buffer for self modifying code
         ;asm in c will not allow db directive
         jmp short crap5
crap5:
         nop
         nop
         nop
;        db    0c4H;,0c4H,16H

         mov   totalticks.words.usloword, ax    ; get the polling data
         mov   totalticks.words.ushiword, bx    ; get the polling data
         mov   totalpolls.words.usloword, cx
         mov   totalpolls.words.ushiword, dx
         mov   usmaxpolls, si
         mov   usminpolls, di
         pop   si
         pop   di
      }


      // If they entered /stopmonitor or the app exited while monitoring,
      // display the statistics
      if (!bExec || (bExec && (rc != -1))) {
         double avg;

         printf("\nTotal polls: %lu\n", totalpolls.longword);
         printf("Total ticks: %lu\n", totalticks.longword);
         avg = (double)(totalpolls.longword)/(double)(totalticks.longword);
         printf("Avg. polls/tick: %.1f\n", avg);
         printf("Minimum polls per detection interval: %u\n", usminpolls);
         printf("Maximum polls per detection interval: %u\n", usmaxpolls);
         printf("Number of milliseconds in a system timer tick is %hd\n",
                 data.msInSystemTick);
         printf("DetectionInterval = %hd tick(s) (%hd msec)\n", 
                data.DetectionInterval, 
                data.DetectionInterval*data.msInSystemTick);
      }
   }

   if (!bQ && !bStartMonitor && !bStopMonitor) {
      printf("Number of milliseconds in a system timer tick is %hd\n",
              data.msInSystemTick);

      printf("DetectionInterval = %hd tick(s) (%hd msec)\n", 
             data.DetectionInterval, 
             data.DetectionInterval*data.msInSystemTick);

      printf("DetectProbationCount= %hd\nInProbationCount= %hd\n",
              data.DetectProbationCount,data.InProbationCount);

      printf("msAllowed= %hd\nmsSleep= %hd\n",data.msAllowed,data.msSleep);

      printf("BusymsAllowed= %hd\nmsProbationTrial= %hd\n\
msGoodProbationEnd= %hd\n",data.BusymsAllowed,
              data.msProbationTrial,data.msGoodProbationEnd);
   }

}


/*******************************************************************************
 *
 * GetCommandLine
 *
 * Return the command line following the /startmonitor switch.  
 *
 * ENTRY:
 *  char *pbuff: pointer to hold command line (returned)
 *
 * EXIT:
 *  SUCCESS: returns TRUE
 *  FAILURE: returns FALSE
 *
 ******************************************************************************/

char GetCommandLine(char *pbuff) 
{
   char *pch, *pcmdline;
   char bfound = FALSE;

   // copy the command line from the PSP to a near buffer
   if (pcmdline = malloc(256)) {
      _asm {
         push  ds
         push  si
         push  di
         mov   ax, _psp
         mov   ds, ax
         mov   si, 80h
         mov   di, pcmdline
         xor   ax,ax
         lodsb
         mov   cx,ax
         rep   movsb
         xor   ax,ax
         stosb 
         pop   di
         pop   si
         pop   ds
      }
      pch = pcmdline;
      while (pch && !bfound) { 
   
         // Get next / or -
         pch = strchr(pch, '/');
         if (!pch) {
            pch = strchr(pch, '-');
         }
   
         // If we found a / or -, skip over it and check for startmonitor
         if (pch) {
            pch++;
   
            if (!strnicmp(pch, STARTMON, sizeof(STARTMON) - 1)) {
               pch += sizeof(STARTMON);
               bfound = TRUE;
            }
         }
      }

      // If we found /startmonitor, return the rest of the command line
      if (bfound) {
         strcpy(pbuff, pch);
         return(TRUE);
      }
      free(pcmdline);
   }
   return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\flattemp\flattemp.c ===
/******************************************************************************
*
*   FLATTEMP.C
*
*   This module contains code for the FLATTEMP utility.
*   This utility adds or removes the Flat Temporary directory registry key.
*
*   Copyright Citrix Systems Inc. 1996
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winstaw.h>
#include <regapi.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <utildll.h>
#include <locale.h>

#include "flattemp.h"
#include "printfoa.h"

/*
 * Global Data
 */
USHORT   help_flag    = FALSE;             // User wants help
USHORT   fQuery       = FALSE;             // query
USHORT   fDisable     = FALSE;             // disable
USHORT   fEnable      = FALSE;             // enable

TOKMAP ptm[] = {
      {L"/query",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fQuery},
      {L"/enable",  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fEnable},
      {L"/disable", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fDisable},
      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
VOID  Usage(BOOLEAN bError);
LONG  DeleteKey(VOID);
LONG  AddKey(VOID);
BOOL  QueryKey(VOID);


#define SZENABLE TEXT("1")


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    WCHAR *CmdLine;
    WCHAR **argvW;
    LONG  rc = 0;
    INT   i;
    POLICY_TS_MACHINE policy;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

             if ( !help_flag && !(rc & PARSE_FLAG_NO_PARMS) ) {

                Usage(TRUE);
                return(FAILURE);

             } else {

                Usage(FALSE);
                return(SUCCESS);
             }
    }

    /*
     * If there is a policy to user tmp folders, then prevent
     * this tool from running.
     */
    RegGetMachinePolicy( &policy );

    if ( policy.fPolicyTempFoldersPerSession )
    {
        Message( IDS_ACCESS_DENIED_DUE_TO_GROUP_POLICY );
        return ( FAILURE );
    }

        //Check if we are running under Terminal Server
        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    if (!TestUserForAdmin(FALSE)) {
        Message(IDS_ACCESS_DENIED_ADMIN);
        return(FAILURE);
    }

    /*
     *  Enable or disable
     */
    rc = 0; // reset in case it changed above and we're querying...
    if ( fDisable ) {
        rc = DeleteKey();
        Message(IDS_FLATTEMP_DISABLED);
    } else if ( fEnable ) {
        rc = AddKey();
        Message(IDS_FLATTEMP_ENABLED);
    } else if ( fQuery ) {
        if ( QueryKey() ) {
           Message(IDS_FLATTEMP_ENABLED);
        } else {
           Message(IDS_FLATTEMP_DISABLED);
        }
    }

    /*
     *  Error?  (It'll be set if there's a problem...)
     */
    if ( rc ) {
        Message(IDS_ACCESS_DENIED);
    }

    return(SUCCESS);
}


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        Message(IDS_ERROR_INVALID_PARAMETERS);
    }
    Message(IDS_HELP_USAGE1);
    Message(IDS_HELP_USAGE2);
    Message(IDS_HELP_USAGE3);
    Message(IDS_HELP_USAGE4);
    Message(IDS_HELP_USAGE5);

}  /* Usage() */


/*******************************************************************************
 *
 *  QueryKey
 *
 *  ENTRY:
 *
 *  EXIT: TRUE  - enabled
 *        FALSE - disabled (key doesn't exist or isn't "1")
 *
 *
 ******************************************************************************/

BOOL
QueryKey()
{
    DWORD  dwType = REG_SZ;
    DWORD  dwSize = 3 * sizeof(WCHAR);
    WCHAR  szValue[3];
    HKEY   Handle;
    LONG   rc;

    /*
     *  Open registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REG_CONTROL_TSERVER,
                       0,
                       KEY_READ,
                       &Handle ) != ERROR_SUCCESS )
        return FALSE;

    /*
     *  Read registry value
     */
    rc = RegQueryValueExW( Handle,
                           REG_CITRIX_FLATTEMPDIR,
                           NULL,
                           &dwType,
                           (PUCHAR)&szValue,
                           &dwSize );

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    if ( rc == ERROR_SUCCESS && lstrcmp(szValue,SZENABLE) == 0 ) {
       return TRUE;
    } else {
       return FALSE;
    }
}


/*******************************************************************************
 *
 *  DeleteKey
 *
 *  ENTRY:
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

LONG
DeleteKey()
{
    HKEY   Handle;
    LONG   rc;

    /*
     *  Open registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REG_CONTROL_TSERVER,
                       0,
                       KEY_ALL_ACCESS,
                       &Handle ) != ERROR_SUCCESS )
        return FALSE;

    /*
     *  Delete flat temp directory key
     */
    rc = RegDeleteValueW( Handle,
                          REG_CITRIX_FLATTEMPDIR );

    if (rc == ERROR_FILE_NOT_FOUND) {
        rc = ERROR_SUCCESS;
    }

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    return( rc );
}


/*******************************************************************************
 *
 *  AddKey
 *
 *  ENTRY:
 *
 * EXIT:
 *
 *
 ******************************************************************************/

LONG
AddKey()
{
    HKEY   Handle;
    LONG   rc;
    DWORD  dwDummy;

    /*
     *  Open registry
     */
    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                         REG_CONTROL_TSERVER,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &Handle,
                         &dwDummy ) != ERROR_SUCCESS )
        return FALSE;

    /*
     *  Write registry value
     */
    rc = RegSetValueExW( Handle,
                         REG_CITRIX_FLATTEMPDIR,
                         0,
                         REG_SZ,
                         (PUCHAR)SZENABLE,
                         sizeof(SZENABLE) );

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    return( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\inc\ansiuni.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*******************************************************************************
*
* ansiuni.h
*
* ANSI / UNICODE function defines
*
*
*******************************************************************************/

#ifdef UNICODE
#ifndef TCHAR
#define TCHAR WCHAR
#endif // TCHAR
#define lstrscanf swscanf
#define lstrncpy wcsncpy
#define lstrtoul wcstoul
#define lstrtol wcstol
#define lstrnicmp _wcsnicmp
#define lstrupr _wcsupr
#define lstrlwr _wcslwr
#define islstrdigit iswdigit
#define lstrtok wcstok
#define lstrprintf swprintf
#define lstrnprintf _snwprintf
#define lstrchr wcschr
#define lstrpbrk wcspbrk
#define lstrrchr wcsrchr
#define lstr_getcwd _wgetcwd
#define lstr_access _waccess
#define lstr_mkdir _wmkdir
#define lstrstr wcsstr
#define lstrcspn wcscspn
#else
#ifndef TCHAR
#define TCHAR char
#endif // TCHAR
#ifdef WIN16
#define lstrscanf sscanf	    // need to cast string args to NEAR pointers
#define lstrncpy _fstrncpy
#define lstrtoul strtoul	    // need to cast string args to NEAR pointers
#define lstrtol strtol		    // need to cast string args to NEAR pointers
#define lstrnicmp _fstrnicmp
#define lstrupr _fstrupr
#define lstrlwr _fstrlwr
#define islstrdigit isdigit
#define lstrtok _fstrtok
#define lstrprintf sprintf          // need to cast string args to NEAR pointers
#define lstrnprintf _snprintf	    // need to cast string args to NEAR pointers
#define lstrchr _fstrchr
#define lstrpbrk _fstrpbrk
#define lstrrchr _fstrrchr
#define lstr_getcwd _getcwd	    // need to cast string args to NEAR pointers
#define lstr_access _access	    // need to cast string args to NEAR pointers
#define lstr_mkdir _mkdir	    // need to cast string args to NEAR pointers
#define lstrstr strstr  	    // need to cast string args to NEAR pointers
#define lstrcspn strcspn	    // need to cast string args to NEAR pointers
#else
#define lstrscanf sscanf
#define lstrncpy strncpy
#define lstrtoul strtoul
#define lstrtol strtol
#define lstrnicmp _strnicmp
#define lstrupr _strupr
#define lstrlwr _strlwr
#define islstrdigit isdigit
#define lstrtok strtok
#define lstrprintf sprintf
#define lstrnprintf _snprintf
#define lstrchr strchr
#define lstrpbrk strpbrk
#define lstrrchr strrchr
#define lstr_getcwd _getcwd
#define lstr_access _access
#define lstr_mkdir _mkdir
#define lstrstr strstr
#define lstrcspn strcspn
#endif // WIN16
#endif // UNICODE

#define lengthof(x)    (sizeof(x) / sizeof(TCHAR))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\inc\expand.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*****************************************************************************
*
*   EXPAND.H
*
*
****************************************************************************/

/*
* Argument structure
*    Used by expand_path routine to build argument list.
*    Caller should initialize using args_init().  Use args_reset() to
*    reset values, args_free() to free memory allocated by args_init().
*/
struct arg_data {
   int argc;
   WCHAR **argv;
   WCHAR **argvp;
   int maxargc;
   int maxargs;
   WCHAR *buf;
   WCHAR *bufptr;
   WCHAR *bufend;
};
typedef struct arg_data ARGS;

/*
 * max size of segment to allocate for pathname storage
 */
#define MAX_ARG_ALLOC 10*1024-20

extern void args_init(ARGS *, int);
extern void args_trunc(ARGS *);
extern void args_reset(ARGS *);
extern void args_free(ARGS *);
extern int  expand_path(WCHAR *, unsigned short, ARGS *);
extern int  unix_match(WCHAR *, WCHAR *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\inc\printfoa.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
//=============================================================================
//
//
//=============================================================================


#ifndef _PRINTF_OEM_ANSI_H
#define _PRINTF_OEM_ANSI_H


// Include files:
//===============
#include <windows.h>
#include <stdio.h>

// Forward References:
//====================


// Const/Define:
//==============

#define printf  ANSI2OEM_Printf
#define wprintf ANSI2OEM_Wprintf

// Classes/Structs:
//=================


// Function Prototypes:
//=====================

#ifdef __cpluspus
extern "C" {
#endif
int ANSI2OEM_Printf(const char *format, ...);
int ANSI2OEM_Wprintf(const wchar_t *format, ...);
void OEM2ANSIW(wchar_t *buffer, USHORT len);
void OEM2ANSIA(char *buffer, USHORT len);
#ifdef __cpluspus
};
#endif

#endif

// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\inc\utilsub.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*****************************************************************************
*   UTILSUB.H
*      This file contains the structure definitions and equtates for
*      communication between calling programs and functions in utilsub.lib.
*
****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/*-----------------------------------------------------------------------------
 --   type-defs for File List Structure.
 ----------------------------------------------------------------------------*/
typedef struct _FILELIST {
   int	  argc;
   WCHAR  **argv;
} FILELIST, *PFILELIST;

/*-----------------------------------------------------------------------------
 --   type-defs for Token Map Structure.
 ----------------------------------------------------------------------------*/
// UNICODE version
typedef struct _TOKMAPW {
   PWCHAR tmToken;	   /* token; null pointer terminates list */
   USHORT tmFlag;	   /* flags for control communication */
   USHORT tmForm;	   /* format control string */
   USHORT tmDLen;	   /* length of data fields */
   PVOID  tmAddr;	   /* pointer to interpreted data */
} TOKMAPW, *PTOKMAPW;

// ANSI version
typedef struct _TOKMAPA {
   PCHAR  tmToken;	   /* token; null pointer terminates list */
   USHORT tmFlag;	   /* flags for control communication */
   USHORT tmForm;	   /* format control string */
   USHORT tmDLen;	   /* length of data fields */
   PVOID  tmAddr;	   /* pointer to interpreted data */
} TOKMAPA, *PTOKMAPA;

/*-----------------------------------------------------------------------------
 --   type-defs for Token Map Structure USE FOR CALLING SDM.DLL FUNCIONS
 ----------------------------------------------------------------------------*/
typedef struct _FILETOKMAP {
   PWCHAR tmToken;         /* token; null pointer terminates list */
   USHORT tmFlag;	   /* flags for control communication */
   USHORT tmForm;	   /* format control string */
   USHORT tmDLen;	   /* length of data fields */
   PVOID  tmAddr;	   /* pointer to interpreted data */
   USHORT tmLast;	   /* pointer for FindFirst FindNext junk */
} FILETOKMAP, FAR * PFILETOKMAP, NEAR * NPFILETOKMAP, * DPFILETOKMAP;

/*-----------------------------------------------------------------------------
 --   equates for _TOKMAP->tmFlag
 ----------------------------------------------------------------------------*/
#define TMFLAG_OPTIONAL       0x0000
#define TMFLAG_REQUIRED       0x0001
#define TMFLAG_PRESENT	      0x0002   /* was present in command line */
#define TMFLAG_MODIFIED       0x0004   /* was modified by app, request write */
#define TMFLAG_DELETE	      0x0008   /* request delete */

/*-----------------------------------------------------------------------------
 --   equates for _TOKMAP->tmForm
 ----------------------------------------------------------------------------*/
#define TMFORM_VOID	      0x0000
#define TMFORM_BOOLEAN	      0x0001
#define TMFORM_BYTE	      0x0002
#define TMFORM_CHAR	      0x0003
#define TMFORM_STRING	      0x0004
#define TMFORM_SHORT	      0x0005
#define TMFORM_USHORT	      0x0006
#define TMFORM_LONG	      0x0007
#define TMFORM_ULONG	      0x0008
#define TMFORM_HEX	      0x0009
#define TMFORM_LONGHEX	      0x000A
#define TMFORM_SERIAL	      0x000B
#define TMFORM_DATE	      0x000C
#define TMFORM_PHONE	      0x000D
#define TMFORM_X_STRING       0x000E
#define TMFORM_FILES	      0x000F
#define TMFORM_S_STRING       0x0010

/*-----------------------------------------------------------------------------
 --   equates for _TOKMAP->tmDLen
 ----------------------------------------------------------------------------*/
#define TMDLEN_VOID	      0x0000

/*-----------------------------------------------------------------------------
 --   prototype for Parse and setargv functions
 ----------------------------------------------------------------------------*/
// UNICODE prototypes
int WINAPI setargvW( LPWSTR szModuleName, LPWSTR szCmdLine, int *, WCHAR *** );
void WINAPI freeargvW( WCHAR ** );
USHORT WINAPI ParseCommandLineW(INT, WCHAR **, PTOKMAPW, USHORT);
BOOLEAN WINAPI IsTokenPresentW( PTOKMAPW, PWCHAR );
BOOLEAN WINAPI SetTokenPresentW( PTOKMAPW, PWCHAR );
BOOLEAN WINAPI SetTokenNotPresentW( PTOKMAPW, PWCHAR );

// ANSI prototypes
int WINAPI setargvA( LPSTR szModuleName, LPSTR szCmdLine, int *, char *** );
void WINAPI freeargvA( char ** );
USHORT WINAPI ParseCommandLineA(INT, CHAR **, PTOKMAPA, USHORT);
BOOLEAN WINAPI IsTokenPresentA( PTOKMAPA, PCHAR );
BOOLEAN WINAPI SetTokenPresentA( PTOKMAPA, PCHAR );
BOOLEAN WINAPI SetTokenNotPresentA( PTOKMAPA, PCHAR );

#ifdef UNICODE
#define setargv setargvW
#define freeargv freeargvW
#define ParseCommandLine ParseCommandLineW
#define IsTokenPresent IsTokenPresentW
#define SetTokenPresent SetTokenPresentW
#define SetTokenNotPresent SetTokenNotPresentW
#define TOKMAP TOKMAPW
#define PTOKMAP PTOKMAPW
#else
#define setargv setargvA
#define freeargv freeargvA
#define ParseCommandLine ParseCommandLineA
#define IsTokenPresent IsTokenPresentA
#define SetTokenPresent SetTokenPresentA
#define SetTokenNotPresent SetTokenNotPresentA
#define TOKMAP TOKMAPA
#define PTOKMAP PTOKMAPA
#endif /* UNICODE */

/*-----------------------------------------------------------------------------
 --   flags for ParseCommandLine().
 ----------------------------------------------------------------------------*/
#define PCL_FLAG_CONTINUE_ON_ERROR     0x0001
#define PCL_FLAG_RET_ON_FIRST_SUCCESS  0x0002
#define PCL_FLAG_IGNORE_INVALID        0x0004
#define PCL_FLAG_NO_CLEAR_MEMORY       0x0008
#define PCL_FLAG_NO_VERSION_CHECK      0x0010
#define PCL_FLAG_VERSION_CHK_UPWARD    0x0020

/*-----------------------------------------------------------------------------
 --   flags for rc=ParseCommandLine(),	PARSE_FLAG_* (BIT FLAGS)
 ----------------------------------------------------------------------------*/
#define PARSE_FLAG_NO_ERROR	       0x0000
#define PARSE_FLAG_MISSING_REQ_FIELD   0x0001
#define PARSE_FLAG_INVALID_PARM        0x0002
#define PARSE_FLAG_DUPLICATE_FIELD     0x0004
#define PARSE_FLAG_NO_PARMS	       0x0008
#define PARSE_FLAG_TOO_MANY_PARMS      0x0010
#define PARSE_FLAG_NOT_ENOUGH_MEMORY   0x0020

/*-----------------------------------------------------------------------------
 --   prototypes for WinStation utility functions
 ----------------------------------------------------------------------------*/

VOID WINAPI RefreshAllCaches();

VOID WINAPI RefreshWinStationCaches();

VOID WINAPI RefreshWinStationObjectCache();

VOID WINAPI RefreshWinStationNameCache();

ULONG WINAPI GetCurrentLogonId( );

VOID WINAPI GetCurrentWinStationName( PWCHAR, int );

BOOLEAN WINAPI GetWinStationNameFromId( ULONG, PWCHAR, int );
BOOLEAN WINAPI xxxGetWinStationNameFromId( HANDLE, ULONG, PWCHAR, int);


BOOLEAN WINAPI GetWinStationUserName( HANDLE, ULONG, PWCHAR, int );

VOID WINAPI GetCurrentUserName( PWCHAR, int );

BOOLEAN WINAPI WinStationObjectMatch( HANDLE, VOID *, PWCHAR );

/*-----------------------------------------------------------------------------
 --   prototypes for process/user utility functions
 ----------------------------------------------------------------------------*/

VOID WINAPI RefreshProcessObjectCaches();

VOID WINAPI RefreshUserSidCrcCache();

BOOLEAN WINAPI ProcessObjectMatch( HANDLE, ULONG, int, PWCHAR, PWCHAR, PWCHAR, PWCHAR );

VOID WINAPI GetUserNameFromSid( VOID *, PWCHAR, PULONG );

/*-----------------------------------------------------------------------------
 --   prototypes for helper functions
 ----------------------------------------------------------------------------*/

USHORT WINAPI CalculateCrc16( PBYTE, USHORT );

INT WINAPI ExecProgram( PPROGRAMCALL, INT, WCHAR ** );

VOID WINAPI ProgramUsage( LPCWSTR, PPROGRAMCALL, BOOLEAN );

VOID WINAPI Message( int nResourceID, ... );

VOID WINAPI StringMessage( int nErrorResourceID, PWCHAR pString );

VOID WINAPI StringDwordMessage( int nErrorResourceID, PWCHAR pString, DWORD Num );

VOID WINAPI DwordStringMessage( int nErrorResourceID, DWORD Num, PWCHAR pString );

VOID WINAPI ErrorPrintf( int nErrorResourceID, ... );

VOID WINAPI StringErrorPrintf( int nErrorResourceID, PWCHAR pString );

VOID WINAPI StringDwordErrorPrintf( int nErrorResourceID, PWCHAR pString, DWORD Num );

VOID WINAPI TruncateString( PWCHAR pString, int MaxLength );

PPDPARAMS WINAPI EnumerateDevices(PDLLNAME pDllName, PULONG pEntries);

FILE * WINAPI wfopen( LPCWSTR filename, LPCWSTR mode );

PWCHAR WINAPI wfgets( PWCHAR Buffer, int Len, FILE *Stream);

int WINAPI PutStdErr(unsigned int MsgNum, unsigned int NumOfArgs, ...);

BOOL AreWeRunningTerminalServices(void);

WCHAR **MassageCommandLine(DWORD dwArgC);

int __cdecl
My_wprintf(
    const wchar_t *format,
    ...
    );

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   );

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\logoff\logoff.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  LOGOFF.C
*
*     This module is the LOGOFF utility code.
*
*
*************************************************************************/

#include <stdio.h>
#include <windows.h>
//#include <ntddkbd.h>
//#include <ntddmou.h>
#include <winstaw.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>

#include "logoff.h"
#include "printfoa.h"

WINSTATIONNAME WSName;
USHORT help_flag = FALSE;
USHORT v_flag    = FALSE;
HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];

TOKMAP ptm[] =
{
#define TERM_PARM 0
   {TOKEN_WS,           TMFLAG_OPTIONAL, TMFORM_STRING,
                            WINSTATIONNAME_LENGTH, WSName},

   {TOKEN_SERVER,       TMFLAG_OPTIONAL, TMFORM_STRING,
                            MAX_IDS_LEN, ServerName},

   {TOKEN_HELP,         TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                            sizeof(USHORT), &help_flag},

   {TOKEN_VERBOSE,      TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                            sizeof(USHORT), &v_flag},

   {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );
BOOL ProceedWithLogoff(HANDLE hServerName,ULONG LogonId,PWINSTATIONNAME pWSName);


/*************************************************************************
*
*  main
*     Main function and entry point of the LOGOFF
*     utility.
*
*  ENTRY:
*     argc  - count of the command line arguments.
*     argv  - vector of strings containing the command line arguments.
*
*  EXIT
*     Nothing.
*
*************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    BOOLEAN bCurrent = FALSE;
    int   rc, i;
    WCHAR *CmdLine;
    WCHAR **argvW, *endptr;
    ULONG LogonId;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, TOKEN_SERVER) ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     * Validate input string for WinStation or LogonId.
     */
    if ( !IsTokenPresent(ptm, TOKEN_WS) ) {

        /*
         * No string specified; use current WinStation / LogonId.
         */
        bCurrent = TRUE;
        LogonId = GetCurrentLogonId();

        if( ServerName[0] ) {
            ErrorPrintf(IDS_ERROR_NEED_A_SESSIONID);
            return(FAILURE);
        }

    } else if ( !iswdigit(*WSName) ) {

        /*
         * Treat the string as a WinStation name.
         */
        if ( !LogonIdFromWinStationName(hServerName, WSName, &LogonId) ) {
            StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, WSName);
            return(FAILURE);
        }

    } else {

        /*
         * Treat the string as a LogonId.
         */
        LogonId = wcstoul(WSName, &endptr, 10);

        if ( *endptr || LogonId == ( ULONG )-1 )
        {
            StringErrorPrintf(IDS_ERROR_INVALID_LOGONID, WSName);
            return(FAILURE);
        }
        if ( !WinStationNameFromLogonId(hServerName, LogonId, WSName) ) {
            ErrorPrintf(IDS_ERROR_LOGONID_NOT_FOUND, LogonId);
            return(FAILURE);
        }

        if( ( LogonId == GetCurrentLogonId() ) )
        {
            bCurrent = TRUE;
        }
    }

    /*
     * Perform the logoff.
     */
    if ( bCurrent ) {

        if ( !ExitWindowsEx(EWX_LOGOFF, (DWORD)-1) ) {

            ErrorPrintf(IDS_ERROR_LOGOFF_CURRENT,
                         GetLastError());
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }

    } else{

         if (!ProceedWithLogoff(hServerName,LogonId,WSName))
            return (SUCCESS);

         if ( v_flag )
           Message(IDS_WINSTATION_LOGOFF, LogonId);

         /*
          * RESOLVED: we need to expose the session manager's "logoff winstation"
          * API and call it here for the specified LogonId.  Till then, we'll
          * do a WinStationReset (nasty, but does the job).
          *
          * - Reset and logoff are synonymous
          */

         if ( !WinStationReset(hServerName, LogonId, TRUE) ) {

            ErrorPrintf(IDS_ERROR_LOGOFF, LogonId, GetLastError());
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
       }
   }

   return(SUCCESS);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      If LogonId does not have a corresponding UserName then a warning
 *      message is displayed.
 *
 *  ENTRY:
 *      hServerName : Handle to server
 *      LogonId     : ID as shown in qwinsta
 *      pWSName     : Session Name
 *
 *  EXIT:
 *       TRUE : User wants to logoff
 *       FALSE: User does not want to proceed with logoff
 *
 *
 ******************************************************************************/
BOOL ProceedWithLogoff(HANDLE hServerName,ULONG LogonId,PWINSTATIONNAME pWSName)
{
   #ifdef UNICODE
   #define GetStdInChar getwchar
   wint_t ch;
   #else
   #define GetStdInChar getchar
   int ch;
   #endif

   WINSTATIONINFORMATION WinInfo;
   ULONG ReturnLength;
   int rc;

   // No-session Name, No-Problem
   if(lstrlen(pWSName) == 0) return (TRUE);

   memset(&WinInfo,0,sizeof(WINSTATIONINFORMATION));
   rc = WinStationQueryInformation( hServerName,
                                    LogonId,
                                    WinStationInformation,
                                    (PVOID)&WinInfo,
                                    sizeof(WINSTATIONINFORMATION),
                                    &ReturnLength);

   // Try to show message only if necessary
   if( rc && (sizeof(WINSTATIONINFORMATION) == ReturnLength) ) {
      if(lstrlen(WinInfo.UserName) == 0) {
         ErrorPrintf(IDS_WARNING_LOGOFF);
         rc = GetStdInChar();
         if(rc == L'n') return(FALSE);
      }
   }
   // Failed on call - assume nothing and prompt with message
   else{
      ErrorPrintf(IDS_WARNING_LOGOFF_QUESTIONABLE);
      rc = GetStdInChar();
      if(rc == L'n') return(FALSE);
   }
   return (TRUE);
}

/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {

        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }
    ErrorPrintf(IDS_USAGE1);
    ErrorPrintf(IDS_USAGE2);
    ErrorPrintf(IDS_USAGE3);
    ErrorPrintf(IDS_USAGE4);
    ErrorPrintf(IDS_USAGE5);
    ErrorPrintf(IDS_USAGE6);
    ErrorPrintf(IDS_USAGE7);
}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\migrate\migrate.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  MIGRATE.C
*
*  Migrate Windows 3.1 ini files, groups and reg.dat to NT registry
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbasep.h>
#include <winuserp.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <winsta.h>
#include <utilsub.h>

#include "migrate.h"
#include "printfoa.h"

USHORT fIni     = FALSE;
USHORT fGroup   = FALSE;
USHORT fReg     = FALSE;
USHORT fHelp    = FALSE;
USHORT fDebug   = FALSE;
WCHAR  IniPath[_MAX_PATH+1];
WCHAR  FullPath[_MAX_PATH+1];
int FileCount;

TOKMAP ptm[] = {
      {L" ",        TMFLAG_OPTIONAL, TMFORM_STRING, _MAX_PATH, IniPath},
      {L"/ini",     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fIni},
      {L"/group",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fGroup},
      {L"/regdata", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fReg},
      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fHelp},
#if DBG
      {L"/debug",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fDebug},
#endif
      {0, 0, 0, 0, 0}
};


BOOL WINAPI Win31MigrationStatusCallback( PWSTR, PVOID );
BOOL InitSystemFontInfo( VOID );
void Usage( BOOLEAN );


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    WCHAR *CmdLine;
    WCHAR **argvW;
    int i, rc, Root;
    BOOL Result;

    /*
     * We can't use argv[] because its always ANSI, regardless of UNICODE
     */
    CmdLine = GetCommandLineW();
    /*
     * convert from oem char set to ansi
     */
    OEM2ANSIW(CmdLine, wcslen(CmdLine));

    /*
     * Massage the new command line to look like an argv[] type
     * because ParseCommandLine() depends on this format
     */
    argvW = (WCHAR **)malloc( sizeof(WCHAR *) * (argc+1) );
    if(argvW == NULL) {
        PutStdErr( ERROR_NOT_ENOUGH_MEMORY, 0 );
        return(FAILURE);
    }

    argvW[0] = wcstok(CmdLine, L" ");
    for(i=1; i < argc; i++){
        argvW[i] = wcstok(0, L" ");
    }
    argvW[argc] = NULL;

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, PCL_FLAG_NO_CLEAR_MEMORY);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( fHelp || rc ) {
        if ( fHelp || (rc & PARSE_FLAG_NO_PARMS) ) {
            Usage(FALSE);
            return(SUCCESS);
        } else {
            Usage(TRUE);
            return(FAILURE);
        }
    }

    /*
     * If path parameter was not specified, then default to current directory
     */
    if ( !(ptm[0].tmFlag & TMFLAG_PRESENT) )
        GetCurrentDirectoryW( sizeof(IniPath), IniPath );

    /*
     * Get full pathname and set INIDRIVE/INIPATH variables
     */
    GetFullPathNameW( IniPath, sizeof(FullPath), FullPath, NULL );
    Root = 2;
    if ( FullPath[0] == '\\' && FullPath[1] == '\\' ) {
        for ( i = 0; i < 2; Root++ )
            if ( FullPath[Root] == '\\' )
                i++;
        Root--;
    }
    FullPath[Root] = L'\0';
    SetEnvironmentVariableW( L"INIDRIVE", FullPath );
    FullPath[Root] = '\\';
    SetEnvironmentVariableW( L"INIPATH", &FullPath[Root] );

    if ( fIni ) {
//        printf( "Migrating .INI files from %S\n", FullPath );
        Message(IDS_MESSAGE_INI, FullPath);
        FileCount = 0;
        Result = SynchronizeWindows31FilesAndWindowsNTRegistry(
                    Win31LogonEvent,
                    WIN31_MIGRATE_INIFILES,
                    Win31MigrationStatusCallback,
                    NULL );
        if ( !Result && FileCount ) {
//            printf( "An error occured during .INI file migration\n" );
            ErrorPrintf(IDS_ERROR_INI);
        }
    }

    if ( fGroup ) {
     //   printf( "Migrating .GRP files from %S\n", FullPath );
        Message(IDS_MESSAGE_GRP, FullPath);
        FileCount = 0;
        Result = SynchronizeWindows31FilesAndWindowsNTRegistry(
                    Win31LogonEvent,
                    WIN31_MIGRATE_GROUPS,
                    Win31MigrationStatusCallback,
                    NULL );
        if ( !Result && FileCount ) {
            // printf( "An error occured during .GRP file migration\n" );
            ErrorPrintf(IDS_ERROR_GRP);
        }
    }

    if ( fReg ) {
     //   printf( "Migrating %S\\REG.DAT file\n", FullPath );
        Message(IDS_MESSAGE_REG, FullPath);
        FileCount = 0;
        Result = SynchronizeWindows31FilesAndWindowsNTRegistry(
                    Win31SystemStartEvent,
                    WIN31_MIGRATE_REGDAT,
                    Win31MigrationStatusCallback,
                    NULL );
        if ( !Result && FileCount ) {
      //      printf( "An error occured during REG.DAT file migration\n" );
              ErrorPrintf(IDS_ERROR_REG);
        }
#if 0
        InitSystemFontInfo();
#endif
    }

    return(SUCCESS);

}  /* main() */


BOOL WINAPI
Win31MigrationStatusCallback(
    IN PWSTR Status,
    IN PVOID CallbackParameter
    )
{
    FileCount++;
    // printf( "   Processing %S\n", Status );
    Message(IDS_MESSAGE_PROCESS, Status);
    return( TRUE );
}


BOOL
InitSystemFontInfo( VOID )
{
    TCHAR *FontNames, *FontName;
    TCHAR FontPath[ MAX_PATH ];
    ULONG cb = 63 * 1024;


    FontNames = malloc( cb );
    if (FontNames == NULL) {
        return FALSE;
    }

    if (GetProfileString( TEXT("Fonts"), NULL, TEXT(""), FontNames, cb )) {
        FontName = FontNames;
        while (*FontName) {
            if (GetProfileString( TEXT("Fonts"), FontName, TEXT(""), FontPath, sizeof( FontPath ) )) {
                switch (AddFontResource( FontPath )) {
                case 0:
                    KdPrint(("WINLOGON: Unable to add new font path: %ws\n", FontPath ));
                    break;

                case 1:
                    KdPrint(("WINLOGON: Found new font path: %ws\n", FontPath ));
                    break;

                default:
                    KdPrint(("WINLOGON: Found existing font path: %ws\n", FontPath ));
                    RemoveFontResource( FontPath );
                    break;
                }
            }
            while (*FontName++) ;
        }
    } else {
        KdPrint(("WINLOGON: Unable to read font info from win.ini - %u\n", GetLastError()));
    }

    free( FontNames );
    return TRUE;
}



/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {

        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }
        ErrorPrintf(IDS_USAGE1);
        ErrorPrintf(IDS_USAGE2);
        ErrorPrintf(IDS_USAGE3);
        ErrorPrintf(IDS_USAGE4);
        ErrorPrintf(IDS_USAGE5);
        ErrorPrintf(IDS_USAGE6);
        ErrorPrintf(IDS_USAGE7);
        ErrorPrintf(IDS_USAGE8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\migrate\migrate.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*  MIGRATE.H
*     This module contains typedefs and defines required for
*     the MIGRATE utility.
*
*************************************************************************/


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_INI                                   102
#define IDS_ERROR_GRP                                   103
#define IDS_ERROR_REG                                   104
#define IDS_USAGE1                                      105
#define IDS_USAGE2                                      106
#define IDS_USAGE3                                      107
#define IDS_USAGE4                                      108
#define IDS_USAGE5                                      109
#define IDS_USAGE6                                      110
#define IDS_USAGE7                                      111
#define IDS_USAGE8                                      112
#define IDS_MESSAGE_INI                                 120
#define IDS_MESSAGE_GRP                                 121
#define IDS_MESSAGE_REG                                 122
#define IDS_MESSAGE_PROCESS                             123
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\logoff\logoff.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  LOGOFF.H
*     This module contains typedefs and defines for the LOGOFF
*     WinStation utility.
*
*************************************************************************/

/*
 * Token string definitions.
 */
#define TOKEN_WS                        L""
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_HELP                      L"/?"
#define TOKEN_SERVER                    L"/server"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_NOT_FOUND                  102
#define IDS_ERROR_INVALID_LOGONID                       103
#define IDS_ERROR_LOGONID_NOT_FOUND                     104
#define IDS_ERROR_LOGOFF                                105
#define IDS_ERROR_LOGOFF_CURRENT                        106
//#define IDS_ERROR_CANT_GET_CURRENT_WINSTATION           107
#define IDS_ERROR_NEED_A_SESSIONID                      107
#define IDS_ERROR_SERVER                                108

#define IDS_WINSTATION_LOGOFF                           200
#define IDS_WARNING_LOGOFF                              201
#define IDS_WARNING_LOGOFF_QUESTIONABLE                 202
#define IDS_USAGE1                                      203
#define IDS_USAGE2                                      204
#define IDS_USAGE3                                      205
#define IDS_USAGE4                                      206
#define IDS_USAGE5                                      207
#define IDS_USAGE6                                      208
#define IDS_USAGE7                                      209
#define IDS_ERROR_NOT_TS                                210
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\ndspsvr\ndspsvr.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*   NDSPSVR.C
*
*   This module contains code for the NDSPSVR utility.
*   This utility adds or removes the NDS Preferred Server registry key.
*
*   Copyright Citrix Systems Inc. 1996-1997
*
*   $Log: $
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsta.h>
#include <regapi.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>

#undef SAP_SOCKET
#include <ncp.h>

#include "ndspsvr.h"
#include <printfoa.h>

/*
 * Global Data
 */
USHORT   help_flag = FALSE;             // User wants help
USHORT   fQuery    = FALSE;             // query
USHORT   fDisable  = FALSE;             // disable
WCHAR    Server[MAX_SERVER_NAME_LENGTH];

TOKMAP ptm[] = {
      {L"/q",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fQuery},
      {L"/query",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fQuery},
      {L"/enable",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_SERVER_NAME_LENGTH, Server},
      {L"/disable", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fDisable},
      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
VOID  Usage(BOOLEAN bError);
BOOL  DeleteKey(VOID);
BOOL  AddKey(VOID);
BOOL  QueryKey(VOID);


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    WCHAR *CmdLine;
    WCHAR **argvW;
    BOOL  rc;
    INT   i;

    /*
     * We can't use argv[] because its always ANSI, regardless of UNICODE
     */
    CmdLine = GetCommandLineW();

    /*
     * Massage the new command line to look like an argv[] type
     * because ParseCommandLine() depends on this format
     */
    argvW = (WCHAR **)malloc( sizeof(WCHAR *) * (argc+1) );
    if(argvW == NULL) {
         ErrorPrintf(IDS_ERROR_MALLOC);
         return(FAILURE);
    }

    argvW[0] = wcstok(CmdLine, L" ");
    for(i=1; i < argc; i++){
             argvW[i] = wcstok(0, L" ");
                 OEM2ANSIW(argvW[i], wcslen(argvW[i]));
    }
    argvW[argc] = NULL;

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

             if ( !help_flag && !(rc & PARSE_FLAG_NO_PARMS) ) {

                Usage(TRUE);
                return(FAILURE);

             } else {

                Usage(FALSE);
                return(SUCCESS);
             }
    }

    /*
     *  Enable or disable
     */
    if ( fDisable ) {
        rc = DeleteKey();
    }
    else if ( Server[0] ) {
        rc = AddKey();
    }
    else if ( fQuery ) {
        if ( rc = QueryKey() ) {
            if (Server[0])
               ErrorPrintf(IDS_NDSPSVR_ENABLED, Server);
            else
               ErrorPrintf(IDS_NDSPSVR_DISABLED);
        }
    }

    /*
     *  Query or error ?
     */
    if ( !rc ) {
        ErrorPrintf(IDS_ACCESS_DENIED);
    }

    return(SUCCESS);
}


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }
    ErrorPrintf(IDS_HELP_USAGE1);
    ErrorPrintf(IDS_HELP_USAGE2);
    ErrorPrintf(IDS_HELP_USAGE3);
    ErrorPrintf(IDS_HELP_USAGE4);
    ErrorPrintf(IDS_HELP_USAGE5);

}  /* Usage() */


/*******************************************************************************
 *
 *  QueryKey
 *
 *  ENTRY:
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

BOOL
QueryKey()
{
    DWORD  dwType = REG_SZ;
    DWORD  dwSize = MAX_SERVER_NAME_LENGTH * sizeof(WCHAR);
    WCHAR  szValue[MAX_SERVER_NAME_LENGTH];
    HKEY   Handle;
    LONG   rc;

    /*
     *  Open registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REG_CONTROL_TSERVER,
                       0,
                       KEY_READ,
                       &Handle ) != ERROR_SUCCESS )
        return FALSE;

    /*
     *  Read registry value
     */
    rc = RegQueryValueExW( Handle,
                           REG_CITRIX_NWNDSPREFERREDSERVER,
                           NULL,
                           &dwType,
                           (PUCHAR)&szValue,
                           &dwSize );

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    if ( rc == ERROR_SUCCESS ) {
         wcscpy (Server, szValue);
         return TRUE;
    }
    else if ( rc == ERROR_FILE_NOT_FOUND )
         return TRUE;
    else
         return FALSE;
}


/*******************************************************************************
 *
 *  DeleteKey
 *
 *  ENTRY:
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

BOOL
DeleteKey()
{
    DWORD  dwType = REG_SZ;
    DWORD  dwSize = MAX_SERVER_NAME_LENGTH;
    WCHAR  szValue[MAX_SERVER_NAME_LENGTH];
    HKEY   Handle;
    LONG   rc;

    /*
     *  Open registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REG_CONTROL_TSERVER,
                       0,
                       KEY_ALL_ACCESS,
                       &Handle ) != ERROR_SUCCESS )
        return FALSE;

    /*
     *  Delete Preferred Server key
     */
    rc = RegDeleteValueW( Handle,
                          REG_CITRIX_NWNDSPREFERREDSERVER );

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    if ( rc != ERROR_SUCCESS )
        return FALSE;
    else
        return TRUE;
}


/*******************************************************************************
 *
 *  AddKey
 *
 *  ENTRY:
 *
 * EXIT:
 *
 *
 ******************************************************************************/

BOOL
AddKey()
{
    HKEY   Handle;
    LONG   rc;
    DWORD  dwDummy;
    DWORD  dwSize;

    /*
     *  Open registry
     */
    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                         REG_CONTROL_TSERVER,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &Handle,
                         &dwDummy ) != ERROR_SUCCESS )
        return FALSE;

    /*
     *  Write registry value
     */
    dwSize = ( (wcslen(Server)+1) * sizeof(WCHAR) );
    rc = RegSetValueExW( Handle,
                         REG_CITRIX_NWNDSPREFERREDSERVER,
                         0,
                         REG_SZ,
                         (PUCHAR)Server,
                         dwSize );

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    return( rc == ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\msg\msg.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  MSG.C
*     Send a message to another user.
*
*  Syntax:
*
*    MSG [username]       [/TIME:seconds] [/V] [/W] [/?] [message]\n" \
*    MSG [WinStationName] [/TIME:seconds] [/V] [/W] [/?] [message]\n" \
*    MSG [logonid]        [/TIME:seconds] [/V] [/W] [/?] [message]\n" \
*    MSG [@filename]      [/TIME:seconds] [/V] [/W] [/?] [message]\n" \
*
*    /TIME:seconds - time delay to wait for receiver to acknowledge msg\n" \
*    /V            - display information about actions being performed\n" \
*    /W            - wait for response from user, useful with /V
*    /?            - display syntax and options\n"
*
*  Parameters:
*
*      username
*         Identifies all logins belonging to the specific username
*
*      winstationname
*         Identifies all logins connected to the winstation name regardless
*         of loginname.
*
*      logonid
*         Decimal number specifying a logon id to send the message to
*
*      @filename
*         Identifies a file that contains usernames or winstation names to
*         send messages to.
*
*   Options:
*
*      /SELF  >>>> UNPUBLISHED <<<<
*         Send message to caller of msg.  Used to send a message to
*         users when maintenace mode is enabled.
*
*      /TIME:seconds (time delay)
*         The amount of time to wait for an acknowledgement from the target
*         login that the message has been received.
*
*      /V (verbose)
*         Display information about the actions being performed.
*
*      /? (help)
*         Display the syntax for the utility and information about the
*         options.
*
*      message
*         The text of the message to send.  If the text is not specified
*         then the text is read from STDIN.
*
*   Remarks:
*
*     The message can be typed on the command line or be read from STDIN.
*     The message is sent via a popup.  The user receiving the popup can
*     hit a key to get rid of it or it will go away after a default timeout.
*
*     If the target of the message is a terminal, then the message is
*     sent to all logins on the target terminal.
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>
#include <windows.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <wchar.h>
#include <io.h>  // for isatty
#include <locale.h>

#include "msg.h"
#include "printfoa.h"

/*=============================================================================
==   Global Data
=============================================================================*/

ULONG      Seconds;
USHORT     file_flag=FALSE;   //wkp
USHORT     v_flag;
USHORT     self_flag;
USHORT     help_flag;
WCHAR      ids_input[MAX_IDS_LEN];
PWCHAR     MsgText, MsgTitle;
WCHAR      MsgLine[MAX_IDS_LEN];
ULONG      gCurrentLogonId = (ULONG)(-1);
BOOLEAN    wait_flag = FALSE;
HANDLE     hServerName = SERVERNAME_CURRENT;
WCHAR      ServerName[MAX_IDS_LEN+1];

/*
 * The token map structure is used for parsing program arguments
 */
TOKMAP ptm[] = {
   { TOKEN_INPUT,       TMFLAG_REQUIRED, TMFORM_STRING,   MAX_IDS_LEN,
                            ids_input },

   { TOKEN_SERVER,      TMFLAG_OPTIONAL, TMFORM_STRING,   MAX_IDS_LEN,
                            ServerName},

   { TOKEN_MESSAGE,     TMFLAG_OPTIONAL, TMFORM_X_STRING, MAX_IDS_LEN,
                            MsgLine },

   { TOKEN_TIME,        TMFLAG_OPTIONAL, TMFORM_ULONG,    sizeof(ULONG),
                            &Seconds },

   { TOKEN_VERBOSE,     TMFLAG_OPTIONAL, TMFORM_BOOLEAN,  sizeof(USHORT),
                            &v_flag },

   { TOKEN_WAIT,        TMFLAG_OPTIONAL, TMFORM_BOOLEAN,  sizeof(BOOLEAN),
                            &wait_flag },

   { TOKEN_SELF,        TMFLAG_OPTIONAL, TMFORM_BOOLEAN,  sizeof(USHORT),
                            &self_flag },

   { TOKEN_HELP,        TMFLAG_OPTIONAL, TMFORM_BOOLEAN,  sizeof(USHORT),
                            &help_flag },

   { 0, 0, 0, 0, 0}
};

/*
 * This is the list of names we are to send the message to
 */
int NameListCount = 0;
WCHAR **NameList = NULL;
WCHAR CurrUserName[USERNAME_LENGTH];

/*
 * Local function prototypes
 */
BOOLEAN SendMessageIfTarget( PLOGONID Id, ULONG Count,
                             LPWSTR pTitle, LPWSTR pMessage );
BOOLEAN CheckMatchList( PLOGONID );
BOOLEAN MessageSend( PLOGONID pLId, LPWSTR pTitle, LPWSTR pMessage );
BOOLEAN LoadFileToNameList( PWCHAR pName );
BOOL ReadFileByLine( HANDLE, PCHAR, DWORD, PDWORD );
void Usage( BOOLEAN bError );


/*****************************************************************************
*
*   MAIN
*
*   ENTRY:
*      argc - count of the command line arguments.
*      argv - vector of strings containing the command line arguments.
*
****************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    // struct tm * pTimeDate;
    // time_t      curtime;
    SYSTEMTIME st;
    WCHAR       TimeStamp[ MAX_TIME_DATE_LEN ];
    WCHAR      *CmdLine;
    WCHAR      **argvW;
    WCHAR       szTitleFormat[50];
    DWORD       dwSize;
    PLOGONID pTerm;
    UINT       TermCount;
    ULONG      Status;
    int        i, rc, TitleLen;
    BOOLEAN MatchedOne = FALSE;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if (rc && (rc & PARSE_FLAG_NO_PARMS) )
       help_flag = TRUE;

    if ( help_flag || rc ) {
         if (!help_flag) {
            Usage(TRUE);
            return(FAILURE);

        } else {
            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, TOKEN_SERVER) ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     * if no timeout was specified, use default
     */
    if ( !IsTokenPresent(ptm, TOKEN_TIME) )
        Seconds = RESPONSE_TIMEOUT;

    /*
     * allocate a buffer for the message header
     */
    if ( (MsgText = (PWCHAR)malloc(MAX_IDS_LEN * sizeof(WCHAR))) == NULL ) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }
    MsgText[0] = 0;

    /*
     * set up message header text: sender and timestamp
     */
    GetCurrentUserName(CurrUserName, USERNAME_LENGTH);

    /*
     * Get the current Winstation Id for this process
     */
    gCurrentLogonId = GetCurrentLogonId();

    /*
     * Form message title string.
     */
    dwSize = sizeof(szTitleFormat) / sizeof(WCHAR);

    LoadString(NULL,IDS_TITLE_FORMAT,szTitleFormat,dwSize);
    
    TitleLen = (wcslen(szTitleFormat) + wcslen(CurrUserName) + 1) * sizeof(WCHAR) + ( 2 * sizeof( TimeStamp ) );

    MsgTitle = (PWCHAR)malloc(TitleLen);

    if( MsgTitle == NULL )
    {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }


    _snwprintf(MsgTitle, TitleLen, szTitleFormat, CurrUserName);

    TimeStamp[0] = 0;

    GetLocalTime( &st );

    GetDateFormat( LOCALE_USER_DEFAULT , 
                   DATE_SHORTDATE ,
                   &st ,
                   NULL ,
                   TimeStamp,
                   MAX_TIME_DATE_LEN );


    wcscat(MsgTitle , TimeStamp);

    TimeStamp[0] = 0;

    GetTimeFormat( LOCALE_USER_DEFAULT , 
                   TIME_NOSECONDS ,
                   &st ,
                   NULL ,
                   TimeStamp,
                   MAX_TIME_DATE_LEN );

    wcscat(MsgTitle , L" " );
    wcscat(MsgTitle , TimeStamp);
    
    /*
     * if message was specified on the command line, add it to MsgText string
     */
    if ( IsTokenPresent(ptm, TOKEN_MESSAGE) ) {

        MsgText = realloc(MsgText, (wcslen(MsgText) + wcslen(MsgLine) + 1) * sizeof(WCHAR));
        if ( MsgText == NULL ) {
            ErrorPrintf(IDS_ERROR_MALLOC);
            return(FAILURE);
        }
        wcscat(MsgText, MsgLine);

    } else {

        /*
         * Message was not on the command line.  If STDIN is connected to
         * the keyboard, then prompt the user for the message to send,
         * otherwise just read STDIN.
         */

        if ( _isatty( _fileno(stdin) ) )
            Message(IDS_MESSAGE_PROMPT);


        while ( wfgets(MsgLine, MAX_IDS_LEN, stdin) != NULL ) {
            MsgText = (PWCHAR)realloc(
                            MsgText,
                            (wcslen(MsgText) + wcslen(MsgLine) + 1) * sizeof(WCHAR) );

            if ( MsgText == NULL ) {
                ErrorPrintf(IDS_ERROR_MALLOC);
                return(FAILURE);
            }
            wcscat(MsgText, MsgLine);
        }

        /*
         * When we fall through, we either have an eof or a problem with
         * STDIN
         */
        if ( feof(stdin) ) {

            /*
             * If we get here then we hit eof on STDIN.  First check to make
             * sure that we did not get an eof on first wfgets
             */
            if ( !wcslen(MsgText) ) {
                ErrorPrintf(IDS_ERROR_EMPTY_MESSAGE);
                return(FAILURE);
            }

        } else {

            /*
             * The return from wfgets was not eof so we have an STDIN
             * problem
             */
            ErrorPrintf(IDS_ERROR_STDIN_PROCESSING);
            return(FAILURE);
        }
    }

    /*
     * Is the ids_input really a file indirection?
     */
    if ( ids_input[0] == L'@' ) {

        /*
         * Open the input file and read the names into the NameList
         */
        if ( !LoadFileToNameList(&ids_input[1]) )
            return(FAILURE);

        /*
         * Ok, let's get in touch
         */
        file_flag = TRUE;

    } else {

        _wcslwr( ids_input );
        NameList = (WCHAR **)malloc( 2 * sizeof( WCHAR * ) );
        if ( NameList == NULL ) {
            ErrorPrintf(IDS_ERROR_MALLOC);
            return(FAILURE);
        }
        NameList[0] = ids_input;
        NameList[1] = NULL;
        NameListCount = 1;
    }

    /*
     * Enumerate across all the WinStations and send the message
     * to them if there are any matches in the NameList
     */
    if ( WinStationEnumerate(hServerName, &pTerm, &TermCount) ) {

        if ( SendMessageIfTarget(pTerm, TermCount, MsgTitle, MsgText) )
            MatchedOne = TRUE;

        WinStationFreeMemory(pTerm);

    } else{

        Status = GetLastError();
        ErrorPrintf(IDS_ERROR_WINSTATION_ENUMERATE, Status);
        return(FAILURE);
    }

    /*
     *  Check for at least one match
     */
    if ( !MatchedOne ) {

        if( file_flag )
            StringErrorPrintf(IDS_ERROR_NO_FILE_MATCHING, &ids_input[1]);
        else
            StringErrorPrintf(IDS_ERROR_NO_MATCHING, ids_input);

        return(FAILURE);

    }

    return(SUCCESS);

}  /* main() */


/******************************************************************************
 *
 *  SendMessageIfTarget - Send a Message to a group of WinStations if
 *                        their the target as specified by TargetName.
 *
 *  ENTRY
 *      LId (input)
 *          Pointer to an array of LOGONIDs returned from WinStationEnumerate()
 *      Count (input)
 *          Number of elements in LOGONID array.
 *      pTitle (input)
 *          Points to message title string.
 *      pMessage (input)
 *          Points to message string.
 *
 *  EXIT
 *      TRUE if message was sent to at least one WinStation; FALSE otherwise.
 *
 *****************************************************************************/

BOOLEAN
SendMessageIfTarget( PLOGONID Id,
                     ULONG Count,
                     LPWSTR pTitle,
                     LPWSTR pMessage )
{
    ULONG i;
    BOOLEAN MatchedOne = FALSE;

    for ( i=0; i < Count ; i++ ) {
        /*
         * Look at Id->WinStationName, get its User, etc. and compare
         * against targetname(s). Accept '*' as "everything".
         */
        if( CheckMatchList( Id ) )
        {
            MatchedOne = TRUE;

            MessageSend(Id, pTitle, pMessage);
                
        }
        Id++;
    }
    return( MatchedOne );

}  /* SendMessageIfTarget() */


/******************************************************************************
 *
 *  CheckMatchList - Returns TRUE if the current WinStation is a match for
 *                   sending a message due to either its name, id, or the
 *                   name of its logged on user being in the message target(s)
 *                   list.
 *
 *  ENTRY
 *      LId (input)
 *          Pointer to a LOGONID returned from WinStationEnumerate()
 *
 *  EXIT
 *      TRUE if this is a match, FALSE otherwise.
 *
 *****************************************************************************/

BOOLEAN
CheckMatchList( PLOGONID LId )
{
    int i;

    /*
     * Wild card matches everything
     */
    if ( ids_input[0] == L'*' ) {
        return(TRUE);
    }

    /*
     * Loop through name list to see if any given name applies to
     * this WinStation
     */
    for( i=0; i<NameListCount; i++ ) {
        if (WinStationObjectMatch( hServerName , LId, NameList[i]) ) {
            return(TRUE);
        }
    }

    return(FALSE);
}


/******************************************************************************
 *
 *  MessageSend - Send a message to the target WinStation
 *
 *  ENTRY
 *      LId (input)
 *          Pointer to a LOGONID returned from WinStationEnumerate()
 *      pTitle (input)
 *          Points to message title string.
 *      pMessage (input)
 *          Points to message string.
 *
 *  EXIT
 *      TRUE message is sent, FALSE otherwise.
 *
 *****************************************************************************/

BOOLEAN
MessageSend( PLOGONID LId,
             LPWSTR pTitle,
             LPWSTR pMessage )
{
    ULONG idResponse, ReturnLength;
    WINSTATIONINFORMATION WSInfo;

    /*
     * Make sure that the WinStation is in the 'connected' state
     */
    if ( !WinStationQueryInformation( hServerName,
                                      LId->LogonId,
                                      WinStationInformation,
                                      &WSInfo,
                                      sizeof(WSInfo),
                                      &ReturnLength ) ) {
        goto BadQuery;
    }

    if ( WSInfo.ConnectState != State_Connected &&
         WSInfo.ConnectState != State_Active ) {
        goto NotConnected;
    }

    /*
     * Send message.
     */
    if ( v_flag ) {
        if( LId->WinStationName[0] )
            StringDwordMessage(IDS_MESSAGE_WS, LId->WinStationName, Seconds);
        else
            Message(IDS_MESSAGE_ID, LId->LogonId, Seconds);

    }

    if ( !WinStationSendMessage( hServerName,
                                 LId->LogonId,
                                     pTitle,
                                 (wcslen(pTitle))*sizeof(WCHAR),
                                 pMessage,
                                 (wcslen(pMessage))*sizeof(WCHAR),
                                                 MB_OK,  // MessageBox() Style
                                                 Seconds,
                                                 &idResponse,
                                                 (BOOLEAN)(!wait_flag) ) ) {

        if( LId->WinStationName[0] )
            StringDwordErrorPrintf(IDS_ERROR_MESSAGE_WS, LId->WinStationName, GetLastError() );
        else
            ErrorPrintf(IDS_ERROR_MESSAGE_ID, LId->LogonId, GetLastError() );

        PutStdErr(GetLastError(), 0);
        goto BadMessage;
    }

    /*
     * Output response result if verbose mode.
     */
    if( v_flag ) {
        switch( idResponse ) {

            case IDTIMEOUT:
                if( LId->WinStationName[0] )
                    StringMessage(IDS_MESSAGE_RESPONSE_TIMEOUT_WS,
                            LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_TIMEOUT_ID, LId->LogonId);

                break;

            case IDASYNC:
                if( LId->WinStationName[0] )
                    StringMessage(IDS_MESSAGE_RESPONSE_ASYNC_WS,
                            LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_ASYNC_ID, LId->LogonId);
                break;

            case IDCOUNTEXCEEDED:
                if( LId->WinStationName[0] )
                    StringMessage(IDS_MESSAGE_RESPONSE_COUNT_EXCEEDED_WS,
                            LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_COUNT_EXCEEDED_ID,
                            LId->LogonId);
                break;

            case IDDESKTOPERROR:
                if( LId->WinStationName[0] )
                    StringMessage(IDS_MESSAGE_RESPONSE_DESKTOP_ERROR_WS,
                            LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_DESKTOP_ERROR_ID,
                            LId->LogonId);
                break;

            case IDERROR:
                if( LId->WinStationName[0] )
                    StringMessage(IDS_MESSAGE_RESPONSE_ERROR_WS,
                            LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_ERROR_ID,
                            LId->LogonId);
                break;

            case IDOK:
            case IDCANCEL:
                if( LId->WinStationName[0] )
                    StringMessage(IDS_MESSAGE_RESPONSE_WS,
                            LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_ID,
                            LId->LogonId);
                break;

            default:
                if( LId->WinStationName[0] )
                    DwordStringMessage(IDS_MESSAGE_RESPONSE_WS,
                            idResponse, LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_ID,
                            idResponse, LId->LogonId);
                break;
        }
    }
    return(TRUE);

/*-------------------------------------
 * Error cleanup and return
 */
BadMessage:
NotConnected:
BadQuery:
    return(FALSE);

}  /* MessageSend() */


/******************************************************************************
 *
 *  LoadFileToNameList
 *
 *  Load names from a file into the input name list.
 *
 *  ENTRY:
 *    pName Name of the file to load from
 *
 *  EXIT:
 *      TRUE for sucessful name load from file; FALSE if error.
 *
 *      An appropriate error message will have been displayed on error.
 *
 *****************************************************************************/

BOOLEAN
LoadFileToNameList( PWCHAR pName )
{
    HANDLE  hFile;
    INT     CurrentSize;

    /*
     * Open input file.
     */

    hFile = CreateFile(
                pName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    if (hFile == INVALID_HANDLE_VALUE) {
        StringErrorPrintf(IDS_ERROR_CANT_OPEN_INPUT_FILE, pName);
        PutStdErr(GetLastError(), 0);
        return(FALSE);
    }

    /*
     * Allocate a large array for the name string pointers
     */

    CurrentSize = 100;
    if ( !(NameList = (WCHAR **)malloc(CurrentSize * sizeof(WCHAR *))) ) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    NameListCount = 0;
    while( 1 ) {
        BOOL    fRet;
        CHAR    *pBuffer;
        DWORD   nBytesRead;
        WCHAR   *pwBuffer;

        /*
         * See if we need to grow the list
         */

        if( NameListCount == CurrentSize ) {

            if (!(NameList = (WCHAR **)realloc(NameList, CurrentSize+100))) {
                ErrorPrintf(IDS_ERROR_MALLOC);
                return(FAILURE);
            }
            CurrentSize += 100;
        }

        pBuffer = (CHAR *)LocalAlloc(LPTR, USERNAME_LENGTH * sizeof(CHAR));
        if (pBuffer == NULL) {
            ErrorPrintf(IDS_ERROR_MALLOC);
            return(FAILURE);
        }

        fRet = ReadFileByLine(
                    hFile,
                    pBuffer,
                    USERNAME_LENGTH,
                    &nBytesRead
                    );
        if (fRet && (nBytesRead > 0)) {
            INT cWChar;

            cWChar = MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        pBuffer,
                        -1,
                        NULL,
                        0
                        );

            pwBuffer = (WCHAR *)LocalAlloc(LPTR, (cWChar + 1) * sizeof(WCHAR));
            if (pwBuffer != NULL) {
                MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    pBuffer,
                    -1,
                    pwBuffer,
                    cWChar
                    );
            } else {
                ErrorPrintf(IDS_ERROR_MALLOC);
                return(FAILURE);
            }

            if (pwBuffer[wcslen(pwBuffer)-1] == L'\n') {
                pwBuffer[wcslen(pwBuffer)-1] = (WCHAR)NULL;
            }

            _wcslwr(pwBuffer);
            NameList[NameListCount++] = pwBuffer;
        } else {
            NameList[NameListCount] = NULL;
            CloseHandle(hFile);
            return(TRUE);
        }
    }

}  /* LoadFileToNameList() */

BOOL
ReadFileByLine(
    HANDLE  hFile,
    PCHAR   pBuffer,
    DWORD   cbBuffer,
    PDWORD  pcbBytesRead
    )
{
    BOOL    fRet;

    fRet = ReadFile(
                hFile,
                pBuffer,
                cbBuffer - 1,
                pcbBytesRead,
                NULL
                );
    if (fRet && (*pcbBytesRead > 0)) {
        CHAR*   pNewLine;

        pNewLine = strstr(pBuffer, "\r\n");
        if (pNewLine != NULL) {
            LONG    lOffset;

            lOffset = (LONG)(pNewLine + 2 - pBuffer) - (*pcbBytesRead);
            if (SetFilePointer(hFile, lOffset, NULL, FILE_CURRENT) ==
                0xFFFFFFFF) {
                return(FALSE);
            }

            *pNewLine = (CHAR)NULL;
        }

    }

    return(fRet);
}


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE1);
        ErrorPrintf(IDS_USAGE2);
        ErrorPrintf(IDS_USAGE3);
        ErrorPrintf(IDS_USAGE4);
        ErrorPrintf(IDS_USAGE5);
        ErrorPrintf(IDS_USAGE6);
        ErrorPrintf(IDS_USAGE7);
        ErrorPrintf(IDS_USAGE8);
        ErrorPrintf(IDS_USAGE9);
        ErrorPrintf(IDS_USAGEA);
        ErrorPrintf(IDS_USAGEB);
        ErrorPrintf(IDS_USAGEC);
        ErrorPrintf(IDS_USAGED);
        ErrorPrintf(IDS_USAGEE);
        ErrorPrintf(IDS_USAGEF);
    }
    else
    {
        Message(IDS_USAGE1);
        Message(IDS_USAGE2);
        Message(IDS_USAGE3);
        Message(IDS_USAGE4);
        Message(IDS_USAGE5);
        Message(IDS_USAGE6);
        Message(IDS_USAGE7);
        Message(IDS_USAGE8);
        Message(IDS_USAGE9);
        Message(IDS_USAGEA);
        Message(IDS_USAGEB);
        Message(IDS_USAGEC);
        Message(IDS_USAGED);
        Message(IDS_USAGEE);
        Message(IDS_USAGEF);
    }
}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\ndspsvr\ndspsvr.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/***********************************************************************
*
*   ndspsvr.h
*
*   This module contains typedefs and defines required for
*   the NDSPSVR utility.
*
*   Copyright Citrix Systems Inc. 1996-1997
*
*   Author: Kurt Perry (kurtp) 05.Mar.1996
*
*   $Log: $
*  
*     Rev 1.0   19 Jun 1996 11:00:26   KenB
*  Initial revision.
*  
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_HELP_USAGE1                                 102
#define IDS_HELP_USAGE2                                 103
#define IDS_HELP_USAGE3                                 104
#define IDS_HELP_USAGE4                                 105
#define IDS_HELP_USAGE5                                 106
#define IDS_NDSPSVR_DISABLED                            107
#define IDS_NDSPSVR_ENABLED                             108
#define IDS_ACCESS_DENIED                               109


/*
 *  Registry defines
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\msg\msg.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/***********************************************************************
*
*  MSG.H
*     This module contains typedefs and defines required for
*     the MSG utility.
*
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256   // maximum length that the input parm can be
#define MAX_COMMAND_LEN 256
#define MSG_MAX_THREADS 40
#define RESPONSE_TIMEOUT 60
#define MAX_TIME_DATE_LEN 80     //  xx/xx/xxxx 12:34pm'\0'
                                 //  12345678901234567890

/*
 * Command line token definitions.
 */
#define TOKEN_INPUT                     L""
#define TOKEN_MESSAGE                   L" "
#define TOKEN_TIME                      L"/time"
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_WAIT                      L"/w"
#define TOKEN_SELF                      L"/self"
#define TOKEN_HELP                      L"/?"
#define TOKEN_SERVER                    L"/server"


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_EMPTY_MESSAGE                         102
#define IDS_ERROR_STDIN_PROCESSING                      103
#define IDS_ERROR_WINSTATION_ENUMERATE                  104
#define IDS_ERROR_NO_FILE_MATCHING                      105
#define IDS_ERROR_NO_MATCHING                           106
#define IDS_ERROR_QUERY_WS                              107
#define IDS_ERROR_QUERY_ID                              108
#define IDS_ERROR_MESSAGE_WS                            109
#define IDS_ERROR_MESSAGE_ID                            110
#define IDS_ERROR_SERVER                                111


#define IDS_MESSAGE_PROMPT                              200
#define IDS_MESSAGE_WS                                  201
#define IDS_MESSAGE_ID                                  202
#define IDS_MESSAGE_RESPONSE_TIMEOUT_WS                 203
#define IDS_MESSAGE_RESPONSE_TIMEOUT_ID                 204
#define IDS_MESSAGE_RESPONSE_ASYNC_WS                   205
#define IDS_MESSAGE_RESPONSE_ASYNC_ID                   206
#define IDS_MESSAGE_RESPONSE_COUNT_EXCEEDED_WS          207
#define IDS_MESSAGE_RESPONSE_COUNT_EXCEEDED_ID          208
#define IDS_MESSAGE_RESPONSE_DESKTOP_ERROR_WS           209
#define IDS_MESSAGE_RESPONSE_DESKTOP_ERROR_ID           210
#define IDS_MESSAGE_RESPONSE_ERROR_WS                   211
#define IDS_MESSAGE_RESPONSE_ERROR_ID                   212
#define IDS_MESSAGE_RESPONSE_WS                         213
#define IDS_MESSAGE_RESPONSE_ID                         214

#define IDS_MESSAGE_RESPONSE_UNKNOWN_WS                 216
#define IDS_MESSAGE_RESPONSE_UNKNOWN_ID                 217
#define IDS_ERROR_CANT_OPEN_INPUT_FILE                  218

#define IDS_USAGE1                                      221
#define IDS_USAGE2                                      222
#define IDS_USAGE3                                      223
#define IDS_USAGE4                                      224
#define IDS_USAGE5                                      225
#define IDS_USAGE6                                      226
#define IDS_USAGE7                                      227
#define IDS_USAGE8                                      228
#define IDS_USAGE9                                      229
#define IDS_USAGEA                                      230
#define IDS_USAGEB                                      231
#define IDS_USAGEC                                      232
#define IDS_USAGED                                      233
#define IDS_USAGEE                                      234
#define IDS_USAGEF                                      235
#define IDS_ERROR_NOT_TS								236
#define IDS_TITLE_FORMAT                                300
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qappsrv\nenum.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*************************************************************************
*
*   NENUM.C
*
*   Name Enumerator for Networks
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "qappsrv.h"


/*=============================================================================
==   External Functions Defined
=============================================================================*/

int AppServerEnum( void );


/*=============================================================================
==   Functions used
=============================================================================*/

int NwEnumerate( void );
int MsEnumerate( void );



/*******************************************************************************
 *
 *  AppServerEnum
 *
 *   AppServerEnum returns an array of application servers
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

int
AppServerEnum()
{
    /*
     *  Enumerate netware network
     */
    (void) NwEnumerate();

    /*
     *  Enumerate ms network
     */
    (void) MsEnumerate();

    return( ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\peruser\peruser.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/***********************************************************************
*
*   PERUSER.H
*
*   This module contains typedefs and defines required for
*   the PERUSER utility.
*
*  
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_HELP_USAGE1                                 102
#define IDS_HELP_USAGE2                                 103
#define IDS_HELP_USAGE3                                 104
#define IDS_HELP_USAGE4                                 105
#define IDS_HELP_USAGE5                                 106
#define IDS_FOXPROFIX_DISABLED                          107
#define IDS_FOXPROFIX_ENABLED                           108
#define IDS_ACCESS_DENIED                               109
#define IDS_ERROR_NOTADMIN                              110
#define IDS_ERROR_NOT_TS                                111
/*
 *  Winlogon defines
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\peruser\peruser.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*   PERUSER.C
*
*   This module contains code for the PERUSER utility.
*   This utility adds or removes the Per-User File Associations registry key.
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winstaw.h>
#include <regapi.h>
#include <syslib.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <utildll.h>
#include <utilsub.h>
#include <string.h>

#include "peruser.h"
#include "printfoa.h"

/*
 * Global Data
 */
USHORT   help_flag = FALSE;             // User wants help
USHORT   fQuery    = FALSE;             // query
USHORT   fEnable   = FALSE;             // enable
USHORT   fDisable  = FALSE;             // disable

TOKMAP ptm[] = {
      {L"/q",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fQuery},
      {L"/query",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fQuery},
      {L"/enable",  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fEnable},
      {L"/disable", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fDisable},
      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
VOID  Usage(BOOLEAN bError);
ULONG ReadDWord(VOID);
ULONG WriteDWord( DWORD );
BOOL AreWeRunningTerminalServices(void);


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    WCHAR *CmdLine;
    WCHAR **argvW;
    ULONG rc;
    INT   i;


        //Check if we are running under Terminal Server
        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }
    /*
     * We can't use argv[] because its always ANSI, regardless of UNICODE
     */
    CmdLine = GetCommandLineW();
    /*
     * convert from oem char set to ansi
     */
    OEM2ANSIW(CmdLine, wcslen(CmdLine));

    /*
     * Massage the new command line to look like an argv[] type
     * because ParseCommandLine() depends on this format
     */
    argvW = (WCHAR **)malloc( sizeof(WCHAR *) * (argc+1) );
    if(argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    argvW[0] = wcstok(CmdLine, L" ");
    for(i=1; i < argc; i++){
        argvW[i] = wcstok(0, L" ");
    }
    argvW[argc] = NULL;

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if (rc && (rc & PARSE_FLAG_NO_PARMS) )
       help_flag = TRUE;

    if ( help_flag || rc ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

    /*
     *  Enable or disable
     */
    if ( fDisable || fEnable ) {

        /*
         * Only allow admins to modify the peruser fix
             */
        if( !TestUserForAdmin(FALSE) ) {
            ErrorPrintf(IDS_ERROR_NOTADMIN);
            return(FAILURE);
            }

        if ( fDisable ) {
            rc = WriteDWord(0x108);
        }
        else if ( fEnable ) {
            rc = WriteDWord(0);
        }
    }

    /*
     *  Query or error ?
     */
    if ( !fQuery && (rc != 1) ) {
        ErrorPrintf(IDS_ACCESS_DENIED);
    }
    else if ( ReadDWord() == TRUE ) {
        ErrorPrintf(IDS_FOXPROFIX_ENABLED);
    }
    else {
        ErrorPrintf(IDS_FOXPROFIX_DISABLED);
    }

    return(SUCCESS);
}


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    ErrorPrintf(IDS_HELP_USAGE1);
    ErrorPrintf(IDS_HELP_USAGE2);
    ErrorPrintf(IDS_HELP_USAGE3);
    ErrorPrintf(IDS_HELP_USAGE4);
    ErrorPrintf(IDS_HELP_USAGE5);
    }
    else {
       Message(IDS_HELP_USAGE1);
       Message(IDS_HELP_USAGE2);
       Message(IDS_HELP_USAGE3);
       Message(IDS_HELP_USAGE4);
       Message(IDS_HELP_USAGE5);
    }
}  /* Usage() */


/*******************************************************************************
 *
 *  ReadDWord
 *
 *  ENTRY:
 *
 * EXIT:
 *
 *
 ******************************************************************************/

ULONG
ReadDWord()
{
    DWORD  dwType = REG_DWORD;
    DWORD  dwSize;
    DWORD  dwValue;
    WCHAR  szValue[2];
    HKEY   Handle;
    LONG   rc;

    /*
     *  Open registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, COMPAT_REGENTRY_REG_NAME, 0, KEY_READ, &Handle ) != ERROR_SUCCESS )
        return FALSE;

    /*
     *  Read registry value
     */
    dwSize = 4;
    rc = RegQueryValueEx( Handle, COMPAT_REGENTRIES_CLASSES, NULL, &dwType, (PCHAR)&dwValue, &dwSize );

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    if ( rc != ERROR_SUCCESS )
        return FALSE;

    if ( dwValue == 0x108 )
        return FALSE;

    return TRUE;
}


/*******************************************************************************
 *
 *  WriteDWord
 *
 *  ENTRY:
 *
 * EXIT:
 *
 *
 ******************************************************************************/

ULONG
WriteDWord( DWORD dwValue )
{
    HKEY   Handle;
    LONG   rc;
    DWORD  dwDummy;

    /*
     *  Open registry
     */
    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, COMPAT_REGENTRY_REG_NAME, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &Handle, &dwDummy ) != ERROR_SUCCESS )
        return FALSE;

    /*
     *  Write registry value
     */
    rc = RegSetValueEx( Handle, COMPAT_REGENTRIES_CLASSES, 0, REG_DWORD, (PCHAR)&dwValue, 4 );

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    return( rc == ERROR_SUCCESS );
}

/*******************************************************************************
 *
 *  AreWeRunningTerminalServices
 *
 *      Check if we are running terminal server
 *
 *  ENTRY:
 *
 *  EXIT: BOOL: True if we are running Terminal Services False if we
 *              are not running Terminal Services
 *
 *
 ******************************************************************************/

BOOL AreWeRunningTerminalServices(void)
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    return VerifyVersionInfo(
        &osVersionInfo,
        VER_SUITENAME,
        dwlConditionMask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qappsrv\mslan.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*************************************************************************
*
*   MSLAN.C
*
*   Name Enumerator for Microsoft networks
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <lm.h>
#include "qappsrv.h"



/*=============================================================================
==   External Functions Defined
=============================================================================*/

int MsEnumerate( void );


/*=============================================================================
==   Private Functions Defined
=============================================================================*/

int _ServerEnum( PSERVER_INFO_101 *, LPDWORD );
int _LookUpAddress( LPTSTR );

/*=============================================================================
==   Functions used
=============================================================================*/

int TreeAdd( LPTSTR, LPTSTR );


/*=============================================================================
==   Global Data
=============================================================================*/

extern WCHAR Domain[];
extern USHORT fAddress;
extern WCHAR AppServer[];



/*******************************************************************************
 *
 *  MsEnumerate
 *
 *   MsEnumerate adds all the hydra application servers on a ms network
 *   to a binary tree
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

int
MsEnumerate()
{
    PSERVER_TRANSPORT_INFO_0 pTransport;
    PSERVER_INFO_101 pInfo = NULL;
    PSERVER_INFO_101 psv101= NULL;
    DWORD AvailCount;
    ULONG ActualCount;
    ULONG TotalCount;
    WCHAR Address[MAXADDRESS];
    LPTSTR pName;
    int i, j;
    int rc;    

    /*
     *  Get the names and the count
     */
    if( AppServer[0] )
    {
        rc = ( int )NetServerGetInfo( AppServer , 101 , ( LPBYTE * )&psv101 );

        if( rc )
        {
            return rc;            
        }

        if( ( psv101->sv101_type & SV_TYPE_TERMINALSERVER ) )
        {
            if( fAddress )
            {
                rc = _LookUpAddress( AppServer );
            }
            else 
            {
                rc = TreeAdd( AppServer, L"" );
            }
        } 
        
        if( psv101 != NULL )
        {
            NetApiBufferFree( psv101 );
        }

        return rc;

    }
    else if( rc = _ServerEnum( &pInfo, &AvailCount ) ) 
    {
        return( rc );
    }
    

    /*
     *  Add name to binary tree
     */
    while( AvailCount-- )
    {
        pName = pInfo[AvailCount].sv101_name;
        
        if( fAddress )
        {
            rc = _LookUpAddress( pName );
        }
        else
        {
            if( rc = TreeAdd( pName, L"" ) )
            {
                break; //return( rc );
            }
        }
    }

    if( pInfo != NULL )
    {
        NetApiBufferFree( pInfo );
    }

    return( rc );
}



/*******************************************************************************
 *
 *  _ServerEnum
 *
 *   enumerate ms network servers
 *
 * ENTRY:
 *    ppInfo (output)
 *       adderss of pointer to data buffer
 *    pAvail (output)
 *       address to return number of entries available
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/
int
_ServerEnum( PSERVER_INFO_101 * ppInfo, LPDWORD pAvail )
{
    INT     rc;
    DWORD   TotalEntries;

    rc = NetServerEnum ( 
                     NULL,                    //IN  LPTSTR      servername OPTIONAL,
                     101,                     //IN  DWORD       level,
                     (LPBYTE *)ppInfo,        //OUT LPBYTE      *bufptr,
                     (DWORD) -1,              //IN  DWORD       prefmaxlen,
                     pAvail,                  //OUT LPDWORD     entriesread,
                     &TotalEntries,           //OUT LPDWORD     totalentries,
                     SV_TYPE_TERMINALSERVER,  //IN  DWORD       servertype,
                     Domain[0] ? Domain:NULL, //IN  LPTSTR      domain OPTIONAL,
                     NULL );                  //IN OUT LPDWORD  resume_handle OPTIONAL

    return( rc );
}

/*******************************************************************************
 *
 *  _LookUpAddress
 *
 *   enumerate ms network nodes
 *
 * ENTRY:
 *      Name of server
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/
int _LookUpAddress( LPTSTR pName )
{
    PSERVER_TRANSPORT_INFO_0 pTransport;
    ULONG ActualCount;
    ULONG TotalCount;
    WCHAR Address[MAXADDRESS] = {0};    
    int i, j;
    int rc;

    rc = NetServerTransportEnum( pName,
                                 0,
                                 (LPBYTE *) &pTransport,
                                 (DWORD) -1,
                                 &ActualCount,
                                 &TotalCount,
                                 NULL );

    if( rc == ERROR_SUCCESS )
    {
        for ( i=0; i < (int)ActualCount; i++ )
        {
            if ( wcscmp(pTransport->svti0_networkaddress,L"000000000000") )
            {
                int nSize;

                wcscpy( Address, L"          [" );
                wcscat( Address, pTransport->svti0_networkaddress );
                wcscat( Address, L"]" );

                nSize = wcslen(Address);

                for ( j=11; j < nSize; j++ )
                {
                    if ( Address[j] == '0' )
                    {
                        Address[j] = ' ';
                    }
                    else
                    {
                        break;
                    }
                }
            }

            pTransport++;

            if( rc = TreeAdd( pName, _wcsupr(Address) ) )
            {
                break; //return( rc );
            }
        }
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qappsrv\qappsrv.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  QAPPSRV.C
*
*  query appserver information
*
*
*******************************************************************************/

/*
 *  Includes
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <lm.h>
#include <winstaw.h>
#include <utilsub.h>
#include <printfoa.h>
#include "qappsrv.h"


/*=============================================================================
==   Global data
=============================================================================*/

WCHAR CurrentAppServer[MAXNAME];
WCHAR AppServer[MAXNAME];
WCHAR Domain[MAX_IDS_LEN+1];
USHORT help_flag   = FALSE;
BOOLEAN MatchedOne = FALSE;
USHORT fAddress = FALSE;
USHORT fNoPage = FALSE;
ULONG Rows = 23;
HANDLE hConIn;
HANDLE hConOut;

TOKMAP ptm[] = {
      {L" ",       TMFLAG_OPTIONAL, TMFORM_STRING, MAXNAME, AppServer},
      {L"/DOMAIN", TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, Domain},
      {L"/ADDRESS", TMFLAG_OPTIONAL, TMFORM_BOOLEAN,sizeof(USHORT), &fAddress},
      {L"/Continue",TMFLAG_OPTIONAL, TMFORM_BOOLEAN,sizeof(USHORT), &fNoPage },
      {L"/?",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN,sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

void DisplayServer( LPTSTR, LPTSTR );
void Usage( BOOLEAN bError );
int _getch( void );


/*=============================================================================
==   Functions used
=============================================================================*/

int AppServerEnum( void );
void TreeTraverse( PTREETRAVERSE );




/*******************************************************************************
 *
 *  main
 *
 *   main routine
 *
 * ENTRY:
 *    argc (input)
 *       number of command line arguments
 *    argv (input)
 *       pointer to arrary of command line arguments
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    CONSOLE_SCREEN_BUFFER_INFO ScreenInfo;
    PSERVER_INFO_101 pCurrentServer;
    ULONG Status;
    ULONG rc;
    WCHAR **argvW;
    int i;

    Domain[0] = UNICODE_NULL;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

    /*
     *  Get handle to console
     */
    hConIn = CreateFile( L"CONIN$", GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, 0, NULL );

    hConOut = CreateFile( L"CONOUT$", GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, 0, NULL );

    /*
     *  Get the number of rows on the screen
     */
    if ( GetConsoleScreenBufferInfo( hConOut, &ScreenInfo ) )
        Rows = ScreenInfo.dwSize.Y - 2;

    /*
     *  Get current server
     */
    Status = NetServerGetInfo( NULL, 101, (LPBYTE *) &pCurrentServer );
    if ( Status ) {
        ErrorPrintf(IDS_ERROR_SERVER_INFO, Status);
        PutStdErr( Status, 0 );
        return(FAILURE);
    }
    lstrcpyn( CurrentAppServer, pCurrentServer->sv101_name, MAXNAME );

    /*
     *  Get the names and the count
     */
    //if ( rc = AppServerEnum() ) {
    //    ErrorPrintf(IDS_ERROR_SERVER_ENUMERATE, rc );
    //    PutStdErr( rc, 0 );
    //    return(FAILURE);
    //}
    
    AppServerEnum();

    /*
     *  Display names
     */
    TreeTraverse( DisplayServer );

    if (!MatchedOne)
    {
        if ( AppServer[0])
        {
            Message(IDS_ERROR_TERMSERVER_NOT_FOUND);
        }
        else
        {
            Message(IDS_ERROR_NO_TERMSERVER_IN_DOMAIN);
        }
    }

    if( pCurrentServer != NULL )
    {
        NetApiBufferFree( pCurrentServer );
    }

    return(SUCCESS);
}



/*******************************************************************************
 *
 *  DisplayServer
 *
 *  This routine displays information for one server
 *
 *
 *  ENTRY:
 *     pName (input)
 *        pointer to server name
 *     pAddress (input)
 *        pointer to server address
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayServer( LPTSTR pName, LPTSTR pAddress )
{
    static ULONG RowCount = 0;

    /*
     *  If appserver name was specified only show it
     */
    if ( AppServer[0] && _wcsicmp( pName, AppServer ) )
        return;

    /*
     *  Page pause
     */
    if ( !(++RowCount % Rows) && !fNoPage ) {
        Message(IDS_PAUSE_MSG);
       _getch();
       wprintf(L"\n");
    }

    /*
     *  If first time - output title
     */
    if ( !MatchedOne ) {
        Message( fAddress ? IDS_TITLE_ADDR : IDS_TITLE );
        Message( fAddress ? IDS_TITLE_ADDR1 : IDS_TITLE1 );
        MatchedOne = TRUE;
    }

    if ( fAddress ) {
        My_wprintf( L"%-37s%-21s\n", _wcsupr(pName), pAddress );
                    
    } else {
        My_wprintf( L"%s\n", _wcsupr(pName) );
    }
}



/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_HELP_USAGE1);
        ErrorPrintf(IDS_HELP_USAGE2);
        ErrorPrintf(IDS_HELP_USAGE3);
        ErrorPrintf(IDS_HELP_USAGE4);
        ErrorPrintf(IDS_HELP_USAGE5);
        ErrorPrintf(IDS_HELP_USAGE6);
        ErrorPrintf(IDS_HELP_USAGE7);
    } else {
        Message(IDS_HELP_USAGE1);
        Message(IDS_HELP_USAGE2);
        Message(IDS_HELP_USAGE3);
        Message(IDS_HELP_USAGE4);
        Message(IDS_HELP_USAGE5);
        Message(IDS_HELP_USAGE6);
        Message(IDS_HELP_USAGE7);
    }

}



int _getch( void )
{
        INPUT_RECORD ConInpRec;
        DWORD NumRead;
        int ch = 0;                     /* single character buffer */
        DWORD oldstate = 0;

        /*
         * Switch to raw mode (no line input, no echo input)
         */
        GetConsoleMode( hConIn, &oldstate );
        SetConsoleMode( hConIn, 0L );

        for ( ; ; ) {

            /*
             * Get a console input event.
             */
            if ( !ReadConsoleInput( hConIn,
                                    &ConInpRec,
                                    1L,
                                    &NumRead )
                 || (NumRead == 0L) )
            {
                ch = EOF;
                break;
            }

            /*
             * Look for, and decipher, key events.
             */
            if ( (ConInpRec.EventType == KEY_EVENT) &&
                 ConInpRec.Event.KeyEvent.bKeyDown ) {
                /*
                 * Easy case: if uChar.AsciiChar is non-zero, just stuff it
                 * into ch and quit.
                 */
                if ( ch = (unsigned char)ConInpRec.Event.KeyEvent.uChar.AsciiChar )
                    break;
            }
        }


        /*
         * Restore previous console mode.
         */
        SetConsoleMode( hConIn, oldstate );

        return ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qappsrv\qappsrv.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*  QAPPSRV.H
*     This module contains typedefs and defines required for
*     the QAPPSRV utility.
*
*
*************************************************************************/


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be

/*
 *  Maximum server name length
 */
#define MAXNAME        48
#define MAXADDRESS     50

/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_SERVER_ENUMERATE                      102
#define IDS_ERROR_SERVER_INFO                           103
#define IDS_HELP_USAGE1                                 104
#define IDS_HELP_USAGE2                                 105
#define IDS_HELP_USAGE3                                 106
#define IDS_HELP_USAGE4                                 107
#define IDS_HELP_USAGE5                                 108
#define IDS_HELP_USAGE6                                 109
#define IDS_HELP_USAGE7                                 110
#define IDS_TITLE                                       111
#define IDS_TITLE1                                      112
#define IDS_TITLE_ADDR                                  113
#define IDS_TITLE_ADDR1                                 114
#define IDS_ERROR_NOT_TS                                115
#define IDS_PAUSE_MSG                                   116
#define IDS_ERROR_TERMSERVER_NOT_FOUND                  117
#define IDS_ERROR_NO_TERMSERVER_IN_DOMAIN               118

/*
 *  Binary tree traverse function
 */
typedef void (* PTREETRAVERSE) ( LPTSTR, LPTSTR );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qappsrv\nwlan.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*************************************************************************
*
*   NWLAN.C
*
*   Name Enumerator for Novell Netware
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <icaipx.h>
#include <nwapi32.h>
#include "qappsrv.h"


/*=============================================================================
==   External Functions Defined
=============================================================================*/

int NwEnumerate( void );


/*=============================================================================
==  LoadLibrary/GetProcAddress stuff for NWAPI32.DLL
=============================================================================*/

/*
 *  NWAPI32.DLL stuff
 */

#define     PSZ_NWAPI32                 TEXT("NWAPI32.DLL")

#define     PSZ_NWATTACHTOFILESERVER        "NWAttachToFileServer"
#define     PSZ_NWDETACHFROMFILESERVER      "NWDetachFromFileServer"
#define     PSZ_NWREADPROPERTYVALUE         "NWReadPropertyValue"
#define     PSZ_NWSCANOBJECT                "NWScanObject"

typedef NWCCODE (NWAPI DLLEXPORT *PNWATTACHTOFILESERVER)
                    (const char NWFAR *,
                     NWLOCAL_SCOPE,
                     NWCONN_HANDLE NWFAR *);
typedef NWCCODE (NWAPI DLLEXPORT *PNWDETACHFROMFILESERVER)
                    (NWCONN_HANDLE);
typedef NWCCODE (NWAPI DLLEXPORT *PNWREADPROPERTYVALUE)
                    (NWCONN_HANDLE,
                     const char NWFAR *,
                     NWOBJ_TYPE,
                     char NWFAR *,
                     unsigned char,
                     char NWFAR *,
                     NWFLAGS NWFAR *,
                     NWFLAGS NWFAR *);
typedef NWCCODE (NWAPI DLLEXPORT *PNWSCANOBJECT)
                     (NWCONN_HANDLE,
                      const char NWFAR *,
                      NWOBJ_TYPE,
                      NWOBJ_ID NWFAR *,
                      char NWFAR *,
                      NWOBJ_TYPE NWFAR *,
                      NWFLAGS NWFAR *,
                      NWFLAGS NWFAR *,
                      NWFLAGS NWFAR *);


/*=============================================================================
==   Private Functions
=============================================================================*/

int AppServerFindFirstNW( NWCONN_HANDLE, LPTSTR, ULONG, LPTSTR, ULONG );
int AppServerFindNextNW( NWCONN_HANDLE, LPTSTR, ULONG, LPTSTR, ULONG );
int GetNetwareAddress( NWCONN_HANDLE, LPBYTE, LPBYTE  );
int w_appsrv_ff_fn( NWCONN_HANDLE, LPTSTR, ULONG, LPTSTR, ULONG );
void FormatAddress( PBYTE, PBYTE );


/*=============================================================================
==   Functions used
=============================================================================*/

int TreeAdd( LPTSTR, LPTSTR );


/*=============================================================================
==   Local Data
=============================================================================*/

static long objectID = -1;
static PNWATTACHTOFILESERVER pNWAttachToFileServer = NULL;
static PNWDETACHFROMFILESERVER pNWDetachFromFileServer = NULL;
static PNWREADPROPERTYVALUE pNWReadPropertyValue = NULL;
static PNWSCANOBJECT pNWScanObject = NULL;

/*=============================================================================
==   Global Data
=============================================================================*/

extern USHORT fAddress;


/*******************************************************************************
 *
 *  NwEnumerate
 *
 *   NwEnumerate adds all the hydra application servers on a netware network
 *   to a binary tree
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

int
NwEnumerate()
{
    NWCONN_HANDLE hConn;
    WCHAR abName[MAXNAME];
    WCHAR Address[MAXADDRESS];
    int rc;
    HINSTANCE hinst;

    /*
     *  Load NWAPI32.DLL
     */
    if ( (hinst = LoadLibrary( PSZ_NWAPI32 )) == NULL ) {
        return( ERROR_DLL_NOT_FOUND );
    }

    /*
     * Load pointers to the NWAPI32 APIs that we'll need.
     */
    if ( (((FARPROC)pNWAttachToFileServer = GetProcAddress( hinst, PSZ_NWATTACHTOFILESERVER )) == NULL) ||
         (((FARPROC)pNWDetachFromFileServer = GetProcAddress( hinst, PSZ_NWDETACHFROMFILESERVER )) == NULL) ||
         (((FARPROC)pNWReadPropertyValue = GetProcAddress( hinst, PSZ_NWREADPROPERTYVALUE )) == NULL) ||
         (((FARPROC) pNWScanObject = GetProcAddress( hinst, PSZ_NWSCANOBJECT )) == NULL) ) {

        FreeLibrary( hinst );
        return( ERROR_PROC_NOT_FOUND );
    }

    /*
     *  Attach to novell file server
     */
    if ( rc = (*pNWAttachToFileServer)( "*", 0, &hConn ) )
        goto badattach;

    /*
     *  Get first appserver
     */
    if ( rc = AppServerFindFirstNW( hConn, abName, sizeof(abName), Address, sizeof(Address) ) )
        goto badfirst;

    /*
     *  Get remaining appservers
     */
    while ( rc == ERROR_SUCCESS ) {

        /*
         *  Add appserver name to binary tree
         */
        if ( rc = TreeAdd( abName, Address ) )
            goto badadd;

        /*
         *  Get next appserver name
         */
        rc = AppServerFindNextNW( hConn, abName, sizeof(abName), Address, sizeof(Address) );
    }

    /*
     *  Detach from file server
     */
    (void) (*pNWDetachFromFileServer)( hConn );

    FreeLibrary( hinst );
    return( ERROR_SUCCESS );


/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  binary tree name add failed
     *  error getting first appserver name
     */
badadd:
badfirst:
    (void) (*pNWDetachFromFileServer)( hConn );

    /*
     *  Attach failed
     */
badattach:
    return( rc );
}



/*******************************************************************************
 *
 *  GetNetwareAddress
 *
 *
 *  ENTRY:
 *
 *  EXIT:
 *     nothing
 *
 *
 ******************************************************************************/

int
GetNetwareAddress( NWCONN_HANDLE hConn, LPBYTE pAppServer, LPBYTE pAddress  )
{
    int             rc;
    unsigned char   more;
    unsigned char   PropFlags;

    /* Get property value */
    rc = (*pNWReadPropertyValue)( hConn,
                                  pAppServer,       // IN: object name
                                  CITRIX_APPLICATION_SERVER_SWAP, // IN: objectType
                                  "NET_ADDRESS",    // IN:
                                  1,                // IN: 1st buffer
                                  pAddress,         // OUT: Buffer to put Address
                                  &more,            // OUT: 0 == no more 128 segment
                                                    //      ff == more 128 segments
                                  &PropFlags );     // OUT: optional

    return( rc );
}


/*******************************************************************************
 *
 *  AppServerFindFirstNW
 *
 *
 *  ENTRY:
 *
 *  EXIT:
 *     nothing
 *
 *
 ******************************************************************************/

int
AppServerFindFirstNW( NWCONN_HANDLE hConn,
                      LPTSTR pAppServer, ULONG NameLength,
                      LPTSTR pAddress, ULONG AddrLength )
{
    objectID = -1;
    return( w_appsrv_ff_fn( hConn, pAppServer, NameLength, pAddress, AddrLength ) );
}


/*******************************************************************************
 *
 *  AppServerFindNextNW
 *
 *
 *  ENTRY:
 *
 *  EXIT:
 *     nothing
 *
 *
 ******************************************************************************/

int
AppServerFindNextNW( NWCONN_HANDLE hConn,
                     LPTSTR pAppServer, ULONG NameLength,
                     LPTSTR pAddress, ULONG AddrLength )
{
   return( w_appsrv_ff_fn( hConn, pAppServer, NameLength, pAddress, AddrLength ) );
}



/*******************************************************************************
 *
 *  Worker routines
 *
 *
 *  ENTRY:
 *
 *  EXIT:
 *     nothing
 *
 *
 ******************************************************************************/

int
w_appsrv_ff_fn( NWCONN_HANDLE hConn,
                LPTSTR pAppServer, ULONG NameLength,
                LPTSTR pAddress, ULONG AddrLength )
{
    int           rc;
    WORD          objectType;
    unsigned char hasPropertiesFlag = 0;
    unsigned char objectFlags;
    unsigned char objectSecurity;
    BYTE abName[49];
    BYTE Address[128];
    BYTE FormatedAddress[MAXADDRESS];
    ULONG ByteCount;


    /* while there are still properties */
    while ( hasPropertiesFlag == 0 ) {
        /* scan bindery object */
        if ( rc = (*pNWScanObject)( hConn,
                                    "*",
                                    CITRIX_APPLICATION_SERVER_SWAP,
                                    &objectID,
                                    abName,
                                    &objectType,
                                    &hasPropertiesFlag,
                                    &objectFlags,
                                    &objectSecurity )) {
            break;
        }
    }

    RtlMultiByteToUnicodeN( pAppServer, NameLength, &ByteCount,
                            abName, (strlen(abName) + 1) );

    /* get netware address */
    if ( fAddress && GetNetwareAddress( hConn, abName, Address ) == ERROR_SUCCESS ) {
        FormatAddress( Address, FormatedAddress );
        RtlMultiByteToUnicodeN( pAddress, AddrLength, &ByteCount,
                                FormatedAddress, (strlen(FormatedAddress) + 1) );
    } else {
        pAddress[0] = '\0';
    }

    return( rc );
}


/*******************************************************************************
 *
 *  FormatAddress
 *
 *
 *  ENTRY:
 *
 *  EXIT:
 *     nothing
 *
 *
 ******************************************************************************/
void
FormatAddress( PBYTE pInternetAddress, PBYTE pszAddress )
{
   USHORT i;
   USHORT j;
   USHORT firstPass;
   BYTE buf2[5];

   /* squish leading 0s on network address 1st */
   firstPass = TRUE;
   pszAddress[0] = '[';
   pszAddress[1] = '\0';
   for ( i=0; i<3; i++ ) {
      j=i;
      if ( pInternetAddress[i] ) {
         sprintf( buf2, "%2X", pInternetAddress[i] );
         strcat( pszAddress, buf2 );
         firstPass = FALSE;
         break;
      }
      else {
         strcat( pszAddress, "  " );
      }
   }

   /* remaining bytes */
   for ( i=++j; i<4; i++ ) {
      if ( firstPass )
         sprintf( buf2, "%2X", pInternetAddress[i] );
      else
         sprintf( buf2, "%02X", pInternetAddress[i] );
      strcat( pszAddress, buf2 );
      firstPass = FALSE;
   }
   strcat( pszAddress, "][" );

   /* squish leading 0s on network address 2nd */
   firstPass = TRUE;
   for ( i=4; i<10; i++ ) {
      j=i;
      if ( pInternetAddress[i] ) {
         sprintf( buf2, "%2X", pInternetAddress[i] );
         strcat( pszAddress, buf2 );
         firstPass = FALSE;
         break;
      }
      else {
         strcat( pszAddress, "  " );
      }
   }

   /* remaining bytes */
   for ( i=++j; i<10; i++ ) {
      if ( firstPass )
         sprintf( buf2, "%2X", pInternetAddress[i] );
      else
         sprintf( buf2, "%02X", pInternetAddress[i] );
      strcat( pszAddress, buf2 );
      firstPass = FALSE;
   }
   strcat( pszAddress, "]" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qobject\dosdev.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*****************************************************************************
*
*   DOSDEV.C for Windows NT
*
*   Description:
*
*   Query NT DOS Objects.
*
*   Copyright Citrix Systems Inc. 1993-1995
*
*   Author: Kurt Perry (adapted from bradp's dosdev utility).
*
*   Log: See VLOG
*
****************************************************************************/

/*******************************************************************************
 *
 * dosdev utility  (NT only)
 *
 * Brad Pedersen
 * August 10, 1993
 ******************************************************************************/

/*
 *  Includes
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
// #include <ntddkbd.h>
// #include <ntddmou.h>
// #include <ntddbeep.h>
// #include <ntddvdeo.h>
#include <winstaw.h>
#include <ntcsrsrv.h>
#include <windows.h>

#include "qobject.h"

#define MAXBUFFER (1024 * 2)

WCHAR Name[ MAXBUFFER ];
WCHAR Info[ MAXBUFFER ];

/*
 * Procedure prototypes
 */
void display_devices( void );
void display_one( WCHAR * );

void Print( int nResourceID, ... );

/*******************************************************************************
 *
 *  display_devices
 *
 ******************************************************************************/

void
display_devices()
{
    WCHAR * pName;

    /*
     *  Get complete device list
     */
    if ( !QueryDosDevice( NULL, Name, MAXBUFFER ) ) {
        Print(IDS_ERROR_TOO_MANY_DEVICES);
        return;
    }

    /*
     *  Display each device name in list
     */
    pName = Name;
    while ( *pName ) {
        display_one( pName );
        pName += (wcslen( pName ) + 1);
    }
}

/*******************************************************************************
 *
 *  display_one
 *
 ******************************************************************************/

void
display_one( WCHAR * pName )
{
    WCHAR * pInfo;

    /*
     *  Get additional information on device name
     */
    if ( !QueryDosDevice( pName, Info, MAXBUFFER ) )
        return;

    wprintf( L"%-17s", pName );

    pInfo = Info;
    while ( *pInfo ) {
        wprintf( L"%s ", pInfo );
        pInfo += (wcslen( pInfo ) + 1);
    }

    wprintf( L"\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qobject\qobject.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation


/*****************************************************************************
*
*   QOBJECT.C for Windows NT
*
*   Description:
*
*   Query NT Objects.
*
****************************************************************************/


/* include files */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winstaw.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <utilsub.h>
#include <printfoa.h>

#include "qobject.h"

/*
 *  Local variables
 */
WCHAR  objectW[MAX_FILE_LEN+1];

USHORT dev_flag  = FALSE;
USHORT help_flag = FALSE;


/*
 *  Command line parsing strucutre
 */
TOKMAP ptm[] =
{
   {L" ",          TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_FILE_LEN,   objectW},
   {L"/Device",    TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &dev_flag},
   {L"/?",         TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
   {0, 0, 0, 0, 0}
};


/*
 *  Local function prototypes
 */
VOID   Usage(BOOL);
BOOL AreWeRunningTerminalServices(void);


/*
 *  External Procedure prototypes
 */
void display_devices( void );


/*******************************************************************************
 *
 *  print
 *      Display a message to stdout with variable arguments.  Message
 *      format string comes from the application resources.
 *
 *  ENTRY:
 *      nResourceID (input)
 *          Resource ID of the format string to use in the message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
Print( int nResourceID, ... )
{
    char sz1[256], sz2[512];
    va_list args;

    va_start( args, nResourceID );

    if ( LoadStringA( NULL, nResourceID, sz1, 256 ) ) {
        vsprintf( sz2, sz1, args );
        printf( sz2 );
    }

    va_end(args);
}

/*******************************************************************************
 *
 *  QueryLink
 *
 ******************************************************************************/

void
QueryLink( HANDLE DirectoryHandle, PCWSTR pName, PWSTR pLinkName, ULONG Length )
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    ULONG ReturnedLength;
    HANDLE LinkHandle;
    NTSTATUS Status;

    pLinkName[ 0 ] = UNICODE_NULL;
    pLinkName[ 1 ] = UNICODE_NULL;

    RtlInitUnicodeString( &UnicodeString, pName );
    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                DirectoryHandle,
                                NULL
                              );
    Status = NtOpenSymbolicLinkObject( &LinkHandle,
                                       SYMBOLIC_LINK_QUERY,
                                       &Attributes
                                     );
    if (NT_SUCCESS( Status )) {
        UnicodeString.Buffer = pLinkName;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = (USHORT)(Length * sizeof( WCHAR ));
        ReturnedLength = 0;
        Status = NtQuerySymbolicLinkObject( LinkHandle,
                                            &UnicodeString,
                                            &ReturnedLength
                                          );
        NtClose( LinkHandle );

        if (NT_SUCCESS( Status )) {

            pLinkName[ (ReturnedLength >> 1) + 0 ] = UNICODE_NULL;
            pLinkName[ (ReturnedLength >> 1) + 1 ] = UNICODE_NULL;
        }
        else {

            pLinkName[ 0 ] = UNICODE_NULL;
            pLinkName[ 1 ] = UNICODE_NULL;
        }
    }
}


/*******************************************************************************
 *
 *  QueryObject
 *
 ******************************************************************************/

void
QueryObject( PCWSTR lpDeviceName )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    BOOLEAN RestartScan;
    UCHAR DirInfoBuffer[ 512 ];
    WCHAR NameBuffer[ 256 ];
    WCHAR LinkBuffer[ 256 ];
    ULONG Context = 0;
    ULONG ReturnedLength;
    WCHAR * pInfo;

    RtlInitUnicodeString( &UnicodeString, lpDeviceName );

    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    Status = NtOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY,
                                    &Attributes
                                  );
//  printf( "NtOpenDirectoryObject: %x\n", Status );

    if (!NT_SUCCESS( Status ))
            return;

    RestartScan = TRUE;
    DirInfo = (POBJECT_DIRECTORY_INFORMATION)&DirInfoBuffer;
    while (TRUE) {

        Status = NtQueryDirectoryObject( DirectoryHandle,
                                         (PVOID)DirInfo,
                                         sizeof( DirInfoBuffer ),
                                         TRUE,
                                         RestartScan,
                                         &Context,
                                         &ReturnedLength
                                       );
//      printf( "NtQueryDirectoryObject: %x\n", Status );

        if (!NT_SUCCESS( Status )) {
            if (Status == STATUS_NO_MORE_ENTRIES)
                Status = STATUS_SUCCESS;
            break;
        }

        swprintf( NameBuffer, L"%s%s%s", lpDeviceName,
                      (PCWSTR) (!wcscmp(lpDeviceName,L"\\") ? L"" : L"\\"),
                      DirInfo->Name.Buffer );

        if ( !wcscmp( DirInfo->TypeName.Buffer, L"SymbolicLink" ) ) {

            QueryLink( DirectoryHandle, DirInfo->Name.Buffer, LinkBuffer, 255 );
            wprintf( L"%-50s ", NameBuffer );

            pInfo = LinkBuffer;
            while ( *pInfo ) {
               wprintf( L"%s ", pInfo );
               pInfo += (wcslen( pInfo ) + 1);
            }

            wprintf( L"\n" );
        } else {

            wprintf( L"%-50s %s\n", NameBuffer, DirInfo->TypeName.Buffer );
            QueryObject( NameBuffer );
        }

        RestartScan = FALSE;
    }

    NtClose( DirectoryHandle );
}


/*******************************************************************************
 *
 *  Usage
 *
 ******************************************************************************/

VOID
Usage( BOOL bError )
{

    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_HELP_USAGE1);
        ErrorPrintf(IDS_HELP_USAGE2);
        ErrorPrintf(IDS_HELP_USAGE3);
        ErrorPrintf(IDS_HELP_USAGE4);
        ErrorPrintf(IDS_HELP_USAGE5);
    } else {
        Print(IDS_HELP_USAGE1);
        Print(IDS_HELP_USAGE2);
        Print(IDS_HELP_USAGE3);
        Print(IDS_HELP_USAGE4);
        Print(IDS_HELP_USAGE5);
    }
}


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main( int argc, char *argv[] )
{
    INT     i;
    ULONG   rc;
    WCHAR **argvW;

        //Check if we are running under Terminal Server
        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }
    /*
     *  No popups
     */
    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

    /*
     * Massage the new command line to look like an argv[] type
     * because ParseCommandLine() depends on this format
     */
    argvW = (WCHAR **)malloc( sizeof(WCHAR *) * (argc+1) );
    if(argvW == NULL) {

        ErrorPrintf(IDS_ERROR_MALLOC);
        return STATUS_NO_MEMORY;
    }

    for( i=0; i < argc; i++ ) {
        // Convert to Ansi
        OEM2ANSIA(argv[i], (USHORT)strlen(argv[i]));
        argvW[i] = (WCHAR *)malloc( (strlen(argv[i]) + 1) * sizeof(WCHAR) );
        wsprintf( argvW[i], L"%S", argv[i] );
    }
    argvW[argc] = NULL;

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && rc != PARSE_FLAG_NO_PARMS) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return rc;
        } else {

            Usage(FALSE);
            return ERROR_SUCCESS;
        }
    }

    /*
     *  Dos devices only
     */
    if ( dev_flag ) {

        display_devices();
    }
    else {

        if ( ptm[0].tmFlag & TMFLAG_PRESENT ) {

            QueryObject( objectW );
        } else {

            QueryObject( L"\\" );
        }
    }

    return( 0 );
}

/*******************************************************************************
 *
 *  AreWeRunningTerminalServices
 *
 *      Check if we are running terminal server
 *
 *  ENTRY:
 *
 *  EXIT: BOOL: True if we are running Terminal Services False if we
 *              are not running Terminal Services
 *
 *
 ******************************************************************************/

BOOL AreWeRunningTerminalServices(void)
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    return VerifyVersionInfo(
        &osVersionInfo,
        VER_SUITENAME,
        dwlConditionMask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qobject\qobject.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*   QOBJECT.H
*
*   This module contains typedefs and defines required for
*   the QUERY OBJECT utility.
*
*************************************************************************/


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_FILE_LEN   260      // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_HELP_USAGE1                                 102
#define IDS_HELP_USAGE2                                 103
#define IDS_HELP_USAGE3                                 104
#define IDS_HELP_USAGE4                                 105
#define IDS_HELP_USAGE5                                 106
#define IDS_ERROR_TOO_MANY_DEVICES                      107
#define IDS_ERROR_NOT_TS                                108
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qappsrv\tree.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation


/*************************************************************************
*
*   TREE.C
*
*   Binary tree routines
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "qappsrv.h"



/*=============================================================================
==   Local Structures
=============================================================================*/

typedef struct _TREENODE {
   WCHAR Name[MAXNAME];
   WCHAR Address[MAXADDRESS];
   struct _TREENODE * pLeft;
   struct _TREENODE * pRight;
   struct _TREENODE * pParent;    
} TREENODE, * PTREENODE;


/*=============================================================================
==   Local data
=============================================================================*/

static PTREENODE G_pRoot = NULL;

/*=============================================================================
==   Global Data
=============================================================================*/

extern USHORT fAddress;


/*=============================================================================
==   External Functions Defined
=============================================================================*/

int  TreeAdd( LPTSTR, LPTSTR );
void TreeTraverse( PTREETRAVERSE );


/*=============================================================================
==   Private Functions Defined
=============================================================================*/

PTREENODE _Tree_GetNext(PTREENODE pCurr);
PTREENODE _Tree_GetFirst(PTREENODE pRoot);

/*******************************************************************************
 *
 *  TreeAdd
 *
 *
 *  ENTRY:
 *     pName (input)
 *        pointer to name to add
 *     pAddress (input)
 *        pointer to address to add
 *
 *  EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

int
TreeAdd( LPTSTR pName, LPTSTR pAddress )
{
    PTREENODE pCurr = G_pRoot;
    PTREENODE pNext;
    PTREENODE pNewNode;
    int cmp;

    /*
     *  Allocate tree node structure
     */
    if ( (pNewNode = malloc(sizeof(TREENODE))) == NULL ) 
        return( ERROR_NOT_ENOUGH_MEMORY );

    /*
     *  Initialize new tree node
     */
    memset( pNewNode, 0, sizeof(TREENODE) );
    lstrcpyn( pNewNode->Name, pName, MAXNAME );
    lstrcpyn( pNewNode->Address, pAddress, MAXADDRESS );

    /*
     *  If root is null, then we are done
     */
    if ( G_pRoot == NULL ) {

        G_pRoot = pNewNode;

    } else {
 
        /*
         *  walk current tree in order
         */
        for (;;) {
  
            cmp = wcscmp( pName, pCurr->Name );

            // if entry already exists, don't add
            if ( cmp == 0 && (!fAddress || !wcscmp( &pAddress[10], &pCurr->Address[10] )) ) {
                free( pNewNode );
                return( ERROR_SUCCESS );
            }

            // greater than lexicographically go right else left
            if ( cmp < 0 ) {
   
               // at end of line, then insert
               if ( (pNext = pCurr->pLeft) == NULL ) {
                   pCurr->pLeft = pNewNode;
                   pNewNode->pParent = pCurr;
                   break;
               }
   
            } else {
   
               // at end of line, then insert
               if ( (pNext = pCurr->pRight) == NULL ) {
                   pCurr->pRight = pNewNode;
                   pNewNode->pParent = pCurr;
                   break;
               }
   
            }
   
            // next
            pCurr = pNext;
        }
    }

    return( ERROR_SUCCESS );
}



/*******************************************************************************
 *
 *  TreeTraverse
 *
 *
 *  ENTRY:
 *     pFunc (input)
 *        pointer to traverse function
 *
 *  EXIT:
 *    nothing
 *
 *  History:    Date        Author     Comment
 *              2/08/01     skuzin     Changed to use non-recursive algorithm
 ******************************************************************************/
void
TreeTraverse( PTREETRAVERSE pFunc )
{
    PTREENODE pNode;

    if(G_pRoot)
    {
        pNode = _Tree_GetFirst(G_pRoot);

        while(pNode)
        {
            /*
             *  Call function with name
             */
            (*pFunc)( pNode->Name, pNode->Address ); 
        
            pNode=_Tree_GetNext(pNode);
        }
    }
}

/*******************************************************************************
 *
 *  _Tree_GetFirst()
 *
 *  Finds the leftmost node of the tree
 *
 *  ENTRY:
 *     PTREENODE pRoot
 *        pointer to the root node
 *
 *  EXIT:
 *    pointer to the leftmost node of the tree
 *
 *  History:    Date        Author     Comment
 *              2/08/01     skuzin     Created
 ******************************************************************************/
PTREENODE 
_Tree_GetFirst(
        IN PTREENODE pRoot)
{
    PTREENODE pNode = pRoot;
    while(pNode->pLeft)
    {
        pNode = pNode->pLeft;
    }
    return pNode;    
}

/*******************************************************************************
 *
 *  _Tree_GetFirst()
 *
 *  Finds the next leftmost node of the tree
 *
 *  ENTRY:
 *     PTREENODE pCurr
 *        pointer to the the previous leftmost node
 *
 *  EXIT:
 *    pointer to the next leftmost node of the tree
 *
 *  History:    Date        Author     Comment
 *              2/08/01     skuzin     Created
 ******************************************************************************/
PTREENODE 
_Tree_GetNext(
        IN PTREENODE pCurr)
{
    PTREENODE pNode = pCurr;

    if(pNode->pRight)
    {
        pNode = pNode->pRight;
        while(pNode->pLeft)
        {
            pNode = pNode->pLeft;
        }
        return pNode;
    }
    else
    {
        while(pNode->pParent && pNode->pParent->pLeft != pNode)
        {
            pNode = pNode->pParent;
        }
        return pNode->pParent;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\query\query.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*************************************************************************
*
*  QUERY.C
*     This module is the QUERY utility code.
*
*
*************************************************************************/

#include <stdio.h>
#include <windows.h>
#include <winstaw.h>
#include <regapi.h>
#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <printfoa.h>

#include "query.h"

/*-----------------------------------------------------------------------
-- Supported commands (now obtained from registry)
------------------------------------------------------------------------*/
PPROGRAMCALL pProgList = NULL;

/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );


/*************************************************************************
*
*  main
*     Main function and entry point of the text-based query
*     menu utility.
*
*  ENTRY:
*       argc (input)
*           count of the command line arguments.
*       argv (input)
*           vector of strings containing the command line arguments;
*           (not used due to always being ANSI strings).
*
*  EXIT
*       (int) exit code: SUCCESS for success; FAILURE for error.
*
*************************************************************************/

int __cdecl
main( INT argc,
      CHAR **argv )
{
    PWCHAR          arg, *argvW;
    PPROGRAMCALL    pProg, pProgramCall = NULL;
    int             len, j, status = FAILURE;
    LONG            regstatus;

    setlocale(LC_ALL, ".OCP");

    /*
     * Obtain the supported QUERY commands from registry.
     */
    if ( (regstatus =
            RegQueryUtilityCommandList( UTILITY_REG_NAME_QUERY, &pProgList ))
            != ERROR_SUCCESS ) {

        ErrorPrintf(IDS_ERROR_REGISTRY_FAILURE, UTILITY_NAME, regstatus);
        goto exit;
    }

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        goto exit;
    }

    /*
     * Check for valid utility name and execute.
     */
    if ( argc > 1 && *(argvW[1]) ) {

        len = wcslen(arg = argvW[1]);
        for ( pProg = pProgList->pFirst; pProg != NULL; pProg = pProg->pNext ) {

            if ( (len >= pProg->CommandLen) &&
                 !_wcsnicmp( arg, pProg->Command, len ) ) {

                pProgramCall = pProg;
                break;
            }
        }

        if ( pProgramCall ) {

                if ( ExecProgram(pProgramCall, argc - 2, &argvW[2]) )
                goto exit;

        } else if ( ((arg[0] == L'-') || (arg[0] == L'/')) &&
                    (arg[1] == L'?') ) {

            /*
             * Help requested.
             */
            Usage(FALSE);
            status = SUCCESS;
            goto exit;

        } else {

            /*
             * Bad command line.
             */
            Usage(TRUE);
            goto exit;
        }

    } else {

        /*
         * Nothing on command line.
         */
        Usage(TRUE);
        goto exit;
    }

exit:
    if ( pProgList )
        RegFreeUtilityCommandList(pProgList);   // let's be tidy

    return(status);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }

    ProgramUsage(UTILITY_NAME, pProgList, bError);

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\query\query.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  QUERY.H
*
*   This module contains typedefs and defines required for the QUERY utility
*   menu.
*
*  
******************************************************************************/

/*
 * Usage string definitions.
 */
#define UTILITY_NAME    L"QUERY"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_REGISTRY_FAILURE                      102
#define IDS_ERROR_NOT_TS                                103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qprocess\qprocess.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*  QPROCESS.H
*     This module contains typedefs and defines required for
*     the QPROCESS utility.
*
*
*************************************************************************/

#include <utildll.h>
/*
 * Header and format string definitions.
 */
// L" USERNAME              SESSIONNAME         ID  STATE         PID  IMAGE\n"
//    12345678901234567890  1234567890123456  1234  1234567890  12345  123456789012345

//#define FORMAT \
//L"%-20s  %-16s  %4u  %-10s  %5u  %0.15s\n"
#define FORMAT \
 "%-20s  %-16s  %4u  %5u  %0.15s\n"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256   // maximum length that the input parm can be
#define MAXNAME 18          // Max allowed for printing.


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_QUERY_INFORMATION                     102
#define IDS_ERROR_PROCESS_NOT_FOUND                     103
#define IDS_ERROR_ENUMERATE_PROCESSES                   104
#define IDS_ERROR_SERVER                                105
#define IDS_HELP_USAGE1                                 106
#define IDS_HELP_USAGE2                                 107
#define IDS_HELP_USAGE3                                 108
#define IDS_HELP_USAGE4                                 109
#define IDS_HELP_USAGE5                                 110
#define IDS_HELP_USAGE6                                 111
#define IDS_HELP_USAGE7                                 112
#define IDS_HELP_USAGE8                                 113
#define IDS_HELP_USAGE9                                 114
#define IDS_HELP_USAGE10                                115
#define IDS_HEADER                                      116
#define IDS_ERROR_NOT_TS								117
#define IDS_HELP_USAGE40                                118
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qwinsta\qwinsta.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  QWINSTA.C
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>

#include <stdio.h>
#include <windows.h>
#include <winstaw.h>
#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>


#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <wsnetbs.h>
#include <nb30.h>
#include <printfoa.h>

#include <allproc.h>
#include "qwinsta.h"

LPCTSTR WINAPI
StrConnectState( WINSTATIONSTATECLASS ConnectState,
                 BOOL bShortString );
LPCTSTR WINAPI
StrAsyncConnectState( ASYNCCONNECTCLASS ConnectState );


HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];
WCHAR  term_string[MAX_IDS_LEN+1];
USHORT a_flag    = FALSE;
USHORT c_flag    = FALSE;
USHORT f_flag    = FALSE;
USHORT m_flag    = FALSE;
USHORT help_flag = FALSE;
USHORT fSm       = FALSE;
USHORT fDebug    = FALSE;
USHORT fVm       = FALSE;
USHORT counter_flag = FALSE;

TOKMAP ptm[] = {
      {L" ",        TMFLAG_OPTIONAL, TMFORM_S_STRING,  MAX_IDS_LEN,
                        term_string},
      {L"/address", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &a_flag},
      {L"/server",  TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN, ServerName},
      {L"/connect", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &c_flag},
      {L"/flow",    TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &f_flag},
      {L"/mode",    TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &m_flag},
      {L"/sm",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fSm},
      {L"/debug",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fDebug},
      {L"/vm",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fVm},
      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT),
                          &help_flag},
      {L"/counter", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT),
                          &counter_flag},
      {0, 0, 0, 0, 0}
};

#define MAX_PRINTFOA_BUFFER_SIZE 1024
char g_pWinStationName[MAX_PRINTFOA_BUFFER_SIZE];
char g_pConnectState[MAX_PRINTFOA_BUFFER_SIZE];
char g_pszState[MAX_PRINTFOA_BUFFER_SIZE];
char g_pDeviceName[MAX_PRINTFOA_BUFFER_SIZE];
char g_pWdDLL[MAX_PRINTFOA_BUFFER_SIZE];
char g_pClientName[MAX_PRINTFOA_BUFFER_SIZE];
char g_pClientAddress[MAX_PRINTFOA_BUFFER_SIZE];
char g_pUserName[MAX_PRINTFOA_BUFFER_SIZE];

WINSTATIONINFORMATION g_WinInfo;
WDCONFIG g_WdInfo;
WINSTATIONCONFIG g_WinConf;
PDCONFIG g_PdConf;
WINSTATIONCLIENT g_ClientConf;
PDPARAMS g_PdParams;
DEVICENAME g_DeviceName;

/*
 * Local function prototypes
 */
BOOLEAN PrintWinStationInfo( PLOGONID pWd, int WdCount );
PWCHAR GetState( WINSTATIONSTATECLASS );
void DisplayBaud( ULONG BaudRate );
void DisplayParity( ULONG Parity );
void DisplayDataBits( ULONG DataBits );
void DisplayStopBits( ULONG StopBits );
void DisplayConnect( ASYNCCONNECTCLASS ConnectFlag, USHORT header_flag );
void DisplayFlow( PFLOWCONTROLCONFIG pFlow, USHORT header_flag );
void DisplayLptPorts( BYTE LptMask, USHORT header_flag );
void DisplayComPorts( BYTE ComMask, USHORT header_flag );
void OutputHeader( void );
void Usage( BOOLEAN bError );

/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    PLOGONID pWd;
    ULONG ByteCount, Index;
    UINT WdCount;
    ULONG Status;
    int rc, i;
    WCHAR **argvW;
    BOOLEAN MatchedOne = FALSE;
    BOOLEAN PrintWinStationInfo(PLOGONID pWd, int Count);

    TS_COUNTER TSCounters[3];

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, L"/server") ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

#if 0
    //
    // Print local WINSTATION VM info
    //
    if( fVm ) {
        PrintWinStationVmInfo();
        return( SUCCESS );
    }
#endif

    /*
     *  if no winstation was specified, display all winstations
     */
    if ( !(*term_string) )
        wcscpy( term_string, L"*" );

    /*
     *  Allocate buffer for WinStation ids
     */
    WdCount = 10;
    if ( (pWd = malloc( WdCount * sizeof(LOGONID) )) == NULL ) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        goto tscounters;
    }
    ByteCount = WdCount * sizeof(LOGONID);
    Index = 0; // Start enumeration from the begining

    /*
     *  get list of active WinStations
     */
    rc = WinStationEnumerate( hServerName, &pWd, &WdCount );
    if ( rc ) {

        if ( PrintWinStationInfo(pWd, WdCount) )
            MatchedOne = TRUE;

        WinStationFreeMemory(pWd);

        } else {

            Status = GetLastError();
        ErrorPrintf(IDS_ERROR_WINSTATION_ENUMERATE, Status);
        PutStdErr( Status, 0 );
        goto tscounters;
    }

    /*
     *  Check for at least one match
     */
    if ( !MatchedOne ) {
        StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, term_string);
        goto tscounters;
    }

tscounters:
    if (counter_flag) {
        TSCounters[0].counterHead.dwCounterID = TERMSRV_TOTAL_SESSIONS;
        TSCounters[1].counterHead.dwCounterID = TERMSRV_DISC_SESSIONS;
        TSCounters[2].counterHead.dwCounterID = TERMSRV_RECON_SESSIONS;

        rc = WinStationGetTermSrvCountersValue(hServerName, 3, TSCounters);

        if (rc) {
            if (TSCounters[0].counterHead.bResult == TRUE) {
                Message(IDS_TSCOUNTER_TOTAL_SESSIONS, TSCounters[0].dwValue);
            }

            if (TSCounters[1].counterHead.bResult == TRUE) {
                Message(IDS_TSCOUNTER_DISC_SESSIONS, TSCounters[1].dwValue);
            }

            if (TSCounters[2].counterHead.bResult == TRUE) {
                Message(IDS_TSCOUNTER_RECON_SESSIONS, TSCounters[2].dwValue);
            }
        }
        else {
            ErrorPrintf(IDS_ERROR_TERMSRV_COUNTERS);
        }
    }

    return(SUCCESS);

}  /* main() */


/******************************************************************************
 *
 * PrintWinStationInfo
 *
 *  Printout the WinStation Information for the WinStations described in
 *  the PLOGONID array.
 *
 *  ENTRY:
 *      pWd (input)
 *          pointer to array of LOGONID structures.
 *      WdCount (input)
 *          number of elements in the pWd array.
 *
 *  EXIT:
 *      TRUE if at least one WinStation was output; FALSE if none.
 *
 *****************************************************************************/

BOOLEAN
PrintWinStationInfo( PLOGONID pWd,
                     int WdCount )
{
    int i, rc;
    ULONG ErrorCode;
    ULONG ReturnLength;
    PWCHAR pState;
    UINT MatchedOne = FALSE;
    static UINT HeaderFlag = FALSE;


    /*
     *  Output terminal ids
     */
    for ( i=0; i < WdCount; i++ ) {

        if ( fSm || fDebug ) {
            {
                WideCharToMultiByte(CP_OEMCP, 0,
                                    pWd[i].WinStationName, -1,
                                    g_pWinStationName, sizeof(g_pWinStationName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    GetState( pWd[i].State ), -1,
                                    g_pConnectState, sizeof(g_pConnectState),
                                    NULL, NULL);
                fprintf( stdout, "%4u %-20s  %s\n", pWd[i].LogonId, g_pWinStationName,
                         g_pConnectState );
            }
            if ( !fDebug )
                continue;
        }

        if ( !WinStationObjectMatch( hServerName , &pWd[i], term_string ) )
            continue;

        /*
         * Get all available information so we can pick out what we need as
         * well as verify the API's
         */
        memset( &g_WinInfo,    0, sizeof(WINSTATIONINFORMATION) );
        memset( &g_WdInfo,   0, sizeof(WDCONFIG) );
        memset( &g_WinConf,    0, sizeof(WINSTATIONCONFIG) );
        memset( &g_PdConf,    0, sizeof(PDCONFIG) );
        memset( &g_ClientConf, 0, sizeof(WINSTATIONCLIENT) );
        memset( &g_PdParams,  0, sizeof(PDPARAMS) );
        memset( &g_DeviceName, 0, sizeof(DEVICENAME) );

        /*
         * If this WinStation is 'down', don't open and query.
         */
        if ( pWd[i].State == State_Init || pWd[i].State == State_Down ) {

            g_WinInfo.ConnectState = pWd[i].State;

        } else {

            /*
             * Query WinStation's information.
             */
            rc = WinStationQueryInformation( hServerName,
                                             pWd[i].LogonId,
                                             WinStationInformation,
                                             (PVOID)&g_WinInfo,
                                             sizeof(WINSTATIONINFORMATION),
                                             &ReturnLength);

            if( !rc ) {
                continue;
            }

            if( ReturnLength != sizeof(WINSTATIONINFORMATION) ) {
                ErrorPrintf(IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH,
                             L"WinStationInformation",
                             ReturnLength, sizeof(WINSTATIONINFORMATION));
                continue;
            }

            rc = WinStationQueryInformation( hServerName,
                                             pWd[i].LogonId,
                                             WinStationWd,
                                             (PVOID)&g_WdInfo,
                                             sizeof(WDCONFIG),
                                             &ReturnLength);
            if( !rc ) {
                continue;
            }

            if( ReturnLength != sizeof(WDCONFIG) ) {
                ErrorPrintf(IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH,
                             L"WinStationWd",
                             ReturnLength, sizeof(WDCONFIG));
                continue;
            }

            rc = WinStationQueryInformation( hServerName,
                                             pWd[i].LogonId,
                                             WinStationConfiguration,
                                             (PVOID)&g_WinConf,
                                             sizeof(WINSTATIONCONFIG),
                                             &ReturnLength);
            if( !rc ) {
                continue;
            }

            if( ReturnLength != sizeof(WINSTATIONCONFIG) ) {
                ErrorPrintf(IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH,
                             L"WinStationConfiguration",
                             ReturnLength, sizeof(WINSTATIONCONFIG));
                continue;
            }

            rc = WinStationQueryInformation( hServerName,
                                             pWd[i].LogonId,
                                             WinStationPd,
                                             (PVOID)&g_PdConf,
                                             sizeof(PDCONFIG),
                                             &ReturnLength);
            if( !rc ) {
                continue;
            }

            if( ReturnLength != sizeof(PDCONFIG) ) {
                ErrorPrintf(IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH,
                            L"WinStationPd",
                            ReturnLength, sizeof(PDCONFIG));
                continue;
            }

            rc = WinStationQueryInformation( hServerName,
                                             pWd[i].LogonId,
                                             WinStationClient,
                                             (PVOID)&g_ClientConf,
                                             sizeof(WINSTATIONCLIENT),
                                             &ReturnLength);
            if( !rc ) {
                continue;
            }

            if( ReturnLength != sizeof(WINSTATIONCLIENT) ) {
                ErrorPrintf(IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH,
                            L"WinStationClient",
                            ReturnLength, sizeof(WINSTATIONCLIENT));
                continue;
            }

            rc = WinStationQueryInformation( hServerName,
                                             pWd[i].LogonId,
                                             WinStationPdParams,
                                             (PVOID)&g_PdParams,
                                             sizeof(PDPARAMS),
                                             &ReturnLength);
            if( !rc ) {
                continue;
            }

            if( ReturnLength != sizeof(PDPARAMS) ) {
                ErrorPrintf(IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH,
                            L"WinStationPdParams",
                            ReturnLength, sizeof(PDPARAMS));
                continue;
            }
        }

        /*
         * If this is a PdAsync Protocol, get the device name to display.
         */
        if ( g_PdParams.SdClass == SdAsync )
            wcscpy( g_DeviceName, g_PdParams.Async.DeviceName );

        /*
         * Flag sucessful match.
         */
        MatchedOne = TRUE;

        /*
         * trucate and convert to lower case
         */
        TruncateString( _wcslwr(g_WinInfo.WinStationName), 16 );
        TruncateString( _wcslwr(g_WdInfo.WdName), 8 );
        TruncateString( _wcslwr(g_DeviceName), 8 );
        TruncateString( _wcslwr(g_WdInfo.WdDLL), 13 );

        /*
         * Determine WinStation state
         */
        pState = GetState( g_WinInfo.ConnectState );

        /*
         * output header
         */
        if ( !HeaderFlag ) {
            HeaderFlag = TRUE;
            OutputHeader();
        }

        /*
         * identify current terminal
         */
        if ( (hServerName == SERVERNAME_CURRENT) && (pWd[i].LogonId == GetCurrentLogonId() ) )
            wprintf( L">" );
        else
                wprintf( L" " );

        if ( m_flag ) {
            {

                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WinInfo.WinStationName, -1,
                                    g_pWinStationName, sizeof(g_pWinStationName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    pState, -1,
                                    g_pszState, sizeof(g_pszState),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_DeviceName, -1,
                                    g_pDeviceName, sizeof(g_pDeviceName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WdInfo.WdDLL, -1,
                                    g_pWdDLL, sizeof(g_pWdDLL),
                                    NULL, NULL);
                fprintf(stdout , FORMAT_M, g_pWinStationName, g_pszState,
                       g_pDeviceName, g_pWdDLL );
            }
            DisplayBaud( g_PdParams.Async.BaudRate );
            DisplayParity( g_PdParams.Async.Parity );
            DisplayDataBits( g_PdParams.Async.ByteSize );
            DisplayStopBits( g_PdParams.Async.StopBits );
            wprintf( L"\n" );
            if ( f_flag ) {
                DisplayFlow( &g_PdParams.Async.FlowControl, TRUE );
                wprintf( L"\n" );
            }
            if ( c_flag ) {
                DisplayConnect( g_PdParams.Async.Connect.Type, TRUE );
                wprintf( L"\n" );
            }
            fflush( stdout );
        } else if ( f_flag && c_flag ) {
            {
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WinInfo.WinStationName, -1,
                                    g_pWinStationName, sizeof(g_pWinStationName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_DeviceName, -1,
                                    g_pDeviceName, sizeof(g_pDeviceName),
                                    NULL, NULL);
                fprintf(stdout,FORMAT_F_C, g_pWinStationName, g_pDeviceName );
            }
            DisplayFlow( &g_PdParams.Async.FlowControl, FALSE );
            DisplayConnect( g_PdParams.Async.Connect.Type, FALSE );
            wprintf( L"\n" );
            fflush( stdout );
        } else if ( c_flag ) {
            {
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WinInfo.WinStationName, -1,
                                    g_pWinStationName, sizeof(g_pWinStationName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    pState, -1,
                                    g_pszState, sizeof(g_pszState),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_DeviceName, -1,
                                    g_pDeviceName, sizeof(g_pDeviceName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WdInfo.WdDLL, -1,
                                    g_pWdDLL, sizeof(g_pWdDLL),
                                    NULL, NULL);
                fprintf(stdout,FORMAT_C, g_pWinStationName, g_pszState,
                       g_pDeviceName, g_pWdDLL );
            }
            DisplayConnect( g_PdParams.Async.Connect.Type, FALSE );
            wprintf( L"\n" );
            fflush(stdout);
        } else if ( f_flag ) {
            {
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WinInfo.WinStationName, -1,
                                    g_pWinStationName, sizeof(g_pWinStationName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    pState, -1,
                                    g_pszState, sizeof(g_pszState),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_DeviceName, -1,
                                    g_pDeviceName, sizeof(g_pDeviceName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WdInfo.WdDLL, -1,
                                    g_pWdDLL, sizeof(g_pWdDLL),
                                    NULL, NULL);
                fprintf(stdout,FORMAT_F, g_pWinStationName, g_pszState,
                       g_pDeviceName, g_pWdDLL );
            }
            DisplayFlow( &g_PdParams.Async.FlowControl, FALSE );
            wprintf( L"\n" );
            fflush(stdout);
        } else {
            {
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WinInfo.WinStationName, -1,
                                    g_pWinStationName, sizeof(g_pWinStationName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WinInfo.UserName, -1,
                                    g_pUserName, sizeof(g_pUserName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    pState, -1,
                                    g_pszState, sizeof(g_pszState),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_DeviceName, -1,
                                    g_pDeviceName, sizeof(g_pDeviceName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WdInfo.WdDLL, -1,
                                    g_pWdDLL, sizeof(g_pWdDLL),
                                    NULL, NULL);
                fprintf(stdout,FORMAT_DEFAULT, g_pWinStationName,
                       g_pUserName, pWd[i].LogonId, g_pszState,
                       g_pWdDLL, g_pDeviceName);
            }
            fflush(stdout);
        }

    } // end for(;;)

    return( MatchedOne || fSm );

}  /* PrintWinStationInfo() */


/*******************************************************************************
 *
 *  GetState
 *
 *  This routine returns a pointer to a string describing the
 *  current WinStation state.
 *
 *  ENTRY:
 *     State (input)
 *        winstation state
 *
 *  EXIT:
 *     pointer to state string
 *
 ******************************************************************************/

PWCHAR
GetState( WINSTATIONSTATECLASS State )
{
    PWCHAR pState;


    pState = (PWCHAR) StrConnectState(State,TRUE);
/*
    switch ( State ) {

        case State_Active :
            pState = L"active";
            break;

        case State_Connected :
            pState = L"conn";
            break;

        case State_ConnectQuery :
            pState = L"connQ";
            break;

        case State_Shadow :
            pState = L"shadow";
            break;

        case State_Disconnected :
            pState = L"disc";
            break;

        case State_Idle :
            pState = L"idle";
            break;

        case State_Reset :
            pState = L"reset";
            break;

        case State_Down :
            pState = L"down";
            break;

        case State_Init :
            pState = L"init";
            break;

        case State_Listen :
            pState = L"listen";
            break;

        default :
            pState = L"unknown";
            break;
    }
*/
    return( pState );
}


/*******************************************************************************
 *
 *  DisplayBaud
 *
 *  This routine displays the baud rate
 *
 *
 *  ENTRY:
 *     BaudRate (input)
 *        baud rate
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayBaud( ULONG BaudRate )
{
    if ( BaudRate > 0 )
        wprintf( L"%6lu  ", BaudRate );
    else
        wprintf( L"        " );
    fflush( stdout );

}  /* DisplayBaud() */


/*******************************************************************************
 *
 *  DisplayParity
 *
 *  This routine displays parity
 *
 *
 *  ENTRY:
 *     Parity (input)
 *        parity
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayParity( ULONG Parity )
{
    WCHAR szParity[64] = L"";

    switch ( Parity ) {
    case 0 :
    case 1 :
    case 2 :
        //
        //  How does one handle a LoadString failure??? I choose to initialize
        //  the storage to an empty string, and then ignore any failure.
        //
        LoadString(NULL, IDS_PARITY_NONE + Parity, szParity,
                   sizeof(szParity) / sizeof(WCHAR));
        wprintf( szParity );
        break;

    default :
        LoadString(NULL, IDS_PARITY_BLANK, szParity,
                   sizeof(szParity) / sizeof(WCHAR));
        wprintf( szParity );
        break;
    }
    fflush( stdout );

}  /* DisplayParity() */


/*******************************************************************************
 *
 *  DisplayDataBits
 *
 *  This routine displays number of data bits
 *
 *
 *  ENTRY:
 *     DataBits (input)
 *        data bits
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayDataBits( ULONG DataBits )
{
    WCHAR szDataBits[64] = L"";

    //
    //  How does one handle a LoadString failure??? I choose to initialize
    //  the storage to an empty string, and then ignore any failure. The
    //  wprintf below, with an extra argument, won't cause any problems
    //  if the LoadString fails.
    //
    if ( DataBits > 0 )
    {
        LoadString(NULL, IDS_DATABITS_FORMAT, szDataBits,
                   sizeof(szDataBits) / sizeof(WCHAR));
        wprintf( szDataBits , DataBits );
    }
    else
    {
        LoadString(NULL, IDS_DATABITS_BLANK, szDataBits,
                   sizeof(szDataBits) / sizeof(WCHAR));
        wprintf( szDataBits );
    }
    fflush( stdout );

}  /* DisplayDataBits() */


/*******************************************************************************
 *
 *  DisplayStopBits
 *
 *  This routine displays the number of stop bits
 *
 *
 *  ENTRY:
 *     StopBits (input)
 *        number of stop bits
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayStopBits( ULONG StopBits )
{
    WCHAR szStopBits[64] = L"";

    switch ( StopBits ) {
    case 0 :
    case 1 :
    case 2 :
        //
        //  How does one handle a LoadString failure??? I choose to initialize
        //  the storage to an empty string, and then ignore any failure.
        //
        LoadString(NULL, IDS_STOPBITS_ONE + StopBits, szStopBits,
                   sizeof(szStopBits) / sizeof(WCHAR));
        wprintf( szStopBits );
        break;

    default :
        LoadString(NULL, IDS_STOPBITS_BLANK, szStopBits,
                   sizeof(szStopBits) / sizeof(WCHAR));
        wprintf( szStopBits );
        break;
    }
    fflush( stdout );

}  /* DisplayStopBits() */


/*******************************************************************************
 *
 *  DisplayConnect
 *
 *  This routine displays the connect settings
 *
 *
 *  ENTRY:
 *     ConnectFlag (input)
 *        connect flags
 *      header_flag (input)
 *          TRUE to display sub-header; FALSE otherwise.
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayConnect( ASYNCCONNECTCLASS ConnectFlag,
                USHORT header_flag )
{
    WCHAR buffer[80] = L"";

    //
    //  How does one handle a LoadString failure??? I choose to initialize
    //  the storage to an empty string, and then ignore any failure. The
    //  wprintf below, with an extra argument, won't cause any problems
    //  if the LoadString fails.
    //
    if ( header_flag )
    {
        LoadString(NULL, IDS_CONNECT_HEADER, buffer, sizeof(buffer) / sizeof(WCHAR));
        wprintf(buffer);
    }

    buffer[0] = (WCHAR)NULL;

    LoadString(NULL, IDS_CONNECT_FORMAT, buffer, sizeof(buffer) / sizeof(WCHAR));
    wprintf( buffer, StrAsyncConnectState(ConnectFlag) );
    fflush( stdout );

}  /* DisplayConnect() */


/*******************************************************************************
 *
 *  DisplayFlow
 *
 *  This routine displays the flow control settings
 *
 *
 *  ENTRY:
 *      pFlow (input)
 *          Pointer to flow control configuration structure
 *      header_flag (input)
 *          TRUE to display sub-header; FALSE otherwise.
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayFlow( PFLOWCONTROLCONFIG pFlow,
             USHORT header_flag )
{
    WCHAR buffer[90], buf2[90], format[90];

    buffer[0] = 0;
    buf2[0] = 0;
    format[0] = 0;

    //
    //  How does one handle a LoadString failure??? I choose to initialize
    //  the storage to an empty string, and then ignore any failure. The
    //  wprintf below, with an extra argument, won't cause any problems
    //  if the LoadString fails.
    //
    if ( header_flag )
    {
        LoadString(NULL, IDS_FLOW_HEADER, buffer, sizeof(buffer) / sizeof(WCHAR));
        wprintf(buffer);
    }

    buffer[0] = (WCHAR)NULL;

    if( pFlow->fEnableDTR )
    {
        LoadString(NULL, IDS_FLOW_ENABLE_DTR, buf2, sizeof(buf2) / sizeof(WCHAR));
        wcscat(buffer, buf2);
    }

    buf2[0] = (WCHAR)NULL;

    if( pFlow->fEnableRTS )
    {
        LoadString(NULL, IDS_FLOW_ENABLE_DTR, buf2, sizeof(buf2) / sizeof(WCHAR));
        wcscat(buffer, buf2);
    }

    buf2[0] = (WCHAR)NULL;

    /*
     * Hardware and Software flow control are mutually exclusive
     */

    if( pFlow->Type == FlowControl_Hardware ) {

        if ( pFlow->HardwareReceive == ReceiveFlowControl_None )
        {
            LoadString(NULL, IDS_FLOW_RECEIVE_NONE, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }
        else if ( pFlow->HardwareReceive == ReceiveFlowControl_RTS )
        {
            LoadString(NULL, IDS_FLOW_RECEIVE_RTS, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }
        else if ( pFlow->HardwareReceive == ReceiveFlowControl_DTR )
        {
            LoadString(NULL, IDS_FLOW_RECEIVE_DTR, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }

        wcscat(buffer, buf2);
        buf2[0] = (WCHAR)NULL;

        if ( pFlow->HardwareTransmit == TransmitFlowControl_None )
        {
            LoadString(NULL, IDS_FLOW_TRANSMIT_NONE, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }
        else if ( pFlow->HardwareTransmit == TransmitFlowControl_CTS )
        {
            LoadString(NULL, IDS_FLOW_TRANSMIT_CTS, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }
        else if ( pFlow->HardwareTransmit == TransmitFlowControl_DSR )
        {
            LoadString(NULL, IDS_FLOW_TRANSMIT_DSR, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }

        wcscat(buffer, buf2);

    } else if ( pFlow->Type == FlowControl_Software ) {

        if ( pFlow->fEnableSoftwareTx )
        {
            LoadString(NULL, IDS_FLOW_SOFTWARE_TX, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }

        wcscat(buffer, buf2);
        buf2[0] = (WCHAR)NULL;

        if( pFlow->fEnableSoftwareRx )
        {
            LoadString(NULL, IDS_FLOW_SOFTWARE_TX, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }

        wcscat(buffer, buf2);
        buf2[0] = (WCHAR)NULL;

        if ( pFlow->XonChar == 0x65 && pFlow->XoffChar == 0x67 )
        {
            LoadString(NULL, IDS_FLOW_SOFTWARE_TX, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }
        else if( pFlow->fEnableSoftwareTx || pFlow->fEnableSoftwareRx )
        {
            LoadString(NULL, IDS_FLOW_SOFTWARE_TX, format,
                       sizeof(format) / sizeof(WCHAR));
            wsprintf( buf2, format, pFlow->XonChar, pFlow->XoffChar );
            format[0] = (WCHAR)NULL;
        }

        wcscat( buffer, buf2 );
    }

    LoadString(NULL, IDS_FLOW_FORMAT, format, sizeof(format) / sizeof(WCHAR));
    wprintf( format, buffer );
    fflush( stdout );

}  /* DisplayFlow() */


/*******************************************************************************
 *
 *  DisplayLptPorts
 *
 *  This routine displays the LPT ports that exist for a winstation
 *
 *
 *  ENTRY:
 *      LptMask (input)
 *          LPT port mask
 *      header_flag (input)
 *          TRUE to display sub-header; FALSE otherwise.
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayLptPorts( BYTE LptMask,
                USHORT header_flag )
{
    WCHAR buffer[80], buf2[10], lptname[6];
    int i;

    buffer[0] = 0;
    buf2[0] = 0;
    lptname[0] = 0;

    //
    //  How does one handle a LoadString failure??? I choose to initialize
    //  the storage to an empty string, and then ignore any failure. The
    //  wprintf below, with an extra argument, won't cause any problems
    //  if the LoadString fails.
    //
    if ( header_flag )
    {
        LoadString(NULL, IDS_LPT_HEADER, buffer, sizeof(buffer) / sizeof(WCHAR));
        wprintf(buffer);
    }

    buffer[0] = (WCHAR)NULL;

    LoadString(NULL, IDS_LPT_FORMAT, buf2, sizeof(buf2) / sizeof(WCHAR));

    /*
     * Display from the 8 possible LPT ports.
     */
    for ( i=0; i < 8; i++ ) {
        if ( LptMask & (1<<i) ) {
            wsprintf( lptname, buf2, i+1 );
            wcscat( buffer, lptname );
        }
    }

    wprintf( buffer );
    fflush( stdout );

}  /* DisplayLptPorts() */


/*******************************************************************************
 *
 *  DisplayComPorts
 *
 *  This routine displays the COM ports that exist for a winstation
 *
 *
 *  ENTRY:
 *      ComMask (input)
 *          COM port mask
 *      header_flag (input)
 *          TRUE to display sub-header; FALSE otherwise.
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayComPorts( BYTE ComMask,
                 USHORT header_flag )
{
    WCHAR buffer[80], buf2[10], comname[6];
    int i;

    buffer[0] = 0;
    buf2[0] = 0;
    comname[0] = 0;

    //
    //  How does one handle a LoadString failure??? I choose to initialize
    //  the storage to an empty string, and then ignore any failure. The
    //  wprintf below, with an extra argument, won't cause any problems
    //  if the LoadString fails.
    //
    if ( header_flag )
    {
        LoadString(NULL, IDS_COM_HEADER, buffer, sizeof(buffer) / sizeof(WCHAR));
        wprintf(buffer);
    }

    buffer[0] = (WCHAR)NULL;

    LoadString(NULL, IDS_COM_FORMAT, buf2, sizeof(buf2) / sizeof(WCHAR));

    /*
     * Display from the 8 possible LPT ports.
     */
    for ( i=0; i < 8; i++ ) {
        if ( ComMask & (1<<i) ) {
            wsprintf( comname, buf2, i+1 );
            wcscat( buffer, comname );
        }
    }

    wprintf( buffer );
    fflush( stdout );

}  /* DisplayComPorts() */


/*******************************************************************************
 *
 *  OutputHeader
 *
 *  output header
 *
 *
 *  ENTRY:
 *     nothing
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
OutputHeader( void )
{
    if ( a_flag ) {

        Message(IDS_HEADER_A);

    } else if ( m_flag ) {

        Message(IDS_HEADER_M);

    } else if ( f_flag && c_flag ) {

        Message(IDS_HEADER_F_C);

    } else if ( c_flag ) {

        Message(IDS_HEADER_C);

    } else if ( f_flag ) {

        Message(IDS_HEADER_F);

    } else {

        Message(IDS_HEADER_DEFAULT);

    }
    fflush(stdout);

}  /* OutputHeader() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_HELP_USAGE1);
        ErrorPrintf(IDS_HELP_USAGE2);
        ErrorPrintf(IDS_HELP_USAGE3);
        ErrorPrintf(IDS_HELP_USAGE4);
        ErrorPrintf(IDS_HELP_USAGE5);
        ErrorPrintf(IDS_HELP_USAGE6);
        ErrorPrintf(IDS_HELP_USAGE7);
        ErrorPrintf(IDS_HELP_USAGE8);
        ErrorPrintf(IDS_HELP_USAGE9);
        ErrorPrintf(IDS_HELP_USAGE10);
        ErrorPrintf(IDS_HELP_USAGE11);
    } else {
        Message(IDS_HELP_USAGE1);
        Message(IDS_HELP_USAGE2);
        Message(IDS_HELP_USAGE3);
        Message(IDS_HELP_USAGE4);
        Message(IDS_HELP_USAGE5);
        Message(IDS_HELP_USAGE6);
        Message(IDS_HELP_USAGE7);
        Message(IDS_HELP_USAGE8);
        Message(IDS_HELP_USAGE9);
        Message(IDS_HELP_USAGE10);
        Message(IDS_HELP_USAGE11);
    }

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qwinsta\qwinsta.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*  QWINSTA.H
*     This module contains typedefs and defines required for
*     the QWINSTA utility.
*
*
*************************************************************************/

/*
 * Header and format string definitions.
 */

//L" SESSIONNAME       CLIENT NAME           TRANSPORT  ADDRESS\n"
// 1234567890123456  12345678901234567890  1234567    1234567890123...

#define FORMAT_A \
 "%-16s  %-20s  %-7s    %-24s  "

//L" SESSIONNAME       STATE   DEVICE    TYPE             BAUD  PARITY  DATA  STOP\n"
// 1234567890123456  123456  12345678  1234567890123  123456  1234       1     1

#define FORMAT_M \
 "%-16s  %-6s  %-8s  %-13s  "

//L" SESSIONNAME       DEVICE    FLOW CONTROL               CONNECT\n"
// 1234567890123456  12345678  1234567890123456789012345  12345678901234567890

#define FORMAT_F_C \
 "%-16s  %-8s  "

//L" SESSIONNAME       STATE   DEVICE    TYPE           CONNECT\n"
// 1234567890123456  123456  12345678  1234567890123  CTS DSR RING DCD CHAR BRK AUTO

#define FORMAT_C \
 "%-16s  %-6s  %-8s  %-13s  "

//L" SESSIONNAME       STATE   DEVICE    TYPE           FLOW CONTROL\n"
// 1234567890123456  123456  12345678  1234567890123  XON DUP RTS RTSH DTR DTRH CTSH DSRH DCDH DSRS

#define FORMAT_F \
 "%-16s  %-6s  %-8s  %-13s  "

//L" SESSIONNAME       USERNAME                ID  STATE   TYPE        DEVICE \n"
// 1234567890123456  12345678901234567890  1234  123456  1234567890  12345678

#define FORMAT_DEFAULT \
 "%-16s  %-20s  %5d  %-6s  %-10s  %-8s\n"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_ENUMERATE                  102
#define IDS_ERROR_WINSTATION_NOT_FOUND                  103
#define IDS_ERROR_WINSTATION_OPEN                       104
#define IDS_ERROR_WINSTATION_GET_INFORMATION            105
#define IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH      106
#define IDS_ERROR_SERVER                                107
#define IDS_ERROR_INFORMATION                           108
#define IDS_VMINFO1	                                    109
#define IDS_VMINFO2	                                    110
#define IDS_VMINFO3	                                    111
#define IDS_VMINFO4	                                    112
#define IDS_VMINFO5	                                    113
#define IDS_HELP_USAGE1                                 114
#define IDS_HELP_USAGE2                                 115
#define IDS_HELP_USAGE3                                 116
#define IDS_HELP_USAGE4                                 117
#define IDS_HELP_USAGE5                                 118
#define IDS_HELP_USAGE6                                 119
#define IDS_HELP_USAGE7                                 120
#define IDS_HELP_USAGE8                                 121
#define IDS_HELP_USAGE9                                 122
#define IDS_HELP_USAGE10                                123
#define IDS_HEADER_A                                    124
#define IDS_HEADER_M                                    125
#define IDS_HEADER_F_C                                  126
#define IDS_HEADER_C                                    127
#define IDS_HEADER_F                                    128
#define IDS_HEADER_DEFAULT                              129
#define IDS_ERROR_NOT_TS                                130
#define IDS_ERROR_TERMSRV_COUNTERS                      131
#define IDS_TSCOUNTER_TOTAL_SESSIONS                    132
#define IDS_TSCOUNTER_DISC_SESSIONS                     133
#define IDS_TSCOUNTER_RECON_SESSIONS                    134
#define IDS_HELP_USAGE11                                135
#define IDS_PARITY_NONE                                 136
#define IDS_PARITY_ODD                                  137
#define IDS_PARITY_EVEN                                 138
#define IDS_PARITY_BLANK                                139
#define IDS_DATABITS_FORMAT                             140
#define IDS_DATABITS_BLANK                              141
#define IDS_STOPBITS_ONE                                142
#define IDS_STOPBITS_ONEANDHALF                         143
#define IDS_STOPBITS_TWO                                144
#define IDS_STOPBITS_BLANK                              145
#define IDS_CONNECT_HEADER                              146
#define IDS_CONNECT_FORMAT                              147
#define IDS_FLOW_HEADER                                 148
#define IDS_FLOW_FORMAT                                 149
#define IDS_FLOW_ENABLE_DTR                             150
#define IDS_FLOW_ENABLE_RTS                             151
#define IDS_FLOW_RECEIVE_NONE                           152
#define IDS_FLOW_RECEIVE_RTS                            153
#define IDS_FLOW_RECEIVE_DTR                            154
#define IDS_FLOW_TRANSMIT_NONE                          155
#define IDS_FLOW_TRANSMIT_CTS                           156
#define IDS_FLOW_TRANSMIT_DSR                           157
#define IDS_FLOW_SOFTWARE_TX                            158
#define IDS_FLOW_SOFTWARE_RX                            159
#define IDS_FLOW_SOFTWARE_XPC                           160
#define IDS_FLOW_SOFTWARE_XON_XOFF                      161
#define IDS_LPT_HEADER                                  162
#define IDS_LPT_FORMAT                                  163
#define IDS_COM_HEADER                                  164
#define IDS_COM_FORMAT                                  165
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\quser\quser.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  QUSER.C
*
*  query user information
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winstaw.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <printfoa.h>

#include "quser.h"

HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];
WCHAR user_string[MAX_IDS_LEN+1];
USHORT help_flag   = FALSE;
ULONG CurrentLogonId = (ULONG) -1;
BOOLEAN MatchedOne = FALSE;

TOKMAP ptm[] = {
      {L" ",       TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, user_string},
      {L"/server", TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN, ServerName},
      {L"/?",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN,sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};

/*
 * Local function prototypes.
 */
void DisplayLastInputTime( LARGE_INTEGER * pCurrentTime, LARGE_INTEGER * pTime );
void DisplayUserInfo( HANDLE hServer , PLOGONID pId, PWCHAR pMatchName );
void Usage( BOOLEAN bError );




/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    PLOGONID pLogonId;
    UINT  TermCount;
    ULONG Status;
    ULONG rc;
    WCHAR **argvW;
    int i;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, L"/server") ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     *  if no user input, then default to all usernames on system
     */
    if ( !(*user_string) )
        wcscpy( user_string, L"*" );

    /*
     *  Get current LogonId
     */
    CurrentLogonId = GetCurrentLogonId();

    /*
     *  Get list of active WinStations & display user info.
     */
    if ( WinStationEnumerate( hServerName, &pLogonId, &TermCount) ) {

        for ( i=0; i< (int)TermCount; i++ )
            DisplayUserInfo( hServerName , &pLogonId[i], user_string );

        WinStationFreeMemory(pLogonId);

    } else {

        Status = GetLastError();
        ErrorPrintf(IDS_ERROR_WINSTATION_ENUMERATE, Status);
        PutStdErr( Status, 0 );
        return(FAILURE);
    }

    /*
     *  Check for at least one match
     */
    if ( !MatchedOne ) {
        StringErrorPrintf(IDS_ERROR_USER_NOT_FOUND, user_string);
        return(FAILURE);
    }

    return(SUCCESS);
}


/*******************************************************************************
 *
 *  DisplayTime
 *
 *  This routine displays time
 *
 *
 *  ENTRY:
 *     pTime (input)
 *        pointer to system time
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayTime( LARGE_INTEGER * pTime )
{
    FILETIME LocalTime;
    SYSTEMTIME stime;
    LPTSTR lpTimeStr;
        int nLen;
        TCHAR TimeString[MAX_DATE_TIME_LENGTH];

    if ( FileTimeToLocalFileTime( (FILETIME*)pTime, &LocalTime ) &&
         FileTimeToSystemTime( &LocalTime, &stime ) ) {

//NBD
//        wprintf( L"%02d/%02d/%02d %02d:%02d",
//              stime.wMonth, stime.wDay, stime.wYear % 100,
//              stime.wHour, stime.wMinute );
//
        //Get DateFormat
        nLen = GetDateFormat(
                            LOCALE_USER_DEFAULT,
                            DATE_SHORTDATE,
                            &stime,
                            NULL,
                            NULL,
                            0);
            if (nLen == 0)
        {
            goto unknowntime;
        }
        lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));
        if (lpTimeStr == NULL)
        {
            goto unknowntime;
        }
            nLen = GetDateFormat(
                            LOCALE_USER_DEFAULT,
                            DATE_SHORTDATE,
                            &stime,
                            NULL,
                            lpTimeStr,
                            nLen);
        if (nLen == 0)
        {
            goto unknowntime;
        }
            wcscpy(TimeString, lpTimeStr);
        wcscat(TimeString, L" ");
            GlobalFree(lpTimeStr);

            //Get Time Format
            nLen = GetTimeFormat(
                            LOCALE_USER_DEFAULT,
                            TIME_NOSECONDS,
                            &stime,
                            NULL,
                            NULL,
                            0);
        if (nLen == 0)
        {
            goto unknowntime;
        }
            lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));
        if (lpTimeStr == NULL)
        {
            goto unknowntime;
        }
            nLen = GetTimeFormat(
                            LOCALE_USER_DEFAULT,
                            TIME_NOSECONDS,
                            &stime,
                            NULL,
                            lpTimeStr,
                            nLen);
        if (nLen == 0)
        {
            goto unknowntime;
        }
            wcscat(TimeString, lpTimeStr);
            GlobalFree(lpTimeStr);
        wprintf(TimeString );
        return;

unknowntime:
        // Use a localized "unknown" string if at all possible
        wprintf(GetUnknownString() ? GetUnknownString() : L"Unknown");
        return;
    }

}  /* DisplayTime() */


/*******************************************************************************
 *
 *  DisplayLastInputTime
 *
 *  This routine displays the time of last terminal input
 *
 *
 *  ENTRY:
 *     pCurrentTime
 *        pointer to current system time
 *     pTime (input)
 *        pointer to system time of last input
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayLastInputTime( LARGE_INTEGER * pCurrentTime, LARGE_INTEGER * pTime )
{
    LARGE_INTEGER InputTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER DiffTime;
    ULONG d_time;
    ULONG minutes;
    ULONG hours;
    ULONG days;
    WCHAR buf[40];

    if ( (pTime->HighPart == 0 && pTime->LowPart == 0 ) ||
         (pCurrentTime->HighPart == 0 && pCurrentTime->LowPart == 0 ) ) {
        goto badtime;
    }

    /*
     *  Get the number of seconds since last input
     */
    DiffTime = RtlLargeIntegerSubtract( *pCurrentTime, *pTime );
    DiffTime = RtlExtendedLargeIntegerDivide( DiffTime, 10000000, NULL );
    d_time = DiffTime.LowPart;

    /*
     *  Get the number of 'days:hours:minutes' since last input
     */
    days    = (USHORT)(d_time / 86400L); // days since last input
    d_time  = d_time % 86400L;           // seconds into partial day
    hours   = (USHORT)(d_time / 3600L);  // hours since last input
    d_time  = d_time % 3600L;            // seconds into partial hour
    minutes = (USHORT)(d_time / 60L);    // minutes since last input

    /*
     *  Output
     */
    if ( days > 0 )
       wsprintf( buf, L"%u+%02u:%02u", days, hours, minutes );
    else if ( hours > 0 )
       wsprintf( buf, L"%u:%02u", hours, minutes );
    else if ( minutes > 0 )
       wsprintf( buf, L"%u", minutes );
    else
       wsprintf( buf, L"." );

    wprintf( L"%9s  ", buf );
    return;

    /*
     *  error returns
     */
 badtime:
    if (LoadString(NULL, IDS_NONE, buf, sizeof(buf) / sizeof( WCHAR ) ) != 0)
    {
        wprintf(buf);
    }
    else
    {
        wprintf( L"    none   " );
    }

}  /* DisplayLastInputTime() */


/*******************************************************************************
 *
 *  DisplayUserInfo
 *
 *  This routine displays user information for one user
 *
 *
 *  ENTRY:
 *     hServer ( input )
 *        handle to termsrv
 *     LogonId (input)
 *        window station id
 *     pUsername (input)
 *        user name to display (or winstation name)
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayUserInfo( HANDLE hServer , PLOGONID pId, PWCHAR pMatchName )
{
    WINSTATIONINFORMATION Info;
    ULONG Length;
    ULONG LogonId;

    LogonId = pId->LogonId;

    if( WinStationObjectMatch( hServer, pId, pMatchName ) ) {

        /*
         *  Query information
         */
        if ( !WinStationQueryInformation( hServer,
                                          LogonId,
                                          WinStationInformation,
                                          &Info,
                                          sizeof(Info),
                                          &Length ) ) {
            goto done;
        }

        if ( Info.UserName[0] == UNICODE_NULL )
            goto done;

        TruncateString( _wcslwr(Info.UserName), 20 );
        TruncateString( _wcslwr(Info.WinStationName), 15 );

        /*
         *  If first time - output title
         */
        if ( !MatchedOne ) {
            Message(IDS_TITLE);
            MatchedOne = TRUE;
        }

        /* output current */
        if ( (hServer == SERVERNAME_CURRENT) && (Info.LogonId == CurrentLogonId ) )
            wprintf( L">" );
        else
            wprintf( L" " );

        {
            #define MAX_PRINTFOA_BUFFER_SIZE 1024
            char pUserName[MAX_PRINTFOA_BUFFER_SIZE];
            char pWinStationName[MAX_PRINTFOA_BUFFER_SIZE];
            char pConnectState[MAX_PRINTFOA_BUFFER_SIZE];

            WideCharToMultiByte(CP_OEMCP, 0,
                                Info.UserName, -1,
                                pUserName, sizeof(pUserName),
                                NULL, NULL);
            WideCharToMultiByte(CP_OEMCP, 0,
                                Info.WinStationName, -1,
                                pWinStationName, sizeof(pWinStationName),
                                NULL, NULL);
            WideCharToMultiByte(CP_OEMCP, 0,
                                StrConnectState(Info.ConnectState, TRUE), -1,
                                pConnectState, sizeof(pConnectState),
                                NULL, NULL);
            fprintf( stdout,"%-20s  %-15s  ", pUserName,
                     (Info.ConnectState == State_Disconnected) ?
                        "" : pWinStationName );
            fprintf( stdout,"%4u  %-6s  ", Info.LogonId, pConnectState );
        }

        DisplayLastInputTime( &Info.CurrentTime, &Info.LastInputTime );

        DisplayTime( &Info.LogonTime );

        wprintf( L"\n" );

        }
done:
    return;

}  /* DisplayUserInfo() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_HELP_USAGE1);
        ErrorPrintf(IDS_HELP_USAGE2);
        ErrorPrintf(IDS_HELP_USAGE3);
        ErrorPrintf(IDS_HELP_USAGE4);
        ErrorPrintf(IDS_HELP_USAGE5);
        ErrorPrintf(IDS_HELP_USAGE6);
    } else {
        Message(IDS_HELP_USAGE1);
        Message(IDS_HELP_USAGE2);
        Message(IDS_HELP_USAGE3);
        Message(IDS_HELP_USAGE4);
        Message(IDS_HELP_USAGE5);
        Message(IDS_HELP_USAGE6);
    }

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\qprocess\qprocess.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  QPROCESS.C
*
*  query process information
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
// #include <ntddkbd.h>
// #include <ntddmou.h>
#include <winstaw.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <printfoa.h>
#include <allproc.h>

#include "qprocess.h"


HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];
WCHAR  match_string[MAX_IDS_LEN+2];
USHORT help_flag    = FALSE;
USHORT system_flag  = FALSE;
ULONG  ArgLogonId = (ULONG)(-1);
BOOLEAN MatchedOne = FALSE;

TOKMAP ptm[] = {
      {L" ",        TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN,
                        match_string},
      {L"/server",  TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,
                        ServerName},
      {L"/system",  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT),
                        &system_flag},
      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT),
                        &help_flag},
      {L"/ID",      TMFLAG_OPTIONAL, TMFORM_ULONG,  sizeof(ULONG),
                        &ArgLogonId },
      {0, 0, 0, 0, 0}
};


// From pstat.c
#define BUFFER_SIZE 32*1024

//
// This table contains common NT system programs that we do not want to display
// unless the user specifies /SYSTEM.
//
WCHAR *SysProcTable[] = {
    L"csrss.exe",
    L"smss.exe",
    L"screg.exe",
    L"lsass.exe",
    L"spoolss.exe",
    L"EventLog.exe",
    L"netdde.exe",
    L"clipsrv.exe",
    L"lmsvcs.exe",
    L"MsgSvc.exe",
    L"winlogon.exe",
    L"NETSTRS.EXE",
    L"nddeagnt.exe",
    L"wfshell.exe",
    L"chgcdm.exe",
    L"userinit.exe",
    NULL
    };

WCHAR *Empty = L" ";

/*
 * Local function prototypes
 */
VOID FormatAndDisplayProcessInfo( HANDLE hServer,
                                  PTS_SYS_PROCESS_INFORMATION ProcessInfo,
                                  PSID pUserSid,
                                  ULONG LogonId,
                                  ULONG CurrentLogonId);
BOOLEAN IsSystemProcess( PTS_SYS_PROCESS_INFORMATION,
                         PWCHAR );
BOOLEAN SystemProcess( INT,
                       PTS_SYS_PROCESS_INFORMATION,
                       PWCHAR );
void Usage( BOOLEAN bError );



/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    int rc;
    // WCHAR CurrWinStationName[WINSTATIONNAME_LENGTH]; -- not used.
    WCHAR CurrUserName[USERNAME_LENGTH];
    WCHAR **argvW;
    DWORD CurrentPid;
    ULONG LogonId, CurrentLogonId;
    PSID pUserSid;

    PTS_SYS_PROCESS_INFORMATION ProcessInfo;
    PCITRIX_PROCESS_INFORMATION CitrixInfo;


    PBYTE       pBuffer;
    ULONG       ByteCount;
    NTSTATUS    status;
    ULONG       NumberOfProcesses,j;
    PTS_ALL_PROCESSES_INFO  ProcessArray = NULL;
    int i;
    ULONG TotalOffset;
    DWORD dwError;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    match_string[0] = L'\0';
    rc = ParseCommandLine(argc-1, argvW+1, ptm, PCL_FLAG_NO_CLEAR_MEMORY);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, L"/server") ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }


    /*
     * Get the current users name
     */
    GetCurrentUserName( CurrUserName, USERNAME_LENGTH );
    _wcslwr( CurrUserName );
    OEM2ANSIW(CurrUserName, (USHORT)wcslen(CurrUserName));

    /*
     * Get current processes pid
     */
    CurrentPid = GetCurrentProcessId();

    /*
     * Get current WinStation name.
     
    GetCurrentWinStationName( CurrWinStationName, WINSTATIONNAME_LENGTH );
    _wcslwr( CurrWinStationName );
    OEM2ANSIW(CurrWinStationName, (USHORT)wcslen(CurrWinStationName));
    */

    /*
     * Get current LogonId.
     */
    CurrentLogonId = GetCurrentLogonId();

    /*
     * If no "match_string" input, then default to all processes for LoginId
     * (if /ID: switch specified) or user logged into current WinStation.
     */
    if ( !(*match_string) ) {

        if( ArgLogonId != (-1) ) {
                wsprintf( match_string, L"%d", ArgLogonId );
        }
        else
            wcscpy( match_string, CurrUserName );
    }

    /*
     * Make match name lower case
     */
    _wcslwr( match_string );

    SetFileApisToOEM();

    /*
     * Enumerate all processes on the server.
     */

    //
    // Try the new interface first (NT5 server ?)
    //
    if (WinStationGetAllProcesses( hServerName,
                                   GAP_LEVEL_BASIC,
                                   &NumberOfProcesses,
                                   &ProcessArray) )
    {
        for (j=0; j<NumberOfProcesses; j++)
        {
            ProcessInfo = (PTS_SYS_PROCESS_INFORMATION )(ProcessArray[j].pTsProcessInfo);
            pUserSid = ProcessArray[j].pSid;
            LogonId = ProcessInfo->SessionId;

            FormatAndDisplayProcessInfo(hServerName,
                                        ProcessInfo,
                                        pUserSid,
                                        LogonId,
                                        CurrentLogonId);

        }

        //
        // Free ppProcessArray and all child pointers allocated by the client stub.
        //
        WinStationFreeGAPMemory(GAP_LEVEL_BASIC, ProcessArray, NumberOfProcesses);

    }
    else    // Maybe a Hydra 4 server ?
    {
        //
        //   Check the return code indicating that the interface is not available.
        //
        dwError = GetLastError();
        if (dwError != RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            ErrorPrintf(IDS_ERROR_ENUMERATE_PROCESSES);
            return(FAILURE);
        }
        else
        {

            //
            // The new interface is not known
            // It must be a Hydra 4 server
            // Let's try the old interface
            //
            if ( !WinStationEnumerateProcesses( hServerName, &pBuffer) ) {
                ErrorPrintf(IDS_ERROR_ENUMERATE_PROCESSES);
                return(FAILURE);
            }

            /*
             * Loop through all processes.  Output those that match desired
             * criteria.
             */

            ProcessInfo = (PTS_SYS_PROCESS_INFORMATION)pBuffer;
            TotalOffset = 0;
            rc = 0;
            for(;;)
            {
                /*
                 * Get the CITRIX_INFORMATION which follows the Threads
                 */
                CitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                             (((PUCHAR)ProcessInfo) +
                              SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION +
                              (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * (int)ProcessInfo->NumberOfThreads));


                if( CitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {
                    LogonId = CitrixInfo->LogonId;
                    pUserSid = CitrixInfo->ProcessSid;

                }
                 else
                {
                    LogonId = (ULONG)(-1);
                    pUserSid = NULL;
                }

                FormatAndDisplayProcessInfo( hServerName,
                                             ProcessInfo,
                                             pUserSid,
                                             LogonId,
                                             CurrentLogonId);


                if( ProcessInfo->NextEntryOffset == 0 ) {
                        break;
                }
                TotalOffset += ProcessInfo->NextEntryOffset;
                ProcessInfo = (PTS_SYS_PROCESS_INFORMATION)&pBuffer[TotalOffset];
            }

            /*
             *  free buffer
             */
            WinStationFreeMemory( pBuffer );
        }
    }
    /*
     *  Check for at least one match
     */
    if ( !MatchedOne ) {
        StringErrorPrintf(IDS_ERROR_PROCESS_NOT_FOUND, match_string);
        return(FAILURE);
    }

    return(SUCCESS);

}  /* main() */

/******************************************************************************
 *
 * FormatAndDisplayProcessInfo
 *
 *
 *****************************************************************************/
VOID
FormatAndDisplayProcessInfo(
        HANDLE hServer,
        PTS_SYS_PROCESS_INFORMATION ProcessInfo,
        PSID pUserSid,
        ULONG LogonId,
        ULONG CurrentLogonId)
{
    WCHAR WinStationName[WINSTATIONNAME_LENGTH];
    WCHAR UserName[USERNAME_LENGTH];
    WCHAR ImageName[ MAXNAME + 2 ];
    ULONG MaxLen;

            ImageName[MAXNAME+1] = 0; // Force NULL termination

            /*
             * Convert the counted string into a buffer
             */

            if( ProcessInfo->ImageName.Length > MAXNAME * 2)
            {
                wcsncpy(ImageName, ProcessInfo->ImageName.Buffer, MAXNAME);
            }
            else if( ProcessInfo->ImageName.Length == 0 )
            {
                    ImageName[0] = 0;
            }
            else
            {
                wcsncpy(ImageName, ProcessInfo->ImageName.Buffer, ProcessInfo->ImageName.Length/2);
                ImageName[ProcessInfo->ImageName.Length/2] = 0;
            }
            

            // get remote winstation name

            if ( (LogonId == (ULONG)(-1)) ||
                 !xxxGetWinStationNameFromId( hServer,
                                           LogonId,
                                           WinStationName,
                                           WINSTATIONNAME_LENGTH ) ) {
                if (GetUnknownString())
                {
                    wsprintf( WinStationName, L"(%s)", GetUnknownString() );
                }
                else
                {
                    wcscpy( WinStationName, L"(Unknown)" );
                }
            }
            OEM2ANSIW(WinStationName, (USHORT)wcslen(WinStationName));

            /*
             * Get the User name for the SID of the process.
             */
            MaxLen = USERNAME_LENGTH;
            GetUserNameFromSid( pUserSid, UserName, &MaxLen);
            OEM2ANSIW(UserName, (USHORT)wcslen(UserName));

            /*
             * Call the general process object match function
             */
            if ( SystemProcess( system_flag, ProcessInfo, UserName ) &&
                     ProcessObjectMatch(
                    UlongToPtr(ProcessInfo->UniqueProcessId),
                    LogonId,
                    ((ArgLogonId == (-1)) ? FALSE : TRUE),
                    match_string,
                    WinStationName,
                    UserName,
                    ImageName ) ) {

                /*
                 * Match: truncate and lower case the names in preparation for
                 * output.
                 */
                    TruncateString( _wcslwr(WinStationName), 12 );
                    TruncateString( _wcslwr(UserName), 18 );
                TruncateString( _wcslwr(ImageName), 15);

                /*
                 *  If first time - output header
                 */
                if ( !MatchedOne ) {
                    Message(IDS_HEADER);
                    MatchedOne = TRUE;
                }

                    /*
                 * identify all processes belonging to current user.
                 */

                if ( (hServerName == SERVERNAME_CURRENT) && (LogonId == CurrentLogonId ) )
                    wprintf( L">" );
                else
                    wprintf( L" " );

                {
                    #define MAX_PRINTFOA_BUFFER_SIZE 1024
                    char pUserName[MAX_PRINTFOA_BUFFER_SIZE];
                    char pWinStationName[MAX_PRINTFOA_BUFFER_SIZE];
                    char pImageName[MAX_PRINTFOA_BUFFER_SIZE];

                    WideCharToMultiByte(CP_OEMCP, 0,
                                        UserName, -1,
                                        pUserName, sizeof(pUserName),
                                        NULL, NULL);
                    WideCharToMultiByte(CP_OEMCP, 0,
                                        WinStationName, -1,
                                        pWinStationName, sizeof(pWinStationName),
                                        NULL, NULL);
                    WideCharToMultiByte(CP_OEMCP, 0,
                                        ImageName, -1,
                                        pImageName, sizeof(pImageName),
                                        NULL, NULL);

                    fprintf( stdout,
                             FORMAT,
                             pUserName,
                             pWinStationName,
                             LogonId,
//                             ProgramState,
                             ProcessInfo->UniqueProcessId,
                             pImageName );
                }
            }
}


/******************************************************************************
 *
 * SystemProcess
 *
 *  Returns TRUE if the process should be displayed depending on the
 *  supplied flag and the result from IsSystemProcess().
 *
 *  ENTRY:
 *      SystemFlag
 *          TRUE if caller wants 'system' processes displayed.
 *          FALSE to display only normal 'user' processes.
 *      pProcessInfo (input)
 *          Pointer to an NT SYSTEM_PROCESS_INFORMATION structure for a single
 *          process.
 *      pUserName (input)
 *          Pointer to the user name associated with the process for checking
 *          against the 'system' user name.
 *
 *  EXIT:
 *      TRUE if this process should be displayed; FALSE if not.
 *
 *****************************************************************************/

BOOLEAN
SystemProcess( int SystemFlag,
               PTS_SYS_PROCESS_INFORMATION pSys,
               PWCHAR pUserName )
{
    if( SystemFlag )
       return( TRUE );

    return( !IsSystemProcess( pSys, pUserName ) );

}  /* SystemProcess() */


/******************************************************************************
 *
 * IsSystemProcess
 *
 *   Return whether the given process described by SYSTEM_PROCESS_INFORMATION
 *   is an NT "system" process, and not a user program.
 *
 *  ENTRY:
 *  pProcessInfo (input)
 *      Pointer to an NT SYSTEM_PROCESS_INFORMATION structure for a single
 *      process.
 *  pUserName (input)
 *      Pointer to the user name associated with the process for checking
 *      against the 'system' user name.
 *
 *  EXIT:
 *    TRUE if this is an NT system process; FALSE if a general user process.
 *
 *****************************************************************************/

BOOLEAN
IsSystemProcess( PTS_SYS_PROCESS_INFORMATION pSysProcessInfo,
                 PWCHAR pUserName )
{
    int i;

    /*
     * If the processes' UserName is 'system', treat this as a system process.
     */
    if ( !_wcsicmp( pUserName, L"system" ) )
        return(TRUE);

    /*
     * Compare its image name against some well known system image names.
     */
    for( i=0; SysProcTable[i]; i++) {
        if ( !_wcsnicmp( pSysProcessInfo->ImageName.Buffer,
                         SysProcTable[i],
                         pSysProcessInfo->ImageName.Length) ) {

            return(TRUE);
        }
    }
    return(FALSE);

}  /* IsSystemProcess() */

/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_HELP_USAGE1);
        ErrorPrintf(IDS_HELP_USAGE2);
        ErrorPrintf(IDS_HELP_USAGE3);
        ErrorPrintf(IDS_HELP_USAGE40);
        ErrorPrintf(IDS_HELP_USAGE4);
        ErrorPrintf(IDS_HELP_USAGE5);
        ErrorPrintf(IDS_HELP_USAGE6);
        ErrorPrintf(IDS_HELP_USAGE7);
        ErrorPrintf(IDS_HELP_USAGE8);
        ErrorPrintf(IDS_HELP_USAGE9);
        ErrorPrintf(IDS_HELP_USAGE10);
    } else {
        Message(IDS_HELP_USAGE1);
        Message(IDS_HELP_USAGE2);
        Message(IDS_HELP_USAGE3);
        Message(IDS_HELP_USAGE40);
        Message(IDS_HELP_USAGE4);
        Message(IDS_HELP_USAGE5);
        Message(IDS_HELP_USAGE6);
        Message(IDS_HELP_USAGE7);
        Message(IDS_HELP_USAGE8);
        Message(IDS_HELP_USAGE9);
        Message(IDS_HELP_USAGE10);
    }

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\quser\quser.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*  QUSER.H
*     This module contains typedefs and defines required for
*     the QUSER utility.
*
*
*************************************************************************/

#include <utildll.h>
/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be

/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_ENUMERATE                  102
#define IDS_ERROR_USER_NOT_FOUND                        103
#define IDS_ERROR_SERVER                                104
#define IDS_HELP_USAGE1                                 105
#define IDS_HELP_USAGE2                                 106
#define IDS_HELP_USAGE3                                 107
#define IDS_HELP_USAGE4                                 108
#define IDS_HELP_USAGE5                                 109
#define IDS_HELP_USAGE6                                 110
#define IDS_ERROR_NOT_TS                                111
#define IDS_TITLE                                       112
#define IDS_NONE                                        113
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\regfix\regfix.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++

Copyright (c) 1998  Citrix Systems

Module Name:

    regfix.c

Abstract:

    Reads hv (low) level structures in a hive and rewrites the hive structs after applying 
    ACL fixes.  Reads in the hive in block sizes.  Scans for and processes security keys.
    Extracts the SECURITY_DESCRIPTOR structure form a cell and checks consistency of sizes 
    of ACEs and ACLs.

    Usage: regfix in_filename out_filename

Author:

    Maris Kurens (v-marisk (MS), marisk (CTXS)) Apr 1998

Revision History: 
    Created - Apr 23, 1998

--*/


/*

    NOTE:   This hive/registry tool does not read the
            entire hive into memory, but will read the hive file
            on a block by block basis,  process each block and 
            write out the block to a new file using file I/O.

*/

// Include NT headers
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include "cmp.h"
#include "regfix.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#define INFILE      0x01
#define OUTFILE     0x02
#define BOTHFILE    0x03


int __cdecl main (int argc, char *argv[]);
void openFile (void);
void closeFile (unsigned which);
void ScanHive (void);
void DoKeySD (IN PCM_KEY_SECURITY Security, IN ULONG CellSize);
void ScanCell (PHCELL Cell, ULONG CellSize);

void DumpSecurityDescriptor (PSECURITY_DESCRIPTOR pSD);
void CtxDumpSid (PSID, PCHAR, PULONG);
void DumpAcl (PACL, PCHAR, PULONG);
void DumpAce (PACE_HEADER, PCHAR, PULONG);
BOOL AreWeRunningTerminalServices(void);


VOID WINAPI ErrorPrintf (int nErrorResourceID, ...);


LPCTSTR inFileName = NULL;
LPCTSTR outFileName = NULL;

HANDLE infilehandle;
HANDLE outfilehandle;

ULONG HiveVersion;

//
//  SUMMARY TOTALS
//
ULONG SizeSDData=0;
ULONG NumSDData=0;

ULONG BlockNumb = 0;
ULONG BadACL = 0;
ULONG BadACE = 0;

//---------------------------------------------------------
//  Description :
//      Basic arg check, arg echo, process calls and result dump
//
//  Args :
//      if you have to ask ...
//
//  Return :
//
//---------------------------------------------------------

int __cdecl main (int argc, char *argv[])
{

	//Check if we are running under Terminal Server
	if(!AreWeRunningTerminalServices())
	{
		ErrorPrintf(IDS_ERROR_NOT_TS);
	    return(1);
	}

    if (argc < 3) 
    {
    	ErrorPrintf (IDS_ERROR_USAGE);
        exit (1);
    }

    inFileName = argv [1];
    outFileName = argv [2];

    //
    // echo the args
    //
    ErrorPrintf (IDS_WORKING);

    //
    // open the in and out files
    //
    openFile ();

    //
    // and process it
    //
    ScanHive ();

    ErrorPrintf (IDS_DONE);
    ErrorPrintf (IDS_SD_NUMBER, NumSDData);
    ErrorPrintf (IDS_BAD_ACL_NUMBER, BadACL);
    ErrorPrintf (IDS_BAD_ACE_NUMBER, BadACE);

    return (0);
}

//---------------------------------------------------------
//  Description :
//      Closes file handles based on input args
//
//  Args :
//      which - signals if input or output or both files should be closed
//
//  Return :  Nothing
//
//---------------------------------------------------------
void closeFile (unsigned which)
{
    if (which & INFILE)
    {
        if (infilehandle != INVALID_HANDLE_VALUE)
        {
            CloseHandle (infilehandle);
            infilehandle = INVALID_HANDLE_VALUE;
        }
    }

    if (which & OUTFILE)
    {
        if (infilehandle != INVALID_HANDLE_VALUE)
        {
            CloseHandle (outfilehandle);
            outfilehandle = INVALID_HANDLE_VALUE;
        }
    }
}

//---------------------------------------------------------
//  Description :
//      Opens input and output files
//
//  Args : Nada
//
//  Return : Nada
//
//---------------------------------------------------------
void openFile (void)
{
    //
    // open the input file
    //
    infilehandle = CreateFile (inFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (infilehandle == INVALID_HANDLE_VALUE) 
    {
        fprintf (stderr,
                 "regfix: Could not open file '%s' error = %08lx\n",
                 inFileName, GetLastError());
        exit(1);
    }

    //
    // open the output file
    //
    outfilehandle = CreateFile (outFileName, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,
                            CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (outfilehandle == INVALID_HANDLE_VALUE) 
    {
        closeFile (INFILE);
        fprintf (stderr,
                 "hivestat: Could not create file '%s' error = %08lx\n",
                 outFileName, GetLastError());
        exit(1);
    }
}

//---------------------------------------------------------
//  Description :
//      Scan the hive, looking for security cells.  Load the 
//      hive block by block and write each block to the output
//      file after processing it. 
//
//  Args :  None
//
//  Return : Nyet
//
//---------------------------------------------------------
void ScanHive (void)
{
    static char buffer[HBLOCK_SIZE];
    PHBASE_BLOCK bbp;
    BOOL rf;
    BOOL wf;
    ULONG readcount;
    ULONG writecount;
    ULONG hivelength;
    ULONG hiveposition;
    PHCELL cp;
    PHCELL guard;
    PHBIN hbp;
    ULONG hoff;
    ULONG binread;
    ULONG binsize;
    ULONG cellsize;
    ULONG boff;
    ULONG lboff;
    ULONG SizeTotal;

    //
    // read the header
    //
    rf = ReadFile (infilehandle, buffer, HBLOCK_SIZE, &readcount, NULL);
    if ((!rf) || (readcount != HBLOCK_SIZE) ) 
    {
        closeFile (BOTHFILE);
        fprintf (stderr, "regfix: '%s' - cannot read base block!\n", inFileName);
        exit(1);
    }

    BlockNumb++;

    bbp = (PHBASE_BLOCK)(&(buffer[0]));

    if ((bbp->Major != HSYS_MAJOR) ||
        (bbp->Minor > HSYS_MINOR))
    {

        closeFile (BOTHFILE);

        fprintf(stderr,
                "hivestat: major/minor != %d/%d get newer hivestat\n",
                HSYS_MAJOR, HSYS_MINOR
                );
        exit(1);
    }

    HiveVersion = bbp->Minor;

    hivelength = bbp->Length + HBLOCK_SIZE;
    hiveposition = HBLOCK_SIZE;
    hoff = 0;


    //
    // scan the hive
    //
    guard = (PHCELL)(&(buffer[0]) + HBLOCK_SIZE);

    wf = WriteFile (outfilehandle, buffer, HBLOCK_SIZE, &writecount, NULL);
    if ((!wf) || (writecount != HBLOCK_SIZE) ) 
    {
        closeFile (BOTHFILE);
        fprintf (stderr, "regfix: '%s' - cannot write base block!\n", outFileName);
        exit(1);
    }

    //
    // hiveposition is file relative offset of next block we will read
    //
    // hoff is the file relative offset of the last block we read
    //
    // hivelength is actual length of file (header's recorded length plus
    // the size of the header.
    //
    // cp is pointer into memory, within range of buffer, it's a cell pointer
    //
    while (hiveposition < hivelength) 
    {

        //
        // read in first block of bin, check signature, determine key type
        //
        rf = ReadFile (infilehandle, buffer, HBLOCK_SIZE, &readcount, NULL);
        if ((! rf) || (readcount != HBLOCK_SIZE)) 
        {
            closeFile (BOTHFILE);
            fprintf (stderr, "hivestat: '%s' read error @%08lx\n", inFileName, hiveposition);
            exit (1);
        }
        BlockNumb++;

        hbp = (PHBIN)(&(buffer[0]));

        if (hbp->Signature != HBIN_SIGNATURE) 
        {
            closeFile (BOTHFILE);
            fprintf(stderr,
                    "hivestat: '%s' bad bin sign. @%08lx\n", inFileName, hiveposition);
            exit(1);
        }

        hiveposition += HBLOCK_SIZE;
        hoff += HBLOCK_SIZE;
        ASSERT (hoff+HBLOCK_SIZE == hiveposition);

        binsize = hbp->Size;
        //
        // scan the bin
        //
        // cp = pointer to cell we are looking at
        // boff = offset within bin
        // lboff = last offset within bin, used only for consistency checks
        // binread = number of bytes of bin we've read so far
        //
        cp = (PHCELL)((PUCHAR)hbp + sizeof(HBIN));
        boff = sizeof(HBIN);
        lboff = (ULONG)-1;
        binread = HBLOCK_SIZE;

        while (binread <= binsize) 
        {

            //
            // if free, update pointer only
            // else scan it
            //
            if (cp->Size > 0) 
            {
                cellsize = cp->Size;
            } 
            else 
            {
                cellsize = -1 * cp->Size;
                ScanCell (cp, cellsize);
            }

            //
            // do basic consistency check
            //
#if 0
            if (cp->Last != lboff) {
                printf("e!,x%08lx  bad LAST pointer %08lx\n",
                        hoff+((PUCHAR)cp - &(buffer[0])), cp->Last);
            }
#endif

            //
            // advance to next cell
            //
            lboff = boff;
            cp = (PHCELL)((PUCHAR)cp + cellsize);
            boff += cellsize;

            //
            // scan ahead in bin, if cp has reached off end of block,
            // AND there's bin left to read.
            // do this BEFORE breaking out for boff at end.
            //
            while ((cp >= guard) && (binread < binsize)) 
            {

                // write out the currently loaded block
                wf = WriteFile (outfilehandle, buffer, HBLOCK_SIZE, &writecount, NULL);
                if ((!wf) || (writecount != HBLOCK_SIZE) ) 
                {
                    closeFile (BOTHFILE);
                    fprintf (stderr, "regfix: '%s' - cannot write block %d!\n", BlockNumb, outFileName);
                    exit(1);
                }


                rf = ReadFile(infilehandle, buffer, HBLOCK_SIZE, &readcount, NULL);
                if ((!rf) || (readcount != HBLOCK_SIZE)) 
                {
                    closeFile (BOTHFILE);
                    fprintf(stderr, "hivestat: '%s' read error @%08lx\n", inFileName, hiveposition);
                    exit(1);
                }
                BlockNumb++;

                cp = (PHCELL)((PUCHAR)cp - HBLOCK_SIZE);
                hiveposition += HBLOCK_SIZE;
                hoff += HBLOCK_SIZE;
                binread += HBLOCK_SIZE;
                ASSERT (hoff+HBLOCK_SIZE == hiveposition);
            }

            if (boff >= binsize) 
            {
                break;              // we are done with this bin
            }
        }

        wf = WriteFile (outfilehandle, buffer, HBLOCK_SIZE, &writecount, NULL);
        if ((!wf) || (writecount != HBLOCK_SIZE) ) 
        {
            closeFile (BOTHFILE);
            fprintf (stderr, "regfix: '%s' - cannot write block %d!\n", BlockNumb, outFileName);
            exit(1);
        }

    }

    return;
}

//---------------------------------------------------------
//  Description :
//      Given a pointer to an HCELL, check the SD type cell signature
//      If it is pass to the SD processing routines. 
//      Note : framework is in place to handle other cell types
//
//  Args :
//    Cell - Supplies a pointer to the HCELL
//
//    CellSize - Supplies the size of the HCELL
//
//  Return :  Nothing
//
//---------------------------------------------------------
void ScanCell (IN PHCELL Cell, IN ULONG CellSize)
{
    PCELL_DATA Data;

    if (HiveVersion==1) 
    {
        Data = (PCELL_DATA)&Cell->u.OldCell.u.UserData;
    } 
    else 
    {
        Data = (PCELL_DATA)&Cell->u.NewCell.u.UserData;
    }

    //
    // grovel through the data, see if we can find the SD keys
    //
    if ((Data->u.KeyNode.Signature == CM_KEY_NODE_SIGNATURE) &&
        (CellSize > sizeof(CM_KEY_NODE))) 
    {
        //
        // probably a key node
        //
        return;
    } 
    else if ((Data->u.KeyValue.Signature == CM_KEY_VALUE_SIGNATURE) &&
              (CellSize > sizeof(CM_KEY_VALUE))) 
    {

        //
        // probably a key value
        //
        return;

    } 
    else if ((Data->u.KeySecurity.Signature == CM_KEY_SECURITY_SIGNATURE) &&
               (CellSize > sizeof(CM_KEY_SECURITY))) 
    {

        //
        // probably a security descriptor
        //
        DoKeySD (&Data->u.KeySecurity, CellSize);

    } 
    else if ((Data->u.KeyIndex.Signature == CM_KEY_INDEX_ROOT) ||
               (Data->u.KeyIndex.Signature == CM_KEY_INDEX_LEAF)) 
    {
        //
        // probably a key index
        //
        return;
    } 
    else 
    {
        //
        // Nothing with a signature, could be either
        //  name
        //  key list
        //  value data
        //
        return;

    }
}


//---------------------------------------------------------
//  Description :
//      Expects an SD cell pointer. Extracts the SD descriptor
//      and passes it on for further processing
//
//  Args :
//    Security - Pointer to PCM_KEY_SECURITY type cell
//
//    CellSize - size of the HCELL
//
//  Return :  Nothing
//
//---------------------------------------------------------
void DoKeySD (IN PCM_KEY_SECURITY Security, IN ULONG CellSize)
{
    PSECURITY_DESCRIPTOR pSD;

    SizeSDData += CellSize;
    NumSDData++;

    pSD = &Security->Descriptor;
    DumpSecurityDescriptor (pSD);
}

//---------------------------------------------------------
//      ** The following routines are hacks of the dumpsd
//      ** lib code in private\citrix\syslib
//      ** This util can easily be modified as a standalone
//      ** utility for a variety of hive security processing
//---------------------------------------------------------



//---------------------------------------------------------
//  Description :
//      Unfolds an SD descriptor passing SID and ACL pointers
//      for further processing
//
//  Args :
//    pSD - Pointer to SECURITY_DESCRIPTOR structure
//
//  Return :  Nothing
//
//---------------------------------------------------------
void DumpSecurityDescriptor (PSECURITY_DESCRIPTOR pSD)
{
    PISECURITY_DESCRIPTOR p = (PISECURITY_DESCRIPTOR)pSD;
    PSID pSid;
    PACL pAcl;
    PCHAR pTmp;
    ULONG Size;

    /*
    DbgPrint ("DUMP_SECURITY_DESCRIPTOR: Revision %d, Sbz1 %d, Control 0x%x\n",
            p->Revision, p->Sbz1, p->Control );

    if (p->Control & SE_SELF_RELATIVE ) 
    {
        DbgPrint("Self Relative\n");
	}

	DbgPrint("PSID Owner 0x%x\n",p->Owner);
    */

    // If this is self relative, must offset the pointers
    if( p->Owner != NULL ) 
    {
	    if (p->Control & SE_SELF_RELATIVE) 
        {
            pTmp = (PCHAR)pSD;
            pTmp += (ULONG)p->Owner;
     	    CtxDumpSid ((PSID)pTmp, (PCHAR)p, &Size );
	    }
	    else 
        {
            // can reference it directly
	        CtxDumpSid (p->Owner, (PCHAR)p, &Size );
	    }
	}


/*
	DbgPrint("PSID Group 0x%x\n",p->Group);
*/
    // If this is self relative, must offset the pointers
    if (p->Group != NULL) 
    {
	    if (p->Control & SE_SELF_RELATIVE) 
        {
            pTmp = (PCHAR)pSD;
            pTmp += (ULONG)p->Group;
     	    CtxDumpSid( (PSID)pTmp, (PCHAR)p, &Size );
	    }
	    else 
        {
            // can reference it directly
	        CtxDumpSid( p->Group, (PCHAR)p, &Size );
	    }
	}

//    DbgPrint("\n");

//	DbgPrint("PACL Sacl 0x%x\n",p->Sacl);

    // If this is self relative, must offset the pointers
    if (p->Sacl != NULL) 
    {
	    if (p->Control & SE_SELF_RELATIVE) 
        {
            pTmp = (PCHAR)pSD;
            pTmp += (ULONG)p->Sacl;
     	    DumpAcl( (PSID)pTmp, (PCHAR)p, &Size );
	    }
	    else 
        {
            // can reference it directly
	        DumpAcl (p->Sacl, (PCHAR)p, &Size);
	    }
	}

//    DbgPrint("\n");

//	DbgPrint ("PACL Dacl 0x%x\n",p->Dacl);

    // If this is self relative, must offset the pointers
    if (p->Dacl != NULL) 
    {
	    if (p->Control & SE_SELF_RELATIVE) 
        {
            pTmp = (PCHAR)pSD;
            pTmp += (ULONG)p->Dacl;
     	    DumpAcl( (PSID)pTmp, (PCHAR)p, &Size );
	    }
	    else 
        {
            // can reference it directly
	        DumpAcl( p->Dacl, (PCHAR)p, &Size );
	    }
	}


}


//---------------------------------------------------------
//  Description :
//      Examine an SD descriptor for subauthority and owner
//      info
//
//  Args :
//    pSid - Pointer to SID structure
//    pBase - not used (kept for historical reasons)
//    pSize - holds the SID size on return
//
//  Return :  Nothing
//
//---------------------------------------------------------
void CtxDumpSid (
    PSID   pSid,
    PCHAR  pBase,
    PULONG pSize)
{
    PISID p;
    ULONG i;
    BOOL  OK;
    DWORD szUserName;
    DWORD szDomain;
    SID_NAME_USE UserSidType;
    WCHAR UserName[256];
    WCHAR Domain[256];
    ULONG Size = 0;

    p = (PISID)pSid;

//    DbgPrint("Revision %d, SubAuthorityCount %d\n", p->Revision, p->SubAuthorityCount);

    Size += 2;   // Revision, SubAuthorityCount

/*
    DbgPrint("IdentifierAuthority: %x %x %x %x %x %x\n",
        p->IdentifierAuthority.Value[0],
        p->IdentifierAuthority.Value[1],
        p->IdentifierAuthority.Value[2],
        p->IdentifierAuthority.Value[3],
        p->IdentifierAuthority.Value[4],
        p->IdentifierAuthority.Value[5] );
*/
    Size += 6;   // IdentifierAuthority

    for (i=0; i < p->SubAuthorityCount; i++) 
    {

//	    DbgPrint("SubAuthority[%d] 0x%x\n", i, p->SubAuthority[i]);

        Size += sizeof(ULONG);
    }

    if (pSize) 
    {
        *pSize = Size;
    }

    szUserName = sizeof (UserName);
    szDomain = sizeof (Domain);

    // Now print its account
    /*
    OK = LookupAccountSidW (
            NULL, // Computer Name
	        pSid,
            UserName,
            &szUserName,
            Domain,
            &szDomain,
            &UserSidType);
    */

//    if (OK) 
//    {
//        DbgPrint("Account Name %ws, Domain %ws, Type %d, SidSize %d\n",UserName,Domain,UserSidType,Size);
//    }
//    else 
//    {
//        DbgPrint("Error looking up account name %d, SizeSid %d\n",GetLastError(),Size);
//    }

}


//---------------------------------------------------------
//  Description :
//      Unfolds an ACL dumping all the ACEs in the process
//      checking consistency by tracking the actual size 
//
//  Args :
//    pAcl - Pointer to ACL structure
//    pBase - not used (kept for historical reasons)
//    pSize - holds the size on return
//
//  Return :  Nothing
//
//---------------------------------------------------------
void DumpAcl (PACL pAcl, PCHAR pBase, PULONG pSize)
{
    USHORT i;
    PCHAR  pTmp;
    ULONG  Size, MySize;
    PACL   p = pAcl;
    PCHAR  pCur = (PCHAR)pAcl;

    MySize = 0;

//    DbgPrint ("AclRevision %d, Sbz1 %d, AclSize %d, AceCount %d, Sbz2 %d\n",
//               p->AclRevision, p->Sbz1, p->AclSize, p->AceCount, p->Sbz2);

    // bump over the ACL header to point to the first ACE
    pCur += sizeof (ACL);

    MySize += sizeof (ACL);

    for (i=0; i < p->AceCount; i++) 
    {
        DumpAce ((PACE_HEADER)pCur, pBase, &Size );

        pCur += Size;
        MySize += Size;
    }

    // ACL consistency check
    if( p->AclSize != MySize ) 
    {
        //
        // HACK!HACK!HACK! 
        //        |
        //        |
        //        |
        //        v
        if (p->AclSize == 1023) // This hack is in response to MS bug #1607. The hive load fails on ACL
        {                       // size alignment check.  The sw hive file that causes this problem has
            p->AclSize = 1024;  // about 3k SD entries of ACL size 1023.  This hack adjusts this.
        }
        //        ^
        //        |
        //        |
        //        |
        //        |
        // HACK!HACK!HACK! 
        
//        DbgPrint("Inconsistent ACL Entry! p->AclSize %d, RealSize %d\n",p->AclSize,MySize);
//        p->AclSize = MySize;
        BadACL++;
    }

    // return the size of this ACL
    *pSize = MySize;
    return;
}


//---------------------------------------------------------
//  Description :
//      Unfolds an ACE descriptor checking consistency by
//      tracking the actual size 
//
//  Args :
//    pAce - Pointer to ACE structure
//    pBase - not used (kept for historical reasons)
//    pSize - holds the size on return
//
//  Return :  Nothing
//
//---------------------------------------------------------
void DumpAce (PACE_HEADER pAce,
    PCHAR  pBase,
    PULONG pSize)
{
    PACE_HEADER p = pAce;
    PACCESS_ALLOWED_ACE pAl;
    PACCESS_DENIED_ACE pAd;
    PSYSTEM_AUDIT_ACE pSa;
    PSYSTEM_ALARM_ACE pSl;
    PCHAR pTmp;
    ULONG MySize, Size, saveSize;


//    DbgPrint ("ACE_HEADER: Type %d, Flags 0x%x, Size %d\n",
//               p->AceType, p->AceFlags, p->AceSize );

 
    switch (p->AceType) 
    {

        case ACCESS_ALLOWED_ACE_TYPE:
	        pAl = (PACCESS_ALLOWED_ACE)p;
//	        DbgPrint("ACCESS_ALLOWED_ACE: AccessMask 0x%x, Sid 0x%x\n",pAl->Mask,pAl->SidStart);

	        MySize = sizeof(ACCESS_ALLOWED_ACE);

            if (pAl->SidStart) 
            {
	            pTmp = (PCHAR)&pAl->SidStart;
		        CtxDumpSid( (PSID)pTmp, pBase, &Size );
	            MySize += Size;
                // Adjust for the first ULONG of the ACE
		        // being part of the Sid
                MySize -= sizeof(ULONG);
	        }
            break;

        case ACCESS_DENIED_ACE_TYPE:
	        pAd = (PACCESS_DENIED_ACE)p;
//	        DbgPrint("ACCESS_DENIED_ACE: AccessMask 0x%x, Sid 0x%x\n",pAd->Mask,pAd->SidStart);
	        MySize = sizeof(ACCESS_DENIED_ACE);

            if (pAd->SidStart) 
            {
	            pTmp = (PCHAR)&pAd->SidStart;
		        CtxDumpSid( (PSID)pTmp, pBase, &Size );
		        MySize += Size;
                // Adjust for the first ULONG of the ACE
		        // being part of the Sid
                MySize -= sizeof(ULONG);
	        }
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
	        pSa = (PSYSTEM_AUDIT_ACE)p;
//	        DbgPrint("SYSTEM_AUDIT_ACE: AccessMask 0x%x, Sid 0x%x\n",pSa->Mask,pSa->SidStart);

	        MySize = sizeof(SYSTEM_AUDIT_ACE);

            if ( pSa->SidStart ) 
            {
 	            pTmp = (PCHAR)&pSa->SidStart;
		        CtxDumpSid( (PSID)pTmp, pBase, &Size );
		        MySize += Size;
                // Adjust for the first ULONG of the ACE
		        // being part of the Sid
                MySize -= sizeof(ULONG);
	        }
            break;

        case SYSTEM_ALARM_ACE_TYPE:
	        pSl = (PSYSTEM_ALARM_ACE)p;
//	        DbgPrint("SYSTEM_ALARM_ACE: AccessMask 0x%x, Sid 0x%x\n",pSl->Mask,pSl->SidStart);

	        MySize = sizeof(SYSTEM_ALARM_ACE);

            if (pSl->SidStart) 
            {
	            pTmp = (PCHAR)&pSl->SidStart;
		        CtxDumpSid( (PSID)pTmp, pBase, &Size );
		        MySize += Size;
                // Adjust for the first ULONG of the ACE
		        // being part of the Sid
                MySize -= sizeof(ULONG);
	        }
            break;

    default:
        break;

//            DbgPrint("Unknown ACE type %d\n", p->AceType);
    }

    saveSize = p->AceSize;
    // Check its consistency
    if ( p->AceSize != MySize ) 
    {
//        DbgPrint("Inconsistent ACE Entry! p->AceSize %d, RealSize %d\n",p->AceSize,MySize);
//        p->AceSize = MySize;
        BadACE++;
    }

    // return the size so the caller can update the pointer
//    *pSize = p->AceSize;
    *pSize = saveSize;

//    DbgPrint("\n");

    return;
}

/*******************************************************************************
 *
 *  AreWeRunningTerminalServices
 *
 *      Check if we are running terminal server
 *
 *  ENTRY:
 *      
 *  EXIT: BOOL: True if we are running Terminal Services False if we
 *              are not running Terminal Services
 *
 *
 ******************************************************************************/

BOOL AreWeRunningTerminalServices(void)
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    return VerifyVersionInfo(
        &osVersionInfo,
        VER_SUITENAME,
        dwlConditionMask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\regfix\regfix.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*
 * Resource string IDs
 */
#define IDS_ERROR_USAGE                     100         
#define IDS_WORKING                         101
#define IDS_DONE                            102
#define IDS_SD_NUMBER                       103
#define IDS_BAD_ACL_NUMBER                  104
#define IDS_BAD_ACE_NUMBER                  105
#define IDS_ERROR_NOT_TS                    106
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\register\register.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*   REGISTER.H
*
*   This module contains typedefs and defines required for
*   the REGISTER utility.
*
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_OPEN                                  101
#define IDS_ERROR_SIZE                                  102
#define IDS_ERROR_CREATE                                103
#define IDS_ERROR_MAP                                   104
#define IDS_ERROR_SIGNATURE                             105
#define IDS_ERROR_INVALID_PARAMETERS                    106
#define IDS_ERROR_NOT_ADMIN				107
#define IDS_ERROR_NOT_TS                                108

#define IDS_REGISTER_USER_GLOBAL                        200
#define IDS_REGISTER_SYSTEM_GLOBAL                      201
#define IDS_REGISTER_GUI_OK                             202
#define IDS_REGISTER_GUI_NOT_OK                         203

#define IDS_USAGE1                                      210
#define IDS_USAGE2                                      211
#define IDS_USAGE3                                      212
#define IDS_USAGE4                                      213
#define IDS_USAGE5                                      214
#define IDS_USAGE6                                      215
#define IDS_USAGE7                                      216
#define IDS_X86_ONLY                                    217
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\remotepage\registry.h ===
#pragma once

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule);

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\remotepage\main.cpp ===
// TSSecurity.cpp : Defines the entry point for the DLL application.
//

#include "RemotePage.h"
#include "registry.h"
#include "resource.h"

// our globals
// {F0152790-D56E-4445-850E-4F3117DB740C}
GUID CLSID_CTSRemotePage = 
    { 0xf0152790, 0xd56e, 0x4445, { 0x85, 0xe, 0x4f, 0x31, 0x17, 0xdb, 0x74, 0xc } };

static HINSTANCE g_hinst = NULL;
static ULONG g_uSrvLock = 0;
ULONG g_uObjects = 0;

//Class factory definition
class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    
    CClassFactory();
    ~CClassFactory();

    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IClassFactory
    ///////////////////////////////
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
};

BOOL WINAPI 
DllMain(HINSTANCE hinstDLL, 
        DWORD fdwReason, 
        void* lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}

/**************************************************************************
Exported functions
***************************************************************************/

STDAPI 
DllGetClassObject(
        REFCLSID rclsid, 
        REFIID riid, 
        LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CTSRemotePage))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CTSRemotePage)
        pFactory = new CClassFactory;
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    pFactory->Release();
    return hr;
}

STDAPI 
DllCanUnloadNow()
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}

//
// Server registration
//
STDAPI 
DllRegisterServer()
{
    return RegisterServer(g_hinst);
}


STDAPI 
DllUnregisterServer()
{
    return UnregisterServer();
}

/**************************************************************************
Class CClassFactory
***************************************************************************/

CClassFactory::CClassFactory()
{
    m_cref = 1;
    g_uObjects++;
}

CClassFactory::~CClassFactory()
{
    g_uObjects--;
}

STDMETHODIMP 
CClassFactory::QueryInterface(
        REFIID riid, 
        LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) 
CClassFactory::AddRef()
{
    return ++m_cref;
}

STDMETHODIMP_(ULONG) 
CClassFactory::Release()
{
    m_cref--;
    if (!m_cref)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP 
CClassFactory::CreateInstance(
        LPUNKNOWN pUnkOuter, 
        REFIID riid, 
        LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    pObj = new CRemotePage(g_hinst);
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    ((LPUNKNOWN)pObj)->Release();
    
    return hr;
}

STDMETHODIMP 
CClassFactory::LockServer(
        BOOL fLock)
{
    if (fLock)
    {
        g_uSrvLock++;
    }
    else
    {
        if(g_uSrvLock>0)
        {
            g_uSrvLock--;
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\register\register.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// Remove redundent check sums. Use the imagehelp one and delete mikes.

/*****************************************************************************
*
*   REGISTER.C for Windows NT
*
*   Description:
*
*   Register USER/SYSTEM global
*
*
****************************************************************************/

/* include files */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <winsta.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <utilsub.h>
#include <utildll.h>
#include <syslib.h>

#include "register.h"
#include "printfoa.h"

/*
 *  Local variables
 */
WCHAR  fileW[MAX_PATH + 1];

USHORT system_flag = FALSE;
USHORT user_flag   = FALSE;
USHORT help_flag   = FALSE;
USHORT v_flag      = FALSE;
USHORT d_flag      = FALSE;


/*
 *  Command line parsing strucutre
 */
TOKMAP ptm[] =
{
   {L" ",          TMFLAG_REQUIRED, TMFORM_STRING,  MAX_PATH,   fileW},
   {L"/SYSTEM",    TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &system_flag},
   {L"/USER",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &user_flag},
   {L"/?",         TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
   {L"/v",         TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &v_flag},
   {L"/d",         TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &d_flag},
   {0, 0, 0, 0, 0}
};


/*
 *  Local function prototypes
 */
USHORT ChkSum( ULONG PartialSum, PUSHORT Source, ULONG Length );
VOID   Usage(BOOL);


BOOLEAN Is_X86_OS()
{
    SYSTEM_INFO SystemInfo;
    BOOLEAN bReturn = FALSE;

    ZeroMemory(&SystemInfo, sizeof(SystemInfo));

    GetSystemInfo(&SystemInfo);

    if(SystemInfo.wProcessorArchitecture ==  PROCESSOR_ARCHITECTURE_INTEL )
    {
        bReturn  = TRUE;
    }

    return bReturn;
}

/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

INT __cdecl
main( int argc, char *argv[] )
{
    INT     i;
    DWORD   rc;
    CHAR   *pFileView;
    HANDLE  FileHandle;
    ULONG   FileLength;
    HANDLE  Handle;
    OFSTRUCT OpenBuff;
    PIMAGE_NT_HEADERS pImageNtHeader;
    WCHAR  *CmdLine;
    WCHAR **argvW;
    ULONG   BytesOut;
    BOOL    readOnly = TRUE;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    if ( !Is_X86_OS() )
    {
        ErrorPrintf( IDS_X86_ONLY );
        return(FAILURE);
    }

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if (rc && (rc & PARSE_FLAG_NO_PARMS) )
       help_flag = TRUE;

    if ( help_flag || rc ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return rc;
        } else {

            Usage(FALSE);
            return ERROR_SUCCESS;
        }
    }
    else if ( system_flag && user_flag ) {

        Usage(TRUE);
        return ERROR_INVALID_PARAMETER;
    }

    if (!TestUserForAdmin(FALSE)) {
       ErrorPrintf(IDS_ERROR_NOT_ADMIN);
       return 1;
    }

    readOnly = !(system_flag || user_flag );

    /*
     *  Open file
     */

    FileHandle = CreateFile(
                    fileW,
                    readOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
    if (FileHandle == INVALID_HANDLE_VALUE) {
        ErrorPrintf(IDS_ERROR_OPEN, (rc = GetLastError()));
        PutStdErr(rc, 0);
        goto done;
    }

    /*
     *  Create mapping
     */
    if ( (Handle = CreateFileMapping( FileHandle, NULL,
          readOnly ? PAGE_READONLY : PAGE_READWRITE, 0, 0, NULL )) == NULL ) {

        ErrorPrintf(IDS_ERROR_CREATE, (rc=GetLastError()));
        PutStdErr( rc, 0 );
        goto closefile;
    }

    /*
     *  Get file size
     */
    if ( (FileLength = GetFileSize( FileHandle, NULL )) == 0xffffffff ) {

        ErrorPrintf(IDS_ERROR_SIZE, (rc=GetLastError()));
        PutStdErr( rc, 0 );
        goto closefile;
    }

    /*
     *  Map file view into our address space
     */
    if ( (pFileView = MapViewOfFile( Handle,
          readOnly ? FILE_MAP_READ : FILE_MAP_WRITE, 0, 0, 0 )) == NULL ) {

        ErrorPrintf(IDS_ERROR_MAP, (rc=GetLastError()));
        PutStdErr( rc, 0 );
        goto closefile;
    }

    /*
     *  Find and validate NT image header
     */
    if ( ((pImageNtHeader = RtlImageNtHeader( pFileView )) == NULL) ||
         (pImageNtHeader->Signature != IMAGE_NT_SIGNATURE) ) {

        ErrorPrintf(IDS_ERROR_SIGNATURE);
        rc = ERROR_BAD_FORMAT;
        goto closefile;
    }

    /*
     *  Process query
     */
    if ( !system_flag && !user_flag ) {

        /*
         *  Check for System Global Flag
         */
        if ( (pImageNtHeader->OptionalHeader.LoaderFlags & IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL) )
            StringMessage(IDS_REGISTER_SYSTEM_GLOBAL, fileW);
        else
            StringMessage(IDS_REGISTER_USER_GLOBAL, fileW);
    }
    else {

        /*
         *  Set SYSTEM/USER bit
         */
        if ( system_flag ) {

            /*
             *  Mask in the load flag
             */
            pImageNtHeader->OptionalHeader.LoaderFlags |= IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL;

            StringMessage(IDS_REGISTER_SYSTEM_GLOBAL, fileW);
        }
        else if ( user_flag ) {

            /*
             *  Mask out the load flag
             */
            pImageNtHeader->OptionalHeader.LoaderFlags &= ~(IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL);

            StringMessage(IDS_REGISTER_USER_GLOBAL, fileW);
        }

        /*
         *  Zero out current check sum and calculate new one
         */
        pImageNtHeader->OptionalHeader.CheckSum = 0;
        pImageNtHeader->OptionalHeader.CheckSum =
                        ChkSum( 0, (PUSHORT)pFileView, (FileLength + 1) >> 1 );
        pImageNtHeader->OptionalHeader.CheckSum += FileLength;

    }

    /*
     *  Close image file when finished
     */
closefile:
    CloseHandle( FileHandle );

done:

    return rc;
}


/*******************************************************************************
 *
 *  ChkSum
 *
 ******************************************************************************/

USHORT
ChkSum(
    ULONG PartialSum,
    PUSHORT Source,
    ULONG Length
    )

/*++

Routine Description:

    Compute a partial checksum on a portion of an imagefile.

Arguments:

    PartialSum - Supplies the initial checksum value.

    Sources - Supplies a pointer to the array of words for which the
        checksum is computed.

    Length - Supplies the length of the array in words.

Return Value:

    The computed checksum value is returned as the function value.

--*/

{

    //
    // Compute the word wise checksum allowing carries to occur into the
    // high order half of the checksum longword.
    //

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xffff);
    }

    //
    // Fold final carry into a single word result and return the resultant
    // value.
    //

    return (USHORT)(((PartialSum >> 16) + PartialSum) & 0xffff);
}


/*******************************************************************************
 *
 *  Usage
 *
 ******************************************************************************/

VOID
Usage( BOOL bError )
{

    if ( !Is_X86_OS() )
    {
        ErrorPrintf( IDS_X86_ONLY );
        return;
    }

    if ( bError ) 
    {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE1);
        ErrorPrintf(IDS_USAGE2);
        ErrorPrintf(IDS_USAGE3);
        ErrorPrintf(IDS_USAGE4);
        ErrorPrintf(IDS_USAGE7);
    }
    else {
       Message(IDS_USAGE1);
       Message(IDS_USAGE2);
       Message(IDS_USAGE3);
       Message(IDS_USAGE4);
       Message(IDS_USAGE7);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\remotepage\registry.cpp ===
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <windows.h>
#include <objbase.h>
#include <olectl.h>

extern GUID CLSID_CTSRemotePage;

LPCWSTR g_szExtKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\"
        L"System\\shellex\\PropertySheetHandlers\\Remote Sessions CPL Extension";
LPCWSTR g_szApprovedKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved";
const WCHAR g_szExtName[] = L"Remote Sessions CPL Extension";

//*************************************************************
//
//  RegisterServer()
//
//  Purpose:    Register the component in the registry
//
//  Parameters: hModule    -   handle to this dll module
//
//
//  Return:     S_OK  if success, error code otherwise
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/26/00    a-skuzin    Created
//              10/27/00   skuzin      Added registration of the 
//                                     component as "Approved" CPL
//                                     extension  
//                                     
//
//*************************************************************
HRESULT 
RegisterServer(HMODULE hModule)
{
    // Get server location.
    WCHAR szModule[MAX_PATH+1] ;

    if(!GetModuleFileName(hModule, szModule, MAX_PATH))
    {
        return E_UNEXPECTED;
    }
    
    // Get CLSID
    LPOLESTR szCLSID = NULL ;
    HRESULT hr = StringFromCLSID(CLSID_CTSRemotePage, &szCLSID) ;
    
    if(FAILED(hr))
    {
        return hr;
    }
    
    // Build the key CLSID\\{...}
    LPWSTR szKey = new WCHAR[wcslen(L"CLSID\\")+wcslen(szCLSID)+1];

    if(!szKey)
    {
        CoTaskMemFree(szCLSID);
        return E_OUTOFMEMORY;
    }

    wcscpy(szKey, L"CLSID\\") ;
	wcscat(szKey, szCLSID) ;
    
    HKEY hKey1,hKey2;
    LONG Err, TotalErr = 0;
    
    // Create "CLSID\{...}" key
    Err = RegCreateKeyExW(HKEY_CLASSES_ROOT, szKey, 0, NULL, 0, KEY_WRITE, NULL, &hKey1, NULL);
    
    delete szKey;
    
    TotalErr |= Err;

    if(Err == ERROR_SUCCESS ) 
    {
        Err = RegSetValueExW(hKey1, NULL, 0, REG_SZ, 
            (CONST BYTE *)g_szExtName, 
            sizeof(g_szExtName));
        
        TotalErr |= Err;
        
        // Create "CLSID\{...}\InprocServer32" key
        Err = RegCreateKeyExW(hKey1, L"InprocServer32", 0, NULL, 0, KEY_WRITE, NULL, &hKey2, NULL);
        
        TotalErr |= Err;

        RegCloseKey(hKey1);

        if(Err == ERROR_SUCCESS)
        {
            Err = RegSetValueExW(hKey2, NULL, 0, REG_SZ, 
                    (CONST BYTE *)szModule, 
                    (wcslen(szModule)+1)*sizeof(WCHAR));

            TotalErr |= Err;

            Err = RegSetValueExW(hKey2, L"ThreadingModel", 0, REG_SZ, 
                    (CONST BYTE *)L"Apartment", 
                    (wcslen(L"Apartment")+1)*sizeof(WCHAR));
            
            TotalErr |= Err;

            RegCloseKey(hKey2);
        }
        
    }
    
    //Register the component as System property sheet extension
    Err = RegCreateKeyExW(HKEY_LOCAL_MACHINE, g_szExtKey, 0, NULL, 0, KEY_WRITE, NULL, &hKey1, NULL);
    
    TotalErr |= Err;

    if(Err == ERROR_SUCCESS ) 
    {
        Err = RegSetValueExW(hKey1, NULL, 0, REG_SZ, 
            (CONST BYTE *)szCLSID, 
            (wcslen(szCLSID)+1)*sizeof(WCHAR));
        
        TotalErr |= Err;

        RegCloseKey(hKey1);
    }
    
    //Make this property sheet extension "Approved"
    Err = RegCreateKeyExW(HKEY_LOCAL_MACHINE, g_szApprovedKey, 0, NULL, 0, KEY_WRITE, NULL, &hKey1, NULL);
    
    TotalErr |= Err;

    if(Err == ERROR_SUCCESS ) 
    {
        Err = RegSetValueExW(hKey1, szCLSID, 0, REG_SZ, 
            (CONST BYTE *)g_szExtName, 
            sizeof(g_szExtName));
        
        TotalErr |= Err;

        RegCloseKey(hKey1);
    }

    // Free memory.
    CoTaskMemFree(szCLSID) ;

    if( TotalErr == ERROR_SUCCESS )
    {
       return S_OK; 
    }
    else
    {
        return SELFREG_E_CLASS;
    }
}

//*************************************************************
//
//  UnregisterServer()
//
//  Purpose:    Deletes the component registration values 
//              from the registry
//
//  Parameters: NONE
//
//
//  Return:     S_OK  if success, error code otherwise
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/26/00    a-skuzin    Created
//              10/27/00   skuzin      Modifyed to reflect 
//                                     changes in RegisterServer()
//
//*************************************************************
HRESULT 
UnregisterServer()       
{
    // Get CLSID
    LPOLESTR szCLSID = NULL ;
    HRESULT hr = StringFromCLSID(CLSID_CTSRemotePage, &szCLSID) ;
    
    if(FAILED(hr))
    {
        return hr;
    }
    
    // Build the key CLSID\\{...}\\InprocServer32
    LPWSTR szKey = new WCHAR[wcslen(L"CLSID\\")+wcslen(szCLSID)+wcslen(L"\\InprocServer32")+1];

    if(!szKey)
    {
        CoTaskMemFree(szCLSID);
        return E_OUTOFMEMORY;
    }

    wcscpy(szKey, L"CLSID\\");
	wcscat(szKey, szCLSID);
    wcscat(szKey, L"\\InprocServer32");
    
    LONG Wrn, Err, TotalErr = ERROR_SUCCESS;
    
    // Delete "CLSID\{...}\InprocServer32" key
    Err = RegDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    
    TotalErr |= Err;

    //Try to delete "CLSID\{...}" key
    //It is not an error if we cannot do this.
    if(Err == ERROR_SUCCESS )
    {
        szKey[wcslen(szKey)-wcslen(L"\\InprocServer32")] = 0;
        Wrn = RegDeleteKey(HKEY_CLASSES_ROOT, szKey);
    }

    delete szKey;
    
    //Delete Property Sheet Handler registration
    TotalErr |= RegDeleteKey(HKEY_LOCAL_MACHINE, g_szExtKey);
    
    //Remove component from list of "Approved" extensions
    HKEY hKey;
    Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,g_szApprovedKey,0,KEY_WRITE,&hKey);

    TotalErr |= Err;

    if( Err == ERROR_SUCCESS )
    {
        TotalErr|= RegDeleteValue(hKey,szCLSID);

        RegCloseKey(hKey);
    }

    // Free memory.
    CoTaskMemFree(szCLSID);

    if( TotalErr == ERROR_SUCCESS )
    {
        if(Wrn == ERROR_SUCCESS)
        {
            return S_OK; 
        }
        else
        {
            //we could not delete "CLSID\{...}" key
            //probably it has subkeys created by a user.
            return S_FALSE;
        }
    }
    else
    {
        return SELFREG_E_CLASS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\remotepage\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RemotePage.rc
//
#define IDI_REMOTE                      500
#define IDI_LOC_USER                    501
#define IDI_GLOB_USER                   502
#define IDI_LOC_GROUP                   503
#define IDI_GLOB_GROUP                  504
#define IDI_UNKNOWN                     505
#define IDD_REMOTE_PTS                  510
#define IDD_REMOTE_APPSERVER            511
#define IDD_DISABLE_OFFLINE_FILES       512
#define IDD_REMOTE_DESKTOP_USERS        513
#define IDD_REMOTE_PERSONAL             514
#define IDS_ERR_SAVE_REGISTRY           520
#define IDS_ERR_SAVE_MEMBERS            521
#define IDS_REMOTE_SESSIONS             522
#define IDS_WRN_NO_PERMISSIONS          523
#define IDS_OTHER_USERS                 524
#define IDS_USER_HAS_ASSESS             525
#define IDS_WRN_EMPTY_PASSWORD          526
#define IDS_PAGE_TITLE                  527
#define IDC_REMOTE_ENABLE               530
#define IDC_REMOTE_USR_LIST             531
#define IDC_REMOTE_USR_ADD              532
#define IDC_REMOTE_USR_REMOVE           533
#define IDC_REMOTE_UPLINK               534
#define IDC_REMOTE_GPLINK_APPSERVER     535
#define IDC_REMOTE_SCLINK_APPSERVER     536
#define IDC_OFFLINE_FILES               537
#define IDC_REMOTE_COMPNAME             538
#define IDC_REMOTE_HELP                 539
#define IDC_REMOTE_HELP_APPSERVER       540
#define IDC_REMOTE_SELECT_USERS         541
#define IDC_USER_HAS_ACCESS             542
#define IDC_DEFAULT1                    550
#define IDC_DEFAULT2                    551
#define IDC_DEFAULT3                    552
#define IDC_DEFAULT4                    553
#define IDC_DEFAULT5                    554
#define IDC_REMOTE_ASSISTANCE_ADVANCED  555
#define IDC_ENABLERA                    556
#define IDC_REMOTERA_HELP               557


// Title of the propertysheet, we choose a special ID since this will be accessed from the outside world
#define IDS_PROPSHEET_TITLE             10000


//Help message IDs
#define HIDC_REMOTE_ENABLE              15001    // (hook up to the "Allow users" checkbox)
#define HIDC_REMOTE_USR_LIST            15002    // (hook up to the "Remote Desktop Users" display window)
#define HIDC_REMOTE_USR_ADD             15003    // (hook up to the Add... button)
#define HIDC_REMOTE_USR_REMOVE          15004    // (hook up to the Remove button)

//Help message IDs for Remote Assistance setup
#define HIDC_RA_ADVANCED                15005
#define HIDC_RA_ENABLE                  15006
#define HIDC_RA_ALLOWUNSOLICIT          15007
#define HIDC_RA_ALLOWRC                 15008
#define HIDC_RA_EXPIRY                  15009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        566
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           200
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\reset\reset.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  RESET.H
*
*   This module contains typedefs and defines required for the RESET utility
*   menu.
*
*  
******************************************************************************/

/*
 * Usage string definitions.
 */
#define UTILITY_NAME    L"RESET"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_REGISTRY_FAILURE                      102
#define IDS_ERROR_NOT_TS                                103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\rmvlnks\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// resource.h 
// resource defines for rmvlnks utility


#define IDS_PROFILES                    250
#define IDS_ACCESSORIES_SUBPATH         251
#define IDS_MAIN_SUBPATH                252
#define IDS_ALLUSERS                    253
#define IDS_DEFAULTUSER                 254
#define IDS_ACCESSPROG1                 255
#define IDS_ACCESSDESC1                 256
#define IDS_ACCESSPROG2                 257
#define IDS_ACCESSDESC2                 258
#define IDS_MAINPROG1                   259
#define IDS_MAINDESC1                   260
#define IDS_MAINPROG2                   261
#define IDS_MAINDESC2                   262
#define IDS_NETWAREUSER                 263
#define IDS_WFCDISKCREATOR              264
#define IDS_APPSECREG                   265
#define IDS_WFSETUP                     266
#define IDS_WFBOOKS                     267
#define IDS_WFHELP                      268
#define IDS_ADMINTOOLS_SUBPATH          269
#define IDS_ADMINISTRATOR               270
#define IDS_STARTUP_SUBPATH             271
#define IDS_WINLOGON_KEY                272
#define IDS_APPSETUP                    273
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\reset\reset.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*************************************************************************
*
*  RESET.C
*     This module is the RESET utility code.
*
*
*************************************************************************/

#include <stdio.h>
#include <windows.h>
//#include <ntddkbd.h>
//#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>
#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>

#include "reset.h"

/*-----------------------------------------------------------------------
-- Supported commands (now obtained from registry)
------------------------------------------------------------------------*/
PPROGRAMCALL pProgList = NULL;

/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );



/*************************************************************************
*
*  main
*     Main function and entry point of the text-based RESET
*     menu utility.
*
*  ENTRY:
*       argc (input)
*           count of the command line arguments.
*       argv (input)
*           vector of strings containing the command line arguments;
*           (not used due to always being ANSI strings).
*
*  EXIT
*       (int) exit code: SUCCESS for success; FAILURE for error.
*
*************************************************************************/

int __cdecl
main( INT argc,
      CHAR **argv )
{
    PWCHAR        arg, *argvW;
    PPROGRAMCALL  pProg, pProgramCall = NULL;
    int           len, j, status = FAILURE;
    LONG    regstatus;

    setlocale(LC_ALL, ".OCP");

    /*
     * Obtain the supported RESET commands from registry.
     */
    if ( (regstatus =
            RegQueryUtilityCommandList( UTILITY_REG_NAME_RESET, &pProgList ))
            != ERROR_SUCCESS ) {

        ErrorPrintf(IDS_ERROR_REGISTRY_FAILURE, UTILITY_NAME, regstatus);
        goto exit;
    }

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        goto exit;
    }

    /*
     * Check for valid utility name and execute.
     */
    if ( argc > 1 && *(argvW[1]) ) {

        len = wcslen(arg = argvW[1]);
        for ( pProg = pProgList->pFirst; pProg != NULL; pProg = pProg->pNext ) {

            if ( (len >= pProg->CommandLen) &&
                 !_wcsnicmp( arg, pProg->Command, len ) ) {

                pProgramCall = pProg;
                break;
            }
        }

        if ( pProgramCall ) {

                if ( ExecProgram(pProgramCall, argc - 2, &argvW[2]) )
                goto exit;

        } else if ( ((arg[0] == L'-') || (arg[0] == L'/')) &&
                    (arg[1] == L'?') ) {

            /*
             * Help requested.
             */
            Usage(FALSE);
            status = SUCCESS;
            goto exit;

        } else {

            /*
             * Bad command line.
             */
            Usage(TRUE);
            goto exit;
        }

    } else {

        /*
         * Nothing on command line.
         */
        Usage(TRUE);
        goto exit;
    }

exit:
    if ( pProgList )
        RegFreeUtilityCommandList(pProgList);   // let's be tidy

    return(status);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }

    ProgramUsage(UTILITY_NAME, pProgList, bError);

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\remotepage\remotepage.h ===
#pragma once

#include <windows.h>
#include <objbase.h>
#include <objsel.h>
#include <shlobj.h>

//
#define TSCFG_MUTEXNAME TEXT("Global\\TerminalServerConfigMutex")

//***************************************************************************************
//class CRemoteUsersDialog
//***************************************************************************************
class CRemoteUsersDialog
{
private:
    HINSTANCE   m_hInst;
    HWND        m_hDlg;
    HWND        m_hList;
    WCHAR       m_szRemoteGroupName[MAX_PATH+1];
    WCHAR       m_szLocalCompName[MAX_PATH+1];
    BOOL        m_bCanShowDialog;
    //image indexes
    int m_iLocUser,m_iGlobUser,m_iLocGroup,m_iGlobGroup,m_iUnknown;
public:
    CRemoteUsersDialog(HINSTANCE hInst);
    INT_PTR DoDialog(HWND hwndParent);
    BOOL CanShowDialog(LPBOOL pbAccessDenied);
    void OnInitDialog(HWND hDlg);
    void OnLink(WPARAM wParam);
    BOOL OnOk();
    void OnItemChanged(LPARAM lParam);
    void OnDestroyWindow();
    void AddUsers();
    void RemoveUsers();
private:
    void AddPickerItems(DS_SELECTION_LIST *selections);
    int FindItemBySid(PSID pSid);
    void ReloadList();
    BOOL IsLocal(LPWSTR wszDomainandname);
    void InitAccessMessage();

};

INT_PTR APIENTRY RemoteUsersDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

//***************************************************************************************
//class CRemotePage
//***************************************************************************************
class CRemotePage : public IShellExtInit, IShellPropSheetExt
{
private:
    //reference counter
    ULONG				m_cref;
    
    BOOL        m_bProfessional;
    DWORD       m_dwPageType;
    HINSTANCE   m_hInst;
    HWND        m_hDlg;
    DWORD       m_dwInitialState;
    BOOL        m_bDisableChkBox;
    BOOL        m_bDisableButtons;
    BOOL        m_bShowAccessDeniedWarning;
    WORD        m_TemplateId;

    CRemoteUsersDialog m_RemoteUsersDialog;
public:
    
    CRemotePage(HINSTANCE hinst);
    ~CRemotePage();
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    ///////////////////////////////
    // Interface IShellExtInit
    ///////////////////////////////   
    STDMETHODIMP Initialize(LPCITEMIDLIST , LPDATAOBJECT , HKEY );

    ///////////////////////////////
    // Interface IShellPropSheetExt
    /////////////////////////////// 
    STDMETHODIMP AddPages( LPFNADDPROPSHEETPAGE ,  LPARAM );
    STDMETHODIMP ReplacePage( UINT , LPFNADDPROPSHEETPAGE , LPARAM );
    
    ///////////////////////////////
    // Internal functions
    /////////////////////////////// 
    void OnInitDialog(HWND hDlg);
    void OnSetActive();
    BOOL OnApply();
    void OnLink(WPARAM wParam);
    BOOL OnRemoteEnable();
    void OnRemoteSelectUsers();
    void RemoteEnableWarning();
private:
    BOOL CanShowRemotePage();

};

INT_PTR APIENTRY RemoteDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#define PAGE_TYPE_UNKNOWN   0
#define PAGE_TYPE_PTS       1
#define PAGE_TYPE_APPSERVER 2
#define PAGE_TYPE_PERSONAL  3

//***************************************************************************************
//class CWaitCursor
//***************************************************************************************
class CWaitCursor
{
private:
    HCURSOR m_hOldCursor;
public:
    CWaitCursor()
    {
        m_hOldCursor=SetCursor(LoadCursor(NULL,IDC_WAIT));
    }
    ~CWaitCursor()
    {
        SetCursor(m_hOldCursor);
    }
};

//***************************************************************************************
//class CMutex
//***************************************************************************************
class CMutex
{
private:
    HANDLE m_hMutex;
public:
    CMutex() : m_hMutex(NULL)
    {
        m_hMutex=CreateMutex(NULL,TRUE,TSCFG_MUTEXNAME);
        if(m_hMutex)
        {
            //wait up to 30 sec.
            WaitForSingleObject(m_hMutex,30000);
        }
    }
    ~CMutex()
    {
        if(m_hMutex)
        {
            ReleaseMutex(m_hMutex);
            CloseHandle(m_hMutex);
        }
    }
};

//***************************************************************************************
//class COfflineFilesDialog
//***************************************************************************************
class COfflineFilesDialog
{
private:
    HINSTANCE   m_hInst;
    HWND        m_hDlg;
public:
    COfflineFilesDialog(HINSTANCE hInst);
    INT_PTR DoDialog(HWND hwndParent);
    void OnInitDialog(HWND hDlg);
    void OnLink(WPARAM wParam);
};

INT_PTR APIENTRY OfflineFilesDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

//***************************************************************************************
//Global functions
//***************************************************************************************
BOOL
getGroupMembershipPickerSettings(
   DSOP_SCOPE_INIT_INFO*&  infos,
   ULONG&                  infoCount);

HRESULT VariantToSid(VARIANT* var, PSID *ppSid);

BOOL TestUserForAdmin();

void DisplayError(HINSTANCE hInst, HWND hDlg, UINT ErrID, UINT MsgID, UINT TitleID, ...);

BOOL LookupSid(IN PSID pSid, OUT LPWSTR *ppName, OUT SID_NAME_USE *peUse);

BOOL GetTokenUserName(IN HANDLE hToken,OUT LPWSTR *ppName);

BOOL GetRDPSecurityDescriptor(OUT PSECURITY_DESCRIPTOR *ppSD);

BOOL CheckWinstationLogonAccess(IN HANDLE hToken,IN PSECURITY_DESCRIPTOR pSD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\remotepage\remotepage.cpp ===
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "RemotePage.h"
#include <lm.h>
#include <crtdbg.h>
#include <shellapi.h>
#include <htmlhelp.h>
#include "resource.h"
#include <shgina.h>
#include "RAssistance.h"
#include "RAssistance_i.c"
#include <winsta.h>
#include "cfgbkend.h"
#include "cfgbkend_i.c"

extern ULONG g_uObjects;

IRASettingProperty* g_praSetting = NULL; // Used for Remote assistance setting

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control
//Table of help IDs for each control
DWORD aHelpIds[] = {
    IDC_REMOTE_ENABLE,              HIDC_REMOTE_ENABLE,               
    IDC_REMOTE_USR_LIST,            HIDC_REMOTE_USR_LIST,
    IDC_REMOTE_USR_ADD,             HIDC_REMOTE_USR_ADD,
    IDC_REMOTE_USR_REMOVE,          HIDC_REMOTE_USR_REMOVE,
    IDC_REMOTE_ASSISTANCE_ADVANCED, HIDC_RA_ADVANCED,
    IDC_ENABLERA,                   HIDC_RA_ENABLE,
    IDC_REMOTE_UPLINK,              NO_HELP,
    IDC_REMOTE_GPLINK_APPSERVER,    NO_HELP,
    IDC_REMOTE_SCLINK_APPSERVER,    NO_HELP,
    IDC_OFFLINE_FILES,              NO_HELP,
    IDC_REMOTE_COMPNAME,            NO_HELP,
    IDC_REMOTE_HELP,                NO_HELP,
    IDC_REMOTE_SELECT_USERS,        NO_HELP,
    IDC_DEFAULT1,                   NO_HELP,
    IDC_DEFAULT2,                   NO_HELP,
    IDC_DEFAULT3,                   NO_HELP,
    IDC_DEFAULT4,                   NO_HELP,
    IDC_DEFAULT5,                   NO_HELP,
    0,                              0
};



//*************************************************************
//
//  CRemotePage::CRemotePage()
//
//  Purpose:    Initializes data members of the object
//
//  Parameters: HINSTANCE hinst 
//
//  Return:     NONE
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
CRemotePage::CRemotePage(
        IN HINSTANCE hinst) : 
        m_RemoteUsersDialog(hinst)
{
    m_cref = 1; //
    m_bProfessional = FALSE;
    m_dwPageType = PAGE_TYPE_UNKNOWN;
    m_hInst = hinst;
    m_bDisableChkBox = FALSE;
    m_bDisableButtons = FALSE;
    m_bShowAccessDeniedWarning = FALSE;
    m_dwInitialState = 0;
    m_hDlg = NULL;
    m_TemplateId = 0;

    g_uObjects++;
}

//*************************************************************
//
//  CRemotePage::~CRemotePage()
//
//  Purpose:    decreases the object counter
//
//  Parameters: NONE 
//
//  Return:     NONE
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
CRemotePage::~CRemotePage()
{
    g_uObjects--;
}

///////////////////////////////
// Interface IUnknown
///////////////////////////////
STDMETHODIMP 
CRemotePage::QueryInterface(
        IN  REFIID riid, 
        OUT LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IShellPropSheetExt *>(this);
    else if (IsEqualIID(riid, IID_IShellExtInit))
        *ppv = static_cast<IShellExtInit *>(this);
    else if (IsEqualIID(riid, IID_IShellPropSheetExt))
        *ppv = static_cast<IShellPropSheetExt *>(this);
    
    if (*ppv)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) 
CRemotePage::AddRef()
{
    return ++m_cref;
}

STDMETHODIMP_(ULONG) 
CRemotePage::Release()
{
    m_cref--;

    if (!m_cref)
    {
        delete this;
        return 0;
    }
    return m_cref;

}


///////////////////////////////
// Interface IShellExtInit
///////////////////////////////   

STDMETHODIMP 
CRemotePage::Initialize(
        IN LPCITEMIDLIST pidlFolder,
        IN LPDATAOBJECT lpdobj,
        IN HKEY hkeyProgID )
{
    return S_OK;
}

///////////////////////////////
// Interface IShellPropSheetExt
/////////////////////////////// 
//*************************************************************
//
//  AddPages()
//
//  Purpose:    Adds "Remote" tab to a property sheet
//
//  Parameters: lpfnAddPage    -   function to call to add a page
//              lParam - Parameter to pass to the function specified by the lpfnAddPage 

//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
STDMETHODIMP 
CRemotePage::AddPages( 
        IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
        IN LPARAM lParam )
{
    
    if(CanShowRemotePage())
    {
        PROPSHEETPAGE psp;
    
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = 0;
        psp.hInstance = m_hInst;
        psp.pszTemplate = MAKEINTRESOURCE(m_TemplateId);
        psp.pfnDlgProc = RemoteDlgProc;
        psp.pszTitle = NULL;
        psp.lParam = (LPARAM)this;

        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&psp);

        if(hPage && lpfnAddPage(hPage,lParam))
        {
            return S_OK;
        }
    }

    return E_FAIL;    
}

STDMETHODIMP 
CRemotePage::ReplacePage(
        IN UINT uPageID,
        IN LPFNADDPROPSHEETPAGE lpfnReplacePage,
        IN LPARAM lParam )
{
    return E_FAIL; 
}


//*************************************************************
//
//  RemoteDlgProc()
//
//  Purpose:    Dialog box procedure for Remote tab
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
INT_PTR APIENTRY 
RemoteDlgProc (
        HWND hDlg, 
        UINT uMsg, 
        WPARAM wParam, 
        LPARAM lParam)
{
    CRemotePage *pPage = (CRemotePage *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            PROPSHEETPAGE *ppsp=(PROPSHEETPAGE *)lParam;
            pPage = (CRemotePage *)ppsp->lParam;

             
            SetWindowLongPtr(hDlg,DWLP_USER,(LONG_PTR)pPage);
            if(pPage)
            {
                pPage->AddRef();
                pPage->OnInitDialog(hDlg);
            }
        }       
        break;

    case WM_NOTIFY:
        
        switch (((NMHDR FAR*)lParam)->code)
        {

        case NM_CLICK:
        case NM_RETURN:
            // Is for RA's help?
            if (wParam == IDC_REMOTERA_HELP)
            {
#if 1
#define HELP_PATH TEXT("\\PCHEALTH\\HelpCtr\\Binaries\\HelpCtr.exe -FromStartHelp -Mode \"hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote Assistance/RAIMLayout.xml\" -Url \"hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote%20Assistance/Common/RCMoreInfo.htm\"")
                TCHAR szCommandLine[2000];
                PROCESS_INFORMATION ProcessInfo;
                STARTUPINFO StartUpInfo;

                TCHAR szWinDir[2048];
                GetWindowsDirectory(szWinDir, 2048);

                ZeroMemory((LPVOID)&StartUpInfo, sizeof(STARTUPINFO));
                StartUpInfo.cb = sizeof(STARTUPINFO);    

                wsprintf(szCommandLine, TEXT("%s%s"), szWinDir,HELP_PATH);
                CreateProcess(NULL, szCommandLine,NULL,NULL,TRUE,CREATE_NEW_PROCESS_GROUP,NULL,&szWinDir[0],&StartUpInfo,&ProcessInfo);
#else
	            HtmlHelp(NULL, TEXT("rassist.chm"), HH_HELP_FINDER, 0);
#endif
            }
            else if(pPage)
            {
                pPage->OnLink(wParam);
            }
            break;

        case PSN_APPLY:
            if(pPage)
            {
                if(pPage->OnApply())
                {
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT,PSNRET_NOERROR);    
                }
                else
                {
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT,PSNRET_INVALID);        
                }
            }
            return TRUE;

        case PSN_SETACTIVE:
            if(pPage)
            {
                pPage->OnSetActive();
            }
            return TRUE;

        default:
            return FALSE;
        }
   
        break;

    case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
            case IDC_REMOTE_ENABLE:
                if(pPage && pPage->OnRemoteEnable())
                {
                    pPage->RemoteEnableWarning();
                    PropSheet_Changed(GetParent(hDlg), hDlg);
                }
                break;
            case IDC_REMOTE_SELECT_USERS:
                if(pPage)
                {
                    pPage->OnRemoteSelectUsers();
                }
                break;
			// Remote Assistance Dialog button.
            case IDC_REMOTE_ASSISTANCE_ADVANCED:
                {
                    BOOL bIsChanged = FALSE;
                    if (!g_praSetting)
                    {
                        CoCreateInstance(CLSID_RASettingProperty,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_IRASettingProperty,
                                      reinterpret_cast<void**>(&g_praSetting));
                        // Need to init it at the first time.
                        if (g_praSetting)
                        {
                            g_praSetting->Init();
                        }
                        else
                        {
                            // Not enough memory, too bad.
                            return TRUE;
                        }
                    }

                    g_praSetting->ShowDialogBox(hDlg);
                    if (SUCCEEDED(g_praSetting->get_IsChanged(&bIsChanged)) && bIsChanged)
                    {
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }
                }
                break;

            case IDC_ENABLERA:
                {
                    PropSheet_Changed(GetParent(hDlg), hDlg);					
                    EnableWindow(GetDlgItem(hDlg,IDC_REMOTE_ASSISTANCE_ADVANCED),
        				            IsDlgButtonChecked(hDlg, IDC_ENABLERA));
                }
                break;

            default:
                
                break;
            }
        }
        return FALSE;
    
    case WM_DESTROY:
        if(pPage)
        {
            pPage->Release();
        }

        if (g_praSetting)
        {
            g_praSetting->Release();
            g_praSetting = NULL;
        }

        return FALSE; //If an application processes this message, it should return zero.

    case WM_HELP:
        {
            LPHELPINFO phi=(LPHELPINFO)lParam;
            if(phi && phi->dwContextId)
            {   
                WinHelp(hDlg,TEXT("SYSDM.HLP"),HELP_CONTEXTPOPUP,phi->dwContextId);
            }
        }
        break;

    case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, TEXT("SYSDM.HLP"), HELP_CONTEXTMENU,
                (DWORD_PTR)aHelpIds);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  CRemotePage::CanShowRemotePage()
//
//  Purpose:    Checks Windows version;
//              searches for "FDenyTSConnections" value first
//              in HKLM\\Software\\Policies\\Microsoft\\Windows NT\\Terminal Services
//              if not found than in
//              SYSTEM\\CurrentControlSet\\Control\\Terminal Server;
//              creates "Remote Desktop Users" SID,
//              gets "Remote Desktop Users" group name from the SID
//
//  Parameters: hInst   -   hInstance
//              dwPageType - can be PAGE_TYPE_PTS or PAGE_TYPE_APPSERVER
//
//  Return:     TRUE if can show remote page 
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************

BOOL 
CRemotePage::CanShowRemotePage()
{

    BOOL    fCreatePage = FALSE;
    
    //Check Windows version
    OSVERSIONINFOEX ov;
    ov.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if(!GetVersionEx((LPOSVERSIONINFO)&ov))
    {
        return FALSE;
    }
    if(ov.wProductType == VER_NT_WORKSTATION && 
        (ov.wSuiteMask & VER_SUITE_SINGLEUSERTS ))
    {
        fCreatePage = TRUE;

        if(ov.wSuiteMask & VER_SUITE_PERSONAL)
        {
#ifdef _WIN64
            // No Remote Assistance on IA64
            fCreatePage = FALSE;
#else
            m_dwPageType = PAGE_TYPE_PERSONAL;
            m_TemplateId = IDD_REMOTE_PERSONAL;
#endif
        }
        else
        {
            m_bProfessional = TRUE;
            m_dwPageType = PAGE_TYPE_PTS;
            m_TemplateId = IDD_REMOTE_PTS;
        }
    }
    else
    {
        if((ov.wProductType == VER_NT_DOMAIN_CONTROLLER || ov.wProductType ==  VER_NT_SERVER) &&
            (ov.wSuiteMask & VER_SUITE_TERMINAL) &&
            TestUserForAdmin())
        {
            fCreatePage = TRUE;

            if(ov.wSuiteMask & VER_SUITE_SINGLEUSERTS)
            {
                m_dwPageType = PAGE_TYPE_PTS; 
                m_TemplateId = IDD_REMOTE_PTS;
            }
            else
            {
                m_dwPageType = PAGE_TYPE_APPSERVER;
                m_TemplateId = IDD_REMOTE_APPSERVER;
            }
        }
 
    }
    
    if( !fCreatePage)
    {
        return FALSE;
    }

    DWORD dwType;
    DWORD cbDisable;
    LONG Err;
    HKEY hKey;

    Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Policies\\Microsoft\\Windows NT\\Terminal Services"),
        0,
        KEY_QUERY_VALUE,
        &hKey);

    if(Err == ERROR_SUCCESS)
    {
        cbDisable = sizeof(DWORD);

        Err = RegQueryValueEx(hKey,
                     TEXT("fDenyTSConnections"),
                     NULL,
                     &dwType,
                     (LPBYTE)&m_dwInitialState,
                     &cbDisable);
        
        if(Err == ERROR_SUCCESS)
        {
            m_bDisableChkBox = TRUE;

            if(m_dwInitialState != 0)
            {
                m_bDisableButtons = TRUE;
            }
        }

        RegCloseKey(hKey);
    }

    if(Err != ERROR_SUCCESS)
    {
        if(Err != ERROR_FILE_NOT_FOUND)
        {
            return FALSE;
        }

        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"),
                        0,
                        KEY_QUERY_VALUE,
                        &hKey);

        if(Err == ERROR_SUCCESS)
        {
            cbDisable = sizeof(DWORD);

            Err = RegQueryValueEx(hKey,
                     TEXT("fDenyTSConnections"),
                     NULL,
                     &dwType,
                     (LPBYTE)&m_dwInitialState,
                     &cbDisable);

            RegCloseKey(hKey);
        }

        if(Err != ERROR_SUCCESS && Err != ERROR_FILE_NOT_FOUND )
        {
            return FALSE;
        }
    }
    

    
    //Check permissions
    //on the registry
    if( !m_bDisableChkBox )
    {
        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"),
                            0,
                            KEY_SET_VALUE,
                            &hKey);
        if( Err == ERROR_SUCCESS )
        {
            RegCloseKey(hKey);
        }
        else
        {
            if(  Err == ERROR_ACCESS_DENIED )
            {
                m_bDisableChkBox = TRUE;
                m_bShowAccessDeniedWarning = TRUE;
            }
        }
    }

    if(m_dwPageType == PAGE_TYPE_PTS)
    {
        if(!m_bDisableButtons)
        {
            if(!m_RemoteUsersDialog.CanShowDialog(&m_bDisableButtons))
            {
                return FALSE;
            }

            if(m_bDisableButtons)
            {
                m_bShowAccessDeniedWarning = TRUE;
            }
        }
    }

    return TRUE;
}

//*************************************************************
//
//  CRemotePage::OnInitDialog()
//
//  Purpose:    initializes check box state 
//              creates list of "Remote Desktop Users" members
//
//  Parameters: hDlg   -   the page handle 
//
//  Return:     NONE
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
void 
CRemotePage::OnInitDialog(
        IN HWND hDlg)
{
    m_hDlg = hDlg;
    
    /* Get Remote Assistance button value */
    BOOL bRAEnable = FALSE;
    int  iErr;
    HKEY hKey = NULL;
    IRARegSetting* pRA = NULL;
    CoCreateInstance(CLSID_RARegSetting,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IRARegSetting,
        reinterpret_cast<void**>(&pRA));
    if (pRA)
    {
        pRA->get_AllowGetHelpCPL(&bRAEnable);
        pRA->Release();
    }

    CheckDlgButton(m_hDlg, IDC_ENABLERA, bRAEnable?BST_CHECKED:BST_UNCHECKED);
    // check if users have permission to change this setting.
    iErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"),
                        0,
                        KEY_SET_VALUE,
                        &hKey);
    if (iErr == ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
    }
    else if (iErr == ERROR_ACCESS_DENIED)
    {
        bRAEnable = FALSE;
        EnableWindow(GetDlgItem(m_hDlg,IDC_ENABLERA), FALSE);
    }

    EnableWindow(GetDlgItem(m_hDlg,IDC_REMOTE_ASSISTANCE_ADVANCED), bRAEnable);

    /***** RA done *******/

    if(m_bDisableChkBox)
    {
        EnableWindow(GetDlgItem(m_hDlg,IDC_REMOTE_ENABLE),FALSE);   
    }
    
    CheckDlgButton(m_hDlg,IDC_REMOTE_ENABLE,m_dwInitialState?BST_UNCHECKED:BST_CHECKED);
    
    if(m_dwPageType == PAGE_TYPE_PTS)
    {

        if(m_bDisableButtons)
        {
            EnableWindow(GetDlgItem(m_hDlg,IDC_REMOTE_SELECT_USERS),FALSE); 
        }

        //Get computer name
        LPTSTR  szCompName = (LPTSTR)LocalAlloc (LPTR, (MAX_PATH+1) * sizeof(TCHAR) );
        DWORD   dwNameSize = MAX_PATH;
        
        if(szCompName)
        {
            BOOL bResult = GetComputerNameEx( ComputerNameDnsFullyQualified, szCompName, &dwNameSize );

            if(!bResult && GetLastError() == ERROR_MORE_DATA)
            {
                LocalFree(szCompName);
                szCompName = (LPTSTR) LocalAlloc (LPTR, (dwNameSize+1) * sizeof(TCHAR) );

                if ( szCompName ) 
                {
                    bResult = GetComputerNameEx( ComputerNameDnsFullyQualified, szCompName, &dwNameSize );
                }
                
            }

            if(bResult)
            {
                SetDlgItemText(hDlg,IDC_REMOTE_COMPNAME,szCompName);     
            }

            if(szCompName)
            {
                LocalFree(szCompName);
            }
        }

    }

}

//*************************************************************
//
//  CRemotePage::OnSetActive()
//
//  Purpose:    When the page gets active and user does not have
//              permissions to change some settings it shows
//              a warning message.
//
//  Parameters: NONE   
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
void 
CRemotePage::OnSetActive()
{
    TCHAR szMsg[MAX_PATH+1];
    TCHAR szTitle[MAX_PATH+1];

    if( m_bShowAccessDeniedWarning )
    {
        if(LoadString(m_hInst,IDS_REMOTE_SESSIONS,szTitle,MAX_PATH) &&
            LoadString(m_hInst,IDS_WRN_NO_PERMISSIONS,szMsg,MAX_PATH))
        {
            MessageBox(m_hDlg,szMsg,szTitle,MB_OK|MB_ICONINFORMATION);
        }

        m_bShowAccessDeniedWarning = FALSE;        
    }
}

//*************************************************************
//
//  CRemotePage::OnApply()
//
//  Purpose:    saves settings in the Registry
//              saves "Remote Desktop Users" membership changes
//
//  Parameters: NONE 
//
//  Return:     TRUE - if changes can be applied
//              FALSE - otherwise.
//
//  Comments:   in case of error shows message box
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
BOOL
CRemotePage::OnApply()
{
    CWaitCursor wait;
    CMutex      mutex;

    DWORD dwType = REG_DWORD;
    DWORD dwDisable = 0;
    DWORD cbDisable = sizeof(DWORD);
    LONG Err;

    // Update RA setting first
    IRARegSetting* pRA = NULL;
    CoCreateInstance(CLSID_RARegSetting,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IRARegSetting,
            reinterpret_cast<void**>(&pRA));
    if (pRA)
    {
        pRA->put_AllowGetHelp(IsDlgButtonChecked(m_hDlg, IDC_ENABLERA)==BST_CHECKED);
        pRA->Release();
    }

    BOOL bIsChanged = FALSE;
    if (g_praSetting && SUCCEEDED(g_praSetting->get_IsChanged(&bIsChanged)) && bIsChanged)
    {
        g_praSetting->SetRegSetting();
    }
    // RA done.

    if(!OnRemoteEnable())
    {
        return FALSE;
    }

    if(IsWindowEnabled(GetDlgItem(m_hDlg,IDC_REMOTE_ENABLE)))
    {

        if(IsDlgButtonChecked(m_hDlg,IDC_REMOTE_ENABLE) == BST_UNCHECKED)
        {
            dwDisable = 1;
        }
       
        
        if(dwDisable != m_dwInitialState)
        {

            HRESULT hr;

            hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
            if (SUCCEEDED(hr))
            {
                ILocalMachine   *pLocalMachine;

                hr = CoCreateInstance(CLSID_ShellLocalMachine,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_ILocalMachine,
                                      reinterpret_cast<void**>(&pLocalMachine));
                if (SUCCEEDED(hr) && (pLocalMachine != NULL))
                {
                    hr = pLocalMachine->put_isRemoteConnectionsEnabled(dwDisable == 0);
                    pLocalMachine->Release();
                }
                CoUninitialize();
            }
            Err = HRESULT_CODE(hr);
            if (ERROR_SUCCESS == Err)
            {
                m_dwInitialState = dwDisable;
            }
            else
            {
                if (ERROR_NOT_SUPPORTED == Err)
                {
                    TCHAR   szContent[256], szTitle[256];

                    (int)LoadString(m_hInst, IDS_OTHER_USERS, szContent, sizeof(szContent) / sizeof(szContent[0]));
                    (int)LoadString(m_hInst, IDS_REMOTE_SESSIONS, szTitle, sizeof(szTitle) / sizeof(szTitle[0]));
                    MessageBox(m_hDlg, szContent, szTitle, MB_OK | MB_ICONSTOP);
                }
                else
                {
                    DisplayError(m_hInst, m_hDlg, Err, IDS_ERR_SAVE_REGISTRY, IDS_REMOTE_SESSIONS);
                }
                CheckDlgButton(m_hDlg, IDC_REMOTE_ENABLE, m_dwInitialState ? BST_UNCHECKED : BST_CHECKED);
            }
        }
    }
    
    return TRUE;
}

//*************************************************************
//
//  CRemotePage::OnLink()
//
//  Purpose:  runs application which link points to.  
//
//  Parameters: WPARAM wParam - link ID
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/8/00    a-skuzin    Created
//
//*************************************************************
void 
CRemotePage::OnLink(
        WPARAM wParam)
{
    switch(wParam)
    {
    case IDC_REMOTE_GPLINK_APPSERVER:
        ShellExecute(NULL,TEXT("open"),TEXT("gpedit.msc"),NULL,NULL,SW_SHOW);
        break;
    case IDC_REMOTE_SCLINK_APPSERVER:
        ShellExecute(NULL,TEXT("open"),TEXT("tscc.msc"),NULL,NULL,SW_SHOW);
        break;
    case IDC_REMOTE_UPLINK:
        ShellExecute(NULL,TEXT("open"),TEXT("control"),TEXT("userpasswords"),NULL,SW_SHOW);
        break;
        /*
    case IDC_REMOTE_HELP:
        HtmlHelp(NULL, TEXT("rdesktop.chm"), HH_HELP_FINDER, 0);
        break;*/
    case IDC_REMOTE_HELP:
        if(m_bProfessional)
        {
            ShellExecute(NULL,TEXT("open"),
                TEXT("hcp://services/subsite?node=TopLevelBucket_2/Working_Remotely/")
                TEXT("Remote_Desktop&topic=MS-ITS:rdesktop.chm::/rdesktop_overview.htm"),NULL,NULL,SW_SHOW);
        }
        else
        {
            ShellExecute(NULL,TEXT("open"),
                TEXT("hcp://services/subsite?node=Management_and_Administration_Tools/")
                TEXT("Remote_Desktop_for_Administration&topic=MS-ITS:rdesktop.chm::/sag_rdesktop_topnode.htm"),NULL,NULL,SW_SHOW);
        }
        break;
    case IDC_REMOTE_HELP_APPSERVER:
        ShellExecute(NULL,TEXT("open"),
                TEXT("hcp://services/subsite?node=Management_and_Administration_Tools/")
                TEXT("Terminal_Server&topic=MS-ITS:termsrv.chm::/sag_termsrv_topnode.htm"),NULL,NULL,SW_SHOW);
        break;
    default:
        break;
    }
    
}

//*************************************************************
//
//  CRemotePage::OnRemoteEnable()
//
//  Purpose:    If user tries to allow remote connections and 
//              "Offline Files" is enabled it shows
//              "Disable Offline Files" dialog and unchecks
//              "Remote Connections" checkbox.  
//
//  Parameters: NONE
//
//  Return:     TRUE - if the check box state was changed.
//              FALSE - otherwise
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/8/00    a-skuzin    Created
//
//*************************************************************

typedef BOOL (WINAPI * PCHECKFN)();

BOOL 
CRemotePage::OnRemoteEnable()
{
    //First check if multiple connections are allowed
    DWORD dwAllowMultipleTSSessions = 0;
    DWORD dwType;
    DWORD cbSize;
    LONG Err;
    HKEY hKey;
    BOOL bResult = TRUE;
    
    //Fast User Switching / Remote Connections and Offline Files should work together fine. 
    //when Brian Aust makes his changes to offline files.
    //therefore we should not restrict remote connections in any case on Professional Machines.
    //on server machine however we conntinue to disallow remote connections if Offline files are on.
    if(m_bProfessional)
    {
        return TRUE;
    }

    //allow user to uncheck the checkbox
    if(IsDlgButtonChecked(m_hDlg,IDC_REMOTE_ENABLE) == BST_UNCHECKED )
    {
        return TRUE;
    }
    
    //check if multiple sessions is allowed.
    Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                            0,
                            KEY_QUERY_VALUE,
                            &hKey);

    if(Err == ERROR_SUCCESS)
    {
        cbSize = sizeof(DWORD);

        Err = RegQueryValueEx(hKey,
                     TEXT("AllowMultipleTSSessions"),
                     NULL,
                     &dwType,
                     (LPBYTE)&dwAllowMultipleTSSessions,
                     &cbSize);
        
        if(Err == ERROR_SUCCESS && dwAllowMultipleTSSessions)
        {
            //multiple sessions is allowed.
            //check if CSC (Offline Files) is enabled 
            HMODULE hLib = LoadLibrary(TEXT("cscdll.dll"));
            if(hLib)
            {
                PCHECKFN pfnCSCIsCSCEnabled = (PCHECKFN)GetProcAddress(hLib,"CSCIsCSCEnabled");

                if(pfnCSCIsCSCEnabled && pfnCSCIsCSCEnabled())
                {
                    //Offline Files is enabled
                    //uncheck the checkbox; show the dialog
                    COfflineFilesDialog Dlg(m_hInst);

                    CheckDlgButton(m_hDlg,IDC_REMOTE_ENABLE,BST_UNCHECKED);
                    Dlg.DoDialog(m_hDlg);
                    
                    bResult = FALSE;
                }
            }

            FreeLibrary(hLib);
            
        }

        RegCloseKey(hKey);
        
    }

    return bResult;
}

//*************************************************************
//
//  CRemotePage::OnRemoteSelectUsers()
//
//  Purpose:    Creates "Remote Desktop Users" dialog.
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void 
CRemotePage::OnRemoteSelectUsers()
{
    m_RemoteUsersDialog.DoDialog(m_hDlg);
}

//*************************************************************
//
//  CRemotePage::RemoteEnableWarning()
//
//  Purpose:    Displays a message box about empty passwords
//              firewalls and other stuff that can prevent
//              remote sessions from working properly.
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              3/28/01    a-skuzin    Created
//
//*************************************************************
void
CRemotePage::RemoteEnableWarning()
{
    if(IsDlgButtonChecked(m_hDlg,IDC_REMOTE_ENABLE) == BST_CHECKED )
    {
        //
        //Now warn admin about empty passwords.
        //Empty passwords are not allowed with 
        //RemoteInteractive logon.
        //
        //Allocate a buffer for the string 1000 chars should be enough
        //
        TCHAR szTitle[MAX_PATH+1];
        DWORD cMsg = 1000;
        LPTSTR szMsg = (LPTSTR) LocalAlloc(LPTR,(cMsg+1)*sizeof(TCHAR));

        if(szMsg)
        {
            if(LoadString(m_hInst,IDS_WRN_EMPTY_PASSWORD,szMsg,cMsg) &&
                LoadString(m_hInst,IDS_REMOTE_SESSIONS,szTitle,MAX_PATH))
            {
                MessageBox(m_hDlg,szMsg,szTitle,
                    MB_OK | MB_ICONINFORMATION);
            }
            LocalFree(szMsg);
        }
    }
}

//*************************************************************
//
//  DisplayError()
//
//  Purpose:    shows message box with error description
//
//  Parameters: ErrID -    error code
//              MsgID -  ID of the first part of error messsage in the string table
//              TitleID - ID of the title in the string table
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
void 
DisplayError(
        IN HINSTANCE hInst, 
        IN HWND hDlg, 
        IN UINT ErrID, 
        IN UINT MsgID, 
        IN UINT TitleID,
        ...)
{
    TCHAR szTemplate[MAX_PATH+1];
    TCHAR szErr[MAX_PATH+1];
    
    if(!LoadString(hInst,MsgID,szTemplate,MAX_PATH))
    {
        return;
    }
    
    va_list arglist;
    va_start(arglist, TitleID);
    wvsprintf(szErr,szTemplate,arglist);
    va_end(arglist);

    TCHAR szTitle[MAX_PATH+1];

    if(!LoadString(hInst,TitleID,szTitle,MAX_PATH))
    {
        return;
    }

    LPTSTR szDescr;
    
    //load module with network error messages
    HMODULE hNetErrModule=LoadLibraryEx(TEXT("netmsg.dll"),NULL,
                            LOAD_LIBRARY_AS_DATAFILE|DONT_RESOLVE_DLL_REFERENCES);

    DWORD dwFlags;

    if(hNetErrModule)
	{
		dwFlags=FORMAT_MESSAGE_FROM_SYSTEM|
			FORMAT_MESSAGE_FROM_HMODULE|
			FORMAT_MESSAGE_ALLOCATE_BUFFER|
			FORMAT_MESSAGE_IGNORE_INSERTS;
	}
	else
	{
		dwFlags=FORMAT_MESSAGE_FROM_SYSTEM|
			FORMAT_MESSAGE_ALLOCATE_BUFFER|
			FORMAT_MESSAGE_IGNORE_INSERTS;
	}

    if(FormatMessage(dwFlags,
                        hNetErrModule,
                        ErrID,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR)&szDescr,
                        0,
                        NULL))
    {
        LPTSTR szErrMessage=(LPTSTR)LocalAlloc(LPTR,
            (lstrlen(szErr)+lstrlen(szDescr)+3)*sizeof(TCHAR));
        if(szErrMessage)
        {
            wsprintf(szErrMessage,TEXT("%s\n\n%s"),szErr,szDescr);
            MessageBox(hDlg,szErrMessage,szTitle,MB_OK | MB_ICONSTOP);
            LocalFree(szErrMessage);
        }
        LocalFree(szDescr);
    }
    else
    {
        MessageBox(hDlg,szErr,szTitle,MB_OK | MB_ICONSTOP);
    }

    if(hNetErrModule)
    {
        FreeLibrary(hNetErrModule);
    }
}


//*************************************************************
//
//  getGroupMembershipPickerSettings()
//
//  Purpose:    prepares DSOP_SCOPE_INIT_INFO
//
//  Parameters: OUT DSOP_SCOPE_INIT_INFO*&  infos,
//              OUT ULONG&                  infoCount
//
//  Return:     FALSE if cannot allocate memory
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
BOOL
getGroupMembershipPickerSettings(
   OUT DSOP_SCOPE_INIT_INFO*&  infos,
   OUT ULONG&                  infoCount)
{
   

   static const int INFO_COUNT = 5;
   infos = new DSOP_SCOPE_INIT_INFO[INFO_COUNT];
   if(infos == NULL)
   {
        infoCount = 0;
        return FALSE;
   }

   infoCount = INFO_COUNT;
   memset(infos, 0, sizeof(DSOP_SCOPE_INIT_INFO) * INFO_COUNT);

   int scope = 0;

   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
   infos[scope].flScope =
            DSOP_SCOPE_FLAG_STARTING_SCOPE
         |  DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH; 
      // this is implied for machine only scope
      /* |  DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT */

   // allow only local users from the machine scope

   infos[scope].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
   infos[scope].FilterFlags.flDownlevel =
         DSOP_DOWNLEVEL_FILTER_USERS;
     // |  DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS;

   // for the domain this machine is joined to (native and mixed mode).

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   infos[scope].flType =
         DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
      |  DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      //|  DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   // here, we allow only domain global groups and domain users.  While
   // it is possible to add a domain local group to a machine local group,
   // I'm told such an operation is not really useful from an administraion
   // perspective.

   infos[scope].FilterFlags.Uplevel.flMixedModeOnly =   
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   // same comment above re: domain local groups applies here too.

   infos[scope].FilterFlags.flDownlevel =
         DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
      |  DSOP_DOWNLEVEL_FILTER_USERS;

   // for domains in the same tree (native and mixed mode)

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
   infos[scope].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   // above domain local group comment applies here, too.

   infos[scope].FilterFlags.Uplevel.flMixedModeOnly =   
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   // for external trusted domains

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   infos[scope].flType =
         DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
      |  DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   infos[scope].FilterFlags.Uplevel.flMixedModeOnly =   
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   infos[scope].FilterFlags.flDownlevel =
         DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
      |  DSOP_DOWNLEVEL_FILTER_USERS;

   // for the global catalog

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   infos[scope].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

   // only native mode applies to gc scope.

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

// SPB:252126 the workgroup scope doesn't apply in this case
//    // for when the machine is not joined to a domain
//    scope++;
//    infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
//    infos[scope].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
//    infos[scope].flType = DSOP_SCOPE_TYPE_WORKGROUP;
// 
//    infos[scope].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
//    infos[scope].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

   _ASSERT(scope == INFO_COUNT - 1);

   return TRUE;
}

//*************************************************************
//
//  VariantToSid()
//
//  Purpose:    Converts a VARIANT containing a safe array 
//              of bytes to a SID
//
//  Parameters: IN VARIANT* var, 
//              OUT PSID *ppSid
//
//  Return:     
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
HRESULT 
VariantToSid(
        IN VARIANT* var, 
        OUT PSID *ppSid)
{
    _ASSERT(var);
    _ASSERT(V_VT(var) == (VT_ARRAY | VT_UI1));

    HRESULT hr = S_OK;
    SAFEARRAY* psa = V_ARRAY(var);

    do
    {
        _ASSERT(psa);
        if (!psa)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (SafeArrayGetDim(psa) != 1)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (SafeArrayGetElemsize(psa) != 1)
        {
            hr = E_INVALIDARG;
            break;
        }

        PSID sid = 0;
        hr = SafeArrayAccessData(psa, reinterpret_cast<void**>(&sid));
        if(FAILED(hr))
        {
            break;
        }

        if (!IsValidSid(sid))
        {
            SafeArrayUnaccessData(psa);
            hr = E_INVALIDARG;
            break;
        }
        
        *ppSid = (PSID) new BYTE[GetLengthSid(sid)];
        
        if(!(*ppSid))
        {
            SafeArrayUnaccessData(psa);
            hr = E_OUTOFMEMORY;
            break;
        }

        CopySid(GetLengthSid(sid),*ppSid,sid);
        SafeArrayUnaccessData(psa);
        
   } while (0);

   return hr;
}

/*****************************************************************************
 *
 *  TestUserForAdmin - Hydrix helper function
 *
 *   Returns whether the current thread is running under admin
 *   security.
 *
 * ENTRY:
 *   NONE
 *
 * EXIT:
 *   TRUE/FALSE - whether user is specified admin
 *
 ****************************************************************************/

BOOL
TestUserForAdmin()
{
    BOOL IsMember, IsAnAdmin;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    PSID AdminSid;


    if (!AllocateAndInitializeSid(&SystemSidAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0, 0, 0, 0, 0, 0,
                                 &AdminSid))
    {
        IsAnAdmin = FALSE;
    }
    else
    {
        if (!CheckTokenMembership(  NULL,
                                    AdminSid,
                                    &IsMember))
        {
            FreeSid(AdminSid);
            IsAnAdmin = FALSE;
        }
        else
        {
            FreeSid(AdminSid);
            IsAnAdmin = IsMember;
        }
    }

    return IsAnAdmin;
}

//*************************************************************
//
//  OfflineFilesDlgProc()
//
//  Purpose:    Dialog box procedure for "Disable Offline Files" dialog
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam (if uMsg is WM_INITDIALOG - this is a pointer to
//                                  object of COfflineFilesDialog class)
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/9/00    a-skuzin    Created
//
//*************************************************************
INT_PTR APIENTRY 
OfflineFilesDlgProc (
        HWND hDlg, 
        UINT uMsg, 
        WPARAM wParam, 
        LPARAM lParam)
{
    
    COfflineFilesDialog *pDlg = (COfflineFilesDialog *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            pDlg=(COfflineFilesDialog *)lParam;
            SetWindowLongPtr(hDlg,DWLP_USER,(LONG_PTR)pDlg);
            if(pDlg)
            {
                pDlg->OnInitDialog(hDlg);
            }
        }       
        break;
    case WM_NOTIFY:
        
        switch (((NMHDR FAR*)lParam)->code)
        {

        case NM_CLICK:
        case NM_RETURN:
            if(pDlg)
            {
                pDlg->OnLink(wParam);
            }
            break;

        default:
            return FALSE;
        }
   
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg,0);
            break;
        default:
            return FALSE;
        }

    default:
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
// class COfflineFilesDialog
//*************************************************************

//*************************************************************
//
//  COfflineFilesDialog::COfflineFilesDialog()
//
//  Purpose:    Constructor
//  Parameters: HINSTANCE hInst
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/8/00    a-skuzin    Created
//
//*************************************************************
COfflineFilesDialog::COfflineFilesDialog(
        IN HINSTANCE hInst) 
    : m_hInst(hInst),m_hDlg(NULL)
{
}

//*************************************************************
//
//  COfflineFilesDialog::DoDialog()
//
//  Purpose:    Creates "Disable Offline Files" dialog
//
//  Parameters: HWND hwndParent
//
//  Return:     
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/8/00    a-skuzin    Created
//
//*************************************************************
INT_PTR 
COfflineFilesDialog::DoDialog(
        IN HWND hwndParent)
{
    return DialogBoxParam(
                      m_hInst,
                      MAKEINTRESOURCE(IDD_DISABLE_OFFLINE_FILES),
                      hwndParent,
                      OfflineFilesDlgProc,
                      (LPARAM) this);
}

//*************************************************************
//
//  COfflineFilesDialog::OnInitDialog()
//
//  Purpose:    Initializes m_hDlg variable
//
//  Parameters: HWND hDlg
//
//  Return:     NONE   
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/8/00    a-skuzin    Created
//
//*************************************************************
void 
COfflineFilesDialog::OnInitDialog(
        IN HWND hDlg)
{
    m_hDlg = hDlg;
}

//*************************************************************
//
//  COfflineFilesDialog::OnLink()
//
//  Purpose:   If ID of the link is  IDC_OFFLINE_FILES
//             it shows "Offline Files" property page.
//
//  Parameters: WPARAM wParam - ID of the link.
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/9/00    a-skuzin    Created
//
//*************************************************************

typedef DWORD (WINAPI * PFNCSCPROP)(HWND);

void 
COfflineFilesDialog::OnLink(
        IN WPARAM wParam)
{
    if(wParam == IDC_OFFLINE_FILES)
    {
        HINSTANCE hLib = LoadLibrary(TEXT("cscui.dll"));
        if (hLib)
        {
            PFNCSCPROP pfnCSCUIOptionsPropertySheet = 
                (PFNCSCPROP)GetProcAddress(hLib, "CSCUIOptionsPropertySheet");

            if (pfnCSCUIOptionsPropertySheet)
            {
                pfnCSCUIOptionsPropertySheet(m_hDlg);
            }

            FreeLibrary(hLib);
        }
    }

}

//*************************************************************
// class CRemoteUsersDialog
//*************************************************************
//*************************************************************
//
//  RemoteUsersDlgProc()
//
//  Purpose:    Dialog box procedure for "Remote Desktop Users" dialog
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam (if uMsg is WM_INITDIALOG - this is a pointer to
//                                  object of CRemoteUsersDialog class)
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              12/22/00    skuzin     Created
//
//*************************************************************
INT_PTR APIENTRY 
RemoteUsersDlgProc (
        HWND hDlg, 
        UINT uMsg, 
        WPARAM wParam, 
        LPARAM lParam)
{
    
    CRemoteUsersDialog *pDlg = (CRemoteUsersDialog *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            pDlg=(CRemoteUsersDialog *)lParam;
            SetWindowLongPtr(hDlg,DWLP_USER,(LONG_PTR)pDlg);
            if(pDlg)
            {
                pDlg->OnInitDialog(hDlg);
            }
        }       
        return TRUE;

    case WM_NOTIFY:
        
        switch (((NMHDR FAR*)lParam)->code)
        {

        case NM_CLICK:
        case NM_RETURN:
            if(pDlg)
            {
                pDlg->OnLink(wParam);
            }
            return TRUE;

        case LVN_ITEMCHANGED:
            if(pDlg)
            {
                pDlg->OnItemChanged(lParam);
            }
            return TRUE;

        default:
            break;
        }
   
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            if(pDlg)
            {
                pDlg->OnOk();
            }
            EndDialog(hDlg,0);
            break;
        case IDCANCEL:
            EndDialog(hDlg,0);
            break;
        case IDC_REMOTE_USR_ADD:
            if(pDlg)
            {
                pDlg->AddUsers();
            }
            break;
        case IDC_REMOTE_USR_REMOVE:
            if(pDlg)
            {
                pDlg->RemoveUsers();
            }
            break;
        default:
            return FALSE;
        }
        
        SetWindowLong(hDlg,DWLP_MSGRESULT,0);
        return TRUE;

    case WM_DESTROY:
        if(pDlg)
        {
            pDlg->OnDestroyWindow();
        }
        SetWindowLong(hDlg,DWLP_MSGRESULT,0);
        return TRUE;

    case WM_HELP:
        {
            LPHELPINFO phi=(LPHELPINFO)lParam;
            if(phi && phi->dwContextId)
            {   
                WinHelp(hDlg,TEXT("SYSDM.HLP"),HELP_CONTEXTPOPUP,phi->dwContextId);
                SetWindowLong(hDlg,DWLP_MSGRESULT,TRUE);
                return TRUE;
            }
        }
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, TEXT("SYSDM.HLP"), HELP_CONTEXTMENU,
                (DWORD_PTR)aHelpIds);
        return TRUE;
    default:
        break;
    }

    return FALSE;
}

//*************************************************************
//
//  CRemoteUsersDialog::CRemoteUsersDialog()
//
//  Purpose:    Constructor
//  Parameters: HINSTANCE hInst
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/22/00    skuzin     Created
//
//*************************************************************
CRemoteUsersDialog::CRemoteUsersDialog(
        IN HINSTANCE hInst) 
    : m_hInst(hInst),m_hDlg(NULL),m_bCanShowDialog(FALSE)
{
    m_szRemoteGroupName[0] = 0;
    m_szLocalCompName[0] = 0;  
    m_hList = NULL;
    m_iLocUser = m_iGlobUser = m_iLocGroup = m_iGlobGroup = m_iUnknown = 0;  
}

//*************************************************************
//
//  CRemoteUsersDialog::DoDialog()
//
//  Purpose:    Creates "Remote Desktop Users" dialog
//
//  Parameters: HWND hwndParent
//
//  Return:     
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/22/00    a-skuzin    Created
//
//*************************************************************
INT_PTR 
CRemoteUsersDialog::DoDialog(
        IN HWND hwndParent)
{
    if(!m_bCanShowDialog)
    {
        return -1;
    }
    else
    {
        return DialogBoxParam(
                          m_hInst,
                          MAKEINTRESOURCE(IDD_REMOTE_DESKTOP_USERS),
                          hwndParent,
                          RemoteUsersDlgProc,
                          (LPARAM) this);
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::CanShowDialog()
//
//  Purpose:    
//
//  Parameters: IN OUT LPBOOL pbAccessDenied - set to TRUE if
//              NetLocalGroupAddMembers returns ACCESS_DENIED.
//
//  Return:     
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
BOOL 
CRemoteUsersDialog::CanShowDialog(
        IN OUT LPBOOL pbAccessDenied)
{
    *pbAccessDenied = FALSE;

    //get name of the "Remote Desktop Users" group 
    //(it can depend on the language used)

    //first create SID
    SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;
    PSID pSid = NULL;
    if( !AllocateAndInitializeSid(
                  &NtSidAuthority,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
                  ))
    {
        return FALSE;
    }

    //Lookup name
    m_szRemoteGroupName[0] = 0;

    DWORD cRemoteGroupName = MAX_PATH;
    WCHAR szDomainName[MAX_PATH+1];
    DWORD cDomainName = MAX_PATH;
    SID_NAME_USE eUse;
    if(!LookupAccountSidW(NULL,pSid,
        m_szRemoteGroupName,&cRemoteGroupName,
        szDomainName,&cDomainName,
        &eUse))
    {
        FreeSid(pSid);
        return FALSE;
    }
    FreeSid(pSid);

    //on the group
    //we trying to add 0 members to the group to see if it returns 
    //ACCESS DENIED
    NET_API_STATUS Result= NetLocalGroupAddMembers(NULL,m_szRemoteGroupName,0,NULL,0);

    if(Result == ERROR_ACCESS_DENIED)
    {
        *pbAccessDenied = TRUE;
    }
    
    m_bCanShowDialog = TRUE;
    return TRUE;
}

//*************************************************************
//
//  CRemoteUsersDialog::OnInitDialog()
//
//  Purpose:    Initializes m_hDlg variable
//
//  Parameters: HWND hDlg
//
//  Return:     NONE   
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/8/00    a-skuzin    Created
//
//*************************************************************
void 
CRemoteUsersDialog::OnInitDialog(
        IN HWND hDlg)
{
    m_hDlg = hDlg;
    
    m_szLocalCompName[0] = 0;
    DWORD cCompName = MAX_PATH;
    GetComputerNameW(m_szLocalCompName,&cCompName);

    //fill list of Remote Desktop Users
    m_hList = GetDlgItem(m_hDlg,IDC_REMOTE_USR_LIST);

    if(m_hList)
    {
    
        //create image list
        HIMAGELIST hImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON), 
                        GetSystemMetrics(SM_CYSMICON), ILC_MASK , 5, 1);
        if(hImageList)
        {
            HICON hIcon;
        
            hIcon = (HICON) LoadImage(m_hInst, MAKEINTRESOURCE(IDI_UNKNOWN), IMAGE_ICON,
                16, 16, 0);
            if (hIcon)
            {
                m_iUnknown = ImageList_AddIcon(hImageList, hIcon);
                DestroyIcon(hIcon);
            }

            hIcon = (HICON) LoadImage(m_hInst, MAKEINTRESOURCE(IDI_LOC_USER), IMAGE_ICON,
                16, 16, 0);
            if (hIcon)
            {
                m_iLocUser = ImageList_AddIcon(hImageList, hIcon);
                DestroyIcon(hIcon);
            }
        
            hIcon = (HICON) LoadImage(m_hInst, MAKEINTRESOURCE(IDI_GLOB_USER), IMAGE_ICON,
                16, 16, 0);
            if (hIcon)
            {
                m_iGlobUser = ImageList_AddIcon(hImageList, hIcon);
                DestroyIcon(hIcon);
            }

            hIcon = (HICON) LoadImage(m_hInst, MAKEINTRESOURCE(IDI_LOC_GROUP), IMAGE_ICON,
                16, 16, 0);
            if (hIcon)
            {
                m_iLocGroup = ImageList_AddIcon(hImageList, hIcon);
                DestroyIcon(hIcon);
            }

            hIcon = (HICON) LoadImage(m_hInst, MAKEINTRESOURCE(IDI_GLOB_GROUP), IMAGE_ICON,
                16, 16, 0);
            if (hIcon)
            {
                m_iGlobGroup = ImageList_AddIcon(hImageList, hIcon);
                DestroyIcon(hIcon);
            }

            ListView_SetImageList(m_hList,hImageList,LVSIL_SMALL);
        }

        ReloadList();
    }

    //If current user already has remote logon access,
    //remind it to him by showing corresponding text in the dialog.
    InitAccessMessage();

}

//*************************************************************
//
//  CRemoteUsersDialog::OnLink()
//
//  Purpose:   
//
//  Parameters: WPARAM wParam - ID of the link.
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/9/00    a-skuzin    Created
//
//*************************************************************
void 
CRemoteUsersDialog::OnLink(
        IN WPARAM wParam)
{
    switch(wParam)
    {
    case IDC_REMOTE_UPLINK:
        ShellExecute(NULL,TEXT("open"),TEXT("control"),TEXT("userpasswords"),NULL,SW_SHOW);
        break;
    default:
        break;
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::OnOk()
//
//  Purpose:   
//
//  Parameters: NONE
//
//  Return:     TRUE if success
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
BOOL 
CRemoteUsersDialog::OnOk()
{
    if(m_hList)
    {
        //Apply members
        LOCALGROUP_MEMBERS_INFO_0 *plmi0 = NULL;
        DWORD entriesread;
        DWORD totalentries;
        NET_API_STATUS Result;
        Result = NetLocalGroupGetMembers(NULL,m_szRemoteGroupName,0,(LPBYTE *)&plmi0,
                        MAX_PREFERRED_LENGTH,&entriesread,&totalentries,NULL);

        if(Result == NERR_Success)
        {
        
            int j;
            LOCALGROUP_MEMBERS_INFO_0 lmi0;

            LVITEM lvi;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM ;

            int iItems=ListView_GetItemCount(m_hList);

            BOOL *pbDoNotAdd = new BOOL[iItems];

            if(!pbDoNotAdd)
            {
                if(plmi0)
                {
                    NetApiBufferFree(plmi0);
                }
                //not enough memory - too bad
                return TRUE;
            }

            ZeroMemory(pbDoNotAdd,iItems*sizeof(BOOL));

            for(DWORD i=0;i<entriesread;i++)
            {
                j = FindItemBySid(plmi0[i].lgrmi0_sid);
                                
                //SID was not found in the list - delete member
                if(j == -1)
                {
                    lmi0.lgrmi0_sid = plmi0[i].lgrmi0_sid;

                    Result = NetLocalGroupDelMembers(NULL,m_szRemoteGroupName,0,(LPBYTE)&lmi0,1);
                    
                    if(Result !=NERR_Success)
                    {
                        delete pbDoNotAdd;
                        NetApiBufferFree(plmi0);
                        DisplayError(m_hInst, m_hDlg, Result, IDS_ERR_SAVE_MEMBERS, IDS_REMOTE_SESSIONS,
                            m_szRemoteGroupName, m_szLocalCompName);
                        return FALSE;
                    }
                }
                else
                {
                    pbDoNotAdd[j] = TRUE;
                }
                
            }

            //Add the rest of members to the group
            for(j=0;j<iItems;j++)
            {
                if(!pbDoNotAdd[j])
                {
                    lvi.iItem = j;
                    ListView_GetItem( m_hList, &lvi );
                    lmi0.lgrmi0_sid = (PSID) lvi.lParam;

                    Result = NetLocalGroupAddMembers(NULL,m_szRemoteGroupName,0,(LPBYTE)&lmi0,1);
                    
                    if(Result !=NERR_Success)
                    {
                        delete pbDoNotAdd;
                        NetApiBufferFree(plmi0);
                        DisplayError(m_hInst, m_hDlg, Result, IDS_ERR_SAVE_MEMBERS, IDS_REMOTE_SESSIONS,
                            m_szRemoteGroupName, m_szLocalCompName);
                        return FALSE;
                    }
                }
            }

            delete pbDoNotAdd;
            NetApiBufferFree(plmi0);
        }
        else
        {
            DisplayError(m_hInst, m_hDlg, Result, IDS_ERR_SAVE_MEMBERS, IDS_REMOTE_SESSIONS,
                m_szRemoteGroupName, m_szLocalCompName);
            return FALSE;
        }

        return TRUE;
    }

    return FALSE;
}

//*************************************************************
//
//  CRemoteUsersDialog::OnItemChanged()
//
//  Purpose:    Enables or disables "Remove" button. 
//
//  Parameters: lParam   -    
//
//  Return:     NONE
//
//  Comments:   in case of error shows message box
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void 
CRemoteUsersDialog::OnItemChanged(
        LPARAM lParam)
{
    NMLISTVIEW* lv = reinterpret_cast<NMLISTVIEW*>(lParam);
    if (lv->uChanged & LVIF_STATE)
    {
        // a list item changed state
        BOOL selected = ListView_GetSelectedCount(m_hList) > 0;

        EnableWindow(GetDlgItem(m_hDlg, IDC_REMOTE_USR_REMOVE), selected);

        //If we disabled IDC_REMOTE_USR_REMOVE button while it had focus
        //all property page loses focus so "Tab" key does not
        //work anymore. We need to restore focus.
        if(!GetFocus())
        {
            SetFocus(m_hDlg);
        }
    
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::OnDestroyWindow()
//
//  Purpose:    Frees memory allocated by member's SIDs 
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void
CRemoteUsersDialog::OnDestroyWindow()
{
    if(m_hList)
    {
        int iItems=ListView_GetItemCount(m_hList);

        LVITEM lvi;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM;
        
        while(iItems)
        {
            lvi.iItem = 0;
            ListView_GetItem( m_hList, &lvi );
            //delete item
            ListView_DeleteItem(m_hList, 0);
            if(lvi.lParam)
            {
                delete (LPVOID)lvi.lParam;
            }
            iItems--; //decrease item count
        }
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::AddUsers()
//
//  Purpose:    adds users to the list
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void 
CRemoteUsersDialog::AddUsers()
{
    HRESULT hr = CoInitializeEx(NULL,COINIT_APARTMENTTHREADED);
    
    if(SUCCEEDED(hr))
    {
        IDsObjectPicker *pDsObjectPicker = NULL;
 
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                     NULL,
                     CLSCTX_INPROC_SERVER,
                     IID_IDsObjectPicker,
                     (void **) &pDsObjectPicker);

        if(SUCCEEDED(hr))
        {
        
            DSOP_INIT_INFO initInfo;
            memset(&initInfo, 0, sizeof(initInfo));

            initInfo.cbSize = sizeof(initInfo);
            initInfo.flOptions = DSOP_FLAG_MULTISELECT;

            // aliasing the computerName internal pointer here -- ok, as lifetime
            // of computerName > initInfo

            initInfo.pwzTargetComputer = NULL;

            initInfo.cAttributesToFetch = 1;
            PWSTR attrs[2] = {0, 0};
            attrs[0] = L"ObjectSID";

            // obtuse notation required to cast *in* const and away the static len

            initInfo.apwzAttributeNames = const_cast<PCWSTR*>(&attrs[0]); 
        
            if(getGroupMembershipPickerSettings(initInfo.aDsScopeInfos, initInfo.cDsScopeInfos))
            {

                IDataObject* pdo = NULL;

                if(SUCCEEDED(pDsObjectPicker->Initialize(&initInfo)) &&
                   pDsObjectPicker->InvokeDialog(m_hDlg, &pdo) == S_OK &&
                   pdo )
                {
                    CWaitCursor wait;

                    static const UINT cf = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

                    FORMATETC formatetc =
                     {
                        (CLIPFORMAT)cf,
                        0,
                        DVASPECT_CONTENT,
                        -1,
                        TYMED_HGLOBAL
                     };
        
                    STGMEDIUM stgmedium =
                     {
                        TYMED_HGLOBAL,
                        0
                     };

                    if(cf && SUCCEEDED(pdo->GetData(&formatetc, &stgmedium)))
                    {
        
                        PVOID lockedHGlobal = GlobalLock(stgmedium.hGlobal);

                        DS_SELECTION_LIST* selections =
                            reinterpret_cast<DS_SELECTION_LIST*>(lockedHGlobal);
        
                        AddPickerItems(selections);

                        GlobalUnlock(stgmedium.hGlobal);
                    }

                    pdo->Release();
                }

                delete initInfo.aDsScopeInfos;
            }

            pDsObjectPicker->Release();
        }

        CoUninitialize();
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::RemoveUsers()
//
//  Purpose:    Removes users from the list
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void 
CRemoteUsersDialog::RemoveUsers()
{
    //delete all selected items
    if(m_hList)
    {

        int iItems=ListView_GetItemCount(m_hList);
        UINT uiState=0;
        int i=0;
        LVITEM lvi;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_STATE | LVIF_PARAM;
        lvi.stateMask = LVIS_SELECTED;

        while(i<iItems)
        {
            lvi.iItem = i;
            ListView_GetItem( m_hList, &lvi );
            if(lvi.state&LVIS_SELECTED)
            {
                //delete item
                ListView_DeleteItem(m_hList, i);
                if(lvi.lParam)
                {
                    delete (LPVOID)lvi.lParam;
                }
                iItems--; //decrease item count
                
            }
            else
            {
                i++;
            }
        }

        //If list is not empty, set focus on the first item.
        if( ListView_GetItemCount(m_hList) )
        {
            ListView_SetItemState(m_hList, 0, LVIS_FOCUSED, LVIS_FOCUSED );
        }
    }

}

//*************************************************************
//
//  CRemoteUsersDialog::IsLocal()
//
//  Purpose:    
//
//  Parameters: wszDomainandname   -  domain\user
//              determines whether the user is local or not
//              if local - cuts out domain name 
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
BOOL 
CRemoteUsersDialog::IsLocal(
        LPWSTR wszDomainandname)
{
    LPWSTR wszTmp = wcschr(wszDomainandname,L'\\');

    if(!wszTmp)
    {
        return TRUE;
    }

    if(!_wcsnicmp(wszDomainandname, m_szLocalCompName,wcslen(m_szLocalCompName) ))
    {
        //get rid of useless domain name
        wcscpy(wszDomainandname,wszTmp+1);
        return TRUE;
    }

    return FALSE;

}

//*************************************************************
//
//  CRemoteUsersDialog::AddPickerItems()
//
//  Purpose:    adds items, returned by DSObjectPicker
//              to the list
//
//  Parameters: IN DS_SELECTION_LIST *selections
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void 
CRemoteUsersDialog::AddPickerItems(
        IN DS_SELECTION_LIST *selections)
{
    
    if(!selections)
    {
        return;
    }

    DS_SELECTION* current = &(selections->aDsSelection[0]);
    
    if(m_hList)
    {

        for (ULONG i = 0; i < selections->cItems; i++, current++)
        {
      
            // extract the ObjectSID of the object (this should always be
            // present)

            PSID pSid;
            HRESULT hr = VariantToSid(&current->pvarFetchedAttributes[0],&pSid);
        
            if( SUCCEEDED(hr) )
            {
                //This SID is not in the list
                //Let's add it.
                if(FindItemBySid(pSid) == -1)
                {
                    LPWSTR szFullName = NULL;
                    SID_NAME_USE eUse;

                    LVITEM item;
                    ZeroMemory(&item,sizeof(item));
                    item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                    
                    //put SID it into the item data
                    //the allocated memory will be freed in OnDestroyWindow()
                    item.lParam = (LPARAM)pSid;
                
                    if(LookupSid(pSid,&szFullName, &eUse))
                    {
                        item.pszText = szFullName;
                    }
                    else
                    {
                        eUse = SidTypeUnknown;
                        if(current->pwzName)
                        {
                            item.pszText = current->pwzName;
                        }
                        else
                        {
                            item.pszText = L"?";
                        }
                    }

                    switch(eUse)
                    {
                    case SidTypeUser:
                        item.iImage = IsLocal(szFullName) ? m_iLocUser : m_iGlobUser;
                        break;
                    case SidTypeGroup:
                        item.iImage = IsLocal(szFullName) ? m_iLocGroup : m_iGlobGroup;
                        break;
                    case SidTypeWellKnownGroup:
                        item.iImage = m_iLocGroup;
                        break;

                    default:
                        item.iImage = m_iUnknown;
                        break;
                    }

                    if(ListView_InsertItem(m_hList,&item) == -1)
                    {
                        delete pSid;
                    }

                    if(szFullName)
                    {
                        LocalFree(szFullName);
                    }
                }
                else
                {
                    //Free allocated memory
                    delete pSid;
                }
            }
        }
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::FindItemBySid()
//
//  Purpose:    finds user with particular SID in the list
//
//  Parameters: pSid - SID to find
//
//  Return:     item index (-1 if not found)
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
int 
CRemoteUsersDialog::FindItemBySid(
        IN PSID pSid)
{
    if(m_hList)
    {
        LVITEM lvi;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM ;

        int iItems=ListView_GetItemCount(m_hList);

        for(int i=0;i<iItems;i++)
        {
            lvi.iItem = i;
            ListView_GetItem( m_hList, &lvi );
            PSID pItemSid = (PSID) lvi.lParam;
            if(pItemSid && EqualSid(pSid,pItemSid))
            {
                return i;
            }

        }
    }

    return -1;
}

//*************************************************************
//
//  CRemoteUsersDialog::ReloadList()
//
//  Purpose:    delete all items and then refill it with
//              names of members of "Remote Desktop Users" group.    
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void 
CRemoteUsersDialog::ReloadList()
{

    if(m_hList)
    {
        CWaitCursor wait;

        //first delete all items
        int iItems=ListView_GetItemCount(m_hList);

        LVITEM item;
        item.iSubItem = 0;
        item.mask = LVIF_PARAM;
        
        while(iItems)
        {
            item.iItem = 0;
            ListView_GetItem( m_hList, &item );
            //delete item
            ListView_DeleteItem(m_hList, 0);
            if(item.lParam)
            {
                delete (LPVOID)item.lParam;
            }
            iItems--; //decrease item count
        }

        LOCALGROUP_MEMBERS_INFO_2 *plmi2;
        DWORD entriesread;
        DWORD totalentries;
        NET_API_STATUS Result;
        Result = NetLocalGroupGetMembers(NULL,m_szRemoteGroupName,2,(LPBYTE *)&plmi2,
            MAX_PREFERRED_LENGTH,&entriesread,&totalentries,NULL);
        if(Result == NERR_Success || Result == ERROR_MORE_DATA )
        {
            
            for(DWORD i=0;i<entriesread;i++)
            {
                ZeroMemory(&item,sizeof(item));
                item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                item.pszText = plmi2[i].lgrmi2_domainandname;
                //create copy of the SID and put it in item data
                PSID pSid = (PSID)new BYTE[GetLengthSid(plmi2[i].lgrmi2_sid)];
                if(pSid)
                {
                    CopySid(GetLengthSid(plmi2[i].lgrmi2_sid),pSid,plmi2[i].lgrmi2_sid);
                    item.lParam = (LPARAM)pSid;
                }
                switch(plmi2[i].lgrmi2_sidusage)
                {
                case SidTypeUser:
                    item.iImage = IsLocal(plmi2[i].lgrmi2_domainandname) ? m_iLocUser : m_iGlobUser;
                    break;
                case SidTypeGroup:
                    item.iImage = IsLocal(plmi2[i].lgrmi2_domainandname) ? m_iLocGroup : m_iGlobGroup;
                    break;
                case SidTypeWellKnownGroup:
                    item.iImage = m_iLocGroup;
                    break;

                default:
                    item.iImage = m_iUnknown;
                    break;
                }

                if(ListView_InsertItem(m_hList,&item) == -1)
                {
                    if(pSid)
                    {
                        delete pSid;
                    }
                }
            }

            NetApiBufferFree(plmi2);
        }

        //If list is not empty, set focus on the first item.
        if( ListView_GetItemCount(m_hList) )
        {
            ListView_SetItemState(m_hList, 0, LVIS_FOCUSED, LVIS_FOCUSED );
        }
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::InitAccessMessage()
//
//  Purpose:    Check if current user has remote logon access   
//              and if he does, show corresponding text in the dialog.
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              01/04/01    skuzin     Created
//
//*************************************************************
void
CRemoteUsersDialog::InitAccessMessage()
{
    //First, get token handle
    HANDLE hToken = NULL, hToken1 = NULL;
    
    //Get Primary token
    if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_DUPLICATE , &hToken))
    {
        return;
    }
    
    //Get Impersonation token
    if(!DuplicateToken(hToken, SecurityIdentification, &hToken1))
    {
        CloseHandle(hToken);
        return;
    }

    CloseHandle(hToken);

    //Get RDP-Tcp WinStation security descriptor.
    PSECURITY_DESCRIPTOR pSD;

    if(GetRDPSecurityDescriptor(&pSD))
    {
        if(CheckWinstationLogonAccess(hToken1,pSD))
        {
            //Extract the name of the user from the token.
            LPWSTR szName = NULL;
            if(GetTokenUserName(hToken1,&szName))
            {
                //If user is local, remove domain name
                IsLocal(szName);

                //Assemble a text for the message.
                WCHAR szTemplate[MAX_PATH+1];
                HWND hMessage = GetDlgItem(m_hDlg,IDC_USER_HAS_ACCESS);    
                if(hMessage &&
                    LoadString(m_hInst,IDS_USER_HAS_ASSESS,szTemplate,MAX_PATH))
                {
                    LPWSTR szMessage = (LPWSTR) LocalAlloc(LPTR,
                        (wcslen(szTemplate)+wcslen(szName))*sizeof(WCHAR));
                    if(szMessage)
                    {
                        wsprintf(szMessage,szTemplate,szName);
                        SetWindowText(hMessage,szMessage);
                        
                        LocalFree(szMessage);
                    }
                }

                LocalFree(szName);
            }
        }
        LocalFree(pSD);    
    }
    
    CloseHandle(hToken1);
}

//*************************************************************
//
//  GetTokenUserName()
//
//  Purpose:    Extracts a user name from the token.
//
//  Parameters: IN HANDLE hToken
//              OUT LPWSTR *ppName 
//
//  Return:     TRUE - if success
//              FALSE - in case of any error
//
//  Comments:   Caller should free memory allocated for user name
//              using LocalFree function
//
//  History:    Date        Author     Comment
//              01/04/01    skuzin     Created
//
//*************************************************************
BOOL 
GetTokenUserName(
        IN HANDLE hToken,
        OUT LPWSTR *ppName)
{
    *ppName = NULL;

    DWORD dwReturnLength=0;
    BOOL  bResult = FALSE;
    PTOKEN_USER pTUser = NULL;

    if(!GetTokenInformation(hToken,TokenUser,NULL,0,&dwReturnLength) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER && 
        dwReturnLength)
    {
        pTUser = (PTOKEN_USER)LocalAlloc(LPTR,dwReturnLength);
        if(pTUser)
        {
            if(GetTokenInformation(hToken,TokenUser,pTUser,dwReturnLength,&dwReturnLength))
            {
                //Get current user 's name.
                LPWSTR szName = NULL;
                SID_NAME_USE eUse;
                
                return LookupSid(pTUser->User.Sid,ppName,&eUse);
            }

            LocalFree(pTUser);
            
        }
    }

    return FALSE;
}

//*************************************************************
//
//  GetRDPSecurityDescriptor()
//
//  Purpose:    Returns security descriptor for RDP-Tcp
//
//  Parameters: OUT PSECURITY_DESCRIPTOR *ppSD
//
//  Return:     TRUE - if success
//              FALSE - in case of any error
//
//  Comments:   Caller should free memory allocated for 
//              security descriptor using LocalFree function
//
//  History:    Date        Author     Comment
//              01/04/01    skuzin     Created
//
//*************************************************************
BOOL
GetRDPSecurityDescriptor(
        OUT PSECURITY_DESCRIPTOR *ppSD)
{
    *ppSD = NULL;

    if( FAILED( CoInitializeEx(NULL, COINIT_APARTMENTTHREADED) ) )
    {
        return FALSE;
    }

    ICfgComp *pCfgcomp;

    if( SUCCEEDED( CoCreateInstance( CLSID_CfgComp , NULL , CLSCTX_INPROC_SERVER , 
                    IID_ICfgComp , ( LPVOID *)&pCfgcomp ) ) )
    {
        LONG lSDsize;
        PSECURITY_DESCRIPTOR  pSD = NULL;

        if( SUCCEEDED( pCfgcomp->Initialize() ) &&
            SUCCEEDED( pCfgcomp->GetSecurityDescriptor( L"RDP-Tcp" , &lSDsize , &pSD ) ) )
        {
           *ppSD = pSD;
        }
    
        pCfgcomp->Release();
    }

    CoUninitialize();

    return (*ppSD != NULL);
}

//*************************************************************
//
//  CheckWinstationLogonAccess()
//
//  Purpose:    Tests access token for LOGON access to WinStation
//
//  Parameters: IN HANDLE hToken
//              IN PSECURITY_DESCRIPTOR pSD
//
//  Return:     TRUE - if user has access
//              FALSE - in case of any error or if user 
//                      does not have access
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              01/04/01    skuzin     Created
//
//*************************************************************
BOOL
CheckWinstationLogonAccess(
        IN HANDLE hToken,
        IN PSECURITY_DESCRIPTOR pSD)
{
    //this is taken from "termsrv\winsta\server\acl.c"
    //
    // Structure that describes the mapping of generic access rights to object
    // specific access rights for Window Station objects.
    //
    GENERIC_MAPPING WinStaMapping = {
        STANDARD_RIGHTS_READ |
            WINSTATION_QUERY,
        STANDARD_RIGHTS_WRITE |
            WINSTATION_SET,
        STANDARD_RIGHTS_EXECUTE,
            WINSTATION_ALL_ACCESS
    };
    
    PRIVILEGE_SET PrivilegeSet;
    //There are no privileges used for this access check
    //so we don't need to allocate additional memory
    DWORD dwPrivilegeSetLength = sizeof(PrivilegeSet);
    DWORD dwGrantedAccess = 0;
    BOOL bAccessStatus = FALSE;

    if(!AccessCheck(
          pSD, // SD
          hToken,                       // handle to client access token
          WINSTATION_LOGON,                      // requested access rights 
          &WinStaMapping,          // mapping
          &PrivilegeSet,              // privileges
          &dwPrivilegeSetLength,               // size of privileges buffer
          &dwGrantedAccess,                    // granted access rights
          &bAccessStatus                      // result of access check
        ) || !bAccessStatus )
    {
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  LookupSid()
//
//  Purpose:   Given SID allocates and returns string containing 
//             name of the user in format DOMAINNAME\USERNAME
//
//  Parameters: IN PSID pSid
//              OUT LPWSTR ppName 
//              OUT SID_NAME_USE *peUse   
//
//  Return:     TRUE if success, FALSE otherwise
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              10/23/00    skuzin     Created
//
//*************************************************************
BOOL
LookupSid(
    IN PSID pSid, 
    OUT LPWSTR *ppName,
    OUT SID_NAME_USE *peUse)
{
    LPWSTR szName = NULL;
    DWORD cName = 0;
    LPWSTR szDomainName = NULL;
    DWORD cDomainName = 0;
    
    *ppName = NULL;
    
    if(!LookupAccountSidW(NULL,pSid,
        szName,&cName,
        szDomainName,&cDomainName,
        peUse) && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        //cName and cDomainName include terminating 0
        *ppName = (LPWSTR)LocalAlloc(LPTR,(cName+cDomainName)*sizeof(WCHAR));

        if(*ppName)
        {
            szDomainName = *ppName;
            szName = &(*ppName)[cDomainName];

            if(LookupAccountSidW(NULL,pSid,
                    szName,&cName,
                    szDomainName,&cDomainName,
                    peUse))
            {
                //user name now in format DOMAINNAME\0USERNAME
                //let's replace '\0' with  '\\'
                //now cName and cDomainName do not include terminating 0
                //very confusing
                if(cDomainName)
                {
                    (*ppName)[cDomainName] = L'\\';
                }
                return TRUE;
            }
            else
            {
                LocalFree(*ppName);
                *ppName = NULL;
            }

        }

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\rmvlnks\rmvlnks.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

#include "resource.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <winreg.h>
#include <wfregupg.h>
#include <shlobj.h>
#include <winioctl.h>
#include <wchar.h>

UINT WFMenuRemoveListMain[] =   {
        IDS_WFSETUP,
        IDS_WFBOOKS,
        IDS_WFHELP,
        0
};

UINT WFMenuRemoveListAdminTools[] = {
        IDS_NETWAREUSER,
        IDS_WFCDISKCREATOR,
        IDS_APPSECREG,
        0
};

HINSTANCE g_hinst;

UINT
MyGetDriveType(
    IN TCHAR Drive
    )
{
    TCHAR DriveNameNt[] = L"\\\\.\\?:";
    TCHAR DriveName[] = L"?:\\";
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type.  If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk. Otherwise
    // just believe the api.
    //
    DriveName[0] = Drive;
    if((rc = GetDriveType(DriveName)) == DRIVE_REMOVABLE) {

        DriveNameNt[4] = Drive;

        hDisk = CreateFile(
                    DriveNameNt,
                    FILE_READ_ATTRIBUTES,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

        if(hDisk != INVALID_HANDLE_VALUE) {

            b = DeviceIoControl(
                    hDisk,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                    NULL,
                    0,
                    &MediaInfo,
                    sizeof(MediaInfo),
                    &DataSize,
                    NULL
                    );

            //
            // It's really a hard disk if the media type is removable.
            //
            if(b && (MediaInfo.MediaType == RemovableMedia)) {
                rc = DRIVE_FIXED;
            }

            CloseHandle(hDisk);
        }
    }

    return(rc);
}

// this routine will look for shortcuts for selected apps on an upgraded WF system, and
// if the drives have been remapped, the shortcuts will be removed and re-created.


void CtxCleanupShortcuts()
{

        HRESULT      hResult;
    IUnknown     *punk;
    IShellLink   *pShellLink;
    IPersistFile *pFile;
        TCHAR  szDeleteFile[MAX_PATH+1];
        TCHAR szSysDir[MAX_PATH+1];
        TCHAR szAccessoriesPath[MAX_PATH+1];
        TCHAR szMainPath[MAX_PATH+1];
        TCHAR szProfileDir[MAX_PATH+1];
        TCHAR szProfileName[MAX_PATH+1];
        TCHAR szSaveDir[MAX_PATH+1];
        TCHAR szShortcutFile[MAX_PATH+1];
        TCHAR szProgramPath[MAX_PATH+1];
        TCHAR szProgramName[MAX_PATH+1];
        TCHAR szProgramDescription[MAX_PATH+1];
    TCHAR szAdminName[MAX_PATH+1];

        int j;
        HKEY SourceKey;

        TCHAR drive = 'C';



        // now see if the drives were remapped - if so, we need to fix up some shortcuts-
        GetSystemDirectory(szSysDir,MAX_PATH);
        if(MyGetDriveType(drive) == DRIVE_FIXED)        // drives not remapped
                return;

    // initialize some strings
        LoadString(g_hinst,IDS_ACCESSORIES_SUBPATH,szAccessoriesPath,MAX_PATH);
        LoadString(g_hinst,IDS_MAIN_SUBPATH,szMainPath,MAX_PATH);
        LoadString(g_hinst,IDS_PROFILES,szProfileName,MAX_PATH);
        LoadString(g_hinst,IDS_ADMINISTRATOR,szAdminName,MAX_PATH);

        GetEnvironmentVariable(L"SystemRoot",szProfileDir,MAX_PATH);
        wcscat(szProfileDir,L"\\");
        wcscat(szProfileDir,szProfileName);
    wcscat(szProfileDir,L"\\");
    wcscat(szProfileDir,szAdminName);

        // setup OLE stuff
        hResult = OleInitialize(NULL);
        hResult = CoCreateInstance(&CLSID_ShellLink,
                                                                                NULL,
                                                                                CLSCTX_SERVER,
                                                                                &IID_IUnknown,
                                                                                (void **)&punk);
        if (FAILED(hResult))
                goto done;

        hResult = punk->lpVtbl->QueryInterface(punk,&IID_IShellLink, (void **)&pShellLink);
        if (FAILED(hResult))
                goto done;

        hResult = punk->lpVtbl->QueryInterface(punk,&IID_IPersistFile, (void **)&pFile);
        if (FAILED(hResult))
                goto done;




    for(j = 1; j <= 4; j++)
    {

            //build up paths to .lnk files
            wcscpy(szDeleteFile,szProfileDir);
            wcscat(szDeleteFile,L"\\");

            switch(j) {
                case 1:
                    wcscat(szDeleteFile,szAccessoriesPath);
                    wcscat(szDeleteFile,L"\\");
                    LoadString(g_hinst,IDS_ACCESSDESC1,szProgramDescription,MAX_PATH);
                    LoadString(g_hinst,IDS_ACCESSPROG1,szProgramName,MAX_PATH);
                    break;
                case 2:
                    wcscat(szDeleteFile,szAccessoriesPath);
                    wcscat(szDeleteFile,L"\\");
                    LoadString(g_hinst,IDS_ACCESSDESC2,szProgramDescription,MAX_PATH);
                    LoadString(g_hinst,IDS_ACCESSPROG2,szProgramName,MAX_PATH);
                    break;
                case 3:
                    wcscat(szDeleteFile,szMainPath);
                    wcscat(szDeleteFile,L"\\");
                    LoadString(g_hinst,IDS_MAINDESC1,szProgramDescription,MAX_PATH);
                    LoadString(g_hinst,IDS_MAINPROG1,szProgramName,MAX_PATH);
                    break;
                case 4:
                    wcscat(szDeleteFile,szMainPath);
                    wcscat(szDeleteFile,L"\\");
                    LoadString(g_hinst,IDS_MAINDESC2,szProgramDescription,MAX_PATH);
                    LoadString(g_hinst,IDS_MAINPROG2,szProgramName,MAX_PATH);
                    break;
                }


                                wcscat(szDeleteFile,szProgramDescription);
                                wcscat(szDeleteFile,L".lnk");
                                SetFileAttributes(szDeleteFile,FILE_ATTRIBUTE_NORMAL);
                                // if we can't delete the original, then this user probably didn't have this
                                // shortcut, or it's saved under a different file name.  In either case we
                                // don't want to create a new one.
                                if(!DeleteFile(szDeleteFile))
                                {
                                        continue;
                                }

                        // create new shortcut
                                wcscpy(szProgramPath,szSysDir);
                                wcscat(szProgramPath,L"\\");
                                wcscat(szProgramPath,szProgramName);
                                pShellLink->lpVtbl->SetPath(pShellLink,szProgramPath);
                                pShellLink->lpVtbl->SetWorkingDirectory(pShellLink,szSysDir);
                                pShellLink->lpVtbl->SetDescription(pShellLink,szProgramDescription);

                        // create the same file we deleted
                                wcscpy(szShortcutFile,szDeleteFile);
                            pFile->lpVtbl->Save(pFile,szShortcutFile,FALSE);

                }

done:


        if (pFile != NULL)
    {
        pFile->lpVtbl->Release(pFile);
        pFile=NULL;
    }
    if (pShellLink != NULL)
    {
        pShellLink->lpVtbl->Release(pShellLink);
        pShellLink=NULL;
    }
    if (punk != NULL)
    {
        punk->lpVtbl->Release(punk);
        punk=NULL;
    }


    OleUninitialize();
        SetCurrentDirectory(szSaveDir);
}
/*
*  This function is used to remove items from the StartMenu that can't be removed via the
* syssetup.inf interface. Items listed there under the StartMenu.ObjectsToDelete are deleted
* the Default User\Start Menu directory (private items) or the All User\Start Menu directory
* (common items). But many tools from WF 1.x are put in the Administrator\Start Menu.
*  This function will remove unwanted items from that group.
*/


void CtxRemoveWFStartMenuItems()
{

        TCHAR szProfileDir[MAX_PATH+1];
        TCHAR szProfileName[MAX_PATH+1];
        TCHAR szMainPath[MAX_PATH+1];
        TCHAR szAdminToolsPath[MAX_PATH+1];
        TCHAR szDeleteFile[MAX_PATH+1];
        TCHAR szSaveDir[MAX_PATH+1];
        TCHAR szTargetDir[MAX_PATH+1];
        TCHAR szAdminName[MAX_PATH+1];
        TCHAR szCurFile[MAX_PATH+1];
        int i;

        DWORD err;
        BOOL bWorking = TRUE;
        BOOL bFoundOne = FALSE;
    WIN32_FIND_DATA     w32fileinfo;
        HANDLE  hSearch;

        LoadString(g_hinst,IDS_MAIN_SUBPATH,szMainPath,MAX_PATH);
        LoadString(g_hinst,IDS_ADMINTOOLS_SUBPATH,szAdminToolsPath, MAX_PATH);
        LoadString(g_hinst,IDS_PROFILES,szProfileName,MAX_PATH);
        LoadString(g_hinst,IDS_ADMINISTRATOR,szAdminName,MAX_PATH);

        //build up a path to \StartMenu\Programs\Administrative Tools


        GetEnvironmentVariable(L"SystemRoot",szProfileDir,MAX_PATH);
        wcscat(szProfileDir,L"\\");
        wcscat(szProfileDir,szProfileName);
        wcscpy(szTargetDir,szProfileDir);
        wcscat(szTargetDir,L"\\");
        wcscat(szTargetDir,szAdminName);
        i=0;

        while(WFMenuRemoveListMain[i] != 0)
        {

                LoadString(g_hinst,WFMenuRemoveListMain[i],szCurFile,MAX_PATH);
                wcscpy(szDeleteFile,szTargetDir);
                wcscat(szDeleteFile,L"\\");
                wcscat(szDeleteFile,szMainPath);
                wcscat(szDeleteFile,L"\\");
                wcscat(szDeleteFile,szCurFile);
                wcscat(szDeleteFile,L".lnk");
                SetFileAttributes(szDeleteFile,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(szDeleteFile);
                i++;
        }

        i=0;

        while(WFMenuRemoveListAdminTools[i] != 0)
        {
                LoadString(g_hinst,WFMenuRemoveListAdminTools[i],szCurFile,MAX_PATH);
                wcscpy(szDeleteFile,szTargetDir);
                wcscat(szDeleteFile,L"\\");
                wcscat(szDeleteFile,szAdminToolsPath);
                wcscat(szDeleteFile,L"\\");
                wcscat(szDeleteFile,szCurFile);
                wcscat(szDeleteFile,L".lnk");
                SetFileAttributes(szDeleteFile,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(szDeleteFile);
        i++;
        }

    //if the admin tools directory is empty, delete it
    wcscat(szTargetDir,L"\\");
    wcscat(szTargetDir,szAdminToolsPath);
    GetCurrentDirectory(MAX_PATH,szSaveDir);
    if(!SetCurrentDirectory(szTargetDir))
         return;

    hSearch = FindFirstFile(L"*",&w32fileinfo);
    bWorking = TRUE;
    bFoundOne = FALSE;
    while(bWorking)
    {
        if( (!wcscmp(w32fileinfo.cFileName,L".")) ||
            (!wcscmp(w32fileinfo.cFileName,L"..")) )
        {
            bWorking = FindNextFile(hSearch,&w32fileinfo);
            continue;
        }
        else
        {
                bFoundOne = TRUE;
                break;
        }
    }

    FindClose(hSearch);

    SetCurrentDirectory(szProfileDir);
    if(!bFoundOne)
        RemoveDirectory(szTargetDir);

    SetCurrentDirectory(szSaveDir);

        return;
}

/***************************************************************************\
* WinMain
*
* History:
* 05-15-98 JasonL       Created.
\***************************************************************************/

int WINAPI WinMain(
    HINSTANCE  hInstance,
    HINSTANCE  hPrevInstance,
    LPSTR   lpszCmdParam,
    int     nCmdShow)
{
    HKEY CurKey;
    WCHAR szAppSetup[MAX_PATH+1];
    WCHAR szSystemDir[MAX_PATH+1];
    WCHAR szDeleteFile[MAX_PATH+1];
    WCHAR szWinLogonKey[MAX_PATH+1];
    WCHAR  Data[MAX_PATH];
    DWORD size;
    PWCHAR pBegin, pEnd;
    WCHAR szNewData[MAX_PATH+1];
    WCHAR szTemp[MAX_PATH+1];
    WCHAR szAdministrator[MAX_PATH+1];
    WCHAR szUserName[MAX_PATH+1];

      long ret;
      WCHAR buf[MAX_PATH];

    // Load up some strings;
    g_hinst = hInstance;
    LoadString(g_hinst,IDS_WINLOGON_KEY,szWinLogonKey,MAX_PATH);
    LoadString(g_hinst,IDS_APPSETUP,szAppSetup,MAX_PATH);
    LoadString(g_hinst,IDS_ADMINISTRATOR,szAdministrator,MAX_PATH);
    size = sizeof(szUserName) / sizeof(WCHAR);

    // only run if it's the administrator - otherwise the directory won't have been created
    // yet

    if(!GetUserName(szUserName,&size))
        return 0;

    if(_wcsicmp(szUserName,szAdministrator) != 0)
        {

        return 0;
    }

    // only do the work if this is an upgraded WF system

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,REG_CONTROL_CITRIX,0,KEY_ALL_ACCESS,&CurKey)
        == ERROR_SUCCESS)
    {

        RegCloseKey(CurKey);
        // call our workers ...
        CtxCleanupShortcuts();
        CtxRemoveWFStartMenuItems();
    }

    // then delete this file, and remove the entry in the AppSetup key
    GetSystemDirectory(szSystemDir,MAX_PATH);
    wcscpy(szDeleteFile,szSystemDir);
    wcscat(szDeleteFile,L"\\rmvlnks.exe");
    MoveFileEx(szDeleteFile,NULL,MOVEFILE_DELAY_UNTIL_REBOOT);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\shadow\shadow.c ===
/*************************************************************************
*
* shadow.c
*
* Shadow utility
*
* Copyright 1994, Citrix Systems Inc.
*
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   tyl  $  Mike Discavage
*
* $Log:   N:\nt\private\utils\citrix\shadow\VCS\shadow.c  $
*
*     Rev 1.20   May 04 1998 17:37:40   tyl
*  bug 2019 - oem to ansi
*
*     Rev 1.19   Jun 26 1997 18:25:40   billm
*  move to WF40 tree
*
*     Rev 1.18   23 Jun 1997 15:39:22   butchd
*  update
*
*     Rev 1.17   15 Feb 1997 15:57:34   miked
*  update
*
*     Rev 1.16   07 Feb 1997 15:56:54   bradp
*  update
*
*     Rev 1.15   13 Nov 1996 17:14:40   miked
*  update
*
*     Rev 1.14   30 Sep 1996 08:34:28   butchd
*  update
*
*     Rev 1.13   11 Sep 1996 09:21:44   bradp
*  update
*
*
*************************************************************************/

#define NT

/*
 *  Includes
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>

#include <windows.h>

// #include <ntddkbd.h>
// #include <ntddmou.h>
#include <winsta.h>

#include <utilsub.h>

#include <kbd.h> // for KBDCTRL                                    KLB 07-15-95

#include "shadow.h"
#include "printfoa.h"





/*
 * Global variables
 */
USHORT help_flag = FALSE;
USHORT v_flag = FALSE;
WINSTATIONNAME WSName;
ULONG LogonId;
ULONG Timeout;  // timeout in seconds
HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_NAME+1];


TOKMAP ptm[] = {
      {TOKEN_WS,            TMFLAG_REQUIRED, TMFORM_STRING,
                                WINSTATIONNAME_LENGTH, WSName },

      {TOKEN_SERVER,        TMFLAG_OPTIONAL, TMFORM_STRING,
                                 MAX_NAME, ServerName },

      {TOKEN_TIMEOUT,       TMFLAG_OPTIONAL, TMFORM_ULONG,
                                sizeof(ULONG), &Timeout },

      {TOKEN_VERBOSE,       TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                                sizeof(USHORT), &v_flag },

      {TOKEN_HELP,          TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                                sizeof(USHORT), &help_flag },

      {0, 0, 0, 0, 0}
};


/*
 * Private function prototypes.
 */
void Usage(BOOLEAN bError);



/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main( INT argc, CHAR **argv )
{
    WCHAR *CmdLine;
    WCHAR **argvW, *endptr;
    ULONG rc;
    int i;
    BOOLEAN Result;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

        if ( !help_flag ) {
            Usage(TRUE);
            return(FAILURE);

        } else {
            Usage(FALSE);
            return(SUCCESS);
        }
    }

        //Check if we are running under Terminal Server
        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     * Validate the shadowee.
     */
    if ( !iswdigit(*WSName) ) {

        /*
         * Treat the entered string as a WinStation name.
         *
         */

        if ( !LogonIdFromWinStationName(hServerName, WSName, &LogonId) ) {
            StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, WSName);
            return(FAILURE);
        }

        Message(IDS_SHADOWING_WARNING);
        if ( v_flag )
            StringMessage(IDS_SHADOWING_WINSTATION, WSName);

    } else {

        /*
         * Treated the entered string as a LogonId.
         */
        LogonId = wcstoul(WSName, &endptr, 10);
        if ( *endptr ) {                            
            StringErrorPrintf(IDS_ERROR_INVALID_LOGONID, WSName);
            return(FAILURE);
        }
        if ( !WinStationNameFromLogonId(hServerName, LogonId, WSName) ) {
            ErrorPrintf(IDS_ERROR_LOGONID_NOT_FOUND, LogonId);
            return(FAILURE);
        }

        Message(IDS_SHADOWING_WARNING);
        if ( v_flag )
            Message(IDS_SHADOWING_LOGONID, LogonId);
    }

    // Let the warning be displayed
    Sleep(500);

    /*
     * Start shadowing.
     */
    if ( IsTokenPresent(ptm, TOKEN_TIMEOUT) ) {
        Result = WinStationShadow( SERVERNAME_CURRENT,
                                   ServerName,
                                   LogonId,
                                   (BYTE)Timeout,
                                   (WORD)-1);
    } else {
        Result = WinStationShadow( SERVERNAME_CURRENT,
                                   ServerName,
                                   LogonId,
                                   VK_MULTIPLY,
                                   KBDCTRL ); // ctrl-*
    }

    /*
     * Return success or failure.
     */
    if ( !Result ) {

        ErrorPrintf(IDS_ERROR_SHADOW_FAILURE, GetLastError());
        PutStdErr( GetLastError(), 0 );
        return(FAILURE);

    } else {

        if ( v_flag )
            Message(IDS_SHADOWING_DONE);

        return(SUCCESS);
    }

}  /* main() */



/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {

        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE_1);
        ErrorPrintf(IDS_USAGE_2);
        ErrorPrintf(IDS_USAGE_3);
        ErrorPrintf(IDS_USAGE_4);
        ErrorPrintf(IDS_USAGE_5);
        ErrorPrintf(IDS_USAGE_6);
        ErrorPrintf(IDS_USAGE_7);
        ErrorPrintf(IDS_USAGE_8);
        ErrorPrintf(IDS_USAGE_9);

    } else {

        Message(IDS_USAGE_1);
        Message(IDS_USAGE_2);
        Message(IDS_USAGE_3);
        Message(IDS_USAGE_4);
        Message(IDS_USAGE_5);
        Message(IDS_USAGE_6);
        Message(IDS_USAGE_7);
        Message(IDS_USAGE_8);
        Message(IDS_USAGE_9);
    }

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\shadow\shadow.h ===
/***********************************************************************
*
*  SHADOW.H
*     This module contains typedefs and defines required for
*     the SHADOW utility.
*
*  Copyright Citrix Systems Inc. 1994
* 
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   scottn  $  Butch Davis
*
* $Log:   T:\nt\private\utils\citrix\shadow\VCS\shadow.h  $
*  
*     Rev 1.7   30 Oct 1997 21:02:52   scottn
*  A few MS changes
*
*     Rev 1.6   10 Oct 1997 00:48:28   scottn
*  Make help like MS.
*
*     Rev 1.5   Oct 07 1997 09:31:02   billm
*  change winstation to session
*
*     Rev 1.4   07 Feb 1997 15:56:56   bradp
*  update
*
*     Rev 1.3   11 Sep 1996 09:21:46   bradp
*  update
*
*     Rev 1.2   22 Feb 1995 13:52:04   butchd
*  update
*
*     Rev 1.1   16 Dec 1994 17:15:54   bradp
*  update
*
*     Rev 1.0   29 Apr 1994 13:11:02   butchd
*  Initial revision.
*
*************************************************************************/

/*
 * Token string definitions.
 */
#define TOKEN_WS                        L""
#define TOKEN_TIMEOUT                   L"/timeout"
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_HELP                      L"/?"
#define TOKEN_SERVER                    L"/server"

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_NAME 256            // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_NOT_FOUND                  102
#define IDS_ERROR_INVALID_LOGONID                       103
#define IDS_ERROR_LOGONID_NOT_FOUND                     104
#define IDS_ERROR_SHADOW_FAILURE                        105
#define IDS_ERROR_SERVER                                106

#define IDS_SHADOWING_WINSTATION                        200
#define IDS_SHADOWING_LOGONID                           201
#define IDS_SHADOWING_DONE                              202
#define IDS_ERROR_NOT_TS                                203
#define IDS_SHADOWING_WARNING                           204

#define IDS_USAGE_1                                     300
#define IDS_USAGE_2                                     301
#define IDS_USAGE_3                                     302
#define IDS_USAGE_4                                     303
#define IDS_USAGE_5                                     304
#define IDS_USAGE_6                                     305
#define IDS_USAGE_7                                     306
#define IDS_USAGE_8                                     307
#define IDS_USAGE_9                                     308
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\rwinsta\rwinsta.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*************************************************************************
*
*  RWINSTA.H
*     This module contains typedefs and defines for the RESET
*     WinStation utility.
*
*
*************************************************************************/

/*
 * Usage string definitions.
 */
#define USAGE \
L"Reset the session subsystem hardware and software to known initial values.\n\n" \
L"RESET SESSION {sessionname | sessionid} [/SERVER:servername] [/V]\n\n" \
L"  sessionname         Identifies the session with name sessionname.\n" \
L"  sessionid           Identifies the session with ID sessionid.\n" \
L"  /SERVER:servername  The server containing the session (default is current).\n" \
L"  /V                  Display additional information.\n\n"


/*
 * Token string definitions.
 */
#define TOKEN_WS                        L""
#define TOKEN_HELP                      L"/?"
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_SERVER                    L"/server"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_NOT_FOUND                  102
#define IDS_ERROR_INVALID_LOGONID                       103
#define IDS_ERROR_LOGONID_NOT_FOUND                     104
#define IDS_ERROR_WINSTATION_RESET_FAILED               105
#define IDS_ERROR_LOGONID_RESET_FAILED                  106
#define IDS_ERROR_SERVER                                107

#define IDS_RESET_WINSTATION                            200
#define IDS_RESET_LOGONID                               201
#define IDS_RESET_WINSTATION_DONE                       202
#define IDS_RESET_LOGONID_DONE                          203
#define IDS_WARNING_LOGOFF                              204
#define IDS_WARNING_LOGOFF_QUESTIONABLE                 205
#define IDS_ERROR_NOT_TS                                206

#define IDS_USAGE_1                                     301
#define IDS_USAGE_2                                     302
#define IDS_USAGE_3                                     303
#define IDS_USAGE_4                                     304
#define IDS_USAGE_5                                     305
#define IDS_USAGE_6                                     306
#define IDS_USAGE_7                                     307
#define IDS_USAGE_8                                     308
#define IDS_USAGE_9                                     309
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\shutdown\tsshutdn.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*************************************************************************
*
*  TSSHUTDN.H
*     This module contains typedefs and defines for the TSSHUTDN utility.
*
*
*************************************************************************/



/*
 * Token string definitions.
 */
#define TOKEN_TIME                      L" "
#define TOKEN_HELP                      L"/?"
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_REBOOT                    L"/reboot"
#define TOKEN_POWERDOWN                 L"/powerdown"
#define TOKEN_FAST                      L"/now"

#if 0
#define TOKEN_DUMP                      L"/dump"
#endif

#define TOKEN_SERVER                    L"/server"
#define TOKEN_DELAY                     L"/delay"

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_INVALID_TIME                          102
#define IDS_ERROR_SHUTDOWN_FAILED                       103
#define IDS_SHUTTING_DOWN                               104
#define IDS_SHUTDOWN_DONE                               105
#define IDS_SHUTDOWN_REBOOT                             106
#define IDS_SHUTDOWN_POWERDOWN                          107
#define IDS_SHUTDOWN_WRITEPROT                          108
#define IDS_ERROR_SERVER                                109
#define IDS_LOGOFF_USERS                                110
#define IDS_ERROR_INVALID_DELAY                         111
#define IDS_ERROR_NO_RIGHTS                             112
#define IDS_NOTIFYING_USERS                             113
#define IDS_SENDING_WINSTATION                          114
#define IDS_ERROR_SENDING_WINSTATION                    115
#define IDS_SHUTDOWN_TITLE                              116
#define IDS_SHUTDOWN_MESSAGE                            117
#define IDS_USAGE                                       118
#define IDS_ERROR_NOT_TS								119
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\rwinsta\rwinsta.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*************************************************************************
*
*  RWINSTA.C
*     This module is the RESET WINSTA utility code.
*
*
*************************************************************************/

#include <stdio.h>
#include <windows.h>
//#include <ntddkbd.h>
//#include <ntddmou.h>
#include <winstaw.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>

#include "rwinsta.h"
#include <printfoa.h>

WINSTATIONNAME WSName;
USHORT help_flag = FALSE;
USHORT v_flag    = FALSE;
HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];

TOKMAP ptm[] =
{
#define TERM_PARM 0
   {TOKEN_WS,       TMFLAG_REQUIRED, TMFORM_S_STRING,
                        WINSTATIONNAME_LENGTH, WSName},

   {TOKEN_SERVER,   TMFLAG_OPTIONAL, TMFORM_STRING,
                        MAX_IDS_LEN, ServerName},

   {TOKEN_HELP,     TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                        sizeof(USHORT), &help_flag},

   {TOKEN_VERBOSE,  TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                        sizeof(USHORT), &v_flag},

   {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );
BOOL ProceedWithLogoff(HANDLE hServerName,ULONG LogonId,PWINSTATIONNAME pWSName);


/*************************************************************************
*
*  main
*     Main function and entry point of the RESET WINSTA
*     utility.
*
*  ENTRY:
*     argc  - count of the command line arguments.
*     argv  - vector of strings containing the command line arguments.
*
*  EXIT
*     Nothing.
*
*************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    int   rc, i;
    ULONG Error;
    WCHAR **argvW, *endptr;
    ULONG LogonId;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, TOKEN_SERVER) ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     * Validate, reset, and output status.
     */
    if ( !iswdigit(*WSName) ) {

        /*
         * Treat the entered string as a WinStation name.
         */
        if ( !LogonIdFromWinStationName(hServerName, WSName, &LogonId) ) {
            StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, WSName);
            return(FAILURE);
        }

        if(!ProceedWithLogoff(hServerName,LogonId,WSName))
           return (SUCCESS);

        if ( v_flag )
            StringMessage(IDS_RESET_WINSTATION, WSName);

        if ( !WinStationReset(hServerName, LogonId, TRUE) ) {
            Error = GetLastError();
            StringDwordErrorPrintf(IDS_ERROR_WINSTATION_RESET_FAILED, WSName, Error);
            PutStdErr( Error, 0 );
            return(FAILURE);
        }

        if ( v_flag )
            StringMessage(IDS_RESET_WINSTATION_DONE, WSName);

    } else {

        /*
         * Treated the entered string as a LogonId.
         */
        LogonId = wcstoul(WSName, &endptr, 10);
        if ( *endptr ) {
            StringErrorPrintf(IDS_ERROR_INVALID_LOGONID, WSName);
            return(FAILURE);
        }
        if ( !WinStationNameFromLogonId(hServerName, LogonId, WSName) ) {
            ErrorPrintf(IDS_ERROR_LOGONID_NOT_FOUND, LogonId);
            return(FAILURE);
        }

        if(!ProceedWithLogoff(hServerName,LogonId,WSName))
           return (SUCCESS);

        if ( v_flag )
            Message(IDS_RESET_LOGONID, LogonId);

        if ( !WinStationReset(hServerName, LogonId, TRUE) ) {
            Error = GetLastError();
            ErrorPrintf(IDS_ERROR_LOGONID_RESET_FAILED, LogonId, Error);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }

        if ( v_flag )
            Message(IDS_RESET_LOGONID_DONE, LogonId);
    }

    return(SUCCESS);

} /* main() */


/*******************************************************************************
 *
 *  ProcessWithLogoff
 *
 *      If LogonId does not have a corresponding UserName then a warning
 *      message is displayed.
 *
 *  ENTRY:
 *      hServerName : Handle to server
 *      LogonId     : ID as shown in qwinsta
 *      pWSName     : Session Name
 *
 *  EXIT:
 *       TRUE : User wants to logoff
 *       FALSE: User does not want to proceed with logoff
 *
 *
 ******************************************************************************/
BOOL ProceedWithLogoff(HANDLE hServerName,ULONG LogonId,PWINSTATIONNAME pWSName)
{
   #ifdef UNICODE
   #define GetStdInChar getwchar
   wint_t ch;
   #else
   #define GetStdInChar getchar
   int ch;
   #endif

   WINSTATIONINFORMATION WinInfo;
   ULONG ReturnLength;
   int rc;

   // No-session Name, No-Problem
   if(lstrlen(pWSName) == 0) return (TRUE);

   memset(&WinInfo,0,sizeof(WINSTATIONINFORMATION));
   rc = WinStationQueryInformation( hServerName,
                                    LogonId,
                                    WinStationInformation,
                                    (PVOID)&WinInfo,
                                    sizeof(WINSTATIONINFORMATION),
                                    &ReturnLength);

   // Try to show message only if necessary
   if( rc && (sizeof(WINSTATIONINFORMATION) == ReturnLength) ) {
      if(lstrlen(WinInfo.UserName) == 0) {
         ErrorPrintf(IDS_WARNING_LOGOFF);
         rc = GetStdInChar();
         if(rc == L'n') return(FALSE);
      }
   }
   // Failed on call - assume nothing and prompt with message
   else{
      ErrorPrintf(IDS_WARNING_LOGOFF_QUESTIONABLE);
      rc = GetStdInChar();
      if(rc == L'n') return(FALSE);
   }
   return (TRUE);
}

/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {

        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE_1);
        ErrorPrintf(IDS_USAGE_2);
        ErrorPrintf(IDS_USAGE_3);
        ErrorPrintf(IDS_USAGE_4);
        ErrorPrintf(IDS_USAGE_5);
        ErrorPrintf(IDS_USAGE_6);
        ErrorPrintf(IDS_USAGE_7);
        ErrorPrintf(IDS_USAGE_8);
        ErrorPrintf(IDS_USAGE_9);

    } else {

        Message(IDS_USAGE_1);
        Message(IDS_USAGE_2);
        Message(IDS_USAGE_3);
        Message(IDS_USAGE_4);
        Message(IDS_USAGE_5);
        Message(IDS_USAGE_6);
        Message(IDS_USAGE_7);
        Message(IDS_USAGE_8);
        Message(IDS_USAGE_9);

    }

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\cfgcomp\cfgbkend.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name:
*
*                       CfgBkEnd.cpp
*
* Abstract:
*                       This Module is generated by the ATL Wizard. This has the
*                       the exported functiond DllGetClassObject,DllRegisterServer
*                       DllUnRegisterServer, DllCanUnloadNow
*
*
* Author:
*
*
* Revision:
*
*
************************************************************************************************/


// Note: Proxy/Stub Information
//              To build a separate proxy/stub DLL,
//              run nmake -f CfgBkEndps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "CfgBkEnd.h"

#include "CfgBkEnd_i.c"
#include "PtrArray.h"
#include <winsta.h>
#include <regapi.h>
#include "Defines.h"
#include "CfgComp.h"


CComModule _Module;
HINSTANCE g_hInstance;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_CfgComp, CCfgComp)
END_OBJECT_MAP()

/**************************************************************************************/
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
        if (dwReason == DLL_PROCESS_ATTACH)
        {
        _Module.Init(ObjectMap, hInstance);

                DisableThreadLibraryCalls(hInstance);

                g_hInstance = hInstance;
        }
        else if (dwReason == DLL_PROCESS_DETACH)
                _Module.Term();
        return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

extern "C"
STDAPI DllCanUnloadNow(void)
{
        return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
extern "C"
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
        // registers object, typelib and all interfaces in typelib
    // except we don't need to register a typelib pass in false
    // alhen
        return _Module.RegisterServer( FALSE );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
        _Module.UnregisterServer();
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\shutdown\tsshutdn.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*************************************************************************
*
*  TSSHUTDN.C
*     This module is the TSSHUTDN utility code.
*
*
*************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <stdio.h>
#include <wchar.h>
#include <windows.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>

#include "tsshutdn.h"
#include "printfoa.h"

#define DEFAULT_WAIT_TIME  60
#define DEFAULT_LOGOFF_DELAY 30
#define MAX_MESSAGE_LENGTH 256

WCHAR  WSTime[MAX_IDS_LEN+2];
WCHAR  WDTime[MAX_IDS_LEN+2];
USHORT help_flag = FALSE;
USHORT v_flag    = FALSE;
USHORT RebootFlag = FALSE;
USHORT PowerDownFlag = FALSE;
USHORT FastFlag = FALSE;
#if 0
USHORT DumpFlag = FALSE;
#endif
HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];

TOKMAP ptm[] =
{
   {TOKEN_TIME,     TMFLAG_OPTIONAL, TMFORM_S_STRING, MAX_IDS_LEN, WSTime},

   {TOKEN_SERVER,   TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN, ServerName},

   {TOKEN_DELAY,    TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN, WDTime},

   {TOKEN_HELP,     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},

   {TOKEN_VERBOSE,  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &v_flag},

   {TOKEN_REBOOT,   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &RebootFlag},

   {TOKEN_POWERDOWN,TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &PowerDownFlag},

   {TOKEN_FAST,     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &FastFlag},

#if 0
   {TOKEN_DUMP,     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &DumpFlag},
#endif

   {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );
void NotifyUsers( ULONG WaitTime );
void NotifyWinStations( PLOGONIDW, ULONG, ULONG );
BOOLEAN CheckShutdownPrivilege();



/*************************************************************************
*
*  main
*     Main function and entry point of the TSSHUTDN utility.
*
*  ENTRY:
*     argc  - count of the command line arguments.
*     argv  - vector of strings containing the command line arguments.
*
*  EXIT
*     Nothing.
*
*************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    int   rc, i;
    ULONG Error;
    WCHAR *CmdLine;
    WCHAR **argvW, *endptr;
    ULONG ShutdownFlags = WSD_SHUTDOWN | WSD_LOGOFF;
    ULONG WaitTime = DEFAULT_WAIT_TIME;
    ULONG LogoffDelay = DEFAULT_LOGOFF_DELAY;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    WSTime[0] = L'\0';
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, TOKEN_SERVER) ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    // Make sure the user has the proper privilege
    // SM should really do the check
    /*
    if( !CheckShutdownPrivilege() ) {
        ErrorPrintf(IDS_ERROR_NO_RIGHTS);
        return(FAILURE);
    }
    */

    // Make sure its a number
    if ( WSTime[0] ) {

        if( !iswdigit(WSTime[0]) ) {
            StringErrorPrintf(IDS_ERROR_INVALID_TIME, WSTime);
            return(FAILURE);
        }

        WaitTime = wcstoul(WSTime, &endptr, 10);
        if ( *endptr ) {
            StringErrorPrintf(IDS_ERROR_INVALID_TIME, WSTime);
            return(FAILURE);
        }
    }

    // Make sure its a number
    if ( WDTime[0] ) {

        if( !iswdigit(WDTime[0]) ) {
            StringErrorPrintf(IDS_ERROR_INVALID_DELAY, WDTime);
            return(FAILURE);
        }

        LogoffDelay = wcstoul(WDTime, &endptr, 10);
        if ( *endptr ) {
            StringErrorPrintf(IDS_ERROR_INVALID_DELAY, WDTime);
            return(FAILURE);
        }
    }

#if 0
    /*
     * If /dump option was specified, call NT function directly
     */
    if ( DumpFlag ) {
        NtShutdownSystem( ShutdownDump );   // will not return
    }
#endif

    if( RebootFlag ) {
        ShutdownFlags |= WSD_REBOOT;
    }

    if( PowerDownFlag )
        ShutdownFlags |= WSD_POWEROFF;

    if( FastFlag ) {
        ShutdownFlags |= WSD_FASTREBOOT;
        ShutdownFlags &= ~WSD_LOGOFF;
        WaitTime = 0;
    }

    if( WaitTime ) {
        NotifyUsers( WaitTime );
    }

    /*
     * If necessary, force all WinStations to logoff
     */
    if ( ShutdownFlags & WSD_LOGOFF ) {
        Message( IDS_SHUTTING_DOWN, 0 );
        if ( !WinStationShutdownSystem( hServerName, WSD_LOGOFF ) ) {
            Error = GetLastError();
            ErrorPrintf( IDS_ERROR_SHUTDOWN_FAILED, Error );
            PutStdErr( Error, 0 );
            return( FAILURE );
        }
        Message( IDS_LOGOFF_USERS, 0);
        if (LogoffDelay) {
            NotifyUsers( LogoffDelay );
        }
        Message( IDS_SHUTDOWN_DONE, 0 );
    }

    /*
     * Inform user of impending reboot/poweroff
     */
    if ( ShutdownFlags & WSD_REBOOT ) {
        Message( IDS_SHUTDOWN_REBOOT, 0 );
        Sleep( 4000 );
    } else if ( ShutdownFlags & WSD_POWEROFF ) {
        Message( IDS_SHUTDOWN_POWERDOWN, 0 );
        Sleep( 4000 );
    }

    /*
     * Perform system shutdown, reboot, or poweroff, depending on flags
     */
    if( WinStationShutdownSystem( hServerName, ShutdownFlags & ~WSD_LOGOFF ) != ERROR_SUCCESS )
    {
        PutStdErr( GetLastError(), 0 );
    }

    // WinStationShutdownSystem is done asynchronously.
    // No way to know when the shudown is completed.
    //if ( !(ShutdownFlags & WSD_REBOOT) && !( ShutdownFlags & WSD_POWEROFF ) ) {
    //    /*
    //     * If we get here, shutdown is complete, all disks are write protected.
    //     */
    //    Message(IDS_SHUTDOWN_WRITEPROT, 0);
    //}

    return(SUCCESS);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    WCHAR sz1[1024];
    LoadString( NULL, IDS_USAGE, sz1, 1024 );
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        fwprintf(stderr, sz1);

    } else {

        fwprintf(stdout,sz1);
    }

}  /* Usage() */


/*****************************************************************************
 *
 *  NotifyUsers
 *
 *   Notify Users that the system is being shutdown
 *
 * ENTRY:
 *   WaitTime (input)
 *     Amount of time to give them to log off.
 *
 * EXIT:
 *
 ****************************************************************************/

void
NotifyUsers( ULONG WaitTime )
{
    BOOLEAN Result;
    ULONG Entries;
    ULONG Error;
    PLOGONIDW ptr;

    //
    // Get all of the WinStations call the function to notify them.
    //
    if ( WinStationEnumerateW( hServerName, &ptr, &Entries ) ) {

        NotifyWinStations( ptr, Entries, WaitTime );
        WinStationFreeMemory(ptr);

    } else {

        Error = GetLastError();
#if DBG
        printf("TSSHUTDN: Error emumerating Sessions %d\n",Error);
#endif
        return;
    }

    Message(IDS_NOTIFYING_USERS);

    // Now wait the wait time
    SleepEx( WaitTime*1000, FALSE );

    return;
}

/*****************************************************************************
 *
 *  NotifyWinStations
 *
 *   Notify the group of WinStations about the impending system shutdown
 *
 * ENTRY:
 *   pId (input)
 *     Array of LOGONIDW's
 *
 *   Entries (input)
 *     Number of entries in array
 *
 *   WaitTime (input)
 *     Amount of time to wait in seconds
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

void
NotifyWinStations(
    PLOGONIDW pId,
    ULONG     Entries,
    ULONG     WaitTime
    )
{
    ULONG Index;
    PLOGONIDW p;
    ULONG Response;
    BOOLEAN Result;
    WCHAR mBuf[MAX_MESSAGE_LENGTH+2];
//    PWCHAR pTitle = L"SYSTEM SHUTDOWN";
    PWCHAR pTitle;
    WCHAR sz1[256], sz2[512];

    LoadString( NULL, IDS_SHUTDOWN_TITLE, sz1, 256 );
    pTitle = &(sz1[0]);

    // Create the message
    LoadString( NULL, IDS_SHUTDOWN_MESSAGE, sz2, 512 );
    _snwprintf( mBuf, MAX_MESSAGE_LENGTH, sz2, WaitTime);

    for( Index=0; Index < Entries; Index++ ) {

        p = &pId[Index];
        if( p->State != State_Active ) continue;

        // Notify this WinStation
    if( v_flag ) {
            StringMessage(IDS_SENDING_WINSTATION, p->WinStationName);
        }

#if DBG
        if( v_flag ) {
            printf("Open, Now really sending message to Session %ws\n", p->WinStationName);
        }
#endif

        Result = WinStationSendMessage(
                     hServerName,
                     p->LogonId,
                     pTitle,
                     (wcslen(pTitle)+1)*sizeof(WCHAR),
                     mBuf,
                     (wcslen(mBuf)+1)*sizeof(WCHAR),
                     MB_OK,
                     WaitTime,
                     &Response,
                     TRUE
                     );

        if( !Result ) {
            StringErrorPrintf(IDS_ERROR_SENDING_WINSTATION, p->WinStationName);
        }

    }
}

/*****************************************************************************
 *
 *  CheckShutdownPrivilege
 *
 *   Check whether the current process has shutdown permission.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *
 ****************************************************************************/

BOOLEAN
CheckShutdownPrivilege()
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    //
    // Try the thread token first
    //

    Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                TRUE,
                                TRUE,
                                &WasEnabled);

    if (Status == STATUS_NO_TOKEN) {

        //
        // No thread token, use the process token
        //

        Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                    TRUE,
                                    FALSE,
                                    &WasEnabled);
    }

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\cfgcomp\cfgcomp.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name: 
*
*            CfgComp.h
*
* Abstract:
*            This contains the declaration for the functions in CfgBkEnd.
*
* 
* Author: Arathi Kundapur: a-akunda
*
* 
* Revision:  
*    
*
************************************************************************************************/

#ifndef __CFGCOMP_H_
#define __CFGCOMP_H_

#include "resource.h"       // main symbols
#include "PtrArray.h"    // Added by ClassView

extern HINSTANCE g_hInstance;
/////////////////////////////////////////////////////////////////////////////
// CCfgComp
class ATL_NO_VTABLE CCfgComp : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CCfgComp, &CLSID_CfgComp>,
    public ICfgComp,
    public ISettingsComp ,
    public IUserSecurity
{
public:
    CCfgComp()
    {
        m_bInitialized = FALSE;
        m_bAdmin = FALSE;

        lstrcpy( m_szConsole , L"Console" );
        /*
        LoadString(g_hInstance, IDS_SYSTEM_CONSOLE_NAME,
                m_szConsole, WINSTATIONNAME_LENGTH );
                */

    }
    ~CCfgComp()
    {
        UnInitialize();
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CFGCOMP)
DECLARE_NOT_AGGREGATABLE(CCfgComp)

BEGIN_COM_MAP(CCfgComp)
    COM_INTERFACE_ENTRY(ICfgComp)
    COM_INTERFACE_ENTRY(ISettingsComp)
    COM_INTERFACE_ENTRY(IUserSecurity)
END_COM_MAP()

// ICfgComp Methods
public:
    // STDMETHOD(SetDefaultSecurity)(ULONG Offset);

    // STDMETHOD(GetDefaultSecurity)(ULONG * pDefaultSecurity);

    STDMETHOD(SetInternetConLic)(BOOL bInternetConLic , PDWORD );

    STDMETHOD(GetInternetConLic)(BOOL * pbInternetConLic , PDWORD );

    STDMETHOD(SetLicensingMode)(ULONG ulMode , PDWORD, PDWORD );

    STDMETHOD(GetLicensingMode)(ULONG *pulMode , PDWORD );

    STDMETHOD(GetLicensingModeInfo)(ULONG ulMode , WCHAR **pwszName, WCHAR **pwszDescription, PDWORD );

    STDMETHOD(GetLicensingModeList)(ULONG *pcModes , ULONG **prgulModes, PDWORD );


    STDMETHOD(SetUseTempDirPerSession)(BOOL bTempDirPerSession);

    STDMETHOD(GetUseTempDirPerSession)(BOOL *  pbTempDir);

    STDMETHOD(SetDelDirsOnExit)(BOOL bDelDirsOnExit);

    STDMETHOD(GetDelDirsOnExit)(BOOL * pDelDirsOnExit);

    // STDMETHOD(SetCachedSessions)(DWORD dCachedSessions);

    STDMETHOD_(BOOL, IsAsyncDeviceAvailable)(LPCTSTR pDeviceName);

    STDMETHOD(DeleteWS)(PWINSTATIONNAME pWs);
    
    STDMETHOD(IsNetWorkConnectionUnique)(WCHAR * WdName, WCHAR * PdName, ULONG LanAdapter , BOOL * pUnique);
    
    STDMETHOD(GetDefaultUserConfig)(WCHAR * WdName,long * pSize,PUSERCONFIG* ppUser);
    
    STDMETHOD(CreateNewWS)(WS WinstationInfo,long UserCnfgSize, PUSERCONFIG pUserConfig, PASYNCCONFIGW pAsyncConfig);
    
    STDMETHOD(GetWSInfo)(PWINSTATIONNAME pWSName, long * Size, WS **ppWS);
    
    STDMETHOD(UpDateWS)( PWS , DWORD Data , PDWORD, BOOLEAN bPerformMerger );
    
    STDMETHOD(GetDefaultSecurityDescriptor)(long * pSize,PSECURITY_DESCRIPTOR  *ppSecurityDescriptor);
    
    STDMETHOD(IsSessionReadOnly)(BOOL * pReadOnly);
    
    STDMETHOD(RenameWinstation)(PWINSTATIONNAMEW pOldWinstation, PWINSTATIONNAMEW pNewWinstation);
    
    STDMETHOD(EnableWinstation)(PWINSTATIONNAMEW pWSName, BOOL fEnable);
    
    STDMETHOD(SetUserConfig)(PWINSTATIONNAMEW pWsName, ULONG size, PUSERCONFIG pUserConfig , PDWORD );
    
    STDMETHOD(GetLanAdapterList)(WCHAR * pdName, ULONG * pNumAdapters,ULONG * pSize,WCHAR ** ppData);

    STDMETHOD(GetLanAdapterList2)(WCHAR * pdName, ULONG * pNumAdapters, PGUIDTBL *);

    STDMETHOD( BuildGuidTable )( PGUIDTBL * , int , WCHAR * );
    
    STDMETHOD(GetTransportTypes)(WCHAR * Name, NameType Type,ULONG *pNumWd,ULONG * pSize, WCHAR **ppData);
    
    STDMETHOD(IsWSNameUnique)(PWINSTATIONNAMEW pWSName,BOOL * pUnique);
    
    STDMETHOD(GetWdTypeList)(ULONG *pNumWd,ULONG * pSize, WCHAR **ppData);
    
    STDMETHOD(GetWinstationList)(ULONG * NumWinstations, ULONG * Size, PWS * ppWS);
    
    STDMETHOD(Initialize)();
    
    STDMETHOD(GetEncryptionLevels)(WCHAR * pName, NameType Type,ULONG * pNumEncryptionLevels,Encryption ** ppEncryption);
    
    STDMETHOD(GetUserConfig)(PWINSTATIONNAMEW pWsName, long * pSize,PUSERCONFIG * ppUser, BOOLEAN bPerformMerger);
    
    STDMETHOD(SetSecurityDescriptor)(PWINSTATIONNAMEW pWsName,DWORD Size,PSECURITY_DESCRIPTOR pSecurityDescriptor);
    
    STDMETHOD(GetSecurityDescriptor)(PWINSTATIONNAMEW pWSName,long * pSize,PSECURITY_DESCRIPTOR *ppSecurityDescriptor);

    STDMETHOD( ForceUpdate )( void );

    STDMETHOD( Refresh )( void );

    STDMETHOD( GetWdType )( PWDNAMEW , PULONG );

    STDMETHOD( GetTransportType )( WCHAR * , WCHAR * , DWORD * );

    STDMETHOD( IsAsyncUnique )( WCHAR * , WCHAR * , BOOL * );

    STDMETHOD( SetAsyncConfig )( WCHAR * , NameType , PASYNCCONFIGW , PDWORD );

    STDMETHOD( GetAsyncConfig )( WCHAR * , NameType , PASYNCCONFIGW );

    STDMETHOD( GetDeviceList )( WCHAR * , NameType , ULONG * , LPBYTE * );

    STDMETHOD( GetConnTypeName )( int  , WCHAR * );

    STDMETHOD( GetHWReceiveName )( int ,  WCHAR * );

    STDMETHOD( GetHWTransmitName )( int , WCHAR * );

    STDMETHOD( GetModemCallbackString )( int , WCHAR * );

    STDMETHOD( GetCaps )( WCHAR * , ULONG * );

    STDMETHOD( QueryLoggedOnCount )( WCHAR * , LONG * );

	STDMETHOD( GetNumofWinStations )(WCHAR *,WCHAR *, PULONG );

    STDMETHOD( UpdateSessionDirectory )( PDWORD );    

    STDMETHOD( GetColorDepth )(  /* in */ PWINSTATIONNAMEW pWs, /* out */ BOOL * , /* out */ PDWORD );

    STDMETHOD( SetColorDepth )(  /* in */ PWINSTATIONNAMEW pWs, /* in */ BOOL, /* out */ PDWORD );

    STDMETHOD( GetKeepAliveTimeout )(  /* in */ PWINSTATIONNAMEW pWs, /* out */ BOOL * , /* out */ PDWORD );

    STDMETHOD( SetKeepAliveTimeout )(  /* in */ PWINSTATIONNAMEW pWs, /* in */ BOOL, /* out */ PDWORD );

    STDMETHOD( GetProfilePath )(  /* out */ BSTR * , /* out */ PDWORD );

    STDMETHOD( SetProfilePath )(  /* in */ BSTR , /* out */ PDWORD );

    STDMETHOD( GetHomeDir )(  /* out */ BSTR * , /* out */ PDWORD );

    STDMETHOD( SetHomeDir )(  /* in */ BSTR , /* out */ PDWORD );



//ISettingComp Methods

    // STDMETHOD( GetCachedSessions )(DWORD * );

	STDMETHOD( SetActiveDesktopState )( /* in */ BOOL , /* out */ PDWORD );

	STDMETHOD( GetActiveDesktopState )( /* out */ PBOOL , /* out */ PDWORD );

    STDMETHOD( GetTermSrvMode )( /* out */ PDWORD , /* out */ PDWORD );

    STDMETHOD( GetWdKey )( /* in */ WCHAR * , /* out , string */ WCHAR * );

    STDMETHOD( GetUserPerm )( /* out */ BOOL * , /* out */ DWORD * );

    STDMETHOD( SetUserPerm )( /* in */ BOOL , /* out */ PDWORD );

    STDMETHOD( GetSalemHelpMode )( /* out */ BOOL *, /* out */ PDWORD );

    STDMETHOD( SetSalemHelpMode )( /* in */ BOOL, /* out */ PDWORD );

    
    STDMETHOD( GetDenyTSConnections )( /* out */ BOOL * , /* out */ PDWORD );

    STDMETHOD( SetDenyTSConnections )( /* in */ BOOL, /* out */ PDWORD );

    STDMETHOD( GetSingleSessionState )(  /* out */ BOOL * , /* out */ PDWORD );

    STDMETHOD( SetSingleSessionState )(  /* in */ BOOL, /* out */ PDWORD );
    


//IUserSecurity Methods
    STDMETHOD( ModifyUserAccess )( /* in */ WCHAR *pwszWinstaName ,
                                   /* in */ WCHAR *pwszAccountName ,
                                   /* in */ DWORD  dwMask ,
                                   /* in */ BOOL   fDel ,
                                   /* in */ BOOL   fAllow ,
                                   /* in */ BOOL   fNew ,
                                   /* in */ BOOL   fAuditing ,
                                   /* out*/ PDWORD pdwStatus );

    STDMETHOD( ModifyDefaultSecurity )( /* in */ WCHAR *pwszWinstaName ,
                                   /* in */ WCHAR *pwszAccountName ,
                                   /* in */ DWORD  dwMask ,
                                   /* in */ BOOL   fDel ,
                                   /* in */ BOOL   fAllow ,
                                   /* in */ BOOL   fAuditing ,
                                   /* out*/ PDWORD pdwStatus );

    STDMETHOD( GetUserPermList )( /* in */ WCHAR *pwszWinstaName ,
                                  /* out*/ PDWORD pcbItems ,
                                  /* out*/ PUSERPERMLIST *ppUserPermList,
                                  /* in */ BOOL fAudit );

    
private:
    // PSECURITY_DESCRIPTOR ReadSecurityDescriptor(ULONG index);
    // HRESULT SetDefaultSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurity);

    DWORD
    RemoveUserEntriesInACL(
        LPCTSTR pszUserName,
        PACL pAcl,
        PACL* ppNewAcl
    );

    DWORD
    GetUserSid(
        LPCTSTR pszUserName,
        PSID* ppUserSid
    );

    HRESULT 
    SetSecurityDescriptor(
        BOOL bDefaultSecurity,    
        PWINSTATIONNAMEW pWsName,
        DWORD Size,
        PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

    BOOL
    ValidDefaultSecurity(
        const WCHAR* pwszName
    );

    HRESULT
    ModifyWinstationSecurity(
        BOOL bDefaultSecurity,
        WCHAR *pwszWinstaName ,
        WCHAR *pwszAccountName ,
        DWORD  dwMask ,
        BOOL   fDel ,
        BOOL   fAllow ,
        BOOL   fNew ,
        BOOL   fAuditing ,
        PDWORD pdwStatus 
    );

    void DeleteWDArray();
    STDMETHODIMP FillWdArray();
    STDMETHODIMP FillWsArray();
    STDMETHODIMP InsertInWSArray( PWINSTATIONNAMEW pWSName,PWINSTATIONCONFIG2W pWSConfig,
                                   PWS * ppObject );
    void DeleteWSArray();
    PWD GetWdObject(PWDNAMEW pWdName);
    PWS GetWSObject(WINSTATIONNAMEW WSName);
    STDMETHOD(UnInitialize)();
    BOOL GetResourceStrings( int * , int , WCHAR * );
    HRESULT GetWinStationSecurity(BOOL bDefault, PWINSTATIONNAMEW pWSName,PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
    //Function borrowed from security.c in tscfg project

    DWORD ValidateSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor);
    // BOOL CompareSD(PSECURITY_DESCRIPTOR pSd1,PSECURITY_DESCRIPTOR pSd2);
    BOOL RegServerAccessCheck(REGSAM samDesired);
    void GetPdConfig( WDNAME WdKey,WINSTATIONCONFIG2W& WsConfig);

    void VerifyGuidsExistence( PGUIDTBL * , int , WCHAR *);
    HRESULT AdjustLanaId( PGUIDTBL * , int , int , PDWORD , PDWORD , int* , int );


    
    CPtrArray m_WDArray;
    BOOL m_bInitialized;
    BOOL m_bAdmin;
    CPtrArray m_WSArray;
    TCHAR m_szConsole[WINSTATIONNAME_LENGTH + 1];
};

#endif //__CFGCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\cfgcomp\defines.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name: 
*
*			Defines.h
*
* Abstract:
*			This is file with some internal definitions
* 
* Author:
*
* 
* Revision:  
*    
*
************************************************************************************************/


#ifndef _DEFINES_H
#define _DEFINES_H_


#ifdef UNICODE
#define lstr_access _waccess
#else
#define lstr_access _access
#endif

// Flags for EncryptionLevel.Flags
const WORD ELF_DEFAULT  = 0x0001;    // This is the default value

typedef void* PEXTOBJECT;

typedef struct _EncLevel {
    WORD StringID;
    DWORD RegistryValue;    
    WORD Flags;
} EncryptionLevel;

#define REG_DEF_SECURITY                      L"DefaultSecurity"
#define REG_REMOTE_SECURITY                   L"RemoteAdmin"
#define REG_APPL_SECURITY                     L"AppServer"
#define REG_ANON_SECURITY                     L"Anonymous"



typedef void (WINAPI *LPFNEXTSTARTPROC) (WDNAMEW *pWdName);
typedef void (WINAPI *LPFNEXTENDPROC) (void);

typedef LONG (WINAPI *LPFNEXTENCRYPTIONLEVELSPROC) (WDNAMEW *pWdName, EncryptionLevel **);

typedef LONG ( WINAPI *LPFNEXTGETENCRYPTIONLEVELDESCPROC )( int idx , int *pnResid );

typedef void (WINAPI *LPFNEXTDIALOGPROC) (HWND, PEXTOBJECT);
typedef void (WINAPI *LPFNEXTDELETEOBJECTPROC) (PEXTOBJECT);
typedef PEXTOBJECT (WINAPI *LPFNEXTDUPOBJECTPROC) (PEXTOBJECT);
typedef PEXTOBJECT (WINAPI *LPFNEXTREGQUERYPROC) (PWINSTATIONNAMEW, PPDCONFIGW);
typedef LONG (WINAPI *LPFNEXTREGCREATEPROC) (PWINSTATIONNAMEW, PEXTOBJECT, BOOLEAN);
typedef LONG (WINAPI *LPFNEXTREGDELETEPROC) (PWINSTATIONNAMEW, PEXTOBJECT);
typedef BOOL (WINAPI *LPFNEXTCOMPAREOBJECTSPROC) (PEXTOBJECT, PEXTOBJECT);
typedef ULONG (WINAPI *LPFNEXTGETCAPABILITIES) (void);



typedef struct tagWD
{
	WDNAMEW wdName;
	WDNAMEW wdKey;
    WDCONFIG2 wd2;
	HINSTANCE  hExtensionDLL;
    LPFNEXTSTARTPROC lpfnExtStart;    
    LPFNEXTENDPROC lpfnExtEnd;
    LPFNEXTENCRYPTIONLEVELSPROC lpfnExtEncryptionLevels;
    LPFNEXTGETENCRYPTIONLEVELDESCPROC lpfnExtGetEncryptionLevelDescr;
	LPFNEXTDELETEOBJECTPROC lpfnExtDeleteObject;
	LPFNEXTREGQUERYPROC lpfnExtRegQuery;
	LPFNEXTREGCREATEPROC lpfnExtRegCreate;
	LPFNEXTREGDELETEPROC lpfnExtRegDelete;
	LPFNEXTDUPOBJECTPROC lpfnExtDupObject;
    LPFNEXTGETCAPABILITIES lpfnGetCaps;
	// CPtrArray PDNameArray;
    CPtrArray PDConfigArray; // PDCONFIG3W

} WD;


/*typedef struct tagWS
{
	WINSTATIONNAMEW Name;
	PDNAMEW pdName;
	WDNAMEW wdName;
	WCHAR Comment[WINSTATIONCOMMENT_LENGTH + 1];
	ULONG uMaxInstanceCount;
	BOOL fEnableWinstation;
	ULONG LanAdapter;
	SDCLASS SdClass;
} WS;*/


typedef WD * PWD;

static CHAR szStart[] = "ExtStart";
static CHAR szEnd[] = "ExtEnd";
static CHAR szDialog[] = "ExtDialog";
static CHAR szDeleteObject[] = "ExtDeleteObject";
static CHAR szDupObject[] = "ExtDupObject";
static CHAR szRegQuery[] = "ExtRegQuery";
static CHAR szRegCreate[] = "ExtRegCreate";
static CHAR szRegDelete[] = "ExtRegDelete";
static CHAR szCompareObjects[] = "ExtCompareObjects";
static CHAR szEncryptionLevels[] = "ExtEncryptionLevels";
static CHAR szGetCapabilities[] = "ExtGetCapabilities";
static CHAR szGetEncryptionLevelDescr[] = "ExtGetEncryptionLevelDescr";
static CHAR szGetCaps[] = "ExtGetCapabilities";
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\cfgcomp\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CfgBkEnd.rc
//
#define IDS_ASYNC_ADVANCED_HWRX_NOTHING 76
#define IDS_ASYNC_ADVANCED_HWRX_TURN_OFF_RTS 77
#define IDS_ASYNC_ADVANCED_HWRX_TURN_OFF_DTR 78
#define IDS_ASYNC_ADVANCED_HWTX_ALWAYS  79
#define IDS_ASYNC_ADVANCED_HWTX_WHEN_CTS_IS_ON 80
#define IDS_ASYNC_ADVANCED_HWTX_WHEN_DSR_IS_ON 81
#define IDS_CONNECT_CTS                 82
#define IDS_CONNECT_DSR                 83
#define IDS_CONNECT_RI                  84
#define IDS_CONNECT_DCD                 85
#define IDS_CONNECT_FIRST_CHARACTER     86
#define IDS_CONNECT_ALWAYS              87
#define IDS_MODEM_CALLBACK_DISABLED     88
#define IDS_MODEM_CALLBACK_ROVING       89
#define IDS_MODEM_CALLBACK_FIXED        90
#define IDS_PROJNAME                    100
#define IDR_CFGCOMP                     101
#define IDS_SYSTEM_CONSOLE_NAME         101
#define IDS_ALL_LAN_ADAPTERS            105
#define IDS_REMOTE_SECURITY             106
#define IDS_APPLICATION_SECURITY        107
#define IDS_ANONYMOUS_SECURITY          108

#define IDS_LICENSING_RA_NAME 1000
#define IDS_LICENSING_RA_DESC 1001
#define IDS_LICENSING_PERSEAT_NAME 1002
#define IDS_LICENSING_PERSEAT_DESC 1003
#define IDS_LICENSING_PERSESSION_NAME 1004
#define IDS_LICENSING_PERSESSION_DESC 1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\cfgcomp\idldefs.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name: 
*
*			idldefs.h
*
* Abstract:
*			This is file with some definitions.
* 
* Author:Arathi Kundapur. a-akunda
*
* 
* Revision:  
*    
*
************************************************************************************************/

#include<Accctrl.h>
typedef struct _Encyption
{
    TCHAR szLevel[128];   // tscfg uses this 128 value, check if this is the restriction on the size in the ext dll.
    TCHAR szDescr[256];   // new field for description
    DWORD RegistryValue;    
    WORD Flags;
} Encryption;

#define NUM_DEFAULT_SECURITY 3
typedef enum _NameType
{
	WdName,
	WsName
} NameType;


/*typedef struct tagWS
{
	WINSTATIONNAME Name;
	PDNAME pdName;
	WDNAME wdName;
	TCHAR Comment[WINSTATIONCOMMENT_LENGTH+1];
	ULONG uMaxInstanceCount;
	BOOL fEnableWinstation;
	ULONG LanAdapter;
	SDCLASS SdClass;
} WS;*/

/*
typedef enum _UpDateDataType
{
	LANADAPTER,
	ENABLEWINSTATION,
	MAXINSTANCECOUNT,
	COMMENT,
	ALL

} UpDateDataType;


const DWORD UDPATE_LANADAPTER       =   0x00000001;
const DWORD UDPATE_ENABLEWINSTAION  =   0x00000002;
const DWORD UDPATE_MAXINSTANCECOUNT =   0x00000004;
const DWORD UDPATE_COMMENT          =   0x00000008;
*/
typedef struct tagWS
{
	WCHAR Name[32 + 1];   // WINSTATIONNAME_LENGTH
	WCHAR pdName[32 + 1]; // Protocol name PDNAME,PDNAME_LENGTH 
	WCHAR wdName[32 + 1]; // winstation driver NAME, WDNAME_LENGTH
	WCHAR Comment[60 +1]; // WINSTATIONCOMMENT_LENGTH
    WCHAR DeviceName[ 128 + 1 ]; // DEVICENAME_LENGTH
	ULONG uMaxInstanceCount;
	BOOL fEnableWinstation;
	ULONG LanAdapter;
	DWORD PdClass;
    
} WS;

typedef WS * PWS;

typedef struct tagGuidTbl
{
    WCHAR DispName[ 128 ]; // DEVICENAME_LENGTH
    GUID  guidNIC;
    DWORD dwLana;
    DWORD dwStatus;

} GUIDTBL , *PGUIDTBL;

typedef struct tagUserPermList
{
    WCHAR Name[ 256 ];
    WCHAR Sid[ 256 ];
    DWORD Mask;
    ACCESS_MODE Type;

} USERPERMLIST , *PUSERPERMLIST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\cfgcomp\cfgcomp.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name:
*
*            CfgComp.cpp
*
* Abstract:
*            This Module contains the implemetation of functions for the CfgBkEnd Component
*
* Author: Arathi Kundapur. a-akunda
* Owner:  alhen
*
*
* Revision: 
*
*
************************************************************************************************/



#include "stdafx.h"
#define SECURITY_WIN32
#include "PtrArray.h"
#include "CfgBkEnd.h"
#include <winsta.h>
#include <regapi.h>
#include "defines.h"
#include "CfgComp.h"
#include "Security.h"
#include <utildll.h>
#define INITGUID
#include "objbase.h"
#include "initguid.h"
#include <netcfgx.h>
#include <cfg.h>
#include "devguid.h"
#include <aclapi.h>
#include <sddl.h>

#define REG_GUID_TABLE      REG_CONTROL_TSERVER L"\\lanatable\\"
#define REG_GUID_TABLE_T    REG_CONTROL_TSERVER L"\\lanatable"
#define LANA_ID             L"LanaId"

#define ARRAYSIZE( rg ) sizeof( rg ) / sizeof( rg[0] )

#ifdef DBG
bool g_fDebug = false;
#endif

/***********************************************************************************************************/

#define RELEASEPTR(iPointer)    if(iPointer) \
                                        { \
                                             iPointer->Release();\
                                             iPointer = NULL;\
                                        }
/***************************************************************************************************************/

LPTSTR g_pszDefaultSecurity[] = {
        L"DefaultSecurity",
        L"ConsoleSecurity"
    };

DWORD g_numDefaultSecurity = sizeof(g_pszDefaultSecurity)/sizeof(g_pszDefaultSecurity[0]);

        

BOOL TestUserForAdmin( );

DWORD RecursiveDeleteKey( HKEY hKeyParent , LPTSTR lpszKeyChild );

/***************************************************************************************************************

  Name:      GetSecurityDescriptor

  Purpose:   Gets the Security Descriptor for a Winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
             out:   pSize - Size of the allocated buffer
                    ppSecurityDescriptor - Pointer to the buffer containing the security descriptor


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetSecurityDescriptor(PWINSTATIONNAMEW pWSName, long * pSize,PSECURITY_DESCRIPTOR * ppSecurityDescriptor)
{
     HRESULT hResult = S_OK;

    if(NULL == pSize || NULL == ppSecurityDescriptor || NULL == pWSName)
        return E_INVALIDARG;

    *pSize =0;

    *ppSecurityDescriptor = NULL;

    hResult = GetWinStationSecurity(FALSE, pWSName,(PSECURITY_DESCRIPTOR *)ppSecurityDescriptor);

    if(FAILED(hResult))
    {
        //Try Getting Default Security Descriptor
        hResult = GetWinStationSecurity(TRUE, NULL,(PSECURITY_DESCRIPTOR *)ppSecurityDescriptor);
    }
    if( SUCCEEDED( hResult ) && *ppSecurityDescriptor != NULL )
    {
        *pSize = GetSecurityDescriptorLength(*ppSecurityDescriptor);
    }
    return hResult;
}

/***************************************************************************************************************

  Name:      SetSecurityDescriptor

  Purpose:   Sets the Security Descriptor for a Winstation

  Returns:   HRESULT.

  Params:
             in:    pWsName - Name of the Winstation.
                    Size - Size of the allocated buffer
                    pSecurityDescriptor - Pointer to the Security Descriptor


 ****************************************************************************************************************/

BOOL
CCfgComp::ValidDefaultSecurity(
    const WCHAR* pwszName
    )
/*++

--*/
{
    for( DWORD i=0; i < g_numDefaultSecurity; i++ )
    {
        if( lstrcmpi( g_pszDefaultSecurity[i], pwszName ) == 0 )
        {
            break;
        }
    }

    return ( i >= g_numDefaultSecurity ) ? FALSE : TRUE;
}


HRESULT 
CCfgComp::SetSecurityDescriptor(
    BOOL bDefaultSecurity,    
    PWINSTATIONNAMEW pWsName,
    DWORD Size,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

--*/
{
    HRESULT hResult = S_OK;
    HKEY Handle1 = NULL, Handle2 = NULL;

    //Check if the caller has write permissions.
    if(!m_bAdmin)
    {
        ODS( L"SetSecurityDescriptor : User Is not Admin. \n" );
        return E_ACCESSDENIED;
    }

    //Check the parametes for NULL
    if(NULL == pWsName || NULL == pSecurityDescriptor || 0 == Size)
        return E_INVALIDARG;

    if( TRUE == bDefaultSecurity && FALSE == ValidDefaultSecurity( pWsName ) )
    {
        return E_INVALIDARG;
    }

    //Check for the validity of the Winstation name

    /*if(NULL == GetWSObject(pWsName))  //Commented out to get Rename Work. This might not be needed .
        return E_INVALIDARG;*/

    //Check if the data passed is a valid security descriptor

     if(ERROR_SUCCESS != ValidateSecurityDescriptor((PSECURITY_DESCRIPTOR)pSecurityDescriptor))
        return E_INVALIDARG;

    if(Size != GetSecurityDescriptorLength((PSECURITY_DESCRIPTOR)pSecurityDescriptor))
        return E_INVALIDARG;

    //Make the Resitry entries required.

    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,KEY_ALL_ACCESS, &Handle1 ) != ERROR_SUCCESS )
    {
        return E_FAIL;
    }

    if( TRUE == bDefaultSecurity )
    {
        if( RegSetValueEx( Handle1, pWsName, 0, REG_BINARY,(BYTE *)pSecurityDescriptor, Size ) != ERROR_SUCCESS )
        {
            hResult = E_FAIL;
        }
    }
    else
    {
        if( RegOpenKeyEx(Handle1, pWsName, 0, KEY_ALL_ACCESS, &Handle2 ) != ERROR_SUCCESS )
        {
            RegCloseKey(Handle1);

            return E_FAIL;
        }

        if( RegSetValueEx( Handle2, L"Security", 0, REG_BINARY,(BYTE *)pSecurityDescriptor, Size ) != ERROR_SUCCESS )
        {
            hResult = E_FAIL;
        }
    }

    if( Handle1 != NULL )
    {
        RegCloseKey(Handle1);
    }

    if( Handle2 != NULL )
    {
        RegCloseKey(Handle2);
    }

    return hResult;
}


STDMETHODIMP CCfgComp::SetSecurityDescriptor(PWINSTATIONNAMEW pWsName, DWORD Size,PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    return SetSecurityDescriptor( FALSE, pWsName, Size, pSecurityDescriptor );
}    

/***************************************************************************************************************

  Name:      GetUserConfig

  Purpose:   Gets the UserConfig for a Winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
             out:   pSize - Size of the allocated buffer
                    ppUser - Pointer to the buffer containing the UserConfig


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetUserConfig(PWINSTATIONNAMEW pWsName, long * pSize, PUSERCONFIG * ppUser, BOOLEAN bPerformMerger)
{
    HRESULT hResult = S_OK;
    WINSTATIONCONFIG2W WSConfig;
    LONG Size = 0;
    ULONG Length = 0;

    *pSize = 0;
    *ppUser = NULL;

    //Read the information from the registry.

    POLICY_TS_MACHINE p;
    memset(&p, 0, sizeof(POLICY_TS_MACHINE));
    if((ERROR_SUCCESS != RegWinStationQueryEx(NULL,&p,pWsName,&WSConfig,sizeof(WINSTATIONCONFIG2W),&Length,bPerformMerger)))
        return E_FAIL;

    Size = sizeof(WSConfig.Config.User);
    *ppUser = (PUSERCONFIG)CoTaskMemAlloc(Size);
    if(*ppUser == NULL)
        return E_OUTOFMEMORY;

    CopyMemory((PVOID)*ppUser,(CONST VOID *)&WSConfig.Config.User,Size);
    *pSize = Size;


    return hResult;
}

/***************************************************************************************************************

  Name:      GetEncryptionLevels

  Purpose:   Gets the Encyption Levels for a Winstation

  Returns:   HRESULT.

  Params:
             in:    pName - Name of the Winstation or the Winstation Driver depending the value of Type
                    Type - Specifies whether the Name is a Winstation name or WD Name (WsName, WdName)
             out:   pNumEncryptionLevels - Number of Encryption Levels
                    ppEncryption - Pointer to the buffer containing the Encryption Levels


 ****************************************************************************************************************/

STDMETHODIMP CCfgComp::GetEncryptionLevels(WCHAR * pName, NameType Type,ULONG * pNumEncryptionLevels,Encryption ** ppEncryption)
{
    HRESULT hResult = S_OK;
    PWD pWD = NULL;
    PWS pWS = NULL;
    ULONG NumLevels = 0, Size =0 ,i = 0;
    EncryptionLevel *pEncryptionLevels = NULL;

    //Check the parameters
    if(NULL == pNumEncryptionLevels || NULL == pName || NULL == ppEncryption)
        return E_INVALIDARG;
    *pNumEncryptionLevels = 0;
     *ppEncryption = NULL;

    //Get the pointer to the appropriate WD object.
    if(Type == WsName)
    {
        pWS = GetWSObject(pName);
        if(NULL == pWS)
            return E_INVALIDARG;
        pWD = GetWdObject(pWS->wdName);
        if(NULL == pWD)
            return E_FAIL;
    }
    else if(Type == WdName)
    {
        pWD = GetWdObject(pName);
        if(NULL == pWD)
            return E_INVALIDARG;
    }
    else
        return E_INVALIDARG;

    //Check if this object has the extension dll associated with it.
    //Check if the function for encryption levels was exposed in the dll
    if(!(pWD->hExtensionDLL && pWD->lpfnExtEncryptionLevels))
        return E_FAIL;

    //Get the EncryptionLevels. The Strings should be seperately extracted from the resource
    NumLevels = (pWD->lpfnExtEncryptionLevels)(&pWS->wdName, &pEncryptionLevels);
    if(NULL == pEncryptionLevels)
        return E_FAIL;

    Size = sizeof(Encryption);
    Size = NumLevels * sizeof(Encryption);
    *ppEncryption = (Encryption*)CoTaskMemAlloc(Size);
    if(*ppEncryption == NULL)
        return E_OUTOFMEMORY;

    //copy the relevent data to the Encryption structure

    for(i = 0; i < NumLevels; i++)
    {
        //Extract the string corresponding to the levels.
        if(0 == LoadString(pWD->hExtensionDLL,pEncryptionLevels[i].StringID,
                          ((*ppEncryption)[i]).szLevel, sizeof( ( ( *ppEncryption )[ i ] ).szLevel ) / sizeof( TCHAR ) ) )
        {
            hResult = E_FAIL;
            break;
        }
        ((*ppEncryption)[i]).RegistryValue = pEncryptionLevels[i].RegistryValue;

        ((*ppEncryption)[i]).szDescr[ 0 ] = 0;

        if( pWD->lpfnExtGetEncryptionLevelDescr != NULL )
        {
            int nResID = 0;

            if( ( pWD->lpfnExtGetEncryptionLevelDescr )( pEncryptionLevels[i].RegistryValue , &nResID ) != -1 )
            {
                LoadString( pWD->hExtensionDLL , nResID ,  ((*ppEncryption)[i]).szDescr , sizeof( ( (*ppEncryption )[ i ] ).szDescr ) / sizeof( TCHAR ) );
            }
        }

        ((*ppEncryption)[i]).Flags = pEncryptionLevels[i].Flags;

    }

    *pNumEncryptionLevels = NumLevels;



    //pEncrptionLevels need not be cleaned up as it is global data in Rdpcfgex.dll
    if(FAILED(hResult))
    {
        if(*ppEncryption)
        {
            CoTaskMemFree(*ppEncryption);
            *ppEncryption = NULL;
            *pNumEncryptionLevels = 0;
        }
    }
    return hResult;
}

/***************************************************************************************************************

  Name:      FillWdArray

  Purpose:   Internal function to fill the m_WdArray

  Returns:   HRESULT.

  Params:

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::FillWdArray()
{

    //Use the functionalities already provided by the regapi,
    //instead of reinventing the wheel

    long Status;
    ULONG Index, Index2, ByteCount, Entries, Entries2;
    PDNAMEW PdKey;
    WDNAMEW WdKey;
    LONG QStatus;
    WDCONFIG2W WdConfig;
    PDCONFIG3W PdConfig;
    TCHAR WdDll[MAX_PATH];
    HRESULT hResult = S_OK;
    /*
    TCHAR * pPdName = NULL;
    */
    PWD pWd = NULL;

    //Delete if there are already entries in the list
    DeleteWDArray();

    //Enumerate the WD's from the Registry
    for ( Index = 0, Entries = 1, ByteCount = sizeof(WDNAMEW);
          (Status =
           RegWdEnumerateW( NULL,
                           &Index,
                           &Entries,
                           WdKey,
                           &ByteCount )) == ERROR_SUCCESS;
          ByteCount = sizeof(WDNAMEW) )

     {
        if ((QStatus = RegWdQueryW( NULL, WdKey, &WdConfig,
                                     sizeof(WdConfig),
                                     &ByteCount)) != ERROR_SUCCESS )
        {
            hResult = E_FAIL;
            break;

        }

        /*
         * Only place this Wd in the WdList if it's DLL is present
         * on the system.
         */
        GetSystemDirectory( WdDll, MAX_PATH );
        lstrcat( WdDll, TEXT("\\Drivers\\") );
        lstrcat( WdDll, WdConfig.Wd.WdDLL );
        lstrcat( WdDll, TEXT(".sys" ) );
        if ( lstr_access( WdDll, 0 ) != 0 )
            continue;

        /*
         * Create a new WdList object and initialize from WdConfig
         * structure, adding it to the end of the WdList.
         */
        pWd = new WD;
        if(NULL == pWd)
        {
            hResult = E_OUTOFMEMORY;
            break;
        }

        lstrcpy(pWd->wdName,WdConfig.Wd.WdName);
        lstrcpy(pWd->wdKey,WdKey);

        pWd->wd2 = WdConfig;

        // Load the extension DLL for this WD
        pWd->hExtensionDLL = ::LoadLibrary(WdConfig.Wd.CfgDLL);
        if(pWd->hExtensionDLL)
        {
//            ODS( L"Loaded extension dll\n" );
            // Get the entry points
            pWd->lpfnExtStart = (LPFNEXTSTARTPROC)::GetProcAddress(pWd->hExtensionDLL, szStart);

            pWd->lpfnExtEnd = (LPFNEXTENDPROC)::GetProcAddress(pWd->hExtensionDLL, szEnd);

            pWd->lpfnExtEncryptionLevels = (LPFNEXTENCRYPTIONLEVELSPROC)::GetProcAddress(pWd->hExtensionDLL, szEncryptionLevels);

            pWd->lpfnExtDeleteObject = (LPFNEXTDELETEOBJECTPROC)::GetProcAddress(pWd->hExtensionDLL, szDeleteObject);

            pWd->lpfnExtRegQuery = (LPFNEXTREGQUERYPROC)::GetProcAddress(pWd->hExtensionDLL, szRegQuery);

            pWd->lpfnExtRegCreate = (LPFNEXTREGCREATEPROC)::GetProcAddress(pWd->hExtensionDLL, szRegCreate);

            pWd->lpfnExtRegDelete = (LPFNEXTREGDELETEPROC)::GetProcAddress(pWd->hExtensionDLL, szRegDelete);

            pWd->lpfnExtDupObject = (LPFNEXTDUPOBJECTPROC)::GetProcAddress(pWd->hExtensionDLL, szDupObject);

            pWd->lpfnGetCaps = ( LPFNEXTGETCAPABILITIES )::GetProcAddress( pWd->hExtensionDLL , szGetCaps );

            pWd->lpfnExtGetEncryptionLevelDescr =
                ( LPFNEXTGETENCRYPTIONLEVELDESCPROC )::GetProcAddress( pWd->hExtensionDLL , szGetEncryptionLevelDescr );


            // Call the ExtStart() function in the extension DLL
            if(pWd->lpfnExtStart)(*pWd->lpfnExtStart)(&WdConfig.Wd.WdName);

        }

        m_WDArray.Add( pWd);


         //Get the names of the Transport drivers associated with this WD
        for ( Index2 = 0, Entries2 = 1, ByteCount = sizeof(PDNAMEW);
                (Status = RegPdEnumerateW(NULL,WdKey,TRUE,&Index2,&Entries2,PdKey,&ByteCount)) == ERROR_SUCCESS;
                 ByteCount = sizeof(PDNAMEW))
              {
                     PDCONFIG3W *pPdConfig = NULL;

                     if ((QStatus = RegPdQueryW(NULL,WdKey,TRUE,PdKey,&PdConfig,sizeof(PdConfig),&ByteCount)) != ERROR_SUCCESS)
                     {
                         hResult = E_FAIL;
                         break;
                     }

                    /*
                     * Create a new PdName and initialize from PdConfig
                     * structure, then add to the TdName list.
                     */

                    pPdConfig = new PDCONFIG3W;

                    if( pPdConfig == NULL )
                    {
                        hResult = E_OUTOFMEMORY;

                        break;
                    }

                    *pPdConfig = PdConfig;

                    pWd->PDConfigArray.Add( pPdConfig );

                    /*
                    pPdName = new PDNAMEW;
                    if(NULL == pPdName)
                    {
                        hResult = E_OUTOFMEMORY;
                        break;

                    }

                    lstrcpy((TCHAR *)pPdName,PdConfig.Data.PdName);

                    pWd->PDNameArray.Add(pPdName);
                    */
            }
        }

        if(FAILED(hResult))
        {
            //Error has occured, cleanup m_WDArray
            DeleteWDArray();
        }

        return hResult;

}

/***************************************************************************************************************

  Name:      Initialize

  Purpose:   Initializes the object

  Returns:   HRESULT.

  Params:

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::Initialize()
{
    HRESULT hResult = S_OK;

    #ifdef DBG

    HKEY hKey;

    LONG lStatus;

    // To control debug spewage add/remove this regkey

    lStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
        L"Software\\Microsoft\\TSCC\\Debug",
        0,
        KEY_READ,
        &hKey );

    if( lStatus == ERROR_SUCCESS )
    {
        g_fDebug = true;

        RegCloseKey( hKey );
    }

    #endif

    //If already initialized, return
    if(m_bInitialized)
        return CFGBKEND_ALREADY_INITIALIZED;

    //Is the user the admin?
    /*
    if(RegWinStationAccessCheck(NULL, KEY_ALL_ACCESS))
    {
       m_bAdmin = FALSE;
    }
    else
    {
        m_bAdmin = TRUE;
    }
    */

    m_bAdmin = TestUserForAdmin( );

    // Fill up the WdArray with information regarding the Wd's installed on this machine.
    hResult = FillWdArray();
    if(SUCCEEDED(hResult))
    {
        //Fill up the WsArray with the info about the WS's on this machine.
        hResult = FillWsArray();
    }

    if(SUCCEEDED(hResult))
        m_bInitialized = TRUE;
    else
    {
        //if Failed, Cleanup the memory used.
        DeleteWSArray();
        DeleteWDArray();
    }

    return hResult;
}

/***************************************************************************************************************

  Name:      FillWsArray

  Purpose:   Internal function to fill m_WsArray

  Returns:   HRESULT.

  Params:

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::FillWsArray()
{
    LONG Status;
    ULONG Index, ByteCount, Entries;
    WINSTATIONNAMEW WSName;
    PWS  pWsObject = NULL;
    HRESULT hResult = S_OK;
    WINSTATIONCONFIG2W* pWSConfig = NULL;
    ULONG Size = 0;

    //Ensure that the WS is empty.
    DeleteWSArray();

    Index = 0;

    Size = sizeof(WINSTATIONCONFIG2W);
    pWSConfig = (WINSTATIONCONFIG2W*)LocalAlloc(LMEM_FIXED, Size);

    if(pWSConfig == NULL)
    {
        return E_FAIL;
    }

    //Enumerate Winstations
    for ( Index = 0, Entries = 1, ByteCount = sizeof(WINSTATIONNAMEW);
          (Status =
           RegWinStationEnumerateW( NULL, &Index, &Entries,
                                   WSName, &ByteCount )) == ERROR_SUCCESS;
          ByteCount = sizeof(WINSTATIONNAMEW) )
    {


   
        ULONG Length;        
     
        Status = RegWinStationQueryW(NULL,
                                       WSName,
                                       pWSConfig,
                                       sizeof(WINSTATIONCONFIG2W), &Length);
        if(Status)
        {
            continue;
        }

        //Insert a WS object into the m_WSArray.

        hResult = InsertInWSArray(WSName, pWSConfig,&pWsObject);
        
            
    }
    
    if(pWSConfig != NULL)
    {

        LocalFree(pWSConfig);
        pWSConfig = NULL;    
    }
                

    if(FAILED(hResult))
    {
        DeleteWSArray();
    }
    return hResult;
}

/***************************************************************************************************************

  Name:      InsertInWSArray

  Purpose:   Internal function to Insert a new WS in the m_WsArray

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
                    pWSConfig - PWINSTATIONCONFIG2W structure
             out:    ppObject - Pointer to the new object


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::InsertInWSArray( PWINSTATIONNAMEW pWSName,
                            PWINSTATIONCONFIG2W pWSConfig,
                            PWS * ppObject )
{
    int Index = 0,Size = 0;
    BOOL bAdded;
    PWS pObject;
    HRESULT hResult = S_OK;

    //Create a new WS object and initialize.
    pObject = new WS;
    if ( NULL == pObject )
        return E_OUTOFMEMORY;


    lstrcpy(pObject->Name, pWSName);

    pObject->fEnableWinstation = pWSConfig->Create.fEnableWinStation ? 1 : 0;

    lstrcpy( pObject->pdName, pWSConfig->Pd[0].Create.PdName );

    pObject->PdClass = (DWORD)pWSConfig->Pd[0].Create.SdClass;

    // New addition

    if( pObject->PdClass == SdAsync )
    {
        lstrcpy( pObject->DeviceName , pWSConfig->Pd[0].Params.Async.DeviceName );
    }

    //

    lstrcpy( pObject->wdName, pWSConfig->Wd.WdName );

    lstrcpy( pObject->Comment, pWSConfig->Config.Comment );

    pObject->LanAdapter = (pObject->PdClass == SdNetwork) ? pWSConfig->Pd[0].Params.Network.LanAdapter : ( ULONG )-1;

    pObject->uMaxInstanceCount = pWSConfig->Create.MaxInstanceCount;


     //Traverse the WSArray and insert this new WS,
     //keeping the list sorted by Name.

    PWS pTempWs = NULL;
    for ( Index = 0, bAdded = FALSE,Size = m_WSArray.GetSize();
            Index < Size; Index++ )
    {


        pTempWs = (PWS)m_WSArray[Index];

        if ( lstrcmpi( pTempWs->Name,pObject->Name ) > 0)
        {
            m_WSArray.InsertAt(Index, pObject );

            bAdded = TRUE;

            break;
        }
    }


    //If we haven't yet added the WS, add it now to the tail
    if ( !bAdded )
        m_WSArray.Add(pObject);


    //Set the ppObject referenced WS pointer to the new WS
    //pointer and return the index of the new WS
    *ppObject = pObject;
    return hResult;

}  // end CCfgComp::InsertInWSArray


/***************************************************************************************************************

  Name:      GetWdObject

  Purpose:   Internal function to get a WD object from m_WdArray

  Returns:   PWD - pointer to a WD object.

  Params:
             in:    pWd - Name of the WD

 ****************************************************************************************************************/
PWD CCfgComp::GetWdObject(PWDNAMEW pWdName)
{
    PWD pObject;

    int Size  = 0,Index = 0;
    
    //Traverse the WD list
    for (Index = 0, Size = m_WDArray.GetSize(); Index < Size; Index ++)
    {
        pObject = (PWD)m_WDArray[Index];

        if ( !lstrcmpi( pObject->wdName, pWdName ) )
        {
            return(pObject);
        }
        /* when PWD includes WDCONFIG2

        if( !lstrcmpi( pObject->wd2.Wd.WdName , pWdName ) )
        {
            return pObject;
        }
        */
    }

    return(NULL);

}  // end GetWdObject

//--------------------------------------------------------------------------------------------------------------
// expected return values WDF_ICA or WDF_TSHARE
//--------------------------------------------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetWdType( PWDNAMEW pWdName , PULONG pulType )
{
    if( pWdName == NULL || pulType == NULL )
    {
        return E_INVALIDARG;
    }

    PWD pwdObject = GetWdObject( pWdName );

    if( pwdObject != NULL )
    {
        *pulType = pwdObject->wd2.Wd.WdFlag;

        return S_OK;
    }

    return E_FAIL;
}

/***************************************************************************************************************

  Name:      GetWSObject

  Purpose:   Internal function to get a WS Object from m_WsArray

  Returns:   PWS - Pointer to a WS Object.

  Params:
             in:    pWSName - Name of the Winstation.


 ****************************************************************************************************************/
PWS CCfgComp::GetWSObject(WINSTATIONNAMEW WSName)
{
    PWS pObject;

    int Size  = 0,Index = 0;

    //Refresh( );

    //Traverse the WD list
    for (Index = 0, Size = m_WSArray.GetSize(); Index < Size; Index ++)
    {

        pObject = (PWS)m_WSArray[Index];

        if ( !lstrcmpi( pObject->Name, WSName ) )
        {
            return(pObject);
        }
    }

    return(NULL);

}  // end GetWdObject



/***************************************************************************************************************

  Name:      GetWinStationSecurity

  Purpose:   Internal function used to Get Winstation Security

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
             out:   ppSecurityDescriptor - Pointer to the buffer containing the security descriptor


 ****************************************************************************************************************/
HRESULT CCfgComp::GetWinStationSecurity( BOOL bDefault, PWINSTATIONNAMEW pWSName,PSECURITY_DESCRIPTOR *ppSecurityDescriptor )
{

    DWORD SDLength = 0;

    DWORD ValueType =0;

    HKEY Handle1 = NULL;

    HKEY Handle2 = NULL;

    HRESULT hResult = S_OK;

    //BOOL bDefault = FALSE;

    WCHAR ValueName[32]; // Just some number enough to hold string "Security" and DefaultSecurity"

    if(NULL == ppSecurityDescriptor)
    {
        return E_INVALIDARG;
    }

    if( TRUE == bDefault )
    {
        if(NULL == pWSName )
        {
            //Default Security
            lstrcpy( ValueName, L"DefaultSecurity" );
        }
        else if( lstrlen(pWSName) > sizeof(ValueName) / sizeof(ValueName[0]) - 1 )
        {
            ODS( L"CFGBKEND : GetWinStationSecurity -- default security key name is too long\n" );

            return E_INVALIDARG;
        }
        else
        {
            ZeroMemory( ValueName, sizeof(ValueName) );
            lstrcpy( ValueName, pWSName );
        }
    }
    else
    {
        lstrcpy( ValueName, L"Security" );
    }

    *ppSecurityDescriptor = NULL;

    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,KEY_READ, &Handle1 ) != ERROR_SUCCESS)
    {
        ODS( L"CFGBKEND : GetWinStationSecurity -- RegOpenKey failed\n" );

        return E_FAIL;
    }

    if(!bDefault)
    {
        if( RegOpenKeyEx( Handle1, pWSName , 0 , KEY_READ/*KEY_ALL_ACCESS*/, &Handle2 )!= ERROR_SUCCESS)
        {
            ODS( L"CFGBKEND : GetWinStationSecurity -- RegOpenKey( 2 ) failed\n" );

            RegCloseKey(Handle1);

            return E_FAIL;

        }

        RegCloseKey(Handle1);

        Handle1 = Handle2;

        Handle2 = NULL;
    }

    if( RegQueryValueEx( Handle1, ValueName, NULL, &ValueType,NULL, &SDLength ) != ERROR_SUCCESS )
    {

        ODS( L"CFGBKEND : GetWinStationSecurity -- RegQueryValueEx failed for -- " );
        ODS( ValueName );
        ODS( L"\n" );

        RegCloseKey(Handle1);

        return E_FAIL;
    }

    //Return error if not correct data type
    if (ValueType != REG_BINARY)
    {
        ODS( L"CFGBKEND : GetWinStationSecurity -- ValueType != REG_BINARY\n" );

        RegCloseKey(Handle1);

        return ERROR_FILE_NOT_FOUND;
    }


    //Allocate a buffer to read the Security info and read it
    // ACLUI uses LocalFree
    // *ppSecurityDescriptor = CoTaskMemAlloc(SDLength);

    *ppSecurityDescriptor = ( PSECURITY_DESCRIPTOR )LocalAlloc( LMEM_FIXED , SDLength );

    if ( *ppSecurityDescriptor == NULL )
    {
        RegCloseKey(Handle1);

        return E_OUTOFMEMORY;
    }

    if( RegQueryValueEx( Handle1,ValueName, NULL, &ValueType,(BYTE *) *ppSecurityDescriptor, &SDLength ) == ERROR_SUCCESS )
    {
        //Check for a valid SD before returning.
        if( ERROR_SUCCESS != ValidateSecurityDescriptor( *ppSecurityDescriptor ) )
        {
            hResult = E_FAIL;
        }
    }
    else
    {
        hResult = E_FAIL;
    }

    if(Handle1)
    {
        RegCloseKey(Handle1);
        Handle1 = NULL;
    }
    if(Handle2)
    {
        RegCloseKey(Handle2);
        Handle2 = NULL;
    }
    if(FAILED(hResult))
    {
        if( *ppSecurityDescriptor != NULL )
        {
            // CoTaskMemFree(*ppSecurityDescriptor);
            LocalFree( *ppSecurityDescriptor );
            *ppSecurityDescriptor = NULL;
        }

    }
    return hResult;

}  // GetWinStationSecurity

//This function is borrowed from security.c in the tscfg project

/***************************************************************************************************************

  Name:      ValidateSecurityDescriptor

  Purpose:   Internal function to Validate a Security Descriptor

  Returns:   DWORD - Error Status.

  Params:
             in:    pSecurityDescriptor - pointer to a security Descriptor.

 ****************************************************************************************************************/
DWORD CCfgComp::ValidateSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    // DWORD Error = ERROR_SUCCESS;

    if( IsValidSecurityDescriptor( pSecurityDescriptor ) )
    {
        return ERROR_SUCCESS;
    }
    else
    {
        return GetLastError( );
    }
    

}  // end ValidateSecurityDescriptor

/***************************************************************************************************************

  Name:      GetWinstationList

  Purpose:   Gets the List of Winstations installed on a Machine

  Returns:   HRESULT.

  Params:
             out:   NumWinstations - pointer to the Number of Winstations returned.
                    Size - pointer to the size of allocated buffer.
                    ppWS - Pointer to the allocated buffer containing the WS Structures


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetWinstationList(ULONG * NumWinstations, ULONG * Size, PWS * ppWS)
{
    HRESULT hResult = S_OK;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    WS * pWSTemp = NULL;
    if(NULL == NumWinstations || NULL == Size || NULL == ppWS)
        return E_INVALIDARG;


    *NumWinstations = 0;
    *Size = 0;
    *ppWS = NULL;

    ULONG Num = m_WSArray.GetSize();

    *ppWS = (PWS)CoTaskMemAlloc(Num * sizeof(WS));
    if(NULL == *ppWS)
        return E_OUTOFMEMORY;

    pWSTemp = (WS *)(*ppWS);
    for(ULONG i = 0; i < Num ; i++)
    {
        lstrcpy(pWSTemp[i].Name,((WS *)m_WSArray[i])->Name);
        lstrcpy(pWSTemp[i].pdName,((WS *)m_WSArray[i])->pdName);
        lstrcpy(pWSTemp[i].wdName,((WS *)m_WSArray[i])->wdName);
        lstrcpy(pWSTemp[i].Comment,((WS *)m_WSArray[i])->Comment);
        pWSTemp[i].uMaxInstanceCount =((WS *)m_WSArray[i])->uMaxInstanceCount;
        pWSTemp[i].fEnableWinstation =((WS *)m_WSArray[i])->fEnableWinstation;
        pWSTemp[i].LanAdapter = ((WS *)m_WSArray[i])->LanAdapter;
        pWSTemp[i].PdClass = ((WS *)m_WSArray[i])->PdClass;
    }
    *NumWinstations = Num;
    *Size = Num * sizeof(WS);

    return hResult;
}

/***************************************************************************************************************

  Name:      GetWdTypeList

  Purpose:   Gets the List of Winstation Drivers

  Returns:   HRESULT.

  Params:
             out:   pNumWd - pointer to the number of entries returned.
                    pSize - pointer to the size of the allocated buffer
                    ppData - Pointer to an array of WDNAMEW


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetWdTypeList(ULONG * pNumWd, ULONG * pSize, WCHAR ** ppData)
{
    HRESULT hResult = S_OK;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;


    if(NULL == pNumWd || NULL == pSize || NULL == ppData)
        return E_INVALIDARG;
    WDNAMEW * pWdTemp = NULL;

    *pNumWd = 0;
    *pSize = 0;
    *ppData = NULL;

    ULONG Num = m_WDArray.GetSize();

    *ppData = (WCHAR *)CoTaskMemAlloc(Num * sizeof(WDNAMEW));
    if(NULL == *ppData)
        return E_OUTOFMEMORY;

    pWdTemp = (WDNAMEW *)(*ppData);
    for(ULONG i = 0; i < Num ; i++)
    {
        lstrcpy(pWdTemp[i],((WD *)m_WDArray[i])->wdName);
    }
    *pNumWd = Num;
    *pSize = Num * sizeof(WS);

    return hResult;

}

/***************************************************************************************************************

  Name:      IsWSNameUnique

  Purpose:   Checks if the Name is already not an existing winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
             out:   pUnique - pointer to whether the winstation name is unique

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::IsWSNameUnique(PWINSTATIONNAMEW pWSName,BOOL * pUnique)
{
    if(NULL == pWSName || NULL == pUnique)
        return E_INVALIDARG;

    *pUnique = FALSE;

    if((NULL == GetWSObject(pWSName)) && (lstrcmpi(pWSName,m_szConsole)))
        *pUnique = TRUE;

    return S_OK;
}

/***************************************************************************************************************

  Name:      GetTransportTypes

  Purpose:   Gets the Security Descriptor for a Winstation

  Returns:   HRESULT.

  Params:
             in:    Name - Name of the Winstation or WD depending on the value of Type.
                    Type - Specifies whether the Name is a Winstation name or WD Name (WsName, WdName)
             out:   pNumPd - pointer to the number of Transport types returned
                    pSize - Size of the allocated buffer
                    ppSecurityDescriptor - Pointer to the buffer containing the Transport types supported


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetTransportTypes(WCHAR * Name, NameType Type,ULONG * pNumPd, ULONG * pSize, WCHAR * * ppData)
{
    HRESULT hResult = S_OK;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    if(NULL == pNumPd || NULL == pSize || NULL == ppData || NULL == Name)
        return E_INVALIDARG;

    WD * pWD = NULL;
    WS * pWS = NULL;

    *pNumPd = 0;
    *pSize = 0;
    *ppData = NULL;

    PDNAMEW * pPdTemp = NULL;

    if(Type == WsName)
    {
        pWS = GetWSObject(Name);
        if(NULL == pWS)
            return E_INVALIDARG;
        pWD = GetWdObject(pWS->wdName);
        if(NULL == pWD)
            return E_FAIL;
    }
    else if(Type == WdName)
    {
        pWD = GetWdObject(Name);
        if(NULL == pWD)
            return E_INVALIDARG;
    }
    else
        return E_INVALIDARG;


    // ULONG Num = (pWD->PDNameArray).GetSize();

    ULONG Num = ( pWD->PDConfigArray ).GetSize( );

    *ppData = (WCHAR *)CoTaskMemAlloc(Num * sizeof(PDNAMEW));
    if(NULL == *ppData)
        return E_OUTOFMEMORY;

    pPdTemp = (PDNAMEW *)(*ppData);
    for(ULONG i = 0; i < Num ; i++)
    {
        // PDNAMEW * pPdName = (PDNAMEW *)pWD->PDNameArray[i];
        PDNAMEW * pPdName = &( ( PDCONFIG3W * )pWD->PDConfigArray[i] )->Data.PdName;

        lstrcpy(pPdTemp[i], *pPdName);
    }
    *pNumPd = Num;
    *pSize = Num * sizeof(PDNAMEW);

    return hResult;
}

/***************************************************************************************************************

  Name:      GetLanAdapterList

  Purpose:   Gets the List of Lan Adapters associated with a given protocol

  Returns:   HRESULT.

  Params:
             in:    pdName - Name of the protocol.
             out:   pNumAdapters:pointer to the number of Lan adapters returned
                    pSize - Size of the allocated buffer
                    ppSecurityDescriptor - Pointer to An Array of DEVICENAME's


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetLanAdapterList(WCHAR * pdName, ULONG * pNumAdapters, ULONG * pSize, WCHAR ** ppData)
{
    HRESULT hResult = S_OK, hr = S_OK;

    //If not initialized return error
    if(!m_bInitialized)
    {
        ODS( L"CCfgComp::GetLanAdapterList returned CFGBKEND_E_NOT_INITIALIZED\n" );

        return CFGBKEND_E_NOT_INITIALIZED;
    }

    if(NULL == pdName || NULL == ppData || NULL == pNumAdapters || NULL == pSize)
    {
        ODS( L"CCfgComp::GetLanAdapterList returned INVALIDARG \n" );

        return E_INVALIDARG;
    }

    *pNumAdapters = 0;
    *pSize = 0;
    *ppData = NULL;

    int NumAdapters = 0;
    TCHAR * pszDevice = NULL;
    int length = 0;
    DEVICENAMEW * pTempPointer = NULL;

    CPtrArray DeviceArray;

     //Interface pointer declarations

    TCHAR szProtocol[256];
    INetCfg * pnetCfg = NULL;
    INetCfgClass * pNetCfgClass = NULL;
    INetCfgClass * pNetCfgClassAdapter = NULL;
    INetCfgComponent * pNetCfgComponent = NULL;
    INetCfgComponent * pNetCfgComponentprot = NULL;
    IEnumNetCfgComponent * pEnumComponent = NULL;
    INetCfgComponentBindings * pBinding = NULL;
    LPWSTR pDisplayName = NULL;
    DWORD dwCharacteristics;
    ULONG count = 0;


    if( 0 == lstrcmpi( pdName , L"tcp" ) )
    {
        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_TCPIP);
    }
    else if( 0 == lstrcmpi( pdName , L"netbios" ) )
    {
        lstrcpy(szProtocol,NETCFG_SERVICE_CID_MS_NETBIOS);
    }
    else if( 0 == lstrcmpi( pdName, L"ipx" ) )
    {
        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWIPX);
    }
    else if( 0 == lstrcmpi( pdName , L"spx" ) )
    {
        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWSPX);
    }
    else
    {
        return E_INVALIDARG;
    }
    /*
    * Assumption: No NetBios Lana MAPPING
    */
    //The First entry will be "All Lan Adapters"

    pszDevice = new TCHAR[DEVICENAME_LENGTH];

    if(NULL == pszDevice)
    {
        return E_OUTOFMEMORY;
    }

    length = LoadString(g_hInstance,IDS_ALL_LAN_ADAPTERS, pszDevice, DEVICENAME_LENGTH );

    NumAdapters++;

    DeviceArray.Add(pszDevice);


    do
    {
        ODS( L"CFGBKEND : CoCreateInstance\n" );

        hResult = CoCreateInstance(CLSID_CNetCfg,NULL,CLSCTX_SERVER,IID_INetCfg,(LPVOID *)&pnetCfg);

        if( FAILED( hResult ) )
        {
            ODS( L"CFGBKEND : CoCreateInstance(CLSID_CNetCfg) failed\n" );

            break;
        }

        if( pnetCfg != NULL )
        {
            ODS( L"pnetCfg->Initialize\n" );

            // shaun cox changed the netcfgx.idl file
            // alhen

            hResult = pnetCfg->Initialize( NULL );

            if( FAILED( hResult ) || pnetCfg == NULL )
            {
                ODS( L"CFGBKEND : netCfg::Init failed\n" );

                break;
            }

            if( lstrcmpi( szProtocol , NETCFG_SERVICE_CID_MS_NETBIOS ) == 0 )
            {

                ODS( L"pnetCfg->QueryNetCfgClass for GUID_DEVCLASS_NETSERVICE\n" );

                hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETSERVICE ,IID_INetCfgClass,(void **)&pNetCfgClass);

                if( FAILED( hResult ) || pNetCfgClass == NULL)
                {
                    ODS( L"CFGBKEND : pnetCfg->QueryNetCfgClass failed\n" );

                    break;
                }
            }
            else
            {
                ODS( L"pnetCfg->QueryNetCfgClass for GUID_DEVCLASS_NETTRANS\n" );

                hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETTRANS ,IID_INetCfgClass,(void **)&pNetCfgClass);

                if( FAILED( hResult ) || pNetCfgClass == NULL)
                {
                    ODS( L"CFGBKEND : pnetCfg->QueryNetCfgClass failed\n" );

                    break;
                }
            }


            ODS( L"pnetCfg->QueryNetCfgClass\n" );

            hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NET ,IID_INetCfgClass,(void **)&pNetCfgClassAdapter);

            if( FAILED( hResult ) || pNetCfgClassAdapter == NULL )
            {
                ODS( L"CFGBKEND : pnetCfg->QueryNetCfgClass failed\n" );

                break;
            }

            ODS( L"pNetCfgClass->FindComponent\n");

            hResult = pNetCfgClass->FindComponent(szProtocol,&pNetCfgComponentprot);

            if( FAILED( hResult ) || pNetCfgComponentprot == NULL)
            {
                ODS( L"CFGBKEND : pnetCfg->FindComponent\n" );

                break;
            }

            ODS( L"pNetCfgComponentprot->QueryInterface\n" );

            hResult = pNetCfgComponentprot->QueryInterface(IID_INetCfgComponentBindings,(void **)&pBinding);

            if( FAILED( hResult ) || pBinding == NULL )
            {
                ODS( L"CFGBKEND : pNetCfgComponentprot->QueryInterface(IID_INetCfgComponentBindings ) failed \n " );
                break;
            }

            ODS( L"pNetCfgClassAdapter->EnumComponents\n" );

            hResult = pNetCfgClassAdapter->EnumComponents(&pEnumComponent);

            RELEASEPTR(pNetCfgClassAdapter);

            if( FAILED( hResult ) || pEnumComponent == NULL )
            {
                ODS( L"CFGBKEND : pNetCfgClassAdapter->EnumComponents failed \n" );
                break;
            }

            // hResult = S_OK;

            while(TRUE)
            {
                ODS( L"pEnumComponent->Next(1,&pNetCfgComponent,&count) \n" );

                hr = pEnumComponent->Next(1,&pNetCfgComponent,&count);

                if(count == 0 || NULL == pNetCfgComponent)
                {
                    break;
                }

                ODS( L"pNetCfgComponent->GetCharacteristics(&dwCharacteristics) \n" );

                hr = pNetCfgComponent->GetCharacteristics(&dwCharacteristics);

                if( FAILED( hr ) )
                {
                    RELEASEPTR(pNetCfgComponent);

                    ODS( L"CFGBKEND : pNetCfgComponent->GetCharacteristics failed\n" );

                    continue;
                }

                if(dwCharacteristics & NCF_PHYSICAL)
                {
                    ODS( L"pBinding->IsBoundTo(pNetCfgComponent)\n" );

                    if(S_OK == pBinding->IsBoundTo(pNetCfgComponent))
                    {
                        ODS( L"pNetCfgComponent->GetDisplayName(&pDisplayName)\n" );

                        hResult = pNetCfgComponent->GetDisplayName(&pDisplayName);

                        if( FAILED( hResult ) )
                        {
                            ODS( L"CFGBKEND : pNetCfgComponent->GetDisplayName failed\n");
                            continue;
                        }

                        // this is not a leak Device array copies the ptr
                        // and we release towards the end

                        pszDevice = new TCHAR[DEVICENAME_LENGTH];

                        if(NULL == pszDevice)
                        {
                            hResult = E_OUTOFMEMORY;
                            break;
                        }

                        lstrcpy(pszDevice,pDisplayName);

                        DBGMSG( L"CFGBKEND: Adapter name %ws\n" , pszDevice );

                        DeviceArray.Add(pszDevice);

                        NumAdapters++;

                        CoTaskMemFree(pDisplayName);
                    }
                }
            }

            RELEASEPTR(pNetCfgComponent);
        }

    }while( 0 );


    ODS( L"RELEASEPTR(pBinding)\n" );

    RELEASEPTR(pBinding);

    ODS( L"RELEASEPTR(pEnumComponent)\n" );

    RELEASEPTR(pEnumComponent);

    ODS( L"RELEASEPTR(pNetCfgComponentprot)\n" );

    RELEASEPTR(pNetCfgComponentprot);

    ODS( L"RELEASEPTR(pNetCfgComponent)\n" );

    RELEASEPTR(pNetCfgComponent);

    ODS( L"RELEASEPTR(pNetCfgClass)\n" );

    RELEASEPTR(pNetCfgClass);

    if( pnetCfg != NULL )
    {
        pnetCfg->Uninitialize();
    }

    ODS( L"RELEASEPTR(pnetCfg)\n" );

    RELEASEPTR(pnetCfg);

    if( SUCCEEDED( hResult ) )
    {
        //Allocate Memory using CoTaskMemAlloc and copy data

        *ppData = (WCHAR *)CoTaskMemAlloc(NumAdapters * sizeof(TCHAR) * DEVICENAME_LENGTH);

        if(*ppData == NULL)
        {
            hResult = E_OUTOFMEMORY;
        }
        else
        {
            pTempPointer = (DEVICENAMEW *)(*ppData);

            for(int i=0; i<NumAdapters; i++)
            {
                lstrcpy(pTempPointer[i],(TCHAR *)DeviceArray[i]);
            }
        }

    }

    for(int i=0;i < DeviceArray.GetSize();i++)
    {
        ODS( L"Deleteing DeviceArray\n" );

        // I told u so.

        delete [] DeviceArray[i];
    }

    *pNumAdapters = NumAdapters;

    return hResult;
}

/***************************************************************************************************************

  Name:      GetLanAdapterList2

  Purpose:   Gets the List of Lan Adapters associated with a given protocol
             Determine if lan ids are valid

  Returns:   HRESULT.

  Params:
             in:    pdName - Name of the protocol.
             out:   pNumAdapters: pointer to the number of Lan adapters returned
                    ppGuidtbl:

  GUIDTBL

  -----------------------------
  DispName    display name [ 128 ]
  guidNIC     32 byte buffer
  dwLana       value is set if regkey entry exist otherwise it will be created in the order obtained
  dwStatus    Any errors reported on a particular guid entry
  -----------------------------


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetLanAdapterList2(WCHAR * pdName, ULONG * pNumAdapters , PGUIDTBL *ppGuidtbl )
{
    HRESULT hResult = S_OK;

    int nMaxLanAdapters = 4;

    //If not initialized return error
    if(!m_bInitialized)
    {
        ODS( L"CCfgComp::GetLanAdapterList2 returned CFGBKEND_E_NOT_INITIALIZED\n" );

        return CFGBKEND_E_NOT_INITIALIZED;
    }

    if(NULL == pdName || NULL == pNumAdapters )
    {
        ODS( L"CCfgComp::GetLanAdapterList2 returned INVALIDARG \n" );

        return E_INVALIDARG;
    }

    *pNumAdapters = 0;

    int NumAdapters = 0;

    //

    *ppGuidtbl = ( PGUIDTBL )CoTaskMemAlloc( sizeof( GUIDTBL ) * nMaxLanAdapters );

    if( *ppGuidtbl == NULL )
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory( *ppGuidtbl , sizeof( GUIDTBL ) * nMaxLanAdapters );

     //Interface pointer declarations

    TCHAR szProtocol[256];

    INetCfg * pnetCfg = NULL;

    INetCfgClass * pNetCfgClass = NULL;

    INetCfgClass * pNetCfgClassAdapter = NULL;

    INetCfgComponent * pNetCfgComponent = NULL;

    INetCfgComponent * pNetCfgComponentprot = NULL;

    IEnumNetCfgComponent * pEnumComponent = NULL;

    INetCfgComponentBindings * pBinding = NULL;

    LPWSTR pDisplayName = NULL;

    DWORD dwCharacteristics;

    ULONG count = 0;


    if( 0 == lstrcmpi( pdName , L"tcp" ) )
    {
        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_TCPIP);
    }
    else if( 0 == lstrcmpi( pdName , L"netbios" ) )
    {
        lstrcpy(szProtocol,NETCFG_SERVICE_CID_MS_NETBIOS);
    }
    else if( 0 == lstrcmpi( pdName, L"ipx" ) )
    {
        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWIPX);
    }
    else if( 0 == lstrcmpi( pdName , L"spx" ) )
    {
        //lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWSPX);
        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWIPX);
    }
    else
    {
        return E_INVALIDARG;
    }
    /*
    * Assumption: No NetBios Lana MAPPING
    */
    //The First entry will be "All Lan Adapters"

    if( lstrcmpi( pdName , L"netbios" ) != 0 )
    {
        LoadString( g_hInstance , IDS_ALL_LAN_ADAPTERS , (*ppGuidtbl )[0].DispName , DEVICENAME_LENGTH );

        NumAdapters++;
    }



    do
    {
        ODS( L"CFGBKEND:GetLanAdapterList2 CoCreateInstance\n" );

        hResult = CoCreateInstance(CLSID_CNetCfg,NULL,CLSCTX_SERVER,IID_INetCfg,(LPVOID *)&pnetCfg);

        if( FAILED( hResult ) )
        {
            ODS( L"CFGBKEND:GetLanAdapterList2 CoCreateInstance(CLSID_CNetCfg) failed\n" );

            break;
        }

        if( pnetCfg != NULL )
        {
            ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->Initialize\n" );

            // shaun cox changed the netcfgx.idl file
            // alhen

            hResult = pnetCfg->Initialize( NULL );

            if( FAILED( hResult ) )
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 netCfg::Init failed\n" );

                break;
            }

            if( lstrcmpi( szProtocol , NETCFG_SERVICE_CID_MS_NETBIOS ) == 0 )
            {

                ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->QueryNetCfgClass for GUID_DEVCLASS_NETSERVICE\n" );

                hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETSERVICE ,IID_INetCfgClass,(void **)&pNetCfgClass);

                if( FAILED( hResult ) || pNetCfgClass == NULL)
                {
                    ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->QueryNetCfgClass failed\n" );

                    break;
                }
            }
            else
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->QueryNetCfgClass for GUID_DEVCLASS_NETTRANS\n" );

                hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETTRANS ,IID_INetCfgClass,(void **)&pNetCfgClass);

                if( FAILED( hResult ) || pNetCfgClass == NULL)
                {
                    ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->QueryNetCfgClass failed\n" );

                    break;
                }
            }


            ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->QueryNetCfgClass\n" );

            hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NET ,IID_INetCfgClass,(void **)&pNetCfgClassAdapter);

            if( FAILED( hResult ) || pNetCfgClassAdapter == NULL )
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->QueryNetCfgClass failed\n" );

                break;
            }

            ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgClass->FindComponent\n");

            hResult = pNetCfgClass->FindComponent(szProtocol,&pNetCfgComponentprot);

            if( FAILED( hResult ) || pNetCfgComponentprot == NULL)
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->FindComponent\n" );

                break;
            }

            ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponentprot->QueryInterface\n" );

            hResult = pNetCfgComponentprot->QueryInterface(IID_INetCfgComponentBindings,(void **)&pBinding);

            if( FAILED( hResult ) || pBinding == NULL )
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponentprot->QueryInterface(IID_INetCfgComponentBindings ) failed \n " );
                break;
            }

            ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgClassAdapter->EnumComponents\n" );

            hResult = pNetCfgClassAdapter->EnumComponents(&pEnumComponent);

            RELEASEPTR(pNetCfgClassAdapter);

            if( FAILED( hResult ) || pEnumComponent == NULL )
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgClassAdapter->EnumComponents failed \n" );
                break;
            }

            // hResult = S_OK;

            while(TRUE)
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 pEnumComponent->Next(1,&pNetCfgComponent,&count) \n" );

                hResult = pEnumComponent->Next(1,&pNetCfgComponent,&count);

                if(count == 0 || NULL == pNetCfgComponent)
                {
                    break;
                }

                ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetCharacteristics(&dwCharacteristics) \n" );

                hResult = pNetCfgComponent->GetCharacteristics(&dwCharacteristics);

                if( FAILED( hResult ) )
                {
                    RELEASEPTR(pNetCfgComponent);

                    ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetCharacteristics failed\n" );

                    continue;
                }

                DBGMSG( L"dwCharacteritics are 0x%x\n", dwCharacteristics );

                if((dwCharacteristics & NCF_PHYSICAL) ||
					((dwCharacteristics & NCF_VIRTUAL) && !(dwCharacteristics & NCF_HIDDEN)))
                {
                    ODS( L"CFGBKEND:GetLanAdapterList2 pBinding->IsBoundTo(pNetCfgComponent)\n" );

                    if(S_OK == pBinding->IsBoundTo(pNetCfgComponent))
                    {
                        if( NumAdapters >= nMaxLanAdapters )
                        {
                            // add four more adapters
                            nMaxLanAdapters += 4;

                            *ppGuidtbl = ( PGUIDTBL )CoTaskMemRealloc( *ppGuidtbl , sizeof( GUIDTBL ) * nMaxLanAdapters );

                            if( *ppGuidtbl == NULL )
                            {
                                return E_OUTOFMEMORY;
                            }
                        }

                        ULONG ulDeviceStatus = 0;

                        hResult = pNetCfgComponent->GetDeviceStatus( &ulDeviceStatus );

                        if( FAILED( hResult ) )
                        {
                            DBGMSG( L"CFGBKEND:GetLanAdapterList2 GetDevice failed with 0x%x\n" , hResult );

                            continue;
                        }

                        DBGMSG( L"GetDevice status returned 0x%x\n" , ulDeviceStatus );

                        if( ulDeviceStatus == CM_PROB_DEVICE_NOT_THERE )
                        {
                            ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetDeviceStatus PNP device not there\n");
                            continue;
                        }

                        ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetDisplayName\n" );
                                                    
                        hResult = pNetCfgComponent->GetDisplayName(&pDisplayName);

                        if( FAILED( hResult ) )
                        {
                            ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetDisplayName failed\n");
                            continue;
                        }

                        ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetInstanceGuid\n" );

                        hResult = pNetCfgComponent->GetInstanceGuid( & ( ( *ppGuidtbl )[ NumAdapters ].guidNIC ) );

                        if( FAILED( hResult ) )
                        {
                            ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetInstanceGuid failed\n");

                            continue;
                        }

                        lstrcpy( ( *ppGuidtbl )[ NumAdapters ].DispName , pDisplayName );

                        // the lana value will be adjusted if guid entry exist

                        // ( *ppGuidtbl )[ NumAdapters ].dwLana = ( DWORD )NumAdapters;

                        NumAdapters++;

                        CoTaskMemFree(pDisplayName);
                    }
                }
            }

            RELEASEPTR(pNetCfgComponent);
        }

    }while( 0 );


    ODS( L"RELEASEPTR(pBinding)\n" );

    RELEASEPTR(pBinding);

    ODS( L"RELEASEPTR(pEnumComponent)\n" );

    RELEASEPTR(pEnumComponent);

    ODS( L"RELEASEPTR(pNetCfgComponentprot)\n" );

    RELEASEPTR(pNetCfgComponentprot);

    ODS( L"RELEASEPTR(pNetCfgComponent)\n" );

    RELEASEPTR(pNetCfgComponent);

    ODS( L"RELEASEPTR(pNetCfgClass)\n" );

    RELEASEPTR(pNetCfgClass);

    if( pnetCfg != NULL )
    {
        pnetCfg->Uninitialize();
    }

    ODS( L"RELEASEPTR(pnetCfg)\n" );

    RELEASEPTR(pnetCfg);

    if( SUCCEEDED( hResult ) )
    {
        //
        // Verify the existence of the guidtable and its entries
        // also re-assign lana ids.
        //

        VerifyGuidsExistence( ppGuidtbl , ( int )NumAdapters , pdName );

    }


    *pNumAdapters = NumAdapters;

    return hResult;
}

/***************************************************************************************************************

  Name:      VerifyGuidsExistence

  Purpose:   Determines the existence of the guid entries and reassigns lana ids

  Note:      ppGuidtbl passed in is valid

  Returns:   void

  Params:    [in] GUIDTBL **
             [in] number of guid entries

***************************************************************************************************************/
void CCfgComp::VerifyGuidsExistence( PGUIDTBL *ppGuidtbl , int cItems , WCHAR *pdName )
{
    HKEY hKey;

    DWORD dwStatus;

    TCHAR tchRootKey[ MAX_PATH ];

    TCHAR tchGuid[ 40 ];

    ODS( L"CFGBKEND:VerifyGuidsExistence\n" );

    int nStart = 1;

    if( lstrcmpi( pdName , L"netbios" ) == 0 )
    {
        nStart = 0;
    }

    for( int idx = nStart ; idx < cItems ; ++idx )
    {
        lstrcpy( tchRootKey , REG_GUID_TABLE );

        StringFromGUID2( ( *ppGuidtbl )[ idx ].guidNIC , tchGuid , ARRAYSIZE( tchGuid ) );

        lstrcat( tchRootKey , tchGuid );

        dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE , tchRootKey , 0 , KEY_READ , &hKey );

        ( *ppGuidtbl )[ idx ].dwStatus = dwStatus;

        if( dwStatus == ERROR_SUCCESS )
        {
            DWORD dwSize = sizeof( DWORD );

            RegQueryValueEx( hKey , LANA_ID , NULL , NULL , ( LPBYTE ) &( ( *ppGuidtbl )[ idx ].dwLana ) , &dwSize );

            DBGMSG( L"CFGBKEND: VerifyGuidsExistence LanaId retrieved = %d\n" , ( *ppGuidtbl )[ idx ].dwLana );
        }
        else
        {
            ODS( L"CFGBKEND: VerifyGuidsExistence NIC must be new\n" );

            ( *ppGuidtbl )[ idx ].dwLana = 0 ;
        }


        RegCloseKey( hKey );
    }

    return;
}

/***************************************************************************************************************

  Name:      BuildGuidTable

  Purpose:   Given valid table entries reconstruct table

  Note:      ppGuidtbl passed in is valid and 1 base

  Returns:   HRESULT

  Params:    [in] GUIDTBL **
             [in] number of guid entries

***************************************************************************************************************/
HRESULT CCfgComp::BuildGuidTable( PGUIDTBL *ppGuidtbl , int cItems , WCHAR *pdName )
{
    HKEY hKey;

    HKEY hSubKey;

    DWORD dwStatus;

    DWORD dwDisp;

    DWORD dwSize = sizeof( DWORD );

    TCHAR tchRootKey[ MAX_PATH ];

    TCHAR tchGuid[ 40 ];

    DWORD rgdwOldLanaIds[ 256 ] = { 0 }; // man what machine will hold 256 nics?

    // get last lanaIndex

    dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE , REG_GUID_TABLE , 0 , KEY_READ , &hKey );

    DWORD dwMaxIdVal = 0;

    DWORD dwVal = 0;

    int nOldAdapters = 0;

    if( dwStatus == ERROR_SUCCESS )
    {
        do
        {
            dwStatus = RegEnumKey( hKey , nOldAdapters , tchGuid , sizeof( tchGuid ) / sizeof( TCHAR ) );

            if( dwStatus != ERROR_SUCCESS )
            {
                break;
            }

            if( RegOpenKeyEx( hKey , tchGuid , 0 , KEY_READ , &hSubKey ) == ERROR_SUCCESS )
            {
                RegQueryValueEx( hSubKey , LANA_ID , NULL , NULL , ( LPBYTE ) &dwVal , &dwSize );

                rgdwOldLanaIds[ nOldAdapters ] = dwVal;

                // calculate max value

                if( dwMaxIdVal < dwVal )
                {
                    dwMaxIdVal = dwVal;
                }

                RegCloseKey( hSubKey );
            }

            nOldAdapters++;

            _ASSERTE( nOldAdapters < 256 );

        } while( 1 );

        RegCloseKey( hKey );
    }

    // remove old table

    RecursiveDeleteKey( HKEY_LOCAL_MACHINE , REG_GUID_TABLE_T );

    // create new table

    int nStart = 1;

    if( lstrcmpi( pdName , L"netbios" ) == 0 )
    {
        nStart = 0;
    }

    for( int idx = nStart ; idx < cItems ; ++idx )
    {
        lstrcpy( tchRootKey , REG_GUID_TABLE );

        StringFromGUID2( ( *ppGuidtbl )[ idx ].guidNIC , tchGuid , ARRAYSIZE( tchGuid ) );

        lstrcat( tchRootKey , tchGuid );

        // modify lana id

        if( ( *ppGuidtbl )[ idx ].dwStatus != ERROR_SUCCESS )
        {
            ( *ppGuidtbl )[ idx ].dwLana = 0;

            AdjustLanaId( ppGuidtbl , cItems , idx , &dwMaxIdVal , rgdwOldLanaIds , &nOldAdapters , nStart );
        }

        dwStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE , tchRootKey , 0 ,  NULL , REG_OPTION_NON_VOLATILE , KEY_READ|KEY_WRITE , NULL , &hKey , &dwDisp );

        ( *ppGuidtbl )[ idx ].dwStatus = dwStatus;


        if( dwStatus == ERROR_SUCCESS )
        {
            RegSetValueEx( hKey , LANA_ID , 0 , REG_DWORD , ( LPBYTE )& ( ( *ppGuidtbl )[ idx ].dwLana ) , sizeof( DWORD ) );

            RegCloseKey( hKey );
        }
    }

    return S_OK;
}

/*-----------------------------------------------------------------------------------------------
     AdjustLanaId

    PARAMETERS: pGuidtbl : Table of queried entries
                cItems   : Number of items in list
                idx      : Entry to modify lana
                pdwMaxIndex : New max value of lana index

    NOTES:      Since Lana is a dword; after 2^32-1 iterations lana ids will recycle to
                the first available entry
-----------------------------------------------------------------------------------------------*/
HRESULT CCfgComp::AdjustLanaId( PGUIDTBL *ppGuidtbl , int cItems , int idx , PDWORD pdwMaxId , PDWORD pdwOldLanaIds , int* pnOldItems , int nStart )
{
    // find the maxium value for the lana_id


    for( int i = nStart ; i < cItems ; ++i )
    {
        if( *pdwMaxId < ( *ppGuidtbl )[ i ].dwLana )
        {
            *pdwMaxId = ( *ppGuidtbl )[ i ].dwLana ;
        }
    }

    *pdwMaxId = *pdwMaxId + 1;

    // check for overflow max id will be 0xfffffffe

    if( *pdwMaxId == ( DWORD )-1 )
    {
        *pdwMaxId = 1;

        do
        {
            for( i = 0 ; i < *pnOldItems; ++i )
            {
                if( *pdwMaxId == pdwOldLanaIds[ i ] )
                {
                    *pdwMaxId = *pdwMaxId + 1;

                    break;
                }
            }

            if( i >= *pnOldItems )
            {
                // no duplicate found use the current maxid

                break;
            }

        } while( 1 );


    }

    ( *ppGuidtbl )[ idx ].dwLana = *pdwMaxId;

    // add new entry to the old table

    if( *pnOldItems < 256 )
    {
        pdwOldLanaIds[ *pnOldItems ] = *pdwMaxId;

        *pnOldItems = *pnOldItems + 1;
    }

    return S_OK;
}



//----------------------------------------------------------------------------------------------
// Delete a key and all of its descendents.
//----------------------------------------------------------------------------------------------
DWORD RecursiveDeleteKey( HKEY hKeyParent , LPTSTR lpszKeyChild )
{
        // Open the child.
        HKEY hKeyChild;

        DWORD dwRes = RegOpenKeyEx(hKeyParent, lpszKeyChild , 0 , KEY_WRITE | KEY_READ, &hKeyChild);

        if (dwRes != ERROR_SUCCESS)
        {
                return dwRes;
        }

        // Enumerate all of the decendents of this child.

        FILETIME time;

        TCHAR szBuffer[256];

        DWORD dwSize = sizeof( szBuffer ) / sizeof( TCHAR );

        while( RegEnumKeyEx( hKeyChild , 0 , szBuffer , &dwSize , NULL , NULL , NULL , &time ) == S_OK )
        {
        // Delete the decendents of this child.

                dwRes = RecursiveDeleteKey(hKeyChild, szBuffer);

                if (dwRes != ERROR_SUCCESS)
                {
                        RegCloseKey(hKeyChild);

                        return dwRes;
                }

                dwSize = sizeof( szBuffer ) / sizeof( TCHAR );
        }

        // Close the child.

        RegCloseKey( hKeyChild );

        // Delete this child.

        return RegDeleteKey( hKeyParent , lpszKeyChild );
}

/***************************************************************************************************************

  Name:      SetUserConfig

  Purpose:   Sets the UserConfig for a Winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
                    size - Size of the input buffer in bytes
                    pUserConfig - Pointer to the UserConfig to be set

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::SetUserConfig(PWINSTATIONNAMEW pWsName, ULONG size, PUSERCONFIG pUserConfig , PDWORD pdwStatus )
{
    WINSTATIONCONFIG2W WsConfig;
    ULONG Length;

    *pdwStatus = ERROR_INVALID_PARAMETER;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    //Check if the caller has write permissions.
    if( !m_bAdmin)
    {
        *pdwStatus = ERROR_ACCESS_DENIED;

        ODS( L"CFGBKEND: ERROR_ACCESS_DENIED\n" );

        return E_ACCESSDENIED;
    }

    //Check the parametes for NULL
    if(NULL == pWsName || NULL == pUserConfig || 0 == size)
    {
        return E_INVALIDARG;
    }

    //Check for the validity of the Winstation name

    if(NULL == GetWSObject(pWsName))
    {
        *pdwStatus = ERROR_INVALID_NAME;

        return E_INVALIDARG;
    }

    //Atleast check if the size of the buffer passed is correct.

    if(size != sizeof(USERCONFIGW))
        return E_INVALIDARG;

    // Query the registry for WinStation data
    *pdwStatus = RegWinStationQueryW( NULL,pWsName,&WsConfig,sizeof(WINSTATIONCONFIG2W), &Length);

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND: SetUserConfig failed at RegWinstationQueryW\n" );

        return E_FAIL;
    }

    //Copy the UserConfig structure to the pWsConfig.
    CopyMemory((PVOID)&(WsConfig.Config.User),(CONST VOID *)pUserConfig,size);

    *pdwStatus = RegWinStationCreateW(NULL,pWsName,FALSE,&WsConfig,sizeof(WsConfig));

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND: SetUserConfig failed at RegWinStationCreateW\n" );
        return E_FAIL;
    }

    return S_OK;
}

/***************************************************************************************************************

  Name:      EnableWinstation

  Purpose:   Enables/Disables a given Winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
                    fEnable - TRUE: Enable, FALSE:Disable

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::EnableWinstation(PWINSTATIONNAMEW pWSName, BOOL fEnable)
{

    WINSTATIONCONFIG2W WsConfig;
    LONG Status;
    ULONG Length;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    //Check if the caller has write permissions.
    if(!m_bAdmin)
        return E_ACCESSDENIED;

    //Check the parametes for NULL
    if(NULL == pWSName)
        return E_INVALIDARG;


    //Check for the validity of the Winstation name, this would eliminate the system console

    if(NULL == GetWSObject(pWSName))
        return E_INVALIDARG;

    // Query the registry for WinStation data
    Status = RegWinStationQueryW( NULL,pWSName,&WsConfig,sizeof(WINSTATIONCONFIG2W), &Length);
    if(Status)
        return E_FAIL;

    WsConfig.Create.fEnableWinStation = fEnable;
    Status = RegWinStationCreateW(NULL,pWSName,FALSE,&WsConfig,sizeof(WsConfig));
    if ( Status)
        return E_FAIL;

    return S_OK;
}

/***************************************************************************************************************

  Name:      RenameWinstation

  Purpose:   Renames a given Winstation

  Returns:   HRESULT.

  Params:
             in:    pOldWinstation - Name of the Winstation to be renamed.
                    pNewWinstation - New Name for the Winstation

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::RenameWinstation(PWINSTATIONNAMEW pOldWinstation, PWINSTATIONNAMEW pNewWinstation)
{

    WINSTATIONCONFIG2W WsConfig;
    LONG Status, size = 0;
    ULONG Length; BOOL Unique;
    void * pExtObject = NULL;
    void * pExtDupObject = NULL;
    HRESULT hResult = S_OK;
    PWD pWD = NULL;
    PWS pWS = NULL;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;


    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;
    //Check if the caller has write permissions.

    if(!m_bAdmin)
        return E_ACCESSDENIED;

    //Check the parametes for NULL

    if(NULL == pOldWinstation || NULL == pNewWinstation)
        return E_INVALIDARG;

    IsWSNameUnique(pNewWinstation,&Unique);
    if(!Unique)
        return E_INVALIDARG;


    //The new Winstation Name cannot be Console

    if(0 ==(lstrcmpi(pNewWinstation,m_szConsole)))
        return E_INVALIDARG;

    //Check the length of the new winstation name

    if(lstrlen(pNewWinstation) > WINSTATIONNAME_LENGTH)
        return E_INVALIDARG;

    //Check for the validity of the Winstation name, this would eliminate the system console

    pWS = GetWSObject(pOldWinstation);
    if(NULL == pWS)
        return E_INVALIDARG;

    //Get the WD object associated with this Winstation.

    pWD = GetWdObject(pWS->wdName);
    if(NULL == pWD)
        return E_FAIL;

    //Query the registry for WinStation data
    Status = RegWinStationQueryW(NULL,pOldWinstation,&WsConfig,sizeof(WINSTATIONCONFIG2W), &Length);
    if(Status)
        return E_FAIL;


    //Get the ExtensionObject data(third party) this will be used for Creating and Deleting the registry keys.

    if(pWD->lpfnExtRegQuery && pWD->hExtensionDLL)
    {
        pExtObject = (pWD->lpfnExtRegQuery)(pOldWinstation, &(WsConfig.Pd[0]));

    }

    // Get the Security descriptor for the old Winstation
    // Must free pSecurityDescriptor via LocalFree]

    // check to see if previous winstation had a security key defined --
    // we do this so that if the default security was used we don't
    // create a "security" keyvalue in the new winstation

    HKEY hKeyWinstation;
    HKEY hKeyWinstationName;

    if( RegOpenKeyEx(
            HKEY_LOCAL_MACHINE ,
            WINSTATION_REG_NAME,
            0,
            KEY_READ,
            &hKeyWinstation ) == ERROR_SUCCESS)
    {
        if( RegOpenKeyEx( 
                hKeyWinstation ,
                pOldWinstation ,
                0 ,
                KEY_READ,
                &hKeyWinstationName ) == ERROR_SUCCESS)
        {
            if( RegQueryValueEx( 
                    hKeyWinstationName ,
                    L"Security" ,
                    NULL ,
                    NULL ,
                    NULL ,
                    NULL ) == ERROR_SUCCESS )
            {                
                hResult = GetSecurityDescriptor(
                            pOldWinstation ,
                            &size ,
                            &pSecurityDescriptor );
            }

            RegCloseKey( hKeyWinstationName );
        }

        RegCloseKey( hKeyWinstation );
    }

    if( FAILED( hResult ) )
    {
        DBGMSG( L"CFGBKEND!RenameWinstation GetSecurityDescriptor failed 0x%x\n " , hResult );
        return E_FAIL;
    }

    do
    {
        //Create a new registry key with the data.

        Status = RegWinStationCreateW(NULL,pNewWinstation,TRUE,&WsConfig,sizeof(WsConfig));

        if( Status != ERROR_SUCCESS )
        {
            hResult = E_FAIL;

            break;
        }

        //Create new extension data.

        if(pWD->lpfnExtDupObject && pWD->hExtensionDLL && pExtObject)
        {
            pExtDupObject = (pWD->lpfnExtDupObject)(pExtObject);

            if(pWD->lpfnExtRegCreate && pWD->hExtensionDLL && pExtDupObject)
            {
                (pWD->lpfnExtRegCreate)(pNewWinstation,pExtDupObject,TRUE);
            }
        }

        //Set the Security information from the previous Winstation

        if( pSecurityDescriptor != NULL )
        {
            hResult = SetSecurityDescriptor(pNewWinstation,size,pSecurityDescriptor);

            if( FAILED( hResult ) )
            {
                break;
            }
        }

        //delete old extension data

        if(pWD->lpfnExtRegDelete && pWD->hExtensionDLL && pExtObject)
        {
            if( ERROR_SUCCESS != ( ( pWD->lpfnExtRegDelete )( pOldWinstation , pExtObject ) ) )
            {
                hResult = CFGBKEND_EXTDELETE_FAILED;
            }
        }


        //Delete old registy key

        Status = RegWinStationDeleteW(NULL,pOldWinstation);

        if( Status != ERROR_SUCCESS )
        {
            //delete the new winstation that was created

            if(pWD->lpfnExtRegDelete && pWD->hExtensionDLL && pExtDupObject)
            {
                (pWD->lpfnExtRegDelete)(pNewWinstation,pExtDupObject);
            }

            RegWinStationDeleteW(NULL,pNewWinstation);

            hResult = E_FAIL;

            break;
       }

        //update the object created in the list of winstation objects.

        lstrcpy(pWS->Name,pNewWinstation);

    } while( 0 );

    //Release pSecurityDescriptor Memory

    if( pSecurityDescriptor != NULL )
    {
        LocalFree( pSecurityDescriptor );
    }

    //Delete the Extension Objects.

    if(pWD->lpfnExtDeleteObject && pWD->hExtensionDLL)
    {
        if( pExtObject )
            (pWD->lpfnExtDeleteObject)(pExtObject);

        if(pExtDupObject)
            (pWD->lpfnExtDeleteObject)(pExtDupObject);

    }

    if(hResult == CFGBKEND_EXTDELETE_FAILED)
    {
        if(pWD->lpfnExtRegDelete && pWD->hExtensionDLL && pExtObject)
            (pWD->lpfnExtRegDelete)(pOldWinstation,pExtObject);
    }

    // force termsrv to re-read settings!!!

    hResult = ForceUpdate( );

    return hResult;

}

/***************************************************************************************************************

  Name:      IsSessionReadOnly

  Purpose:   Checks if the Current session readonly.

  Returns:   HRESULT.

  Params:
             out:   pReadOnly - pointer to whether the current session is readonly.

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::IsSessionReadOnly(BOOL * pReadOnly)
{
    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    if(NULL == pReadOnly)
        return E_INVALIDARG;

    *pReadOnly = !m_bAdmin;

    return S_OK;
}

/***************************************************************************************************************

  Name:      UnInitialize

  Purpose:   Uninitializes the Object

  Returns:   HRESULT.

  Params:

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::UnInitialize()
{
    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    DeleteWDArray();
    DeleteWSArray();
    m_bInitialized = FALSE;
    return S_OK;
}

/***************************************************************************************************************

  Name:      DeleteWDArray

  Purpose:   Internal function to delete m_WdArray

  Returns:   void.

  Params:

 ****************************************************************************************************************/
void CCfgComp::DeleteWDArray()
{
    for(int i = 0; i < m_WDArray.GetSize();i++)
    {
        PWD pWd = ( PWD )m_WDArray[ i ];

        if( pWd != NULL )
        {
            if( pWd->hExtensionDLL != NULL )
            {
//                ODS( L"Freeing extension dll\n" );
                FreeLibrary( pWd->hExtensionDLL );
            }

            for( int j = 0 ; j < pWd->PDConfigArray.GetSize( ); j++ )
            {
                if( pWd->PDConfigArray[ j ] != NULL )
                {
                    delete[] pWd->PDConfigArray[ j ];
                }
            }

            delete[] m_WDArray[i];
        }
    }

    m_WDArray.RemoveAll( );

    return;


}

/***************************************************************************************************************

  Name:      DeleteWSArray

  Purpose:   Internal function to delete m_WSArray

  Returns:   void.

  Params:

 ****************************************************************************************************************/
void CCfgComp::DeleteWSArray()
{
    for(int i = 0; i <m_WSArray.GetSize();i++)
    {
        if(m_WSArray[i])
            delete [] m_WSArray[i];
    }

    m_WSArray.RemoveAll( );
    return;

}


/***************************************************************************************************************

  Name:      GetDefaultSecurityDescriptor

  Purpose:   Gets the Default Security Descriptor for a Winstation

  Returns:   HRESULT.

  Params:
             out:   pSize - Size of the allocated buffer
                    ppSecurityDescriptor - Pointer to the buffer containing the security descriptor


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetDefaultSecurityDescriptor(long * pSize, PSECURITY_DESCRIPTOR * ppSecurityDescriptor)
{
    HRESULT hResult = S_OK;

    //If not initialized return error
    if( !m_bInitialized )
    {
        return CFGBKEND_E_NOT_INITIALIZED;
    }

    if(NULL == pSize || NULL == ppSecurityDescriptor)
    {
        return E_INVALIDARG;
    }

    *pSize = 0;

    *ppSecurityDescriptor = NULL;

    //Try Getting Default Security Descriptor

    hResult = GetWinStationSecurity(TRUE, NULL,(PSECURITY_DESCRIPTOR *)ppSecurityDescriptor);

    if(SUCCEEDED(hResult) && *ppSecurityDescriptor != NULL )
    {
        *pSize = GetSecurityDescriptorLength( *ppSecurityDescriptor );
    }

    return hResult;
}


/***************************************************************************************************************

  Name:      UpDateWS

  Purpose:   UpDates the Winstation Information

  Returns:   HRESULT.

  Params:
             in:    winstationInfo - WS
                    Data - Data fields to be updated


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::UpDateWS( PWS pWinstationInfo, DWORD Data , PDWORD pdwStatus, BOOLEAN bPerformMerger )
{
    WINSTATIONCONFIG2W WSConfig;
    ULONG Length;

    _ASSERTE( pWinstationInfo != NULL );

    *pdwStatus = 0;

    if( pWinstationInfo == NULL || !( Data & UPDATE_ALL ) )
    {
        return E_INVALIDARG;
    }

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;


    //Check if the caller has write permissions.
    if( !m_bAdmin)
    {
        *pdwStatus = ERROR_ACCESS_DENIED;

        return E_ACCESSDENIED;
    }

    //Check for the validity of the Winstation name, this would eliminate the system console

    if(NULL == GetWSObject( pWinstationInfo->Name ) )
    {
        *pdwStatus = ERROR_INVALID_NAME;

        return E_INVALIDARG;
    }

    // Query the registry for WinStation data
    POLICY_TS_MACHINE p;
    memset(&p, 0, sizeof(POLICY_TS_MACHINE));
    *pdwStatus = RegWinStationQueryEx( NULL, &p, pWinstationInfo->Name,&WSConfig,sizeof(WINSTATIONCONFIG2W), &Length, bPerformMerger);

    if( *pdwStatus != ERROR_SUCCESS )
    {
        return E_FAIL;
    }

    if( Data & UPDATE_LANADAPTER )
    {
        WSConfig.Pd[0].Params.Network.LanAdapter = pWinstationInfo->LanAdapter;
    }

    if( Data & UPDATE_ENABLEWINSTATION )
    {
        WSConfig.Create.fEnableWinStation = pWinstationInfo->fEnableWinstation;
    }

    if( Data & UPDATE_MAXINSTANCECOUNT )
    {
        WSConfig.Create.MaxInstanceCount = pWinstationInfo->uMaxInstanceCount;
    }

    if( Data & UPDATE_COMMENT )
    {
        lstrcpy( WSConfig.Config.Comment , pWinstationInfo->Comment );
    }

    /*
    switch(Data)
    {
    case LANADAPTER:
        WSConfig.Pd[0].Params.Network.LanAdapter = winstationInfo.LanAdapter;
        break;
    case ENABLEWINSTATION:
        WSConfig.Create.fEnableWinStation = winstationInfo.fEnableWinstation;
        break;
    case MAXINSTANCECOUNT:
        WSConfig.Create.MaxInstanceCount = winstationInfo.uMaxInstanceCount;
        break;
    case COMMENT:
        lstrcpy(WSConfig.Config.Comment,winstationInfo.Comment);
        break;
    // case ASYNC:
    //    break;
    case ALL:
        WSConfig.Pd[0].Params.Network.LanAdapter = winstationInfo.LanAdapter;
        WSConfig.Create.fEnableWinStation = winstationInfo.fEnableWinstation;
        WSConfig.Create.MaxInstanceCount = winstationInfo.uMaxInstanceCount;
        lstrcpy(WSConfig.Config.Comment,winstationInfo.Comment);
        break;
    default:
        return E_INVALIDARG;
        break;
    }

  */
    *pdwStatus = RegWinStationCreateW( NULL , pWinstationInfo->Name , FALSE , &WSConfig , sizeof( WSConfig ) );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        return E_FAIL;
    }

    // force termsrv to re-read settings!!!

    return ForceUpdate( );

}

/***************************************************************************************************************

  Name:      GetWSInfo

  Purpose:   Gets Information about a Winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
             out:   pSize - Size of the allocated buffer
                    ppWS - Pointer to the buffer containing the WS


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetWSInfo(PWINSTATIONNAME pWSName, long * pSize, WS ** ppWS)
{

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    PWS pWS1 = NULL;
    if(NULL == pWSName || NULL == pSize || NULL == ppWS)
        return E_INVALIDARG;

    *ppWS = NULL;

    *pSize = 0;


    pWS1 = GetWSObject(pWSName);
    if(NULL == pWS1)
        return E_INVALIDARG;

    *ppWS = (WS *)CoTaskMemAlloc(sizeof(WS));
    if(NULL == *ppWS)
        return E_OUTOFMEMORY;

    CopyMemory((PVOID)*ppWS,(CONST VOID *)pWS1,sizeof(WS));
    *pSize = sizeof(WS);

    return S_OK;
}

/***************************************************************************************************************

  Name:      CreateNewWS

  Purpose:   Creates a new WS

  Returns:   HRESULT.

  Params:
             in:    WinstationInfo - Info about new UI.
                    UserCnfgSize - Size of the Userconfig Buffer
                    pserConfig - Pointer to USERCONFIG.
                    pAsyncConfig - Can be NULL if async is not used

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::CreateNewWS(WS WinstationInfo, long UserCnfgSize, PUSERCONFIG pUserConfig,PASYNCCONFIGW pAsyncConfig)
{
    WINSTATIONCONFIG2W WSConfig;

    WDCONFIG2W WdConfig;

    PDCONFIG3W PdConfig;

    BOOL Unique;

    ULONG ByteCount;

    HRESULT hResult = S_OK;

    PWD pWd = NULL;

    DWORD dwStatus = ERROR_SUCCESS;

    //If not initialized return error
    if(!m_bInitialized)
    {
        ODS( L"CFGBKEND : CreateNewWS not initialized\n" );

        return CFGBKEND_E_NOT_INITIALIZED;
    }

    do
    {
        //Check if the caller has write permissions.
        if(!m_bAdmin)
        {
            ODS( L"CFGBKEND : CreateNewWS not Admin\n" );

            hResult = E_ACCESSDENIED;

            break;
        }

        pWd = GetWdObject(WinstationInfo.wdName);

        if(NULL == pWd)
        {
            ODS( L"CFGBKEND : CreateNewWS no WD Object found\n" );

            hResult = E_INVALIDARG;

            break;
        }


        if(UserCnfgSize != sizeof(USERCONFIGW) && pUserConfig == NULL)
        {
            ODS( L"CFGBKEND : CreateNewWS UserConfig invalid\n" );

            hResult = E_INVALIDARG;

            break;
        }

        //See if the Name of the Winstation is Unique
        hResult = IsWSNameUnique(WinstationInfo.Name,&Unique);

        if( FAILED( hResult ) )
        {
            break;
        }

        if(0 == Unique)
        {
            ODS( L"CFGBKEND : CreateNewWS WINSTA name not unique\n" );

            hResult = E_INVALIDARG;

            break;
        }

        //Check the length of the new winstation name

        if(lstrlen(WinstationInfo.Name) > WINSTATIONNAME_LENGTH)
        {
            hResult = E_INVALIDARG;

            break;
        }


        //Now begins the actual work.

        ZeroMemory(&WSConfig, sizeof(WINSTATIONCONFIG2W));

        //WINSTATIONCONFIG2W.Create

        WSConfig.Create.fEnableWinStation = WinstationInfo.fEnableWinstation;

        WSConfig.Create.MaxInstanceCount = WinstationInfo.uMaxInstanceCount;

        //WINSTATIONCONFIG2W.Wd

        dwStatus = RegWdQueryW(NULL,pWd->wdKey, &WdConfig,sizeof(WdConfig),&ByteCount);

        if(ERROR_SUCCESS != dwStatus )
        {
            DBGMSG( L"CFGBKEND : CreateNewWS@RegWdQuery failed with 0x%x\n" , dwStatus );

            hResult = E_FAIL;

            break;
        }

        WSConfig.Wd = WdConfig.Wd;

        //WINSTATIONCONFIG2W.Config

        lstrcpy(WSConfig.Config.Comment,WinstationInfo.Comment);

        CopyMemory( ( PVOID )&WSConfig.Config.User , ( CONST VOID * )pUserConfig , UserCnfgSize );

        //WINSTATIONCONFIG2W.Pd

        dwStatus = RegPdQueryW( NULL , pWd->wdKey , TRUE , WinstationInfo.pdName , &PdConfig , sizeof(PdConfig) , &ByteCount );

        if( ERROR_SUCCESS != dwStatus )
        {
            DBGMSG( L"CFGBKEND : CreateNewWS RegPdQuery failed with 0x%x\n" , dwStatus );

            hResult = E_FAIL;

            break;
        }

        WSConfig.Pd[0].Create = PdConfig.Data;

        WSConfig.Pd[0].Params.SdClass = (SDCLASS)WinstationInfo.PdClass;

        if(SdNetwork == (SDCLASS)WinstationInfo.PdClass)
        {
            WSConfig.Pd[0].Params.Network.LanAdapter = WinstationInfo.LanAdapter;
        }
        else if(SdAsync == (SDCLASS)WinstationInfo.PdClass)
        {
            if(NULL != pAsyncConfig)
            {
                pAsyncConfig->fConnectionDriver = *( pAsyncConfig->ModemName ) ? TRUE : FALSE;

                WSConfig.Pd[0].Params.Async = *pAsyncConfig;

                CDCONFIG cdConfig;

                SetupAsyncCdConfig( pAsyncConfig , &cdConfig );

                if( cdConfig.CdName[ 0 ] != 0 )
                {
                    dwStatus = RegCdCreateW( NULL , pWd->wdKey , cdConfig.CdName , TRUE , &cdConfig , sizeof( CDCONFIG ) );

                    if( dwStatus != ERROR_SUCCESS )
                    {
                        DBGMSG( L"CFGBKEND: RegCdCreateW returned 0x%x\n", dwStatus );

                        if( dwStatus == ERROR_ALREADY_EXISTS )
                        {
                            hResult = S_FALSE;
                        }
                        else if( dwStatus == ERROR_CANTOPEN )
                        {
                            hResult = E_ACCESSDENIED;

                            break;
                        }
                        else
                        {
                            hResult = E_FAIL;

                            break;
                        }
                    }

                    WSConfig.Cd = cdConfig;
                }

            }

        }

        //Get the additional Pd's. Currently only ICA has this.

        GetPdConfig(pWd->wdKey,WSConfig);

        //Try Creating

        dwStatus = ( DWORD )RegWinStationCreate( NULL , WinstationInfo.Name , TRUE , &WSConfig , sizeof(WINSTATIONCONFIG2) );

        if( dwStatus != ERROR_SUCCESS )
        {
            DBGMSG( L"CFGBKEND : CreateNewWS@RegWinStationCreate failed 0x%x\n" , dwStatus );

            hResult = E_FAIL;

            break;
        }

        //Create the extension Data, Currently only ICA has this

        void * pExtObject = NULL;

        if(pWd->lpfnExtRegQuery && pWd->hExtensionDLL)
        {
            pExtObject = (pWd->lpfnExtRegQuery)(L"", &(WSConfig.Pd[0]));

        }

        if(pExtObject)
        {
            if(pWd->lpfnExtRegCreate)
            {
                (pWd->lpfnExtRegCreate)(WinstationInfo.Name,pExtObject,TRUE);
            }
        }

        //Delete the extension object

        if(pWd->lpfnExtDeleteObject && pExtObject)
        {
            (pWd->lpfnExtDeleteObject )(pExtObject );
        }

        //Add the Winstation to our local list.

        PWS pObject = NULL;

        hResult = InsertInWSArray(WinstationInfo.Name,&WSConfig,&pObject);

        if( SUCCEEDED( hResult ) )
        {
            hResult = ForceUpdate( );
        }

    }while( 0 );


    return hResult;
}

/***************************************************************************************************************

  Name:      GetDefaultUserConfig

  Purpose:   Gets the Default User Configuration for a given Winstation Driver

  Returns:   HRESULT.

  Params:
             in:    WdName - Name of the Winstation Driver.
             out:   pSize - Size of the allocated buffer
                    ppUser - Pointer to the buffer containing the UserConfig


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetDefaultUserConfig(WCHAR * WdName,long * pSize, PUSERCONFIG * ppUser)
{
    LONG QStatus;
    WDCONFIG2W WdConfig;
    ULONG ByteCount;
    PWD pWd = NULL;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;


    if(NULL == pSize || NULL == ppUser || NULL == WdName)
        return E_INVALIDARG;

    pWd = GetWdObject(WdName);
    if(NULL == pWd)
        return E_INVALIDARG;

    if (( QStatus = RegWdQueryW( NULL, pWd->wdKey, &WdConfig,
                                     sizeof(WdConfig),
                                     &ByteCount )) != ERROR_SUCCESS )
        return E_FAIL;

    *ppUser = (PUSERCONFIG)CoTaskMemAlloc(sizeof(WdConfig.User));
    if(*ppUser == NULL)
        return E_OUTOFMEMORY;

    CopyMemory((PVOID)*ppUser,(CONST VOID *)&WdConfig.User,sizeof(WdConfig.User));
    *pSize = sizeof(WdConfig.User);

    return S_OK;
}

/***************************************************************************************************************

  Name:      IsNetWorkConnectionUnique

  Purpose:   Checks if the combination of Winstation driver name, LanAdapter and the transport is Unique.

  Returns:   HRESULT.

  Params:
             in:    WdName - Name of the Winstation Driver.
                    PdName - Name of the Transport
                    LanAdapter - LanAdapter Index
            out:    pUnique - pointer to whether the information is unique or not.

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::IsNetWorkConnectionUnique(WCHAR * WdName, WCHAR * PdName, ULONG LanAdapter, BOOL * pUnique)
{
    //If not initialized return error
    if( !m_bInitialized )
    {
        return CFGBKEND_E_NOT_INITIALIZED;
    }

    //Check for uniqueness of this combination,
    //Transport, Type , LanAdapter
    if( NULL == WdName || NULL == PdName || NULL == pUnique )
    {
        return E_INVALIDARG;
    }

    *pUnique = TRUE;

    int nSize = m_WSArray.GetSize();

    for(int i = 0; i < nSize; i++ )
    {
        if(lstrcmpi(WdName,((WS *)(m_WSArray[i]))->wdName) == 0 )
        {
            if(lstrcmpi(PdName,((WS *)(m_WSArray[i]))->pdName) == 0)
            {
                // Make sure there's not a lanadapter configured for all settings

                if( ( LanAdapter == 0 ) ||

                    ( LanAdapter == ( ( WS * )( m_WSArray[ i ] ) )->LanAdapter ) ||

                    ( ( ( WS * )( m_WSArray[ i ] ) )->LanAdapter == 0 ) )

                    //( oldLanAdapter != ( ( WS * )( m_WSArray[ i ] ) )->LanAdapter && ( ( WS * )( m_WSArray[ i ] ) )->LanAdapter == 0 ) )
                {
                    *pUnique = FALSE;

                    break;
                }
            }
        }

    }

    return S_OK;
}

/***************************************************************************************************************

  Name:      DeleteWS

  Purpose:   Deletes a given Winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
             out:   pSize - Size of the allocated buffer
                    ppSecurityDescriptor - Pointer to the buffer containing the security descriptor


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::DeleteWS(PWINSTATIONNAME pWs)
{
    HRESULT hResult = S_OK;
    PWS pWinsta = NULL;
    PWD pWD = NULL;
    void * pExtObject = NULL;
    WINSTATIONCONFIG2W WsConfig;
    ULONG Length = 0;
    long Status;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    //Check if the caller has write permissions.
    if(!m_bAdmin)
        return E_ACCESSDENIED;

    //Check if Valid Winstation Name
    if(NULL == pWs)
        return E_INVALIDARG;

    //Check for the validity of the Winstation name,

    pWinsta = GetWSObject(pWs);
    if(NULL == pWinsta)
        return E_INVALIDARG;

    //Get the WD object associated with this Winstation.

    pWD = GetWdObject(pWinsta->wdName);
    if(NULL == pWD)
        return E_FAIL;

    //Query the registry for WinStation data
    Status = RegWinStationQueryW(NULL,pWs,&WsConfig,sizeof(WINSTATIONCONFIG2W), &Length);
    if(Status)
        return E_FAIL;

#if 0 // tscc now uses aclui
    // Remove name entry keys
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server\\winstations\\" );

    HKEY hKey;

    lstrcat( tchRegPath , pWs );

    lstrcat( tchRegPath , L"\\NamedEntries" );

    OutputDebugString( tchRegPath );

    if( RegOpenKey( HKEY_LOCAL_MACHINE , tchRegPath , &hKey ) == ERROR_SUCCESS )
    {
        RegDeleteValue( hKey , L"cbSize" );

        RegDeleteValue( hKey , L"NE" );

        RegCloseKey( hKey );

        RegDeleteKey( HKEY_LOCAL_MACHINE , tchRegPath );
    }

#endif

    //Get the ExtensionObject data(third party) this will be used for Creating and Deleting the registry keys.

    if(pWD->lpfnExtRegQuery && pWD->hExtensionDLL)
    {
        pExtObject = (pWD->lpfnExtRegQuery)(pWs, &(WsConfig.Pd[0]));
        if(pWD->lpfnExtRegDelete && pExtObject)
        {
            //Try Deleting the Extension entries in the registy
            if(ERROR_SUCCESS != (pWD->lpfnExtRegDelete)(pWs,pExtObject))
                hResult = CFGBKEND_EXTDELETE_FAILED;
            //Delete the extension object. It will not be used further.
            if(pWD->lpfnExtDeleteObject)
                (pWD->lpfnExtDeleteObject)(pExtObject);
        }

    }


    //Delete registy key
    Status = RegWinStationDeleteW(NULL,pWs);
    if (Status)
        return Status;

    //update our list of winstation objects.

    PWS pObject;
    int Size  = 0,Index = 0;

    /*
     * Traverse the WD list
     */
    for (Index = 0, Size = m_WSArray.GetSize(); Index < Size; Index ++)
    {

        pObject = (PWS)m_WSArray[Index];

        if ( !lstrcmpi( pObject->Name, pWs ) )
        {
           m_WSArray.RemoveAt(Index,1);
           delete pObject;
           break;
        }
    }

    return hResult;
}

//----------------------------------------------------------------------
// good to call when you've updated the winstation security descriptor
//----------------------------------------------------------------------

STDMETHODIMP CCfgComp::ForceUpdate( void )
{
    if( !m_bInitialized )
    {
        ODS( L"CFGBKEND : CCfgComp::ForceUpdate return NOT_INIT\n" );

        return CFGBKEND_E_NOT_INITIALIZED;
    }

    //Check if the caller has write permissions.

    if(!m_bAdmin)
    {
        ODS( L"CFGBKEND : CCfgComp::ForceUpdate -- not admin\n" );

        return E_ACCESSDENIED;
    }

    if( _WinStationReadRegistry( SERVERNAME_CURRENT ) )
    {
        return S_OK;
    }

    ODS( L"CFGBKEND : ForceUpdate failed Winstation not updated\n" );

    return E_FAIL;
}

//----------------------------------------------------------------------
// Must delete the array completely first.
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::Refresh( void )
{
    //Check if the caller has write permissions.

    /* bugid 364103
    if(!m_bAdmin)
    {
        return E_ACCESSDENIED;
    }
    */

    HRESULT hr = FillWdArray();

    if( SUCCEEDED( hr) )
    {
        hr = FillWsArray();
    }

    return hr;
}

//----------------------------------------------------------------------
// Obtain Winstation SDCLASS type
// m_WDArray must already be initialized
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetTransportType( WCHAR *wszDriverName , WCHAR *wszTransportType , DWORD *sdtype )
{
    _ASSERTE( wszDriverName != NULL || wszTransportType != NULL || sdtype != NULL );

    if( wszDriverName == NULL || wszTransportType == NULL || sdtype == NULL )
    {
        return E_INVALIDARG;
    }

    *sdtype = SdNone;

    PWD pWd = GetWdObject( wszDriverName );

    if( pWd != NULL )
    {
        BOOL bFound = FALSE;

        for( int i = 0; i < pWd->PDConfigArray.GetSize( ) ; ++i )
        {
            if( lstrcmpi( wszTransportType , ( ( PDCONFIG3W *)pWd->PDConfigArray[ i ] )->Data.PdName ) == 0 )
            {
                bFound = TRUE;

                break;
            }
        }

        if( bFound )
        {
            *sdtype = ( ( PDCONFIG3W * )pWd->PDConfigArray[ i ] )->Data.SdClass;

            return S_OK;
        }

    }

    return E_FAIL;
}

//----------------------------------------------------------------------
// Async's are unique if device name protocol type vary from other
// winstations.
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::IsAsyncUnique( WCHAR *wszDeviceName , WCHAR *wszProtocolType , BOOL *pbUnique )
{
    _ASSERTE( wszDecoratedName != NULL || wszProtocolType != NULL || pbUnique != NULL );

    if( wszDeviceName == NULL || wszProtocolType == NULL || pbUnique == NULL )
    {
        return E_INVALIDARG;
    }

    *pbUnique = TRUE;

    // Traverse the WinStationList.

    for( int i = 0; i < m_WSArray.GetSize(); i++ )
    {
        if( lstrcmpi( wszProtocolType , ( ( WS * )( m_WSArray[ i ] ) )->wdName ) == 0 )
        {
            if( SdAsync == ( ( WS *)( m_WSArray[i] ) )->PdClass )
            {
                if( !lstrcmpi( wszDeviceName , ( ( WS * )( m_WSArray[ i ] ) )->DeviceName ) == 0 )
                {
                    *pbUnique = FALSE;

                    break;
                }
            }
        }

    }

    return S_OK;
}

//----------------------------------------------------------------------
// Pull async configuration from the registry
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetAsyncConfig( WCHAR *wszName , NameType nt , PASYNCCONFIGW pAsync )
{
    if( wszName == NULL || pAsync == NULL )
    {
        ODS( L"CFGBKEND: Invalid arg @ GetAsyncConfig\n" );

        return E_INVALIDARG;
    }

    WINSTATIONCONFIG2W WSConfig2;

    ULONG ulLength = 0;

    if( nt == WsName )
    {
        //Read the information from the registry.
        if( RegWinStationQueryW( NULL , wszName , &WSConfig2 , sizeof( WINSTATIONCONFIG2W) , &ulLength ) != ERROR_SUCCESS )
        {
            ODS( L"CFGBKEND: RegWinStationQueryW failed @ GetAsyncConfig\n " );

            return E_FAIL;
        }

        *pAsync = WSConfig2.Pd[0].Params.Async;
    }
    else if( nt == WdName )
    {
        PWD pObject = GetWdObject( wszName );

        if( pObject == NULL )
        {
            return E_UNEXPECTED;
        }

        *pAsync = pObject->wd2.Async;
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

//----------------------------------------------------------------------
// Push async config back in to the registry
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetAsyncConfig( WCHAR *wszName , NameType nt , PASYNCCONFIGW pAsync , PDWORD pdwStatus )
{
    *pdwStatus = 0;

    if( wszName == NULL || pAsync == NULL )
    {
        ODS( L"CFGBKEND: Invalid arg @ SetAsyncConfig\n" );

        *pdwStatus = ERROR_INVALID_PARAMETER;

        return E_INVALIDARG;
    }

    WINSTATIONCONFIG2W WSConfig2;

    // WDCONFIG2W wdConfig2;

    ULONG ulLength = 0;

    if( nt == WsName )
    {
        //Read the information from the registry.
        CDCONFIG cdConfig;

        ZeroMemory( ( PVOID )&cdConfig , sizeof( CDCONFIG ) );

        if( ( *pdwStatus = RegWinStationQueryW( NULL , wszName , &WSConfig2 , sizeof( WINSTATIONCONFIG2W) , &ulLength ) ) != ERROR_SUCCESS )
        {
            ODS( L"CFGBKEND: RegWinStationQueryW failed @ SetAsyncConfig\n" );

            return E_FAIL;
        }

        pAsync->fConnectionDriver = *( pAsync->ModemName ) ? TRUE : FALSE;

        SetupAsyncCdConfig( pAsync , &cdConfig );

        WSConfig2.Pd[0].Params.Async = *pAsync;

        WSConfig2.Cd = cdConfig;


        if( ( *pdwStatus = RegWinStationCreateW( NULL , wszName , FALSE , &WSConfig2 , sizeof( WINSTATIONCONFIG2W ) ) ) != ERROR_SUCCESS )
        {
            ODS( L"CFGBKEND: RegWinStationCreateW failed @ SetAsyncConfig\n" );

            return E_FAIL;
        }
    }
    /*else if( nt == WdName )
    {
        PWD pObject = GetWdObject( wszName );

        if( pObject == NULL )
        {
            ODS( L"CFGBKEND: Failed to obtain WD @ SetAsyncConfig\n" );

            *pdwStatus = ERROR_INVALID_NAME;

            return E_FAIL;
        }

        if( ( *pdwStatus = RegWdQueryW(  NULL , pObject->wdKey , &wdConfig2 , sizeof( WDCONFIG2W ) , &ulLength )  ) != ERROR_SUCCESS )
        {
            ODS( L"CFGBKEND: RegWdQueryW failed @ SetAsyncConfig driver name is " );
            ODS( pObject->wdKey );
            ODS( L"\n" );

            return E_FAIL;
        }

        wdConfig2.Async = *pAsync;

        if( ( *pdwStatus = RegWdCreateW( NULL , pObject->wdKey , FALSE , &wdConfig2 , sizeof( WDCONFIG2W ) ) ) != ERROR_SUCCESS )
        {
            ODS( L"CFGBKEND: RegWdCreateW failed @ SetAsyncConfig\n" );

            return E_FAIL;
        }
    }*/
    else
    {
        *pdwStatus = ERROR_INVALID_PARAMETER;

        return E_INVALIDARG;
    }


    return S_OK;
}

//----------------------------------------------------------------------
// GetDeviceList expects the name of the WD
// the return is a BLOB PDPARAMs containing ASYNCCONFG's
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetDeviceList( WCHAR *wszName , NameType Type , ULONG *pulItems , LPBYTE *ppBuffer )
{
    PWD pObject = NULL;

    if( wszName == NULL || pulItems == NULL )
    {
        ODS( L"CFGBKEND : @GetDeviceList - Driver or WinSta Name invalid\n" );

        return E_INVALIDARG;
    }

    if( Type == WsName )
    {
        PWS pWS = GetWSObject( wszName );
        if( NULL == pWS )
        {
            ODS( L"CFGBKEND : @GetDeviceList - No winsta object found\n" );

            return E_INVALIDARG;
        }

        pObject = GetWdObject( pWS->wdName );

        if( NULL == pObject )
        {
            ODS( L"CFGBKEND : @GetDeviceList - No WD object found\n" );
            return E_FAIL;
        }
    }
    else
    {
        pObject = GetWdObject( wszName );
    }

    if( pObject == NULL )
    {
        ODS( wszName ); ODS( L" - @GetDeviceList - driver object not found\n" );

        return E_UNEXPECTED;
    }

    PDCONFIG3W *pPdConfig3 = NULL;

    int nItems = ( pObject->PDConfigArray ).GetSize( );

    for( int i = 0; i < nItems ; i++)
    {
        if( SdAsync == ( ( PDCONFIG3W * )pObject->PDConfigArray[i] )->Data.SdClass )
        {
            pPdConfig3 = ( PDCONFIG3W * )pObject->PDConfigArray[i];

            break;
        }

    }

    if( pPdConfig3 == NULL )
    {
        ODS( L"@GetDeviceList - PDCONFIG3 not found for ASYNC\n" );

        return E_UNEXPECTED;
    }

    // Get the list of PDPARAMS -- last param if true queries registry for com devices
    // if false uses DosDevices to obtain list

    ODS( L"CFGBKEND : Calling WinEnumerateDevices\n" );

    LPBYTE lpBuffer = ( LPBYTE )WinEnumerateDevices( NULL , pPdConfig3 , pulItems , FALSE );

    if( lpBuffer == NULL )
    {
        ODS( L"CFGBKEND : WinEnumerateDevices failed @ CCfgComp::GetDeviceList\n" );

        return E_OUTOFMEMORY;
    }

    // don't forget to free with LocalFree

    *ppBuffer = lpBuffer;

    return S_OK;
}

//----------------------------------------------------------------------
// GetConnType retreives the name of the connection type for an Async
// device.  The list of resource ids is match the order of the
// CONNECTCONFIG enum data type.
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetConnTypeName( int idxItem , WCHAR *rgwszConnectName )
{
    int rgIds[] = { IDS_CONNECT_CTS , IDS_CONNECT_DSR , IDS_CONNECT_RI ,

                    IDS_CONNECT_DCD , IDS_CONNECT_FIRST_CHARACTER ,

                    IDS_CONNECT_ALWAYS , -1 };


    _ASSERTE( rgwszConnectName != NULL );

    _ASSERTE( idxItem >= 0 && idxItem < ARRAYSIZE( rgIds ) );

    if( rgIds[ idxItem ] == -1 )
    {
        return S_FALSE;
    }

    if( !GetResourceStrings( rgIds , idxItem , rgwszConnectName ) )
    {
        ODS( L"Error happen in CCfgComp::GetConnTypeName\n" );

        return E_FAIL;
    }

    return S_OK;
}

//----------------------------------------------------------------------
// GetModemCallbackString
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetModemCallbackString( int idxItem , WCHAR *rgwszModemCallBackString )
{
    int rgIds[] = { IDS_MODEM_CALLBACK_DISABLED , IDS_MODEM_CALLBACK_ROVING , IDS_MODEM_CALLBACK_FIXED , -1 };

    _ASSERTE( rgwszModemCallBackString != NULL );

    _ASSERTE( idxItem >= 0 && idxItem < ARRAYSIZE( rgIds ) );

    if( rgIds[ idxItem ] == -1 )
    {
        return S_FALSE;
    }

    if( !GetResourceStrings( rgIds , idxItem , rgwszModemCallBackString ) )
    {
        ODS( L"Error happen in CCfgComp::GetConnTypeName\n" );

        return E_FAIL;
    }

    return S_OK;
}

//----------------------------------------------------------------------
// Returns the name of hardware flow control receive string
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetHWReceiveName( int idxItem , WCHAR *rgwszHWRName )
{
    int rgIds[] = { IDS_ASYNC_ADVANCED_HWRX_NOTHING ,

                    IDS_ASYNC_ADVANCED_HWRX_TURN_OFF_RTS ,

                    IDS_ASYNC_ADVANCED_HWRX_TURN_OFF_DTR , -1

                  };

    _ASSERTE( rgwszHWRName != NULL );

    _ASSERTE( idxItem >= 0 && idxItem < ARRAYSIZE( rgIds ) );

    if( rgIds[ idxItem ] == -1 )
    {
        return S_FALSE;
    }

    if( !GetResourceStrings( rgIds , idxItem , rgwszHWRName ) )
    {
        ODS( L"Error happen in CCfgComp::GetHWReceiveName\n" );

        return E_FAIL;
    }

    return S_OK;
}

//----------------------------------------------------------------------
// returns the name of hardware flow control transmit string
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetHWTransmitName( int idxItem , WCHAR *rgwzHWTName )
{
    int rgIds[] = { IDS_ASYNC_ADVANCED_HWTX_ALWAYS ,

                    IDS_ASYNC_ADVANCED_HWTX_WHEN_CTS_IS_ON,

                    IDS_ASYNC_ADVANCED_HWTX_WHEN_DSR_IS_ON,

                    -1
                  };

    _ASSERTE( rgwszHWRName != NULL );

    _ASSERTE( idxItem >= 0 && idxItem < ARRAYSIZE( rgIds ) );

    if( rgIds[ idxItem ] == -1 )
    {
        return S_FALSE;
    }

    if( !GetResourceStrings( rgIds , idxItem , rgwzHWTName ) )
    {
        ODS( L"Error happen in CCfgComp::GetHWReceiveName\n" );

        return E_FAIL;
    }

    return S_OK;
}

//----------------------------------------------------------------------
// Internal method call -- helper function.
//----------------------------------------------------------------------
BOOL CCfgComp::GetResourceStrings( int *prgIds , int iItem , WCHAR *rgwszList )
{
    _ASSERTE( rgwszList != NULL );

    if( rgwszList == NULL )
    {
        ODS( L"rgwszList is NULL @ CCfgComp::GetResourceStrings\n" );

        return FALSE;
    }

    TCHAR tchConType[ 80 ];

    if( LoadString( _Module.GetResourceInstance( ) , prgIds[ iItem ] , tchConType , sizeof( tchConType ) / sizeof( TCHAR ) ) == 0 )
    {
        ODS( L"String resource not found @ CCfgComp::GetResourceStrings\n" );

        return FALSE;
    }

    // copy enough characters

    lstrcpyn( rgwszList , tchConType , sizeof( tchConType ) );


    return TRUE;
}

//----------------------------------------------------------------------
HRESULT CCfgComp::GetCaps( WCHAR *szWdName , ULONG *pMask )
{
    if( szWdName == NULL || pMask == NULL )
    {
        ODS( L"CCfgComp::GetCaps returned INVALIDARG\n" );

        return E_INVALIDARG;
    }

    PWD pObject = GetWdObject( szWdName );

    if( pObject == NULL )
    {
        return E_UNEXPECTED;
    }


    if( pObject->lpfnGetCaps != NULL )
    {
        *pMask = ( pObject->lpfnGetCaps )( );
    }

    return S_OK;
}


//----------------------------------------------------------------------
HRESULT CCfgComp::QueryLoggedOnCount( WCHAR *pWSName , PLONG pCount )
{
    ODS( L"CFGBKEND : CCfgComp::QueryLoggedOnCount\n" );

    *pCount = 0;

    ULONG Entries = 0;

    TCHAR *p;

    PLOGONID pLogonId;

    if(FALSE == WinStationEnumerate( NULL , &pLogonId, &Entries))
    {
        return E_FAIL;
    }

    if( pLogonId )
    {
        for( ULONG i = 0; i < Entries; i++ )
        {
            /*
             * Check active, connected, and shadowing WinStations, and increment
             * the logged on count if the specified name matches the 'root'
             * name of current winstation.
             */

            if( ( pLogonId[i].State == State_Active ) || ( pLogonId[i].State == State_Connected ) || ( pLogonId[i].State == State_Shadow ) )
            {
                // remove appended connection number

                p = _tcschr( pLogonId[i].WinStationName , TEXT('#') );

                if( p != NULL )
                {
                    *p = TEXT('\0');
                }


                if( !lstrcmpi( pWSName, pLogonId[i].WinStationName ) )
                {
                    *pCount += 1 ;
                }
            }
        }

        WinStationFreeMemory(pLogonId);
    }

    return S_OK;

}  // end QueryLoggedOnCount

/*
//-----------------------------------------------------------------------------
// returns the number of configured winstations
//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetNumofWinStations( PULONG nWinsta )
{
    if( nWinsta == NULL )
    {
        ODS( L"CFGBKEND : GetNumofWinStations - INVALID ARG\n" );

        return E_INVALIDARG;
    }

    *nWinsta = ( ULONG )m_WSArray.GetSize();

    return S_OK;
}
*/
//-----------------------------------------------------------------------------
// returns the number of configured winstations
//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetNumofWinStations(WCHAR * WdName,WCHAR * PdName, PULONG nWinsta )
{
    if( nWinsta == NULL || NULL == WdName || NULL == PdName )
    {
        ODS( L"CFGBKEND : GetNumofWinStations - INVALID ARG\n" );

        return E_INVALIDARG;
    }

    ULONG lCount = 0;
    for( int i = 0; i < m_WSArray.GetSize(); i++ )
    {
         if(lstrcmpi(WdName,( ( WS *)( m_WSArray[i] ) )->wdName) == 0 )
         {
             if(lstrcmpi( PdName , ( ( WS * )( m_WSArray[ i ] ) )->pdName ) == 0 )
             {
                lCount++;
             }
         }

     }

        *nWinsta = lCount;

    return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP_(BOOL) CCfgComp::IsAsyncDeviceAvailable(LPCTSTR pDeviceName)
{
    /*
     * If this is an async WinStation, the device is the same as the
     * one we're checking, but this is not the current WinStation being
     * edited, return FALSE.
     * THIS NEEDS TO BE REVIEWED - alhen
     */

    //return TRUE;

    if( pDeviceName != NULL )
    {
        for( int i = 0; i < m_WSArray.GetSize(); i++ )
        {
            if( SdAsync == ( ( WS *)( m_WSArray[i] ) )->PdClass )
            {
                if( lstrcmpi( pDeviceName , ( ( WS * )( m_WSArray[ i ] ) )->DeviceName ) == 0 )
                {
                    return FALSE;
                }
            }

        }
    }

    return TRUE;


}

#if 0 // removed for final
//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetCachedSessions(DWORD * pCachedSessions)
{
    HKEY Handle = NULL;
      DWORD ValueBuffer = 0;
    DWORD ValueType = 0;
    LONG Status = 0;

    DWORD ValueSize = sizeof(ValueBuffer);

    if(NULL == pCachedSessions)
    {
        return E_INVALIDARG;
    }

    *pCachedSessions = 0;

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ, &Handle );
    if ( Status == ERROR_SUCCESS )
    {

        Status = RegQueryValueEx( Handle,
                                  REG_CITRIX_IDLEWINSTATIONPOOLCOUNT,
                                  NULL,
                                  &ValueType,
                                  (LPBYTE) &ValueBuffer,
                                  &ValueSize );
        if ( Status == ERROR_SUCCESS )
        {
            if(ValueType == REG_DWORD)
            {
                *pCachedSessions = ValueBuffer;
            }
            else
            {
                Status = E_FAIL;
            }
        }


     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }
     return Status;

}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetCachedSessions(DWORD dCachedSessions)
{
    // TODO: Add your implementation code here
    LONG Status = 0;
    HKEY Handle = NULL;

    if(RegServerAccessCheck(KEY_ALL_ACCESS))
    {
        return E_ACCESSDENIED;
    }

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ | KEY_SET_VALUE, &Handle );
    if ( Status == ERROR_SUCCESS )
    {
        Status = RegSetValueEx(Handle,REG_CITRIX_IDLEWINSTATIONPOOLCOUNT,
                              0,REG_DWORD,(const BYTE *)&dCachedSessions,
                              sizeof(dCachedSessions));

     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }

    return Status;
}

#endif // removed

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetDelDirsOnExit(BOOL * pDelDirsOnExit)
{
    HKEY Handle = NULL;
      DWORD ValueBuffer = 0;
    DWORD ValueType = 0;
    LONG Status = 0;

    DWORD ValueSize = sizeof(ValueBuffer);

    if(NULL == pDelDirsOnExit)
    {
        return E_INVALIDARG;
    }

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ, &Handle );
    if ( Status == ERROR_SUCCESS )
    {

        Status = RegQueryValueEx( Handle,
                                  REG_CITRIX_DELETETEMPDIRSONEXIT,
                                  NULL,
                                  &ValueType,
                                  (LPBYTE) &ValueBuffer,
                                  &ValueSize );
        if ( Status == ERROR_SUCCESS )
        {
            if(ValueType == REG_DWORD)
            {
                if(ValueBuffer)
                {
                    *pDelDirsOnExit = TRUE;
                }
                else
                {
                    *pDelDirsOnExit = FALSE;
                }
            }
            else
            {
                Status = E_FAIL;
            }
        }


     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }
     return Status;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetDelDirsOnExit(BOOL bDelDirsOnExit)
{
    LONG Status = 0;
    HKEY Handle = NULL;

    /* admin only
    if(RegServerAccessCheck(KEY_ALL_ACCESS))
    {
        return E_ACCESSDENIED;
    }
    */
    if( !m_bAdmin )
    {
        ODS( L"CCfgComp::SetDelDirsOnExit not admin\n" );        

        return E_ACCESSDENIED;
    }    

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ | KEY_SET_VALUE, &Handle );
    if ( Status == ERROR_SUCCESS )
    {
        Status = RegSetValueEx(Handle,REG_CITRIX_DELETETEMPDIRSONEXIT,
                              0,REG_DWORD,(const BYTE *)&bDelDirsOnExit,
                              sizeof(bDelDirsOnExit));

     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }

    return Status;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetUseTempDirPerSession(BOOL * pbTempDir)
{
    HKEY Handle = NULL;
      DWORD ValueBuffer = 0;
    DWORD ValueType = 0;
    LONG Status = 0;

    DWORD ValueSize = sizeof(ValueBuffer);

    if(NULL == pbTempDir)
    {
        return E_INVALIDARG;
    }

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ, &Handle );
    if ( Status == ERROR_SUCCESS )
    {

        Status = RegQueryValueEx( Handle,
                                  REG_TERMSRV_PERSESSIONTEMPDIR,
                                  NULL,
                                  &ValueType,
                                  (LPBYTE) &ValueBuffer,
                                  &ValueSize );
        if ( Status == ERROR_SUCCESS )
        {
            if(ValueType == REG_DWORD)
            {
                if(ValueBuffer)
                {
                    *pbTempDir = TRUE;
                }
                else
                {
                    *pbTempDir = FALSE;
                }
            }
            else
            {
                Status = E_FAIL;
            }
        }


     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }
     return Status;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetUseTempDirPerSession(BOOL bTempDirPerSession)
{
    LONG Status = 0;
    HKEY Handle = NULL;

    /* admin only bugid294645
    if(RegServerAccessCheck(KEY_ALL_ACCESS))
    {
        return E_ACCESSDENIED;
    }
    */
    if( !m_bAdmin )
    {
        ODS( L"CCfgComp::SetUseTempDirPerSession not admin\n" );        

        return E_ACCESSDENIED;
    }

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ | KEY_SET_VALUE, &Handle );
    if ( Status == ERROR_SUCCESS )
    {
        Status = RegSetValueEx(Handle,REG_TERMSRV_PERSESSIONTEMPDIR,
                              0,REG_DWORD,(const BYTE *)&bTempDirPerSession,
                              sizeof(bTempDirPerSession));

     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }

    return Status;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetInternetConLic( BOOL *pbInternetConLic , PDWORD pdwStatus )
{
    // shouldn't be called on post-Win2000 machines
    _ASSERTE( FALSE );

    UNREFERENCED_PARAMETER(pbInternetConLic);

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = ERROR_NOT_SUPPORTED;

    return E_FAIL;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetInternetConLic( BOOL bInternetConLic , PDWORD pdwStatus )
{
    // shouldn't be called on post-Win2000 machines
    _ASSERTE( FALSE );

    UNREFERENCED_PARAMETER(bInternetConLic);

    if( pdwStatus == NULL )
    {        
        return E_INVALIDARG;
    }

    *pdwStatus = ERROR_NOT_SUPPORTED;

    return E_FAIL;
}


//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetLicensingMode( ULONG * pulMode , PDWORD pdwStatus )
{
    BOOL fRet;
    HRESULT hr = S_OK;

    if( NULL == pulMode || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    HANDLE hServer = ServerLicensingOpen(NULL);

    if (NULL == hServer)
    {
        *pdwStatus = GetLastError();
        return E_FAIL;
    }

    fRet = ServerLicensingGetPolicy(
                                    hServer,
                                    pulMode
                                    );
    if (fRet)
    {
        *pdwStatus = ERROR_SUCCESS;
    }
    else
    {
        *pdwStatus = GetLastError();
        hr = E_FAIL;
    }

    ServerLicensingClose(hServer);

    return hr;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetLicensingModeInfo( ULONG ulMode , WCHAR **pwszName, WCHAR **pwszDescription, PDWORD pdwStatus )
{
#define MAX_LICENSING_STRING_LEN 1024
    UINT                nNameResource, nDescResource;
    int                 nRet;

    if( NULL == pwszName || NULL == pwszDescription || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = ERROR_SUCCESS;
    *pwszName = NULL;
    *pwszDescription = NULL;

    switch (ulMode)
    {
        case 1:
            nNameResource = IDS_LICENSING_RA_NAME;
            nDescResource = IDS_LICENSING_RA_DESC;
            break;
        case 2:
            nNameResource = IDS_LICENSING_PERSEAT_NAME;
            nDescResource = IDS_LICENSING_PERSEAT_DESC;
            break;
        case 4:
            nNameResource = IDS_LICENSING_PERSESSION_NAME;
            nDescResource = IDS_LICENSING_PERSESSION_DESC;
            break;
        default:
            return E_INVALIDARG;
            break;
    }

    *pwszName = (WCHAR *) CoTaskMemAlloc((MAX_LICENSING_STRING_LEN+1)*sizeof(WCHAR));

    if (NULL == *pwszName)
    {
        *pdwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto return_failure;
    }

    *pwszDescription = (WCHAR *) CoTaskMemAlloc((MAX_LICENSING_STRING_LEN+1)*sizeof(WCHAR));

    if (NULL == *pwszDescription)
    {
        *pdwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto return_failure;
    }

    nRet = LoadString(g_hInstance,
                      nNameResource,
                      *pwszName,
                      MAX_LICENSING_STRING_LEN+1);

    if (0 == nRet)
    {
        *pdwStatus = GetLastError();
        goto return_failure;
    }

    nRet = LoadString(g_hInstance,
                      nDescResource,
                      *pwszDescription,
                      MAX_LICENSING_STRING_LEN+1);

    if (0 == nRet)
    {
        *pdwStatus = GetLastError();
        goto return_failure;
    }
    
    return S_OK;

return_failure:
    if (NULL != *pwszName)
    {
        CoTaskMemFree(*pwszName);
        *pwszName = NULL;
    }

    if (NULL != *pwszDescription)
    {
        CoTaskMemFree(*pwszDescription);
        *pwszDescription = NULL;
    }

    return E_FAIL;
}


//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetLicensingModeList( ULONG *pcModes , ULONG **prgulModes, PDWORD pdwStatus )
{
    ULONG       *rgulModes = NULL;
    BOOL        fRet;
    HRESULT     hr = S_OK;

    if( NULL == pcModes || NULL == prgulModes || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    HANDLE hServer = ServerLicensingOpen(NULL);

    if (NULL == hServer)
    {
        *pdwStatus = GetLastError();
        return E_FAIL;
    }

    fRet = ServerLicensingGetAvailablePolicyIds(
                                            hServer,
                                            &rgulModes,
                                            pcModes
                                            );

    if (fRet)
    {
        *pdwStatus = ERROR_SUCCESS;

        *prgulModes = (ULONG *) CoTaskMemAlloc((*pcModes)*sizeof(ULONG));

        if (NULL != *prgulModes)
        {
            memcpy(*prgulModes,rgulModes,(*pcModes)*sizeof(ULONG));
        }
        else
        {
            *pdwStatus = ERROR_NOT_ENOUGH_MEMORY;
            hr = E_FAIL;
        }

        LocalFree(rgulModes);
    }
    else
    {
        *pdwStatus = GetLastError();
        hr = E_FAIL;
    }

    return hr;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetLicensingMode( ULONG ulMode , PDWORD pdwStatus, PDWORD pdwNewStatus )
{
    if( pdwStatus == NULL || pdwNewStatus == NULL )
    {        
        return E_INVALIDARG;
    }

    HANDLE hServer = ServerLicensingOpen(NULL);

    if (NULL == hServer)
    {
        *pdwStatus = GetLastError();
        return E_FAIL;
    }

    *pdwStatus = ServerLicensingSetPolicy(hServer,
                                        ulMode,
                                        pdwNewStatus);

    ServerLicensingClose(hServer);

    return ((*pdwStatus == ERROR_SUCCESS) && (*pdwNewStatus == ERROR_SUCCESS)) ? S_OK : E_FAIL;
}

//-----------------------------------------------------------------------------
// pUserPerm ==  TRUE if security is relaxed
// FALSE for tight security
//-----------------------------------------------------------------------------

STDMETHODIMP CCfgComp::SetUserPerm( BOOL bUserPerm , PDWORD pdwStatus )
{
	if( !m_bAdmin )
	{
		ODS( L"CFGBKEND:SetUserPerm not admin\n" );

		return E_ACCESSDENIED;
	}

	if( pdwStatus == NULL )
	{
		ODS( L"CFGBKEND-SetUserPerm invalid arg\n" );

		return E_INVALIDARG;
	}

	HKEY hKey;

	*pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
							   REG_CONTROL_TSERVER,
							   0 ,
							   KEY_READ | KEY_SET_VALUE,
							   &hKey );


    if( *pdwStatus != ERROR_SUCCESS )
    {
		DBGMSG( L"CFGBKEND-SetUserPerm RegOpenKeyEx failed 0x%x\n", *pdwStatus );

		return E_FAIL;
	}

	*pdwStatus = RegSetValueEx( hKey ,
								L"TSUserEnabled" ,
								0 ,
								REG_DWORD ,
								( const PBYTE )&bUserPerm ,
								sizeof( BOOL ) );

	if( *pdwStatus != ERROR_SUCCESS )
	{
		DBGMSG( L"CFGBKEND-SetUserPerm RegSetValueEx failed 0x%x\n" , *pdwStatus );

		return E_FAIL;
	}

	RegCloseKey( hKey );

	return S_OK;
}

//-----------------------------------------------------------------------------
// pUserPerm ==  TRUE if security is relaxed
// FALSE for tight security
//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetUserPerm( BOOL *pbUserPerm  , PDWORD pdwStatus )
{
	HKEY hKey;

	DWORD dwSize = sizeof( DWORD );

    DWORD dwValue;

    if( pbUserPerm == NULL || pdwStatus == NULL )
    {
		ODS( L"CFGBKEND-GetUserPerm invalid arg\n" );

        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
							   REG_CONTROL_TSERVER,
							   0 ,
							   KEY_READ ,
							   &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
	{
		DBGMSG( L"CFGBKEND-GetUserPerm RegOpenKeyEx failed 0x%x\n", *pdwStatus );

		return E_FAIL;
	}

	*pdwStatus = RegQueryValueEx( hKey,
                                  L"TSUserEnabled",
                                  NULL,                                  
                                  NULL,
                                  ( LPBYTE )&dwValue,
                                  &dwSize );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        DBGMSG( L"CFGBKEND-GetUserPerm RegQueryValueEx failed 0x%x\n", *pdwStatus );

		// not a true failure this means the key does not exist
        // set to one for relaxed security

        dwValue = 1;

        *pdwStatus = S_OK;
	}

    RegCloseKey( hKey );

    *pbUserPerm =  !( ( BOOL )( dwValue == 0 ) );

    return S_OK;
}

#if 1
//-----------------------------------------------------------------------------
//Private function
//-----------------------------------------------------------------------------
void CCfgComp::GetPdConfig( WDNAME WdKey,WINSTATIONCONFIG2W& WsConfig)
{
    LONG Status;
    PDCONFIG3 PdConfig;PDCONFIG3 PdSelected;PDCONFIG3 PdConfig2;
    ULONG Index = 0, Entries, ByteCount = sizeof(PDNAME);
    PDNAME PdKey;
    // BOOL bFound = FALSE;

    ULONG ByteCount2 = sizeof(PDNAME);
    ULONG Index1 = 1; // start off with one since WsConfig.Pd[0] is already populated
    
    do
    {
        Entries = 1;
        // outer loop searches for keys in /Wds / ( wdname ) /Tds
        Status = RegPdEnumerate(NULL,WdKey,TRUE,&Index,&Entries,PdKey,&ByteCount);

        if(Status != ERROR_SUCCESS)
        {
           break;
        }

        Status = RegPdQuery( NULL,WdKey,TRUE,PdKey,&PdConfig,sizeof(PdConfig),&ByteCount );

        if(Status != ERROR_SUCCESS)
        {
           break;
        }

        if(0 == lstrcmpi(WsConfig.Pd[0].Create.PdName, PdConfig.Data.PdName))
        {
            PdSelected = PdConfig;
            // bFound = TRUE;
            // 
            ULONG Index2 = 0;
            
            do
            {   
                // innerloop forces the search in Wds/ (wdname )/ Pds
                // Index must now be set to zero so that we get the first item

                Status = RegPdEnumerate(NULL,WdKey,FALSE,&Index2,&Entries,PdKey,&ByteCount2);

                if(Status != ERROR_SUCCESS)
                {
                      break;
                }
                
                Status = RegPdQuery( NULL,WdKey,FALSE,PdKey,&PdConfig2,sizeof(PdConfig),&ByteCount2);
                

                if(Status != ERROR_SUCCESS)
                {
                      break;
                }
                
                for( UINT i = 0; i < PdSelected.RequiredPdCount ; i++)
                {
                    if(0 == lstrcmpi(PdSelected.RequiredPds[i],PdConfig2.Data.PdName))
                    {
                        WsConfig.Pd[Index1].Create = PdConfig2.Data;
                        WsConfig.Pd[Index1].Params.SdClass = PdConfig2.Data.SdClass;
                        Index1++;

                        if(Index1 > MAX_PDCONFIG)
                        {
                            break;
                        }
                    }
                }
                
            }while(1);

        }

        /*
        if(bFound)
        {
            break;
        }
        */

     }while(1);

    return;
}

#endif 

#if 0
//-----------------------------------------------------------------------------
//Private function
//-----------------------------------------------------------------------------
void CCfgComp::GetPdConfig( WDNAME WdKey,WINSTATIONCONFIG2W& WsConfig)
{
    LONG Status;
    PDCONFIG3 PdConfig;
	PDCONFIG3 PdSelected;
	PDCONFIG3 PdConfig2;

    ULONG Index = 0, Entries = 1, ByteCount = sizeof(PDNAME);
    PDNAME PdKey;
    BOOL bFound = FALSE;

    ULONG ByteCount2 = sizeof(PDNAME);
    ULONG Index1 = 1;
    do
    {
        Status = RegPdEnumerate(NULL,WdKey,TRUE,&Index,&Entries,PdKey,&ByteCount);
        if(Status != ERROR_SUCCESS)
        {
           break;
        }
        
		// we could speed this up by enumerating only for the protocol type

		/*
		Status = RegPdQuery( NULL,WdKey,TRUE,PdKey,&PdConfig,sizeof(PdConfig),&ByteCount );
        if(Status != ERROR_SUCCESS)
        {
           break;
        }
		*/
		DBGMSG( L"CFGBKEND: PdKey is at first %ws\n", PdKey );

		DBGMSG( L"CFGBKEND: WsConfig.Pd[0].Create.PdName is %ws\n", WsConfig.Pd[0].Create.PdName );

        if( 0 == lstrcmpi(WsConfig.Pd[0].Create.PdName, PdKey ) ) //PdConfig.Data.PdName))
        {
			Status = RegPdQuery( NULL,WdKey,TRUE,PdKey,&PdConfig,sizeof(PdConfig),&ByteCount );

			if(Status != ERROR_SUCCESS)
			{
				break;
			}

            PdSelected = PdConfig;

            bFound = TRUE;

			// why didn't we reset Index to zero?

			Index = 0;

			// why didn't we reset Entries back to one?

			Entries = 1;

            do
            {
				DBGMSG( L"CFGBKEND: WdKey is %ws\n" , WdKey );

				DBGMSG( L"CFGBKEND: PdKey before Enum is %ws\n", PdKey );

				
                Status = RegPdEnumerate(NULL,WdKey,FALSE,&Index,&Entries,PdKey,&ByteCount2);

                if(Status != ERROR_SUCCESS)
                {
                      break;
                }
				
				DBGMSG( L"CFGBKEND: PdKey is %ws\n", PdKey );

                Status = RegPdQuery( NULL,WdKey,FALSE,PdKey,&PdConfig2,sizeof(PdConfig),&ByteCount2);

                if(Status != ERROR_SUCCESS)
                {
					ODS(L"RegPdQuery failed\n" );
                      break;
                }

				ODS(L"RegPdQuery ok\n" );
				
				
                for( UINT i = 0; i < PdSelected.RequiredPdCount ; i++)
                {
					DBGMSG( L"CFGBKEND: Required pd name %s\n", PdConfig2.Data.PdName );

					DBGMSG( L"CFGBKEND: ReqName is list is %s\n", PdSelected.RequiredPds[i] );

                    if( 0 == lstrcmpi( PdSelected.RequiredPds[i] , PdConfig2.Data.PdName ) )
                    {
						DBGMSG( L"CFGBKEND: Copying pdconfig2 for pd name %s\n" , PdConfig2.Data.PdName );

                        WsConfig.Pd[Index1].Create = PdConfig2.Data;

                        WsConfig.Pd[Index1].Params.SdClass = PdConfig2.Data.SdClass;

                        Index1++;

                        if(Index1 > MAX_PDCONFIG)
                        {
                            break;
                        }
                    }
                }
				

            }while(1);

        }

        if(bFound)
        {
            break;
        }

     }while(1);

    return;
}

#endif 
#if 0 // removed for final
//-----------------------------------------------------------------------------
//Private function
//-----------------------------------------------------------------------------
BOOL CCfgComp::CompareSD(PSECURITY_DESCRIPTOR pSd1,PSECURITY_DESCRIPTOR pSd2)
{
    DWORD dwErr;
    ULONG index1 = 0;
    //int index2 = 0;
    ULONG    cAce1 = 0;
    EXPLICIT_ACCESS *pAce1 = NULL;

    ULONG    cAce2 = 0;
    EXPLICIT_ACCESS *pAce2 = NULL;
    BOOL bMatch = TRUE;

    if (!IsValidSecurityDescriptor(pSd1) || !IsValidSecurityDescriptor(pSd2))
    {
        return FALSE;
    }

    dwErr = LookupSecurityDescriptorParts(
             NULL,
             NULL,
             &cAce1,
             &pAce1,
             NULL,
             NULL,
             pSd1);
    if (ERROR_SUCCESS != dwErr)
    {
        return FALSE;
    }
    dwErr = LookupSecurityDescriptorParts(
             NULL,
             NULL,
             &cAce2,
             &pAce2,
             NULL,
             NULL,
             pSd2);
    if (ERROR_SUCCESS != dwErr)
    {
        bMatch = FALSE;
        goto cleanup;
    }
    if(cAce1 != cAce2)
    {
        bMatch = FALSE;
        goto cleanup;
    }
    for(index1 = 0; index1 < cAce1; index1++)
    {
        //for(index2 = 0; index2 < cAce1; index2++)
        {
            if ( _tcscmp(GetTrusteeName(&pAce1[index1].Trustee),GetTrusteeName(&pAce2[index1].Trustee)) ||
                (pAce1[index1].grfAccessPermissions != pAce2[index1].grfAccessPermissions)||
                (pAce1[index1].grfAccessMode != pAce2[index1].grfAccessMode ))
            {
                bMatch = FALSE;
                break;
            }

        }
    }

cleanup:
    if(pAce1)
    {
        LocalFree(pAce1);
    }
    if(pAce2)
    {
        LocalFree(pAce2);
    }
    return bMatch;

}

#endif

//-----------------------------------------------------------------------------
BOOL CCfgComp::RegServerAccessCheck(REGSAM samDesired)
{
    LONG Status = 0;
    HKEY Handle = NULL;

    /*
     * Attempt to open the registry
     * at the requested access level.
     */
    if ( (Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                                 samDesired, &Handle )) == ERROR_SUCCESS  )
    {
        RegCloseKey( Handle );
    }

    return( Status );

}

#if 0 // removed for final release
//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetDefaultSecurity(ULONG * pDefaultSecurity)
{
    HRESULT hResult = S_OK;
    //Check the parameters
    if(NULL == pDefaultSecurity)
    {
        return E_INVALIDARG;
    }

    *pDefaultSecurity = 0;

    PSECURITY_DESCRIPTOR pDefaultDescriptor = NULL;
    PSECURITY_DESCRIPTOR pTempDescriptor = NULL;

    pDefaultDescriptor = ReadSecurityDescriptor(0);
    if(NULL == pDefaultDescriptor)
    {
        *pDefaultSecurity = 0;
        return hResult;
    }

    for(int i = 0; i < NUM_DEFAULT_SECURITY; i++)
    {
        pTempDescriptor = ReadSecurityDescriptor(i+1);
        if(NULL == pTempDescriptor)
        {
            continue;
        }
        if(TRUE == CompareSD(pDefaultDescriptor,pTempDescriptor))
        {
            *pDefaultSecurity = i+1;
            break;
        }
        else
        {
            LocalFree(pTempDescriptor);
            pTempDescriptor = NULL;
        }
    }

    if(pDefaultDescriptor)
    {
        LocalFree(pDefaultDescriptor);
    }
    if(pTempDescriptor)
    {
        LocalFree(pTempDescriptor);
    }
    return hResult;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetDefaultSecurity(ULONG Offset)
{
    HRESULT hResult;

    if( !m_bAdmin )
    {
        return E_ACCESSDENIED;
    }

    if(0 == Offset)
    {
        return E_INVALIDARG;
    }

    PSECURITY_DESCRIPTOR pTempDescriptor = NULL;

    pTempDescriptor = ReadSecurityDescriptor(Offset);

    if(NULL == pTempDescriptor)
    {
        return E_FAIL;
    }

    hResult = SetDefaultSecurityDescriptor( pTempDescriptor );

    if( pTempDescriptor != NULL )
    {
        LocalFree(pTempDescriptor);
    }

    return hResult;
}

//-----------------------------------------------------------------------------
PSECURITY_DESCRIPTOR CCfgComp::ReadSecurityDescriptor(ULONG index)
{
    PBYTE pData = NULL;
    TCHAR * pValue = NULL;
    HLOCAL hLocal;
    HKEY Handle = NULL;
    DWORD ValueType = 0;
    DWORD ValueSize=0;
    LONG Status = 0;

    switch(index)
    {

    case 0:
        pValue = REG_DEF_SECURITY;
        break;
    case 1:
        pValue = REG_REMOTE_SECURITY;
        break;
    case 2:
        pValue = REG_APPL_SECURITY;
        break;
    case 3:
        pValue = REG_ANON_SECURITY;
        break;

    default:
        return NULL;
    }

    if(NULL == pValue)
    {
        return NULL;
    }

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                       KEY_READ, &Handle );
    if ( Status == ERROR_SUCCESS )
    {

        Status = RegQueryValueEx( Handle,
                                  pValue,
                                  NULL,
                                  &ValueType,
                                  NULL,
                                  &ValueSize );
        if(Status != ERROR_SUCCESS)
        {
            return NULL;
        }
        hLocal = LocalAlloc(LMEM_FIXED, ValueSize);
        if(NULL == hLocal)
        {
            return pData;
        }
        pData = (LPBYTE)LocalLock(hLocal);
        if(NULL == pData)
        {
            return NULL;
        }
        Status = RegQueryValueEx( Handle,
                                  pValue,
                                  NULL,
                                  &ValueType,
                                  pData,
                                  &ValueSize );
        if(Status != ERROR_SUCCESS)
        {
            RegCloseKey(Handle);
            LocalFree(pData);
            return NULL;
        }


     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }
     return (PSECURITY_DESCRIPTOR)pData;

}

//-----------------------------------------------------------------------------
HRESULT CCfgComp::SetDefaultSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurity)
{
    if(NULL == pSecurity)
    {
        return E_INVALIDARG;
    }

    if(ValidateSecurityDescriptor(pSecurity)!=ERROR_SUCCESS)
    {
        return E_INVALIDARG;
    }

    HKEY Handle = NULL;
    LONG Status = 0;
    ULONG Size = 0;

    Size = GetSecurityDescriptorLength(pSecurity);

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                       KEY_READ |KEY_SET_VALUE , &Handle );
    if ( Status == ERROR_SUCCESS )
    {
        Status = RegSetValueEx(Handle,
                               REG_DEF_SECURITY,
                               0,
                               REG_BINARY,
                               (BYTE *)pSecurity,
                               Size);
        if(Status != ERROR_SUCCESS)
        {
            return E_FAIL;
        }

    }

    if( Handle )
    {
        RegCloseKey(Handle);
    }


    if( !_WinStationReInitializeSecurity( SERVERNAME_CURRENT ) )
    {
        ODS( L"CFGBKEND: _WinStationReInitializeSecurity failed\n" );

        return E_FAIL;
    }



    return S_OK;
}

#endif //

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetActiveDesktopState( /* in */ BOOL bActivate , /* out */ PDWORD pdwStatus )
{
        // HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\NoActiveDesktop
        if( !m_bAdmin )
        {
                ODS( L"CFGBKEND : SetActiveDesktopState caller does not have admin rights\n" );

                *pdwStatus = ERROR_ACCESS_DENIED;

                return E_ACCESSDENIED;

        }

        // try to open key

        HKEY hKey;

        *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                                                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer" ) ,
                                                        0,
                                                        KEY_READ | KEY_WRITE ,
                                                        &hKey );

        if( *pdwStatus != ERROR_SUCCESS )
        {
                if( bActivate )
                {
                        ODS( L"CFGBKEND : SetActiveDesktopState -- RegOpenEx unable to open key\n" );

                        return E_FAIL;
                }
                else
                {
                        // the key doesn't exist but we were trying to disable anyway donot pro
                        // we should assert( 0 ) here  because we should not be disabling what
                        // could not have been enabled

                        return S_FALSE;
                }
        }

        if( !bActivate )
        {
                DWORD dwValue = 1;

                *pdwStatus = RegSetValueEx( hKey ,
                                                                    TEXT( "NoActiveDesktop" ),
                                                                        NULL,
                                                                        REG_DWORD,
                                                                        ( LPBYTE )&dwValue ,
                                                                        sizeof( DWORD ) );
        }
        else
        {
                *pdwStatus = RegDeleteValue( hKey , TEXT( "NoActiveDesktop" ) );
        }

        RegCloseKey( hKey );


        if( *pdwStatus != NO_ERROR )
        {
                ODS( L"CFGBKEND : SetActiveDesktopState returned error\n" );

                return E_FAIL;
        }


        return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetActiveDesktopState( /* out */ PBOOL pbActive , /* out */PDWORD pdwStatus)
{
        if( pbActive == NULL )
        {
                ODS( L"CFGBKEND : GetActiveDesktop -- invaild arg\n" );

                return E_INVALIDARG;
        }

                // try to open key

        HKEY hKey;

        *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                                                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer" ) ,
                                                        0,
                                                        KEY_READ ,
                                                        &hKey );

        if( *pdwStatus != ERROR_SUCCESS )
        {
                ODS( L"CFGBKEND : GetActiveDesktopState -- RegOpenEx unable to open key\n" );

                return E_FAIL;

        }

        DWORD dwData = 0;

        DWORD dwSize = sizeof( DWORD );

        *pdwStatus = RegQueryValueEx( hKey ,
                                      TEXT( "NoActiveDesktop" ) ,
                                      NULL ,
                                      NULL ,
                                      ( LPBYTE )&dwData ,
                                      &dwSize );

        // Status of this key is enabled if the key does not exist

        if( *pdwStatus == ERROR_SUCCESS )
        {
                *pbActive = !( BOOL )dwData;
        }

        RegCloseKey( hKey );

        if( *pdwStatus != ERROR_SUCCESS )
        {
                DBGMSG( L"CFGBKEND : GetActiveDesktopState -- error ret 0x%x\n" , *pdwStatus );

                if( *pdwStatus == ERROR_FILE_NOT_FOUND )
                {
                        *pbActive = TRUE;

                        return S_FALSE;
                }

                return E_FAIL;
        }

        return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetTermSrvMode( /* out */ PDWORD pdwMode , PDWORD pdwStatus )
{
    ODS( L"CFGBKEND : GetTermSrvMode\n" );

    if( pdwMode == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    HKEY hKey;

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               REG_CONTROL_TSERVER,
                               0,
                               KEY_READ ,
                               &hKey );

        if( *pdwStatus != ERROR_SUCCESS )
        {
                ODS( L"CFGBKEND : GetTermSrvMode -- RegOpenEx unable to open key\n" );

                return E_FAIL;

        }

        DWORD dwData = 0;

        DWORD dwSize = sizeof( DWORD );

        *pdwStatus = RegQueryValueEx( hKey ,
                                  TEXT( "TSAppCompat" ) ,
                                  NULL ,
                                  NULL ,
                                  ( LPBYTE )&dwData ,
                                  &dwSize );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetTermSrvMode -- RegQueryValueEx failed\n" );

        *pdwMode = 1; // for application server
    }
    else
    {
        *pdwMode = dwData;

    }

    RegCloseKey( hKey );

    return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetSalemHelpMode( BOOL *pVal, PDWORD pdwStatus)
{
    HKEY hKey;

    ODS( L"CFGBKEND : GetSalemHelpMode\n" );

    if( pVal == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               REG_CONTROL_GETHELP,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetSalemHelpMode -- RegOpenEx unable to open key\n" );
        *pVal = 1;   // default to help is available

        // don't want to fail caller so return S_OK
        return S_OK;
    }

    DWORD dwData = 0;

    DWORD dwSize = sizeof( DWORD );

    *pdwStatus = RegQueryValueEx( hKey ,
                              POLICY_TS_REMDSK_ALLOWTOGETHELP,
                              NULL ,
                              NULL ,
                              ( LPBYTE )&dwData ,
                              &dwSize );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetSalemHelpMode -- RegQueryValueEx failed\n" );
        *pVal = 1; // assume help is available
    }
    else
    {
        *pVal = dwData;

    }

    RegCloseKey( hKey );
    return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetSalemHelpMode( BOOL val, PDWORD pdwStatus )
{
    HKEY hKey;

    ODS( L"CFGBKEND : SetSalemHelpMode\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REG_CONTROL_GETHELP,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetSalemHelpMode -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    DWORD dwValue;
    dwValue = (val) ? 1 : 0;

    *pdwStatus = RegSetValueEx(
                            hKey,
                            POLICY_TS_REMDSK_ALLOWTOGETHELP,
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwValue,
                            sizeof(DWORD)
                        );

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}

//-----------------------------------------------------------------------------
HRESULT CCfgComp::GetSingleSessionState( BOOL *pVal, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server" );


    ODS( L"CFGBKEND : GetSingleSessionState\n" );

    if( pVal == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               tchRegPath ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {        
        ODS( L"CFGBKEND : GetSingleSessionState -- RegOpenKeyEx unable to open key\n" );
        
        return S_OK;
    }

    DWORD dwData = 0;

    DWORD dwSize = sizeof( DWORD );

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"fSingleSessionPerUser",
                              NULL ,
                              NULL ,
                              ( LPBYTE )&dwData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {        
        *pVal = dwData;
    }
    else
    {
        ODS( L"CFGBKEND : GetSingleSessionState -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );
    return S_OK;
}

//----------------------------------------------------------------------------

HRESULT CCfgComp::SetSingleSessionState( BOOL val, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server" );

    ODS( L"CFGBKEND : SetSingleSessionState\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    
    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            tchRegPath,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetSingleSessionState -- RegCreateKeyEx failed\n" );

        if (ERROR_ACCESS_DENIED == *pdwStatus)
            return E_ACCESSDENIED;
        else
            return E_FAIL;
    }

    DWORD dwValue;
    dwValue = (val) ? 1 : 0;

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"fSingleSessionPerUser",
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwValue,
                            sizeof(DWORD)
                        );

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}


//-----------------------------------------------------------------------------
HRESULT CCfgComp::GetColorDepth ( PWINSTATIONNAME pWs, BOOL *pVal, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server\\winstations\\" );

	if(pWs != NULL)
	{
		lstrcat( tchRegPath , pWs );
	}

    ODS( L"CFGBKEND : GetColorDepth\n" );

    if( pVal == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               tchRegPath ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetColorDepth -- RegOpenKeyEx unable to open key\n" );
       
        return E_FAIL;
    }

    DWORD dwData = 0;

    DWORD dwSize = sizeof( DWORD );

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"fInheritColorDepth",
                              NULL ,
                              NULL ,
                              ( LPBYTE )&dwData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {         
        *pVal = dwData;
    }
    else
    {
        ODS( L"CFGBKEND : GetColorDepth -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );

    return S_OK;
}

//----------------------------------------------------------------------------

HRESULT CCfgComp::SetColorDepth( PWINSTATIONNAME pWs, BOOL val, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server\\winstations\\" );

	if(pWs != NULL)
	{
		lstrcat( tchRegPath , pWs );
	}

    ODS( L"CFGBKEND : SetColorDepth\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            tchRegPath ,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetColorDepth -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    DWORD dwValue;
    dwValue = (val) ? 1 : 0;

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"fInheritColorDepth",
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwValue,
                            sizeof(DWORD)
                        );

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}





//-----------------------------------------------------------------------------
HRESULT CCfgComp::GetKeepAliveTimeout ( PWINSTATIONNAME pWs, BOOL *pVal, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server\\winstations\\" );

    if(pWs != NULL)
    {
	    lstrcat( tchRegPath , pWs );
    }

    ODS( L"CFGBKEND : GetKeepAliveTimeout\n" );

    if( pVal == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               tchRegPath ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetKeepAliveTimeout -- RegOpenKeyEx unable to open key\n" );
       
        return E_FAIL;
    }

    DWORD dwData = 0;

    DWORD dwSize = sizeof( DWORD );

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"KeepAliveTimeout",
                              NULL ,
                              NULL ,
                              ( LPBYTE )&dwData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {         
        *pVal = dwData;
    }
    else
    {
        ODS( L"CFGBKEND : GetKeepAliveTimeout -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );

    return S_OK;
}

//----------------------------------------------------------------------------

HRESULT CCfgComp::SetKeepAliveTimeout( PWINSTATIONNAME pWs, BOOL val, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server\\winstations\\" );

	if(pWs != NULL)
	{
		lstrcat( tchRegPath , pWs );
	}

    ODS( L"CFGBKEND : SetKeepAliveTimeout\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            tchRegPath ,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetKeepAliveTimeout -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    DWORD dwValue;
    dwValue = (val) ? 1 : 0;

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"KeepAliveTimeout",
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwValue,
                            sizeof(DWORD)
                        );

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}




//-----------------------------------------------------------------------------
HRESULT CCfgComp::GetDenyTSConnections ( BOOL *pVal, PDWORD pdwStatus )
{
    HKEY hKey;

    ODS( L"CFGBKEND : GetDenyTSConnections\n" );

    if( pVal == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               REG_CONTROL_TSERVER  ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetDenyTSConnections -- RegOpenKeyEx unable to open key\n" );        

        return S_OK;
    }

    DWORD dwData = 0;

    DWORD dwSize = sizeof( DWORD );

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"fDenyTSConnections",
                              NULL ,
                              NULL ,
                              ( LPBYTE )&dwData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {
        *pVal = dwData;
    }
    else
    {
        ODS( L"CFGBKEND : GetDenyTSConnections -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );
    return S_OK;
}

//----------------------------------------------------------------------------

HRESULT CCfgComp::SetDenyTSConnections( BOOL val, PDWORD pdwStatus )
{
    HKEY hKey;

    ODS( L"CFGBKEND : SetDenyTSConnections\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REG_CONTROL_TSERVER ,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetDenyTSConnections -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    DWORD dwValue;
    dwValue = (val) ? 1 : 0;

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"fDenyTSConnections",
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwValue,
                            sizeof(DWORD)
                        );

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}

//-----------------------------------------------------------------------------

HRESULT CCfgComp::GetProfilePath ( BSTR *pbstrVal, PDWORD pdwStatus )
{
    HKEY hKey;
    DWORD dwSize = 0;
    static TCHAR tchData[ MAX_PATH ] ;
    dwSize = sizeof( tchData);

    ODS( L"CFGBKEND : GetProfilePath\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               REG_CONTROL_TSERVER  ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetProfilePath -- RegOpenKeyEx unable to open key\n" );        

        return E_FAIL;
    }

    dwSize = sizeof( tchData );

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"WFProfilePath",
                              NULL ,
                              NULL ,
                              (LPBYTE)&tchData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {
        *pbstrVal = SysAllocString (tchData);
    }
    else
    {
        ODS( L"CFGBKEND : GetProfilePath -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );

    return S_OK;
}


//----------------------------------------------------------------------------

HRESULT CCfgComp::SetProfilePath( BSTR bstrVal, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server" );

    ODS( L"CFGBKEND : SetProfilePath\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    
    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            tchRegPath,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetProfilePath -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"WFProfilePath",
                            0,
                            REG_SZ,
                            ( LPBYTE const )(bstrVal) ,
                            (lstrlen(bstrVal)+1)*sizeof(WCHAR)
                            );

    ODS( L"CFGBKEND : SetProfilePath -- RegCreateKeyEx failed\n" );

    if(bstrVal != NULL)
    {
        SysFreeString(bstrVal);
    }

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}



//-----------------------------------------------------------------------------

HRESULT CCfgComp::GetHomeDir ( BSTR *pbstrVal, PDWORD pdwStatus )
{
    HKEY hKey;
    DWORD dwSize = 0;
    static TCHAR tchData[ MAX_PATH ] ;
    dwSize = sizeof( tchData);

    ODS( L"CFGBKEND : GetHomeDir\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               REG_CONTROL_TSERVER  ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetProfilePath -- RegOpenKeyEx unable to open key\n" );        

        return E_FAIL;
    }

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"WFHomeDir",
                              NULL ,
                              NULL ,
                              (LPBYTE)&tchData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {
        *pbstrVal = SysAllocString (tchData);
    }
    else
    {
        ODS( L"CFGBKEND : GetHomeDir -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );

    return S_OK;
}


//----------------------------------------------------------------------------

HRESULT CCfgComp::SetHomeDir( BSTR bstrVal, PDWORD pdwStatus )
{
    HKEY hKey = NULL;    

    ODS( L"CFGBKEND : SetHomeDir\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REG_CONTROL_TSERVER ,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    

    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetHomeDir -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"WFHomeDir",
                            0,
                            REG_SZ,
                            ( LPBYTE const )(bstrVal) ,
                            (lstrlen(bstrVal)+1)*sizeof(WCHAR)
                        );
    if(bstrVal != NULL)
    {
        SysFreeString(bstrVal);
    }

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetWdKey( WCHAR *wdname ,  WCHAR *wdkey )
{
    if( wdname == NULL || wdkey == NULL )
    {
        return E_INVALIDARG;
    }

    PWD pWD = GetWdObject( wdname );

    if(NULL == pWD)
    {
        return E_FAIL;
    }

    lstrcpy( wdkey , pWD->wdKey );

    return S_OK;
}

/*=-----------------------------------------------------------------------------

  pwszWinstaName  -- name of winstation to modify.
  pwszAccountName -- is the netbios name of the user we want to modify.
  dwMask          -- winstation specific access.
  fDel            -- TRUE to delete all DACL or SACL for the specifed 
                     account if it exist, FALSE to add entry.
  fAllow          -- TRUE to allow, FALSE to deny, parameter ignored if
                     fDel is set to TRUE
  fNew            -- TRUE removes all existing entries for this account
                     FALSE no action taken, parameter ignored if fDel
                     is set to TRUE.
  fAuditing       -- TRUE, modify SACL, FALSE modify DACL.
  pdwStatus       -- status of operation

Remark:


    fDel    fNew        Operation
    ------- -------     ------------------------------------------
    TRUE    ignored     Delete all entries for the specified user.
    FALSE   TRUE        Delete all entries then add allow or deny
                        entry for the specified user.
    FALSE   FALSE       Add allow or deny entry for the specified user,
                        no modify to existing entries.

 =----------------------------------------------------------------------------*/
STDMETHODIMP CCfgComp::ModifyUserAccess( WCHAR *pwszWinstaName ,
                                         WCHAR *pwszAccountName ,
                                         DWORD  dwMask ,
                                         BOOL   fDel ,
                                         BOOL   fAllow ,
                                         BOOL   fNew ,
                                         BOOL   fAuditing ,
                                         PDWORD pdwStatus )
{
    return ModifyWinstationSecurity( FALSE, 
                                     pwszWinstaName,
                                     pwszAccountName,
                                     dwMask,
                                     fDel,
                                     fAllow,
                                     fNew,
                                     fAuditing,
                                     pdwStatus
                                );
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::ModifyDefaultSecurity( WCHAR *pwszWinstaName ,
                                              WCHAR *pwszAccountName ,
                                              DWORD  dwMask ,
                                              BOOL   fDel ,
                                              BOOL   fAllow ,
                                              BOOL   fAuditing ,
                                              PDWORD pdwStatus )
{
    HRESULT hr = S_OK;

    if( NULL == pwszWinstaName || 0 == lstrlen(pwszWinstaName) )
    {
        for( DWORD i = 0; i < g_numDefaultSecurity && SUCCEEDED(hr) ; i++ )
        {
            hr = ModifyWinstationSecurity( 
                                     TRUE, 
                                     g_pszDefaultSecurity[i],
                                     pwszAccountName,
                                     dwMask,
                                     fDel,
                                     fAllow,
                                     FALSE,     // never recreate default security
                                     fAuditing,
                                     pdwStatus
                                );
        }
    }
    else
    {
        hr = ModifyWinstationSecurity( 
                                    TRUE, 
                                    pwszWinstaName,
                                    pwszAccountName,
                                    dwMask,
                                    fDel,
                                    fAllow,
                                    FALSE,     // never recreate default security
                                    fAuditing,
                                    pdwStatus
                                );
    }


    return hr;
}

DWORD
CCfgComp::GetUserSid(
    LPCTSTR pwszAccountName,
    PSID* ppUserSid
    )
/*++

Abstract:

    Retrieve User SID for user account.

Parameter:

    pwszAccountName : Name of the account to retrieve SID.
    ppUserSid : Pointer to PSID to receive SID for the account.

Returns:

    ERROR_SUCCESS or Error Code

Note :

    Retrieve only local account or domain account.

--*/
{
    DWORD cbSid = 0;
    DWORD cbDomain = 0;
    PSID pSID = NULL;
    LPTSTR pszDomain = NULL;
    BOOL bStatus;
    DWORD dwStatus = ERROR_SUCCESS;    
    SID_NAME_USE seUse;   

    bStatus = LookupAccountName( 
                            NULL ,
                            pwszAccountName ,
                            NULL ,
                            &cbSid,
                            NULL ,
                            &cbDomain,
                            &seUse);

    if( FALSE == bStatus )
    {
        dwStatus = GetLastError();
        if( ERROR_INSUFFICIENT_BUFFER != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }
    }

    dwStatus = ERROR_SUCCESS;

    pSID = ( PSID )LocalAlloc( LMEM_FIXED , cbSid );
    pszDomain = ( LPTSTR )LocalAlloc( LMEM_FIXED , sizeof(WCHAR) * (cbDomain + 1) );

    if( pSID == NULL || pszDomain == NULL )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( !LookupAccountName( NULL ,
                            pwszAccountName ,
                            pSID ,
                            &cbSid,
                            pszDomain ,
                            &cbDomain,
                            &seUse ) )
    {
        dwStatus = GetLastError();
    }
    else
    {
        *ppUserSid = pSID;
        pSID = NULL;
    }


CLEANUPANDEXIT:

    if( NULL != pszDomain )
    {
        LocalFree( pszDomain );
    }

    if( NULL != pSID )
    {
        LocalFree( pSID );
    }

    return dwStatus;
}    


DWORD
CCfgComp::RemoveUserEntriesInACL( 
    LPCTSTR pszUserName,
    PACL pAcl,
    PACL* ppNewAcl
    )
/*++

Abstract :

    Remote all DACL or SACL from ACL for the account.

Parameters:

    pszUserName : Name of the user account to be removed from ACL list.
    pAcl : Pointer to ACL.
    ppNewAcl : Pointer to PACL to receive resulting ACL.


Returns:

    ERROR_SUCCESS
    ERROR_FILE_NOT_FOUND    All ACL are flagged as INHERITED_ACE.
    other error code

--*/
{
    DWORD dwStatus;
    DWORD dwNumNewEntries = 0;
    PSID pUserSid = NULL;
    ULONG cbExplicitEntries = 0;
    PEXPLICIT_ACCESS prgExplicitEntries = NULL;
    PEXPLICIT_ACCESS prgExplicitEntriesNew = NULL;

    // 
    // We can use this funtion since we don't use INHERITED_ACE
    //
    dwStatus = GetExplicitEntriesFromAcl( 
                                    pAcl ,
                                    &cbExplicitEntries,
                                    &prgExplicitEntries
                                );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    if( 0 == cbExplicitEntries )
    {
        dwStatus = ERROR_FILE_NOT_FOUND;
        goto CLEANUPANDEXIT;
    }

    dwStatus = GetUserSid( pszUserName, &pUserSid );
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    // create a big enough buffer
    prgExplicitEntriesNew = ( PEXPLICIT_ACCESS )LocalAlloc( LMEM_FIXED , sizeof( EXPLICIT_ACCESS ) * cbExplicitEntries );
    if( prgExplicitEntriesNew == NULL )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }
                
    for( ULONG idx = 0 ; idx < cbExplicitEntries; idx++ )
    {
        if( prgExplicitEntries[ idx ].Trustee.TrusteeForm == TRUSTEE_IS_SID )
        {
            if( !EqualSid( pUserSid, prgExplicitEntries[ idx ].Trustee.ptstrName ) )
            {
                // this one we can keep
                // copy over EXPLICIT_ACCESS
                prgExplicitEntriesNew[ dwNumNewEntries ].grfAccessPermissions = prgExplicitEntries[ idx ].grfAccessPermissions;
                prgExplicitEntriesNew[ dwNumNewEntries ].grfAccessMode = prgExplicitEntries[ idx ].grfAccessMode;
                prgExplicitEntriesNew[ dwNumNewEntries ].grfInheritance = prgExplicitEntries[ idx ].grfInheritance;

                BuildTrusteeWithSid( &prgExplicitEntriesNew[ dwNumNewEntries ].Trustee , prgExplicitEntries[ idx ].Trustee.ptstrName );
                dwNumNewEntries++;
            }
        }
    }

    dwStatus = SetEntriesInAcl( 
                            dwNumNewEntries,
                            prgExplicitEntriesNew, 
                            NULL, 
                            ppNewAcl 
                        );

CLEANUPANDEXIT:

    if( pUserSid != NULL )
    {
        LocalFree( pUserSid );
    }

    if( prgExplicitEntriesNew != NULL )
    {
        LocalFree( prgExplicitEntriesNew );
    }

    if( NULL != prgExplicitEntries )
    {
        LocalFree( prgExplicitEntries );
    }

    return dwStatus;
}


HRESULT
CCfgComp::ModifyWinstationSecurity(
        BOOL bDefaultSecurity,          
        WCHAR *pwszWinstaName ,
        WCHAR *pwszAccountName ,
        DWORD  dwMask , 
        BOOL   fDel ,       // delete existing ACL entries for user passed in
        BOOL   fAllow ,     // Grant/Deny ACL
        BOOL   fNew ,       // New entries
        BOOL   fAuditing ,
        PDWORD pdwStatus 
        )
/*++

Abstract :

    Modify specific winstation security.

Parameters:

    bDefaultSecurity : TRUE to modify default security, FALSE otherwise.  Current
                       default security are ConsoleSecurity and DefaultSecurity.
    pwszWinstaName : Name of the winstation or default security to be modified, if
                     bDefaultSecurity is TRUE, valid winstation name are ConsoleSecurity 
                     and DefaultSecurity.
    pwszAccountName : is the netbios name of the user we want to modify.
    dwMask          : winstation specific access.
    fDel            : TRUE to delete all DACL or SACL for the specifed 
                      account if it exist, FALSE to add entry.
    fAllow          : TRUE to allow, FALSE to deny, parameter ignored if
                      fDel is set to TRUE
    fNew            : TRUE removes all existing entries for this account
                      FALSE no action taken, parameter ignored if fDel
                      is set to TRUE.
    fAuditing       : TRUE, modify SACL, FALSE modify DACL.
    pdwStatus       : Return status of operation

Returns:

    S_OK, E_FAIL, E_INVALIDARG, win32 status code is returned via *pdwStatus.

Remark:


    fDel    fNew        Operation
    ------- -------     ------------------------------------------
    TRUE    ignored     Delete all entries for the specified user.
    FALSE   TRUE        Delete all entries then add allow or deny
                        entry for the specified user.
    FALSE   FALSE       Add allow or deny entry for the specified user,
                        no modify to existing entries.

--*/
{
    EXPLICIT_ACCESS ea;
    HRESULT hr;
    PACL pNewAcl = NULL;
    PACL pAcl    = NULL;

    BOOL bOwnerDefaulted    = FALSE;
    BOOL bDaclDefaulted     = FALSE;
    BOOL bDaclPresent       = FALSE;
    BOOL bSaclPresent       = FALSE;
    BOOL bSaclDefaulted     = FALSE;

    PSECURITY_DESCRIPTOR pSD;
    LONG lSize = 0;
    DWORD dwSDLen = 0;
    PACL pSacl = NULL;       
    PACL pDacl = NULL;
   
    PSECURITY_DESCRIPTOR pNewSD = NULL;

    if( pwszAccountName == NULL || pdwStatus == NULL )
    {
        ODS( L"CCfgComp::ModifyUserAccess -- invalid arg\n" );

        return E_INVALIDARG;
    }

    *pdwStatus = 0;

    if( TRUE == bDefaultSecurity )
    {
        if( FALSE == ValidDefaultSecurity( pwszWinstaName ) )
        {
            *pdwStatus = ERROR_INVALID_PARAMETER;
            return E_INVALIDARG;
        }
    }
    else if( pwszWinstaName == NULL  )
    {
        *pdwStatus = ERROR_INVALID_PARAMETER;
        return E_INVALIDARG;
    }
    
    hr = GetWinStationSecurity( bDefaultSecurity, pwszWinstaName , &pSD );

    if( FAILED( hr ) )
    {
        //Try Getting Default Security Descriptor
        hr = GetWinStationSecurity(TRUE, NULL, &pSD);
    }

    if( SUCCEEDED( hr ) )
    {
        if( pSD != NULL )
        {
            lSize = GetSecurityDescriptorLength(pSD);
        }
        else
        {
            hr = E_FAIL;
            *pdwStatus = ERROR_INTERNAL_ERROR;
        }
    }
    else
    {
        *pdwStatus = ERROR_INTERNAL_ERROR;
        return hr;
    }
    
    if( fAuditing )
    {
        if( pSD != NULL && !GetSecurityDescriptorSacl( pSD ,
                                        &bSaclPresent,
                                        &pAcl,
                                        &bSaclDefaulted ) )
        {
            *pdwStatus = GetLastError( ) ;

            hr = E_FAIL;
        }
    }
    else
    {        
        if( pSD != NULL && !GetSecurityDescriptorDacl( pSD ,
                                        &bDaclPresent,
                                        &pAcl,
                                        &bDaclDefaulted ) )
        {
            *pdwStatus = GetLastError( ) ;

            hr = E_FAIL;
        }
    }

    // remove all entries for this user
    
    if( SUCCEEDED( hr ) )
    {        
        if( fNew || fDel )
        {
            // SetEntriesInAcl() does not remove DENY_ACCESS ACL,
            // pAcl will point to DACL or SACL depends on fAuditing
            // flag.
            *pdwStatus = RemoveUserEntriesInACL( 
                                                pwszAccountName,
                                                pAcl,
                                                &pNewAcl
                                            );

            if( *pdwStatus == ERROR_SUCCESS)
            {
                // DO NOTHING.
            }
            else if( *pdwStatus == ERROR_FILE_NOT_FOUND )
            {
                pNewAcl = pAcl;
                *pdwStatus = ERROR_SUCCESS;
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    if( SUCCEEDED(hr) && !fDel )
    {
        // auditing is requested build SACL

        if( fAuditing )
        {            

            BuildExplicitAccessWithName( &ea , 
                                         pwszAccountName ,
                                         dwMask ,
                                         fAllow ? SET_AUDIT_SUCCESS : SET_AUDIT_FAILURE ,
                                         NO_INHERITANCE );

            *pdwStatus = SetEntriesInAcl( 1 , &ea , pAcl , &pNewAcl );

            if( *pdwStatus != ERROR_SUCCESS )
            {
                hr = E_FAIL;
            }
        }
        else
        {
            BuildExplicitAccessWithName( &ea , 
                                         pwszAccountName ,
                                         dwMask ,
                                         fAllow ? GRANT_ACCESS : DENY_ACCESS ,
                                         NO_INHERITANCE );

            *pdwStatus = SetEntriesInAcl( 1 , &ea , pAcl , &pNewAcl );

            if( *pdwStatus != ERROR_SUCCESS )
            {
                hr = E_FAIL;
            }
        }
    }

    // re-build SD.

    ULONG cbExplicitEntriesDACL = 0;
    PEXPLICIT_ACCESS prgExplicitEntriesDACL = NULL;
    ULONG cbExplicitEntriesSACL = 0;
    PEXPLICIT_ACCESS prgExplicitEntriesSACL = NULL;


    if( SUCCEEDED( hr ) )
    {
    
        if( fAuditing )
        {

            if( GetExplicitEntriesFromAcl( pNewAcl ,
                                           &cbExplicitEntriesSACL ,
                                           &prgExplicitEntriesSACL ) != ERROR_SUCCESS )
            {
                ODS( L"CFGBKEND! GetExplicitEntriesFromAcl failed\n" );

                *pdwStatus = GetLastError();

                hr = E_FAIL;
            }

            if( !GetSecurityDescriptorDacl( pSD , &bDaclPresent , &pDacl , &bDaclDefaulted ) )
            {
                ODS( L"CFGBKEND! GetSecurityDescriptorDacl failed\n" );

                *pdwStatus = GetLastError();

                hr = E_FAIL;
            }
            else 
            {
                if( GetExplicitEntriesFromAcl( pDacl ,
                                               &cbExplicitEntriesDACL ,
                                               &prgExplicitEntriesDACL ) != ERROR_SUCCESS )
                {
                    ODS( L"CFGBKEND! GetExplicitEntriesFromAcl failed\n" );

                    *pdwStatus = GetLastError();

                    hr = E_FAIL;
                }
            }

        }
        else
        {
            if( GetExplicitEntriesFromAcl( pNewAcl ,
                                           &cbExplicitEntriesDACL ,
                                           &prgExplicitEntriesDACL ) != ERROR_SUCCESS )
            {
                ODS( L"CFGBKEND! GetExplicitEntriesFromAcl failed\n" );

                *pdwStatus = GetLastError();

                hr = E_FAIL;
            }

            if( !GetSecurityDescriptorSacl( pSD , &bSaclPresent , &pSacl , &bSaclDefaulted ) )
            {
                ODS( L"CFGBKEND! GetSecurityDescriptorSacl failed\n" );

                *pdwStatus = GetLastError();

                hr = E_FAIL;
            }
            else
            {                              

                if( GetExplicitEntriesFromAcl( pSacl ,
                                               &cbExplicitEntriesSACL ,
                                               &prgExplicitEntriesSACL ) != ERROR_SUCCESS )
                {
                    ODS( L"CFGBKEND! GetExplicitEntriesFromAcl failed\n" );

                    *pdwStatus = GetLastError();

                    hr = E_FAIL;
                }
            }
        }


        if( SUCCEEDED(hr) )
        {
            TRUSTEE trustmeOwner;
            PSID pOwner;

            if( !GetSecurityDescriptorOwner( pSD , &pOwner , &bOwnerDefaulted ) )
            {
                ODS( L"CFGBKEND! GetSecurityDescriptorOwner failed\n" );

                *pdwStatus = GetLastError();
                hr = E_FAIL;
            }

            if( SUCCEEDED( hr ) )
            {
                BuildTrusteeWithSid( &trustmeOwner , pOwner );

                *pdwStatus = BuildSecurityDescriptor( &trustmeOwner ,
                                         &trustmeOwner ,
                                         cbExplicitEntriesDACL ,
                                         prgExplicitEntriesDACL,
                                         cbExplicitEntriesSACL,
                                         prgExplicitEntriesSACL,
                                         NULL,
                                         &dwSDLen , 
                                         &pNewSD );

                hr = HRESULT_FROM_WIN32( *pdwStatus );
            }

            if( SUCCEEDED( hr ) )
            {
                hr = SetSecurityDescriptor( bDefaultSecurity, pwszWinstaName , dwSDLen , pNewSD );
            
                if( pNewSD != NULL )
                {
                    LocalFree( pNewSD );
                }
            }
        }
    }


    if( NULL != prgExplicitEntriesDACL )
    {
        LocalFree( prgExplicitEntriesDACL );
    }

    if( NULL != prgExplicitEntriesSACL )
    {
        LocalFree( prgExplicitEntriesSACL );
    }

    if( pSD != NULL )
    {
        LocalFree( pSD );
    }
        
    //
    // pNewAcl might point to pAcl, check RemoteUserEntriesInAcl() on above.
    //
    if( pNewAcl != NULL && pNewAcl != pAcl )
    {
        LocalFree( pNewAcl );
    }

    return hr;
    
}


/*=----------------------------------------------------------------------------------------------------------------
  GetUserPermList
  [ in ] pwszWinstaName Name of winstation
  [ out] pcbItems       The number of items in the user permission list
  [ out] ppUserPermList structure defined in idldefs.h

 =----------------------------------------------------------------------------------------------------------------*/
STDMETHODIMP CCfgComp::GetUserPermList( WCHAR *pwszWinstaName , PDWORD pcbItems , PUSERPERMLIST *ppUserPermList , BOOL fAudit )
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL bAclDefaulted;
    BOOL bAclPresent;
    PACL pAcl = NULL;
    LONG lSize;
    ULONG cbExplicitEntries = 0;
    PEXPLICIT_ACCESS prgExplicitEntries = NULL;


    hr = GetSecurityDescriptor( pwszWinstaName , &lSize , &pSD );

    if( SUCCEEDED( hr ) )
    {
        if( fAudit )
        {
            if( !GetSecurityDescriptorSacl( pSD ,
                                            &bAclPresent,
                                            &pAcl,
                                            &bAclDefaulted ) )
            { 
                ODS( L"CFGBKEND!GetUserPermList GetSecurityDescriptorSacl failed\n" );

                hr = E_FAIL;
            }
        }
        else if( !GetSecurityDescriptorDacl( pSD ,
                                             &bAclPresent,
                                             &pAcl,
                                             &bAclDefaulted ) )
        { 
            ODS( L"CFGBKEND!GetUserPermList GetSecurityDescriptorDacl failed\n" );

            hr = E_FAIL;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        if( GetExplicitEntriesFromAcl( pAcl ,
                                       &cbExplicitEntries ,
                                       &prgExplicitEntries ) != ERROR_SUCCESS )
        {
            ODS( L"CFGBKEND!GetUserPermList GetExplicitEntriesFromAcl failed\n" );

            hr = E_FAIL;
        }

        *pcbItems = cbExplicitEntries;
    }

    if( SUCCEEDED( hr ) )
    {
        *ppUserPermList = ( PUSERPERMLIST )CoTaskMemAlloc( sizeof( USERPERMLIST ) * cbExplicitEntries );

        if( *ppUserPermList != NULL )
        {
            for( ULONG i = 0; i < cbExplicitEntries; ++i )
            {
                ( *ppUserPermList )[ i ].Name[ 0 ] = 0;
                ( *ppUserPermList )[ i ].Sid[ 0 ] = 0;

                if( prgExplicitEntries[ i ].Trustee.TrusteeForm == TRUSTEE_IS_SID )
                {
                    WCHAR szDomain[ 120 ];
                    WCHAR szUser[ 128 ];
                    DWORD dwSizeofName = sizeof( szUser  ) / sizeof( WCHAR );
                    DWORD dwSizeofDomain = sizeof( szDomain ) / sizeof( WCHAR );
                    SID_NAME_USE snu;                

                    if( LookupAccountSid( NULL ,
                                          prgExplicitEntries[ i ].Trustee.ptstrName ,
                                          szUser ,
                                          &dwSizeofName ,
                                          szDomain , 
                                          &dwSizeofDomain ,
                                          &snu ) )
                    {
                        if( dwSizeofDomain > 0 )
                        {
                            lstrcpy( ( *ppUserPermList )[ i ].Name , szDomain );
                            lstrcat( ( *ppUserPermList )[ i ].Name , L"\\" );
                        }

                        lstrcat( ( *ppUserPermList )[ i ].Name , szUser );

                        LPTSTR pszSid = NULL;

                        if( ConvertSidToStringSid( prgExplicitEntries[ i ].Trustee.ptstrName , &pszSid ) )
                        {
                            if( pszSid != NULL )
                            {
                                lstrcpyn( ( *ppUserPermList )[ i ].Sid , pszSid , 256 );
                            
                                LocalFree( pszSid );
                            }
                        }
                    }

                }
                else if( prgExplicitEntries[ i ].Trustee.TrusteeForm == TRUSTEE_IS_NAME )
                {
                    lstrcpy( ( *ppUserPermList )[ i ].Name , GetTrusteeName( &prgExplicitEntries[ i ].Trustee ) );

                    // todo reverse lookup for sid
                    // not sure if we'll ever need this
                }
                
                ( *ppUserPermList )[ i ].Mask = prgExplicitEntries[ i ].grfAccessPermissions;

                ( *ppUserPermList )[ i ].Type = prgExplicitEntries[ i ].grfAccessMode;
            }
        }
        else
        {
            ODS( L"CFGBKEND!GetUserPermList no mem for UserPermList\n" );

            hr = E_OUTOFMEMORY;
        }
    }

    if( prgExplicitEntries != NULL )
    {
        LocalFree( prgExplicitEntries );
    }

    if( pSD != NULL )
    {
        LocalFree( pSD );
    }

    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CCfgComp::UpdateSessionDirectory( PDWORD pdwStatus )
{
    HRESULT hr = S_OK;

    if( !_WinStationUpdateSettings( SERVERNAME_CURRENT,
            WINSTACFG_SESSDIR ,
            0 ) )    
    {
        hr = E_FAIL;
    }

    *pdwStatus = GetLastError( );

    return hr;
}
//-----------------------------------------------------------------------------

/*****************************************************************************
 *
 *  TestUserForAdmin
 *
 *   Returns whether the current thread is running under admin
 *   security.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 * alhen
 *
 * Code is from
 *   HOWTO: Determine if Running In User Context of Local Admin Acct
 *          Last reviewed: March 4, 1998
 *          Article ID: Q118626
 *
 * corrected by alhen "common coding errors"
 *
 *
 ****************************************************************************/

BOOL TestUserForAdmin( )
{

    PSID psidAdministrators = NULL;

    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

    BOOL bSuccess;

        BOOL bIsMember = FALSE;


        bSuccess = AllocateAndInitializeSid( &siaNtAuthority , 2 ,

                                    SECURITY_BUILTIN_DOMAIN_RID,

                                    DOMAIN_ALIAS_RID_ADMINS,

                                    0, 0, 0, 0, 0, 0,

                                    &psidAdministrators );

    if( bSuccess )
        {
                CheckTokenMembership( NULL , psidAdministrators , &bIsMember );

                FreeSid( psidAdministrators );
        }

    return bIsMember;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\cfgcomp\stdafx.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\cfgcomp\ptrarray.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name: 
*
*			Ptrarray.h
*
* Abstract:
*			This is file has declaration of CPtrArray class borrowed from MFC
* 
* Author:
*
* 
* Revision:  
*    
*
************************************************************************************************/


#ifndef PTRARRAY_H_
#define PTRARRAY_H_

class CPtrArray 
{
public:

// Construction
	CPtrArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(int nIndex) const;
	void SetAt(int nIndex, void* newElement);
	void*& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const void** GetData() const;
	void** GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, void* newElement);
	int Add(void* newElement);
	int Append(const CPtrArray& src);
	void Copy(const CPtrArray& src);

	// overloaded operator helpers
	void* operator[](int nIndex) const;
	void*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, void* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CPtrArray();
protected:
	// local typedefs for class templates
//	typedef void* BASE_TYPE;
//	typedef void* BASE_ARG_TYPE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\cfgcomp\ptrarray.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name: 
*
*			Ptrarray.cpp
*
* Abstract:
*			This is file has implementation of CPtrArray class borrowed from MFC
* 
* Author:
*
* 
* Revision:  
*    
*
************************************************************************************************/


#include "stdafx.h"
#include "PtrArray.h"
#include <windows.h>
#include <assert.h>


CPtrArray::CPtrArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CPtrArray::~CPtrArray()
{
	delete[] (BYTE*)m_pData;
}

void CPtrArray::SetSize(int nNewSize, int nGrowBy)
{

	assert(nNewSize >= 0);

	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		delete[] (BYTE*)m_pData;
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		assert(nNewSize <= SIZE_T_MAX/sizeof(void*));    // no overflow
#endif
		m_pData = (void**) new BYTE[nNewSize * sizeof(void*)];

        if( m_pData != NULL )
        {
            memset(m_pData, 0, nNewSize * sizeof(void*));  // zero fill
            m_nSize = m_nMaxSize = nNewSize;
        }
        else
        {
            m_nSize = m_nMaxSize = 0;
        }

	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements

			memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));

		}

		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = min(1024, max(4, m_nSize / 8));
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		assert(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
		assert(nNewMax <= SIZE_T_MAX/sizeof(void*)); // no overflow
#endif
		void** pNewData = (void**) new BYTE[nNewMax * sizeof(void*)];

		// copy new data from old
        if( pNewData != NULL )
        {
            memcpy(pNewData, m_pData, m_nSize * sizeof(void*));
        
		    // construct remaining elements
		    assert(nNewSize > m_nSize);

		    memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));
        
    		// get rid of old stuff (note: no destructors called)
	    	delete[] (BYTE*)m_pData;
		    m_pData = pNewData;
		    m_nSize = nNewSize;
		    m_nMaxSize = nNewMax;
        }
	}
}

int CPtrArray::Append(const CPtrArray& src)
{
	assert(this != &src);   // cannot append to itself

	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);

	memcpy(m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(void*));

	return nOldSize;
}

void CPtrArray::Copy(const CPtrArray& src)
{

	assert(this != &src);   // cannot append to itself

	SetSize(src.m_nSize);

	if( m_pData != NULL )
    {
        memcpy(m_pData, src.m_pData, src.m_nSize * sizeof(void*));
    }

}

void CPtrArray::FreeExtra()
{

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		assert(m_nSize <= SIZE_T_MAX/sizeof(void*)); // no overflow
#endif
		void** pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (void**) new BYTE[m_nSize * sizeof(void*)];
			// copy new data from old
            if( pNewData != NULL )
            {
                memcpy(pNewData, m_pData, m_nSize * sizeof(void*));
            }
            else
            {
                m_nSize = 0;
            }
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

/////////////////////////////////////////////////////////////////////////////

void CPtrArray::SetAtGrow(int nIndex, void* newElement)
{

	assert(nIndex >= 0);

	if (nIndex >= m_nSize)
    {
        SetSize(nIndex+1);
    }
    
    if( m_pData != NULL )
    {
        m_pData[nIndex] = newElement;
    }
}

void CPtrArray::InsertAt(int nIndex, void* newElement, int nCount)
{

	assert(nIndex >= 0);    // will expand to meet need
	assert(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount);  // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount);  // grow it to new size
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(void*));

		// re-init slots we copied from

		memset(&m_pData[nIndex], 0, nCount * sizeof(void*));

	}

	// insert new value in the gap
	assert(nIndex + nCount <= m_nSize);
	while (nCount--)
		m_pData[nIndex++] = newElement;
}

void CPtrArray::RemoveAt(int nIndex, int nCount)
{
	assert(nIndex >= 0);
	assert(nCount >= 0);
	assert(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);

	if (nMoveCount)
		memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(void*));
	m_nSize -= nCount;
}

void CPtrArray::InsertAt(int nStartIndex, CPtrArray* pNewArray)
{
	assert(pNewArray != NULL);
	assert(nStartIndex >= 0);

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}

int CPtrArray::GetSize() const
	{ return m_nSize; }
int CPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
void CPtrArray::RemoveAll()
	{ SetSize(0); }
void* CPtrArray::GetAt(int nIndex) const
	{ assert(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
void CPtrArray::SetAt(int nIndex, void* newElement)
	{ assert(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
void*& CPtrArray::ElementAt(int nIndex)
	{ assert(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
const void** CPtrArray::GetData() const
	{ return (const void**)m_pData; }
void** CPtrArray::GetData()
	{ return (void**)m_pData; }
int CPtrArray::Add(void* newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
void* CPtrArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
void*& CPtrArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\sdk\lib\lib.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "tswiz_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\sdk\xss\lib\lib.c ===
//Copyright (c) 2000 Microsoft Corporation
#include "SrvSetEx_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\asyncdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

#ifndef _ASYNCDLG_H
#define _ASYNCDLG_H

#define ULONG_DIGIT_MAX 12
#define UINT_DIGIT_MAX 7
#define UCHAR_DIGIT_MAX 5

#define WM_ADDWINSTATION        (WM_USER + 0)
#define WM_LISTINITERROR        (WM_USER + 1)
#define WM_EDITSETFIELDSERROR   (WM_USER + 2)
#define WM_ASYNCTESTERROR       (WM_USER + 3)
#define WM_ASYNCTESTABORT       (WM_USER + 4)
#define WM_ASYNCTESTSTATUSREADY (WM_USER + 5)
#define WM_ASYNCTESTINPUTREADY  (WM_USER + 6)
#define WM_ASYNCTESTWRITECHAR   (WM_USER + 7)

#define NUM_LEDS    6
#define MAX_COMMAND_LEN 255


////////////////////////////////////////////////////////////////////////////////
class CAsyncDlg
{
    HWND m_hDlg;

    ICfgComp * m_pCfgcomp;

    INT_PTR m_nHexBase;

    TCHAR m_szWinstation[ WINSTATIONNAME_LENGTH + 1 ];

    TCHAR m_szWDName[ WDNAME_LENGTH + 1 ];

    INT m_nOldAsyncDeviceNameSelection;

    INT m_nOldAsyncConnectType;

    INT m_nOldBaudRate;

    INT m_nOldModemCallBack;
    
public:

    ASYNCCONFIG m_ac;

    ASYNCCONFIG m_oldAC;

    USERCONFIG m_uc;


public:

    CAsyncDlg( );

    BOOL OnInitDialog( HWND , LPTSTR , LPTSTR , ICfgComp * );

    void OnClickedAsyncModemcallbackPhonenumberInherit( );

    void OnClickedAsyncModemcallbackInherit( );

    void OnClickedModemProperties();

    BOOL OnSelchangeAsyncDevicename( );

    BOOL OnSelchangeAsyncConnect();

    BOOL OnSelchangeAsyncModemcallback() ;

    void OnSelchangeAsyncModemcallbackPhoneNumber() ;


    BOOL OnSelchangeAsyncBaudrate();

   
    BOOL OnCommand( WORD , WORD , HWND , PBOOL );

    HRESULT SetDefaults( );

    HRESULT DoAsyncAdvance( );

    BOOL DoAsyncTest( );

    BOOL AsyncRelease( );

    BOOL GetAsyncFields(ASYNCCONFIG& AsyncConfig,USERCONFIG UsrCfg);

    HRESULT SetAsyncFields(ASYNCCONFIG& AsyncConfig , PUSERCONFIG );
   
};

////////////////////////////////////////////////////////////////////////////////
class CAdvancedAsyncDlg 
{

/*
 * Member variables.
 */
    
public:
    ASYNCCONFIG m_Async;
    BOOL m_bReadOnly;
    BOOL m_bModem;
    INT_PTR m_nHexBase;
    ULONG m_nWdFlag;
    HWND m_hDlg;
    ICfgComp *m_pCfgcomp;

/* 
 * Implementation.
 */
public:
    CAdvancedAsyncDlg();

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL OnCommand( WORD , WORD , HWND );

    int GetCheckedRadioButton( int , int );

    BOOL OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp );

/*
 * Operations.
 */
protected:
    BOOL HandleEnterEscKey(int nID);
    void SetFields();
    void SetHWFlowText();
    void SetGlobalFields();
    void SetHWFields();
    void SetSWFields();
    BOOL GetFields();
    void GetFlowControlFields();
    BOOL GetGlobalFields();
    BOOL GetHWFields();
    BOOL GetSWFields( BOOL bValidate );

/*
 * Message map / commands.
 */
protected:
    
    void OnClickedAsyncAdvancedFlowcontrolHardware();
    void OnClickedAsyncAdvancedFlowcontrolSoftware();
    void OnClickedAsyncAdvancedFlowcontrolNone();
    void OnClickedAsyncAdvancedBasedec();
    void OnClickedAsyncAdvancedBasehex();
    void OnCloseupAsyncAdvancedHwrx();
    void OnSelchangeAsyncAdvancedHwrx();
    void OnCloseupAsyncAdvancedHwtx();
    void OnSelchangeAsyncAdvancedHwtx();
    void OnOK();
    void OnCancel();
    


}; 

////////////////////////////////////////////////////////////////////////////////
class cwnd
{
public:

    HWND m_hWnd;

    WNDPROC m_oldproc;

};


////////////////////////////////////////////////////////////////////////////////
// CEchoEditControl class
//
class CEchoEditControl : public cwnd
{
friend class CAsyncTestDlg;

/*
 * Member variables.
 */
public:
    BOOL m_bProcessingOutput;
    HWND m_hDlg;
    int m_FontHeight;
    int m_FontWidth;
    int m_FormatOffsetX;
    int m_FormatOffsetY;

/*
 * Message map / commands.
 */
    
    void OnChar (UINT nChar, UINT nRepCnt, UINT nFlags);

    void SubclassDlgItem( HWND , int  );

    static LRESULT CALLBACK WndProc( HWND , UINT , WPARAM , LPARAM );
    
};  // end CEchoEditControl class interface

////////////////////////////////////////////////////////////////////////////////
// CLed class
//
class CLed : public cwnd
{

private:
    HBRUSH          m_hBrush;
    BOOL            m_bOn;

/* 
 * Implementation.
 */
public:
    CLed( HBRUSH hBrush );

/*
 * Operations.
 */
public:
    void Subclass( HWND , int  );
    void Update(int nOn);
    void Toggle();

/*
 * Message map / commands.
 */


    void OnPaint( HWND );

    static LRESULT CALLBACK WndProc( HWND , UINT , WPARAM , LPARAM );


};


////////////////////////////////////////////////////////////////////////////////
class CThread
{

/*
 * Member variables.
 */
public:
    HANDLE m_hThread;
    DWORD m_dwThreadID;

/*
 * Implementation
 */
public:

    virtual ~CThread();


    CThread();

    static DWORD __stdcall ThreadEntryPoint(LPVOID lpParam);

    virtual DWORD RunThread() = 0;

/*
 * Operations: primary thread
 */

    HANDLE CreateThread( DWORD cbStack = 0 , DWORD fdwCreate = 0 );

};  // end CThread class interface

////////////////////////////////////////////////////////////////////////////////
// CATDlgInputThread class
//
#define MAX_STATUS_SEMAPHORE_COUNT 1
#define MAX_SLEEP_COUNT 10

class CATDlgInputThread : public CThread
{

/*
 * Member variables.
 */
public:
    HWND m_hDlg;
    HANDLE m_hDevice;
    ASYNCCONFIG m_ac;
    PROTOCOLSTATUS m_Status;
    BYTE m_Buffer[MAX_COMMAND_LEN+1];
    DWORD m_BufferBytes;

    DWORD m_ErrorStatus;
    HANDLE m_hConsumed;
    BOOL m_bExit;
    DWORD m_EventMask;
    OVERLAPPED m_OverlapSignal;
    OVERLAPPED m_OverlapRead;

/*
 * Implementation
 */

    CATDlgInputThread();

    virtual ~CATDlgInputThread();
    virtual DWORD RunThread();

/*
 * Operations: primary thread.
 */

    void SignalConsumed();
    void ExitThread();

/*
 * Operations: secondary thread.
 */

    void NotifyAbort( UINT idError );
    int CommInputNotify();
    int CommStatusAndNotify();
    int PostInputRead();
    int PostStatusRead();

};  // end CATDlgInputThread class interface



///////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg class
//

class CAsyncTestDlg 
{

/*
 * Member variables.
 */
    HWND m_hDlg;

    ICfgComp * m_pCfgComp;

    
    
public:
    ASYNCCONFIG m_ac;
    PDCONFIG m_PdConfig1;
    PWINSTATIONNAME m_pWSName;
    CEchoEditControl m_EditControl;

protected:
    
    HANDLE  m_hDevice;
    HBRUSH  m_hRedBrush;
    UINT_PTR  m_LEDToggleTimer;
    PROTOCOLSTATUS m_Status;
    CATDlgInputThread *m_pATDlgInputThread;
    OVERLAPPED m_OverlapWrite;
    BYTE    m_Buffer[MAX_COMMAND_LEN+1];
    INT_PTR m_CurrentPos;
    DWORD   m_BufferBytes;
    TCHAR   m_szModemInit[MAX_COMMAND_LEN+1];
    TCHAR   m_szModemDial[MAX_COMMAND_LEN+1];
    TCHAR   m_szModemListen[MAX_COMMAND_LEN+1];
    HANDLE  m_hModem;
    BOOL    m_bDeletedWinStation;
    CLed *  m_pLeds[NUM_LEDS];
    WINSTATIONCONFIG2 m_WSConfig;


/* 
 * Implementation.
 */
public:
    CAsyncTestDlg(ICfgComp * pCfgComp = NULL);
    ~CAsyncTestDlg();

/*
 * Operations.
 */

    void NotifyAbort( UINT idError );
    BOOL DeviceSetParams();
    BOOL DeviceWrite();
    void SetInfoFields( PPROTOCOLSTATUS pCurrent, PPROTOCOLSTATUS pNew );
    void OutputToEditControl( BYTE *pBuffer, int *pIndex );

/*
 * Message map / commands.
 */

    BOOL OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp );

    BOOL OnCommand( WORD , WORD , HWND );

    void OnTimer(UINT nIDEvent);
    LRESULT OnAsyncTestError(WPARAM wParam, LPARAM lParam);
    LRESULT OnAsyncTestAbort(WPARAM wParam, LPARAM lParam);
    LRESULT OnAsyncTestStatusReady(WPARAM wParam, LPARAM lParam);
    LRESULT OnAsyncTestInputReady(WPARAM wParam, LPARAM lParam);
    LRESULT OnAsyncTestWriteChar(WPARAM wParam, LPARAM lParam);
    void OnClickedAtdlgModemDial();
    void OnClickedAtdlgModemInit();
    void OnClickedAtdlgModemListen();
    void OnNcDestroy();
    cwnd *GetDlgItem( int nRes );
    

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );



};  // end CAsyncTestDlg class interface 

#define ASYNC_LED_TOGGLE_MSEC   200

    
#endif // _ASYNCDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\asyncdlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

#include "stdafx.h"
#include <winsta.h>
#include "resource.h"
#include "asyncdlg.h"
#include <utildll.h>

//Most of the code for this has been borrowed from tscfg.

extern void ErrMessage( HWND hwndOwner , INT_PTR iResourceID );

static int LedIds[NUM_LEDS] =
{
    IDC_ATDLG_DTR,
    IDC_ATDLG_RTS,
    IDC_ATDLG_CTS,
    IDC_ATDLG_DSR,
    IDC_ATDLG_DCD,
    IDC_ATDLG_RI
};

INT_PTR CBInsertInstancedName( LPCTSTR pName , HWND hCombo );

void ParseRootAndInstance( LPCTSTR pString, LPTSTR pRoot, long *pInstance );

//---------------------------------------------------------------------------------------------------
CAsyncDlg::CAsyncDlg( )
{
    m_hDlg = NULL;

    m_pCfgcomp = NULL;

    m_nHexBase = 0;

    m_szWinstation[ 0 ] = 0;

    m_szWDName[ 0 ] = 0;

    ZeroMemory( &m_ac , sizeof( ASYNCCONFIG ) );

    ZeroMemory( &m_uc , sizeof( USERCONFIG ) );

    ZeroMemory( &m_oldAC , sizeof( ASYNCCONFIG ) );

    m_nOldAsyncDeviceNameSelection = ( INT )-1;

    m_nOldAsyncConnectType = ( INT )-1;

    m_nOldBaudRate = ( INT )-1;

    m_nOldModemCallBack = ( INT )-1;
}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::OnInitDialog( HWND hDlg , LPTSTR szWDName , LPTSTR szWinstationName ,  ICfgComp *pCfgcomp )
{
    TCHAR tchName[ 80 ];

    TCHAR tchErrTitle[ 80 ];

    TCHAR tchErrMsg[ 256 ];

    TCHAR szDecoratedName[ DEVICENAME_LENGTH + MODEMNAME_LENGTH + 1 ];

    ASSERT( pCfgcomp != NULL );

    if( m_pCfgcomp == NULL )
    {
        m_pCfgcomp = pCfgcomp;

        m_pCfgcomp->AddRef( );
    }

    m_hDlg = hDlg;

    m_oldAC = m_ac;    

    if( szWinstationName != NULL )
    {
        lstrcpyn( m_szWinstation , szWinstationName , SIZE_OF_BUFFER( m_szWinstation ) - sizeof( TCHAR ) );
    }

    if( szWDName != NULL )
    {
        lstrcpyn( m_szWDName , szWDName , SIZE_OF_BUFFER( m_szWDName ) - sizeof( TCHAR ) );
    }

    // initialize controls

    int idx = 0;

    HRESULT hr;

    SendMessage( GetDlgItem( hDlg , IDC_ASYNC_CONNECT ) , CB_RESETCONTENT , 0 , 0 );

    while( SUCCEEDED( ( hr = pCfgcomp->GetConnTypeName( idx , tchName ) ) ) )
    {
        if( hr ==  S_FALSE )
        {
            break;
        }

        SendMessage( GetDlgItem( hDlg , IDC_ASYNC_CONNECT ) , CB_ADDSTRING , 0 , ( LPARAM )tchName );

        idx++;
    }

    idx = 0;

    SendMessage( GetDlgItem( hDlg , IDC_ASYNC_MODEMCALLBACK ) , CB_RESETCONTENT , 0 , 0 );

    while( SUCCEEDED( ( hr = pCfgcomp->GetModemCallbackString( idx , tchName ) ) ) )
    {
        if( hr == S_FALSE )
        {
            break;
        }

        SendMessage( GetDlgItem( hDlg , IDC_ASYNC_MODEMCALLBACK ) , CB_ADDSTRING , 0 , ( LPARAM )tchName );

        idx++;
    }

    // fill in device list

    ULONG ulItems = 0;

    LPBYTE pBuffer = NULL;

    HWND hCombo = GetDlgItem( hDlg , IDC_ASYNC_DEVICENAME );

    SendMessage( hCombo , CB_RESETCONTENT , 0 , 0 );

    // szWDname is used for creating a new connection
    // szWinstaionName is used if we're editing an existing connection

    TCHAR *pszName = NULL;

    NameType type = WdName;

    if( szWDName == NULL )
    {
        pszName = szWinstationName;

        type = WsName;
    }
    else
    {
        pszName = szWDName;
    }

    ASSERT( pszName != NULL );

    hr = pCfgcomp->GetDeviceList( pszName , type ,  &ulItems , &pBuffer );

    if( SUCCEEDED(  hr ) )
    {
        PPDPARAMS pPdParams = NULL;

		DBGMSG( L"TSCC : GetDeviceList returned %d devices that are available\n" , ulItems );

        for( idx = 0 , pPdParams = ( PPDPARAMS )pBuffer; idx < ( int )ulItems ; idx++, pPdParams++ )
        {
            // Form decorated name.

#ifdef DBG
			TCHAR temsg[ 128 ];

			wsprintf( temsg , L"TSCC : %d ) %s is a device\n" , idx , pPdParams->Async.DeviceName );

			ODS( temsg );
#endif

            FormDecoratedAsyncDeviceName( szDecoratedName, &( pPdParams->Async ) );

            if( pCfgcomp->IsAsyncDeviceAvailable( pPdParams->Async.DeviceName ) )
            {
                CBInsertInstancedName( szDecoratedName , hCombo );
            }

#if 0 // this block was taken from tscfg and to this date it still does not make any sense

            /*
              Don't add this device to the list if it is already in use by a
              WinStation other than the current one.
             */

              if (FALSE == pCfgcomp->IsAsyncDeviceAvailable(pPdParams->Async.DeviceName))
                  continue;


            // Insert the name into the combo-box if it's not a TAPI modem
            // or it is a TAPI modem that's not being used by RAS and it's
            // port is currently available.

            INT_PTR nRet = SendMessage( hCombo , CB_FINDSTRINGEXACT , ( WPARAM )-1 , ( LPARAM )pPdParams->Async.DeviceName );

            if( !*( pPdParams->Async.ModemName ) || ( /*!pPdParams->Async.Parity &&*/ ( nRet != ( INT_PTR )CB_ERR ) ) )
            {
                CBInsertInstancedName( szDecoratedName , hCombo );
            }
#endif

            // If this device is a modem, make sure that the raw port this
            // device is configured on is not present in the list.  This will
            // also take care of removing the raw port for TAPI modems that are
            // configured for use by RAS, in which case neither the configured.
            // TAPI modem(s) or raw port will be present in the list.

            INT_PTR nRet = SendMessage( hCombo , CB_FINDSTRINGEXACT , ( WPARAM )-1 , ( LPARAM )pPdParams->Async.DeviceName );

            if( *( pPdParams->Async.ModemName ) && ( nRet != CB_ERR ) )
            {
                ODS(L"Deleting item\n");

                SendMessage( hCombo , CB_DELETESTRING ,  ( WPARAM )nRet , 0 );
            }

        }

        LocalFree( pBuffer );


    }

    // Always make sure that the currently configured device is in

    if( m_ac.DeviceName[0] != 0  )
    {
        FormDecoratedAsyncDeviceName( szDecoratedName , &m_ac );

        INT_PTR nRet = SendMessage( hCombo , CB_FINDSTRINGEXACT , ( WPARAM )-1 , ( LPARAM )szDecoratedName );

        if( nRet == CB_ERR )
        {
            nRet = CBInsertInstancedName( szDecoratedName , hCombo );
        }

        SendMessage( hCombo , CB_SETCURSEL , ( WPARAM )nRet , 0 );

        m_nOldAsyncDeviceNameSelection = (int)nRet;

    }
    else
    {
        SendMessage( hCombo , CB_SETCURSEL , ( WPARAM )0, 0 );

        m_nOldAsyncDeviceNameSelection = 0;

    }

    INT_PTR iitem = SendMessage( hCombo , CB_GETCOUNT , ( WPARAM )0 , ( LPARAM )0);
    if(0 == iitem || CB_ERR == iitem)
    {
        LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) );

        LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_NODEVICES , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) );

        MessageBox( hDlg , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );

        return FALSE;
    }


    // Set the BAUDRATE combo-box selection (in it's edit field) and limit the
    // edit field text.

    TCHAR string[ULONG_DIGIT_MAX];

    wsprintf( string, TEXT("%lu"), m_ac.BaudRate );

    m_nOldBaudRate = ( INT )m_ac.BaudRate;

    HWND hBaud = GetDlgItem( hDlg , IDC_ASYNC_BAUDRATE );

    SendMessage( hBaud , CB_RESETCONTENT , 0 , 0 );

    SetDlgItemText( hDlg , IDC_ASYNC_BAUDRATE , string );

    SendMessage(hBaud , CB_LIMITTEXT , ULONG_DIGIT_MAX - 1 , 0  );


    //The Baud rate field should contain only numbers

    HWND  hEdit = GetWindow(hBaud,GW_CHILD);

    if(hEdit)
    {
        LONG Style = GetWindowLong(hEdit, GWL_STYLE);
        SetWindowLong(hEdit,GWL_STYLE, Style | ES_NUMBER);
    }


    TCHAR TempString[100]; // Number enough to hold the baud rate values


    //Add the default strings to the BaudRate Field

    lstrcpy(TempString, L"9600");

    SendMessage(hBaud , CB_ADDSTRING ,(WPARAM)0 ,(LPARAM)(LPCTSTR)TempString );

    lstrcpy(TempString, L"19200");

    SendMessage(hBaud , CB_ADDSTRING ,(WPARAM)0 ,(LPARAM)(LPCTSTR)TempString );

    lstrcpy(TempString, L"38400");

    SendMessage(hBaud , CB_ADDSTRING ,(WPARAM)0 ,(LPARAM)(LPCTSTR)TempString );

    lstrcpy(TempString, L"57600");

    SendMessage(hBaud , CB_ADDSTRING ,(WPARAM)0 ,(LPARAM)(LPCTSTR)TempString );

    lstrcpy(TempString, L"115200");

    SendMessage(hBaud , CB_ADDSTRING ,(WPARAM)0 ,(LPARAM)(LPCTSTR)TempString );

    lstrcpy(TempString, L"230400");

    SendMessage(hBaud , CB_ADDSTRING ,(WPARAM)0 ,(LPARAM)(LPCTSTR)TempString );


     // Set the CONNECT combo-box selection.

    SendMessage( GetDlgItem( hDlg , IDC_ASYNC_CONNECT ) , CB_SETCURSEL , m_ac.Connect.Type , 0 );

    m_nOldAsyncConnectType = ( INT )m_ac.Connect.Type;

    // CoTaskMemFree( pac );


    HWND hCbxModemCallback = GetDlgItem( hDlg , IDC_ASYNC_MODEMCALLBACK );

    // Set the MODEMCALLBACK combo-box selection, phone number, and 'inherit'
    // checkboxes, based on the current UserConfig settings.

    SendMessage( hCbxModemCallback , CB_SETCURSEL , ( WPARAM )m_uc.Callback , 0 );

    m_nOldModemCallBack = ( INT )m_uc.Callback;

    SetDlgItemText( hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER , m_uc.CallbackNumber );

    CheckDlgButton( hDlg , IDC_ASYNC_MODEMCALLBACK_INHERIT , m_uc.fInheritCallback );

    CheckDlgButton( hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT , m_uc.fInheritCallbackNumber );

    OnSelchangeAsyncDevicename( );

    return TRUE;

}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::OnSelchangeAsyncModemcallback()
{
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK);

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        return FALSE;
    }

    /*
     * Fetch current callback selection.
     */

    INT index = (INT)SendMessage(hCbx,CB_GETCURSEL,0,0);

    if( index != m_nOldModemCallBack )
    {
        m_uc.Callback = (CALLBACKCLASS)index;

        m_nOldModemCallBack = index;

        if( index == 0 ) // disabled
        {
            EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , FALSE );

            //EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , FALSE );
        }
        else
        {
            // inusre that these controls are in the proper state

            OnClickedAsyncModemcallbackPhonenumberInherit();
        }

        return TRUE;
    }

    return FALSE;

}  // end OnSelchangeAsyncModemcallback

//---------------------------------------------------------------------------------------------------
void CAsyncDlg::OnSelchangeAsyncModemcallbackPhoneNumber()
{
    GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER);

    /*
     * Fetch current callback Phone number.
     */
    GetDlgItemText(m_hDlg, IDC_ASYNC_MODEMCALLBACK_PHONENUMBER, m_uc.CallbackNumber,SIZE_OF_BUFFER(m_uc.CallbackNumber));

    return;

}  // end OnSelchangeAsyncModemcallback

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::OnSelchangeAsyncConnect()
{
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_CONNECT );

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        return FALSE;
    }

    INT index = ( INT )SendMessage(hCbx,CB_GETCURSEL,0,0);

    if( index != m_nOldAsyncConnectType )
    {
        m_ac.Connect.Type = (ASYNCCONNECTCLASS)index;

        m_nOldAsyncConnectType = index;

        return TRUE;
    }

    return FALSE;
}  // end CAsyncDlg::OnSelchangeAsyncConnect

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::OnSelchangeAsyncBaudrate()
{
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_BAUDRATE );

    ODS( L"TSCC : OnSelchangeAsyncBaudrate\n" );

    TCHAR string[ULONG_DIGIT_MAX], *endptr = NULL;

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        return FALSE;
    }

    //GetDlgItemText(m_hDlg, IDC_ASYNC_BAUDRATE, string,ULONG_DIGIT_MAX);
    int idx = ( int )SendMessage( hCbx , CB_GETCURSEL , 0 , 0 );

    SendMessage( hCbx , CB_GETLBTEXT , ( WPARAM )idx , ( LPARAM )&string[ 0 ] );

    INT nBaudRate = ( INT )wcstoul(string, &endptr, 10);

    if( m_nOldBaudRate != nBaudRate )
    {
        m_ac.BaudRate = nBaudRate;

        m_nOldBaudRate = nBaudRate;

        return TRUE;
    }

    return FALSE;

}  // end CAsyncDlg::OnSelchangeAsyncBaudrate

//---------------------------------------------------------------------------------------------------
void CAsyncDlg::OnClickedModemProperties()
{
    if ( !ConfigureModem( m_ac.ModemName, m_hDlg) )
    {
        ErrMessage(m_hDlg,IDP_ERROR_MODEM_PROPERTIES_NOT_AVAILABLE);
    }
    return;

}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::OnSelchangeAsyncDevicename( )
{
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_DEVICENAME );

    BOOL bModemEnableFlag, bDirectEnableFlag;

    INT_PTR index;

    int nModemCmdShow, nDirectCmdShow;

    // Ignore this notification if the combo box is in a dropped-down state.

    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        return TRUE;
    }

    if( ( index = SendMessage( hCbx , CB_GETCURSEL , 0 , 0 ) ) != CB_ERR )
    {

        if( m_nOldAsyncDeviceNameSelection != index )
        {
            TCHAR szDeviceName[DEVICENAME_LENGTH+MODEMNAME_LENGTH+1];

            // Fetch current selection and parse into device and modem names.
            
            TCHAR tchErrMsg[ 512 ];

            TCHAR tchbuf[ 356 ];

            TCHAR tchErrTitle[ 80 ];

            LONG lCount = 0;            

            if( m_pCfgcomp != NULL )
            {
                m_pCfgcomp->QueryLoggedOnCount( m_szWinstation , &lCount );               

                if( lCount > 0 )
                {
                    if( *m_ac.ModemName != 0 )
                    {
                        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_CHANGE_ASYNC , tchbuf , SIZE_OF_BUFFER( tchbuf ) ) );
                    }
                    else
                    {
                        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_CHANGE_MODEM , tchbuf , SIZE_OF_BUFFER( tchbuf ) ) );
                    }

                    wsprintf( tchErrMsg , tchbuf , m_szWinstation );
                    
                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) ) );

                    if( MessageBox( m_hDlg , tchErrMsg , tchErrTitle , MB_YESNO | MB_ICONEXCLAMATION ) == IDNO )
                    {
                        SendMessage( hCbx , CB_SETCURSEL , ( WPARAM )m_nOldAsyncDeviceNameSelection , 0 );

                        return FALSE;

                    }
                }
            }


            SendMessage( hCbx , CB_GETLBTEXT , ( WPARAM )index , ( LPARAM )&szDeviceName[0] );

            ParseDecoratedAsyncDeviceName( szDeviceName , &m_ac );

            m_nOldAsyncDeviceNameSelection = (INT)index;
        }
        else
        {
            return FALSE;
        }

    }


    /*
     * The SetDefaults, Advanced, and Test buttons and Device Connect
     * and Baud fields are enabled if the configuration is non-modem.
     * Otherwise, the Configure Modem button and modem callback fields
     * are enabled.  (The Install Modems buttons is always enabled).
     */
    if( ( *m_ac.ModemName != 0 ) )
    {

        bModemEnableFlag = TRUE;
        nModemCmdShow = SW_SHOW;
        bDirectEnableFlag = FALSE;
        nDirectCmdShow = SW_HIDE;

    } else {

        bModemEnableFlag = FALSE;
        nModemCmdShow = SW_HIDE;
        bDirectEnableFlag = TRUE;
        nDirectCmdShow = SW_SHOW;

    }

    ShowWindow( GetDlgItem( m_hDlg, IDL_ASYNC_MODEMCALLBACK) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDL_ASYNC_MODEMCALLBACK ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_MODEM_PROP_PROP) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_MODEM_PROP_PROP ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_MODEM_PROP_WIZ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_MODEM_PROP_WIZ ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDL_ASYNC_MODEMCALLBACK1 ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDL_ASYNC_MODEMCALLBACK1 ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK_INHERIT ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK_INHERIT ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDL_ASYNC_MODEMCALLBACK_PHONENUMBER ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDL_ASYNC_MODEMCALLBACK_PHONENUMBER ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDL_ASYNC_CONNECT ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDL_ASYNC_CONNECT ) , bDirectEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_CONNECT ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_CONNECT ) , bDirectEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDL_ASYNC_BAUDRATE ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDL_ASYNC_BAUDRATE ) , bDirectEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_BAUDRATE ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_BAUDRATE ) , bDirectEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_DEFAULTS ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_DEFAULTS ) , bDirectEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_ADVANCED ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_ADVANCED ) , bDirectEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_TEST ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_TEST ) , bDirectEnableFlag );



    // If this is a modem device, properly set the callback fields.

    if( ( *m_ac.ModemName != 0 ) )
    {
        OnClickedAsyncModemcallbackInherit( );

        OnClickedAsyncModemcallbackPhonenumberInherit( );
    }

    return TRUE;
}

//---------------------------------------------------------------------------------------------------
void CAsyncDlg::OnClickedAsyncModemcallbackInherit( )
{
    BOOL bChecked = ( BOOL )SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_INHERIT ) , BM_GETCHECK , 0 , 0 );

    BOOL bEnable = !bChecked;

    m_uc.fInheritCallback = bChecked;

    EnableWindow( GetDlgItem( m_hDlg , IDL_ASYNC_MODEMCALLBACK1 ) , bEnable );

    EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK ) , bEnable );

    // now check to see if we need to enable the modem callback number

    if( bChecked )
    {
        if( SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK) , CB_GETCURSEL , 0 , 0 ) == 0 )
        {
            if( !( BOOL )SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , BM_GETCHECK , 0 , 0 ) )
            {
                EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , TRUE );

                // EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , TRUE );
            }
        }
    }
    else
    {
        if( (INT)SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK) , CB_GETCURSEL , 0 , 0 ) == 0 )
        {
            if( !( BOOL )SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , BM_GETCHECK , 0 , 0 ) )
            {
                EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , FALSE );

                // EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , FALSE );
            }
        }
    }

    return;
}


//---------------------------------------------------------------------------------------------------
void CAsyncDlg::OnClickedAsyncModemcallbackPhonenumberInherit( )
{
    BOOL bChecked = ( BOOL )SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , BM_GETCHECK , 0 , 0 );

    BOOL bEnable = !bChecked;

    m_uc.fInheritCallbackNumber = bChecked;

    if( !bChecked )
    {
        if( !( BOOL )SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_INHERIT ) , BM_GETCHECK , 0 , 0 ) )
        {
            if( SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK) , CB_GETCURSEL , 0 , 0 ) == 0 )
            {
                EnableWindow( GetDlgItem( m_hDlg , IDL_ASYNC_MODEMCALLBACK_PHONENUMBER ) , FALSE );

                EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , FALSE );

                return;
            }
        }
    }

    EnableWindow( GetDlgItem( m_hDlg , IDL_ASYNC_MODEMCALLBACK_PHONENUMBER ) , bEnable );

    EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , bEnable );

    return;
}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl , PBOOL pfPersisted )
{
    UNREFERENCED_PARAMETER( hwndCtrl );

    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_ASYNC_DEFAULTS )
        {
            if( SetDefaults( ) == S_OK )
            {
                *pfPersisted = FALSE;
            }
        }
        else if( wID == IDC_ASYNC_ADVANCED )
        {
            if( DoAsyncAdvance( ) == S_OK )
            {
                *pfPersisted = FALSE;
            }

        }
        else if( wID == IDC_ASYNC_TEST )
        {
            DoAsyncTest( );
        }
        else if( wID == IDC_ASYNC_MODEMCALLBACK_INHERIT )
        {
            OnClickedAsyncModemcallbackInherit();

            *pfPersisted = FALSE;
        }
        else if( wID == IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT )
        {
            OnClickedAsyncModemcallbackPhonenumberInherit();

            *pfPersisted = FALSE;
        }
        else if(wID == IDC_MODEM_PROP_PROP || wID == IDC_MODEM_PROP_WIZ)
        {
            OnClickedModemProperties();
        }

    }
    else if( wNotifyCode == CBN_SELCHANGE )
    {
        if(wID == IDC_ASYNC_DEVICENAME)
        {
            if( OnSelchangeAsyncDevicename( ) )
            {
                *pfPersisted = FALSE;
            }

        }
        else if(wID == IDC_ASYNC_CONNECT)
        {
            if( OnSelchangeAsyncConnect() )
            {
                *pfPersisted = FALSE;
            }
        }
        else if(wID == IDC_ASYNC_BAUDRATE)
        {
            if( OnSelchangeAsyncBaudrate() )
            {
                *pfPersisted = FALSE;
            }
        }
        else if(wID == IDC_ASYNC_MODEMCALLBACK)
        {
            if( OnSelchangeAsyncModemcallback() )
            {
                *pfPersisted = FALSE;
            }
        }

    }
    /*else if( wNotifyCode == CBN_KILLFOCUS)
    {
        if(wID == IDC_ASYNC_BAUDRATE)
        {
            OnSelchangeAsyncBaudrate();
        }

    }*/
    else if(wNotifyCode == EN_CHANGE )
    {
        if(wID == IDC_ASYNC_MODEMCALLBACK_PHONENUMBER)
        {
            OnSelchangeAsyncModemcallbackPhoneNumber();

            *pfPersisted = FALSE;
        }

    }


    return TRUE;

}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::AsyncRelease( )
{
    if( m_pCfgcomp != NULL )
    {
        m_pCfgcomp->Release( );
    }

    return TRUE;
}

//---------------------------------------------------------------------------------------------------
HRESULT CAsyncDlg::SetAsyncFields(ASYNCCONFIG& AsyncConfig , PUSERCONFIG pUc)
{
    HRESULT hres = S_OK;

    if( pUc == NULL )
    {
        return E_INVALIDARG;
    }

    // check for variation

    lstrcpy( AsyncConfig.DeviceName , m_ac.DeviceName );

    if( memcmp( ( PVOID )&AsyncConfig , ( PVOID )&m_ac , sizeof( ASYNCCONFIG ) ) == 0 )
    {
        if( memcmp( pUc->CallbackNumber , m_uc.CallbackNumber , sizeof( m_uc.CallbackNumber ) ) == 0 &&

            pUc->fInheritCallback == m_uc.fInheritCallback &&

            pUc->fInheritCallbackNumber == m_uc.fInheritCallbackNumber )

        {
            return S_FALSE;
        }
    }


    BOOL bSelectDefault = !( *AsyncConfig.DeviceName);

    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_DEVICENAME );

    HWND hCbxCallback = GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK );

    TCHAR szDeviceName[DEVICENAME_LENGTH+MODEMNAME_LENGTH+1];

    /*
     * Set the DEVICE combo-box selection from the current selection.
     */
    FormDecoratedAsyncDeviceName( szDeviceName, &AsyncConfig );


    if( SendMessage( hCbx , CB_SELECTSTRING , ( WPARAM )-1 , ( LPARAM )szDeviceName ) == CB_ERR )
    {
        /*
         * Can't select current async DeviceName in combo-box.  If this is
         * because we're supposed to select a default device name, select
         * the first device in the list.
         */
        if( bSelectDefault )
        {
            SendMessage( hCbx , CB_SETCURSEL , 0 , 0 );
        }
        else
        {
            hres = E_FAIL;
        }
    }

    /*
     * Set the MODEMCALLBACK combo-box selection, phone number, and 'inherit'
     * checkboxes, based on the current UserConfig settings.
     */
    SendMessage( hCbxCallback , CB_SETCURSEL , m_uc.Callback , 0 );

    SetDlgItemText( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER, m_uc.CallbackNumber );

    CheckDlgButton( m_hDlg , IDC_ASYNC_MODEMCALLBACK_INHERIT , m_uc.fInheritCallback );

    CheckDlgButton( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT , m_uc.fInheritCallbackNumber );

    /*
     * Set the BAUDRATE combo-box selection (in it's edit field) and limit the
     * edit field text.
     */

    TCHAR string[ULONG_DIGIT_MAX];

    wsprintf( string, TEXT("%lu"), AsyncConfig.BaudRate );

    SetDlgItemText( m_hDlg , IDC_ASYNC_BAUDRATE, string );

    SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_BAUDRATE ) , CB_LIMITTEXT ,  ULONG_DIGIT_MAX-1  , 0);

    HWND  hEdit = GetWindow(GetDlgItem( m_hDlg , IDC_ASYNC_BAUDRATE ),GW_CHILD);

    if(hEdit)
    {
        LONG Style = GetWindowLong(hEdit, GWL_STYLE);
        SetWindowLong(hEdit,GWL_STYLE, Style | ES_NUMBER);
    }

    /*
     * Set the CONNECT combo-box selection.
     */

    SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_CONNECT) , CB_SETCURSEL , AsyncConfig.Connect.Type , 0 );

    // copy over default values

    CopyMemory( ( PVOID )&m_ac , ( PVOID )&AsyncConfig , sizeof( ASYNCCONFIGW ) );

    return hres;

}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::GetAsyncFields(ASYNCCONFIG& AsyncConfig, USERCONFIG UsrCfg)
{
    /*
     * Fetch the currently selected DEVICENAME string.
     */
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_DEVICENAME );

    ASSERT( hCbx != NULL );

    if( !SendMessage( hCbx , CB_GETCOUNT , 0 , 0 ) || SendMessage( hCbx , CB_GETCURSEL , 0 , 0 ) == CB_ERR )
    {
        ErrMessage( m_hDlg , IDS_INVALID_DEVICE );

        return FALSE;
    }

    /*
     * Get the MODEMCALLBACK phone number (callback state and 'user specified'
     * flags are already gotten).
     */

    GetDlgItemText(m_hDlg,IDC_ASYNC_MODEMCALLBACK_PHONENUMBER,
                    UsrCfg.CallbackNumber,
                    SIZE_OF_BUFFER(UsrCfg.CallbackNumber) );

    /*
     * Fetch and convert the BAUDRATE combo-box selection (in it's edit field).
     */
    {
        TCHAR string[ULONG_DIGIT_MAX], *endptr;
        ULONG ul;

        GetDlgItemText(m_hDlg,IDC_ASYNC_BAUDRATE, string, ULONG_DIGIT_MAX);
        ul = wcstoul( string, &endptr, 10 );

        if ( *endptr != TEXT('\0') )
        {

            /*
             * Invalid character in Baud Rate field.
             */
            ErrMessage( m_hDlg , IDS_INVALID_DEVICE );

            return FALSE;

        }
        else
        {
            AsyncConfig.BaudRate = ul;
        }
    }

    /*
     * Fetch the CONNECT combo-box selection and set/reset the break
     * disconnect flag.
     */

    AsyncConfig.Connect.Type = (ASYNCCONNECTCLASS)SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_CONNECT ) , CB_GETCURSEL , 0 , 0 );
    if(AsyncConfig.Connect.Type == Connect_FirstChar)
    {
        AsyncConfig.Connect.fEnableBreakDisconnect = 1;
    }
    else
    {
        AsyncConfig.Connect.fEnableBreakDisconnect = 0;
    }

    return(TRUE);

}  // end CAsyncDlg::GetAsyncFields

//---------------------------------------------------------------------------------------------------
// returns  E_FAIL  for general error
//          S_OK    for default values saved
//          S_FALSE for default values have not been changed
//---------------------------------------------------------------------------------------------------
HRESULT CAsyncDlg::SetDefaults()
{
    ASYNCCONFIG AsyncConfig;

    PUSERCONFIG pUserConfig = NULL;

    HRESULT hResult;

    hResult = m_pCfgcomp->GetAsyncConfig(m_szWDName,WdName,&AsyncConfig);

    if( SUCCEEDED( hResult ) )
    {
        LONG lsz;

        hResult = m_pCfgcomp->GetUserConfig( m_szWinstation , &lsz , &pUserConfig, TRUE );
    }

    if( SUCCEEDED( hResult ) )
    {
        hResult = SetAsyncFields( AsyncConfig , pUserConfig );
    }

    if( pUserConfig != NULL )
    {
        CoTaskMemFree( pUserConfig );

    }

    return hResult;

}

//---------------------------------------------------------------------------------------------------
HRESULT CAsyncDlg::DoAsyncAdvance( )
{
     CAdvancedAsyncDlg AADlg;

     //Initialize the dialog's member variables.

     AADlg.m_Async = m_ac;

     AADlg.m_bReadOnly =  FALSE;

     AADlg.m_bModem = FALSE;

     AADlg.m_nHexBase = m_nHexBase;

     PWS pWs = NULL;

     LONG lSize = 0;

     if( m_szWDName[ 0 ] != 0 )
     {
         ODS( L"CAsyncDlg::DoAsyncAdvance m_pCfgcomp->GetWdType\n" );

         VERIFY_S( S_OK , m_pCfgcomp->GetWdType( m_szWDName , ( ULONG *)&AADlg.m_nWdFlag ) );
     }
     else if( SUCCEEDED( m_pCfgcomp->GetWSInfo( m_szWinstation , &lSize , &pWs ) ) )
     {
         ODS( L"CAsyncDlg::DoAsyncAdvance with m_szWinstation -- m_pCfgcomp->GetWdType\n" );

         VERIFY_S( S_OK , m_pCfgcomp->GetWdType( pWs->wdName , ( ULONG *)&AADlg.m_nWdFlag ) ) ;

         CoTaskMemFree( pWs );
     }

     AADlg.m_pCfgcomp = m_pCfgcomp; // addref here

     // Invoke dialog

     INT_PTR nRet = ::DialogBoxParam( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDD_ASYNC_ADVANCED ) , m_hDlg , CAdvancedAsyncDlg::DlgProc  , ( LPARAM )&AADlg );

     if( nRet == IDOK )
     {
         // Fetch the dialog's member variables.

         if( memcmp( ( PVOID )&m_ac ,( PVOID )&AADlg.m_Async , sizeof( ASYNCCONFIG ) ) != 0 )
         {
             m_ac = AADlg.m_Async;

             m_nHexBase = AADlg.m_nHexBase;

             return S_OK;
         }
     }

     return S_FALSE;
}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::DoAsyncTest( )
{
    CAsyncTestDlg ATDlg( m_pCfgcomp );

    // WINSTATIONCONFIG2W wsconfig;

    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_DEVICENAME );

    ASSERT( hCbx != NULL );

    if( !SendMessage( hCbx , CB_GETCOUNT , 0 , 0 ) || SendMessage( hCbx , CB_GETCURSEL , 0 , 0 ) == CB_ERR )
    {
        ErrMessage( m_hDlg , IDS_INVALID_DEVICE );

        return FALSE;
    }

    ATDlg.m_ac = m_ac;

    ATDlg.m_pWSName = m_szWinstation;

    // Invoke the dialog.

    INT_PTR nRet = ::DialogBoxParam( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDD_ASYNC_TEST ) , m_hDlg , CAsyncTestDlg::DlgProc  , ( LPARAM )&ATDlg);

    if( nRet == IDOK )
    {
        m_ac = ATDlg.m_ac;
    }

    return TRUE;
}

//*******************************************************************************
//
// Help functions from Citrix
//
/*******************************************************************************
 *
 *  CBInsertInstancedName - helper function
 *
 *      Insert the specified 'instanced' name into the specified combo box,
 *      using a special sort based on the 'root' name and 'instance' count.
 *
 *  ENTRY:
 *      pName (input)
 *          Pointer to name string to insert.
 *      pComboBox (input)
 *          Pointer to CComboBox object to insert name string into.
 *
 *  EXIT:
 *      (int) Combo box list index of name after insertion, or error code.
 *
 ******************************************************************************/

INT_PTR CBInsertInstancedName( LPCTSTR pName, HWND hCombo )
{
    INT_PTR i, count, result;

    TCHAR NameRoot[64], ListRoot[64];

    if( pName == NULL || *pName == 0 )
    {
        ODS( L"TSCC: Invalid Arg @ CBInsertInstancedName\n" );
        return -1;
    }

    LPTSTR ListString = NULL;

    long NameInstance, ListInstance;

    /*
     * Form the root and instance for this name
     */
    ParseRootAndInstance( pName, NameRoot, &NameInstance );

    /*
     * Traverse combo box to perform insert.
     */
    for ( i = 0, count = SendMessage( hCombo , CB_GETCOUNT , 0 , 0 ); i < count; i++ ) {

        /*
         * Fetch current combo (list) box string.
         */
        if( ListString != NULL )
        {
            SendMessage( hCombo , CB_GETLBTEXT , ( WPARAM )i , ( LPARAM )ListString );
        }


        /*
         * Parse the root and instance of the list box string.
         */
        ParseRootAndInstance( ListString, ListRoot, &ListInstance );

        /*
         * If the list box string's root is greater than the our name string's
         * root, or the root strings are the same but the list instance is
         * greater than the name string's instance, or the root strings are
         * the same and the instances are the same but the entire list string
         * is greater than the entire name string, the name string belongs
         * at the current list position: insert it there.
         */

        if ( ((result = lstrcmpi( ListRoot, NameRoot )) > 0) ||
             ((result == 0) &&
              (ListInstance > NameInstance)) ||
             ((result == 0) &&
              (ListInstance == NameInstance) &&
              ( ListString != NULL && lstrcmpi(ListString, pName) > 0) ) )
        {
            return SendMessage( hCombo , CB_INSERTSTRING , ( WPARAM )i , ( LPARAM )pName );
        }
    }

    /*
     * Insert this name at the end of the list.
     */
    return SendMessage( hCombo , CB_INSERTSTRING , ( WPARAM )-1 , ( LPARAM )pName );

}  // end CBInsertInstancedName


/*******************************************************************************
 *
 *  ParseRootAndInstance - helper function
 *
 *      Parse the 'root' string and instance count for a specified string.
 *
 *  ENTRY:
 *      pString (input)
 *          Points to the string to parse.
 *      pRoot (output)
 *          Points to the buffer to store the parsed 'root' string.
 *      pInstance (output)
 *          Points to the int variable to store the parsed instance count.
 *
 *  EXIT:
 *      ParseRootAndInstance will parse only up to the first blank character
 *      of the string (if a blank exists).
 *      If the string contains no 'instance' count (no trailing digits), the
 *      pInstance variable will contain -1.  If the string consists entirely
 *      of digits, the pInstance variable will contain the conversion of those
 *      digits and pRoot will contain a null string.
 *
 ******************************************************************************/

void
ParseRootAndInstance( LPCTSTR pString,
                      LPTSTR pRoot,
                      long *pInstance )
{
    LPCTSTR end, p;
    TCHAR szString[256];

    if( pString == NULL || pString[ 0 ] == 0 )
    {
        ODS( L"TSCC: Invalid arg @ ParseRootAndInstance\n" );

        return;
    }

    /*
     * Make a copy of the string and terminate at first blank (if present).
     */
    lstrcpyn(szString, pString, SIZE_OF_BUFFER( szString ) );

    // szString[ lstrlen(szString) - 1 ] = TEXT('\0');

    TCHAR *pTemp = szString;

    while( *pTemp && *pTemp != L' ' )
    {
        pTemp++;
    }


    p = &(pTemp[lstrlen(pTemp)-1]);

    /*
     * Parse the instance portion of the string.
     */
    end = p;

    while( (p >= pTemp) && !IsCharAlpha(*p) )
        p--;

    if ( p == end ) {

        /*
         * No trailing digits: indicate no 'instance' and make the 'root'
         * the whole string.
         */
        *pInstance = -1;
        lstrcpy( pRoot, pTemp );

    } else {

        /*
         * Trailing digits found (or entire string was digits): calculate
         * 'instance' and copy the 'root' string (null if all digits).
         */
        end = p;
        *pInstance = (int)_tcstol( p+1, NULL, 10 );

        /*
         * Copy 'root' string.
         */
        for ( p = szString; p <= end; pRoot++, p++ )
            *pRoot = *p;

        /*
         * Terminate 'root' string.
         */
        *pRoot = TEXT('\0');
    }

}  // end ParseRootAndInstance



////////////////////////////////////////////////////////////////////////////////
CAdvancedAsyncDlg::CAdvancedAsyncDlg()
{
    m_hDlg = NULL;

}  // end CAdvancedAsyncDlg::CAdvancedAsyncDlg

//---------------------------------------------------------------------------------------------------
BOOL CAdvancedAsyncDlg::HandleEnterEscKey(int nID)
{
    /*
     * Check HW Flow Receive and Transmit combo boxes.
     */
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWRX );

    ASSERT( hCbx != NULL );

    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        if( nID == IDCANCEL )
        {
            // select original selection

            SendMessage( hCbx , CB_SETCURSEL , ( WPARAM )m_Async.FlowControl.HardwareReceive , 0 );
        }

        SendMessage( hCbx , CB_SHOWDROPDOWN , ( WPARAM )FALSE , 0 );

        return FALSE;
    }

    hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWTX );

    ASSERT( hCbx != NULL );

    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        if( nID == IDCANCEL )
        {
            // select original selection

            SendMessage( hCbx , CB_SETCURSEL , ( WPARAM )m_Async.FlowControl.HardwareTransmit , 0 );

        }

        SendMessage( hCbx , CB_SHOWDROPDOWN , ( WPARAM )FALSE , 0 );

        return FALSE;
    }

    /*
     * No combo boxes are down; process Enter/Esc.
     */

    return TRUE;

}  // end CAdvancedAsyncDlg::HandleEnterEscKey

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::SetFields()
{
    int nId = 0;

    /*
     * Set the FLOWCONTROL radio buttons.
     */
    switch( m_Async.FlowControl.Type ) {

        case FlowControl_None:
            nId = IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE;
            break;

        case FlowControl_Hardware:
            nId = IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE;
            break;

        case FlowControl_Software:
            nId = IDC_ASYNC_ADVANCED_FLOWCONTROL_SOFTWARE;
            break;
    }

    CheckRadioButton( m_hDlg ,
                      IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE,
                      IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE,
                      nId );

    /*
     * Set the text of the Hardware flowcontrol button.
     */
    SetHWFlowText();


    /*
     * If a modem is defined, disable the Flow Control fields, since they cannot
     * be modified (must match modem's flow control established in Modem dialog).
     */
    if( m_bModem )
    {
        for ( nId = IDL_ASYNC_ADVANCED_FLOWCONTROL; nId <= IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE; nId++ )
        {
            EnableWindow( GetDlgItem( m_hDlg , nId ) ,  FALSE);
        }
    }

    /*
     * Call member functions to set the Global, Hardware, and Software fields.
     */
    SetGlobalFields();
    SetHWFields();
    SetSWFields();

}  // end CAdvancedAsyncDlg::SetFields

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::SetHWFlowText( )
{
    TCHAR tchStr[ 256 ];

    LoadString( _Module.GetResourceInstance( ) , IDS_HARDWARE , tchStr , SIZE_OF_BUFFER( tchStr ) );       

    switch ( m_Async.FlowControl.HardwareReceive )
    {

        case ReceiveFlowControl_None:

            lstrcat( tchStr , TEXT(" (.../") );

            break;

        case ReceiveFlowControl_RTS:

            lstrcat( tchStr , TEXT(" (RTS/") );

            break;

        case ReceiveFlowControl_DTR:

            lstrcat( tchStr , TEXT(" (DTR/") ) ;

            break;
    }

    switch ( m_Async.FlowControl.HardwareTransmit )
    {
        case TransmitFlowControl_None:

            lstrcat( tchStr , TEXT("...)" ) );

            break;

        case TransmitFlowControl_CTS:

            lstrcat( tchStr , TEXT("CTS)") );

            break;

        case TransmitFlowControl_DSR:

            lstrcat( tchStr ,  TEXT("DSR)") );

            break;
    }

    SetDlgItemText( m_hDlg , IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE , tchStr );

}  // end CAdvancedAsyncDlg::SetHWFlowText

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::SetGlobalFields()
{
    /*
     * Select proper DTR radio button.
     */
    CheckRadioButton( m_hDlg , IDC_ASYNC_ADVANCED_DTROFF, IDC_ASYNC_ADVANCED_DTRON,
                      IDC_ASYNC_ADVANCED_DTROFF +
                      (int)m_Async.FlowControl.fEnableDTR );

    /*
     * Select proper RTS radio button.
     */
    CheckRadioButton( m_hDlg , IDC_ASYNC_ADVANCED_RTSOFF, IDC_ASYNC_ADVANCED_RTSON,
                      IDC_ASYNC_ADVANCED_RTSOFF +
                      (int)m_Async.FlowControl.fEnableRTS );

    /*
     * Set the PARITY radio buttons.
     */
    CheckRadioButton( m_hDlg , IDC_ASYNC_ADVANCED_PARITY_NONE,
                      IDC_ASYNC_ADVANCED_PARITY_SPACE,
                      IDC_ASYNC_ADVANCED_PARITY_NONE +
                        (int)m_Async.Parity );

    /*
     * Set the STOPBITS radio buttons.
     */
    CheckRadioButton( m_hDlg , IDC_ASYNC_ADVANCED_STOPBITS_1,
                      IDC_ASYNC_ADVANCED_STOPBITS_2,
                      IDC_ASYNC_ADVANCED_STOPBITS_1 +
                        (int)m_Async.StopBits );

    /*
     * Set the BYTESIZE radio buttons.
     *
     * NOTE: the constant '7' that is subtracted from the stored ByteSize
     * must track the lowest allowed byte size / BYTESIZE radio button.
     */
    CheckRadioButton( m_hDlg , IDC_ASYNC_ADVANCED_BYTESIZE_7,
                      IDC_ASYNC_ADVANCED_BYTESIZE_8,
                      IDC_ASYNC_ADVANCED_BYTESIZE_7 +
                        ((int)m_Async.ByteSize - 7) );

    /*
     * If the currently selected Wd is an ICA type, disable the BYTESIZE
     * group box and buttons - user can't change from default.
     */
    if ( m_nWdFlag & WDF_ICA )
    {
        int i;

        for( i =  IDL_ASYNC_ADVANCED_BYTESIZE ; i <= IDC_ASYNC_ADVANCED_BYTESIZE_8; i++ )
        {
            EnableWindow( GetDlgItem( m_hDlg , i ) , FALSE );
        }
    }

}  // end CAdvancedAsyncDlg::SetGlobalFields

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::SetHWFields()
{
    int i;

    /*
     * Initialize HW Receive class combo-box
     */
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWRX );

    ASSERT( hCbx != NULL );

    SendMessage( hCbx , CB_SETCURSEL , ( WPARAM )m_Async.FlowControl.HardwareReceive , 0 );

    /*
     * If HW flow control is selected AND the HW Receive class is set to
     * ReceiveFlowControl_DTR, disable the DTR controls & labels.
     * Otherwise, enable the DTR control & labels.
     */
    for( i = IDL_ASYNC_ADVANCED_DTRSTATE ; i <= IDC_ASYNC_ADVANCED_DTRON ; i++ )
    {
        EnableWindow( GetDlgItem( m_hDlg , i ) , ( ( m_Async.FlowControl.Type == FlowControl_Hardware) &&
             (m_Async.FlowControl.HardwareReceive == ReceiveFlowControl_DTR) ) ? FALSE : TRUE );
    }

    /*
     * Initialize HW Transmit class combo-box.
     */

    hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWTX);

    SendMessage( hCbx , CB_SETCURSEL , ( WPARAM )m_Async.FlowControl.HardwareTransmit , 0  );

    /*
     * If HW flow control is selected AND the HW Receive class is set to
     * ReceiveFlowControl_RTS, disable the RTS controls & labels.
     * Otherwise, enable the RTS control & labels.
     */

    for( i = IDL_ASYNC_ADVANCED_RTSSTATE ; i <= IDC_ASYNC_ADVANCED_RTSON ; i++ )
    {
        EnableWindow( GetDlgItem( m_hDlg , i ) , ( ( m_Async.FlowControl.Type == FlowControl_Hardware) &&
             ( m_Async.FlowControl.HardwareReceive == ReceiveFlowControl_RTS ) ) ? FALSE : TRUE );
    }

    /*
     * Enable or disable all HW fields.
     */

    for( i = IDL_ASYNC_ADVANCED_HARDWARE ; i <= IDC_ASYNC_ADVANCED_HWTX ; i++ )
    {

        EnableWindow( GetDlgItem( m_hDlg , i ) , m_Async.FlowControl.Type == FlowControl_Hardware );
    }

}  // end CAdvancedAsyncDlg::SetHWFields


//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::SetSWFields()
{
    TCHAR string[UCHAR_DIGIT_MAX];

    /*
     * Initialize Xon character edit control.
     */
    wsprintf( string, ( m_nHexBase ? TEXT("0x%02X") : TEXT("%d")) , (UCHAR)m_Async.FlowControl.XonChar );

    SetDlgItemText( m_hDlg , IDC_ASYNC_ADVANCED_XON , string );

    SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XON ) , EM_SETMODIFY , ( WPARAM )FALSE , 0 );

    SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XON ) , EM_LIMITTEXT , ( WPARAM )UCHAR_DIGIT_MAX-1 , 0 );

    /*
     * Initialize Xoff character edit control.
     */
    wsprintf( string, ( m_nHexBase ? TEXT( "0x%02X" ) : TEXT( "%d" ) ) , ( UCHAR )m_Async.FlowControl.XoffChar );

    SetDlgItemText( m_hDlg , IDC_ASYNC_ADVANCED_XOFF, string );

    SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XOFF ) , EM_SETMODIFY , ( WPARAM )FALSE , 0 );

    SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XOFF ) , EM_LIMITTEXT , ( WPARAM )UCHAR_DIGIT_MAX-1 , 0 );

    /*
     * Initialize the Xon/Xoff base control.
     */
    CheckRadioButton( m_hDlg , IDC_ASYNC_ADVANCED_BASEDEC, IDC_ASYNC_ADVANCED_BASEHEX,
                      ( int )( IDC_ASYNC_ADVANCED_BASEDEC + m_nHexBase ) );

    /*
     * Enable or disable all SW fields.
     */
    for( int i = IDL_ASYNC_ADVANCED_SOFTWARE ; i <= IDC_ASYNC_ADVANCED_BASEHEX ; i++ )
    {
        EnableWindow( GetDlgItem( m_hDlg , i ) , m_Async.FlowControl.Type == FlowControl_Software );
    }

}  // end CAdvancedAsyncDlg::SetSWFields

//---------------------------------------------------------------------------------------------------
BOOL CAdvancedAsyncDlg::GetFields()
{
    /*
     * Call member functions to get the Flow Control, Global, Hardware, and
     * Software fields.
     */
    GetFlowControlFields();

    if ( !GetGlobalFields() )
        return(FALSE);

    if ( !GetHWFields() )
        return(FALSE);

    if ( !GetSWFields(TRUE) )
        return(FALSE);

    return(TRUE);

}  // end CAdvancedAsyncDlg::GetFields

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::GetFlowControlFields()
{
    switch( GetCheckedRadioButton( IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE ,  IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE )  )
    {

        case IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE:
            m_Async.FlowControl.Type = FlowControl_None;
            break;

        case IDC_ASYNC_ADVANCED_FLOWCONTROL_SOFTWARE:
            m_Async.FlowControl.Type = FlowControl_Software;
            break;

        case IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE:
            m_Async.FlowControl.Type = FlowControl_Hardware;
            break;
    }

}  // end CAdvancedAsyncDlg::GetFlowControlFields

//---------------------------------------------------------------------------------------------------
BOOL CAdvancedAsyncDlg::GetGlobalFields()
{
    /*
     * Fetch DTR state.
     */
    m_Async.FlowControl.fEnableDTR =
            (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_DTROFF,
                                    IDC_ASYNC_ADVANCED_DTRON )
                    - IDC_ASYNC_ADVANCED_DTROFF);

    /*
     * Fetch RTS state.
     */
    m_Async.FlowControl.fEnableRTS =
            (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_RTSOFF,
                                    IDC_ASYNC_ADVANCED_RTSON )
                    - IDC_ASYNC_ADVANCED_RTSOFF);

    /*
     * Fetch the selected PARITY.
     */
    m_Async.Parity = (ULONG)
        (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_PARITY_NONE,
                                IDC_ASYNC_ADVANCED_PARITY_SPACE )
                - IDC_ASYNC_ADVANCED_PARITY_NONE);

    /*
     * Fetch the selected STOPBITS.
     */
    m_Async.StopBits = (ULONG)
        (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_STOPBITS_1,
                                IDC_ASYNC_ADVANCED_STOPBITS_2 )
                - IDC_ASYNC_ADVANCED_STOPBITS_1);

    /*
     * Fetch the selected BYTESIZE.
     *
     * NOTE: the constant '7' that is added to the stored ByteSize
     * must track the lowest allowed byte size / BYTESIZE radio button.
     */
    m_Async.ByteSize = (ULONG)
        (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_BYTESIZE_7,
                                IDC_ASYNC_ADVANCED_BYTESIZE_8 )
                - IDC_ASYNC_ADVANCED_BYTESIZE_7 + 7);

    return(TRUE);

}  // end CAdvancedAsyncDlg::GetGlobalFields

//---------------------------------------------------------------------------------------------------
BOOL CAdvancedAsyncDlg::GetHWFields()
{
    /*
     * Fetch the HW receive flow class.
     */
    m_Async.FlowControl.HardwareReceive = ( RECEIVEFLOWCONTROLCLASS )
        SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWRX ) , CB_GETCURSEL , 0 , 0 );

    /*
     * Fetch the HW transmit flow class.
     */
    m_Async.FlowControl.HardwareTransmit = ( TRANSMITFLOWCONTROLCLASS )
        SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWTX ) , CB_GETCURSEL , 0 , 0 );

    return TRUE;

}  // end CAdvancedAsyncDlg::GetHWFields

//---------------------------------------------------------------------------------------------------
BOOL CAdvancedAsyncDlg::GetSWFields( BOOL bValidate )
{
    TCHAR string[UCHAR_DIGIT_MAX], *endptr;
    ULONG ul;
    INT_PTR nNewHexBase, base;

    /*
     * Determine the current state of the base controls and save.
     */
    nNewHexBase = (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_BASEDEC,
                                          IDC_ASYNC_ADVANCED_BASEHEX )
                                            - IDC_ASYNC_ADVANCED_BASEDEC);

    /*
     * Fetch and convert XON character.
     */
    GetDlgItemText( m_hDlg , IDC_ASYNC_ADVANCED_XON , string , SIZE_OF_BUFFER( string ) );

    /*
     * If the edit box is modified, use the 'new' base for conversion.
     */
    base = SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XON ) , EM_GETMODIFY , 0 , 0 ) ?  nNewHexBase : m_nHexBase ;

    ul = _tcstoul( string, &endptr, (base ? 16 : 10) );

    /*
     * If validation is requested and there is a problem with the input,
     * complain and allow user to fix.
     */
    if( bValidate && ( (*endptr != TEXT('\0') ) || ( ul > 255 ) ) )
    {

        /*
         * Invalid character in field or invalid value.
         */
        // ERROR_MESSAGE((IDP_INVALID_XONXOFF))

        /*
         * Set focus to the control so that it can be fixed.
         */
        SetFocus( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XON ) );

        return FALSE;
    }

    /*
     * Save the Xon character.
     */
    m_Async.FlowControl.XonChar = (UCHAR)ul;

    /*
     * Fetch and convert XOFF character.
     */
    GetDlgItemText( m_hDlg , IDC_ASYNC_ADVANCED_XOFF , string , SIZE_OF_BUFFER( string ) );

    /*
     * If the edit box is modified, use the 'new' base for conversion.
     */

    base = SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XOFF ) , EM_GETMODIFY , 0 , 0 ) ?  nNewHexBase : m_nHexBase ;

    ul = _tcstoul( string, &endptr, (base ? 16 : 10) );

    /*
     * If validation is requested and there is a problem with the input,
     * complain and allow user to fix.
     */
    if( bValidate && ( (*endptr != TEXT('\0' )) || ( ul > 255 ) ) )
    {
        /*
         * Invalid character in field or invalid value.
         */
        // ERROR_MESSAGE((IDP_INVALID_XONXOFF))

        /*
         * Set focus to the control so that it can be fixed.
         */
        SetFocus( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XOFF ) );

        return FALSE;
    }

    /*
     * Save the Xoff character.
     */
    m_Async.FlowControl.XoffChar = (UCHAR)ul;

    /*
     * Save the current base state.
     */
    m_nHexBase = nNewHexBase;

    return TRUE;

}  // end CAdvancedAsyncDlg::GetSWFields


////////////////////////////////////////////////////////////////////////////////
// CAdvancedAsyncDlg message map
BOOL CAdvancedAsyncDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    switch( wNotifyCode )
    {
    case BN_CLICKED:
        if( wID == IDC_ASYNC_ADVANCED_BASEDEC )
        {
            OnClickedAsyncAdvancedBasedec( );
        }
        else if( wID == IDC_ASYNC_ADVANCED_BASEHEX )
        {
            OnClickedAsyncAdvancedBasehex( );
        }
        else if( wID == IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE )
        {
            OnClickedAsyncAdvancedFlowcontrolHardware( );
        }
        else if( wID == IDC_ASYNC_ADVANCED_FLOWCONTROL_SOFTWARE )
        {
            OnClickedAsyncAdvancedFlowcontrolSoftware( );
        }
        else if( wID == IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE )
        {
            OnClickedAsyncAdvancedFlowcontrolNone( );
        }
        else if( wID == IDOK )
        {
            OnOK( );

            return EndDialog( m_hDlg , IDOK );
        }
        else if( wID == IDCANCEL )
        {
            OnCancel( );

            return EndDialog( m_hDlg , IDCANCEL );
        }
        else if( wID == ID_HELP )
        {
            TCHAR tchHelpFile[ MAX_PATH ];

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ASYNC_HELPFILE , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) ) );
            
            WinHelp( GetParent( hwndCtrl ) , tchHelpFile , HELP_CONTEXT , HID_ASYNCADVANCE );
        }

        break;

    case CBN_CLOSEUP:

        if( wID == IDC_ASYNC_ADVANCED_HWRX )
        {
            OnCloseupAsyncAdvancedHwrx( );
        }
        else if( wID == IDC_ASYNC_ADVANCED_HWTX )
        {
            OnCloseupAsyncAdvancedHwtx( );
        }
        break;

    case CBN_SELCHANGE:

        if( wID == IDC_ASYNC_ADVANCED_HWRX )
        {
            OnSelchangeAsyncAdvancedHwrx( );
        }
        else if( wID == IDC_ASYNC_ADVANCED_HWTX )
        {
            OnSelchangeAsyncAdvancedHwtx( );
        }
        break;

    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
// CAdvancedAsyncDlg commands

//---------------------------------------------------------------------------------------------------
BOOL CAdvancedAsyncDlg::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );

    // int i;
    TCHAR tchString[ 80 ];

    HWND hCbx = GetDlgItem( hDlg , IDC_ASYNC_ADVANCED_HWRX );

    ASSERT( hCbx != NULL );

    // Load up combo boxes with strings.

    m_hDlg = hDlg;

    int idx = 0;

    HRESULT hr;

    while( SUCCEEDED( ( hr =  m_pCfgcomp->GetHWReceiveName( idx , tchString ) ) ) )
    {
        if( hr == S_FALSE )
        {
            break;
        }

        SendMessage( hCbx , CB_ADDSTRING , 0 , ( LPARAM )tchString );

        idx++;
    }

    hCbx = GetDlgItem( hDlg , IDC_ASYNC_ADVANCED_HWTX);

    ASSERT( hCbx != NULL );

    idx = 0;

    while( SUCCEEDED( ( hr =  m_pCfgcomp->GetHWTransmitName( idx , tchString ) ) ) )
    {
        if( hr == S_FALSE )
        {
            break;
        }

        SendMessage( hCbx , CB_ADDSTRING , 0 , ( LPARAM )tchString );

        idx++;
    }

    // Initalize all dialog fields.

    SetFields();

    /*


    if ( m_bReadOnly ) {

        /*
         * Document is 'read-only': disable all dialog controls and labels
         * except for CANCEL & HELP buttons.

        for ( i=IDL_ASYNC_ADVANCED_FLOWCONTROL;
              i <=IDC_ASYNC_ADVANCED_BYTESIZE_8; i++ )
            GetDlgItem(i)->EnableWindow(FALSE);
        GetDlgItem(IDOK)->EnableWindow(FALSE);
    }
    */

    return(TRUE);

}  // end CAdvancedAsyncDlg::OnInitDialog

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolHardware()
{
    GetFlowControlFields();
    SetFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolHardware

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolSoftware()
{
    GetFlowControlFields();
    SetFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolSoftware

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolNone()
{
    GetFlowControlFields();
    SetFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolNone

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnCloseupAsyncAdvancedHwrx()
{
    OnSelchangeAsyncAdvancedHwrx();

}  // end CAdvancedAsyncDlg::OnCloseupAsyncAdvancedHwrx

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnSelchangeAsyncAdvancedHwrx()
{
    HWND hCbx  = GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWRX );

    ASSERT( hCbx != NULL );

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        return;
    }

    /*
     * Fetch and Set the Hardware fields to update.
     */
    GetHWFields();
    SetHWFields();
    SetHWFlowText();

}  // end CAdvancedAsyncDlg::OnSelchangeAsyncAdvancedHwrx

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnCloseupAsyncAdvancedHwtx()
{
    OnSelchangeAsyncAdvancedHwtx();

}  // end CAdvancedAsyncDlg::OnCloseupAsyncAdvancedHwtx

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnSelchangeAsyncAdvancedHwtx()
{
    HWND hCbx  = GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWTX );

    ASSERT( hCbx != NULL );

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        return;
    }



    /*
     * Fetch and Set the Hardware fields to update.
     */
    GetHWFields();
    SetHWFields();
    SetHWFlowText();

}  // end CAdvancedAsyncDlg::OnSelchangeAsyncAdvancedHwtx

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnClickedAsyncAdvancedBasedec()
{
    /*
     * Get/Set the SW fields to display in decimal base.
     */
    GetSWFields(FALSE);
    SetSWFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedBasedec

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnClickedAsyncAdvancedBasehex()
{
    /*
     * Get/Set the SW fields to display in hexadecimal base.
     */
    GetSWFields(FALSE);
    SetSWFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedBasehex

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnOK()
{
    /*
     * If the Enter key was pressed while a combo box was dropped down, ignore
     * it (treat as combo list selection only).
     */
    if ( !HandleEnterEscKey(IDOK) )
        return;

    /*
     * Fetch the field contents.  Return (don't close dialog) if a problem
     * was found.
     */
    GetFields();


}  // end CAdvancedAsyncDlg::OnOK

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnCancel()
{
    /*
     * If the Esc key was pressed while a combo box was dropped down, ignore
     * it (treat as combo close-up and cancel only).
     */
    HandleEnterEscKey( IDCANCEL );

}  // end CAdvancedAsyncDlg::OnCancel

//---------------------------------------------------------------------------------------------------
int CAdvancedAsyncDlg::GetCheckedRadioButton( int nIDFirstButton, int nIDLastButton )
{
    for (int nID = nIDFirstButton; nID <= nIDLastButton; nID++)
    {
        if( IsDlgButtonChecked( m_hDlg , nID ) )
        {
            return nID; // id that matched
        }
    }

    return 0; // invalid ID
}

//---------------------------------------------------------------------------------------------------
INT_PTR CALLBACK CAdvancedAsyncDlg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CAdvancedAsyncDlg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CAdvancedAsyncDlg *pDlg = ( CAdvancedAsyncDlg * )lp;

        SetWindowLongPtr( hwnd , DWLP_USER, ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CAdvancedAsyncDlg ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CAdvancedAsyncDlg * )GetWindowLongPtr( hwnd , DWLP_USER);

        if( IsBadReadPtr( pDlg , sizeof( CAdvancedAsyncDlg ) ) )
        {
            return 0;
        }
    }

    switch( msg )
    {

    /*case WM_DESTROY:

        pDlg->OnDestroy( );

        break;*/

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            // pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        // pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    /*case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );*/
    }

    return 0;
}
/***********************************************************************************************************/

//---------------------------------------------------------------------------------------------------
void CEchoEditControl::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    UNREFERENCED_PARAMETER( nRepCnt );
    UNREFERENCED_PARAMETER( nFlags );
    /*
     * Tell dialog to write the character to the device unless we're
     * currently processing edit control output.  This flag check is needed
     * because the CEdit::Cut() member function will generate an OnChar()
     * event, which we need to ignore ('\b' processing).
     */

    if( !m_bProcessingOutput )
    {
        ODS( L"CEchoEditControl::OnChar -- WM_ASYNCTESTWRITECHAR( S )\n" );

        ::SendMessage( m_hDlg , WM_ASYNCTESTWRITECHAR, nChar, 0 );
    }

    /*
     * Pass character on to the edit control.  This will do nothing if
     * the edit control is 'read only'.  To cause a 'local echo' effect,
     * set the edit control to 'read/write'.
     */

}

//---------------------------------------------------------------------------------------------------
void CEchoEditControl::SubclassDlgItem( HWND hDlg , int nRes )
{
    HWND hCtrl = GetDlgItem( hDlg , nRes );

    ASSERT( hCtrl != NULL );

    m_oldproc = ( WNDPROC )SetWindowLongPtr( hCtrl , GWLP_WNDPROC , ( LONG_PTR )CEchoEditControl::WndProc );

    SetWindowLongPtr( hCtrl , GWLP_USERDATA , ( LONG_PTR )this );

}

//---------------------------------------------------------------------------------------------------
LRESULT CALLBACK CEchoEditControl::WndProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CEchoEditControl *pEdit = ( CEchoEditControl * )GetWindowLongPtr( hwnd , GWLP_USERDATA );

    if( pEdit == NULL )
    {
        ODS( L"CEchoEditControl static object not set\n" );

        return 0;
    }

    switch( msg )
    {

    case WM_CHAR:

        pEdit->OnChar( ( TCHAR )wp , LOWORD( lp ) , HIWORD( lp ) );

        break;
    }

    if( pEdit->m_oldproc != NULL )
    {
        return ::CallWindowProc( pEdit->m_oldproc , hwnd , msg ,wp , lp ) ;
    }

    return DefWindowProc( hwnd , msg ,wp , lp );
}

//---------------------------------------------------------------------------------------------------
CLed::CLed( HBRUSH hBrush )
{
    m_hBrush = hBrush;

    m_bOn = FALSE;
}

//---------------------------------------------------------------------------------------------------
void CLed::Subclass( HWND hDlg  , int nRes )
{
    HWND hCtrl = GetDlgItem( hDlg , nRes );

    ASSERT( hCtrl != NULL );

    m_hWnd = hCtrl;

    m_oldproc = ( WNDPROC )SetWindowLongPtr( hCtrl , GWLP_WNDPROC , ( LONG_PTR )CLed::WndProc );

    SetWindowLongPtr( hCtrl , GWLP_USERDATA , ( LONG_PTR )this );
}

//---------------------------------------------------------------------------------------------------
void CLed::Update(int nOn)
{
    m_bOn = nOn ? TRUE : FALSE;

    InvalidateRect( m_hWnd , NULL , FALSE );

    UpdateWindow( m_hWnd );
}

//---------------------------------------------------------------------------------------------------
void CLed::Toggle()
{
    ODS(L"CLed::Toggle\n");

    m_bOn = !m_bOn;

    InvalidateRect( m_hWnd , NULL , FALSE );

    // UpdateWindow( m_hWnd );
}

void CLed::OnPaint( HWND hwnd )
{
    RECT rect;
    PAINTSTRUCT ps;

    ODS(L"CLed::OnPaint\n");

    HDC dc = BeginPaint( hwnd , &ps );

    HBRUSH brush;

    GetClientRect( hwnd , &rect );

#ifdef USING_3DCONTROLS
    (rect.right)--;
    (rect.bottom)--;
    brush = ( HBRUSH )GetStockObject( GRAY_BRUSH );

    FrameRect( dc , &rect, brush );

    (rect.top)++;
    (rect.left)++;
    (rect.right)++;
    (rect.bottom)++;

    brush = ( HBRUSH )GetStockObject( WHITE_BRUSH );

    FrameRect( dc , &rect, brush );

    (rect.top)++;
    (rect.left)++;
    (rect.right) -= 2;
    (rect.bottom) -= 2;
#else

    brush = ( HBRUSH )GetStockObject( BLACK_BRUSH );
    FrameRect( dc , &rect , brush );
    (rect.top)++;
    (rect.left)++;
    (rect.right)--;
    (rect.bottom)--;
#endif
    DBGMSG( L"led should be %s\n" , m_bOn ? L"red" : L"grey" );

    brush = m_bOn ? m_hBrush : ( HBRUSH )GetStockObject( LTGRAY_BRUSH );

    FillRect( dc , &rect , brush );

    EndPaint( hwnd , &ps );

}

//---------------------------------------------------------------------------------------------------
LRESULT CALLBACK CLed::WndProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CLed *pWnd = ( CLed * )GetWindowLongPtr( hwnd , GWLP_USERDATA );

    if( pWnd == NULL )
    {
        ODS( L"CLed is not available\n" );

        return 0;
    }


    switch( msg )
    {

    case WM_PAINT:

        pWnd->OnPaint( hwnd );

        break;
    }

    if( pWnd->m_oldproc != NULL )
    {
        return ::CallWindowProc( pWnd->m_oldproc , hwnd , msg ,wp , lp ) ;
    }

    return DefWindowProc( hwnd , msg ,wp , lp );

}

//---------------------------------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
// CThread class construction / destruction, implementation

/*******************************************************************************
 *
 *  CThread - CThread constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CThread::CThread()
{
    m_hThread = NULL;

    m_dwThreadID = 0;
}  // end CThread::CThread


/*******************************************************************************
 *
 *  ~CThread - CThread destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/
CThread::~CThread()
{
}  // end CThread::~CThread


////////////////////////////////////////////////////////////////////////////////
// CThread operations: primary thread

/*******************************************************************************
 *
 *  CreateThread - CThread implementation function
 *
 *      Class wrapper for the Win32 CreateThread API.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

HANDLE CThread::CreateThread( DWORD cbStack , DWORD fdwCreate )
{
    /*
     * Simple wrapper for Win32 CreateThread API.
     */
    return( m_hThread = ::CreateThread( NULL, cbStack, ThreadEntryPoint , ( LPVOID ) this, fdwCreate, &m_dwThreadID ) );

}  // end CThread::CreateThread


////////////////////////////////////////////////////////////////////////////////
// CThread operations: secondary thread

/*******************************************************************************
 *
 *  ThreadEntryPoint - CThread implementation function
 *                     (SECONDARY THREAD)
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

DWORD __stdcall CThread::ThreadEntryPoint( LPVOID lpParam )
{
    CThread *pThread;
    DWORD dwResult = ( DWORD )-1;

    /*
     * (lpParam is actually the 'this' pointer)
     */
    pThread = (CThread*)lpParam;



    /*
     * Run the thread.
     */
    if( pThread != NULL )
    {
        dwResult = pThread->RunThread();
    }

    /*
     * Return the result.
     */
    return(dwResult);

}  // end CThread::ThreadEntryPoint
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// CATDlgInputThread class construction / destruction, implementation

/*******************************************************************************
 *
 *  CATDlgInputThread - CATDlgInputThread constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CATDlgInputThread::CATDlgInputThread()
{
    /*
     * Initialize member variables.
     */
    m_bExit = FALSE;
    m_ErrorStatus = ERROR_SUCCESS;
    m_hConsumed = NULL;

    ZeroMemory( &m_OverlapSignal , sizeof( OVERLAPPED ) );
    ZeroMemory( &m_OverlapRead   , sizeof( OVERLAPPED ) );

    //m_OverlapSignal.hEvent = NULL;
    //m_OverlapRead.hEvent = NULL;
    m_BufferBytes = 0;


}  // end CATDlgInputThread::CATDlgInputThread


/*******************************************************************************
 *
 *  ~CATDlgInputThread - CATDlgInputThread destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CATDlgInputThread::~CATDlgInputThread()
{
    /*
     * Close the semaphore and events when the CATDlgInputThread
     * object is destroyed.
     */
    if ( m_hConsumed )
        CloseHandle(m_hConsumed);

    if ( m_OverlapRead.hEvent )
        CloseHandle(m_OverlapRead.hEvent);

    if ( m_OverlapSignal.hEvent )
        CloseHandle(m_OverlapSignal.hEvent);

}  // end CATDlgInputThread::~CATDlgInputThread


/*******************************************************************************
 *
 *  RunThread - CATDlgInputThread secondary thread main function loop
 *              (SECONDARY THREAD)
 *
 *  ENTRY:
 *  EXIT:
 *      (DWORD) exit status for the secondary thread.
 *
 ******************************************************************************/

DWORD
CATDlgInputThread::RunThread()
{
    HANDLE hWait[2];
    DWORD Status;
    int iStat;

    /*
     * Initialize for overlapped status and read input.
     */
    m_hConsumed = CreateSemaphore( NULL , 0 , MAX_STATUS_SEMAPHORE_COUNT , NULL );

    m_OverlapRead.hEvent = CreateEvent( NULL , TRUE , FALSE , NULL );

    m_OverlapSignal.hEvent = CreateEvent( NULL , TRUE , FALSE , NULL );

    if ( m_hConsumed == NULL || m_OverlapRead.hEvent == NULL || m_OverlapSignal.hEvent == NULL ||
         !SetCommMask( m_hDevice , EV_CTS | EV_DSR | EV_ERR | EV_RING | EV_RLSD | EV_BREAK ) )
    {

        NotifyAbort(IDP_ERROR_CANT_INITIALIZE_INPUT_THREAD);
        return(1);
    }

    /*
     * Query initial comm status to initialize dialog with (return if error).
     */
    if ( (iStat = CommStatusAndNotify()) != -1 )
        return(iStat);

    /*
     *  Post Read for input data.
     */
    if ( (iStat = PostInputRead()) != -1 )
        return(iStat);

    /*
     *  Post Read for status.
     */
    if ( (iStat = PostStatusRead()) != -1 )
        return(iStat);

    /*
     * Loop till exit requested.
     */
    for ( ; ; ) {

        /*
         * Wait for either input data or an comm status event.
         */
        hWait[0] = m_OverlapRead.hEvent;
        hWait[1] = m_OverlapSignal.hEvent;

        ODS( L"CATDlgInputThread::RunThread waiting on either event to be signaled\n");
        Status = WaitForMultipleObjects(2, hWait, FALSE, INFINITE);

        /*
         * Check for exit.
         */
        if ( m_bExit )
        {
            ODS( L"CATDlgInputThread::RunThread exiting\n" );

            return(0);
        }

        if ( Status == WAIT_OBJECT_0 ) {

            /*
             * Read event:
             * Get result of overlapped read.
             */

            ODS(L"CATDlgInputThread::RunThread Read event signaled\n" );

            if ( !GetOverlappedResult( m_hDevice,
                                       &m_OverlapRead,
                                       &m_BufferBytes,
                                       TRUE ) ) {

                NotifyAbort(IDP_ERROR_GET_OVERLAPPED_RESULT_READ);
                return(1);
            }

            /*
             * Notify dialog.
             */
            if ( (iStat = CommInputNotify()) != -1 )
                return(iStat);

            /*
             *  Post Read for input data.
             */
            if ( (iStat = PostInputRead()) != -1 )
                return(iStat);

        } else if ( Status == WAIT_OBJECT_0+1 ) {

            ODS(L"CATDlgInputThread::RunThread Signal event signaled\n" );

            /*
             * Comm status event:
             * Query comm status and notify dialog.
             */
            if ( (iStat = CommStatusAndNotify()) != -1 )
                return(iStat);

            /*
             *  Post Read for status.
             */
            if ( (iStat = PostStatusRead()) != -1 )
                return(iStat);


        } else {

            /*
             * Unknown event: Abort.
             */
            NotifyAbort(IDP_ERROR_WAIT_FOR_MULTIPLE_OBJECTS);
            return(1);
        }
    }

}  // end CATDlgInputThread::RunThread


////////////////////////////////////////////////////////////////////////////////
// CATDlgInputThread operations: primary thread

/*******************************************************************************
 *
 *  SignalConsumed - CATDlgInputThread member function: public operation
 *
 *      Release the m_hConsumed semaphore to allow secondary thread to continue
 *      running.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CATDlgInputThread::SignalConsumed()
{
    ReleaseSemaphore( m_hConsumed, 1, NULL );

}  // end CATDlgInputThread::SignalConsumed


/*******************************************************************************
 *
 *  ExitThread - CATDlgInputThread member function: public operation
 *
 *      Tell the secondary thread to exit and cleanup after.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CATDlgInputThread::ExitThread()
{
    DWORD dwReturnCode;
    int i;
    // CWaitCursor wait;

    /*
     * If the thread was not created properly, just delete object and return.
     */
    if ( !m_hThread ) {
        delete this;
        return;
    }

    /*
     * Set the m_bExit flag to TRUE, wake up the run thread's WaitCommEvent() by
     * resetting device's Comm mask, and bump the consumed semaphore to assure exit.
     */
    m_bExit = TRUE;
    SetCommMask(m_hDevice, 0);
    SignalConsumed();

    /*
     * Purge the recieve buffer and any pending read.
     */
    PurgeComm(m_hDevice, PURGE_RXABORT | PURGE_RXCLEAR);

    /*
     * Wait a while for the thread to exit.
     */
    for ( i = 0, GetExitCodeThread( m_hThread, &dwReturnCode );
          (i < MAX_SLEEP_COUNT) && (dwReturnCode == STILL_ACTIVE); i++ ) {

        Sleep(100);
        GetExitCodeThread( m_hThread, &dwReturnCode );
    }

    /*
     * If the thread has still not exited, terminate it.
     */
    if( dwReturnCode == STILL_ACTIVE )
    {
        TerminateThread( m_hThread, 1 );

        ODS( L"Thread terminated irregularly\n" );
    }

    /*
     * Close the thread handle and delete this CATDlgInputThread object
     */
    CloseHandle( m_hThread );

    delete this;

}  // end CATDlgInputThread::ExitThread


////////////////////////////////////////////////////////////////////////////////
// CATDlgInputThread operations: secondary thread

/*******************************************************************************
 *
 *  NotifyAbort - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Notify the dialog of thread abort and reason.
 *
 *  ENTRY:
 *      idError (input)
 *          Resource id for error message.
 *  EXIT:
 *
 ******************************************************************************/

void
CATDlgInputThread::NotifyAbort(UINT idError )
{
    TCHAR tchErrTitle[ 80 ];

    TCHAR tchErrMsg[ 256 ];
    //::PostMessage(m_hDlg, WM_ASYNCTESTABORT, idError, GetLastError());
    LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) );

    LoadString( _Module.GetResourceInstance( ) , idError , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) );

    MessageBox( m_hDlg , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );


}  // end CATDlgInputThread::NotifyAbort


/*******************************************************************************
 *
 *  CommInputNotify - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Notify the dialog of comm input.
 *
 *  ENTRY:
 *  EXIT:
 *      -1 no error and continue thread
 *      0 if ExitThread was requested by parent
 *
 ******************************************************************************/

int
CATDlgInputThread::CommInputNotify()
{
    /*
     * Tell the dialog that we've got some new input.
     */
    ::PostMessage(m_hDlg, WM_ASYNCTESTINPUTREADY, 0, 0);

    ODS( L"TSCC:CATDlgInputThread::CommInputNotify WM_ASYNCTESTINPUTREADY (P)\n" );
    ODS( L"TSCC:CATDlgInputThread::CommInputNotify waiting on semaphore\n" );
    WaitForSingleObject(m_hConsumed, INFINITE);
    ODS( L"TSCC:CATDlgInputThread::CommInputNotify semaphore signaled\n" );

    /*
     * Check for thread exit request.
     */
    if ( m_bExit )
        return(0);
    else
        return(-1);

}  // end CATDlgInputThread::CommInputNotify


/*******************************************************************************
 *
 *  CommStatusAndNotify - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Read the comm port status and notify dialog.
 *
 *  ENTRY:
 *  EXIT:
 *      -1 no error and continue thread
 *      0 if ExitThread was requested by parent
 *      1 error condition
 *
 ******************************************************************************/

int
CATDlgInputThread::CommStatusAndNotify()
{
    PFLOWCONTROLCONFIG pFlow = NULL;
    DWORD ModemStatus = 0;
	DWORD Error = 0;

    if ( !GetCommModemStatus(m_hDevice, &ModemStatus) ) {

        /*
         * We can't query the comm information; tell the primary thread
         * that we've aborted, and return error (will exit thread).
         */
        NotifyAbort(IDP_ERROR_GET_COMM_MODEM_STATUS);
        return(1);
    }

    /*
     *  Update modem status
     */
    m_Status.AsyncSignal = ModemStatus;

    /*
     *  Or in status of DTR and RTS
     */
    // pFlow = &m_PdConfig.Params.Async.FlowControl;

    pFlow = &m_ac.FlowControl;

    if ( pFlow->fEnableDTR )
        m_Status.AsyncSignal |= MS_DTR_ON;
    if ( pFlow->fEnableRTS )
        m_Status.AsyncSignal |= MS_RTS_ON;

    /*
     *  OR in new event mask
     */
    m_Status.AsyncSignalMask |= m_EventMask;

    /*
     *  Update async error counters
     */
    if ( m_EventMask & EV_ERR ) {
        (VOID) ClearCommError( m_hDevice, &Error, NULL );
        if ( Error & CE_OVERRUN )
            m_Status.Output.AsyncOverrunError++;
        if ( Error & CE_FRAME )
            m_Status.Input.AsyncFramingError++;
        if ( Error & CE_RXOVER )
            m_Status.Input.AsyncOverflowError++;
        if ( Error & CE_RXPARITY )
            m_Status.Input.AsyncParityError++;
    }

    /*
     * Tell the dialog that we've got some new status information.
     */
    ::PostMessage(m_hDlg, WM_ASYNCTESTSTATUSREADY, 0, 0);

    ODS( L"TSCC:CATDlgInputThread::CommStatusAndNotify WM_ASYNCTESTSTATUSREADY( P )\n");
    ODS( L"TSCC:CATDlgInputThread::CommStatusAndNotify waiting on semaphore\n" );
    WaitForSingleObject(m_hConsumed, INFINITE);
    ODS( L"TSCC:CATDlgInputThread::CommStatusAndNotify semaphore signaled\n" );


    /*
     * Check for thread exit request.
     */
    if ( m_bExit )
        return(0);
    else
        return(-1);

}  // end CATDlgInputThread::CommStatusAndNotify


/*******************************************************************************
 *
 *  PostInputRead - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Post a ReadFile operation for the device, processing as long as data
 *      is present.
 *
 *  ENTRY:
 *  EXIT:
 *      -1 if read operation posted sucessfully
 *      0 if ExitThread was requested by parent
 *      1 if error condition
 *
 ******************************************************************************/

int
CATDlgInputThread::PostInputRead()
{
    int iStat;

    // TCHAR tchErrTitle[ 80 ];

    // TCHAR tchErrMsg[ 256 ];

    ODS(L"TSCC:CATDlgInputThread::PostInputRead\n");


    /*
     * Post read for input data, processing immediataly if not 'pending'.
     */

    while ( ReadFile( m_hDevice, m_Buffer, MAX_COMMAND_LEN,
                   &m_BufferBytes, &m_OverlapRead ) )
    {
        DBGMSG( L"Buffer received %s\n",m_Buffer );

        if ( (iStat = CommInputNotify()) != -1 )
            return(iStat);
    }

    /*
     *  Make sure read is pending (not some other error).
     */
    if ( GetLastError() != ERROR_IO_PENDING )
    {
        DBGMSG( L"ReadFile returned 0x%x\n" , GetLastError() );

        NotifyAbort(IDP_ERROR_READ_FILE);
    /*    LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , sizeof( tchErrTitle ) );

        LoadString( _Module.GetResourceInstance( ) , IDP_ERROR_READ_FILE , tchErrMsg , sizeof( tchErrMsg ) );

        MessageBox( m_hDlg , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );*/

        EndDialog(m_hDlg, IDCANCEL);

        return(1);
    }

    /*
     * Return 'posted sucessfully' status.
     */
    return(-1);

}  // end CATDlgInputThread::PostInputRead


/*******************************************************************************
 *
 *  PostStatusRead - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Post a WaitCommStatus operation for the device.
 *
 *  ENTRY:
 *  EXIT:
 *      -1 if status operation posted sucessfully
 *      1 if error condition
 *
 ******************************************************************************/

int
CATDlgInputThread::PostStatusRead()
{
    /*
     * Post read for comm status.
     */
    ODS( L"CATDlgInputThread::PostStatusRead\n");

    if ( !WaitCommEvent(m_hDevice, &m_EventMask, &m_OverlapSignal) ) {

        /*
         *  Make sure comm status read is pending (not some other error).
         */
        if ( GetLastError() != ERROR_IO_PENDING ) {

            NotifyAbort(IDP_ERROR_WAIT_COMM_EVENT);
            return(1);
        }
    }

    /*
     * Return 'posted sucessfully' status.
     */
    return(-1);

}  // end CATDlgInputThread::PostStatusRead
////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg class construction / destruction, implementation

/*******************************************************************************
 *
 *  CAsyncTestDlg - CAsyncTestDlg constructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::CDialog documentation)
 *
 ******************************************************************************/

CAsyncTestDlg::CAsyncTestDlg(ICfgComp * pCfgComp) :
      m_hDevice(INVALID_HANDLE_VALUE),
      m_hRedBrush(NULL),
      m_LEDToggleTimer(0),
      m_pATDlgInputThread(NULL),
      m_CurrentPos(0),
      m_hModem(NULL),
      m_bDeletedWinStation(FALSE)
{
    /*
     * Create a solid RED brush for painting the 'LED's when 'on'.
     */
    m_hRedBrush = CreateSolidBrush( RGB( 255 , 0 , 0 ) );

    /*
     * Initialize member variables.
     */

    FillMemory( &m_Status , sizeof( PROTOCOLSTATUS ) , 0 );

    FillMemory( &m_OverlapWrite , sizeof( OVERLAPPED ) , 0 );

    /*
     * Create the led objects.
     */
    for( int i = 0 ; i < NUM_LEDS ; i++ )
    {
        m_pLeds[i] = new CLed(m_hRedBrush);

    }

    m_pCfgComp = pCfgComp;

    if( pCfgComp != NULL )
    {
        m_pCfgComp->AddRef();
    }


}  // end CAsyncTestDlg::CAsyncTestDlg


/*******************************************************************************
 *
 *  ~CAsyncTestDlg - CAsyncTestDlg destructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::~CDialog documentation)
 *
 ******************************************************************************/

CAsyncTestDlg::~CAsyncTestDlg()
{
    /*
     * Zap our led objects.
     */
    for( int i = 0; i < NUM_LEDS; i++ )
    {
        if( m_pLeds[i] != NULL  )
        {
            delete m_pLeds[i];
        }
    }
    if(m_pCfgComp != NULL )
    {
        m_pCfgComp->Release();
    }

}  // end CAsyncTestDlg::~CAsyncTestDlg


////////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg operations

/*******************************************************************************
 *
 *  NotifyAbort - CAsyncTestDlg member function: private operation
 *
 *      Post a WM_ASYNCTESTABORT message to notify the dialog of
 *      abort and reason.
 *
 *  ENTRY:
 *      idError (input)
 *          Resource id for error message.
 *  EXIT:
 *
 ******************************************************************************/

void CAsyncTestDlg::NotifyAbort( UINT idError )
{
    TCHAR tchErrTitle[ 80 ];

    TCHAR tchErrMsg[ 256 ];

    LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) );

    LoadString( _Module.GetResourceInstance( ) , idError , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) );

    MessageBox( m_hDlg , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );


}  // end CAsyncTestDlg::NotifyAbort


/*******************************************************************************
 *
 *  DeviceSetParams - CAsyncTestDlg member function: private operation
 *
 *      Set device parameters for opened device.
 *
 *  ENTRY:
 *  EXIT:
 *    TRUE - no error; FALSE error.
 *
 ******************************************************************************/

BOOL CAsyncTestDlg::DeviceSetParams()
{
    PASYNCCONFIG pAsync;
    PFLOWCONTROLCONFIG pFlow;
    DCB Dcb;

    /*
     *  Get pointer to async parameters
     */
    // pAsync = &m_PdConfig0.Params.Async;

    pAsync = &m_ac;

    /*
     *  Get current DCB
     */
    if( !GetCommState( m_hDevice, &Dcb ) )
    {
        return(FALSE);
    }

    /*
     *  Set defaults
     */
    Dcb.fOutxCtsFlow      = FALSE;
    Dcb.fOutxDsrFlow      = FALSE;
    Dcb.fTXContinueOnXoff = TRUE;
    Dcb.fOutX             = FALSE;
    Dcb.fInX              = FALSE;
    Dcb.fErrorChar        = FALSE;
    Dcb.fNull             = FALSE;
    Dcb.fAbortOnError     = FALSE;

    /*
     *  Set Communication parameters
     */
    Dcb.BaudRate        = pAsync->BaudRate;
    Dcb.Parity          = (BYTE) pAsync->Parity;
    Dcb.StopBits        = (BYTE) pAsync->StopBits;
    Dcb.ByteSize        = (BYTE) pAsync->ByteSize;
    Dcb.fDsrSensitivity = pAsync->fEnableDsrSensitivity;

    pFlow = &pAsync->FlowControl;

    /*
     *  Initialize default DTR state
     */
    if ( pFlow->fEnableDTR )
        Dcb.fDtrControl = DTR_CONTROL_ENABLE;
    else
        Dcb.fDtrControl = DTR_CONTROL_DISABLE;

    /*
     *  Initialize default RTS state
     */
    if ( pFlow->fEnableRTS )
        Dcb.fRtsControl = RTS_CONTROL_ENABLE;
    else
        Dcb.fRtsControl = RTS_CONTROL_DISABLE;

    /*
     *  Initialize flow control
     */
    switch ( pFlow->Type ) {

        /*
         *  Initialize hardware flow control
         */
        case FlowControl_Hardware :

            switch ( pFlow->HardwareReceive ) {
                case ReceiveFlowControl_RTS :
                    Dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
                    break;
                case ReceiveFlowControl_DTR :
                    Dcb.fDtrControl = DTR_CONTROL_HANDSHAKE;
                    break;
            }
            switch ( pFlow->HardwareTransmit ) {
                case TransmitFlowControl_CTS :
                    Dcb.fOutxCtsFlow = TRUE;
                    break;
                case TransmitFlowControl_DSR :
                    Dcb.fOutxDsrFlow = TRUE;
                    break;
            }
            break;

        /*
         *  Initialize software flow control
         */
        case FlowControl_Software :
            Dcb.fOutX    = pFlow->fEnableSoftwareTx;
            Dcb.fInX     = pFlow->fEnableSoftwareRx;
            Dcb.XonChar  = (char) pFlow->XonChar;
            Dcb.XoffChar = (char) pFlow->XoffChar;
            break;

        case FlowControl_None :
            break;

    }

    /*
     *  Set new DCB
     */
    if ( !SetCommState( m_hDevice, &Dcb ) )
        return(FALSE);

    return( TRUE );

}  // end CAsyncTestDlg::DeviceSetParams


/*******************************************************************************
 *
 *  DeviceWrite - CAsyncTestDlg member function: private operation
 *
 *      Write out m_Buffer contents (m_BufferBytes length) to the m_hDevice.
 *
 *  ENTRY:
 *  EXIT:
 *    TRUE - no error; FALSE error.
 *
 ******************************************************************************/

BOOL CAsyncTestDlg::DeviceWrite()
{
    DWORD Error, BytesWritten;

    /*
     *  Write data
     */
    ODS( L"TSCC:CAsyncTestDlg::DeviceWrite Writing out to buffer\n" );

    if ( !WriteFile( m_hDevice, m_Buffer, m_BufferBytes,
                     &BytesWritten, &m_OverlapWrite ) )
    {
        DBGMSG( L"TSCC:CAsyncTestDlg::DeviceWrite WriteFile returned 0x%x\n" , GetLastError() );

        if ( (Error = GetLastError()) == ERROR_IO_PENDING )
        {
            /*
             *  Wait for write to complete (this may block till timeout)
             */
            if ( !GetOverlappedResult( m_hDevice, &m_OverlapWrite,
                                       &BytesWritten, TRUE ) )
            {
                CancelIo( m_hDevice );

                NotifyAbort(IDP_ERROR_GET_OVERLAPPED_RESULT_WRITE);

                return(FALSE);
            }

        } else {

            NotifyAbort(IDP_ERROR_WRITE_FILE);
            return(FALSE);
        }
    }

    return(TRUE);

}  // end CAsyncTestDlg::DeviceWrite

//---------------------------------------------------------------------
cwnd * CAsyncTestDlg::GetDlgItem( int nRes )
{
    HWND hCtrl = ::GetDlgItem( m_hDlg , nRes );

    for( int i = 0; i < NUM_LEDS; i++ )
    {
        if( m_pLeds[ i ] != NULL )
        {
            if( m_pLeds[ i ]->m_hWnd == hCtrl )
            {
                return m_pLeds[ i ];
            }
        }
    }

    return 0;
}

/*******************************************************************************
 *
 *  SetInfoFields - CAsyncTestDlg member function: private operation
 *
 *      Update the fields in the dialog with new data, if necessary.
 *
 *  ENTRY:
 *      pCurrent (input)
 *          points to COMMINFO structure containing the current Comm Input data.
 *      pNew (input)
 *          points to COMMINFO structure containing the new Comm Input data.
 *
 *  EXIT:
 *
 ******************************************************************************/

void CAsyncTestDlg::SetInfoFields( PPROTOCOLSTATUS pCurrent , PPROTOCOLSTATUS pNew )
{
    BOOL    bSetTimer = FALSE;

    /*
     * Set new LED states if state change, or set up for quick toggle if
     * no state changed, but change(s) were detected since last query.
     */
    if( ( pCurrent->AsyncSignal & MS_DTR_ON ) != ( pNew->AsyncSignal & MS_DTR_ON ) )
    {
        pNew->AsyncSignalMask &= ~EV_DTR;

        ((CLed *)GetDlgItem(IDC_ATDLG_DTR))->Update(pNew->AsyncSignal & MS_DTR_ON);

    } else if ( pNew->AsyncSignalMask & EV_DTR ) {

        pCurrent->AsyncSignal ^= MS_DTR_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_DTR))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_RTS_ON) !=
         (pNew->AsyncSignal & MS_RTS_ON) ) {

        pNew->AsyncSignalMask &= ~EV_RTS;
        ((CLed *)GetDlgItem(IDC_ATDLG_RTS))->
            Update(pNew->AsyncSignal & MS_RTS_ON);

    } else if ( pNew->AsyncSignalMask & EV_RTS ) {

        pCurrent->AsyncSignal ^= MS_RTS_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_RTS))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_CTS_ON) !=
         (pNew->AsyncSignal & MS_CTS_ON) ) {

        pNew->AsyncSignalMask &= ~EV_CTS;
        ((CLed *)GetDlgItem(IDC_ATDLG_CTS))->
            Update(pNew->AsyncSignal & MS_CTS_ON);

    } else if ( pNew->AsyncSignalMask & EV_CTS ) {

        pCurrent->AsyncSignal ^= MS_CTS_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_CTS))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_RLSD_ON) !=
         (pNew->AsyncSignal & MS_RLSD_ON) ) {

        pNew->AsyncSignalMask &= ~EV_RLSD;
        ((CLed *)GetDlgItem(IDC_ATDLG_DCD))->
            Update(pNew->AsyncSignal & MS_RLSD_ON);

    } else if ( pNew->AsyncSignalMask & EV_RLSD ) {

        pCurrent->AsyncSignal ^= MS_RLSD_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_DCD))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_DSR_ON) !=
         (pNew->AsyncSignal & MS_DSR_ON) ) {

        pNew->AsyncSignalMask &= ~EV_DSR;
        ((CLed *)GetDlgItem(IDC_ATDLG_DSR))->
            Update(pNew->AsyncSignal & MS_DSR_ON);

    } else if ( pNew->AsyncSignalMask & EV_DSR ) {

        pCurrent->AsyncSignal ^= MS_DSR_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_DSR))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_RING_ON) !=
         (pNew->AsyncSignal & MS_RING_ON) ) {

        pNew->AsyncSignalMask &= ~EV_RING;
        ((CLed *)GetDlgItem(IDC_ATDLG_RI))->
            Update(pNew->AsyncSignal & MS_RING_ON);

    } else if ( pNew->AsyncSignalMask & EV_RING ) {

        pCurrent->AsyncSignal ^= MS_RING_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_RI))->Toggle();

        bSetTimer = TRUE;
    }

    /*
     * Create our led toggle timer if needed.
     */
    if ( bSetTimer && !m_LEDToggleTimer )
    {
        m_LEDToggleTimer = SetTimer( m_hDlg , IDD_ASYNC_TEST , ASYNC_LED_TOGGLE_MSEC, NULL );
    }

}  // end CAsyncTestDlg::SetInfoFields


////////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg message map

BOOL CAsyncTestDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_ATDLG_MODEM_DIAL )
        {
            OnClickedAtdlgModemDial( );
        }
        else if( wID == IDC_ATDLG_MODEM_INIT )
        {
            OnClickedAtdlgModemInit( );
        }
        else if( wID == IDC_ATDLG_MODEM_LISTEN )
        {
            OnClickedAtdlgModemListen( );
        }
        else if( wID == IDOK )
        {
            EndDialog( m_hDlg , IDOK );
        }
        else if( wID == IDCANCEL )
        {
            EndDialog( m_hDlg , IDCANCEL );
        }
        else if( wID == ID_HELP )
        {
            TCHAR tchHelpFile[ MAX_PATH ];

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ASYNC_HELPFILE , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) ) );

            WinHelp( GetParent( hwndCtrl ) , tchHelpFile , HELP_CONTEXT , HID_ASYNCTEST );
        }

    }


    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg commands

/*******************************************************************************
 *
 *  OnInitDialog - CAsyncTestDlg member function: command (override)
 *
 *      Performs the dialog intialization.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnInitDialog documentation)
 *      WM_ASYNCTESTABORT message(s) will have been posted on error.
 *
 ******************************************************************************/

BOOL CAsyncTestDlg::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );

    int i;

    DEVICENAME DeviceName;

    COMMTIMEOUTS CommTimeouts;

    TCHAR tchErrTitle[ 80 ];

    TCHAR tchErrMsg[ 256 ];

    m_hDlg = hDlg;

//#ifdef WINSTA
    ULONG LogonId;
//#endif // WINSTA


    /*
     * Fill in the device and baud fields.
     */
    SetDlgItemText( hDlg , IDL_ATDLG_DEVICE , m_ac.DeviceName );

    SetDlgItemInt( hDlg , IDL_ATDLG_BAUD , m_ac.BaudRate , FALSE );


    /*
     * If a WinStation memory object is currently present, reset it.
     */
//#ifdef WINSTA
    if ( m_pWSName != NULL ) //&& LogonIdFromWinStationName( SERVERNAME_CURRENT , m_pWSName , &LogonId ) )
    {
        LONG Status;

        ULONG Length;

        LONG lCount = 0;

        TCHAR tchbuf[ 256 ];

        if( m_pCfgComp != NULL )
        {
            ODS( L"TSCC : Testing for live connections\n" );

            m_pCfgComp->QueryLoggedOnCount( m_pWSName,&lCount);

            if( lCount )
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WRN_TSTCON , tchbuf , SIZE_OF_BUFFER( tchbuf ) ) );

                wsprintf( tchErrMsg , tchbuf , m_pWSName);

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) ) );

                if( MessageBox( hDlg , tchbuf , tchErrTitle , MB_YESNO | MB_ICONEXCLAMATION ) == IDNO )
                {
                    PostMessage( hDlg , WM_COMMAND , MAKEWPARAM( IDOK, BN_CLICKED ) , (LPARAM)(::GetDlgItem( hDlg , IDOK ) ) );

                    return(TRUE);   // exit dialog via posted 'OK' click
                }
            }
        }

        Status = RegWinStationQuery( SERVERNAME_CURRENT,
                                           m_pWSName,
                                           &m_WSConfig,
                                           sizeof(WINSTATIONCONFIG2),
                                           &Length );
        if(Status)
        {
            NotifyAbort(IDP_ERROR_DISABLE);
            return(TRUE);
        }

        m_WSConfig.Create.fEnableWinStation = FALSE;

        Status = RegWinStationCreate( SERVERNAME_CURRENT,
                                            m_pWSName,
                                            FALSE,
                                            &m_WSConfig,
                                            sizeof(WINSTATIONCONFIG2 ) ) ;
        if(Status)
        {
            NotifyAbort(IDP_ERROR_DISABLE);
            return(TRUE);
        }

        /*
         * Do the reset.  If, for some reason, the reset was unsucessful,
         * the device open will fail (below).
         */
        // CWaitCursor wait;
        if( LogonIdFromWinStationName( SERVERNAME_CURRENT , m_pWSName , &LogonId ) )
        {

            BOOL b = ( BOOL )WinStationReset(SERVERNAME_CURRENT, LogonId, TRUE);

            DBGMSG( L"TSCC:CAsyncTestDlg::OnInitDialog WinStationReset returned %s\n", b ? L"TRUE" : L"FALSE" );

            //m_bDeletedWinStation = TRUE;
        }


        m_bDeletedWinStation = TRUE;
    }
//#endif // WINSTA

    /*
     * Open the specified device.
     */
    lstrcpy( DeviceName, TEXT("\\\\.\\") );

    // lstrcat( DeviceName, m_PdConfig0.Params.Async.DeviceName );

    lstrcat( DeviceName, m_ac.DeviceName );

    if( ( m_hDevice = CreateFile( DeviceName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  0,                  // exclusive access
                                  NULL,               // no security attr
                                  OPEN_EXISTING,      // must exist
                                  FILE_FLAG_OVERLAPPED,
                                  NULL                // no template
                                ) ) == INVALID_HANDLE_VALUE )
    {
        NotifyAbort(IDP_ERROR_CANT_OPEN_DEVICE);
    /*    LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , sizeof( tchErrTitle ) );

        LoadString( _Module.GetResourceInstance( ) , IDP_ERROR_CANT_OPEN_DEVICE , tchErrMsg , sizeof( tchErrMsg ) );

        MessageBox( hDlg , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );*/

        return(FALSE);
    }

    /*
     * Set device timeouts & communication parameters and create an event
     * for overlapped writes.
     */
    FillMemory( &CommTimeouts , sizeof( COMMTIMEOUTS ) , 0 );

    CommTimeouts.ReadIntervalTimeout = 1;           // 1 msec

    CommTimeouts.WriteTotalTimeoutConstant = 1000;  // 1 second

    m_OverlapWrite.hEvent = CreateEvent( NULL , TRUE , FALSE, NULL );

    if( !SetCommTimeouts(m_hDevice, &CommTimeouts) || !DeviceSetParams() || m_OverlapWrite.hEvent == NULL )
    {

        NotifyAbort(IDP_ERROR_CANT_INITIALIZE_DEVICE);
        ODS( L"IDP_ERROR_CANT_INITIALIZE_DEVICE\n" );

    /*    LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , sizeof( tchErrTitle ) );

        LoadString( _Module.GetResourceInstance( ) , IDP_ERROR_CANT_INITIALIZE_DEVICE , tchErrMsg , sizeof( tchErrMsg ) );

        MessageBox( hDlg , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );*/


        return(TRUE);
    }

    /*
     * Create the input thread object and initialize it's member variables.
     */
    m_pATDlgInputThread = new CATDlgInputThread;

    m_pATDlgInputThread->m_hDlg = m_hDlg;

    m_pATDlgInputThread->m_hDevice = m_hDevice;

    // m_pATDlgInputThread->m_PdConfig = m_PdConfig0;

    m_pATDlgInputThread->m_ac = m_ac;

    if( !m_pATDlgInputThread->CreateThread() )
    {
        NotifyAbort(IDP_ERROR_CANT_CREATE_INPUT_THREAD);
        ODS( L"IDP_ERROR_CANT_CREATE_INPUT_THREAD\n" );

        return(TRUE);
    }

    /*
     * Hide the modem string buttons if a modem is not configured, or disable
     * buttons that are not valid.
     */
    for( int id = IDC_ATDLG_MODEM_INIT ; id <= IDC_ATDLG_PHONE_NUMBER ; id++ )
    {
        EnableWindow( ::GetDlgItem( hDlg , id) , FALSE);

        ShowWindow( ::GetDlgItem( hDlg , id) , SW_HIDE);
    }

    /*
     * Subclass the edit field to pass messages to dialog first.
     */
    m_EditControl.m_hDlg = m_hDlg;

    m_EditControl.m_bProcessingOutput = FALSE;

    m_EditControl.SubclassDlgItem( hDlg , IDC_ATDLG_EDIT );

    /*
     * Determine the edit control's font and format offset metrics.
     */

    TEXTMETRIC tm;
    RECT Rect;
    HDC dc;
    HFONT hFont , hOldFont;

    dc = GetDC( m_EditControl.m_hWnd );

    hFont = ( HFONT )SendMessage( m_EditControl.m_hWnd , WM_GETFONT , 0 , 0 );

    hOldFont = ( HFONT )SelectObject( dc , hFont);

    GetTextMetrics( dc , &tm );

    SelectObject( dc , hOldFont);

    ReleaseDC( m_EditControl.m_hWnd , dc );

    m_EditControl.m_FontHeight = tm.tmHeight;

    m_EditControl.m_FontWidth = tm.tmMaxCharWidth;

    SendMessage( m_EditControl.m_hWnd , EM_GETRECT , 0 , ( LPARAM )&Rect );

    m_EditControl.m_FormatOffsetY = Rect.top;

    m_EditControl.m_FormatOffsetX = Rect.left;


    /*
     * Subclass the led controls and default to 'off'.
     */
    for( i = 0; i < NUM_LEDS; i++ )
    {
        m_pLeds[i]->Subclass( hDlg , LedIds[i] );

        m_pLeds[i]->Update(0);

    }

    return ( TRUE );

}  // end CAsyncTestDlg::OnInitDialog


/*******************************************************************************
 *
 *  OnTimer - CAsyncTestDlg member function: command (override)
 *
 *      Used for quick 'LED toggle'.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CWnd::OnTimer documentation)
 *
 ******************************************************************************/

void CAsyncTestDlg::OnTimer(UINT nIDEvent)
{
    /*
     * Process this timer event if it it our 'LED toggle' event.
     */
    ODS( L"TSCC:CAsyncTestDlg::OnTimer \n" );

    if( nIDEvent == m_LEDToggleTimer )
    {
        ODS( L"TSCC:CAsyncTestDlg::OnTimer hit event\n" );
        /*
         * Toggle each LED that is flagged as 'changed'.
         */
        ODS( L"TSCC:led toggle " );

        if( m_Status.AsyncSignalMask & EV_DTR )
        {
            ODS( L"dtr\n");

            ( ( CLed * )GetDlgItem( IDC_ATDLG_DTR ) )->Toggle();
        }

        if( m_Status.AsyncSignalMask & EV_RTS )
        {
            ODS(L"rts\n");

            ( ( CLed * )GetDlgItem( IDC_ATDLG_RTS ) )->Toggle();
        }

        if( m_Status.AsyncSignalMask & EV_CTS )
        {
            ODS(L"cts\n");
            ( ( CLed * )GetDlgItem( IDC_ATDLG_CTS ) )->Toggle();
        }

        if( m_Status.AsyncSignalMask & EV_RLSD )
        {
            ODS(L"rlsd\n");

            ( ( CLed * )GetDlgItem( IDC_ATDLG_DCD ) )->Toggle();
        }

        if( m_Status.AsyncSignalMask & EV_DSR )
        {
            ODS(L"dsr\n");

            ( ( CLed * )GetDlgItem( IDC_ATDLG_DSR ) )->Toggle();
        }

        if( m_Status.AsyncSignalMask & EV_RING )
        {
            ODS(L"ring\n" );
            ( ( CLed * )GetDlgItem( IDC_ATDLG_RI ) )->Toggle();
        }


        /*
         * Kill this timer event and indicate so.
         */

        KillTimer( m_hDlg , m_LEDToggleTimer );

        m_LEDToggleTimer = 0;
    }

}  // end CAsyncTestDlg::OnTimer


/*******************************************************************************
 *
 *  OnAsyncTestError - CAsyncTestDlg member function: command
 *
 *      Handle the Async Test Dialog error conditions.
 *
 *  ENTRY:
 *      wParam (input)
 *          Contains message ID for error.
 *      wLparam (input)
 *          Contains error code (GetLastError or API-specific return code)
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate error handling complete.
 *
 ******************************************************************************/
/*#define STANDARD_ERROR_MESSAGE(x) { if ( 1 ) StandardErrorMessage x ; }

LRESULT
CAsyncTestDlg::OnAsyncTestError( WPARAM wParam, LPARAM lParam )
{
    /*
     * Handle special and default errors.
     */

    /*switch ( wParam )
    {

        case IDP_ERROR_MODEM_SET_INFO:
        case IDP_ERROR_MODEM_GET_DIAL:
        case IDP_ERROR_MODEM_GET_INIT:
        case IDP_ERROR_MODEM_GET_LISTEN:
            break;

        case IDP_ERROR_DISABLE:
            StandardErrorMessage( L"Test", (HWND)LOGONID_NONE, (HINSTANCE)lParam,
                                     wParam, (UINT)m_pWSName,0 );
            break;

        default:
            StandardErrorMessage( L"Test",(HWND) LOGONID_NONE, (HINSTANCE)lParam, (UINT)wParam, lParam,0);
            break;
    }

    return(0);

} // end CAsyncTestDlg::OnAsyncTestError*/


/*******************************************************************************
 *
 *  OnAsyncTestAbort - CAsyncTestDlg member function: command
 *
 *      Handle the Async Test Dialog abort conditions.
 *
 *  ENTRY:
 *      wParam (input)
 *          Contains message ID for error.
 *      wLparam (input)
 *          Contains error code (GetLastError)
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate error handling complete.  Will
 *          have posted an 'Ok' (Exit) button click to cause exit.
 *
 ******************************************************************************/

LRESULT CAsyncTestDlg::OnAsyncTestAbort( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( lParam );
    /*
     * Call OnAsyncTestError() to output message.
     */
    //OnAsyncTestError(wParam, lParam);
    NotifyAbort((UINT)wParam);
    /*
     * Post a click for 'OK' (Exit) button to exit dialog.
     */
    PostMessage( m_hDlg , WM_COMMAND , MAKEWPARAM( IDOK, BN_CLICKED ) , (LPARAM)::GetDlgItem( m_hDlg , IDOK ) );

    return(0);


} // end CAsyncTestDlg::OnAsyncTestAbort


/*******************************************************************************
 *
 *  OnAsyncTestStatusReady - CAsyncTestDlg member function: command
 *
 *      Update dialog with comm status information.
 *
 *  ENTRY:
 *      wParam (input)
 *          not used (0)
 *      wLparam (input)
 *          not used (0)
 *  EXIT:
 *      (LRESULT) always returns 0.
 *
 ******************************************************************************/

LRESULT
CAsyncTestDlg::OnAsyncTestStatusReady( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );

    /*
     * Update dialog fields with information from the input thread's
     * PROTOCOLSTATUS structure.
     */
    SetInfoFields( &m_Status, &(m_pATDlgInputThread->m_Status) );

    /*
     * Set our working PROTOCOLSTATUS structure to the new one and signal
     * the thread that we're done.
     */
    m_Status = m_pATDlgInputThread->m_Status;

    m_pATDlgInputThread->SignalConsumed();

    return(0);

} // end CAsyncTestDlg::OnAsyncTestStatusReady


/*******************************************************************************
 *
 *  OnAsyncTestInputReady - CAsyncTestDlg member function: command
 *
 *      Update dialog with comm input data.
 *
 *  ENTRY:
 *      wParam (input)
 *          not used (0)
 *      wLparam (input)
 *          not used (0)
 *  EXIT:
 *      (LRESULT) always returns 0.
 *
 ******************************************************************************/

LRESULT
CAsyncTestDlg::OnAsyncTestInputReady( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );

    BYTE OutBuf[MAX_COMMAND_LEN+2];

    int i, j;

    /*
     * Copy the thread's buffer and count locally.
     */
    m_BufferBytes = m_pATDlgInputThread->m_BufferBytes;

    CopyMemory( m_Buffer , m_pATDlgInputThread->m_Buffer , m_BufferBytes );

    /*
     * Always return caret to the current position before processing, and set
     * edit control to 'read/write' so that character overwrites can occur
     * properly.  Finally, flag control for no redraw until all updates are completed,
     * and flag 'processing output' to avoid OnChar() recursion during '\b' processing.
     */

    SendMessage( m_EditControl.m_hWnd , EM_SETSEL , m_CurrentPos , m_CurrentPos );

    SendMessage( m_EditControl.m_hWnd , EM_SETREADONLY , ( WPARAM )FALSE , 0 );

    SendMessage( m_EditControl.m_hWnd , WM_SETREDRAW , ( WPARAM )FALSE , 0 );

    /*
     * Loop to traverse the buffer, with special processing for certain
     * control characters.
     */
    for ( i = 0, j = 0; m_BufferBytes; i++, m_BufferBytes-- )
    {
        switch( m_Buffer[i] )
        {
        case '\b':
            /*
            * If there is data in the output buffer, write it now.
            */
            if( j )
            {
                OutputToEditControl(OutBuf, &j);
            }

            /*
            * Output the '\b' (will actually cut current character from buffer)
            */
            OutBuf[j++] = '\b';

            OutputToEditControl(OutBuf, &j);

            continue;

        case '\r':
            /*
             * If there is data in the output buffer, write it now.
             */
            if( j )
            {
                OutputToEditControl(OutBuf, &j);
            }

            /*
             * Output the '\r' (will not actually output, but will special case
             * for caret positioning and screen update).
             */

            OutBuf[j++] = '\r';

            OutputToEditControl(OutBuf, &j);

            continue;

        case '\n':
            /*
             * If there is data in the output buffer, write it now.
             */

            if( j )
            {
                OutputToEditControl(OutBuf, &j);
            }

            /*
             * Output the '\n' (will actually quietly output the '\r' and take
             * care of scolling).
             */
            OutBuf[j++] = '\n';

            OutputToEditControl(OutBuf, &j);

            continue;
        }

        /*
         * Add this character to the output buffer.
         */
        OutBuf[j++] = m_Buffer[i];
    }

    /*
     * If there is anything remaining in the output buffer, output it now.
     */
    if( j )
    {
        OutputToEditControl(OutBuf, &j);
    }

    /*
     * Place edit control back in 'read only' mode, flag 'not processing output',
     * set redraw flag for control, and validate the entire control (updates have
     * already taken place).
     */
    SendMessage( m_EditControl.m_hWnd , EM_SETREADONLY , ( WPARAM )TRUE , 0 );

    SendMessage( m_EditControl.m_hWnd , WM_SETREDRAW , ( WPARAM )TRUE , 0 );

    ValidateRect( m_EditControl.m_hWnd , NULL );

    /*
     * Signal thread that we're done with input so that it can continue.
     * NOTE: we don't do this at the beginning of the routine even though
     * we could (for more parallelism), since a constantly chatty async
     * line would cause WM_ASYNCTESTINPUTREADY messages to always be posted
     * to our message queue, effectively blocking any other message processing
     * (like telling the dialog to exit!).
     */

    m_pATDlgInputThread->SignalConsumed();

    return(0);

} // end CAsyncTestDlg::OnAsyncTestInputReady

/*******************************************************************************/
void CAsyncTestDlg::OutputToEditControl( BYTE *pBuffer, int *pIndex )
{
    RECT Rect, ClientRect;

    BOOL bScroll = FALSE;

    INT_PTR CurrentLine = SendMessage( m_EditControl.m_hWnd , EM_LINEFROMCHAR , ( WPARAM )m_CurrentPos , 0 );

    INT_PTR FirstVisibleLine = SendMessage( m_EditControl.m_hWnd , EM_GETFIRSTVISIBLELINE , 0 , 0  );

    INT_PTR CurrentLineIndex = SendMessage( m_EditControl.m_hWnd , EM_LINEINDEX , ( WPARAM )CurrentLine , 0 );


    /*
     * Calculate clip rectangle.
     */
    Rect.top = ( ( int )( CurrentLine - FirstVisibleLine ) * m_EditControl.m_FontHeight )
                + m_EditControl.m_FormatOffsetY;

    Rect.bottom = Rect.top + m_EditControl.m_FontHeight;

    Rect.left = m_EditControl.m_FormatOffsetX +( ( int )( m_CurrentPos - CurrentLineIndex ) * m_EditControl.m_FontWidth );

    Rect.right = Rect.left + (*pIndex * m_EditControl.m_FontWidth);

    /*
     * Handle special cases.
     */
    if ( pBuffer[0] == '\b' ) {

        /*
         * If we're already at the beginning of the line, clear buffer index
         * and return (don't do anything).
         */
        if ( m_CurrentPos == CurrentLineIndex ) {

            *pIndex = 0;
            return;
        }

        /*
         * Position the caret back one character and select through current character.
         */
        SendMessage( m_EditControl.m_hWnd , EM_SETSEL , m_CurrentPos - 1 , m_CurrentPos );

        /*
         * Cut the character out of the edit buffer.
         */
        m_EditControl.m_bProcessingOutput = TRUE;

        SendMessage( m_EditControl.m_hWnd , WM_CUT , 0 , 0 );

        m_EditControl.m_bProcessingOutput = FALSE;

        /*
         * Decrement current position and zero index to suppress further output.  Also,
         * widen the clipping rectangle back one character.
         */
        Rect.left -= m_EditControl.m_FontWidth;

        m_CurrentPos--;

        *pIndex = 0;

    }
    else if( pBuffer[0] == '\r' )
    {

        /*
         * Position the caret at the beginning of the current line.
         */
        m_CurrentPos = CurrentLineIndex;

        SendMessage( m_EditControl.m_hWnd , EM_SETSEL , m_CurrentPos, m_CurrentPos );

        /*
         * Zero index to keep from actually outputing to edit buffer.
         */
        *pIndex = 0;

    }
    else if( pBuffer[0] == '\n' )
    {

        /*
         * Position selection point at end of the current edit buffer.
         */

        m_CurrentPos = GetWindowTextLength( m_EditControl.m_hWnd );

        SendMessage( m_EditControl.m_hWnd , EM_SETSEL , m_CurrentPos , -1 );

        /*
         * Cause '\r' '\n' pair to be output to edit buffer.
         */
        pBuffer[0] = '\r';
        pBuffer[1] = '\n';
        *pIndex = 2;

        /*
         * See if scrolling needed.
         */
        GetClientRect( m_EditControl.m_hWnd , &ClientRect );


        if ( (Rect.bottom + m_EditControl.m_FontHeight) > ClientRect.bottom )
            bScroll = TRUE;

    }
    else
    {

        /*
         * Set selection from current position through *pIndex characters.  This
         * will perform desired 'overwrite' function if current position is not at
         * the end of the edit buffer.
         */

        SendMessage( m_EditControl.m_hWnd , EM_SETSEL , m_CurrentPos , m_CurrentPos + *pIndex );
    }

    /*
     * If necessary, update the dialog's edit box with the buffer data.
     */
    if( *pIndex )
    {


#ifdef UNICODE
        TCHAR OutBuffer[MAX_COMMAND_LEN+1];

        mbstowcs(OutBuffer, (PCHAR)pBuffer, *pIndex);
        OutBuffer[*pIndex] = TEXT('\0');
        SendMessage( m_EditControl.m_hWnd , EM_REPLACESEL , ( WPARAM )FALSE , ( LPARAM )OutBuffer );
#else
        pBuffer[*pIndex] = BYTE('\0');

        SendMessage( m_EditControl.m_hWnd , EM_REPLACESEL , ( WPARAM )FALSE , ( LPARAM )pBuffer );

#endif // UNICODE
    }

    /*
     * Update the current line.
     */


    SendMessage( m_EditControl.m_hWnd , WM_SETREDRAW , ( WPARAM )TRUE , 0 );

    ValidateRect( m_EditControl.m_hWnd , NULL );

    InvalidateRect( m_EditControl.m_hWnd , &Rect , FALSE );

    UpdateWindow( m_EditControl.m_hWnd );
    /*
     * If scrolling is required to see the new line, do so.
     */
    if( bScroll )
    {
        SendMessage( m_EditControl.m_hWnd , EM_LINESCROLL , 0 , 1 );
    }

    SendMessage( m_EditControl.m_hWnd , WM_SETREDRAW , ( WPARAM )FALSE , 0 );

    /*
     * Update current position and clear buffer index.
     */

    m_CurrentPos += *pIndex;

    *pIndex = 0;


} // end CAsyncTestDlg::OutputToEditControl


/*******************************************************************************
 *
 *  OnAsyncTestWriteChar - CAsyncTestDlg member function: command
 *
 *      Place the specified character in m_Buffer, set m_BufferBytes to 1,
 *      and call DeviceWrite() to output the character to the device.
 *
 *  ENTRY:
 *      wParam (input)
 *          Character to write.
 *      lParam (input)
 *          not used (0)
 *  EXIT:
 *      (LRESULT) always returns 0.
 *
 ******************************************************************************/

LRESULT CAsyncTestDlg::OnAsyncTestWriteChar( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );
    /*
     * Write the byte to the device.
     */
    m_Buffer[0] = (BYTE)wParam;

    m_BufferBytes = 1;

    DeviceWrite();

    return(0);

}  // end CAsyncTestDlg::OnAsyncTestWriteChar


/*******************************************************************************
 *
 *  OnClickedAtdlgModemDial - CAsyncTestDlg member function: command
 *
 *      Send the modem dial string.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void CAsyncTestDlg::OnClickedAtdlgModemDial()
{
}  // end CAsyncTestDlg::OnClickedAtdlgModemDial


/*******************************************************************************
 *
 *  OnClickedAtdlgModemInit - CAsyncTestDlg member function: command
 *
 *      Send the modem init string.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void CAsyncTestDlg::OnClickedAtdlgModemInit()
{
}  // end CAsyncTestDlg::OnClickedAtdlgModemInit


/*******************************************************************************
 *
 *  OnClickedAtdlgModemListen - CAsyncTestDlg member function: command
 *
 *      Send the modem listen string.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void CAsyncTestDlg::OnClickedAtdlgModemListen()
{
    lstrcpy((TCHAR *)m_Buffer, m_szModemListen);

    m_BufferBytes = lstrlen((TCHAR *)m_Buffer);

    DeviceWrite();


}  // end CAsyncTestDlg::OnClickedAtdlgModemListen


/*******************************************************************************
 *
 *  OnNcDestroy - CAsyncTestDlg member function: command
 *
 *      Clean up before deleting dialog object.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CWnd::OnNcDestroy documentation)
 *
 ******************************************************************************/

void
CAsyncTestDlg::OnNcDestroy()
{
    if( m_LEDToggleTimer )
    {
        KillTimer( m_hDlg , m_LEDToggleTimer );
    }

    if( m_pATDlgInputThread )
    {
        m_pATDlgInputThread->ExitThread();
    }

    if( m_hDevice != INVALID_HANDLE_VALUE )
    {
        PurgeComm(m_hDevice, PURGE_TXABORT | PURGE_TXCLEAR);
    }

    if( m_OverlapWrite.hEvent != NULL )
    {
        CloseHandle(m_OverlapWrite.hEvent);
    }

    if( m_hDevice != INVALID_HANDLE_VALUE )
    {
        CloseHandle(m_hDevice);
    }

    if( m_bDeletedWinStation && m_pWSName )
    {
        m_WSConfig.Create.fEnableWinStation = TRUE;

        if( RegWinStationCreate( SERVERNAME_CURRENT , m_pWSName , FALSE , &m_WSConfig , sizeof(WINSTATIONCONFIG2) ) != ERROR_SUCCESS )
        {
            _WinStationReadRegistry(SERVERNAME_CURRENT);

        }
    }

    DeleteObject(m_hRedBrush);

}  // end CAsyncTestDlg::OnNcDestroy
////////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK CAsyncTestDlg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CAsyncTestDlg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CAsyncTestDlg *pDlg = ( CAsyncTestDlg * )lp;

        SetWindowLongPtr( hwnd , DWLP_USER, ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CAsyncTestDlg ) ) )
        {
            if(FALSE == pDlg->OnInitDialog( hwnd , wp , lp ))
                PostMessage(hwnd,WM_CLOSE,0,0);
        }

        return 0;
    }

    else
    {
        pDlg = ( CAsyncTestDlg * )GetWindowLongPtr( hwnd , DWLP_USER);

        if( IsBadReadPtr( pDlg , sizeof( CAsyncTestDlg ) ) )
        {
            return 0;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnNcDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_TIMER:

        pDlg->OnTimer( ( UINT )wp );

        break;

    case WM_ASYNCTESTERROR:

        ODS(L"TSCC:CAsyncTestDlg WM_ASYNCTESTERROR (R)\n" );

        pDlg->NotifyAbort((UINT)wp);

        break;

    case WM_ASYNCTESTABORT:

        ODS(L"TSCC:CAsyncTestDlg WM_ASYNCTESTABORT (R)\n" );

        pDlg->OnAsyncTestAbort( wp , lp );

        break;

    case WM_ASYNCTESTSTATUSREADY:

        ODS(L"TSCC:CAsyncTestDlg WM_ASYNCTESTSTATUSREADY (R)\n" );

        pDlg->OnAsyncTestStatusReady( wp , lp );

        break;

    case WM_ASYNCTESTINPUTREADY:

        ODS(L"TSCC:CAsyncTestDlg WM_ASYNCTESTINPUTREADY (R)\n" );

        pDlg->OnAsyncTestInputReady( wp , lp );

        break;

    case WM_ASYNCTESTWRITECHAR:

        ODS(L"TSCC:CAsyncTestDlg WM_ASYNCTESTWRITECHAR (R)\n" );

        pDlg->OnAsyncTestWriteChar( wp , lp );

        break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\baspdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _BASPDLG_H
#define _BASPDLG_H

#include <prsht.h>


//---------------------------------------------------------------------
// CDialogBase - as the name implies base class for all the dialogs
//---------------------------------------------------------------------
class CDialogPropBase
{
protected:
    BOOL m_bPersisted;

    HWND m_hWnd;

    //HMENU m_hmenu;

public:
    virtual BOOL OnInitDialog( HWND hwnd , WPARAM , LPARAM ){ m_hWnd = hwnd;  return FALSE; }

    virtual BOOL OnDestroy( ){ return( TRUE /*DestroyMenu( m_hmenu )*/ ); }

    virtual BOOL GetPropertySheetPage( PROPSHEETPAGE& ){ return FALSE;}

    virtual BOOL PersistSettings( HWND ){ return FALSE;} 

    virtual BOOL IsValidSettings( HWND ){ return TRUE;}

    virtual BOOL OnNotify( int , LPNMHDR , HWND );

    virtual BOOL OnContextMenu( HWND , POINT& );

    virtual BOOL OnHelp( HWND , LPHELPINFO );

    CDialogPropBase( ){}

    //virtual ~CDialogBase( );
};

#endif //_BASPDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\cfgcomp\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__BB0D717D_3C44_11D2_BB98_3078302C2030__INCLUDED_)
#define AFX_STDAFX_H__BB0D717D_3C44_11D2_BB98_3078302C2030__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


#ifdef DBG

extern bool g_fDebug;

#define ODS( x ) \
if( g_fDebug ) OutputDebugString( x ); \

#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[80]; \
    if( g_fDebug ) {\
    wsprintf( tchErr , x , y ); \
    ODS( tchErr ); \
    }\
    }

#else
#define ODS
#define DBGMSG

#endif
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.




#endif // !defined(AFX_STDAFX_H__BB0D717D_3C44_11D2_BB98_3078302C2030__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\baswdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _BASWDLG_H
#define _BASWDLG_H

#include <prsht.h>
//---------------------------------------------------------------------
// CDialogBase - as the name implies base class for all the dialogs
//---------------------------------------------------------------------
class CDialogWizBase
{
protected:
    BOOL m_bPersisted;

    HWND m_hWnd;

public:
    virtual BOOL OnInitDialog( HWND , WPARAM , LPARAM ) = 0;

    virtual BOOL OnDestroy( ){ return TRUE ; }

    virtual BOOL GetPropertySheetPage( PROPSHEETPAGE& ){ return FALSE;}

    virtual BOOL PersistSettings( HWND ){ return FALSE;} 

    virtual BOOL IsValidSettings( HWND ){ return TRUE;}

    virtual BOOL OnNotify( int , LPNMHDR , HWND );

    //virtual BOOL OnContextMenu( HWND , POINT& ){ return TRUE; }

    //virtual BOOL OnHelp( HWND , LPHELPINFO ){ return TRUE; }

    CDialogWizBase( ){}

    //virtual ~CDialogWizBase( );
};

#endif //_BASWDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\comp.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//
// 08/13/98
// alhen
//
#include "stdafx.h"
#include "tscc.h"
#include "compdata.h"
#include "comp.h"
#include "tsprsht.h"
#include "sdlgs.h"

INT_PTR CALLBACK RenameDlgProc( HWND , UINT , WPARAM , LPARAM );

void ErrMessage( HWND hwndOwner , INT_PTR iResourceID );

extern void xxxErrMessage( HWND hwnd , INT_PTR nResMessageId , INT_PTR nResTitleId , UINT nFlags );

extern void TscAccessDeniedMsg( HWND hwnd );

extern void TscGeneralErrMsg( HWND hwnd );

BOOL IsValidConnectionName( LPTSTR szConName , PDWORD );

extern void SnodeErrorHandler( HWND hParent , INT nObjectId , DWORD dwStatus );

extern void ReportStatusError( HWND hwnd , DWORD dwStatus );

extern BOOL g_bAppSrvMode;

//extern BOOL g_bEditMode;

//--------------------------------------------------------------------------
CComp::CComp( CCompdata* pCompdata )
{
    m_pConsole = NULL;

    m_pCompdata = pCompdata;

    m_pResultData = NULL;

    m_pHeaderCtrl = NULL;

    m_pConsoleVerb = NULL;

    m_pImageResult = NULL;

    m_pDisplayHelp = NULL;

    m_nSettingCol = 0;
    
    m_nAttribCol = 0;

    m_cRef = 1; // addref at ctor

}

//--------------------------------------------------------------------------
CComp::~CComp( )
{
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::QueryInterface( REFIID riid , PVOID *ppv )
{
    HRESULT hr = S_OK;

    if( riid == IID_IUnknown )
    {
        *ppv = ( LPUNKNOWN )( LPCOMPONENT )this;
    }
    else if( riid == IID_IComponent )
    {
        *ppv = ( LPCOMPONENT )this;
    }
    else if( riid == IID_IExtendContextMenu )
    {
        *ppv = ( LPEXTENDCONTEXTMENU )this;
    }
    else if( riid == IID_IExtendPropertySheet )
    {
        *ppv = ( LPEXTENDPROPERTYSHEET )this;
    }
    else
    {
        *ppv = 0;

        hr = E_NOINTERFACE;
    }

    AddRef( );

    return hr;
}
    
//--------------------------------------------------------------------------
STDMETHODIMP_( ULONG ) CComp::AddRef( )
{
    return InterlockedIncrement( ( LPLONG )&m_cRef );
}

//--------------------------------------------------------------------------
STDMETHODIMP_( ULONG )CComp::Release( )
{
    if( InterlockedDecrement( ( LPLONG )&m_cRef ) == 0 )
    {
        delete this;

        return 0;
    }

    return m_cRef;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::Initialize( LPCONSOLE lpConsole )
{
    HRESULT hr;

    ASSERT( lpConsole != NULL );

    m_pConsole = lpConsole;
    
    m_pConsole->AddRef( );

    // VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_MAINFOLDERNAME , m_strDispName , sizeof( m_strDispName ) ) );

    do
    {
        if( FAILED( ( hr = m_pConsole->QueryInterface( IID_IResultData , ( LPVOID *)&m_pResultData ) ) ) )
        {
            break;
        }

        if( FAILED( ( hr = m_pConsole->QueryInterface( IID_IHeaderCtrl , ( LPVOID *)&m_pHeaderCtrl ) ) ) )
        {
            break;
        }

        if( FAILED( ( hr = m_pConsole->QueryConsoleVerb( &m_pConsoleVerb ) ) ) )
        {
            break;
        }

        if( FAILED( ( hr = m_pConsole->QueryInterface( IID_IDisplayHelp , ( LPVOID * )&m_pDisplayHelp ) ) ) )
        {
            break;
        }

        hr = m_pConsole->QueryResultImageList( &m_pImageResult );
        
    }while( 0 );
    
    return hr;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::Notify( LPDATAOBJECT pDataObj , MMC_NOTIFY_TYPE event , LPARAM arg , LPARAM  )
{
    switch( event )
    {
    case MMCN_ACTIVATE:

        ODS( L"IComponent -- MMCN_ACTIVATE\n" );

        break;

    case MMCN_ADD_IMAGES:

        ODS( L"IComponent -- MMCN_ADD_IMAGES\n" );

        OnAddImages( );

        break;

    case MMCN_BTN_CLICK:

        ODS( L"IComponent -- MMCN_BTN_CLICK\n" );

        break;

    case MMCN_CLICK:

        ODS( L"IComponent -- MMCN_CLICK\n" );

        break;

    case MMCN_DBLCLICK:

        ODS( L"IComponent -- MMCN_DBLCLICK\n" );

        // enables navigation to inner folders.
        // final item launches default verb
        OnDblClk( pDataObj );

        return S_FALSE;

    case MMCN_DELETE:

        ODS( L"IComponent -- MMCN_DELETE\n" );

        OnDelete( pDataObj );

        break;

    case MMCN_EXPAND:

        ODS( L"IComponent -- MMCN_EXPAND\n" );

        break;

    case MMCN_MINIMIZED:

        ODS( L"IComponent -- MMCN_MINIMIZED\n" );

        break;

    case MMCN_PROPERTY_CHANGE:

        ODS( L"IComponent -- MMCN_PROPERTY_CHANGE\n" );

        break;

    case MMCN_REMOVE_CHILDREN:

        ODS( L"IComponent -- MMCN_REMOVE_CHILDREN\n" );

        break;

    case MMCN_REFRESH:

        ODS( L"IComponent -- MMCN_REFRESH\n" );

        OnRefresh( pDataObj );

        break;

    case MMCN_RENAME:

        ODS( L"IComponent -- MMCN_RENAME\n" );

        break;

    case MMCN_SELECT:

        ODS( L"IComponent -- MMCN_SELECT\n" );

        OnSelect( pDataObj , ( BOOL )LOWORD( arg ) , ( BOOL )HIWORD( arg ) );

        break;

    case MMCN_SHOW:

        ODS( L"IComponent -- MMCN_SHOW\n" );

        OnShow( pDataObj , ( BOOL )arg );

        break;

    case MMCN_VIEW_CHANGE:

        ODS( L"IComponent -- MMCN_VIEW_CHANGE\n" );

        OnViewChange( );

        break;

    case MMCN_CONTEXTHELP:

        ODS( L"IComponent -- MMCN_CONTEXTHELP\n" );

        OnHelp( pDataObj );

        break;

    case MMCN_SNAPINHELP:

        ODS( L"IComponent -- MMCN_SNAPINHELP\n" );

        break;


    default:
        ODS( L"CComp::Notify - event not registered\n" );
    }

    return S_OK;
}

//--------------------------------------------------------------------------
// pDataobject represents the current selected scope folder
// this should only be our main folder in the scope pane
//--------------------------------------------------------------------------
HRESULT CComp::OnShow( LPDATAOBJECT pDataobject , BOOL bSelect )
{
    TCHAR tchBuffer[ 256 ];

    HRESULT hr = S_FALSE;

    ASSERT( pDataobject != NULL );

    

    if( bSelect && m_pCompdata->IsSettingsFolder( pDataobject ) )
    {
        // set up columns for services folder 

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_SETTINGS_COLUMN1 , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );

        if( m_nSettingCol == 0 && m_nAttribCol == 0 )
        {
            SetColumnsForSettingsPane( );
        }
        
        ODS( L"TSCC:Comp@OnShow inserting columns\n" );

        if( m_nSettingCol == 0 )
        {
            hr = m_pHeaderCtrl->InsertColumn( 0 , tchBuffer , 0 , MMCLV_AUTO );
        }
        else
        {
            hr = m_pHeaderCtrl->InsertColumn( 0 , tchBuffer , 0 , m_nSettingCol );
        }


        if( SUCCEEDED( hr ) )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ATTRIB_COLUMN2 , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );

            if( m_nAttribCol == 0 )
            {
                hr = m_pHeaderCtrl->InsertColumn( 1 , tchBuffer , 0 , MMCLV_AUTO );            
            }
            else
            {
                hr = m_pHeaderCtrl->InsertColumn( 1 , tchBuffer , 0 , m_nAttribCol );
            }

        }

        AddSettingsinResultPane( );
        
    }

    else if( bSelect && m_pCompdata->IsConnectionFolder( pDataobject ) )
    {        
        // set up column headers for connection folder 
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_COLCONNECT , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );
        
        hr = m_pHeaderCtrl->InsertColumn( 0 , tchBuffer , 0 , MMCLV_AUTO );

        if( SUCCEEDED( hr ) )
        {
            //SetColumnWidth( 0 );

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_COLTRANSPORT , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );
            
            hr = m_pHeaderCtrl->InsertColumn( 1 , tchBuffer , 0 , MMCLV_AUTO );
        }

        if( SUCCEEDED( hr ) )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_COLTYPE , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );

            // ui master dirty trick 120 equals fudge factor

            hr = m_pHeaderCtrl->InsertColumn( 2 , tchBuffer , 0 , 120/*MMCLV_AUTO*/ );
        }
        

        if( SUCCEEDED( hr ) )
        {
            //SetColumnWidth( 2 );

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_COLCOMMENT , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );

            hr = m_pHeaderCtrl->InsertColumn( 3 , tchBuffer , 0 , MMCLV_AUTO );
        }

        // insert items
        if( SUCCEEDED( hr ) )
        {
            hr = InsertItemsinResultPane( );
        }
    }

    return hr;
}

//--------------------------------------------------------------------------
BOOL CComp::OnAddImages( )
{
    HICON hiconConnect = LoadIcon( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_CON ) );

    HICON hiconDiscon  = LoadIcon( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_DISCON ) );

    HICON hiconBullet = LoadIcon( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_BULLET ) );

    m_pImageResult->ImageListSetIcon( ( PLONG_PTR  )hiconConnect , 1 );

    m_pImageResult->ImageListSetIcon( ( PLONG_PTR )hiconDiscon , 2 );

    m_pImageResult->ImageListSetIcon( ( PLONG_PTR )hiconBullet , 3 );

    
    return TRUE;
}

//--------------------------------------------------------------------------
// update resultitems in result pane and note scopeitems
//--------------------------------------------------------------------------
BOOL CComp::OnViewChange( )
{
    RESULTDATAITEM rdi;

    ZeroMemory( &rdi , sizeof( RESULTDATAITEM ) );

    rdi.mask = RDI_PARAM;

    m_pResultData->GetItem( &rdi );

    if( rdi.bScopeItem )
    {
        return FALSE;
    }
    
    if( SUCCEEDED( InsertItemsinResultPane( ) ) )
    {
        return TRUE;
    }

    return FALSE;
}

//--------------------------------------------------------------------------
// Forced refreshed!!
//--------------------------------------------------------------------------
BOOL CComp::OnRefresh( LPDATAOBJECT pdo )
{
    RESULTDATAITEM rdi;

    ZeroMemory( &rdi , sizeof( RESULTDATAITEM ) );

    CBaseNode *pNode = static_cast< CBaseNode * >( pdo );

    if( pNode->GetNodeType() == MAIN_NODE )
    {
        rdi.mask = RDI_PARAM;

        m_pResultData->GetItem( &rdi );

        if( rdi.bScopeItem )
        {
            return FALSE;
        }
    
        //NA 2/28/01 This has been moved to InsertItemsinResultPane because
        //it needs to be performed between its two operations, not before
        //if( FAILED( m_pCompdata->UpdateAllResultNodes( ) ) )
        //{       
        //    ODS( L"OnRefresh - UpdateAllResultNodes failed!!\n" ) ;
        //    return FALSE;
        //}
    
        InsertItemsinResultPane( );
    }
#if 0 // too late for this feature
    else if( pNode->GetNodeType() == SETTINGS_NODE )
    {
        HRESULT hr;
         
        ODS( L"OnRefresh - called for settings node\n" );

        rdi.mask = RDI_PARAM;

        rdi.itemID = 1;

        m_pResultData->GetItem( &rdi );

        if( rdi.bScopeItem )
        {
            return FALSE;
        }
        

        if( FAILED( hr = m_pResultData->DeleteAllRsltItems( ) ) )
        {
            DBGMSG( L"TSCC:OnRefresh DeleteAllRsltItems ( SNODES ) failed 0x%x\n" , hr );

            return FALSE;
        }       
                
        SetColumnsForSettingsPane( );

        AddSettingsinResultPane( );
    }
#endif

    return TRUE;
}
    


//--------------------------------------------------------------------------
STDMETHODIMP CComp::Destroy( MMC_COOKIE  /* reserved */ )
{
    ODS( L"IComponent releasing interfaces\n" );

    if( m_pResultData != NULL )
    {
        m_pResultData->Release( );
    }

    if( m_pConsole != NULL )
    {
        m_pConsole->Release( );
    }

    if( m_pHeaderCtrl != NULL )
    {
        m_pHeaderCtrl->Release( );
    }

    if( m_pConsoleVerb != NULL )
    {
        m_pConsoleVerb->Release( );
    }

    if( m_pImageResult != NULL )
    {
        m_pImageResult->Release( );
    }

    if( m_pDisplayHelp != NULL )
    {
        m_pDisplayHelp->Release( );
    }

    return S_OK;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::GetResultViewType( MMC_COOKIE  , LPOLESTR*  , PLONG plView )
{
    *plView = MMC_VIEW_OPTIONS_NONE;
    
    return S_FALSE;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::QueryDataObject( MMC_COOKIE ck , DATA_OBJECT_TYPES dtype , LPDATAOBJECT* ppDataObject )
{
    if( dtype == CCT_RESULT )
    {
        *ppDataObject = ( LPDATAOBJECT )ck;

        ( ( LPDATAOBJECT )*ppDataObject)->AddRef( );

    }

    else if( m_pCompdata != NULL )
    {
       return m_pCompdata->QueryDataObject( ck , dtype , ppDataObject );
    }

    return S_OK;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::GetDisplayInfo( LPRESULTDATAITEM pRdi )
{
    ASSERT( pRdi != NULL );

    if( pRdi == NULL )
    {
        return E_INVALIDARG;
    }

    if( pRdi->bScopeItem )
    {
        CBaseNode *pScopeNode = ( CBaseNode * )pRdi->lParam;

        if( pScopeNode != NULL )
        {
            if( pScopeNode->GetNodeType( ) == MAIN_NODE )
            {
                //
                if( pRdi->mask & RDI_STR )
                {
                    if( pRdi->nCol == 0 )
                    {
                        // pRdi->str is NULL in this call

                        pRdi->str = ( LPOLESTR )m_pCompdata->m_tchMainFolderName; //m_strDispName; 
                    }
            
                }
            }
            else if( pScopeNode->GetNodeType( ) == SETTINGS_NODE )
            {
                if( pRdi->mask & RDI_STR )
                {
                    if( pRdi->nCol == 0 )
                    {
                        // pRdi->str is NULL in this call

                        pRdi->str = ( LPOLESTR )m_pCompdata->m_tchSettingsFolderName; //L"Server Settings"; 
                    }
            
                }
            }
        }


        if( pRdi->mask & RDI_IMAGE )  
        {
            ODS( TEXT("RDI_IMAGE -- in CComponent::GetDisplayInfo\n") );

            pRdi->nImage = ( ( CBaseNode * )pRdi->lParam )->GetImageIdx( );

        }

    }
    else
    {
        // populate result pane
        CBaseNode *pItem = ( CBaseNode * )pRdi->lParam;

        if( pItem != NULL )
        {
            if( pItem->GetNodeType( ) == RESULT_NODE )
            {
                CResultNode *pNode = ( CResultNode * )pRdi->lParam;

                if( pRdi->mask & RDI_STR )
                {
                    switch( pRdi->nCol )
                    {
                        case 0:
            
                            pRdi->str = pNode->GetConName( );
                
                        break;

                        case 1:

                            pRdi->str = pNode->GetTTName( );

                        break;

                        case 2:

                            pRdi->str = pNode->GetTypeName( );
                
                        break;

                        case 3:

                            pRdi->str = pNode->GetComment( );

                        break;
                    }
                }
            }
            else if( pItem->GetNodeType( ) == RSETTINGS_NODE )
            {
                CSettingNode *pNode = ( CSettingNode *)pRdi->lParam;

                if( pRdi->mask & RDI_STR )
                {
                    switch( pRdi->nCol )
                    {
                        case 0:

                            pRdi->str = pNode->GetAttributeName( );

                            break;

                        case 1:

                            if( pNode->GetObjectId( ) >= CUSTOM_EXTENSION )
                            {
                                DWORD dwStatus;

                                pNode->SetAttributeValue( 0 , &dwStatus );
                            }

                            pRdi->str = pNode->GetCachedValue( );

                            break;
                    }
                }
            }
        }
    }

    return S_OK;
}

//--------------------------------------------------------------------------
// Returns S_OK if they are similar S_FALSE otherwise
//--------------------------------------------------------------------------
STDMETHODIMP CComp::CompareObjects( LPDATAOBJECT , LPDATAOBJECT )
{
    return S_OK;
}

//--------------------------------------------------------------------------
HRESULT CComp::InsertItemsinResultPane( )
{
    HRESULT hr;
  
    //This removes the node information from the data in MMC
    if( FAILED( hr = m_pResultData->DeleteAllRsltItems( ) ) )
    {
        return hr;
    }

    if( m_pCompdata == NULL )
    {
        return E_UNEXPECTED;
    }

    //NA 3/2/01 This needs to be done to update the data held
    //in m_pCompdata before the nodes are put into its list
    if( FAILED( m_pCompdata->UpdateAllResultNodes( ) ) )
    {       
        ODS( L"OnRefresh - UpdateAllResultNodes failed!!\n" ) ;
        return FALSE;
    }

    //This puts the data for the nodes into m_pCompdata and also
    //sends that same information to MMC
    if( FAILED( hr = m_pCompdata->InsertFolderItems( m_pResultData ) ) )
    {
        return hr;
    }

    return hr;
}
        
//--------------------------------------------------------------------------
HRESULT CComp::AddSettingsinResultPane( )
{
    HRESULT hr;
      
    if( m_pCompdata == NULL )
    {
        return E_UNEXPECTED;
    }

    if( FAILED( hr = m_pCompdata->InsertSettingItems( m_pResultData ) ) )
    {
        return hr;
    }

    return hr;
}

//--------------------------------------------------------------------------
HRESULT CComp::OnSelect( LPDATAOBJECT pdo , BOOL bScope , BOOL bSelected )
{    
    CBaseNode *pNode = static_cast< CBaseNode * >( pdo );
    
    if( pNode == NULL ) 
    {
        return S_FALSE;
    }

    if( m_pConsoleVerb == NULL )
    {
        return E_UNEXPECTED;
    }

    // Item is being deselected and we're not interested currently

    if( !bSelected )
    {
        return S_OK;
    }
    
    // pNode == NULL if the folder item is being viewed in the result pane

    // settings node is ignored for this release
    
    if( bScope && pNode->GetNodeType( ) == MAIN_NODE )
    {
        m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH , ENABLED , TRUE );

        m_pConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN );

    }
    else
    {
        if( pNode->GetNodeType() == RESULT_NODE )
        {
            m_pConsoleVerb->SetVerbState( MMC_VERB_DELETE , ENABLED , TRUE );

            //m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH , ENABLED , TRUE );

            m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES , ENABLED , TRUE );

            m_pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );
        }
    }

    return S_OK;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::AddMenuItems( LPDATAOBJECT pdo , LPCONTEXTMENUCALLBACK pcmc , PLONG pl )
{
    // CONTEXTMENUITEM cmi;

    if( pdo == NULL || pcmc == NULL )
    {
        return E_UNEXPECTED;
    }
    
    // do not allow scope node types

    if( m_pCompdata->IsConnectionFolder( pdo ) || m_pCompdata->IsSettingsFolder( pdo ) )
    {
        return S_FALSE;
    }

    CBaseNode *pNode = NULL;

    pNode = static_cast< CBaseNode * >( pdo );
    
    if( pNode == NULL )
    {
        return S_FALSE;
    }

    // hey root node has no menu items to insert.

    if( pNode->GetNodeType() == 0 )
    {
        return S_FALSE;
    }
   
    if( pNode->AddMenuItems( pcmc , pl ) )
    {        
        return S_OK;
    }

    return E_FAIL;

}

//--------------------------------------------------------------------------
// Toggles connection 
//--------------------------------------------------------------------------
STDMETHODIMP CComp::Command( LONG lCmd , LPDATAOBJECT pdo )
{
    TCHAR buf[ 512 ];
                    
    TCHAR tchmsg[ 256 ];

    HRESULT hr;

    if( pdo == NULL )
    {
        return E_UNEXPECTED;
    }

    HWND hMain;

    if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
    {
        hMain = NULL;
    }
    
    CResultNode *pNode = NULL;
    
    CSettingNode *pSetNode = NULL;

    if( pdo == NULL )
    {
        return S_FALSE;
    }

    if( ( ( CBaseNode * )pdo )->GetNodeType( ) == RSETTINGS_NODE )
    {
        pSetNode = ( CSettingNode * )pdo;

        BOOL bVal;

        DWORD dwStatus = 0;

        switch( lCmd )
        {
        case IDM_SETTINGS_PROPERTIES:
            
            OnDblClk( pdo );

            break;

        case IDM_SETTINGS_DELTEMPDIRSONEXIT:
        
        case IDM_SETTINGS_USETMPDIR:

        case IDM_SETTINGS_ADP:

        case IDM_SETTINGS_SS:
            {
                bVal = ( BOOL )pSetNode->xx_GetValue( );
                
                HCURSOR hCursor = SetCursor( LoadCursor( NULL , MAKEINTRESOURCE( IDC_WAIT ) ) );
                
                hr = pSetNode->SetAttributeValue( !bVal , &dwStatus );
                
                if( FAILED( hr ) )
                {
                    SnodeErrorHandler( hMain , pSetNode->GetObjectId( ) , dwStatus );
                }


                //
                // We might want to move this code into OnRefresh() but for now, this is fix for
                // not updating attribute value and don't want to cause other regression
                //
                HRESULT hr;
                HRESULTITEM itemID;
         
                hr = m_pResultData->FindItemByLParam( (LPARAM) pdo, &itemID );

                if( SUCCEEDED(hr) )
                {
                    m_pResultData->UpdateItem( itemID );
                }

                SetCursor( hCursor );                                 
            }

            break;

        default:

            if( pSetNode->GetObjectId() >= CUSTOM_EXTENSION )
            {
                IExtendServerSettings *pEss = reinterpret_cast< IExtendServerSettings * >( pSetNode->GetInterface() );

                if( pEss != NULL )
                {
                    pEss->ExecMenuCmd( lCmd , hMain , &dwStatus );

                    // this forces the ui to be updated.
                    
                    if( dwStatus == UPDATE_TERMSRV || dwStatus == UPDATE_TERMSRV_SESSDIR )
                    {
                        ICfgComp *pCfgcomp = NULL;

                        m_pCompdata->GetServer( &pCfgcomp );

                        if( pCfgcomp != NULL )
                        {
                            ODS( L"TSCC!ExecMenuCmd forcing termsrv update\n" );

                            if( dwStatus == UPDATE_TERMSRV_SESSDIR )
                            {
                                HCURSOR hCursor = SetCursor( LoadCursor( NULL ,
                                        MAKEINTRESOURCE( IDC_WAIT ) ) );

                                if( FAILED( pCfgcomp->UpdateSessionDirectory( &dwStatus ) ) )
                                {
                                    ReportStatusError( hMain , dwStatus );
                                }

                                SetCursor(hCursor);
                            }
                            else
                            {
                                pCfgcomp->ForceUpdate( );
                            }

                            pCfgcomp->Release();
                        }

                    }

                    pSetNode->SetAttributeValue( 0 , &dwStatus );                    
                }
            }
        }

    }
    else if( ( ( CBaseNode * )pdo )->GetNodeType( ) == RESULT_NODE )
    {
        pNode = ( CResultNode * )pdo;

        if( lCmd == IDM_ENABLE_CONNECTION )
        {
            if( pNode->m_bEditMode )
            {
                xxxErrMessage( hMain , IDS_ERR_INEDITMODE , IDS_WARN_TITLE , MB_OK | MB_ICONWARNING );
            
                return S_FALSE;
            }

            ICfgComp *pCfgcomp;

            if( pNode->GetServer( &pCfgcomp ) != 0 )
            {
                WS *pWs;

                LONG lSz;

                if( SUCCEEDED( pCfgcomp->GetWSInfo( pNode->GetConName( ) , &lSz , &pWs ) ) )
                {
                    BOOL bProceed = TRUE;

                    pWs->fEnableWinstation = !pNode->GetConnectionState( );

                    if( pWs->fEnableWinstation == 0 )
                    {
                        
                        LONG lCount;

                        // check to see if anyone is connected 

                        pCfgcomp->QueryLoggedOnCount( pNode->GetConName( ) , &lCount );

                        if( lCount > 0 )
                        {
                            LoadString( _Module.GetResourceInstance( ) , IDS_DISABLELIVECONNECTION , tchmsg , SIZE_OF_BUFFER( tchmsg ) );
                        }
                        else
                        {
                            LoadString( _Module.GetResourceInstance( ) , IDS_DISABLECONNECTION , tchmsg , SIZE_OF_BUFFER( tchmsg ) );
                        }

                        wsprintf( buf , tchmsg , pNode->GetConName( ) );

                        LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchmsg , SIZE_OF_BUFFER( tchmsg ) );

                        
                        if( MessageBox( hMain , buf , tchmsg , MB_ICONWARNING | MB_YESNO ) == IDNO )
                        {
                            bProceed = FALSE;
                        }
                    }

                    if( bProceed )
                    {
                        /*pNode->EnableConnection( pWs->fEnableWinstation );

                        pNode->SetImageIdx( ( pWs->fEnableWinstation ? 1 : 2 )  );
                    
                        pCfgcomp->UpDateWS( pWs , UPDATE_ENABLEWINSTATION );
                    
                        m_pConsole->UpdateAllViews( ( LPDATAOBJECT )pNode , 0 , 0 );
                        */

                        DWORD dwStatus;

                        if( FAILED( hr = pCfgcomp->UpDateWS( pWs , UPDATE_ENABLEWINSTATION , &dwStatus, TRUE ) ) )
                        {
                            if( hr == E_ACCESSDENIED )
                            {
                                TscAccessDeniedMsg( hMain );
                            }
                            else
                            {
                                TscGeneralErrMsg( hMain );
                            }
                        }
                        else
                        {
                            pNode->EnableConnection( pWs->fEnableWinstation );
                            
                            pNode->SetImageIdx( ( pWs->fEnableWinstation ? 1 : 2 )  );

                            m_pConsole->UpdateAllViews( ( LPDATAOBJECT )pNode , 0 , 0 );
                        }                    
                    
                    }

                    if(pWs->fEnableWinstation && pWs->PdClass == SdAsync)
                    {
                        ASYNCCONFIGW AsyncConfig;

                        HRESULT hResult = pCfgcomp->GetAsyncConfig( pWs->Name , WsName , &AsyncConfig );

                        if( SUCCEEDED( hResult ) )
                        {
                            if( AsyncConfig.ModemName[0] )
                            {                               
                                LoadString( _Module.GetResourceInstance( ) , IDS_REBOOT_REQD , buf , SIZE_OF_BUFFER( buf ) );

                                LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchmsg , SIZE_OF_BUFFER( tchmsg ) );

                                MessageBox( hMain , buf , tchmsg , MB_ICONWARNING | MB_OK );
                            }
                        }
                    }

                    CoTaskMemFree( pWs );
                }

                pCfgcomp->Release( );
            }            

        }
        else if( lCmd == IDM_RENAME_CONNECTION )
        {            
            if( pNode->m_bEditMode )
            {
                xxxErrMessage( hMain , IDS_ERR_INEDITMODE , IDS_WARN_TITLE , MB_OK | MB_ICONWARNING );
            
                return S_FALSE;
            }

            ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_RENAME ) , hMain , RenameDlgProc , ( LPARAM )pNode );
        }    
    }

    return S_OK;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::CreatePropertyPages( LPPROPERTYSHEETCALLBACK psc , LONG_PTR Handle , LPDATAOBJECT pdo )
{
    HRESULT hr = E_OUTOFMEMORY;

    if( psc == NULL )
    {
        return E_UNEXPECTED;
    }
    
    CPropsheet *pPropsheet = new CPropsheet( );

    if( pPropsheet != NULL )
    {
        HWND hMain;
        
        if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
        {
            hMain = NULL;
        }
    
        if( FAILED( ( hr = pPropsheet->InitDialogs( hMain , psc , dynamic_cast< CResultNode *>( pdo ) , Handle ) ) ) )
        {
            delete pPropsheet;
        }
        
    }

    return hr;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::QueryPagesFor( LPDATAOBJECT pdo )
{
    if( dynamic_cast< CResultNode *>( pdo ) == NULL )
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

//--------------------------------------------------------------------------
BOOL CComp::OnDelete( LPDATAOBJECT pDo )
{
    CResultNode *pNode = dynamic_cast< CResultNode *>( pDo );

    if( pNode == NULL )
    {
        ODS( L"TSCC: OnDelete, node == NULL\n");

        return FALSE;
    }

    if( pNode->m_bEditMode )
    {
        HWND hMain;
        
        if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
        {
            hMain = NULL;
        }

        xxxErrMessage( hMain , IDS_ERR_INEDITMODE , IDS_WARN_TITLE , MB_OK | MB_ICONWARNING );

        return FALSE;
    }


    return m_pCompdata->OnDeleteItem( pDo );
}
    

//--------------------------------------------------------------------------
// CResultNode passed in on init
//--------------------------------------------------------------------------
INT_PTR CALLBACK RenameDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
    CResultNode *pNode;

    TCHAR tchNewName[ 60 ];

    // HWND h;

    switch( msg )
    {
    case WM_INITDIALOG :

        pNode = ( CResultNode *)lp;

        ASSERT( pNode != NULL );
        
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        // Insert name

        ICfgComp *pCfgcomp;

        if( pNode == NULL )
        {
            break;
        }

        if( pNode->GetServer( &pCfgcomp ) == 0 )
        {
            ASSERT( 0 );

            break;
        }
        
        SetWindowText( GetDlgItem( hDlg , IDC_STATIC_CURRENT_NAME ) , pNode->GetConName( ) );

        pCfgcomp->Release( );

        SetFocus( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) );
    
        SendMessage( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) , EM_SETLIMITTEXT , ( WPARAM )( WINSTATIONNAME_LENGTH - WINSTATION_NAME_TRUNCATE_BY ) , 0 );

        break;

    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CResultNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }

            DWORD dwErr = 0;

            if( GetWindowText( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) , tchNewName , SIZE_OF_BUFFER( tchNewName ) ) == 0 ||

                !IsValidConnectionName( tchNewName , &dwErr ) )
            {
                if( dwErr == ERROR_INVALID_FIRSTCHARACTER )
                {
                    ErrMessage( hDlg , IDS_ERR_INVALIDFIRSTCHAR );
                }
                else
                {
                    ErrMessage( hDlg , IDS_ERR_INVALIDCHARS );
                }               

                SetFocus( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) );

                SendMessage( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );
                
                return 0;
            }

            // verify the name is unique

            ICfgComp *pCfgcomp;

            
            if( pNode->GetServer( &pCfgcomp ) == 0 )
            {
                ODS( L"GetServer failed in RenameDlgProc\n" );

                break;
            }

            do
            {
                BOOL bUnique = FALSE;

                if( FAILED( pCfgcomp->IsWSNameUnique( ( PWINSTATIONNAMEW )tchNewName , &bUnique ) ) )
                {
                    break;
                }
            
                if( !bUnique )
                {

                    ErrMessage( hDlg , IDS_ERR_WINNAME );
                    
                    pCfgcomp->Release( );

                    SetFocus( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) );

                    SendMessage( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

                    return 0;
                }

                HRESULT hr;

                LONG lCount;

                TCHAR tchWrnBuf[ 256 ];

                TCHAR tchOutput[ 512 ];

                
                // check to see if anyone is connected 
                
                pCfgcomp->QueryLoggedOnCount( pNode->GetConName( ) , &lCount );
                
                if( lCount > 0 )
                {
                   
                    if( lCount == 1 )
                    {
                        LoadString( _Module.GetResourceInstance() , IDS_RENAME_WRN_SINGLE , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );
                    }
                    else
                    {
                        LoadString( _Module.GetResourceInstance() , IDS_RENAME_WRN_PL , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );
                    }

                    wsprintf( tchOutput , tchWrnBuf , pNode->GetConName( ) );

                    LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );

                    if( MessageBox( hDlg , tchOutput , tchWrnBuf , MB_ICONWARNING | MB_YESNO ) == IDNO )
                    {
                        break;
                    }
                }


                if( FAILED( hr = pCfgcomp->RenameWinstation( ( PWINSTATIONNAMEW )pNode->GetConName( ) , ( PWINSTATIONNAMEW )tchNewName ) ) )
                {
                    ODS( L"TSCC: RenameWinstation failed\n" );

                    if( hr == E_ACCESSDENIED )
                    {
                        TscAccessDeniedMsg( hDlg );
                    }
                    else
                    {
                        TscGeneralErrMsg( hDlg );
                    }

                    break;
                }
                
                /*
                LONG lCount;

                TCHAR tchWrnBuf[ 256 ];

                TCHAR tchOutput[ 512 ];

                
                // check to see if anyone is connected 
                
                pCfgcomp->QueryLoggedOnCount( pNode->GetConName( ) , &lCount );
                
                if( lCount > 0 )
                {
                   
                    if( lCount == 1 )
                    {
                        LoadString( _Module.GetResourceInstance() , IDS_RENAME_WRN_SINGLE , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );
                    }
                    else
                    {
                        LoadString( _Module.GetResourceInstance() , IDS_RENAME_WRN_PL , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );
                    }

                    wsprintf( tchOutput , tchWrnBuf , pNode->GetConName( ) );

                    LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );

                    MessageBox( hDlg , tchOutput , tchWrnBuf , MB_OK | MB_ICONWARNING );
                }
                */

                WS *pWs;

                LONG lSz;

                if( SUCCEEDED( pCfgcomp->GetWSInfo(tchNewName , &lSz , &pWs ) ) )
                {
                    if(pWs->fEnableWinstation && pWs->PdClass == SdAsync)
                    {
                        ASYNCCONFIGW AsyncConfig;

                        HRESULT hResult = pCfgcomp->GetAsyncConfig( pWs->Name , WsName , &AsyncConfig );
                        
                        if( SUCCEEDED( hResult ) )
                        {
                            if( AsyncConfig.ModemName[0] )
                            {
                                LoadString( _Module.GetResourceInstance( ) , IDS_REBOOT_REQD , tchOutput , SIZE_OF_BUFFER( tchOutput ) );
                                
                                LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );
                                
                                MessageBox( hDlg , tchOutput , tchWrnBuf , MB_ICONWARNING | MB_OK );
                            }
                        }
                    }

                    CoTaskMemFree( pWs );
                }
                        
                pNode->SetConName( tchNewName , SIZE_OF_BUFFER( tchNewName ) );

            }while( 0 );
            
            pCfgcomp->Release( );

            EndDialog( hDlg , 0 );

        }
        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}

//--------------------------------------------------------------------------
BOOL IsValidConnectionName( LPTSTR szConName , PDWORD pdwErr )
{
    TCHAR tchInvalidChars[ 80 ];

    tchInvalidChars[0] = 0;

    if( szConName == NULL || pdwErr == NULL )
    {
        return FALSE;
    }

    if( _istdigit( szConName[ 0 ] ) )
    {
        *pdwErr = ERROR_INVALID_FIRSTCHARACTER;

        return FALSE;
    }
    
    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance() , IDS_INVALID_CHARS , tchInvalidChars , SIZE_OF_BUFFER( tchInvalidChars ) ) );

    int nLen = lstrlen( tchInvalidChars );

    while( *szConName )
    {
        for( int idx = 0 ; idx < nLen ; idx++ )
        {
            if( *szConName == tchInvalidChars[ idx ] )
            {
                *pdwErr = ERROR_ILLEGAL_CHARACTER;

                return FALSE;
            }
        }

        szConName++;
    }

    *pdwErr = ERROR_SUCCESS;

    return TRUE;
}

//----------------------------------------------------------------------            
BOOL CComp::OnHelp( LPDATAOBJECT pDo )
{
    TCHAR tchTopic[ 80 ];

    HRESULT hr = E_FAIL;

    if( pDo == NULL || m_pDisplayHelp == NULL )    
    {
        return hr;
    }

    INT_PTR nNodeType = ( ( CBaseNode * )pDo )->GetNodeType();

    if( nNodeType == RESULT_NODE || nNodeType == MAIN_NODE || nNodeType == 0 )
    {
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance() , IDS_TSCCHELPTOPIC , tchTopic , SIZE_OF_BUFFER( tchTopic ) ) );
        
        hr = m_pDisplayHelp->ShowTopic( tchTopic );
        
    }
    else if( nNodeType == SETTINGS_NODE || nNodeType == RSETTINGS_NODE )
    {
        if( nNodeType == SETTINGS_NODE )
        {
            IExtendServerSettings *pEss = NULL;

            INT iRet = -1;

            CSettingNode *pNode = dynamic_cast< CSettingNode *>( pDo );

            if( pNode != NULL )
            {
                if( pNode->GetObjectId( ) >= CUSTOM_EXTENSION )
                {
                    pEss = reinterpret_cast< IExtendServerSettings * >( pNode->GetInterface( ) );

                    if( pEss != NULL )
                    {
                        pEss->OnHelp( &iRet );

                        if( iRet == 0 )
                        {
                            return TRUE;
                        }
                    }
                }
            }
        }

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance() , IDS_SETTINGSHELP , tchTopic , SIZE_OF_BUFFER( tchTopic ) ) );
        
        hr = m_pDisplayHelp->ShowTopic( tchTopic );
    }

    return ( SUCCEEDED( hr ) ? TRUE : FALSE );
}

//----------------------------------------------------------------------            
BOOL CComp::OnDblClk( LPDATAOBJECT pDo )
{
    CSettingNode *pNode = dynamic_cast< CSettingNode *>( pDo );

    if( pNode == NULL )
    {
        // we're only concerned about Setting nodes

        return FALSE;
    }

    HWND hMain;

    if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
    {
        hMain = NULL;
    }

    INT nObjectId = pNode->GetObjectId( );
    
    switch( nObjectId )
    {
        /*
    case 0:
        
        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_CACHED_SESSIONS ) , hMain , CachedSessionsDlgProc , ( LPARAM )pNode );
        
        break;*/

    case DELETED_DIRS_ONEXIT:

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_YESNODIALOG ) , hMain , DeleteTempDirsDlgProc , ( LPARAM )pNode );

        break;

    case PERSESSION_TEMPDIR:

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_DIALOG_PERSESSION ) , hMain , UsePerSessionTempDirsDlgProc , ( LPARAM )pNode );

        break;

    /*
    case DEF_CONSECURITY:

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_DEFCONSEC ) , hMain , DefConSecurityDlgProc , ( LPARAM )pNode );

        break;

     */

    case LICENSING:

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_LICENSING ) , hMain , LicensingDlgProc , ( LPARAM )pNode );

        break;

    case ACTIVE_DESK:

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_ADP_DIALOG ) , hMain , ConfigActiveDesktop , ( LPARAM )pNode );

        break;

    case USERSECURITY:

        // error if we're trying to modify property in remote admin mode

        if( !g_bAppSrvMode )
        {
            xxxErrMessage( hMain , IDS_REMOTEADMIN_ONLY , IDS_WARN_TITLE , MB_OK | MB_ICONINFORMATION );

            break;
        }

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_PROPPAGE_TERMINAL_SERVER_PERM ) , hMain , UserPermCompat , ( LPARAM )pNode );

        break;

    case SINGLE_SESSION:

        // error if we're trying to modify property in remote admin mode

        if( !g_bAppSrvMode )
        {
            xxxErrMessage( hMain , IDS_REMOTEADMIN_ONLY , IDS_WARN_TITLE , MB_OK | MB_ICONINFORMATION );

            break;
        }

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_SINGLE_SESSION) , hMain , ConfigSingleSession , ( LPARAM )pNode );

        break;

    default:

        if( nObjectId >= CUSTOM_EXTENSION )
        {
            IExtendServerSettings *pEss = reinterpret_cast< IExtendServerSettings * >( pNode->GetInterface() );

            if( pEss != NULL )
            {          
                DWORD dwStatus;

                pEss->InvokeUI( hMain , &dwStatus );
               
                if( dwStatus == UPDATE_TERMSRV || dwStatus == UPDATE_TERMSRV_SESSDIR )
                {
                    ICfgComp *pCfgcomp = NULL;

                    m_pCompdata->GetServer( &pCfgcomp );

                    if( pCfgcomp != NULL )
                    {
                        ODS( L"TSCC!Comp OnDblClk forcing termsrv update\n" );

                        if( dwStatus == UPDATE_TERMSRV_SESSDIR )
                        {
                            HCURSOR hCursor = SetCursor( LoadCursor( NULL ,
                                    MAKEINTRESOURCE( IDC_WAIT ) ) );

                            if( FAILED( pCfgcomp->UpdateSessionDirectory( &dwStatus ) ) )
                            {
                                ReportStatusError( hMain , dwStatus );
                            }

                            SetCursor(hCursor);
                        }
                        else
                        {
                            pCfgcomp->ForceUpdate( );
                        }

                        pCfgcomp->Release();
                    }

                }
            }
        }


    }

    return TRUE;
}

/*
//----------------------------------------------------------------------            
HRESULT CComp::SetColumnWidth( int nCol )
{
    HWND hMain;

    int nCurColLen;

    CResultNode *pNode;

    do
    {
        if( FAILED( m_pHeaderCtrl->GetColumnWidth( nCol , &nCurColLen ) ) )
        {
            break;
        }
          
        if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
        {
            break;
        }
    
        HDC hdc = GetDC( hMain );
        
        SIZE sz;

        int idx = 0;

        TCHAR *psz;
        
        while( ( pNode = *m_pCompdata->GetResultNode( idx ) ) != NULL )
        {           
            
            switch( nCol )
            {
            case 0:
                
                psz = pNode->GetConName( );
                
                break;

            case 1:
                
                psz = pNode->GetTTName( );

                break;

            case 2:
                
                psz = pNode->GetTypeName( );
                
                break;

            // comment is too big allow user to adjust size
            }



            GetTextExtentPoint32( hdc , psz , lstrlen( psz ) , &sz );

            if( sz.cx > nCurColLen )
            {
                nCurColLen = sz.cx;
            }

            idx++;
        }
        
        
        m_pHeaderCtrl->SetColumnWidth( nCol , nCurColLen );
        
        ReleaseDC( hMain , hdc );

    } while( 0 );


    return S_OK;
}

*/

//----------------------------------------------------------------------                            
HRESULT CComp::SetColumnsForSettingsPane( )
{
    HWND hParent;

    SIZE sz = { 0 , 0 };

    TCHAR tchBuffer[ 256 ];

    INT nMaxLen;
    
    if( FAILED( m_pConsole->GetMainWindow( &hParent ) ) )
    {
        hParent = NULL;
    }
  
    HDC hdc = GetDC( hParent );

    if( hdc != NULL )
    {

        m_pCompdata->GetMaxTextLengthSetting( tchBuffer , &nMaxLen );
    
        VERIFY_S( TRUE , GetTextExtentPoint32( hdc , tchBuffer , nMaxLen , &sz ) );

        m_nSettingCol = sz.cx - 16 ; // remove icon width from column width

        m_pCompdata->GetMaxTextLengthAttribute( tchBuffer , &nMaxLen );
    
        VERIFY_S( TRUE , GetTextExtentPoint32( hdc , tchBuffer , nMaxLen , &sz ) );
    
        m_nAttribCol = sz.cx;

        ReleaseDC( hParent , hdc );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\compdata.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// Compdata.cpp : Implementation of CCompdata
#include "stdafx.h"
#include <ntverp.h>
#include "tscc.h"
#include "dataobj.h"
#include "Compdata.h"
#include "comp.h"
#include <regapi.h>
#include "cfgbkend_i.c"

void ErrMessage( HWND hwndOwner , INT_PTR iResourceID );

extern void xxxErrMessage( HWND hwnd , INT_PTR nResMessageId , INT_PTR nResTitleId , UINT nFlags );

extern void TscAccessDeniedMsg( HWND hwnd );

extern void TscGeneralErrMsg( HWND hwnd );

void InitWarningThread( PVOID pvParam );

extern "C" BOOL
IsWhistlerAdvanceServer();

BOOL g_bAppSrvMode = FALSE;

#ifdef DBG

bool g_fDebug = false;

#endif

//extern "C" BOOL RegisterCheckListWndClass( void );
/////////////////////////////////////////////////////////////////////////////
// CCompdata

//----------------------------------------------------------------------------------------------------------
CCompdata::CCompdata( )
{
    m_pConsole = NULL;

    m_pConsoleNameSpace = NULL;

    m_pCfgcomp = NULL;

    m_pMainRoot[ 0 ] = NULL;

    m_pMainRoot[ 1 ] = NULL;    


}

//----------------------------------------------------------------------------------------------------------
// NDMGR is asking for us to return a view of our doc ( MFC talk )
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::CreateComponent( LPCOMPONENT * ppComponent)
{
    *ppComponent = ( LPCOMPONENT )new CComp( this );

    if( *ppComponent == NULL )
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
// Obtain interfaces used by for the scope pane
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::Initialize( LPUNKNOWN pUnk )
{
    HRESULT hr;

#ifdef DBG

    HKEY hKey;

    LONG lStatus;

    // To control debug spewage add/remove this regkey

    lStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
        L"Software\\Microsoft\\TSCC\\Debug",
        0,
        KEY_READ,
        &hKey );

    if( lStatus == ERROR_SUCCESS )
    {
        g_fDebug = true;

        RegCloseKey( hKey );
    }

#endif

    hr = pUnk->QueryInterface( IID_IConsole , ( LPVOID *)&m_pConsole );

    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = pUnk->QueryInterface( IID_IConsoleNameSpace , ( LPVOID * )&m_pConsoleNameSpace );

    if( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = CoCreateInstance( CLSID_CfgComp , NULL , CLSCTX_INPROC_SERVER , IID_ICfgComp , ( LPVOID *)&m_pCfgcomp );

    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = m_pCfgcomp->Initialize( );

    if( FAILED( hr ) )
    {
        return hr;
    }

    // RegisterCheckListWndClass( );
    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_MAINFOLDERNAME , m_tchMainFolderName , SIZE_OF_BUFFER( m_tchMainFolderName ) ) );

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_SETTINGSFOLDER , m_tchSettingsFolderName , SIZE_OF_BUFFER( m_tchSettingsFolderName ) ) );    

    hr = BuildSettingsNodes( );

    if( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = BuildResultNodes( );
     
    return hr;
}



//----------------------------------------------------------------------------------------------------------
// Dispatch to notification handlers
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::Notify( LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = NOERROR;

    switch( event )
    {
    case MMCN_RENAME:

        ODS( L"IComponentdata -- MMCN_RENAME\n");

        break;

    case MMCN_EXPAND:

        ODS( L"IComponentdata -- MMCN_EXPAND\n" );

        ExpandScopeTree( lpDataObject , ( BOOL ) arg , ( HSCOPEITEM )param );

        break;

    case MMCN_DELETE:

        ODS( L"IComponentdata -- MMCN_DELETE\n" );
        break;

    case MMCN_PROPERTY_CHANGE:

        ODS( L"IComponentdata -- MMCN_PROPERTY_CHANGE\n" );

        break;

    default:
        ODS( L"CCompdata::Notify - - event not defined!\n" );
        hr = E_NOTIMPL;
    }

    return hr;
}

//----------------------------------------------------------------------------------------------------------
// Prepareing for parent entry
BOOL CCompdata::ExpandScopeTree( LPDATAOBJECT pRoot , BOOL bExpand , HSCOPEITEM hConsole )
{   
    SCOPEDATAITEM sdi;

    if( !bExpand )
    {
        return FALSE;
    }

    CBaseNode *pNode = dynamic_cast< CBaseNode *>( pRoot );

    if( pNode == NULL )
    {
        return FALSE;
    }

    if( pNode->GetNodeType( ) != 0 ) // ROOT_NODE add subscope items
    {
        return FALSE;
    }

    // make sure we're not re-adding

    for( int i = 0 ; i < 2 ; i++ )
    {
        if( m_pMainRoot[ i ] != NULL )
        {
            return TRUE;
        }
    }

    for( i = 0 ; i < 2 ; i++ )
    {
        m_pMainRoot[ i ] = ( CBaseNode * )new CBaseNode;
        
        if( m_pMainRoot[ i ] == NULL )
        {
            ODS( L"TSCC: Scope node failed allocation\n" );

            return FALSE;
        }

        m_pMainRoot[ i ]->SetNodeType( i + MAIN_NODE );

        //m_pMainRoot[ i ]->AddRef( );
   
        ZeroMemory( &sdi , sizeof( SCOPEDATAITEM ) );

        sdi.mask = SDI_STR | SDI_PARAM | SDI_PARENT;
    
        sdi.displayname = MMC_CALLBACK;

        sdi.relativeID = hConsole;

        sdi.lParam = (LPARAM)m_pMainRoot[ i ];

        if( FAILED( m_pConsoleNameSpace->InsertItem( &sdi ) ) )
        {
            //sdi.ID;

            return FALSE;
        }
    }

    return TRUE;
}

//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::CompareObjects( LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{ 
    if( lpDataObjectA == lpDataObjectB )
    {
        return S_OK;
    }

    return E_FAIL;
}

//----------------------------------------------------------------------------------------------------------
// Not yet finished
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetDisplayInfo( LPSCOPEDATAITEM pItem)
{
    CBaseNode *pNode = ( CBaseNode * )pItem->lParam;

    if( pItem->mask & SDI_STR )
    {
        if( pNode->GetNodeType( ) == MAIN_NODE )
        {
            //pItem->displayname = ( LPOLESTR )L"Connections"; 
            
            pItem->displayname = ( LPOLESTR )m_tchMainFolderName;
        }
        else if( pNode->GetNodeType( ) == SETTINGS_NODE )
        {            
            // pItem->displayname = ( LPOLESTR )L"Server Settings";

            pItem->displayname = ( LPOLESTR )m_tchSettingsFolderName;
        }
    }
    
    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::QueryDataObject( MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT * ppDataObject)
{
    *ppDataObject = NULL;

    switch( type )
    {

    case CCT_SCOPE:
    case CCT_SNAPIN_MANAGER:

        if( cookie == 0 )
        {
            *ppDataObject = ( LPDATAOBJECT )new CBaseNode( );
        }
        else
        {
            *ppDataObject = ( LPDATAOBJECT )cookie;

            // this is the only scopenode keep this one alive

            ( ( LPDATAOBJECT )*ppDataObject)->AddRef( );
        }

        break;

    case CCT_RESULT:
        
        // here we can cast from cookie for each node

        break;

    case CCT_UNINITIALIZED:

        // ok thanks

        break;

    }
    
    return ( *ppDataObject == NULL ) ? E_FAIL : S_OK ;
    
}

//----------------------------------------------------------------------------------------------------------
// Free all used interfaces
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::Destroy( )
{
    if( m_pConsole != NULL )
    {
        m_pConsole->Release( );
    }

    if( m_pConsoleNameSpace != NULL )
    {
        m_pConsoleNameSpace->Release( );
    }

    if( m_pMainRoot[ 0 ] != NULL )
    {   
    
        DWORD dwRef = m_pMainRoot[ 0 ]->Release( );
        
        DBGMSG( TEXT("Ref count for main node ended in %d\n" ) , dwRef );

    }

    if( m_pMainRoot[ 1 ] != NULL )
    {
        DWORD dwRef = m_pMainRoot[ 1 ]->Release( );
        
        DBGMSG( TEXT("Ref count for settings node ended in %d\n" ) , dwRef );
    }

    
    int items = m_rnNodes.GetSize( );

    for( int idx = 0 ; idx < items; ++idx )
    {
        CResultNode *pNode = *m_rnNodes.GetAt( idx );

        if( pNode != NULL )
        {
            pNode->FreeServer( );

            pNode->Release( );
        }
    }

    m_rnNodes.DeleteArray( );

    items = m_rgsNodes.GetSize( );

    for( idx = 0 ; idx < items; idx++ )
    {
        CSettingNode *pNode = *m_rgsNodes.GetAt( idx );

        if( pNode != NULL )
        {
            delete pNode;
        }
    }    

    m_rgsNodes.DeleteArray( );
    
    if( m_pCfgcomp != NULL )
    {
        m_pCfgcomp->Release( );
    }

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
// Places our menu items as spec'd
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::AddMenuItems( LPDATAOBJECT pNode , LPCONTEXTMENUCALLBACK pCtxMenu , PLONG plInsertion )
{
    TCHAR tchBuffer1[ 128 ];

    TCHAR tchBuffer2[ 128 ];

    ASSERT( pNode != NULL );

    ASSERT( pCtxMenu != NULL );

    ASSERT( plInsertion != NULL );

    if( pNode != m_pMainRoot[ 0 ] )
    {
        return S_FALSE;
    }

    CONTEXTMENUITEM ctxmi;

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_CTXM_NAME , tchBuffer1 , SIZE_OF_BUFFER( tchBuffer1 ) ) );

    ctxmi.strName = tchBuffer1;

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_CTXM_STATUS , tchBuffer2 , SIZE_OF_BUFFER( tchBuffer2 ) ) );

    ctxmi.strStatusBarText = tchBuffer2;

    ctxmi.lCommandID = IDM_CREATECON;

    ctxmi.lInsertionPointID =  CCM_INSERTIONPOINTID_PRIMARY_TOP ;

    ctxmi.fFlags = 0;

    ctxmi.fSpecialFlags = 0;

    *plInsertion |= CCM_INSERTIONALLOWED_TOP;

    //VERIFY_S( S_OK , pCtxMenu->AddItem( &ctxmi ) );

    //ctxmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;

    return pCtxMenu->AddItem( &ctxmi );

}

//----------------------------------------------------------------------------------------------------------
// This is where the wizard will kick off
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::Command( LONG lCommand , LPDATAOBJECT pNode )
{
    HWND hMain;

    if( pNode != m_pMainRoot[ 0 ] )
    {
        return S_FALSE;
    }

    if( lCommand == IDM_CREATECON )
    {
        // insure that no other connections are being edited

        for( int i = 0 ; i < m_rnNodes.GetSize( ); i++ )
        {
            CResultNode *pNd = *m_rnNodes.GetAt( i );

            if( pNd != NULL )
            {
                if( pNd->m_bEditMode )
                {   
                    if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
                    {
                        hMain = NULL;
                    }
                
                    xxxErrMessage( hMain , IDS_ERR_INEDITMODE , IDS_WARN_TITLE , MB_OK | MB_ICONWARNING );
                    
                    return E_FAIL;
                }
            }
        }

        // check for admin rights.
        BOOL bReadOnly;

        m_pCfgcomp->IsSessionReadOnly( &bReadOnly );

        if( bReadOnly )
        {
           if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
           {
               hMain = NULL;
           }
           // report access denied
           
           TscAccessDeniedMsg( hMain );

            return S_FALSE;
        }

        if( !InitDialogObjects( ) )
        {
            return E_FAIL;
        }

        BuildWizardPath( );

        FreeDialogObjects( );
    }

    m_pConsole->UpdateAllViews( ( LPDATAOBJECT )m_rnNodes.GetAt( 0 ) , 0 , 0 );

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
// Try to allocate
BOOL CCompdata::InitDialogObjects( )
{    
    try
    {
        m_pDlg[ 0 ] = ( CDialogWizBase * )new CWelcome( );

        m_pDlg[ 1 ] = ( CDialogWizBase * )new CConType( this );

        m_pDlg[ 2 ] = ( CDialogWizBase * )new CSecurity( this );

        // m_pDlg[ 3 ] = ( CDialogWizBase * )new CTimeout( );

        // m_pDlg[ 4 ] = ( CDialogWizBase * )new CAutoLogon( );

        // m_pDlg[ 5 ] = ( CDialogWizBase * )new CInitProg( );

        m_pDlg[ 3 ] = ( CDialogWizBase * )new CRemotectrl( );

        // m_pDlg[ 7 ] = ( CDialogWizBase * )new CWallPaper( );

        m_pDlg[ 4 ] = ( CDialogWizBase * )new CConProp( this );

        m_pDlg[ 5 ] = ( CDialogWizBase * )new CLan( this );

        m_pDlg[ 6 ] = ( CDialogWizBase * )new CAsync( this );

        m_pDlg[ 7 ] = ( CDialogWizBase * )new CFin( this );
    }
    catch(...)
    {
        return FALSE;
    }

    return TRUE;
}

//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::BuildWizardPath( )
{
    // build up ms propsheetheader

    PROPSHEETPAGE psp;

    PROPSHEETHEADER psh;

    for( int idx = 0 ;  idx < MS_DIALOG_COUNT ; ++idx )
    {
        if( m_pDlg[ idx ] != NULL )
        {
            m_pDlg[ idx ]->GetPropertySheetPage( psp );

            m_hPages.Insert( CreatePropertySheetPage( &psp ) );
        }
    }

    // obtain clsid of IExtendwizard object

    // forward IWizardProvider to object

    // add last page CFin

    ZeroMemory( &psh , sizeof( PROPSHEETHEADER ) );

    psh.dwSize = sizeof( PROPSHEETHEADER );

    psh.hInstance = _Module.GetModuleInstance( );

    if( m_pConsole != NULL )
    {
        m_pConsole->GetMainWindow( &psh.hwndParent );
    }

    //psh.pszCaption = MAKEINTRESOURCE( IDS_WIZARDTITLE ); //NULL

    psh.dwFlags =  PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER ;

    psh.pszbmWatermark = MAKEINTRESOURCE( IDB_TSCC_LOGO );

    psh.pszbmHeader    = MAKEINTRESOURCE( IDB_TSCC_ICON );

    psh.phpage         = m_hPages.ExposeArray( );

    psh.nStartPage     = 0;

    psh.nPages         = m_hPages.GetSize( );

    PropertySheet( &psh );
   
    return TRUE;
}

//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::FreeDialogObjects( )
{
    for( int idx = 0 ; idx < MS_DIALOG_COUNT ; ++idx )
    {
        if( m_pDlg[ idx ] != NULL )
        {
            delete m_pDlg[ idx ];
        }
    }

    m_hPages.DeleteArray( );

    return TRUE;
}

//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::IsConnectionFolder( LPDATAOBJECT pObject )
{
    if( SUCCEEDED( CompareObjects( pObject , m_pMainRoot[ 0 ] ) ) )
    {
        return TRUE;
    }
 
    return FALSE;
}

//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::IsSettingsFolder( LPDATAOBJECT pObject )
{
    if( SUCCEEDED( CompareObjects( pObject , m_pMainRoot[ 1 ] ) ) )
    {
        return TRUE;
    }

    return FALSE;
}


//----------------------------------------------------------------------------------------------------------
HRESULT CCompdata::UpdateAllResultNodes( )
{
    HWND hMain;
    
    if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
    {
        hMain = NULL;
    }

    int items = m_rnNodes.GetSize( );

    for( int idx = 0 ; idx < items; ++idx )
    {
        CResultNode *pNode = *m_rnNodes.GetAt( idx );

        if( pNode != NULL )
        {
            if( pNode->m_bEditMode )
            {
                 // ErrMessage( NULL , IDS_ERR_INEDITMODE );
                
                xxxErrMessage( hMain , IDS_ERR_INEDITMODE , IDS_WARN_TITLE , MB_OK | MB_ICONWARNING );

                 return E_FAIL;
            }
        }
    }


    HRESULT hr = m_pCfgcomp->Refresh( );
    
    if( FAILED( hr ) )
    {
        ODS( L"m_pCfgcomp->Refresh - failed\n" );

        if( hr == E_ACCESSDENIED )
        {
            TscAccessDeniedMsg( hMain );
        }
        else
        {
            TscGeneralErrMsg( hMain );
        }

        return hr;
    }

    for( idx = 0 ; idx < items; ++idx )
    {
        CResultNode *pNode = *m_rnNodes.GetAt( idx );

        if( pNode != NULL )
        {
            pNode->FreeServer( );

            pNode->Release( );
        }
    }

    m_rnNodes.DeleteArray( );
    
    return BuildResultNodes( );
}

//----------------------------------------------------------------------------------------------------------
BOOL IsAppServerMode()
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;
    BOOL fSuiteTerminal = FALSE;
    BOOL fSuiteSingleUserTS = FALSE; 

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
    fSuiteTerminal = VerifyVersionInfo(&osVersionInfo, VER_SUITENAME,
            dwlConditionMask);

    osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;
    fSuiteSingleUserTS = VerifyVersionInfo(&osVersionInfo, VER_SUITENAME,
            dwlConditionMask);

    if( (FALSE == fSuiteSingleUserTS) && (TRUE == fSuiteTerminal) )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//----------------------------------------------------------------------------------------------------------
HRESULT CCompdata::BuildSettingsNodes( )
{

    // Resource ID for item move to snodes.h

    //INT rgResid[] = { 
    //                  IDS_DELTEMPONEXIT, 
    //                  IDS_USETEMPDIR,
                      /* IDS_DEFCONSEC, */
    //                  IDS_LICENSING,
    //                  IDS_ADS_ATTR,
    //                  IDS_USERPERM,
    //                  IDS_SINGLE_SESSION,
    //                  -1};

    DWORD dwNumItems = sizeof( RGRESID ) / sizeof( RGRESID[0] );

    BOOL bAdvanceServer = IsWhistlerAdvanceServer();

    BOOL bAppSrvMode = FALSE;

    TCHAR tchbuffer[ 256 ];

    TCHAR tchKey[ ] = L"Software\\Microsoft\\TSCC\\CLSID";

    HKEY hKey;
    
    DWORD dwStatus;
 
    TCHAR szSubKeyName[ 256 ];

    DWORD dwSubKeyNameLength;
    
    CLSID clsidOther;

    INT nObjectId = 0;

    ISettingsComp *pSettings = NULL;
    IExtendServerSettings *pExtendServerSettings = NULL;

    if( m_pCfgcomp == NULL || FAILED( m_pCfgcomp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ) )
    {
        return E_FAIL;
    }

    ASSERT( sizeof( RGRESID ) / sizeof( RGRESID[0] ) == sizeof(VALIDOBJECTONSERVER)/sizeof(VALIDOBJECTONSERVER[0]) );
    ASSERT( sizeof(VALIDOBJECTONSERVER)/sizeof(VALIDOBJECTONSERVER[0]) == sizeof(VALIDOBJECTONADS)/sizeof(VALIDOBJECTONADS[0]) );

    
    for( DWORD idx = 0; idx < dwNumItems  ; idx++ )
    {        
        // error checking, do go over array boundary
        if( !bAdvanceServer )
        {
            if( idx > sizeof(VALIDOBJECTONSERVER)/sizeof(VALIDOBJECTONSERVER[0]) )
            {
                ASSERT(FALSE);
                continue;
            } 
        }
        else
        {
            if( idx > sizeof(VALIDOBJECTONADS)/sizeof(VALIDOBJECTONADS[0]) )
            {
                ASSERT(FALSE);
                continue;
            } 
        }

        if( ( bAdvanceServer && VALIDOBJECTONADS[idx] ) || (!bAdvanceServer && VALIDOBJECTONSERVER[idx] ) )
        {

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , RGRESID[ idx ] , tchbuffer , SIZE_OF_BUFFER( tchbuffer ) ) );

            // ASSERT( idx < MAX_SETTINGS );

            CSettingNode *pSet = ( CSettingNode * )new CSettingNode( );
        
            if( pSet != NULL )
            {
                pSet->SetObjectId( nObjectId );

                pSet->SetInterface( ( LPUNKNOWN )pSettings );

                if( !pSet->SetAttributeName( tchbuffer ) )
                {
                    ODS( L"TSCC: BuildSettingsNodes -- SetItemName failed\n" );
                }

                m_rgsNodes.Insert( pSet );

                nObjectId++;
            }        
        }
        else
        {
            nObjectId++;
        }        
    }

    pSettings->Release( );

    // Find out how many extension nodes are out there.

    // First we need to get the specific tssd component supplied for session
    // directory services, but only on application servers.
    bAppSrvMode = IsAppServerMode();
    
    if( bAppSrvMode && ( dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                                 REG_CONTROL_TSERVER ,
                                 0,
                                 KEY_READ,
                                 &hKey ) ) == ERROR_SUCCESS )
    {
        DBGMSG( L"RegOpenKeyEx tssd ok at %s\n" , REG_CONTROL_TSERVER );

        dwSubKeyNameLength = sizeof( szSubKeyName );

        dwStatus = RegQueryValueEx( hKey ,
            REG_TS_SESSDIRCLSID ,
            NULL ,
            NULL ,
            ( LPBYTE )szSubKeyName ,
            &dwSubKeyNameLength );

        DBGMSG( L"tssd RegQueryValueEx for %s\n" , REG_TS_SESSDIRCLSID );

        DBGMSG( L"tssd RegQueryValueEx ret 0x%x\n" , dwStatus );        

        if( dwStatus == ERROR_SUCCESS )
        {
            DBGMSG( L"CCompdata!BuildSettingsNode key name %s\n" , szSubKeyName );

            if( SUCCEEDED( CLSIDFromString( szSubKeyName , &clsidOther ) ) )
            {
                if( SUCCEEDED( CoCreateInstance( 
                    clsidOther ,
                    NULL ,
                    CLSCTX_INPROC_SERVER ,
                    IID_IExtendServerSettings ,
                    ( LPVOID *) &pExtendServerSettings ) ) )
                {
                    if( pExtendServerSettings != NULL )
                    {
                        CSettingNode *pSet = ( CSettingNode * )new CSettingNode( );
        
                        if( pSet != NULL )
                        {
                            pSet->SetObjectId( nObjectId );

                            pSet->SetInterface( ( LPUNKNOWN )pExtendServerSettings );

                            pExtendServerSettings->GetAttributeName( tchbuffer );

                            if( !pSet->SetAttributeName( tchbuffer ) )
                            {
                                ODS( L"TSCC: BuildSettingsNodes -- SetItemName failed\n" );
                            }

                            m_rgsNodes.Insert( pSet );

                            nObjectId++;
                        }
                    }
                    
                    pExtendServerSettings->Release();
                }
            }
        }

        RegCloseKey( hKey );
    }   

    // look for other custom components at HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\TSCC\CLSID

    idx = 0;
    
    if( ( dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                                 tchKey ,
                                 0,
                                 KEY_READ,
                                 &hKey ) ) == ERROR_SUCCESS )
    {
        
        while( dwStatus == ERROR_SUCCESS )
        {
            dwSubKeyNameLength = SIZE_OF_BUFFER( szSubKeyName );

            dwStatus = RegEnumKeyEx(
                                hKey ,
                                ( DWORD )idx,
                                szSubKeyName ,
                                &dwSubKeyNameLength,
                                NULL ,
                                NULL ,
                                NULL ,
                                NULL 
                                );
            
            if( dwStatus != ERROR_SUCCESS )
            {
                DBGMSG( L"RegEnumKeyEx failed with 0x%x\n" , dwStatus );

                break;
            }
            
            DBGMSG( L"CCompdata!BuildSettingsNode key name %s\n" , szSubKeyName );

            idx++;
            
            
            if( FAILED( CLSIDFromString( szSubKeyName , &clsidOther ) ) )
            {
                continue;
            }
            
            if( SUCCEEDED( CoCreateInstance( 
                                clsidOther ,
                                NULL ,
                                CLSCTX_INPROC_SERVER ,
                                IID_IExtendServerSettings ,
                                ( LPVOID *) &pExtendServerSettings ) ) )
            {


                if( pExtendServerSettings != NULL )
                {
                    CSettingNode *pSet = ( CSettingNode * )new CSettingNode( );
        
                    if( pSet != NULL )
                    {
                        pSet->SetObjectId( nObjectId );

                        pSet->SetInterface( ( LPUNKNOWN )pExtendServerSettings );

                        pExtendServerSettings->GetAttributeName( tchbuffer );

                        if( !pSet->SetAttributeName( tchbuffer ) )
                        {
                            ODS( L"TSCC: BuildSettingsNodes -- SetItemName failed\n" );
                        }

                        m_rgsNodes.Insert( pSet );

                        nObjectId++;
                    }
                }

                pExtendServerSettings->Release();
            }
        } // while

        RegCloseKey( hKey );
    } // if
    
    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
HRESULT CCompdata::BuildResultNodes( )
{
    CResultNode *pResultNode;
    
    WS *pWs;

    ULONG ulitems = 0;
    
    ULONG cbSize = 0;

    ULONG cItems = 0;

    BOOL bValid = TRUE;
    
    PGUIDTBL pGuidtbl = NULL;

    TCHAR szOldPdName[ MAX_PATH ];

    HRESULT hr = E_FAIL;


    if( SUCCEEDED( m_pCfgcomp->GetWinstationList( &ulitems , &cbSize , &pWs ) ) )
    {
        // Get valid lanids        

        for( ULONG i = 0 ; i < ulitems ; ++i )
        {
            // do not list console

            if( lstrcmpi( pWs[ i ].Name , L"console" ) == 0 )
            {
                continue;
            }

            pResultNode = new CResultNode( );

            if( pResultNode == NULL )
            {
                return E_OUTOFMEMORY;
            }

            pResultNode->SetConName( pWs[ i ].Name , lstrlen( pWs[ i ].Name ) );

            pResultNode->SetTTName( pWs[ i ].pdName , lstrlen( pWs[ i ].pdName ) );

            pResultNode->SetTypeName( pWs[ i ].wdName , lstrlen( pWs[ i ].wdName ) );

            pResultNode->SetComment(  pWs[ i ].Comment , lstrlen( pWs[ i ].Comment ) );

            pResultNode->EnableConnection( pWs[ i ].fEnableWinstation );

            pResultNode->SetImageIdx( ( pWs[ i ].fEnableWinstation ? 1 : 2 ) );

            pResultNode->SetServer( m_pCfgcomp );


            if( lstrcmpi( pWs[i].pdName , szOldPdName ) != 0 )
            {
                if( pGuidtbl != NULL )
                {
                    CoTaskMemFree( pGuidtbl );

                    pGuidtbl = NULL;                    
                }

                hr = m_pCfgcomp->GetLanAdapterList2( pWs[ i ].pdName , &cItems , &pGuidtbl );

                lstrcpy( szOldPdName , pWs[i].pdName );
            }

            if( pGuidtbl != NULL && SUCCEEDED( hr ) )
            {
                BOOL bFoundaMatch = FALSE;

                for( int k = 0; k < ( int )cItems ; ++k )
                {
                    if( ( pGuidtbl[ k ].dwStatus == ERROR_SUCCESS ) && ( pGuidtbl[ k ].dwLana == pWs[ i ].LanAdapter ) )
                    {
                        bFoundaMatch = TRUE;

                        break;
                    }
                }

                if( !bFoundaMatch )
                {
                    DWORD dwStatus;

                    ODS( L"TSCC:BuildResultNodes we found an invalid lanaid\n" );

                    pWs[ i ].fEnableWinstation = 0;

                    m_pCfgcomp->UpDateWS( pWs , UPDATE_ENABLEWINSTATION , &dwStatus, TRUE );

                    pResultNode->EnableConnection( 0 );
                    
                    pResultNode->SetImageIdx( 2 );
                }


                if( bValid ) // once set to false we know we have a winstation that has an invalid lanaid
                {
                    bValid = bFoundaMatch;
                }

            }            
            
    
            if( m_rnNodes.Insert( pResultNode ) == 0 )
            {
                return E_OUTOFMEMORY;
            }
        }

        if( pGuidtbl != NULL )
        {
            CoTaskMemFree( pGuidtbl );
        }

        CoTaskMemFree( pWs );

        
        if( !bValid )
        {
            HWND hwnd;

            BOOL bReadOnly = FALSE;

            m_pCfgcomp->IsSessionReadOnly( &bReadOnly );

            if( bReadOnly )
            {
                return S_OK;
            }

            if( m_pConsole != NULL )
            {
                m_pConsole->GetMainWindow( &hwnd );

                DWORD dwTid;

                HANDLE hThread = CreateThread( NULL , 0 , ( LPTHREAD_START_ROUTINE  )InitWarningThread,  hwnd , 0 , &dwTid );

                CloseHandle( hThread );                
            }
        }
        
                
        return S_OK;
    }

    return E_FAIL;
}

//----------------------------------------------------------------------------------------------------------
//BOOL CCompdata::GetResultNode( int idx , CResultNode** pRn )
CResultNode * CCompdata::GetResultNode( int idx )
{
    
    return *m_rnNodes.GetAt( idx );
/*
    if( *pRn == NULL )
    {
        return FALSE;
    }

    return TRUE;
    */
}

//----------------------------------------------------------------------------------------------------------
HRESULT CCompdata::InsertSettingItems( LPRESULTDATA pResultData )
{
    RESULTDATAITEM rdi;

    HRESULT hr;
    
    CSettingNode *pSettingNode = NULL;

    ASSERT( pResultData != NULL );

    if( pResultData == NULL )
    {
        return E_INVALIDARG;
    }

    ZeroMemory( &rdi , sizeof(RESULTDATAITEM) );

    rdi.mask = RDI_STR | RDI_PARAM | RDI_IMAGE;
    
    rdi.str = MMC_CALLBACK;

    if (NULL != m_pCfgcomp)
    {
        DWORD nVal, dwStatus;
        ISettingsComp* pISettingComp = NULL;

        hr = m_pCfgcomp->QueryInterface( IID_ISettingsComp, (void **) &pISettingComp );

        if (SUCCEEDED(hr))
        {
            hr = pISettingComp->GetTermSrvMode( &nVal, &dwStatus );
            
            if (SUCCEEDED(hr))
            {
                g_bAppSrvMode = nVal;
            }

            pISettingComp->Release();
        }
    }

    int nMax = m_rgsNodes.GetSize();

    for( int idx = 0 ; idx < nMax ; ++idx )
    {  
        // init object -- if it fails skip over it
        pSettingNode = *m_rgsNodes.GetAt( idx );

        if( pSettingNode != NULL )
        {
            if( FAILED( pSettingNode->GetNodeStatus( ) ) )
            {
                continue;
            }
        

        /*
        if( m_rgsNodes[ idx ].GetObjectId() == USERSECURITY )
        {
            // check to see if we're remote admin mode
            // if so skip over usersecurity

            if( !bDisplayUserPerm )
            {
                continue;
            }
        }
        */
            rdi.itemID = 1; // unique from connection items

            rdi.lParam = ( LPARAM )pSettingNode;

            rdi.nImage = pSettingNode->GetImageIdx( );

            hr = pResultData->InsertItem( &rdi );

            if( FAILED( hr ) )
            {
                return hr;
            }
        }
    }

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
HRESULT CCompdata::InsertFolderItems( LPRESULTDATA pResultData )
{
    RESULTDATAITEM rdi;

    HRESULT hr;

    // TCHAR tchBuffer[80];

    ASSERT( pResultData != NULL );

    if( pResultData == NULL )
    {
        return E_INVALIDARG;
    }

    ZeroMemory( &rdi , sizeof(RESULTDATAITEM) );

    rdi.mask = RDI_STR | RDI_PARAM | RDI_IMAGE;
    
    rdi.str = MMC_CALLBACK;

    int items = m_rnNodes.GetSize( );

    for( int idx = 0 ; idx < items ; ++idx )
    {
        CResultNode *pNode = *m_rnNodes.GetAt( idx );

        if( pNode == NULL )
        {
            return E_FAIL;
        }

        rdi.lParam = ( LPARAM )pNode;

        rdi.nImage = pNode->GetImageIdx( );

        hr = pResultData->InsertItem( &rdi );

        if( FAILED( hr ) )
        {
            return hr;
        }
    }

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
int CCompdata::GetServer( ICfgComp **ppCfgcomp )
{
    if( m_pCfgcomp != NULL )
    {
        *ppCfgcomp = m_pCfgcomp;

        return  ( ( ICfgComp * )*ppCfgcomp )->AddRef( );
    }

    return 0;
}

//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::OnDeleteItem( LPDATAOBJECT pDo)
{
    ICfgComp *pCfgcomp;

    CResultNode *pNode = dynamic_cast< CResultNode *>( pDo );

    if( pNode != NULL )
    {
        HWND hWnd = NULL;

        m_pConsole->GetMainWindow( &hWnd );
        
        if( pNode->GetServer( &pCfgcomp ) == 0 )
        {
            return FALSE;
        }

    	TCHAR tchWarnText[ 512 ];

        TCHAR tchmsg[ 256 ];

    	TCHAR tchDeleteTitle[ 80 ];

        LONG lCount;
        
        // check to see if anyone is connected 
        
        pCfgcomp->QueryLoggedOnCount( pNode->GetConName( ) , &lCount );
        
        if( lCount > 0 )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DELETELIVECON , tchmsg , SIZE_OF_BUFFER( tchmsg ) ) );

            wsprintf( tchWarnText , tchmsg , pNode->GetConName( ) );            
        }
        else
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DELETETEXT , tchWarnText , SIZE_OF_BUFFER( tchWarnText ) ) );
        }

    	VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DELTITLE , tchDeleteTitle , SIZE_OF_BUFFER( tchDeleteTitle ) ) );

        if( MessageBox( hWnd , tchWarnText , tchDeleteTitle , MB_YESNO | MB_ICONEXCLAMATION ) == IDNO )
        {
            return FALSE;
        }
        
        if( FAILED( pCfgcomp->DeleteWS( pNode->GetConName( ) ) ) )
        {
            // WARN USER
            ErrMessage( hWnd , IDS_ERR_DELFAIL );

        	return FALSE;
           
        }
        else
        {
            VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );
        }
        
        pCfgcomp->Release( );
    }

    BOOL bFound;

    int idx = m_rnNodes.FindItem( pNode , bFound );

    if( bFound )
    {
        pNode->FreeServer( );

        pNode->Release( );

        m_rnNodes.DeleteItemAt( idx );
    }

    m_pConsole->UpdateAllViews( ( LPDATAOBJECT )m_rnNodes.GetAt( 0 ) , 0 , 0 );

    return TRUE;
}

//----------------------------------------------------------------------------------------------------------
// MMC Free up ppStr when it's done
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetSnapinDescription( LPOLESTR *ppStr )
{
    TCHAR tchDescription[ 1024 ];

    int iCharCount = LoadString( _Module.GetResourceInstance( ) , IDS_DESCRIPTION , tchDescription , SIZE_OF_BUFFER( tchDescription ) );

    *ppStr = ( LPOLESTR )CoTaskMemAlloc( iCharCount * sizeof( TCHAR ) + sizeof( TCHAR ) );

    if( *ppStr != NULL )
    {
        lstrcpy( *ppStr , tchDescription );
        
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//----------------------------------------------------------------------------------------------------------
// MMC Free up ppStr when it's done
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetProvider( LPOLESTR *ppStr )
{
    TCHAR tchProvider[ 128 ];
    
    int iCharCount = LoadString( _Module.GetResourceInstance( ) , IDS_PROVIDER , tchProvider , SIZE_OF_BUFFER( tchProvider ) );

    *ppStr = ( LPOLESTR )CoTaskMemAlloc( iCharCount * sizeof( TCHAR ) + sizeof( TCHAR ) );

    if( *ppStr != NULL )
    {
        lstrcpy( *ppStr , tchProvider );
        
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//----------------------------------------------------------------------------------------------------------
// MMC Free up ppStr when it's done
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetSnapinVersion( LPOLESTR *ppStr  )
{
    char chVersion[ 32 ] = VER_PRODUCTVERSION_STR;

    TCHAR tchVersion[ 32 ];

    int iCharCount = MultiByteToWideChar( CP_ACP , 0 , chVersion , sizeof( chVersion ) , tchVersion , SIZE_OF_BUFFER( tchVersion ) );
    
    *ppStr = ( LPOLESTR )CoTaskMemAlloc( ( iCharCount + 1 ) * sizeof( TCHAR ) );
    
    if( *ppStr != NULL && iCharCount != 0 )
    {
        lstrcpy( *ppStr , tchVersion );
        
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//----------------------------------------------------------------------------------------------------------
// Supply an icon here for the main icon in the about box
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetSnapinImage( HICON *phIcon )
{
    //*phIcon = ( HICON )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_ABOUT )  , IMAGE_ICON , 37 ,37 , LR_DEFAULTCOLOR );
    *phIcon = ( HICON )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_GENERAL2 )  , IMAGE_ICON , 32 ,32 , LR_DEFAULTCOLOR );

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
// Supply an icon here for the main icon in the about box
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetStaticFolderImage(  HBITMAP *phSmallImage , HBITMAP *phSmallImageOpen , HBITMAP *phLargeImage, COLORREF *pClr )
{
    *phSmallImage = ( HBITMAP )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDB_BITMAP_GENSMALL )  , IMAGE_BITMAP , 16 ,16 , LR_DEFAULTCOLOR );

    *phSmallImageOpen = ( HBITMAP )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDB_BITMAP_GENSMALL )  , IMAGE_BITMAP , 16 ,16 , LR_DEFAULTCOLOR );

    *phLargeImage = ( HBITMAP )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDB_BITMAP_GENLARGE )  , IMAGE_BITMAP , 32 ,32 , LR_DEFAULTCOLOR );

    *pClr = RGB( 255 , 0 , 255 );

    //return E_NOTIMPL;

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
// MMC will ask for our help file
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetHelpTopic( LPOLESTR *ppszHelpFile )
{
    ODS( L"CCompdata::GetHelpTopic called\n" );

    if( ppszHelpFile == NULL )
    {
        return E_INVALIDARG;
    }

    TCHAR tchHelpFile[ MAX_PATH ];

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_TSCCSNAPHELP , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) ) );
  
    // mmc will call CoTaskMemFree

    *ppszHelpFile = ( LPOLESTR )CoTaskMemAlloc( sizeof( tchHelpFile ) );

    if( *ppszHelpFile != NULL )
    {
        if( GetSystemWindowsDirectory( *ppszHelpFile , MAX_PATH ) != 0 )
        {
            lstrcat( *ppszHelpFile , tchHelpFile );
        }
        else
        {
            lstrcpy( *ppszHelpFile , tchHelpFile );
        }

        ODS( *ppszHelpFile );

        ODS( L"\n" );

        return S_OK;
    }

    return E_OUTOFMEMORY;
}
//----------------------------------------------------------------------------------------------------------
// Helper methods for fixing the column lengths
//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::GetMaxTextLengthSetting( LPTSTR pszText , PINT pnMaxLen )
{
    INT nIndex = 0;

    INT nCurrentMax = 0;

    INT nMax;

    *pnMaxLen = 0;

    nMax = m_rgsNodes.GetSize( );

    CSettingNode *pSettingNode;

    for( int idx = 0 ; idx < nMax ; ++idx )
    {
        pSettingNode = *m_rgsNodes.GetAt( idx );

        if( pSettingNode != NULL && pSettingNode->GetAttributeName( ) != NULL )
        {
            nCurrentMax = lstrlen( pSettingNode->GetAttributeName( ) );

            if( *pnMaxLen < nCurrentMax )
            {
                *pnMaxLen = nCurrentMax;

                nIndex = idx;            
            }
        }
    }

    pSettingNode = *m_rgsNodes.GetAt( nIndex );

    if (pSettingNode != NULL && pSettingNode->GetAttributeName( ) != NULL)
    {

        lstrcpy( pszText , pSettingNode->GetAttributeName( ) );
    }

    return TRUE;
}

//----------------------------------------------------------------------------------------------------------
// Helper methods for fixing the column lengths
//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::GetMaxTextLengthAttribute( LPTSTR pszText , PINT pnMaxLen )
{
    INT nIndex = 0;

    INT nCurrentMax = 0;

    INT nMax;

    *pnMaxLen = 0;

    nMax = m_rgsNodes.GetSize( );

    CSettingNode *pSettingNode = NULL;

    for( int idx = 0 ; idx < nMax ; ++idx )
    {        
        pSettingNode = *m_rgsNodes.GetAt( idx );

        if (pSettingNode != NULL && pSettingNode->GetAttributeName( ) != NULL )
        {

            nCurrentMax = lstrlen( pSettingNode->GetAttributeValue( ) );

            DBGMSG( L"CCompdata!GetMaxTextLengthAttribute AttributeValue = %s\n", pSettingNode->GetAttributeValue( ) );

            if( *pnMaxLen < nCurrentMax )
            {
                *pnMaxLen = nCurrentMax;

                nIndex = idx;            
            }
        }
    }

    pSettingNode = *m_rgsNodes.GetAt( nIndex );
    
    if (pSettingNode != NULL)
    {
        LPTSTR pszValue = pSettingNode->GetAttributeValue( );

        if(pszValue != NULL)
        {
            lstrcpy( pszText , pszValue );    
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}



void InitWarningThread( PVOID pvParam )
{
    HWND hwnd = ( HWND )pvParam;

    TCHAR tchMessage[ 256 ];

    TCHAR tchTitle[ 80 ];

    Sleep( 200 );

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABNETWORK , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_TSCERRTITLE , tchTitle , SIZE_OF_BUFFER( tchTitle ) ) );
    
    MessageBox( hwnd , tchMessage , tchTitle , MB_ICONINFORMATION | MB_OK );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\comp.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef __COMP_H_
#define __COMP_H_

#include <mmc.h>

/*
#define IDM_ENABLE_CONNECTION 102

#define IDM_RENAME_CONNECTION 103

#define IDM_SETTINGS_PROPERTIES 104

#define IDM_SETTINGS_DELTEMPDIRSONEXIT 105

#define IDM_SETTINGS_USETMPDIR 106
*/

class CComp:
  public IComponent,
  public IExtendContextMenu,
  public IExtendPropertySheet
  // public IExtendControlbar,
  
{
public:

    CComp( CCompdata *);
    ~CComp();

    //
    // IUnknown
    //

    STDMETHOD( QueryInterface )( REFIID , PVOID * );
    
    STDMETHOD_( ULONG , AddRef )( );

    STDMETHOD_( ULONG , Release )( );

    //
    // IComponent interface members
    //

    STDMETHOD( Initialize )( LPCONSOLE );

    STDMETHOD( Notify )( LPDATAOBJECT , MMC_NOTIFY_TYPE , LPARAM , LPARAM );

    STDMETHOD( Destroy )( MMC_COOKIE  );

    STDMETHOD( GetResultViewType )( MMC_COOKIE , LPOLESTR* , PLONG );

    STDMETHOD( QueryDataObject )( MMC_COOKIE , DATA_OBJECT_TYPES , LPDATAOBJECT* );

    STDMETHOD( GetDisplayInfo )( LPRESULTDATAITEM );

    STDMETHOD( CompareObjects )( LPDATAOBJECT , LPDATAOBJECT );

    HRESULT OnShow( LPDATAOBJECT , BOOL );

    HRESULT InsertItemsinResultPane( );

    HRESULT AddSettingsinResultPane( );

    HRESULT OnSelect( LPDATAOBJECT , BOOL , BOOL );

    //
    // IExtendContextMenu
    

    STDMETHOD( AddMenuItems )( LPDATAOBJECT , LPCONTEXTMENUCALLBACK , PLONG );

    STDMETHOD( Command )( LONG , LPDATAOBJECT );


    STDMETHOD( CreatePropertyPages )( LPPROPERTYSHEETCALLBACK , LONG_PTR , LPDATAOBJECT );

    STDMETHOD( QueryPagesFor )( LPDATAOBJECT );

    BOOL OnRefresh( LPDATAOBJECT );

    BOOL OnDelete( LPDATAOBJECT );

    BOOL OnViewChange( );

    BOOL OnAddImages( );

    BOOL OnHelp( LPDATAOBJECT );

    BOOL OnDblClk( LPDATAOBJECT );

    // HRESULT SetColumnWidth( int );

    HRESULT SetColumnsForSettingsPane( );
  
private:

    ULONG m_cRef;

    LPCONSOLE m_pConsole;

    CCompdata* m_pCompdata;   

    LPRESULTDATA m_pResultData;

    LPHEADERCTRL m_pHeaderCtrl;

    LPCONSOLEVERB m_pConsoleVerb;

    LPIMAGELIST m_pImageResult;

    LPDISPLAYHELP m_pDisplayHelp;

    INT m_nSettingCol;

    INT m_nAttribCol;

    // TCHAR m_strDispName[80];

    // IConsoleVerb*    m_ipConsoleVerb;

    
    
    // LPTOOLBAR        m_ipToolbar1;

    // LPCONTROLBAR     m_ipControlbar;
    
    // HBITMAP          m_hbmp16x16;
    
    // HBITMAP          m_hbmp32x32;
        
    // HBITMAP          m_hbmpToolbar1;
    
    
    
    // LONG             m_nFileCount;

};

#endif // __COMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\dataobj.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _DATAOBJ_H
#define _DATAOBJ_H

#include<mmc.h>

#define IDM_ENABLE_CONNECTION 102

#define IDM_RENAME_CONNECTION 103

#define IDM_SETTINGS_PROPERTIES 104

#define IDM_SETTINGS_DELTEMPDIRSONEXIT 105

#define IDM_SETTINGS_USETMPDIR 106

#define IDM_SETTINGS_ADP 110

#define IDM_SETTINGS_SS  111

//This needs to match the definition in tssdjet
#define IDM_MENU_PROPS 2001

// {E26D0049-378C-11d2-988B-00A0C925F917}
static const GUID GUID_MainNode = { 0xe26d0049, 0x378c, 0x11d2, { 0x98, 0x8b, 0x0, 0xa0, 0xc9, 0x25, 0xf9, 0x17 } };

// {E26D0050-378C-11d2-988B-00A0C925F917}
static const GUID GUID_SettingsNode = { 0xe26d0050, 0x378c, 0x11d2, { 0x98, 0x8b, 0x0, 0xa0, 0xc9, 0x25, 0xf9, 0x17 } };

// {fe8e7e84-6f63-11d2-98a9-00a0c925f917}
// extern const GUID GUID_ResultNode = { 0xfe8e7e84 , 0x6f63 , 0x11d2 , { 0x98, 0xa9 , 0x0 , 0x0a0 , 0xc9 , 0x25 , 0xf9 , 0x17 } };

enum { MAIN_NODE = 1 , SETTINGS_NODE ,  RESULT_NODE , RSETTINGS_NODE };

class CBaseNode : public IDataObject
{
    ULONG m_cref;

	INT_PTR m_nNodeType;

public:
    CBaseNode( );

    virtual ~CBaseNode( ) { }

    STDMETHOD( QueryInterface )( REFIID , PVOID * );

    STDMETHOD_( ULONG , AddRef )(  );

    STDMETHOD_( ULONG , Release )( );

    // IDataObject

    STDMETHOD( GetData )( LPFORMATETC , LPSTGMEDIUM );

    STDMETHOD( GetDataHere )( LPFORMATETC , LPSTGMEDIUM );

    STDMETHOD( QueryGetData )( LPFORMATETC );

    STDMETHOD( GetCanonicalFormatEtc )( LPFORMATETC , LPFORMATETC );

    STDMETHOD( SetData )( LPFORMATETC , LPSTGMEDIUM , BOOL );

    STDMETHOD( EnumFormatEtc )( DWORD , LPENUMFORMATETC * );

    STDMETHOD( DAdvise )( LPFORMATETC , ULONG , LPADVISESINK , PULONG );

    STDMETHOD( DUnadvise )( DWORD );

    STDMETHOD( EnumDAdvise )( LPENUMSTATDATA * );

    // BaseNode methods are left to the derived object

	void SetNodeType( INT_PTR nNodeType )
	{
		m_nNodeType = nNodeType;
	}

	INT_PTR GetNodeType( void )
	{
		return m_nNodeType;
	}


    virtual BOOL AddMenuItems( LPCONTEXTMENUCALLBACK , PLONG ) { return FALSE; }

    virtual DWORD GetImageIdx( ){ return 0; }

    
    
                           
};

#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\rnodes.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include"stdafx.h"
#include"rnodes.h"
#include"resource.h"


//----------------------------------------------------------------------------------
CResultNode::CResultNode( )
{
    m_pszConnectionName = NULL;

    m_pszTransportTypeName = NULL;

    m_pszTypeName = NULL;

    m_pszComment = NULL;

    m_pCfgcomp = NULL;

	SetNodeType( RESULT_NODE );

    m_bEditMode = FALSE;

}
    
//CResultNode( CResultNode& x );
//----------------------------------------------------------------------------------    
CResultNode::~CResultNode( )
{
    ODS( L"CResultNode::dtor -- Deleting result node\n" );

    if( m_pszConnectionName != NULL )
    {
        delete[] m_pszConnectionName;
    }

    if( m_pszTransportTypeName != NULL )
    {
        delete[] m_pszTransportTypeName;
    }

    if( m_pszTypeName != NULL )
    {
        delete[] m_pszTypeName;
    }

    if( m_pszComment != NULL )
    {
        delete[] m_pszComment;
    }


}
//----------------------------------------------------------------------------------
LPTSTR CResultNode::GetConName( )
{
    return m_pszConnectionName;
}
//----------------------------------------------------------------------------------
LPTSTR CResultNode::GetTTName( )
{
    return m_pszTransportTypeName;
}
//----------------------------------------------------------------------------------
LPTSTR CResultNode::GetTypeName( )
{
    return m_pszTypeName;
}
//----------------------------------------------------------------------------------
LPTSTR CResultNode::GetComment( )
{
    return m_pszComment;
}
//----------------------------------------------------------------------------------
DWORD CResultNode::GetImageIdx( )
{
    return m_dwImageidx;
}

//----------------------------------------------------------------------------------
int CResultNode::SetConName( LPTSTR psz , int cwSz )
{
    if( IsBadReadPtr( psz , cwSz * sizeof( TCHAR ) ) )
    {
        return 0;
    }

    if( m_pszConnectionName != NULL )
    {
        delete[] m_pszConnectionName;

        m_pszConnectionName = NULL;
    }

    m_pszConnectionName = ( LPTSTR ) new TCHAR[ cwSz + 1];

    if( m_pszConnectionName == NULL )
    {
        return 0;
    }

    lstrcpy( m_pszConnectionName , psz );

    return cwSz;
}


//----------------------------------------------------------------------------------
int CResultNode::SetTTName( LPTSTR psz , int cwSz )
{    
    if( IsBadReadPtr( psz , cwSz * sizeof( TCHAR ) ) )
    {
        return 0;
    }

    m_pszTransportTypeName = ( LPTSTR ) new TCHAR[ cwSz + 1];

    if( m_pszTransportTypeName == NULL )
    {
        return 0;
    }

    lstrcpy( m_pszTransportTypeName , psz );

    return cwSz;
}

//----------------------------------------------------------------------------------
int CResultNode::SetTypeName( LPTSTR psz , int cwSz)
{
    if( IsBadReadPtr( psz , cwSz * sizeof( TCHAR ) ) )
    {
        return 0;
    }

    m_pszTypeName = ( LPTSTR ) new TCHAR[ cwSz + 1];

    if( m_pszTypeName == NULL )
    {
        return 0;
    }

    lstrcpy( m_pszTypeName , psz );

    return cwSz;
    
}

//----------------------------------------------------------------------------------
int CResultNode::SetComment( LPTSTR psz , int cwSz )
{
    if( IsBadReadPtr( psz , cwSz * sizeof( TCHAR ) ) )
    {
        return 0;
    }

    if( m_pszComment != NULL )
    {
        delete[] m_pszComment;

        m_pszComment = NULL;
    }

    m_pszComment = ( LPTSTR ) new TCHAR[ cwSz + 1];

    if( m_pszComment == NULL )
    {
        return 0;
    }

    lstrcpy( m_pszComment , psz );

    return cwSz;
 
}

//----------------------------------------------------------------------------------
int CResultNode::SetImageIdx( DWORD dwIdx )
{
    // Check for invalid dwIdx

    m_dwImageidx = dwIdx;

    return dwIdx;
}

//----------------------------------------------------------------------------------
BOOL CResultNode::EnableConnection( BOOL bSet )
{
    m_bEnableConnection = bSet;

    return TRUE;
}

//----------------------------------------------------------------------------------
int CResultNode::SetServer( ICfgComp *pCfgcomp )
{
    if( pCfgcomp == NULL )
    {
        return 0;
    }

    if( m_pCfgcomp != NULL )
    {
        m_pCfgcomp->Release( );

    }

    m_pCfgcomp = pCfgcomp;

    return m_pCfgcomp->AddRef( );
    
}

//----------------------------------------------------------------------------------
int CResultNode::GetServer( ICfgComp **ppCfgcomp )
{
    if( m_pCfgcomp != NULL )
    {
        *ppCfgcomp = m_pCfgcomp;

        return  ( ( ICfgComp * )*ppCfgcomp )->AddRef( );
    }

    return 0;
}

//----------------------------------------------------------------------------------
int CResultNode::FreeServer( )
{
    if( m_pCfgcomp != NULL )
    {
        return m_pCfgcomp->Release( );
    }

    return 0;
}

//----------------------------------------------------------------------------------
BOOL CResultNode::AddMenuItems( LPCONTEXTMENUCALLBACK pcmc , PLONG pl )
{
    HRESULT hr;

    TCHAR tchName[ 80 ];

    TCHAR tchStatus[ 256 ];

    CONTEXTMENUITEM cmi;

    if( GetConnectionState( ) )
    {
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABLECON , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABLECON_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;
    }
    else
    {        
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ENABLECON , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ENABLECON_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;
    }

    cmi.lCommandID = IDM_ENABLE_CONNECTION;

    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;

    cmi.fFlags = cmi.fSpecialFlags = 0;

    *pl |= CCM_INSERTIONALLOWED_TASK;

    hr = pcmc->AddItem( &cmi );

    if( SUCCEEDED( hr ) )
    {
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_RENAMECON , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_RENAMECON_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_RENAME_CONNECTION;

        hr = pcmc->AddItem( &cmi );
    }

    return ( SUCCEEDED( hr ) ? TRUE : FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tscc.rc
//
#define IDI_ICON_COMPUTER               16
#define IDS_PROJNAME                    100
#define IDR_COMPDATA                    101
#define IDS_NAMESTRING                  101
#define IDD_WELCOME                     101
#define IDS_WELCOMEHEADER               102
#define IDS_WELCOMESUBHEADER            103
#define IDS_WIZARDTITLE                 104
#define IDD_FINISH                      105
#define IDD_LAN                         106
#define IDD_AUTO_LOGON                  107
#define IDD_LICENSING                   108
#define IDD_INITIAL_PROGRAM             110
#define IDD_CONNECTION_TYPE             111
#define IDD_SECURITY                    112
#define IDD_TIMEOUT                     113
#define IDD_CONNECTION_PROP             114
#define IDD_WALLPAPER                   115
#define IDD_REMOTE_CONTROL              116
#define IDD_GENERAL                     129
#define IDD_LOGONSETTINGS               130
#define IDD_ENVIRONMENT                 131
#define IDD_TIMEOUTSETTING              132
#define IDD_PAGE_SHADOW                 137
#define IDD_TIMEOUTS_PS                 138
#define IDD_TSCC_CLIENT                 141
#define IDD_TSCC_PERMISSIONS            142
#define IDC_CHECK_WALLPAPER             201
#define IDB_TSCC_LOGO                   202
#define IDC_CHECK_CCPL_PS               202
#define IDC_COMBO_CON_WZ                203
#define IDB_TSCC_ICON                   204
#define IDC_RADIO_CNTS_WZ               204
#define IDC_RADIO_UDCCS_WZ              205
#define IDI_ICON_GLOBALGROUP            205
#define IDC_COMBO_ENCRYPT_LVL           206
#define IDI_ICON_LOCALGROUP             206
#define IDC_CHECK_ENCRYPT               207
#define IDI_ICON_USER                   207
#define IDC_LV_USRGRPS                  208
#define IDC_LV_PERMISSIONS              209
#define IDC_CHECK_REMOTECTRL_NOTIFYUSER 210
#define IDI_ICON_GENERAL                210
#define IDC_CHECK_LOGON_PROMPTPASSWD    211
#define IDC_CHECK_LAN_UNLIMITEDCON      212
#define IDC_EDIT_LAN_MAXCONS            213
#define IDC_COMBO_LAN_ADAPTERS          214
#define IDC_CHECK_INITPROG_INHERIT      215
#define IDI_ICON_GENERAL2               215
#define IDC_EDIT_INITPROG_CMDLINE       216
#define IDC_EDIT_INITPROG_WD            217
#define IDC_STATIC_GEN_TYPE             218
#define IDC_STATIC_GEN_TRANSPORT        219
#define IDC_EDIT_USRNAME_WZ             220
#define IDC_EDIT_DOMAIN_WZ              221
#define IDC_EDIT_PASSWD_WZ              222
#define IDC_STATIC_IMAGE_HOLDER         223
#define IDI_ICON_CON                    223
#define IDC_STATIC_NAMESTR              224
#define IDI_ICON_DISCON                 224
#define IDC_STATIC_CONNAME              225
#define IDD_RENAME                      225
#define IDC_STATIC_WELCOME              226
#define IDC_STATIC_FINISH               227
#define IDI_ICON_ABOUT                  227
#define IDC_STATIC_CURRENT_NAME         228
#define IDD_CITRIX_PAGE                 228
#define IDC_CHECKLIST                   229
#define IDD_TRANSPORT_PS                229
#define IDC_CUSTOM1                     230
#define IDD_NETWORK_FACE                231
#define IDD_ASYNC_FACE                  232
#define IDC_STATIC_DESCRIPTION          232
#define IDC_STATIC_DESCR_TITLE          233
#define IDC_STATIC_GEN_DESCRTITLE       234
#define IDC_STATIC_GEN_DESCR            235
#define IDC_STATIC_CONGRP               236
#define IDD_CACHED_SESSIONS             236
#define IDC_STATIC_CON                  237
#define IDD_YESNODIALOG                 237
#define IDC_STATIC_DISCON               238
#define IDD_DEFCONSEC                   238
#define IDC_STATIC_IDLE                 239
#define IDC_STATIC_USRNAME              240
#define IDC_STATIC_DOMAIN               241
#define IDD_DIALOG_PERSESSION           241
#define IDC_STATIC_PASSWD               242
#define IDB_BITMAP_GENLARGE             242
#define IDC_STATIC_CONPASSWD            243
#define IDB_BITMAP_GENSMALL             243
#define IDC_STATIC_CMDLINE              244
#define IDC_STATIC_WF                   245
#define IDC_STATIC_MAXINST              246
#define IDC_STATIC_ENCL                 247
#define IDC_STATIC_WD                   248
#define IDC_STATIC_LSUSR                249
#define IDC_STATIC_LSDOMAIN             250
#define IDC_STATIC_LSPWD                251
#define IDC_STATIC_LSCONPWD             252
#define IDC_STATIC_TIMCON               253
#define IDC_STATIC_TIMDISCON            254
#define IDC_STATIC_TIMIDLE              255
#define IDC_STATIC_TNMAX                256
#define IDC_STATIC_YNTEXTHLDR           257
#define IDC_RADIO_YES                   258
#define IDC_RADIO_NO                    259
#define IDC_STATIC_TEMPPERSESSION       260
#define IDC_STATIC_ADP_HDR              261
#define IDC_RADIO_AD_ENABLE             262
#define IDC_RADIO_ADP_DISABLE           263
#define IDC_TSMSTATIC_RA                265
#define IDS_RAM                         267
#define IDS_ASM                         268
#define IDC_LICENSING_MODE              270
#define IDC_LICENSING_DESCRIPTION       271
#define IDC_LICENSING_TO_REMOTE_ADMIN   272
#define IDC_LICENSING_FROM_REMOTE_ADMIN 273
#define IDD_EDIT_WINSTATION             300
#define IDD_ASYNC_WIZ                   300
#define IDL_WINSTATIONNAME              301
#define IDC_WINSTATIONNAME              302
#define IDL_TDNAME                      304
#define IDC_TDNAME                      305
#define IDL_WDNAME                      306
#define IDC_WDNAME                      307
#define IDL_WSCOMMENT                   308
#define IDC_WSCOMMENT                   309
#define IDC_ADVANCED_WINSTATION         312
#define IDC_CLIENT_SETTINGS             313
#define IDC_EXTENSION_BUTTON            314
#define IDL_ASYNC                       330
#define IDL_ASYNC_DEVICENAME            331
#define IDC_ASYNC_DEVICENAME            332
#define IDC_ASYNC_MODEMINSTALL          333
#define IDC_ASYNC_MODEMCONFIG           334
#define IDL_ASYNC_MODEMCALLBACK         335
#define IDL_ASYNC_MODEMCALLBACK1        336
#define IDC_ASYNC_MODEMCALLBACK         337
#define IDC_ASYNC_MODEMCALLBACK_INHERIT 338
#define IDL_ASYNC_MODEMCALLBACK_PHONENUMBER 339
#define IDC_ASYNC_MODEMCALLBACK_PHONENUMBER 340
#define IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT 341
#define IDL_ASYNC_CONNECT               342
#define IDC_ASYNC_CONNECT               343
#define IDL_ASYNC_BAUDRATE              344
#define IDC_ASYNC_BAUDRATE              345
#define IDC_ASYNC_DEFAULTS              346
#define IDC_ASYNC_ADVANCED              347
#define IDC_ASYNC_TEST                  348
#define IDD_ASYNC_ADVANCED              500
#define IDL_ASYNC_ADVANCED_FLOWCONTROL  501
#define IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE 502
#define IDC_ASYNC_ADVANCED_FLOWCONTROL_SOFTWARE 503
#define IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE 504
#define IDL_ASYNC_ADVANCED_DTRSTATE     505
#define IDL_ASYNC_ADVANCED_DTRALWAYS    506
#define IDC_ASYNC_ADVANCED_DTROFF       507
#define IDC_ASYNC_ADVANCED_DTRON        508
#define IDL_ASYNC_ADVANCED_RTSSTATE     509
#define IDL_ASYNC_ADVANCED_RTSALWAYS    510
#define IDC_ASYNC_ADVANCED_RTSOFF       511
#define IDC_ASYNC_ADVANCED_RTSON        512
#define IDL_ASYNC_ADVANCED_HARDWARE     513
#define IDC_ASYNC_ADVANCED_HWRX         514
#define IDL_ASYNC_ADVANCED_HWRX         515
#define IDL_ASYNC_ADVANCED_HWTX         516
#define IDC_ASYNC_ADVANCED_HWTX         517
#define IDL_ASYNC_ADVANCED_SOFTWARE     518
#define IDL_ASYNC_ADVANCED_XON          519
#define IDC_ASYNC_ADVANCED_XON          520
#define IDL_ASYNC_ADVANCED_XOFF         521
#define IDC_ASYNC_ADVANCED_XOFF         522
#define IDL_ASYNC_ADVANCED_BASE         523
#define IDC_ASYNC_ADVANCED_BASEDEC      524
#define IDC_ASYNC_ADVANCED_BASEHEX      525
#define IDL_ASYNC_ADVANCED_PARITY       526
#define IDC_ASYNC_ADVANCED_PARITY_NONE  527
#define IDC_ASYNC_ADVANCED_PARITY_EVEN  528
#define IDC_ASYNC_ADVANCED_PARITY_ODD   529
#define IDC_ASYNC_ADVANCED_PARITY_MARK  530
#define IDC_ASYNC_ADVANCED_PARITY_SPACE 531
#define IDL_ASYNC_ADVANCED_STOPBITS     532
#define IDC_ASYNC_ADVANCED_STOPBITS_1   533
#define IDC_ASYNC_ADVANCED_STOPBITS_2   534
#define IDL_ASYNC_ADVANCED_BYTESIZE     535
#define IDC_ASYNC_ADVANCED_BYTESIZE_7   536
#define IDC_ASYNC_ADVANCED_BYTESIZE_8   537
#define IDD_ASYNC_TEST                  620
#define IDC_ATDLG_DTR                   621
#define IDD_ADP_DIALOG                  621
#define IDC_ATDLG_RTS                   622
#define IDC_ATDLG_CTS                   623
#define IDC_ATDLG_DSR                   624
#define IDC_ATDLG_DCD                   625
#define IDC_ATDLG_RI                    626
#define IDL_ATDLG_DEVICE                627
#define IDL_ATDLG_BAUD                  628
#define IDC_ATDLG_EDIT                  629
#define IDC_ATDLG_MODEM_INIT            630
#define IDC_ATDLG_MODEM_LISTEN          631
#define IDC_ATDLG_MODEM_DIAL            632
#define IDL_ATDLG_PHONE_NUMBER          633
#define IDC_ATDLG_PHONE_NUMBER          634
#define IDI_ICON_BULLET                 635
#define IDC_STATIC_SINGLE_SESSION_HDR   637
#define IDC_RADIO_SINGLE_SESSION_ENABLE 638
#define IDC_COMBO1                      1001
#define IDC_COMBO_WIZ_CONTYPE           1001
#define IDC_COMBO_GENERAL_TRANSPORT     1001
#define IDC_COMBO_TRANSPORT_WZ          1001
#define IDC_EDIT_GENERAL_TRANSPORT      1001
#define IDC_COMBO_DEFSEC                1001
#define IDC_COLORDEPTH_OVERRIDE         1001
#define IDC_EDIT2                       1002
#define IDC_ADD_GRPUSR                  1002
#define IDC_EDIT_LOGON_USRNAME          1002
#define IDC_EDIT_GEN_COMMENT            1002
#define IDC_EDIT_ENVIRO_CMDLINE         1002
#define IDC_SPIN1                       1003
#define IDC_REMOVE_GRPUSR               1003
#define IDC_EDIT_LOGON_DOMAIN           1003
#define IDC_EDIT_GEN_MAXCONS            1003
#define IDC_EDIT_ENVIRO_WD              1003
#define IDC_SPIN_WZ                     1003
#define IDC_CHECK1                      1004
#define IDC_EDIT_LOGON_PASSWD           1004
#define IDC_CHECK_ICCP_WZ               1004
#define IDC_CHECK_COLORDEPTH_OVERRIDE   1004
#define IDC_RADIO1                      1005
#define IDC_COMBO_CON_PS                1005
#define IDC_RADIO_DISABLE_REMOTE_CONTROL 1005
#define IDC_COMBO_GEN_LANADAPTER        1005
#define IDC_RADIO_REMOTECTRL_NO         1005
#define IDC_COMBO_TIMEOUTS_CON_PS       1005
#define IDC_RADIO_ENABLE_REMOTE         1005
#define IDC_RADIO_PERSESSION_YES        1005
#define IDC_RADIO2                      1006
#define IDC_RADIO_ENABLE_REMOTECONTROL  1006
#define IDC_EDIT_LOGON_CONFIRMPASSWD    1006
#define IDC_RADIO_NOREMOTE              1006
#define IDC_RADIO_PERSESSION_NO         1006
#define IDC_CHECK2                      1007
#define IDC_COMBO_DISCON_PS             1007
#define IDC_COMBO_GEN_ENCRYPT           1007
#define IDC_CHECK_PROMPTPASSWD_WZ       1007
#define IDC_COMBO_TIMEOUTS_DISCON_PS    1007
#define IDC_EDIT1                       1008
#define IDC_COMBO_IDLE_PS               1008
#define IDC_COMBO_TIMEOUTS_IDLE_PS      1008
#define IDC_EDIT_WSNAME_WZ              1008
#define IDC_EDIT_GENERAL_NAME           1008
#define IDC_EDIT_NEWNAME                1008
#define IDC_EDIT_CACHEDSESSION          1008
#define IDC_EDIT3                       1009
#define IDC_EDIT_COMMENT_WZ             1009
#define IDC_EDIT4                       1010
#define IDC_RADIO_DISCON_PS             1010
#define IDC_EDIT_CONFIRM_WZ             1010
#define IDC_RADIO_TIMEOUTS_DISCON_PS    1010
#define IDC_RADIO3                      1011
#define IDC_RADIO_RESET_PS              1011
#define IDC_RADIO_INHERIT_REMOTE_CONTROL 1011
#define IDC_RADIO_TIMEOUTS_RESET_PS     1011
#define IDC_RADIO_REMOTE_INHERIT        1011
#define IDC_COMBO_DISCON_WZ             1012
#define IDC_CHECK_TIMEOUT_INHERIT       1013
#define IDC_COMBO_IDLE_WZ               1013
#define IDC_CHECK_LOGON_INHERIT         1013
#define IDC_CHECK_GEN_UNLIMITED         1013
#define IDC_CHECK_ENVIRO_INHERIT        1013
#define IDC_CHECK_INHERITTIMEOUT_PS     1013
#define IDC_RADIO4                      1014
#define IDC_CHECK_CONCLIENT_INHERIT     1014
#define IDC_RADIO_FAC_PS                1014
#define IDC_RADIO_REMOTECTRL_WATCH      1014
#define IDC_RADIO_TIMEOUTS_ANYCLIENT_PS 1014
#define IDC_RADIO_WATCH                 1014
#define IDC_RADIO5                      1015
#define IDC_CHECK_DCDM_PS               1015
#define IDC_RADIO_FPC_PS                1015
#define IDC_RADIO_REMOTECTRL_CONTROL    1015
#define IDC_RADIO_TIMEOUTS_PREVCLNT_PS  1015
#define IDC_RADIO_CONTROL               1015
#define IDC_CHECK_CCDL_PS               1016
#define IDC_CHECK_GEN_AUTHEN            1016
#define IDC_CHECK_ENVIRO_RUNONLYAPPS    1016
#define IDC_CHECK_TIMEOUTS_INHERITBKCON_PS 1016
#define IDC_CHECK3                      1017
#define IDC_CHECK_ENVIRO_DISABLEWALL    1017
#define IDC_CHECK_TIMEOUTS_INHERITRECON_PS 1017
#define IDC_CHECK_NOTIFY                1017
#define IDC_CHECK_DMCP_PS               1018
#define IDC_CHECK_DWCPM_PS              1019
#define IDC_CHECK_DCLPM_PS              1020
#define IDC_CHECK_DCCPM_PS              1021
#define IDC_CHECK_DCCM_PS               1022
#define IDC_CHECK_DCAM_PS               1023
#define IDC_SPINCTR_GEN                 1024
#define IDP_ERROR_GET_OVERLAPPED_RESULT_WRITE 1052
#define IDP_ERROR_WRITE_FILE            1053
#define IDS_ERROR_NO_LICENSING_MODE_LIST 1054
#define IDS_ERROR_NO_LICENSING_MODE     1055
#define IDS_ERROR_NO_MEMORY             1056
#define IDS_ERROR_NO_LICENSING_MODE_INFO 1057
#define IDC_RADIO_MAXPROP               18164
#define IDC_STATIC_ENCGRP               18165
#define IDS_ERROR_TITLE                 18636
#define IDS_WARN_TITLE                  18637
#define IDS_ERROR_NUMERICENTRY          18639
#define IDS_NOTIMEOUT                   18640
#define IDS_DIGIT_DOT_DIGIT_TU          18644
#define IDS_DIGIT_TU                    18645
#define IDS_DAYS                        18647
#define IDS_DAY                         18648
#define IDS_HOURS                       18649
#define IDS_HOUR                        18650
#define IDS_MINUTES                     18651
#define IDS_MINUTE                      18652
#define IDS_D                           18653
#define IDS_H                           18654
#define IDS_M                           18655
#define IDS_HR                          18656
#define IDS_HRS                         18657
#define IDS_MIN                         18658
#define IDS_ERROR_TOOMANYDIGITS         18659
#define IDS_ERROR_PARSEINVALID          18660
#define IDS_ERROR_MAXVALEXCEEDED        18661
#define IDS_VERDANABLDFONTSIZE          18662
#define IDS_VERDANABLDFONTNAME          18663
#define IDS_PROVIDER                    18664
#define IDS_DESCRIPTION                 18665
#define IDS_VERSION                     18666
#define IDS_HELPFILE                    18667
#define IDS_COLCONNECT                  18668
#define IDS_COLTRANSPORT                18669
#define IDS_COLTYPE                     18670
#define IDS_COLCOMMENT                  18671
#define IDS_FOLDERCON                   18672
#define IDS_CTXM_NAME                   18673
#define IDS_CTXM_STATUS                 18674
#define IDS_COMBO_CONNECTION            18675
#define IDS_COMBO_DISCONNECTION         18676
#define IDS_COMBO_IDLECONNECTION        18677
#define IDS_PERMS_SPECIAL_QUERY         18678
#define IDS_PERMS_SPECIAL_SET           18679
#define IDS_PERMS_SPECIAL_RESET         18680
#define IDS_PERMS_SPECIAL_SHADOW        18681
#define IDS_PERMS_SPECIAL_LOGON         18682
#define IDS_PERMS_SPECIAL_LOGOFF        18683
#define IDS_PERMS_SPECIAL_MSG           18684
#define IDS_PERMS_SPECIAL_CONNECT       18685
#define IDS_PERMS_SPECIAL_DISCONNECT    18686
#define IDS_PERMS_SPECIAL_DELETE        18687
#define IDS_PERMS_RESOURCE_ADMIN        18688
#define IDS_PERMS_RESOURCE_USER         18689
#define IDS_PERMS_RESOURCE_GUEST        18690
#define IDS_ERR_CONREADFAIL             18691
#define IDS_ERR_CONMAX                  18692
#define IDS_ERR_UNIQUECON               18693
#define IDS_ERR_PASSWDLEN               18694
#define IDS_ERR_PASSWDCONFIRM           18695
#define IDS_SUBHEADER_TIMEOUT           18696
#define IDS_HEADER_LOGONSETTINGS        18697
#define IDS_SUBHEADER_LOGONSETTINGS     18698
#define IDS_HDR_CONTYPE                 18699
#define IDS_SUBHDR_CONTYPE              18700
#define IDS_SUBHDR_SECURITY             18701
#define IDS_HDR_INITPRG                 18702
#define IDS_SUBHDR_INITPRG              18703
#define IDS_HDR_REMOTE                  18704
#define IDS_SUBHDR_REMOTE               18705
#define IDS_HDR_WALLPR                  18706
#define IDS_SUBHDR_WALLPR               18707
#define IDS_HDR_TRANSTYPE               18708
#define IDS_SUBHDR_TRANSTYPE            18709
#define IDS_HDR_LAN                     18710
#define IDS_SUBHDR_LAN                  18711
#define IDS_HDR_ASYNC                   18712
#define IDS_SUBHDR_ASYNC                18713
#define IDS_HDR_TIMEOUT                 18714
#define IDS_SUBHDR_TIMEOUT              18715
#define IDS_INVALID_DEVICE              18716
#define IDS_MAINFOLDERNAME              18717
#define IDS_DELETETEXT                  18718
#define IDS_DELTITLE                    18719
#define IDS_SECURPAGENAME               18720
#define IDS_ERR_PASSWD                  18721
#define IDS_ERR_PASSCONFIRM             18722
#define IDS_ERR_CONNAME                 18723
#define IDS_ERR_CONEXIST                18724
#define IDS_ERR_WINNAME                 18725
#define IDS_HDR_SECURITY                18726
#define IDS_DISABLECONNECTION           18727
#define IDS_DISABLELIVECONNECTION       18728
#define IDS_DELETELIVECON               18729
#define IDS_ERR_INEDITMODE              18730
#define IDS_INVALID_CHARS               18731
#define IDS_ERR_INVALIDCHARS            18732
#define IDS_ERR_LANRECFG                18733
#define IDS_ERR_LANCHANGE               18734
#define IDS_TSCCSNAPHELP                18735
#define IDS_TSCCHELPTOPIC               18736
#define IDS_ERR_DELFAIL                 18737
#define IDS_ERROR_NODEVICES             18738
#define IDP_ERROR_GET_OVERLAPPED_RESULT_READ 18739
#define IDP_ERROR_MODEM_SET_INFO        18740
#define IDP_ERROR_MODEM_GET_INIT        18741
#define IDP_ERROR_MODEM_GET_DIAL        18742
#define IDP_ERROR_MODEM_GET_LISTEN      18743
#define IDP_ERROR_GET_SECURITY_WINSTATION 18744
#define IDP_ERROR_PERMISSIONS_EDITOR_FAILED 18745
#define IDP_ERROR_SET_SECURITY_WINSTATION 18746
#define IDP_ERROR_INTERNAL_SETARGV      18747
#define IDP_ERROR_INTERNAL_PARSECOMMANDLINE 18748
#define IDP_ERROR_OEMTDINIT_CONFIGDLLENUMERATIONFAILURE 18749
#define IDP_ERROR_DISABLE               18750
#define IDP_ERROR_CANT_OPEN_DEVICE      18751
#define IDP_ERROR_CANT_INITIALIZE_DEVICE 18752
#define IDP_ERROR_READ_FILE             18753
#define IDP_ERROR_CANT_INITIALIZE_INPUT_THREAD 18754
#define IDP_ERROR_WAIT_FOR_MULTIPLE_OBJECTS 18755
#define IDP_ERROR_GET_COMM_MODEM_STATUS 18756
#define IDP_ERROR_WAIT_COMM_EVENT       18757
#define IDP_ERROR_CANT_CREATE_INPUT_THREAD 18758
#define IDC_RADIO_LGINFO_WZ             18759
#define IDS_WRN_UNIQUECON               18760
#define IDC_RADIO_MAXCON                18761
#define IDS_CACHEDSESSIONS              18761
#define IDC_CONNECTION_NAME             18762
#define IDS_DELTEMPONEXIT               18762
#define IDC_RADIO_LOGON                 18763
#define IDS_USETEMPDIR                  18763
#define IDS_DEFCONSEC                   18764
#define IDS_LICENSING                   18765
#define IDS_ERR_CACHEDVALUE             18766
#define IDS_SETTINGS_COLUMN1            18767
#define IDS_ATTRIB_COLUMN2              18768
#define IDS_DISABLECON                  18769
#define IDS_DISABLECON_STATUS           18770
#define IDS_ENABLECON                   18771
#define IDS_ENABLECON_STATUS            18772
#define IDS_RENAMECON                   18773
#define IDS_RENAMECON_STATUS            18774
#define IDS_REMOVEONEXIT                18775
#define IDS_USEPERSESSION               18776
#define IDS_RAA                         18777
#define IDS_AS                          18778
#define IDS_AA                          18779
#define IDS_ERROR_INVALID_SD            18780
#define IDS_YES                         18781
#define IDS_NO                          18782
#define IDS_ENABLED                     18783
#define IDS_DISABLED                    18784
#define IDS_YESMENU                     18785
#define IDS_NOMENU                      18786
#define IDS_ENABLEMENU                  18787
#define IDS_DISABLEMENU                 18788
#define IDS_CACHEDSESSION_STATUS        18789
#define IDS_STANDARAD_PROPERTIES_STATUS 18790
#define IDS_NOTDELTEMP_STATUS           18791
#define IDS_DELTEMP_STATUS              18792
#define IDS_PROPERTIES_MENU             18793
#define IDS_NOTUSEPERSESSION_STATUS     18794
#define IDS_USEPERSESSION_STATUS        18795
#define IDS_SETTINGSFOLDER              18798
#define IDS_RENAME_WRN_SINGLE           18799
#define IDS_RENAME_WRN_PL               18800
#define IDC_MODEM_PROP_WIZ              18801
#define IDC_MODEM_PROP_PROP             18802
#define IDP_ERROR_MODEM_PROPERTIES_NOT_AVAILABLE 18803
#define IDS_WRN_TSTCON                  18804
#define IDS_DD_WINTITLE                 18805
#define IDS_UPS_WINTITLE                18806
#define IDP_INVALID_BAUD                18807
#define IDS_REBOOT_REQD                 18808
#define IDS_LIC_ERRTITLE                18812
#define IDS_SETTINGSHELP                18813
#define IDS_TSCACCESSDENIED             18814
#define IDS_TSCERRGENERAL               18815
#define IDS_TSCERRTITLE                 18816
#define IDS_SSERROR                     18817
#define IDS_PROPCHANGE_WRN              18818
#define IDS_PROPCHANGE_WRN_2            18819
#define IDS_TERMSERPROP                 18820
#define IDS_REPORTERROR                 18821
#define IDS_ERR_INVALIDFIRSTCHAR        18822
#define IDS_CHANGE_ASYNC                18823
#define IDS_CHANGE_MODEM                18824
#define IDS_ASYNC_HELPFILE              18825
#define IDS_ACTIVEDESK_MENU             18827
#define IDS_ACTIVEDESK_PROP_STATUS      18828
#define IDS_DISABLE_ADP_STATUS          18829
#define IDS_ENABLE_ADP_STATUS           18830
#define IDS_ADS_ATTR                    18831
#define IDS_NONE                        18834
#define IDS_DISABNETWORK                18835
#define IDS_INVALNETWORK                18836
#define HID_ASYNCTEST                   28324
#define HID_ASYNCADVANCE                28325
#define IDS_USERPERM_W2K                18837
#define IDS_USERPERM_NT4                18838
#define IDS_USERPERM                    18839
#define IDC_RADIO_WIN2KPERM             18840
#define IDC_RADIO_TS4PERM               18841
#define IDC_LTEXT_W2KUSERS              18842
#define IDD_PROPPAGE_TERMINAL_SERVER_PERM 18843
#define IDC_USERPERM_ICON               18844
#define IDI_ICON_WARNING                18845
#define IDS_REMOTEADMIN_ONLY            18846
#define IDC_STATIC_NA                   18847
#define IDS_HARDWARE		            18848
#define IDS_ERR_TERMSRVMODE             18849

//
#define IDD_CUSTOM_SECURITY             18853
#define IDC_GP_LINK                     18854

#define IDS_SINGLE_SESSION              18855
#define IDS_DISABLE_SINGLESESSION_STATUS 18856
#define IDS_ENABLE_SINGLESESSION_STATUS 18857
#define IDD_SINGLE_SESSION              18858

#define IDS_COLORDEPTH_24		18859
#define IDS_COLORDEPTH_16		18860
#define IDS_COLORDEPTH_15		18861
#define IDS_COLORDEPTH_8		18862

#define ID_HELP                         0xE146
#define IDC_STATIC_LEVELOFCTRL          -2
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        636
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         639
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif

//
// MUI localized strings for
// start menu, etc. DO NOT CHANGE THESE VALUES
// without updating tsoc.inx
//
#define IDS_TSCC_STARTMENU_NAME                10000
#define IDS_TSCC_STARTMENU_TIP                 10001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\dataobj.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include "tscc.h"
#include "dataobj.h"
#include "resource.h"
#include "rnodes.h"

extern const GUID GUID_ResultNode;

static UINT s_cfInternal;// = RegisterClipboardFormat( TEXT( "TSCC" ) );   

static UINT s_cfDisplayName;// = RegisterClipboardFormat( CCF_DISPLAY_NAME );

static UINT s_cfNodeType;// = RegisterClipboardFormat( CCF_NODETYPE );

static UINT s_cfSnapinClsid;// = RegisterClipboardFormat( CCF_SNAPIN_CLASSID );

static UINT s_cfSZNodeType;// = RegisterClipboardFormat( CCF_SZNODETYPE );

static UINT s_cfSZWinstaName;


//--------------------------------------------------------------------------
// ctor
//--------------------------------------------------------------------------
CBaseNode::CBaseNode( )
{
    // The ndmgr gets the dataobj via IComponent and then calls release
    // so dataobj should have an implicit addref

    m_cref = 1;

    if( s_cfInternal == 0 )
    {
        s_cfInternal = RegisterClipboardFormat( TEXT( "TSCC" ) );   
    }

    if( s_cfSZWinstaName == 0 )
    {
        s_cfSZWinstaName = RegisterClipboardFormat( TEXT( "TSCC_WINSTANAME" ) );
    }

    if( s_cfDisplayName == 0 )
    {
        s_cfDisplayName = RegisterClipboardFormat( CCF_DISPLAY_NAME );
    }

    if( s_cfNodeType == 0 )
    {
        s_cfNodeType = RegisterClipboardFormat( CCF_NODETYPE );
    }

    if( s_cfSnapinClsid == 0 )
    {
        s_cfSnapinClsid = RegisterClipboardFormat( CCF_SNAPIN_CLASSID );
    }

    if( s_cfSZNodeType == 0 )
    {
        s_cfSZNodeType = RegisterClipboardFormat( CCF_SZNODETYPE );
    }

	m_nNodeType = 0;
	
}

//--------------------------------------------------------------------------
// Standard QI behavior
//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::QueryInterface( REFIID riid , PVOID *ppv )
{
    if( riid == IID_IUnknown )
    {
        *ppv = ( LPUNKNOWN )this;
    }
    else if( riid == IID_IDataObject )
    {
        *ppv = ( LPDATAOBJECT )this;
    }
    else
    {
        *ppv = NULL;

        return E_NOINTERFACE;
    }

    AddRef( );

    return S_OK;
}

//--------------------------------------------------------------------------
// Standard addref
//--------------------------------------------------------------------------
STDMETHODIMP_( ULONG )CBaseNode::AddRef(  )
{
    return InterlockedIncrement( ( LPLONG )&m_cref );
}

//--------------------------------------------------------------------------
// Same as addref no need for cs
//--------------------------------------------------------------------------
STDMETHODIMP_( ULONG )CBaseNode::Release( )
{
    if( InterlockedDecrement( ( LPLONG )&m_cref ) == 0 )
    {
         ODS( L"CBaseNode -- Releasing Dataobj\n" );

        delete this;

        return 0;
    }

    return m_cref;
}

//--------------------------------------------------------------------------
// Trust me ndmgr will call this with a fury
//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::GetDataHere( LPFORMATETC pF , LPSTGMEDIUM pMedium)
{
    HRESULT hr = DV_E_FORMATETC;
        
    const CLIPFORMAT cf = pF->cfFormat;
  
    IStream *pStream = NULL;
  
    pMedium->pUnkForRelease = NULL;
    

    hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );

    if( SUCCEEDED( hr ) ) 
    {
        if( cf == s_cfDisplayName )
        {
            TCHAR szDispname[ 128 ]; // = TEXT("Terminal Server Connection Configuration" );

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NAMESTRING , szDispname , SIZE_OF_BUFFER( szDispname ) ) );

            // Include null terminator 

            hr = pStream->Write( szDispname , SIZE_OF_BUFFER( szDispname )/* + sizeof( TCHAR )*/ , NULL );
        }
        else if( cf == s_cfInternal )
        {
            // The nodemgr will use this copy and pass it back to us in
            // functions such as ::Notify

            ODS( L"GetDataHere -- s_cfInternal used\n" );

            hr = pStream->Write( this , sizeof( CBaseNode ) , NULL );
        }
        else if( cf == s_cfSZWinstaName )
        {
            CResultNode *pNode = dynamic_cast< CResultNode *>( this );

            hr = E_FAIL; // generic failure

            // if we're talking about a connection base node get the winstation name

            ODS( L"GetDataHere -- current winstaname\n" );

            if( pNode != NULL )
            {
                LPTSTR szConName = pNode->GetConName( );

                hr = pStream->Write( szConName , lstrlen( szConName ) * sizeof( TCHAR ) + sizeof( TCHAR ) , NULL  );
            }
        }            
        else if( cf == s_cfNodeType )
        {
            const GUID *pGuid = NULL;

			if( GetNodeType( ) == MAIN_NODE )
			{
			    ODS( L"GetDataHere -- NodeType is MAIN_NODE\n" );

				pGuid = &GUID_MainNode;
			}
            else if( GetNodeType( ) == SETTINGS_NODE )
            {
                ODS( L"GetDataHere -- NodeType is SETTINGS_NODE\n" );

                pGuid = &GUID_SettingsNode;
            }
			else if( GetNodeType( ) == RESULT_NODE )
			{
				ODS( L"GetDataHere -- NodeType is RESULT_NODE\n" );

				pGuid = &GUID_ResultNode;
			}
			else
			{
				ODS( L"GetDataHere -- NodeType is userdefined\n ");

				pGuid = &GUID_ResultNode;
			}

            hr = pStream->Write( ( PVOID )pGuid , sizeof( GUID ) , NULL );
        }
		else if( cf == s_cfSZNodeType )
        {
            TCHAR szGUID[ 40 ];

			if( GetNodeType( ) == MAIN_NODE )
			{
				StringFromGUID2( GUID_MainNode , szGUID , SIZE_OF_BUFFER( szGUID ) );
			}
            else if( GetNodeType( ) == SETTINGS_NODE )
            {
                StringFromGUID2( GUID_SettingsNode , szGUID , SIZE_OF_BUFFER( szGUID ) );
            }                
			else if( GetNodeType( ) == RESULT_NODE )
			{
				StringFromGUID2( GUID_ResultNode , szGUID , SIZE_OF_BUFFER( szGUID ) );
			}
			else
			{
				StringFromGUID2( GUID_ResultNode , szGUID , SIZE_OF_BUFFER( szGUID ) );
			}

            // write nodetype in String format -- ok

            hr = pStream->Write( szGUID , sizeof( szGUID ) , NULL );
        }
        else if( cf == s_cfSnapinClsid )
        {
            // write out snapin's clsid

            hr = pStream->Write( &CLSID_Compdata , sizeof( CLSID ) , NULL );
        }

        pStream->Release( );

    } // CreateStreamOnHGlobal
     
    return hr;
   
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::GetData( LPFORMATETC , LPSTGMEDIUM )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::QueryGetData( LPFORMATETC )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::GetCanonicalFormatEtc( LPFORMATETC , LPFORMATETC )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::SetData( LPFORMATETC , LPSTGMEDIUM , BOOL )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::EnumFormatEtc( DWORD , LPENUMFORMATETC * )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::DAdvise( LPFORMATETC , ULONG , LPADVISESINK , PULONG )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::DUnadvise( DWORD )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::EnumDAdvise( LPENUMSTATDATA * )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\stdafx.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\compdata.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// Compdata.h : Declaration of the CCompdata

#ifndef __COMPDATA_H_
#define __COMPDATA_H_

#include "resource.h"       // main symbols
#include <mmc.h>
#include "tarray.h"
#include "twiz.h"
#include "rnodes.h"
#include "snodes.h"

//#include "cfgbkend.h"

#define IDM_CREATECON 101

#define MS_DIALOG_COUNT 8

#define FIN_PAGE 7

#define LAN_PAGE 5

#define ASYNC_PAGE 6


//enum { DELETED_DIRS_ONEXIT , PERSESSION_TEMPDIR , DEF_CONSECURITY , LICENSING , MAX_SETTINGS };

/////////////////////////////////////////////////////////////////////////////
// CCompdata
class ATL_NO_VTABLE CCompdata : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCompdata, &CLSID_Compdata>,
    public IExtendContextMenu,
    public ISnapinAbout,
    public ISnapinHelp,
	public IComponentData
{

public:
	
	
DECLARE_REGISTRY_RESOURCEID( IDR_COMPDATA )

DECLARE_NOT_AGGREGATABLE( CCompdata )

BEGIN_COM_MAP( CCompdata )

	COM_INTERFACE_ENTRY( IComponentData )

    COM_INTERFACE_ENTRY( ISnapinAbout )

    COM_INTERFACE_ENTRY( IExtendContextMenu )

    COM_INTERFACE_ENTRY( ISnapinHelp )

END_COM_MAP()

// ICompdata
public:
    
    CCompdata();

    STDMETHOD( CompareObjects )( LPDATAOBJECT , LPDATAOBJECT );

	STDMETHOD( GetDisplayInfo )( LPSCOPEDATAITEM );

	STDMETHOD( QueryDataObject )( MMC_COOKIE , DATA_OBJECT_TYPES , LPDATAOBJECT * );

	STDMETHOD( Notify )( LPDATAOBJECT , MMC_NOTIFY_TYPE , LPARAM , LPARAM );

	STDMETHOD( CreateComponent )( LPCOMPONENT * );

	STDMETHOD( Initialize )( LPUNKNOWN );

    STDMETHOD( Destroy )();

    //IExtendContextMenu

    STDMETHOD( AddMenuItems )( LPDATAOBJECT , LPCONTEXTMENUCALLBACK , PLONG );

    STDMETHOD( Command )( LONG , LPDATAOBJECT );

    // ISnapinAbout
    
    STDMETHOD( GetSnapinDescription )( LPOLESTR * );

    STDMETHOD( GetProvider )( LPOLESTR * );

    STDMETHOD( GetSnapinVersion )( LPOLESTR *  );

    STDMETHOD( GetSnapinImage )( HICON * );

    STDMETHOD( GetStaticFolderImage )( HBITMAP * , HBITMAP *, HBITMAP *, COLORREF * );

    // ISnapinHelp

    STDMETHOD( GetHelpTopic )( LPOLESTR * );


    //IComponentdata helper methods

    BOOL ExpandScopeTree( LPDATAOBJECT , BOOL , HSCOPEITEM );

    BOOL InitDialogObjects( );

    BOOL BuildWizardPath( );

    BOOL FreeDialogObjects( );

    BOOL IsConnectionFolder( LPDATAOBJECT );

    BOOL IsSettingsFolder( LPDATAOBJECT );

    HRESULT BuildResultNodes( );

    //    BOOL GetResultNode( int , CResultNode** );

    CResultNode * GetResultNode( int );

    HRESULT InsertFolderItems( LPRESULTDATA );

    int GetServer( ICfgComp ** );

    BOOL OnDeleteItem( LPDATAOBJECT );

    HRESULT UpdateAllResultNodes( );
    
    HRESULT InsertSettingItems( LPRESULTDATA );

    HRESULT BuildSettingsNodes( );

    BOOL GetMaxTextLengthSetting( LPTSTR , PINT );

    BOOL GetMaxTextLengthAttribute( LPTSTR , PINT );
    
private:

    LPCONSOLE m_pConsole;

    LPCONSOLENAMESPACE m_pConsoleNameSpace;

    //LPDATAOBJECT m_pMainRoot;

	CBaseNode *m_pMainRoot[ 2 ];

    ICfgComp *m_pCfgcomp;



public:

	TCHAR m_tchMainFolderName[ 80 ];

    TCHAR m_tchSettingsFolderName[ 80 ];

    CDialogWizBase *m_pDlg[ MS_DIALOG_COUNT ];

    CArrayT< HPROPSHEETPAGE > m_hPages;

    CArrayT< CResultNode * > m_rnNodes;

    CArrayT< CSettingNode * > m_rgsNodes;//[ MAX_SETTINGS ];
   
};

#endif //__COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\rnodes.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _RNODES_H
#define _RNODES_H

#include "dataobj.h"

#include "cfgbkend.h"

/*
#define IDM_ENABLE_CONNECTION 102

#define IDM_RENAME_CONNECTION 103
*/

class CResultNode : public CBaseNode
{
    DWORD m_dwImageidx;

    BOOL m_bEnableConnection;
    
    LPTSTR m_pszConnectionName;
    
    LPTSTR m_pszTransportTypeName;

    LPTSTR m_pszTypeName;

    LPTSTR m_pszComment;

    ICfgComp *m_pCfgcomp;
   

public:

    CResultNode( );
    
    CResultNode( CResultNode& x );
    
    ~CResultNode( );

    LPTSTR GetConName( );

    LPTSTR GetTTName( );

    LPTSTR GetTypeName( );

    LPTSTR GetComment( );

    DWORD GetImageIdx( );

    int SetConName( LPTSTR , int );

    int SetTTName( LPTSTR , int );

    int SetTypeName( LPTSTR , int );

    int SetComment( LPTSTR , int );

    int SetImageIdx( DWORD );

    BOOL EnableConnection( BOOL );

    BOOL GetConnectionState( ) const
    {
        return m_bEnableConnection;
    }

    int SetServer( ICfgComp * );

    int GetServer( ICfgComp ** );

    int FreeServer( );

    BOOL m_bEditMode;

    // additional routines 

    BOOL AddMenuItems( LPCONTEXTMENUCALLBACK , PLONG );


};


#endif //_RNODES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\sdlgs.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _SDLGS_H
#define _SDLGS_H

// INT_PTR CALLBACK CachedSessionsDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp );

INT_PTR CALLBACK UsePerSessionTempDirsDlgProc( HWND  , UINT , WPARAM , LPARAM );

INT_PTR CALLBACK DeleteTempDirsDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp );

// INT_PTR CALLBACK DefConSecurityDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp );

INT_PTR CALLBACK LicensingDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp );

INT_PTR CALLBACK ConfigActiveDesktop( HWND hDlg , UINT msg, WPARAM wp , LPARAM lp );

INT_PTR CALLBACK UserPermCompat( HWND hDlg , UINT msg, WPARAM wp , LPARAM lp );

INT_PTR CALLBACK ConfigSingleSession(HWND hDlg , UINT msg, WPARAM wp , LPARAM lp );

#endif // _SDLGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\snodes.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _SNODES_H
#define _SNODES_H

#include "dataobj.h"

#include "resource.h"

//
// WARNING -
//   Following enum, VALIDOBJECTONSERVER, VALIDOBJECTONADS, and RGRESID 
//   has one to one correspondence, if you add/remove/change order of item, 
//   you must also update the other arrays.
//

//
// Object ID for the item display on the right panel (under server settings)
//
#define CUSTOM_EXTENSION 6

enum { DELETED_DIRS_ONEXIT,     // delete temp. folder on exit
       PERSESSION_TEMPDIR,      // use temporary folder per session
       LICENSING,               // licensing mode
       ACTIVE_DESK,             // active desktop
       USERSECURITY,            // FULL or relax security 
       SINGLE_SESSION};         // single session per user.

//
// Valid item to be display on right panel 
// when running in server.
//
const BOOL VALIDOBJECTONSERVER[] = { 
                                        TRUE, 
                                        TRUE, 
                                        FALSE,  // licensing
                                        TRUE, 
                                        FALSE, 
                                        FALSE };

//
// Valid item to be display on right panel 
// when running in advance server.
//
const BOOL VALIDOBJECTONADS[] = { 
                                    TRUE, 
                                    TRUE, 
                                    TRUE, 
                                    TRUE, 
                                    TRUE, 
                                    TRUE };


//
// Resource ID for the item
//
const INT RGRESID [] = {
                         IDS_DELTEMPONEXIT, 
                         IDS_USETEMPDIR,
                         IDS_LICENSING,
                         IDS_ADS_ATTR,
                         IDS_USERPERM,
                         IDS_SINGLE_SESSION };

class CSettingNode : public CBaseNode
{
    LPTSTR m_szAttributeName;
    
    LPTSTR m_szAttributeValue;

    INT m_nGenericValue;

    INT m_objectid;

	HRESULT m_hrStatus;

public:

    CSettingNode( );

    virtual ~CSettingNode( );

    HRESULT SetAttributeValue( DWORD , PDWORD );

    BOOL SetAttributeName( LPTSTR );

    LPTSTR GetAttributeName( ){ return m_szAttributeName; }

    LPTSTR GetAttributeValue( );

    LPTSTR GetCachedValue( ){ return m_szAttributeValue; }

    DWORD GetImageIdx( );

    void SetObjectId( INT );

    INT GetObjectId( ) { return m_objectid; }

    BOOL AddMenuItems( LPCONTEXTMENUCALLBACK , PLONG );

    BOOL SetInterface( LPUNKNOWN );

    BOOL xx_SetValue( INT );

    INT xx_GetValue( ){ return m_nGenericValue; }

	HRESULT GetNodeStatus( ) const { return m_hrStatus; }

    LPUNKNOWN GetInterface( ) { return m_pSettings; }

private:

    LPUNKNOWN m_pSettings;
    
};


#endif //_SNODES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\tarray.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include"tarray.h"

//------------------------------------------------------------------------
template< class T > CArrayT< T >::CArrayT( )
{
    m_pT = NULL;

    m_nMaxSize = 0;

    m_idx = 0;
}

//------------------------------------------------------------------------
// destroy the list
template< class T > CArrayT< T >::~CArrayT( )
{
    if( m_pT != NULL )
    {
        delete[] m_pT;
    }
}

//------------------------------------------------------------------------
// increases array size,  returns zero if the operation failed
template< class T > int CArrayT< T >::GrowBy( int iSize )
{
    if( iSize == 0 )
    {
        //
        //Grow by # number of items
        //
        iSize = 4;

    }

    if( m_pT == NULL )
    {
        m_pT = ( T * )new T[ iSize ];

        if( m_pT == NULL )
        {
            return 0;
        }

        m_nMaxSize = iSize;

        m_idx = 0;
    }
    else
    {
        T *pT;

        m_nMaxSize += iSize;

        pT = ( T * )new T[ m_nMaxSize ];

        if( pT == NULL )
        {
            return 0;
        }

        ZeroMemory( ( PVOID )pT , sizeof( T ) * m_nMaxSize );

        CopyMemory( pT , m_pT , sizeof( T ) * ( m_idx ) );

        if( m_pT != NULL )
        {
            delete[] m_pT;
        }

        m_pT = pT;
    }
    

    return m_nMaxSize;
}

//------------------------------------------------------------------------
// Simply put, increase the array size if empty, and place item at the
// end of the list
template< class T > int CArrayT< T >::Insert( T tItem )
{
    if( m_pT == NULL || ( m_idx ) >= m_nMaxSize )
    {
        if( GrowBy( 0 ) == 0 )
        {
            return 0;
        }
    }


    m_pT[ m_idx ] = tItem;

    m_idx++;

    return m_idx;

}    

//------------------------------------------------------------------------
// exposes the array for direct reference
template< class T > T* CArrayT< T >::ExposeArray( )
{
    return &m_pT[0];
}
    
//------------------------------------------------------------------------
// Returns the number of valid entries in the array
template< class T > int CArrayT< T >::GetSize( ) const
{
    return ( m_idx );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\snodes.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include"stdafx.h"
#include"snodes.h"
#include"resource.h"

#define ERROR_USERDEFINED_LICENSE_VIOLATION ( ( DWORD )0xC000026AL )

extern void xxxErrMessage( HWND hwnd , INT_PTR nResMessageId , INT_PTR nResTitleId , UINT nFlags );

extern void TscAccessDeniedMsg( HWND hwnd );

extern void TscGeneralErrMsg( HWND hwnd );

extern void ReportStatusError( HWND hwnd , DWORD dwStatus );

void SnodeErrorHandler( HWND hParent , INT nObjectId , DWORD dwStatus );

//----------------------------------------------------------
CSettingNode::CSettingNode( )
{
    m_szAttributeName = NULL;

    m_szAttributeValue = NULL;

    SetNodeType( RSETTINGS_NODE );

    m_objectid = -1;

    m_pSettings = NULL;

    m_hrStatus = S_OK;
}

//----------------------------------------------------------
void CSettingNode::SetObjectId( INT id )
{
    m_objectid = id;
}

//----------------------------------------------------------
HRESULT CSettingNode::SetAttributeValue( DWORD nVal , PDWORD pdwStatus )
{
    HRESULT hr = S_OK;

    ISettingsComp *pSettings = NULL;

    INT nObjectId = GetObjectId( );

    if( nObjectId < CUSTOM_EXTENSION )
    {
        pSettings = reinterpret_cast< ISettingsComp *>(  m_pSettings );

        if( pSettings == NULL  )
        {
            ODS( L"CSettingNode::SetAttributeValue downcasting failure\n" );

            return E_FAIL;
        }
    }


    if( nObjectId == LICENSING )
    {        
        DWORD dwNewStatus;

        hr = pSettings->SetLicensingMode( nVal , pdwStatus, &dwNewStatus );

        if( SUCCEEDED( hr ) )
        {
            xx_SetValue( nVal );
        }
        else
        {
            if ((NULL != pdwStatus) && (ERROR_SUCCESS == *pdwStatus))
            {
                // make sure any failure gets returned to caller

                *pdwStatus = dwNewStatus;
            }
        }
    }
    else
    {
        if( nObjectId == DELETED_DIRS_ONEXIT ) // Delete temp dirs on exit
        {
            hr =  pSettings->SetDelDirsOnExit( ( BOOL )nVal );
        }
        else if( nObjectId == PERSESSION_TEMPDIR )// User temp dirs per session
        {
            hr = pSettings->SetUseTempDirPerSession( ( BOOL )nVal );
        }
        /* else if( nObjectId == DEF_CONSECURITY ) // default security descriptor
        {
            hr = m_pSettings->SetDefaultSecurity( nVal );
        }*/ 
        else if( nObjectId == ACTIVE_DESK )
        {
            hr = pSettings->SetActiveDesktopState( nVal , pdwStatus );

        }
        else if( nObjectId == USERSECURITY )
        {
            hr = pSettings->SetUserPerm( nVal , pdwStatus );

            if( FAILED( hr ) )
            {
                return hr;
            }
        }
        else if( nObjectId == SINGLE_SESSION )
        {
            hr = pSettings->SetSingleSessionState( nVal , pdwStatus );

        }


        if( FAILED( hr ) )
        {
            if( hr == E_ACCESSDENIED )
            {
                *pdwStatus = ERROR_ACCESS_DENIED;
            }
            else
            {
                *pdwStatus = ( DWORD )hr; // general failure
            }
        
        }
        else
        {
            xx_SetValue( nVal );
        }
    }

    return hr;
}

//----------------------------------------------------------
BOOL CSettingNode::SetAttributeName( LPTSTR psz )
{
    if( psz != NULL )
    {
        int cchText = lstrlen( psz ) + 1;

        if( m_szAttributeName != NULL )
        {
            delete[] m_szAttributeName;
        }

        m_szAttributeName = ( LPTSTR )new TCHAR[ cchText ];

        if( m_szAttributeName != NULL )
        {
            lstrcpy( m_szAttributeName , psz );
        }

        return TRUE;
    }

    return FALSE;
}


//----------------------------------------------------------
LPTSTR CSettingNode::GetAttributeValue( )
{     
    DWORD nVal = 0;

    DWORD dwStatus;
    
    ISettingsComp *pSettings = NULL;

    HRESULT hr = S_OK;

    INT nObjectId = GetObjectId( );

    if( nObjectId < CUSTOM_EXTENSION )
    {        
        pSettings = reinterpret_cast< ISettingsComp *>(  m_pSettings );

        if( pSettings == NULL )
        {            
            hr = E_FAIL;
        }

        ODS( L"Getting attribute value\n" );
    }   
    
    if( SUCCEEDED( hr ) )
    {    
        POLICY_TS_MACHINE p;
        RegGetMachinePolicy(&p);

        switch( nObjectId )
        {
        case DELETED_DIRS_ONEXIT: // Delete temp dirs on exit
        
            hr = pSettings->GetDelDirsOnExit( ( PBOOL )&nVal );

            if (p.fPolicyDeleteTempFoldersOnExit)
                nVal = p.fDeleteTempFoldersOnExit;
     
            break;

        case PERSESSION_TEMPDIR:// User temp dirs per session
        
            hr = pSettings->GetUseTempDirPerSession( ( PBOOL )&nVal );

            if (p.fPolicyTempFoldersPerSession)
                nVal = p.fTempFoldersPerSession;
     
            break;
        

        /* case DEF_CONSECURITY: // default security descriptor
        
            hr = m_pSettings->GetDefaultSecurity( &nVal );
        
            break;
            */
        
        case LICENSING: // licensing mode
            
            hr = pSettings->GetLicensingMode( &nVal , &dwStatus );

            break;

        case ACTIVE_DESK:
            
            hr = pSettings->GetActiveDesktopState( ( PBOOL )&nVal , &dwStatus );

            break;

        case USERSECURITY:

            hr = pSettings->GetUserPerm( ( PBOOL )&nVal , &dwStatus );

            break;

        case SINGLE_SESSION:

            hr = pSettings->GetSingleSessionState( ( PBOOL )&nVal , &dwStatus );

            if (p.fPolicySingleSessionPerUser)
                nVal = p.fSingleSessionPerUser;

            break;

        default:
            if( nObjectId >= CUSTOM_EXTENSION )
            {
                ODS( L"Getting attribute value\n" );
                nVal = 0; // we don't care we leave it up to the provider 
                hr = S_OK;
            }

        }
    }

    if( FAILED( hr ) )
    {
        TCHAR szBuffer[ 80 ];

        szBuffer[0] = 0;

        if( m_szAttributeValue != NULL )
        {
            delete[] m_szAttributeValue;
        }
        
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_SSERROR , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        
        m_szAttributeValue = ( LPTSTR )new TCHAR[ lstrlen( szBuffer ) + 1 ];
        
        if( m_szAttributeValue != NULL )
        {
            lstrcpy( m_szAttributeValue , szBuffer );
        }

        if( nObjectId != LICENSING )
        {
            xx_SetValue( 0 );
        }

    }
    else
    {
        xx_SetValue( nVal );
    }   

    m_hrStatus = hr;

    return m_szAttributeValue;
}

//----------------------------------------------------------
DWORD CSettingNode::GetImageIdx( )
{
    return ( DWORD )3;
}


//----------------------------------------------------------
BOOL CSettingNode::AddMenuItems( LPCONTEXTMENUCALLBACK pcmc , PLONG pl )
{

    HRESULT hr = E_FAIL;

    TCHAR tchName[ 80 ];

    TCHAR tchStatus[ 256 ];

    CONTEXTMENUITEM cmi;

    BOOL bVal = FALSE;

    INT nObjectId = GetObjectId( );

    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);

    switch( nObjectId )
    {

    case DELETED_DIRS_ONEXIT:
                
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_STANDARAD_PROPERTIES_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;
        
        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        if( SUCCEEDED( hr ) )
        {        
            bVal = ( BOOL )xx_GetValue( );

            if( bVal )
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NOMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NOTDELTEMP_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;                
            }
            else
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_YESMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DELTEMP_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;                
            }

            if (p.fPolicyDeleteTempFoldersOnExit)
            {
                //Clear the last 2 bits since MF_GRAYED is 
                //incompatible with MF_DISABLED
                cmi.fFlags &= 0xFFFFFFFCL; 
                cmi.fFlags |= MF_GRAYED;
            }

            cmi.lCommandID = IDM_SETTINGS_DELTEMPDIRSONEXIT;

            hr = pcmc->AddItem( &cmi );
        }


        break;

    case PERSESSION_TEMPDIR:

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_STANDARAD_PROPERTIES_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        if( SUCCEEDED( hr ) )
        {
            bVal = ( BOOL )xx_GetValue( );

            if( bVal )
            {                
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NOMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NOTUSEPERSESSION_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;                
        
            }
            else
            {                
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_YESMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_USEPERSESSION_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;        
            }

            if (p.fPolicyTempFoldersPerSession)
            {
                //Clear the last 2 bits since MF_GRAYED is 
                //incompatible with MF_DISABLED
                cmi.fFlags &= 0xFFFFFFFCL; 
                cmi.fFlags |= MF_GRAYED;
            }

            cmi.lCommandID = IDM_SETTINGS_USETMPDIR;

            hr = pcmc->AddItem( &cmi );
        }

        break;

    /* case DEF_CONSECURITY:

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_STANDARAD_PROPERTIES_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        break;
        */

    case LICENSING:

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_STANDARAD_PROPERTIES_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        break;

    case ACTIVE_DESK:

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ACTIVEDESK_PROP_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        if( SUCCEEDED( hr ) )
        {
            bVal = ( BOOL )xx_GetValue( );

            if( bVal )
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABLEMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABLE_ADP_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;  
            }
            else
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ENABLEMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ENABLE_ADP_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;
            }

            cmi.lCommandID = IDM_SETTINGS_ADP;

            hr = pcmc->AddItem( &cmi );
        }

        break;    

    case SINGLE_SESSION:

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_STANDARAD_PROPERTIES_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        if( SUCCEEDED( hr ) )
        {
            bVal = ( BOOL )xx_GetValue( );

            if( bVal )
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NOMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABLE_SINGLESESSION_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;  
            }
            else
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_YESMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ENABLE_SINGLESESSION_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;
            }

            if (p.fPolicySingleSessionPerUser)
            {
                //Clear the last 2 bits since MF_GRAYED is 
                //incompatible with MF_DISABLED
                cmi.fFlags &= 0xFFFFFFFCL; 
                cmi.fFlags |= MF_GRAYED;
            }

            cmi.lCommandID = IDM_SETTINGS_SS;

            hr = pcmc->AddItem( &cmi );
        }

        break;    

    case USERSECURITY:
        
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_STANDARAD_PROPERTIES_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        break;

    default:

        if( nObjectId >= CUSTOM_EXTENSION )
        {
            IExtendServerSettings *pSetting = reinterpret_cast< IExtendServerSettings * >( m_pSettings );

            if( pSetting != NULL )
            {
                PMENUEXTENSION pMex = NULL;

                INT cbItems = 0;

                if( SUCCEEDED( pSetting->GetMenuItems( &cbItems , &pMex ) ) )
                {
                    for( INT i = 0 ; i < cbItems; i++ )
                    {
                        cmi.strName = pMex[ i ].MenuItemName;

                        cmi.strStatusBarText = pMex[ i ].StatusBarText;

                        cmi.lCommandID = pMex[ i ].cmd;

                        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
        
                        cmi.fFlags = cmi.fSpecialFlags = 0;
        
                        *pl |= CCM_INSERTIONALLOWED_TOP;
        
                        if (p.fPolicySessionDirectoryActive)
                        {
                            //Gray out everything but properties
                            if (cmi.lCommandID != IDM_MENU_PROPS) 
                            {
                                //Clear the last 2 bits since MF_GRAYED is 
                                //incompatible with MF_DISABLED
                                cmi.fFlags &= 0xFFFFFFFCL; 
                                cmi.fFlags |= MF_GRAYED;
                            }
                        }

                        pcmc->AddItem( &cmi );

                    }

                    hr = S_OK;

                    LocalFree( pMex );
                }

            }
        }

    }
 
    return ( SUCCEEDED( hr ) ? TRUE : FALSE );
    
}

//----------------------------------------------------------
BOOL CSettingNode::SetInterface( LPUNKNOWN pInf )
{
    pInf->AddRef( );

    m_pSettings = pInf;

    return TRUE;
}

//----------------------------------------------------------
CSettingNode::~CSettingNode( )
{
    DBGMSG( L"CSettingNode dtor called for objectid %d\n" , m_objectid );

    if( m_szAttributeName != NULL )
    {
        delete[] m_szAttributeName;
    }

    if( m_szAttributeValue != NULL )
    {
        delete[] m_szAttributeValue;
    }

    if( m_pSettings != NULL )
    {
        m_pSettings->Release( );
    }
}


//---------------------------------------------------------
// Helper functions
//---------------------------------------------------------
BOOL CSettingNode::xx_SetValue( INT nVal )
{
    TCHAR szBuffer[ 1024 ]; 

    szBuffer[0] = 0;

    INT nObjectId = GetObjectId( );

    if( m_szAttributeValue != NULL )
    {
        delete[] m_szAttributeValue;
    }
        
    switch( nObjectId )
    {

    case SINGLE_SESSION:
        
        if( ( BOOL )nVal )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_YES , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
            
        }
        else
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NO , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
            
        }
        break;
    
    case DELETED_DIRS_ONEXIT: // Delete temp dirs on exit
        
        if( ( BOOL )nVal )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_YES , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
            
        }
        else
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NO , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
            
        }
        break;

    case PERSESSION_TEMPDIR:// User temp dirs per session
        
        if( ( BOOL )nVal )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_YES , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        }
        else
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NO , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        }
        break;

    /*
    case DEF_CONSECURITY: // default security descriptor
    
        switch( nVal )
        {
        case 0: // this shoudl never happen
        case 1:

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_RAA , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );

            break;

        case 2:

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_AS , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );

            break;

        case 3:

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_AA , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );

            break;
        }

        break;
     */

        
    case LICENSING: // licensing mode
        {
            ISettingsComp *pSettings = reinterpret_cast< ISettingsComp * > (m_pSettings);

            if (NULL != pSettings)
            {
                WCHAR *wszName, *wszDescription;
                DWORD dwStatus;
                HRESULT hr;

                hr = pSettings->GetLicensingModeInfo(
                                                     nVal,
                                                     &wszName,
                                                     &wszDescription,
                                                     &dwStatus);

                if (SUCCEEDED(hr))
                {
                    _ASSERTE( ERROR_SUCCESS == dwStatus );
                    
                    lstrcpyn(szBuffer,wszName,sizeof(szBuffer)/sizeof(TCHAR));
                    
                    CoTaskMemFree(wszName);
                    CoTaskMemFree(wszDescription);
                }
            }
        }
        break;

    case ACTIVE_DESK:

        if( ( BOOL )nVal )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ENABLED , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        }
        else
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABLED , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        }

        break;

    case USERSECURITY:

        if( ( BOOL )nVal )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_USERPERM_NT4 , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        }
        else
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_USERPERM_W2K , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        }

        break;

    default:

        if( nObjectId >= CUSTOM_EXTENSION )
        {
            IExtendServerSettings *pSettings = reinterpret_cast< IExtendServerSettings *>(  m_pSettings );

            if( pSettings != NULL )
            {
                pSettings->GetDisplayableValueName( szBuffer );

                DBGMSG( L"xx_SetValue for Extension returned %s\n" , szBuffer );
            }
        }


    } // switch

    m_szAttributeValue = ( LPTSTR )new TCHAR[ lstrlen( szBuffer ) + 1 ];
    
    if( m_szAttributeValue != NULL )
    {
        lstrcpy( m_szAttributeValue , szBuffer );
    }

    m_nGenericValue = nVal;

    return TRUE;
}
        
//----------------------------------------------------------------------
// And all out central server setting error handler
// this is setup in this manner to allow MMC to own the Msgbx as well
// as the custom dialog pages
//
void SnodeErrorHandler( HWND hParent , INT nObjectId , DWORD dwStatus )
{
    switch( nObjectId )
    {
        
    case DELETED_DIRS_ONEXIT: // Delete temp dirs on exit

    case PERSESSION_TEMPDIR:// User temp dirs per session

    case SINGLE_SESSION: // Restrict to single session per user

    // case DEF_CONSECURITY: // default security descriptor

    case LICENSING: // licensing mode

    case ACTIVE_DESK:
        
        if( dwStatus == ERROR_ACCESS_DENIED )
        {
            TscAccessDeniedMsg( hParent );
        }
        else
        {
            TscGeneralErrMsg( hParent );
        }                
        break;

    case USERSECURITY:

        if( dwStatus != 0 )
        {
            ReportStatusError( hParent , dwStatus ); 
        }
    } // switch


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\sdlgs.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include<stdafx.h>
#include"resource.h"
#include"sdlgs.h"
#include"snodes.h"


#include<shellapi.h>
#include<shlapip.h>
#include <shlobj.h>
#include<shlobjp.h>

BOOL OnHelp( HWND hwnd , LPHELPINFO lphi );

BOOL OnContextMenu( HWND hwnd , POINT& pt );

void ErrMessage( HWND hwndOwner , INT_PTR iResourceID );

extern void xxxErrMessage( HWND hwnd , INT_PTR nResMessageId , INT_PTR nResTitleId , UINT nFlags );

void SnodeErrorHandler( HWND hParent , INT nObjectId , DWORD dwStatus );

#define RECTWIDTH( rc )  ((rc).right - (rc).left)
#define RECTHEIGHT( rc ) ((rc).bottom - (rc).top)

extern BOOL g_bAppSrvMode;


#if 0
//--------------------------------------------------------------------------------------
INT_PTR CALLBACK CachedSessionsDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
    CSettingNode *pNode;
    
    DWORD nVal = 0;

    switch( msg )
    {
    case WM_INITDIALOG :

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );
        
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );
        
        SetFocus( GetDlgItem( hDlg , IDC_EDIT_CACHEDSESSION ) );

        pNode->m_pSettings->GetCachedSessions( &nVal );

        SetDlgItemInt( hDlg , IDC_EDIT_CACHEDSESSION , ( UINT )nVal , FALSE );

        break;

    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }

            BOOL bSuccess = FALSE;

            UINT uVal = GetDlgItemInt( hDlg , IDC_EDIT_CACHEDSESSION , &bSuccess , FALSE );
            
            if( !bSuccess )
            {
                ErrMessage( hDlg , IDS_ERR_CACHEDVALUE );

                return 0;
            }

            // check for any errors when setting this value

            pNode->SetAttributeValue( ( DWORD )uVal );
            
            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}

#endif 

//--------------------------------------------------------------------------------------
INT_PTR CALLBACK UsePerSessionTempDirsDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
    CSettingNode *pNode;

    // TCHAR tchNewName[ 128 ];
    
    BOOL bVal = FALSE;

    static INT nOldSelection;

    switch( msg )
    {
    case WM_INITDIALOG :

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );
        
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        if( pNode->GetObjectId( ) == PERSESSION_TEMPDIR )
        {            
            bVal = ( BOOL )pNode->xx_GetValue( );
        }

        SendMessage( GetDlgItem( hDlg , IDC_RADIO_PERSESSION_YES ) , BM_SETCHECK , ( WPARAM )bVal , 0 );
        SendMessage( GetDlgItem( hDlg , IDC_RADIO_PERSESSION_NO ) , BM_SETCHECK , ( WPARAM )!bVal , 0 );
        
        POLICY_TS_MACHINE p;
        RegGetMachinePolicy(&p);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_PERSESSION_YES), !p.fPolicyTempFoldersPerSession);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_PERSESSION_NO), !p.fPolicyTempFoldersPerSession);

        nOldSelection = bVal;
        
        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            if( hDlg == GetParent( ( HWND )wp ) )
            {
                OnContextMenu( ( HWND )wp , pt );
            }
        }

        break;

    case WM_HELP:

        OnHelp( hDlg , ( LPHELPINFO )lp );

        break;


    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }            
            
            INT nCurrent = IsDlgButtonChecked( hDlg , IDC_RADIO_PERSESSION_YES ) == BST_CHECKED ? 1 : 0;

            if( nOldSelection != nCurrent )
            {
                DWORD dwStatus;

                if( FAILED( pNode->SetAttributeValue( ( DWORD )nCurrent , &dwStatus ) ) )
                {
                    SnodeErrorHandler( hDlg , pNode->GetObjectId( ) , dwStatus );
                }
            }
            
            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}

#if 0 // removed from final release
//--------------------------------------------------------------------------------------
INT_PTR CALLBACK DefConSecurityDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
    CSettingNode *pNode = NULL;
    
    DWORD nVal = 0;
    

    switch( msg )
    {
    case WM_INITDIALOG :
        {
            TCHAR tchBuffer[ 128 ];

            INT rgid[] = { IDS_RAA , IDS_AS , IDS_AA , -1 };
            
            pNode = ( CSettingNode *)lp;

            ASSERT( pNode != NULL );
        
            // ok to store null -- it's initializing DWLP_USER area

            SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

            for( int idx = 0; rgid[ idx ] != -1 ; ++idx )
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , rgid[ idx ] , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );

                SendMessage( GetDlgItem( hDlg , IDC_COMBO_DEFSEC ) , CB_ADDSTRING , 0 , ( LPARAM )tchBuffer );
            }


            nVal = ( DWORD )pNode->xx_GetValue( );

            if( nVal == 0 )
            {
                // error message 

                ErrMessage( hDlg , IDS_ERROR_INVALID_SD );
                            
            }
        
            SendMessage( GetDlgItem( hDlg , IDC_COMBO_DEFSEC ) , CB_SETCURSEL , ( WPARAM )( nVal - 1 ) , 0 );

        }

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            if( hDlg == GetParent( ( HWND )wp ) )
            {
                OnContextMenu( ( HWND )wp , pt );
            }
        }

        break;

    case WM_HELP:

        OnHelp( hDlg , ( LPHELPINFO )lp );

        break;


    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }
            
            INT_PTR iSel = SendMessage( GetDlgItem( hDlg , IDC_COMBO_DEFSEC ) , CB_GETCURSEL , 0 , 0 );

            if( iSel != CB_ERR )
            {
                INT nOld = pNode->xx_GetValue( );

                if( nOld != ( INT )( iSel + 1 ) )
                {
                    DWORD dwStatus;

                    if( FAILED( pNode->SetAttributeValue( ( DWORD )( iSel + 1 ) , &dwStatus ) ) )
                    {
                        SnodeErrorHandler( hDlg , pNode->GetObjectId( ) , dwStatus );
                    }
                }
            }
            else
            {
                ErrMessage( hDlg , IDS_ERROR_INVALID_SD );                
            }

            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;

}

#endif

//--------------------------------------------------------------------------------------
INT_PTR CALLBACK LicensingDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
    CSettingNode *pNode;
    DWORD dwStatus;

    static HCURSOR hcurWait;

    static ULONG ulOldSelection;

    static ULONG *rgulModes = NULL;

    static WCHAR **rgszNames = NULL;

    static WCHAR **rgszDescriptions = NULL;

    static ULONG cModes = 0;

    switch( msg )
    {
    case WM_INITDIALOG :
        {
        ULONG ulMode;
        ULONG iMode = 0;        // index of ulMode in rgulModes
        DWORD nTermSrvMode;
        DWORD idcRA;
        RECT rcTextCtrl;
        HRESULT hr;
        HWND hLW;
        ISettingsComp *pSc;
        BOOL fIModeFound = FALSE;

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );

        pSc = reinterpret_cast< ISettingsComp * >( pNode->GetInterface() );

        ASSERT(NULL != pSc)
        
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        //
        // read valid modes and cache them
        //

        hr = pSc->GetLicensingModeList( &cModes, &rgulModes, &dwStatus );

        if (FAILED(hr))
        {
            ErrMessage( hDlg , IDS_ERROR_NO_LICENSING_MODE_LIST );
            EndDialog( hDlg , 0 );
            goto done_init;
        }

        hr = pSc->GetLicensingMode( &ulMode, &dwStatus );

        if (FAILED(hr))
        {
            ErrMessage( hDlg , IDS_ERROR_NO_LICENSING_MODE );
            EndDialog( hDlg , 0 );
            goto done_init;
        }

        rgszNames = (WCHAR **) CoTaskMemAlloc(cModes * sizeof(WCHAR *));

        if (NULL == rgszNames)
        {
            ErrMessage( hDlg , IDS_ERROR_NO_MEMORY );
            EndDialog( hDlg , 0 );
            goto done_init;
        }

        rgszDescriptions = (WCHAR **) CoTaskMemAlloc(cModes * sizeof(WCHAR *));

        if (NULL == rgszDescriptions)
        {
            ErrMessage( hDlg , IDS_ERROR_NO_MEMORY );
            EndDialog( hDlg , 0 );
            goto done_init;
        }

        for (ULONG i = 0; i < cModes; i++)
        {
            hr = pSc->GetLicensingModeInfo(rgulModes[i],rgszNames+i,rgszDescriptions+i,&dwStatus);

            if (FAILED(hr))
            {
                ErrMessage( hDlg , IDS_ERROR_NO_LICENSING_MODE_INFO );
                EndDialog( hDlg , 0 );
                goto done_init;
            }

            if (ulMode == rgulModes[i])
            {
                iMode = i;
                fIModeFound = TRUE;
            }

            SendMessage( GetDlgItem( hDlg , IDC_LICENSING_MODE ) , CB_ADDSTRING , 0 , (LPARAM) rgszNames[i] ); 
        }

        ASSERT(fIModeFound);

        ulOldSelection = iMode;

        //
        // make current mode the selection in the dropdown
        //
        SendMessage( GetDlgItem( hDlg , IDC_LICENSING_MODE ) , CB_SETCURSEL , (WPARAM) iMode , 0 );

        //
        // Show the mode description in the description control
        //
        SetWindowText( GetDlgItem( hDlg , IDC_LICENSING_DESCRIPTION ),  rgszDescriptions[iMode] );

        //
        // make the valid remote admin control visible
        //
        hr = pSc->GetTermSrvMode( &nTermSrvMode , &dwStatus );

        if (FAILED(hr))
        {
            ErrMessage( hDlg , IDS_ERR_TERMSRVMODE );
            EndDialog( hDlg , 0 );
            goto done_init;
        }

        idcRA = nTermSrvMode ? IDC_LICENSING_TO_REMOTE_ADMIN : IDC_LICENSING_FROM_REMOTE_ADMIN;

        //
        // make the remote admin control into a link
        //
        GetWindowRect( GetDlgItem( hDlg , idcRA ) , &rcTextCtrl );

        MapWindowPoints( NULL , hDlg , ( LPPOINT )&rcTextCtrl , 2 );

        LinkWindow_RegisterClass();

        hLW = CreateWindowEx( 0 ,
                              TEXT("Link Window") ,
                              TEXT( "" ) ,
                              WS_CLIPSIBLINGS | WS_TABSTOP | WS_CHILD | WS_VISIBLE,
                              rcTextCtrl.left ,
                              rcTextCtrl.top ,
                              RECTWIDTH( rcTextCtrl ) ,
                              RECTHEIGHT( rcTextCtrl ),
                              hDlg ,
                              ( HMENU )12,
                              NULL,
                              NULL );

        {
            TCHAR tchBuffer[ 512 ];
            GetWindowText( GetDlgItem( hDlg , idcRA ), tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) ;

            SetWindowText( hLW , tchBuffer );
        }

        hcurWait = LoadCursor( NULL , MAKEINTRESOURCE( IDC_WAIT ) ) ;
        }         
done_init:
        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            if( hDlg == GetParent( ( HWND )wp ) )
            {
                OnContextMenu( ( HWND )wp , pt );
            }
        }

        break;


    case WM_HELP:

        OnHelp( hDlg , ( LPHELPINFO )lp );

        break;

    case WM_COMMAND:

        if ( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }            

            LRESULT nCurSel = SendMessage(GetDlgItem( hDlg ,
                                                      IDC_LICENSING_MODE),
                                          CB_GETCURSEL,
                                          0,
                                          0);

            if ( ulOldSelection != (ULONG) nCurSel )
            {
                if( FAILED( pNode->SetAttributeValue( ( DWORD )rgulModes[nCurSel] , &dwStatus ) ) )
                {
                    SnodeErrorHandler( hDlg ,
                                       pNode->GetObjectId( ),
                                       dwStatus );
                }
            }
        }

        if (( LOWORD( wp ) == IDCANCEL ) || ( LOWORD( wp ) == IDOK ))
        {
            LinkWindow_UnregisterClass( _Module.GetModuleInstance() );

            if (NULL != rgszNames)
            {
                CoTaskMemFree(rgszNames);
                rgszNames = NULL;
            }

            if (NULL != rgszDescriptions)
            {
                CoTaskMemFree(rgszDescriptions);
                rgszDescriptions = NULL;
            }

            EndDialog( hDlg , 0 );
        }
        else if (HIWORD( wp ) == CBN_SELCHANGE)
        {
            LRESULT nCurSel = SendMessage((HWND) lp,
                                          CB_GETCURSEL,
                                          0,
                                          0);
            
            ASSERT((ULONG)nCurSel < cModes);

            SetWindowText( GetDlgItem( hDlg , IDC_LICENSING_DESCRIPTION ),
                           rgszDescriptions[nCurSel] );
        }

        break;
    case WM_NOTIFY:

        switch (((LPNMHDR)lp)->code)
        {
            case NM_CHAR:
			
				if( ( ( LPNMCHAR )lp )->ch != VK_SPACE )
				{
					break;
				}

				// else fall through

            case NM_RETURN:	
            case NM_CLICK:
			{                
                TCHAR szFile[MAX_PATH];

                TCHAR szParam[MAX_PATH];

                SHELLEXECUTEINFO sei;

                ZeroMemory( &sei , sizeof( SHELLEXECUTEINFO ) );

                if ( GetSystemDirectory( szFile , SIZE_OF_BUFFER( szFile ) ) )
                {
                    lstrcpy( szParam , TEXT( ",2" ) );

                    lstrcpy( szFile , TEXT( "appwiz.cpl" ) );

                    sei.cbSize = sizeof( SHELLEXECUTEINFO );

                    sei.fMask = SEE_MASK_NOCLOSEPROCESS;

                    sei.lpFile = szFile;

                    sei.lpParameters = szParam;
                 
                    if( ShellExecuteEx( &sei ) )
                    {
                        EndDialog( hDlg, IDCANCEL );                        
                    }
                }
            }

            break;
        }

        break;
    }

    return 0;
}

//--------------------------------------------------------------------------------------
INT_PTR CALLBACK ConfigActiveDesktop( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
	CSettingNode *pNode;

    //TCHAR tchNewName[ 128 ];
    
    BOOL bVal = FALSE;

	static nOldSelection;

    switch( msg )
    {

    case WM_INITDIALOG :

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );
               
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        if( pNode->GetObjectId( ) == ACTIVE_DESK )
        {
            
            bVal = ( BOOL )pNode->xx_GetValue( );

        }
        
		// control converted into a checkbox if the chkbx is checked it means disable
		// unchecked, well you've guest it.

        if( bVal )
        {
			
            SendMessage( GetDlgItem( hDlg , IDC_RADIO_AD_ENABLE ) , BM_SETCHECK , ( WPARAM )FALSE , 0 );
        }
        else
        {
			SendMessage( GetDlgItem( hDlg , IDC_RADIO_AD_ENABLE ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );
            //SendMessage( GetDlgItem( hDlg , IDC_RADIO_ADP_DISABLE ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );
        }

        nOldSelection = bVal;
        
        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            if( hDlg == GetParent( ( HWND )wp ) )
            {
                OnContextMenu( ( HWND )wp , pt );
            }
        }

        break;

    case WM_HELP:

        OnHelp( hDlg , ( LPHELPINFO )lp );

        break;

    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }

            INT nCurrent = IsDlgButtonChecked( hDlg , IDC_RADIO_AD_ENABLE ) == BST_CHECKED ? 0 : 1;

            if( nOldSelection != nCurrent )
            {
                DWORD dwStatus;

                if( FAILED( pNode->SetAttributeValue( ( DWORD )nCurrent , &dwStatus ) ) )
                {
                    SnodeErrorHandler( hDlg , pNode->GetObjectId( ) , dwStatus );
                }
            }
            
            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}


//--------------------------------------------------------------------------------------
INT_PTR CALLBACK ConfigSingleSession( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
	CSettingNode *pNode;

    //TCHAR tchNewName[ 128 ];
    
    BOOL bVal = FALSE;

	static nOldSelection;

    switch( msg )
    {

    case WM_INITDIALOG :

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );
               
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        if( pNode->GetObjectId( ) == SINGLE_SESSION )
        {
            
            bVal = ( BOOL )pNode->xx_GetValue( );

        }
        
		// control converted into a checkbox if the chkbx is checked it means enable
		// unchecked, well you've guest it.

			
        SendMessage( GetDlgItem( hDlg , IDC_RADIO_SINGLE_SESSION_ENABLE ) , BM_SETCHECK , ( WPARAM )bVal , 0 );

        POLICY_TS_MACHINE p;
        RegGetMachinePolicy(&p);
        EnableWindow(GetDlgItem(hDlg,IDC_RADIO_SINGLE_SESSION_ENABLE), !p.fPolicySingleSessionPerUser);

        nOldSelection = bVal;
        
        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            if( hDlg == GetParent( ( HWND )wp ) )
            {
                OnContextMenu( ( HWND )wp , pt );
            }
        }

        break;

    case WM_HELP:

        OnHelp( hDlg , ( LPHELPINFO )lp );

        break;

    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }

            INT nCurrent = IsDlgButtonChecked( hDlg , IDC_RADIO_SINGLE_SESSION_ENABLE ) == BST_CHECKED ? 1 : 0;

            if( nOldSelection != nCurrent )
            {
                DWORD dwStatus;

                if( FAILED( pNode->SetAttributeValue( ( DWORD )nCurrent , &dwStatus ) ) )
                {
                    SnodeErrorHandler( hDlg , pNode->GetObjectId( ) , dwStatus );
                }
            }
            
            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}


//--------------------------------------------------------------------------------------
INT_PTR CALLBACK DeleteTempDirsDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
    CSettingNode *pNode;

    // TCHAR tchNewName[ 128 ];
    
    BOOL bVal = FALSE;

    static nOldSelection;

    switch( msg )
    {
    case WM_INITDIALOG :

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );
        
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        if( pNode->GetObjectId( ) == DELETED_DIRS_ONEXIT )
        {            
            bVal = ( BOOL )pNode->xx_GetValue( );
        }

        SendMessage( GetDlgItem( hDlg , IDC_RADIO_YES ) , BM_SETCHECK , ( WPARAM )bVal , 0 );
        SendMessage( GetDlgItem( hDlg , IDC_RADIO_NO ) , BM_SETCHECK , ( WPARAM )!bVal , 0 );

        POLICY_TS_MACHINE p;
        RegGetMachinePolicy(&p);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_YES), !p.fPolicyDeleteTempFoldersOnExit);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_NO), !p.fPolicyDeleteTempFoldersOnExit);
        
        nOldSelection = bVal;
        
        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            if( hDlg == GetParent( ( HWND )wp ) )
            {
                OnContextMenu( ( HWND )wp , pt );
            }
        }

        break;

    case WM_HELP:

        OnHelp( hDlg , ( LPHELPINFO )lp );

        break;

    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }

            INT nCurrent = IsDlgButtonChecked( hDlg , IDC_RADIO_YES ) == BST_CHECKED ? 1 : 0;

            if( nOldSelection != nCurrent )
            {
                DWORD dwStatus;

                if( FAILED( pNode->SetAttributeValue( ( DWORD )nCurrent , &dwStatus ) ) )
                {
                    SnodeErrorHandler( hDlg , pNode->GetObjectId( ) , dwStatus );
                }
            }
            
            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}

//-------------------------------------------------------------------------------
INT_PTR CALLBACK UserPermCompat( HWND hDlg , UINT msg, WPARAM wp , LPARAM lp )
{
	CSettingNode *pNode;
        
    BOOL bVal = FALSE;

    HICON hIcon;

    static nOldSelection;

    switch( msg )
    {
    case WM_INITDIALOG :

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );
        
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        if( pNode->GetObjectId( ) == USERSECURITY )
        {            
            bVal = ( BOOL )pNode->xx_GetValue( );
        }
        
        if( bVal )
        {
			CheckDlgButton( hDlg , IDC_RADIO_TS4PERM , BST_CHECKED );            
        }
        else
        {
            CheckDlgButton( hDlg , IDC_RADIO_WIN2KPERM , BST_CHECKED );
        }

        nOldSelection = bVal;

       hIcon = LoadIcon( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDI_ICON_WARNING ) );

       hIcon = ( HICON )LoadImage( _Module.GetModuleInstance( ) ,
                                    MAKEINTRESOURCE( IDI_ICON_WARNING ) ,
                                    IMAGE_ICON,
                                    0,
                                    0,
                                    0 );



       SendMessage( GetDlgItem( hDlg , IDC_USERPERM_ICON ) , STM_SETICON , ( WPARAM )hIcon , 0 );

        
        break;

	 case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }

            INT nCurrent = IsDlgButtonChecked( hDlg , IDC_RADIO_TS4PERM ) == BST_CHECKED ? 1 : 0;

            if( nOldSelection != nCurrent )
            {
                DWORD dwStatus;                

                // flag error if not in appsrv mode
                // we should never get here -- unless someone mucked around with the registry.

                if( !g_bAppSrvMode )
                {
                    xxxErrMessage( hDlg , IDS_REMOTEADMIN_ONLY , IDS_WARN_TITLE , MB_OK | MB_ICONINFORMATION );

                    CheckRadioButton( hDlg ,
                                      IDC_RADIO_WIN2KPERM , 
                                      IDC_RADIO_TS4PERM,
                                      ( nOldSelection ) ? IDC_RADIO_TS4PERM : IDC_RADIO_WIN2KPERM 
                                    );
                    return 0;

                }

                else if( FAILED( pNode->SetAttributeValue( ( DWORD )nCurrent , &dwStatus ) ) )
                {
                    SnodeErrorHandler( hDlg , pNode->GetObjectId( ) , dwStatus );
                }
            }
            
            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}

//-------------------------------------------------------------------------------
// Each control has a helpid assign to them.  Some controls share the same topic
// check for these.
//-------------------------------------------------------------------------------
BOOL OnHelp( HWND hwnd , LPHELPINFO lphi )
{
    UNREFERENCED_PARAMETER( hwnd );

    TCHAR tchHelpFile[ MAX_PATH ];

    //
    // For the information to winhelp api
    //

    if( IsBadReadPtr( lphi , sizeof( HELPINFO ) ) )
    {
        return FALSE;
    }

    if( lphi->iCtrlId <= -1 )
    {
        return FALSE;
    }

    LoadString( _Module.GetModuleInstance( ) , IDS_HELPFILE , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) );

    ULONG_PTR rgdw[ 2 ];

    rgdw[ 0 ] = ( ULONG_PTR )lphi->iCtrlId;

    rgdw[ 1 ] = ( ULONG_PTR )lphi->dwContextId;

    WinHelp( ( HWND )lphi->hItemHandle , tchHelpFile , HELP_WM_HELP , ( ULONG_PTR )&rgdw );//lphi->dwContextId );

    return TRUE;
}

//-------------------------------------------------------------------------------
// Used when user right clicks the item.  "What's this?" will appear
//
// The first parameter must be the control in the dialog
// because this is a helper function the caller must insure this.
//-------------------------------------------------------------------------------
BOOL OnContextMenu( HWND hwnd , POINT& pt )
{
    UNREFERENCED_PARAMETER( pt );

    TCHAR tchHelpFile[ MAX_PATH ];

    //
    // Make sure its not a dummy window
    //
    
    if( GetDlgCtrlID( hwnd ) <= ( int )-1 )
    {
        return FALSE;
    }
    
    ULONG_PTR rgdw[ 2 ];
    
    rgdw[ 0 ] = GetDlgCtrlID( hwnd );
    
    rgdw[ 1 ] = GetWindowContextHelpId( hwnd );
    
    LoadString( _Module.GetModuleInstance( ) , IDS_HELPFILE , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) );
    
    WinHelp( hwnd , tchHelpFile , HELP_CONTEXTMENU , ( ULONG_PTR )&rgdw );
    
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\tarray.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _TARRAY_H
#define _TARRAY_H
template< class T > class CArrayT
{
    T *m_pT;

    int m_nMaxSize;

    int m_idx;                  //current array pos

public:
    
//------------------------------------------------------------------------
    CArrayT( )
    {
        m_pT = NULL;

        m_nMaxSize = 0;

        m_idx = 0;
    }
//------------------------------------------------------------------------
// destroy the list
    ~CArrayT( )
    {
        if( m_pT != NULL )
        {
            delete[] m_pT;
        }
    }
//------------------------------------------------------------------------
// increases array size,  returns zero if the operation failed
    int GrowBy( int iSize )
    {
        if( iSize == 0 )
        {
            //
            //Grow by # number of items
            //
            iSize = 4;

        }

        if( m_pT == NULL )
        {
            m_pT = ( T * )new T[ iSize ];

            if( m_pT == NULL )
            {
                return 0;
            }

            m_nMaxSize = iSize;

            m_idx = 0;
        }
        else
        {
            T *pT;

            m_nMaxSize += iSize;

            pT = ( T * )new T[ m_nMaxSize ];

            if( pT == NULL )
            {
                return 0;
            }

            ZeroMemory( ( PVOID )pT , sizeof( T ) * m_nMaxSize );

            CopyMemory( pT , m_pT , sizeof( T ) * ( m_idx ) );

            if( m_pT != NULL )
            {
                delete[] m_pT;
            }

            m_pT = pT;
        }
    

        return m_nMaxSize;
    }
//------------------------------------------------------------------------
// Simply put, increase the array size if empty, and place item at the
// end of the list
    int Insert( T tItem )
    {
        if( m_pT == NULL || ( m_idx ) >= m_nMaxSize )
        {
            if( GrowBy( 0 ) == 0 )
            {
                return 0;
            }
        }


        m_pT[ m_idx ] = tItem;

        m_idx++;

        return m_idx;
    }

//------------------------------------------------------------------------
// exposes the array for direct reference
   T* ExposeArray(  )
   {
        if( m_pT != NULL )
        {
            return &m_pT[0];
        }

        return NULL;
    }
//------------------------------------------------------------------------
// Returns the number of valid entries in the array
    int GetSize( ) const
    {
        return ( m_idx );
    }

//------------------------------------------------------------------------
// Returns an item in the array, or null if not with in range
    T* GetAt( int idx ) 
    {
        if( idx < 0 || idx >= m_idx )
        {            
            return NULL;
        }

        return &m_pT[ idx ];
    }

//------------------------------------------------------------------------
// Assigns a value in the array
    int SetAt( int idx , T tItem )
    {
        if( idx < 0 || idx >= m_idx )
        {
            return -1;
        }

        m_pT[ idx ] = tItem;

        return idx;
    }

//------------------------------------------------------------------------
// Finds an item in the array ( incase one forgot the index )

    int FindItem( T tItem , BOOL& bFound )
    {
        bFound = FALSE;

        int idx = 0;

        while( idx < m_idx )
        {
            if( m_pT[ idx ] == tItem )
            {
                bFound = TRUE;
                break;
            }

            idx++;
        }

        return idx;
    }

//------------------------------------------------------------------------
// Deletes an item from the array

    int DeleteItemAt( int idx )
    {
        if( 0 > idx || idx >= m_idx )
        {
            return 0;
        }
        
        if( idx == m_idx - 1 )  //delete last item
        {
            m_idx--;
            
            return -1;
        }

        void *pvDest    =   &m_pT[ idx ];
        
        void *pvSrc     =   &m_pT[ idx + 1 ];    
        
        ULONG ulDistance =  (ULONG)( ( BYTE *)&m_pT[ m_nMaxSize - 1 ] - ( BYTE * )pvSrc ) + sizeof( T );

        if( ulDistance != 0 )
        {
            MoveMemory( pvDest , pvSrc , ulDistance );
            
            // Adjust the array status
            
            m_idx--;
        
            m_nMaxSize--;
        }


        return ulDistance;
    }
     


//------------------------------------------------------------------------
// Deletes the array of items
    int DeleteArray( )
    {
        if( m_pT != NULL )
        {
            delete[] m_pT;
        }

        m_pT = NULL;

        m_nMaxSize = 0;

        m_idx = 0;

        return 0;
    }


};

#endif //_TARRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B91B5FFE_32D2_11D2_9888_00A0C925F917__INCLUDED_)
#define AFX_STDAFX_H__B91B5FFE_32D2_11D2_9888_00A0C925F917__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include<winsta.h>
#include "cfgbkend.h"
#include "srvsetex.h"

#if __RPCNDR_H_VERSION__ < 440             // This may be needed when building
#define __RPCNDR_H_VERSION__ 440           // on NT5 (1671) to prevent MIDL errors
#define MIDL_INTERFACE(x) interface
#endif

#define ALN_APPLY ( WM_USER + 333 )

#define ERROR_ILLEGAL_CHARACTER         0x01

#define ERROR_INVALID_FIRSTCHARACTER    0x02

#define SPECIAL_ENABLETODISABLE         0x82345678

#define SPECIAL_DISABLETOENABLE         0x82345679

#define SIZE_OF_BUFFER( x ) sizeof( x ) / sizeof( TCHAR )

#ifdef DBG

extern bool g_fDebug;

#define ODS( x ) \
    if( g_fDebug ) OutputDebugString( x );\

#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[180]; \
    if( g_fDebug ) {\
    wsprintf( tchErr , x , y ); \
    ODS( tchErr ); \
    }\
    }

#define VERIFY_E( retval , expr ) \
    if( ( expr ) == retval ) \
    {  \
       ODS( L#expr ); \
       ODS( L" returned "); \
       ODS( L#retval ); \
       ODS( L"\n" ); \
    } \


#define VERIFY_S( retval , expr ) \
    if( ( expr ) != retval ) \
{\
      ODS( L#expr ); \
      ODS( L" failed to return " ); \
      ODS( L#retval ); \
      ODS( L"\n" ); \
}\

#define ASSERT( expr ) \
    if( !( expr ) ) \
    { \
       char tchAssertErr[ 180 ]; \
       wsprintfA( tchAssertErr , "Assertion in expression ( %s ) failed\nFile - %s\nLine - %d\nDo you wish to Debug?", #expr , (__FILE__) , __LINE__ ); \
       if( MessageBoxA( NULL , tchAssertErr , "ASSERTION FAILURE" , MB_YESNO | MB_ICONERROR )  == IDYES ) \
       {\
            DebugBreak( );\
       }\
    } \

#else

#define ODS
#define DBGMSG
#define ASSERT( expr )
#define VERIFY_E( retval , expr ) ( expr )
#define VERIFY_S( retval , expr ) ( expr )
#endif

#define WINSTATION_NAME_TRUNCATE_BY 7

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.



#endif // !defined(AFX_STDAFX_H__B91B5FFE_32D2_11D2_9888_00A0C925F917__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\todlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _TODLG_H
#define _TODLG_H

enum TOKEN { TOKEN_DAY , TOKEN_HOUR , TOKEN_MINUTE };


const ULONG kMilliMinute = 60000;
const ULONG kMaxTimeoutMinute = 71580;

#define E_PARSE_VALUEOVERFLOW   0x80000000
#define E_PARSE_INVALID         0xffffffff
#define E_SUCCESS               0
#define E_PARSE_MISSING_DIGITS  0X7fffffff

//---------------------------------------------------------------------
// retains object state for the timeout dlg combx
//---------------------------------------------------------------------
typedef struct _cbxstate
{
    int icbxSel;

    BOOL bEdit;

} CBXSTATE;

//---------------------------------------------------------------------
// keeps a list of the time unit abbreviations and full names
// ie: h hr hrs hour hours
//---------------------------------------------------------------------
typedef struct _toktable
{
    LPTSTR pszAbbrv;

    DWORD dwresourceid;

} TOKTABLE, *PTOKTABLE;

//---------------------------------------------------------------------
// Dialog for Timeout settings page
//---------------------------------------------------------------------
class CTimeOutDlg 
{
    CBXSTATE m_cbxst[ 3 ];

public:
    
    CTimeOutDlg( );
    
    // BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    // BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    // BOOL OnDestroy( );

    // BOOL PersistSettings( HWND );

    // BOOL IsValidSettings( HWND );

    BOOL InitControl( HWND );

    BOOL ReleaseAbbreviates( );

    BOOL OnCommand( WORD , WORD , HWND , PBOOL );
    
    // static BOOL CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL ConvertToMinutes( HWND , PULONG );

    BOOL InsertSortedAndSetCurSel( HWND , DWORD );

    BOOL RestorePreviousValue( HWND );

    BOOL SaveChangedSelection( HWND );

    BOOL OnCBNSELCHANGE( HWND );

    BOOL ConvertToDuration ( ULONG , LPTSTR );

    LRESULT ParseDurationEntry( LPTSTR , PULONG );

    virtual int GetCBXSTATEindex( HWND ) = 0;

    BOOL OnCBEditChange( HWND );

    BOOL DoesContainDigits( LPTSTR );

    BOOL OnCBDropDown( HWND );

    BOOL IsToken( LPTSTR , TOKEN );

    BOOL LoadAbbreviates( );

    BOOL xxxLoadAbbreviate( PTOKTABLE );

    BOOL xxxUnLoadAbbreviate( PTOKTABLE );

};
#endif // _TODLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\todlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include <prsht.h>
#include "todlg.h"
#include "resource.h"

TOKTABLE tokday[ 4 ] = {
    { NULL , IDS_D },
    { NULL , IDS_DAY },
    { NULL , IDS_DAYS },
    { NULL , ( DWORD )-1 }
};

TOKTABLE tokhour[ 6 ] = {
    { NULL , IDS_H     },
    { NULL , IDS_HR    },
    { NULL , IDS_HRS   },
    { NULL , IDS_HOUR  },
    { NULL , IDS_HOURS },
    { NULL , ( DWORD )-1 }
};

TOKTABLE tokmin[ 5 ] = {
    { NULL , IDS_M       },
    { NULL , IDS_MIN     },
    { NULL , IDS_MINUTE  },
    { NULL , IDS_MINUTES },
    { NULL , ( DWORD )-1 }
};


TCHAR * GetNextToken( TCHAR *pszString , TCHAR *tchToken );

//-------------------------------------------------------------------------------
// CTimeOutDlg::ctor
//-------------------------------------------------------------------------------
CTimeOutDlg::CTimeOutDlg( )
{
    ZeroMemory( &m_cbxst , sizeof( CBXSTATE ) * 3 );
}

//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::InitControl( HWND hCtrl )
{
    int i = GetCBXSTATEindex( hCtrl );

    m_cbxst[ i ].icbxSel = ( int )SendMessage( hCtrl , CB_GETCURSEL , 0 , 0 );

    return TRUE;
}


//-------------------------------------------------------------------------------
// release the parent reference
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ReleaseAbbreviates( )
{
    xxxUnLoadAbbreviate( &tokday[0] );

    xxxUnLoadAbbreviate( &tokhour[0] );

    xxxUnLoadAbbreviate( &tokmin[0] );

    return TRUE;
}



//-------------------------------------------------------------------------------
// OnCommand
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtl , PBOOL pfPersisted )
{
    UNREFERENCED_PARAMETER( wID );

    switch( wNotifyCode )
    {

    case CBN_EDITCHANGE:

        if( OnCBEditChange( hwndCtl ) )
        {
            *pfPersisted = FALSE;
        }

        break;

    case CBN_SELCHANGE:

        if( OnCBNSELCHANGE( hwndCtl ) )
        {
            *pfPersisted = FALSE;
        }


    //case BN_CLICKED:

        break;

    case CBN_DROPDOWN:               // FALLTHROUGH

    case CBN_KILLFOCUS:

        OnCBDropDown( hwndCtl );

        break;

        //return FALSE;
/*
    case ALN_APPLY:

        SendMessage( GetParent( hwndCtl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
        */

    }

    // m_bPersisted = FALSE;
/*
    if( bChange )
    {
        SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
    }
    */

    return FALSE;

}

//-------------------------------------------------------------------------------
// Update the entry if it has been modified by user
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnCBDropDown( HWND hCombo )
{
    TCHAR tchBuffer[ 80 ];

    ULONG ulTime;

    int i = GetCBXSTATEindex( hCombo );

    if( i < 0 )
    {
        return FALSE;
    }

    if( m_cbxst[ i ].bEdit )
    {
        GetWindowText( hCombo , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );

        if( ParseDurationEntry( tchBuffer , &ulTime ) == E_SUCCESS )
        {
            InsertSortedAndSetCurSel( hCombo , ulTime );
        }

        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------------
// Use this flag to distinguish between hand entry or listbox selection
// setting it to true implies that the use has edit the cbx via typing
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnCBEditChange( HWND hCombo )
{
    int i = GetCBXSTATEindex( hCombo );

    if( i > -1 )
    {
        m_cbxst[ i ].bEdit = TRUE;

        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------------
// Determine if user wants to enter a custom time
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnCBNSELCHANGE( HWND hwnd )
{
    return SaveChangedSelection( hwnd );
}

//-------------------------------------------------------------------------------
// Saves selected item.
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::SaveChangedSelection( HWND hCombo )
{
    INT_PTR idx = SendMessage( hCombo , CB_GETCURSEL , 0 , 0 );

    int i = GetCBXSTATEindex( hCombo );

    if( i > -1 )
    {
        if( m_cbxst[ i ].icbxSel != idx )
        {
            m_cbxst[ i ].icbxSel = ( int )idx;

            m_cbxst[ i ].bEdit = FALSE;

            return TRUE;
        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// Restore previous setting
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::RestorePreviousValue( HWND hwnd )
{
    int iSel;

    if( ( iSel = GetCBXSTATEindex( hwnd ) ) > -1 )
    {
        SendMessage( hwnd , CB_SETCURSEL , m_cbxst[ iSel ].icbxSel , 0 );

        return TRUE;
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// ConvertToMinutes -- helper for CTimeOutDlg::OnNotify
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ConvertToMinutes( HWND hwndCtl , PULONG pulMinutes )
{
    TCHAR tchBuffer[ 80 ];

    TCHAR tchErrTitle[ 80 ];

    TCHAR tchErrMsg[ 256 ];

    TCHAR tchSetting[ 80 ];

    int idx = GetCBXSTATEindex( hwndCtl );

    if( idx < 0 )
    {
        return FALSE;
    }

    ASSERT( idx <= 2 );

    int resID = -1;

    if( idx == 0 )
    {
        resID = IDS_COMBO_CONNECTION;
    }
    else if( idx == 1 )
    {
        resID = IDS_COMBO_DISCONNECTION;
    }
    else if( idx == 2 )
    {
        resID = IDS_COMBO_IDLECONNECTION;
    }

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , resID , tchSetting , SIZE_OF_BUFFER( tchSetting ) ) );

    ULONG_PTR dw = ( ULONG_PTR )&tchSetting[ 0 ];

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) ) );

    if( m_cbxst[ idx ].bEdit )
    {
        DBGMSG( L"Automatic %s parsing\n" , tchSetting );

        if( GetWindowText( hwndCtl , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) < 1 )
        {
            *pulMinutes = 0;

            return TRUE;
        }

        LRESULT lr = ParseDurationEntry( tchBuffer , pulMinutes );

        if( lr != E_SUCCESS )
        {
            if( lr == E_PARSE_VALUEOVERFLOW )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TOOMANYDIGITS , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) );

                FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchErrMsg , 0 , 0 , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) , ( va_list * )&dw );

                MessageBox( hwndCtl , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );

                SetFocus( hwndCtl );
            }
            else if( lr == E_PARSE_MISSING_DIGITS || lr == E_PARSE_INVALID )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_PARSEINVALID , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) );

                FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchErrMsg , 0 , 0 , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) , ( va_list * )&dw );

                MessageBox( hwndCtl , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );

                SetFocus( hwndCtl );
            }
            return FALSE;
        }
    }
    else
    {
        ODS( L"Getting current selection\n" );

        INT_PTR iCurSel = SendMessage( hwndCtl , CB_GETCURSEL , 0 , 0 );

        // See if user wants "No Timeout"

        if( iCurSel == 0 )
        {
            *pulMinutes = 0;

           return TRUE;
        }

        if( ( *pulMinutes = ( ULONG )SendMessage( hwndCtl , CB_GETITEMDATA , iCurSel , 0 ) ) == CB_ERR  )
        {
            *pulMinutes = 0;
        }
    }

    if( *pulMinutes > kMaxTimeoutMinute )
    {
        LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_MAXVALEXCEEDED , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) );

        FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchErrMsg , 0 , 0 , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) , ( va_list * )&dw );

        MessageBox( hwndCtl , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );

        SetFocus( hwndCtl );

        return FALSE;
    }

    *pulMinutes *= kMilliMinute;

    return TRUE;
}

#if 0
//-------------------------------------------------------------------------------
// Lets cut to the chase and find out if this is even worth parsing
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::DoesContainDigits( LPTSTR pszString )
{
    while( *pszString )
    {
        if( iswdigit( *pszString ) )
        {
            return TRUE;
        }

        pszString++;
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
LRESULT CTimeOutDlg::ParseDurationEntry( LPTSTR pszTime , PULONG pTime )
{
    TCHAR tchNoTimeout[ 80 ];

    LPTSTR pszTemp = pszTime;

    UINT uDec = 0;

    float fFrac = 0.0f;

    float fT;

    UINT uPos = 1;

    LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchNoTimeout , SIZE_OF_BUFFER( tchNoTimeout ) );

    if( lstrcmpi( pszTime , tchNoTimeout ) == 0 )
    {
        *pTime = 0;

        return E_SUCCESS;
    }

    if( !DoesContainDigits( pszTime ) )
    {
        return E_PARSE_MISSING_DIGITS;
    }

    while( *pszTemp )
    {
        if( !iswdigit( *pszTemp ) )
        {
            break;
        }

        // check for overflow

        if( uDec >= 1000000000 )
        {
            return E_PARSE_VALUEOVERFLOW ;
        }

        uDec *= 10;

        uDec += ( *pszTemp - '0' );

        pszTemp++;

    }

    TCHAR tchSDecimal[ 5 ];

    GetLocaleInfo( LOCALE_USER_DEFAULT , LOCALE_SDECIMAL , tchSDecimal , SIZE_OF_BUFFER( tchSDecimal ) );

    if( *pszTemp == *tchSDecimal )
    {
        pszTemp++;

        while( *pszTemp )
        {
            if( !iswdigit( *pszTemp ) )
            {
                break;
            }

            // check for overflow

            if( uDec >= 1000000000 )
            {
                return E_PARSE_VALUEOVERFLOW;
            }

            uPos *= 10;

            fFrac += ( float )( *pszTemp - '0' ) / ( float )uPos;

            pszTemp++;
        }
    }

    // remove white space

    while( *pszTemp == L' ' )
    {
        pszTemp++;
    }


    if( *pszTemp != NULL )
    {
        if( IsToken( pszTemp , TOKEN_DAY ) )
        {
            *pTime = uDec * 24 * 60;

            fT = ( fFrac * 24.0f * 60.0f + 0.5f );

            *pTime += ( ULONG )fT;

            return E_SUCCESS;
        }
        else if( IsToken( pszTemp , TOKEN_HOUR ) )
        {
            *pTime = uDec * 60;

            fT = ( fFrac * 60.0f + 0.5f );

            *pTime += ( ULONG )fT;

            return E_SUCCESS;
        }
        else if( IsToken( pszTemp , TOKEN_MINUTE ) )
        {
            // minutes are rounded up in the 1/10 place

            fT = fFrac + 0.5f;

            *pTime = uDec;

            *pTime += ( ULONG )( fT );

            return E_SUCCESS;

        }

    }

    if( *pszTemp == NULL )
    {

        // if no text is defined considered the entry in hours

        *pTime = uDec * 60;

         fT = ( fFrac * 60.0f + 0.5f );

        *pTime += ( ULONG )fT ;

        return E_SUCCESS;
    }


    return E_PARSE_INVALID;

}

#endif


//-------------------------------------------------------------------------------
// Adds strings to table from resource
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::LoadAbbreviates( )
{
    xxxLoadAbbreviate( &tokday[0] );

    xxxLoadAbbreviate( &tokhour[0] );

    xxxLoadAbbreviate( &tokmin[0] );

    return TRUE;
}

//-------------------------------------------------------------------------------
// Take cares some repetitive work for us
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::xxxLoadAbbreviate( PTOKTABLE ptoktbl )
{
    int idx;

    int nSize;

    TCHAR tchbuffer[ 80 ];

    if( ptoktbl == NULL )
    {
        return FALSE;
    }

    for( idx = 0; ptoktbl[ idx ].dwresourceid != ( DWORD )-1 ; ++idx )
    {
        nSize = LoadString( _Module.GetResourceInstance( ) , ptoktbl[ idx ].dwresourceid , tchbuffer , SIZE_OF_BUFFER( tchbuffer ) );

        if( nSize > 0 )
        {
            ptoktbl[ idx ].pszAbbrv = ( TCHAR *)new TCHAR[ nSize + 1 ];

            if( ptoktbl[ idx ].pszAbbrv != NULL )
            {
                lstrcpy( ptoktbl[ idx ].pszAbbrv , tchbuffer );
            }
        }
    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// Frees up allocated resources
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::xxxUnLoadAbbreviate( PTOKTABLE ptoktbl )
{
    if( ptoktbl == NULL )
    {
        return FALSE;
    }

    for( int idx = 0; ptoktbl[ idx ].dwresourceid != ( DWORD )-1 ; ++idx )
    {
        if( ptoktbl[ idx ].pszAbbrv != NULL )
        {
            delete[] ptoktbl[ idx ].pszAbbrv;

        }
    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// tear-off token tables
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::IsToken( LPTSTR pszString , TOKEN tok )
{
    TOKTABLE *ptoktable;

    if( tok == TOKEN_DAY )
    {
        ptoktable = &tokday[0];
    }
    else if( tok == TOKEN_HOUR )
    {
        ptoktable = &tokhour[0];
    }
    else if( tok == TOKEN_MINUTE )
    {
        ptoktable = &tokmin[0];
    }
    else
    {
        return FALSE;
    }


    for( int idx = 0 ; ptoktable[ idx ].dwresourceid != -1 ; ++idx )
    {
        if( lstrcmpi( pszString , ptoktable[ idx ].pszAbbrv ) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;

}

#if 0
//-------------------------------------------------------------------------------
// Converts the number minutes into a formated string
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ConvertToDuration( ULONG ulTime , LPTSTR pszDuration )
{
    ULONG_PTR dw[3];

    TCHAR tchTimeUnit[ 40 ];

    TCHAR tchTimeFormat[ 40 ];

    TCHAR tchOutput[ 80 ];

    // ASSERT( ulTime != 0 );

    int iHour= ulTime / 60;

    int iDays = iHour / 24;

    dw[ 2 ] = ( ULONG_PTR )&tchTimeUnit[ 0 ];

    LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_DOT_DIGIT_TU , tchTimeFormat , SIZE_OF_BUFFER( tchTimeFormat ) );

    if( iDays != 0 )
    {
        int iRemainingHours = iHour % 24;

        float fx = ( float )iRemainingHours / 24.0f;

        iRemainingHours = ( int )( fx * 10 );

        LoadString( _Module.GetResourceInstance( ) , IDS_DAYS , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );

        dw[ 0 ] = iDays;

        dw[ 1 ] = iRemainingHours;

        if( iRemainingHours == 0 )
        {
            // formatted string requires two arguments

            dw[ 1 ] = ( ULONG_PTR )&tchTimeUnit[ 0 ];

            LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , SIZE_OF_BUFFER( tchTimeFormat ) );

            if( iDays == 1 )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_DAY , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
            }
        }

    }

    else if( iHour != 0 )
    {
        int iRemainingMinutes = ulTime % 60;

        float fx = ( float )iRemainingMinutes / 60.0f;

        iRemainingMinutes = ( int ) ( fx * 10 );

        dw[ 0 ] = iHour;

        dw[ 1 ] = iRemainingMinutes;

        LoadString( _Module.GetResourceInstance( ) , IDS_HOURS , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );

        if( iRemainingMinutes == 0 )
        {
            dw[ 1 ] = ( ULONG_PTR )&tchTimeUnit[ 0 ];

            LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , SIZE_OF_BUFFER( tchTimeFormat ) );

            if( iHour == 1 )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_HOUR , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
            }
        }
    }
    else
    {
        LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );

        LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , SIZE_OF_BUFFER( tchTimeFormat ) );

        dw[ 0 ] = ulTime ;

        dw[ 1 ] = ( ULONG_PTR )&tchTimeUnit[ 0 ];

        if( ulTime > 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTE , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }
    }

    FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchTimeFormat , 0 , 0 , tchOutput , SIZE_OF_BUFFER( tchOutput ) , ( va_list * )&dw );

    lstrcpy( pszDuration , tchOutput );

    return TRUE;
}

#endif

//-------------------------------------------------------------------------------
// Place entry in listbox and set as current selection
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::InsertSortedAndSetCurSel( HWND hCombo , DWORD dwMinutes )
{
    // ASSERT( dwMinutes != ( DWORD )-1 );

    TCHAR tchBuffer[ 80 ];

    INT_PTR iCount = SendMessage( hCombo , CB_GETCOUNT , 0 , 0 );

    for( INT_PTR idx = 0 ; idx < iCount ; ++idx )
    {
        // Don't insert an item that's already in the list

        if( dwMinutes == ( DWORD )SendMessage( hCombo , CB_GETITEMDATA , idx , 0 ) )
        {
            SendMessage( hCombo , CB_SETCURSEL , idx , 0 ) ;

            return TRUE;
        }

        if( dwMinutes < ( DWORD )SendMessage( hCombo , CB_GETITEMDATA , idx , 0 ) )
        {
            break;
        }
    }

    // hey if the value has exceeded the max timeout don't bother entering it in our list

    if( dwMinutes > kMaxTimeoutMinute )
    {
        return FALSE;
    }

    if( ConvertToDuration ( dwMinutes , tchBuffer ) )
    {
        idx = SendMessage( hCombo , CB_INSERTSTRING , idx , ( LPARAM )&tchBuffer[ 0 ] );

        if( idx != CB_ERR )
        {
            SendMessage( hCombo , CB_SETITEMDATA , idx , dwMinutes );

        }

        SendMessage( hCombo , CB_SETCURSEL , idx , 0 ) ;
    }

    // must call this here because CB_SETCURSEL does not send CBN_SELCHANGE

    SaveChangedSelection( hCombo );

    return TRUE;
}


/* Modified settings for a more readable time out settings
 * added 1/25/99
 * alhen
*/

//-------------------------------------------------------------------------------
// Removing decimal entries
//-------------------------------------------------------------------------------
LRESULT CTimeOutDlg::ParseDurationEntry( LPTSTR pszTime , PULONG pTime )
{
    TCHAR tchNoTimeout[ 80 ];

    LPTSTR pszTemp = pszTime;

    UINT uDec = 0;

    BOOL bSetDay  = FALSE;
    BOOL bSetHour = FALSE;
    BOOL bSetMin  = FALSE;
    BOOL bEOL     = FALSE;
    BOOL bHasDigit= FALSE;

    *pTime = 0;

    LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchNoTimeout , SIZE_OF_BUFFER( tchNoTimeout ) );

    if( lstrcmpi( pszTime , tchNoTimeout ) == 0 )
    {
        // *pTime = 0;

        return E_SUCCESS;
    }

    while( !bEOL )
    {
        // remove leading white spaces

        while( *pszTemp == L' ' )
        {
            pszTemp++;
        }

        while( *pszTemp )
        {
            if( !iswdigit( *pszTemp ) )
            {
                if( !bHasDigit )
                {
                    return E_PARSE_MISSING_DIGITS;
                }

                break;
            }

            // check for overflow

            if( uDec >= 1000000000 )
            {
                return E_PARSE_VALUEOVERFLOW ;
            }

            uDec *= 10;

            uDec += ( *pszTemp - '0' );

            if( !bHasDigit )
            {
                bHasDigit = TRUE;
            }

            pszTemp++;
        }

        // remove intermediate white spaces

        while( *pszTemp == L' ' )
        {
            pszTemp++;
        }

        if( *pszTemp != NULL )
        {
            // Get next token

            TCHAR tchToken[ 80 ];

            pszTemp = GetNextToken( pszTemp , tchToken );


            if( IsToken( tchToken , TOKEN_DAY ) )
            {
                if( !bSetDay )
                {
                    *pTime += uDec * 1440;

                    bSetDay = TRUE;
                }

            }
            else if( IsToken( tchToken , TOKEN_HOUR ) )
            {
                if( !bSetHour )
                {
                    *pTime += uDec * 60;

                    bSetHour = TRUE;
                }

            }
            else if( IsToken( tchToken , TOKEN_MINUTE ) )
            {
                if( !bSetMin )
                {
                    *pTime += uDec;

                    bSetMin = TRUE;
                }

            }
            else
            {
                return E_PARSE_INVALID;
            }

        }
        else
        {
            if( !bSetHour )
            {
                *pTime += uDec * 60;
            }

            bEOL = TRUE;
        }

        uDec = 0;

        bHasDigit = FALSE;

    }

    return E_SUCCESS;
}

//-------------------------------------------------------------------------------
// replacing older api
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ConvertToDuration( ULONG ulTime , LPTSTR pszDuration )
{
//    TCHAR dw[] = L"dhm";

    TCHAR tchTimeUnit[ 40 ];

    TCHAR tchTimeFormat[ 40 ];

    TCHAR tchOutput[ 80 ];

    ASSERT( ulTime != 0 );

    int iHour = ( ulTime / 60 );

    int iDays = iHour / 24;

    int iMinute = ulTime % 60;

    // Resolve format

    tchOutput[0] = 0;


    if( iDays > 0 )
    {
        if( iDays == 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_DAY , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_DAYS , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }

        iHour = iHour % 24;

        wsprintf( tchTimeFormat , L"%d %s", iDays , tchTimeUnit );

        lstrcat( tchOutput , tchTimeFormat );

        lstrcat( tchOutput , L" " );
    }

    if( iHour > 0 )
    {
        if( iHour == 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_HOUR , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_HOURS , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }

        wsprintf( tchTimeFormat , L"%d %s", iHour , tchTimeUnit );

        lstrcat( tchOutput , tchTimeFormat );

        lstrcat( tchOutput , L" " );
    }

    if( iMinute > 0 )
    {
        if( iMinute == 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTE , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }

        wsprintf( tchTimeFormat , L"%d %s", iMinute , tchTimeUnit );

        lstrcat( tchOutput , tchTimeFormat );

        lstrcat( tchOutput , L" " );
    }

    lstrcpy( pszDuration , tchOutput );

    return TRUE;

}

//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::DoesContainDigits( LPTSTR pszString )
{
    while( *pszString )
    {
        if( *pszString != L' ')
        {
            if( iswdigit( *pszString ) )
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }

            pszString++;
        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
TCHAR * GetNextToken( TCHAR *pszString , TCHAR *tchToken )
{
    while( *pszString )
    {
        if( IsCharAlpha( *pszString ) )
        {
            *tchToken = *pszString;
        }
        else
        {
            break;
        }

        tchToken++;

        pszString++;
    }

    *tchToken = '\0';

    return pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\tsprsht.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include"stdafx.h"
#include"tsprsht.h"
#include"resource.h"
#include"tarray.h"
#include<tscfgex.h>
#include<shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include "regapi.h"

void ErrMessage( HWND hwndOwner , INT_PTR iResourceID );

void TscAccessDeniedMsg( HWND hwnd );

void TscGeneralErrMsg( HWND hwnd );

void xxxErrMessage( HWND  , INT_PTR  , INT_PTR  , UINT  );

void ReportStatusError( HWND hwnd , DWORD dwStatus );

DWORD xxxLegacyLogoffCleanup( PSECURITY_DESCRIPTOR *ppSD , PBOOL );
//extern BOOL g_bEditMode = FALSE;

//
INT_PTR APIENTRY CustomSecurityDlgProc( HWND, UINT, WPARAM, LPARAM );

extern void EnableGroup( HWND hParent , LPINT rgID , BOOL bEnable );

//-----------------------------------------------------------------------------
typedef enum _AcluiApiIndex
{
    ACLUI_CREATE_PAGE = 0,
    ACLUI_EDIT_SECURITY
};

//-----------------------------------------------------------------------------
typedef struct _DLL_FUNCTIONS
{
    LPCSTR pcstrFunctionName;
    LPVOID lpfnFunction;
    HINSTANCE hInst;

} DLL_FUNCTIONS;

//-----------------------------------------------------------------------------
// not subject to localization
//-----------------------------------------------------------------------------
static DLL_FUNCTIONS g_aAclFunctions[] =
{
    "CreateSecurityPage", NULL, NULL ,
     NULL , NULL , NULL
};



//-----------------------------------------------------------------------------
CPropsheet::CPropsheet( )
{
    m_cref = 0;

    m_hNotify = 0;

    m_pResNode = NULL;

    m_bGotUC = FALSE;

    m_puc = NULL;

    m_bPropertiesChange = FALSE;

    m_hMMCWindow = NULL;
}

//-----------------------------------------------------------------------------
int CPropsheet::AddRef( )
{
    DBGMSG( L"Propsheet Refcount at %d\n", ( m_cref + 1 ) );

    return InterlockedIncrement( ( LPLONG )&m_cref );
}

//-----------------------------------------------------------------------------
// called before the destructor
//-----------------------------------------------------------------------------
void CPropsheet::PreDestruct( )
{
    ICfgComp *pCfgcomp = NULL;

    if( m_bPropertiesChange )
    {
        // check to see if any users are logged on

        LONG lCount;

        if( m_pResNode->GetServer( &pCfgcomp ) > 0 )
        {
            if( SUCCEEDED( pCfgcomp->QueryLoggedOnCount( m_pResNode->GetConName( ) , &lCount ) ) )
            {
                TCHAR tchTitle[ 80 ];

                TCHAR tchMessage[ 256 ];

                TCHAR tchBuffer[ 336 ];

                UINT nFlags = MB_OK | MB_ICONINFORMATION;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_TERMSERPROP , tchTitle , SIZE_OF_BUFFER( tchTitle ) ) );

                if( lCount > 0 )
                {
                    // Notify user that settings will not affect connected users

                    if( lCount == 1 )
                    {
                        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPCHANGE_WRN , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );
                    }
                    else if( lCount > 1 )
                    {
                        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPCHANGE_WRN_2, tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

                        wsprintf( tchBuffer , tchMessage , m_pResNode->GetConName( ) );
                    }

                    wsprintf( tchBuffer , tchMessage , m_pResNode->GetConName( ) );

                    if( m_hMMCWindow == NULL )
                    {
                        nFlags |= MB_TASKMODAL;
                    }

                    MessageBox( m_hMMCWindow , tchBuffer , tchTitle , MB_OK | MB_ICONINFORMATION );
                }
            }

            pCfgcomp->Release( );
        }

    }

    if( m_puc != NULL )
    {
        CoTaskMemFree( m_puc );
    }

    // FreeStrings( );

    g_aAclFunctions[ ACLUI_CREATE_PAGE ].lpfnFunction = NULL;

    for( INT x = 0; x < NUM_OF_PRSHT ; ++x )
    {
        if( m_pDlg[ x ] != NULL )
        {
            delete[] m_pDlg[x];
        }
    }

    m_pResNode->m_bEditMode = FALSE;
}

//-----------------------------------------------------------------------------
int CPropsheet::Release( )
{
    if( InterlockedDecrement( ( LPLONG )&m_cref ) == 0 )
    {
        MMCFreeNotifyHandle( m_hNotify );

        ODS( L"Propsheet Released\n" );

        PreDestruct( );

        delete this;

        return 0;
    }

    DBGMSG( L"Propsheet Refcount at %d\n", m_cref );

    return m_cref;
}

//-----------------------------------------------------------------------------
HRESULT CPropsheet::InitDialogs( HWND hMMC , LPPROPERTYSHEETCALLBACK pPsc , CResultNode *pResNode , LONG_PTR lNotifyHandle )
{
    PROPSHEETPAGE psp;

    if( pPsc == NULL || pResNode == NULL )
    {
        return E_INVALIDARG;
    }

    m_pResNode = pResNode;

    m_hNotify = lNotifyHandle;

    BOOL bAlloc = FALSE;

    m_hMMCWindow = hMMC;

    m_pResNode->m_bEditMode = TRUE;

    // init array

    for( int x = 0; x < NUM_OF_PRSHT; x++ )
    {
        m_pDlg[ x ] = NULL;
    }

    do
    {
        m_pDlg[ 0 ] = ( CDialogPropBase * )new CGeneral( this );

        if( m_pDlg[ 0 ] == NULL )
        {
            ODS( L"CGeneral object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        m_pDlg[ 1 ] = ( CDialogPropBase * )new CLogonSetting( this );

        if( m_pDlg[ 1 ] == NULL )
        {
            ODS( L"CLogonSetting object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        m_pDlg[ 2 ] = ( CDialogPropBase * )new CTimeSetting( this );

        if( m_pDlg[ 2 ] == NULL )
        {
            ODS( L"CTimeSetting object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        // m_pDlg[ 3 ] = ( CDialogPropBase * )new CPerm( this );

        m_pDlg[ 3 ] = ( CDialogPropBase * )new CEnviro( this );

        if( m_pDlg[ 3 ] == NULL )
        {
            ODS( L"CEnviro object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        m_pDlg[ 4 ] = ( CDialogPropBase * )new CRemote( this );

        if( m_pDlg[ 4 ] == NULL )
        {
            ODS( L"CRemote object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        m_pDlg[ 5 ] = ( CDialogPropBase * )new CClient( this );

        if( m_pDlg[ 5 ] == NULL )
        {
            ODS( L"CClient object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        m_pDlg[ 6 ] = ( CDialogPropBase * )new CTransNetwork( this );

        if( m_pDlg[ 6 ] == NULL )
        {
            ODS( L"CTransNetwork object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        m_pDlg[ 7 ] = ( CDialogPropBase * )new CTransAsync( this );

        if( m_pDlg[ 7 ] == NULL )
        {
            ODS( L"CTransAsync object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        bAlloc = TRUE;

    }while( 0 );

    if( !bAlloc )
    {
        // try cleaning up before leaving

        for( x = 0; x < NUM_OF_PRSHT ; ++x )
        {
            if( m_pDlg[ x ] != NULL )
            {
                delete[] m_pDlg[x];
            }
        }

        return E_OUTOFMEMORY;
    }

    for( int idx = 0; idx < 5; ++idx )
    {
        if( m_pDlg[ idx ] != NULL )
        {
            if( !m_pDlg[ idx ]->GetPropertySheetPage( psp ) )
            {
                return E_UNEXPECTED;
            }

            if( FAILED( pPsc->AddPage( CreatePropertySheetPage( &psp ) ) ) )
            {
                return E_FAIL;
            }

        }

    }

    HRESULT hr = E_FAIL;

    if( m_pResNode != NULL )
    {
        ICfgComp *pCfgcomp = NULL;

        PWS pWinsta = NULL;

        // don't fail here third party vendor may want to use their own page

        if( m_pResNode->GetServer( &pCfgcomp ) > 0 )
        {
            LONG cbSize;

            hr = pCfgcomp->GetWSInfo( m_pResNode->GetConName( ) , &cbSize , &pWinsta );

            if( SUCCEEDED( hr ) )
            {
                CDialogPropBase *pDlg = NULL;

                CDialogPropBase *pDlgClientSettings = m_pDlg[ 5 ]; // client settings

                if( pWinsta->PdClass == SdNetwork )
                {
                    pDlg = m_pDlg[ 6 ];
                }                
                else if( pWinsta->PdClass == SdAsync )
                {
                    pDlg = m_pDlg[ 7 ];
                }

                if( pDlg != NULL )
                {
                    if( !pDlgClientSettings->GetPropertySheetPage( psp ) )
                    {
                        ODS( L"Client settings page failed to load\n" );

                        hr = E_UNEXPECTED;
                    }

                    if( SUCCEEDED( hr ) )
                    {
                        hr = pPsc->AddPage( CreatePropertySheetPage( &psp ) );

                    }

                    if( SUCCEEDED( hr ) )
                    {
                        if( !pDlg->GetPropertySheetPage( psp ) )
                        {
                            ODS( L"Transport page failed to load\n" );

                            hr = E_UNEXPECTED;
                        }
                    }

                    if( SUCCEEDED( hr ) )
                    {
                        hr = pPsc->AddPage( CreatePropertySheetPage( &psp ) );
                    }
                }

                CoTaskMemFree( pWinsta );

            }

            pCfgcomp->Release();
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = pPsc->AddPage( GetSecurityPropertyPage( this ) );
    }

    return hr;

}

//The UC structure will contain data from a merger between the TSCC data and the machine policy data. We
//don't want all that written to the TSCC data though. If there's a machine policy for a given field, we
//want to replace its data with the data that currently exists in the TSCC section of the registry
BOOL CPropsheet::ExcludeMachinePolicySettings(USERCONFIG& uc)
{
    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);
    USERCONFIG origUC;

    //The default is to call GetUserConfig with a TRUE merge 
    //parameter, so we have to do that before we can call 
    //GetCurrentUserConfig which just returns the cached USERCONFIG structure
    if (!GetUserConfig(FALSE))
        return FALSE;
    if (!GetCurrentUserConfig(origUC, FALSE))
        return FALSE;
    //We have to do this so that the cached USERCONFIG structure 
    //will again have the expected (merged) data
    if (!GetUserConfig(TRUE))
        return FALSE;

    //CRemote fields
    if (p.fPolicyShadow)
    {
        uc.fInheritShadow = origUC.fInheritShadow;
        uc.Shadow = origUC.Shadow;
    }

    //CEnviro fields
    if (p.fPolicyInitialProgram)
    {
        uc.fInheritInitialProgram = origUC.fInheritInitialProgram;
        wcscpy(uc.InitialProgram, origUC.InitialProgram);
        wcscpy(uc.WorkDirectory, origUC.WorkDirectory);
    }

    //CClient fields
    if (p.fPolicyColorDepth)
    {
        uc.fInheritColorDepth = origUC.fInheritColorDepth;
        uc.ColorDepth = origUC.ColorDepth;
    }

    if (p.fPolicyForceClientLptDef)
        uc.fForceClientLptDef = origUC.fForceClientLptDef;
    
    if (p.fPolicyDisableCdm)
        uc.fDisableCdm = origUC.fDisableCdm;
    
    if (p.fPolicyDisableCpm)
        uc.fDisableCpm = origUC.fDisableCpm;

    if (p.fPolicyDisableLPT)
        uc.fDisableLPT = origUC.fDisableLPT;

    if (p.fPolicyDisableCcm)
        uc.fDisableCcm = origUC.fDisableCcm;

    if (p.fPolicyDisableClip)
        uc.fDisableClip = origUC.fDisableClip;

    if (p.fPolicyDisableCam)
        uc.fDisableCam = origUC.fDisableCam;

    //CLogonSetting fields
    if (p.fPolicyPromptForPassword)
        uc.fPromptForPassword = origUC.fPromptForPassword;

    //CGeneral fields
    if (p.fPolicyMinEncryptionLevel)
        uc.MinEncryptionLevel = origUC.MinEncryptionLevel;

    //CTimeSetting fields
    if (p.fPolicyMaxSessionTime)
        uc.MaxConnectionTime = origUC.MaxConnectionTime;

    if (p.fPolicyMaxDisconnectionTime)
        uc.MaxDisconnectionTime = origUC.MaxDisconnectionTime;

    if (p.fPolicyMaxIdleTime)
        uc.MaxIdleTime = origUC.MaxIdleTime;

    if (p.fPolicyResetBroken)
        uc.fResetBroken = origUC.fResetBroken;

    if (p.fPolicyReconnectSame)
        uc.fReconnectSame = origUC.fReconnectSame;

    if (p.fPolicyMaxSessionTime || p.fPolicyMaxDisconnectionTime || p.fPolicyMaxIdleTime)
        uc.fInheritMaxSessionTime = origUC.fInheritMaxSessionTime;
    
    if (p.fPolicyResetBroken)
        uc.fInheritResetBroken = origUC.fInheritResetBroken;

    if (p.fPolicyReconnectSame)
        uc.fInheritReconnectSame = origUC.fInheritReconnectSame;

    return TRUE;
}



//-------------------------------------------------------------------------------
// Use custom interface to persist uc to winstation
//-------------------------------------------------------------------------------
HRESULT CPropsheet::SetUserConfig( USERCONFIG& uc , PDWORD pdwStatus )
{
    ICfgComp *pCfgcomp;

    *pdwStatus = ERROR_INVALID_PARAMETER;

    if( m_pResNode == NULL )
        return E_FAIL;

    if( m_pResNode->GetServer( &pCfgcomp ) == 0 )
        return E_FAIL;

    if (!ExcludeMachinePolicySettings(uc))
        return E_FAIL;

    HRESULT hr = pCfgcomp->SetUserConfig( m_pResNode->GetConName( ) , sizeof( USERCONFIG ) , &uc , pdwStatus );

    if( SUCCEEDED( hr ) )
    {
        m_bGotUC = FALSE;
    }


    pCfgcomp->Release( );

    return hr;

}

//-------------------------------------------------------------------------------
// Use custom interface to obtain the winstation userconfig
// store it in m_puc -- and return t | f
//-------------------------------------------------------------------------------
BOOL CPropsheet::GetUserConfig(BOOLEAN bPerformMerger)
{
    ICfgComp *pCfgcomp;

    if( m_pResNode == NULL )
    {
        return FALSE;
    }

    if( m_pResNode->GetServer( &pCfgcomp ) == 0 )
    {
        return FALSE;
    }

    LONG lSzReqd;

    if( m_puc != NULL )
    {
        CoTaskMemFree( m_puc );

        m_puc = NULL;
    }

    HRESULT hr = pCfgcomp->GetUserConfig( m_pResNode->GetConName( ) , &lSzReqd , &m_puc, bPerformMerger );

    if( FAILED( hr ) )
    {
        hr = pCfgcomp->GetDefaultUserConfig( m_pResNode->GetConName( ) , &lSzReqd , &m_puc );
    }

    pCfgcomp->Release( );
    
    return ( FAILED( hr ) ? FALSE: TRUE );

}

//-------------------------------------------------------------------------------
// Cache the uc
//-------------------------------------------------------------------------------
BOOL CPropsheet::GetCurrentUserConfig( USERCONFIG& uc, BOOLEAN bPerformMerger )
{
    if( !m_bGotUC )
    {
        m_bGotUC = GetUserConfig(bPerformMerger);
    }

    if( m_puc != NULL )
    {
        uc = *m_puc;
    }

    return m_bGotUC;
}

//*******************************************************************************
//-------------------------------------------------------------------------------
// OnNotify - base class method
//-------------------------------------------------------------------------------
BOOL CDialogPropBase::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    UNREFERENCED_PARAMETER( idCtrl );

    if( pnmh->code == PSN_APPLY )
    {
        if( !m_bPersisted )
        {
            m_bPersisted = PersistSettings( hDlg );
        }
    }

    else if( pnmh->code == PSN_KILLACTIVE )
    {
        if( !m_bPersisted )
        {
            if( !IsValidSettings( hDlg ) )
            {
                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , PSNRET_INVALID_NOCHANGEPAGE );

                return TRUE;
            }

        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// OnCOntextMenu -- base class operation
//-------------------------------------------------------------------------------
BOOL CDialogPropBase::OnContextMenu( HWND hwnd , POINT& pt )
{
    UNREFERENCED_PARAMETER( pt );

    TCHAR tchHelpFile[ MAX_PATH ];

    ODS( L"CDialogPropBase::OnContextMenu\n" );

    if( m_hWnd == GetParent( hwnd ) )
    {
        //
        // Make sure its not a dummy window
        //

        if( GetDlgCtrlID( hwnd ) <= ( int )-1 )
        {
            return FALSE;
        }

        ULONG_PTR rgdw[ 2 ];

        rgdw[ 0 ] = GetDlgCtrlID( hwnd );

        rgdw[ 1 ] = GetWindowContextHelpId( hwnd );

        LoadString( _Module.GetModuleInstance( ) , IDS_HELPFILE , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) );

        WinHelp( hwnd , tchHelpFile , HELP_CONTEXTMENU , ( ULONG_PTR )&rgdw );

    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// Each control has a helpid assign to them.  Some controls share the same topic
// check for these.
//-------------------------------------------------------------------------------
BOOL CDialogPropBase::OnHelp( HWND hwnd , LPHELPINFO lphi )
{
    UNREFERENCED_PARAMETER( hwnd );

    TCHAR tchHelpFile[ MAX_PATH ];

    //
    // For the information to winhelp api
    //

    if( IsBadReadPtr( lphi , sizeof( HELPINFO ) ) )
    {
        return FALSE;
    }

    if( lphi->iCtrlId <= -1 )
    {
        return FALSE;
    }

    LoadString( _Module.GetModuleInstance( ) , IDS_HELPFILE , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) );

    ULONG_PTR rgdw[ 2 ];

    rgdw[ 0 ] = ( ULONG_PTR )lphi->iCtrlId;

    rgdw[ 1 ] = ( ULONG_PTR )lphi->dwContextId;

    WinHelp( ( HWND )lphi->hItemHandle , tchHelpFile , HELP_WM_HELP , ( ULONG_PTR )&rgdw );//lphi->dwContextId );

    return TRUE;
}

//*****************************************************************************
//                  General dialog

CGeneral::CGeneral( CPropsheet *pSheet )
{
    m_pParent = pSheet;

    m_pEncrypt = NULL;

    m_DefaultEncryptionLevelIndex = 0;

    m_nOldSel = ( INT_PTR )-1;
}

//-----------------------------------------------------------------------------
BOOL CGeneral::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    if( m_pParent == NULL )
    {
        ODS( L"CGeneral::OnInitDialog - PropertySheet: Parent object lost!!!\n" );

        return FALSE;
    }

    m_pParent->AddRef( );

    USERCONFIG uc;

    ZeroMemory( &uc , sizeof( USERCONFIG ) );

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        ODS( L"CGeneral::OnInitDialog - PropertySheet: GetCurrentUserConfig failed!!!\n" );

        return FALSE;
    }

    // Security

    SendMessage( GetDlgItem( hDlg , IDC_CHECK_GEN_AUTHEN ) , BM_SETCHECK , ( WPARAM )uc.fUseDefaultGina , 0 );

    // Network Transport

    if( m_pParent->m_pResNode == NULL )
    {
        return FALSE;
    }

    ICfgComp *pCfgcomp;

    ULONG cbSize = 0;

    ULONG ulItems = 0;

    do
    {
        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
        {
            break;
        }

        // Set Connection name

        SetWindowText( GetDlgItem( hDlg , IDC_STATIC_CONNAME ) , m_pParent->m_pResNode->GetConName( ) );

        PWS pWinSta = NULL;

        if( SUCCEEDED( pCfgcomp->GetWSInfo( m_pParent->m_pResNode->GetConName( ) , ( PLONG )&cbSize , &pWinSta ) ) )
        {

            SendMessage( GetDlgItem( hDlg , IDC_EDIT_GEN_COMMENT ) , EM_SETLIMITTEXT , ( WPARAM )WINSTATIONCOMMENT_LENGTH , 0 );

            SetWindowText( GetDlgItem( hDlg , IDC_EDIT_GEN_COMMENT ) , pWinSta->Comment );

            //m_pParent->m_pResNode->GetComment( ) );

            SetWindowText( GetDlgItem( hDlg , IDC_STATIC_GEN_TYPE ) , m_pParent->m_pResNode->GetTypeName( ) );

            SetWindowText(  GetDlgItem( hDlg , IDC_EDIT_GENERAL_TRANSPORT ) , pWinSta->pdName );

            // security

            // Encryption *pEncrypt;

            if( SUCCEEDED( pCfgcomp->GetEncryptionLevels( m_pParent->m_pResNode->GetConName( ) , WsName , &ulItems , &m_pEncrypt ) ) )
            {
                BOOL bSet = FALSE;

                for( ULONG i = 0; i < ulItems; ++i )
                {
                    SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT ) , CB_ADDSTRING , 0 , ( LPARAM )m_pEncrypt[ i ].szLevel );
                    if(m_pEncrypt[ i ].Flags & ELF_DEFAULT)
                    {
                        m_DefaultEncryptionLevelIndex = i;
                    }

                    if( uc.MinEncryptionLevel == m_pEncrypt[ i ].RegistryValue )
                    {
                        SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT ) , CB_SETCURSEL ,  ( WPARAM )i , 0);

                        bSet = TRUE;

                    }
                }

                POLICY_TS_MACHINE p;
                RegGetMachinePolicy(&p);
                EnableWindow(GetDlgItem(hDlg, IDC_COMBO_GEN_ENCRYPT), !p.fPolicyMinEncryptionLevel);

                if(!bSet)
                {
                    uc.MinEncryptionLevel = (UCHAR)(m_pEncrypt[m_DefaultEncryptionLevelIndex].RegistryValue);

                    SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT ) , CB_SETCURSEL ,  ( WPARAM )m_DefaultEncryptionLevelIndex, 0 );
                }

                OnCommand( CBN_SELCHANGE , IDC_COMBO_GEN_ENCRYPT , GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT ) );

                if( !IsWindowEnabled( GetDlgItem( hDlg , IDC_STATIC_GEN_DESCR ) ) )
                {
                    RECT rc;
                    RECT rc2;

                    GetWindowRect( GetDlgItem( hDlg , IDC_STATIC_CONGRP ) , &rc );

                    GetWindowRect( GetDlgItem( hDlg , IDC_STATIC_GEN_DESCR ) , &rc2 );

                    rc.bottom = rc2.top;

                    MapWindowPoints( NULL , hDlg , ( LPPOINT )&rc , 2 );

                    SetWindowPos( GetDlgItem( hDlg , IDC_STATIC_CONGRP ) , 0 , 0 , 0 , rc.right - rc.left , rc.bottom - rc.top , SWP_NOMOVE | SWP_SHOWWINDOW );


                    //resize window
                }
            }
            else
            {
                // no encryption info insert value to none and grey out the control
                TCHAR tchNone[ 80 ];

                LoadString( _Module.GetResourceInstance( ) , IDS_NONE , tchNone , SIZE_OF_BUFFER( tchNone ) );

                SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT )  , CB_ADDSTRING , 0 , ( LPARAM )tchNone );

                SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT )  , CB_SETCURSEL , 0 , 0 );

                EnableWindow( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT )  , FALSE );

                EnableWindow( GetDlgItem( hDlg , IDC_STATIC_CONGRP )  , FALSE );
            }

            CoTaskMemFree( pWinSta );
        }

        // check to see if session is readonly

        BOOL bReadOnly;

        if( SUCCEEDED( pCfgcomp->IsSessionReadOnly( &bReadOnly ) ) )
        {
            if( bReadOnly )
            {
                // make edit controls read-only

                SendMessage( GetDlgItem( hDlg , IDC_EDIT_GEN_COMMENT ) , EM_SETREADONLY , ( WPARAM )TRUE , 0 );

                // disable the remaining controls
                INT rgIds[] = {  IDC_CHECK_GEN_AUTHEN , IDC_STATIC_CONGRP, IDC_COMBO_GEN_ENCRYPT , -1 };

                EnableGroup( hDlg , &rgIds[ 0 ] , FALSE );
            }
        }

        pCfgcomp->Release( );


    }while( 0 );

   m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hDlg , wp , lp );
}


//-----------------------------------------------------------------------------
INT_PTR CALLBACK CGeneral::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CGeneral *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CGeneral *pDlg = ( CGeneral * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CGeneral ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CGeneral * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CGeneral ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

       pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CGeneral::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED || wNotifyCode == EN_CHANGE )
    {
        m_bPersisted = FALSE;
    }
    else if( wNotifyCode == CBN_SELCHANGE && wID == IDC_COMBO_GEN_ENCRYPT )
    {
        if( SendMessage( hwndCtrl , CB_GETDROPPEDSTATE , 0 , 0 ) == FALSE )
        {
            INT_PTR nSel = SendMessage( hwndCtrl , CB_GETCURSEL , 0 , 0 );

            if( nSel != CB_ERR )
            {
                if( nSel != m_nOldSel && m_pEncrypt != NULL )
                {
                    if( m_pEncrypt[ nSel ].szDescr[ 0 ] == 0 )
                    {
                        EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCRTITLE ) , FALSE );

                        EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCR ) , FALSE );

                        ShowWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCRTITLE ) , SW_HIDE );

                        ShowWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCR ) , SW_HIDE );
                    }
                    else
                    {
                        ShowWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCRTITLE ) , SW_SHOW  );

                        ShowWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCR ) , SW_SHOW );

                        EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCR ) , TRUE );

                        EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCRTITLE ) , TRUE );

                        SetWindowText( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCR ) ,  m_pEncrypt[ nSel ].szDescr );
                    }

                    m_bPersisted = FALSE;

                    m_nOldSel = nSel;
                }
            }
        }

    }
    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }


    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;
}


//-----------------------------------------------------------------------------
BOOL CGeneral::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_GENERAL );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CGeneral::DlgProc;

    return TRUE;

}

//-----------------------------------------------------------------------------
BOOL CGeneral::PersistSettings( HWND hDlg )
{
    HRESULT hr;

    if( IsValidSettings( hDlg ) )
    {
        ICfgComp *pCfgcomp;

        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
        {
            return FALSE;
        }

        WS *pWinsta = NULL;

        LONG lSize = 0;

        hr = pCfgcomp->GetWSInfo( m_pParent->m_pResNode->GetConName( ) , &lSize , &pWinsta );

        if( SUCCEEDED( hr ) )
        {
            GetWindowText( GetDlgItem( hDlg , IDC_EDIT_GEN_COMMENT ) , pWinsta->Comment , WINSTATIONCOMMENT_LENGTH + 1 );

            m_pParent->m_pResNode->SetComment( pWinsta->Comment , lstrlen( pWinsta->Comment ) );

            DWORD dwStatus;

            hr = pCfgcomp->UpDateWS( pWinsta , UPDATE_COMMENT , &dwStatus, FALSE );

            if( FAILED( hr ) )
            {
                // report error

                ReportStatusError( GetDlgItem( hDlg , IDC_EDIT_GEN_COMMENT ) , dwStatus );
            }

            CoTaskMemFree( pWinsta );
        }

        if( SUCCEEDED( hr ) )
        {

            USERCONFIG uc;

            if( m_pParent->GetCurrentUserConfig( uc, TRUE ) )
            {
                if( m_pEncrypt != NULL )
                {
                    UINT index = ( UCHAR )SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT ) , CB_GETCURSEL , 0 , 0 );

                    if(index == CB_ERR )
                    {
                        uc.MinEncryptionLevel =(UCHAR) m_pEncrypt[m_DefaultEncryptionLevelIndex].RegistryValue;
                    }
                    else
                    {
                        uc.MinEncryptionLevel = (UCHAR) m_pEncrypt[index].RegistryValue;
                    }
                }
                else
                {
                    uc.MinEncryptionLevel = 0;
                }

                uc.fUseDefaultGina = SendMessage( GetDlgItem( hDlg , IDC_CHECK_GEN_AUTHEN ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED;

                DWORD dwStatus = 0;

                hr = m_pParent->SetUserConfig( uc , &dwStatus );

                if( FAILED( hr ) )
                {
                    // report error

                    ReportStatusError( hDlg , dwStatus );
                }
            }
        }

        if( SUCCEEDED( hr ) )
        {
            ODS( L"TSCC : Forcing reg update on General Page\n" );

            VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

            VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

            // global flag can only be set to true

            m_pParent->m_bPropertiesChange = TRUE;

            PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

            SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

            return TRUE;
        }


        pCfgcomp->Release( );
    }

    return FALSE;
}


//-----------------------------------------------------------------------------
BOOL CGeneral::OnDestroy( )
{
    if( m_pEncrypt != NULL )
    {
        CoTaskMemFree( m_pEncrypt );

        m_pEncrypt = NULL;
    }

    m_pParent->Release( );

    return CDialogPropBase::OnDestroy( );

}

//*****************************************************************************

CTransNetwork::CTransNetwork( CPropsheet *pSheet )
{
    ASSERT( pSheet != NULL );

    m_pParent = pSheet;

    // this now behaves as the last combx selection

    m_ulOldLanAdapter = ( ULONG )-1;

    m_oldID = ( WORD )-1;

    m_uMaxInstOld = ( ULONG )-1;

}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CTransNetwork::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CTransNetwork *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CTransNetwork *pDlg = ( CTransNetwork * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CTransNetwork ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CTransNetwork * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CTransNetwork ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }

    return FALSE;

}

//-----------------------------------------------------------------------------
BOOL CTransNetwork::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    BOOL bReadOnly;
    HICON hIcon;

    m_pParent->AddRef( );

    SendMessage( GetDlgItem( hDlg , IDC_SPINCTR_GEN ) , UDM_SETRANGE32 , 0 , ( LPARAM )999999 );

    if( m_pParent->m_pResNode == NULL )
    {
        return FALSE;
    }

    ICfgComp *pCfgcomp = NULL;

    ULONG cbSize = 0;

    ULONG ulItems = 0;

    PGUIDTBL pGuidtbl = NULL;

    m_bPersisted = TRUE;

    do
    {
        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
        {
            ODS( L"CTransNetwork::OnInitDialog - GetServer failed\n" );

            break;
        }

        WS *pWinSta = NULL;

        if( FAILED( pCfgcomp->GetWSInfo( m_pParent->m_pResNode->GetConName( ) , ( PLONG )&cbSize , &pWinSta ) ) )
        {
            ODS( L"TSCC: GetWSInfo failed in TransNetwork::OnInitDialog\n" );

            break;
        }

        ISettingsComp* pISettingComp = NULL;
        HRESULT hr;
        DWORD dwStatus;
        DWORD nVal;        

        hr = pCfgcomp->QueryInterface( IID_ISettingsComp, (void **) &pISettingComp );

        //
        // Assume we are not remote admin if anything go wrong
        //
        m_RemoteAdminMode = FALSE;

        if( SUCCEEDED(hr) && NULL != pISettingComp )
        {
            hr = pISettingComp->GetTermSrvMode( &nVal, &dwStatus );
            if( SUCCEEDED(hr) && nVal == 0 )
            {
                // we are in RA mode
                m_RemoteAdminMode = TRUE;
            }

            pISettingComp->Release();
        }

        if( FAILED(hr) )
        {
            //
            // QueryInterface() or GetTermSrvMode() failed
            // bring up a error message
            //
            TCHAR tchMessage[ 256 ];

            TCHAR tchWarn[ 40 ];

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ERR_TERMSRVMODE , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWarn , SIZE_OF_BUFFER( tchWarn ) ) );

            MessageBox( hDlg , tchMessage , tchWarn , MB_ICONWARNING | MB_OK );

        }


        // certain operations cannot be performed if the user is not part of the admin group

        pCfgcomp->IsSessionReadOnly( &bReadOnly );


        // Set Connection name

        SetWindowText( GetDlgItem( hDlg , IDC_STATIC_CONNAME ) , m_pParent->m_pResNode->GetConName( ) );

        // List all supported lan adapters for transport type

        ULONG idx;

        if( SUCCEEDED( pCfgcomp->GetLanAdapterList2( m_pParent->m_pResNode->GetTTName() , &ulItems , &pGuidtbl ) ) )
        {
            // verify table is valid

            BOOL bFound = FALSE;

            for( idx = 0 ; idx < ulItems ; ++idx )
            {
                if( pGuidtbl[ idx ].dwStatus != ERROR_SUCCESS && !bReadOnly )
                {
                    pCfgcomp->BuildGuidTable( &pGuidtbl , ulItems , m_pParent->m_pResNode->GetTTName() );

                    break;
                }
            }

            for( idx = 0 ; idx < ulItems ; ++idx )
            {
                if( pGuidtbl[ idx ].dwLana == pWinSta->LanAdapter )
                {
                    bFound = TRUE;

                    break;
                }
            }

            if( !bFound )
            {
                if( !bReadOnly )
                {
                    // Notify user we must rebuild guid table
                    TCHAR tchMessage[ 256 ];

                    TCHAR tchTitle[ 80 ];

                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_INVALNETWORK , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_TSCERRTITLE , tchTitle , SIZE_OF_BUFFER( tchTitle ) ) );

                    MessageBox( hDlg , tchMessage , tchTitle , MB_OK | MB_ICONINFORMATION );

                    m_bPersisted = FALSE;

                    SendMessage( GetParent( hDlg ) , PSM_CHANGED , ( WPARAM )hDlg , 0 );
                }

                // reset lana index

                pWinSta->LanAdapter = ( DWORD )-1;

            }

            for( idx = 0 ; idx < ulItems; ++idx )
            {
                if( pGuidtbl[ idx ].dwLana == pWinSta->LanAdapter )
                {
                    // make sure we only set this once
                    // invalid entries will have dwLana set to zero

                    if( m_ulOldLanAdapter == ( DWORD )-1 )
                    {
                        m_ulOldLanAdapter = idx;
                    }
                }

                SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_ADDSTRING , 0 , ( LPARAM )pGuidtbl[ idx ].DispName );

                SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_SETITEMDATA , idx , ( LPARAM )pGuidtbl[ idx ].dwLana );
            }

            CoTaskMemFree( pGuidtbl );
        }


        SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_SETCURSEL , ( WPARAM )m_ulOldLanAdapter , 0 );


        if( !m_bPersisted )
        {
            // force IsValidSettings to confirm on the lana uniqueness

            m_ulOldLanAdapter = ( DWORD )-1;
        }


        /*
        if( SUCCEEDED( pCfgcomp->GetLanAdapterList( m_pParent->m_pResNode->GetTTName() , &ulItems , &cbSize , ( WCHAR ** )&pdnw ) ) )
        {
            for( ULONG i = 0 ; i < ulItems ; i++ )
            {
                SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_ADDSTRING , 0 , ( LPARAM )pdnw[ i ] );
            }

            CoTaskMemFree( pdnw );
        }
        */


        // SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_SETCURSEL , ( WPARAM )pWinSta->LanAdapter , 0 );

        // m_ulOldLanAdapter = pWinSta->LanAdapter;

        // unlimited connections

        TCHAR tchBuf[ 6 ];      // max digits

        m_uMaxInstOld = pWinSta->uMaxInstanceCount;
        SendMessage( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , EM_SETLIMITTEXT , SIZE_OF_BUFFER( tchBuf )  , 0  );


        if( TRUE == m_RemoteAdminMode )
        {
            hIcon = LoadIcon( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDI_ICON_WARNING ) );

            hIcon = ( HICON )LoadImage( _Module.GetModuleInstance( ) ,
                                        MAKEINTRESOURCE( IDI_ICON_WARNING ) ,
                                        IMAGE_ICON,
                                        0,
                                        0,
                                        0 );

            SendMessage( GetDlgItem( hDlg , IDC_USERPERM_ICON ) , STM_SETICON , ( WPARAM )hIcon , 0 );

            ShowWindow( GetDlgItem( hDlg , IDC_USERPERM_ICON ), SW_SHOW );
            
            ShowWindow( GetDlgItem( hDlg , IDC_TSMSTATIC_RA ), SW_SHOW );

            wsprintf( 
                    tchBuf , 
                    L"%d" , 
                    (pWinSta->uMaxInstanceCount > 2 || pWinSta->uMaxInstanceCount == (ULONG) -1) ? 2 : pWinSta->uMaxInstanceCount 
                );
            SetWindowText( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , tchBuf );

            SendMessage( GetDlgItem( hDlg , IDC_CHECK_GEN_UNLIMITED ) , BM_SETCHECK , ( WPARAM )FALSE , 0 );

            SendMessage( GetDlgItem( hDlg , IDC_RADIO_MAXPROP) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            SendMessage( GetDlgItem( hDlg , IDC_SPINCTR_GEN ) , UDM_SETRANGE32 , 0 , ( LPARAM )2 );

        }
        else
        {
            BOOL bUnlimitedConnections = (pWinSta->uMaxInstanceCount == (ULONG)-1);

            SendMessage(GetDlgItem(hDlg, IDC_CHECK_GEN_UNLIMITED), BM_SETCHECK, 
                (WPARAM)(bUnlimitedConnections), 0);

            SendMessage(GetDlgItem(hDlg, IDC_RADIO_MAXPROP), BM_SETCHECK,
                (WPARAM)(!bUnlimitedConnections), 0);

            POLICY_TS_MACHINE p;
            RegGetMachinePolicy(&p);

            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_GEN_UNLIMITED), !p.fPolicyMaxInstanceCount);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MAXPROP), !p.fPolicyMaxInstanceCount);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_GEN_MAXCONS), !bUnlimitedConnections && !p.fPolicyMaxInstanceCount);
            EnableWindow(GetDlgItem(hDlg, IDC_SPINCTR_GEN), !bUnlimitedConnections && !p.fPolicyMaxInstanceCount);

            if (!bUnlimitedConnections)
            {
                wsprintf(tchBuf, L"%d", pWinSta->uMaxInstanceCount);
                SetWindowText(GetDlgItem(hDlg, IDC_EDIT_GEN_MAXCONS), tchBuf);
                m_oldID = IDC_RADIO_MAXPROP;
            }
            else
                m_oldID = IDC_CHECK_GEN_UNLIMITED;
        }

        CoTaskMemFree( pWinSta );

        if( bReadOnly || m_RemoteAdminMode )
        {
            // disable the remaining controls

            // Disable Unlimited connections
            EnableWindow( GetDlgItem( hDlg, IDC_CHECK_GEN_UNLIMITED ), FALSE );

            // purely cosmetic, on m_RemoteAdminMode, we enable this control 
            EnableWindow( GetDlgItem( hDlg, IDC_RADIO_MAXPROP ), !bReadOnly );

            //
            // if we are read only, disable the window, in remote admin mode, we still let
            // user pick a NIC card, if this is read onlu (user not in admin group), bReadOnly
            // will be TRUE which will disable static text and combo box.
            //

            EnableWindow( GetDlgItem( hDlg, IDC_STATIC_NA ), !bReadOnly );

            EnableWindow( GetDlgItem( hDlg, IDC_COMBO_GEN_LANADAPTER ), !bReadOnly );

            // if user have only read access, disable MAX connection and its associated spin control
            EnableWindow( GetDlgItem( hDlg, IDC_EDIT_GEN_MAXCONS ), !bReadOnly );

            EnableWindow( GetDlgItem( hDlg, IDC_SPINCTR_GEN ), !bReadOnly );
        }

        pCfgcomp->Release( );

    }while( 0 );

    return CDialogPropBase::OnInitDialog( hDlg , wp , lp );

}

//-----------------------------------------------------------------------------
BOOL CTransNetwork::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_NETWORK_FACE );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CTransNetwork::DlgProc;

    return TRUE;

}

//-----------------------------------------------------------------------------
BOOL CTransNetwork::OnDestroy( )
{
    m_pParent->Release( );

    return CDialogPropBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CTransNetwork::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED || wNotifyCode == EN_CHANGE )// || wNotifyCode == CBN_SELCHANGE )
    {
        if( wID == IDC_CHECK_GEN_UNLIMITED )
        {
            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_GEN_MAXCONS ) ,

                SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );

            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_SPINCTR_GEN ) ,

                SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );

            SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_RADIO_MAXPROP),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);


        }

		else if(wID == IDC_RADIO_MAXPROP)
		{
            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_GEN_MAXCONS ) ,

                SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED );

            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_SPINCTR_GEN ) ,

                SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED );

            SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_GEN_UNLIMITED),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);

            SetFocus( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_GEN_MAXCONS ) );

            SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_GEN_MAXCONS ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

		}

        if( wID != m_oldID )
        {
            m_bPersisted = FALSE;

            // this could come from EN_CHANGE -- so don't save the current control id

            if( wID != IDC_EDIT_GEN_MAXCONS )
            {
                m_oldID = wID;
            }
        }

    }
    else if( wNotifyCode == CBN_SELCHANGE )
    {
        INT_PTR iSel = SendMessage( hwndCtrl , CB_GETCURSEL , 0 , 0 );

        if( iSel != ( INT_PTR )m_ulOldLanAdapter )
        {
            m_bPersisted = FALSE;
        }
    }


    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CTransNetwork::PersistSettings( HWND hDlg )
{
    BOOL bOk = FALSE;

    if( IsValidSettings( hDlg ) )
    {
        ICfgComp *pCfgcomp;

        bOk = TRUE;

        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
        {
            return FALSE;
        }

        WS winsta;

        ZeroMemory( &winsta , sizeof( WS ) );

        // winsta.LanAdapter = ( ULONG )SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_GETCURSEL , 0 , 0 );

        //If a group policy exists, its data will be in the winsta structure. We don't want to write that to 
        //the TSCC registry, so read the TSCC data by getting the User Config without merging the machine policy
        POLICY_TS_MACHINE p;
        RegGetMachinePolicy(&p);

        if (p.fPolicyMaxInstanceCount)
        {
            POLICY_TS_MACHINE pTemp;
            ULONG Length = 0;
            WINSTATIONCONFIG2W WSConfig;
        
            memset(&pTemp, 0, sizeof(POLICY_TS_MACHINE));
            if((ERROR_SUCCESS != RegWinStationQueryEx(NULL,&pTemp,m_pParent->m_pResNode->GetConName( ),&WSConfig,sizeof(WINSTATIONCONFIG2W),&Length,FALSE)))
                return FALSE;

            winsta.uMaxInstanceCount = WSConfig.Create.MaxInstanceCount;
        }
        else
        {
            if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_GEN_UNLIMITED ), BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
                winsta.uMaxInstanceCount = ( ULONG )-1;
            else
                winsta.uMaxInstanceCount = GetDlgItemInt( hDlg , IDC_EDIT_GEN_MAXCONS , &bOk , FALSE );
        }

        INT_PTR iSel = SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_GETCURSEL , 0 , 0 );

        winsta.LanAdapter = ( ULONG )SendMessage(
                                        GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) ,
                                        CB_GETITEMDATA ,
                                        ( WPARAM )iSel ,
                                        0 );

        if( iSel != CB_ERR )
        {
            if( iSel != ( INT_PTR )m_ulOldLanAdapter )
            {
                LONG lCount;

                pCfgcomp->QueryLoggedOnCount( m_pParent->m_pResNode->GetConName( ) , &lCount );

                if( lCount > 0 )
                {
                    // Warn user, changing an active lan adapter will cause all connections to disconnect

                    TCHAR tchMessage[ 256 ];

                    TCHAR tchWarn[ 40 ];

                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ERR_LANCHANGE , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWarn , SIZE_OF_BUFFER( tchWarn ) ) );

                    if( MessageBox( hDlg , tchMessage , tchWarn , MB_ICONWARNING | MB_YESNO ) == IDNO )
                    {
                        bOk = FALSE;
                    }
                }
            }
        }

        if( bOk && iSel != CB_ERR ) //winsta.LanAdapter != CB_ERR )
        {
            lstrcpyn( winsta.Name , m_pParent->m_pResNode->GetConName( ) , SIZE_OF_BUFFER( winsta.Name ) - 1 );

            DWORD dwStatus;

            if( FAILED( pCfgcomp->UpDateWS( &winsta , UPDATE_LANADAPTER | UPDATE_MAXINSTANCECOUNT , &dwStatus, FALSE ) ) )
            {
                // report error and get out

                ReportStatusError( hDlg , dwStatus );

                pCfgcomp->Release( );

            }
            else
            {

                ODS( L"Connection LANA persisted\n" );

                m_ulOldLanAdapter = ( ULONG )iSel;

                ODS( L"TSCC : Forcing reg update - CTransNetwork\n" );

                VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

                VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

                // global flag can only be set to true

                m_pParent->m_bPropertiesChange = TRUE;

                PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

                SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

            }

        }

        pCfgcomp->Release( );

    }

    return bOk;
}

//-----------------------------------------------------------------------------
BOOL CTransNetwork::IsValidSettings( HWND hDlg )
{
    BOOL ret = TRUE;

    ICfgComp *pCfgcomp;

    TCHAR tchMessage[ 256 ];

    TCHAR tchWarn[ 40 ];

    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_GEN_UNLIMITED ), BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
    {
        UINT uMax;

        BOOL bOK = FALSE;

        uMax = GetDlgItemInt( hDlg , IDC_EDIT_GEN_MAXCONS , &bOK , FALSE );

        if( !bOK )
        {
            ErrMessage( hDlg , IDS_ERR_CONREADFAIL );

            SetFocus( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) );

            SendMessage( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

            return FALSE;
        }

        if( uMax > 999999UL )
        {
            ErrMessage( hDlg , IDS_ERR_CONMAX );

            SetFocus( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) );

            SendMessage( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

            return FALSE;
        }
    }

    if( m_pParent != NULL && m_pParent->m_pResNode != NULL )
    {
        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
        {
            return FALSE;
        }

        // PDNAMEW pName;

        PWS pWinSta;

        LONG cbSize;

        if( SUCCEEDED( pCfgcomp->GetWSInfo( m_pParent->m_pResNode->GetConName( ) , ( PLONG )&cbSize , &pWinSta ) ) )
        {
            INT_PTR iSel = SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_GETCURSEL , 0 , 0 );

            BOOL bUnique = TRUE;

            if( iSel != CB_ERR )
            {
                if( iSel != ( int )m_ulOldLanAdapter )
                {
                    ULONG nStations;

					VERIFY_S( S_OK , pCfgcomp->GetNumofWinStations(pWinSta->wdName,pWinSta->pdName,&nStations ) );

                    DBGMSG( L"TSCC: Number of winstations equals = %d\n" , nStations );

                    if( nStations > 1 )
                    {
                        ODS( L"TSCC: We have more than one winstation verify unique lana settings\n" );

                        ULONG ulLana = ( ULONG )SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_GETITEMDATA , ( WPARAM )iSel , 0 );

                        VERIFY_S( S_OK , pCfgcomp->IsNetWorkConnectionUnique( m_pParent->m_pResNode->GetTypeName( ) , pWinSta->pdName , ulLana , &bUnique ) );
                    }

                    if( !bUnique )
                    {
                        //ErrMessage( hDlg , IDS_ERR_UNIQUECON );
                        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ERR_UNIQUECON , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

                        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWarn , SIZE_OF_BUFFER( tchWarn ) ) );

                        MessageBox( hDlg , tchMessage , tchWarn , MB_ICONINFORMATION | MB_OK );

                        ret = FALSE;
                    }
                    else
                    {
                        LONG lCount;

                        pCfgcomp->QueryLoggedOnCount( m_pParent->m_pResNode->GetConName( ) , &lCount );

                        if( lCount > 0 )
                        {
                            // Warn user, changing an active lan adapter will cause all connections to disconnect
                            TCHAR tchMessage[ 256 ];

                            TCHAR tchWarn[ 40 ];

                            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ERR_LANCHANGE , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

                            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWarn , SIZE_OF_BUFFER( tchWarn ) ) );

                            if( MessageBox( hDlg , tchMessage , tchWarn , MB_ICONWARNING | MB_YESNO ) == IDNO )
                            {
                                ret = FALSE;
                            }
                        }
                    }

                    if( ret )
                    {
                        m_ulOldLanAdapter = (ULONG)iSel;
                    }
                }

            }

            CoTaskMemFree( pWinSta );
        }

        pCfgcomp->Release( );
    }

    if( !ret )
    {
        if( m_uMaxInstOld == ( ULONG )-1 )
        {
            EnableWindow( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , FALSE );

            EnableWindow( GetDlgItem( hDlg , IDC_SPINCTR_GEN ) , FALSE );

            SendMessage( GetDlgItem( hDlg , IDC_CHECK_GEN_UNLIMITED ) , BM_CLICK , 0 , 0 );

            m_oldID = IDC_CHECK_GEN_UNLIMITED;
        }
        else
        {
            TCHAR tchBuf[ 16 ];

            EnableWindow( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , TRUE );

            EnableWindow( GetDlgItem( hDlg , IDC_SPINCTR_GEN ) , TRUE );

            wsprintf( tchBuf , L"%d" , m_uMaxInstOld );

            SetWindowText( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , tchBuf );

            SendMessage( GetDlgItem( hDlg , IDC_RADIO_MAXPROP) , BM_CLICK , 0 , 0 );

            m_oldID = IDC_RADIO_MAXPROP;

        }

        SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_SETCURSEL , ( WPARAM )m_ulOldLanAdapter , 0 );

        SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

        m_bPersisted = TRUE;
    }

    return ret;
}

//*****************************************************************************
CTransAsync::CTransAsync( CPropsheet * pSheet )
{
    m_pParent = pSheet;    
}

//-----------------------------------------------------------------------------
BOOL CTransAsync::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    ICfgComp *pCfgcomp = NULL;

    m_pParent->AddRef( );

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
    {
        ODS( L"Cound not obtain backend interface @  CTransAsync::OnInitDialog\n" );

        return FALSE;
    }

    
    VERIFY_S( TRUE , m_pParent->GetCurrentUserConfig( m_uc, TRUE ) );

    pCfgcomp->GetAsyncConfig( m_pParent->m_pResNode->GetConName() , WsName , &m_ac );

    VERIFY_S( TRUE , CAsyncDlg::OnInitDialog( hwnd , m_pParent->m_pResNode->GetTypeName( ) , m_pParent->m_pResNode->GetConName( ) , pCfgcomp ) ) ;

    BOOL bReadOnly;

    if( SUCCEEDED( pCfgcomp->IsSessionReadOnly( &bReadOnly ) ) )
    {
        if( bReadOnly )
        {
            // disable the remaining controls
            INT rgIds[] = {
                IDC_ASYNC_DEVICENAME,
                    IDC_ASYNC_CONNECT,
                    IDC_ASYNC_BAUDRATE,
                    IDC_ASYNC_MODEMCALLBACK_PHONENUMBER,
                    IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT,
                    IDC_ASYNC_MODEMCALLBACK,
                    IDC_ASYNC_MODEMCALLBACK_INHERIT,
                    IDC_MODEM_PROP_PROP,
                    IDC_ASYNC_DEFAULTS,
                    IDC_ASYNC_ADVANCED,
                    IDC_ASYNC_TEST, -1
            };


            EnableGroup( hwnd , &rgIds[ 0 ] , FALSE );

        }
    }

    pCfgcomp->Release( );

    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hwnd , wp , lp );
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CTransAsync::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CTransAsync *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CTransAsync *pDlg = ( CTransAsync * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CTransAsync ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CTransAsync * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CTransAsync ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CTransAsync::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_ASYNC_FACE );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CTransAsync::DlgProc;

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CTransAsync::OnDestroy( )
{
    AsyncRelease( );
    
    m_pParent->Release( );

    return CDialogPropBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CTransAsync::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{

    CAsyncDlg::OnCommand( wNotifyCode , wID , hwndCtrl , &m_bPersisted );
    
    if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;

}

//-----------------------------------------------------------------------------
BOOL CTransAsync::PersistSettings( HWND hDlg )
{
    if( !IsValidSettings( hDlg ) )
    {
        return FALSE;
    }

    ICfgComp * pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
    {
        ODS( L"Cound not obtain backend interface @  CTransAsync::OnInitDialog\n" );

        return FALSE;
    }

    DWORD dwStatus;

    HRESULT hr = pCfgcomp->SetAsyncConfig( m_pParent->m_pResNode->GetConName() , WsName , &m_ac , &dwStatus );

    if( FAILED( hr ) )
    {
        ReportStatusError( hDlg , dwStatus );
    }

    if( SUCCEEDED( hr ) )
    {
        DWORD dwStatus;

        hr = m_pParent->SetUserConfig( m_uc , &dwStatus );

        if( FAILED( hr ) )
        {
            ReportStatusError( hDlg , dwStatus );
        }
    }

    if( SUCCEEDED( hr ) )
    {
        ODS( L"TSCC : Forcing reg update - CTransAsync\n" );

        VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

        VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

        // global flag can only be set to true

        m_pParent->m_bPropertiesChange = TRUE;

        PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

        SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );
    }


    pCfgcomp->Release( );

    return SUCCEEDED( hr ) ? TRUE : FALSE;

}

BOOL CTransAsync::IsValidSettings(HWND hDlg)
{
    UNREFERENCED_PARAMETER( hDlg );
    // all async connections are checked for usage
    // thus no two connections can use the same port

    return TRUE;
}


//*****************************************************************************
//                  Logon settings dialog

CLogonSetting::CLogonSetting( CPropsheet *pSheet )
{
    m_pParent = pSheet;

    m_wOldId = ( WORD )-1;
}

//-----------------------------------------------------------------------------
BOOL CLogonSetting::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    if( !IsBadReadPtr( m_pParent , sizeof( CPropsheet ) ) )
    {
        m_pParent->AddRef( );
    }

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        ODS( L"CLogonSetting::OnInitDialog - GetCurrentUserConfig failed!!!\n" );

        return FALSE;
    }

    /*
    SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_INHERIT ) , BM_SETCHECK ,

        uc.fInheritAutoLogon ? BST_CHECKED : BST_UNCHECKED , 0 );*/

    if( uc.fInheritAutoLogon == BST_CHECKED )
    {
        CheckRadioButton( hDlg , IDC_CHECK_LOGON_INHERIT , IDC_RADIO_LOGON , IDC_CHECK_LOGON_INHERIT );

        m_wOldId = IDC_CHECK_LOGON_INHERIT;
    }
    else
    {
        CheckRadioButton( hDlg , IDC_CHECK_LOGON_INHERIT , IDC_RADIO_LOGON , IDC_RADIO_LOGON );

        m_wOldId = IDC_RADIO_LOGON;
    }


    SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_PROMPTPASSWD ), BM_SETCHECK ,
        uc.fPromptForPassword ? BST_CHECKED : BST_UNCHECKED , 0 );

    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);
    EnableWindow( GetDlgItem( hDlg, IDC_CHECK_LOGON_PROMPTPASSWD ), !p.fPolicyPromptForPassword);

    //int rgID[] = { IDC_EDIT_LOGON_USRNAME , IDC_EDIT_LOGON_DOMAIN , IDC_EDIT_LOGON_PASSWD , IDC_EDIT_LOGON_CONFIRMPASSWD , -1 };

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_USRNAME ) , EM_SETLIMITTEXT , ( WPARAM )USERNAME_LENGTH , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_DOMAIN ) , EM_SETLIMITTEXT , ( WPARAM )DOMAIN_LENGTH , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_PASSWD ) , EM_SETLIMITTEXT , ( WPARAM )PASSWORD_LENGTH , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_CONFIRMPASSWD ) , EM_SETLIMITTEXT , ( WPARAM )PASSWORD_LENGTH , 0 );

    if( !uc.fInheritAutoLogon )
    {
        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_USRNAME ) , ( LPTSTR )uc.UserName );

        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_DOMAIN ) , ( LPTSTR )uc.Domain );
    }

    if( !uc.fPromptForPassword )
    {
        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_PASSWD ) , ( LPTSTR )uc.Password );

        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_CONFIRMPASSWD ) , ( LPTSTR )uc.Password );
    }

    int rgID[] = { IDC_EDIT_LOGON_USRNAME , IDC_STATIC_LSUSR ,  IDC_EDIT_LOGON_DOMAIN , IDC_STATIC_LSDOMAIN , IDC_EDIT_LOGON_PASSWD , IDC_STATIC_LSPWD , IDC_EDIT_LOGON_CONFIRMPASSWD , IDC_STATIC_LSCONPWD , -1 };

    EnableGroup( hDlg , &rgID[0] , !uc.fInheritAutoLogon );

    if( !uc.fInheritAutoLogon )
    {
        EnableGroup( hDlg , &rgID[4] , !uc.fPromptForPassword );
    }

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) != 0 )
    {
        BOOL bReadOnly;

        if( SUCCEEDED( pCfgcomp->IsSessionReadOnly( &bReadOnly ) ) )
        {
            if( bReadOnly )
            {
                // make edit controls read-only

                SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_USRNAME ) , EM_SETREADONLY , ( WPARAM )TRUE , 0 );

                SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_DOMAIN ) , EM_SETREADONLY , ( WPARAM )TRUE , 0 );

                // disable the remaining controls

                INT rgIds[] = {
                        IDC_EDIT_LOGON_PASSWD,
                        IDC_EDIT_LOGON_CONFIRMPASSWD,
                        IDC_CHECK_LOGON_PROMPTPASSWD,
                        IDC_CHECK_LOGON_INHERIT,
                        IDC_RADIO_LOGON,
                        -1
                };

                EnableGroup( hDlg , &rgIds[ 0 ] , FALSE );
            }
        }

        pCfgcomp->Release( );
    }



    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hDlg , wp , lp );
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CLogonSetting::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CLogonSetting *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CLogonSetting *pDlg = ( CLogonSetting * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CLogonSetting ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CLogonSetting * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CLogonSetting ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }

    return 0;
}

//-----------------------------------------------------------------------------
BOOL CLogonSetting::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_LOGONSETTINGS );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CLogonSetting::DlgProc;

    return TRUE;

}

//---------------------------------------------------------------------------
BOOL CLogonSetting::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED )
    {
       int rgID[] = { IDC_EDIT_LOGON_USRNAME , IDC_STATIC_LSUSR ,  IDC_EDIT_LOGON_DOMAIN , IDC_STATIC_LSDOMAIN , IDC_EDIT_LOGON_PASSWD , IDC_STATIC_LSPWD , IDC_EDIT_LOGON_CONFIRMPASSWD , IDC_STATIC_LSCONPWD , -1 };

       BOOL bEnable = ( BOOL )SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_CHECK_LOGON_INHERIT ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED;


       if( wID == IDC_CHECK_LOGON_INHERIT )
       {
           EnableGroup( GetParent( hwndCtrl ) , &rgID[ 0 ] , bEnable );

           if( bEnable )
           {
               EnableGroup( GetParent( hwndCtrl ) , &rgID[ 4 ] , SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_CHECK_LOGON_PROMPTPASSWD ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );

               SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_RADIO_LOGON),BM_SETCHECK,(WPARAM)BST_CHECKED,0);

           }
           else
           {
               SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_RADIO_LOGON),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);
           }
       }
       else if( wID == IDC_CHECK_LOGON_PROMPTPASSWD )
       {
           if( bEnable )
           {
               EnableGroup( GetParent( hwndCtrl ) , &rgID[ 4 ] , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );
           }

           // make sure apply button becomes enabled when user checks this box

           m_bPersisted = FALSE;
       }
       else if( wID == IDC_RADIO_LOGON )
       {
           BOOL bChecked = SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ;

            if(bChecked)
            {
                //SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_LOGON_INHERIT),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);

                EnableGroup( GetParent( hwndCtrl ) , &rgID[ 0 ] , TRUE );

                EnableGroup( GetParent( hwndCtrl ) , &rgID[ 4 ] , !( SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_CHECK_LOGON_PROMPTPASSWD )  , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ) );

            }
            else
            {
                SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_LOGON_INHERIT),BM_SETCHECK,(WPARAM)BST_CHECKED,0);
            }
            //SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_ICCP_WZ),BM_CLICK,0,0);

       }

       // if radio button from the last is different enabled the apply button

       if( m_wOldId != wID )
       {
           m_wOldId = wID;

           m_bPersisted = FALSE;
       }


    }

    else if( wNotifyCode == EN_CHANGE )
    {
        m_bPersisted = FALSE;
    }

    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }


    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;

}

//-----------------------------------------------------------------------------
BOOL CLogonSetting::OnDestroy( )
{
    m_pParent->Release( );

    return CDialogPropBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CLogonSetting::PersistSettings( HWND hDlg )
{
    if( m_pParent != NULL )
    {
        USERCONFIG uc;

        m_pParent->GetCurrentUserConfig( uc, TRUE );

        uc.fPromptForPassword = SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_PROMPTPASSWD ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

        if( !uc.fPromptForPassword )
        {
            if( !ConfirmPassWd( hDlg ) )
            {
                return FALSE;
            }
        }
        else
        {
            ZeroMemory( ( PVOID )uc.Password , sizeof( uc.Password ) );
        }

        if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_INHERIT ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
        {
            uc.fInheritAutoLogon = TRUE;

            ZeroMemory( ( PVOID )uc.UserName , sizeof( uc.UserName ) );

            ZeroMemory( ( PVOID )uc.Domain , sizeof( uc.Domain ) );

            ZeroMemory( ( PVOID )uc.Password , sizeof( uc.Password ) );
        }
        else
        {
            uc.fInheritAutoLogon = FALSE;

            GetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_USRNAME ) , uc.UserName , USERNAME_LENGTH + 1 );

            GetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_DOMAIN ) , uc.Domain , DOMAIN_LENGTH + 1 );

            GetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_PASSWD ) , uc.Password , PASSWORD_LENGTH + 1 );
        }

        DWORD dwStatus;

        if( FAILED( m_pParent->SetUserConfig( uc , &dwStatus ) ) )
        {
            ReportStatusError( hDlg , dwStatus );

            return FALSE;
        }

        ICfgComp *pCfgcomp = NULL;

        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) > 0 )
        {
            VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

            VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

            // global flag can only be set to true

            m_pParent->m_bPropertiesChange = TRUE;

            pCfgcomp->Release( );
        }

        PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

        SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CLogonSetting::IsValidSettings( HWND hDlg )
{
    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_PROMPTPASSWD ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
    {
        return ConfirmPassWd( hDlg );
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CLogonSetting::ConfirmPassWd( HWND hDlg )
{
    TCHAR tchPzWd[ PASSWORD_LENGTH + 1];

    TCHAR tchConfirm[ PASSWORD_LENGTH + 1];

    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_INHERIT ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
    {
        return TRUE;
    }

    int iSz = GetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_PASSWD ) , tchPzWd , PASSWORD_LENGTH + 1 );

    // warn on the minimum and maximum sizes

    if( iSz > PASSWORD_LENGTH ) //if( iSz > 0 && ( iSz < 6 || iSz > PASSWORD_LENGTH ) )
    {

        ErrMessage( hDlg , IDS_ERR_PASSWD );

        // set focus back on password and erase the confirm entry

        SetFocus( GetDlgItem( hDlg , IDC_EDIT_LOGON_PASSWD ) );

        SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_PASSWD ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_CONFIRMPASSWD ) , L"" );

        return FALSE;
    }

    int iSz2 = GetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_CONFIRMPASSWD ) , tchConfirm , PASSWORD_LENGTH + 1 );

    if( iSz == iSz2 )
    {
        if( iSz == 0 )
        {
            return TRUE;
        }

        if( lstrcmp( tchPzWd , tchConfirm ) == 0 )
        {
            return TRUE;
        }
    }

    ErrMessage( hDlg , IDS_ERR_PASSCONFIRM );

    SetFocus( GetDlgItem( hDlg , IDC_EDIT_LOGON_CONFIRMPASSWD ) );

    SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_CONFIRMPASSWD ) , L"" );

    return FALSE;
}

//*****************************************************************************
//                  Time out settings dialog


CTimeSetting::CTimeSetting( CPropsheet *pSheet )
{
    m_pParent = pSheet;

    m_wOldAction = ( WORD )-1;

    m_wOldCon = ( WORD )-1;

	m_bPrevClient = FALSE;

}

//-----------------------------------------------------------------------------
BOOL CTimeSetting::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    TCHAR tchBuffer[ 80 ];

    if( m_pParent == NULL )
    {
        ODS( L"CTimeSetting::OnInitDialog - PropertySheet: We've lost our parent node!!!\n" );

        return FALSE;
    }

    m_pParent->AddRef( );

    USERCONFIG uc;

    HWND hCombo[ 3 ] =
    {
        GetDlgItem( hwnd , IDC_COMBO_TIMEOUTS_CON_PS ),

        GetDlgItem( hwnd , IDC_COMBO_TIMEOUTS_DISCON_PS ),

        GetDlgItem( hwnd , IDC_COMBO_TIMEOUTS_IDLE_PS )
    };

    DWORD rgdwTime[] = { 0 , 1 , 5 , 10 , 15 , 30 , 60 , 120 , 180 , 1440 , 2880 , ( DWORD )-1 };


    for( int idx = 0; rgdwTime[ idx ] != ( DWORD)-1; ++idx )
    {
        if( rgdwTime[ idx ] == 0 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );
        }
        else
        {
            ConvertToDuration( rgdwTime[ idx ] , tchBuffer );
        }

        for( int inner = 0 ; inner < 3 ; ++inner )
        {
            SendMessage( hCombo[ inner ] , CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );

            SendMessage( hCombo[ inner ] , CB_SETITEMDATA , idx , rgdwTime[ idx ] );
        }
    }


    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        ODS( L"CTimeSetting::OnInitDialog - PropertySheet: Could not get current USERCONFIG\n" );

        return FALSE;
    }

    ULONG ulTime;

    if( uc.MaxConnectionTime > 0 )
    {
        ulTime = uc.MaxConnectionTime / kMilliMinute;

        InsertSortedAndSetCurSel( hCombo[ 0 ] , ulTime );

    }
    else
    {
        SendMessage( hCombo[ 0 ] , CB_SETCURSEL , 0 , 0 );
    }

    CTimeOutDlg::InitControl( hCombo[ 0 ] );

    //
    // Set the current or default disconnection timeout
    //

    if( uc.MaxDisconnectionTime > 0 )
    {
        ulTime = uc.MaxDisconnectionTime / kMilliMinute;

        InsertSortedAndSetCurSel( hCombo[ 1 ] , ulTime );

    }
    else
    {
        SendMessage( hCombo[ 1] , CB_SETCURSEL , 0 , 0 );
    }

    CTimeOutDlg::InitControl( hCombo[ 1 ] );

    //
    // Set the current or default idle timeout
    //

    if( uc.MaxIdleTime > 0 )
    {
        ulTime = uc.MaxIdleTime / kMilliMinute;

        InsertSortedAndSetCurSel( hCombo[ 2 ] , ulTime );

    }
    else
    {
        SendMessage( hCombo[ 2 ] , CB_SETCURSEL , 0 , 0 );
    }

    CTimeOutDlg::InitControl( hCombo[ 2 ] );

    //
    // all the timeout settings will have the same inherit status (NOT!)
    //
    // GP made all these settings orthogonal.  When we write son of TSCC
    // in Blackcomb, we should allow individual settings.
    //

//  ASSERT( ( BOOL )uc.fInheritMaxSessionTime == ( BOOL )uc.fInheritMaxDisconnectionTime );

//  ASSERT( ( BOOL )uc.fInheritMaxSessionTime == ( BOOL )uc.fInheritMaxIdleTime );

    DBGMSG( L"uc.fInheritMaxSessionTime %d\n" , uc.fInheritMaxSessionTime );

    DBGMSG( L"uc.fInheritMaxDisconnectionTime %d\n" , uc.fInheritMaxDisconnectionTime );

    DBGMSG( L"uc.fInheritMaxIdleTime %d\n" , uc.fInheritMaxIdleTime );

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_INHERITTIMEOUT_PS ) , BM_SETCHECK , ( WPARAM )( BOOL )!uc.fInheritMaxSessionTime , 0 );

    SetTimeoutControls(hwnd);

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_TIMEOUTS_INHERITBKCON_PS ) , BM_SETCHECK , ( WPARAM )!uc.fInheritResetBroken , 0 );

    if( uc.fResetBroken ) //BST_CHECKED : BST_UNCHECKED
    {
        CheckDlgButton( hwnd , IDC_RADIO_TIMEOUTS_RESET_PS , BST_CHECKED );

        m_wOldAction = IDC_RADIO_TIMEOUTS_RESET_PS;
    }
    else
    {
        CheckDlgButton( hwnd , IDC_RADIO_TIMEOUTS_DISCON_PS , BST_CHECKED );

        m_wOldAction = IDC_RADIO_TIMEOUTS_DISCON_PS;
    }

    /*
	if( uc.fReconnectSame )
    {
        CheckDlgButton( hwnd , IDC_RADIO_TIMEOUTS_PREVCLNT_PS , BST_CHECKED );

        m_wOldCon = IDC_RADIO_TIMEOUTS_PREVCLNT_PS;
    }
    else
    {
        CheckDlgButton( hwnd , IDC_RADIO_TIMEOUTS_ANYCLIENT_PS , BST_CHECKED );

        m_wOldCon = IDC_RADIO_TIMEOUTS_ANYCLIENT_PS;
    }
	*/

    SetBkResetControls(hwnd);

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_TIMEOUTS_INHERITRECON_PS ) , BM_SETCHECK , ( WPARAM )!uc.fInheritReconnectSame , 0 );

    //SetReconControls( hwnd , !uc.fInheritReconnectSame );

    LoadAbbreviates( );

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) != 0 )
    {

        BOOL bReadOnly = FALSE;

        if( SUCCEEDED( pCfgcomp->IsSessionReadOnly( &bReadOnly ) ) )
        {
            if( bReadOnly )
            {
                // disable the remaining controls
                int rgID[] =    {
                    IDC_COMBO_TIMEOUTS_CON_PS ,
                    IDC_COMBO_TIMEOUTS_DISCON_PS ,
                    IDC_COMBO_TIMEOUTS_IDLE_PS ,

                    IDC_RADIO_TIMEOUTS_DISCON_PS ,
                    IDC_RADIO_TIMEOUTS_RESET_PS ,

                    IDC_RADIO_TIMEOUTS_ANYCLIENT_PS ,
                    IDC_RADIO_TIMEOUTS_PREVCLNT_PS ,

                    IDC_CHECK_INHERITTIMEOUT_PS,
                    IDC_CHECK_TIMEOUTS_INHERITBKCON_PS,
                    IDC_CHECK_TIMEOUTS_INHERITRECON_PS,

                    -1
                };


                EnableGroup( hwnd , &rgID[ 0 ] , FALSE );
            }
		}

		if( !bReadOnly )
		{
			ULONG mask = 0;

			if( SUCCEEDED( pCfgcomp->GetCaps( m_pParent->m_pResNode->GetTypeName( ) , &mask ) ) )
			{
				// citrix only flag

				m_bPrevClient = mask & WDC_RECONNECT_PREVCLIENT;

				if( !m_bPrevClient )
				{
					EnableWindow( GetDlgItem( hwnd , IDC_CHECK_TIMEOUTS_INHERITRECON_PS ) , FALSE );
				}

				SetReconControls(hwnd);
			}
		}


        pCfgcomp->Release( );
    }

	if( uc.fReconnectSame )
    {
        CheckDlgButton( hwnd , IDC_RADIO_TIMEOUTS_PREVCLNT_PS , BST_CHECKED );

        m_wOldCon = IDC_RADIO_TIMEOUTS_PREVCLNT_PS;
    }
    else
    {
        CheckDlgButton( hwnd , IDC_RADIO_TIMEOUTS_ANYCLIENT_PS , BST_CHECKED );

        m_wOldCon = IDC_RADIO_TIMEOUTS_ANYCLIENT_PS;
    }


    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hwnd , wp , lp );
}

//-----------------------------------------------------------------------------
// the next set of functions manage the enabling and disabling of the controls
//-----------------------------------------------------------------------------

void CTimeSetting::SetTimeoutControls(HWND hDlg)
{
    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);

    BOOL bOverride = 
        (SendMessage(GetDlgItem(hDlg, IDC_CHECK_INHERITTIMEOUT_PS), BM_GETCHECK, 0, 0) == BST_CHECKED);

    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_TIMEOUTS_CON_PS), (bOverride && !p.fPolicyMaxSessionTime));
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TIMCON), (bOverride && !p.fPolicyMaxSessionTime));

    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_TIMEOUTS_DISCON_PS), (bOverride && !p.fPolicyMaxDisconnectionTime));
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TIMDISCON), (bOverride && !p.fPolicyMaxDisconnectionTime));

    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_TIMEOUTS_IDLE_PS), (bOverride && !p.fPolicyMaxIdleTime));
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TIMIDLE), (bOverride && !p.fPolicyMaxIdleTime));

    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_INHERITTIMEOUT_PS), 
        !(p.fPolicyMaxSessionTime && p.fPolicyMaxDisconnectionTime && p.fPolicyMaxIdleTime));
}

void CTimeSetting::SetBkResetControls(HWND hDlg)
{
    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);

    BOOL bOverride = 
        (SendMessage(GetDlgItem(hDlg, IDC_CHECK_TIMEOUTS_INHERITBKCON_PS), BM_GETCHECK, 0, 0) == BST_CHECKED);

    EnableWindow(GetDlgItem(hDlg, IDC_RADIO_TIMEOUTS_DISCON_PS), bOverride && !p.fPolicyResetBroken);
    EnableWindow(GetDlgItem(hDlg, IDC_RADIO_TIMEOUTS_RESET_PS), bOverride && !p.fPolicyResetBroken);

    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_TIMEOUTS_INHERITBKCON_PS), !p.fPolicyResetBroken);
}

void CTimeSetting::SetReconControls(HWND hDlg)
{
    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);

    BOOL bOverride = 
        (SendMessage(GetDlgItem(hDlg, IDC_CHECK_TIMEOUTS_INHERITRECON_PS), BM_GETCHECK, 0, 0) == BST_CHECKED);

	if( !m_bPrevClient )
	{
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_TIMEOUTS_ANYCLIENT_PS), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_TIMEOUTS_PREVCLNT_PS), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_TIMEOUTS_INHERITRECON_PS), FALSE);
	}
	else
	{
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_TIMEOUTS_ANYCLIENT_PS), bOverride && !p.fPolicyReconnectSame);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_TIMEOUTS_PREVCLNT_PS), bOverride && !p.fPolicyReconnectSame);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_TIMEOUTS_INHERITRECON_PS), !p.fPolicyReconnectSame);
	}

}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CTimeSetting::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CTimeSetting *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CTimeSetting *pDlg = ( CTimeSetting * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CTimeSetting ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CTimeSetting * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CTimeSetting ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    }

    return 0;
}

//-----------------------------------------------------------------------------
BOOL CTimeSetting::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_TIMEOUTS_PS );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CTimeSetting::DlgProc;

    return TRUE;

}

//-----------------------------------------------------------------------------
BOOL CTimeSetting::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_CHECK_INHERITTIMEOUT_PS )
        {
            SetTimeoutControls(GetParent(hwndCtrl));

            m_bPersisted = FALSE;
        }
        else if( wID == IDC_CHECK_TIMEOUTS_INHERITBKCON_PS )
        {
            SetBkResetControls(GetParent(hwndCtrl));

            m_bPersisted = FALSE;
        }
        else if( wID == IDC_CHECK_TIMEOUTS_INHERITRECON_PS )
        {
            SetReconControls(GetParent(hwndCtrl));

            m_bPersisted = FALSE;
        }
        else if( wID == IDC_RADIO_TIMEOUTS_DISCON_PS || wID == IDC_RADIO_TIMEOUTS_RESET_PS )
        {
            if( wID != m_wOldAction )
            {
                m_wOldAction = wID;

                m_bPersisted = FALSE;
            }
        }
        else if( wID == IDC_RADIO_TIMEOUTS_ANYCLIENT_PS || wID == IDC_RADIO_TIMEOUTS_PREVCLNT_PS )
        {
            if( wID != m_wOldCon )
            {
                m_wOldCon = wID;

                m_bPersisted = FALSE;
            }
        }


    }
    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }
    else
    {
         CTimeOutDlg::OnCommand( wNotifyCode , wID , hwndCtrl , &m_bPersisted );
    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
int CTimeSetting::GetCBXSTATEindex( HWND hCombo )
{
    int idx = -1;

    switch( GetDlgCtrlID( hCombo ) )
    {
    case IDC_COMBO_TIMEOUTS_CON_PS:

        idx = 0;

        break;

    case IDC_COMBO_TIMEOUTS_DISCON_PS:

        idx = 1;

        break;

    case IDC_COMBO_TIMEOUTS_IDLE_PS:

        idx = 2;

        break;
    }

    return idx;
}



//-------------------------------------------------------------------------------
// PersistSettings
//-------------------------------------------------------------------------------
BOOL CTimeSetting::PersistSettings( HWND hDlg )
{
    if( m_pParent == NULL )
    {
        return FALSE;
    }

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        return FALSE;
    }

    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_INHERITTIMEOUT_PS ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
    {
        uc.fInheritMaxSessionTime = 1;

        uc.fInheritMaxDisconnectionTime = 1;

        uc.fInheritMaxIdleTime = 1;

        // reset timeout values to no timeout

        uc.MaxConnectionTime = 0;

        uc.MaxDisconnectionTime = 0;

        uc.MaxIdleTime = 0;

    }
    else
    {
        uc.fInheritMaxSessionTime = 0;

        uc.fInheritMaxDisconnectionTime = 0;

        uc.fInheritMaxIdleTime = 0;

        if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_TIMEOUTS_CON_PS ) , &uc.MaxConnectionTime ) )
        {
            return FALSE;
        }

        if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_TIMEOUTS_DISCON_PS ) , &uc.MaxDisconnectionTime ) )
        {
            return FALSE;
        }

        if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_TIMEOUTS_IDLE_PS ) , &uc.MaxIdleTime ) )
        {
            return FALSE;
        }
    }

   if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_TIMEOUTS_INHERITBKCON_PS ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
   {
       uc.fInheritResetBroken = 1;
   }
   else
   {
       uc.fInheritResetBroken = 0;

       uc.fResetBroken = SendMessage( GetDlgItem( hDlg , IDC_RADIO_TIMEOUTS_RESET_PS ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;
   }

   if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_TIMEOUTS_INHERITRECON_PS ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
   {
       uc.fInheritReconnectSame = 1;
   }
   else
   {
       uc.fInheritReconnectSame = 0;

       uc.fReconnectSame = ( ULONG )SendMessage( GetDlgItem( hDlg , IDC_RADIO_TIMEOUTS_PREVCLNT_PS ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;
   }

   DWORD dwStatus;

   if( FAILED( m_pParent->SetUserConfig( uc , &dwStatus ) ) )
   {
       ReportStatusError( hDlg , dwStatus );

       return FALSE;
   }

   ICfgComp *pCfgcomp = NULL;

   if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) > 0 )
   {
       VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

       VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

       // global flag can only be set to true

       m_pParent->m_bPropertiesChange = TRUE;

       pCfgcomp->Release( );
   }

   PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

   SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

   return TRUE;

}

//-------------------------------------------------------------------------------
// Making sure the user has entered valid info
//-------------------------------------------------------------------------------
BOOL CTimeSetting::IsValidSettings( HWND hDlg )
{
    if( m_pParent == NULL )
    {
        return FALSE;
    }

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        return FALSE;
    }

    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_INHERITTIMEOUT_PS ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
    {
        if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_TIMEOUTS_CON_PS ) , &uc.MaxConnectionTime ) )
        {
            return FALSE;
        }

        if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_TIMEOUTS_DISCON_PS ) , &uc.MaxDisconnectionTime ) )
        {
            return FALSE;
        }

        if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_TIMEOUTS_IDLE_PS ) , &uc.MaxIdleTime ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}


//-----------------------------------------------------------------------------
BOOL CTimeSetting::OnDestroy( )
{
    m_pParent->Release( );

    ReleaseAbbreviates( );

    return CDialogPropBase::OnDestroy( );
}

//*****************************************************************************
//                  Environment dialog

CEnviro::CEnviro( CPropsheet *pSheet )
{
    m_pParent = pSheet;
}

//-----------------------------------------------------------------------------
BOOL CEnviro::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    if( m_pParent == NULL )
    {
        ODS( L"CEnviro::OnInitDialog - PropertySheet: Parent object is lost!!!\n" );
        return FALSE;
    }

    m_pParent->AddRef( );

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        ODS( L"CEnviro::OnInitDialog - PropertySheet: Failed to obtain USERCONFIG\n" );

        return FALSE;
    }

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_ENVIRO_CMDLINE ) , EM_SETLIMITTEXT , ( WPARAM )INITIALPROGRAM_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_ENVIRO_WD ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );

    if(uc.fInheritInitialProgram)
    {
        SendMessage( GetDlgItem( hwnd , IDC_CHECK_ENVIRO_INHERIT ) , BM_SETCHECK , ( WPARAM )BST_UNCHECKED , 0 );

    }
    else
    {
        SendMessage( GetDlgItem( hwnd , IDC_CHECK_ENVIRO_INHERIT ) , BM_SETCHECK , ( WPARAM )BST_CHECKED, 0 );

    }

    if(uc.fInheritInitialProgram)
    {
        SetControls( hwnd , FALSE );
    }
    else
    {
        SetWindowText( GetDlgItem( hwnd , IDC_EDIT_ENVIRO_CMDLINE ) , ( LPCTSTR )uc.InitialProgram );

        SetWindowText( GetDlgItem( hwnd , IDC_EDIT_ENVIRO_WD ) , ( LPCTSTR )uc.WorkDirectory );
    }

    // SendMessage( GetDlgItem( hwnd , IDC_CHECK_ENVIRO_DISABLEWALL ) , BM_SETCHECK , ( WPARAM )uc.fWallPaperDisabled , 0  );

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) != 0 )
    {

        BOOL bReadOnly;

        if( SUCCEEDED( pCfgcomp->IsSessionReadOnly( &bReadOnly ) ) )
        {
            if( bReadOnly )
            {
                // make edit controls read-only

                SendMessage( GetDlgItem( hwnd , IDC_EDIT_ENVIRO_CMDLINE ) , EM_SETREADONLY , ( WPARAM )TRUE , 0 );

                SendMessage( GetDlgItem( hwnd , IDC_EDIT_ENVIRO_WD ) , EM_SETREADONLY , ( WPARAM )TRUE , 0 );

                // disable the remaining controls
                int rgID[] =    {
                    IDC_CHECK_ENVIRO_INHERIT ,
                    // IDC_CHECK_ENVIRO_DISABLEWALL,
                    -1
                };


                EnableGroup( hwnd , &rgID[ 0 ] , FALSE );
            }
        }

        pCfgcomp->Release( );
    }

    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);
    if (p.fPolicyInitialProgram)
    {
        int rgID[] = 
        {
            IDC_CHECK_ENVIRO_INHERIT,
            IDC_EDIT_ENVIRO_CMDLINE,
            IDC_EDIT_ENVIRO_WD, -1
        };
        EnableGroup(hwnd, &rgID[0], FALSE);
    }

    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hwnd , wp , lp );
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CEnviro::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CEnviro *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CEnviro *pDlg = ( CEnviro * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CEnviro ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CEnviro * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CEnviro ) ) )
        {
            return 0;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }

    return 0;
}

//-----------------------------------------------------------------------------
BOOL CEnviro::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_ENVIRONMENT );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CEnviro::DlgProc;

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CEnviro::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_CHECK_ENVIRO_INHERIT )
        {
            SetControls( GetParent( hwndCtrl ) , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED );
        }

        m_bPersisted = FALSE;
    }
    else if( wNotifyCode == EN_CHANGE )
    {
        m_bPersisted = FALSE;
    }
    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
void CEnviro::SetControls( HWND hDlg , BOOL bEnable )
{
    int rgID[] = { IDC_EDIT_ENVIRO_CMDLINE , IDC_STATIC_ENCL ,  IDC_EDIT_ENVIRO_WD , IDC_STATIC_WD ,-1 };

    EnableGroup( hDlg , &rgID[ 0 ] , bEnable );
}

//-----------------------------------------------------------------------------
BOOL CEnviro::PersistSettings( HWND hDlg )
{
    if( m_pParent == NULL )
    {
        return FALSE;
    }

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        return FALSE;
    }

    uc.fInheritInitialProgram = (( ULONG )SendMessage( GetDlgItem( hDlg , IDC_CHECK_ENVIRO_INHERIT ) , BM_GETCHECK , 0 , 0 )) == BST_UNCHECKED;

    if( !uc.fInheritInitialProgram )
    {
        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_ENVIRO_CMDLINE ) , uc.InitialProgram , INITIALPROGRAM_LENGTH + 1);

        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_ENVIRO_WD ) , uc.WorkDirectory , DIRECTORY_LENGTH + 1 );
    }
    else
    {
        ZeroMemory( ( PVOID )uc.InitialProgram , sizeof( uc.InitialProgram ) );

        ZeroMemory( ( PVOID )uc.WorkDirectory , sizeof( uc.WorkDirectory ) );
    }

    // uc.fWallPaperDisabled = ( ULONG )SendMessage( GetDlgItem( hDlg , IDC_CHECK_ENVIRO_DISABLEWALL ) , BM_GETCHECK , 0 , 0  );

    DWORD dwStatus;

    if( FAILED( m_pParent->SetUserConfig( uc , &dwStatus ) ) )
    {
        ReportStatusError( hDlg , dwStatus );

        return FALSE;
    }

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) > 0 )
    {
        VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

        VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

        // global flag can only be set to true

        m_pParent->m_bPropertiesChange = TRUE;

        pCfgcomp->Release( );
    }

    PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

    SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CEnviro::OnDestroy( )
{
    m_pParent->Release( );

    return CDialogPropBase::OnDestroy( );
}

//*****************************************************************************
//                  Shadow dialog

CRemote::CRemote( CPropsheet *pSheet )
{
    m_pParent = pSheet;

    m_wOldRadioID = ( WORD )-1;

    m_wOldSel = ( WORD )-1;
}

//-----------------------------------------------------------------------------
BOOL CRemote::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    if( m_pParent == NULL )
    {
        ODS( L"CRemote::OnInitDialog - PropertySheet: Parent object lost!!\n" );

        return FALSE;
    }

    m_pParent->AddRef( );

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        ODS( L"CRemote::OnInitDialog - PropertySheet: GetCurrentUserConfig failed!!\n" );

        return FALSE;
    }

    if( uc.fInheritShadow || uc.Shadow == Shadow_Disable )
    {
        // setup some default values

        SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

        SendMessage( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

        m_wOldSel = IDC_RADIO_WATCH;

        if( uc.fInheritShadow )
        {
            SendMessage( GetDlgItem( hwnd , IDC_RADIO_REMOTE_INHERIT ) , BM_SETCHECK , ( WPARAM )uc.fInheritShadow , 0 );

        }
        else
        {
            SendMessage( GetDlgItem( hwnd , IDC_RADIO_NOREMOTE ) , BM_SETCHECK , ( WPARAM )TRUE , 0  );

        }

        m_wOldRadioID = ( WORD )( uc.fInheritShadow ? IDC_RADIO_REMOTE_INHERIT : IDC_RADIO_NOREMOTE );

        SetControls( hwnd , FALSE );
    }
    else
    {
        // Controls are initially enabled,  set current status

        SendMessage( GetDlgItem( hwnd , IDC_RADIO_ENABLE_REMOTE ) , BM_SETCHECK , ( WPARAM )TRUE , 0  );

        m_wOldRadioID = IDC_RADIO_ENABLE_REMOTE;

        switch( uc.Shadow )
        {
        case Shadow_EnableInputNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            break;

        case Shadow_EnableInputNoNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )FALSE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            break;

        case Shadow_EnableNoInputNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            break;

        case Shadow_EnableNoInputNoNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )FALSE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            break;
        }

        if( IsDlgButtonChecked( hwnd , IDC_RADIO_WATCH ) == BST_CHECKED )
        {
            m_wOldSel = IDC_RADIO_WATCH;
        }
        else
        {
            m_wOldSel = IDC_RADIO_CONTROL;
        }
    }

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) != 0 )
    {

        BOOL bReadOnly;

        if( SUCCEEDED( pCfgcomp->IsSessionReadOnly( &bReadOnly ) ) )
        {
            if( bReadOnly )
            {
                // disable the remaining controls
                int rgID[] =    {
                    IDC_RADIO_ENABLE_REMOTE ,
                    IDC_RADIO_NOREMOTE,
                    IDC_RADIO_CONTROL,
                    IDC_RADIO_REMOTE_INHERIT,
                    IDC_RADIO_WATCH,
                    IDC_CHECK_NOTIFY,
                    -1
                };


                EnableGroup( hwnd , &rgID[ 0 ] , FALSE );
            }
        }

        pCfgcomp->Release( );
    }

    //Disable all the controls if there is a group policy set
    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);

    if (p.fPolicyShadow)
    {
        int rgID[] = 
        {
            IDC_RADIO_ENABLE_REMOTE ,
            IDC_RADIO_NOREMOTE,
            IDC_RADIO_CONTROL,
            IDC_RADIO_REMOTE_INHERIT,
            IDC_RADIO_WATCH,
            IDC_CHECK_NOTIFY,
            -1
        };

        EnableGroup( hwnd , &rgID[ 0 ] , FALSE );
    }

    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hwnd , wp , lp );
}

//-----------------------------------------------------------------------------
void CRemote::SetControls( HWND hDlg , BOOL bEnable )
{
    int rgID[] = { IDC_RADIO_WATCH , IDC_RADIO_CONTROL , IDC_CHECK_NOTIFY , IDC_STATIC_LEVELOFCTRL , -1 };

    EnableGroup( hDlg , &rgID[ 0 ] , bEnable );
}


//-----------------------------------------------------------------------------
INT_PTR CALLBACK CRemote::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CRemote *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CRemote *pDlg = ( CRemote * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CRemote ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CRemote * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CRemote ) ) )
        {
            return 0;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }

    return 0;
}

//-----------------------------------------------------------------------------
BOOL CRemote::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_PAGE_SHADOW );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CRemote::DlgProc;

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CRemote::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_CHECK_NOTIFY )
        {
            m_bPersisted = FALSE;
        }
        else if( wID == IDC_RADIO_REMOTE_INHERIT || wID == IDC_RADIO_NOREMOTE || wID == IDC_RADIO_ENABLE_REMOTE )
        {
            if( m_wOldRadioID != wID )
            {
                if( wID == IDC_RADIO_REMOTE_INHERIT || wID == IDC_RADIO_NOREMOTE )
                {
                    SetControls( GetParent( hwndCtrl ) , FALSE );
                }
                else if( wID == IDC_RADIO_ENABLE_REMOTE )
                {
                    SetControls( GetParent( hwndCtrl ) , TRUE );
                }

                m_wOldRadioID = wID;

                m_bPersisted = FALSE;
            }
        }
        else if( wID == IDC_RADIO_CONTROL || wID == IDC_RADIO_WATCH )
        {
            if( wID != m_wOldSel )
            {
                m_wOldSel = wID;

                m_bPersisted = FALSE;
            }
        }
    }
    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CRemote::OnDestroy( )
{
    m_pParent->Release( );

    return CDialogPropBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
// The nesting may appear scary but its has a nice logic flow to a weird
// datatype called shadow
//-----------------------------------------------------------------------------
BOOL CRemote::PersistSettings( HWND hDlg )
{
    if( m_pParent != NULL )
    {
        USERCONFIG uc;
        m_pParent->GetCurrentUserConfig( uc, TRUE );

        if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_REMOTE_INHERIT ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
        {
            uc.fInheritShadow = FALSE;

            if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_NOREMOTE ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
            {
                BOOL bCheckNotify = ( BOOL )SendMessage( GetDlgItem( hDlg , IDC_CHECK_NOTIFY ) , BM_GETCHECK , 0 , 0 );

                BOOL bRadioControl = ( BOOL )SendMessage( GetDlgItem( hDlg , IDC_RADIO_CONTROL ) , BM_GETCHECK , 0 , 0 );

                if( bCheckNotify )
                {
                    if( bRadioControl )
                    {
                        uc.Shadow = Shadow_EnableInputNotify;
                    }
                    else
                    {
                        uc.Shadow = Shadow_EnableNoInputNotify;
                    }
                }
                else
                {
                    if( bRadioControl )
                    {
                        uc.Shadow = Shadow_EnableInputNoNotify;
                    }
                    else
                    {
                        uc.Shadow = Shadow_EnableNoInputNoNotify;
                    }
                }
            }
            else
            {
                uc.Shadow = Shadow_Disable;
            }

        }
        else
        {
            uc.fInheritShadow = TRUE;
        }

        DWORD dwStatus;

        if( FAILED( m_pParent->SetUserConfig( uc , &dwStatus ) ) )
        {
            ReportStatusError( hDlg , dwStatus );

            return FALSE;
        }

        ICfgComp *pCfgcomp = NULL;

        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) > 0 )
        {
            VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

            VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

            // global flag can only be set to true

            m_pParent->m_bPropertiesChange = TRUE;

            pCfgcomp->Release( );
        }

        PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

        SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

        return TRUE;
    }

    return FALSE;
}

//*****************************************************************************
//                  Client settings dialog

CClient::CClient( CPropsheet *pSheet )
{
    m_pParent = pSheet;
	m_nColorDepth = TS_8BPP_SUPPORT;
}

//-----------------------------------------------------------------------------
BOOL CClient::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    if( m_pParent == NULL )
    {
        ODS( L"CClient::OnInitDialog - PropertySheet: Parent object lost!!\n" );
        return FALSE;
    }

    m_pParent->AddRef( );

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        ODS( L"CClient::OnInitDialog - PropertySheet: GetCurrentUserConfig failed!!\n" );
        return FALSE;
    }

    // Obtain capabilities mask

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
    {
        ODS( L"CClient::OnInitDialog  GetServer failed\n" );

        return FALSE;
    }

    SendMessage( GetDlgItem( hDlg , IDC_CHECK_CONCLIENT_INHERIT ) , BM_SETCHECK , ( WPARAM )uc.fInheritAutoClient , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_CHECK_CCDL_PS ) , BM_SETCHECK , ( WPARAM )uc.fAutoClientDrives , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_CHECK_CCPL_PS ) , BM_SETCHECK , ( WPARAM )uc.fAutoClientLpts , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_CHECK_DMCP_PS ) , BM_SETCHECK , ( WPARAM )uc.fForceClientLptDef , 0 );


    //NA 2/23/01    
    TCHAR tchBuffer[80];
    int nColorDepthIndex = 0;

    LoadString( _Module.GetResourceInstance( ) , IDS_COLORDEPTH_24 , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );    
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_SETITEMDATA , nColorDepthIndex++ , TS_24BPP_SUPPORT );

    LoadString( _Module.GetResourceInstance( ) , IDS_COLORDEPTH_16 , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_SETITEMDATA , nColorDepthIndex++ , TS_16BPP_SUPPORT );

    LoadString( _Module.GetResourceInstance( ) , IDS_COLORDEPTH_15 , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_SETITEMDATA , nColorDepthIndex++ , TS_15BPP_SUPPORT );

    LoadString( _Module.GetResourceInstance( ) , IDS_COLORDEPTH_8 , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_SETITEMDATA , nColorDepthIndex++ , TS_8BPP_SUPPORT );

    if(uc.fInheritColorDepth)
        SendMessage( GetDlgItem( hDlg , IDC_CHECK_COLORDEPTH_OVERRIDE ) , BM_SETCHECK , ( WPARAM )BST_UNCHECKED , 0 );
    else
        SendMessage( GetDlgItem( hDlg , IDC_CHECK_COLORDEPTH_OVERRIDE ) , BM_SETCHECK , ( WPARAM )BST_CHECKED, 0 );

    if (uc.ColorDepth < TS_8BPP_SUPPORT)
    	m_nColorDepth = TS_8BPP_SUPPORT;
    else if (uc.ColorDepth > TS_24BPP_SUPPORT)
    	m_nColorDepth = TS_24BPP_SUPPORT;
    else
    	m_nColorDepth = (int)uc.ColorDepth;

    //Mapping fields
    ULONG mask = 0;
    VERIFY_S(S_OK, pCfgcomp->GetCaps(m_pParent->m_pResNode->GetTypeName(), &mask));

    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCDM_PS), mask & WDC_CLIENT_DRIVE_MAPPING);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DWCPM_PS), mask & WDC_WIN_CLIENT_PRINTER_MAPPING);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCLPM_PS), mask & WDC_CLIENT_LPT_PORT_MAPPING);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCCPM_PS), mask & WDC_CLIENT_COM_PORT_MAPPING);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCCM_PS), mask & WDC_CLIENT_CLIPBOARD_MAPPING);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCAM_PS), mask & WDC_CLIENT_AUDIO_MAPPING);

    if (!(mask & WDC_CLIENT_DRIVE_MAPPING))
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_DCDM_PS), BM_SETCHECK, (WPARAM)TRUE, 0);
    else
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_DCDM_PS), BM_SETCHECK, (WPARAM)uc.fDisableCdm, 0);

    if(!(mask & WDC_WIN_CLIENT_PRINTER_MAPPING))
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_DWCPM_PS), BM_SETCHECK, (WPARAM)TRUE, 0 );
    else
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_DWCPM_PS), BM_SETCHECK, (WPARAM)uc.fDisableCpm, 0);

    if(!(mask & WDC_CLIENT_LPT_PORT_MAPPING))
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_DCLPM_PS), BM_SETCHECK, (WPARAM)TRUE, 0);
    else
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_DCLPM_PS), BM_SETCHECK, (WPARAM)uc.fDisableLPT, 0);

    SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCCPM_PS ) , BM_SETCHECK , ( WPARAM )uc.fDisableCcm , 0 );
    SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCCM_PS ) , BM_SETCHECK , ( WPARAM )uc.fDisableClip , 0 );
    SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCAM_PS ) , BM_SETCHECK , ( WPARAM )uc.fDisableCam , 0 );

    DetermineFieldEnabling(hDlg);
    SetColorDepthEntry(hDlg);

    BOOL bReadOnly;
    if (SUCCEEDED(pCfgcomp->IsSessionReadOnly(&bReadOnly)))
    {
        if(bReadOnly)
        {
            // disable the remaining controls
            int rgID[] =    
            {
                IDC_CHECK_DCDM_PS ,
                IDC_CHECK_DWCPM_PS ,
                IDC_CHECK_DCLPM_PS ,
                IDC_CHECK_DCCPM_PS ,
                IDC_CHECK_DCCM_PS ,
                IDC_CHECK_DCAM_PS ,
                IDC_CHECK_CCDL_PS ,
                IDC_CHECK_CCPL_PS ,
                IDC_CHECK_DMCP_PS ,
                IDC_CHECK_CONCLIENT_INHERIT,
                IDC_CHECK_COLORDEPTH_OVERRIDE,
                IDC_COLORDEPTH_OVERRIDE,
                -1
            };
            EnableGroup( hDlg , &rgID[ 0 ] , FALSE );
        }
    }

    pCfgcomp->Release( );

    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hDlg , wp , lp );
}


//-----------------------------------------------------------------------------
//Disable fields if a group policy is set
void CClient::DetermineFieldEnabling(HWND hDlg)
{
    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);
	
    //Mapping fields
    //EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DMCP_PS), !p.fPolicyForceClientLptDef); //Done below since it depends on 2 things
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCDM_PS), !p.fPolicyDisableCdm);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DWCPM_PS), !p.fPolicyDisableCpm);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCLPM_PS), !p.fPolicyDisableLPT);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCCPM_PS), !p.fPolicyDisableCcm);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCCM_PS), !p.fPolicyDisableClip);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCAM_PS), !p.fPolicyDisableCam);

    //Connection fields
	BOOL bEnableConnectionSettings = (SendMessage(GetDlgItem(hDlg, IDC_CHECK_CONCLIENT_INHERIT), BM_GETCHECK, 0, 0) != BST_CHECKED);

    // check to see if client drive mapping is selected if so disable
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_CCDL_PS), bEnableConnectionSettings && 
        (SendMessage(GetDlgItem(hDlg, IDC_CHECK_DCDM_PS), BM_GETCHECK, 0, 0) != BST_CHECKED));

	EnableWindow( GetDlgItem( hDlg , IDC_CHECK_CCPL_PS ) , bEnableConnectionSettings );

	EnableWindow( GetDlgItem( hDlg , IDC_CHECK_DMCP_PS ) , bEnableConnectionSettings && !p.fPolicyForceClientLptDef);

    //Color Depth fields
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_COLORDEPTH_OVERRIDE), (!p.fPolicyColorDepth));

    BOOL bEnableColorDepthSetting = SendMessage( GetDlgItem( hDlg , IDC_CHECK_COLORDEPTH_OVERRIDE ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED;
    EnableWindow(GetDlgItem(hDlg, IDC_COLORDEPTH_OVERRIDE), (bEnableColorDepthSetting && !p.fPolicyColorDepth));

}


//-----------------------------------------------------------------------------
void CClient::SetColorDepthEntry(HWND hwnd)
{
	//NA 2/23/01
	BOOL bEnableColorDepthSetting = TRUE;

    // check to see if override Color Depth setting is checked
	bEnableColorDepthSetting = SendMessage( GetDlgItem( hwnd , IDC_CHECK_COLORDEPTH_OVERRIDE ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED;

	//Select the correct combo box entry
	if (bEnableColorDepthSetting)
	{
		//Select the correct value in the combo box based on the current value
		INT_PTR iColorDepthListCount = 0;
		iColorDepthListCount = SendMessage( GetDlgItem( hwnd, IDC_COLORDEPTH_OVERRIDE ), CB_GETCOUNT , 0 , 0 );

		//Traverse the list looking an entry with value equal to m_nColorDepth
		for (int iColorDepthListIndex = 0; iColorDepthListIndex < iColorDepthListCount; iColorDepthListIndex++)
		{
			INT_PTR iMatchingColorDepthValue = 0;
			iMatchingColorDepthValue = SendMessage( GetDlgItem( hwnd, IDC_COLORDEPTH_OVERRIDE ), CB_GETITEMDATA , iColorDepthListIndex , 0 ) ;

			if (iMatchingColorDepthValue == m_nColorDepth )
			{
				//Value found, set the combo box selection to the correct index
				SendMessage( GetDlgItem( hwnd, IDC_COLORDEPTH_OVERRIDE ), CB_SETCURSEL , iColorDepthListIndex , 0 );
				break;
			}
		}

		//Make sure something's been selected - if not, just select the first value in the list
		INT_PTR iSelection = SendMessage ( GetDlgItem( hwnd, IDC_COLORDEPTH_OVERRIDE ), CB_GETCURSEL, 0, 0 );
		if (iSelection == CB_ERR)
			SendMessage( GetDlgItem( hwnd, IDC_COLORDEPTH_OVERRIDE ), CB_SETCURSEL , 0 , 0 );
	}
	else
	{
		//Clear the contents of the combo box window if the color depth isn't editable
		SendMessage( GetDlgItem( hwnd, IDC_COLORDEPTH_OVERRIDE ), CB_SETCURSEL , (WPARAM)CB_ERR , 0 );
	}
}

//-----------------------------------------------------------------------------
BOOL CClient::PersistSettings( HWND hDlg )
{
    if( m_pParent == NULL )
    {
        return FALSE;
    }

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        return FALSE;
    }

    uc.fInheritAutoClient = SendMessage( GetDlgItem( hDlg , IDC_CHECK_CONCLIENT_INHERIT ) , BM_GETCHECK , 0 , 0 );

    if( !uc.fInheritAutoClient )
    {
        uc.fAutoClientDrives = SendMessage( GetDlgItem( hDlg , IDC_CHECK_CCDL_PS ) , BM_GETCHECK , 0 , 0 );

        uc.fAutoClientLpts = SendMessage( GetDlgItem( hDlg , IDC_CHECK_CCPL_PS ) , BM_GETCHECK , 0 , 0 );

        uc.fForceClientLptDef = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DMCP_PS ) , BM_GETCHECK , 0 , 0 );
    }

    uc.fDisableCdm = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCDM_PS ) , BM_GETCHECK , 0 , 0 );

    uc.fDisableCpm = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DWCPM_PS ) , BM_GETCHECK , 0 , 0 );

    uc.fDisableLPT = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCLPM_PS ) , BM_GETCHECK , 0 , 0 );

    uc.fDisableCcm = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCCPM_PS ) , BM_GETCHECK , 0 , 0 );

    uc.fDisableClip = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCCM_PS ) , BM_GETCHECK , 0 , 0 );

    uc.fDisableCam = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCAM_PS ) , BM_GETCHECK , 0 , 0 );


    //NA 2/23/01
    uc.fInheritColorDepth = (( ULONG )SendMessage( GetDlgItem( hDlg , IDC_CHECK_COLORDEPTH_OVERRIDE ) , BM_GETCHECK , 0 , 0 )) == BST_UNCHECKED;

    if( !uc.fInheritColorDepth )
    {
		INT_PTR iColorDepthSel = CB_ERR;
		iColorDepthSel = SendMessage( GetDlgItem( hDlg , IDC_COLORDEPTH_OVERRIDE ) , CB_GETCURSEL, 0 , 0 );

		INT_PTR iColorDepthValue = 0;
		iColorDepthValue = SendMessage( GetDlgItem( hDlg , IDC_COLORDEPTH_OVERRIDE ) , CB_GETITEMDATA , iColorDepthSel , 0 );
		
		uc.ColorDepth = iColorDepthValue;
    }
    else
    {
        uc.ColorDepth = TS_24BPP_SUPPORT;
    }


    DWORD dwStatus;

    if( FAILED( m_pParent->SetUserConfig( uc , &dwStatus ) ) )
    {
        ReportStatusError( hDlg , dwStatus );

        return FALSE;
    }

	ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) > 0 )
    {
        VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

        VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

        // global flag can only be set to true

        m_pParent->m_bPropertiesChange = TRUE;

        pCfgcomp->Release( );
    }

    PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

    SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

    return TRUE;
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CClient::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CClient *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CClient *pDlg = ( CClient * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CClient ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CClient * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CClient ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CClient::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_TSCC_CLIENT );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CClient::DlgProc;

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CClient::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED )
    {
		if ((wID == IDC_CHECK_CONCLIENT_INHERIT) || (wID == IDC_CHECK_COLORDEPTH_OVERRIDE) || 
                                (wID == IDC_CHECK_DWCPM_PS ) || (wID == IDC_CHECK_DCDM_PS))
        {
            DetermineFieldEnabling(GetParent(hwndCtrl));
        }

        if (wID == IDC_CHECK_COLORDEPTH_OVERRIDE)
            SetColorDepthEntry(GetParent(hwndCtrl));
    }
    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }

    m_bPersisted = FALSE;

    SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );


    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CClient::OnDestroy( )
{
    m_pParent->Release( );

    return TRUE;
}


/*************************************************************************************************************************/

/*EXTERN_C const GUID IID_ISecurityInformation =
        { 0x965fc360, 0x16ff, 0x11d0, 0x91, 0xcb, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x23 };
*/
//
// WinStation General Permissions
//

/*
SI_ACCESS siWinStationAccesses[] =
{
    { &GUID_NULL , WINSTATION_QUERY                             , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_SET                               , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_RESET                             , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_SHADOW                            , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_LOGON                             , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_LOGOFF                            , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_MSG                               , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_CONNECT                           , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_DISCONNECT                        , NULL , SI_ACCESS_SPECIFIC},
    { &GUID_NULL , WINSTATION_VIRTUAL | STANDARD_RIGHTS_REQUIRED, NULL , SI_ACCESS_SPECIFIC},
    { &GUID_NULL , WINSTATION_ALL_ACCESS                        , NULL , SI_ACCESS_GENERAL },
    { &GUID_NULL , WINSTATION_USER_ACCESS                       , NULL , SI_ACCESS_GENERAL },
    { &GUID_NULL , WINSTATION_GUEST_ACCESS                      , NULL , SI_ACCESS_GENERAL }
};

  */

SI_ACCESS siWinStationAccesses[] =
{
    { &GUID_NULL , WINSTATION_QUERY                             , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_QUERY ),SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_SET                               , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_SET ) ,SI_ACCESS_SPECIFIC },
    //{ &GUID_NULL , WINSTATION_RESET                             , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_RESET ) ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_SHADOW                            , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_SHADOW ) ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_LOGON                             , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_LOGON ) ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_RESET                             , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_LOGOFF ) ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_MSG                               , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_MSG ) ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_CONNECT                           , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_CONNECT ) ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_DISCONNECT                        , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_DISCONNECT ) , SI_ACCESS_SPECIFIC},
    { &GUID_NULL , WINSTATION_VIRTUAL | STANDARD_RIGHTS_REQUIRED, MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_DELETE ) , SI_ACCESS_SPECIFIC},
    { &GUID_NULL , WINSTATION_ALL_ACCESS                        , MAKEINTRESOURCE ( IDS_PERMS_RESOURCE_ADMIN ) , SI_ACCESS_GENERAL },
    { &GUID_NULL , WINSTATION_USER_ACCESS                       , MAKEINTRESOURCE ( IDS_PERMS_RESOURCE_USER ) , SI_ACCESS_GENERAL },
    { &GUID_NULL , WINSTATION_GUEST_ACCESS                      , MAKEINTRESOURCE ( IDS_PERMS_RESOURCE_GUEST ) , SI_ACCESS_GENERAL }
};

#define MAX_PERM 12
#define iWinStationDefAccess 11   // index of value in array siWinStationAccesses



//-----------------------------------------------------------------------------
STDMETHODIMP CSecurityPage::GetAccessRights(
    const GUID  *pguidObjectType,
    DWORD       dwFlags,
    PSI_ACCESS  *ppAccess,
    PULONG       pcAccesses,
    PULONG       piDefaultAccess
)
{
    UNREFERENCED_PARAMETER( dwFlags );

    UNREFERENCED_PARAMETER( pguidObjectType );

    ASSERT( ppAccess != NULL );

    ASSERT( pcAccesses != NULL );

    ASSERT( piDefaultAccess != NULL );

    *ppAccess = siWinStationAccesses;

    *pcAccesses = MAX_PERM;

    *piDefaultAccess = iWinStationDefAccess;

    return S_OK;
}

//-----------------------------------------------------------------------------
// This is consistent with the termsrv code
//-----------------------------------------------------------------------------
GENERIC_MAPPING WinStationMap =
{
    WINSTATION_QUERY      , /*     GenericRead             */
    WINSTATION_USER_ACCESS, /*     GenericWrite            */
    WINSTATION_USER_ACCESS, /*     GenericExecute          */
    WINSTATION_ALL_ACCESS   /*     GenericAll              */
};

//-----------------------------------------------------------------------------
void CSecurityPage::SetParent( CPropsheet *pParent  )
{
    m_pParent = pParent;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CSecurityPage::MapGeneric( const GUID  *pguidObjectType , PUCHAR pAceFlags , ACCESS_MASK *pMask )
{
    UNREFERENCED_PARAMETER( pguidObjectType );
    UNREFERENCED_PARAMETER( pAceFlags );

    ASSERT( pMask != NULL );

    MapGenericMask( pMask , &WinStationMap );

    return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CSecurityPage::GetInheritTypes( PSI_INHERIT_TYPE  *ppInheritTypes ,  PULONG pcInheritTypes )
{
    UNREFERENCED_PARAMETER( ppInheritTypes );
    UNREFERENCED_PARAMETER( pcInheritTypes );


    return E_NOTIMPL;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CSecurityPage::PropertySheetPageCallback( HWND hwnd , UINT uMsg , SI_PAGE_TYPE uPage )
{
    UNREFERENCED_PARAMETER( hwnd );
    UNREFERENCED_PARAMETER( uPage );

    if( uMsg == PSPCB_SI_INITDIALOG  )
    {
        ODS( L"CSecurityPage::PropertySheetPageCallback -- Init\n" );

        if (!m_WritablePermissionsTab )
        {

            LinkWindow_RegisterClass();

            DialogBox( _Module.GetResourceInstance( ), MAKEINTRESOURCE(IDD_CUSTOM_SECURITY), 

            hwnd, CustomSecurityDlgProc);

            LinkWindow_UnregisterClass(_Module.GetModuleInstance( ));

        }

    }
    else if( uMsg == PSPCB_RELEASE )
    {


        ODS( L"CSecurityPage::PropertySheetPageCallback -- Release\n" );

    }


    return S_FALSE; //Be sure to return S_FALSE, This supresses other popups.
}

/*
    Change to TSCC's permissions TAB such that the default state is READ-ONLY unless 
    group policy is used to override it.

    If TRUE, permissions TAB can be edited by local Adimn.
    if FALSE, the local Admin should not edit permissions TAB, it is read only
*/

BOOLEAN QueryWriteAccess()
{
    DWORD   ValueType;
    DWORD   ValueSize = sizeof(DWORD);
    DWORD   valueData ;
    LONG    errorCode;

    HKEY   hTSControlKey = NULL;

    //
    // first check the policy tree, 
    //

    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);

    if ( p.fPolicyWritableTSCCPermissionsTAB ) 
    {
        return (BOOLEAN)( p.fWritableTSCCPermissionsTAB ? TRUE : FALSE  );
    }

    // if we got this far, then no policy was set. Check the local machine now.

    errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                                KEY_READ, &hTSControlKey );

    if ( ( errorCode == ERROR_SUCCESS ) && hTSControlKey )
    {
        errorCode = RegQueryValueEx( hTSControlKey, 
                                     POLICY_TS_TSCC_PERM_TAB_WRITABLE , NULL, &ValueType,
                          (LPBYTE) &valueData, &ValueSize );

        RegCloseKey(hTSControlKey); 
    
        if (errorCode == ERROR_SUCCESS )
        {
            return (BOOLEAN)( valueData ? TRUE : FALSE  ) ; 
        }

    }

    // if no localKey, gee... the registry is missing data... return FALSE  to be on the secure side

    return FALSE;
}

/*-----------------------------------------------------------------------------
JeffreyS 1/24/97:
If you don't set the SI_RESET flag in
ISecurityInformation::GetObjectInformation, then fDefault should never be TRUE
so you can ignore it.  Returning E_NOTIMPL in this case is OK too.

If you want the user to be able to reset the ACL to some default state
(defined by you) then turn on SI_RESET and return your default ACL
when fDefault is TRUE.  This happens if/when the user pushes a button
that is only visible when SI_RESET is on.
-----------------------------------------------------------------------------*/

STDMETHODIMP CSecurityPage::GetObjectInformation( PSI_OBJECT_INFO pObjectInfo )
{
    ASSERT( pObjectInfo != NULL && !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo ) ) );

    pObjectInfo->dwFlags = SI_OWNER_READONLY | SI_EDIT_PERMS | SI_NO_ACL_PROTECT | SI_PAGE_TITLE | SI_EDIT_AUDITS | SI_ADVANCED | SI_RESET;

    m_WritablePermissionsTab = QueryWriteAccess() ; 

    if( ! m_WritablePermissionsTab ) {
        pObjectInfo->dwFlags |= SI_READONLY;
    }
   

    pObjectInfo->hInstance = _Module.GetResourceInstance( );

    pObjectInfo->pszServerName = NULL;

    pObjectInfo->pszObjectName = m_pParent->m_pResNode->GetConName();

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_SECURPAGENAME , m_szPageName , SIZE_OF_BUFFER( m_szPageName ) ) );

    pObjectInfo->pszPageTitle = m_szPageName;

    return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CSecurityPage::GetSecurity( SECURITY_INFORMATION RequestedInformation , PSECURITY_DESCRIPTOR *ppSecurityDescriptor , BOOL bDefault )
{
#ifdef DBG
    if( RequestedInformation & OWNER_SECURITY_INFORMATION )
    {
        ODS( L"CSecurityPage::GetSecurity - OWNER_SECURITY_INFORMATION\n");
    }
    if( RequestedInformation & GROUP_SECURITY_INFORMATION )
    {
        ODS( L"CSecurityPage::GetSecurity - GROUP_SECURITY_INFORMATION\n");
    }
    if( RequestedInformation & DACL_SECURITY_INFORMATION )
    {
        ODS( L"CSecurityPage::GetSecurity - DACL_SECURITY_INFORMATION\n");
    }
    if( RequestedInformation & SACL_SECURITY_INFORMATION )
    {
        ODS( L"CSecurityPage::GetSecurity - SACL_SECURITY_INFORMATION\n");
    }

#endif

    if( 0 == RequestedInformation || NULL == ppSecurityDescriptor )
    {
        ASSERT( FALSE );

        return E_INVALIDARG;
    }

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
    {
        return FALSE;
    }

    LONG lSDsize;

    HRESULT hr;

    PSECURITY_DESCRIPTOR  pSD = NULL;

    if( bDefault )
    {
        hr = pCfgcomp->GetDefaultSecurityDescriptor( &lSDsize , &pSD );

        *ppSecurityDescriptor = pSD;

    }
    else
    {   
        BOOL bChanged = FALSE;

        hr = pCfgcomp->GetSecurityDescriptor( m_pParent->m_pResNode->GetConName( ) , &lSDsize , &pSD );
        
        // check for legacy "denied logoff" ace and remove.
        if( xxxLegacyLogoffCleanup( &pSD , &bChanged ) != ERROR_SUCCESS )
        {           
            hr = pCfgcomp->GetDefaultSecurityDescriptor( &lSDsize , &pSD );
        }        
        *ppSecurityDescriptor = pSD;
    }

    pCfgcomp->Release( );

    return hr;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CSecurityPage::SetSecurity( SECURITY_INFORMATION SecurityInformation ,PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
    HRESULT hr = S_OK;

    ICfgComp *pCfgcomp = NULL;

    PSECURITY_DESCRIPTOR pSD1;

    if( m_pParent == NULL || m_pParent->m_pResNode == NULL )
    {
        hr = E_UNEXPECTED;
    }

    else if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) != 0 )
    {
        long lSDsize;

        
        hr = pCfgcomp->GetSecurityDescriptor( m_pParent->m_pResNode->GetConName( ) , &lSDsize , &pSD1 );

        if( FAILED( hr ) )
        {
            pCfgcomp->Release( );

            return hr;
        }

        SECURITY_DESCRIPTOR_CONTROL sdc;
        DWORD dwREV;
        PACL pDacl = NULL;
        PACL pSacl = NULL;
        SECURITY_DESCRIPTOR absSD;
        BOOL bSaclPresent = FALSE;
        BOOL bSaclDefaulted = FALSE;
        BOOL bDaclPresent = FALSE;
        BOOL bDaclDefaulted = FALSE;

        //
        // Convert SelfRel to Absolute
        // ignore owner and group
        //


        GetSecurityDescriptorControl( pSD1 , &sdc , &dwREV );
                
        if( !InitializeSecurityDescriptor( &absSD , dwREV ) )
        {
            DBGMSG( L"TSCC!CSecurityPage_SetSecurity InitializeSecurityDescriptor failed with 0x%x\n" , GetLastError( ) );

            return E_FAIL;
        }

        GetSecurityDescriptorDacl( pSD1 , &bDaclPresent , &pDacl , &bDaclDefaulted );

        SetSecurityDescriptorDacl( &absSD , bDaclPresent , pDacl , bDaclDefaulted );

        GetSecurityDescriptorSacl( pSD1 , &bSaclPresent , &pSacl , &bSaclDefaulted );

        SetSecurityDescriptorSacl( &absSD , bSaclPresent , pSacl , bSaclDefaulted );

        // now call SetDACL or SACL depending on SecurityInformation

        if( SecurityInformation & OWNER_SECURITY_INFORMATION )
        {
            ODS( L"CSecurityPage::SetSecurity - OWNER_SECURITY_INFORMATION ( default value set )\n");
        }
        if( SecurityInformation & GROUP_SECURITY_INFORMATION )
        {
            ODS( L"CSecurityPage::SetSecurity - GROUP_SECURITY_INFORMATION ( default value set )\n");
        }
        if( SecurityInformation & DACL_SECURITY_INFORMATION )
        {
            ODS( L"CSecurityPage::SetSecurity - DACL_SECURITY_INFORMATION\n");

            GetSecurityDescriptorDacl( pSecurityDescriptor , &bDaclPresent , &pDacl , &bDaclDefaulted );
            
            SetSecurityDescriptorDacl( &absSD , bDaclPresent , pDacl , bDaclDefaulted );

        }
        if( SecurityInformation & SACL_SECURITY_INFORMATION )
        {
            ODS( L"CSecurityPage::SetSecurity - SACL_SECURITY_INFORMATION\n");

            GetSecurityDescriptorSacl( pSecurityDescriptor , &bSaclPresent , &pSacl , &bSaclDefaulted );           

            SetSecurityDescriptorSacl( &absSD , bSaclPresent , pSacl , bSaclDefaulted );
        }

        PSID SystemSid = NULL;

        SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;

        hr = E_OUTOFMEMORY;

        if( AllocateAndInitializeSid( &NtSidAuthority,
                                      1,
                                      SECURITY_LOCAL_SYSTEM_RID,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &SystemSid ) )
        {

            if( SystemSid != NULL )
            {
                hr = S_OK;
            }
        }

        PSECURITY_DESCRIPTOR pSD = NULL;

        DWORD dwSDLen;

        if( SUCCEEDED( hr ) )
        {
            VERIFY_S( TRUE , SetSecurityDescriptorOwner( &absSD , SystemSid , FALSE ) );

            VERIFY_S( TRUE, SetSecurityDescriptorGroup( &absSD , SystemSid , FALSE ) );
                        
            dwSDLen = 0;
            
            MakeSelfRelativeSD( &absSD, pSD, &dwSDLen);
            
            if (dwSDLen != 0)
            {
                pSD = ( LPBYTE )new BYTE[ dwSDLen ];
            }
           
        }

        if( pSD == NULL )
        {
            ODS( L"TSCC!CSecurityPage::SetSecurity - SD allocation failed\n" );

            hr = E_OUTOFMEMORY;
        }


        if( SUCCEEDED( hr ) )
        {
            if( !MakeSelfRelativeSD( &absSD , pSD , &dwSDLen ) )
            {                
                hr = E_UNEXPECTED;

                DBGMSG( L"MakeSelfRelativeSD - failed in  CSecurityPage::SetSecurity With error %x\n" , GetLastError( ) );
            }

            if( SUCCEEDED( hr ) )
            {
                hr = pCfgcomp->SetSecurityDescriptor(  m_pParent->m_pResNode->GetConName( ) , dwSDLen , pSD );
            }

            if( SUCCEEDED( hr ) )
            {
                ODS( L"TSCC : Update SD for TERMSRV\n" );

                hr = pCfgcomp->ForceUpdate( );

                // global flag can only be set to true

                m_pParent->m_bPropertiesChange = TRUE;
            }
            delete[] pSD;
        }

        if( SystemSid != NULL )
        {
            FreeSid( SystemSid );
        }

        // free originally stored SD.

        LocalFree( pSD1 );

        pCfgcomp->Release( );
    }
    return hr;
}


typedef HPROPSHEETPAGE (*CREATEPAGE_PROC) (LPSECURITYINFO);

//-----------------------------------------------------------------------------
HPROPSHEETPAGE GetSecurityPropertyPage( CPropsheet *pParent )
{
    LPVOID *pvFunction = &g_aAclFunctions[ ACLUI_CREATE_PAGE ].lpfnFunction;

    if( *pvFunction == NULL )
    {
        g_aAclFunctions[ ACLUI_CREATE_PAGE ].hInst = LoadLibrary( TEXT("ACLUI.DLL") );

        ASSERT( g_aAclFunctions[ ACLUI_CREATE_PAGE ].hInst != NULL );

        if( g_aAclFunctions[ ACLUI_CREATE_PAGE ].hInst == NULL )
        {
            return NULL;
        }

        *pvFunction =  ( LPVOID )GetProcAddress( g_aAclFunctions[ ACLUI_CREATE_PAGE ].hInst , g_aAclFunctions[ ACLUI_CREATE_PAGE ].pcstrFunctionName );

        ASSERT( *pvFunction != NULL );

        if( *pvFunction == NULL )
        {
            return NULL;
        }

        CComObject< CSecurityPage > *psecinfo = NULL;

        HRESULT hRes = CComObject< CSecurityPage >::CreateInstance( &psecinfo );

        if( SUCCEEDED( hRes ) )
        {
            // InitStrings();

            psecinfo->SetParent( pParent );

            return ( ( CREATEPAGE_PROC )*pvFunction )( psecinfo );
        }

    }

    return NULL;
}

//-----------------------------------------------------------------------------
// Error messag boxes
//
void ErrMessage( HWND hwndOwner , INT_PTR iResourceID )
{
    xxxErrMessage( hwndOwner , iResourceID , IDS_ERROR_TITLE , MB_OK | MB_ICONERROR );
}

//-----------------------------------------------------------------------------
void TscAccessDeniedMsg( HWND hwnd )
{
    xxxErrMessage( hwnd , IDS_TSCACCESSDENIED , IDS_TSCERRTITLE , MB_OK | MB_ICONERROR );
}

//-----------------------------------------------------------------------------
void TscGeneralErrMsg( HWND hwnd )
{
    xxxErrMessage( hwnd , IDS_TSCERRGENERAL , IDS_TSCERRTITLE , MB_OK | MB_ICONERROR );
}

//-----------------------------------------------------------------------------
void xxxErrMessage( HWND hwnd , INT_PTR nResMessageId , INT_PTR nResTitleId , UINT nFlags )
{
    TCHAR tchErrMsg[ 256 ];

    TCHAR tchErrTitle[ 80 ];

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) ,  ( UINT )nResMessageId , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) ) );

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) ,  ( UINT )nResTitleId , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) ) );

    if( hwnd == NULL )
    {
        nFlags |= MB_TASKMODAL;
    }

    MessageBox( hwnd , tchErrMsg , tchErrTitle , nFlags ) ; //MB_OK|MB_ICONERROR );
}

//-----------------------------------------------------------------------------

void ReportStatusError( HWND hwnd , DWORD dwStatus )
{
    LPTSTR pBuffer = NULL;

    TCHAR tchTitle[ 80 ];

    TCHAR tchBuffer[ 256 ];

    TCHAR tchErr[ 256 ];

    if( dwStatus != 0 )
    {

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_TSCERRTITLE , tchTitle , SIZE_OF_BUFFER( tchTitle ) ) );

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_REPORTERROR , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );


        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                     FORMAT_MESSAGE_FROM_SYSTEM,
                     NULL,                                          //ignored
                     dwStatus    ,                                //message ID
                     MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ), //message language
                     (LPTSTR)&pBuffer,                              //address of buffer pointer
                     0,                                             //minimum buffer size
                     NULL);                                         //no other arguments

        wsprintf( tchErr , tchBuffer , pBuffer );

        ::MessageBox( hwnd , tchErr , tchTitle , MB_OK | MB_ICONERROR );

        if( pBuffer != NULL )
        {
            LocalFree( pBuffer );
        }
    }

}

//=------------------------------------------------------------------------------------------------
// xxxLegacDenyCleanup -- checked for the old LOGOFF bit
//=------------------------------------------------------------------------------------------------
DWORD xxxLegacyLogoffCleanup( PSECURITY_DESCRIPTOR *ppSD , PBOOL pfDaclChanged )
{
    ACL_SIZE_INFORMATION asi;
    BOOL bDaclPresent;
    BOOL bDaclDefaulted;
    PACL pDacl = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwREV;
    SECURITY_DESCRIPTOR absSD;
    BOOL bSaclPresent;
    BOOL bSaclDefaulted;
    BOOL bOwnerDefaulted;
    PSID psidOwner = NULL;
    PVOID pAce = NULL;
    PACL pSacl = NULL;
    PSECURITY_DESCRIPTOR pOldSD = NULL;

    DWORD dwStatus = ERROR_SUCCESS;

    ZeroMemory( &asi , sizeof( ACL_SIZE_INFORMATION ) );

    if( !GetSecurityDescriptorDacl( *ppSD ,
                                    &bDaclPresent , 
                                    &pDacl,
                                    &bDaclDefaulted ) )
    {
        dwStatus = GetLastError();
        DBGMSG( L"xxxLegacyLogoffCleanup@GetSecurityDescriptorDacl returned 0x%x\n" , dwStatus );
        return dwStatus;
    }

    do
    {
        *pfDaclChanged = FALSE;

        if( !GetAclInformation( pDacl , &asi , sizeof( asi ) , AclSizeInformation ) )
        {
            dwStatus = GetLastError( );

            DBGMSG( L"xxxLegacyLogoffCleanup@GetAclInformation returned 0x%x\n" , dwStatus );

            break;
        }  

        // killed denied logoff.

        BYTE bAceType;

        for( int i = 0 ; i < ( int )asi.AceCount ; ++i )
        {
            if( !GetAce( pDacl , i , &pAce ) )
            {
                dwStatus = GetLastError( );

                DBGMSG( L"xxxLegacyLogoffCleanup@GetAce returned 0x%x\n" , dwStatus );

                break;
            }

            bAceType = ( ( PACE_HEADER )pAce )->AceType;

            if( bAceType == ACCESS_DENIED_ACE_TYPE || bAceType == ACCESS_ALLOWED_ACE_TYPE )
            {
                // if the denied ace represents a single bit get rid of it
                if( ( ( ACCESS_DENIED_ACE * )pAce )->Mask == WINSTATION_LOGOFF )
                {
                    if( DeleteAce( pDacl , i ) )
                    {
                        // pDacl should have been reallocated to we need to re-obtain the acl info
                        GetAclInformation( pDacl , &asi , sizeof( asi ) , AclSizeInformation );

                        // reset the loop to point to the first ace
                        i=-1;

                        *pfDaclChanged = TRUE;
                    }
                }
                else if( ( ( ACCESS_DENIED_ACE * )pAce )->Mask & WINSTATION_LOGOFF )
                {
                    // if the denied ace is a collection of bits with one as logoff turn the bit off
                    ( ( ACCESS_DENIED_ACE * )pAce )->Mask ^= WINSTATION_LOGOFF;

                    *pfDaclChanged = TRUE;
                }
            }
        }

        

        if( dwStatus == ERROR_SUCCESS && *pfDaclChanged )
        {
            //
            // Convert SelfRel to Absolute
            //

            DWORD dwSDLen = 0;
            
            pOldSD = *ppSD;

            GetSecurityDescriptorControl( *ppSD , &sdc , &dwREV );

            InitializeSecurityDescriptor( &absSD , dwREV );
    
            SetSecurityDescriptorDacl( &absSD , bDaclPresent , pDacl , bDaclDefaulted );

            GetSecurityDescriptorSacl( *ppSD , &bSaclPresent , &pSacl , &bSaclDefaulted );

            SetSecurityDescriptorSacl( &absSD , bSaclPresent , pSacl , bSaclDefaulted );

            GetSecurityDescriptorOwner( *ppSD , &psidOwner , &bOwnerDefaulted );

            SetSecurityDescriptorOwner( &absSD , psidOwner , FALSE );

            SetSecurityDescriptorGroup( &absSD , psidOwner , FALSE );            

            *ppSD = NULL;

            if( !MakeSelfRelativeSD( &absSD , *ppSD , &dwSDLen ) )
            {
                ODS( L"xxxLegacyLogoffCleanup -- MakeSelfRelativeSD failed as expected\n" );

                *ppSD = ( PSECURITY_DESCRIPTOR )LocalAlloc( LMEM_FIXED , dwSDLen );

                if( *ppSD == NULL )
                {
                    dwStatus = ERROR_NOT_ENOUGH_MEMORY;

                    DBGMSG( L"xxxLegacyLogoffCleanup -- LocalAlloc failed 0x%x\n" , dwStatus );

                    break;
                }

                if( !MakeSelfRelativeSD( &absSD , *ppSD , &dwSDLen ) )
                {
                    dwStatus = GetLastError( );

                    DBGMSG( L"xxxLegacyLogoffCleanup -- MakeSelfRelativeSD failed 0x%x\n" , dwStatus );

                    break;
                }   
                
            }            
        }

    }while( 0 );

    if( pOldSD != NULL )
    {
        LocalFree( pOldSD );
    }

    return dwStatus;

}

//
INT_PTR APIENTRY 
CustomSecurityDlgProc (
        HWND hDlg, 
        UINT uMsg, 
        WPARAM wParam, 
        LPARAM lParam)
{
    UNREFERENCED_PARAMETER( hDlg );

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // This may seem that it does nothin, but it casues this function to return TRUE
        // otherwise, you won't get this dialog!
        break;

    case WM_NOTIFY:
        
        switch (((NMHDR FAR*)lParam)->code)
        {

        case NM_CLICK:
        case NM_RETURN:
            if(wParam == IDC_GP_LINK)
            {
                ShellExecute(NULL,TEXT("open"),TEXT("gpedit.msc"),NULL,NULL,SW_SHOW);
                break;  
            }
            else
            {
                return FALSE;
            }
            

        default:
            return FALSE;
        }
        
        break;
    
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg,0);
            break;
        default:
            return FALSE;
        }

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\tscc.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// tscc.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f tsccps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "tscc.h"

#include "tswiz_i.c"
#include "tscc_i.c"
#include "srvsetex_i.c"


#include "Compdata.h"

LONG RecursiveDeleteKey( HKEY hKeyParent , LPTSTR lpszKeyChild );


extern const GUID GUID_ResultNode = { 0xfe8e7e84 , 0x6f63 , 0x11d2 , { 0x98, 0xa9 , 0x0 , 0x0a0 , 0xc9 , 0x25 , 0xf9 , 0x17 } };

TCHAR tchSnapKey[]    = TEXT( "Software\\Microsoft\\MMC\\Snapins\\" );

TCHAR tchNameString[] = TEXT( "NameString" );

TCHAR tchNameStringIndirect[] = TEXT( "NameStringIndirect" );

TCHAR tchAbout[]      = TEXT( "About" );

TCHAR tchNodeType[]   = TEXT( "NodeTypes" );

TCHAR tchStandAlone[] = TEXT( "StandAlone" );

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Compdata, CCompdata)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{        
        _Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
       
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKeyRoot , hKey;
    
    TCHAR tchGUID[ 40 ];

    TCHAR tchKey[ MAX_PATH ];//TEXT( "Software\\Microsoft\\MMC\\Snapins\\" );

    lstrcpy( tchKey , tchSnapKey );

    StringFromGUID2( CLSID_Compdata , tchGUID , SIZE_OF_BUFFER( tchGUID ) );

    lstrcat( tchKey , tchGUID );

    if( RegCreateKey( HKEY_LOCAL_MACHINE , tchKey , &hKeyRoot ) != ERROR_SUCCESS )
    {
        return GetLastError( );
    }

    TCHAR tchBuf[ MAX_PATH ];
    TCHAR tchSysDllPathName[ MAX_PATH ];
    
    GetModuleFileName( _Module.GetResourceInstance( ) , tchSysDllPathName , sizeof( tchSysDllPathName ) / sizeof( TCHAR ) );

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NAMESTRING , tchBuf , SIZE_OF_BUFFER( tchBuf ) ) );

    VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKeyRoot , tchNameString , NULL , REG_SZ , ( PBYTE )&tchBuf[ 0 ] , SIZE_OF_BUFFER( tchBuf ) ) );
    
    wsprintf( tchBuf , L"@%s,-%d", tchSysDllPathName , IDS_NAMESTRING );    

    VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKeyRoot , tchNameStringIndirect , NULL , REG_SZ , ( PBYTE )&tchBuf[ 0 ] , SIZE_OF_BUFFER( tchBuf ) ) );

    VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKeyRoot , tchAbout , NULL , REG_SZ , ( PBYTE )&tchGUID[ 0 ] , sizeof( tchGUID ) ) );
    
    lstrcpy( tchKey , tchStandAlone );

    RegCreateKey( hKeyRoot , tchKey , &hKey );

    RegCloseKey( hKey );

	lstrcpy( tchKey , tchNodeType );

	RegCreateKey( hKeyRoot , tchKey , &hKey );

	TCHAR szGUID[ 40 ];

	HKEY hDummy;

	StringFromGUID2( GUID_ResultNode , szGUID , SIZE_OF_BUFFER( szGUID ) );

	RegCreateKey( hKey , szGUID , &hDummy );

	RegCloseKey( hDummy );

	RegCloseKey( hKey );

    RegCloseKey( hKeyRoot );

	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HKEY hKey;

    TCHAR tchGUID[ 40 ];

    TCHAR tchKey[ MAX_PATH ];

    lstrcpy( tchKey , tchSnapKey );

    if( RegOpenKey( HKEY_LOCAL_MACHINE , tchKey , &hKey ) != ERROR_SUCCESS )
    {
        return GetLastError( ) ;
    }

    StringFromGUID2( CLSID_Compdata , tchGUID , SIZE_OF_BUFFER( tchGUID ) );

	RecursiveDeleteKey( hKey , tchGUID );
	
	RegCloseKey( hKey );
    
	_Module.UnregisterServer();

	return S_OK;
}

//---------------------------------------------------------------------------
// Delete a key and all of its descendents.
//---------------------------------------------------------------------------
LONG RecursiveDeleteKey( HKEY hKeyParent , LPTSTR lpszKeyChild )
{
	// Open the child.
	HKEY hKeyChild;

	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild , 0 , KEY_ALL_ACCESS, &hKeyChild);

	if (lRes != ERROR_SUCCESS)
	{
		return lRes;
	}

	// Enumerate all of the decendents of this child.

	FILETIME time;

	TCHAR szBuffer[256];

	DWORD dwSize = SIZE_OF_BUFFER( szBuffer );

	while( RegEnumKeyEx( hKeyChild , 0 , szBuffer , &dwSize , NULL , NULL , NULL , &time ) == S_OK )
	{
        // Delete the decendents of this child.

		lRes = RecursiveDeleteKey(hKeyChild, szBuffer);

		if (lRes != ERROR_SUCCESS)
		{
			RegCloseKey(hKeyChild);

			return lRes;
		}

		dwSize = SIZE_OF_BUFFER( szBuffer );
	}

	// Close the child.

	RegCloseKey( hKeyChild );

	// Delete this child.

	return RegDeleteKey( hKeyParent , lpszKeyChild );
}


extern "C" BOOL
IsWhistlerAdvanceServer()
{
    OSVERSIONINFOEX osVersionInfo;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (GetVersionEx((LPOSVERSIONINFO )&osVersionInfo))
    {
        return (osVersionInfo.wSuiteMask & VER_SUITE_ENTERPRISE) ||
               (osVersionInfo.wSuiteMask & VER_SUITE_DATACENTER);

    }
    else
    {
        return FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\tsprsht.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _TSPRSHT_H
#define _TSPRSHT_H

#include"baspdlg.h"
#include"todlg.h"
#include<mmc.h>
#include"rnodes.h"
// #include<objsel.h>
#include<commctrl.h>
// #include<winsta.h>
#include<aclui.h>
#include "asyncdlg.h"

#define NUM_OF_PRSHT 8

class CPropsheet
{
    int m_cref;

    LONG_PTR m_hNotify;

    CDialogPropBase *m_pDlg[ NUM_OF_PRSHT ];

    BOOL m_bGotUC;

    PUSERCONFIG m_puc;

    HWND m_hMMCWindow;

public:

    CPropsheet( );

    int AddRef( );

    int Release( );

    HRESULT InitDialogs( HWND , LPPROPERTYSHEETCALLBACK , CResultNode * , LONG_PTR );

    HRESULT SetUserConfig( USERCONFIG&  , PDWORD );

    BOOL ExcludeMachinePolicySettings(USERCONFIG& uc);

    BOOL GetUserConfig( BOOLEAN bPerformMerger );

    BOOL GetCurrentUserConfig( USERCONFIG&, BOOLEAN bPerformMerger );
    
    CResultNode *m_pResNode;

    void PreDestruct( );

    BOOL m_bPropertiesChange;

};

HPROPSHEETPAGE GetSecurityPropertyPage( CPropsheet * );

//-----------------------------------------------------------------------------
class CGeneral : public CDialogPropBase
{
    CPropsheet *m_pParent;

    Encryption *m_pEncrypt;

    DWORD m_DefaultEncryptionLevelIndex;

    INT_PTR m_nOldSel;

public:

    CGeneral( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL PersistSettings( HWND );

};

//-----------------------------------------------------------------------------
class CLogonSetting : public CDialogPropBase
{
    CPropsheet *m_pParent;

    WORD m_wOldId;

public:

    CLogonSetting( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL PersistSettings( HWND );

    BOOL IsValidSettings( HWND );

    BOOL ConfirmPassWd( HWND );

};

//-----------------------------------------------------------------------------
class CTimeSetting : public CDialogPropBase , public CTimeOutDlg
{
    CPropsheet *m_pParent;

    WORD m_wOldAction;

    WORD m_wOldCon;

	BOOL m_bPrevClient;

public:

    CTimeSetting( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    int GetCBXSTATEindex( HWND );

    void SetTimeoutControls(HWND);

    void SetBkResetControls(HWND);

    void SetReconControls(HWND);

    //void xxxSetControls( HWND , BOOL , int );

    BOOL IsValidSettings( HWND );

    BOOL PersistSettings( HWND );

    
};

/*-----------------------------------------------------------------------------
typedef struct _securedentry
{
    PSID psid;

    ACCESS_MASK amAllowed;

    ACCESS_MASK amDenied;

    TCHAR tchDisplayName[ 260 ];

    TCHAR tchADSPath[ 260 ];

    TCHAR tchType[ 20 ];

} SECUREDENTRY , * PSECUREDENTRY;

//-----------------------------------------------------------------------------
typedef struct _namedentry
{
    TCHAR tchNamedEntry[ 260 ];

    DWORD dwAcepos;

} NAMEDENTRY , * PNAMEDENTRY;

//-----------------------------------------------------------------------------
class CPerm : public CDialogPropBase
{
    CPropsheet *m_pParent;

    HWND m_lvUserGroups;

    HWND m_clPerms;

    HIMAGELIST m_hImglist;

    int m_iLastSelectedItem;

    LPBYTE m_pNE; // named entry blob

    int m_nNE;

public:

    CPerm( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL AddGroupUser( HWND );

    BOOL InsertSelectedItemsInList( HWND , PDSSELECTIONLIST );

    BOOL InitPriviledges( );

    BOOL InitImageList( );

    int GetObjectTypeIcon( LPTSTR );

    BOOL InitSecurityDialog( );

    BOOL ConvertSDtoEntries( PSECURITY_DESCRIPTOR  );

    BOOL ReleaseEntries( );

    BOOL SidToStr( PSID , LPTSTR );

    BOOL ItemDuplicate( PSID );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL GetMask( PDWORD , PDWORD );

    BOOL SetMask( DWORD , DWORD );

    BOOL PersistSettings( HWND ); 

    BOOL ConvertEntriesToSD( PSECURITY_DESCRIPTOR , PSECURITY_DESCRIPTOR * );

    BOOL RemoveGroupUser( HWND );

    BOOL RemoveNamedEntries( );

    BOOL AssembleNamedEntries( );

    BOOL FindNamedEntryAcePos( DWORD  , PSECUREDENTRY );

}; */

//-----------------------------------------------------------------------------
class CEnviro : public CDialogPropBase
{
    CPropsheet *m_pParent;

public:

    CEnviro( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    void SetControls( HWND , BOOL );

    BOOL PersistSettings( HWND ); 

};

//-----------------------------------------------------------------------------
class CRemote : public CDialogPropBase
{
    CPropsheet *m_pParent;

    WORD m_wOldRadioID;

    WORD m_wOldSel;

public:

    CRemote( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    void SetControls( HWND , BOOL );

    BOOL PersistSettings( HWND ); 
};

//-----------------------------------------------------------------------------
class CClient : public CDialogPropBase
{
    public:

        CClient( CPropsheet * );

        BOOL OnInitDialog( HWND , WPARAM , LPARAM );

        static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

        BOOL GetPropertySheetPage( PROPSHEETPAGE& );

        BOOL OnDestroy( );

        BOOL OnCommand( WORD , WORD , HWND );

        BOOL PersistSettings( HWND ); 

    private:

        void DetermineFieldEnabling(HWND hDlg);
        void SetColorDepthEntry( HWND );

        CPropsheet *m_pParent;

	    INT_PTR m_nColorDepth;
};

//-----------------------------------------------------------------------------
class CSecurityPage : public ISecurityInformation, public CComObjectRoot
{

    DECLARE_NOT_AGGREGATABLE( CSecurityPage )
    BEGIN_COM_MAP( CSecurityPage )
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

public:

    // *** ISecurityInformation methods ***

    STDMETHOD( GetObjectInformation )( PSI_OBJECT_INFO );

    STDMETHOD( GetSecurity )( SECURITY_INFORMATION , PSECURITY_DESCRIPTOR *, BOOL );

    STDMETHOD( SetSecurity )( SECURITY_INFORMATION , PSECURITY_DESCRIPTOR );
  
    STDMETHOD( GetAccessRights )( const GUID * , DWORD , PSI_ACCESS * , PULONG , PULONG );

    STDMETHOD( MapGeneric )( const GUID *, PUCHAR , ACCESS_MASK * );
  
    STDMETHOD( GetInheritTypes )( PSI_INHERIT_TYPE  * , PULONG );
  
    STDMETHOD( PropertySheetPageCallback )( HWND , UINT , SI_PAGE_TYPE );

    void SetParent( CPropsheet *  );
        
private:

    TCHAR m_szPageName[ 80 ];

    CPropsheet * m_pParent;

    BOOLEAN     m_WritablePermissionsTab;

};

//-----------------------------------------------------------------------------
class CTransNetwork : public CDialogPropBase
{
      CPropsheet *m_pParent;

      ULONG m_ulOldLanAdapter;

      WORD m_oldID;

      ULONG m_uMaxInstOld;

      BOOL m_RemoteAdminMode;

public:

    CTransNetwork( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL PersistSettings( HWND ); 

    BOOL IsValidSettings( HWND );

};


//-----------------------------------------------------------------------------
class CTransAsync : public CAsyncDlg , public CDialogPropBase
{
      CPropsheet *m_pParent;

public:
    BOOL IsValidSettings(HWND);

    CTransAsync( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    void SetControls( HWND , BOOL );

    BOOL PersistSettings( HWND ); 
};



BOOL InitStrings( );

BOOL FreeStrings( );


//-----------------------------------------------------------------------------
#endif // _TSPRSHT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\twiz.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include "tscc.h"
#include "tscfgex.h"
#include "compdata.h"
#include "resource.h"
#include "winsta.h"
#include "commctrl.h"

//#include "asyncdlg.h"

static USERCONFIG g_uc;

static ASYNCCONFIG g_ac;

static WS g_ws;

static TCHAR tchThirdPartyPath[] = TEXT("Software\\Microsoft\\Tscc\\");

void EnableGroup( HWND hParent , LPINT rgID , BOOL bEnable );

static int g_nAsyncOrNetwork;

extern void ErrMessage( HWND hwndOwner , INT_PTR iResourceID );

extern void TscAccessDeniedMsg( HWND hwnd );

extern void TscGeneralErrMsg( HWND hwnd );

extern BOOL IsValidConnectionName( LPTSTR szConName , PDWORD );

static BOOL g_bConnectionTypeChanged_forEncryption = FALSE;

static BOOL g_bConnectionTypeChanged_forConProps = FALSE;

LPEXTENDTSWIZARD g_pObj;

//-----------------------------------------------------------------------------
BOOL CDialogWizBase::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    UNREFERENCED_PARAMETER( idCtrl );

    if( pnmh->code == PSN_SETACTIVE )
    {
        PropSheet_SetWizButtons( GetParent( hDlg ) , PSWIZB_NEXT | PSWIZB_BACK );
    }

    return TRUE;
}


//***********************************************************************************
//                      Welcome Dialog

//-----------------------------------------------------------------------------
BOOL CWelcome::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );

    UNREFERENCED_PARAMETER( lp );

    ODS( L"TSCC-WIZ welcome\n" );

    LOGFONT lgfn;

    int iFontSize;

    TCHAR szFontSize[16];

    ZeroMemory( &lgfn , sizeof( LOGFONT ) );

    LoadString( _Module.GetResourceInstance( ) , IDS_VERDANABLDFONTSIZE , szFontSize , SIZE_OF_BUFFER(szFontSize) );

    iFontSize = _ttoi( szFontSize );

    HDC hdc = ::GetDC( NULL );

    if( hdc != NULL )
    {
        lgfn.lfHeight = MulDiv( -iFontSize , GetDeviceCaps(hdc , LOGPIXELSY), 72);

        LoadString( _Module.GetResourceInstance( ) , IDS_VERDANABLDFONTNAME , lgfn.lfFaceName , SIZE_OF_BUFFER(lgfn.lfFaceName) );

        m_hFont = CreateFontIndirect( &lgfn );

        ASSERT( m_hFont != NULL ); // let me know if we got it or not

        SendMessage( GetDlgItem( hwnd , IDC_STATIC_WELCOME ) , WM_SETFONT , ( WPARAM )m_hFont , MAKELPARAM( TRUE , 0 ) );

        g_nAsyncOrNetwork = 0;

        ReleaseDC( NULL , hdc );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CWelcome::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CWelcome *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CWelcome *pDlg = ( CWelcome * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CWelcome ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CWelcome * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CWelcome ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CWelcome::OnDestroy( )
{
    DeleteObject( m_hFont );

    return CDialogWizBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CWelcome::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_HIDEHEADER | PSP_USETITLE ;

    psp.pszTitle    = MAKEINTRESOURCE( IDS_WIZARDTITLE );

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_WELCOME );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CWelcome::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_WELCOMEHEADER );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_WELCOMESUBHEADER );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CWelcome::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    UNREFERENCED_PARAMETER( idCtrl );

    if( pnmh->code == PSN_SETACTIVE )
    {
        PropSheet_SetWizButtons( GetParent( hDlg ) , PSWIZB_NEXT );
    }

    return TRUE;
}

//***********************************************************************************
//                    Connection Type Dialog
// Determines the path the wizard will take in configuring the connection

//-----------------------------------------------------------------------------
CConType::CConType(  CCompdata *pCompdata )
{
    m_pCompdata = pCompdata;

    m_iOldSelection = -1;
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CConType::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CConType *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CConType *pDlg = ( CConType * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CConType ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CConType * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CConType ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CConType::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );
    //
    // Obtain a list of entries for the contype
    // if not RDP remove the last two entries on the list

    AddEntriesToConType( hwnd );


    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CConType::OnNotify( int idCtrl, LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        SetConType( hDlg );
    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );

}

//-----------------------------------------------------------------------------
// Place entries in connection type combx
//-----------------------------------------------------------------------------
BOOL CConType::AddEntriesToConType( HWND hDlg )
{
    HWND hCtrl = GetDlgItem( hDlg , IDC_COMBO_WIZ_CONTYPE );

    ICfgComp *pCfgcomp = NULL;

    ULONG cbSize = 0;

    ULONG ulItems = 0;

    WDNAMEW *wszWdname = NULL;

    BOOL ret = FALSE;


    if( !IsWindow( hCtrl ) )
    {
        return ret;
    }

    if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
    {
        return ret;
    }

    if( SUCCEEDED( pCfgcomp->GetWdTypeList( &ulItems , &cbSize , ( WCHAR ** )&wszWdname ) ) )
    {
        for( ULONG i = 0; i < ulItems ; i++ )
        {
            SendMessage( hCtrl , CB_ADDSTRING , 0 , ( LPARAM )&wszWdname[ i ] );
        }

        CoTaskMemFree( wszWdname );

        SendMessage( hCtrl , CB_SETCURSEL , 0 , 0 );

        ret = TRUE;
    }
    else
    {
        ODS( L"GetWdTypeList -- failed\n" );

        ret = FALSE;
    }

    pCfgcomp->Release( );

    return ret;
}

//-----------------------------------------------------------------------------
BOOL CConType::SetConType( HWND hwnd )
{
    // PROPSHEETPAGE psp;

    TCHAR tchWdName[ WDNAME_LENGTH + 1 ];

    INT_PTR idx = SendMessage( GetDlgItem( hwnd , IDC_COMBO_WIZ_CONTYPE ) , CB_GETCURSEL , 0 , 0 );

    if( idx == CB_ERR )
    {
        return FALSE;
    }

    if( idx != m_iOldSelection )
    {
        g_bConnectionTypeChanged_forEncryption = TRUE;

        g_bConnectionTypeChanged_forConProps = TRUE;

        m_iOldSelection = (INT)idx;
    }

    SendMessage( GetDlgItem( hwnd , IDC_COMBO_WIZ_CONTYPE ) , CB_GETLBTEXT , idx , ( LPARAM )tchWdName );

    lstrcpy( g_ws.wdName , tchWdName );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CConType::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_CONNECTION_TYPE );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CConType::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_CONTYPE );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_CONTYPE );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CConType::OnDestroy( )
{
    // m_hOtherPages.DeleteArray( );

    return CDialogWizBase::OnDestroy( );
}

//***********************************************************************************
//                  Network Lan adapters

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CLan::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CLan *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CLan *pDlg = ( CLan * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CLan ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CLan * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CLan ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    }

    return FALSE;
}

//-----------------------------------------------------------------------------
CLan::CLan( CCompdata *pCompdata )
{
   m_pCompdata = pCompdata;
}

//-----------------------------------------------------------------------------
BOOL CLan::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );

    // DEVICENAMEW *pdnw = NULL;

    PGUIDTBL pGuidtbl = NULL;

    ICfgComp *pCfgcomp = NULL;

    // ULONG cbSize = 0;

    ULONG ulItems = 0;

    SendMessage( GetDlgItem( hDlg , IDC_SPIN_WZ ) , UDM_SETRANGE32 , 0 , ( LPARAM )999999 );

    if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
    {
        ODS( L"CLan::OnInitDialog GetServer failed\n" );

        return FALSE;
    }

    if( SUCCEEDED( pCfgcomp->GetLanAdapterList2( g_ws.pdName , &ulItems , &pGuidtbl ) ) )
    {
        for( ULONG i = 0 ; i < ulItems ; i++ )
        {
            SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_ADDSTRING , 0 , ( LPARAM )pGuidtbl[ i ].DispName );

            SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_SETITEMDATA , ( WPARAM )i , ( LPARAM )pGuidtbl[ i ].dwLana );
        }

        SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_SETCURSEL , 0 , 0 );

        pCfgcomp->BuildGuidTable( &pGuidtbl , ulItems , g_ws.pdName  );

        CoTaskMemFree( pGuidtbl );
    }


    // LanAdapter list requires protocol type
    /*

    if( SUCCEEDED( pCfgcomp->GetLanAdapterList( g_ws.pdName , &ulItems , &cbSize , ( WCHAR ** )&pdnw ) ) )
    {
        for( ULONG i = 0 ; i < ulItems ; i++ )
        {
            if( pdnw[ i ] != NULL )
            {
                SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_ADDSTRING , 0 , ( LPARAM )pdnw[ i ] );
            }
        }

        SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_SETCURSEL , 0 , 0 );

        CoTaskMemFree( pdnw );
    }
    */

    pCfgcomp->Release( );


    SendMessage( GetDlgItem( hDlg , IDC_CHECK_LAN_UNLIMITEDCON ) , BM_CLICK , 0 , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_LAN_MAXCONS ) , EM_SETLIMITTEXT , ( WPARAM )6 , 0 );


    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CLan::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED)
    {
        if(wID == IDC_CHECK_LAN_UNLIMITEDCON )
        {
            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_LAN_MAXCONS ) , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );

            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_SPIN_WZ ) , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );

            SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_RADIO_MAXCON),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);
        }

        else if(wID == IDC_RADIO_MAXCON)
        {

            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_LAN_MAXCONS ) , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED );

            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_SPIN_WZ ) , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED );

            SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_LAN_UNLIMITEDCON),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);

            SetFocus( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_LAN_MAXCONS ) );

            SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_LAN_MAXCONS ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

		}

    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CLan::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_LAN_UNLIMITEDCON ), BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
        {
            UINT uMax;

            BOOL bOK = FALSE;

            uMax = GetDlgItemInt( hDlg , IDC_EDIT_LAN_MAXCONS , &bOK , FALSE );

            if( !bOK  || uMax > 999999UL )
            {
                ErrMessage( hDlg , IDS_ERR_CONREADFAIL );

                //MessageBox( hDlg , L"Maximum number of connections allowed is 999,999" , L"Error" , MB_OK|MB_ICONERROR );

                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                return TRUE;
            }
        }
        // check for unique lanadapter

        ICfgComp *pCfgcomp;

        if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
        {
            return FALSE;
        }

        INT_PTR iSel = SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_GETCURSEL , 0 , 0 );

        BOOL bUnique = FALSE;

        if( iSel != CB_ERR )
        {
            g_ws.LanAdapter = ( DWORD )SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_GETITEMDATA , ( WPARAM )iSel , 0 );


            if( SUCCEEDED( pCfgcomp->IsNetWorkConnectionUnique( g_ws.wdName , g_ws.pdName , ( ULONG )g_ws.LanAdapter , &bUnique ) ) )
            {
                if( !bUnique )
                {
                    TCHAR tchMessage[256];

                    TCHAR tchWarn[40];

                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ERR_UNIQUECON , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWarn , SIZE_OF_BUFFER( tchWarn ) ) );

                    MessageBox( hDlg , tchMessage , tchWarn , MB_ICONINFORMATION | MB_OK );

                    SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                    pCfgcomp->Release( );

                    return TRUE;
                }
            }
        }

        g_ws.PdClass = SdNetwork;

        pCfgcomp->Release( );


        //g_ws.LanAdapter = ( ULONG )iSel;

        if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_LAN_UNLIMITEDCON ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
        {
            g_ws.uMaxInstanceCount = ( ULONG )-1;
        }
        else
        {
            g_ws.uMaxInstanceCount = GetDlgItemInt( hDlg , IDC_EDIT_LAN_MAXCONS , &bUnique , FALSE );

        }

    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}
//-----------------------------------------------------------------------------
BOOL CLan::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_LAN );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CLan::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_LAN );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_LAN );

    return TRUE;
}

//***********************************************************************************
//                      Security dialog -- MSGina or your gina


//-----------------------------------------------------------------------------
CSecurity::CSecurity( CCompdata *pCompdata )
{
    m_pCompdata = pCompdata;

    m_pEncrypt = NULL;

    m_DefaultEncryptionLevelIndex = 0;
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CSecurity::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CSecurity *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CSecurity *pDlg = ( CSecurity * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CSecurity ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CSecurity * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CSecurity ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;



    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;


    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;

    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CSecurity::OnDestroy( )
{
    if( m_pEncrypt != NULL )
    {
        CoTaskMemFree( m_pEncrypt );
    }

    return CDialogWizBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CSecurity::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{

    if( wNotifyCode == CBN_SELCHANGE && wID == IDC_COMBO_ENCRYPT_LVL )
    {
        if( SendMessage( hwndCtrl , CB_GETDROPPEDSTATE , 0 , 0 ) == FALSE )
        {
            INT_PTR nSel = SendMessage( hwndCtrl , CB_GETCURSEL , 0 , 0 );

            if( nSel != CB_ERR && m_pEncrypt != NULL )
            {
                if( m_pEncrypt[ nSel ].szDescr[ 0 ] == 0 )
                {

                    EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_DESCRIPTION ) , FALSE );


                    ShowWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_DESCRIPTION ) , SW_HIDE );
                }
                else
                {

                    ShowWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_DESCRIPTION ) , SW_SHOW );

                    EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_DESCRIPTION ) , TRUE );


                    SetWindowText( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_DESCRIPTION ) ,  m_pEncrypt[ nSel ].szDescr );
                }

                if( !IsWindowEnabled( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_DESCRIPTION ) ) )
                {
                    RECT rc;
                    RECT rc2;

                    GetWindowRect( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_ENCGRP ) , &rc );

                    GetWindowRect( GetDlgItem( GetParent( hwndCtrl ), IDC_STATIC_DESCRIPTION ) , &rc2 );

                    rc.bottom = rc2.top;

                    MapWindowPoints( NULL , GetParent( hwndCtrl ) , ( LPPOINT )&rc , 2 );

                    SetWindowPos( GetDlgItem( GetParent( hwndCtrl ), IDC_STATIC_ENCGRP ) , 0 , 0 , 0 , rc.right - rc.left , rc.bottom - rc.top , SWP_NOMOVE | SWP_SHOWWINDOW );


                    //resize window
                }

            }
        }

    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CSecurity::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );
    // Obtain USERCONFIG struct to determine if msgina is enabled or not
    // otherwise load thirdparty level's of encryption
    /*
    ICfgComp *pCfgcomp;

    if( m_pCompdata->GetServer( &pCfgcomp ) != 0 )
    {
        ULONG ulItems;

        // WdName is an enumtype

        if( SUCCEEDED( pCfgcomp->GetEncryptionLevels( g_ws.wdName , WdName , &ulItems , &m_pEncrypt ) ) )
        {
            for( ULONG i = 0; i < ulItems; ++i )
            {
                SendMessage( GetDlgItem( hwnd , IDC_COMBO_ENCRYPT_LVL ) , CB_ADDSTRING , 0 , ( LPARAM )m_pEncrypt[ i ].szLevel );
                if(m_pEncrypt[ i ].Flags & ELF_DEFAULT)
                {
                    m_DefaultEncryptionLevelIndex = i;
                }
            }

            SendMessage( GetDlgItem( hwnd , IDC_COMBO_ENCRYPT_LVL ) , CB_SETCURSEL , (WPARAM)m_DefaultEncryptionLevelIndex, 0 );

            OnCommand( CBN_SELCHANGE , IDC_COMBO_ENCRYPT_LVL , GetDlgItem( hwnd , IDC_COMBO_ENCRYPT_LVL ) );



        }

        pCfgcomp->Release( );
    }
    */

    CheckDlgButton(  hwnd,               // handle to dialog box
                     IDC_CHECK_ENCRYPT,  // button-control identifier
                     BST_UNCHECKED       // check state
                  );


    //SendMessage( GetDlgItem( hwnd , IDC_CHECK_ENCRYPT ) , BM_CLICK , 0 , 0 );

    return FALSE;
}

//-----------------------------------------------------------------------------
// Save out information when going to the next area
//-----------------------------------------------------------------------------
BOOL CSecurity::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_SETACTIVE && g_bConnectionTypeChanged_forEncryption )
    {
        ODS( L"Encryption PSN_SETACTIVE\n" );

        ICfgComp *pCfgcomp;

        if( m_pCompdata->GetServer( &pCfgcomp ) != 0 )
        {
            ULONG ulItems = 0;

            HWND hCombo = GetDlgItem( hDlg , IDC_COMBO_ENCRYPT_LVL );

            ASSERT( hCombo != NULL );

            // Remove everything from the list

            SendMessage( hCombo , CB_RESETCONTENT , 0 , 0 );


            // WdName is an enumtype

            if( m_pEncrypt != NULL )
            {
                CoTaskMemFree( m_pEncrypt );

                m_pEncrypt = NULL;
            }

            if( SUCCEEDED( pCfgcomp->GetEncryptionLevels( g_ws.wdName , WdName , &ulItems , &m_pEncrypt ) ) )
            {
                for( ULONG i = 0; i < ulItems; ++i )
                {
                    SendMessage( hCombo , CB_ADDSTRING , 0 , ( LPARAM )m_pEncrypt[ i ].szLevel );

                    if( m_pEncrypt[ i ].Flags & ELF_DEFAULT )
                    {
                        m_DefaultEncryptionLevelIndex = i;

                    }
                }

                SendMessage( hCombo , CB_SETCURSEL , ( WPARAM )m_DefaultEncryptionLevelIndex, 0 );

                OnCommand( CBN_SELCHANGE , IDC_COMBO_ENCRYPT_LVL , hCombo );

                // SendMessage( GetDlgItem( hDlg , IDC_CHECK_ENCRYPT ) , BM_CLICK , 0 , 0 );
            }
            else
            {
                // no encryption info insert value to none and grey out the control
                TCHAR tchNone[ 80 ];

                LoadString( _Module.GetResourceInstance( ) , IDS_NONE , tchNone , SIZE_OF_BUFFER( tchNone ) );

                SendMessage( hCombo , CB_ADDSTRING , 0 , ( LPARAM )tchNone );

                SendMessage( hCombo , CB_SETCURSEL , 0 , 0 );

                EnableWindow( hCombo , FALSE );
            }


            pCfgcomp->Release( );
        }

        g_bConnectionTypeChanged_forEncryption = FALSE;
    }

    else if( pnmh->code == PSN_WIZNEXT )
    {
        if( m_pEncrypt != NULL )
        {
            INT_PTR iSel = SendMessage( GetDlgItem( hDlg , IDC_COMBO_ENCRYPT_LVL ) , CB_GETCURSEL , 0  , 0 );

            if( iSel != CB_ERR )
            {
                g_uc.MinEncryptionLevel = ( UCHAR )m_pEncrypt[iSel].RegistryValue;
            }
            else
            {
                g_uc.MinEncryptionLevel = ( UCHAR )m_pEncrypt[m_DefaultEncryptionLevelIndex].RegistryValue;
            }
        }
        else
        {
            g_uc.MinEncryptionLevel = 0;
        }


        g_uc.fUseDefaultGina = SendMessage( GetDlgItem( hDlg , IDC_CHECK_ENCRYPT ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED;
    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

//-----------------------------------------------------------------------------
BOOL CSecurity::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_SECURITY );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CSecurity::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_SECURITY );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_SECURITY );

    return TRUE;
}

//***********************************************************************************
//                      Timeout settings dialog
//
#if 0 // not used in the connection wizard
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CTimeout::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CTimeout *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CTimeout *pDlg = ( CTimeout * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CTimeout ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CTimeout * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CTimeout ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    }
    return FALSE;
}

//-----------------------------------------------------------------------------
// Set time out settings to a default setting
//-----------------------------------------------------------------------------
BOOL CTimeout::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    TCHAR tchBuffer[ 80 ];

    HWND hCombo[ 3 ] =
    {
        GetDlgItem( hwnd , IDC_COMBO_CON_WZ ),

        GetDlgItem( hwnd , IDC_COMBO_DISCON_WZ ),

        GetDlgItem( hwnd , IDC_COMBO_IDLE_WZ )
    };

    DWORD rgdwTime[] = { 0 , 1 , 5 , 10 , 15 , 30 , 60 , 120 , 180 , 1440 , 2880 , ( DWORD )-1 };


    for( int idx = 0; rgdwTime[ idx ] != ( DWORD)-1; ++idx )
    {
        if( rgdwTime[ idx ] == 0 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );
        }
        else
        {
            ConvertToDuration( rgdwTime[ idx ] , tchBuffer );
        }

        for( int inner = 0 ; inner < 3 ; ++inner )
        {
            SendMessage( hCombo[ inner ] , CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );

            SendMessage( hCombo[ inner ] , CB_SETITEMDATA , idx , rgdwTime[ idx ] );
        }
    }


    SendMessage( hCombo[ 0 ] , CB_SETCURSEL , 0 , 0 );

    SendMessage( hCombo[ 1] , CB_SETCURSEL , 0 , 0 );

    SendMessage( hCombo[ 2 ] , CB_SETCURSEL , 0 , 0 );

    // force WM_COMMAND to be sent

    SendMessage( GetDlgItem( hwnd , IDC_RADIO_UDCCS_WZ ) , BM_CLICK , 0 , 0 ) ;

    LoadAbbreviates( );

    return FALSE;

}

//-----------------------------------------------------------------------------
BOOL CTimeout::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    BOOL bEnable;

    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_RADIO_UDCCS_WZ  )
        {
            bEnable = FALSE;
        }
        else
        {
            bEnable = TRUE;
        }

        int rgID[] = { IDC_STATIC_CON , IDC_STATIC_DISCON , IDC_STATIC_IDLE , IDC_COMBO_CON_WZ , IDC_COMBO_DISCON_WZ  , IDC_COMBO_IDLE_WZ , -1 };

        EnableGroup( GetParent( hwndCtrl ) , &rgID[0] , bEnable );

    }

    CTimeOutDlg::OnCommand( wNotifyCode , wID , hwndCtrl );

    return FALSE;
}

//-----------------------------------------------------------------------------
// return TRUE if wish not to continue to the next page
//-----------------------------------------------------------------------------
BOOL CTimeout::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_UDCCS_WZ ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
        {
            g_uc.fInheritMaxSessionTime = 1;

            g_uc.fInheritMaxDisconnectionTime = 1;

            g_uc.fInheritMaxIdleTime = 1;
        }
        else
        {
            g_uc.fInheritMaxSessionTime = 0;

            g_uc.fInheritMaxDisconnectionTime = 0;

            g_uc.fInheritMaxIdleTime = 0;

            if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_CON_WZ ) , &g_uc.MaxConnectionTime ) )
            {
                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                return TRUE;
            }

            if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_DISCON_WZ ) , &g_uc.MaxDisconnectionTime ) )
            {
                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                return TRUE;
            }

            if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_IDLE_WZ ) , &g_uc.MaxIdleTime ) )
            {
                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                return TRUE;
            }
        }

    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

//-----------------------------------------------------------------------------
BOOL CTimeout::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_TIMEOUT );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CTimeout::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_TIMEOUT );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_TIMEOUT );

    return TRUE;
}

//-----------------------------------------------------------------------------
int CTimeout::GetCBXSTATEindex( HWND hCombo )
{
    int idx = -1;

    switch( GetDlgCtrlID( hCombo ) )
    {
    case IDC_COMBO_CON_WZ:

        idx = 0;

        break;

    case IDC_COMBO_DISCON_WZ:

        idx = 1;

        break;

    case IDC_COMBO_IDLE_WZ:

        idx = 2;

        break;
    }

    return idx;
}

#endif
//***********************************************************************************

#if 0 // object not used in connection wizard
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CAutoLogon::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CAutoLogon *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CAutoLogon *pDlg = ( CAutoLogon * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CAutoLogon ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CAutoLogon * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CAutoLogon ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CAutoLogon::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    int rgID[] = { IDC_EDIT_USRNAME_WZ , IDC_STATIC_USRNAME ,  IDC_EDIT_DOMAIN_WZ , IDC_STATIC_DOMAIN , IDC_EDIT_PASSWD_WZ , IDC_STATIC_PASSWD , IDC_EDIT_CONFIRM_WZ , IDC_STATIC_CONPASSWD , -1 };

    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_CHECK_ICCP_WZ )
        {
            BOOL bChecked = SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ;

            EnableGroup( GetParent( hwndCtrl ) , &rgID[ 0 ] , !bChecked );

            if( !bChecked )
            {
                EnableGroup( GetParent( hwndCtrl ) , &rgID[ 4 ] , !( SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_CHECK_PROMPTPASSWD_WZ )  , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ) );
                SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_RADIO_LGINFO_WZ),BM_SETCHECK,(WPARAM)BST_CHECKED,0);

            }
            else
            {
                SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_RADIO_LGINFO_WZ),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);
            }

        }
        else if( wID == IDC_CHECK_PROMPTPASSWD_WZ )
        {
            if( SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_CHECK_ICCP_WZ )  , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
            {
                EnableGroup( GetParent( hwndCtrl ) , &rgID[ 4 ] , !( SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ) );
            }
        }
        else if( wID == IDC_RADIO_LGINFO_WZ )
        {
            BOOL bChecked = SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ;

            if(bChecked)
            {
                SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_ICCP_WZ),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);

                EnableGroup( GetParent( hwndCtrl ) , &rgID[ 0 ] , TRUE );

                EnableGroup( GetParent( hwndCtrl ) , &rgID[ 4 ] , !( SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_CHECK_PROMPTPASSWD_WZ )  , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ) );

            }
            else
            {
                SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_ICCP_WZ),BM_SETCHECK,(WPARAM)BST_CHECKED,0);
            }
            //SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_ICCP_WZ),BM_CLICK,0,0);
        }

    }
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CAutoLogon::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    SendMessage( GetDlgItem( hwnd , IDC_EDIT_USRNAME_WZ ) , EM_SETLIMITTEXT , ( WPARAM )USERNAME_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_DOMAIN_WZ ) , EM_SETLIMITTEXT , ( WPARAM )DOMAIN_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_PASSWD_WZ ) , EM_SETLIMITTEXT , ( WPARAM )PASSWORD_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_CONFIRM_WZ ) , EM_SETLIMITTEXT , ( WPARAM )PASSWORD_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_ICCP_WZ ) , BM_CLICK , 0 , 0 );

    return FALSE;
}


//-----------------------------------------------------------------------------
BOOL CAutoLogon::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_AUTO_LOGON );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CAutoLogon::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HEADER_LOGONSETTINGS );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHEADER_LOGONSETTINGS );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CAutoLogon::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        g_uc.fInheritAutoLogon = SendMessage( GetDlgItem( hDlg , IDC_CHECK_ICCP_WZ ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

        if( !g_uc.fInheritAutoLogon )
        {
            if( !ConfirmPwd( hDlg ) )
            {
                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                return TRUE;
            }
        }

         GetWindowText( GetDlgItem( hDlg , IDC_EDIT_USRNAME_WZ ) , g_uc.UserName , SIZE_OF_BUFFER( g_uc.UserName ) );

         GetWindowText( GetDlgItem( hDlg , IDC_EDIT_DOMAIN_WZ ) , g_uc.Domain , SIZE_OF_BUFFER( g_uc.Domain ) );

         GetWindowText( GetDlgItem( hDlg , IDC_EDIT_PASSWD_WZ ) , g_uc.Password , SIZE_OF_BUFFER( g_uc.Password ) );

         g_uc.fPromptForPassword = SendMessage( GetDlgItem( hDlg , IDC_CHECK_PROMPTPASSWD_WZ ) ,

                BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

//-----------------------------------------------------------------------------
BOOL CAutoLogon::ConfirmPwd( HWND hDlg )
{
    TCHAR tchPzWd[ PASSWORD_LENGTH + 1];

    TCHAR tchConfirm[ PASSWORD_LENGTH + 1];

    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_INHERIT ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
    {
        return TRUE;
    }

    int iSz = GetWindowText( GetDlgItem( hDlg , IDC_EDIT_PASSWD_WZ ) , tchPzWd , SIZE_OF_BUFFER( tchPzWd ) );

    // warn on the minimum and maximum sizes

    if( iSz > 0 && ( iSz < 6 || iSz > PASSWORD_LENGTH ) )
    {

        ErrMessage( hDlg , IDS_ERR_PASSWD );

        SetFocus( GetDlgItem( hDlg , IDC_EDIT_PASSWD_WZ ) );

        SendMessage( GetDlgItem( hDlg , IDC_EDIT_PASSWD_WZ ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_CONFIRM_WZ ) , L"" );

        return FALSE;
    }

    int iSz2 = GetWindowText( GetDlgItem( hDlg , IDC_EDIT_CONFIRM_WZ ) , tchConfirm , SIZE_OF_BUFFER( tchConfirm ) );

    if( iSz == iSz2 )
    {
        if( iSz == 0 )
        {
            return TRUE;
        }

        if( lstrcmp( tchPzWd , tchConfirm ) == 0 )
        {
            return TRUE;
        }
    }

    ErrMessage( hDlg , IDS_ERR_PASSCONFIRM );

    SetFocus( GetDlgItem( hDlg , IDC_EDIT_CONFIRM_WZ ) );

    SetWindowText( GetDlgItem( hDlg , IDC_EDIT_CONFIRM_WZ ) , L"" );

    return FALSE;
}

#endif
//***********************************************************************************

#if 0 // object no longer used in connection wizard
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CInitProg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CInitProg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CInitProg *pDlg = ( CInitProg * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CInitProg ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CInitProg * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CInitProg ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    }
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CInitProg::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    SendMessage( GetDlgItem( hwnd , IDC_EDIT_INITPROG_CMDLINE ) , EM_SETLIMITTEXT , ( WPARAM )INITIALPROGRAM_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_INITPROG_WD ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_INITPROG_INHERIT ) , BM_CLICK , 0 , 0 );

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CInitProg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED && wID == IDC_CHECK_INITPROG_INHERIT )
    {
        int rgID[] = { IDC_EDIT_INITPROG_CMDLINE , IDC_STATIC_CMDLINE , IDC_EDIT_INITPROG_WD , IDC_STATIC_WF , -1 };

        EnableGroup( GetParent( hwndCtrl ) , &rgID[0] , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CInitProg::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_INITIAL_PROGRAM );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CInitProg::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_INITPRG );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_INITPRG );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CInitProg::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    g_uc.fInheritInitialProgram = SendMessage( GetDlgItem( hDlg , IDC_CHECK_INITPROG_INHERIT ) , BM_GETCHECK , 0 , 0 );

    if( !g_uc.fInheritInitialProgram )
    {
        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_INITPROG_CMDLINE ) , g_uc.InitialProgram , SIZE_OF_BUFFER( g_uc.InitialProgram ) );

        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_INITPROG_WD ) , g_uc.WorkDirectory , SIZE_OF_BUFFER( g_uc.WorkDirectory ) );
    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

#endif
//***********************************************************************************

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CRemotectrl::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CRemotectrl *pDlg;

    if( msg == WM_INITDIALOG )
    {
        pDlg = ( CRemotectrl * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CRemotectrl ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CRemotectrl * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CRemotectrl ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;


    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
// Set default values for Remote control dialog
//-----------------------------------------------------------------------------
BOOL CRemotectrl::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );

    SendMessage( GetDlgItem( hwnd , IDC_RADIO_REMOTECTRL_WATCH ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_REMOTECTRL_NOTIFYUSER ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

    SendMessage( GetDlgItem( hwnd  , IDC_RADIO_INHERIT_REMOTE_CONTROL ) , BM_CLICK , 0 , 0 );

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CRemotectrl::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED && wID == IDC_RADIO_INHERIT_REMOTE_CONTROL ||

        wID == IDC_RADIO_REMOTECTRL_NO || wID == IDC_RADIO_ENABLE_REMOTECONTROL )
    {
        int rgID[] = { IDC_CHECK_REMOTECTRL_NOTIFYUSER , IDC_RADIO_REMOTECTRL_WATCH , IDC_RADIO_REMOTECTRL_CONTROL , -1 };

        EnableGroup( GetParent( hwndCtrl ) , rgID , SendMessage( GetDlgItem( GetParent( hwndCtrl ) ,

            IDC_RADIO_ENABLE_REMOTECONTROL ) , BM_GETCHECK ,  0 , 0 ) == BST_CHECKED );

    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CRemotectrl::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_INHERIT_REMOTE_CONTROL ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
        {
            g_uc.fInheritShadow = FALSE;

            if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_REMOTECTRL_NO ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
            {
                BOOL bCheckNotify = ( BOOL )SendMessage( GetDlgItem( hDlg , IDC_CHECK_REMOTECTRL_NOTIFYUSER ) , BM_GETCHECK , 0 , 0 );

                BOOL bRadioControl = ( BOOL )SendMessage( GetDlgItem( hDlg , IDC_RADIO_REMOTECTRL_CONTROL ) , BM_GETCHECK , 0 , 0 );

                if( bCheckNotify )
                {
                    if( bRadioControl )
                    {
                        g_uc.Shadow = Shadow_EnableInputNotify;
                    }
                    else
                    {
                        g_uc.Shadow = Shadow_EnableNoInputNotify;
                    }
                }
                else
                {
                    if( bRadioControl )
                    {
                        g_uc.Shadow = Shadow_EnableInputNoNotify;
                    }
                    else
                    {
                        g_uc.Shadow = Shadow_EnableNoInputNoNotify;
                    }
                }
            }
            else
            {
                g_uc.Shadow = Shadow_Disable;
            }

        }
        else
        {
            g_uc.fInheritShadow = TRUE;
        }

    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}


//-----------------------------------------------------------------------------
BOOL CRemotectrl::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_REMOTE_CONTROL );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CRemotectrl::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_REMOTE );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_REMOTE );

    return TRUE;
}

//***********************************************************************************
#if 0 // object not used in connection wizard
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CWallPaper::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CWallPaper *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CWallPaper *pDlg = ( CWallPaper * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CWallPaper ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CWallPaper * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CWallPaper ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CWallPaper::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CWallPaper::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_WALLPAPER );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CWallPaper::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_WALLPR );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_WALLPR );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CWallPaper::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        g_uc.fWallPaperDisabled = SendMessage( GetDlgItem( hDlg , IDC_CHECK_WALLPAPER ) , BM_GETCHECK , 0 , 0  );
    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

#endif
//***********************************************************************************

//-----------------------------------------------------------------------------
CConProp::CConProp( CCompdata *pCompdata )
{
    m_pCompdata = pCompdata;

    m_iOldSel = -1;
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CConProp::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CConProp *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CConProp *pDlg = ( CConProp * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CConProp ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CConProp * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CConProp ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CConProp::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );

    g_pObj = NULL;

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_COMMENT_WZ ) , EM_SETLIMITTEXT , ( WPARAM )WINSTATIONCOMMENT_LENGTH , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_WSNAME_WZ ) , EM_SETLIMITTEXT , ( WPARAM )( WINSTATIONNAME_LENGTH - WINSTATION_NAME_TRUNCATE_BY ), 0 );

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CConProp::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_CONNECTION_PROP );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CConProp::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_TRANSTYPE );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_TRANSTYPE );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CConProp::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    ICfgComp *pCfgcomp;

    if( pnmh->code == PSN_SETACTIVE && g_bConnectionTypeChanged_forConProps )
    {
        PDNAMEW * pDname;

        ULONG ulItems = 0;

        ULONG cbSize = 0;

        ODS( L"CConProp::OnNotify -- PSN_SETACTIVE\n" );

        if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
        {
            ODS( L"CConProp::OnNotify - PSN_SETACTIVE getserver failed\n" );

            return FALSE;
        }

        // remove every item from the list

        HWND hCombo = GetDlgItem( hDlg , IDC_COMBO_TRANSPORT_WZ );

        ASSERT( hCombo != NULL );

        // Remove everything from the list

        SendMessage( hCombo , CB_RESETCONTENT , 0 , 0 );

        // WdName is a flag and not a variable

        if( SUCCEEDED( pCfgcomp->GetTransportTypes( g_ws.wdName , WdName , &ulItems , &cbSize , ( WCHAR ** )&pDname ) ) )
        {
            for( ULONG i = 0 ; i < ulItems ; ++i )
            {
                SendMessage( hCombo , CB_ADDSTRING , 0 , ( LPARAM )pDname[ i ] );
            }

            SendMessage( hCombo , CB_SETCURSEL , ( WPARAM ) 0 , 0 );

            CoTaskMemFree( pDname );
        }

        pCfgcomp->Release( );

        g_bConnectionTypeChanged_forConProps = FALSE;

    }
    else if( pnmh->code == PSN_WIZNEXT )
    {
        DWORD dwErr = 0;

        if( GetWindowText( GetDlgItem( hDlg , IDC_EDIT_WSNAME_WZ ) , g_ws.Name , SIZE_OF_BUFFER( g_ws.Name ) ) == 0 || !IsValidConnectionName( g_ws.Name , &dwErr ) )
        {
            if( dwErr == ERROR_INVALID_FIRSTCHARACTER )
            {
                ErrMessage( hDlg , IDS_ERR_INVALIDFIRSTCHAR );
            }
            else
            {
                ErrMessage( hDlg , IDS_ERR_INVALIDCHARS );
            }

            SetFocus( GetDlgItem( hDlg , IDC_EDIT_WSNAME_WZ ) );

            SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

            return TRUE;
        }

        if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
        {
            return FALSE;
        }

        BOOL bUnique;

        if( SUCCEEDED( pCfgcomp->IsWSNameUnique( g_ws.Name , &bUnique ) ) )
        {
            if( !bUnique )
            {
                ErrMessage( hDlg , IDS_ERR_CONEXIST );

                SetFocus( GetDlgItem( hDlg , IDC_EDIT_WSNAME_WZ ) );

                SendMessage( GetDlgItem( hDlg , IDC_EDIT_WSNAME_WZ ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                pCfgcomp->Release( );

                return TRUE;
            }

        }

        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_COMMENT_WZ ) , g_ws.Comment , SIZE_OF_BUFFER( g_ws.Comment ) );

        INT_PTR iSel = SendMessage( GetDlgItem( hDlg , IDC_COMBO_TRANSPORT_WZ ) , CB_GETCURSEL , 0 , 0 );

        if( iSel != CB_ERR )
        {
            SendMessage( GetDlgItem( hDlg , IDC_COMBO_TRANSPORT_WZ ) , CB_GETLBTEXT , iSel , ( LPARAM )g_ws.pdName );

            if( iSel != m_iOldSel )
            {
                g_nAsyncOrNetwork = 0;

                m_iOldSel = iSel;
            }
        }


        // get the SDCLASS

        DWORD dwSdClass = 0;

        if( FAILED( pCfgcomp->GetTransportType( g_ws.wdName , g_ws.pdName , &dwSdClass ) ) )
        {
            dwSdClass = SdNone;

            ODS( L"GetTransPortType failed @ CConProp::OnNotify\n" );
        }

        if( dwSdClass == SdNetwork && g_nAsyncOrNetwork != LAN_PAGE )
        {
            g_nAsyncOrNetwork = LAN_PAGE;

            VERIFY_S( TRUE , RemovePages( hDlg ) );

            VERIFY_S( TRUE , AddPages( hDlg , LAN_PAGE , g_ws.wdName ) );
        }

        else if( dwSdClass == SdAsync && g_nAsyncOrNetwork != ASYNC_PAGE )
        {
            g_nAsyncOrNetwork = ASYNC_PAGE;

            VERIFY_S( TRUE , RemovePages( hDlg ) );

            VERIFY_S( TRUE , AddPages( hDlg , ASYNC_PAGE , g_ws.wdName ) );
        }

        else if( dwSdClass != SdAsync && dwSdClass != SdNetwork )
        {
            // remove g_nAsyncOrNetwork page and let citrix or third party vendor worry about the transport type

            g_nAsyncOrNetwork = FIN_PAGE;

            VERIFY_S( TRUE , RemovePages( hDlg ) );

            VERIFY_S( TRUE , AddPages( hDlg , -1 , g_ws.wdName ) ); // only add citrix or 3rd parth pages

            // I'm tempted
            // g_nAsyncOrNetwork = 0;

        }


        pCfgcomp->Release( );

    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

//-------------------------------------------------------------------------------
// We're about to update lanpage or asyncpage and slap in citrix additional pages
// so we need to remove all of them first even the final page
//-------------------------------------------------------------------------------
BOOL CConProp::RemovePages( HWND hDlg )
{
    HPROPSHEETPAGE hPage = NULL;

    for( int idx = /*g_nAsyncOrNetwork*/ LAN_PAGE; idx < MS_DIALOG_COUNT ; idx++ )
    {
        hPage= *m_pCompdata->m_hPages.GetAt( idx );

        if( hPage != NULL )
        {
            PropSheet_RemovePage( GetParent( hDlg ) , 0 , hPage );

            m_pCompdata->m_hPages.SetAt( idx , NULL );
        }
    }

    for( idx = 0 ; idx < ( m_hOtherPages.GetSize( ) ) ; ++idx )
    {
        hPage = *m_hOtherPages.GetAt( idx );

        if( hPage != NULL )
        {
            PropSheet_RemovePage( GetParent( hDlg ) , 0 , hPage );

            m_hOtherPages.SetAt( idx , NULL );
        }

        m_hOtherPages.DeleteArray( );
    }

    // remove final page

    hPage= *m_pCompdata->m_hPages.GetAt( FIN_PAGE );

    if( hPage != NULL )
    {
        PropSheet_RemovePage( GetParent( hDlg ) , 0 , hPage );

        m_pCompdata->m_hPages.SetAt( FIN_PAGE , NULL );

    }

    return TRUE;

}

//-----------------------------------------------------------------------------
// Now include lanpage or async page or either and slapin citrix pages
//-----------------------------------------------------------------------------
BOOL CConProp::AddPages( HWND hwnd , int idx , LPTSTR szDriverName )
{
    PROPSHEETPAGE psp;

    ASSERT( szDriverName != NULL );

    if( idx == LAN_PAGE )
    {
        if( *m_pCompdata->m_hPages.GetAt( LAN_PAGE ) == NULL )
        {
            m_pCompdata->m_pDlg[ LAN_PAGE ]->GetPropertySheetPage( psp );

            m_pCompdata->m_hPages.SetAt( LAN_PAGE , CreatePropertySheetPage( &psp ) );

            PropSheet_AddPage( GetParent( hwnd ) , *m_pCompdata->m_hPages.GetAt( LAN_PAGE ) );
        }

    }
    else if( idx == ASYNC_PAGE )
    {
        if( *m_pCompdata->m_hPages.GetAt( ASYNC_PAGE ) == NULL )
        {
            m_pCompdata->m_pDlg[ ASYNC_PAGE ]->GetPropertySheetPage( psp );

            m_pCompdata->m_hPages.SetAt( ASYNC_PAGE , CreatePropertySheetPage( &psp ) );

            PropSheet_AddPage( GetParent( hwnd ) , *m_pCompdata->m_hPages.GetAt( ASYNC_PAGE ) );
        }
    }

    // add thirdparty pages

    ODS( L"Adding third party page\n" );

    VERIFY_S( TRUE , InsertThirdPartyPages( szDriverName ) );
    

    for( idx = 0 ; idx < ( m_hOtherPages.GetSize( ) ) ; ++idx )
    {
        HPROPSHEETPAGE hPage = *m_hOtherPages.GetAt( idx );

        if( hPage != NULL )
        {
            PropSheet_AddPage( GetParent( hwnd ) , hPage );

            m_hOtherPages.SetAt( idx , hPage );
        }

    }

    if( *m_pCompdata->m_hPages.GetAt( FIN_PAGE ) == NULL )
    {
        m_pCompdata->m_pDlg[ FIN_PAGE ]->GetPropertySheetPage( psp );

        m_pCompdata->m_hPages.SetAt( FIN_PAGE , CreatePropertySheetPage( &psp ) );

        PropSheet_AddPage( GetParent( hwnd ) , *m_pCompdata->m_hPages.GetAt( FIN_PAGE ) );

        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CConProp::InsertThirdPartyPages( LPTSTR pszKey )
{
    HKEY hKey;

    TCHAR tchKey[ MAX_PATH ];

    TCHAR tchCLSID[ 40 ];

    CLSID clsidOther;

    DWORD dwSize;

    //LPEXTENDTSWIZARD pObj = NULL;

    lstrcpy( tchKey , tchThirdPartyPath );

    lstrcat( tchKey , pszKey );

    HRESULT hr = E_FAIL;

    if( g_pObj != NULL )
    {
        g_pObj->Release( );

        // we set this to NULL in case Cocreate fails we don't want to
        // deference an interface that went away.

        g_pObj = NULL;
    }

    do
    {

        if( RegOpenKey( HKEY_LOCAL_MACHINE , tchKey , &hKey ) != ERROR_SUCCESS )
        {
            ODS( L"CConProp::InsertThirdPartyPages RegOpenKey failed\n" );
            break;
        }

        dwSize = sizeof( tchCLSID );

        if( RegQueryValueEx( hKey , L"CLSID" , NULL , NULL , ( LPBYTE )&tchCLSID[ 0 ] , &dwSize ) != ERROR_SUCCESS )
        {
            ODS( L"CConProp::InsertThirdPartyPages RegQueryValueEx failed\n" );
            break;
        }

        if( FAILED( CLSIDFromString( tchCLSID , &clsidOther ) ) )
        {
            ODS( L"CConProp::InsertThirdPartyPages CLSIDFromString failed\n" );
            break;
        }

        if( FAILED( CoCreateInstance( clsidOther , NULL , CLSCTX_INPROC_SERVER , IID_IExtendTSWizard , ( LPVOID *) &g_pObj ) ) )
        {
            ODS( L"CConProp::InsertThirdPartyPages CoCreate failed\n" );
            break;
        }

        if( FAILED( g_pObj->AddPages( ( LPWIZARDPROVIDER )this ) ) )
        {
            ODS( L"CConProp::InsertThirdPartyPages ExtWiz->Addpages failed\n" );
            break;
        }

        if( FAILED( g_pObj->SetWinstationName( g_ws.Name ) ) )
        {
            ODS( L"CConProp::InsertThirdPartyPages ExtWiz->SetWinstationName failed\n" );
            break;
        }

        hr = S_OK;

    }while( 0 );    

    RegCloseKey( hKey );

    if( FAILED( hr ) )
    {
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CConProp::QueryInterface( REFIID riid , LPVOID *ppobj )
{
    ODS( L"TSCC-WIZ CConProp QI--" );

    if( riid == IID_IUnknown )
    {
        ODS( L"IUnknown" );

        *ppobj = ( LPUNKNOWN )this;
    }
    else if( riid == IID_IWizardProvider )
    {
        ODS( L"IWizardProvider" );

        *ppobj = ( IWizardProvider *)this;
    }
    else
    {
        DBGMSG( L"Interface not supported %x\n" , riid );

        *ppobj = NULL;

        return( E_NOINTERFACE );
    }

    AddRef( );

    ODS( L"\n" );

    return S_OK;
}

//-----------------------------------------------------------------------------
// For IWizardProvider
//-----------------------------------------------------------------------------
STDMETHODIMP_( ULONG ) CConProp::AddRef( )
{
    return InterlockedIncrement( ( LPLONG )&m_cRef );
}

//-----------------------------------------------------------------------------
// For IWizardProvider
//-----------------------------------------------------------------------------
STDMETHODIMP_( ULONG ) CConProp::Release( )
{
    if( InterlockedDecrement( ( LPLONG )&m_cRef ) == 0 )
    {
        //
        // DONOT delete this
        //
        return 0;
    }

    return m_cRef;
}

//-----------------------------------------------------------------------------
// This is the call back function IExtendTSWizard will use to add pages to
// the array
//-----------------------------------------------------------------------------
STDMETHODIMP CConProp::AddPage( HPROPSHEETPAGE hPage )
{
    if( m_hOtherPages.Insert( hPage ) > 0 )
    {
        return S_OK;
    }

    return E_FAIL;
}

//***********************************************************************************

CAsync::CAsync( CCompdata *pComdata )
{
    m_pCompdata = pComdata;
}

//-----------------------------------------------------------------------------
BOOL CAsync::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );

    UNREFERENCED_PARAMETER( lp );

    UNREFERENCED_PARAMETER( hwnd );

    ICfgComp *pCfgcomp = NULL;

    BOOL bRet = TRUE;

    if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
    {
        ODS( L"Wizard could obtain backend interface for CAsync\n" );

        return FALSE;
    }

    // populate CAsyncDlg members

    m_uc = g_uc;

    pCfgcomp->GetAsyncConfig( g_ws.wdName , WdName , &m_ac );

    pCfgcomp->Release( );

    return bRet;
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CAsync::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CAsync *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CAsync *pDlg = ( CAsync * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CAsync ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CAsync * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CAsync ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
BOOL CAsync::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_ASYNC_WIZ );

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_ASYNC );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_ASYNC );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CAsync::DlgProc;

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CAsync::OnDestroy( )
{
    AsyncRelease( );

    return CDialogWizBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CAsync::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        g_uc = m_uc;

        g_ac = m_ac;
    }

    g_ws.PdClass = SdAsync;

    if( pnmh->code == PSN_SETACTIVE )
    {
        ICfgComp * pCfgcomp = NULL;
        if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
        {
            ODS( L"Wizard could obtain backend interface for CAsync\n" );

            return FALSE;
        }

        BOOL bRet = CAsyncDlg::OnInitDialog( hDlg ,  g_ws.wdName , NULL , pCfgcomp ) ;

        if(FALSE == bRet)
        {
            PropSheet_PressButton( GetParent(hDlg),PSBTN_BACK );

        }

        if(pCfgcomp)
        {
            pCfgcomp->Release();
        }
    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

//-----------------------------------------------------------------------------
BOOL CAsync::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    BOOL bDummy;

    return CAsyncDlg::OnCommand( wNotifyCode , wID , hwndCtrl , &bDummy );
}

//***********************************************************************************

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CFin::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CFin *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CFin *pDlg = ( CFin * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CFin ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CFin * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CFin ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CFin::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );

    LOGFONT lgfn;

    int iFontSize;

    TCHAR szFontSize[16];

    ZeroMemory( &lgfn , sizeof( LOGFONT ) );

    LoadString( _Module.GetResourceInstance( ) , IDS_VERDANABLDFONTSIZE , szFontSize , SIZE_OF_BUFFER(szFontSize) );

    iFontSize = _ttoi( szFontSize );

    HDC hdc = ::GetDC( NULL );

    if( hdc != NULL )
    {
        lgfn.lfHeight = MulDiv( -iFontSize , GetDeviceCaps(hdc , LOGPIXELSY), 72);

        LoadString( _Module.GetResourceInstance( ) , IDS_VERDANABLDFONTNAME , lgfn.lfFaceName , SIZE_OF_BUFFER(lgfn.lfFaceName) );

        m_hFont = CreateFontIndirect( &lgfn );

        ASSERT( m_hFont != NULL ); // let me know if we got it or not

        SetWindowText( GetDlgItem(hwnd , IDC_CONNECTION_NAME ) ,g_ws.Name );

        SendMessage( GetDlgItem( hwnd , IDC_STATIC_FINISH ) , WM_SETFONT , ( WPARAM )m_hFont , MAKELPARAM( TRUE , 0 ) );

        ReleaseDC( NULL , hdc );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CFin::OnDestroy( )
{
    DeleteObject( m_hFont );

    return CDialogWizBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CFin::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_HIDEHEADER;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_FINISH );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CFin::DlgProc;

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CFin::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    UNREFERENCED_PARAMETER( idCtrl );

    HRESULT hResult = S_OK;

    if( pnmh->code == PSN_SETACTIVE )
    {
        PropSheet_SetWizButtons( GetParent( hDlg ) , PSWIZB_BACK | PSWIZB_FINISH  );
    }
    else if( pnmh->code == PSN_WIZFINISH )
    {
        ICfgComp *pCfgcomp;

        m_pCompdata->GetServer( &pCfgcomp );

        //PSECURITY_DESCRIPTOR pSd;

        //LONG lSdsize;

        g_ws.fEnableWinstation = 1;

        BOOL bUnique;

        // verify that network adapter was not modified
        // bugid 253896

        if( SUCCEEDED( pCfgcomp->IsWSNameUnique( g_ws.Name , &bUnique ) ) )
        {
            if( !bUnique )
            {
                ErrMessage( hDlg , IDS_ERR_LANRECFG );

                pCfgcomp->Release( );

                return FALSE;
            }
        }

        if(g_ws.PdClass == SdNetwork)
        {
            if( SUCCEEDED( pCfgcomp->IsNetWorkConnectionUnique( g_ws.wdName , g_ws.pdName , ( ULONG )g_ws.LanAdapter , &bUnique ) ) )
            {
                if( !bUnique )
                {
                    ErrMessage( hDlg , IDS_ERR_LANRECFG );

                    pCfgcomp->Release( );

                    return FALSE;
                }
            }
        }

        TCHAR tchWdkey[ 80 ];

        if( SUCCEEDED( pCfgcomp->GetWdKey( g_ws.wdName , tchWdkey ) ) )
        {
            WDCONFIG2 WdConfig;

            ULONG ulByteCount;

            if( RegWdQuery( NULL, tchWdkey, &WdConfig , sizeof( WDCONFIG2 ) , &ulByteCount ) == ERROR_SUCCESS )
            {
                g_uc.fAutoClientDrives  =   WdConfig.User.fAutoClientDrives;
                g_uc.fAutoClientLpts    =   WdConfig.User.fAutoClientLpts;
                g_uc.fDisableCam        =   WdConfig.User.fDisableCam;
                g_uc.fDisableCcm        =   WdConfig.User.fDisableCcm;
                g_uc.fDisableCdm        =   WdConfig.User.fDisableCdm;
                g_uc.fDisableClip       =   WdConfig.User.fDisableClip;
                g_uc.fDisableCpm        =   WdConfig.User.fDisableCpm;
                g_uc.fDisableLPT        =   WdConfig.User.fDisableLPT;
				g_uc.fInheritAutoClient =   WdConfig.User.fInheritAutoClient;
				g_uc.fForceClientLptDef =   WdConfig.User.fForceClientLptDef;
                g_uc.ColorDepth         =   WdConfig.User.ColorDepth;

            }
            else
            {
                ODS( L"TSCC:Holy cow our wdkeys were not copied going default\n" );
                // Set default values for pages that were removed
                // Logon setting

                g_uc.fAutoClientLpts = 1;
	
                //g_uc.fAutoClientDrives = 1;

                g_uc.fDisableCcm = 1;

                g_uc.fForceClientLptDef = 1;
            }

        }


        g_uc.fInheritMaxSessionTime = 1;

        g_uc.fInheritMaxDisconnectionTime = 1;

        g_uc.fInheritMaxIdleTime = 1;

        g_uc.fInheritResetBroken = 1;

        g_uc.fInheritReconnectSame = 1;

        // Environment

        g_uc.fInheritInitialProgram = 1;

        g_uc.fPromptForPassword = 1;

        // Client Settings

        g_uc.fWallPaperDisabled = 1;

		g_uc.fInheritAutoLogon = 1;


        if(g_ws.PdClass == SdAsync)
        {
            ODS( L"TSCC : Async connection about to be configured\n" );

            g_ws.uMaxInstanceCount = 1;

            hResult = pCfgcomp->CreateNewWS( g_ws , sizeof( USERCONFIG ) , &g_uc , &g_ac) ;

        }
        else
        {
            hResult = pCfgcomp->CreateNewWS( g_ws , sizeof( USERCONFIG ) , &g_uc , NULL) ;
        }

        if( SUCCEEDED(hResult) )
        {
            ODS( L"New WS created\n" );

            if( g_pObj != NULL )
            {
                ODS( L" calling finito\n" );

                if( FAILED( g_pObj->Finito( ) ) )
                {
                    ODS( L"TSCC : CFin::OnNotify@g_pObj failed final call\n" );
                }                

                ODS( L"about to release object\n" );

                g_pObj->Release( );                

                //g_pObj = NULL;
            }

            CResultNode  *pResultNode = ( CResultNode * )new CResultNode( );

            if( pResultNode != NULL )
            {
                pResultNode->SetConName( g_ws.Name , SIZE_OF_BUFFER( g_ws.Name ) );

                pResultNode->SetTTName( g_ws.pdName , SIZE_OF_BUFFER( g_ws.pdName ) );

                pResultNode->SetTypeName( g_ws.wdName , SIZE_OF_BUFFER( g_ws.wdName ) );

                pResultNode->SetComment(  g_ws.Comment , SIZE_OF_BUFFER( g_ws.Comment ) );

                pResultNode->EnableConnection( g_ws.fEnableWinstation );

                pResultNode->SetImageIdx( ( g_ws.fEnableWinstation ? 1 : 2 ) );

                pResultNode->SetServer( pCfgcomp );

                m_pCompdata->m_rnNodes.Insert( pResultNode );
            }

            if( g_nAsyncOrNetwork == ASYNC_PAGE )
            {
                 WS *pWs;

                 LONG lSz;

                 TCHAR tchWrnBuf[ 256 ];

                 TCHAR tchOutput[ 512 ];

                 if( SUCCEEDED( pCfgcomp->GetWSInfo(g_ws.Name , &lSz , &pWs ) ) )
                 {
                     if( pWs->fEnableWinstation && pWs->PdClass == SdAsync )
                     {
                         ASYNCCONFIGW AsyncConfig;

                         HRESULT hResult = pCfgcomp->GetAsyncConfig(pWs->Name,WsName,&AsyncConfig);

                         if( SUCCEEDED( hResult ) )
                         {
                             if( AsyncConfig.ModemName[0] )
                             {
                                 LoadString( _Module.GetResourceInstance( ) , IDS_REBOOT_REQD , tchOutput , SIZE_OF_BUFFER( tchOutput ) );

                                 LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );

                                 MessageBox( hDlg , tchOutput , tchWrnBuf , MB_ICONWARNING | MB_OK );
                             }
                         }
                     }

                     CoTaskMemFree( pWs );
                 }
            }
        }
        else
        {
            if( hResult == E_ACCESSDENIED )
            {
                TscAccessDeniedMsg( hDlg );
            }
            else
            {
                TscGeneralErrMsg( hDlg );
            }
        }

        pCfgcomp->Release();
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
CFin::CFin( CCompdata * pCompdata)
{
    m_pCompdata = pCompdata;
}

//-----------------------------------------------------------------------------
void EnableGroup( HWND hParent , LPINT rgID , BOOL bEnable )
{
    while( rgID && *rgID != ( DWORD )-1 )
    {
        EnableWindow( GetDlgItem( hParent , *rgID ) , bEnable );

        rgID++;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tskill\tskill.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*****************************************************************************
*
*   TSKILL.C for Windows NT Terminal Server
*
*  Description:
*
*     tskill [processID] [/v] [/?]
*
****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <utilsub.h>
#include <allproc.h>

#include "tskill.h"
#include "printfoa.h"

WCHAR  user_string[MAX_IDS_LEN+1];

#define MAXCBMSGBUFFER 2048

WCHAR MsgBuf[MAXCBMSGBUFFER];

USHORT help_flag = FALSE;
USHORT v_flag    = FALSE;
USHORT a_flag    = FALSE;

HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];
WCHAR  ipLogonId[MAX_IDS_LEN+1];

TOKMAP ptm[] =
{
   {L" ",       TMFLAG_REQUIRED, TMFORM_STRING, MAX_IDS_LEN,   user_string},
   {L"/server", TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN, ServerName},
   {L"/id",      TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN, &ipLogonId},
   {L"/?",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
   {L"/v",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &v_flag},
   {L"/a",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &a_flag},
   {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );
BOOLEAN KillProcessUseName();
BOOLEAN KillProcessButConfirmTheID( ULONG TargetPid );
BOOLEAN KillProcess(ULONG TargetPid);
BOOLEAN MatchPattern(PWCHAR String, PWCHAR Pattern);
BOOLEAN CheckImageNameAndKill(PTS_SYS_PROCESS_INFORMATION pProcessInfo);


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    ULONG TargetPid;
    int  i;
    DWORD  rc;
    WCHAR *CmdLine, **argvW, *StopChar;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, L"/server") ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }


    /*
    * Check for the command line pid and convert to a ULONG
    */
    TargetPid = wcstoul(user_string, &StopChar, 10);

    if (!TargetPid) {
        //Get the process IDs and Kill.
        return (KillProcessUseName());
    } else if (*StopChar) {
        StringErrorPrintf(IDS_ERROR_BAD_PID_NUMBER, user_string);
        return(FAILURE);
    // end of getting the process ids from names
    } else {
        return( KillProcessButConfirmTheID( TargetPid ) );
    }

}  /* main() */



/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {

        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }
   ErrorPrintf(IDS_USAGE1);
   ErrorPrintf(IDS_USAGE2);
   ErrorPrintf(IDS_USAGE3);
   ErrorPrintf(IDS_USAGE4);
   ErrorPrintf(IDS_USAGE5);
   ErrorPrintf(IDS_USAGE6);
   ErrorPrintf(IDS_USAGE7);
   ErrorPrintf(IDS_USAGE8);
   ErrorPrintf(IDS_USAGE9);
   ErrorPrintf(IDS_USAGEA);
}  /* Usage() */


// ***********************************************************************
// KillProcessUseName
//    Gets all the ProcessIDs of all the processes with the name passed
//    to the command line and kill them. Returns FALSE if there are no
//    processes running with the process names.
//
// ***********************************************************************

BOOLEAN KillProcessUseName()
{

    ULONG LogonId, ReturnLength, BufferOffset=0, ulLogonId;
    PBYTE pProcessBuffer;
    PTS_SYS_PROCESS_INFORMATION pProcessInfo;
    PCITRIX_PROCESS_INFORMATION pCitrixInfo;

    PTS_ALL_PROCESSES_INFO  ProcessArray = NULL;
    ULONG   NumberOfProcesses;
    ULONG   j;
    BOOLEAN bRet;
    short nTasks=0;
    ULONG CurrentLogonId = (ULONG) -1;
    ULONG ProcessSessionId;
    DWORD dwError;

    // if a servername is specified and session id is not specified,
    // prompt an error.

    if (ServerName[0] && !ipLogonId[0] && !a_flag) {
        StringErrorPrintf(IDS_ERROR_ID_ABSENT, ServerName);
        return FAILURE;
    }


    // convert the input task name to lower
    _wcslwr(user_string);

     /*
     *  Get current LogonId
     */
    CurrentLogonId = GetCurrentLogonId();

    // get the login id of the current user.
    //if (!WinStationQueryInformation(hServerName, LOGONID_CURRENT,
    //    WinStationInformation, &WSInfo, sizeof(WSInfo), &ReturnLength)) {
    //    fprintf(stdout, "Error QueryInfo failed");
    //}

    //convert the input logon id to ulong

    ulLogonId = wcstoul(ipLogonId, NULL, 10);


    //Use the input logon id if passed. If not use the current logon ID.
    //LogonId = (!wcscmp(ipLogonId,""))? WSInfo.LogonId:ulLogonId;
    LogonId = (!ipLogonId[0])? CurrentLogonId:ulLogonId;

    bRet = WinStationGetAllProcesses( hServerName,
                                      GAP_LEVEL_BASIC,
                                      &NumberOfProcesses,
                                      &ProcessArray);
    if (bRet == TRUE)
    {
        for (j=0; j<NumberOfProcesses; j++)
        {
            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION)(ProcessArray[j].pTsProcessInfo);
            ProcessSessionId = pProcessInfo->SessionId;

            //if a_flag is set, check for the processes in all sessions;
            //if not, check for the processes in one LogonSession only.
            if(( ProcessSessionId == LogonId)|| a_flag)
            {
                if (CheckImageNameAndKill(pProcessInfo))
                {
                    nTasks++;
                }
            }
        }

        //
        // Free ppProcessArray and all child pointers allocated by the client stub.
        //
        WinStationFreeGAPMemory(GAP_LEVEL_BASIC, ProcessArray, NumberOfProcesses);

    }
    else    // Maybe a Hydra 4 server ?
    {
        //
        //   Check the return code indicating that the interface is not available.
        //
        dwError = GetLastError();
        if (dwError != RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            return (FALSE);
        }

        //Enumerate All the processes in order to get the ProcessId
        if (!WinStationEnumerateProcesses(hServerName, (PVOID *)&pProcessBuffer)) {
            if( pProcessBuffer)
                WinStationFreeMemory(pProcessBuffer);
            ErrorPrintf(IDS_ERROR_ENUM_PROCESS);
            return FAILURE;
        }

        //Make use of the ProcessBuffer to get the Process ID after
        //checking for a match in Logon User Name

        do {

            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION)
                &(((PUCHAR)pProcessBuffer)[BufferOffset]);

            /*
             * Point to the CITRIX_INFORMATION which follows the Threads
             */
            pCitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                         (((PUCHAR)pProcessInfo) +
                          SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION +
                          (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * (int)pProcessInfo->NumberOfThreads));

            if( pCitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {

                ProcessSessionId = pCitrixInfo->LogonId;

            } else {

                ProcessSessionId = (ULONG)(-1);
           }


            //if a_flag is set, check for the processes in all sessions;
            //if not, check for the processes in one LogonSession only.
            if(( ProcessSessionId == LogonId)|| a_flag)
            {
                if (CheckImageNameAndKill(pProcessInfo))
                {
                    nTasks++;
                }
            }

            BufferOffset += pProcessInfo->NextEntryOffset;

        } while (pProcessInfo->NextEntryOffset != 0);

        if( pProcessBuffer)
        {
            WinStationFreeMemory(pProcessBuffer);
        }
    }
    if(!nTasks)
    {
        StringErrorPrintf(IDS_ERROR_BAD_PROCESS, user_string);
        return FAILURE;
    }

    return SUCCESS;

}
// ***********************************************************************
BOOLEAN
CheckImageNameAndKill(PTS_SYS_PROCESS_INFORMATION pProcessInfo)
{
    WCHAR   ImageName[MAXNAME + 2] = { 0 };
    PWCHAR  p;
    ULONG   TargetPid;
    BOOLEAN bRet = FALSE;

    ImageName[MAXNAME+1] = 0; //force the end of string

    if( pProcessInfo->ImageName.Length == 0 )
    {
        ImageName[0] = 0;
    }
    else if( pProcessInfo->ImageName.Length > MAXNAME * 2)
    {
        wcsncpy(ImageName, pProcessInfo->ImageName.Buffer, MAXNAME);
    }
    else
    {
        wcsncpy(ImageName,  pProcessInfo->ImageName.Buffer, pProcessInfo->ImageName.Length/2);
        ImageName[pProcessInfo->ImageName.Length/2] = 0;
    }


    //convert the imagename to lower
    _wcslwr(ImageName);

    if(ImageName != NULL) {
        p = wcschr(ImageName,'.');
        if (p)
            p[0] = L'\0';

        //get the ProcessID if the imagename matches
        if(MatchPattern(ImageName, user_string) ) {
            TargetPid = (ULONG)(ULONG_PTR)(pProcessInfo->UniqueProcessId);
            bRet = TRUE;
            KillProcess(TargetPid);
        }
    }
    return bRet;
}



// ***********************************************************************
// KillProcess:
//      Kills the process with the specific ProcessID.
// ***********************************************************************

BOOLEAN KillProcess(ULONG TargetPid)
{
    DWORD rc;

    /*
     * Kill the specified process.
     */
    if (v_flag)
        Message(IDS_KILL_PROCESS, TargetPid);


    if ( !WinStationTerminateProcess( hServerName, TargetPid, 0 ) ) {
        rc = GetLastError();
        StringErrorPrintf(IDS_ERROR_KILL_PROCESS_FAILED, user_string);
        if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL, rc, 0, MsgBuf, MAXCBMSGBUFFER, NULL) != 0)
        {
            fwprintf( stderr, MsgBuf );
        }
        fwprintf( stderr, L"\n");

        return FAILURE;
    }

    return SUCCESS;
}


// ***********************************************************************
// MatchPattern
//      Checks if the passed string matches with the pattern used
//      Return TRUE if it matches and FALSE if not.
//
// String(input)
//       String being checked for the match
// processname (input)
//       Pattern used for the check
// ***********************************************************************


BOOLEAN
MatchPattern(
    PWCHAR String,
    PWCHAR Pattern
    )
{
    WCHAR   c, p, l;

    for (; ;) {
        switch (p = *Pattern++) {
            case 0:                             // end of pattern
                return *String ? FALSE : TRUE;  // if end of string TRUE

            case '*':
                while (*String) {               // match zero or more char
                    if (MatchPattern (String++, Pattern))
                        return TRUE;
                }
                return MatchPattern (String, Pattern);

            case '?':
                if (*String++ == 0)             // match any one char
                    return FALSE;                   // not end of string
                break;

            case '[':
                if ( (c = *String++) == 0)      // match char set
                    return FALSE;                   // syntax

                c = towupper(c);
                l = 0;
                while (p = *Pattern++) {
                    if (p == ']')               // if end of char set, then
                        return FALSE;           // no match found

                    if (p == '-') {             // check a range of chars?
                        p = *Pattern;           // get high limit of range
                        if (p == 0  ||  p == ']')
                            return FALSE;           // syntax

                        if (c >= l  &&  c <= p)
                            break;              // if in range, move on
                    }

                    l = p;
                    if (c == p)                 // if char matches this element
                        break;                  // move on
                }

                while (p  &&  p != ']')         // got a match in char set
                    p = *Pattern++;             // skip to end of set

                break;

            default:
                c = *String++;
                if (c != p)            // check for exact char
                    return FALSE;                   // not a match

                break;
        }
    }
}

// ***********************************************************************
// KillProcessButConfirmTheID
//    Gets all the ProcessIDs of all the processes with the name passed
//    to the command line and kill them. Returns FALSE if there are no
//    processes running with the process names.
//
// ***********************************************************************

BOOLEAN KillProcessButConfirmTheID( ULONG TargetPid )
{

    ULONG BufferOffset=0;
    PBYTE pProcessBuffer;
    PTS_SYS_PROCESS_INFORMATION pProcessInfo;
    
    PTS_ALL_PROCESSES_INFO  ProcessArray = NULL;
    ULONG   NumberOfProcesses;
    ULONG   j;
    BOOLEAN bRet;
    BOOLEAN bFound = FALSE;        
    DWORD dwError;


    bRet = WinStationGetAllProcesses( hServerName,
                                      GAP_LEVEL_BASIC,
                                      &NumberOfProcesses,
                                      &ProcessArray);

    if (bRet == TRUE)
    {
        for (j=0; j<NumberOfProcesses; j++)
        {
            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION)(ProcessArray[j].pTsProcessInfo);
            pProcessInfo->SessionId;

            //if a_flag is set, check for the processes in all sessions;
            //if not, check for the processes in one LogonSession only.
            if( pProcessInfo->UniqueProcessId == TargetPid )
            {
                KillProcess( TargetPid );

                bFound = TRUE;

                break;
            }
        }

        //
        // Free ppProcessArray and all child pointers allocated by the client stub.
        //
        WinStationFreeGAPMemory(GAP_LEVEL_BASIC, ProcessArray, NumberOfProcesses);

    }
    else    // Maybe a Hydra 4 server ?
    {
        //
        //   Check the return code indicating that the interface is not available.
        //
        dwError = GetLastError();
        if (dwError != RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            return (FALSE);
        }

        //Enumerate All the processes in order to get the ProcessId
        if (!WinStationEnumerateProcesses(hServerName, (PVOID *)&pProcessBuffer)) {
            if( pProcessBuffer)
                WinStationFreeMemory(pProcessBuffer);
            ErrorPrintf(IDS_ERROR_ENUM_PROCESS);
            return FAILURE;
        }

        //Make use of the ProcessBuffer to get the Process ID after
        //checking for a match in Logon User Name

        do {

            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) &(((PUCHAR)pProcessBuffer)[BufferOffset]);


            if( pProcessInfo->UniqueProcessId == TargetPid )
            {
                KillProcess( TargetPid );

                bFound = TRUE;

                break;
            }
            
            BufferOffset += pProcessInfo->NextEntryOffset;

        } while (pProcessInfo->NextEntryOffset != 0);

        if( pProcessBuffer)
        {
            WinStationFreeMemory(pProcessBuffer);
        }
    }

    if(!bFound)
    {
        StringErrorPrintf(IDS_ERROR_BAD_PROCESS, user_string);
        return FAILURE;
    }

    return SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utildll\resource.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*******************************************************************************
*
* resource.h
*
* UTILDLL resource file defines
*
*
*******************************************************************************/

#define IDS_ALL_LAN_ADAPTERS            1
#define IDS_NO_ADDITIONAL_ERROR_INFO    2
#define IDS_NO_ERROR_TEXT_AVAILABLE     3
#define IDS_STANDARD_ERROR_FORMAT       4
#define IDS_ERROR                       5

#define IDP_ERROR_REGLANA               100
#define IDP_ERROR_REGNETCARD            101

#define IDS_CONSOLE                     200
#define IDS_NETWORK                     201
#define IDS_ASYNC                       202
#define IDS_FRAME                       203
#define IDS_RELIABLE                    204
#define IDS_COMPRESSION                 205
#define IDS_ENCRYPTION                  206
#define IDS_TELNET                      207
#define IDS_UNKNOWN_PROTOCOL            208

#define IDS_ACTIVE                      300
#define IDS_SHORT_ACTIVE                301
#define IDS_CONNECTED                   302
#define IDS_SHORT_CONNECTED             303
#define IDS_CONNECT_QUERY               304
#define IDS_SHORT_CONNECT_QUERY         305
#define IDS_SHADOW                      306
#define IDS_SHORT_SHADOW                307
#define IDS_DISCONNECTED                308
#define IDS_SHORT_DISCONNECTED          309
#define IDS_IDLE                        310
#define IDS_SHORT_IDLE                  311
#define IDS_RESET                       312
#define IDS_SHORT_RESET                 313
#define IDS_DOWN                        314
#define IDS_SHORT_DOWN                  315
#define IDS_INIT                        316
#define IDS_SHORT_INIT                  317
#define IDS_LISTEN                      318
#define IDS_SHORT_LISTEN                319
#define IDS_UNKNOWN                     320
#define IDS_ASYNC_CONNECT_CTS           321
#define IDS_ASYNC_CONNECT_DTR           322
#define IDS_ASYNC_CONNECT_RI            323
#define IDS_ASYNC_CONNECT_DCD           324
#define IDS_ASYNC_CONNECT_FIRSTCHAR     325
#define IDS_ASYNC_CONNECT_PERM          326

#define IDS_INITED                      400
#define IDS_READY                       401
#define IDS_RUN                         402
#define IDS_STANDBY                     403
#define IDS_TERMINATE                   404
#define IDS_WAIT                        405
#define IDS_TRANSIT                     406
#define IDS_STATE_DASHES                407
#define IDS_EXECUTIVE                   408
#define IDS_FREE_PAGE                   409
#define IDS_PAGE_IN                     410
#define IDS_POOL_ALLOC                  411
#define IDS_DELAY_EXECUTION             412
#define IDS_SUSPENDED                   413
#define IDS_USER_REQUEST                414
#define IDS_EVENT_PAIR_HIGH             415
#define IDS_EVENT_PAIR_LOW              416
#define IDS_LPC_RECEIVE                 417
#define IDS_LPC_REPLY                   418
#define IDS_VIRTUAL_MEMORY              419
#define IDS_PAGE_OUT                    420
#define IDS_WAIT1                       421
#define IDS_WAIT2                       422
#define IDS_WAIT3                       423
#define IDS_WAIT4                       424
#define IDS_WAIT5                       425
#define IDS_WAIT6                       426
#define IDS_WAIT7                       427
#define IDS_WAIT8                       428
#define IDS_WAIT9                       429
#define IDS_WAIT10                      430

#define IDS_DOMAIN_ADMINS               431


/* resources from 1000 onwords are used by utilsub */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tscc\snapin\twiz.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _TWIZ_H
#define _TWIZ_H

#include "baswdlg.h"
#include "todlg.h"
#include "asyncdlg.h"

class CCompdata;

//-----------------------------------------------------------------------------
class CWelcome : public CDialogWizBase
{
    HFONT m_hFont;

public:

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL OnDestroy( );
};



//-----------------------------------------------------------------------------
class CConType : public CDialogWizBase
{
    CCompdata *m_pCompdata;

    int m_iOldSelection;
    
public:
    
    CConType( CCompdata * );
    
    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    BOOL OnDestroy( );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL SetConType( HWND );

    BOOL AddEntriesToConType( HWND );

};

//-----------------------------------------------------------------------------
class CLan : public CDialogWizBase
{
    CCompdata *m_pCompdata;

public:

    CLan( CCompdata * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL OnNotify( int , LPNMHDR , HWND );
};

//-----------------------------------------------------------------------------
class CSecurity : public CDialogWizBase
{
    CCompdata *m_pCompdata;

    Encryption *m_pEncrypt;

	DWORD m_DefaultEncryptionLevelIndex;

public:

    CSecurity( CCompdata * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL OnDestroy( );
};

//-----------------------------------------------------------------------------
#if 0  // objects not used in connection wizard
class CTimeout : public CDialogWizBase , public CTimeOutDlg
{
public:

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnCommand( WORD , WORD , HWND );

    int GetCBXSTATEindex( HWND );

    BOOL OnNotify( int , LPNMHDR , HWND );
};

//-----------------------------------------------------------------------------
class CAutoLogon : public CDialogWizBase
{
public:

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL ConfirmPwd( HWND );
};


//-----------------------------------------------------------------------------
class CInitProg : public CDialogWizBase
{
public:

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL OnNotify( int , LPNMHDR , HWND );
};
#endif 

//-----------------------------------------------------------------------------
class CRemotectrl : public CDialogWizBase
{
public:

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL OnNotify( int , LPNMHDR , HWND );
};

#if 0
//-----------------------------------------------------------------------------
class CWallPaper : public CDialogWizBase
{
public:

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );
    
    BOOL OnNotify( int , LPNMHDR , HWND );
};
#endif

//-----------------------------------------------------------------------------
class CConProp : public CDialogWizBase , public IWizardProvider
{
    CCompdata *m_pCompdata;

    CArrayT< HPROPSHEETPAGE > m_hOtherPages;

    UINT m_cRef;

    INT_PTR m_iOldSel;


public:

    CConProp( CCompdata * );

    STDMETHOD( QueryInterface )( REFIID , LPVOID * );

    STDMETHOD_( ULONG , AddRef )( );

    STDMETHOD_( ULONG , Release )( );

    STDMETHOD( AddPage )( HPROPSHEETPAGE );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL RemovePages( HWND );

    BOOL AddPages( HWND , int , LPTSTR );

    BOOL InsertThirdPartyPages( LPTSTR );
};

//-----------------------------------------------------------------------------
class CAsync : public CAsyncDlg , public CDialogWizBase
{
    CCompdata * m_pCompdata;
      
public:

    CAsync( CCompdata * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL OnCommand( WORD , WORD , HWND );
};

//-----------------------------------------------------------------------------
class CFin : public CDialogWizBase
{
    CCompdata * m_pCompdata;

    HFONT m_hFont;

public:

    CFin( CCompdata * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL OnDestroy( );
};



#endif // _TWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\tskill\tskill.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*  TSKILL.H
*     This module contains typedefs and defines required for
*     the TSKILL utility.
*
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be
#define MAXNAME 18

/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_BAD_PID_NUMBER                        102
#define IDS_ERROR_KILL_PROCESS_FAILED                   103
#define IDS_ERROR_SERVER                                104
#define IDS_ERROR_BAD_PROCESS                           201

#define IDS_KILL_PROCESS                                200
#define IDS_ERROR_ID_ABSENT                             202
#define IDS_ERROR_ENUM_PROCESS                          203
#define IDS_USAGE1                                      204
#define IDS_USAGE2                                      205
#define IDS_USAGE3                                      206
#define IDS_USAGE4                                      207
#define IDS_USAGE5                                      208
#define IDS_USAGE6                                      209
#define IDS_USAGE7                                      210
#define IDS_USAGE8                                      211
#define IDS_USAGE9                                      212
#define IDS_USAGEA                                      213
#define IDS_ERROR_NOT_TS                                214
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\expand.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*   EXPAND.C
*
*   
******************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "utilsubres.h" // resources refrenced in this file.

void ErrorOutFromResource(UINT uiStringResource, ...);

#define INCL_DOSPROCESS
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_ERRORS
#ifdef DOS
#define INCL_NOXLATE_DOS16
#endif

#include "expand.h"

#define TRUE 1
#define FALSE 0

#define SUCCESS 0       /* function call successful */
#define FAILURE (-1)    /* function call had a failure */

#define READ_ONLY 0x0001   /* file is read only */
#define HIDDEN    0x0002   /* file is hidden */
#define SYSTEM    0x0004   /* file is a system file */
#define VOLUME    0x0008   /* file is a volume label */
#define SUBDIR    0x0010   /* file is a subdirectory */
#define ARCHIVE   0x0020   /* file has archive bit on */

#define uint unsigned int
#define ulong unsigned long
#define ushort unsigned short

/*
 * struct search_rec is used to form a linked list of path specifications
 * that are still left to be searched.
 */
struct search_rec {
   struct search_rec *next;
   WCHAR *dir_spec;         /* path spec up until component w/ wildcard */
   WCHAR *wild_spec;        /* component containing wildcard char(s) */
   WCHAR *remain;           /* remainder of name after wildcard component */
   ushort attr;
   };

/*
 * global variables
 */
static struct search_rec *search_head = NULL;

/*
 * prototypes of functions referenced
 */
split_path(WCHAR *, WCHAR *, WCHAR *, WCHAR *);
add_search_list(WCHAR *, WCHAR *, WCHAR *, ushort);
add_arg_to_list(WCHAR *, ARGS *);
do_tree(struct search_rec *, ushort, ARGS *);
file_exists(WCHAR *);


/******************************************************************************
*
* args_init()
*
*   Initialize the ARGS struct passed as an argument.
*
*   ENTRY:
*       argp = pointer to ARGS struct
*       maxargs = max number of args expected
*
*   EXIT:
*
******************************************************************************/

void
args_init( ARGS *argp,
           int maxargs )
{

   argp->argc = 0;
   argp->argv = argp->argvp = NULL;
   argp->maxargc = argp->maxargs = maxargs;
   argp->buf = argp->bufptr = argp->bufend = NULL;
}


/******************************************************************************
* args_trunc()
*
*   Truncate the memory used by the ARGS struct
*   so that unused memory is freed.
*
*   ENTRY:
*       argp = pointer to ARGS struct
*
*   EXIT:
*
******************************************************************************/

void
args_trunc( ARGS *argp )
{

   /*
    * call realloc to shrink size of argv array, set maxargc = argc
    * to indicate no more room in argv array.
    */
   realloc(argp->argv, (argp->argc + 1) * sizeof(WCHAR*));
   argp->maxargc = argp->argc;

   /*
    * call realloc to shrink size of argument string buffer, set bufend
    * pointer to current buf pointer to indicate buf is full.
    */
   realloc(argp->buf, (size_t)(argp->bufptr - argp->buf));
   argp->bufend = argp->bufptr - 1;
}


/******************************************************************************
*
* args_reset()
*
*   Re-initialize the ARGS struct passed as an argument,
*   free memory if possible.
*
*   ENTRY:
*       argp = pointer to ARGS struct
*
*   EXIT:
*
******************************************************************************/

void
args_reset( ARGS *argp )
{

   /*
    * if there is an argv array, but it has been truncated, then free
    * the array so a new one will be allocated later.
    */
   if (argp->argv && argp->maxargc != argp->maxargs) {
      free(argp->argv);
      argp->argv = NULL;
   }
   argp->argc = 0;
   argp->argvp = argp->argv;
   argp->maxargc = argp->maxargs;

   /*
    * if there is an argument buffer, but it has been truncated, then
    * free the buffer so a new one will be allocated later.
    */
   if (argp->buf && argp->bufend != argp->buf + MAX_ARG_ALLOC - 1) {
      free(argp->buf);
      argp->buf = argp->bufend = NULL;
   }
   argp->bufptr = argp->buf;
}


/******************************************************************************
*
* args_free()
*
*   Will free the memory allocated for
*   argument storage by all preceeding calls to expand_path().
*   Args_init() must be called before reusing this ARGS structure.
*
*   ENTRY:
*       argp = pointer to ARGSW struct
*
*   EXIT:
*
******************************************************************************/

void
args_free( ARGS *argp )
{

   if (argp->argv != NULL)
      free(argp->argv);
   argp->argv = argp->argvp = NULL;

   if (argp->buf != NULL)
      free(argp->buf);
   argp->buf = argp->bufptr = argp->bufend = NULL;
}


/******************************************************************************
*
* expand_path()
*
*   This routine will expand the specified path string into pathnames
*   that match.  The matching pathnames will be added to the specified
*   argv array and the specified argc count will be incremented to
*   reflect the number of pathnames added.
*
*   This routine will expand filename arguments in Unix fashion
*   (i.e. '[..]' is supported, '?' and '*' are allowed anywhere in the
*   pathname, even in the directory part of the name, and the
*   name/extension separator '.' is not treated special but is just
*   considered part of the filename).
*
*   Storage for the pathname strings will be obtained via malloc.
*   This space may later be free'd with a call to args_free();
*
*   ENTRY:
*       path     Pathname string to be expanded.
*       attr     Attribute bits of files to include
*                   (regular, directory, hidden, system).
*                   -1 = return the specified pathname string unmodified
*                        in the argv array.
*       argp     Pointer to an ARGSW struct containing fields to be used/
*                updated by expand_path.  The ARGS struct must be initialized
*                by calling args_init() before calling expand_path().
*
*    EXIT:
*       TRUE  -- indicates at least 1 pathname was found matching
*                the pathname string specified.
*       FALSE -- indicates no matching pathnames were found.  The specified
*                pathname string is returned unmodified in the argv array.
*
******************************************************************************/

int
expand_path( WCHAR *path,
             ushort attr,
             ARGS *argp )
{
   int argc, add_count, rc, i, j, k;
   WCHAR **argv;
   WCHAR dirname[128], wild[128], remain[128];
   struct search_rec *save, *q;

#ifdef DEBUG
   printf("expand_path: path=%s attr=%d\n", path, attr);
#endif

   argc = argp->argc;
   argv = argp->argvp;
   if ( attr != -1 && split_path(path, dirname, wild, remain)) {
      add_search_list(dirname, wild, remain, attr);
      while (search_head) {
         /*
          * save the next portion and allow new directories to be
          * added to the head.
          */
         save = search_head->next;
         search_head->next = NULL;

         /*
          * perform the do_tree operation on the current path
          */
         rc = do_tree(search_head, attr, argp);

         /*
          * restore the saved list at the end of the head list
          */
         if ( save ) {
            q = search_head;
            while ( q->next ) {
               q = q->next;
            }
            q->next = save;
         }

         /*
          * move to the next path in the list and free the memory used
          * by the link we are done with
          */
         do {
            q = search_head;
            search_head = search_head->next;
            free( q->dir_spec );
            free( q->wild_spec );
            free( q->remain );
            free( q );
         } while (rc==FAILURE && search_head);
      }
   }

/*
 * If no filenames were expanded, just put the original name
 * into the buffer and indicate no names were expanded.
 */
   if (argc == argp->argc) {
      add_arg_to_list(path, argp);
      return(FALSE);
   }

/*
 * Sort the names just added
 */
   if ( argv == NULL )
      argv = argp->argv;
   add_count = argp->argc - argc;
   for (i=add_count-1; i>0; --i) {
      uint swap = FALSE;
      for (j=0; j<i; ++j) {
         if (!argv[j] || !argv[j+1]) {
            ErrorOutFromResource(IDS_INTERNAL_ERROR_1);
            //fprintf(stderr,"internal error 1\n");
         }
         for (k=0; k<128; ++k) {
            if (argv[j][k] < argv[j+1][k]) {
               break;
            } else if (argv[j][k] > argv[j+1][k]) {
               WCHAR *temp;
               swap = TRUE;
               temp = argv[j];
               argv[j] = argv[j+1];
               argv[j+1] = temp;
               break;
            }
         }
         if (k>125) {
            ErrorOutFromResource(IDS_INTERNAL_ERROR_2);
            // fprintf(stderr,"internal error 2\n");
         }
      }
      if (!swap) {
         break;
      }
   }
   return(TRUE);
}


/******************************************************************************
*
* add_search_list()
*
*    Adds a record to the global search list, search_head.
*
******************************************************************************/

static
add_search_list(
    WCHAR *dir_spec,        /* the dir to be added to the list */
    WCHAR *wild_spec,       /* the file to be added to the list */
    WCHAR *remain_spec,     /* remaining portion of pathname */
    ushort attr )
{
   struct search_rec *new, /* pointer to the new link */
                     *q;   /* used to traverse the linked list */

#ifdef DEBUG
   wprintf(L"add_search_list: dir=%s: file=%s: rem=%s:\n", dir_spec, wild_spec, remain_spec);
#endif

/*
 * allocate the new link.  make sure that it is initialized to zeros.
 */
   new = malloc(sizeof(struct search_rec));

   if (!new) {
      ErrorOutFromResource(IDS_ADD_SRCH_LIST_NO_MEMORY_MALLOC);
      // fprintf(stderr, "add_search_list: not enough memory (malloc)");
      return FAILURE;
   }

   memset(new, 0, sizeof(struct search_rec));

/*
 * allocate memory for and copy the dir spec and file spec.
 */
   if (dir_spec)
   {
       new->dir_spec = _wcsdup(dir_spec);
       if( new->dir_spec == NULL )
       {
           ErrorOutFromResource(IDS_ADD_SRCH_LIST_NO_MEMORY_STRDUP1);
            // fprintf(stderr, "add_search_list: not enough memory (strdup1)");
            return FAILURE;
       }

       _wcslwr( new->dir_spec );
   }
   if (wild_spec)
   {
      new->wild_spec = _wcsdup(wild_spec);
      if (new->wild_spec == NULL )
      {
          ErrorOutFromResource(IDS_ADD_SRCH_LIST_NO_MEMORY_STRDUP2);
          // fprintf(stderr, "add_search_list: not enough memory (strdup2)");
          return FAILURE;
      }

      _wcslwr( new->wild_spec );
      
   }
   if (remain_spec)
   {
       new->remain = _wcsdup(remain_spec);
       if( new->remain == NULL )
       {
           ErrorOutFromResource(IDS_ADD_SRCH_LIST_NO_MEMORY_STRDUP3);
            // fprintf(stderr, "add_search_list: not enough memory (strdup3)");
            return FAILURE;
       }

       _wcslwr( new->remain );

   }

/*
 * store file attributes
 */
   if (remain_spec)
      new->attr = attr | SUBDIR;
   else
      new->attr = attr;

/*
 * add the new link at the end of the list
 */
   if (!search_head) {
      search_head = new;
   } else {
      q = search_head;
      while (q->next) {
         q = q->next;
      }
      q->next = new;
   }

   return SUCCESS;
}


/******************************************************************************
*
* add_arg_to_list()
*
*   This routine adds the specified argument string to the argv array,
*   and increments the argv pointer and argc counter.
*   If necessary, memory for the argument string is allocated.
*
*   EXIT:
*       SUCCESS -- if argument added successfully
*       FAILURE -- if argument could not be added
*             (indicates too many args or out of memory for argument string)
*
******************************************************************************/
static int
add_arg_to_list( WCHAR *arg_string,
                 ARGS *argp )
{
   int len;

#ifdef DEBUG
   wprintf(L"add_arg_to_list: arg_string=%s:, argc=%d, argvp=%x, maxargs=%d\n",
           arg_string,argp->argc,argp->argvp,argp->maxargc);
#endif
   if (argp->argc >= argp->maxargc) {
      ErrorOutFromResource(IDS_TOO_MANY_ARGUMENTS);
      // fprintf(stderr,"add_arg_to_list: too many arguments\n");
      return FAILURE;
   }
   if (!argp->argv) {
      argp->argv = malloc(sizeof(WCHAR *) * (argp->maxargs+1));
      if (argp->argv) {
         argp->argc = 0;
         argp->argvp = argp->argv;
         argp->maxargc = argp->maxargs;
      } else {
         ErrorOutFromResource(IDS_ARGS_TO_LIST_NOT_ENOUGH_MEMORY);
         // fprintf(stderr,"add_arg_to_list: not enough memory\n");
         return FAILURE;
      }
   }
   if (!argp->buf) {
      argp->buf = malloc(MAX_ARG_ALLOC);
      if (argp->buf) {
         argp->bufptr = argp->buf;
         argp->bufend = argp->buf + MAX_ARG_ALLOC - 1;
      } else {
         ErrorOutFromResource(IDS_ARGS_TO_LIST_NOT_ENOUGH_MEMORY);
         // fprintf(stderr,"add_arg_to_list: not enough memory\n");
         return FAILURE;
      }
   }
   len = wcslen(arg_string) + 1;
   if (argp->bufptr + len > argp->bufend) {
      ErrorOutFromResource(IDS_ARGS_TO_LIST_ARG_BUFFER_SMALL);
      // fprintf(stderr,"add_arg_to_list: argument buffer too small\n");
      return FAILURE;
   }
   wcscpy(argp->bufptr, arg_string);
   *(argp->argvp) = argp->bufptr;
   argp->bufptr += len;
   ++argp->argc;
   ++argp->argvp;
   *(argp->argvp) = NULL;
   return SUCCESS;
}


/******************************************************************************
*
* do_tree()
*
******************************************************************************/

static
do_tree( struct search_rec *searchp,
         ushort attr,
         ARGS *argp )
{
   int rc;                 /* return code from Dos calls */
   WIN32_FIND_DATA result; /* the structure returned from FindFirst/Next */
   ushort count = 1;       /* number of files to look for at one time */
   HANDLE handle;   /* the dir handle used by FindFirst/Next */
   WCHAR full_path[128];    /* used to hold the path/file combination */
   WCHAR dirname[128], wild[128], remain[128];
   WCHAR *fptr;             /* pointer to file portion of full_path */
   ULONG Status;

#ifdef DEBUG
   wprintf(L"do_tree: dirname=%s:\n", searchp->dir_spec);
#endif

   /*
    * build up directory part of path and save a pointer to the file portion
    */
   wcscpy(full_path, searchp->dir_spec);
   fptr = full_path + wcslen(searchp->dir_spec);
   wcscpy(fptr, L"*.*");

   handle = FindFirstFile ( full_path,                  /* files to find */
			&result
		       );

   if(handle == INVALID_HANDLE_VALUE){
       Status = GetLastError();
       if(Status == ERROR_NO_MORE_FILES) {
           // no files match
	   return(SUCCESS);
       }
       return(FAILURE);
   }

   rc = TRUE;
   while (rc) {
      /*
       * do not do anything for the "." and ".." entries
       */
      if (wcscmp(result.cFileName, L".") == 0 ||
         wcscmp(result.cFileName, L"..") == 0) {
         rc = FindNextFile( handle, &result );
         continue;
      }

      /*
       * fully qualify the found file
       */
      wcscpy(fptr, _wcslwr(result.cFileName));
      if (searchp->remain)
         wcscat(full_path, searchp->remain);

      /*
       * see if current wild_spec matches FindFirst/Next file
       */
      if (unix_match(searchp->wild_spec, result.cFileName)) {
         if (searchp->remain && split_path(full_path, dirname, wild, remain)) {
            if (result.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&
		file_exists(dirname))
               add_search_list(dirname, wild, remain, attr);
         } else if (file_exists(full_path)) {
            rc = add_arg_to_list(full_path, argp);
            if (rc != SUCCESS)
               break;
         }
      }

      /*
       * find the next file
       */
      rc = FindNextFile( handle, &result );
   }

   /*
    * if no more files to find then reset the error code back to successful.
    */

   if(!rc) {
       Status = GetLastError();
       if(Status == ERROR_NO_MORE_FILES)
	   rc = SUCCESS;
   }

   return rc;
}


/******************************************************************************
*
* split_path()
*
*   This routine splits the specified pathname into 3 parts, any of which
*   may be null; 1) the pathname from the beginning up to but not including
*   the first component containing a wildcard character, 2) the component
*   containing the wildcard, and 3) the remainder of the path string after
*   the component containing the wildcard.
*
*   Examples:
*      Original path              dir            file     remain
*      "c:\mydir\dir??\*.c"       "c:\mydir\"    "dir??"  "\*.c"
*      "*\abc.def"                ""             "*"      "\abc.def"
*      "mydir\*.c"                "mydir\"       "*.c"    ""
*
*   EXIT:
*       TRUE  -- if the pathname could be split
*       FALSE -- otherwise (i.e. pathname did not contain any wildcards)
*
******************************************************************************/

static int
split_path( WCHAR *path,
            WCHAR *dir,
            WCHAR *file,
            WCHAR *remain )
{
   WCHAR *cp, *end_dir, *end_wild = NULL;

#ifdef DEBUG
   wprintf("split_path: path=%s:\n", path);
#endif
   for (cp=end_dir=path; *cp!=L'\0'; ) {
      if (*cp==L'\\' || *cp==L'/' || *cp==L':') {
         ++cp;
         while (*cp==L'\\' || *cp==L'/' ) ++cp;
         end_dir = cp;
      } else if (*cp==L'*' || *cp==L'?' || *cp==L'[') {
         ++cp;
         while (*cp!=L'\\' && *cp!=L'/' && *cp!=L'\0') ++cp;
         end_wild = cp;
         break;
      } else {
         ++cp;
      }
   }
   if (!end_wild)
      return(FALSE);

   for (cp=path; cp<end_dir; ++cp, ++dir)
      *dir = *cp;
   *dir = L'\0';
   for (cp=end_dir; cp<end_wild; ++cp, ++file)
      *file = *cp;
   *file = L'\0';
   wcscpy(remain, cp);
#ifdef DEBUG
   wprintf("split_path: dir=%s: file=%s: remain=%s:\n", dir, file, remain);
#endif

   return(TRUE);
}


/******************************************************************************
*
* file_existsW()
*
*   Returns TRUE if specified file exists, otherwise returns FALSE.
*
******************************************************************************/

static int
file_exists( WCHAR *path )
{
   int len;
   WCHAR path2[128];
   WCHAR ch;
   ULONG Result;

   wcscpy(path2, path);
   len = wcslen(path2);
   while ((ch=path2[--len]) == L'\\' || ch == L'/' ) path2[len] = L'\0';
   
   Result = GetFileAttributes(path2);
   if(Result == 0xFFFFFFFF) {
       return(FALSE);
   }
   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\makefile.inc ===
#
#       Do not delete this file, needed to build .lib file.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utildll\utildll.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation

/*******************************************************************************
*
* utildll.c
*
* UTILDLL multi-user utility support functions
*
*
*******************************************************************************/

/*
 * include files
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntcsrsrv.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <nb30.h>
#include <tapi.h>
#include <raserror.h>
#include <lmerr.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmwksta.h>
#include <lmremutl.h>
#include <lmapibuf.h>

#define INITGUID
#include "objbase.h"
#include "initguid.h"
//#include "basetyps.h"
#include "devguid.h"
#include "setupapi.h"

#include <winsta.h>

#include <utildll.h>
#include "..\inc\utilsub.h"
#include "..\inc\ansiuni.h"
#include "resource.h"

/*
 * Hydrix helpers function internal defines
 */
#define INITIAL_ENUMERATION_COUNT   16
#define REGISTRY_NETCARDS           TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards")
#define REGISTRY_TITLE              TEXT("Title")
#define REGISTRY_SERVICE_NAME       TEXT("ServiceName")
#define REGISTRY_HIDDEN             TEXT("Hidden")
#define REGISTRY_ROUTE              TEXT("Route")
#define REGISTRY_NETBLINKAGE        TEXT("SYSTEM\\CurrentControlSet\\Services\\NetBIOS\\Linkage")
#define REGISTRY_NETBLINKAGE_LANAMAP TEXT("LanaMap")
#define REGISTRY_SERVICES           TEXT("SYSTEM\\CurrentControlSet\\Services")
#define REGISTRY_DISPLAY_NAME       TEXT("DisplayName")

/*
 * TAPI defines.
 */
#define LOW_MAJOR_VERSION   0x0001
#define LOW_MINOR_VERSION   0x0003
#define HIGH_MAJOR_VERSION  0x0002
#define HIGH_MINOR_VERSION  0x0000

#define LOW_VERSION  ((LOW_MAJOR_VERSION  << 16) | LOW_MINOR_VERSION)
#define HIGH_VERSION ((HIGH_MAJOR_VERSION << 16) | HIGH_MINOR_VERSION)


/*=============================================================================
==   Local Functions Defined
=============================================================================*/
BOOL CheckForComDevice( LPTSTR );
int NetBiosLanaEnum( LANA_ENUM * pLanaEnum );
DWORD EnumerateTapiPorts( PPDPARAMS pPdParams, ULONG Count, ULONG **ppEntries );
VOID CALLBACK DummyTapiCallback(HANDLE, DWORD, DWORD, DWORD, DWORD, DWORD);
BOOL GetAssociatedPortName(char  *szKeyName, WCHAR *wszPortName);
BOOL _UserInGroup( LPWSTR pwszUsername, LPWSTR pwszDomain, LPWSTR pwszGroup );

/*******************************************************************************
 *
 *  StandardErrorMessage - Hydrix helper function
 *
 *      Output an error message with optional additional arguments like the
 *      ErrorMessagexxx routines.  Additionally, a standard error line will
 *      also be output containing the error code and error message associated
 *      with that code.
 *
 *  ENTRY:
 *      pszAppName (input)
 *          Application name for error message box title.
 *      hwndApp (input)
 *          Owner window for error message box.
 *      hinstApp (input)
 *          Instance handle of application.
 *      LogonId (input)
 *          Optional WinStation LogonId for querying special error strings
 *          from WinStation via WinStationGetInformation API.  If this value
 *          is LOGONID_NONE then no special error message code checking will
 *          be done.
 *      nId (input)
 *          System message code to get standard error string for.
 *      nErrorResourceID (input)
 *          Resource ID of the format string to use in the error message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

void WINAPI
StandardErrorMessage( LPCTSTR pszAppName,
                      HWND hwndApp,
                      HINSTANCE hinstApp,
                      ULONG LogonId,
                      UINT nId,
                      int nErrorMessageLength,
                      int nArgumentListLength,
                      int nErrorResourceID, ...)
{
    TCHAR* szClientErrorMessage = NULL;
    TCHAR* szClientResourceString = NULL;
    TCHAR* szError = NULL;
    TCHAR* szFormattedErrorMessage = NULL;
    TCHAR* szMessage = NULL;
    TCHAR  szStandardErrorMessage[STANDARD_ERROR_TEXT_LENGTH + 1];

    va_list args;
    va_start( args, nErrorResourceID );

    szClientErrorMessage = (TCHAR*)malloc((nErrorMessageLength + 1) * sizeof(TCHAR));
    if (szClientErrorMessage)
    {
        LoadString( hinstApp, nErrorResourceID, szClientErrorMessage, nErrorMessageLength );

        szClientResourceString = (TCHAR*)malloc((wcslen(szClientErrorMessage) + nArgumentListLength + 1) * sizeof(TCHAR));
        if (szClientResourceString != NULL)
        {
            wvsprintf( szClientResourceString, szClientErrorMessage, args );

            LoadString( GetModuleHandle( UTILDLL_NAME ),
                        IDS_STANDARD_ERROR_FORMAT, szStandardErrorMessage, STANDARD_ERROR_TEXT_LENGTH );

            szError = GetSystemMessage( LogonId, nId);
            if (szError != NULL)
            {
                szFormattedErrorMessage = (TCHAR*)malloc((wcslen(szStandardErrorMessage) + 10 + wcslen(szError) + 1) * sizeof(TCHAR));
                if (szFormattedErrorMessage != NULL)
                {
                    wsprintf( szFormattedErrorMessage, szStandardErrorMessage, nId, szError);

                    //lstrcpy(sz1, pszAppName);

                    szMessage = (TCHAR*)malloc((wcslen(szClientResourceString) + wcslen(szFormattedErrorMessage) + 1) * sizeof(TCHAR));
                    if (szMessage != NULL)
                    {
                        wcscpy(szMessage, szClientResourceString);
                        wcscat(szMessage, szFormattedErrorMessage);

                        MessageBox( hwndApp, szMessage, pszAppName, MB_OK | MB_ICONEXCLAMATION );
    
                        free(szMessage);
                    }
                    free(szFormattedErrorMessage);
                }
                free (szError);
            }
            free(szClientResourceString);
        }
        free (szClientErrorMessage);
    }
    va_end(args);
}  // end StandardErrorMessage


/*******************************************************************************
 *
 *  GetSystemMessageA - Hydrix helper function (ANSI stub)
 *
 *      Return the string associated with the specified system message.
 *
 *  ENTRY:
 *      (refer to GetSystemMessageW)
 *  EXIT:
 *      (refer to GetSystemMessageW)
 *      If cannot allocate temporary UNICODE buffer to call GetSystemMessageW
 *      with, the ntents of chBuffer will be set to the "(no error text
 *      available)" string.
 *
 ******************************************************************************/

LPSTR WINAPI
GetSystemMessageA( ULONG LogonId,
                   UINT nId
                   /*LPSTR chBuffer,
                   int cbBuffSize*/ )
{
    LPWSTR uBuffer = NULL;
    LPSTR aBuffer = NULL;
    int length;
    
    //Call the GetSystemMessageW function
    uBuffer = GetSystemMessageW(LogonId, nId);
    if (uBuffer == NULL)
    {
        //If no message was returned from the GetSystemMessageW
        //function just return a generic error message
        aBuffer = malloc((NO_ERROR_TEXT_LENGTH + 1) * sizeof(char));
        if (aBuffer == NULL)
            return NULL;

        length = LoadStringA( GetModuleHandle( UTILDLL_NAME ),
                              IDS_NO_ERROR_TEXT_AVAILABLE,
                              aBuffer, NO_ERROR_TEXT_LENGTH );
        ASSERT(length);
    }
    else
    {
        length = wcslen(uBuffer) + 1;

        //Convert the result into ANSI in caller supplied buffer.
        aBuffer = malloc(length * sizeof(char));
        if (aBuffer != NULL)
            WideCharToMultiByte(CP_ACP, 0, uBuffer, length - 1, aBuffer, length, 0, 0);

        //Free the temporary buffer.
        free (uBuffer);
    }

    //Return message.
    return(aBuffer);
}  // end GetSystemMessageA


/*******************************************************************************
 *
 *  GetSystemMessageW - Hydrix helper function (UNICODE version)
 *
 *      Return the string associated with the specified system message.
 *
 *  ENTRY:
 *      LogonId (input)
 *          Optional WinStation LogonId for querying special error strings
 *          from WinStation via WinStationGetInformation API.  If this value
 *          is LOGONID_NONE then no special error message code checking will
 *          be done.
 *      nId (input)
 *          System message code to get string for.
 *      chBuffer (input)
 *          Points to buffer to fill with system message string.
 *      cbBuffSize (input)
 *          Maximum number of characters that can be placed in chBuffer.
 *
 *  EXIT:
 *      Returns chBuffer.  Contents of chBuffer will always be set; to
 *      the "(no error text available)" string if error.
 *
 *      Note: the total length of chBuffer (including terminating NULL) will
 *      not exceed the size of the internal temporary buffer (Buffer).
 *
 ******************************************************************************/


//NA 3/9/01 IMPORTANT: Behavior has changed. Instead of expecting a buffer long
//enough to accomodate the message, it now allocates the memory dynamically, so 
//it's up to the calling procedure to deallocate it.
LPWSTR WINAPI
GetSystemMessageW( ULONG LogonId,
                   UINT nId
                   /*LPWSTR chBuffer,
                   int cbBuffSize*/ )
{
    LPWSTR chBuffer = NULL;

    WCHAR StackBuffer[512];
    WCHAR* SpecialBuffer = NULL;
    WCHAR* Buffer = NULL;
    BOOL bSpecialCitrixError = FALSE;
    HINSTANCE cxerror = LoadLibraryW(L"cxerror.dll");
    int length = 0;

    StackBuffer[0]=0;

    //If we have a valid LogonId passed in, determine if the error
    //is a special code requiring that the specific error string be
    //queried from the WinStation.
    if ( LogonId != LOGONID_NONE ) 
    {
        switch ( nId ) 
        {
            case ERROR_CTX_TD_ERROR:               
                length = LoadStringW( GetModuleHandle( UTILDLL_NAME ),
                                      IDS_NO_ADDITIONAL_ERROR_INFO,
                                      StackBuffer,
                                      sizeof(StackBuffer)/sizeof(WCHAR) );
                ASSERT(length);
                SpecialBuffer = malloc((length + 1) * sizeof(WCHAR));
                if (SpecialBuffer != NULL)
                {
                    wcscpy(SpecialBuffer, StackBuffer);
                    bSpecialCitrixError = TRUE;
                }
                break;

            default:
                break;
        }
    }

    //See if this is a Citrix error message first...
    if ( !cxerror ||
         !FormatMessageW( FORMAT_MESSAGE_IGNORE_INSERTS |
                          FORMAT_MESSAGE_MAX_WIDTH_MASK |
                          FORMAT_MESSAGE_FROM_HMODULE |
                          FORMAT_MESSAGE_ALLOCATE_BUFFER,
                          (LPCVOID)cxerror,
                          nId,
                          0,
                          (LPWSTR)&Buffer,
                          0,
                          NULL ) ) 
    {
        //It's not a Citrix error message; fetch system message.
        if ( !FormatMessageW( FORMAT_MESSAGE_IGNORE_INSERTS |
                              FORMAT_MESSAGE_MAX_WIDTH_MASK |
                              FORMAT_MESSAGE_FROM_SYSTEM |
                              FORMAT_MESSAGE_ALLOCATE_BUFFER,
                              NULL,
                              nId,
                              0,
                              (LPWSTR)&Buffer,
                              0,
                              NULL ) ) 
        {
            //It's not a system message; don't know what the message is...
            length = LoadStringW( GetModuleHandle( UTILDLL_NAME ),
                                  IDS_NO_ERROR_TEXT_AVAILABLE,
                                  StackBuffer,
                                  sizeof(StackBuffer)/sizeof(WCHAR) );
            ASSERT(length);
            Buffer = LocalAlloc(0,(length + 1) * sizeof(WCHAR));
            if (Buffer == NULL)
            {
                if (SpecialBuffer != NULL)
                    free (SpecialBuffer);
                return NULL;
            }
            wcscpy(Buffer, StackBuffer);
        }
    }
    if ( cxerror )
        FreeLibrary(cxerror);

    length = wcslen(Buffer);
    if ( bSpecialCitrixError )
        length += wcslen(SpecialBuffer) + 2;

    chBuffer = malloc((length + 1) * sizeof(WCHAR));
    if (chBuffer != NULL)
    {
        wcscpy(chBuffer, Buffer);

        //If we fetched a special Citrix error string, tack it onto the end
        //of whatever we've buffered already.
        if ( bSpecialCitrixError )
        {
            lstrcatW(chBuffer, L"  ");
            lstrcatW(chBuffer, SpecialBuffer);
        }
    }

    if (Buffer != NULL)
        LocalFree (Buffer);

    if (( bSpecialCitrixError ) && (SpecialBuffer != NULL))
        free (SpecialBuffer);

    return(chBuffer);

}  // end GetSystemMessageW


/*******************************************************************************
 *
 *  WinEnumerateDevices - Hydrix helper function
 *
 *      Perform PD device enumeration for the specified PD.
 *
 *  ENTRY:
 *      hWnd (input)
 *          Parent window for error message, if needed.
 *      pPdConfig (input)
 *          Points to PDCONFIG3 structure of the PD.
 *      pEntries (output)
 *          Points to variable to return number of devices that were enumerated.
 *      bInSetup (input)
 *          TRUE if we're operating in Setup; FALSE otherwise.
 *
 *  EXIT:
 *      (PPDPARAMS) Points to the PDPARAMS array containing the enumeration
 *                  results if sucessful.  The caller must perform a LocalFree
 *                  of this array when done.  NULL if error; error set for
 *                  GetLastError();
 *      If the returned error code is anything other than
 *      ERROR_NOT_ENOUGH_MEMORY, the caller can assume that none of the
 *      requested devices were available to be enumerated.
 *
 ******************************************************************************/

typedef BOOL (WINAPI * PPDENUMERATE)( PPDCONFIG3, PULONG, PPDPARAMS, PULONG, BOOL );

PPDPARAMS WINAPI
WinEnumerateDevices( HWND hWnd,
                     PPDCONFIG3 pPdConfig,
                     PULONG pEntries,
                     BOOL bInSetup )
{
    PPDENUMERATE pPdEnumerate;
    ULONG ByteCount;
    DWORD Error;
    int i;
    PPDPARAMS pPdParams = NULL;

    /*
     * Enumerate according to class.
     */
    switch ( pPdConfig->Data.SdClass ) {

        case SdAsync:
            pPdEnumerate = AsyncDeviceEnumerate;
            break;

        case SdNetwork:
            if ( pPdConfig->Data.PdFlag & PD_LANA ) {

                /*
                 * This is a LANA based network PD (ie, NetBIOS).  Perform
                 * NetBIOS enumerate.
                 */
                pPdEnumerate = NetBIOSDeviceEnumerate;

            }
            else {

                /*
                 * This is a physical lan adapter based network (TCP/IP,
                 * IPX, SPX, etc).  Enumerate based on the associated network
                 * protocol service name.
                 */
                pPdEnumerate = NetworkDeviceEnumerate;
            }
            break;

        default:
            return(NULL);
    }

    /*
     * Call enumerate in loop till we hit enough buffer entries to handle
     * a complete enumeration.  NOTE: some enumeration routines will return
     * the necessary ByteCount on 'insufficient buffer' status; others won't.
     */
    for ( ByteCount = 0, i = INITIAL_ENUMERATION_COUNT; ; i *= 2 ) {


        if ( pPdParams != NULL )
            LocalFree(pPdParams);

        pPdParams = (PPDPARAMS)LocalAlloc(
                                         LPTR,
                                         ByteCount ?
                                         ByteCount :
                                         (ByteCount = sizeof(PDPARAMS) * i) );


        if ( pPdParams == NULL ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto OutOfMemory;
        }

        /*
         * Perform enumeration and break loop if successful.
         */
        if ( (*pPdEnumerate)( pPdConfig,
                              pEntries,
                              pPdParams,
                              &ByteCount,
                              bInSetup ) )
            break;

        /*
         * If we received any other error other than 'insufficient buffer',
         * quit (quietly).
         */
        if ( (Error = GetLastError()) != ERROR_INSUFFICIENT_BUFFER )
            goto BadEnumerate;
    }

    /*
     * Success: return the PDPARAMS pointer.
     */
    return(pPdParams);

    /*==============================================================================
     * Error returns
     *============================================================================*/
    BadEnumerate:
    LocalFree(pPdParams);
    OutOfMemory:
    return(NULL);

}  // end WinEnumerateDevices


/*******************************************************************************
 *
 *  NetworkDeviceEnumerate - Hydrix helper function
 *
 *   Returns a list of Lan Adapter indexes of network cards bound to the the
 *   specified protocol.  The Lan Adapter is returned in the LanAdapter field
 *   of each PDPARAMS array.  A LanAdapter value of 0 indicates 'any configured
 *   network card'.  Indexes >=1 indicate 1-based index into the specific
 *   protocol's  "servicename"\Linkage\Route registry entry to specify the
 *   particular network card.
 *
 * ENTRY:
 *    pPdConfig (input)
 *       Points to PDCONFIG3 structure of the PD.
 *    pEntries (output)
 *       When the function finishes successfully, the variable pointed to
 *       by the pEntries parameter contains the number of entries actually
 *       returned.
 *    pPdParams (output)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of PDPARAMS structures.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pPdParams parameter. If the buffer is too small to receive all the
 *       entries, on output this variable receives the required size of the
 *       buffer.
 *    bInSetup (input)
 *          TRUE if we're operating in Setup; FALSE otherwise.
 *
 * EXIT:
 *      TRUE: enumeration was sucessful; FALSE otherwise.
 *
 *      The error code can be retrieved via GetLastError(), and are the
 *      following possible values:
 *          ERROR_INSUFFICIENT_BUFFER
 *              enumeration failed because of an insufficient pPdParams
 *              buffer size to contain all devices
 *          ERROR_DEV_NOT_EXIST
 *              The specified network's service was not found, indicating that
 *              the protocol was not configured.  This error code can be
 *              interpreted as 'no devices are configured for the xxx protocol'
 *              for reporting purposes.
 *          ERROR_xxxx
 *              Registry error code.
 *
 ******************************************************************************/

BOOL WINAPI
NetworkDeviceEnumerate( PPDCONFIG3 pPdConfig,
                        PULONG pEntries,
                        PPDPARAMS pPdParams,
                        PULONG pByteCount,
                        BOOL bInSetup )
{
    ULONG i, Count;
    LPTSTR szRoute, szRouteStr;
    LONG Status;
    DWORD ValueSize, Type;
    TCHAR szKey[256];
    HKEY Handle;

    /*
     * Get maximum number of LanAdapter indexes that can be returned.
     */
    Count = *pByteCount / sizeof(PDPARAMS);

    /*
     * Form key for service name associated with this PD and fetch
     * the Linkage\Route strings.
     */
    _snwprintf( szKey, sizeof(szKey)/sizeof(TCHAR),
                TEXT("%s\\%s\\Linkage"), REGISTRY_SERVICES,
                pPdConfig->ServiceName );
    if ( (Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &Handle ))
         != ERROR_SUCCESS ) {
        Status = ERROR_DEV_NOT_EXIST;
        goto BadRegistryOpen;
    }

    /*
     * Alloc and read in the linkage route multi-string.
     */
    if ( ((Status = RegQueryValueEx( Handle, REGISTRY_ROUTE,
                                     NULL, &Type,
                                     NULL, &ValueSize ))
          != ERROR_SUCCESS) || (Type != REG_MULTI_SZ) )
        goto BadQuery1;

    if ( !(szRoute = (LPTSTR)LocalAlloc(LPTR, ValueSize)) ) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto BadAlloc;
    }

    if ( ((Status = RegQueryValueEx( Handle, REGISTRY_ROUTE,
                                     NULL, &Type,
                                     (LPBYTE)szRoute, &ValueSize ))
          != ERROR_SUCCESS) )
        goto BadQuery2;

    /*
     * Close the registry key handle and count the route strings to obtain
     * the number of entries to report in the enumeration.
     */
    RegCloseKey(Handle);
    for ( i = 1, szRouteStr = szRoute; lstrlen(szRouteStr); i++ )
        szRouteStr += (lstrlen(szRouteStr) + 1);
    LocalFree(szRoute);

    /*
     * If we don't have enough PDPARAMS structures to report all of the
     * LanAdapter indexes, return error.
     */
    if ( i > Count ) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        *pByteCount = (i * sizeof(PDPARAMS));
        goto BadBufferSize;
    }

    /*
     * Set the LanAdapter fields of the first 'i' PDPARAMS structures to
     * the indexes (0-based), set total number of entries, and return success.
     */
    for ( Count = 0, *pEntries = i; Count < i; pPdParams++, Count++ )
        pPdParams->Network.LanAdapter = (LONG)Count;
    return(TRUE);

    /*==============================================================================
     * Error returns
     *============================================================================*/
    BadQuery2:
    LocalFree(szRoute);
    BadAlloc:
    BadQuery1:
    RegCloseKey(Handle);
    BadBufferSize:
    BadRegistryOpen:
    SetLastError(Status);
    return(FALSE);

}  // end NetworkDeviceEnumerate


/*******************************************************************************
 *
 *  QueryCurrentWinStation  - Hydrix helper function
 *
 *      Query the currently logged-on WinStation information.
 *
 *  ENTRY:
 *      pWSName (output)
 *          Points to string to place current WinStation name.
 *      pUserName (output)
 *          Points to string to place current User name.
 *      pLogonId (output)
 *          Points to ULONG to place current LogonId.
 *      pFlags (output)
 *          Points to ULONG to place current WinStation's flags.
 *
 *  EXIT:
 *      (BOOL) TRUE if the user's current WinStation information was queried
 *              sucessfully; FALSE otherwise.  The error code is set for
 *              GetLastError() to retrieve.
 *
 ******************************************************************************/

BOOL WINAPI
QueryCurrentWinStation( PWINSTATIONNAME pWSName,
                        LPTSTR pUserName,
                        PULONG pLogonId,
                        PULONG pFlags )
{
    ULONG Flags = 0;
    WINSTATIONINFORMATION WSInfo;
#ifdef WINSTA
    ULONG ReturnLength;
#endif // WINSTA

#ifdef WINSTA
    /*
     * Fetch the WinStation's basic information.
     */
    if ( !WinStationQueryInformation( SERVERNAME_CURRENT,
                                      LOGONID_CURRENT,
                                      WinStationInformation,
                                      &WSInfo,
                                      sizeof(WSInfo),
                                      &ReturnLength ) )
        goto BadQuery;

    /*
     * Check for shadow capability if WinStation is connected.  If the
     * WinStation is not connected, we can't shadow.
     */
    if ( WSInfo.ConnectState != State_Disconnected ) {

        WDCONFIG WdConfig;

        /*
         * Query Wd config stuff.
         */
        if ( !WinStationQueryInformation( SERVERNAME_CURRENT,
                                          LOGONID_CURRENT,
                                          WinStationWd,
                                          &WdConfig,
                                          sizeof(WdConfig),
                                          &ReturnLength ) )
            goto BadQuery;

        /*
         * Set WinStation's Wd flags.
         */
        Flags = WdConfig.WdFlag;
    }
#else
    lstrcpy(WSInfo.WinStationName, TEXT("console"));
    lstrcpy(WSInfo.UserName, TEXT("bonzo"));
    WSInfo.LogonId = 0;
#endif // WINSTA

    /*
     * Set WinStation information into caller's variables, and return success.
     */
    lstrcpy( pWSName, WSInfo.WinStationName );
    lstrlwr(pWSName);
    lstrcpy( pUserName, WSInfo.UserName );
    lstrlwr(pUserName);
    *pLogonId = WSInfo.LogonId;
    *pFlags = Flags;

    return(TRUE);

    /*==============================================================================
     * Error returns
     *============================================================================*/
#ifdef WINSTA
    BadQuery:
#endif // WINSTA
    return(FALSE);

}  // end QueryCurrentWinStation


/*******************************************************************************
 *
 *  RegGetNetworkDeviceName - Hydrix helper function
 *
 *      Obtain the network device name associated with the given WinStation PD.
 *
 *  ENTRY:
 *      hServer (input)
 *          Handle to Hydrix Server
 *      pPdConfig (input)
 *          Points to the PDCONFIG3 structure for the WinStation's PD.
 *      pPdParams (input)
 *          Points to the PDPARAMS structure for the WinStation's PD.
 *      szDeviceName (output)
 *          Points to buffer to return the network device name.
 *      nDeviceName (input)
 *          Specifies the maxmum number of characters that can be stored in
 *          szDeviceName.
 *
 *  EXIT:
 *      No return.  Will always place a string representation of
 *      pPdParams->Network.LanAdapter along with an appropriate error string
 *      in pDeviceName if the network device name could not be read from the
 *      registry.
 *
 ******************************************************************************/

typedef struct _LANAMAP {
    BYTE enabled;
    BYTE lana;
} LANAMAP, *PLANAMAP;

LONG WINAPI
RegGetNetworkDeviceName( HANDLE hServer,
                         PPDCONFIG3 pPdConfig,
                         PPDPARAMS pPdParams,
                         LPTSTR szDeviceName,
                         int nDeviceName )
{
    int i, length;
    LPTSTR szRoute, szRouteStr, p;
    LONG Status = ERROR_SUCCESS;
    DWORD ValueSize, Type;
    TCHAR szKey[256];
    HKEY Handle;
    HKEY hkey_local_machine;
    PLANAMAP pLanaMap, pLana;

    if ( hServer == NULL)
        hkey_local_machine = HKEY_LOCAL_MACHINE;
    else
        hkey_local_machine = hServer;

    /*
     * Check for NetBIOS (PD_LANA) mapping or other mapping.
     */
    if ( !(pPdConfig->Data.PdFlag & PD_LANA) ) {

        LPTSTR szRoute, szRouteStr;

        /*
         * Non-LANA mapping.  If the LanAdapter is 0, treat this as the
         * special 'all configured network cards' value and return that
         * string as the device name.
         */
        if ( pPdParams->Network.LanAdapter == 0 ) {
            TCHAR szString[256];

            length = LoadString( GetModuleHandle( UTILDLL_NAME ),
                                 IDS_ALL_LAN_ADAPTERS, szString, 256 );
            ASSERT(length);
            lstrncpy(szDeviceName, szString, nDeviceName);
            szDeviceName[nDeviceName-1] = TEXT('\0');
            return Status;
        }

        /*
         * Form key for service name associated with this PD and fetch
         * the Linkage\Route strings.
         */
        _snwprintf( szKey, sizeof(szKey)/sizeof(TCHAR),
                    TEXT("%s\\%s\\Linkage"), REGISTRY_SERVICES,
                    pPdConfig->ServiceName );
        if ( (Status = RegOpenKeyEx( hkey_local_machine, szKey, 0,
                                     KEY_READ, &Handle ))
             != ERROR_SUCCESS )
            goto Error;

        /*
         * Alloc and read in the linkage route multi-string.
         */
        if ( ((Status = RegQueryValueEx( Handle, REGISTRY_ROUTE,
                                         NULL, &Type,
                                         NULL, &ValueSize ))
              != ERROR_SUCCESS) || (Type != REG_MULTI_SZ) )
            goto Error;

        if ( !(szRoute = (LPTSTR)LocalAlloc(LPTR, ValueSize)) ) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        if ( ((Status = RegQueryValueEx( Handle, REGISTRY_ROUTE,
                                         NULL, &Type,
                                         (LPBYTE)szRoute, &ValueSize ))
              != ERROR_SUCCESS) ) {
            LocalFree(szRoute);
            goto Error;
        }

        /*
         * Close the registry key handle and point to the route string
         * associated with this LanAdapter index.
         */
        RegCloseKey(Handle);
        for ( i = 1, szRouteStr = szRoute;
            i < pPdParams->Network.LanAdapter; i++ ) {

            szRouteStr += (lstrlen(szRouteStr) + 1);

            if ( !lstrlen(szRouteStr) ) {

                /*
                 * Error: Index past end of route multi-string.
                 */
                LocalFree(szRoute);
                Status = ERROR_DEV_NOT_EXIST;
                goto Error;
            }
        }

        /*
         * Isolate the service string representing the lowest binding
         * in the route and convert it to its display name.
         */
        *(p = (szRouteStr + lstrlen(szRouteStr) - 1)) = TEXT('\0');
        for ( ; *p != TEXT('\"'); p-- );
        p++;
        if ( (Status = RegGetNetworkServiceName( hServer, p, szDeviceName, nDeviceName ))
             != ERROR_SUCCESS ) {
            LocalFree(szRoute);
            goto Error;
        }

        /*
         * Clean up and return.
         */
        LocalFree(szRoute);
        return Status;

    }
    else {

        /*
         * NetBIOS LANA #: see which LanaMap entry corresponds to the specified
         * Lan Adapter.
         */
        if ( (Status = RegOpenKeyEx( hkey_local_machine, REGISTRY_NETBLINKAGE, 0,
                                     KEY_READ, &Handle ))
             != ERROR_SUCCESS )
            goto Error;

        /*
         * Alloc and read the LanaMap
         */
        if ( ((Status = RegQueryValueEx( Handle, REGISTRY_NETBLINKAGE_LANAMAP,
                                         NULL, &Type,
                                         NULL, &ValueSize))
              != ERROR_SUCCESS) || (Type != REG_BINARY) ) {
            RegCloseKey(Handle);
            goto Error;
        }

        if ( !(pLanaMap = (PLANAMAP)LocalAlloc(LPTR, ValueSize)) ) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        if ( (Status = RegQueryValueEx( Handle, REGISTRY_NETBLINKAGE_LANAMAP,
                                        NULL, &Type,
                                        (LPBYTE)pLanaMap, &ValueSize))
             != ERROR_SUCCESS ) {
            LocalFree(pLanaMap);
            RegCloseKey(Handle);
            goto Error;
        }

        /*
         * Loop through LanaMap to check for match with the specified Lan
         * Adapter #.
         */
        for ( pLana = pLanaMap, i = 0;
            i < (int)(ValueSize / sizeof(LANAMAP));
            i++, pLana++ ) {

            if ( pLana->lana == (BYTE)(pPdParams->Network.LanAdapter) ) {

                TCHAR szHighestBinding[256], szLowestBinding[256];

                LocalFree(pLanaMap);

                /*
                 * Match found.  Alloc and fetch the Route multi-string
                 */
                if ( ((Status = RegQueryValueEx( Handle,
                                                 REGISTRY_ROUTE,
                                                 NULL, &Type,
                                                 NULL, &ValueSize))
                      != ERROR_SUCCESS) || (Type != REG_MULTI_SZ) ) {
                    RegCloseKey(Handle);
                    goto Error;
                }

                if ( !(szRoute = (LPTSTR)LocalAlloc(LPTR, ValueSize)) ) {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto Error;
                }

                if ( (Status = RegQueryValueEx( Handle,
                                                REGISTRY_ROUTE,
                                                NULL, &Type,
                                                (LPBYTE)szRoute, &ValueSize))
                     != ERROR_SUCCESS ) {
                    LocalFree(szRoute);
                    RegCloseKey(Handle);
                    goto Error;
                }

                /*
                 * Free the registry key handle and make a local copy of the
                 * 'i'th multi string, which is the binding route for this lana.
                 */
                RegCloseKey(Handle);
                for ( szRouteStr = szRoute; i > 0; i-- )
                    szRouteStr += (lstrlen(szRouteStr) + 1);
                lstrncpy(szDeviceName, szRouteStr, nDeviceName);
                szDeviceName[nDeviceName-1] = TEXT('\0');
                LocalFree(szRoute);

                /*
                 * Isolate the service string representing the highest binding
                 * in the route and convert it to its display name.
                 */
                szRouteStr = szDeviceName + 1;     // skip first "
                for ( p = szRouteStr; *p && *p != TEXT('\"'); p++ );
                if ( !(*p) )
                    goto Error;
                *p = TEXT('\0');
                if ( (Status = RegGetNetworkServiceName(
                                                       hServer,
                                                       szRouteStr,
                                                       szHighestBinding,
                                                       sizeof(szHighestBinding)/sizeof(TCHAR) ))
                     != ERROR_SUCCESS )
                    goto Error;

                /*
                 * Isolate the service string representing the lowest binding
                 * in the route and convert it to its display name.
                 */
                if ( !(*(szRouteStr = p+1)) ) {

                    *szLowestBinding = TEXT('\0');

                }
                else {

                    *(p = (szRouteStr + lstrlen(szRouteStr) - 1)) = TEXT('\0');
                    for ( ; *p != TEXT('\"'); p-- );
                    p++;
                    if ( (Status = RegGetNetworkServiceName(
                                                           hServer,
                                                           p,
                                                           szLowestBinding,
                                                           sizeof(szLowestBinding)/sizeof(TCHAR) ))
                         != ERROR_SUCCESS )
                        goto Error;
                }

                /*
                 * Build the complete name string.
                 */
                _snwprintf( szDeviceName, nDeviceName, TEXT("%s => %s"),
                            szHighestBinding, szLowestBinding );

                /*
                 * Return.
                 */
                return ERROR_SUCCESS;
            }
        }

        /*
         * No match found.
         */
        LocalFree(pLanaMap);
        RegCloseKey(Handle);
        goto Error;
    }

    /*==============================================================================
     * Error returns
     *============================================================================*/
    Error:
    {
        TCHAR sz1[256], sz2[1024];
        int length;

        length = LoadString( GetModuleHandle( UTILDLL_NAME ),
                             (pPdConfig->Data.PdFlag & PD_LANA) ?
                             IDP_ERROR_REGLANA :
                             IDP_ERROR_REGNETCARD,
                             sz1, 256 );

        wsprintf( sz2, sz1, pPdParams->Network.LanAdapter, Status );
        lstrncpy(szDeviceName, sz2, nDeviceName);
        szDeviceName[nDeviceName-1] = TEXT('\0');
    }
    return Status;

}  // end RegGetNetworkDeviceName


/*******************************************************************************
 *
 *  RegGetNetworkServiceName - Hydrix helper function
 *
 *      Obtain the display name associated with a given network service name.
 *      If the service is a reference to a physical network card, will return
 *      the title of the card as obtained from the LOCAL_MACHINE\Software\
 *      Microsoft\Windows NT\NetworkCards registry.
 *
 *  ENTRY:
 *      hServer (input)
 *          Handle of the Hydrix Server
 *      szServiceKey (input)
 *          Key string into the LOCAL_MACHINE\System\CurrentControlSet\Services
 *          registry.
 *      szServiceName (output)
 *          Points to buffer to return the service's display name.
 *      nServiceName (input)
 *          Specifies the maxmum number of characters that can be stored in
 *          szServiceName.
 *
 *  EXIT:
 *      ERROR_SUCCESS if a service name was sucessfully found and returned;
 *      error code otherwise.
 *
 *      NOTE: If the service name is for an entry in the NetworkCards resistry
 *            and the entry is flagged as 'hidden', the service name will be
 *            blank.  This will flag caller's logic to ignore the entry.
 *
 ******************************************************************************/

LONG WINAPI
RegGetNetworkServiceName( HANDLE hServer,
                          LPTSTR szServiceKey,
                          LPTSTR szServiceName,
                          int nServiceName )
{
    LONG Status;
    DWORD ValueSize, Type, dwValue;
    TCHAR szKey[256];
    LPTSTR szTemp;
    HKEY Handle;
    HKEY hkey_local_machine;

    if (hServer == NULL)
        hkey_local_machine = HKEY_LOCAL_MACHINE;
    else
        hkey_local_machine = hServer;

    lstrnprintf( szKey, sizeof(szKey)/sizeof(TCHAR),
                 TEXT("%s\\%s"), REGISTRY_SERVICES, szServiceKey );

    if ( (Status = RegOpenKeyEx( hkey_local_machine,
                                 szKey, 0,
                                 KEY_READ, &Handle ))
         != ERROR_SUCCESS )
        return(Status);

    /*
     * Alloc and read in the service's DisplayName value (if there).
     */
    if ( ((Status = RegQueryValueEx( Handle, REGISTRY_DISPLAY_NAME,
                                     NULL, &Type,
                                     NULL, &ValueSize ))
          != ERROR_SUCCESS) || (Type != REG_SZ) ) {

        HKEY Subkey;
        FILETIME KeyTime;
        DWORD i;

        /*
         * The service doesn't have a DisplayName associated with it (it's a
         * Network Card's service name).  Traverse the NetworkCards registry
         * entries and find the entry associated with this service name
         * (if it exists).
         */
        RegCloseKey(Handle);
        if ( (Status = RegOpenKeyEx( hkey_local_machine,
                                     REGISTRY_NETCARDS, 0,
                                     KEY_READ, &Handle ))
             != ERROR_SUCCESS )
            return(Status);

        for ( i = 0, ValueSize = sizeof(szKey)/sizeof(TCHAR) ;
            RegEnumKeyEx( Handle, i, szKey, &ValueSize,
                          NULL, NULL, NULL, &KeyTime ) == ERROR_SUCCESS ;
            i++, ValueSize = sizeof(szKey)/sizeof(TCHAR) ) {

            /*
             * Open the Network Card's registry.
             */
            if ( (Status = RegOpenKeyEx( Handle,
                                         szKey, 0,
                                         KEY_READ, &Subkey ))
                 != ERROR_SUCCESS ) {
                RegCloseKey(Handle);
                return(Status);
            }

            /*
             * Alloc and fetch the card's service name.  Continue net card
             * enumeration if service name not found.
             */
            if ( ((Status = RegQueryValueEx( Subkey,
                                             REGISTRY_SERVICE_NAME,
                                             NULL, &Type,
                                             NULL, &ValueSize))
                  != ERROR_SUCCESS) || (Type != REG_SZ) ) {
                RegCloseKey(Subkey);
                continue;
            }

            szTemp = (LPTSTR)LocalAlloc(LPTR, ValueSize);
            if(NULL == szTemp)
            {
                RegCloseKey(Subkey);
                RegCloseKey(Handle);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            if ( (Status = RegQueryValueEx( Subkey,
                                            REGISTRY_SERVICE_NAME,
                                            NULL, &Type,
                                            (LPBYTE)szTemp, &ValueSize))
                 != ERROR_SUCCESS ) {
                LocalFree(szTemp);
                RegCloseKey(Subkey);
                continue;
            }

            /*
             * If the current Network Card's service name matches the service
             * name that we're looking for, fetch the card's title.
             */
            if ( !lstrcmpi(szServiceKey, szTemp) ) {

                LocalFree(szTemp);

                ValueSize = sizeof(dwValue);
                if ( (RegQueryValueEx( Subkey, REGISTRY_HIDDEN,
                                       NULL, &Type,
                                       (LPBYTE)&dwValue, &ValueSize )
                      == ERROR_SUCCESS) &&
                     (Type == REG_DWORD) &&
                     (dwValue == 1) ) {

                    /*
                     * Entry is hidden: return empty title.
                     */
                    *szServiceName = TEXT('\0');

                }
                else {

                    /*
                     * Entry is not hidden: Alloc for the card's title.
                     */
                    if ( ((Status = RegQueryValueEx( Subkey,
                                                     REGISTRY_TITLE,
                                                     NULL, &Type,
                                                     NULL, &ValueSize))
                          != ERROR_SUCCESS) || (Type != REG_SZ) ) {
                        RegCloseKey(Subkey);
                        RegCloseKey(Handle);
                        return(Status);
                    }
                    szTemp = (LPTSTR)LocalAlloc(LPTR, ValueSize);
                    if(NULL == szTemp)
                    {
                        RegCloseKey(Subkey);
                        RegCloseKey(Handle);
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    /*
                     * Fetch the title.
                     */
                    if ( (Status = RegQueryValueEx( Subkey,
                                                    REGISTRY_TITLE,
                                                    NULL, &Type,
                                                    (LPBYTE)szTemp, &ValueSize))
                         != ERROR_SUCCESS ) {
                        LocalFree(szTemp);
                        RegCloseKey(Subkey);
                        RegCloseKey(Handle);
                        return(Status);
                    }

                    /*
                     * Copy the card's title.
                     */
                    lstrncpy(szServiceName, szTemp, nServiceName);
                    szServiceName[nServiceName-1] = TEXT('\0');
                    LocalFree(szTemp);
                }

                /*
                 * Clean up and return success.
                 */
                RegCloseKey(Subkey);
                RegCloseKey(Handle);
                return(ERROR_SUCCESS);

            }
            else {

                /*
                 * This is not the Network Card that we're looking for.  Close
                 * it's registry key, free the service name buffer, and continue
                 * enumeration loop.
                 */
                LocalFree(szTemp);
                RegCloseKey(Subkey);
            }
        }

        /*
         * Network Card not found with service name matching the one supplied.
         * Close NetworkCards registry key and return failure,
         */
        RegCloseKey(Handle);
        return(ERROR_DEV_NOT_EXIST);

    }
    else {

        szTemp = (LPTSTR)LocalAlloc(LPTR, ValueSize);
        if(NULL == szTemp)
        {
            RegCloseKey(Handle);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if ( ((Status = RegQueryValueEx( Handle, REGISTRY_DISPLAY_NAME,
                                         NULL, &Type,
                                         (LPBYTE)szTemp, &ValueSize ))
              == ERROR_SUCCESS) )
            lstrncpy(szServiceName, szTemp, nServiceName);
        szServiceName[nServiceName-1] = TEXT('\0');

        LocalFree(szTemp);
        RegCloseKey(Handle);
        return(Status);
    }

}  // end RegGetNetworkServiceName


/*******************************************************************************
 *
 *  AsyncDeviceEnumerate - Hydrix helper function
 *
 *   Returns a list of async device names.  This will return both 'COM' devices
 *   and TAPI configured modems.
 *
 * ENTRY:
 *    pPdConfig (input)
 *       Points to PDCONFIG3 structure of the PD.
 *    pEntries (output)
 *       When the function finishes successfully, the variable pointed to
 *       by the pEntries parameter contains the number of entries actually
 *       returned.
 *    pPdParams (output)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of PDPARAMS structures.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pPdParams parameter. If the buffer is too small to receive all the
 *       entries, on output this variable is set to 0 (caller should double
 *       the input buffer and try again).
 *    bInSetup (input)
 *          TRUE if we're operating in Setup; FALSE otherwise.
 * EXIT:
 *      TRUE: enumeration was sucessful; FALSE otherwise.
 *
 *      The error code can be retrieved via GetLastError(), and are the
 *      following possible values:
 *          ERROR_NOT_ENOUGH_MEMORY
 *              not enough memory to allocate working buffer(s)
 *          ERROR_INSUFFICIENT_BUFFER
 *              enumeration failed because of an insufficient pPdParams
 *              buffer size to contain all devices
 *          ERROR_DEV_NOT_EXIST
 *              the QueryDosDevice call failed.  This error code can be
 *              interpreted as 'no async devices are configured' for reporting
 *              purposes.
 *
 ******************************************************************************/

#define MAX_QUERY_BUFFER    (1024*16)

BOOL WINAPI
AsyncDeviceEnumerate( PPDCONFIG3 pPdConfig,
                      PULONG pEntries,
                      PPDPARAMS pPdParams,
                      PULONG pByteCount,
                      BOOL bInSetup )
{
    DWORD    Error = ERROR_SUCCESS;
    ULONG    Count;
    HKEY     hRoot = NULL;
    DWORD    BufSize, NameSize, Type, Index, SaveBufSize, SaveNameSize;
    LONG     Result = 0;
    LONG     nDosDevice = 0;
    LPTSTR   pBuffer = NULL, pBufferEnd = NULL;
    LPTSTR   pNameBuffer = NULL, pName;
    BOOLEAN  bRetVal = FALSE;

    /*
     *  Get maximum number of names that can be returned
     */
    Count = *pByteCount / sizeof(PDPARAMS);
    *pByteCount = 0;
    *pEntries = 0;

    /*
     *  Allocate buffer
     */
    SaveBufSize  = MAX_QUERY_BUFFER;
    SaveNameSize = MAX_QUERY_BUFFER;

    BufSize  = SaveBufSize;
    NameSize = SaveNameSize;

    if ( !(pBuffer = (LPTSTR)LocalAlloc(LPTR, BufSize * sizeof(TCHAR))) ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if ( !(pNameBuffer = (LPTSTR)LocalAlloc(LPTR, NameSize)) ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    /*
     * If we're in Setup, obtain devices from the SERIALCOMM section in
     * LOCAL MACHINE registry, since the serial device driver(s) are most
     * likely not running.  Otherwise, we'll query all DosDevices and
     * return those that are COM devices and are not currently in use.
     */
    if ( bInSetup ) {

        Result = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               TEXT("HARDWARE\\DEVICEMAP\\SERIALCOMM"),
                               0,    // Reserved
                               KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,
                               &hRoot );

        if ( Result != ERROR_SUCCESS ) {

            //
            // This is usually the result of having no ports, so the key
            // SERIALCOMM does not exist.
            //
            goto Cleanup;
        }

        for ( Index=0; ; Index++ ) {

            // Each enumerate stomps on our buffer sizes
            BufSize  = SaveBufSize;
            NameSize = SaveNameSize;

            Result = RegEnumValue( hRoot,
                                   Index,
                                   pBuffer,
                                   &BufSize,
                                   NULL,    // Reserved
                                   &Type,
                                   (LPBYTE)pNameBuffer,
                                   &NameSize );

            if ( Result == ERROR_INSUFFICIENT_BUFFER ) {

                // Reallocate the buffer
                LocalFree( pBuffer );
                pBuffer = (LPTSTR)LocalAlloc(LPTR, BufSize * sizeof(TCHAR));
                if ( pBuffer == NULL ) {
                    // Try and reallocate next key
                    SaveBufSize = BufSize = 0;
                    continue;
                }
                else {
                    SaveBufSize = BufSize;
                }

                // Reallocate the name buffer
                LocalFree( pNameBuffer );
                pNameBuffer = (LPTSTR)LocalAlloc(LPTR, NameSize);
                if ( pNameBuffer == NULL ) {
                    // Try and reallocate next key
                    SaveNameSize = NameSize = 0;
                    continue;
                }
                else {
                    SaveNameSize = NameSize;
                }

                Result = RegEnumValue( hRoot,
                                       Index,
                                       pBuffer,
                                       &BufSize,
                                       NULL,    // Reserved
                                       &Type,
                                       (LPBYTE)pNameBuffer,
                                       &NameSize );
            }

            // We are done
            if ( Result == ERROR_NO_MORE_ITEMS ) {
                bRetVal = TRUE;
                Result = 0;
                goto Cleanup;
            }

            if ( Result != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            if ( Count > 0 ) {

                if ( Type != REG_SZ ) {
                    continue;
                }

                pPdParams->SdClass = SdAsync;
                lstrcpy( pPdParams->Async.DeviceName, pNameBuffer );
                pPdParams++;
                Count--;
                (*pEntries)++;

            }
            else {

                Error = ERROR_INSUFFICIENT_BUFFER;
                goto Cleanup;
            }
        }

    }
    else {    // not in Setup

        /*
         *  Get complete device list
         */
        nDosDevice = QueryDosDevice( NULL, pBuffer, MAX_QUERY_BUFFER );
        if ( !nDosDevice)
        {
            Error = ERROR_DEV_NOT_EXIST;
            goto Cleanup;
        }

        /*
         *  Find each device name in list
         */
        pName = pBuffer;
        pBufferEnd = pBuffer + nDosDevice;
        while ( *pName && (pName < pBufferEnd) )  {
            if ( CheckForComDevice( pName ) ) {
                if ( Count > 0 ) {
                    pPdParams->SdClass = SdAsync;
                    lstrcpy( pPdParams->Async.DeviceName, pName );
                    pPdParams++;
                    Count--;
                    (*pEntries)++;
                }
                else {

                    Error = ERROR_INSUFFICIENT_BUFFER;
                    goto Cleanup;
                }
            }
            pName += (lstrlen(pName) + 1);
        }

        bRetVal = TRUE;     // sucessful enumeration
    }

    Cleanup:
    /*
     * If no errors yet, perform TAPI device enumeration.
     */
    if ( bRetVal ) {

        if ( (Error = EnumerateTapiPorts( pPdParams,
                                          Count,
                                          &pEntries ))
             != ERROR_SUCCESS ) {

            bRetVal = FALSE;
        }
    }

    if ( pBuffer ) {
        LocalFree( pBuffer );
    }

    if ( pNameBuffer ) {
        LocalFree( pNameBuffer );
    }

    if ( hRoot ) {
        CloseHandle( hRoot );
    }
    SetLastError(Error);
    return(bRetVal);

}  // AsyncDeviceEnumerate


/*******************************************************************************
 *
 *  NetBIOSDeviceEnumerate - Hydrix helper function
 *
 *   Returns a list of NetBIOS lana adapter numbers.
 *
 * ENTRY:
 *    pPdConfig (input)
 *       Points to PDCONFIG3 structure of the PD.
 *    pEntries (output)
 *       When the function finishes successfully, the variable pointed to
 *       by the pEntries parameter contains the number of entries actually
 *       returned.
 *    pPdParams (output)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of PDPARAMS structures.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pPdParams parameter. If the buffer is too small to receive all the
 *       entries, on output this variable receives the required size of the
 *       buffer.
 *    bInSetup (input)
 *          TRUE if we're operating in Setup; FALSE otherwise.
 *
 * EXIT:
 *      TRUE: enumeration was sucessful; FALSE otherwise.
 *
 *      The error code can be retrieved via GetLastError(), and are the
 *      following possible values:
 *        v  ERROR_INSUFFICIENT_BUFFER
 *              enumeration failed because of an insufficient pPdParams
 *              buffer size to contain all devices
 *          ERROR_DEV_NOT_EXIST
 *              the NetBiosLanaEnum call failed.  This error code can be
 *              interpreted as 'no netbios devices are configured' for reporting
 *              purposes.
 *
 ******************************************************************************/

BOOL WINAPI
NetBIOSDeviceEnumerate( PPDCONFIG3 pPdConfig,
                        PULONG pEntries,
                        PPDPARAMS pPdParams,
                        PULONG pByteCount,
                        BOOL bInSetup )
{
    LANA_ENUM LanaEnum;
    NTSTATUS Status;
    int i;

    /*
     *  Issue netbios enum command
     */
    if ( Status = NetBiosLanaEnum( &LanaEnum ) ) {
        SetLastError(ERROR_DEV_NOT_EXIST);
        return(FALSE);
    }

    /*
     *  Make sure user's buffer is big enough
     */
    if ( LanaEnum.length > (*pByteCount / sizeof(PDPARAMS)) ) {

        *pByteCount = LanaEnum.length * sizeof(PDPARAMS);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    }

    /*
     *  Return number of entries
     */
    *pEntries = (ULONG) LanaEnum.length;

    /*
     *  Return lana numbers
     */
    for ( i=0; i < (int)LanaEnum.length; i++, pPdParams++ ) {
        pPdParams->SdClass = SdNetwork;
        pPdParams->Network.LanAdapter = LanaEnum.lana[i];
    }

    return(TRUE);

}  // NetBIOSDeviceEnumerate


/*******************************************************************************
 *
 *  FormDecoratedAsyncDeviceName - Hydrix helper function
 *
 *   Format a decorated async device name if a modem is defined.
 *
 * ENTRY:
 *    pDeviceName (output)
 *       Points to buffer that will contain the decorated name (or undecorated
 *       name if no modem).
 *    pPdParams (input)
 *       Points to the ASYNCCONFIG structure to be used in forming the
 *       decorated name.
 *
 * EXIT:
 *
 ******************************************************************************/

void WINAPI
FormDecoratedAsyncDeviceName( LPTSTR pDeviceName,
                              PASYNCCONFIG pAsyncConfig )
{
    if ( *(pAsyncConfig->ModemName) )
        wsprintf( pDeviceName, TEXT("%s - %s"),
                  pAsyncConfig->DeviceName,
                  pAsyncConfig->ModemName );
    else
        lstrcpy( pDeviceName,
                 pAsyncConfig->DeviceName );

}  // end FormDecoratedAsyncDeviceName


/*******************************************************************************
 *
 *  ParseDecoratedAsyncDeviceName - Hydrix helper function
 *
 *   Given a decorated async device name, form it's component device and
 *   modem name portions.
 *
 * ENTRY:
 *    pDeviceName (input)
 *       Points to buffer that contain the decorated async device name.
 *    pAsyncConfig (output)
 *       Points to the ASYNCCONFIG structure to save the device (in
 *       ->DeviceName) and modem (in ->ModemName).
 * EXIT:
 *
 ******************************************************************************/

void WINAPI
ParseDecoratedAsyncDeviceName( LPCTSTR pDeviceName,
                               PASYNCCONFIG pAsyncConfig )
{
    int i;

    /*
     * Form DeviceName portion up to the first blank.
     */
    for ( i=0; *pDeviceName && (*pDeviceName != TEXT(' ')); i++ )
        (pAsyncConfig->DeviceName)[i] = *pDeviceName++;
    (pAsyncConfig->DeviceName)[i] = TEXT('\0');

    /*
     * Skip the ' - ' decoration (to the next space).
     */
    if ( *pDeviceName ) {
        for ( pDeviceName++;
            *pDeviceName && (*pDeviceName != TEXT(' '));
            pDeviceName++ );
    }

    /*
     * Form the ModemName from the remainder of the string.
     */
    i = 0;
    if ( *pDeviceName ) {

        for ( pDeviceName++; *pDeviceName ; i++ )
            (pAsyncConfig->ModemName)[i] = *pDeviceName++;
    }
    (pAsyncConfig->ModemName)[i] = TEXT('\0');

}  // end ParseDecoratedAsyncDeviceName


/*******************************************************************************
 *
 *  SetupAsyncCdConfig - Hydrix helper function
 *
 *   Given a properly configured ASYNCCONFIG structure, set up a given
 *   CDCONFIG structure.
 *
 * ENTRY:
 *    pAsyncConfig (input)
 *       Points properly configured ASYNCCONFIG structure.
 *    pCdConfig (output)
 *       Points to the CDCONFIG structure to setup.
 * EXIT:
 *
 ******************************************************************************/

void WINAPI
SetupAsyncCdConfig( PASYNCCONFIG pAsyncConfig,
                    PCDCONFIG pCdConfig )
{
    memset(pCdConfig, 0, sizeof(CDCONFIG));

    if ( *(pAsyncConfig->ModemName) ) {

        pCdConfig->CdClass = CdModem;
        lstrcpy( pCdConfig->CdName, TEXT("cdmodem") );
        lstrcpy( pCdConfig->CdDLL, TEXT("cdmodem.dll") );
    }

}  // end SetupAsyncCdConfig


/*******************************************************************************
 *
 *  InstallModem - Hydrix helper function
 *
 *   Install UNIMODEM modem(s).
 *
 * ENTRY:
 *    hwndOwner
 *       Window handle that owns the installation dialog.
 * EXIT:
 *      TRUE: installation completed; FALSE: error or user canceled.
 *
 *      If an error, the error code can be retrieved via GetLastError().
 *
 ******************************************************************************/

BOOL WINAPI
InstallModem( HWND hwndOwner )
{
    HDEVINFO hdi;
    BOOL bStatus = FALSE;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /*
     * Create a modem DeviceInfoSet
     */
    if ( (hdi = SetupDiCreateDeviceInfoList( (LPGUID)&GUID_DEVCLASS_MODEM,
                                             hwndOwner )) ) {

        SP_INSTALLWIZARD_DATA iwd;

        /*
         * Initialize the InstallWizardData
         */
        memset(&iwd, 0, sizeof(iwd));
        iwd.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        iwd.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
        iwd.hwndWizardDlg = hwndOwner;

        /*
         * Set the InstallWizardData as the ClassInstallParams
         */
        if ( SetupDiSetClassInstallParams( hdi,
                                           NULL,
                                           (PSP_CLASSINSTALL_HEADER)&iwd,
                                           sizeof(iwd)) ) {

            /*
             * Call the class installer to invoke the installation
             * wizard.
             */
            SetCursor(hcur);
            hcur = NULL;

            if ( SetupDiCallClassInstaller( DIF_INSTALLWIZARD,
                                            hdi,
                                            NULL) ) {

                /*
                 * Success.  The wizard was invoked and finished.
                 */
                SetupDiCallClassInstaller( DIF_DESTROYWIZARDDATA,
                                           hdi,
                                           NULL );
                bStatus = TRUE;
            }
        }

        /*
         * Clean up
         */
        SetupDiDestroyDeviceInfoList( hdi );
    }

    if (hcur)
        SetCursor(hcur);

    return(bStatus);

}  // end InstallModem


/*******************************************************************************
 *
 *  ConfigureModem - Hydrix helper function
 *
 *   Configure the specified UNIMODEM modem.
 *
 * ENTRY:
 *    pModemName
 *       Name of UNIMODEM modem to configure.
 *    hwndOwner
 *       Window handle that owns the configuration dialog.
 * EXIT:
 *      TRUE: configuration was sucessful; FALSE otherwise.
 *
 *      The error code can be retrieved via GetLastError().
 *
 ******************************************************************************/

BOOL WINAPI
ConfigureModem( LPCTSTR pModemName,
                HWND hwndOwner )
{
    BOOL bStatus = FALSE;
    COMMCONFIG ccDummy;
    COMMCONFIG * pcc;
    DWORD dwSize;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    ccDummy.dwProviderSubType = PST_MODEM;
    dwSize = sizeof(COMMCONFIG);
    GetDefaultCommConfig(pModemName, &ccDummy, &dwSize);

    pcc = (COMMCONFIG *)LocalAlloc(LPTR, (UINT)dwSize);
    if ( pcc ) {

        pcc->dwProviderSubType = PST_MODEM;
        if ( GetDefaultCommConfig(pModemName, pcc, &dwSize) ) {

            COMMCONFIG *pccOld = (COMMCONFIG *)LocalAlloc(LPTR, (UINT)dwSize);

            if ( pccOld ) {

                memcpy(pccOld, pcc, dwSize);
            }

            SetCursor(hcur);
            hcur = NULL;

            bStatus = TRUE;
            if ( CommConfigDialog(pModemName, hwndOwner, pcc) ) {

                if ( !SetDefaultCommConfig(pModemName, pcc, dwSize) )
                    bStatus = FALSE;
            }

            LocalFree((HLOCAL)pcc);
        }
    }
    else
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (hcur)
        SetCursor(hcur);

    return(bStatus);

}  // end ConfigureModem


///////////////////////////////////////////////////////////////////////////////
// Static Helper Functions

/***************************************************************************
 *
 *  InitServerLock
 *
 *  Since we do not require the user to call an initialize function,
 *  we must initialize our critical section in a thread safe manner.
 *
 *  The problem is, a critical section is needed to guard against multiple
 *  threads trying to init the critical section at the same time.
 *
 *  The solution that Nt uses, in which RtlInitializeCriticalSection itself
 *  uses, is to wait on a kernel supported process wide Mutant before proceding.
 *  This Mutant almost works by itself, but RtlInitializeCriticalSection does
 *  not wait on it until after trashing the semaphore count. So we wait on
 *  it ourselves, since it can be acquired recursively.
 *
 ***************************************************************************/

typedef struct SERVERVERSION {
    struct SERVERVERSION * pNext;
    char ServerNameA[MAX_BR_NAME+1];
    USHORT ServerVersion;
} SERVERVERSION, *PSERVERVERSION;

BOOLEAN G_fLockInited = FALSE;
PSERVERVERSION G_pServerList = NULL;
RTL_CRITICAL_SECTION G_ServerLock;

NTSTATUS
InitServerLock()
{
    NTSTATUS status = STATUS_SUCCESS;

    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    /*
     * Make sure another thread did not beat us here
     */
    if ( !G_fLockInited ) {
        status = RtlInitializeCriticalSection( &G_ServerLock );
        if (status == STATUS_SUCCESS) {
            G_fLockInited = TRUE;
        }
    }

    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    return status;
}

/*******************************************************************************
 *
 *  CheckForComDevice - local helper function
 *
 *  check if device name is a serial com device
 *
 * ENTRY:
 *    pName (input)
 *       device name
 *
 * EXIT:
 *    TRUE  - serial device
 *    FALSE - not a serial device
 *
 ******************************************************************************/

static BOOL
CheckForComDevice( LPTSTR pName )
{
    FILE_FS_DEVICE_INFORMATION DeviceInformation;
    IO_STATUS_BLOCK IoStatus;
    HANDLE Handle;
    DEVICENAME Name;
    NTSTATUS Status;

    if ( (lstrlen(pName) == 2 && pName[1] == TEXT(':')) ||
         !lstrcmpi(pName, TEXT("aux")) ||
         !lstrnicmp(pName, TEXT("lpt"), 3) ||
         !lstrnicmp(pName, TEXT("prn"), 3) ||
         !lstrnicmp(pName, TEXT("display"), 7) ||
         !lstrnicmp(pName, TEXT("$VDMLPT"), 7))
        return(FALSE);

    lstrcpy( Name, TEXT("\\\\.\\") );
    lstrcat( Name, pName );

    try
    {
        Handle = CreateFile( Name,
                             GENERIC_READ | GENERIC_WRITE,
                             0,     // exclusive access
                             NULL,      // no security attr
                             OPEN_EXISTING, // must exist
                             0,
                             NULL       // no template
                           );
    }
    __except (1)
    {
        if ( Handle != INVALID_HANDLE_VALUE )
        {
            CloseHandle( Handle );
            Handle = INVALID_HANDLE_VALUE;
        }
    }

    if ( Handle == INVALID_HANDLE_VALUE )
        return(FALSE);

    Status = NtQueryVolumeInformationFile( (HANDLE) Handle,
                                           &IoStatus,
                                           &DeviceInformation,
                                           sizeof(DeviceInformation),
                                           FileFsDeviceInformation );

    CloseHandle( Handle );

    if ( (Status != STATUS_SUCCESS) ||
         (DeviceInformation.DeviceType != FILE_DEVICE_SERIAL_PORT) )
        return(FALSE);

    return(TRUE);

}  // end CheckForComDevice


/*******************************************************************************
 *
 * NetBiosLanaEnum - local helper function
 *
 *  enumerate lana numbers
 *
 * ENTRY:
 *     pLanaEnum (input)
 *        pointer to receive LAN_ENUM structure
 * EXIT:
 *      NO_ERROR - succesful
 *
 ******************************************************************************/

typedef struct _LANA_MAP {
    BOOLEAN Enum;
    UCHAR Lana;
} LANA_MAP, *PLANA_MAP;

static int
NetBiosLanaEnum( LANA_ENUM * pLanaEnum )
{
    int ProviderCount;
    void * pProviderNames = NULL;
    PLANA_MAP pLanaMap = NULL;
    HKEY netbiosKey = NULL;
    ULONG providerListLength;
    ULONG lanaMapLength;
    ULONG type;
    int i;
    LPTSTR currentProviderName;
    int rc;

    //
    // Read the registry for information on all Netbios providers,
    // including Lana numbers, protocol numbers, and provider device
    // names.  First, open the Netbios key in the registry.
    //

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGISTRY_NETBLINKAGE, 0,
                       MAXIMUM_ALLOWED, &netbiosKey );
    if ( rc != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Determine the size of the provider names.  We need this so
    // that we can allocate enough memory to hold it.
    //

    providerListLength = 0;

    rc = RegQueryValueEx(
                        netbiosKey,
                        TEXT("Bind"),
                        NULL,
                        &type,
                        NULL,
                        &providerListLength
                        );
    if ( rc != ERROR_MORE_DATA && rc != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Allocate enough memory to hold the mapping.
    //
    if ( (pProviderNames = LocalAlloc(LPTR,providerListLength)) == NULL ) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Get the list of transports from the registry.
    //

    rc = RegQueryValueEx(
                        netbiosKey,
                        TEXT("Bind"),
                        NULL,
                        &type,
                        (PVOID)pProviderNames,
                        &providerListLength
                        );
    if ( rc != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Determine the size of the Lana map.  We need this so that we
    // can allocate enough memory to hold it.
    //

    providerListLength = 0;

    rc = RegQueryValueEx(
                        netbiosKey,
                        TEXT("LanaMap"),
                        NULL,
                        &type,
                        NULL,
                        &lanaMapLength
                        );
    if ( rc != ERROR_MORE_DATA && rc != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Allocate enough memory to hold the Lana map.
    //

    if ( (pLanaMap = LocalAlloc(LPTR,lanaMapLength)) == NULL ) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Get the list of transports from the registry.
    //

    rc = RegQueryValueEx(
                        netbiosKey,
                        TEXT("LanaMap"),
                        NULL,
                        &type,
                        (PVOID)pLanaMap,
                        &lanaMapLength
                        );
    if ( rc != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Determine the number of Netbios providers loaded on the system.
    //
    ProviderCount = (int) (lanaMapLength / sizeof(LANA_MAP));

    //
    // Fill in the lana array
    //
    pLanaEnum->length = 0;
    for ( currentProviderName = pProviderNames, i = 0;
        *currentProviderName != UNICODE_NULL && i < ProviderCount;
        currentProviderName += lstrlen( currentProviderName ) + 1, i++ ) {

        if ( pLanaMap[i].Enum &&
             lstrstr( currentProviderName, TEXT("Nbf_") ) ) {
            pLanaEnum->lana[ pLanaEnum->length++ ] = pLanaMap[i].Lana;
        }
    }

    error_exit:

    if ( netbiosKey != NULL )
        RegCloseKey( netbiosKey );

    if ( pProviderNames != NULL )
        LocalFree( pProviderNames );

    if ( pLanaMap != NULL )
        LocalFree( pLanaMap );

    return( rc );
}


//
// NOTE: Butchd 9-26-96
// all of this following TAPI-related code is from various
// \nt\private\net\ras\src\ui\setup\src\ files
//
/******************************************************************************
 *
 *  EnumerateTapiPorts - local helper function
 *
 *  Determine all TAPI configured modems.
 *
 *  ENTRY
 *      pPdParams (output)
 *          Points to array of PDPARAMS structures to save enumerated TAPI
 *          modems into.
 *      Count (input)
 *          Specifies number of entries in the pPdParams array.
 *      ppEntries (input/output)
 *          Points to pointer to variable containing the existing number of
 *          PDPARAMS entries already stored at addresses prior to pPdParams.
 *          The referenced variable will be incremented by the number of
 *          TAPI modems found and stored in the pPdParams array.
 *  EXIT
 *    Returns ERROR_SUCCESS if successful, error code if not.
 *
 *****************************************************************************/

DWORD
EnumerateTapiPorts( PPDPARAMS pPdParams,
                    ULONG Count,
                    ULONG **ppEntries )
{
    LINEINITIALIZEEXPARAMS params;
    LINEDEVCAPS            *linedevcaps ;
    LINEEXTENSIONID        extensionid ;
    HLINEAPP               TapiLine = (HLINEAPP)0;
    DWORD                  NegotiatedApiVersion ;
    DWORD                  NegotiatedExtVersion = 0;
    WORD                   i;
    DWORD                  lines = 0 ;
    BYTE                   buffer[1000] ;
    CHAR                   szregkey[512];
    WCHAR                  wszDeviceName[DEVICENAME_LENGTH+1];
    WCHAR                  wszModemName[DEVICENAME_LENGTH+1];
    CHAR                   szModemName[DEVICENAME_LENGTH+1];
    LONG                   lerr;
    DWORD                  Status = ERROR_TAPI_CONFIGURATION;
    DWORD                  dwApiVersion = HIGH_VERSION;
    BOOL                   fSuccess = FALSE;
    ULONG                  RASIsUsingPort = 0;
    HKEY                   CurKey, CurKey2;
    DWORD                  KeyCount=0, KeySize, CurSize, DataType;
    TCHAR                  szSubKey[255], CurRASDev[1024], szMainKey[255], *pCurRASDev;

    /*
     * Un-comment / edit the following line if time needed to allow newly
     * added modem to appear in TAPI's enumeration list.
     */
    //  Sleep(4000L);

    /*
     * Initialize TAPI.
     */
    memset(&params, 0, sizeof(params));
    params.dwTotalSize = sizeof(params);
    params.dwOptions   = LINEINITIALIZEEXOPTION_USEEVENT;
    if ( lerr = lineInitializeExA( &TapiLine,
                                   GetModuleHandle( UTILDLL_NAME ),
                                   (LINECALLBACK)DummyTapiCallback,
                                   NULL,
                                   &lines,
                                   &dwApiVersion,
                                   &params ) )
        goto error;

    /*
     * Get configured TAPI modems on all lines.
     */
    for ( i = 0; i < lines; i++ ) {

        if ( lineNegotiateAPIVersion( TapiLine, i,
                                      LOW_VERSION, HIGH_VERSION,
                                      &NegotiatedApiVersion,
                                      &extensionid ) ) {
            continue ;
        }

        memset( buffer, 0, sizeof(buffer) );

        linedevcaps = (LINEDEVCAPS *)buffer;
        linedevcaps->dwTotalSize = sizeof(buffer);

        /*
         * Get this line's dev caps (ANSI).
         */
        if ( lineGetDevCapsA( TapiLine, i,
                              NegotiatedApiVersion,
                              NegotiatedExtVersion,
                              linedevcaps ) ) {
            continue ;
        }

        /*
li         * Only process modems.
         */
        if ( linedevcaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM ) {

            /*
             * The linedevcaps stuff is in ASCII.
             */
            DWORD j;
            char *temp;

            /*
             * Convert all nulls in the device class string to non nulls.
             */
            for ( j = 0, temp = (char *)((BYTE *)linedevcaps+linedevcaps->dwDeviceClassesOffset);
                j < linedevcaps->dwDeviceClassesSize;
                j++, temp++ ) {

                if ( *temp == '\0' )
                    *temp = ' ';
            }

            /*
             * Select only those devices that have comm/datamodem as a
             * device class.
             */
            if ( strstr( (char*)((BYTE *)linedevcaps+linedevcaps->dwDeviceClassesOffset),
                         "comm/datamodem" ) == NULL ) {
                continue;
            }

            /*
             * Fetch modem name (line name).
             */
            strncpy( szModemName,
                     (char *)((BYTE *)linedevcaps+linedevcaps->dwLineNameOffset),
                     DEVICENAME_LENGTH );
            szModemName[DEVICENAME_LENGTH] = '\0';
            MultiByteToWideChar(CP_ACP, 0, szModemName, -1, wszModemName, DEVICENAME_LENGTH + 1);

            /*
             * The registry key name where the modem specific information is
             * stored is at dwDevSpecificOffset + 2 * DWORDS
             *
             * The device specifc string is not unicode so copy that as
             * an ansii string
             */
            strncpy( szregkey,
                     (char *)linedevcaps+linedevcaps->dwDevSpecificOffset+(2*sizeof(DWORD)),
                     linedevcaps->dwDevSpecificSize );
            szregkey[linedevcaps->dwDevSpecificSize] = '\0';

            if ( !GetAssociatedPortName( szregkey, wszDeviceName ) ) {

                goto error;
            }

            /*
             * If RAS is installed and is using the port configured with this
             * modem, we will return the modem, but the Parity field will be
             * set to 1, indicating that RAS is using the port.  This is done
             * so that WinCfg (or other caller) can filter out the raw port
             * (device name) as well as the TAPI modem from the list.
             */
            RASIsUsingPort = 0;
            //See if the RAS Key even exists
            if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\RAS\\TAPI DEVICES"), 0, KEY_ALL_ACCESS, &CurKey) == ERROR_SUCCESS) {

                KeySize = sizeof(szSubKey) / sizeof( TCHAR );
                KeyCount = 0;
                while (RegEnumKeyEx( CurKey,
                                     KeyCount++,
                                     szSubKey,
                                     &KeySize,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL
                                   ) != ERROR_NO_MORE_ITEMS) {

                    wcscpy(szMainKey,TEXT("SOFTWARE\\Microsoft\\RAS\\TAPI DEVICES"));
                    wcscat(szMainKey,TEXT("\\"));
                    wcscat(szMainKey,szSubKey);

                    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, szMainKey, 0, KEY_ALL_ACCESS, &CurKey2) == ERROR_SUCCESS) {
                        CurSize = sizeof(CurRASDev);
                        if (RegQueryValueEx(
                                           CurKey2,
                                           TEXT("Address"),
                                           NULL,
                                           &DataType,
                                           (LPBYTE)CurRASDev,
                                           &CurSize
                                           ) == ERROR_SUCCESS) {

                            for ( pCurRASDev = CurRASDev;
                                *pCurRASDev && !RASIsUsingPort; ) {

                                if ( lstrcmpi(pCurRASDev, wszDeviceName) == 0 )
                                    RASIsUsingPort = 1;
                                else
                                    pCurRASDev += (wcslen(pCurRASDev) + 1);
                            }
                        }
                        RegCloseKey(CurKey2);
                    }

                    KeySize = sizeof(szSubKey) / sizeof( TCHAR );
                }
                RegCloseKey(CurKey);
            }

            /*
             * Save DeviceName and ModemName to PDPARAMS
             * structure and bump counts.  Also, set the BaudRate
             * element to the TAPI line index so that the caller can
             * determine the most recently added line, and set the Parity
             * field to 0 if RAS is not using the line, 1 if RAS is
             * using the line (so caller can filter properly).
             */
            if ( Count > 0 ) {

                pPdParams->SdClass = SdAsync;
                lstrcpy( pPdParams->Async.DeviceName, wszDeviceName );
                lstrcpy( pPdParams->Async.ModemName, wszModemName );
                pPdParams->Async.BaudRate = (ULONG)i;
                pPdParams->Async.Parity = RASIsUsingPort;
                pPdParams++;
                Count--;
                (**ppEntries)++;

            }
            else {

                Status = ERROR_INSUFFICIENT_BUFFER;
                goto error;
            }
        }
    }
    Status = ERROR_SUCCESS;

    error:
    if ( TapiLine )
        lineShutdown(TapiLine);

    return( Status );

}  // end EnumerateTapiPorts


/******************************************************************************
 *
 *  DummyTapiCallback - local helper function
 *
 *  A dummy callback routine to satisfy TAPI initialization.
 *
 *  ENTRY
 *      (see TAPI lineInitialize documentation)
 *  EXIT
 *
 *****************************************************************************/

VOID CALLBACK
DummyTapiCallback (HANDLE context, DWORD msg, DWORD instance, DWORD param1, DWORD param2, DWORD param3)
{
}  // end DummyTapiCallback


/******************************************************************************
 *
 *  GetAssociatedPortName - local helper function
 *
 *  Determine the 'attached to' (port) for the given modem via it's device
 *  specific registry key (szKeyName).
 *
 *  ENTRY
 *      (see TAPI lineInitialize documentation)
 *  EXIT
 *
 *****************************************************************************/

#define VALNAME_ATTACHEDTO "AttachedTo"

BOOL
GetAssociatedPortName( char  *szKeyName,
                       WCHAR * wszPortName )
{
    HKEY   hKeyModem;
    DWORD  dwType;
    DWORD  cbValueBuf;
    char   szPortName[DEVICENAME_LENGTH+1];

    if ( RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                        szKeyName,
                        0,
                        KEY_READ,
                        &hKeyModem ) ) {

        return( FALSE );
    }

    cbValueBuf = sizeof( szPortName );
    if ( RegQueryValueExA( hKeyModem,
                           VALNAME_ATTACHEDTO,
                           NULL,
                           &dwType,
                           (LPBYTE)&szPortName,
                           &cbValueBuf ) ) {
        return ( FALSE );
    }

    RegCloseKey( hKeyModem );

    MultiByteToWideChar(CP_ACP, 0, szPortName, -1, wszPortName, DEVICENAME_LENGTH + 1);

    return( TRUE );

}  // end GetAssociatedPortName


/*
 * Defines and typedefs
 */
typedef struct _userlist {
    struct _userlist *pNext;
    WCHAR UserName[USERNAME_LENGTH+1];
} USERLIST, *PUSERLIST;

#define MAX_DOMAINANDNAME     ((DOMAIN_LENGTH+1+USERNAME_LENGTH+1)*sizeof(WCHAR))
#define MAX_BUFFER            (10*MAX_DOMAINANDNAME)

/*
 * Local variables
 */
WCHAR *s_pszCompareList = NULL;
WCHAR s_szServer[256];

/*
 * Local functions.
 */
WCHAR *_ctxCreateAnonymousUserCompareList();

/*******************************************************************************
 *
 *  InitializeAnonymousUserCompareList - helper routine
 *
 *    Creates a list of all local users who currently belong to the local
 *    Anonymous group on the specified server, and saves the server name.
 *
 * ENTRY:
 *    pszServer (input)
 *       Name of server to query users for.
 *
 ******************************************************************************/

void WINAPI
InitializeAnonymousUserCompareList( const WCHAR *pszServer )
{
    if ( s_pszCompareList )
        free( s_pszCompareList );

    wcscpy(s_szServer, pszServer);

    s_pszCompareList = _ctxCreateAnonymousUserCompareList();
}


/*******************************************************************************
 *
 *  HaveAnonymousUsersChanged - helper routine
 *
 *    Using the saved server name, fetch current list of local users that
 *    belong to the local Anonymous group and compare with saved list.
 *
 * ENTRY:
 * EXIT:
 *    On exit, the original compare list is freed and server name cleared.
 *
 ******************************************************************************/

BOOL WINAPI
HaveAnonymousUsersChanged()
{
    BOOL bChanged = FALSE;
    WCHAR *pszNewCompareList, *pszOldName, *pszNewName;

    if ( s_pszCompareList && *s_szServer ) {

        if ( pszNewCompareList = _ctxCreateAnonymousUserCompareList() ) {

            bChanged = TRUE;

            for ( pszOldName = s_pszCompareList, pszNewName = pszNewCompareList;
                (*pszOldName != L'\0') && (*pszNewName != L'\0'); ) {

                if ( wcscmp(pszOldName, pszNewName) )
                    break;
                pszOldName += (wcslen(pszOldName) + 1);
                pszNewName += (wcslen(pszNewName) + 1);
            }

            if ( (*pszOldName == L'\0') && (*pszNewName == L'\0') )
                bChanged = FALSE;

            free(pszNewCompareList);
        }
    }

    if ( s_pszCompareList )
        free( s_pszCompareList );

    s_pszCompareList = NULL;

    memset(s_szServer, 0, sizeof(s_szServer));

    return(bChanged);
}


/*******************************************************************************
 *
 *  _ctxCreateAnonymousUserCompareList - local routine
 *
 *    Routine to get local anonymous users and place in sorted string list.
 *
 * ENTRY:
 * EXIT:
 *      pszCompareList - Returns pointer to buffer containing sorted string
 *                       list of local anonymous users, double null terminated.
 *                       NULL if error.
 *
 ******************************************************************************/

WCHAR *
_ctxCreateAnonymousUserCompareList()
{
    DWORD                        EntriesRead, EntriesLeft, ResumeHandle = 0;
    NET_API_STATUS               rc;
    WCHAR                        DomainAndUsername[256], *pszCompareList = NULL;
    DWORD                        i, TotalCharacters = 0;
    LPWSTR                       p;
    PLOCALGROUP_MEMBERS_INFO_3   plgrmi3 = NULL;
    PUSERLIST                    pUserListBase = NULL, pNewUser;

    /*
     * Loop till all local anonymous users have been retrieved.
     */
    do {

        /*
         *  Get first batch
         */
        if ( (rc = NetLocalGroupGetMembers( s_szServer,
                                            PSZ_ANONYMOUS,
                                            3,
                                            (LPBYTE *)&plgrmi3,
                                            MAX_BUFFER,
                                            &EntriesRead,
                                            &EntriesLeft,
                                            (PDWORD_PTR)(&ResumeHandle) )) &&
             (rc != ERROR_MORE_DATA ) ) {

            break;
        }

        /*
         *  Process first batch
         */
        for ( i = 0; i < EntriesRead; i++ ) {

            /*
             *  Get DOMAIN/USERNAME
             */
            wcscpy( DomainAndUsername, plgrmi3[i].lgrmi3_domainandname );

            /*
             *  Check that DOMAIN is actually LOCAL MACHINE NAME
             */
            if ( (p = wcsrchr( DomainAndUsername, L'\\' )) != NULL ) {

                /*
                 * Make sure that this user belongs to specified
                 * server.
                 */
                *p = L'\0';
                if ( _wcsicmp( DomainAndUsername, &s_szServer[2] ) ) {
                    continue;
                }
            }

            /*
             * Allocate list element and insert this username into list.
             */
            if ( (pNewUser = (PUSERLIST)malloc(sizeof(USERLIST))) == NULL ) {

                rc = ERROR_OUTOFMEMORY;
                break;
            }

            pNewUser->pNext = NULL;
            wcscpy(pNewUser->UserName, p+1);
            TotalCharacters += wcslen(p+1) + 1;

            if ( pUserListBase == NULL ) {

                /*
                 * First item in list.
                 */
                pUserListBase = pNewUser;

            }
            else {

                PUSERLIST pPrevUserList, pUserList;
                pPrevUserList = pUserList = pUserListBase;

                for ( ; ; ) {

                    if ( wcscmp(pNewUser->UserName, pUserList->UserName) < 0 ) {

                        if ( pPrevUserList == pUserListBase ) {

                            /*
                             * Insert at beginning of list.
                             */
                            pUserListBase = pNewUser;

                        }
                        else {

                            /*
                             * Insert into middle or beginning of list.
                             */
                            pPrevUserList->pNext = pNewUser;
                        }

                        /*
                         * Link to next.
                         */
                        pNewUser->pNext = pUserList;
                        break;

                    }
                    else if ( pUserList->pNext == NULL ) {

                        /*
                         * Add to end of list.
                         */
                        pUserList->pNext = pNewUser;
                        break;
                    }

                    pPrevUserList = pUserList;
                    pUserList = pUserList->pNext;
                }
            }
        }

        /*
         *  Free memory
         */
        if ( plgrmi3 != NULL ) {
            NetApiBufferFree( plgrmi3 );
        }

    } while ( rc == ERROR_MORE_DATA );

    /*
     * Allocate buffer for multi-string compare list if no error so far
     * and terminate in case of empty list.
     */
    if ( rc == ERROR_SUCCESS ) {

        pszCompareList = (WCHAR *)malloc( (++TotalCharacters) * 2 );

        if( pszCompareList != NULL )
        {
            *pszCompareList = L'\0';
        }
    }

    /*
     * Traverse and free username list, creating the multi-string compare
     * list if buffer is available (no error so far).
     */
    if ( pUserListBase ) {

        PUSERLIST pUserList = pUserListBase,
                              pNext = NULL;
        WCHAR *pBuffer = pszCompareList;

        do {

            pNext = pUserList->pNext;

            if ( pBuffer ) {

                wcscpy(pBuffer, pUserList->UserName);
                pBuffer += (wcslen(pBuffer) + 1);
                *pBuffer = L'\0';   // auto double-null terminate
            }

            free(pUserList);
            pUserList = pNext;

        } while ( pUserList );
    }

    return(pszCompareList);
}


/*******************************************************************************
 *
 *  GetUserFromSid - Hydrix helper function
 *
 *      Fetch the user name associated with the specified SID.
 *
 *  ENTRY:
 *      pSid (input)
 *          Points to SID to match to user name.
 *      pUserName (output)
 *          Points to buffer to place the user name into.
 *      cbUserName (input)
 *          Specifies the size in bytes of the user name buffer.  The returned
 *          user name will be truncated to fit this buffer (including NUL
 *          terminator) if necessary.
 *
 *  EXIT:
 *
 *      GetUserFromSid() will always return a user name.  If the specified
 *      SID fails to match to a user name, then the user name "(unknown)" will
 *      be returned.
 *
 ******************************************************************************/

void WINAPI
GetUserFromSid( PSID pSid,
                LPTSTR pUserName,
                DWORD cbUserName )
{
    TCHAR DomainBuffer[DOMAIN_LENGTH], UserBuffer[USERNAME_LENGTH];
    DWORD cbDomainBuffer=sizeof(DomainBuffer), cbUserBuffer=sizeof(UserBuffer),
                                                            Error;
    LPTSTR pDomainBuffer = NULL, pUserBuffer = NULL;
    SID_NAME_USE SidNameUse;

    /*
     * Fetch user name from SID: try user lookup with a reasonable Domain and
     * Sid buffer size first, before resorting to alloc.
     */
    if ( !LookupAccountSid( NULL, pSid,
                            UserBuffer, &cbUserBuffer,
                            DomainBuffer, &cbDomainBuffer, &SidNameUse ) ) {

        if ( ((Error = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) ) {

            if ( cbDomainBuffer > sizeof(DomainBuffer) ) {

                if ( !(pDomainBuffer =
                       (LPTSTR)LocalAlloc(
                                         LPTR, cbDomainBuffer * sizeof(TCHAR))) ) {

                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto BadDomainAlloc;
                }
            }

            if ( cbUserBuffer > sizeof(UserBuffer) ) {

                if ( !(pUserBuffer =
                       (LPTSTR)LocalAlloc(
                                         LPTR, cbUserBuffer * sizeof(TCHAR))) ) {

                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto BadUserAlloc;
                }
            }

            if ( !LookupAccountSid( NULL, pSid,
                                    pUserBuffer ?
                                    pUserBuffer : UserBuffer,
                                    &cbUserBuffer,
                                    pDomainBuffer ?
                                    pDomainBuffer : DomainBuffer,
                                    &cbDomainBuffer,
                                    &SidNameUse ) ) {

                Error = GetLastError();
                goto BadLookup;
            }

        }
        else {

            goto BadLookup;
        }
    }

    /*
     * Copy the user name into the specified buffer, truncating if necessary,
     * and make lower case.
     */
    lstrncpy( pUserName, pUserBuffer ? pUserBuffer : UserBuffer,
              cbUserName - 1 );
    pUserName[cbUserName-1] = TEXT('\0');
    lstrlwr(pUserName);

    /*
     * Free our local allocs (if any) and return.
     */
    if ( pDomainBuffer )
        LocalFree(pDomainBuffer);
    if ( pUserBuffer )
        LocalFree(pUserBuffer);
    return;

    /*--------------------------------------
     * Error clean-up and return...
     */
    BadLookup:
    BadUserAlloc:
    BadDomainAlloc:
    if ( pDomainBuffer )
        LocalFree(pDomainBuffer);
    if ( pUserBuffer )
        LocalFree(pUserBuffer);
    LoadString( GetModuleHandle( UTILDLL_NAME ),
                IDS_UNKNOWN, pUserName, cbUserName - 1 );
    pUserName[cbUserName-1] = TEXT('\0');
    return;

}  // end GetUserFromSid


/*******************************************************************************
 *
 *  CachedGetUserFromSid - Hydrix helper function
 *
 *      Provides entry point for a direct call to the UTILSUB.LIB
 *      GetUserNameFromSid, which performs its own caching of usernames.
 *
 *  ENTRY:
 *      See UTILSUB.LIB GetUserNameFromSid (procutil.c)
 *  EXIT:
 *      See UTILSUB.LIB GetUserNameFromSid (procutil.c)
 *
 ******************************************************************************/

void WINAPI
CachedGetUserFromSid( PSID pSid,
                      PWCHAR pUserName,
                      PULONG pcbUserName )
{
    GetUserNameFromSid( pSid, pUserName, pcbUserName );

}  // end CachedGetUserFromSid

/*****************************************************************************
 *
 *  TestUserForAdmin - Hydrix helper function
 *
 *   Returns whether the current thread is running under admin
 *   security.
 *
 * ENTRY:
 *   dom (input)
 *     TRUE/FALSE - whether we want DOMAIN admin (as compared to local admin)
 *
 * EXIT:
 *   TRUE/FALSE - whether user is specified admin
 *
 ****************************************************************************/

BOOL WINAPI
TestUserForAdmin( BOOL dom )
{
    BOOL IsMember, IsAnAdmin;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    PSID AdminSid;


    if (RtlAllocateAndInitializeSid(
                                     &SystemSidAuthority,
                                     2,
                                     SECURITY_BUILTIN_DOMAIN_RID,
                                     DOMAIN_ALIAS_RID_ADMINS,
                                     0, 0, 0, 0, 0, 0,
                                     &AdminSid
                                     ) != STATUS_SUCCESS)
    {
        IsAnAdmin = FALSE;
    }
    else
    {
        if (!CheckTokenMembership(  NULL,
                                    AdminSid,
                                    &IsMember))
        {
            RtlFreeSid(AdminSid);
            IsAnAdmin = FALSE;
        }
        else
        {
            RtlFreeSid(AdminSid);
            IsAnAdmin = IsMember;
        }
    }

    return IsAnAdmin;

//    UNUSED dom;

} // end of TestUserForAdmin


/*****************************************************************************
 *
 *  IsPartOfDomain - Hydrix helper function
 *
 *   Returns whether the current server participates in a domain.
 *
 * ENTRY:
 *
 * EXIT:
 *   TRUE or FALSE
 *
 ****************************************************************************/

BOOL WINAPI
IsPartOfDomain(VOID)
{
    NTSTATUS Status;
    LSA_HANDLE PolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo;
    OBJECT_ATTRIBUTES ObjAttributes;
    BOOL IsDomainName = FALSE;

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes( &ObjAttributes, NULL, 0, NULL, NULL );

    Status = LsaOpenPolicy( NULL,
                            &ObjAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle );

    if ( !NT_SUCCESS(Status) )
        goto done;

    //
    // Get the name of the primary domain from LSA
    //
    Status = LsaQueryInformationPolicy( PolicyHandle,
                                        PolicyPrimaryDomainInformation,
                                        (PVOID *)&DomainInfo );

    (void) LsaClose( PolicyHandle );

    if ( !NT_SUCCESS(Status) )
        goto done;

    if ( DomainInfo->DomainSid )
        IsDomainName = TRUE;

    (void) LsaFreeMemory( DomainInfo );

    done:
    return( IsDomainName );

}  // end IsPartOfDomain


/*******************************************************************************
 *
 *  StrSdClass - Hydrix helper function
 *
 *      Returns pointer to string representing the specified SdClass.
 *
 *  ENTRY:
 *      SdClass (input)
 *          The SDCLASS to associate with a string.
 *
 *  EXIT:
 *      (LPCTSTR) Points to string representing the SDCLASS.
 *
 ******************************************************************************/

LPTSTR SdClassStrings[9] = { NULL};

LPCTSTR WINAPI
StrSdClass( SDCLASS SdClass )
{
    TCHAR buffer[256];

    WORD wID = IDS_UNKNOWN_PROTOCOL;

    switch ( SdClass ) {

        case SdConsole:
            wID = IDS_CONSOLE;
            break;

        case SdNetwork:
            wID = IDS_NETWORK;
            break;

        case SdAsync:
            wID = IDS_ASYNC;
            break;

        case SdFrame:
            wID = IDS_FRAME;
            break;

        case SdReliable:
            wID = IDS_RELIABLE;
            break;

        case SdCompress:
            wID = IDS_COMPRESSION;
            break;

        case SdEncrypt:
            wID = IDS_ENCRYPTION;
            break;

        case SdTelnet:
            wID = IDS_TELNET;
            break;
    }

    // If we haven't loaded the string yet, do it now
    if (!SdClassStrings[wID - IDS_CONSOLE]) {
        LoadString(GetModuleHandle( UTILDLL_NAME ),
                   wID, buffer, lengthof(buffer) );
        SdClassStrings[wID - IDS_CONSOLE] = LocalAlloc(LPTR, 2*(wcslen(buffer)+1));
        if(NULL == SdClassStrings[wID - IDS_CONSOLE])
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
        lstrcpy(SdClassStrings[wID - IDS_CONSOLE], buffer);

    }

    return(SdClassStrings[wID]);

}  // end StrSdClass


/*******************************************************************************
 *
 *  StrConnectState - Hydrix helper function
 *
 *      Returns pointer to string representing the specified WinStation
 *      connection state.
 *
 *  ENTRY:
 *      ConnectState (input)
 *          The WinStation connect state to associate with a string.
 *      bShortString (input)
 *          If TRUE, returns a short(er) version of the string (if there is
 *          one); FALSE returns the full spelling.
 *
 *  EXIT:
 *      (LPCTSTR) Points to string representing the connect state.
 *
 *  Note: The short version of the string may be the same as the long version.
 *          (i.e. "active")  However, there are two string resources in case
 *          the long version of the string is not short in a language other
 *          than English.
 ******************************************************************************/

LPTSTR ConnectStateStrings[21] = { NULL};

LPCTSTR WINAPI
StrConnectState( WINSTATIONSTATECLASS ConnectState,
                 BOOL bShortString )
{
    TCHAR buffer[256];
    WORD wID = IDS_UNKNOWN;

    switch ( ConnectState ) {

        case State_Active:
            wID  = bShortString ? IDS_SHORT_ACTIVE : IDS_ACTIVE;
            break;

        case State_Connected:
            wID  = bShortString ? IDS_SHORT_CONNECTED : IDS_CONNECTED;
            break;

        case State_ConnectQuery:
            wID  = bShortString ? IDS_SHORT_CONNECT_QUERY : IDS_CONNECT_QUERY;
            break;

        case State_Shadow:
            wID  = bShortString ? IDS_SHORT_SHADOW : IDS_SHADOW;
            break;

        case State_Disconnected:
            wID  = bShortString ? IDS_SHORT_DISCONNECTED : IDS_DISCONNECTED;
            break;

        case State_Idle:
            wID  = bShortString ? IDS_SHORT_IDLE  : IDS_IDLE;
            break;

        case State_Reset:
            wID  = bShortString ? IDS_SHORT_RESET  : IDS_RESET;
            break;

        case State_Down:
            wID  = bShortString ? IDS_SHORT_DOWN  : IDS_DOWN;
            break;

        case State_Init:
            wID  = bShortString ? IDS_SHORT_INIT  : IDS_INIT;
            break;

        case State_Listen:
            wID  = bShortString ? IDS_SHORT_LISTEN : IDS_LISTEN;
            break;
    }

    // If we haven't loaded the string yet, do it now
    if (!ConnectStateStrings[wID - IDS_ACTIVE]) {
        LoadString(GetModuleHandle( UTILDLL_NAME ),
                   wID, buffer, lengthof(buffer) );
        ConnectStateStrings[wID - IDS_ACTIVE] = LocalAlloc(LPTR, 2*(wcslen(buffer)+1));
        if(NULL == ConnectStateStrings[wID - IDS_ACTIVE])
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
        lstrcpy(ConnectStateStrings[wID - IDS_ACTIVE], buffer);
    }

    return(ConnectStateStrings[wID - IDS_ACTIVE]);


}  // end StrConnectState


/*******************************************************************************
 *
 *  StrProcessState - Hydrix helper function
 *
 *      Returns pointer to string representing the specified process state.
 *
 *  ENTRY:
 *      State (input)
 *          The process state to associate with a string.
 *
 *  EXIT:
 *      (LPCTSTR) Points to string representing the process state.
 *
 ******************************************************************************/

LPTSTR ProcessStateStrings[8] = { NULL};

WORD StateTable[] = {
    IDS_INITED,
    IDS_READY,
    IDS_RUN,
    IDS_STANDBY,
    IDS_TERMINATE,
    IDS_WAIT,
    IDS_TRANSIT,
    IDS_STATE_DASHES,
    IDS_STATE_DASHES,
    IDS_STATE_DASHES,
    IDS_STATE_DASHES,
    IDS_STATE_DASHES
};

LPCTSTR WINAPI
StrProcessState( ULONG State )
{
    TCHAR buffer[256];

    WORD wID = StateTable[State];

    // If we haven't loaded the string yet, do it now
    if (!ProcessStateStrings[wID - IDS_INITED]) {
        LoadString(GetModuleHandle( UTILDLL_NAME ),
                   wID, buffer, lengthof(buffer) );
        ProcessStateStrings[wID - IDS_INITED] = LocalAlloc(LPTR, 2*(wcslen(buffer)+1));
        if(NULL == ProcessStateStrings[wID - IDS_INITED])
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
        lstrcpy(ProcessStateStrings[wID - IDS_INITED], buffer);
    }

    return(ProcessStateStrings[wID - IDS_INITED]);


}  // end StrProcessState


/*******************************************************************************
 *
 *  StrSystemWaitReason - Hydrix helper function
 *
 *      Returns pointer to string representing the specified 'system'
 *      wait reason code.
 *
 *  ENTRY:
 *      WaitReason (input)
 *          The system wait reason code to associate with a string.
 *
 *  EXIT:
 *      (LPCTSTR) Points to string representing the system wait reason.
 *
 ******************************************************************************/

LPTSTR SystemWaitStrings[31] = { NULL};

WORD SystemWaitReason[] = {
    IDS_EXECUTIVE,          // Executive
    IDS_FREE_PAGE,          // FreePage
    IDS_PAGE_IN,            // PageIn
    IDS_POOL_ALLOC,         // PoolAlloc
    IDS_DELAY_EXECUTION,    // DelayExecution
    IDS_SUSPENDED,          // Suspended
    IDS_USER_REQUEST,       // UserRequest
    IDS_EXECUTIVE,          // Executive
    IDS_FREE_PAGE,          // FreePage
    IDS_PAGE_IN,            // PageIn
    IDS_POOL_ALLOC,         // PoolAllocation
    IDS_DELAY_EXECUTION,    // DelayExecution
    IDS_SUSPENDED,          // Suspended
    IDS_USER_REQUEST,       // UserRequest
    IDS_EVENT_PAIR_HIGH,    // EventPairHigh
    IDS_EVENT_PAIR_LOW,     // EventPairLow
    IDS_LPC_RECEIVE,        // LpcReceive
    IDS_LPC_REPLY,          // LpcReply
    IDS_VIRTUAL_MEMORY,     // VirtualMemory
    IDS_PAGE_OUT,           // PageOut
    IDS_WAIT1,
    IDS_WAIT2,
    IDS_WAIT3,
    IDS_WAIT4,
    IDS_WAIT5,
    IDS_WAIT6,
    IDS_WAIT7,
    IDS_WAIT8,
    IDS_WAIT9,
    IDS_WAIT10
};

LPCTSTR WINAPI
StrSystemWaitReason( ULONG WaitReason )
{
    TCHAR buffer[256];

    WORD wID = SystemWaitReason[WaitReason];

    // If we haven't loaded the string yet, do it now
    if (!SystemWaitStrings[wID - IDS_EXECUTIVE]) {
        LoadString(GetModuleHandle( UTILDLL_NAME ),
                   wID, buffer, lengthof(buffer) );
        SystemWaitStrings[wID - IDS_EXECUTIVE] = LocalAlloc(LPTR, 2*(wcslen(buffer)+1));
                if(NULL == SystemWaitStrings[wID - IDS_EXECUTIVE])
                {
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        return NULL;
                }
        wcscpy(SystemWaitStrings[wID - IDS_EXECUTIVE], buffer);
    }

    return(SystemWaitStrings[wID - IDS_EXECUTIVE]);


}  // end StrSystemWaitReason


/*******************************************************************************
 *
 *  StrAsyncConnectState - Hydrix helper function
 *
 *      Returns pointer to string representing the specified async connect state.
 *
 *  ENTRY:
 *      State (input)
 *          The async connect state to associate with a string.
 *
 *  EXIT:
 *      (LPCTSTR) Points to string representing the async connect state.
 *
 ******************************************************************************/

LPTSTR AsyncConnectStateStrings[6] = { NULL };

LPCTSTR WINAPI
StrAsyncConnectState( ASYNCCONNECTCLASS State )
{
    TCHAR buffer[256];
    WORD wID = State - Connect_CTS;

    // If we haven't loaded the string yet, do it now
    if (!AsyncConnectStateStrings[wID]) {
        LoadString(GetModuleHandle( UTILDLL_NAME ),
                   wID + IDS_ASYNC_CONNECT_CTS, buffer, lengthof(buffer) );
        AsyncConnectStateStrings[wID] = LocalAlloc(LPTR, 2*(wcslen(buffer)+1));
        if(NULL == AsyncConnectStateStrings[wID])
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
        lstrcpy(AsyncConnectStateStrings[wID], buffer);
    }

    return(AsyncConnectStateStrings[wID]);


}  // end StrProcessState


/*******************************************************************************
*
*  GetUnknownString - Hydrix helper function
*
*      Returns pointer to the string representing an unknown
*      Connect State or DateTimeString (IDS_UNKNOWN)
*      This is primarily so that WinAdmin can compare against it
*
*  ENTRY:
*      None
*
*  EXIT:
*      (LPCTSTR) Points to string representing the unknown string
*
******************************************************************************/

LPTSTR UnknownString = NULL;

LPCTSTR WINAPI
GetUnknownString()
{
    TCHAR buffer[256];

    // if we haven't loaded the string yet, do it now
    if (!UnknownString) {
        LoadString(GetModuleHandle( UTILDLL_NAME ),
                   IDS_UNKNOWN, buffer, lengthof(buffer) );
        UnknownString = LocalAlloc(LPTR, 2*(wcslen(buffer)+1));
        if(NULL == UnknownString)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
        lstrcpy(UnknownString, buffer);
    }

    return(UnknownString);

}  // end GetUnknownString


/*******************************************************************************
 *
 *  CalculateElapsedTime - Hydrix helper function
 *
 *      Determines the difference between a specified LARGE_INTEGER time value
 *      and the current system time, saves this 'elapsed time' into the
 *      specified ELAPSEDTIME structure.
 *
 *  ENTRY:
 *      pTime (input)
 *          Points to LARGE_INTEGER of time for difference calculation.
 *      pElapsedTime (output)
 *          Points to ELAPSEDTIME structure to save elapsed time.
 *
 *  EXIT:
 *
 ******************************************************************************/

void WINAPI
CalculateElapsedTime( LARGE_INTEGER *pTime,
                      ELAPSEDTIME *pElapsedTime )
{
    LARGE_INTEGER InputTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER DiffTime;
    SYSTEMTIME ltime;
    ULONG d_time;

    /*
     * Fetch the current time and zero out the specified ELAPSEDTIME structure.
     */
    GetLocalTime( &ltime );
    memset( pElapsedTime, 0, sizeof(ELAPSEDTIME) );

    if ( (pTime->HighPart == 0 && pTime->LowPart == 0 ) ||
         !FileTimeToLocalFileTime( (FILETIME*)pTime, (FILETIME*)&InputTime ) ||
         !SystemTimeToFileTime( &ltime, (FILETIME *)&CurrentTime ) )
        return;

    /*
     * Get the number of seconds since specified time.
     */
    DiffTime = CalculateDiffTime( InputTime, CurrentTime );
    d_time = DiffTime.LowPart;

    /*
     * Calculate the days, hours, minutes, seconds since specified time.
     */
    pElapsedTime->days = (USHORT)(d_time / 86400L); // days since
    d_time = d_time % 86400L;                       // seconds => partial day
    pElapsedTime->hours = (USHORT)(d_time / 3600L); // hours since
    d_time  = d_time % 3600L;                       // seconds => partial hour
    pElapsedTime->minutes = (USHORT)(d_time / 60L); // minutes since
    pElapsedTime->seconds = (USHORT)(d_time % 60L); // seconds remaining

}  // end CalculateElapsedTime


/*******************************************************************************
 *
 *  CompareElapsedTime - Hydrix helper function
 *
 *      Determines the difference between two ELAPSEDTIME values.
 *
 *  ENTRY:
 *      pElapsedTime1 (input)
 *          Points to first ELAPSEDTIME
 *      pElapsedTime2 (input)
 *          Points to ELAPSEDTIME structure to save elapsed time.
 *      bCompareSeconds (input)
 *          TRUE to include the seconds member in comparison; false otherwise.
 *
 *  EXIT:
 *      < 1 if first time is less than second time
 *      0 if times are the same
 *      > 1 if first time is greater than second time
 *
 ******************************************************************************/

int WINAPI
CompareElapsedTime( ELAPSEDTIME *pElapsedTime1,
                    ELAPSEDTIME *pElapsedTime2,
                    BOOL bCompareSeconds )
{
    int result;

    if ( !(result = pElapsedTime1->days - pElapsedTime2->days)       &&
         !(result = pElapsedTime1->hours - pElapsedTime2->hours)     &&
         !(result = pElapsedTime1->minutes - pElapsedTime2->minutes) &&
         (!bCompareSeconds ||
          !(result = pElapsedTime1->seconds - pElapsedTime2->seconds) ) )
        return(0);
    else
        return(result);

}  // end CompareElapsedTime


/*******************************************************************************
 *
 *  ElapsedTimeString - Hydrix helper function
 *
 *      Converts the specified ELAPSEDTIME into a string of the form
 *      "ddd+hh:mm:ss" or, optionally "ddd+hh:mm" (suppress seconds).
 *
 *  ENTRY:
 *      pElapsedTime (input)
 *          Points to ELAPSEDTIME structure to convert to string.
 *      bIncludeSeconds (input)
 *          If TRUE, will include seconds in string; FALSE will exclude.
 *      pString (output)
 *          Points to location to store elapsed time string.
 *  EXIT:
 *
 ******************************************************************************/

void WINAPI
ElapsedTimeString( ELAPSEDTIME *pElapsedTime,
                   BOOL bIncludeSeconds,
                   LPTSTR pString )
{
    if ( bIncludeSeconds ) {

        if ( pElapsedTime->days > 0 )
            wsprintf( pString, TEXT("%u+%02u:%02u:%02u"),
                      pElapsedTime->days,
                      pElapsedTime->hours,
                      pElapsedTime->minutes,
                      pElapsedTime->seconds );
        else if ( pElapsedTime->hours > 0 )
            wsprintf( pString, TEXT("%u:%02u:%02u"),
                      pElapsedTime->hours,
                      pElapsedTime->minutes,
                      pElapsedTime->seconds );
        else if ( pElapsedTime->minutes > 0 )
            wsprintf( pString, TEXT("%u:%02u"),
                      pElapsedTime->minutes,
                      pElapsedTime->seconds );
        else if ( pElapsedTime->seconds > 0 )
            wsprintf( pString, TEXT("%u"),
                      pElapsedTime->seconds );
        else
            wsprintf( pString, TEXT(".") );

    }
    else {

        if ( pElapsedTime->days > 0 )
            wsprintf( pString, TEXT("%u+%02u:%02u"),
                      pElapsedTime->days,
                      pElapsedTime->hours,
                      pElapsedTime->minutes );
        else if ( pElapsedTime->hours > 0 )
            wsprintf( pString, TEXT("%u:%02u"),
                      pElapsedTime->hours,
                      pElapsedTime->minutes );
        else if ( pElapsedTime->minutes > 0 )
            wsprintf( pString, TEXT("%u"),
                      pElapsedTime->minutes );
        else
            wsprintf( pString, TEXT(".") );
    }

}  // end ElapsedTimeString


/*******************************************************************************
 *
 *  DateTimeString - Hydrix helper function
 *
 *      Converts the specified LARGE_INTEGER time value into a date/time string
 *      of the form "mm/dd/yy hh:mm".
 *
 *  ENTRY:
 *      pTime (input)
 *          Points to LARGE_INTEGER of time to convert to string.
 *      pString (output)
 *          Points string to store converted date/time into.
 *
 *  EXIT:
 *
 ******************************************************************************/

void WINAPI
DateTimeString( LARGE_INTEGER *pTime,
                LPTSTR pString )
{
    FILETIME LocalTime;
    SYSTEMTIME stime;
    LPTSTR lpTimeStr;
    int nLen;

    if ( FileTimeToLocalFileTime( (FILETIME *)pTime, &LocalTime ) &&
         FileTimeToSystemTime( &LocalTime, &stime ) ) {

        //Get Date Format
        nLen = GetDateFormat(
                    LOCALE_USER_DEFAULT,
                    DATE_SHORTDATE,
                    &stime,
                    NULL,
                    NULL,
                    0);
        lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));
        if(NULL == lpTimeStr)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            wcscpy(pString, L"");
            return;
        }
        nLen = GetDateFormat(
                    LOCALE_USER_DEFAULT,
                    DATE_SHORTDATE,
                    &stime,
                    NULL,
                    lpTimeStr,
                    nLen);
        wcscpy(pString, lpTimeStr);
        wcscat(pString, L" ");
        GlobalFree(lpTimeStr);

        //Get Time Format
        nLen = GetTimeFormat(
                    LOCALE_USER_DEFAULT,
                    TIME_NOSECONDS,
                    &stime,
                    NULL,
                    NULL,
                    0);
        lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));
        if(NULL == lpTimeStr)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            wcscpy(pString, L"");
            return;
        }
        nLen = GetTimeFormat(
                    LOCALE_USER_DEFAULT,
                    TIME_NOSECONDS,
                    &stime,
                    NULL,
                    lpTimeStr,
                    nLen);
        wcscat(pString, lpTimeStr);
        GlobalFree(lpTimeStr);
    }
    else
        LoadString( GetModuleHandle( UTILDLL_NAME ),
                    IDS_UNKNOWN, pString, lengthof(pString) );

}  // end DateTimeString


/*******************************************************************************
 *
 *  CurrentDateTimeString - Hydrix helper function
 *
 *      Converts the current system time into a date/time string of the form
 *      "mm/dd/yy hh:mm".
 *
 *  ENTRY:
 *      pString (output)
 *          Points string to store converted date/time into.
 *  EXIT:
 *
 ******************************************************************************/

void WINAPI
CurrentDateTimeString( LPTSTR pString )
{
    SYSTEMTIME stime;
    LPTSTR lpTimeStr;
    int nLen;

    GetLocalTime(&stime);
    //Get DateFormat
    nLen = GetDateFormat(
                LOCALE_USER_DEFAULT,
                DATE_SHORTDATE,
                &stime,
                NULL,
                NULL,
                0);
    lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));
    if(NULL == lpTimeStr)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        wcscpy(pString, L"");
        return;
    }
    nLen = GetDateFormat(
                   LOCALE_USER_DEFAULT,
                DATE_SHORTDATE,
                &stime,
                NULL,
                lpTimeStr,
                nLen);
    wcscpy(pString, lpTimeStr);
    wcscat(pString, L" ");
    GlobalFree(lpTimeStr);

    //Get Time Format
    nLen = GetTimeFormat(
                   LOCALE_USER_DEFAULT,
                TIME_NOSECONDS,
                &stime,
                NULL,
                NULL,
                0);
    lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));
    if(NULL == lpTimeStr)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        wcscpy(pString, L"");
        return;
    }
    nLen = GetTimeFormat(
                   LOCALE_USER_DEFAULT,
                TIME_NOSECONDS,
                &stime,
                NULL,
                lpTimeStr,
                nLen);
    wcscat(pString, lpTimeStr);
    GlobalFree(lpTimeStr);

}  // end CurrentDateTimeString


/*******************************************************************************
 *
 *  CalculateDiffTime - Hydrix helper function
 *
 *  Calculate the time difference between two LARGE_INTEGER time values.
 *
 * ENTRY:
 *    FirstTime (input)
 *       The first (lower) time value.
 *    SecondTime (input)
 *       The second (higher) time value.
 *
 * EXIT:
 *    LARGE_INTEGER - the time difference
 *
 ******************************************************************************/

LARGE_INTEGER WINAPI
CalculateDiffTime( LARGE_INTEGER FirstTime, LARGE_INTEGER SecondTime )
{
    LARGE_INTEGER DiffTime;

    DiffTime = RtlLargeIntegerSubtract( SecondTime, FirstTime );
    DiffTime = RtlExtendedLargeIntegerDivide( DiffTime, 10000000, NULL );
    return(DiffTime);

}  // end CalculateDiffTime


/*******************************************************************************
 *
 *  EnumerateMultiUserServers - Hydrix helper function
 *
 *      Enumerate the Hydrix servers on the network by Domain
 *
 *  ENTRY:
 *      pDomain (input)
 *          Specifies the domain to enumerate; NULL for current domain.
 *
 *  EXIT:
 *      (LPTSTR) Points to LocalAlloced buffer containing results of the
 *               enumeration, in multi-string format, if sucessful; NULL if
 *               error.  The caller must perform a LocalFree of this buffer
 *               when done.  If error (NULL), the error code is set for
 *               retrieval by GetLastError();
 *
 ******************************************************************************/

LPWSTR WINAPI
EnumerateMultiUserServers( LPWSTR pDomain )

{
    PSERVER_INFO_101 pInfo = NULL;
    DWORD dwByteCount, dwIndex, TotalEntries;
    DWORD AvailCount = 0;
    LPWSTR pTemp, pBuffer = NULL;

    /*
     * Enumerate all WF servers on the specified domain.
     */
    if ( NetServerEnum ( NULL,
                         101,
                         (LPBYTE *)&pInfo,
                         (DWORD) -1,
                         &AvailCount,
                         &TotalEntries,
                         SV_TYPE_TERMINALSERVER,
                         pDomain,
                         NULL ) ||
         !AvailCount )
        goto done;

    /*
     * Traverse list and calculate the total byte count for list of
     * servers that will be returned.
     */
    for ( dwByteCount = dwIndex = 0; dwIndex < AvailCount; dwIndex++ ) {

        dwByteCount += (wcslen(pInfo[dwIndex].sv101_name) + 1) * 2;
    }
    dwByteCount += 2;   // for ending null

    /*
     * Allocate memory.
     */
    if ( (pBuffer = LocalAlloc(LPTR, dwByteCount)) == NULL ) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto done;
    }

    /*
     * Traverse list again and copy servers to buffer.
     */
    for ( pTemp = pBuffer, dwIndex = 0; dwIndex < AvailCount; dwIndex++ ) {

        wcscpy(pTemp, pInfo[dwIndex].sv101_name);
        pTemp += (wcslen(pInfo[dwIndex].sv101_name) + 1);
    }
    *pTemp = L'\0';     // ending null

    done:
    if ( AvailCount && pInfo )
        NetApiBufferFree( pInfo );

    return(pBuffer);

}  // end EnumerateMultiUserServers


/******************************************************************************
 *
 *      _UserInGroup
 *          Internal function, determines if a user is a member of any of the
 *          groups passed in
 *
 *  ENTRY:
 *      pwszUsername (IN) - Username to test group membership of
 *
 *      pwszDomain (IN)   - Domain of the user passed in
 *
 *      pwszGroup (IN)    - String array of all the allowed groups
 *
 *  EXIT:
 *      Returns BOOLEAN value if user is a member of one of the groups
 *  HISTORY:
 *
 *
 *****************************************************************************/
BOOL _UserInGroup( LPWSTR pwszUsername, LPWSTR pwszDomain, LPWSTR pwszGroup )
{
    DWORD                EntriesRead;
    DWORD                EntriesLeft;
    NET_API_STATUS       rc;
    PGROUP_USERS_INFO_0  pszGroups;
    ULONG                i;
    PWCHAR               pwcUser;
    WCHAR                szBuf[MAX_PATH];
    LPWKSTA_INFO_100     pWorkstationInfo = NULL;
    WCHAR                szDomainController[50];
#if DBG
    DbgPrint( "MSGINA: UserInGroup: look(%S\\%S)  group(%S)\n",
              pwszDomain, pwszUsername, pwszGroup );
#endif
    // This call will return the domain of the computer, not the domain of the user
    if (( NetWkstaGetInfo( NULL,
                           100,
                           (LPBYTE *)&pWorkstationInfo )) == NERR_Success) {
        if( !CtxGetAnyDCName( NULL,
                              pWorkstationInfo->wki100_langroup,
                              szDomainController ) ){
            NetApiBufferFree((LPVOID)pWorkstationInfo);
            return( FALSE );
        }
    }
    else {
        return (FALSE);
    }

    if ( wcscmp( pWorkstationInfo->wki100_langroup, pwszDomain ) != 0 ) {
        // user is from a different domain than the machine (trusted domain)
        // need to change username to reflect the domain
        wcscpy( szBuf, pwszDomain );
        wcscat( szBuf, L"\\" );
        wcscat( szBuf, pwszUsername );
        pwcUser = szBuf;
    }
    else {
        pwcUser = pwszUsername;
    }

    rc = NetUserGetLocalGroups( szDomainController,
                                pwcUser,
                                0, // level
                                LG_INCLUDE_INDIRECT, // flags
                                (LPBYTE*)&pszGroups,
                                MAX_BUFFER,
                                &EntriesRead,
                                &EntriesLeft );

    if( pWorkstationInfo != NULL )
        NetApiBufferFree((LPVOID)pWorkstationInfo);

    if ( rc != NERR_Success ) {
        return( FALSE );
    }

    for ( i=0; i < EntriesRead; i++ ) {
        if ( wcscmp( pszGroups[i].grui0_name, pwszGroup ) == 0 ) {
            NetApiBufferFree( pszGroups );
            pszGroups = NULL;
            return( TRUE );
        }
    }

    NetApiBufferFree( pszGroups );
    pszGroups = NULL;
    return(FALSE);

}


/******************************************************************************
 *
 *  CtxGetAnyDCName
 *      Function to find a any DC of a specified domain.  The call
 *      NetGetAnyDCName does not work as needed in all occasions.
 *      ie.  Trusted domains and the current server being a DC.
 *
 *  ENTRY:
 *      pServer (IN)  -  Server on which to run the call (RPC)
 *
 *      pDomain (IN)  -  Domain you are inquring about, does not need to be
 *                          current domain
 *
 *      pBuffer (OUT) -  Pointer to a string containg a DC name, buffer must
 *                       be passed in.
 *  EXIT:
 *      BOOL  Success
 *
 *  HISTORY:
 *
 *
 *****************************************************************************/

BOOL
CtxGetAnyDCName ( PWCHAR pServer, PWCHAR pDomain, PWCHAR pBuffer )
{

    PWCHAR               pDomainController = NULL;
    PWCHAR               pLocalDomainDC    = NULL;
    SERVER_INFO_101*     ServerBuf         = NULL;
    BOOLEAN              rc = TRUE;
    BOOLEAN              bFoundDC = FALSE;

    // This call will return the domain of the computer, not the domain of the user
        if (( NetGetAnyDCName(NULL,
                              pDomain,
                              (LPBYTE *)&pDomainController)) != NERR_Success) {
//
// NetGetAnyDCName doesn't work in two situations
//  1.  If the domain is a trusted domain, it must be run from a DC.  So we find our local
//           DC and have it run getanydcname for us.
//  2.  If we are a DC it will fail.  So a second check is made to see
//         if in fact we are a DC or not
//

            // find a local DC in which to RPC to
            if( NetGetAnyDCName( NULL,
                                 NULL,
                                 (LPBYTE *) &pLocalDomainDC ) == NERR_Success ) {
                // Make the call as an RPC and pass it the Domain name
                if( NetGetAnyDCName( pLocalDomainDC,
                                          pDomain,
                                          (LPBYTE *) &pDomainController ) == NERR_Success){
                    bFoundDC = TRUE;
                }
            }

            // if it wasn't a trusted domain, maybe we are a domain controller
            if( !bFoundDC ) {
                if( NetServerGetInfo( NULL,
                                      101,
                                      (LPBYTE*)&ServerBuf ) == NERR_Success ) {
                    if( ServerBuf->sv101_type & (SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL) ) {
                        pDomainController = NULL;
                    }
                    else {
                       rc = FALSE;
                       goto done;
                    }
                }
                else {
                    rc = FALSE;
                    goto done;
                }
            }
        }
    if( pDomainController )
        wcscpy( pBuffer, pDomainController);
    else
        *pBuffer = '\0';
done:

    if( pLocalDomainDC )
        NetApiBufferFree( pLocalDomainDC );
    if( pDomainController )
        NetApiBufferFree( pDomainController );
    if( ServerBuf )
        NetApiBufferFree( ServerBuf );

    return( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\parse.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*****************************************************************************
*
*   PARSE.C
*
*      This module contains the code to implement generic parsing routines
*      for utilities.  There are several parsing routines included here.
*
*      External Entry Points:  (defined in utilsub.h)
*
*         ParseCommandLineW()
*         IsTokenPresentW()
*         SetTokenPresentW()
*         SetTokenNotPresentW()
*
*
****************************************************************************/

/* Get the standard C includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#include <winstaw.h>
#include <utilsub.h>
#include <expand.h>

// Verify that these are used internally, and do not rep. OS flags
// usage appears in parse.c and expand.c only
//
#define READ_ONLY 0x0001   /* file is read only */
#define HIDDEN    0x0002   /* file is hidden */
#define SYSTEM    0x0004   /* file is a system file */
#define VOLUME    0x0008   /* file is a volume label */
#define SUBDIR    0x0010   /* file is a subdirectory */
#define ARCHIVE   0x0020   /* file has archive bit on */


/*=============================================================================
 ==   Local Functions Defined
 ============================================================================*/
static USHORT StoreArgument(PTOKMAPW, WCHAR *);

/*=============================================================================
 ==   External Functions Used
 ============================================================================*/

/*=============================================================================
 ==   Local Variables Used
 ============================================================================*/
ARGS  arg_data;

/*=============================================================================
 ==   Global Variables Used
 ============================================================================*/

VOID
SetBoolean(
    PTOKMAPW TokenMap,
    BOOL Value
    )
{
    //
    // Folks pass in a variety of types and sizes as "boolean".  Carefully
    // perform the write based on the size of the token map: first clear the
    // entire field, then (if Value != FALSE) set the only the first byte to
    // TRUE.
    //

    ZeroMemory( TokenMap->tmAddr, TokenMap->tmDLen );
    if (Value != FALSE) {
        *((PCHAR)TokenMap->tmAddr) = TRUE;
    }
}

/*****************************************************************************
*
*   ParseCommandLineW (UNICODE version)
*
*      This is the main function of the ParseCommandLine function. If the
*      caller is passing argv from the main() function the caller is
*      is responsible for pointing to argv[1], unless he wants this function
*      to parse the program name (argv[0]).
*
*      If the user wishes to parse an admin file it is necessary to massage
*      the data into a form compatible with the command line arguements
*      passed to a main() function before calling ParseCommandLine().
*
*   ENTRY:
*      argc - count of the command line arguments.
*      argv - vector of strings containing the
*      ptm  - pointer to begining of the token map array
*      flag - USHORT set of flags (see utilsub.h for flag descriptions).
*
*   EXIT:
*      Normal:                           ********** NOTE***********
*         PARSE_FLAG_NO_ERROR            * All errors returned    *
*                                        * from this function are *
*      Error:                            * BIT flags and must be  *
*         PARSE_FLAG_NO_PARMS            * converted by caller to *
*         PARSE_FLAG_INVALID_PARM        * OS/2+ ERRORS!!!!       *
*         PARSE_FLAG_TOO_MANY_PARMS      ********** NOTE***********
*         PARSE_FLAG_MISSING_REQ_FIELD
*   ALGORITHM:
*
****************************************************************************/

USHORT WINAPI
ParseCommandLineW( INT argc,
                   WCHAR **argv,
                   PTOKMAPW ptm,
                   USHORT flag )
{
   BOOL      everyonespos = FALSE;
   WCHAR     *pChar;
   USHORT    rc, argi, found;
   size_t    tokenlen, arglen;
   PTOKMAPW   ptmtmp, nextpositional;
   PFILELIST pFileList;

   rc = PARSE_FLAG_NO_ERROR;

   /*--------------------------------------------------------------------------
   -- If there are no parameters inform the caller of this fact.
   --------------------------------------------------------------------------*/
   if(argc == 0) {
      rc |= PARSE_FLAG_NO_PARMS;
      return(rc);
   }

   /*--------------------------------------------------------------------------
   -- Find the first positional parameter in the token map array, if any.
   -- Also set the valid memory locations to '\0'.
   --------------------------------------------------------------------------*/
   nextpositional = NULL;
   for(ptmtmp=ptm; ptmtmp->tmToken != NULL; ptmtmp++) {
      if(ptmtmp->tmDLen && !(flag & PCL_FLAG_NO_CLEAR_MEMORY)) {
         pChar = (WCHAR *) ptmtmp->tmAddr;
         /*
          * Clear the 'string' form fields for tmDLen*sizeof(WCHAR) bytes;
          * all other forms to tmDLen bytes.
          */
         if ( (ptmtmp->tmForm == TMFORM_S_STRING) ||
              (ptmtmp->tmForm == TMFORM_DATE) ||
              (ptmtmp->tmForm == TMFORM_PHONE) ||
              (ptmtmp->tmForm == TMFORM_STRING) ||
              (ptmtmp->tmForm == TMFORM_X_STRING) )
            memset(pChar, L'\0', (ptmtmp->tmDLen*sizeof(WCHAR)));
        else
            memset(pChar, L'\0', ptmtmp->tmDLen);
      }
      if(ptmtmp->tmToken[0] != L'/' && ptmtmp->tmToken[0] != L'-' && nextpositional == NULL) {
         nextpositional = ptmtmp;
      }
   }

   /*--------------------------------------------------------------------------
   -- Scan the argument array looking for /x or -x switches or positional
   -- parameters.  If a switch is found look it up in the token map array
   -- and if found see if it has a trailing parameter of the format:
   --              -x:foo || /x:foo || -x foo || /x foo
   -- when found set the found flag and if there is a trailing parameter
   -- store it at the location the user requested.
   --
   -- If it is not found in the token map array return the proper error
   -- unless the user requests us to ignore it (PCL_FLAG_IGNORE_INVALID).
   --
   -- If it is a positional parameter enter it into the token map array if
   -- there is room for it (i.e. nextpositional != NULL), if there is no
   -- room for it then return the proper error.
   --------------------------------------------------------------------------*/
   for(argi=0; argi<argc;) {
      if(everyonespos) {
         if( (wcslen(nextpositional->tmAddr) + wcslen(argv[argi]) + 1) > nextpositional->tmDLen) {
            rc |= PARSE_FLAG_TOO_MANY_PARMS;
            return(rc);
         }
         wcscat((WCHAR *) nextpositional->tmAddr, L" ");
         wcscat((WCHAR *) nextpositional->tmAddr, argv[argi]);
         argi++;
      }
      else if(argv[argi][0] == L'/' ||     /* argument is a switch (/x or -x) */
         argv[argi][0] == L'-') {
         found = FALSE;
         for(ptmtmp=ptm; ptmtmp->tmToken != NULL; ptmtmp++) {
            /*-----------------------------------------------------------------
             --   The string is found if a few requirements are met:
             --   1) The first N-1 characters are the same, where N is
             --      the length of the string in the token map array.
             --      We ignore the first character (could be '-' or '/').
             --   2) If the strings are not the same length, then the only
             --      valid character after /x can be ':', this is only  true
             --      if the switch has a trailing parameter.
             ----------------------------------------------------------------*/
            tokenlen = wcslen(ptmtmp->tmToken);    /* get token length       */
            arglen   = wcslen(argv[argi]);         /* get argument length    */
            if(!(_wcsnicmp(&(ptmtmp->tmToken[1]), &(argv[argi][1]), tokenlen-1))) {
               if(tokenlen != arglen) {            /* not same length        */
                  if(ptmtmp->tmForm != TMFORM_VOID && /* if trailing parm is    */
                     argv[argi][tokenlen] == L':') {/* delemited with a ':'   */
                     if(ptmtmp->tmFlag & TMFLAG_PRESENT) { /* seen already  */
                        rc |= PARSE_FLAG_DUPLICATE_FIELD;
                     }
                     found = TRUE;                 /* then report it found.  */
                     break;
                  }
               }
               else {                              /* all character same and */
                  if(ptmtmp->tmFlag & TMFLAG_PRESENT) { /* seen already  */
                     rc |= PARSE_FLAG_DUPLICATE_FIELD;
                  }
                  found = TRUE;                    /* strings are the same   */
                  break;                           /* len report it found.   */
               }
            }
         }
         /* switch not found in token map array and not requested to ignore */
         if(found != TRUE && !(flag & PCL_FLAG_IGNORE_INVALID)) {
            rc |= PARSE_FLAG_INVALID_PARM;
            if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
               return(rc);
            }
            ++argi;
         }
         else if (!found) {
            ++argi;
         }
         else {               /* switch was found in token map array */
            if(ptmtmp->tmForm == TMFORM_VOID) { /* no trailing parameter, done */
               ptmtmp->tmFlag |= TMFLAG_PRESENT;
               ++argi;
            }
            else if(ptmtmp->tmForm == TMFORM_BOOLEAN) {  /* need confirmation */
               ptmtmp->tmFlag |= TMFLAG_PRESENT;
               SetBoolean(ptmtmp, TRUE);
               ++argi;
            }
            else {         /* has a trailing parameter */
               if(argv[argi][tokenlen] == L':') { /* all in one switch (i.e. /x:foo) */
                  if(StoreArgument(ptmtmp, &(argv[argi][tokenlen+1]))) {
                     ptmtmp->tmFlag |= TMFLAG_PRESENT;
                     if(flag & PCL_FLAG_RET_ON_FIRST_SUCCESS) {
                        return(rc);
                     }
                  }
                  else {
                     rc |= PARSE_FLAG_INVALID_PARM;
                     if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
                        return(rc);
                     }
                  }
                  ++argi;                 /* bump up to next argument */
               }
               else {   /* two argument switch (i.e. /x foo) */
                  if ((++argi >= argc) ||
                      (argv[argi][0] == L'/') ||
                      (argv[argi][0] == L'-')) { /* bump up to trailing parm */
                     switch ( ptmtmp->tmForm ) {
                     case TMFORM_S_STRING:
                     case TMFORM_STRING:
                        ptmtmp->tmFlag |= TMFLAG_PRESENT;
                        pChar    = (WCHAR *) ptmtmp->tmAddr;
                        pChar[0] = (WCHAR)NULL;
                        break;
                     default:
                        rc |= PARSE_FLAG_INVALID_PARM;
                        if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
                           return(rc);
                        }
                        break;
                     }
                  }
                  else if(StoreArgument(ptmtmp, argv[argi])) {
                     ptmtmp->tmFlag |= TMFLAG_PRESENT;
                     if(flag & PCL_FLAG_RET_ON_FIRST_SUCCESS) {
                        return(rc);
                     }
                     ++argi;           /* bump up to next argument         */
                  }
                  else {
                     rc |= PARSE_FLAG_INVALID_PARM;
                     if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
                        return(rc);
                     }
                     ++argi;           /* bump up to next argument         */
                  }
               }
            }
         }
      }                                /* endif - is switch                */
      else {                           /* argument is a positional parmater*/
         if(nextpositional == NULL) {  /* if there are no positional left  */
            rc |= PARSE_FLAG_TOO_MANY_PARMS;
            if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
               return(rc);
            }
         }
         else {                        /* set positional in token array **/
            /*
            *  Is the current PTM the start of TMFORM_FILES?
            */
            if (nextpositional->tmForm == TMFORM_FILES) {
               nextpositional->tmFlag |= TMFLAG_PRESENT;
               args_init(&arg_data, MAX_ARG_ALLOC);
               do {
                  /*
                  *  If no match was found then return the current id.
                  */
//                if (!expand_path(argv[argi], (HIDDEN|SYSTEM), &arg_data)) {
//                   arg_data.argc--;
//                   arg_data.argvp--;
//                }
                  expand_path(argv[argi], (HIDDEN|SYSTEM), &arg_data);
               } while (++argi<argc);
               pFileList = (PFILELIST) nextpositional->tmAddr;
               pFileList->argc = arg_data.argc;
               pFileList->argv = &arg_data.argv[0];
               return (rc);
            }
            else if(StoreArgument(nextpositional, argv[argi])) {
               nextpositional->tmFlag |= TMFLAG_PRESENT;
               if(flag & PCL_FLAG_RET_ON_FIRST_SUCCESS) {
                  return(rc);
               }
               /*--------------------------------------------------------------
               -- if this is an X_STRING then every thing from now on is
               -- going to be a concatenated string
               --------------------------------------------------------------*/
               if(nextpositional->tmForm == TMFORM_X_STRING) {
                  everyonespos = TRUE;
               }
               else {
                  for(++nextpositional; nextpositional->tmToken!=NULL; nextpositional++) {
                     if(nextpositional->tmToken[0] != L'/' && nextpositional->tmToken[0] != L'-') {
                        break;
                     }
                  }
                  if(nextpositional->tmToken == NULL) {  /* ran out of PP */
                     nextpositional = NULL;
                  }
               }
            }
            else {                                    /* invalid PP */
               rc |= PARSE_FLAG_INVALID_PARM;
               if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
                  return(rc);
               }
            }
         }
         argi++;
      }
   }

   for(ptmtmp=ptm; ptmtmp->tmToken!=NULL; ptmtmp++) {
      if(ptmtmp->tmFlag & TMFLAG_REQUIRED && !(ptmtmp->tmFlag & TMFLAG_PRESENT)) {
         rc |= PARSE_FLAG_MISSING_REQ_FIELD;
         break;
      }
   }

   return(rc);

}  // end ParseCommandLineW


/*****************************************************************************
*
*   IsTokenPresentW (UNICODE version)
*
*       Determines if a specified command line token (in given TOKMAPW array)
*       was present on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPW array to scan.
*       pToken (input)
*           The token to scan for.
*
*   EXIT:
*       TRUE if the specified token was present on the command line;
*       FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
IsTokenPresentW( PTOKMAPW ptm,
                 PWCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !wcscmp( ptm[i].tmToken, pToken ) )
            return( (ptm[i].tmFlag & TMFLAG_PRESENT) ? TRUE : FALSE );
    }

    return(FALSE);

}  // end IsTokenPresentW


/*****************************************************************************
*
*   SetTokenPresentW (UNICODE version)
*
*       Forces a specified command line token (in given TOKMAPW array)
*       to be flagged as 'present' on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPW array to scan.
*       pToken (input)
*           The token to scan for and set flags.
*
*   EXIT:
*       TRUE if the specified token was found in the TOKMAPW array
*       (TMFLAG_PRESENT flag is set).  FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
SetTokenPresentW( PTOKMAPW ptm,
                  PWCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !wcscmp( ptm[i].tmToken, pToken ) ) {
            ptm[i].tmFlag |= TMFLAG_PRESENT;
            return(TRUE);
        }
    }

    return(FALSE);

}  // end SetTokenPresentW


/*****************************************************************************
*
*   SetTokenNotPresentW (UNICODE version)
*
*       Forces a specified command line token (in given TOKMAPW array)
*       to be flagged as 'not present' on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPW array to scan.
*       pToken (input)
*           The token to scan for and set flags.
*
*   EXIT:
*       TRUE if the specified token was found in the TOKMAPW array
*       (TMFLAG_PRESENT flag is reset).  FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
SetTokenNotPresentW( PTOKMAPW ptm,
                     PWCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !wcscmp( ptm[i].tmToken, pToken ) ) {
            ptm[i].tmFlag &= ~TMFLAG_PRESENT;
            return(TRUE);
        }
    }

    return(FALSE);

}  // end SetTokenNotPresentW


/*****************************************************************************
*
*   StoreArgument:
*
*   ENTRY:
*      ptm - a pointer to an entry in the token array map
*      s   - the argument to be entered into the current token array map entry.
*
*   EXIT:
*      Normal:
*         TRUE
*
*      Error:
*         FALSE
*
*   ALGORITHM:
*
****************************************************************************/

USHORT
StoreArgument( PTOKMAPW ptm,
               WCHAR *s )
{
   char *pByte;
   WCHAR *pChar;
   SHORT *pShort;
   USHORT *pUShort;
   LONG *pLong;
   ULONG *pULong;

   WCHAR *pEnd = s; //pointer to end of conversion

   /*
    * If the string is empty, allow it for real 'strings'!
    */
   if( !wcslen(s) ) {
      switch ( ptm->tmForm ) {
      case TMFORM_S_STRING:
      case TMFORM_STRING:
         pChar    = (WCHAR *) ptm->tmAddr;
         pChar[0] = (WCHAR)NULL;
         return( TRUE );
      }
      return( FALSE );
   }

   /*
    * Fail if there is no room to store result.
    */
   if ( ptm->tmDLen == 0) {
      return(FALSE);
   }

   switch(ptm->tmForm) {
      case TMFORM_BOOLEAN:
         SetBoolean(ptm, TRUE);
         break;
      case TMFORM_BYTE:
         pByte = (BYTE *) ptm->tmAddr;
        *pByte = (BYTE) wcstol(s, &pEnd, 10);
        if (pEnd == s)
        {
            return FALSE;
        }
         break;
      case TMFORM_CHAR:
         pChar = (WCHAR *) ptm->tmAddr;
        *pChar = s[0];
         break;
      case TMFORM_S_STRING:
         if (*s == L'\\') {
            ++s;
         }
      case TMFORM_DATE:
      case TMFORM_PHONE:
      case TMFORM_STRING:
      case TMFORM_X_STRING:
         
         //Added by a-skuzin
         //case when we need parameter to start with '-' or '/' and use "\-" or"\/"
		 if(s[0]==L'\\' && (s[1]==L'-' || s[1]==L'/' || s[1]==L'\\') ) {
	    	  ++s;
		 }
         //end of "added by a-skuzin"
         
         pChar = (WCHAR *) ptm->tmAddr;
         wcsncpy(pChar, s, ptm->tmDLen);
         break;
      case TMFORM_SHORT:
         pShort = (SHORT *) ptm->tmAddr;
        *pShort = (SHORT) wcstol(s, &pEnd, 10);
        if (pEnd == s)
        {
            return FALSE;
        }
         break;
      case TMFORM_USHORT:
         if ( s[0] == L'-') {        /* no negative numbers! */
            return( FALSE );
         }
         pUShort = (USHORT *) ptm->tmAddr;
        *pUShort = (USHORT) wcstol(s, &pEnd, 10);
        if (pEnd == s)
        {
            return FALSE;
        }
         break;
      case TMFORM_LONG:
         pLong = (LONG *) ptm->tmAddr;
        *pLong = wcstol(s, &pEnd, 10);
        if (pEnd == s)
        {
            return FALSE;
        }
         break;
      case TMFORM_SERIAL:
      case TMFORM_ULONG:
          if ( s[0] == L'-') {        /* no negative numbers! */
             return (FALSE);
         }
         pULong = (ULONG *) ptm->tmAddr;
        *pULong = (ULONG) wcstol(s, &pEnd, 10);
        if (pEnd == s)
        {
            return FALSE;
        }
         break;
      case TMFORM_HEX:
         if ( s[0] == L'-') {        /* no negative numbers! */
            return( FALSE );
         }
         pUShort = (USHORT *) ptm->tmAddr;
        *pUShort = (USHORT) wcstoul(s,NULL,16);
         break;
      case TMFORM_LONGHEX:
         if ( s[0] == L'-') {        /* no negative numbers! */
            return( FALSE );
         }
         pULong = (ULONG *) ptm->tmAddr;
        *pULong = wcstoul(s,NULL,16);
         break;
      default:                         /* if invalid format return FALSE */
         return(FALSE);
         break;
   }

   return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\parse_a.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*****************************************************************************
*
*   PARSE_A.C
*
*      ANSI stubs / replacements for the UNICODE command line parsing
*      routines (parse.c)
*
*      External Entry Points:  (defined in utilsub.h)
*
*         ParseCommandLineA()
*         IsTokenPresentA()
*         SetTokenPresentA()
*         SetTokenNotPresentA()
*
*
****************************************************************************/

/* Get the standard C includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#include <winstaw.h>
#include <utilsub.h>

/*=============================================================================
 ==   Local Functions Defined
 ============================================================================*/

/*=============================================================================
 ==   External Functions Used
 ============================================================================*/

/*=============================================================================
 ==   Local Variables Used
 ============================================================================*/

/*=============================================================================
 ==   Global Variables Used
 ============================================================================*/

/*****************************************************************************
*
*   ParseCommandLineA (ANSI stub for ParseCommandLineW)
*
*   Thunks over argv_a (ANSI) to argv_w (UNICODE) and TOKMAPA to TOKMAPW,
*   calls ParseCommandLineW(), then thunks back TOKMAPW to TOKMAPA and
*   returns
*
*   ENTRY:
*       (refer to ParseCommandLineW)
*   EXIT:
*       (refer to ParseCommandLineW), plus
*       PARSE_FLAG_NOT_ENOUGH_MEMORY
*
****************************************************************************/

#define tmFormIsString(x) ((x == TMFORM_S_STRING) || (x == TMFORM_DATE) || (x == TMFORM_PHONE) || (x == TMFORM_STRING) || (x == TMFORM_X_STRING))

USHORT WINAPI
ParseCommandLineA( INT argc,
                   CHAR **argv_a,
                   PTOKMAPA ptm_a,
                   USHORT flag )
{
    int i, len1, len2;
    USHORT rc = PARSE_FLAG_NOT_ENOUGH_MEMORY;   // default to memory error
    WCHAR **argv_w = NULL;
    PTOKMAPA ptmtmp_a;
    PTOKMAPW ptmtmp_w, ptm_w = NULL;

    /*
     * If no parameters, we skip a lot of work.
     */
    if ( argc == 0 ) {
        rc = PARSE_FLAG_NO_PARMS;
        return(rc);
    }

    /*
     * Alloc and form WCHAR argvw array.
     */
    if ( !(argv_w = (WCHAR **)malloc( (len1 = argc * sizeof(WCHAR *)) )) )
        goto done;  // memory error
    memset(argv_w, 0, len1);     // zero all to init pointers to NULL
    for ( i = 0; i < argc; i++ ) {
        if ( argv_w[i] = malloc((len1 = ((len2 = strlen(argv_a[i])+1) * 2))) ) {
            memset(argv_w[i], 0, len1);
            mbstowcs(argv_w[i], argv_a[i], len2);
        } else {
            goto done;  // memory error
        }
    }

    /*
     * Alloc and form TOKMAPW array.
     */
    for ( ptmtmp_a=ptm_a, i=0;
          ptmtmp_a->tmToken != NULL;
          ptmtmp_a++, i++ );
    if ( !(ptm_w = (PTOKMAPW)malloc( (len1 = ++i * sizeof(TOKMAPW)) )) )
        goto done;  // memory error
    memset(ptm_w, 0, len1);     // zero all to init pointers to NULL
    for ( ptmtmp_w=ptm_w, ptmtmp_a=ptm_a;
          ptmtmp_a->tmToken != NULL;
          ptmtmp_w++, ptmtmp_a++ ) {

        /*
         * Allocate and convert token.
         */
        if ( ptmtmp_w->tmToken =
                malloc((len1 = ((len2 = strlen(ptmtmp_a->tmToken)+1) * 2))) ) {
            memset(ptmtmp_w->tmToken, 0, len1);
            mbstowcs(ptmtmp_w->tmToken, ptmtmp_a->tmToken, len2);
        } else {
            goto done;  // memory error
        }

        /*
         * Copy flag, form, and length (no conversion needed).
         */
        ptmtmp_w->tmFlag = ptmtmp_a->tmFlag;
        ptmtmp_w->tmForm = ptmtmp_a->tmForm;
        ptmtmp_w->tmDLen = ptmtmp_a->tmDLen;

        /*
         * Allocate or copy address if a data length was specified.
         */
        if ( ptmtmp_w->tmDLen ) {

            /*
             * Allocate new WCHAR address if we're a string type.
             * Otherwise, point to original address (no conversion needed).
             */
            if ( tmFormIsString(ptmtmp_w->tmForm) ) {

                if ( ptmtmp_w->tmAddr =
                        malloc(len1 = ptmtmp_w->tmDLen*sizeof(WCHAR)) )
                    memset(ptmtmp_w->tmAddr, 0, len1);
                else
                    goto done;  // memory error

            } else {

                ptmtmp_w->tmAddr = ptmtmp_a->tmAddr;
            }

            /*
             * For proper default behavior, zero ANSI address contents if
             * the "don't clear memory" flag is not set.
             */
            if ( !(flag & PCL_FLAG_NO_CLEAR_MEMORY) )
                memset(ptmtmp_a->tmAddr, 0, ptmtmp_a->tmDLen);
        }
    }

    /*
     * Call ParseCommandLineW
     */
    rc = ParseCommandLineW(argc, argv_w, ptm_w, flag);

    /*
     * Copy flags for each TOPMAPW element.  Also, convert to ANSI strings
     * that were present on the command line into caller's TOKMAPA array, if
     * data length was specified.
     */
    for ( ptmtmp_w=ptm_w, ptmtmp_a=ptm_a;
          ptmtmp_w->tmToken != NULL;
          ptmtmp_w++, ptmtmp_a++ ) {

        ptmtmp_a->tmFlag = ptmtmp_w->tmFlag;

        if ( ptmtmp_w->tmDLen &&
             (ptmtmp_w->tmFlag & TMFLAG_PRESENT) &&
             tmFormIsString(ptmtmp_w->tmForm) )
            wcstombs(ptmtmp_a->tmAddr, ptmtmp_w->tmAddr, ptmtmp_w->tmDLen);
    }

done:
    /*
     * Free the argvw array.
     */
    if ( argv_w ) {

        for ( i = 0; i < argc; i++ ) {
            if ( argv_w[i] )
                free(argv_w[i]);
        }
        free(argv_w);
    }

    /*
     * Free the TOKMAPW tokens, string addresses, and TOKMAK array itself.
     */
    if ( ptm_w ) {

        for ( ptmtmp_w=ptm_w; ptmtmp_w->tmToken != NULL; ptmtmp_w++ ) {

            /*
             * Free token.
             */
            free(ptmtmp_w->tmToken);

            /*
             * Free address if a data length was specified and we're a
             * string type.
             */
            if ( ptmtmp_w->tmDLen && tmFormIsString(ptmtmp_w->tmForm) )
                free(ptmtmp_w->tmAddr);
        }
        free(ptm_w);
    }

    /*
     * Return ParseCommandLineW status.
     */
    return(rc);

}  // end ParseCommandLineA


/*****************************************************************************
*
*   IsTokenPresentA (ANSI version)
*
*       Determines if a specified command line token (in given TOKMAPA array)
*       was present on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPA array to scan.
*       pToken (input)
*           The token to scan for.
*
*   EXIT:
*       TRUE if the specified token was present on the command line;
*       FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
IsTokenPresentA( PTOKMAPA ptm,
                 PCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !strcmp( ptm[i].tmToken, pToken ) )
            return( (ptm[i].tmFlag & TMFLAG_PRESENT) ? TRUE : FALSE );
    }

    return(FALSE);

}  // end IsTokenPresentA


/*****************************************************************************
*
*   SetTokenPresentA (ANSI version)
*
*       Forces a specified command line token (in given TOKMAPA array)
*       to be flagged as 'present' on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPA array to scan.
*       pToken (input)
*           The token to scan for and set flags.
*
*   EXIT:
*       TRUE if the specified token was found in the TOKMAPA array
*       (TMFLAG_PRESENT flag is set).  FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
SetTokenPresentA( PTOKMAPA ptm,
                  PCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !strcmp( ptm[i].tmToken, pToken ) ) {
            ptm[i].tmFlag |= TMFLAG_PRESENT;
            return(TRUE);
        }
    }

    return(FALSE);

}  // end SetTokenPresentA


/*****************************************************************************
*
*   SetTokenNotPresentA (ANSI Versio)
*
*       Forces a specified command line token (in given TOKMAPA array)
*       to be flagged as 'not present' on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPA array to scan.
*       pToken (input)
*           The token to scan for and set flags.
*
*   EXIT:
*       TRUE if the specified token was found in the TOKMAPA array
*       (TMFLAG_PRESENT flag is reset).  FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
SetTokenNotPresentA( PTOKMAPA ptm,
                     PCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !strcmp( ptm[i].tmToken, pToken ) ) {
            ptm[i].tmFlag &= ~TMFLAG_PRESENT;
            return(TRUE);
        }
    }

    return(FALSE);

}  // end SetTokenNotPresentA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\helpers.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  HELPERS.C
*
*  Various helper functions.
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>

#include <winstaw.h>
#include <utilsub.h>
#include <tchar.h>

#include "utilsubres.h" // resources refrenced in this file.


#define PERCENT TEXT('%')
#define NULLC TEXT('\0')
#define MAXCBMSGBUFFER 2048
TCHAR MsgBuf[MAXCBMSGBUFFER];
HANDLE NtDllHandle = NULL;

TCHAR *
mystrchr(TCHAR const *string, int c);


/* makarp, #259849
   we cannot put an rc file in this file.
   so we need to keep all the string resources referenced in this file in
   utildll.dll.
*/

/* this function returns the string resource from utildll.dll */
BOOL GetResourceStringFromUtilDll(UINT uID, LPTSTR szBuffer, int iBufferSize)
{
    HINSTANCE hUtilDll = LoadLibrary(TEXT("utildll.dll"));
    if (hUtilDll)
    {
        int iReturn = LoadString(hUtilDll, uID, szBuffer, iBufferSize);
        int iLastError = GetLastError();
        FreeLibrary( hUtilDll );

        if ( iReturn != 0 && iReturn < iBufferSize)
        {
            // we have got the string
            return TRUE;

        }
        else if (iReturn == 0)
        {
            _ftprintf( stderr, _T("GetResourceStringFromUtilDll: LoadString failed, Error %ld\n"), iLastError);
            return FALSE;
        }
        else
        {
            // we have provided insufficient buffer.
            _ftprintf(stderr, _T("GetResourceStringFromUtilDll: Insufficient buffer for resource string"));
            return FALSE;
        }

    }
    else
    {
        _ftprintf(stderr, _T("GetResourceStringFromUtilDll: LoadLibrary failed for utildll.dll, %ld"), GetLastError());
        return FALSE;
    }
}

/* this function is used internally.
 it prints an error message on stderr
 its like ErrorPrintf except it looks for
 the resource into utildll.dll
 This function accepts the  arguments in WCHAR.
*/

void ErrorOutFromResource(UINT uiStringResource, ...)
{

    WCHAR szBufferString[512];
    WCHAR szBufferMessage[1024];

    va_list args;
    va_start( args, uiStringResource);

    if (GetResourceStringFromUtilDll(uiStringResource, szBufferString, 512))
    {
        vswprintf( szBufferMessage, szBufferString, args );
        My_fwprintf( stderr, szBufferMessage);
    }
    else
    {
        fwprintf( stderr, L"ErrorOutFromResource:GetResourceStringFromUtilDll failed, Error %ld\n", GetLastError());
        PutStdErr( GetLastError(), 0 );
    }

    va_end(args);
}



int
PutMsg(unsigned int MsgNum, unsigned int NumOfArgs, va_list *arglist);

/*******************************************************************************
 *
 *  CalculateCrc16
 *
 *      Calculates a 16-bit CRC of the specified buffer.
 *
 *  ENTRY:
 *      pBuffer (input)
 *          Points to buffer to calculate CRC for.
 *      length (input)
 *          Length in bytes of the buffer.
 *
 *  EXIT:
 *      (USHORT)
 *          The 16-bit CRC of the buffer.
 *
 ******************************************************************************/

/*
 * updcrc macro derived from article Copyright (C) 1986 Stephen Satchell.
 *  NOTE: First argument must be in range 0 to 255.
 *        Second argument is referenced twice.
 *
 * Programmers may incorporate any or all code into their programs,
 * giving proper credit within the source. Publication of the
 * source routines is permitted so long as proper credit is given
 * to Stephen Satchell, Satchell Evaluations and Chuck Forsberg,
 * Omen Technology.
 */

#define updcrc(cp, crc) ( crctab[((crc >> 8) & 255)] ^ (crc << 8) ^ cp)


/* crctab calculated by Mark G. Mendel, Network Systems Corporation */
unsigned short crctab[256] = {
    0x0000,  0x1021,  0x2042,  0x3063,  0x4084,  0x50a5,  0x60c6,  0x70e7,
    0x8108,  0x9129,  0xa14a,  0xb16b,  0xc18c,  0xd1ad,  0xe1ce,  0xf1ef,
    0x1231,  0x0210,  0x3273,  0x2252,  0x52b5,  0x4294,  0x72f7,  0x62d6,
    0x9339,  0x8318,  0xb37b,  0xa35a,  0xd3bd,  0xc39c,  0xf3ff,  0xe3de,
    0x2462,  0x3443,  0x0420,  0x1401,  0x64e6,  0x74c7,  0x44a4,  0x5485,
    0xa56a,  0xb54b,  0x8528,  0x9509,  0xe5ee,  0xf5cf,  0xc5ac,  0xd58d,
    0x3653,  0x2672,  0x1611,  0x0630,  0x76d7,  0x66f6,  0x5695,  0x46b4,
    0xb75b,  0xa77a,  0x9719,  0x8738,  0xf7df,  0xe7fe,  0xd79d,  0xc7bc,
    0x48c4,  0x58e5,  0x6886,  0x78a7,  0x0840,  0x1861,  0x2802,  0x3823,
    0xc9cc,  0xd9ed,  0xe98e,  0xf9af,  0x8948,  0x9969,  0xa90a,  0xb92b,
    0x5af5,  0x4ad4,  0x7ab7,  0x6a96,  0x1a71,  0x0a50,  0x3a33,  0x2a12,
    0xdbfd,  0xcbdc,  0xfbbf,  0xeb9e,  0x9b79,  0x8b58,  0xbb3b,  0xab1a,
    0x6ca6,  0x7c87,  0x4ce4,  0x5cc5,  0x2c22,  0x3c03,  0x0c60,  0x1c41,
    0xedae,  0xfd8f,  0xcdec,  0xddcd,  0xad2a,  0xbd0b,  0x8d68,  0x9d49,
    0x7e97,  0x6eb6,  0x5ed5,  0x4ef4,  0x3e13,  0x2e32,  0x1e51,  0x0e70,
    0xff9f,  0xefbe,  0xdfdd,  0xcffc,  0xbf1b,  0xaf3a,  0x9f59,  0x8f78,
    0x9188,  0x81a9,  0xb1ca,  0xa1eb,  0xd10c,  0xc12d,  0xf14e,  0xe16f,
    0x1080,  0x00a1,  0x30c2,  0x20e3,  0x5004,  0x4025,  0x7046,  0x6067,
    0x83b9,  0x9398,  0xa3fb,  0xb3da,  0xc33d,  0xd31c,  0xe37f,  0xf35e,
    0x02b1,  0x1290,  0x22f3,  0x32d2,  0x4235,  0x5214,  0x6277,  0x7256,
    0xb5ea,  0xa5cb,  0x95a8,  0x8589,  0xf56e,  0xe54f,  0xd52c,  0xc50d,
    0x34e2,  0x24c3,  0x14a0,  0x0481,  0x7466,  0x6447,  0x5424,  0x4405,
    0xa7db,  0xb7fa,  0x8799,  0x97b8,  0xe75f,  0xf77e,  0xc71d,  0xd73c,
    0x26d3,  0x36f2,  0x0691,  0x16b0,  0x6657,  0x7676,  0x4615,  0x5634,
    0xd94c,  0xc96d,  0xf90e,  0xe92f,  0x99c8,  0x89e9,  0xb98a,  0xa9ab,
    0x5844,  0x4865,  0x7806,  0x6827,  0x18c0,  0x08e1,  0x3882,  0x28a3,
    0xcb7d,  0xdb5c,  0xeb3f,  0xfb1e,  0x8bf9,  0x9bd8,  0xabbb,  0xbb9a,
    0x4a75,  0x5a54,  0x6a37,  0x7a16,  0x0af1,  0x1ad0,  0x2ab3,  0x3a92,
    0xfd2e,  0xed0f,  0xdd6c,  0xcd4d,  0xbdaa,  0xad8b,  0x9de8,  0x8dc9,
    0x7c26,  0x6c07,  0x5c64,  0x4c45,  0x3ca2,  0x2c83,  0x1ce0,  0x0cc1,
    0xef1f,  0xff3e,  0xcf5d,  0xdf7c,  0xaf9b,  0xbfba,  0x8fd9,  0x9ff8,
    0x6e17,  0x7e36,  0x4e55,  0x5e74,  0x2e93,  0x3eb2,  0x0ed1,  0x1ef0
};

USHORT WINAPI
CalculateCrc16( PBYTE pBuffer,
                USHORT length )
{

   USHORT Crc = 0;
   USHORT Data;

   while ( length-- ) {
      Data = (USHORT) *pBuffer++;
      Crc = updcrc( Data, Crc );
   }

   return(Crc);

} /* CalculateCrc16() */


/*****************************************************************************
*
*  ExecProgram
*     Build a command line argument string and execute a program.
*
*  ENTRY:
*       pProgCall (input)
*           ptr to PROGRAMCALL structure with program to execute.
*       argc (input)
*           count of the command line arguments.
*       argv (input)
*           vector of strings containing the command line arguments.
*
*  EXIT:
*       (int)
*           0 for success; 1 for error.  An error message will have already
*           been output on error.
*
*****************************************************************************/

#define ARGS_LEN       512      // maximum # of characters on command line
                                // for CreateProcess() call.

INT WINAPI
ExecProgram( PPROGRAMCALL pProgCall,
             INT argc,
             WCHAR **argv )
{
    int count;
    WCHAR program[50];
    PWCHAR pCurrArg;
    STARTUPINFO StartInfo;
    PROCESS_INFORMATION ProcInfo;
    BOOL flag;
    DWORD Status;
    WCHAR wszFullPath[MAX_PATH]; //contains the full path name of the program
    WCHAR wszCmdLine[MAX_PATH + ARGS_LEN + 5]; //for the quoted string and NULL
    PWSTR pwstrFilePart;

    wcscpy(program, pProgCall->Program);
    //
    //Fix 330770 TS: Suspicious CreateProcess call using no program name might execute c:\program.exe	AdamO	02/28/2001
    //get the full path of the program
    //search in the same way as createprocess would
    //
    if (!SearchPath(NULL, program, NULL, MAX_PATH, wszFullPath, &pwstrFilePart)) {
        ErrorOutFromResource(IDS_TS_SYS_UTIL_NOT_FOUND, program);
        // fwprintf(stderr, L"Terminal Server System Utility %s Not Found\n", program);
        return(1);
    }

    //
    //create the command line args
    //
    wcscpy(wszCmdLine, L"\"");
    wcscat(wszCmdLine, wszFullPath);
    wcscat(wszCmdLine, L"\"");

    if (pProgCall->Args != NULL) {

        wcscat(wszCmdLine, L" ");
        
        if ( (wcslen(pProgCall->Args) + wcslen(wszCmdLine) + 3) > sizeof(wszCmdLine)) {
        // IDS_MAX_CMDLINE_EXCEEDED
            ErrorOutFromResource(IDS_MAX_CMDLINE_EXCEEDED);
            // fwprintf(stderr, L"Maximum command line length exceeded\n");
            return(1);
        }
        
        wcscat(wszCmdLine, pProgCall->Args);
    }

    for (count = 0; count < argc; count++) {

        pCurrArg = argv[count];

        if ( (int)(wcslen(pCurrArg) + wcslen(wszCmdLine) + 3) > sizeof(wszCmdLine) ) {

        // IDS_MAX_CMDLINE_EXCEEDED
            ErrorOutFromResource(IDS_MAX_CMDLINE_EXCEEDED);
            // fwprintf(stderr, L"Maximum command line length exceeded\n");
            return(1);
        }
        wcscat(wszCmdLine, L" ");
        wcscat(wszCmdLine, pCurrArg);
    }

    /*
     * Setup the NT CreateProcess parameters
     */
    memset( &StartInfo, 0, sizeof(StartInfo) );
    StartInfo.cb = sizeof(STARTUPINFO);
    StartInfo.lpReserved = NULL;
    StartInfo.lpTitle = NULL; // Use the program name
    StartInfo.dwFlags = 0;  // no extra flags
    StartInfo.cbReserved2 = 0;
    StartInfo.lpReserved2 = NULL;

    
    flag = CreateProcess(wszFullPath, // full path of the program
                   wszCmdLine, // arguments
                   NULL, // lpsaProcess
                   NULL, // lpsaThread
                   TRUE, // Allow handles to be inherited
                   0,    // No additional creation flags
                   NULL, // inherit parent environment block
                   NULL, // inherit parent directory
                   &StartInfo,
                   &ProcInfo);

    if ( !flag ) {

        Status = GetLastError();
        if(Status == ERROR_FILE_NOT_FOUND) {
            ErrorOutFromResource(IDS_TS_SYS_UTIL_NOT_FOUND, program);
            // fwprintf(stderr, L"Terminal Server System Utility %s Not Found\n", program);
            return(1);

        } else if ( Status == ERROR_INVALID_NAME ) {

        ErrorOutFromResource(IDS_BAD_INTERNAL_PROGNAME, program, wszCmdLine);
            // fwprintf(stderr, L"Bad Internal Program Name :%s:, args :%s:\n", program, wszCmdLine);
            return(1);
        }

        ErrorOutFromResource(IDS_CREATEPROCESS_FAILED, Status);
        // fwprintf(stderr, L"CreateProcess Failed, Status %u\n", Status);
        return(1);
    }

    /*
     * Wait for the process to terminate
     */
    Status =  WaitForSingleObject(ProcInfo.hProcess, INFINITE);
    if ( Status == WAIT_FAILED ) {

        Status = GetLastError();
        ErrorOutFromResource(IDS_WAITFORSINGLEOBJECT_FAILED, Status);
        // fwprintf(stderr, L"WaitForSingle Object Failed, Status %u\n", Status);
        return(1);
    }

    /*
     * Close the process and thread handles
     */
    CloseHandle(ProcInfo.hThread);
    CloseHandle(ProcInfo.hProcess);
    return(0);

} /* ExecProgram() */


/*****************************************************************************
*
*  ProgramUsage
*     Output a standard 'usage' message for the given program.
*
*  ENTRY:
*       pProgramName (input)
*           Points to string of program's name.
*       pProgramCommands (input)
*           Points to an array of PROGRAMCALL structures defining the
*           valid commands for the program.  The last element in the array
*           will contain all 0 or NULL items.
*       fError (input)
*           If TRUE, will output message with fwprintf to stderr; otherwise,
*           will output message to stdout via wprintf.
*
*  EXIT:
*
*   Only commands not flagged as 'alias' commands will be output in the
*   usage message.
*
*****************************************************************************/

VOID WINAPI
ProgramUsage( LPCWSTR pProgramName,
              PPROGRAMCALL pProgramCommands,
              BOOLEAN fError )
{
    WCHAR szUsage[83];    // 80 characters per line + newline chars & null
    PPROGRAMCALL pProg;
    BOOL bFirst;
    int i, namelen = wcslen(pProgramName);

    i = wsprintf(szUsage, L"%s {", pProgramName);
    for ( pProg = pProgramCommands->pFirst, bFirst = TRUE;
          pProg != NULL;
          pProg = pProg->pNext ) {

        if ( !pProg->fAlias ) {

            if ( (i + wcslen(pProg->Command) + (bFirst ? 1 : 3)) >= 80 ) {

                wcscat(szUsage, L"\n");

                if ( fError )
                    My_fwprintf(stderr, szUsage);
                else
                    My_wprintf(szUsage);

                bFirst = TRUE;
                for ( i=0; i < namelen; i++)
                    szUsage[i] = L' ';
            }

            i += wsprintf( &(szUsage[i]),
                           bFirst ? L" %s" : L" | %s",
                           pProg->Command );
            bFirst = FALSE;
        }
    }

    wcscat(szUsage, L" }\n");

    if ( fError )
        My_fwprintf(stderr, szUsage);
    else
        My_wprintf(szUsage);
}
/*******************************************************************************
 *  ScanPrintfString
 *      Scans a string, detects any % and double it
 *      (Use it for any string argument before calling ErrorPrintf)
 *
 *******************************************************************************/
#define PERCENTCHAR L'%'

BOOLEAN ScanPrintfString(PWCHAR pSource, PWCHAR *ppDest)
{
    ULONG i, j = 0, k = 0, n = 0;
    ULONG SourceLength, DestLength;
    PWCHAR pDest = NULL;

    if ( (pSource == 0) || (ppDest == 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    SourceLength = wcslen(pSource);
    for (i = 0; i < SourceLength; i++)
    {
        if (pSource[i] == PERCENTCHAR)
        {
            n++;
        }
    }

    if (n != 0)     // at least one %, we need to build a new string.
    {
        pDest = (PWCHAR)malloc((SourceLength + n + 1) * sizeof(WCHAR));
        *ppDest  = pDest;
        if (pDest == NULL)
        {
            return FALSE;
        }
        else
        {
            //
            // rescan and copy
            //
            for (i = 0; i < SourceLength; i++)
            {
                if (pSource[i] == PERCENTCHAR)
                {
                    if ( i > j )
                    {
                        memcpy(&(pDest[k]), &(pSource[j]), (i - j) * sizeof(WCHAR));
                        k += (i-j);
                        j = i;
                    }
                    pDest[k] = PERCENTCHAR;
                    pDest[k+1] = PERCENTCHAR;
                    k += 2;
                    j++;
                }
            }
            if (i > j)
            {
                memcpy(&(pDest[k]), &(pSource[j]), (i - j) * sizeof(WCHAR));
            }
            pDest[SourceLength + n] = L'\0';
        }
    }
    else            // OK pSource is fine; no need of a new string.
    {
        *ppDest = NULL;
    }
    return (TRUE);
}


/*******************************************************************************
 *
 *  Message
 *      Display a message to stdout with variable arguments.  Message
 *      format string comes from the application resources.
 *
 *  ENTRY:
 *      nResourceID (input)
 *          Resource ID of the format string to use in the message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID WINAPI
Message( int nResourceID, ...)
{
    WCHAR sz1[256], sz2[512];

    va_list args;
    va_start( args, nResourceID );

    if ( LoadString( NULL, nResourceID, sz1, 256 ) ) {

        vswprintf( sz2, sz1, args );
        My_wprintf( sz2 );

    } else {

        fwprintf( stderr, L"{Message(): LoadString failed, Error %ld, (0x%08X)}\n",
                  GetLastError(), GetLastError() );
    }

    va_end(args);

}  /* Message() */



/************************************************************************************
 *  StringMessage
 *      used as a pre-routine for Message in case the argument is a single string
 *      (fix for bug #334374)
 *
 ************************************************************************************/
VOID WINAPI
StringMessage(int nErrorResourceID, PWCHAR pString)
{
    PWCHAR pFixedString = NULL;
    if (ScanPrintfString(pString, &pFixedString) )
    {
        if (pFixedString != NULL)
        {
            Message(nErrorResourceID, pFixedString);
            free(pFixedString);
        }
        else
        {
            Message(nErrorResourceID, pString);
        }
    }
    else
    {
        Message(nErrorResourceID, L" ");
    }
}

/************************************************************************************
 *  StringErrorPrintf
 *      used as a pre-routine for ErrorPrintf in case the argument is a single string
 *      (fix for bug #334374)
 *
 ************************************************************************************/
VOID WINAPI
StringErrorPrintf(int nErrorResourceID, PWCHAR pString)
{
    PWCHAR pFixedString = NULL;
    if (ScanPrintfString(pString, &pFixedString) )
    {
        if (pFixedString != NULL)
        {
            ErrorPrintf(nErrorResourceID, pFixedString);
            free(pFixedString);
        }
        else
        {
            ErrorPrintf(nErrorResourceID, pString);
        }
    }
    else
    {
        ErrorPrintf(nErrorResourceID, L" ");
    }
}

/************************************************************************************
 *  StringDwordMessage
 *      used as a pre-routine for Message in case the argument are:
 *      a single string + a ulong
 *      (fix for bug #334374)
 *
 ************************************************************************************/
VOID WINAPI
StringDwordMessage(int nErrorResourceID, PWCHAR pString, DWORD Num)
{
    PWCHAR pFixedString = NULL;
    if (ScanPrintfString(pString, &pFixedString) )
    {
        if (pFixedString != NULL)
        {
            Message(nErrorResourceID, pFixedString, Num);
            free(pFixedString);
        }
        else
        {
            Message(nErrorResourceID, pString, Num);
        }
    }
    else
    {
        Message(nErrorResourceID, L" ", Num);
    }
}
/************************************************************************************
 *  DwordStringMessage
 *      used as a pre-routine for Message in case the argument are:
 *      a single string + a ulong
 *      (fix for bug #334374)
 *
 ************************************************************************************/
VOID WINAPI
DwordStringMessage(int nErrorResourceID, DWORD Num, PWCHAR pString)
{
    PWCHAR pFixedString = NULL;
    if (ScanPrintfString(pString, &pFixedString) )
    {
        if (pFixedString != NULL)
        {
            Message(nErrorResourceID, Num, pFixedString);
            free(pFixedString);
        }
        else
        {
            Message(nErrorResourceID, Num, pString);
        }
    }
    else
    {
        Message(nErrorResourceID, Num, L" ");
    }
}
/************************************************************************************
 *  StringDwordErrorPrintf
 *      used as a pre-routine for ErrorPrintf in case the argument are:
 *      a single string + a ulong
 *      (fix for bug #334374)
 *
 ************************************************************************************/
VOID WINAPI
StringDwordErrorPrintf(int nErrorResourceID, PWCHAR pString, DWORD Num)
{
    PWCHAR pFixedString = NULL;
    if (ScanPrintfString(pString, &pFixedString) )
    {
        if (pFixedString != NULL)
        {
            ErrorPrintf(nErrorResourceID, pFixedString, Num);
            free(pFixedString);
        }
        else
        {
            ErrorPrintf(nErrorResourceID, pString, Num);
        }
    }
    else
    {
        ErrorPrintf(nErrorResourceID, L" ", Num);
    }
}

/*******************************************************************************
 *
 *  ErrorPrintf
 *      Output an error message to stderr with variable arguments.  Message
 *      format string comes from the application resources.
 *
 *  ENTRY:
 *      nErrorResourceID (input)
 *          Resource ID of the format string to use in the error message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID WINAPI
ErrorPrintf( int nErrorResourceID, ...)
{

    WCHAR sz1[256], sz2[512];


    va_list args;
    va_start( args, nErrorResourceID );

    if ( LoadString( NULL, nErrorResourceID, sz1, 256 ) ) {

        vswprintf( sz2, sz1, args );
        My_fwprintf( stderr, sz2 );

    } else {

        fwprintf( stderr, L"{ErrorPrintf(): LoadString failed, Error %ld, (0x%08X)}\n",
                  GetLastError(), GetLastError() );
        PutStdErr( GetLastError(), 0 );
    }

    va_end(args);

}  /* ErrorPrintf() */


/*******************************************************************************
 *
 *  TruncateString
 *
 *  This routine truncates given string with elipsis '...' suffix, if needed.
 *
 *
 *  ENTRY:
 *     pString (input/output)
 *        pointer to string to truncate
 *     MaxLength (input)
 *        maximum length of string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID WINAPI
TruncateString( PWCHAR pString, int MaxLength )
{
    /*
     *  if string is too long, trucate it
     */
    if ( (int)wcslen(pString) > MaxLength && MaxLength > 2 ) {
        wcscpy( pString + MaxLength - 3, L"..." );
    }

}  /* TruncateString() */


/*******************************************************************************
 *
 *  EnumerateDevices
 *
 *  Perform PD device enumeration for the specified PD DLL.
 *
 *  ENTRY:
 *      pDllName (input)
 *          Pointer to DLLNAME string specifying the PD DLL to enumerate.
 *      pEntries (output)
 *          Points to variable to return number of devices that were enumerated.
 *
 *  EXIT:
 *      (PPDPARAMS) Points to a malloc()'ed PDPARAMS array containing the
 *                  enumeration results if sucessful.  The caller must perform
 *                  free of this array when done.  NULL if error.
 *
 ******************************************************************************/

/*
 * Typedefs for PdEnumerate function (from ...WINDOWS\INC\CITRIX\PDAPI.H)
 */
typedef NTSTATUS (APIENTRY * PPDENUMERATE)(PULONG, PPDPARAMS, PULONG);
#define INITIAL_ENUMERATION_COUNT   30

PPDPARAMS WINAPI
EnumerateDevices( PDLLNAME pDllName,
                  PULONG pEntries )
{
    PPDENUMERATE pPdEnumerate;
    HANDLE Handle;
    ULONG ByteCount;
    NTSTATUS Status;
    int i;
    PPDPARAMSW pPdParams = NULL;

    /*
     *  Load the specified PD DLL.
     */
    if ( (Handle = LoadLibrary(pDllName)) == NULL ) {

        ErrorOutFromResource(IDS_DEVICE_ENUM_CANT_LOAD, pDllName);

        // fwprintf(
           //  stderr,
           // L"Device enumeration failure:\n\tCan't load the %s DLL for device enumeration\n",
           // pDllName );
        goto CantLoad;
    }

    /*
     *  Get the PD enumeration function's load entry pointer.
     */
    if ( (pPdEnumerate =
          (PPDENUMERATE)GetProcAddress((HMODULE)Handle, "PdEnumerate"))
            == NULL ) {

        ErrorOutFromResource(IDS_DEVENUM_NO_ENTRY_POINT, pDllName);
        // fwprintf(
           //  stderr,
           // L"Device enumeration failure:\n\tDLL %s has no enumeration entry point\n",
           // pDllName );
        goto EnumerateMissing;
    }

    /*
     * Call enumerate in loop till we hit enough buffer entries to handle
     * a complete enumeration.
     */
    for ( i = INITIAL_ENUMERATION_COUNT; ; i *= 2 ) {


        if ( pPdParams == NULL ) {
            pPdParams =
                (PPDPARAMS)malloc(ByteCount = (sizeof(PDPARAMS) * i));
        } else {
            free(pPdParams);
            pPdParams =
                (PPDPARAMS)malloc(ByteCount = (sizeof(PDPARAMS) * i));
        }

        if ( pPdParams == NULL ) {
            ErrorOutFromResource(IDS_ERROR_MEMORY);
            // fwprintf(stderr, L"Error allocating memory\n");
            goto OutOfMemory;
        }

        /*
         * Perform enumeration and break loop if successful.
         */
        if ( (Status = (*pPdEnumerate)(pEntries, pPdParams, &ByteCount))
                == STATUS_SUCCESS )
            break;

        /*
         * If we received any other error other than 'buffer too small',
         * complain and quit.
         */
        if ( Status != STATUS_BUFFER_TOO_SMALL ) {

            ErrorOutFromResource(IDS_DEVICE_ENUM_FAILED, pDllName, Status);
            // fwprintf(
               //  stderr,
               //  L"Device enumeration failure\n\tDLL %s, Error 0x%08lX\n",
               //  pDllName, Status );
            goto BadEnumerate;
        }
    }

    /*
     * Close the DLL handle and return the PDPARAMS pointer.
     */
    CloseHandle(Handle);
    return(pPdParams);

/*-------------------------------------
 * Error cleanup and return
 */
BadEnumerate:
    free(pPdParams);
OutOfMemory:
EnumerateMissing:
    CloseHandle( Handle );
CantLoad:
    return(NULL);

}  /* EnumerateDevices() */


/******************************************************************************
 *
 *  wfopen
 *
 *  UNICODE version of fopen
 *
 *  ENTRY:
 *    filename (input)
 *       UNICODE filename to open.
 *    mode (input)
 *       UNICODE file open mode string.
 *
 *  EXIT:
 *      Pointer to FILE or NULL if open error.
 *
 *****************************************************************************/

FILE * WINAPI
wfopen( LPCWSTR filename, LPCWSTR mode )
{
    PCHAR FileBuf, ModeBuf;
    FILE *pFile;

    if ( !(FileBuf = (PCHAR)malloc((wcslen(filename)+1) * sizeof(CHAR))) )
        goto BadFileBufAlloc;

    if ( !(ModeBuf = (PCHAR)malloc((wcslen(mode)+1) * sizeof(CHAR))) )
        goto BadModeBufAlloc;

    /*
     * Convert UNICODE strings to ANSI and call ANSI fopen.
     */
    wcstombs(FileBuf, filename, wcslen(filename)+1);
    wcstombs(ModeBuf, mode, wcslen(mode)+1);
    pFile = fopen(FileBuf, ModeBuf);

    /*
     * Clean up and return
     */
    free(FileBuf);
    free(ModeBuf);
    return(pFile);

/*-------------------------------------
 * Error cleanup and return
 */
BadModeBufAlloc:
    free(FileBuf);
BadFileBufAlloc:
    return(NULL);

}  /* wfopen() */


/******************************************************************************
 *
 *  wfgets
 *
 *  UNICODE version of fgets
 *
 *  ENTRY:
 *    Buffer (output)
 *       Buffer to place string retreived from stream
 *    Len (input)
 *       Maximum number of WCHARs in buffer.
 *    Stream (input)
 *       STDIO file stream for input
 *
 *  EXIT:
 *      Pointer to Buffer or NULL.
 *
 *****************************************************************************/

PWCHAR WINAPI
wfgets( PWCHAR Buffer, int Len, FILE *Stream )
{
    PCHAR AnsiBuf, pRet;
    int count;

    if ( !(AnsiBuf = (PCHAR)malloc(Len * sizeof(CHAR))) )
        goto BadAnsiBufAlloc;

    /*
     * Get the ANSI version of the string from the stream
     */
    if ( !(pRet = fgets(AnsiBuf, Len, Stream)) )
        goto NullFgets;

    /*
     * Convert to UNICODE string in user's buffer.
     */
    count = mbstowcs(Buffer, AnsiBuf, strlen(AnsiBuf)+1);

    /*
     * Clean up and return
     */
    free(AnsiBuf);
    return(Buffer);

/*-------------------------------------
 * Error cleanup and return
 */
NullFgets:
    free(AnsiBuf);
BadAnsiBufAlloc:
    return(NULL);

}  /* wfgets() */




/***    PutStdErr - Print a message to STDERR
 *
 *  Purpose:
 *      Calls PutMsg sending STDERR as the handle to which the message
 *      will be written.
 *
 *  int PutStdErr(unsigned MsgNum, unsigned NumOfArgs, ...)
 *
 *  Args:
 *      MsgNum          - the number of the message to print
 *      NumOfArgs       - the number of total arguments
 *      ...             - the additonal arguments for the message
 *
 *  Returns:
 *      Return value from PutMsg()                      M026
 *
 */

int WINAPI
PutStdErr(unsigned int MsgNum, unsigned int NumOfArgs, ...)
{
        int Result;

        va_list arglist;

        va_start(arglist, NumOfArgs);
        Result = PutMsg(MsgNum, NumOfArgs, &arglist);
        va_end(arglist);
        return Result;
}


int
FindMsg(unsigned MsgNum, PTCHAR NullArg, unsigned NumOfArgs, va_list *arglist)
{
    unsigned msglen;
    DWORD msgsource;
    TCHAR *Inserts[ 2 ];
    CHAR numbuf[ 32 ];
    TCHAR   wnumbuf[ 32 ];

    //
    // find message without doing argument substitution
    //

    if (MsgNum == ERROR_MR_MID_NOT_FOUND) {
        msglen = 0;
    }
    else {
#ifdef LATER
        msgsource = MsgNum >= IDS_ERROR_MALLOC ?
                       FORMAT_MESSAGE_FROM_HMODULE :
                       FORMAT_MESSAGE_FROM_SYSTEM;
#endif
        msgsource = FORMAT_MESSAGE_FROM_SYSTEM;
        msglen = FormatMessage(msgsource | FORMAT_MESSAGE_IGNORE_INSERTS,
                               NULL,
                               MsgNum,
                               0,
                               MsgBuf,
                               MAXCBMSGBUFFER,
                               NULL
                             );
        if (msglen == 0) {
            if (NtDllHandle == NULL) {
                NtDllHandle = GetModuleHandle( TEXT("NTDLL") );
            }
            msgsource = FORMAT_MESSAGE_FROM_HMODULE;
            msglen = FormatMessage(msgsource | FORMAT_MESSAGE_IGNORE_INSERTS,
                                   (LPVOID)NtDllHandle,
                                   MsgNum,
                                   0,
                                   MsgBuf,
                                   MAXCBMSGBUFFER,
                                   NULL
                                 );
        }
    }

    if (msglen == 0) {
        //
        // didn't find message
        //
        msgsource = FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY;
        _ultoa( MsgNum, numbuf, 16 );
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, numbuf, -1, wnumbuf, 32);
        Inserts[ 0 ]= wnumbuf;
#ifdef LATER
        Inserts[ 1 ]= (MsgNum >= IDS_ERROR_MALLOC ? TEXT("Application") : TEXT("System"));
#endif
        Inserts[ 1 ]= TEXT("System");
        MsgNum = ERROR_MR_MID_NOT_FOUND;
        msglen = FormatMessage(msgsource,
                               NULL,
                               MsgNum,
                               0,
                               MsgBuf,
                               MAXCBMSGBUFFER,
                               (va_list *)Inserts
                             );
    }
    else {

        // see how many arguments are expected and make sure we have enough

        PTCHAR tmp;
        ULONG count;

        tmp=MsgBuf;
        count = 0;
        while (tmp = mystrchr(tmp, PERCENT)) {
            tmp++;
            if (*tmp >= TEXT('1') && *tmp <= TEXT('9')) {
                count += 1;
            }
            else if (*tmp == PERCENT) {
                tmp++;
            }
        }
        if (count > NumOfArgs) {
            PTCHAR *LocalArgList;
            ULONG i;

            LocalArgList = (PTCHAR*)malloc(sizeof(PTCHAR) * count);

            if( LocalArgList == NULL )
            {
                msglen = 0;
            }
            else
            {
                for (i=0; i<count; i++)
                {
                    if (i < NumOfArgs)
                    {
                        LocalArgList[i] = (PTCHAR)(ULONG_PTR)va_arg( *arglist, ULONG );
                    }
                    else
                    {
                        LocalArgList[i] = NullArg;
                    }
                }
                msglen = FormatMessage(msgsource | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                       NULL,
                                       MsgNum,
                                       0,
                                       MsgBuf,
                                       MAXCBMSGBUFFER,
                                       (va_list *)LocalArgList
                                     );
                free(LocalArgList);
            }
        }
        else {
            msglen = FormatMessage(msgsource,
                                   NULL,
                                   MsgNum,
                                   0,
                                   MsgBuf,
                                   MAXCBMSGBUFFER,
                                   arglist
                                 );
        }
    }
    return msglen;
}

/***    PutMsg - Print a message to a handle
 *
 *   Purpose:
 *      PutMsg is the work routine which interfaces command.com with the
 *      DOS message retriever.  This routine is called by PutStdOut and
 *      PutStdErr.
 *
 *  int PutMsg(unsigned MsgNum, unsigned Handle, unsigned NumOfArgs, ...)
 *
 *  Args:
 *      MsgNum          - the number of the message to print
 *      NumOfArgs       - the number of total arguments
 *      Handle          - the handle to print to
 *      Arg1 [Arg2...]  - the additonal arguments for the message
 *
 *  Returns:
 *      Return value from DOSPUTMESSAGE                 M026
 *
 *  Notes:
 *    - PutMsg builds an argument table which is passed to DOSGETMESSAGE;
 *      this table contains the variable information which the DOS routine
 *      inserts into the message.
 *    - If more than one Arg is sent into PutMsg, it (or they)  are taken
 *      from the stack in the first for loop.
 *    - M020 MsgBuf is a static array of 2K length.  It is temporary and
 *      will be replaced by a more efficient method when decided upon.
 *
 */

int
PutMsg(unsigned int MsgNum, unsigned int NumOfArgs, va_list *arglist)
{
        unsigned msglen;
    PTCHAR   NullArg = TEXT(" ");
    WCHAR    szErrorNo[256];

    if (GetResourceStringFromUtilDll(IDS_ERROR_NUMBER, szErrorNo, 256))
    {
        fwprintf( stderr, szErrorNo, MsgNum );
    }

    msglen = FindMsg(MsgNum,NullArg,NumOfArgs,arglist);
    My_fwprintf( stderr, MsgBuf );

    return NO_ERROR;
}


 /***
 * mystrchr(string, c) - search a string for a character
 *
 * mystrchr will search through string and return a pointer to the first
 * occurance of the character c. This version of mystrchr knows about
 * double byte characters. Note that c must be a single byte character.
 *
 */

TCHAR *
mystrchr(TCHAR const *string, int c)
{

        /* handle null seperatly to make main loop easier to code */
        if (string == NULL)
            return(NULL);

        if (c == NULLC)
        return((TCHAR *)(string + wcslen(string)));

    return wcschr( string, (TCHAR)c );
}



 /***
 * My_wprintf(format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW.
 * Note: This My_wprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
My_wprintf(
    const wchar_t *format,
    ...
    )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = My_vfwprintf(stdout, format, args);

    va_end(args);

    return cchWChar;
}



 /***
 * My_fwprintf(stream, format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW.
 * Note: This My_fwprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = My_vfwprintf(str, format, args);

    va_end(args);

    return cchWChar;
}


int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   )

{
    HANDLE hOut;

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    if ((GetFileType(hOut) & ~FILE_TYPE_REMOTE) == FILE_TYPE_CHAR) {
        DWORD  cchWChar;
        WCHAR  szBufferMessage[1024];

        vswprintf( szBufferMessage, format, argptr );
        cchWChar = wcslen(szBufferMessage);
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
        return cchWChar;
    }

    return vfwprintf(str, format, argptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\printfoa.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
// File: PRINTFOA.C
//
//============================================================================

// Include Files:
//===============

#include <printfoa.h>

// Extern Data:												
//=============


// Global Data:
//=============


// Function Prototypes:
//=====================


// Code:
//======


#undef printf
#undef wprintf

// Function: int ANSI2OEM_Printf(const char *format, ...)
//=======================================================
//
// Desc:  Takes ANSI code page characters and prints them out 
//			in OEM code page
//
// Input: 
//
// Return:
//
// Misc: 
//
//=======================================================
int ANSI2OEM_Printf(const char *format, ...)
{
    va_list arg_marker;
    char buffer[256];
	WCHAR uniBuffer[256];

	// sprintf the buffer
    va_start(arg_marker, format);
    vsprintf(buffer, format, arg_marker);
	va_end(arg_marker);

    if (GetACP() == GetOEMCP()) {
        // In case of Far East, ACP and OEMCP are equal, then return.
        return printf(buffer);
    }

	// clear it out
	memset(uniBuffer, 0, sizeof(uniBuffer));

	// convert it to unicode
	MultiByteToWideChar(CP_ACP, 0, buffer, strlen(buffer), uniBuffer, 
                        sizeof(uniBuffer) / sizeof(WCHAR));

	// change the code page of the buffer
	CharToOemW(uniBuffer, buffer);

	// do the actual printf
    return printf(buffer);
}
// end - int ANSI2OEM_Printf(const char *format, ...)


// Function: int ANSI2OEM_Wprintf(const wchar_t *format, ...)
//=======================================================
//
// Desc: Takes ANSI code page characters and prints them out 
//			in OEM code page
//
// Input: 
//
// Return:
//
// Misc: 
//
//=======================================================
int ANSI2OEM_Wprintf(const wchar_t *format, ...)
{
	va_list arg_marker;
    wchar_t buffer[256];
	char oemBuffer[256];

	// do the sprintf
    va_start(arg_marker, format);
    wvsprintf(buffer, format, arg_marker);
	va_end(arg_marker);

    if (GetACP() == GetOEMCP()) {
        // In case of Far East, ACP and OEMCP are equal, then return.
        return wprintf(buffer);
    }

	// clear the buffer
	memset(oemBuffer, 0, sizeof(oemBuffer));
	
	// change the code page	of the buffer (this function outputs ascii)
	CharToOemW(buffer, oemBuffer);

    return printf(oemBuffer);
} 
// end - int ANSI2OEM_Wprintf(const wchar_t *format, ...)


// Function: void OEM2ANSIW(WCHAR *buffer, USHORT len)
//=======================================================
//
// Desc: converts wide characters from the OEM code page to 
//			ANSI
//
// Input: 
//
// Return:
//
// Misc: 
//
//=======================================================
void OEM2ANSIW(WCHAR *buffer, USHORT len)
{
    int     BufferNeeded;
    char    *temp = NULL;
    WCHAR   *cvt;

    if (GetACP() == GetOEMCP()) {
        // In case of Far East, ACP and OEMCP are equal, then return.
        return;
    }

	// allocate a wide character buffer
	cvt = (WCHAR *) LocalAlloc( 0, (len+1) * sizeof(WCHAR) );

	if (cvt) {

        // determine the buffer size needed for the multi byte string
        BufferNeeded = WideCharToMultiByte(CP_OEMCP, 0, buffer, len, NULL, 0,
            NULL, NULL);

        // allocate the temporary buffer
        temp = (char *)LocalAlloc(0, BufferNeeded+1);

        if (temp) {

    		// clear them out
    		memset(temp, 0, BufferNeeded+1);
    		memset(cvt, 0, (len + 1) * sizeof(WCHAR));

    		// convert the incoming wide buffer to a multi byte buffer
		    WideCharToMultiByte(CP_OEMCP, 0, buffer, len, temp, BufferNeeded+1,
                NULL, NULL);

    		// convert the oem multi byte buffer to ansi (wide)
    		OemToCharW(temp, cvt);

    		// copy the buffer onto the orginal
    		wcscpy(buffer, cvt);
        }
	} 

	// clean up
	if (cvt)
		LocalFree(cvt);

	if (temp)
		LocalFree(temp); 
}
// end - void OEM2ANSIW(WCHAR *buffer, USHORT len)

// Function: void OEM2ANSIA(char *buffer, USHORT len)
//=======================================================
//
// Desc: converts ascii characters from the OEM code page to 
//			ANSI
//
// Input: 
//
// Return:
//
// Misc: 
//
//=======================================================
void OEM2ANSIA(char *buffer, USHORT len)
{
    WCHAR *temp;

    if (GetACP() == GetOEMCP()) {
        // In case of Far East, ACP and OEMCP are equal, then return.
        return;
    }

	temp = (WCHAR *) LocalAlloc(9, (len+1) * sizeof(WCHAR));

	if (temp) {

		// set the buffer
		memset(temp, 0, (len+1) * sizeof(WCHAR));

		// convert the oem multi byte buffer to ansi (wide)
		OemToCharW(buffer, temp);

		// convert from wide back to multi byte
		WideCharToMultiByte(CP_OEMCP, 0, temp, wcslen(temp), buffer, len+1, NULL, NULL);

		// clean up
		LocalFree(temp);
	} 

}
// end - void OEM2ANSIA(char *buffer, USHORT len)



// - end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\setargv.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*******************************************************************************
*
*   SETARGV.C (ANSI argc, argv routines)
*
*   argc / argv routines
*
*
******************************************************************************/

/*
 * Include files
 */
#include <windows.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
 * ANSI ARGS structure and other stuff (private).
 */
#include "setargv.h"

/*
 * Local function prototypes.
 */
void args_init(ARGS *);
int add_arg_to_list(char *, ARGS *);
int args_trunc(ARGS *);

/*
 * setargv()
 *
 *    Forms a standard C-runtime argc, argv parsed command line.
 *
 *  ENTRY:
 *      szModuleName (input)
 *          Optional Windows module name.  If not NULL, will be added as first
 *          parsed argument (argv[0], argc=1).
 *      szCmdLine (input)
 *          Points to command line to parse into argc, argv
 *      argc (output)
 *          Points to int to save argument count into on exit.
 *      argv (output)
 *          Points to (char **) to save argv array into on exit.
 *
 *  RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_xxx code if not ok.
 *
 *    A typical use of this routine is by a Windows UI application to 
 *    convert a command line into the C argc & argv variables prior to calling 
 *    the utilsub.lib ParseCommandLine() function.  Therefore, a companion 
 *    routine, freeargv(), allows for alloc'd memory to be freed by the caller 
 *    after use, if desired.
 *
 */
int WINAPI
setargv( LPSTR szModuleName, 
         LPSTR szCmdLine, 
         int *argc, 
         char ***argv )
{
    int rc;
   char *cp;
   char FAR *cfp = szCmdLine;
   char ch, fname[_MAX_PATH];
   ARGS arg_data;

   /*
    * Initialize arg_data
    */
   args_init( &arg_data );

   /*
    * If present, add module name as argv[0].
    */
   if ( szModuleName ) {
      if ( (rc = add_arg_to_list( szModuleName, &arg_data )) != ERROR_SUCCESS )
         goto setargv_error;
   }

   /*
    * Skip leading blanks/tabs of remaining args
    */
   cp = fname;
   /* skip consecutive blanks and/or tabs */
   while ( (ch = *cfp) == ' ' || ch == '\t' )
      cfp++;

   /*
    * Process remainder of command line
    */
   while ( ch = *cfp++ ) {

      /*
       * Process quoted strings.
       */
      if ( ch == '"' ) {
         while ( (ch = *cfp++) && ch != '"' )
            *cp++ = ch;
         if ( ch == '\0' )
            cfp--;

      /*
       * If we find a delimeter, process the pathname we just scanned.
       */
      } else if ( ch == ' ' || ch == '\t') {
         *cp = '\0';
         if ( (rc = add_arg_to_list( fname, &arg_data )) != ERROR_SUCCESS )
            goto setargv_error;

         cp = fname;
         /* skip consecutive blanks and/or tabs */
         while ( (ch = *cfp) == ' ' || ch == '\t')
	    cfp++;

      /*
       * All other chars, just copy to internal buffer.
       */
      } else {
         *cp++ = ch;
      }
   }
   if ( cp != fname ) {
      *cp = '\0';
      if ( (rc = add_arg_to_list( fname, &arg_data )) != ERROR_SUCCESS )
        goto setargv_error;
   }

   if ( (rc = args_trunc( &arg_data )) != ERROR_SUCCESS )
       goto setargv_error;

   /*
    * Initialize global variables __argc and __argv
    */
   *argc = arg_data.argc;
   *argv = arg_data.argv;

   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
setargv_error:
    return(rc);
}


/*
 * freeargv()
 *
 *    Frees up the memory alloc'd for argv strings and argv
 *    array itself.
 *
 *    ENTER:
 *       argv = argv array as created by this setargv() routine.
 *
 */
void WINAPI
freeargv( char **argv )
{
    free(*argv);
    free(argv);
}


/*
 * args_init()
 *
 *    Initialize the ARGS struct passed as an argument.
 *
 *    ENTER:
 *       argp = pointer to ARGS struct
 *
 */
static void
args_init( ARGS *argp )
{

   argp->argc = 0;
   argp->argv = NULL;
   argp->argvlen = 0;
   argp->argvp = NULL;
   argp->buflen = 0;
   argp->buf = argp->bufptr = argp->bufend = NULL;
}


/*
 * add_arg_to_list()
 *
 *    This routine adds the specified argument string to the argv array,
 *    and increments the argv pointer and argc counter.
 *    If necessary, memory for the argument string is allocated.
 *
 *    RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_NOT_ENOUGH_MEMORY if not.
 *
 */
static int
add_arg_to_list( char *arg_string,
                 ARGS *argp )
{
   int len;

#ifdef notdef
   printf( "add_arg_to_list: arg_string=%s:, argc=%d, argvp=%x",
           arg_string,argp->argc,argp->argvp );
#endif

   /*
    * Verify we have an argv array buffer.
    * If we have one but it is full, expand the array.
    * If we can't alloc/realloc the array, return an error.
    */
   if ( !argp->argv ) {
      argp->argvlen = MIN_ARG_ALLOC;
      argp->argc = 0;
      argp->argv = malloc( argp->argvlen * sizeof( char *) );
      argp->argvp = argp->argv;
   } else if ( argp->argc + 1 >= argp->argvlen ) {
      argp->argvlen += MIN_ARG_ALLOC;
      argp->argv = realloc( argp->argv, argp->argvlen * sizeof(char *) );
      argp->argvp = argp->argv + argp->argc;
   }
   if ( !argp->argv ) {
#ifdef notdef
      printf("add_arg_to_list: failed to (re)alloc argv buf\n");
#endif
      goto add_arg_to_list_error;
   }

   /*
    * Verify we have a string buffer to store the argument string.
    * If we have one but there is not room for the new arg, expand the
    * buffer.  If we can't alloc/realloc the buffer, return an error.
    */
   len = strlen( arg_string ) + 1;
   if ( !argp->buf ) {
      argp->buflen = MIN_BUF_ALLOC;
      while ( argp->buflen < len )
	 argp->buflen += MIN_BUF_ALLOC;
      argp->buf = malloc( argp->buflen );
      argp->bufptr = argp->buf;
      argp->bufend = argp->buf + argp->buflen - 1;

   } else if ( argp->bufptr + len > argp->bufend ) {
      char *old_buf;
      int buf_offset = argp->bufptr - argp->buf;
      while ( argp->buflen < buf_offset + len )
         argp->buflen += MIN_BUF_ALLOC;
      old_buf = argp->buf;
      argp->buf = realloc( argp->buf, argp->buflen );
      argp->bufend = argp->buf + argp->buflen - 1;
      argp->bufptr = argp->buf + buf_offset;

      /*
       * If the argument string buffer moved, then we need to relocate the
       * argv pointers in the argv array to point to the new string locations.
       */
      if ( argp->buf != old_buf ) {
	 char *buf_ptr, **argv_ptr;
	 argv_ptr = argp->argv;
	 buf_ptr = argp->buf;
	 while ( buf_ptr != argp->bufptr ) {
	    *argv_ptr++ = buf_ptr;
	    buf_ptr += strlen( buf_ptr ) + 1;
	 }
      }
   }
   if ( !argp->buf ) {
#ifdef notdef
      printf("add_arg_to_list: failed to (re)alloc string buf\n");
#endif
      goto add_arg_to_list_error;
   }

   /*
    * Add the new argument to the buffer and the argv array.
    * Increment the arg count, the argv pointer, and the buffer pointer.
    */
   strcpy( argp->bufptr, arg_string );
   *(argp->argvp) = argp->bufptr;
   argp->bufptr += len;
   ++argp->argc;
   ++argp->argvp;
   *(argp->argvp) = NULL;
   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
add_arg_to_list_error:
    return(ERROR_NOT_ENOUGH_MEMORY);
}


/*
 * args_trunc()
 *
 *    Truncate the memory used by the ARGS struct
 *    so that unused memory is freed.
 *
 *    ENTER:
 *       argp = pointer to ARGS struct
 *
 *    RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_NOT_ENOUGH_MEMORY code if not ok.
 *
 */
static int
args_trunc( ARGS *argp )
{
   char *old_buf;

   /*
    * call realloc to shrink size of argv array, set argvlen = argc
    * to indicate no more room in argv array.
    */
   argp->argvlen = argp->argc + 1;
   argp->argv = realloc( argp->argv, argp->argvlen * sizeof(char *) );
   if ( !argp->argv )
      goto args_trunc_error;
   argp->argvp = argp->argv + argp->argc;

   /*
    * call realloc to shrink size of argument string buffer, set bufend
    * pointer to end of buffer to indicate buf is full.
    */
   old_buf = argp->buf;
   argp->buflen = argp->bufptr - argp->buf;
   argp->buf = realloc( argp->buf, argp->buflen );
   if ( !argp->buf )
      goto args_trunc_error;
   argp->bufptr = argp->buf + argp->buflen;
   argp->bufend = argp->buf + argp->buflen - 1;

   /*
    * If the argument string buffer moved, then we need to relocate the
    * argv pointers in the argv array to point to the new string locations.
    */
   if ( old_buf != argp->buf ) {
      char *buf_ptr, **argv_ptr;

      argv_ptr = argp->argv;
      buf_ptr = argp->buf;
      while ( buf_ptr != argp->bufptr ) {
         *argv_ptr++ = buf_ptr;
	 buf_ptr += strlen( buf_ptr ) + 1;
      }
   }

   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
args_trunc_error:
   return(ERROR_NOT_ENOUGH_MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\procutil.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  PROCUTIL.C
*
*  Various useful utilities for dealing with processes
*  that are useful across a range of utilities and apps.
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <process.h>
#include <string.h>
#include <malloc.h>

#include <winstaw.h>
#include <utilsub.h>

// from helpers.c
BOOL GetResourceStringFromUtilDll(UINT uID, LPTSTR szBuffer, int iBufferSize);
void ErrorOutFromResource(UINT uiStringResource, ...);

#include "utilsubres.h" // resources refrenced in this file.
        

/*
 * Local function prototypes.
 */
VOID LookupSidUser( PSID pSid, PWCHAR pUserName, PULONG pcbUserName );

/*
 * RefreshProcessObjectCaches()
 *
 *  Refresh (invalidate) any caches that may be used by process object
 *  utilities.
 *
 * This is currently a place holder, but is here so that utilities can call
 * it, thus being isolated from any future decisions to add caching.
 */
VOID WINAPI
RefreshProcessObjectCaches()
{
    RefreshUserSidCrcCache();
}

/******************************************************************************
 *
 * ProcessObjectMatch
 *
 * General Name match function against a process.
 *
 * The multi-user admin utilities can take a user name, winstation name,
 * a winstation id, or process id as an argument to a command that targets
 * a process for some action (query status, kill, etc.)
 *
 * This function does general compares of the supplied name to see if it
 * applies to the given process because the name represents the NT user
 * account, a winstations system name, the winstations unique id, or the
 * processes unique id.
 *
 * The various information about a process is supplied by the caller. Because
 * of the way processes are enumerated from the NT system, it is easier
 * and faster for the caller to supply this information than for the routine
 * to retrieve it itself. This could be folded into a general EnumerateProcess()
 * if needed. Currently this routine serves the purpose of having one unified
 * way of handling process objects across all utilities.
 *
 *
 * Matching:
 *
 *  An integer number is assumed to be an NT process ID unless NumberIsLogonId
 *  is set, which then says to treat it as a LogonId.
 *
 *  A name starting with a character is tested first as a winstation name, then
 *  as a user name, finally as a program image name.  A user or group name
 *  could stand alone, or be preceded by a '\' to be [somewhat] compatible
 *  with the OS/2 product.
 *
 * Parameters:
 *
 *  Pid (input)
 *      Windows NT unique process identifier
 *  LogonId (input)
 *      Logon (also called Session) ID the process is executing on.
 *  NumberIsLogonId (input)
 *      Treat a number in pMatchName as a LogonId not an PID number.
 *  pMatchName (input)
 *      Name for match testing
 *  pWinStationName (input)
 *      Name of WinStation for process.
 *  pUserName (input)
 *      Name of User for process.
 *  pImageName (input)
 *      Image name of executing program for process.
 *
 *****************************************************************************/

BOOLEAN WINAPI
ProcessObjectMatch( HANDLE Pid,
                    ULONG LogonId,
                    int NumberIsLogonId,
                    PWCHAR pMatchName,
                    PWCHAR pWinStationName,
                    PWCHAR pUserName,
                    PWCHAR pImageName )
{
    ULONG tmp;
    HANDLE htmp;

    /*
     * Check for wild card
     */
    if( pMatchName[0] == L'*' ) return( TRUE );

    /*
     * If someone puts a '\' in front of pMatchName, strip it off
     */
    if( pMatchName[0] == L'\\' ) pMatchName++;

    /*
     * First, if the match name is a number, check for == to process ID or
     * LogonId.
     */
    if( iswdigit( pMatchName[0] ) ) {
        tmp = wcstol( pMatchName, NULL, 10 );
        htmp = LongToPtr (tmp);

            if( NumberIsLogonId && (tmp == LogonId) )
            return( TRUE );
            else if( htmp == Pid )
                return( TRUE );
        else
                return( FALSE );
    }

    /*
     * Then, check the match name against the WinStation Name of the process.
     */
    if ( !_wcsicmp( pWinStationName, pMatchName ) ) {
        return( TRUE );
    }

    /*
     * Then, check the match name against the UserName of the process.
     */
    if( !_wcsicmp( pUserName, pMatchName ) ) {
        return( TRUE );
    }

    /*
     * Finally, check the match name against the image name of the process.
     */
    if( !_wcsicmp( pImageName, pMatchName ) ) {
        return(TRUE);
    }

    return( FALSE );
}


/*
 * This is the cache maintained by the GetUserNameFromSid function
 *
 * It is thread safe through the use of ULock.
 */

typedef struct TAGUSERSIDLIST {
    struct TAGUSERSIDLIST *Next;
    USHORT SidCrc;
    WCHAR UserName[USERNAME_LENGTH];
} USERSIDLIST, *PUSERSIDLIST;

static PUSERSIDLIST pUList = NULL;
static RTL_CRITICAL_SECTION ULock;
static BOOLEAN ULockInited = FALSE;

/***************************************************************************
 *
 *  InitULock
 *
 *  Since we do not require the user to call an initialize function,
 *  we must initialize our critical section in a thread safe manner.
 *
 *  The problem is, a critical section is needed to guard against multiple
 *  threads trying to init the critical section at the same time.
 *
 *  The solution that Nt uses, in which RtlInitializeCriticalSection itself
 *  uses, is to wait on a kernel supported process wide Mutant before proceding.
 *  This Mutant almost works by itself, but RtlInitializeCriticalSection does
 *  not wait on it until after trashing the semaphore count. So we wait on
 *  it ourselves, since it can be acquired recursively.
 *
 ***************************************************************************/
NTSTATUS InitULock()
{
    NTSTATUS status = STATUS_SUCCESS;

    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    /*
     * Make sure another thread did not beat us here
     */
    if( ULockInited == FALSE ){
       status = RtlInitializeCriticalSection( &ULock );
       if (status == STATUS_SUCCESS) {
           ULockInited = TRUE;
       }
    }

    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    return status;
}


/***************************************************************************
 *
 * RefreshUserSidCrcCache
 *
 *  Invalidate the User/SidCrc cache so that the newest information
 *  will be fetched from the system.
 *
 ***************************************************************************/

VOID WINAPI
RefreshUserSidCrcCache( )
{
    NTSTATUS status = STATUS_SUCCESS;
    PUSERSIDLIST pEntry, pNext;

    if( pUList == NULL ) return;

    /*
     * Make sure critical section has been inited
     */
    if( !ULockInited ) {
       status = InitULock();
    }

    if (status == STATUS_SUCCESS) {
        RtlEnterCriticalSection( &ULock );

        pEntry = pUList;

        while( pEntry ) {
           pNext = pEntry->Next;
           free( pEntry );
           pEntry = pNext;
        }

        pUList = NULL;

        RtlLeaveCriticalSection( &ULock );
    }
}


/******************************************************************************
 *
 * GetUserNameFromSid
 *
 *  Attempts to retrieve the user (login) name of the process by first looking
 *  in our User/SidCrc cache table, then (if no match) looking up the SID in
 *  the SAM database and adding the new entry to the User/SidCrc table.
 *
 *  Input
 *
 *   IN pUserSid   Sid pointer
 *
 *   OUT NameBuf   WCHAR pointer to buffer for name
 *
 *   IN/OUT  pBufSize   PULONG NameBuf size
 *
 *  Will always return a user name, which will be "(unknown)" if the SID is
 *  invalid or can't determine the user/SID relationship for any other reason.
 *
 *****************************************************************************/

VOID WINAPI
GetUserNameFromSid( PSID pUserSid, PWCHAR pBuffer, PULONG pcbBuffer )
{
    NTSTATUS status = STATUS_SUCCESS;
    USHORT SidCrc = 0;
    PUSERSIDLIST pEntry;

    /*
     * Make sure critical section has been inited
     */
    if( !ULockInited ) {
       status = InitULock();
    }

    /*
     * Determine SID length in bytes and calculate a 16-bit CRC for it,
     * to facilitate quick matching.
     */
    if ( pUserSid )
        SidCrc = CalculateCrc16( (PBYTE)pUserSid,
                                 (USHORT)GetLengthSid(pUserSid) );

    /*
     * First: Before performing the expensive LookupAccountSid() function,
     * see if we've encountered this SID already, and match the user name
     * if so.
     */
    if ( status == STATUS_SUCCESS && pUList ) {

        RtlEnterCriticalSection( &ULock );

        pEntry = pUList;

        while( pEntry ) {

            if ( SidCrc == pEntry->SidCrc ) {

                wcsncpy( pBuffer, pEntry->UserName, (*pcbBuffer)-1 );
                pBuffer[(*pcbBuffer)-1] = 0;
                *pcbBuffer = wcslen(pBuffer);
                RtlLeaveCriticalSection( &ULock );
                return;
            }
            pEntry = pEntry->Next;
        }

        RtlLeaveCriticalSection( &ULock );
    }

    /*
     * Last resort: Determine the user name associated with the SID using
     * the LookupAccountSid() API, embedded in our local function
     * LookupSidUser().
     */
    LookupSidUser( pUserSid, pBuffer, pcbBuffer );

    /*
     * Add this new User/Sid relationship in our User/Sid cache list.
     */
    if (status == STATUS_SUCCESS) {
        RtlEnterCriticalSection( &ULock );

        if ( (pEntry = (PUSERSIDLIST)malloc(sizeof(USERSIDLIST))) ) {

            pEntry->SidCrc = SidCrc;
            wcsncpy( pEntry->UserName, pBuffer, USERNAME_LENGTH - 1 );
            pEntry->UserName[USERNAME_LENGTH-1] = 0;
            pEntry->Next = pUList;
            pUList = pEntry;
        }

        RtlLeaveCriticalSection( &ULock );
    }
}


/******************************************************************************
 * LookupSidUser
 *
 *      Fetch the user name associated with the specified SID.
 *
 *  ENTRY:
 *      pSid (input)
 *          Points to SID to match to user name.
 *      pUserName (output)
 *          Points to buffer to place the user name into.
 *      pcbUserName (input/output)
 *          Specifies the size in bytes of the user name buffer.  The returned
 *          user name will be truncated to fit this buffer (including NUL
 *          terminator) if necessary and this variable set to the number of
 *          characters copied to pUserName.
 *
 *  EXIT:
 *
 *      LookupSidUser() will always return a user name.  If the specified
 *      SID fails to match to a user name, then the user name "(unknown)" will
 *      be returned.
 *
 *****************************************************************************/

VOID
LookupSidUser( PSID pSid,
               PWCHAR pUserName,
               PULONG pcbUserName )
{
    WCHAR DomainBuffer[DOMAIN_LENGTH], UserBuffer[USERNAME_LENGTH];
    DWORD cbDomainBuffer=sizeof(DomainBuffer), cbUserBuffer=sizeof(UserBuffer),
          Error;
    PWCHAR pDomainBuffer = NULL, pUserBuffer = NULL;
    SID_NAME_USE SidNameUse;

    /*
     * Fetch user name from SID: try user lookup with a reasonable Domain and
     * Sid buffer size first, before resorting to alloc.
     */
    if ( !LookupAccountSid( NULL, pSid,
                            UserBuffer, &cbUserBuffer,
                            DomainBuffer, &cbDomainBuffer, &SidNameUse ) ) {

        if ( ((Error = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) ) {

            if ( cbDomainBuffer > sizeof(DomainBuffer) ) {

                if ( !(pDomainBuffer =
                        (PWCHAR)malloc(
                            cbDomainBuffer * sizeof(WCHAR))) ) {

                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto BadDomainAlloc;
                }
            }

            if ( cbUserBuffer > sizeof(UserBuffer) ) {

                if ( !(pUserBuffer =
                        (PWCHAR)malloc(
                            cbUserBuffer * sizeof(WCHAR))) ) {

                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto BadUserAlloc;
                }
            }

            if ( !LookupAccountSid( NULL, pSid,
                                     pUserBuffer ?
                                        pUserBuffer : UserBuffer,
                                     &cbUserBuffer,
                                     pDomainBuffer ?
                                        pDomainBuffer : DomainBuffer,
                                     &cbDomainBuffer,
                                     &SidNameUse ) ) {

                Error = GetLastError();
                goto BadLookup;
            }

        } else {

            goto BadLookup;
        }
    }

    /*
     * Copy the user name into the specified buffer, truncating if necessary.
     */
    wcsncpy( pUserName, pUserBuffer ? pUserBuffer : UserBuffer,
              (*pcbUserName)-1 );
    pUserName[(*pcbUserName)-1] = 0;
    *pcbUserName = wcslen(pUserName);

    /*
     * Free our allocs (if any) and return.
     */
    if ( pDomainBuffer )
        free(pDomainBuffer);
    if ( pUserBuffer )
        free(pUserBuffer);
    return;

/*--------------------------------------
 * Error clean-up and return...
 */
BadLookup:
BadUserAlloc:
BadDomainAlloc:
    if ( pDomainBuffer )
        free(pDomainBuffer);
    if ( pUserBuffer )
        free(pUserBuffer);
    GetResourceStringFromUtilDll(IDS_UNKNOWN_USERNAME, pUserName, (*pcbUserName)-1);
    pUserName[(*pcbUserName)-1] = 0;
    *pcbUserName = wcslen(pUserName);
    return;
}

/*******************************************************************************
 *
 *  AreWeRunningTerminalServices
 *
 *      Check if we are running terminal server
 *
 *  ENTRY:
 *
 *  EXIT: BOOL: True if we are running Terminal Services False if we
 *              are not running Terminal Services
 *
 *
 ******************************************************************************/

BOOL AreWeRunningTerminalServices(void)
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_OR );

    return VerifyVersionInfo(
        &osVersionInfo,
        VER_SUITENAME,
        dwlConditionMask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\setargva.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*******************************************************************************
*
*   SETARGVA.C (ANSI argc, argv routines)
*
*   argc / argv routines
*
*
******************************************************************************/

/*
 * Include files
 */
#include <windows.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
 * ANSI ARGS structure and other stuff (private).
 */
#include "setargva.h"

/*
 * Local function prototypes.
 */
void args_init(ARGS *);
int add_arg_to_list(char *, ARGS *);
int args_trunc(ARGS *);

/*
 * setargvA()
 *
 *    Forms a standard C-runtime argc, argv parsed command line.
 *
 *  ENTRY:
 *      szModuleName (input)
 *          Optional Windows module name.  If not NULL, will be added as first
 *          parsed argument (argv[0], argc=1).
 *      szCmdLine (input)
 *          Points to command line to parse into argc, argv
 *      argc (output)
 *          Points to int to save argument count into on exit.
 *      argv (output)
 *          Points to (char **) to save argv array into on exit.
 *
 *  RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_xxx code if not ok.
 *
 *    A typical use of this routine is by a Windows UI application to 
 *    convert a command line into the C argc & argv variables prior to calling 
 *    the utilsub.lib ParseCommandLine() function.  Therefore, a companion 
 *    routine, freeargv(), allows for alloc'd memory to be freed by the caller 
 *    after use, if desired.
 *
 */
int WINAPI
setargvA( LPSTR szModuleName, 
          LPSTR szCmdLine, 
          int *argc, 
          char ***argv )
{
    int rc;
   char *cp;
   char FAR *cfp = szCmdLine;
   char ch, fname[_MAX_PATH];
   ARGS arg_data;

   /*
    * Initialize arg_data
    */
   args_init( &arg_data );

   /*
    * If present, add module name as argv[0].
    */
   if ( szModuleName ) {
      if ( (rc = add_arg_to_list( szModuleName, &arg_data )) != ERROR_SUCCESS )
         goto setargv_error;
   }

   /*
    * Skip leading blanks/tabs of remaining args
    */
   cp = fname;
   /* skip consecutive blanks and/or tabs */
   while ( (ch = *cfp) == ' ' || ch == '\t' )
      cfp++;

   /*
    * Process remainder of command line
    */
   while ( ch = *cfp++ ) {

      /*
       * Process quoted strings.
       */
      if ( ch == '"' ) {
         while ( (ch = *cfp++) && ch != '"' )
            *cp++ = ch;
         if ( ch == '\0' )
            cfp--;

      /*
       * If we find a delimeter, process the pathname we just scanned.
       */
      } else if ( ch == ' ' || ch == '\t') {
         *cp = '\0';
         if ( (rc = add_arg_to_list( fname, &arg_data )) != ERROR_SUCCESS )
            goto setargv_error;

         cp = fname;
         /* skip consecutive blanks and/or tabs */
         while ( (ch = *cfp) == ' ' || ch == '\t')
	    cfp++;

      /*
       * All other chars, just copy to internal buffer.
       */
      } else {
         *cp++ = ch;
      }
   }
   if ( cp != fname ) {
      *cp = '\0';
      if ( (rc = add_arg_to_list( fname, &arg_data )) != ERROR_SUCCESS )
        goto setargv_error;
   }

   if ( (rc = args_trunc( &arg_data )) != ERROR_SUCCESS )
       goto setargv_error;

   /*
    * Initialize global variables __argc and __argv
    */
   *argc = arg_data.argc;
   *argv = arg_data.argv;

   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
setargv_error:
    return(rc);
}


/*
 * freeargvA()
 *
 *    Frees up the memory alloc'd for argv strings and argv
 *    array itself.
 *
 *    ENTER:
 *       argv = argv array as created by this setargv() routine.
 *
 */
void WINAPI
freeargvA( char **argv )
{
    free(*argv);
    free(argv);
}


/*
 * args_init()
 *
 *    Initialize the ARGS struct passed as an argument.
 *
 *    ENTER:
 *       argp = pointer to ARGS struct
 *
 */
static void
args_init( ARGS *argp )
{

   argp->argc = 0;
   argp->argv = NULL;
   argp->argvlen = 0;
   argp->argvp = NULL;
   argp->buflen = 0;
   argp->buf = argp->bufptr = argp->bufend = NULL;
}


/*
 * add_arg_to_list()
 *
 *    This routine adds the specified argument string to the argv array,
 *    and increments the argv pointer and argc counter.
 *    If necessary, memory for the argument string is allocated.
 *
 *    RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_NOT_ENOUGH_MEMORY if not.
 *
 */
static int
add_arg_to_list( char *arg_string,
                 ARGS *argp )
{
   int len;

#ifdef notdef
   printf( "add_arg_to_list: arg_string=%s:, argc=%d, argvp=%x",
           arg_string,argp->argc,argp->argvp );
#endif

   /*
    * Verify we have an argv array buffer.
    * If we have one but it is full, expand the array.
    * If we can't alloc/realloc the array, return an error.
    */
   if ( !argp->argv ) {
      argp->argvlen = MIN_ARG_ALLOC;
      argp->argc = 0;
      argp->argv = malloc( argp->argvlen * sizeof( char *) );
      argp->argvp = argp->argv;
   } else if ( argp->argc + 1 >= argp->argvlen ) {
      argp->argvlen += MIN_ARG_ALLOC;
      argp->argv = realloc( argp->argv, argp->argvlen * sizeof(char *) );
      argp->argvp = argp->argv + argp->argc;
   }
   if ( !argp->argv ) {
#ifdef notdef
      printf("add_arg_to_list: failed to (re)alloc argv buf\n");
#endif
      goto add_arg_to_list_error;
   }

   /*
    * Verify we have a string buffer to store the argument string.
    * If we have one but there is not room for the new arg, expand the
    * buffer.  If we can't alloc/realloc the buffer, return an error.
    */
   len = strlen( arg_string ) + 1;
   if ( !argp->buf ) {
      argp->buflen = MIN_BUF_ALLOC;
      while ( argp->buflen < len )
	 argp->buflen += MIN_BUF_ALLOC;
      argp->buf = malloc( argp->buflen );
      argp->bufptr = argp->buf;
      argp->bufend = argp->buf + argp->buflen - 1;

   } else if ( argp->bufptr + len > argp->bufend ) {
      char *old_buf;
      int buf_offset = (int)(argp->bufptr - argp->buf);  //NBD sundown
      while ( argp->buflen < buf_offset + len )
         argp->buflen += MIN_BUF_ALLOC;
      old_buf = argp->buf;
      argp->buf = realloc( argp->buf, argp->buflen );
      argp->bufend = argp->buf + argp->buflen - 1;
      argp->bufptr = argp->buf + buf_offset;

      /*
       * If the argument string buffer moved, then we need to relocate the
       * argv pointers in the argv array to point to the new string locations.
       */
      if ( argp->buf != old_buf ) {
	 char *buf_ptr, **argv_ptr;
	 argv_ptr = argp->argv;
	 buf_ptr = argp->buf;
	 while ( buf_ptr != argp->bufptr ) {
	    *argv_ptr++ = buf_ptr;
	    buf_ptr += strlen( buf_ptr ) + 1;
	 }
      }
   }
   if ( !argp->buf ) {
#ifdef notdef
      printf("add_arg_to_list: failed to (re)alloc string buf\n");
#endif
      goto add_arg_to_list_error;
   }

   /*
    * Add the new argument to the buffer and the argv array.
    * Increment the arg count, the argv pointer, and the buffer pointer.
    */
   strcpy( argp->bufptr, arg_string );
   *(argp->argvp) = argp->bufptr;
   argp->bufptr += len;
   ++argp->argc;
   ++argp->argvp;
   *(argp->argvp) = NULL;
   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
add_arg_to_list_error:
    return(ERROR_NOT_ENOUGH_MEMORY);
}


/*
 * args_trunc()
 *
 *    Truncate the memory used by the ARGS struct
 *    so that unused memory is freed.
 *
 *    ENTER:
 *       argp = pointer to ARGS struct
 *
 *    RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_NOT_ENOUGH_MEMORY code if not ok.
 *
 */
static int
args_trunc( ARGS *argp )
{
   char *old_buf;

   /*
    * call realloc to shrink size of argv array, set argvlen = argc
    * to indicate no more room in argv array.
    */
   argp->argvlen = argp->argc + 1;
   argp->argv = realloc( argp->argv, argp->argvlen * sizeof(char *) );
   if ( !argp->argv )
      goto args_trunc_error;
   argp->argvp = argp->argv + argp->argc;

   /*
    * call realloc to shrink size of argument string buffer, set bufend
    * pointer to end of buffer to indicate buf is full.
    */
   old_buf = argp->buf;
   argp->buflen = (int)(argp->bufptr - argp->buf);
   argp->buf = realloc( argp->buf, argp->buflen );
   if ( !argp->buf )
      goto args_trunc_error;
   argp->bufptr = argp->buf + argp->buflen;
   argp->bufend = argp->buf + argp->buflen - 1;

   /*
    * If the argument string buffer moved, then we need to relocate the
    * argv pointers in the argv array to point to the new string locations.
    */
   if ( old_buf != argp->buf ) {
      char *buf_ptr, **argv_ptr;

      argv_ptr = argp->argv;
      buf_ptr = argp->buf;
      while ( buf_ptr != argp->bufptr ) {
         *argv_ptr++ = buf_ptr;
	 buf_ptr += strlen( buf_ptr ) + 1;
      }
   }

   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
args_trunc_error:
   return(ERROR_NOT_ENOUGH_MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\setargva.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation

/*
 * Argument structure
 *    Caller should initialize using args_init().  Use args_reset() to
 *    reset values, args_free() to free memory allocated by args_init().
 */
struct arg_data {
   int argc;
   char **argv;
   int argvlen;
   char **argvp;
   int buflen;
   char *buf;
   char *bufptr;
   char *bufend;
};
typedef struct arg_data ARGS;

/*
 * minimum size for argv/string buffer allocation
 */
#define MIN_ARG_ALLOC 128
#define MIN_BUF_ALLOC 1024
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\setargv.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation

/*
 * Argument structure
 *    Caller should initialize using args_init().  Use args_reset() to
 *    reset values, args_free() to free memory allocated by args_init().
 */
struct arg_data {
   int argc;
   char **argv;
   int argvlen;
   char **argvp;
   int buflen;
   char *buf;
   char *bufptr;
   char *bufend;
};
typedef struct arg_data ARGS;

/*
 * minimum size for argv/string buffer allocation
 */
#define MIN_ARG_ALLOC 128
#define MIN_BUF_ALLOC 1024
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\setargvw.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*******************************************************************************
*
*   SETARGVW.C (UNICODE argc, argv routines)
*
*   argc / argv routines
*
*
******************************************************************************/

/*
 * Include files
 */
#include <windows.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
 * UNICODE ARGS structure and other stuff (private).
 */
#include "setargvw.h"

/*
 * Local function prototypes.
 */
void args_init( ARGS * );
int add_arg_to_list( WCHAR *, ARGS * );
int args_trunc( ARGS * );

/*
 * setargvW()
 *
 *    Forms a standard C-runtime argc, argv parsed command line.
 *
 *  ENTRY:
 *      szModuleName (input)
 *          Optional Windows module name.  If not NULL, will be added as first
 *          parsed argument (argv[0], argc=1).
 *      szCmdLine (input)
 *          Points to command line to parse into argc, argv
 *      argc (output)
 *          Points to int to save argument count into on exit.
 *      argv (output)
 *          Points to (WCHAR **) to save argv array into on exit.
 *
 *  RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_xxx code if not ok.
 *
 *    A typical use of this routine is by a Windows UI application to 
 *    convert a command line into the C argc & argv variables prior to calling 
 *    the utilsub.lib ParseCommandLine() function.  Therefore, a companion 
 *    routine, freeargv(), allows for alloc'd memory to be freed by the caller 
 *    after use, if desired.
 *
 */
int WINAPI
setargvW( LPWSTR szModuleName, 
          LPWSTR szCmdLine, 
          int *argc, 
          WCHAR ***argv )
{
   int rc;
   WCHAR *cp;
   WCHAR FAR *cfp = szCmdLine;
   WCHAR ch, fname[_MAX_PATH];
   ARGS arg_data;

   /*
    * Initialize arg_data
    */
   args_init( &arg_data );

   /*
    * If present, add module name as argv[0].
    */
   if ( szModuleName ) {
      if ( (rc = add_arg_to_list( szModuleName, &arg_data )) != ERROR_SUCCESS )
         goto setargv_error;
   }

   /*
    * Skip leading blanks/tabs of remaining args
    */
   cp = fname;
   /* skip consecutive blanks and/or tabs */
   while ( (ch = *cfp) == L' ' || ch == L'\t' )
      cfp++;

   /*
    * Process remainder of command line
    */
   while ( ch = *cfp++ ) {

      /*
       * Process quoted strings.
       */
      if ( ch == '"' ) {
         while ( (ch = *cfp++) && ch != '"' )
            *cp++ = ch;
         if ( ch == '\0' )
            cfp--;

      /*
       * If we find a delimeter, process the pathname we just scanned.
       */
      } else if ( ch == ' ' || ch == '\t') {
         *cp = '\0';
         if ( (rc = add_arg_to_list( fname, &arg_data )) != ERROR_SUCCESS )
            goto setargv_error;

         cp = fname;
         /* skip consecutive blanks and/or tabs */
         while ( (ch = *cfp) == ' ' || ch == '\t')
	    cfp++;

      /*
       * All other chars, just copy to internal buffer.
       */
      } else {
         *cp++ = ch;
      }
   }
   if ( cp != fname ) {
      *cp = '\0';
      if ( (rc = add_arg_to_list( fname, &arg_data )) != ERROR_SUCCESS )
        goto setargv_error;
   }

   if ( (rc = args_trunc( &arg_data )) != ERROR_SUCCESS )
       goto setargv_error;

   /*
    * Initialize global variables __argc and __argv
    */
   *argc = arg_data.argc;
   *argv = arg_data.argv;

   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
setargv_error:
    return(rc);
}


/*
 * freeargvW()
 *
 *    Frees up the memory alloc'd for argv strings and argv
 *    array itself.
 *
 *    ENTER:
 *       argv = argv array as created by this setargv() routine.
 *
 */
void WINAPI
freeargvW( WCHAR **argv )
{
    free(*argv);
    free(argv);
}


/*
 * args_init()
 *
 *    Initialize the ARGS struct passed as an argument.
 *
 *    ENTER:
 *       argp = pointer to ARGS struct
 *
 */
static void
args_init( ARGS *argp )
{

   argp->argc = 0;
   argp->argv = NULL;
   argp->argvlen = 0;
   argp->argvp = NULL;
   argp->buflen = 0;
   argp->buf = argp->bufptr = argp->bufend = NULL;
}


/*
 * add_arg_to_list()
 *
 *    This routine adds the specified argument string to the argv array,
 *    and increments the argv pointer and argc counter.
 *    If necessary, memory for the argument string is allocated.
 *
 *    RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_NOT_ENOUGH_MEMORY if not.
 *
 */
static int
add_arg_to_list( WCHAR *arg_string,
                 ARGS *argp )
{
   int len;

#ifdef notdef
   wprintf( L"add_arg_to_list: arg_string=%s:, argc=%d, argvp=%x",
            arg_string, argp->argc, argp->argvp );
#endif

   /*
    * Verify we have an argv array buffer.
    * If we have one but it is full, expand the array.
    * If we can't alloc/realloc the array, return an error.
    */
   if ( !argp->argv ) {
      argp->argvlen = MIN_ARG_ALLOC;
      argp->argc = 0;
      argp->argv = malloc( argp->argvlen * sizeof( WCHAR *) );
      argp->argvp = argp->argv;
   } else if ( argp->argc + 1 >= argp->argvlen ) {
      argp->argvlen += MIN_ARG_ALLOC;
      argp->argv = realloc( argp->argv, argp->argvlen * sizeof(WCHAR *) );
      argp->argvp = argp->argv + argp->argc;
   }
   if ( !argp->argv ) {
#ifdef notdef
      wprintf( L"add_arg_to_list: failed to (re)alloc argv buf\n" );
#endif
      goto add_arg_to_list_error;
   }

   /*
    * Verify we have a string buffer to store the argument string.
    * If we have one but there is not room for the new arg, expand the
    * buffer.  If we can't alloc/realloc the buffer, return an error.
    */
   len = wcslen( arg_string ) + 1;
   if ( !argp->buf ) {
      argp->buflen = MIN_BUF_ALLOC;
      while ( argp->buflen < len )
	 argp->buflen += MIN_BUF_ALLOC;
      argp->buf = malloc( argp->buflen );
      argp->bufptr = argp->buf;
      argp->bufend = argp->buf + argp->buflen - 1;

   } else if ( argp->bufptr + len > argp->bufend ) {
      WCHAR *old_buf;
      int buf_offset = (int)(argp->bufptr - argp->buf);
      while ( argp->buflen < buf_offset + len )
         argp->buflen += MIN_BUF_ALLOC;
      old_buf = argp->buf;
      argp->buf = realloc( argp->buf, argp->buflen );
      argp->bufend = argp->buf + argp->buflen - 1;
      argp->bufptr = argp->buf + buf_offset;

      /*
       * If the argument string buffer moved, then we need to relocate the
       * argv pointers in the argv array to point to the new string locations.
       */
      if ( argp->buf != old_buf ) {
	     WCHAR *buf_ptr, **argv_ptr;
	     argv_ptr = argp->argv;
	     buf_ptr = argp->buf;

	     while ( buf_ptr != argp->bufptr ) {
	        *argv_ptr++ = buf_ptr;
            buf_ptr += wcslen( buf_ptr ) + 1;
	     }
      }
   }
   if ( !argp->buf ) {
#ifdef notdef
      wprintf( L"add_arg_to_list: failed to (re)alloc string buf\n" );
#endif
      goto add_arg_to_list_error;
   }

   /*
    * Add the new argument to the buffer and the argv array.
    * Increment the arg count, the argv pointer, and the buffer pointer.
    */
   wcscpy( argp->bufptr, arg_string );
   *(argp->argvp) = argp->bufptr;
   argp->bufptr += len;
   ++argp->argc;
   ++argp->argvp;
   *(argp->argvp) = NULL;
   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
add_arg_to_list_error:
    return(ERROR_NOT_ENOUGH_MEMORY);
}


/*
 * args_trunc()
 *
 *    Truncate the memory used by the ARGS struct
 *    so that unused memory is freed.
 *
 *    ENTER:
 *       argp = pointer to ARGS struct
 *
 *    RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_NOT_ENOUGH_MEMORY code if not ok.
 *
 */
static int
args_trunc( ARGS *argp )
{
   WCHAR *old_buf;

   /*
    * call realloc to shrink size of argv array, set argvlen = argc
    * to indicate no more room in argv array.
    */
   argp->argvlen = argp->argc + 1;
   argp->argv = realloc( argp->argv, argp->argvlen * sizeof(WCHAR *) );
   if ( !argp->argv )
      goto args_trunc_error;
   argp->argvp = argp->argv + argp->argc;

   /*
    * call realloc to shrink size of argument string buffer, set bufend
    * pointer to end of buffer to indicate buf is full.
    */
   old_buf = argp->buf;
   argp->buflen = (int)(argp->bufptr - argp->buf);
   argp->buf = realloc( argp->buf, argp->buflen );
   if ( !argp->buf )
      goto args_trunc_error;
   argp->bufptr = argp->buf + argp->buflen;
   argp->bufend = argp->buf + argp->buflen - 1;

   /*
    * If the argument string buffer moved, then we need to relocate the
    * argv pointers in the argv array to point to the new string locations.
    */
   if ( old_buf != argp->buf ) {
      WCHAR *buf_ptr, **argv_ptr;

      argv_ptr = argp->argv;
      buf_ptr = argp->buf;
      while ( buf_ptr != argp->bufptr ) {
         *argv_ptr++ = buf_ptr;
	     buf_ptr += wcslen( buf_ptr ) + 1;
      }
   }

   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
args_trunc_error:
   return(ERROR_NOT_ENOUGH_MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\setargvw.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation

/*
 * Argument structure
 *    Caller should initialize using args_init().  Use args_reset() to
 *    reset values, args_free() to free memory allocated by args_init().
 */
struct arg_data {
   int argc;
   WCHAR **argv;
   int argvlen;
   WCHAR **argvp;
   int buflen;
   WCHAR *buf;
   WCHAR *bufptr;
   WCHAR *bufend;
};
typedef struct arg_data ARGS;

/*
 * minimum size for argv/string buffer allocation
 */
#define MIN_ARG_ALLOC 128
#define MIN_BUF_ALLOC 1024
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\utilsubres.h ===
//  Copyright (c) 1999 Microsoft Corporation
// utilsubres.h

/*
   these ids are for the strings used by utilsub.lib.
   these must not conflict with any of the users of utilsub.lib
*/

#define BASE_UTILSUB_STRING                     1000
#define IDS_UNKNOWN_USERNAME                    BASE_UTILSUB_STRING+0
#define IDS_MAX_CMDLINE_EXCEEDED                BASE_UTILSUB_STRING+1
#define IDS_TS_SYS_UTIL_NOT_FOUND               BASE_UTILSUB_STRING+2
#define IDS_BAD_INTERNAL_PROGNAME               BASE_UTILSUB_STRING+3
#define IDS_CREATEPROCESS_FAILED                BASE_UTILSUB_STRING+4
#define IDS_WAITFORSINGLEOBJECT_FAILED          BASE_UTILSUB_STRING+5
#define IDS_DEVICE_ENUM_CANT_LOAD               BASE_UTILSUB_STRING+6
#define IDS_DEVENUM_NO_ENTRY_POINT              BASE_UTILSUB_STRING+7
#define IDS_ERROR_MEMORY                        BASE_UTILSUB_STRING+8
#define IDS_DEVICE_ENUM_FAILED                  BASE_UTILSUB_STRING+9
#define IDS_INTERNAL_ERROR_1                    BASE_UTILSUB_STRING+10
#define IDS_INTERNAL_ERROR_2                    BASE_UTILSUB_STRING+11
#define IDS_ADD_SRCH_LIST_NO_MEMORY_MALLOC      BASE_UTILSUB_STRING+12
#define IDS_ADD_SRCH_LIST_NO_MEMORY_STRDUP1     BASE_UTILSUB_STRING+13
#define IDS_ADD_SRCH_LIST_NO_MEMORY_STRDUP2     BASE_UTILSUB_STRING+14
#define IDS_ADD_SRCH_LIST_NO_MEMORY_STRDUP3     BASE_UTILSUB_STRING+15
#define IDS_TOO_MANY_ARGUMENTS                  BASE_UTILSUB_STRING+16
#define IDS_ARGS_TO_LIST_NOT_ENOUGH_MEMORY      BASE_UTILSUB_STRING+17
#define IDS_ARGS_TO_LIST_ARG_BUFFER_SMALL       BASE_UTILSUB_STRING+18
#define IDS_ERROR_NUMBER                        BASE_UTILSUB_STRING+19
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\wfprof\wfprof.c ===
/******************************************************************************
*
*   WFPROF.C
*
*   Description: 
*
*   Copyright Citrix Systems Inc. 1997
*
*   Copyright (c) 1998 - 1999 Microsoft Corporation
*
*   Author: Kurt Perry (kurtp)
*
*   Date: 11-Apr-1997
*
*   $Log:   M:\nt\private\utils\citrix\wfprof\VCS\wfprof.c  $
*  
*     Rev 1.3   Jun 26 1997 18:26:30   billm
*  move to WF40 tree
*  
*     Rev 1.2   23 Jun 1997 16:20:02   butchd
*  update
*  
*     Rev 1.1   29 Apr 1997 21:35:20   kurtp
*  I fixed a bug in this file, update, duh!
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <lmerr.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmremutl.h>

#include <citrix\winstaw.h>
#include <utilsub.h>

#include "wfprof.h"


/*=============================================================================
==  Macros
=============================================================================*/


/*=============================================================================
==  Variables
=============================================================================*/

WCHAR * pServerName = NULL;

WCHAR DomainName[MAX_IDS_LEN + 1];
WCHAR SourceUser[MAX_IDS_LEN + 1];
WCHAR DestinationUser[MAX_IDS_LEN + 1];
WCHAR WFProfilePath[MAX_IDS_LEN + 1];


/*=============================================================================
==   Data types and definitions
=============================================================================*/

USHORT copy_flag    = FALSE;
USHORT update_flag  = FALSE;
USHORT query_flag   = FALSE;
USHORT help_flag    = FALSE;
USHORT local_flag   = FALSE;

TOKMAP ptm[] = {

      {L" ",        TMFLAG_REQUIRED, TMFORM_STRING,  MAX_IDS_LEN,    SourceUser}, 
      {L" ",        TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    DestinationUser}, 
      {L"/Domain",  TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    DomainName}, 
      {L"/Profile", TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    WFProfilePath}, 
      {L"/Local",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &local_flag}, 

      {L"/Copy",    TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &copy_flag}, 
      {L"/Q",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &query_flag},
      {L"/Update",  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &update_flag},

      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};

#define SOURCE_USER  (ptm[0].tmFlag & TMFLAG_PRESENT)
#define DEST_USER    (ptm[1].tmFlag & TMFLAG_PRESENT) 
#define DOMAIN       (ptm[2].tmFlag & TMFLAG_PRESENT) 
#define PROFILE_PATH (ptm[3].tmFlag & TMFLAG_PRESENT) 
#define LOCAL        (ptm[4].tmFlag & TMFLAG_PRESENT) 



/*=============================================================================
==  Functions
=============================================================================*/

void Usage( BOOLEAN bError );


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main( int argc, char **argv )
{
    int   i;
    int   Error;
    ULONG ReturnLength;
    WCHAR **argvW;
    USERCONFIG UserConfig;

    /*
     * Massage the new command line to look like an argv[] type
     * because ParseCommandLine() depends on this format
     */
    argvW = (WCHAR **)malloc( sizeof(WCHAR *) * (argc+1) );
    if(argvW == NULL) {
        printf( "Error: malloc failed\n" );
        return(FAILURE);
    }

    for( i=0; i < argc; i++ ) {
        argvW[i] = (WCHAR *)malloc( (strlen(argv[i]) + 1) * sizeof(WCHAR) );
        wsprintf( argvW[i], L"%S", argv[i] );
    }
    argvW[argc] = NULL;

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    Error = ParseCommandLine(argc-1, argvW+1, ptm, PCL_FLAG_NO_CLEAR_MEMORY);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag ) {

        Usage(FALSE);
        return(SUCCESS);
    }
    else if ( Error || 
        (!copy_flag && !update_flag && !query_flag) ||
        (copy_flag && update_flag) ||
        (copy_flag && query_flag) ||
        (update_flag && query_flag) ||
        (copy_flag && !DEST_USER) ||
        (update_flag && !PROFILE_PATH) ||
        (!DOMAIN && !LOCAL) ||
        (DOMAIN && LOCAL) ) {

        Usage(TRUE);
        return(FAILURE);
    }

    /*
     *  Get server name for domain name
     */
    if ( LOCAL ) {
        pServerName = NULL;
        Error = ERROR_SUCCESS;
    }
    else {
        Error = NetGetDCName( (WCHAR)NULL, DomainName, (LPBYTE *)&pServerName );
    }

    if ( Error == ERROR_SUCCESS ) {

        /*
         *  Update or Query
         */
        if ( update_flag || query_flag ) {
        
        
query_it:
    
            Error = RegUserConfigQuery( pServerName,
                                        SourceUser,
                                        &UserConfig,
                                        sizeof(UserConfig),
            	                        &ReturnLength );
    
            if ( Error == ERROR_SUCCESS ) {
    
                if ( query_flag ) {
                    Message( IDS_QUERY, 
                             DomainName, 
                             SourceUser, 
                             UserConfig.WFProfilePath );
                }
                else {
    
                    wcscpy( UserConfig.WFProfilePath, WFProfilePath );
    
                    Error = RegUserConfigSet( pServerName,
                                              SourceUser,
                                              &UserConfig,
                    	                      sizeof(UserConfig) );
    
                    if ( Error == ERROR_SUCCESS ) {
                        query_flag = TRUE;
                        goto query_it;
                    }
                    else {
                        ErrorPrintf(IDS_ERROR_SET_USER_CONFIG, Error, Error);
                    }
                }
            }
            else {
                ErrorPrintf(IDS_ERROR_GET_USER_CONFIG, Error, Error);
            }
        }
        else if ( copy_flag ) {
    
            Error = RegUserConfigQuery( pServerName,
                                        SourceUser,
                                        &UserConfig,
                                        sizeof(UserConfig),
                                        &ReturnLength );
    
            if ( Error == ERROR_SUCCESS ) {
    
                if ( query_flag ) {
                    Message( IDS_QUERY, 
                             DomainName, 
                             SourceUser, 
                             UserConfig.WFProfilePath );
                }
                else {
    
                    if ( PROFILE_PATH ) {
                        wcscpy( UserConfig.WFProfilePath, WFProfilePath );
                    }
    
                    Error = RegUserConfigSet( pServerName,
                                              DestinationUser,
                                              &UserConfig,
                                              sizeof(UserConfig) );
    
                    if ( Error != ERROR_SUCCESS ) {
                        ErrorPrintf(IDS_ERROR_SET_USER_CONFIG, Error, Error);
                    }
                }
            }
            else {
                ErrorPrintf(IDS_ERROR_GET_USER_CONFIG, Error, Error);
            }
        }
    }
    else {
        ErrorPrintf(IDS_ERROR_GET_DC, Error, Error);
    }

    return( (Error == ERROR_SUCCESS ? SUCCESS : FAILURE) );
}



/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *      
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    } 

    Message(IDS_USAGE1);
    Message(IDS_USAGE2);
    Message(IDS_USAGE3);

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\wfprof\tsprof.c ===
/******************************************************************************
*
*   TSPROF.C
*
*   Description:
*
*   Copyright Citrix Systems Inc. 1997
*
*   Copyright (c) 1998 - 1999 Microsoft Corporation
*
*   Author: Kurt Perry (kurtp)
*
*   Date: 11-Apr-1997
*
*   $Log:   N:\nt\private\utils\citrix\wfprof\VCS\tsprof.c  $
*
*     Rev 1.5   May 04 1998 17:46:34   tyl
*  bug 2019 - oem to ansi
*
*     Rev 1.4   Jan 30 1998 20:46:22   yufengz
*  change the file name
*
*     Rev 1.3   Jun 26 1997 18:26:30   billm
*  move to WF40 tree
*
*     Rev 1.2   23 Jun 1997 16:20:02   butchd
*  update
*
*     Rev 1.1   29 Apr 1997 21:35:20   kurtp
*  I fixed a bug in this file, update, duh!
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>

#include <lmerr.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmremutl.h>

#include <winstaw.h>
#include <utilsub.h>
#include <printfoa.h>

#include "wfprof.h"


/*=============================================================================
==  Macros
=============================================================================*/


/*=============================================================================
==  Variables
=============================================================================*/

WCHAR * pServerName = NULL;

WCHAR DomainName[MAX_IDS_LEN + 1];
WCHAR SourceUser[MAX_IDS_LEN + 1];
WCHAR DestinationUser[MAX_IDS_LEN + 1];
WCHAR WFProfilePath[MAX_IDS_LEN + 1];


/*=============================================================================
==   Data types and definitions
=============================================================================*/

USHORT copy_flag    = FALSE;
USHORT update_flag  = FALSE;
USHORT query_flag   = FALSE;
USHORT help_flag    = FALSE;
USHORT local_flag   = FALSE;

TOKMAP ptm[] = {

      {L" ",        TMFLAG_REQUIRED, TMFORM_STRING,  MAX_IDS_LEN,    SourceUser},
      {L" ",        TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    DestinationUser},
      {L"/Domain",  TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    DomainName},
      {L"/Profile", TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    WFProfilePath},
      {L"/Local",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &local_flag},

      {L"/Copy",    TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &copy_flag},
      {L"/Q",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &query_flag},
      {L"/Update",  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &update_flag},

      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};

#define SOURCE_USER  (ptm[0].tmFlag & TMFLAG_PRESENT)
#define DEST_USER    (ptm[1].tmFlag & TMFLAG_PRESENT)
#define DOMAIN       (ptm[2].tmFlag & TMFLAG_PRESENT)
#define PROFILE_PATH (ptm[3].tmFlag & TMFLAG_PRESENT)
#define LOCAL        (ptm[4].tmFlag & TMFLAG_PRESENT)



/*=============================================================================
==  Functions
=============================================================================*/

void Usage( BOOLEAN bError );


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main( int argc, char **argv )
{
    int   i;
    int   Error;
    ULONG ReturnLength;
    WCHAR **argvW;
    USERCONFIG UserConfig;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    Error = ParseCommandLine(argc-1, argvW+1, ptm, PCL_FLAG_NO_CLEAR_MEMORY);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag ) {

        Usage(FALSE);
        return(SUCCESS);
    }
    else if ( Error ||
        (!copy_flag && !update_flag && !query_flag) ||
        (copy_flag && update_flag) ||
        (copy_flag && query_flag) ||
        (update_flag && query_flag) ||
        (copy_flag && !DEST_USER) ||
        (update_flag && !PROFILE_PATH) ||
        (!DOMAIN && !LOCAL) ||
        (DOMAIN && LOCAL) ) {

        Usage(TRUE);
        return(FAILURE);
    }

    /*
     *  Get server name for domain name
     */
    if ( LOCAL ) {
        pServerName = NULL;
        Error = ERROR_SUCCESS;
    }
    else {
        Error = NetGetDCName( (WCHAR)NULL, DomainName, (LPBYTE *)&pServerName );
    }

    if ( Error == ERROR_SUCCESS ) {

        /*
         *  Update or Query
         */
        if ( update_flag || query_flag ) {


query_it:

            Error = RegUserConfigQuery( pServerName,
                                        SourceUser,
                                        &UserConfig,
                                        sizeof(UserConfig),
                                        &ReturnLength );
            if(Error != ERROR_SUCCESS)
            {
                Error = RegDefaultUserConfigQuery(pServerName,
                                                            &UserConfig,                // address for userconfig buffer
                                                            sizeof(UserConfig),         // size of buffer
                                                            &ReturnLength);
            }

            if ( Error == ERROR_SUCCESS )
            {

                if ( query_flag )
                {
                    TCHAR tchOutput[ 512 ];
                    TCHAR tchFormat[ 256 ];
                    DWORD_PTR dw[ 3 ];

                    dw[ 0 ] = (DWORD_PTR)(ULONG_PTR)&DomainName[0];
                    dw[ 1 ] = (DWORD_PTR)(ULONG_PTR)&SourceUser[0];
                    dw[ 2 ] = (DWORD_PTR)(ULONG_PTR)&UserConfig.WFProfilePath[0];

                    LoadString( NULL , IDS_QUERY3 , tchFormat , sizeof( tchFormat ) / sizeof( TCHAR ) );


                    FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   tchFormat ,
                                   0 ,
                                   0 ,
                                   tchOutput ,
                                   sizeof( tchOutput ) / sizeof( TCHAR ) ,
                                   ( va_list * )&dw );

                    My_wprintf( tchOutput );



                    /*
                    StringMessage( IDS_QUERY1, 
                                   DomainName);
                    StringMessage( IDS_QUERY2,
                                   SourceUser);
                    StringMessage( IDS_QUERY3,
                                   UserConfig.WFProfilePath );
                                   */
                }
                else
                {

                            wcscpy( UserConfig.WFProfilePath, WFProfilePath );

                            Error = RegUserConfigSet( pServerName,
                                                      SourceUser,
                                                      &UserConfig,
                                                      sizeof(UserConfig) );

                            if ( Error == ERROR_SUCCESS )
                            {
                                query_flag = TRUE;
                                goto query_it;
                            }
                            else
                            {
                                ErrorPrintf(IDS_ERROR_SET_USER_CONFIG, Error, Error);
                            }
                    }


            }
            else {
                ErrorPrintf(IDS_ERROR_GET_USER_CONFIG, Error, Error);
            }
        }
        else if ( copy_flag ) {

            Error = RegUserConfigQuery( pServerName,
                                        SourceUser,
                                        &UserConfig,
                                        sizeof(UserConfig),
                                        &ReturnLength );
    
            if ( Error == ERROR_SUCCESS )
            {
    
                if ( query_flag )
                {
                    TCHAR tchOutput[ 512 ];
                    TCHAR tchFormat[ 256 ];
                    ULONG_PTR dw[ 3 ];

                    dw[ 0 ] = (ULONG_PTR)&DomainName[0];
                    dw[ 1 ] = (ULONG_PTR)&SourceUser[0];
                    dw[ 2 ] = (ULONG_PTR)&UserConfig.WFProfilePath[0];

                    LoadString( NULL , IDS_QUERY3 , tchFormat , sizeof( tchFormat ) / sizeof( TCHAR ) );


                    FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   tchFormat ,
                                   0 ,
                                   0 ,
                                   tchOutput ,
                                   sizeof( tchOutput )  / sizeof( TCHAR ) ,
                                   ( va_list * )&dw );

                    My_wprintf( tchOutput );

                    /*
                    StringMessage( IDS_QUERY1, 
                                   DomainName);
                    StringMessage( IDS_QUERY2,
                                   SourceUser);
                    StringMessage( IDS_QUERY3,
                                   UserConfig.WFProfilePath );
                    */
                }
                else {

                    if ( PROFILE_PATH ) {
                        wcscpy( UserConfig.WFProfilePath, WFProfilePath );
                    }

                    Error = RegUserConfigSet( pServerName,
                                              DestinationUser,
                                              &UserConfig,
                                              sizeof(UserConfig) );

                    if ( Error != ERROR_SUCCESS ) {
                        ErrorPrintf(IDS_ERROR_SET_USER_CONFIG, Error, Error);
                    }
                }
            }
            else {
                ErrorPrintf(IDS_ERROR_GET_USER_CONFIG, Error, Error);
            }
        }
    }
    else {
        ErrorPrintf(IDS_ERROR_GET_DC, Error, Error);
    }

    return( (Error == ERROR_SUCCESS ? SUCCESS : FAILURE) );
}



/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }

    Message(IDS_USAGE1);
    Message(IDS_USAGE2);
    Message(IDS_USAGE3);

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\toolinit.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*
 *
 *  Module Name:
 *
 *      toolinit.c
 *
 *  Abstract:
 *
 *      This file contains initialization code that is shared among all
 *      the command line tools.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Dec-16-98
 *
 *  Environment:
 *
 *      User Mode
 */

#include <windows.h>
#include <printfoa.h>

/*
 *  Function Implementations.
 */

/*
 *  MassageCommandLine()
 *
 *  Obtains the command line, parses it as a UNICODE string, and returns
 *  it in the ANSI argv style.
 *
 *  Parameters:
 *      IN DWORD    dwArgC: The number of arguments on the command line.
 *
 *  Return Values:
 *      Returns a WCHAR array (WCHAR **), or NULL if an error occurs.
 *      Extended error information is available from GetLastError().
 *
 */

WCHAR**
MassageCommandLine(
    IN DWORD    dwArgC
    )
{
    BOOL    fInQuotes = FALSE, fInWord = TRUE;
    DWORD   i, j, k, l;
    WCHAR   *CmdLine;
    WCHAR   **ArgVW;

    /*
     *  argv can't be used because its always ANSI.
     */

    CmdLine = GetCommandLineW();

    /*
     *  Convert from OEM character set to ANSI.
     */
	
    //OEM2ANSIW(CmdLine, (USHORT)wcslen(CmdLine));

    /*
     * Massage the new command line to look like an argv type
     * because ParseCommandLine() depends on this format
     */

    ArgVW = (WCHAR **)LocalAlloc(
                        LPTR,
                        (dwArgC + 1) * (sizeof(WCHAR *))
                        );
    if(ArgVW == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    /*
     *  Parse CmdLine by spaces (or tabs), ignoring spaces inside double quotes;
     *  i.e. "1 2" is one argument, but cannot contain the double quotes
     *  after parsing. Also, multiple spaces inside quotes are maintained,
     *  while multiple spaces outside of quotes are condensed. Example:
     *
     *  test.exe 1 "2 3"  4"5  6"7 8 '9 10'
     *      will have as arguments:
     *
     *      0:  test.exe
     *      1:  1
     *      2:  2 3
     *      3:  45  67
     *      4:  8
     *      5:  '9
     *      6:  10'
     */

    i = j = k = 0;

    while (CmdLine[i] != (WCHAR)NULL) {
        if (CmdLine[i] == L' '||CmdLine[i] == L'\t') {
            if (!fInQuotes) {
                fInWord = FALSE;

                if (i != k) {
                    CmdLine[i] = (WCHAR)NULL;

                    ArgVW[j] = (WCHAR *)LocalAlloc(
                                            LPTR,
                                            (i - k + 1) * (sizeof(WCHAR))
                                            );
                    if (ArgVW[j] != NULL) {
                        wcscpy(ArgVW[j], &(CmdLine[k]));
                        k = i + 1;
                        j++;

                        if (j > dwArgC) {
                            SetLastError(ERROR_INVALID_PARAMETER);
                            goto CleanUp;
                        }
                    } else {
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        goto CleanUp;
                    }
                } else {
                    k = i + 1;
                }
            }
        } else if (CmdLine[i] == L'\"') {
            DWORD dwLen = wcslen(&(CmdLine[i]));
            
            //Added by a-skuzin
            //case when we need to have quota inside parameter and use " \" "
            if(i && (CmdLine[i-1] == L'\\')) {
                MoveMemory(
                        &(CmdLine[i-1]),
                        &(CmdLine[i]),
                        (dwLen+1) * sizeof(WCHAR) // drop 1 char, add NULL
                        );
                i--;
                fInWord = TRUE;
                goto increment;
            }
            //end of "added by a-skuzin"

            //  Special case a double quote by itself or at the end of the line

            if (fInQuotes && (l == i)) {
                if ((dwLen == 1) || (CmdLine[i + 1] == L' ') || (CmdLine[i + 1] == L'\t')) {
                    k = i;
                    CmdLine[k] = (WCHAR)NULL;
                    fInQuotes = FALSE;
                    goto increment;
                }
            }

            if (fInQuotes && fInWord) {
                if ((dwLen == 2) && (CmdLine[i + 1] == L'\"')) {
                    MoveMemory(
                        &(CmdLine[i]),
                        &(CmdLine[i + 1]),
                        dwLen * sizeof(WCHAR) // drop 1 char, add NULL
                        );
                    goto increment;
                }

                if ((dwLen >= 3) &&
                    (CmdLine[i + 1] == L'\"') &&
                    (CmdLine[i + 2] != L' ') &&
                    (CmdLine[i + 2] != L'\t')) {
                    fInQuotes = FALSE;
                    MoveMemory(
                        &(CmdLine[i]),
                        &(CmdLine[i + 1]),
                        dwLen * sizeof(WCHAR) // drop 1 char, add NULL
                        );
                    goto increment;
                }

                if ((dwLen >= 3) &&
                    (CmdLine[i + 1] == L'\"') &&
                    (CmdLine[i + 2] == L' ') &&
					(CmdLine[i + 2] == L'\t')) {
                    goto increment;
                }
            }

            if (!fInQuotes && fInWord && (dwLen == 1) && (j == 0)) {
                goto increment;
            }

            fInQuotes = !fInQuotes;
            if (fInQuotes && !fInWord) {
                fInWord = TRUE;
                l = i;
            }

            MoveMemory(
                &(CmdLine[i]),
                &(CmdLine[i + 1]),
                dwLen * sizeof(WCHAR) // drop 1 char, add NULL
                );

            i--;
        } else {
            fInWord = TRUE;
        }

increment:
        i++;
    }

    if (i != k) {
        if (j >= dwArgC) {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto CleanUp;
        }

        ArgVW[j] = (WCHAR *)LocalAlloc(
                            LPTR,
                                (i - k + 1) * (sizeof(WCHAR))
                                );
        if (ArgVW[j] != NULL) {
            wcscpy(ArgVW[j], &(CmdLine[k]));
        } else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto CleanUp;
        }
    } else if (fInQuotes && (l == i)) {
        if (j >= dwArgC) {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto CleanUp;
        }

        ArgVW[j] = (WCHAR *)LocalAlloc(
                            LPTR,
                                (i - k + 1) * (sizeof(WCHAR))
                                );
        if (ArgVW[j] != NULL) {
            wcscpy(ArgVW[j], &(CmdLine[k]));
        } else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto CleanUp;
        }
    }

    ArgVW[dwArgC] = (WCHAR)NULL;

    return(ArgVW);

CleanUp:

    for (i = 0; i < dwArgC; i++) {
        if (ArgVW[i] != NULL) {
            LocalFree(ArgVW[i]);
        }
    }

    LocalFree(ArgVW);

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\wfprof\wfprof.h ===
/***********************************************************************
*
*  WFPROF.H
*
*  Copyright Citrix Systems Inc. 1997
*
*  Copyright (c) 1998 - 1999 Microsoft Corporation
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_INVALID_PARAMETERS                    100
#define IDS_ERROR_GET_DC                                101
#define IDS_ERROR_GET_USER_CONFIG                       102
#define IDS_ERROR_SET_USER_CONFIG                       103
#define IDS_ERROR_MALLOC                                104

#define IDS_USAGE1                                      200
#define IDS_USAGE2                                      201
#define IDS_USAGE3                                      202
#define IDS_QUERY1                                      203
#define IDS_QUERY2                                      204
#define IDS_QUERY3                                      205
#define IDS_ERROR_NOT_TS                                206
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\umatch.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*   UMATCH.C
*
*   The unix_match() function, performing unix style wild-card matching on
*   a given file name.
*
*
******************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <string.h>

#define TRUE 1
#define FALSE 0

/******************************************************************************
*
* unix_match()
*
*   Check specified filename (found_file) to see if it matches
*   the filename with global characters (with globals).
*   Uses unix style wild-card matching.
*
*   EXIT:
*       TRUE  -- the specified filename matched the filename with wildcards
*       FALSE -- the specified filename did not match
*
******************************************************************************/

int
unix_match(
     WCHAR *with_globals,     /* the file with possible global characters */
     WCHAR *found_file )      /* file name returned - no globals in it */
{
   WCHAR *c1, *c2, *start_c1, *start_c2, *sav_c1, *sav_c2;
   WCHAR ch, ch2;
   int  i, j, k, char_ok, match, want_match;

/*
 * Play with filename so that blanks are removed.
 */
   j = k = 0;
   for (i=0; found_file[i]!=L'\0'; ++i) {
      if (found_file[i] == L' ') {
         if (j == 0) {
            j = i;
         } else {
            found_file[i] = L'\0';
         }
      } else if (found_file[i] == L'.') {
         k = i;
      }
   }
   if (j && k) {
      wcscpy(&found_file[j], &found_file[k]);
   }

/*
 * If Search name is just "*", simply return success now.
 */
   if (with_globals[0]==L'*' && with_globals[1]==L'\0') {
      return TRUE;
   }

#ifdef DEBUG
   wprintf("unix_match: search=%s: found=%s:\n", with_globals, found_file);
#endif

/*
 * Now compare the 2 filenames to see if we have a match.
 */
   c1 = with_globals,
   c2 = found_file;
   start_c1 = sav_c1 = NULL;
      while (*c2!=L'\0') {
         char_ok = FALSE;
         switch (*c1) {
         case L'\0':
            break;
         case '*':
            while (*++c1 == L'*') ;     /* skip consecutive '*'s */
            if (*c1 == L'\0') {         /* if we reached the end, we match */
               return TRUE;
            }
            start_c1 = c1;             /* remember where '*' was and where */
            start_c2 = c2;             /* we were in filename string */
            sav_c1 = NULL;
            char_ok = TRUE;
            break;
         case L'?':
            ++c1; ++c2;
            char_ok = TRUE;
            break;
         case L'[':
            if (!sav_c1) {
               sav_c1 = c1;
               sav_c2 = c2;
            }
            match = FALSE;
            want_match = TRUE;
            if (*++c1 == L'!') {
               ++c1;
               want_match = FALSE;
            }
            while ((ch=*c1) && ch != L']') {             /* BJP */
               if (c1[1] == L'-') {
                  ch2 = *c2;
                  if (ch<=ch2 && c1[2]>=ch2) {
                     match = TRUE;
                     break;
                  }
                  ++c1; ++c1;    /* skip '-' and following char */
               } else if (ch == *c2) {
                  match = TRUE;
                  break;
               }
               ++c1;
            }
            if (want_match) {
               if (match) {
                  while ((ch=*c1++) && ch != L']') ;     /* BJP */
                  ++c2;
                  char_ok = TRUE;
               } else if (!start_c1) {
                  return FALSE;
               }
            } else /*!want_match*/ {
               if (match) {
                  return FALSE;
               } else if (start_c1) {
                  if (sav_c1 != start_c1) {
                     while ((ch=*c1++) && ch != L']') ;  /* BJP */
                     ++c2;
                     sav_c1 = NULL;
                     char_ok = TRUE;
                  } else if (c2[1] == L'\0') {
                     while ((ch=*c1++) && ch != L']') ;  /* BJP */
                     c2 = sav_c2;
                     sav_c1 = NULL;
                     char_ok = TRUE;
                  }
               } else {
                  while ((ch=*c1++) && ch != L']') ;     /* BJP */
                  ++c2;
                  char_ok = TRUE;
               }
            }
            break;
         default:
            if (*c1 == *c2) {     /* See if this char matches exactly */
               ++c1; ++c2;
               char_ok = TRUE;
            }
         }
         if (!char_ok) {               /* No match found */
            if (start_c1) {            /* If there was a '*', start over after*/
               c1 = start_c1;          /* the '*', and one char further into */
               c2 = ++start_c2;        /* the filename string than before */
            } else {
               return FALSE;
            }
         }
      }

   while (*c1==L'*') ++c1;

   if (*c1==L'\0' && *c2==L'\0')
      return TRUE;
   else
      return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\utilsub\wstutil.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  WSTUTIL.C
*
*  Various useful utilities for dealing with multi-user WinStations and User
*  accounts that are useful across a range of utilities and apps.
*
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <process.h>
#include <string.h>
#include <malloc.h>

#include <winstaw.h>
#include <utilsub.h>

/*
 * RefreshAllCaches
 *
 *  Invalidate any caches maintained by the UTILSUB.DLL
 *
 *  This does not need to be called for utilities that exit when done, but
 *  are for server, or monitoring type programs that need to periodicly
 *  see the latest system information.
 *  IE: A new user could have logged onto a given winstation since the last
 *      call.
 *
 *
 * Exit
 *
 *  Any caches in the UTILSUB.DLL have been invalidated insuring fresh
 *  system information on future calls.
 *
 */
VOID WINAPI
RefreshAllCaches()
{
    RefreshWinStationCaches();
    RefreshProcessObjectCaches();
}

/*
 * RefreshWinStationCaches
 *
 *  Invalidate any caches maintained by the WinStation helper utilities.
 *
 *  This does not need to be called for utilities that exit when done, but
 *  are for server, or monitoring type programs that need to periodicly
 *  see the latest system information.
 *  IE: A new user could have logged onto a given winstation since the last
 *      call.
 *
 *
 * Exit
 *
 *   Makes sure that any WinStation helper utility calls will return the
 *   system information at least up to date as the time that this call
 *   was made.
 *
 */
VOID WINAPI
RefreshWinStationCaches()
{
    RefreshWinStationObjectCache();
    RefreshWinStationNameCache();
}

/*
 * GetCurrentLogonId
 *
 * Gets the WinStation ID for the current processes WinStation
 *
 * Exit
 *
 *  ID of the current processes WinStation
 *
 */

ULONG WINAPI
GetCurrentLogonId()
{
    return( NtCurrentPeb()->SessionId );
}

/*
 * GetCurrentWinStationName
 *
 * Get the current UNICODE name for the WinStation for this process
 *
 * Input:
 *
 *   pName - Pointer to wide character buffer for name
 *
 *   MaxSize - Maximum number of characters in buffer (including terminator).
 *
 *   pName - Pointer to wide character buffer for name
 *
 * Output:
 *
 */
VOID WINAPI
GetCurrentWinStationName( PWCHAR pName, int MaxSize )
{
    GetWinStationNameFromId( NtCurrentPeb()->SessionId, pName, MaxSize );
}

/*
 * This is the cache maintained by the GetWinStationNameFromId function
 *
 * It is thread safe through the use of WLock.
 */

typedef struct TAGWINSTATIONLIST {
    struct TAGWINSTATIONLIST *Next;
    LOGONID LogonId;
} WINSTATIONLIST, *PWINSTATIONLIST;

static PWINSTATIONLIST pWList = NULL;
static RTL_CRITICAL_SECTION WLock;
static BOOLEAN WLockInited = FALSE;

/***************************************************************************
 *
 *  InitWLock
 *
 *  Since we do not require the user to call an initialize function,
 *  we must initialize our critical section in a thread safe manner.
 *
 *  The problem is, a critical section is needed to guard against multiple
 *  threads trying to init the critical section at the same time.
 *
 *  The solution that Nt uses, in which RtlInitializeCriticalSection itself
 *  uses, is to wait on a kernel supported process wide Mutant before proceding.
 *  This Mutant almost works by itself, but RtlInitializeCriticalSection does
 *  not wait on it until after trashing the semaphore count. So we wait on
 *  it ourselves, since it can be acquired recursively.
 *
 ***************************************************************************/
NTSTATUS InitWLock()
{
    NTSTATUS status = STATUS_SUCCESS;

    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    /*
     * Make sure another thread did not beat us here
     */
    if( WLockInited == FALSE ){
        status = RtlInitializeCriticalSection( &WLock );

        if (status == STATUS_SUCCESS) {
            WLockInited = TRUE;
        }
    }

    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    return status;
}

/***************************************************************************
 *
 * RefreshWinStationNameCache
 *
 *  Invalidate the WinStation Name cache so that the newest information
 *  will be fetched from the system.
 *
 ***************************************************************************/

VOID WINAPI
RefreshWinStationNameCache( )
{
    NTSTATUS status = STATUS_SUCCESS;

    PWINSTATIONLIST pEntry, pNext;

    if( pWList == NULL ) return;

    /*
     * Make sure critical section has been inited
     */
    if( !WLockInited ) {
       status = InitWLock();
    }

    if (status == STATUS_SUCCESS) {
        RtlEnterCriticalSection( &WLock );

        pEntry = pWList;

        while( pEntry ) {
           pNext = pEntry->Next;
           free( pEntry );
           pEntry = pNext;
        }

        pWList = NULL;

        RtlLeaveCriticalSection( &WLock );
    }
}

/*
 * GetWinStationNameFromId
 *
 *  Attempt to retrieve the WinStationName for the given LogonId.
 *
 *  Parameters:
 *
 *     LogonId (input)
 *       Unique LogonId
 *
 *     pName (output)
 *       Pointer to buffer for name
 *
 *     MaxSize (input)
 *       Maximum number of characters in buffer (including terminator).
 *
 *  Returns
 *     TRUE if name was retreived, FALSE otherwise.
 *
 */

BOOLEAN WINAPI
GetWinStationNameFromId( ULONG LogonId, PWCHAR pName, int MaxSize )
{    
    return xxxGetWinStationNameFromId( SERVERNAME_CURRENT , LogonId , pName , MaxSize );    
}

/*----------------------------------------------------------------------------------------
/*
 * xxxGetWinStationNameFromId
 *
 *  Attempt to retrieve the WinStationName for the given LogonId.
 *
 *  Parameters:
 *  
 *     hServer ( input )
 *       rpc handle to termsrv
 *
 *     LogonId (input)
 *       Unique LogonId
 *
 *     pName (output)
 *       Pointer to buffer for name
 *
 *     MaxSize (input)
 *       Maximum number of characters in buffer (including terminator).
 *
 *  Returns
 *     TRUE if name was retreived, FALSE otherwise.
 *
 */

BOOLEAN WINAPI
xxxGetWinStationNameFromId( HANDLE hServer , ULONG LogonId, PWCHAR pName, int MaxSize )
{
    NTSTATUS status = STATUS_SUCCESS;
    PLOGONID pIdBase, pId;
    int          rc;
    ULONG        Count;
    PWINSTATIONLIST pEntryBase, pEntry;

    // Since We do not have a WinStationNamefromId Sm Api like we do for
    // LogonIdfromName, we will perform a WinStationEnumerate function across
    // all WinStations known by the Session Manager, and store them in a locally
    // maintained list. We do this so we that this search against the session
    // manager is not done every time we're called.
    //
    // Another alternative that was tested is to open the WinStation itself
    // and then do a WinStationQueryInformation against it in order to
    // retrieve its name from itself. This is much slower because we must
    // set up and tear down an LPC connection to each WinStation, as opposed
    // to the one connection we get to the session manager.

    /*
     * Make sure critical section has been inited
     */
    if( !WLockInited ) {
       status = InitWLock();
    }

    if (status == STATUS_SUCCESS) {
        RtlEnterCriticalSection( &WLock );

        // Initialize the list the first time
        if( pWList == NULL ) {

            rc = WinStationEnumerate( hServer, &pIdBase, &Count );
            if( rc ) {

                /*
                 * Allocate an Entry for each enumerated winstation.
                 */
                pEntryBase = (PWINSTATIONLIST)malloc( Count * sizeof(WINSTATIONLIST) );
                    if( pEntryBase == NULL ) {

                   pWList = NULL; // We are having severe problems
                   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                   WinStationFreeMemory(pIdBase);
                   RtlLeaveCriticalSection( &WLock );
                             return( FALSE );
                         }

               /*
                * Load up Entries.
                */
                for ( pEntry = pEntryBase, pId = pIdBase;
                      Count ;
                      Count--, pEntry++, pId++ ) {

                    pEntry->LogonId = *pId;
                    pEntry->Next = pWList;
                    pWList = pEntry;
                }

                /*
                 * Free enumerate buffer.
                 */
                WinStationFreeMemory(pIdBase);
                 }

        } // End if pWList == NULL

        pEntry = pWList;
        while ( pEntry ) {

                if( pEntry->LogonId.LogonId == LogonId ) {

                wcsncpy( pName, pEntry->LogonId.WinStationName, MaxSize-1 );
                pName[MaxSize-1] = 0;
                RtlLeaveCriticalSection( &WLock );
                     return( TRUE );
                }
           pEntry = pEntry->Next;
        }

        RtlLeaveCriticalSection( &WLock );
    }

    // If we can not find its name, print its ID #

    wsprintf( pName, L"ID %d", LogonId );

    return( TRUE );
}

/*----------------------------------------------------------------------------------------
/*
 * GetCurrentUserName
 *
 * Get the current UNICODE name for the logon USER for this process
 *
 * Input:
 *
 *   pName - Pointer to wide character buffer for name
 *
 *   MaxSize - Maximum number of characters in buffer (including terminator)
 *
 *
 * Output:
 *
 */
VOID WINAPI
GetCurrentUserName( PWCHAR pName, int MaxSize )
{
    /*
     * The quickest way appears to open the current processes WinStation and
     * get the name from it. The other way would be to open the process, then
     * its token, extract the SID, then lookup the SID in the SAM database.
     * We have conviently stored the user name in the WinStation at Logon
     * time, so we'll use that.
     */
    GetWinStationUserName( SERVERNAME_CURRENT , LOGONID_CURRENT, pName, MaxSize );
    return;
}


/*
 * GetWinStationUserName
 *
 * Get the UNICODE name for the USER for the winstation
 *
 * Input:
 *
 *   hServer - handle to termsrv
 *
 *   LogonId - integer identifier for WinStation
 *
 *   pName - Pointer to wide character buffer for name
 *
 *   MaxSize - Maximum number of characters in buffer (including terminator)
 *
 *
 * Output:
 *
 */
BOOLEAN WINAPI
GetWinStationUserName( HANDLE hServer , ULONG LogonId, PWCHAR pName, int MaxSize )
{
    BOOLEAN rc;
    ULONG ReturnLength;
    WINSTATIONINFORMATION Info;

    if( MaxSize == 0) return( FALSE );

    memset( &Info, 0, sizeof(WINSTATIONINFORMATION) );

    rc = WinStationQueryInformation( hServer,
                                     LogonId,
                                     WinStationInformation,
                                     (PVOID)&Info,
                                     sizeof(WINSTATIONINFORMATION),
                                     &ReturnLength);
    if(!rc){
        pName[0] = 0;
        return( FALSE );
    }
    if(ReturnLength != sizeof(WINSTATIONINFORMATION)) {
        pName[0] = 0; // Version mismatch
        return( FALSE );
    }
    /*
     * Now copy the name out
     */
    if( MaxSize > USERNAME_LENGTH ) {
        MaxSize = USERNAME_LENGTH;
    }
    wcsncpy( pName, Info.UserName, MaxSize-1 );
    pName[MaxSize-1] = 0; // insure null termination if string is truncated
    return( TRUE );
}


/*
 * These variables maintain a one entry cache so that we
 * do not have to keep querying the winstation (causes an LPC)
 * each time called.
 */
static ULONG CachedId = (ULONG)(-1);
static WCHAR CachedUserName[USERNAME_LENGTH];

/**************************************************************************
*
* RefreshWinStationObjectCache
*
* Flush the cache for the WinStationObject name comparision function.
*
**************************************************************************/

VOID WINAPI
RefreshWinStationObjectCache()
{
    CachedId = (ULONG)(-1);
    CachedUserName[0] = 0;
}

/*
 * WinStationObjectMatch
 *
 * General Name match function against a WinStation.
 *
 * The admin utilities can take a user name, winstation name, or
 * a winstation id as an argument to a command that targets a winstation
 * for some action (send a message, query status, reset, etc.)
 *
 * This function does general compares of the supplied name to see if it
 * applies to the given winstation because the name represents the logged
 * on user of the winstation, the winstations system name when attached, or
 * the winstations unique id.
 *
 *
 * NOTE: The caching for this function assumes typical use of comparing this
 *       winstation against a list of names across multiple calls.
 *       It does not optimize for comparing one name at a time across all
 *       winstation(s) in succession.
 *
 * Parameters:
 *
 *   hServer ( input ) remote termsrv
 *
 *   Id (input) WinStation Id for do the match against
 *
 *   pName (input) UNICODE name for match testing
 */

BOOLEAN WINAPI
WinStationObjectMatch( HANDLE hServer , PLOGONID Id, PWCHAR pName )
{
    ULONG tmp;

    /*
     * Handle the wild card case
     */
    if( pName[0] == L'*' ) {
        return( TRUE );
    }

    /*
     * See if the supplied name is the name assigned to the WinStation
     */
    if( !_wcsnicmp( pName, Id->WinStationName, WINSTATIONNAME_LENGTH ) ) {
       return( TRUE );
    }

    /*
     * See if it represents the numerical id for the winstation
     */
    if( iswdigit( pName[0] ) ) {
       tmp = (ULONG)wcstol( pName, NULL, 10 );
       if( tmp == Id->LogonId ) {
          return( TRUE );
       }
    }

    /*
     * Else extract the logged on user name from the winstation itself
     * and compare this.
     */
    if( CachedId == Id->LogonId ) {
       if( !_wcsnicmp( CachedUserName, pName, USERNAME_LENGTH ) ) {
          return( TRUE );
       }
    }

    if ( Id->State == State_Down )
        return( FALSE );

    if( GetWinStationUserName( hServer , Id->LogonId, CachedUserName, USERNAME_LENGTH ) ) {
        CachedId = Id->LogonId;
    }
    else {
       CachedId = (ULONG)(-1); // In case name was trashed
       return( FALSE );
    }

    if( !_wcsnicmp( CachedUserName, pName, USERNAME_LENGTH ) ) {
       return( TRUE );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\c2config\c2cfg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// c2cfg.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "c2cfg.h"
#include "c2cfgDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CC2cfgApp

BEGIN_MESSAGE_MAP(CC2cfgApp, CWinApp)
	//{{AFX_MSG_MAP(CC2cfgApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CC2cfgApp construction

CC2cfgApp::CC2cfgApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CC2cfgApp object

CC2cfgApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CC2cfgApp initialization

BOOL CC2cfgApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CC2cfgDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\c2config\c2cfg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// c2cfg.h : main header file for the C2CFG application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CC2cfgApp:
// See c2cfg.cpp for the implementation of this class
//

class CC2cfgApp : public CWinApp
{
public:
	CC2cfgApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CC2cfgApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CC2cfgApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\c2config\security.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include "c2cfg.h"
#include "c2cfgDlg.h"
#include "security.h"

extern HKEY g_RegEventKey;

void RegistrySecurityCheck( EVENT_CHECK_TYPE *pRegistryEventCheck )
{
    
    ULONG   Status;
        	
    Status = RegOpenKeyExW( HKEY_LOCAL_MACHINE, L"SOFTWARE", 0, KEY_ALL_ACCESS, &g_RegEventKey );
    if( Status != ERROR_SUCCESS )
    {
        // DbgPrint( "Couldn't open registry key\n" );
        return;
    }
  
	Status = RegNotifyChangeKeyValue( g_RegEventKey, 
                                      FALSE, 
                                      REG_NOTIFY_CHANGE_SECURITY,
                                      pRegistryEventCheck->handle, 
                                      TRUE 
                                    );

    if( Status != ERROR_SUCCESS )
    {
        // DbgPrint( "Invalid Reg Handle Created\n" );
        return;
    }

    // DbgPrint( "Created a correct reg handle\n" );
    
    WaitForSingleObject( pRegistryEventCheck->handle, INFINITE );

    // DbgPrint( "The registry was touched\n" );
    pRegistryEventCheck->bEventTriggered = TRUE;
    
}


void DirectorySecurityCheck( EVENT_CHECK_TYPE *pDirectoryEventCheck )
{

        
    // DbgPrint( "Created a correct Dir handle\n" );
    
    WaitForSingleObject( pDirectoryEventCheck->handle, INFINITE );

    // DbgPrint( "The security of directory c:\\ was changed\n" );
    pDirectoryEventCheck->bEventTriggered = TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\c2config\security.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _SECURITY_H_
#define _SECURITY_H_

struct EVENT_CHECK_TYPE
{
	HANDLE   handle;
	BOOLEAN	 bEventTriggered;
};

void DirectorySecurityCheck( EVENT_CHECK_TYPE *pDirectoryEventCheck );
void RegistrySecurityCheck( EVENT_CHECK_TYPE *pRegistryEventCheck );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\c2config\stdafx.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//	c2cfg.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\c2config\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by c2cfg.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_C2CFG_DIALOG                102
#define IDS_TEXT_HIGH                   102
#define IDS_TEXT_MED                    103
#define IDS_TEXT_LOW                    104
#define IDS_ERR_REG                     105
#define IDS_ERR_NO_FILE                 106
#define IDS_C2_ERR                      107
#define IDS_Debug                       109
#define IDS_SUCCESS_FM                  110
#define IDS_C2                          111
#define IDS_FAIL                        112
#define IDS_TEXT_DEFAULT                113
#define IDS_NOT_ADMIN                   114
#define IDR_MAINFRAME                   128
#define IDC_HIGH                        1001
#define IDC_MED                         1002
#define IDC_LOW                         1003
#define IDC_STATUS                      1009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\c2config\c2cfgdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// c2cfgDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CC2cfgDlg dialog

class CC2cfgDlg : public CDialog
{
// Construction
public:
	CC2cfgDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CC2cfgDlg)
	enum { IDD = IDD_C2CFG_DIALOG };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CC2cfgDlg)
	public:
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CC2cfgDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	virtual void OnOK();
	afx_msg void OnHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	HKEY  hKey;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\c2config\c2cfgdlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// c2cfgDlg.cpp : implementation file
//

#include "stdafx.h"
#include "c2cfg.h"
#include "c2cfgDlg.h"
#include "security.h"
#include <hydra\winsta.h>
#include <HYDRA\regapi.h>
#include "..\..\inc\utildll.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CC2cfgDlg dialog

CC2cfgDlg::CC2cfgDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CC2cfgDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CC2cfgDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CC2cfgDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CC2cfgDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CC2cfgDlg, CDialog)
	//{{AFX_MSG_MAP(CC2cfgDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(ID_HELP, OnHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CC2cfgDlg message handlers


BOOL CC2cfgDlg::OnInitDialog()
{
	WCHAR    pwcSecLevel[sizeof("Medium")];
	PWCHAR	 pwcSecurityPath = SECURITY_REG_NAME;
	PWCHAR   pwcSecurity     = CTXSECURITY_SECURITYLEVEL;
	ULONG    ulSize;
	ULONG	 ulType;
	CString  sErrorString;
	CString  sErrorTitle;
	CWnd     *wndRButton;
	CString  sSecLevelString;
		
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here

   	if( TestUserForAdmin( TRUE ) != TRUE )  // param TRUE specifies check for domain admin
	{   
        if( TestUserForAdmin( FALSE ) != TRUE )  // param FALSE specifies check for local admin
        {   sErrorString.LoadString( IDS_NOT_ADMIN );
		    sErrorTitle.LoadString( IDS_C2_ERR );
		    MessageBox( sErrorString, sErrorTitle, MB_OK | MB_ICONEXCLAMATION );
	    	DestroyWindow();
		    return FALSE;
        }
	}
	
	if( RegOpenKeyExW( HKEY_LOCAL_MACHINE, pwcSecurityPath,0,KEY_ALL_ACCESS,&hKey ) )
   {
      //error message box
		sErrorString.LoadString( IDS_ERR_REG );
		sErrorTitle.LoadString( IDS_C2_ERR );
		MessageBox( sErrorString, sErrorTitle,MB_OK );
		DestroyWindow();
		return FALSE;
	}

	if( RegQueryValueExW( hKey,pwcSecurity,0,&ulType,(LPBYTE)pwcSecLevel,&ulSize) )
   {
	   //error message box
		sErrorString.LoadString( IDS_ERR_REG );
		sErrorTitle.LoadString( IDS_C2_ERR );
		MessageBox( sErrorString, sErrorTitle,MB_OK );
		RegCloseKey( hKey );
		DestroyWindow();
		return FALSE;
   }
	
	if( wcscmp( pwcSecLevel,L"Default")== 0 )
    {
		CheckRadioButton( IDC_HIGH, IDC_LOW, IDC_LOW );
		sSecLevelString.LoadString( IDS_TEXT_DEFAULT );
	}
	else if( wcscmp( pwcSecLevel,L"Low")== 0 )
    {
		CheckRadioButton( IDC_HIGH, IDC_LOW, IDC_LOW );
		sSecLevelString.LoadString( IDS_TEXT_LOW );
	}
	else if( wcscmp( pwcSecLevel,L"Medium")== 0 )
    {
		CheckRadioButton( IDC_HIGH, IDC_LOW, IDC_MED );		
		sSecLevelString.LoadString( IDS_TEXT_MED );
		// disable low button
		wndRButton = GetDlgItem( IDC_LOW );
		wndRButton->EnableWindow( FALSE );
	}
	else
   {
		CheckRadioButton( IDC_HIGH, IDC_LOW, IDC_HIGH );
		sSecLevelString.LoadString( IDS_TEXT_HIGH );
		//disable other two buttons
		wndRButton = GetDlgItem( IDC_MED );
		wndRButton->EnableWindow( FALSE );
		wndRButton = GetDlgItem( IDC_LOW );
		wndRButton->EnableWindow( FALSE );

	}
	SetDlgItemText( IDC_STATUS, sSecLevelString );
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CC2cfgDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CC2cfgDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CC2cfgDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

HKEY    g_RegEventKey;

void CC2cfgDlg::OnOK() 
{
	// TODO: Add extra validation here
	WCHAR  pwcPath[MAX_PATH];
	WCHAR  pwc_src[MAX_PATH];
	WCHAR  pwc_dest[MAX_PATH];
	WCHAR  pwcNTF_file[20];
	WCHAR  pwcREG_file[20];
	WCHAR  C2CONFIG[] = L"c2config";

	WCHAR   pwcSecLevel[sizeof("Medium")];
	ULONG   ulSize;
	PWCHAR  pwcSecurity = CTXSECURITY_SECURITYLEVEL;
	WCHAR   szDir[MAX_PATH];
	CString sErrorString;
	CString sErrorTitle;
	CString sMessage;
	CString sMessageTitle;
    
	DWORD                idRegSecCheck,
                         idDirSecCheck;
/************
	Structures containing event handles to wait on and boolean variable
	to set when event occurs
**************/
	EVENT_CHECK_TYPE	 DirectoryEventCheck,	
						 RegistryEventCheck;
	BOOLEAN				 PosixDeleted = FALSE;
	BOOLEAN				 OS2Deleted = FALSE;
	WCHAR                szBuffer[MAX_PATH];
	WCHAR                szFileName[MAX_PATH];
	PWCHAR				 pwc;

	STARTUPINFOW	      StartUpInfo;
	PROCESS_INFORMATION	  ProcessInfo;


	if( IsDlgButtonChecked(IDC_HIGH) )
   {
		wcscpy( pwcNTF_file, L"\\c2ntfhi.inf" );
		wcscpy( pwcREG_file, L"\\c2reghi.inf" );
		wcscpy( pwcSecLevel, L"High");
	}
	else if( IsDlgButtonChecked(IDC_MED) )
   {
		wcscpy( pwcNTF_file, L"\\c2ntfmed.inf" );
		wcscpy( pwcREG_file, L"\\c2regmed.inf" );
		wcscpy( pwcSecLevel, L"Medium" );
	}
	else
    {
		// low 
		wcscpy( pwcNTF_file, L"\\c2ntflow.inf" );
		wcscpy( pwcREG_file, L"\\c2reglow.inf" );
		wcscpy( pwcSecLevel, L"Low");
	}
	
/*************************************************************************************
	What I'm trying to do:  C2config.exe takes in the files c2regacl.inf (registry) 
	and c2ntfacl.inf( file system ).  These files are scripts to set the ACL's on the 
	registry and file system .  There a 3 different
	flavors of each of these files.  One each for LOW, MEDIUM, and HIGH c2 security.  I 
	simply select a file based on the security level selected and then copy it to the 
	the generic name c2regacl.inf or c2ntfacl.inf.

	The user must still run 2 functions in c2config.exe to use these inf files.  After
	c2config.exe runs I do a check to see if they were run.
*************************************************************************************/
	GetSystemDirectoryW( pwcPath, MAX_PATH );
	wcscpy( pwc_src, pwcPath );
	wcscat( pwc_src, pwcNTF_file );
	wcscpy( pwc_dest, pwcPath );
	wcscat( pwc_dest, L"\\c2ntfacl.inf" );
	
	
	if( !CopyFileW(pwc_src, pwc_dest, FALSE) )
    {
        //error message box
        sErrorString.Format( IDS_ERR_NO_FILE, pwcNTF_file+1 );
		sErrorTitle.LoadString( IDS_C2_ERR );
		MessageBox( sErrorString, sErrorTitle,MB_OK );
		RegCloseKey( hKey );
		CDialog::OnOK();
		return;	
	}
			
	*pwc_src = *pwc_dest = L'\0';
	wcscpy( pwc_src, pwcPath );
	wcscat( pwc_src, pwcREG_file );
	wcscpy( pwc_dest, pwcPath );
	wcscat( pwc_dest, L"\\c2regacl.inf" );
			
	if( !CopyFileW(pwc_src, pwc_dest, FALSE) )
    {
		//send an error box out
		sErrorString.Format( IDS_ERR_NO_FILE, pwcREG_file+1 );
		sErrorTitle.LoadString( IDS_C2_ERR );
		MessageBox( sErrorString, sErrorTitle,MB_OK );
		RegCloseKey( hKey );
		CDialog::OnOK();
		return;	
	}


	memset( &StartUpInfo,'\0', sizeof(STARTUPINFO) );
	StartUpInfo.cb          = sizeof(STARTUPINFO);
	StartUpInfo.wShowWindow = SW_SHOWDEFAULT;

/*****************************************************************************
	These threads are started to check if c2config is run correctly -- changing
	the security ACL's on the registry and specified files.  Theses threads are 
	passed an event handle and a boolean variable.  If the security they are 
	looking at is changed, the event is triggered and the bolean variable is set.
 *****************************************************************************/

    RegistryEventCheck.handle = CreateEvent( NULL, FALSE, FALSE, NULL );
	RegistryEventCheck.bEventTriggered = FALSE;    

    if(  RegistryEventCheck.handle != NULL )
    {
		CreateThread( NULL,
					  0, 
					  (LPTHREAD_START_ROUTINE)RegistrySecurityCheck,
					  &RegistryEventCheck,
					  0,
					  &idRegSecCheck
					);
	}


	/* I only want to keep the drive letter info part of the system directory */
	GetSystemDirectoryW( szDir, MAX_PATH );
	szDir[3] = L'\0';

	DirectoryEventCheck.handle = FindFirstChangeNotificationW( szDir, 
															TRUE, 
															FILE_NOTIFY_CHANGE_SECURITY );
	DirectoryEventCheck.bEventTriggered = FALSE;
    
	if( DirectoryEventCheck.handle != INVALID_HANDLE_VALUE )
    {
		CreateThread( NULL,
                  0, 
                  (LPTHREAD_START_ROUTINE)DirectorySecurityCheck,
                  &DirectoryEventCheck,
                  0,
                  &idDirSecCheck
                );
	}

/******* Run C2config and then I'll check to see what the user did **************/
	CreateProcessW(NULL, C2CONFIG, NULL, NULL, FALSE, 0, NULL, NULL, &StartUpInfo, &ProcessInfo );

    WaitForSingleObject( ProcessInfo.hProcess, INFINITE );

/********************************************************************
  I can't guarentee that the created threads ever stop waiting for an 
  event.  So they would not always be able to close there handles.  So 
  I do it here.
 ***********************************************************************/
    RegCloseKey( g_RegEventKey );
	CloseHandle( RegistryEventCheck.handle );
	FindCloseChangeNotification( DirectoryEventCheck.handle );
    
/**********************************************************************
	Both the Registry and the Directory Security levels must be set, or
	I do not record the change in the directory.
 **********************************************************************/
    wcscpy( szFileName, L"psxss.exe" );
	if( SearchPathW( NULL, szFileName, NULL, MAX_PATH, szBuffer, &pwc ) == 0 )
		PosixDeleted = TRUE;
	
	wcscpy( szFileName, L"os2.exe" );
	if( SearchPathW( NULL, szFileName, NULL, MAX_PATH, szBuffer, &pwc ) == 0 )
		OS2Deleted = TRUE;
	
	
	if( (RegistryEventCheck.bEventTriggered == TRUE) && 
		(DirectoryEventCheck.bEventTriggered == TRUE) &&
		(PosixDeleted == TRUE) &&
		(OS2Deleted == TRUE) 
	  )
    {
		ulSize = ( wcslen(pwcSecLevel) + 1 ) * sizeof(WCHAR);
		RegSetValueExW( hKey,pwcSecurity,0,REG_SZ,(LPBYTE)pwcSecLevel,ulSize );
		
		sMessage.Format( IDS_SUCCESS_FM, pwcSecLevel );
		sMessageTitle.LoadString( IDS_C2 );
		MessageBox( sMessage, sMessageTitle, MB_OK );	
	}
	else
    {
        sMessage.LoadString( IDS_FAIL );
		sMessageTitle.LoadString( IDS_C2 );
		MessageBox( sMessage, sMessageTitle,MB_OK );
	}

	RegCloseKey( hKey );

	CDialog::OnOK();
}

void CC2cfgDlg::WinHelp(DWORD dwData, UINT nCmd) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	CDialog::WinHelp(dwData, nCmd);
}


void CC2cfgDlg::OnHelp() 
{
	// TODO: Add your control notification handler code here
	WinHelp(0, HELP_CONTENTS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\c2config\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\installr\installr.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// installr.h : main header file for the INSTALLR application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CInstallrApp:
// See installr.cpp for the implementation of this class
//

class CInstallrApp : public CWinApp
{
public:
	CInstallrApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInstallrApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CInstallrApp)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\installr\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by INSTALLR.RC
//
#define IDR_MAINFRAME					128
#define IDD_INSTALLR_DIALOG				102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\installr\installrdlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// installrDlg.cpp : implementation file
//

#include "stdafx.h"
#include "installr.h"
#include "installrDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInstallrDlg dialog

CInstallrDlg::CInstallrDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CInstallrDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CInstallrDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CInstallrDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInstallrDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CInstallrDlg, CDialog)
	//{{AFX_MSG_MAP(CInstallrDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInstallrDlg message handlers

BOOL CInstallrDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CInstallrDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

HCURSOR CInstallrDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\installr\stdafx.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//	installr.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\installr\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

//#include <citrix\winframe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\installr\installrdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// installrDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CInstallrDlg dialog

class CInstallrDlg : public CDialog
{
// Construction
public:
	CInstallrDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CInstallrDlg)
	enum { IDD = IDD_INSTALLR_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInstallrDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CInstallrDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\installr\installr.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// installr.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include <hydra/winsta.h>
#include "../../inc/utildll.h"
#include "installr.h"
#include "installrDlg.h"
#include "process.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInstallrApp

BEGIN_MESSAGE_MAP(CInstallrApp, CWinApp)
	//{{AFX_MSG_MAP(CInstallrApp)
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInstallrApp construction

CInstallrApp::CInstallrApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CInstallrApp object

CInstallrApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CInstallrApp initialization

BOOL CInstallrApp::InitInstance()
{
	// Standard initialization

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	if (TestUserForAdmin(FALSE) || TestUserForAdmin(TRUE)) {
		TCHAR sysdir[MAX_PATH], path[MAX_PATH];
		GetSystemDirectory(sysdir, MAX_PATH * sizeof(TCHAR));
		_tcscpy(path, sysdir);
		_tcscat(path, TEXT("\\nhloader.exe"));
		_wspawnl(_P_WAIT, path, TEXT("foo"), NULL);
	}

	// Since the loader has been run, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\allsrvpg.cpp ===
/*******************************************************************************
*
* allsrvpg.cpp
*
* implementations of the All Servers info pages
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\allsrvpg.cpp  $
*
*     Rev 1.8   19 Feb 1998 20:01:44   donm
*  removed latest extension DLL support
*
*     Rev 1.7   19 Feb 1998 17:39:48   donm
*  removed latest extension DLL support
*
*     Rev 1.6   15 Feb 1998 09:14:56   donm
*  update
*
*     Rev 1.2   19 Jan 1998 17:36:06   donm
*  new ui behavior for domains and servers
*
*     Rev 1.5   19 Jan 1998 16:45:34   donm
*  new ui behavior for domains and servers
*
*     Rev 1.4   03 Nov 1997 15:18:28   donm
*  Added descending sort
*
*     Rev 1.3   18 Oct 1997 18:49:38   donm
*  update
*
*     Rev 1.2   13 Oct 1997 18:41:08   donm
*  update
*
*     Rev 1.1   26 Aug 1997 19:13:56   donm
*  bug fixes/changes from WinFrame 1.7
*
*     Rev 1.0   30 Jul 1997 17:10:18   butchd
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "admindoc.h"
#include "allsrvpg.h"

#include <malloc.h>                     // for alloca used by Unicode conversion macros
#include <mfc42\afxconv.h>           // for Unicode conversion macros
//USES_CONVERSION
static int _convert;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


////////////////////////////////
// MESSAGE MAP: CAllServerServersPage
//
IMPLEMENT_DYNCREATE(CAllServerServersPage, CFormView)

BEGIN_MESSAGE_MAP(CAllServerServersPage, CFormView)
        //{{AFX_MSG_MAP(CAllServerServersPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_SERVER_LIST, OnColumnclick)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_SERVER_LIST, OnServerItemChanged)
        ON_NOTIFY(NM_SETFOCUS, IDC_SERVER_LIST, OnSetfocusServerList)
        //ON_NOTIFY( NM_KILLFOCUS , IDC_SERVER_LIST , OnKillfocusServerList )
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CAllServerServersPage ctor
//
CAllServerServersPage::CAllServerServersPage()
        : CAdminPage(CAllServerServersPage::IDD)
{
        //{{AFX_DATA_INIT(CAllServerServersPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_bSortAscending = TRUE;

}  // end CAllServerServersPage ctor


/////////////////////////////
// F'N: CAllServerServersPage dtor
//
CAllServerServersPage::~CAllServerServersPage()
{

}  // end CAllServerServersPage dtor


////////////////////////////////////////
// F'N: CAllServerServersPage::DoDataExchange
//
void CAllServerServersPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAllServerServersPage)
        DDX_Control(pDX, IDC_SERVER_LIST, m_ServerList);
        //}}AFX_DATA_MAP

}  // end CAllServerServersPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CAllServerServersPage::AssertValid
//
void CAllServerServersPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CAllServerServersPage::AssertValid


//////////////////////////////
// F'N: CAllServerServersPage::Dump
//
void CAllServerServersPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CAllServerServersPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CAllServerServersPage::OnSize
//
void CAllServerServersPage::OnSize(UINT nType, int cx, int cy)
{
        RECT rect;
        GetClientRect(&rect);

        rect.top += LIST_TOP_OFFSET;

        if(m_ServerList.GetSafeHwnd())
                m_ServerList.MoveWindow(&rect, TRUE);

        // CFormView::OnSize(nType, cx, cy);

}  // end CAllServerServersPage::OnSize


static ColumnDef ServerColumns[] = {
        CD_SERVER,
        CD_TCPADDRESS,
        CD_IPXADDRESS,
        CD_NUM_SESSIONS
};

#define NUM_AS_SERVER_COLUMNS sizeof(ServerColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CAllServerServersPage::OnInitialUpdate
//
void CAllServerServersPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        BuildImageList();               // builds the image list for the list control

        CString columnString;

        for(int col = 0; col < NUM_AS_SERVER_COLUMNS; col++) {
                columnString.LoadString(ServerColumns[col].stringID);
                m_ServerList.InsertColumn(col, columnString, ServerColumns[col].format, ServerColumns[col].width, col);
        }

        m_CurrentSortColumn = SERVERS_COL_SERVER;

}  // end CAllServerServersPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CAllServerServersPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CAllServerServersPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 4, 0);

        m_idxServer = AddIconToImageList(IDI_SERVER);
        m_idxCurrentServer = AddIconToImageList(IDI_CURRENT_SERVER);
        m_idxNotSign = AddIconToImageList(IDI_NOTSIGN);
        m_idxQuestion = AddIconToImageList(IDI_QUESTIONMARK);

        m_ImageList.SetOverlayImage(m_idxNotSign, 1);
        m_ImageList.SetOverlayImage(m_idxQuestion, 2);

        m_ServerList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CAllServerServersPage::BuildImageList


/////////////////////////////////////////
// F'N: CAllServerServersPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CAllServerServersPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CAllServerServersPage::AddIconToImageList


//////////////////////////////
// F'N: CAllServerServersPage::Reset
//
void CAllServerServersPage::Reset(void *p)
{
    CTreeNode *pT = ( CTreeNode * )p;

    if( pT != NULL )
    {
        DisplayServers( pT->GetNodeType( ) );
    }
    else
    {
        DisplayServers( NODE_NONE );
    }

} // end CAllServerServersPage::Reset


//////////////////////////////
// F'N: CAllServerServersPage::AddServer
//
void CAllServerServersPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // We have to make sure the server isn't already in the list
        // Add the server to the list
        if(AddServerToList(pServer)) {
            // Tell the list to sort itself
            LockListControl();
            SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

}  // end CAllServerServersPage::AddServer


//////////////////////////////
// F'N: CAllServerServersPage::RemoveServer
//
void CAllServerServersPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

        LockListControl();
        // Find out how many items in the list
        int ItemCount = m_ServerList.GetItemCount();

        // Go through the items are remove this server
        for(int item = 0; item < ItemCount; item++) {
                CServer *pListServer = (CServer*)m_ServerList.GetItemData(item);

                if(pListServer == pServer) {
                        m_ServerList.DeleteItem(item);
                        pServer->ClearAllSelected();
                        break;
                }
        }
        UnlockListControl();

}  // end CAllServerServersPage::RemoveServer


//////////////////////////////
// F'N: CAllServerServersPage::UpdateServer
//
void CAllServerServersPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

        // If we aren't connected to the server anymore, remove it from the list control
        if(pServer->IsState(SS_NOT_CONNECTED)) {
                RemoveServer(pServer);
                return;
        }

        // If we just connected to this server, add it to the list control
        if(pServer->IsState(SS_GOOD)) {
                AddServer(pServer);
                return;
        }

        LockListControl();
        // Find the Server in the list
        LV_FINDINFO FindInfo;
        FindInfo.flags = LVFI_PARAM;
        FindInfo.lParam = (LPARAM)pServer;

        // Find the Server in our list
        int item = m_ServerList.FindItem(&FindInfo, -1);
        if(item != -1) {
                // Change the icon overlay
                USHORT NewState;
                // Change the icon/overlay for the server
                // If the server isn't sane, put a not sign over the icon
                if(!pServer->IsServerSane()) NewState = STATE_NOT;
                // If we aren't done getting all the information about this server,
                // put a question mark over the icon
                else if(!pServer->IsState(SS_GOOD)) NewState = STATE_QUESTION;
                // If it is fine, we want to remove any overlays from the icon
                else NewState = STATE_NORMAL;

                // Set the tree item to the new state
                m_ServerList.SetItemState(item, NewState, 0x0F00);

                ExtServerInfo *pExtServerInfo = pServer->GetExtendedInfo();

                // TCP Address
                m_ServerList.SetItemText(item, SERVERS_COL_TCPADDRESS, pExtServerInfo->TcpAddress);

                // IPX Address
                m_ServerList.SetItemText(item, SERVERS_COL_IPXADDRESS, pExtServerInfo->IpxAddress);

                CString NumString;
                if(pExtServerInfo && (pExtServerInfo->Flags & ESF_WINFRAME)) {
                        NumString.Format(TEXT("%lu"), pExtServerInfo->ServerTotalInUse);
                } else {
                        NumString.LoadString(IDS_NOT_APPLICABLE);
                }

                m_ServerList.SetItemText(item, SERVERS_COL_NUMWINSTATIONS, NumString);
        }

        // Tell the list to sort itself
        if(m_CurrentSortColumn == SERVERS_COL_NUMWINSTATIONS
                || m_CurrentSortColumn == SERVERS_COL_TCPADDRESS
                || m_CurrentSortColumn == SERVERS_COL_IPXADDRESS)
                        SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);

        UnlockListControl();

}  // end CAllServerServersPage::UpdateServer


//////////////////////////////
// F'N: CAllServerServersPage::AddServerToList
//
BOOL CAllServerServersPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

        // If we aren't currently connected to the server, don't display it
        if(!pServer->IsState(SS_GOOD)) return FALSE;

        LockListControl();

        // Find the Server in the list
        LV_FINDINFO FindInfo;
        FindInfo.flags = LVFI_PARAM;
        FindInfo.lParam = (LPARAM)pServer;

        // Find the Server in our list
        int item = m_ServerList.FindItem(&FindInfo, -1);
        if(item != -1) return FALSE;

        //////////////////////
        // Fill in the columns
        //////////////////////
        // Name - put at the end of the list
        item = m_ServerList.InsertItem(m_ServerList.GetItemCount(), pServer->GetName(),
                                                                pServer->IsCurrentServer() ? m_idxCurrentServer : m_idxServer);

        // If the server isn't sane, put a not sign over the icon
        if(!pServer->IsServerSane()) m_ServerList.SetItemState(item, STATE_NOT, 0x0F00);
        // If we aren't done getting all the information about this server,
        // put a question mark over the icon
        else if(!pServer->IsState(SS_GOOD)) m_ServerList.SetItemState(item, STATE_QUESTION, 0x0F00);

        ExtServerInfo *pExtServerInfo = pServer->GetExtendedInfo();

        // TCP Address
        m_ServerList.SetItemText(item, SERVERS_COL_TCPADDRESS, pExtServerInfo->TcpAddress);

        // IPX Address
        m_ServerList.SetItemText(item, SERVERS_COL_IPXADDRESS, pExtServerInfo->IpxAddress);

        // Connected
        CString NumString;
        if(pExtServerInfo && (pExtServerInfo->Flags & ESF_WINFRAME)) {
                NumString.Format(TEXT("%lu"), pExtServerInfo->ServerTotalInUse);
        } else {
                NumString.LoadString(IDS_NOT_APPLICABLE);
        }

        m_ServerList.SetItemText(item, SERVERS_COL_NUMWINSTATIONS, NumString);

        m_ServerList.SetItemData(item, (DWORD_PTR)pServer);

        UnlockListControl();

    return TRUE;

}  // end CAllServerServersPage::AddServerToList


/////////////////////////////////////
// F'N: CAllServerServersPage::DisplayServers
//
void CAllServerServersPage::DisplayServers( NODETYPE ntType )
{
    LockListControl();

    // Clear out the list control
    m_ServerList.DeleteAllItems();

    // Get a pointer to our document
    CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

    // Get a pointer to the list of servers
    doc->LockServerList();
    CObList *pServerList = doc->GetServerList();

    // Iterate through the Server list
    POSITION pos = pServerList->GetHeadPosition();

    while(pos)
    {
        CServer *pServer = (CServer*)pServerList->GetNext(pos);

        // check to see if its just for favorites
        if( ntType == NODE_FAV_LIST )        
        { 
            if( pServer->GetTreeItemFromFav() != NULL )
            {
                AddServerToList(pServer);
            }
        }
        else if( ntType == NODE_THIS_COMP )
        {
            if( pServer->GetTreeItemFromThisComputer( ) != NULL )
            {
                AddServerToList( pServer );
            }
        }
        else
        {
            AddServerToList(pServer);
        }

    }  // end while(pos)

    doc->UnlockServerList();

    UnlockListControl();

}  // end CAllServerServersPage::DisplayServers


//////////////////////////////
// F'N: CAllServerServersPage::OnServerItemChanged
//
void CAllServerServersPage::OnServerItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here
        CServer *pServer = (CServer*)m_ServerList.GetItemData(pLV->iItem);

        if(pLV->uNewState & LVIS_SELECTED) {
                pServer->SetSelected();
        }

        if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
                pServer->ClearSelected();
        }

        *pResult = 0;

}  // end CAllServerServersPage::OnServerItemChanged


//////////////////////////////
// F'N: CAllServerServersPage::OnColumnclick
//
void CAllServerServersPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CAllServerServersPage::OnColumnclick


//////////////////////////////
// F'N: CAllServerServersPage::OnContextMenu
//
void CAllServerServersPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_ServerList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_ServerList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_ServerList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }
                /*
                RECT rect;
                m_ServerList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_ServerList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                        return;
        }

        CMenu menu;
        menu.LoadMenu(IDR_SERVER_POPUP);
        // set the temp selected item so that handler doesn't think
        // this came from the tree
        // Get a pointer to our document
        CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();
        doc->SetTreeTemp(NULL, NODE_NONE);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CAllServerServersPage::OnContextMenu


////////////////////////////////
// MESSAGE MAP: CAllServerUsersPage
//
IMPLEMENT_DYNCREATE(CAllServerUsersPage, CFormView)

BEGIN_MESSAGE_MAP(CAllServerUsersPage, CFormView)
        //{{AFX_MSG_MAP(CAllServerUsersPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_USER_LIST, OnColumnclick)
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_USER_LIST, OnUserItemChanged)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(NM_SETFOCUS, IDC_USER_LIST, OnSetfocusUserList)
        //ON_NOTIFY( NM_KILLFOCUS , IDC_USER_LIST , OnKillfocusUserList )
        // ON_WM_SETFOCUS( )
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CAllServerUsersPage ctor
//
CAllServerUsersPage::CAllServerUsersPage()
        : CAdminPage(CAllServerUsersPage::IDD)
{
        //{{AFX_DATA_INIT(CAllServerUsersPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_bSortAscending = TRUE;

}  // end CAllServerUsersPage ctor


/////////////////////////////
// F'N: CAllServerUsersPage dtor
//
CAllServerUsersPage::~CAllServerUsersPage()
{
}  // end CAllServerUsersPage dtor


////////////////////////////////////////
// F'N: CAllServerUsersPage::DoDataExchange
//
void CAllServerUsersPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAllServerUsersPage)
        DDX_Control(pDX, IDC_USER_LIST, m_UserList);
        //}}AFX_DATA_MAP

}  // end CAllServerUsersPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CAllServerUsersPage::AssertValid
//
void CAllServerUsersPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CAllServerUsersPage::AssertValid


//////////////////////////////
// F'N: CAllServerUsersPage::Dump
//
void CAllServerUsersPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CAllServerUsersPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CAllServerUsersPage::OnSize
//
void CAllServerUsersPage::OnSize(UINT nType, int cx, int cy)
{
        RECT rect;
        GetClientRect(&rect);

        rect.top += LIST_TOP_OFFSET;

        if(m_UserList.GetSafeHwnd())
                m_UserList.MoveWindow(&rect, TRUE);

        // CFormView::OnSize(nType, cx, cy);
}  // end CAllServerUsersPage::OnSize


static ColumnDef UserColumns[] = {
        CD_SERVER,
        CD_USER3,
        CD_SESSION,
        CD_ID,
        CD_STATE,
        CD_IDLETIME,
        CD_LOGONTIME
};

#define NUM_AS_USER_COLUMNS sizeof(UserColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CAllServerUsersPage::OnInitialUpdate
//
void CAllServerUsersPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        BuildImageList();               // builds the image list for the list control

        CString columnString;

        for(int col = 0; col < NUM_AS_USER_COLUMNS; col++) {
                columnString.LoadString(UserColumns[col].stringID);
                m_UserList.InsertColumn(col, columnString, UserColumns[col].format, UserColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_USERS_COL_SERVER;

}  // end CAllServerUsersPage::OnInitialUpdate


//////////////////////////////
// F'N: CAllServerUsersPage::OnUserItemChanged
//
void CAllServerUsersPage::OnUserItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{   
    NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

    if(pLV->uNewState & LVIS_SELECTED)
    {
        CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(pLV->iItem);
        pWinStation->SetSelected();
    }

    if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED))
    {
        CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(pLV->iItem);
        pWinStation->ClearSelected();       
    }
    
    *pResult = 0;

}  // end CAllServerUsersPage::OnUserItemChanged


/////////////////////////////////////
// F'N: CAllServerUsersPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CAllServerUsersPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 2, 0);

        m_idxUser = AddIconToImageList(IDI_USER);
        m_idxCurrentUser  = AddIconToImageList(IDI_CURRENT_USER);

        m_UserList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CAllServerUsersPage::BuildImageList


/////////////////////////////////////////
// F'N: CAllServerUsersPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CAllServerUsersPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CAllServerUsersPage::AddIconToImageList


//////////////////////////////
// F'N: CAllServerUsersPage::Reset
//
void CAllServerUsersPage::Reset(void *p)
{
    CTreeNode *pT = ( CTreeNode * )p;

    if( pT != NULL )
    {
        DisplayUsers( pT->GetNodeType() );
    }   
    else
    {
        DisplayUsers( NODE_NONE );
    }

} // end CAllServerUsersPage::Reset


//////////////////////////////
// F'N: CAllServerUsersPage::AddServer
//
void CAllServerUsersPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add the server's users to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            LockListControl();
            SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

} // end CAllServerUsersPage::AddServer


//////////////////////////////
// F'N: CAllServerUsersPage::RemoveServer
//
void CAllServerUsersPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

        LockListControl();

        int ItemCount = m_UserList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(item-1);
                CServer *pListServer = pWinStation->GetServer();

                if(pListServer == pServer) {
                        m_UserList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

        UnlockListControl();

} // end CAllServerUsersPage::RemoveServer


//////////////////////////////
// F'N: CAllServerUsersPage::UpdateServer
//
void CAllServerUsersPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

} // end CAllServerUsersPage::UpdateServer


//////////////////////////////
// F'N: CAllServerUsersPage::UpdateWinStations
//
void CAllServerUsersPage::UpdateWinStations(CServer *pServer)
{
        ASSERT(pServer);

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
        BOOL bAnyChanged = FALSE;
        BOOL bAnyAdded = FALSE;

        // Loop through the WinStations
        pServer->LockWinStationList();
        CObList *pWinStationList = pServer->GetWinStationList();

        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                LV_FINDINFO FindInfo;
                FindInfo.flags = LVFI_PARAM;
                FindInfo.lParam = (LPARAM)pWinStation;

                // Find the WinStation in our list
                int item = m_UserList.FindItem(&FindInfo, -1);

                // If the WinStation is new and isn't currently in the list,
                // add it to the list
                if(pWinStation->IsNew() && pWinStation->HasUser() && item == -1) {

                        AddUserToList(pWinStation);
                        bAnyAdded = TRUE;
                        continue;
                }

                // If the WinStation is no longer current,
                // remove it from the list
                if((!pWinStation->IsCurrent() || !pWinStation->HasUser()) && item != -1) {
                        // Remove the WinStation from the list
                        m_UserList.DeleteItem(item);
                        pWinStation->ClearSelected();
                        continue;
                }

                // If the WinStation info has changed, change
                // it's info in our tree
                if(pWinStation->IsChanged() && item != -1) {
                        // change the user name
                        m_UserList.SetItemText(item, AS_USERS_COL_USER, pWinStation->GetUserName());
                        // change the WinStation Name
                        if(pWinStation->GetName()[0])
                            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, pWinStation->GetName());
                        else {
                                CString NameString(" ");
                                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, NameString);
                        }


            // change the Connect State
                        m_UserList.SetItemText(item, AS_USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));
                        // change the Idle Time
                        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

                        ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

                        if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
                        {
                                ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
                        }
                        else wcscpy(IdleTimeString, TEXT("."));

                        m_UserList.SetItemText(item, AS_USERS_COL_IDLETIME, IdleTimeString);
                        // change the Logon Time
                        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
                        // We don't want to pass a 0 logon time to DateTimeString()
                        // It will blow up if the timezone is GMT
                        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                                pDoc->FixUnknownString(LogonTimeString);
                        }
                        else LogonTimeString[0] = '\0';
                        // change the

                        m_UserList.SetItemText(item, AS_USERS_COL_LOGONTIME, LogonTimeString);

                        if(m_CurrentSortColumn != AS_USERS_COL_ID)
                                bAnyChanged = TRUE;

                        continue;
                }

                // If the WinStation is not in the list but now has a user, add it to the list
                if(item == -1 && pWinStation->IsCurrent() && pWinStation->HasUser()) {
                        AddUserToList(pWinStation);
                        bAnyAdded = TRUE;
                }
        }

        pServer->UnlockWinStationList();

        if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);

}  // end CAllServerUsersPage::UpdateWinStations


//////////////////////////////
// F'N: CAllServerUsersPage::AddUserToList
//
int CAllServerUsersPage::AddUserToList(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        CServer *pServer = pWinStation->GetServer();

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        LockListControl();
        //////////////////////
        // Fill in the columns
        //////////////////////
        // Server - put at the end of the list
        int item = m_UserList.InsertItem(m_UserList.GetItemCount(), pServer->GetName(),
                pWinStation->IsCurrentUser() ? m_idxCurrentUser : m_idxUser);

        // User
        m_UserList.SetItemText(item, AS_USERS_COL_USER, pWinStation->GetUserName());

        // WinStation Name
        if(pWinStation->GetName()[0])
            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, pWinStation->GetName());
        else {
                CString NameString(" ");
                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, NameString);
        }

        // Logon ID
        CString ColumnString;
        ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
        m_UserList.SetItemText(item, AS_USERS_COL_ID, ColumnString);

        // Connect State
        m_UserList.SetItemText(item, AS_USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

        // Idle Time
        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

        ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

        if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
        {
                ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
        }
        else wcscpy(IdleTimeString, TEXT("."));

        m_UserList.SetItemText(item, AS_USERS_COL_IDLETIME, IdleTimeString);

        // Logon Time
        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
        // We don't want to pass a 0 logon time to DateTimeString()
        // It will blow up if the timezone is GMT
        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                pDoc->FixUnknownString(LogonTimeString);
        }
        else LogonTimeString[0] = '\0';

        m_UserList.SetItemText(item, AS_USERS_COL_LOGONTIME, LogonTimeString);

        // Attach a pointer to the CWinStation structure to the list item
        m_UserList.SetItemData(item, (DWORD_PTR)pWinStation);
        
        //bug #191727
        //m_UserList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

        UnlockListControl();

        return item;

}  // end CAllServerUsersPage::AddUserToList


//////////////////////////////
// F'N: CAllServerUsersPage::AddServerToList
//
BOOL CAllServerUsersPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

        pServer->LockWinStationList();
        // Get a pointer to this server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();

        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                // only show the WinStation if it has a user
                if(pWinStation->HasUser()) {
                        AddUserToList(pWinStation);
                }
        }  // end while(pos)

        pServer->UnlockWinStationList();

    return TRUE;

}  // end CAllServerUsersPage::AddServerToList


//////////////////////////////
// F'N: CAllServerUsersPage::OnColumnclick
//
void CAllServerUsersPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CAllServerUsersPage::OnColumnclick


//////////////////////////////
// F'N: CAllServerUsersPage::OnContextMenu
//
void CAllServerUsersPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_UserList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_UserList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }

                /*
                RECT rect;
                m_UserList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_UserList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                {
                    //
                    // ListView HitTest bug? return -1 but item display as selected.
                    // workaround for now, Al can fix this later
                    //
                    UINT iCount = m_UserList.GetItemCount( );
                    RECT rc;

                    for( Item = 0 ; Item < iCount ; Item++ )
                    {
                        if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                            break;
                        }
                    }

                    if( Item >= iCount )
                    {
                        return;
                    }

                }

                //
                // NM_RCLICK (WM_NOTIFY) then WM_CNTEXTMENU but no NM_ITEMCHANGED message
                // manually set it to selected state
                //
                CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(Item);

                if( !pWinStation )
                    return;

                if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                {
                    pWinStation->SetSelected();
                }
        }

        CMenu menu;

        menu.LoadMenu(IDR_USER_POPUP);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CAllServerUsersPage::OnContextMenu


/////////////////////////////////////
// F'N: CAllServerUsersPage::DisplayUsers
//
void CAllServerUsersPage::DisplayUsers( NODETYPE ntType )
{
        LockListControl();

        // Clear out the list control
        m_UserList.DeleteAllItems();

                // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos2 = pServerList->GetHeadPosition();

        while(pos2)
        {           
            CServer *pServer = (CServer*)pServerList->GetNext(pos2);

            if( ntType == NODE_FAV_LIST )        
            {
                if( pServer->GetTreeItemFromFav() != NULL )
                {
                    AddServerToList(pServer);
                }
            }
            else if( ntType == NODE_THIS_COMP )
            {
                if( pServer->GetTreeItemFromThisComputer() != NULL )
                {
                    AddServerToList(pServer);
                }
            }
            else
            {
                AddServerToList( pServer );
            }
        } // end while(pos2)

        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

        UnlockListControl();

}  // end CAllServerUsersPage::DisplayUsers

/////////////////////////////////////
// F'N: CAllServerUsersPage::ClearSelections
//
void CAllServerUsersPage::ClearSelections()
{
    
    if(m_UserList.m_hWnd != NULL)
    {
        POSITION pos = m_UserList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nItem = m_UserList.GetNextSelectedItem(pos);
            // you could do your own processing on nItem here
            m_UserList.SetItemState(nItem,0,LVIS_SELECTED);
        }
    }
}

////////////////////////////////
// MESSAGE MAP: CAllServerWinStationsPage
//
IMPLEMENT_DYNCREATE(CAllServerWinStationsPage, CFormView)

BEGIN_MESSAGE_MAP(CAllServerWinStationsPage, CFormView)
        //{{AFX_MSG_MAP(CAllServerWinStationsPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_WINSTATION_LIST, OnColumnclick)
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_WINSTATION_LIST, OnWinStationItemChanged)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(NM_SETFOCUS, IDC_WINSTATION_LIST, OnSetfocusWinstationList)
        //ON_NOTIFY( NM_KILLFOCUS , IDC_WINSTATION_LIST , OnKillfocusWinstationList )
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CAllServerWinStationsPage ctor
//
CAllServerWinStationsPage::CAllServerWinStationsPage()
        : CAdminPage(CAllServerWinStationsPage::IDD)
{
        //{{AFX_DATA_INIT(CAllServerWinStationsPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_bSortAscending = TRUE;

}  // end CAllServerWinStationsPage ctor


/////////////////////////////
// F'N: CAllServerWinStationsPage dtor
//
CAllServerWinStationsPage::~CAllServerWinStationsPage()
{

}  // end CAllServerWinStationsPage dtor


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::DoDataExchange
//
void CAllServerWinStationsPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAllServerWinStationsPage)
        DDX_Control(pDX, IDC_WINSTATION_LIST, m_StationList);
        //}}AFX_DATA_MAP

}  // end CAllServerWinStationsPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CAllServerWinStationsPage::AssertValid
//
void CAllServerWinStationsPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CAllServerWinStationsPage::AssertValid


//////////////////////////////
// F'N: CAllServerWinStationsPage::Dump
//
void CAllServerWinStationsPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CAllServerWinStationsPage::Dump

#endif //_DEBUG


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::OnWinStationItemChanged
//
void CAllServerWinStationsPage::OnWinStationItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;


    if(pLV->uNewState & LVIS_SELECTED)
    {
        CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(pLV->iItem);
        pWinStation->SetSelected();
    }
    if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED))
    {
        CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(pLV->iItem);
        pWinStation->ClearSelected();        
    }

    *pResult = 0;

}  // end CAllServerWinStationsPage::OnWinStationItemChanged


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::OnSize
//
void CAllServerWinStationsPage::OnSize(UINT nType, int cx, int cy)
{
        RECT rect;
        GetClientRect(&rect);

        rect.top += LIST_TOP_OFFSET;

        if(m_StationList.GetSafeHwnd())
                m_StationList.MoveWindow(&rect, TRUE);

        // CFormView::OnSize(nType, cx, cy);

}  // end CAllServerWinStationsPage::OnSize


static ColumnDef WinsColumns[] = {
        CD_SERVER,
        CD_SESSION2,
        CD_USER2,
        CD_ID,
        CD_STATE,
        CD_TYPE,
        CD_CLIENT_NAME,
        CD_IDLETIME,
        CD_LOGONTIME,
        CD_COMMENT
};

#define NUM_AS_WINS_COLUMNS sizeof(WinsColumns)/sizeof(ColumnDef)

////////////////////////////////////////
// F'N: CAllServerWinStationsPage::OnInitialUpdate
//
void CAllServerWinStationsPage::OnInitialUpdate()
{
        // Call the parent class
        CFormView::OnInitialUpdate();

        // builds the image list for the list control
        BuildImageList();

        // Add the column headings
        CString columnString;

        for(int col = 0; col < NUM_AS_WINS_COLUMNS; col++) {
                columnString.LoadString(WinsColumns[col].stringID);
                m_StationList.InsertColumn(col, columnString, WinsColumns[col].format, WinsColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_WS_COL_SERVER;

}  // end CAllServerWinStationsPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CAllServerWinStationsPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CAllServerWinStationsPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 11, 0);

        m_idxBlank  = AddIconToImageList(IDI_BLANK);
        m_idxCitrix = AddIconToImageList(IDR_MAINFRAME);
        m_idxServer = AddIconToImageList(IDI_SERVER);
        m_idxConsole = AddIconToImageList(IDI_CONSOLE);
        m_idxNet = AddIconToImageList(IDI_NET);
        m_idxAsync = AddIconToImageList(IDI_ASYNC);
        m_idxCurrentConsole = AddIconToImageList(IDI_CURRENT_CONSOLE);
        m_idxCurrentNet = AddIconToImageList(IDI_CURRENT_NET);
        m_idxCurrentAsync = AddIconToImageList(IDI_CURRENT_ASYNC);
        m_idxDirectAsync = AddIconToImageList(IDI_DIRECT_ASYNC);
        m_idxCurrentDirectAsync = AddIconToImageList(IDI_CURRENT_DIRECT_ASYNC);

        m_StationList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CAllServerWinStationsPage::BuildImageList


/////////////////////////////////////////
// F'N: CAllServerWinStationsPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CAllServerWinStationsPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CAllServerWinStationsPage::AddIconToImageList


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::Reset
//
void CAllServerWinStationsPage::Reset(void *p)
{
    CTreeNode *pT = ( CTreeNode * )p;

    if( pT != NULL )
    {
        DisplayStations( pT->GetNodeType( ) );
    }
    else
    {
        DisplayStations( NODE_NONE );
    }

}  // end CAllServerWinStationsPage::Reset


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::AddServer
//
void CAllServerWinStationsPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add server's WinStations to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            LockListControl();
            SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

}  // end CAllServerWinStationsPage::AddServer


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::RemoveServer
//
void CAllServerWinStationsPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

        LockListControl();

        int ItemCount = m_StationList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(item-1);
                CServer *pListServer = pWinStation->GetServer();

                if(pListServer == pServer) {
                        m_StationList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

        UnlockListControl();

}  // end CAllServerWinStationsPage::RemoveServer


//////////////////////////////
// F'N: CAllServerWinStationsPage::UpdateServer
//
void CAllServerWinStationsPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

} // end CAllServerWinStationsPage::UpdateServer


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::UpdateWinStations
//
void CAllServerWinStationsPage::UpdateWinStations(CServer *pServer)
{
        ASSERT(pServer);

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
        BOOL bAnyChanged = FALSE;
        BOOL bAnyAdded = FALSE;

        // Loop through the WinStations
        pServer->LockWinStationList();
        CObList *pWinStationList = pServer->GetWinStationList();

        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                LV_FINDINFO FindInfo;
                FindInfo.flags = LVFI_PARAM;
                FindInfo.lParam = (LPARAM)pWinStation;

                // Find the WinStation in our list
                int item = m_StationList.FindItem(&FindInfo, -1);

                // If the process is new and isn't currently in the list,
                // add it to the list
                if(pWinStation->IsNew() && item == -1) {

                        AddWinStationToList(pWinStation);
                        bAnyAdded = TRUE;
                        continue;
                }

                // If the WinStation is no longer current,
                // remove it from the list
                if(!pWinStation->IsCurrent() && item != -1) {
                        // Remove the WinStation from the list
                        m_StationList.DeleteItem(item);
                        pWinStation->ClearSelected();
                        continue;
                }

                // If the WinStation info has changed, change
                // it's info in our tree
                if(pWinStation->IsChanged() && item != -1) {
                        // Figure out which icon to use
                        int WhichIcon = m_idxBlank;
                        BOOL CurrentWinStation = pWinStation->IsCurrentWinStation();

                        if(pWinStation->GetState() != State_Disconnected
                        && pWinStation->GetState() != State_Idle) {
                                switch(pWinStation->GetSdClass()) {
                                        case SdAsync:
                                                if(pWinStation->IsDirectAsync())
                                                        WhichIcon = CurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
                                                else
                                                        WhichIcon = CurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
                                                break;

                                        case SdNetwork:
                                                WhichIcon = CurrentWinStation ? m_idxCurrentNet : m_idxNet;
                                                break;

                                        default:
                                                WhichIcon = CurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
                                        break;
                                }
                        }

                        m_StationList.SetItem(item, 0, LVIF_IMAGE, 0, WhichIcon, 0, 0, 0L);

                        // WinStation Name
                        if(pWinStation->GetName()[0])
                                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, pWinStation->GetName());
                        else {
                                CString NameString(" ");
                                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, NameString);
                        }

                        // User
                        m_StationList.SetItemText(item, AS_WS_COL_USER, pWinStation->GetUserName());

                        // Logon ID
                        CString ColumnString;
                        ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
                        m_StationList.SetItemText(item, AS_WS_COL_ID, ColumnString);

                        // Connect State
                        m_StationList.SetItemText(item, AS_WS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

                        // Type
                        m_StationList.SetItemText(item, AS_WS_COL_TYPE, pWinStation->GetWdName());

                        // Client Name
                        m_StationList.SetItemText(item, AS_WS_COL_CLIENTNAME, pWinStation->GetClientName());

                        // Idle Time
                        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

                        ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

                        if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
                        {
                                ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
                        }
                        else wcscpy(IdleTimeString, TEXT("."));

                        m_StationList.SetItemText(item, AS_WS_COL_IDLETIME, IdleTimeString);

                        // Logon Time
                        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
                        // We don't want to pass a 0 logon time to DateTimeString()
                        // It will blow up if the timezone is GMT
                        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                                pDoc->FixUnknownString(LogonTimeString);
                        }
                        else LogonTimeString[0] = '\0';

                        m_StationList.SetItemText(item, AS_WS_COL_LOGONTIME, LogonTimeString);

                        // Comment
                        m_StationList.SetItemText(item, AS_WS_COL_COMMENT, pWinStation->GetComment());

                        if(m_CurrentSortColumn != AS_WS_COL_ID)
                                bAnyChanged = TRUE;
                }
        }

        pServer->UnlockWinStationList();

        if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);

} // end CAllServerWinStationsPage::UpdateWinStations


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::AddWinStationToList
//
int CAllServerWinStationsPage::AddWinStationToList(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        CServer *pServer = pWinStation->GetServer();

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        // Figure out which icon to use
        int WhichIcon = m_idxBlank;
        BOOL bCurrentWinStation = pWinStation->IsCurrentWinStation();

        if(pWinStation->GetState() != State_Disconnected
                && pWinStation->GetState() != State_Idle) {
                switch(pWinStation->GetSdClass()) {
                        case SdAsync:
                                if(pWinStation->IsDirectAsync())
                                        WhichIcon = bCurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
                                else
                                        WhichIcon = bCurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
                                break;

                        case SdNetwork:
                                WhichIcon = bCurrentWinStation ? m_idxCurrentNet : m_idxNet;
                                break;

                        default:
                                WhichIcon = bCurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
                                break;
                }
        }

        LockListControl();
        //////////////////////
        // Fill in the columns
        //////////////////////

        // Server Name
        int item = m_StationList.InsertItem(m_StationList.GetItemCount(), pServer->GetName(), WhichIcon);
        // WinStation Name
        if(pWinStation->GetName()[0])
                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, pWinStation->GetName());
        else {
                CString NameString(" ");
                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, NameString);
        }

        // User
        m_StationList.SetItemText(item, AS_WS_COL_USER, pWinStation->GetUserName());

        // Logon ID
        CString ColumnString;
        ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
        m_StationList.SetItemText(item, AS_WS_COL_ID, ColumnString);

        // Connect State
        m_StationList.SetItemText(item, AS_WS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

        // Type
        m_StationList.SetItemText(item, AS_WS_COL_TYPE, pWinStation->GetWdName());

        // Client Name
        m_StationList.SetItemText(item, AS_WS_COL_CLIENTNAME, pWinStation->GetClientName());

        // Idle Time
        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];
        if(pWinStation->GetState() == State_Active
                && pWinStation->GetLastInputTime().QuadPart <= pWinStation->GetCurrentTime().QuadPart)
        {
            LARGE_INTEGER DiffTime = CalculateDiffTime(pWinStation->GetLastInputTime(), pWinStation->GetCurrentTime());            
            
            ULONG_PTR d_time = ( ULONG_PTR )DiffTime.QuadPart;            

            ELAPSEDTIME IdleTime;
            // Calculate the days, hours, minutes, seconds since specified time.
            IdleTime.days = (USHORT)(d_time / 86400L); // days since
            d_time = d_time % 86400L;                  // seconds => partial day
            IdleTime.hours = (USHORT)(d_time / 3600L); // hours since
            d_time  = d_time % 3600L;                  // seconds => partial hour
            IdleTime.minutes = (USHORT)(d_time / 60L); // minutes since
            IdleTime.seconds = (USHORT)(d_time % 60L);// seconds remaining
            
            ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
            pWinStation->SetIdleTime(IdleTime);
        }
        else wcscpy(IdleTimeString, TEXT("."));

        m_StationList.SetItemText(item, AS_WS_COL_IDLETIME, IdleTimeString);

        // Logon Time
        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
        // We don't want to pass a 0 logon time to DateTimeString()
        // It will blow up if the timezone is GMT
        
        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart)
        {
            DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
            
            if( LogonTimeString[0] != 0 )
            {           
                pDoc->FixUnknownString(LogonTimeString);
            }
        }
        else LogonTimeString[0] = '\0';

        m_StationList.SetItemText(item, AS_WS_COL_LOGONTIME, LogonTimeString);

        // Comment
        m_StationList.SetItemText(item, AS_WS_COL_COMMENT, pWinStation->GetComment());

        // Attach a pointer to the CWinStation structure to the list item
        m_StationList.SetItemData(item, (DWORD_PTR)pWinStation);

        //bug #191727
        //m_StationList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

        UnlockListControl();

        return item;

}  // end CAllServerWinStationsPage::AddWinStationToList


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::AddServerToList
//
BOOL CAllServerWinStationsPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

        pServer->LockWinStationList();
        // Get a pointer to this server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();

        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                AddWinStationToList(pWinStation);
        }

        pServer->UnlockWinStationList();

    return TRUE;

}  // end CAllServerWinStationsPage::AddServerToList


/////////////////////////////////////
// F'N: CAllServerWinStationsPage::DisplayStations
//
void CAllServerWinStationsPage::DisplayStations( NODETYPE ntType )
{
    // Clear out the list control
    m_StationList.DeleteAllItems();

    // Get a pointer to the document's list of servers
    CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

    ((CWinAdminDoc*)GetDocument())->LockServerList();
    // Iterate through the server list
    POSITION pos = pServerList->GetHeadPosition();

    while(pos)
    {
        CServer *pServer = (CServer*)pServerList->GetNext(pos);

        if( ntType == NODE_FAV_LIST )        
        {
            if( pServer->GetTreeItemFromFav() != NULL )
            {
                AddServerToList(pServer);
            }
        }
        else if( ntType == NODE_THIS_COMP )
        {
            if( pServer->GetTreeItemFromThisComputer() != NULL )
            {
                AddServerToList(pServer);
            }
        }
        else
        {
            AddServerToList( pServer );
        }            
    }

    ((CWinAdminDoc*)GetDocument())->UnlockServerList();

}  // end CAllServerWinStationsPage::DisplayStations


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::OnColumnclick
//
void CAllServerWinStationsPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CAllServerWinStationsPage::OnColumnclick


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::OnContextMenu
//
void CAllServerWinStationsPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_StationList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_StationList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_StationList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }
                /*
                RECT rect;
                m_StationList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_StationList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                        return;
        }

        CMenu menu;
        menu.LoadMenu(IDR_WINSTATION_POPUP);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CAllServerWinStationsPage::OnContextMenu


//////////////////////////////////
// MESSAGE MAP: CAllServerProcessesPage
//
IMPLEMENT_DYNCREATE(CAllServerProcessesPage, CFormView)

BEGIN_MESSAGE_MAP(CAllServerProcessesPage, CFormView)
        //{{AFX_MSG_MAP(CAllServerProcessesPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_PROCESS_LIST, OnColumnclick)
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_PROCESS_LIST, OnProcessItemChanged)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(NM_SETFOCUS, IDC_PROCESS_LIST, OnSetfocusProcessList)
        //ON_NOTIFY( NM_KILLFOCUS , IDC_PROCESS_LIST , OnKillfocusProcessList )
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


///////////////////////////////
// F'N: CAllServerProcessesPage ctor
//
CAllServerProcessesPage::CAllServerProcessesPage()
        : CAdminPage(CAllServerProcessesPage::IDD)
{
        //{{AFX_DATA_INIT(CAllServerProcessesPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_bSortAscending = TRUE;

}  // end CAllServerProcessesPage ctor


///////////////////////////////
// F'N: CAllServerProcessesPage dtor
//
CAllServerProcessesPage::~CAllServerProcessesPage()
{
}  // end CAllServerProcessesPage dtor


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::DoDataExchange
//
void CAllServerProcessesPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAllServerProcessesPage)
                // NOTE: the ClassWizard will add DDX and DDV calls here
                DDX_Control(pDX, IDC_PROCESS_LIST, m_ProcessList);
        //}}AFX_DATA_MAP

}  // end CAllServerProcessesPage::DoDataExchange


#ifdef _DEBUG
///////////////////////////////////////
// F'N: CAllServerProcessesPage::AssertValid
//
void CAllServerProcessesPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CAllServerProcessesPage::AssertValid


////////////////////////////////
// F'N: CAllServerProcessesPage::Dump
//
void CAllServerProcessesPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CAllServerProcessesPage::Dump

#endif //_DEBUG


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::OnSize
//
void CAllServerProcessesPage::OnSize(UINT nType, int cx, int cy)
{
        RECT rect;
        GetClientRect(&rect);

        rect.top += LIST_TOP_OFFSET;

        if(m_ProcessList.GetSafeHwnd())
                m_ProcessList.MoveWindow(&rect, TRUE);

        // CFormView::OnSize(nType, cx, cy);

}  // end CAllServerProcessesPage::OnSize

static ColumnDef ProcColumns[] = {
        CD_SERVER,
        CD_USER,
        CD_SESSION,
        CD_PROC_ID,
        CD_PROC_PID,
        CD_PROC_IMAGE
};

#define NUM_AS_PROC_COLUMNS sizeof(ProcColumns)/sizeof(ColumnDef)

//////////////////////////////////////////
// F'N: CAllServerProcessesPage::OnInitialUpdate
//
void CAllServerProcessesPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        // Add the column headings
        CString columnString;

        for(int col = 0; col < NUM_AS_PROC_COLUMNS; col++) {
                columnString.LoadString(ProcColumns[col].stringID);
                m_ProcessList.InsertColumn(col, columnString, ProcColumns[col].format, ProcColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_PROC_COL_SERVER;

}  // end CAllServerProcessesPage::OnInitialUpdate


////////////////////////////////
// F'N: CAllServerProcessesPage::Reset
//
void CAllServerProcessesPage::Reset(void *)
{
        // We don't want to display processes until the user clicks
        // on the "Processes" tab

}  // end CAllServerProcessesPage::Reset


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::AddServer
//
void CAllServerProcessesPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add the Server's processes to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            LockListControl();
            SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

}  // end CAllServerProcessesPage::AddServer


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::RemoveServer
//
void CAllServerProcessesPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

        LockListControl();

        int ItemCount = m_ProcessList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(item-1);
                CServer *pListServer = pProcess->GetServer();

                if(pListServer == pServer) {
                        m_ProcessList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

        UnlockListControl();

}  // end CAllServerProcessesPage::RemoveServer


//////////////////////////////
// F'N: CAllServerProcessesPage::UpdateServer
//
void CAllServerProcessesPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

} // end CAllServerProcessesPage::UpdateServer


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::UpdateProcesses
//
void CAllServerProcessesPage::UpdateProcesses(CServer *pServer)
{
        ASSERT(pServer);

        CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
        BOOL bAnyChanged = FALSE;
        BOOL bAnyAdded = FALSE;

        // Loop through the processes
        pServer->LockProcessList();
        CObList *pProcessList = pServer->GetProcessList();

        POSITION pos = pProcessList->GetHeadPosition();

        while(pos) {
                CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

                // If this is a 'system' process and we aren't currently showing them,
                // go to the next process
                if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
                        continue;

                // If this user is not an Admin, don't show him someone else's processes unless it
                // is a System process
                if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers() && !pProcess->IsSystemProcess())
                        continue;

                // If the process is new, add it to the list
                if(pProcess->IsNew()) {

                        if(AddProcessToList(pProcess) != -1)
                                bAnyAdded = TRUE;
                        continue;
                }

                LV_FINDINFO FindInfo;
                FindInfo.flags = LVFI_PARAM;
                FindInfo.lParam = (LPARAM)pProcess;

                // Find the Process in our list
                int item = m_ProcessList.FindItem(&FindInfo, -1);

                // If the process is no longer current,
                // remove it from the list
                if(!pProcess->IsCurrent() && item != -1) {
                        // Remove the Process from the list
                        m_ProcessList.DeleteItem(item);
                        pProcess->ClearSelected();
                }

                // If the process info has changed, change
                // it's info in our tree
                if(pProcess->IsChanged() && item != -1)
                {
                        // WinStation Name
                        CWinStation *pWinStation = pProcess->GetWinStation();
                        if(pWinStation)
                        {
                                if(pWinStation->GetName()[0])
                                        m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, pWinStation->GetName());
                                else
                                {
                                        CString NameString(" ");
                                        if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                                        if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                                        m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, NameString);
                                }
                        }
                        if(m_CurrentSortColumn == AS_PROC_COL_WINSTATION)
                                bAnyChanged = TRUE;
                }
        }

        pServer->UnlockProcessList();

        if(bAnyChanged || bAnyAdded) {
                LockListControl();
                SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
                UnlockListControl();
        }

}  // end CAllServerProcessesPage::UpdateProcesses


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::RemoveProcess
//
void CAllServerProcessesPage::RemoveProcess(CProcess *pProcess)
{
        ASSERT(pProcess);

        LockListControl();

        // Find out how many items in the list
        int ItemCount = m_ProcessList.GetItemCount();

        // Go through the items and remove this process
        for(int item = 0; item < ItemCount; item++) {
                CProcess *pListProcess = (CProcess*)m_ProcessList.GetItemData(item);

                if(pListProcess == pProcess) {
                        m_ProcessList.DeleteItem(item);
                        break;
                }
        }

        UnlockListControl();
}


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::AddProcessToList
//
int CAllServerProcessesPage::AddProcessToList(CProcess *pProcess)
{
        ASSERT(pProcess);

        CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
        CServer *pServer = pProcess->GetServer();

        LockListControl();
        // Server - put at end of list
        int item = m_ProcessList.InsertItem(m_ProcessList.GetItemCount(), pProcess->GetServer()->GetName(), NULL);

        // User
        m_ProcessList.SetItemText(item, AS_PROC_COL_USER, pProcess->GetUserName());

        // WinStation Name
        CWinStation *pWinStation = pProcess->GetWinStation();
        if(pWinStation) {

                if(pWinStation->GetName()[0])
                    m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, pWinStation->GetName());
                else {
                        CString NameString(" ");
                        if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                        if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                    m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, NameString);
                }



    }

        // ID
        CString ProcString;
        ProcString.Format(TEXT("%lu"), pProcess->GetLogonId());
        m_ProcessList.SetItemText(item, AS_PROC_COL_ID, ProcString);

        // PID
        ProcString.Format(TEXT("%lu"), pProcess->GetPID());
        m_ProcessList.SetItemText(item, AS_PROC_COL_PID, ProcString);

        // Image
        m_ProcessList.SetItemText(item, AS_PROC_COL_IMAGE, pProcess->GetImageName());
        m_ProcessList.SetItemData(item, (DWORD_PTR)pProcess);

        m_ProcessList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_SELECTED | LVIS_FOCUSED );

        UnlockListControl();

        return item;

}  // end CAllServerProcessesPage::AddProcessToList


////////////////////////////////
// F'N: CAllServerProcessesPage::AddServerToList
//
BOOL CAllServerProcessesPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

        CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();

        pServer->EnumerateProcesses();
        CObList *pProcessList = pServer->GetProcessList();
        pServer->LockProcessList();

        POSITION pos = pProcessList->GetHeadPosition();

        while(pos) {
                CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

                // If this is a 'system' process and we aren't currently showing them,
                // go to the next process
                if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
                        continue;

                // If this user is not an Admin, don't show him someone else's processes unless it
                // is a System process
                if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers() && !pProcess->IsSystemProcess())
                        continue;

                AddProcessToList(pProcess);
        }

        pServer->UnlockProcessList();

    return TRUE;

}  // end CAllServerProcessesPage::AddServerToList


////////////////////////////////
// F'N: CAllServerProcessesPage::DisplayProcesses
//
void CAllServerProcessesPage::DisplayProcesses( NODETYPE ntType )
{
        CWaitCursor Nikki;

        LockListControl();

        // Clear out the list control
        m_ProcessList.DeleteAllItems();

        // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos = pServerList->GetHeadPosition();
        
        CServer *pTempServer;

        while(pos)
        {
            CServer *pServer = (CServer*)pServerList->GetNext(pos);

            pTempServer = NULL;

            if( ntType == NODE_FAV_LIST )        
            { 
                if( pServer->GetTreeItemFromFav() != NULL )
                {

                    pTempServer = pServer;
                }
            }
            else if( ntType == NODE_THIS_COMP )
            {
                if( pServer->GetTreeItemFromThisComputer( ) != NULL )
                {
                    pTempServer = pServer;
                }
            }
            else
            {
                pTempServer = pServer;
            }

            if( pTempServer != NULL && pTempServer->IsServerSane())
            {
                AddServerToList( pTempServer );
            }  // end if(pServer->IsServerSane())
        } // end while(pos)

        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

        UnlockListControl();

}  // end CAllServerProcessesPage::DisplayProcesses


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::OnProcessItemChanged
//
void CAllServerProcessesPage::OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

        if(pLV->uNewState & LVIS_SELECTED) {
                CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
                pProcess->SetSelected();
        }

        if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
                CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
                pProcess->ClearSelected();
        }

        *pResult = 0;

}  // end CAllServerProcessesPage::OnProcessItemChanged


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::OnColumnclick
//
void CAllServerProcessesPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CAllServerProcessesPage::OnColumnclick


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::OnContextMenu
//
void CAllServerProcessesPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_ProcessList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_ProcessList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_ProcessList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }

                /*
                RECT rect;
                m_ProcessList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_ProcessList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                        return;
        }

        CMenu menu;
        menu.LoadMenu(IDR_PROCESS_POPUP);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CAllServerProcessesPage::OnContextMenu


////////////////////////////////
// MESSAGE MAP: CAllServerLicensesPage
//
IMPLEMENT_DYNCREATE(CAllServerLicensesPage, CFormView)

BEGIN_MESSAGE_MAP(CAllServerLicensesPage, CFormView)
        //{{AFX_MSG_MAP(CAllServerLicensesPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_LICENSE_LIST, OnColumnclick)
        ON_NOTIFY(NM_SETFOCUS, IDC_LICENSE_LIST, OnSetfocusLicenseList)
        //ON_NOTIFY( NM_KILLFOCUS , IDC_LICENSE_LIST , OnKillfocusLicenseList )
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CAllServerLicensesPage ctor
//
CAllServerLicensesPage::CAllServerLicensesPage()
        : CAdminPage(CAllServerLicensesPage::IDD)
{
        //{{AFX_DATA_INIT(CAllServerLicensesPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_bSortAscending = TRUE;

}  // end CAllServerLicensesPage ctor


/////////////////////////////
// F'N: CAllServerLicensesPage dtor
//
CAllServerLicensesPage::~CAllServerLicensesPage()
{

}  // end CAllServerLicensesPage dtor


////////////////////////////////////////
// F'N: CAllServerLicensesPage::DoDataExchange
//
void CAllServerLicensesPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAllServerLicensesPage)
        DDX_Control(pDX, IDC_LICENSE_LIST, m_LicenseList);
        //}}AFX_DATA_MAP

}  // end CAllServerLicensesPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CAllServerLicensesPage::AssertValid
//
void CAllServerLicensesPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CAllServerLicensesPage::AssertValid


//////////////////////////////
// F'N: CAllServerLicensesPage::Dump
//
void CAllServerLicensesPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CAllServerLicensesPage::Dump
#endif //_DEBUG


/////////////////////////////////////
// F'N: CAllServerLicensesPage::OnSize
//
void CAllServerLicensesPage::OnSize(UINT nType, int cx, int cy)
{
        RECT rect;
        GetWindowRect(&rect);

        CWnd *pWnd = GetDlgItem(IDC_LOCAL_AVAILABLE);
        if(pWnd) {
                RECT rect2;
                pWnd->GetWindowRect(&rect2);
                rect.top = rect2.bottom + 5;
        }

        ScreenToClient(&rect);

        if(m_LicenseList.GetSafeHwnd())
                m_LicenseList.MoveWindow(&rect, TRUE);

        // CFormView::OnSize(nType, cx, cy);

}  // end CAllServerLicensesPage::OnSize


static ColumnDef LicenseColumns[] = {
        CD_SERVER,
        CD_LICENSE_DESC,
        CD_LICENSE_REG,
        CD_USERCOUNT,
        CD_POOLCOUNT,
        CD_LICENSE_NUM
};

#define NUM_AS_LICENSE_COLUMNS sizeof(LicenseColumns)/sizeof(ColumnDef)

/////////////////////////////////////
// F'N: CAllServerLicensesPage::OnInitialUpdate
//
void CAllServerLicensesPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        BuildImageList();               // builds the image list for the list control

        CString columnString;

        for(int col = 0; col < NUM_AS_LICENSE_COLUMNS; col++) {
                columnString.LoadString(LicenseColumns[col].stringID);
                m_LicenseList.InsertColumn(col, columnString, LicenseColumns[col].format, LicenseColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_LICENSE_COL_SERVER;

}  // end CAllServerLicensesPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CAllServerLicensePage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CAllServerLicensesPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 5, 0);

        m_idxBase = AddIconToImageList(IDI_BASE);
        m_idxBump = AddIconToImageList(IDI_BUMP);
        m_idxEnabler = AddIconToImageList(IDI_ENABLER);
        m_idxUnknown = AddIconToImageList(IDI_UNKNOWN);
       
        m_LicenseList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CAllServerLicensesPage::BuildImageList


/////////////////////////////////////////
// F'N: CAllServerLicensesPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CAllServerLicensesPage::AddIconToImageList(int iconID)
{
    HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
    
    return m_ImageList.Add(hIcon);
    
}  // end CAllServerLicensesPage::AddIconToImageList


/////////////////////////////////////
// F'N: CAllServerLicensesPage::Reset
//
void CAllServerLicensesPage::Reset(void *p)
{
        DisplayLicenses();
        DisplayLicenseCounts();

}  // end CAllServerLicensesPage::Reset


/////////////////////////////////////
// F'N: CAllServerLicensesPage::AddServer
//
void CAllServerLicensesPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add the Server's licenses to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_LICENSES, &m_LicenseList, m_CurrentSortColumn, m_bSortAscending);
    }

}  // end F'N: CAllServerLicensesPage::AddServer


/////////////////////////////////////
// F'N: CAllServerLicensesPage::RemoveServer
//
void CAllServerLicensesPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

        int ItemCount = m_LicenseList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CLicense *pLicense = (CLicense*)m_LicenseList.GetItemData(item-1);
                CServer *pListServer = pLicense->GetServer();

                if(pListServer == pServer) {
                        m_LicenseList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

}  // end CAllServerLicensesPage::RemoveServer


//////////////////////////////
// F'N: CAllServerLicensesPage::UpdateServer
//
void CAllServerLicensesPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

        if(pServer->IsState(SS_GOOD))
                AddServer(pServer);

} // end CAllServerLicensesPage::UpdateServer


/////////////////////////////////////
// F'N: CAllServerLicensesPage::AddServerToList
//
BOOL CAllServerLicensesPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

        int item;

        pServer->LockLicenseList();

        // Get a pointer to the Server's list of licenses
        CObList *pLicenseList = pServer->GetLicenseList();

        // Iterate through the License list
        POSITION pos = pLicenseList->GetHeadPosition();

        while(pos) {
                CLicense *pLicense = (CLicense*)pLicenseList->GetNext(pos);

                //////////////////////
                // Fill in the columns
                //////////////////////
                int WhichIcon;

                switch(pLicense->GetClass()) {
                        case LicenseBase:
                                WhichIcon = m_idxBase;
                                break;
                        case LicenseBump:
                                WhichIcon = m_idxBump;
                                break;
                        case LicenseEnabler:
                                WhichIcon = m_idxEnabler;
                                break;
                        case LicenseUnknown:
                                WhichIcon = m_idxUnknown;
                                break;
                }

                // Server Name
                item = m_LicenseList.InsertItem(m_LicenseList.GetItemCount(), pServer->GetName(), WhichIcon);

                // Description
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_DESCRIPTION, pLicense->GetDescription());

                // Registered
                CString RegString;
                RegString.LoadString(pLicense->IsRegistered() ? IDS_YES : IDS_NO);
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_REGISTERED, RegString);

                BOOL bUnlimited = (pLicense->GetClass() == LicenseBase
                        && pLicense->GetTotalCount() == 4095
                        && pServer->GetCTXVersionNum() == 0x00000040);

                // User (Total) Count
                CString CountString;
                if(bUnlimited)
                        CountString.LoadString(IDS_UNLIMITED);
                else
                        CountString.Format(TEXT("%lu"), pLicense->GetTotalCount());
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_USERCOUNT, CountString);

                // Pool Count
                if(bUnlimited)
                        CountString.LoadString(IDS_NOT_APPLICABLE);
                else
                        CountString.Format(TEXT("%lu"), pLicense->GetPoolCount());
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_POOLCOUNT, CountString);

                // License Number
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_NUMBER, pLicense->GetLicenseNumber());

                m_LicenseList.SetItemData(item, (DWORD_PTR)pLicense);
        }  // end while(pos)

        pServer->UnlockLicenseList();

    return TRUE;

}  // end CAllServerLicensesPage::AddServerToList


/////////////////////////////////////
// F'N: CAllServerLicensesPage::DisplayLicenseCounts
//
void CAllServerLicensesPage::DisplayLicenseCounts()
{
        // Get a pointer to our document
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();
        ExtGlobalInfo *pExtGlobalInfo = pDoc->GetExtGlobalInfo();

        if(pExtGlobalInfo) {
                BOOL bUnlimited = (pExtGlobalInfo->NetworkLocalAvailable == 32767);

                CString LicenseString;

                if(bUnlimited) {
                        LicenseString.LoadString(IDS_UNLIMITED);
                        SetDlgItemText(IDC_LOCAL_INSTALLED, LicenseString);
                        SetDlgItemText(IDC_LOCAL_AVAILABLE, LicenseString);
                        SetDlgItemText(IDC_TOTAL_INSTALLED, LicenseString);
                        SetDlgItemText(IDC_TOTAL_AVAILABLE, LicenseString);

                } else {

                        LicenseString.Format(TEXT("%lu"), pExtGlobalInfo->NetworkLocalInstalled);
                        SetDlgItemText(IDC_LOCAL_INSTALLED, LicenseString);
                        LicenseString.Format(TEXT("%lu"), pExtGlobalInfo->NetworkLocalAvailable);
                        SetDlgItemText(IDC_LOCAL_AVAILABLE, LicenseString);
                        LicenseString.Format(TEXT("%lu"),
                        pExtGlobalInfo->NetworkPoolInstalled + pExtGlobalInfo->NetworkLocalInstalled);
                        SetDlgItemText(IDC_TOTAL_INSTALLED, LicenseString);

                        LicenseString.Format(TEXT("%lu"),
                        pExtGlobalInfo->NetworkPoolAvailable + pExtGlobalInfo->NetworkLocalAvailable);
                        SetDlgItemText(IDC_TOTAL_AVAILABLE, LicenseString);

                }

                LicenseString.Format(TEXT("%lu"), pExtGlobalInfo->NetworkLocalInUse);
                SetDlgItemText(IDC_LOCAL_INUSE, LicenseString);
                LicenseString.Format(TEXT("%lu"), pExtGlobalInfo->NetworkPoolInstalled);
                SetDlgItemText(IDC_POOL_INSTALLED, LicenseString);
                LicenseString.Format(TEXT("%lu"), pExtGlobalInfo->NetworkPoolInUse);
                SetDlgItemText(IDC_POOL_INUSE, LicenseString);
                LicenseString.Format(TEXT("%lu"), pExtGlobalInfo->NetworkPoolAvailable);
                SetDlgItemText(IDC_POOL_AVAILABLE, LicenseString);

                LicenseString.Format(TEXT("%lu"),
                pExtGlobalInfo->NetworkPoolInUse + pExtGlobalInfo->NetworkLocalInUse);
                SetDlgItemText(IDC_TOTAL_INUSE, LicenseString);
        }

}  // end CAllServerLicensesPage::DisplayLicenseCounts


/////////////////////////////////////
// F'N: CAllServerLicensesPage::DisplayLicenses
//
void CAllServerLicensesPage::DisplayLicenses()
{
        // Clear out the list control
        m_LicenseList.DeleteAllItems();

        // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos = pServerList->GetHeadPosition();

        while(pos) {
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                AddServerToList(pServer);
        }

        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

}  // end CAllServerLicensesPage::DisplayLicenses


/////////////////////////////////////
// F'N: CAllServerLicensesPage::OnColumnclick
//
void CAllServerLicensesPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_LICENSES, &m_LicenseList, m_CurrentSortColumn, m_bSortAscending);

        *pResult = 0;

}  // end CAllServerLicensesPage::OnColumnclick


//=-----------------------------------------------------------------------------------------
void CAllServerUsersPage::OnKillfocusUserList(NMHDR* , LRESULT* pResult)
{
    m_UserList.Invalidate( );

    *pResult = 0;
}

void CAllServerUsersPage::OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L" CAllServerUsersPage::OnSetfocusUserList\n" );
   
    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_UserList.Invalidate( );

/*
    int nItem;

    int nCount = m_UserList.GetSelectedCount();

    if( nCount == 0 )
    {
        m_UserList.SetItemState( 0 , LVIS_SELECTED , LVIS_SELECTED );
    }
    else
    {
        for( int i = 0 ; i < nCount; +++i )
        {
            nItem = m_UserList.GetNextItem( -1 , LVNI_FOCUSED );

            m_UserList.Update( nItem );
        }
    }
*/
    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;   
}

//=-----------------------------------------------------------------------------------------
void CAllServerProcessesPage::OnKillfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult)
{
    m_ProcessList.Invalidate( );

    *pResult = 0;
}

void CAllServerProcessesPage::OnSetfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult)
{    
    ODS( L" CAllServerProcessesPage::OnSetfocusProcessList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_ProcessList.Invalidate();
/*
    int nItem;

    int nCount = m_ProcessList.GetSelectedCount();

    if( nCount == 0 )
    {
        m_ProcessList.SetItemState( 0 , LVIS_SELECTED , LVIS_SELECTED );
    }
    else
    {
        for( int i = 0 ; i < nCount; +++i )
        {
            nItem = m_ProcessList.GetNextItem( -1 , LVNI_FOCUSED );

            m_ProcessList.Update( nItem );
        }
    }
*/  
    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;   

}

//=-----------------------------------------------------------------------------------------
void CAllServerWinStationsPage::OnKillfocusWinstationList(NMHDR* , LRESULT* pResult)
{
    m_StationList.Invalidate( );

    *pResult = 0;
}

//=-----------------------------------------------------------------------------------------
void CAllServerWinStationsPage::OnSetfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CAllServerWinStationsPage::OnSetfocusWinstationList\n" );
   
    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_StationList.Invalidate();

/*
    int nItem;

    int nCount = m_StationList.GetSelectedCount();

    if( nCount == 0 )
    {
        m_StationList.SetItemState( 0 , LVIS_SELECTED , LVIS_SELECTED );
    }
    else
    {
        for( int i = 0 ; i < nCount; +++i )
        {
            nItem = m_StationList.GetNextItem( -1 , LVNI_FOCUSED );

            m_StationList.Update( nItem );
        }
    }
*/    
    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;   

}

/////////////////////////////////////
// F'N: CAllServerWinStationsPage::ClearSelections
//
void CAllServerWinStationsPage::ClearSelections()
{
    
    if(m_StationList.m_hWnd != NULL)
    {
        POSITION pos = m_StationList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nItem = m_StationList.GetNextSelectedItem(pos);
            // you could do your own processing on nItem here
            m_StationList.SetItemState(nItem,0,LVIS_SELECTED);
        }
    }
}

//=-----------------------------------------------------------------------------------------
void CAllServerServersPage::OnKillfocusServerList(NMHDR* pNMHDR, LRESULT* pResult)
{
    m_ServerList.Invalidate();

    *pResult = 0;
}

void CAllServerServersPage::OnSetfocusServerList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CAllServerServersPage::OnSetfocusServerList\n" );
   
    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();
/*
    int nItem;

    int nCount = m_ServerList.GetSelectedCount();

    if( nCount == 0 )
    {
        m_ServerList.SetItemState( 0 , LVIS_SELECTED , LVIS_SELECTED );
    }
    else
    {
        for( int i = 0 ; i < nCount; +++i )
        {
            nItem = m_ServerList.GetNextItem( -1 , LVNI_FOCUSED );

            m_ServerList.Update( nItem );
        }
    }
*/  
    m_ServerList.Invalidate();

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;   

}

//=-----------------------------------------------------------------------------------------
void CAllServerLicensesPage::OnKillfocusLicenseList(NMHDR*, LRESULT* pResult)
{
    m_LicenseList.Invalidate();

    *pResult = 0;
}

void CAllServerLicensesPage::OnSetfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CAllServerLicensesPage::OnSetfocusLicenseList\n" );
  
    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_LicenseList.Invalidate();

/*
    int nItem;

    int nCount = m_LicenseList.GetSelectedCount();

    if( nCount == 0 )
    {
        m_LicenseList.SetItemState( 0 , LVIS_SELECTED , LVIS_SELECTED );
    }
    else
    {
        for( int i = 0 ; i < nCount; +++i )
        {
            nItem = m_LicenseList.GetNextItem( -1 , LVNI_FOCUSED );

            m_LicenseList.Update( nItem );
        }
    }
*/    
    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;   


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\admindoc.cpp ===
/*******************************************************************************
*
* admindoc.cpp
*
* implementation of the CWinAdminDoc class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\admindoc.cpp  $
*
*     Rev 1.15   25 Apr 1998 13:43:08   donm
*  MS 2167: try to use proper Wd from registry
*
*     Rev 1.14   19 Feb 1998 17:39:28   donm
*  removed latest extension DLL support
*
*     Rev 1.12   19 Jan 1998 16:45:28   donm
*  new ui behavior for domains and servers
*
*     Rev 1.11   13 Nov 1997 13:18:46   donm
*  removed check for ICA for shadowing
*
*     Rev 1.10   07 Nov 1997 23:05:58   donm
*  fixed inability to logoff/reset
*     Rev 1.0   30 Jul 1997 17:10:10   butchd
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"

#include "admindoc.h"
#include "dialogs.h"

#include <malloc.h>                     // for alloca used by Unicode conversion macros
#include <mfc42\afxconv.h>           // for Unicode conversion macros
static int _convert;

#include <winsta.h>
#include <regapi.h>
#include "..\..\inc\utilsub.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef _STRESS_BUILD
extern BOOL g_fWaitForAllServersToDisconnect;
#endif

DWORD Shadow_WarningProc( LPVOID param );
INT_PTR CALLBACK ShadowWarn_WndProc( HWND , UINT , WPARAM , LPARAM );
void CenterDlg(HWND hwndToCenterOn , HWND hDlg );
HWND g_hwndShadowWarn = NULL;
DWORD g_dwTreeViewExpandedStates;

#define WM_SETTHEEVENT ( WM_USER + 755 )

//  Sort order for Connect States
ULONG SortOrder[] =
{
        3, //State_Active               user logged on to WinStation
        2, //State_Connected    WinStation connected to client
        0, //State_ConnectQuery in the process of connecting to client
        5, //State_Shadow               shadowing another WinStation
        4, //State_Disconnected WinStation logged on without client
        6, //State_Idle                 waiting for client to connect
        1, //State_Listen               WinStation is listening for connection
        9, //State_Reset                WinStation is being reset
        7, //State_Down                 WinStation is down due to error
        8  //State_Init                 WinStation in initialization
};

/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc

IMPLEMENT_DYNCREATE(CWinAdminDoc, CDocument)

BEGIN_MESSAGE_MAP(CWinAdminDoc, CDocument)
        //{{AFX_MSG_MAP(CWinAdminDoc)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //    DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CWinAdminDoc::m_ProcessContinue = TRUE;

/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc constructor
//
CWinAdminDoc::CWinAdminDoc()
{
    // TODO: add one-time construction code here
    m_CurrentSelectedNode = NULL;
    m_CurrentSelectedType = NODE_NONE;
    m_pTempSelectedNode = NULL;
    m_TempSelectedType = NODE_NONE;
    m_AllViewsReady = FALSE;
    m_pProcessThread = NULL;
    m_pCurrentDomain = NULL;
    m_pCurrentServer = NULL;
    m_pPersistentConnections = NULL;
    m_InRefresh = FALSE;
    m_bInShutdown = FALSE;
    m_UnknownString = ::GetUnknownString();

    ASSERT( m_UnknownString != NULL );

    ((CWinAdminApp*)AfxGetApp())->SetDocument(this);

    // If there is an extension DLL, get a pointer to it's global
    // info structure
    LPFNEXGETGLOBALINFOPROC InfoProc = ((CWinAdminApp*)AfxGetApp())->GetExtGetGlobalInfoProc();
    if(InfoProc)
    {
        m_pExtGlobalInfo = (*InfoProc)();
    }
    else
    {
        m_pExtGlobalInfo = NULL;
    }
    // create the default extended server info
    // for servers that haven't had their extended info
    // created yet
    m_pDefaultExtServerInfo = new ExtServerInfo;
    CString NAString;
    NAString.LoadString(IDS_NOT_APPLICABLE);

    memset(m_pDefaultExtServerInfo, 0, sizeof(ExtServerInfo));
    // This is so the N/A TcpAddresses will sort at the end
    m_pDefaultExtServerInfo->RawTcpAddress = 0xFFFFFFFF;
    m_pDefaultExtServerInfo->ServerTotalInUse = 0xFFFFFFFF;
    wcscpy(m_pDefaultExtServerInfo->TcpAddress, NAString);
    wcscpy(m_pDefaultExtServerInfo->IpxAddress, NAString);

    m_focusstate = TREE_VIEW;
    m_prevFocusState = TAB_CTRL;
    m_fOnTab = FALSE;

    m_pszFavList = NULL;

}  // end CWinAdminDoc::CWinAdminDoc


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc destructor
//
CWinAdminDoc::~CWinAdminDoc()
{
        // all code moved to Shutdown();

   delete m_pDefaultExtServerInfo;
   if(m_pPersistentConnections) LocalFree(m_pPersistentConnections);

   if( m_UnknownString != NULL )
   {
       LocalFree( ( PVOID )m_UnknownString );
   }

}       // end CWinAdminDoc::~CWinAdminDoc


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ShutdownMessage
//
void CWinAdminDoc::ShutdownMessage(UINT id, CDialog *pDlg)
{
        ASSERT(pDlg);

        CString AString;

        AString.LoadString(id);
        pDlg->SetDlgItemText(IDC_SHUTDOWN_MSG, AString);

}       // end CWinAdminDoc::ShutdownMessage


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::Shutdown
//
void CWinAdminDoc::Shutdown(CDialog *pDlg)
{
    ASSERT(pDlg);
    
    m_bInShutdown = TRUE;
    
    // Iterate through the domain list
    POSITION pos = m_DomainList.GetHeadPosition();    
    
    ShutdownMessage(IDS_SHUTDOWN_DOMAINTHREADS, pDlg);
    
    while(pos) {
        // Go to the next domain in the list
        CDomain *pDomain = (CDomain*)m_DomainList.GetNext(pos);
        pDomain->ClearBackgroundContinue();
        // Fire off the event to wake him up if he is
        // waiting
        pDomain->SetEnumEvent();
    }
    
    pos = m_DomainList.GetHeadPosition();
    while(pos) {
        // Go to the next domain in the list
        CDomain *pDomain = (CDomain*)m_DomainList.GetNext(pos);
        pDomain->StopEnumerating();
    }
    
    // Tell the process thread to terminate and
    // wait for it to do so.
    if( m_pProcessThread != NULL )
    {
        ShutdownMessage(IDS_SHUTDOWN_PROCTHREAD, pDlg);
        
        m_ProcessContinue = FALSE;
        // Fire off the event to wake him up if he is
        // waiting
        m_ProcessWakeUpEvent.SetEvent();
        
        HANDLE hThread = m_pProcessThread->m_hThread;
        
        if( WaitForSingleObject(hThread, 1000) == WAIT_TIMEOUT )
        {
            TerminateThread(hThread, 0);
        }
        
        WaitForSingleObject(hThread, INFINITE);
    }
    
    ShutdownMessage(IDS_SHUTDOWN_PREFS, pDlg);
    
    WritePreferences();
    
    LockServerList();
    
    ShutdownMessage(IDS_SHUTDOWN_NOTIFY, pDlg);
    
    // First, tell all the server background threads to stop.
    // We do this before the destructor for each server does it
    // so that the background threads for all the servers can stop
    // and we don't have to wait until we get to the destructor for
    // each server
    pos = m_ServerList.GetHeadPosition();
    
    while(pos)
    {
        // Go to the next server in the list
        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
        pServer->ClearBackgroundContinue();
    }
    
    // Iterate through the server list
    pos = m_ServerList.GetHeadPosition();
    
    while(pos) {
        // Go to the next server in the list
        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
        if(pServer->IsState(SS_GOOD)) {
            CString AString;
            AString.Format(IDS_DISCONNECTING, pServer->GetName());
            pDlg->SetDlgItemText(IDC_SHUTDOWN_MSG, AString);
        }
        
        pServer->Disconnect( );
        
        delete pServer;
    }
    
    m_ServerList.RemoveAll();
    UnlockServerList();
    
    // Iterate through the domain list
    pos = m_DomainList.GetHeadPosition();
    
    while(pos) {
        // Go to the next domain in the list
        CDomain *pDomain = (CDomain*)m_DomainList.GetNext(pos);
        delete pDomain;
    }
    
    m_DomainList.RemoveAll();
    
    // If there is an extension DLL, call it's shutdown function
    LPFNEXSHUTDOWNPROC ShutdownProc = ((CWinAdminApp*)AfxGetApp())->GetExtShutdownProc();
    if(ShutdownProc) {
        (*ShutdownProc)();
    }
    
    // Iterate through the Wd list
    LockWdList();
    
    pos = m_WdList.GetHeadPosition();
    
    while(pos) {
        // Go to the next Wd in the list
        CWd *pWd = (CWd*)m_WdList.GetNext(pos);
        delete pWd;
    }
    
    m_WdList.RemoveAll();
    UnlockWdList();
    
    ShutdownMessage(IDS_DONE, pDlg);
    
}       // end CWinAdminDoc::Shutdown


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanCloseFrame
//
BOOL CWinAdminDoc::CanCloseFrame(CFrameWnd *pFW)
{
    ASSERT(pFW);
    
    CWaitCursor Nikki;
    
    CDialog dlgWait;
    dlgWait.Create(IDD_SHUTDOWN, pFW);
    
    Shutdown(&dlgWait);
    
    dlgWait.PostMessage(WM_CLOSE);
    return TRUE;
    
}       // end CWinAdminDoc::CanCloseFrame


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::OnNewDocument
//
BOOL CWinAdminDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;
    
    // TODO: add reinitialization code here
    // (SDI documents will reuse this document)
    
    ReadPreferences();
    
    BuildWdList();
    
    BuildDomainList();
    
    // Create a pServer object for the Server we are running on, this will give
    // him a headstart in getting his information
    CServer *pServer = new CServer(m_pCurrentDomain, ((CWinAdminApp*)AfxGetApp())->GetCurrentServerName(), FALSE, TRUE);
    
    m_pCurrentServer = pServer;
    
    if( pServer )
    {
        AddServer(pServer);
    }
    
    // Start enumerating servers in the current domain
    // if(m_pCurrentDomain) m_pCurrentDomain->StartEnumerating();
    
    // Start the background thread to enumerate processes
    m_pProcessThread = AfxBeginThread((AFX_THREADPROC)CWinAdminDoc::ProcessThreadProc, this);
    
    return TRUE;
    
}       // end CWinAdminDoc::OnNewDocument


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc serialization
//
void CWinAdminDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
    
}       // end CWinAdminDoc::Serialize


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc diagnostics
//
#ifdef _DEBUG
void CWinAdminDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CWinAdminDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ShouldConnect
//
// Returns TRUE if the server is in the list of persistent connections
//
BOOL CWinAdminDoc::ShouldConnect(LPWSTR pServerName)
{
    ASSERT(pServerName);
    
    if(m_ConnectionsPersistent && m_pPersistentConnections)
    {
        LPWSTR pTemp = m_pPersistentConnections;
        while(*pTemp)
        {
            if( !wcscmp( pTemp , pServerName ) )
            {
                return TRUE;
            }
            
            // Go to the next server in the buffer
            
            pTemp += (wcslen(pTemp) + 1);
        }
    }
    
    return FALSE;
}

//=-------------------------------------------------------------------
BOOL CWinAdminDoc::ShouldAddToFav( LPTSTR pServerName )
{
    ODS( L"CWinAdminDoc::ShouldAddToFav\n" );
    
    if( m_pszFavList != NULL )
    {
        LPTSTR pszTemp = m_pszFavList;
        
        while(*pszTemp)
        {
            if( !wcscmp( pszTemp , pServerName ) )
            {
                DBGMSG( L"Adding %s to favorites\n" , pszTemp );
                return TRUE;
            }
            
            // Go to the next server in the buffer
            
            pszTemp += ( wcslen( pszTemp ) + 1 );
        }
    }
    
    return FALSE;
}



/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ProcessThreadProc
//
// Static member function for process thread
// Called with AfxBeginThread
// Thread terminates when function returns
//
UINT CWinAdminDoc::ProcessThreadProc(LPVOID _doc)
{
    ASSERT(_doc);
    
    // We need a pointer to the document so we can make
    // calls to member functions
    CWinAdminDoc *pDoc = (CWinAdminDoc*)_doc;
    
    // We can't send messages to the view until they're ready
    
    while(!pDoc->AreAllViewsReady()) Sleep(500);
    
    pDoc->AddToFavoritesNow( );
    
    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
    
    if( p != NULL )
    {
        
        p->SendMessage( WM_ADMIN_UPDATE_TVSTATE , 0 , 0 );
    }
    
    while(1) {
        // We don't want to do this constantly, it eats up processor cycles
        // Document destructor will signal the event to wake us up if he
        // wants us to quit
        pDoc->m_ProcessWakeUpEvent.Lock(((CWinAdminApp*)AfxGetApp())->GetProcessListRefreshTime());
        
        // Make sure we don't have to quit
        if(!ShouldProcessContinue()) return 0;
        
        // We only want to enumerate processes if the page is VIEW_SERVER or VIEW_WINSTATION
        if(pDoc->GetCurrentView() == VIEW_SERVER || pDoc->GetCurrentView() == VIEW_WINSTATION) {
            CServer *pServer = (pDoc->GetCurrentView() == VIEW_SERVER) ? (CServer*)pDoc->GetCurrentSelectedNode()
                : (CServer*)((CWinStation*)pDoc->GetCurrentSelectedNode())->GetServer();
            
            // Enumerate processes for this server if his state is SS_GOOD
            if(pServer->IsState(SS_GOOD)) {
                pServer->EnumerateProcesses();
            }
            
            // Make sure we don't have to quit
            if(!ShouldProcessContinue()) return 0;
            
            // We only want to send a message to update the view if the
            // view is still VEIW_SERVER/VIEW_WINSTATION and the currently
            // selected Server is the same one that we just enumerate processes for
            if((pDoc->GetCurrentView() == VIEW_SERVER && pServer == (CServer*)pDoc->GetCurrentSelectedNode())
                || (pDoc->GetCurrentView() == VIEW_WINSTATION && pServer == (CServer*)((CWinStation*)pDoc->GetCurrentSelectedNode())->GetServer())) {
                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
                if(p && ::IsWindow(p->GetSafeHwnd())) p->SendMessage(WM_ADMIN_UPDATE_PROCESSES, 0, (LPARAM)pServer);
            }
        }
        
        // Make sure we don't have to quit
        if(!ShouldProcessContinue()) return 0;
        
    }
    
    return 0;
    
}       // end CWinAdminDoc::ProcessThreadProc


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::UpdateAllProcesses
//
void CWinAdminDoc::UpdateAllProcesses()
{
    LockServerList();
    
    POSITION pos = m_ServerList.GetHeadPosition();
    while(pos) {
        
        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
        // Enumerate processes for this server if his state is SS_GOOD
        if(pServer->IsState(SS_GOOD)) {
            pServer->EnumerateProcesses();
            
            // Send a message to the view to update this server's processes
            CFrameWnd *p = (CFrameWnd*)GetMainWnd();
            if(p && ::IsWindow(p->GetSafeHwnd())) p->SendMessage(WM_ADMIN_UPDATE_PROCESSES, 0, (LPARAM)pServer);
        }
    }
    
    UnlockServerList();
    
}       // end CWinAdminDoc::UpdateAllProcesses


static TCHAR szWinAdminAppKey[] = REG_SOFTWARE_TSERVER TEXT("\\TSADMIN");
static TCHAR szConnectionsPersistent[] = TEXT("ConnectionsPersistent");
static TCHAR szFavList[] = TEXT("Favorites" );
static TCHAR szTVStates[] = TEXT( "TreeViewStates" );
static TCHAR szConnections[] = TEXT("Connections");

/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ReadPreferences
//
// Read user preferences
//
void CWinAdminDoc::ReadPreferences()
{
    HKEY hKeyWinAdmin;
    DWORD dwType, cbData, dwValue;
    
    // Set to defaults
    m_ConnectionsPersistent = FALSE;
    
    // Open registry key for our application
    DWORD Disposition;
    
    if( RegCreateKeyEx( HKEY_CURRENT_USER ,
        szWinAdminAppKey,
        0,
        TEXT(""),
        REG_OPTION_NON_VOLATILE,
        KEY_READ,
        NULL,
        &hKeyWinAdmin,
        &Disposition) != ERROR_SUCCESS )
    {
        return;
    }
    
    // Read the favorites list
    DWORD dwLen = 0;
    
    dwType = 0;
    
    // See how big the multi-string is
    
    int err = RegQueryValueEx( hKeyWinAdmin,
        szFavList,
        NULL,
        &dwType,
        NULL,
        &dwLen );
    
    if( err == ERROR_SUCCESS || err == ERROR_BUFFER_OVERFLOW )
    {
        m_pszFavList = ( LPWSTR )LocalAlloc( 0 , dwLen );
        
        if( m_pszFavList != NULL )
        {
            memset( m_pszFavList , 0 , dwLen );
            
            RegQueryValueEx( hKeyWinAdmin,
                szFavList,
                NULL,
                &dwType,
                (LPBYTE)m_pszFavList,
                &dwLen);            
        }        
    }        
    
    
    // Read the Connections Persist preference
    
    cbData = sizeof( m_ConnectionsPersistent );
    
    if( RegQueryValueEx( hKeyWinAdmin ,
        szConnectionsPersistent ,
        NULL,
        &dwType,
        (LPBYTE)&dwValue,
        &cbData) == ERROR_SUCCESS)
    {
        m_ConnectionsPersistent = dwValue;
    }
    
    // If connections are persistent, read the list of connections saved
    if( m_ConnectionsPersistent )
    {
        dwLen = 0;
        dwType = 0;
        // See how big the multi-string is
        err = RegQueryValueEx( hKeyWinAdmin,
            szConnections,
            NULL,
            &dwType,
            NULL,
            &dwLen );
        
        if(err && (err != ERROR_BUFFER_OVERFLOW) )
        {
            RegCloseKey(hKeyWinAdmin);
            return;
        }        
        
        m_pPersistentConnections = (LPWSTR)LocalAlloc(0, dwLen);
        
        if( m_pPersistentConnections != NULL )
        {
            memset(m_pPersistentConnections, 0, dwLen);
            
            RegQueryValueEx( hKeyWinAdmin,
                szConnections,
                NULL,
                &dwType,
                (LPBYTE)m_pPersistentConnections,
                &dwLen);
        }
    }
    
    g_dwTreeViewExpandedStates = 0;
    
    dwLen = sizeof( g_dwTreeViewExpandedStates );
    
    RegQueryValueEx( hKeyWinAdmin , 
        szTVStates,
        NULL,
        &dwType,
        ( LPBYTE )&g_dwTreeViewExpandedStates,
        &dwLen );
    
    
    RegCloseKey(hKeyWinAdmin);
    
}       // end CWinAdminDoc::ReadPreferences


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::WritePreferences
//
// Write user preferences
//
void CWinAdminDoc::WritePreferences()
{
    HKEY hKeyWinAdmin;
    DWORD dwValue;
    
    // Open registry key for our application
    DWORD Disposition;

    if( RegCreateKeyEx( HKEY_CURRENT_USER,
                        szWinAdminAppKey,
                        0,
                        TEXT(""),
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hKeyWinAdmin,
                        &Disposition) != ERROR_SUCCESS )
    {
        return;
    }
    
    // Write the servers that are in the favorite list
    DWORD dwByteCount = 0;
    
    LockServerList();

    POSITION pos = m_ServerList.GetHeadPosition();

#ifdef _STRESS_BUILD
    int nStressServerLimit = 0;
#endif;

    while(pos)
    {
#ifdef _STRESS_BUILD
        if( nStressServerLimit >= 10000 )
        {
            break;
        }

        nStressServerLimit++;
#endif

        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);

        if( pServer->GetTreeItemFromFav( ) != NULL )
        {
            // format is domain/server
            if( pServer->GetDomain( ) )
            {
                dwByteCount += ( wcslen( pServer->GetDomain( )->GetName() ) * 2 );
                dwByteCount += 2;
            }
            dwByteCount += ( wcslen( pServer->GetName() ) + 1) * 2;
        }
    }

    LPWSTR pBuffer = NULL;

    if( dwByteCount != 0 )
    {
        dwByteCount += 2;   // for ending null

        // Allocate memory.       

        if( ( pBuffer = ( LPWSTR )LocalAlloc( LPTR, dwByteCount ) ) != NULL )
        {
            // Traverse list again and copy servers to buffer.
            LPWSTR pTemp = pBuffer;

            pos = m_ServerList.GetHeadPosition();

#ifdef _STRESS_BUILD 
            nStressServerLimit = 0;
#endif

            while(pos)
            {

#ifdef _STRESS_BUILD
                if( nStressServerLimit >= 10000 )
                {
                    break;
                }

                nStressServerLimit++;
#endif
                // Go to the next server in the list
                CServer *pServer = (CServer*)m_ServerList.GetNext(pos);

                if( pServer->GetTreeItemFromFav( ) != NULL )
                {
                    if( pServer->GetDomain( ) )
                    {
                        lstrcpy( pTemp , pServer->GetDomain( )->GetName( ) );
                        lstrcat( pTemp , L"/" );
                    }
                    lstrcat(pTemp, pServer->GetName());

                    pTemp += ( wcslen( pTemp ) + 1);
                }
            }
        
            *pTemp = L'\0';     // ending null
        
            RegSetValueEx (hKeyWinAdmin, szFavList, 0, REG_MULTI_SZ, (PBYTE)pBuffer, dwByteCount);
        
            LocalFree(pBuffer);        
        }
    }
    else
    {
        RegDeleteValue( hKeyWinAdmin , szFavList );
    }

    UnlockServerList();

    // Write the persistent connections preference
    dwValue = m_ConnectionsPersistent;

    RegSetValueEx( hKeyWinAdmin,
                   szConnectionsPersistent,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(DWORD)
                   );
    
    if( m_ConnectionsPersistent )
    {
        // Create a multistring of the persistent connections
        // loop through the list of servers and see how much memory
        // to allocate for the multistring.
        dwByteCount = 0;
        
        LockServerList();
        POSITION pos = m_ServerList.GetHeadPosition();
        while(pos)
        {
            // Go to the next server in the list
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
            if( pServer->IsState(SS_GOOD) )
            {
                dwByteCount += (wcslen(pServer->GetName()) + 1) * 2;
            }
        }
        
        UnlockServerList();

        dwByteCount += 2;   // for ending null
        
        // Allocate memory.
        pBuffer = NULL;
        
        if( ( pBuffer = ( LPWSTR )LocalAlloc( LPTR, dwByteCount ) ) != NULL )
        {
            // Traverse list again and copy servers to buffer.
            LPWSTR pTemp = pBuffer;            
            LockServerList();
            pos = m_ServerList.GetHeadPosition();
            while(pos)
            {
                // Go to the next server in the list
                CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
                if( pServer->IsState(SS_GOOD) )
                {
                    wcscpy(pTemp, pServer->GetName());
                    pTemp += (wcslen(pServer->GetName()) + 1);
                }
            }
            
            UnlockServerList();
            
            *pTemp = L'\0';     // ending null
            
            // write the registry entry
            RegSetValueEx(hKeyWinAdmin, szConnections, 0, REG_MULTI_SZ, (PBYTE)pBuffer, dwByteCount);
            
            LocalFree(pBuffer);
        }

    }
    else
    {
        RegDeleteValue(hKeyWinAdmin, szConnections);
    }

    // persist treeview state

    // send message to treeview to retreive tv state bits

    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

    DWORD dwTVStates = 0;

    if( p != NULL )
    {
        dwTVStates = ( DWORD )p->SendMessage( WM_ADMIN_GET_TV_STATES , 0 , 0 );
    }

    RegSetValueEx( hKeyWinAdmin , szTVStates , 0 , REG_DWORD , ( PBYTE )&dwTVStates , sizeof( DWORD ) );
    
    RegCloseKey(hKeyWinAdmin);

}       // end CWinAdminDoc::WritePreferences

/*
static TCHAR DOMAIN_KEY[] = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
static TCHAR PRIMARY_VAL[] = TEXT("CachePrimaryDomain");
static TCHAR CACHE_VAL[] =  TEXT("DomainCache");
*/

/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::BuildDomainList
//
// Read the list of trusted domains from the registry
// and build a linked list of CDomains
//
void CWinAdminDoc::BuildDomainList()
{
    /*
    HKEY hKey,hSubKey;
    DWORD size = 128;
    DWORD dwIndex = 0;
    */
    
    PDOMAIN_CONTROLLER_INFO pDCI;


    if( DsGetDcName( NULL ,
                     NULL , 
                     NULL ,
                     NULL ,
                     DS_RETURN_FLAT_NAME,
                     &pDCI ) == NO_ERROR )
    {
        CDomain *pDomain = new CDomain( pDCI->DomainName );

        if(pDomain != NULL )
        {
            pDomain->SetCurrentDomain();

            m_pCurrentDomain = pDomain;

            AddDomain( pDomain );
        }

        NetApiBufferFree( pDCI );


        // query for the other domains

        LPWSTR szDomainNames = NULL;

        if( NetEnumerateTrustedDomains( NULL ,
                                        &szDomainNames ) == ERROR_SUCCESS )
        {
            LPWSTR pszDN = szDomainNames;

            while( *pszDN )
            {
                CDomain *pDomain = new CDomain( pszDN );
            
                if( pDomain != NULL )
                {
                    AddDomain( pDomain );
                }
            
                pszDN += ( wcslen( pszDN ) + 1 );
            }
    
            NetApiBufferFree( szDomainNames );
        }
    }
}       // end CWinAdminDoc::BuildDomainList


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::AddDomain
//
// Add a Domain to DomainList in sorted order
//
void CWinAdminDoc::AddDomain(CDomain *pNewDomain)
{
    ASSERT(pNewDomain);

        BOOLEAN bAdded = FALSE;
        POSITION pos, oldpos;
        int Index;

        // Traverse the DomainList and insert this new Domain,
        // keeping the list sorted by Name.
    for(Index = 0, pos = m_DomainList.GetHeadPosition(); pos != NULL; Index++) {
        oldpos = pos;
        CDomain *pDomain = (CDomain*)m_DomainList.GetNext(pos);

        if(wcscmp(pDomain->GetName(), pNewDomain->GetName()) > 0) {
            // The new object belongs before the current list object.
            m_DomainList.InsertBefore(oldpos, pNewDomain);
                        bAdded = TRUE;
                        // NOTE: If you add a critical section to protect the domain list,
                        // you should change this to a break; and unlock the list
                        // just before exiting this function
            return;
        }
    }

    // If we haven't yet added the Domain, add it now to the tail
    // of the list.
    if(!bAdded) {
        m_DomainList.AddTail(pNewDomain);
        }

}       // end CWinAdminDoc::AddDomain


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::BuildWdList
//
// Read the list of Wds from the registry
// and build a linked list of CWds
//
void CWinAdminDoc::BuildWdList()
{
    LONG Status;
    ULONG Index, ByteCount, Entries;
    WDNAME WdKey;
    LONG QStatus;
    WDCONFIG2 WdConfig;
    TCHAR WdDll[MAX_PATH];
        CWd *pWd;

        // Initialize the Wd list.
    for ( Index = 0, Entries = 1, ByteCount = sizeof(WDNAME);
          (Status =
           RegWdEnumerate( SERVERNAME_CURRENT,
                           &Index,
                           &Entries,
                           WdKey,
                           &ByteCount )) == ERROR_SUCCESS;
          ByteCount = sizeof(WDNAME) ) {

        if ( ( QStatus = RegWdQuery( SERVERNAME_CURRENT, WdKey, &WdConfig,
                                     sizeof(WdConfig),
                                     &ByteCount ) ) != ERROR_SUCCESS ) {

//If this is added back in, the signature of StandardErrorMessage has changed!!!!
#if 0
            STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, QStatus,
                                     IDP_ERROR_REGWDQUERY, WdKey ))
            return(FALSE);
#endif
        }

        /*
         * Only place this Wd in the WdList if it's DLL is present
         * on the system.
         */
        GetSystemDirectory( WdDll, MAX_PATH );
        lstrcat( WdDll, TEXT("\\Drivers\\") );
        lstrcat( WdDll, WdConfig.Wd.WdDLL );
        lstrcat( WdDll, TEXT(".sys" ) );
        if ( _waccess( WdDll, 0 ) != 0 )
            continue;

        pWd = new CWd(&WdConfig, (PWDNAME)&WdKey);

        m_WdList.AddTail(pWd);
        }

}       // end CWinAdminDoc::BuildWdList


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::Refresh
//
// Perform a Refresh
//
void CWinAdminDoc::Refresh()
{
        // We don't want to refresh if we are currently doing one
        if(m_InRefresh) return;

        CWaitCursor Nikki;

        m_InRefresh = TRUE;

        // Wake up our background tasks that enumerates servers
        POSITION pos = m_DomainList.GetHeadPosition();
        while(pos) {
                CDomain *pDomain = (CDomain*)m_DomainList.GetNext(pos);
                pDomain->SetEnumEvent();
        }

        // Make each of the Server's background tasks enumerate WinStations
        LockServerList();
        pos = m_ServerList.GetHeadPosition();
        while(pos) {
                ULONG WSEventFlags;
                CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
                if(pServer->IsHandleGood() && pServer->IsState(SS_GOOD)) {
                        WinStationWaitSystemEvent(pServer->GetHandle(), WEVENT_FLUSH, &WSEventFlags);
                }
        }

        UnlockServerList();

        // If the current page is a processes page, tell appropriate process enumeration
        // background thread to do their thing

        if(m_CurrentView == VIEW_ALL_SERVERS && m_CurrentPage == PAGE_AS_PROCESSES) {
                UpdateAllProcesses();
        }

        if(m_CurrentView == VIEW_DOMAIN && m_CurrentPage == PAGE_DOMAIN_PROCESSES) {
                UpdateAllProcesses();
        }

        if((m_CurrentView == VIEW_SERVER && m_CurrentPage == PAGE_PROCESSES)
                || (m_CurrentView == VIEW_WINSTATION && m_CurrentPage == PAGE_WS_PROCESSES)) {
                m_ProcessWakeUpEvent.SetEvent();
        }

        m_InRefresh = FALSE;

}  // end CWinAdminDoc::Refresh


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::AddServer
//
// Add a Server to ServerList in sorted order
//
void CWinAdminDoc::AddServer(CServer *pNewServer)
{
    ASSERT(pNewServer);
    
    LockServerList();
    
    BOOLEAN bAdded = FALSE;
    POSITION pos, oldpos;
    int Index;
    
    // Traverse the ServerList and insert this new Server,
    // keeping the list sorted by Name.
    for(Index = 0, pos = m_ServerList.GetHeadPosition(); pos != NULL; Index++)
    {
        oldpos = pos;

        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
        
        if( lstrcmpi( pServer->GetName() , pNewServer->GetName() ) > 0 )
        {
            // The new object belongs before the current list object.
            m_ServerList.InsertBefore(oldpos, pNewServer);
            bAdded = TRUE;
            break;
        }
    }
    
    // If we haven't yet added the Server, add it now to the tail
    // of the list.
    if(!bAdded)
    {
        m_ServerList.AddTail(pNewServer);
    }
    
    UnlockServerList();

}       // end CWinAdminDoc::AddServer

//=----------------------------------------------------------------------------------
//= AddToFavoritesNow will add all persisted servers to the fav node and
//= connect to them as appropriate.
void CWinAdminDoc::AddToFavoritesNow( )
{
    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

    LPTSTR pszDomain = NULL;
    LPTSTR pszServer = NULL;
    LPTSTR pszDomServer = NULL;

    int nJump = 0;

    POSITION pos;

    if( m_pszFavList != NULL )
    {
        LPTSTR pszDomServer = m_pszFavList;
        
        while( *pszDomServer )
        {
            pos = m_DomainList.GetHeadPosition();

            nJump = wcslen( pszDomServer );

            pszDomain = pszDomServer;

            TCHAR *pTemp = pszDomServer;

            while( *pTemp )
            {
                if( *pTemp == L'/' )
                {
                    break;
                }

                pTemp++;
            }
            
            if(*pTemp == L'/')
            {
                *pTemp = 0;
                pTemp++;
                pszServer = pTemp;
            }
            else
            {
                //there is no domain for this server
                pszServer = pszDomServer;
                pszDomain = NULL;
            }
            
            // let's check to see if server already exist primarily "this computer"
            if( m_pCurrentServer != NULL && lstrcmpi( pszServer , m_pCurrentServer->GetName( ) ) == 0 )
            {
                p->SendMessage(WM_ADMIN_ADDSERVERTOFAV , 0 , (LPARAM)m_pCurrentServer );
            }
            else
            {
                CDomain *pDomain = NULL;
                CServer *pServer = NULL;

                if( pszDomain )
                {
                    BOOL bFound = FALSE;

                    while( pos )
                    {                
                        pDomain = (CDomain*)m_DomainList.GetNext(pos);                
                
                        if( _wcsicmp( pDomain->GetName() ,  pszDomain ) == 0 )
                        {
                            bFound = TRUE;
                            break;
                        }
                    }

                    if(!bFound)
                    {
                        pDomain = new CDomain( pszDomain );

                        if( pDomain != NULL )
                        {
                            AddDomain( pDomain );
                         
                            p->SendMessage( WM_ADMIN_ADD_DOMAIN , (WPARAM)NULL , ( LPARAM )pDomain );
                        }
                    }
                }

                pServer = new CServer( pDomain , pszServer , FALSE , FALSE );
                
                if( pServer != NULL )
                {
                    pServer->SetManualFind( );

                    AddServer(pServer);
        
                    p->SendMessage(WM_ADMIN_ADDSERVERTOFAV , 0 , (LPARAM)pServer);
        
                }
            }
            
            pszDomServer += nJump + 1;                        
        }
    }   

    // check to see if we need to connect these servers.

    LockServerList();

    pos = m_ServerList.GetHeadPosition();

    while( pos )
    {
        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);

        if( ShouldConnect( pServer->GetName( ) ) )
        {
            if( pServer->GetTreeItemFromFav( ) != NULL )
            {
                pServer->Connect( );
            }
        }
    }


    UnlockServerList();


}
/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::FindServerByName
//
// returns a pointer to a given CServer object if it is in our list
//
CServer* CWinAdminDoc::FindServerByName(TCHAR *pServerName)
{
        ASSERT(pServerName);

        LockServerList();

        POSITION pos = m_ServerList.GetHeadPosition();

        while(pos) {
                CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
                if( lstrcmpi( pServer->GetName() , pServerName ) == 0)
                {
                    UnlockServerList();
                    return pServer;
                }
        }

        UnlockServerList();

        return NULL;

}       // end CWinAdminDoc::FindServerByName


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::FindWdByName
//
// returns a pointer to a given CWd object if it is in our list
//
CWd* CWinAdminDoc::FindWdByName(TCHAR *pWdName)
{
        ASSERT(pWdName);

        LockWdList();

        POSITION pos = m_WdList.GetHeadPosition();

        while(pos) {
                CWd *pWd = (CWd*)m_WdList.GetNext(pos);
                if(wcscmp(pWd->GetName(), pWdName) == 0) {
                        UnlockWdList();
                        return pWd;
                }
        }

        UnlockWdList();

        return NULL;

}       // end CWinAdminDoc::FindWdByName


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::SetTreeCurrent
//
void CWinAdminDoc::SetTreeCurrent(CObject* selected, NODETYPE type)
{
        m_CurrentSelectedNode = selected;
        m_CurrentSelectedType = type;
        CString TitleString;

        // Set the window title
        switch(m_CurrentSelectedType) {
                case NODE_ALL_SERVERS:
                        TitleString.LoadString(IDS_TREEROOT);
                        SetTitle(TitleString);
                        break;
                case NODE_DOMAIN:
                        TitleString.Format(TEXT("\\\\%s"), ((CDomain*)selected)->GetName());
                        SetTitle(TitleString);
                        break;
                case NODE_SERVER:
                        SetTitle(((CServer*)selected)->GetName());
                        break;
                case NODE_WINSTATION:
                        SetTitle(((CWinStation*)selected)->GetServer()->GetName());
                        break;

                case NODE_THIS_COMP:
                        TitleString.LoadString( IDS_THISCOMPUTER );
                        SetTitle( TitleString );
                        break;

                case NODE_FAV_LIST:
                        TitleString.LoadString( IDS_FAVSERVERS );
                        SetTitle( TitleString );
                        break;
        }

}       // end CWinAdminDoc::SetTreeCurrent


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::SendWinStationMessage
//
//      bTemp is TRUE if message is to be sent to the temporarily selected
//      tree item.
//
void CWinAdminDoc::SendWinStationMessage(BOOL bTemp, MessageParms *pParms)
{
        ASSERT(pParms);

        // Are we sending a message to temporarily selected tree item?
        if(bTemp) {
                // Is the temporarily selected item in the tree a WinStation?
                if(m_TempSelectedType == NODE_WINSTATION) {
                        pParms->pWinStation = (CWinStation*)m_pTempSelectedNode;
                        AfxBeginThread((AFX_THREADPROC)CWinStation::SendMessage, pParms);
                }

                return;
        }

        // Is the WinStation selected in the tree?
        if(m_CurrentSelectedType == NODE_WINSTATION) {
                pParms->pWinStation = (CWinStation*)m_CurrentSelectedNode;
                AfxBeginThread((AFX_THREADPROC)CWinStation::SendMessage, pParms);
        }
        // Go through the list of WinStations on the currently selected server
        // and send messages to those that are selected
        else if(m_CurrentView == VIEW_SERVER) {
                // Get a pointer to the selected server
                CServer *pServer = (CServer*)m_CurrentSelectedNode;
                // Lock the server's list of WinStations
                pServer->LockWinStationList();
                // Get a pointer to the server's list of WinStations
                CObList *pWinStationList = pServer->GetWinStationList();

                // Iterate through the WinStation list
                POSITION pos = pWinStationList->GetHeadPosition();

                while(pos) {
                        CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                        if(pWinStation->IsSelected()) {
                                // Make a copy of the MessageParms
                                MessageParms *pParmsCopy = new MessageParms;
                if(pParmsCopy) {
                                    memcpy(pParmsCopy, pParms, sizeof(MessageParms));
                                    // Start a thread to send the message
                                    pParmsCopy->pWinStation = pWinStation;
                                    AfxBeginThread((AFX_THREADPROC)CWinStation::SendMessage, pParmsCopy);
                }
                        }
                }

                // Unlock the list of WinStations
                pServer->UnlockWinStationList();

                // Delete MessageParms - we sent copies to the WinStation objects
                // They will delete their copies
                delete pParms;
        }
        else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
                LockServerList();
                POSITION pos2 = m_ServerList.GetHeadPosition();
                while(pos2) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
                        // Lock the server's list of WinStations
                        pServer->LockWinStationList();
                        // Get a pointer to the server's list of WinStations
                        CObList *pWinStationList = pServer->GetWinStationList();

                        // Iterate through the WinStation list
                        POSITION pos = pWinStationList->GetHeadPosition();

                        while(pos) {
                                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                                if(pWinStation->IsSelected()) {
                                        // Make a copy of the MessageParms
                                        MessageParms *pParmsCopy = new MessageParms;
                    if(pParmsCopy) {
                                            memcpy(pParmsCopy, pParms, sizeof(MessageParms));
                                            // Start a thread to send the message
                                            pParmsCopy->pWinStation = pWinStation;
                                            AfxBeginThread((AFX_THREADPROC)CWinStation::SendMessage, pParmsCopy);
                    }
                                }
                        }

                        // Unlock the list of WinStations
                        pServer->UnlockWinStationList();
                }

                UnlockServerList();

                // Delete MessageParms - we sent copies to the WinStation objects
                // They will delete their copies
                delete pParms;
        }

}       // end CWinAdminDoc::SendWinStationMessage


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ConnectWinStation
//
//      bTemp is TRUE if we are to connect to the temporarily selected tree item.
//
void CWinAdminDoc::ConnectWinStation(BOOL bTemp, BOOL bUser)
{
        // Are we connecting to temporarily selected tree item?
        if(bTemp) {
                // Is the temporarily selected item in the tree a WinStation?
                if(m_TempSelectedType == NODE_WINSTATION) {
                        ((CWinStation*)m_pTempSelectedNode)->Connect(NULL);
                }

                return;
        }


        if(m_CurrentSelectedType == NODE_WINSTATION) {
                ((CWinStation*)m_CurrentSelectedNode)->Connect(NULL);
        }
        // Go through the list of WinStations on the currently selected server
        // and disconnect those that are selected
        else if(m_CurrentView == VIEW_SERVER) {
                // Get a pointer to the selected server
                CServer *pServer = (CServer*)m_CurrentSelectedNode;
                // Lock the server's list of WinStations
                pServer->LockWinStationList();
                // Get a pointer to the server's list of WinStations
                CObList *pWinStationList = pServer->GetWinStationList();

                // Iterate through the WinStation list
                POSITION pos = pWinStationList->GetHeadPosition();

                while(pos) {
                        CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                        if(pWinStation->IsSelected()) {
                                // do the connect
                                pWinStation->Connect(bUser);
                                break;  // we can only connect to one WinStation
                        }
                }

                // Unlock the list of WinStations
                pServer->UnlockWinStationList();
        }
        else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
                LockServerList();
                POSITION pos2 = m_ServerList.GetHeadPosition();
                while(pos2) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
                        // Lock the server's list of WinStations
                        pServer->LockWinStationList();
                        // Get a pointer to the server's list of WinStations
                        CObList *pWinStationList = pServer->GetWinStationList();

                        // Iterate through the WinStation list
                        POSITION pos = pWinStationList->GetHeadPosition();

                        while(pos) {
                                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                                if(pWinStation->IsSelected()) {
                                        // do the connect
                                        pWinStation->Connect(bUser);
                                        break;  // we can only connect to one WinStation
                                }
                        }
                        // Unlock the list of WinStations
                        pServer->UnlockWinStationList();
                }

                UnlockServerList();
        }

}       // end CWinAdminDoc::ConnectWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::StatusWinStation
//
//      bTemp is TRUE if we are to show status for the temporarily selected tree item.
//
void CWinAdminDoc::StatusWinStation(BOOL bTemp)
{
        // Are we showing status for the temporarily selected tree item?
        if(bTemp) {
                // Is the temporarily selected item in the tree a WinStation?
                if(m_TempSelectedType == NODE_WINSTATION) {
                        ((CWinStation*)m_pTempSelectedNode)->ShowStatus();
                }

                return;
        }

        if(m_CurrentSelectedType == NODE_WINSTATION) {
                ((CWinStation*)m_CurrentSelectedNode)->ShowStatus();
        }
        // Go through the list of WinStations on the currently selected server
        // and show status for those that are selected
        else if(m_CurrentView == VIEW_SERVER) {
                // Get a pointer to the selected server
                CServer *pServer = (CServer*)m_CurrentSelectedNode;
                // Lock the server's list of WinStations
                pServer->LockWinStationList();
                // Get a pointer to the server's list of WinStations
                CObList *pWinStationList = pServer->GetWinStationList();

                // Iterate through the WinStation list
                POSITION pos = pWinStationList->GetHeadPosition();

                while(pos) {
                        CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                        if(pWinStation->IsSelected()) {
                                pWinStation->ShowStatus();
                        }
                }

                // Unlock the list of WinStations
                pServer->UnlockWinStationList();
        }
        else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
                LockServerList();
                POSITION pos2 = m_ServerList.GetHeadPosition();
                while(pos2) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
                        // Lock the server's list of WinStations
                        pServer->LockWinStationList();
                        // Get a pointer to the server's list of WinStations
                        CObList *pWinStationList = pServer->GetWinStationList();

                        // Iterate through the WinStation list
                        POSITION pos = pWinStationList->GetHeadPosition();

                        while(pos) {
                                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                                if(pWinStation->IsSelected()) {
                                        pWinStation->ShowStatus();
                                }
                        }

                        // Unlock the list of WinStations
                        pServer->UnlockWinStationList();
                }

                UnlockServerList();
        }

}       // end CWinAdminDoc::StatusWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::DisconnectWinStation
//
//      bTemp is TRUE if we are disconnecting the temporarily selected tree item.
//
void CWinAdminDoc::DisconnectWinStation(BOOL bTemp)
{
        // Are we disconnecting the temporarily selected tree item?
        if(bTemp) {
                // Is the temporarily selected item in the tree a WinStation?
                if(m_TempSelectedType == NODE_WINSTATION) {
                        AfxBeginThread((AFX_THREADPROC)CWinStation::Disconnect, (CWinStation*)m_pTempSelectedNode);
                }

                return;
        }

        if(m_CurrentSelectedType == NODE_WINSTATION) {
                AfxBeginThread((AFX_THREADPROC)CWinStation::Disconnect, (CWinStation*)m_CurrentSelectedNode);
        }
        // Go through the list of WinStations on the currently selected server
        // and disconnect those that are selected
        else if(m_CurrentView == VIEW_SERVER) {
                // Get a pointer to the selected server
                CServer *pServer = (CServer*)m_CurrentSelectedNode;
                // Lock the server's list of WinStations
                pServer->LockWinStationList();
                // Get a pointer to the server's list of WinStations
                CObList *pWinStationList = pServer->GetWinStationList();

                // Iterate through the WinStation list
                POSITION pos = pWinStationList->GetHeadPosition();

                while(pos) {
                        CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                        if(pWinStation->IsSelected()) {
                                // Start a thread to do the disconnect
                                AfxBeginThread((AFX_THREADPROC)CWinStation::Disconnect, pWinStation);
                        }
                }

                // Unlock the list of WinStations
                pServer->UnlockWinStationList();
        }
        else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
                LockServerList();
                POSITION pos2 = m_ServerList.GetHeadPosition();
                while(pos2) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
                        // Lock the server's list of WinStations
                        pServer->LockWinStationList();
                        // Get a pointer to the server's list of WinStations
                        CObList *pWinStationList = pServer->GetWinStationList();

                        // Iterate through the WinStation list
                        POSITION pos = pWinStationList->GetHeadPosition();

                        while(pos) {
                                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                                if(pWinStation->IsSelected()) {
                                        // Start a thread to do the disconnect
                                        AfxBeginThread((AFX_THREADPROC)CWinStation::Disconnect, pWinStation);
                                }
                        }

                        // Unlock the list of WinStations
                        pServer->UnlockWinStationList();
                }

                UnlockServerList();
        }

}       // end CWinAdminDoc::DisconnectWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ResetWinStation
//
//      bTemp is TRUE if we are to reset the temporarily selected tree item.
//      bReset is TRUE if reset, FALSE if logoff
//
void CWinAdminDoc::ResetWinStation(BOOL bTemp, BOOL bReset)
{
    // Are we resetting the temporarily selected tree item?
    if(bTemp)
    {
        // Is the temporarily selected item in the tree a WinStation?
        if(m_TempSelectedType == NODE_WINSTATION)
        {
            // create a reset parameters structure
            ResetParms *pResetParms = new ResetParms;
            if(pResetParms)
            {
                pResetParms->pWinStation = (CWinStation*)m_pTempSelectedNode;

                pResetParms->bReset = bReset;

                AfxBeginThread((AFX_THREADPROC)CWinStation::Reset, pResetParms);

                // the thread will delete pResetParms
            }
        }
        
        return;
    }
    
    if(m_CurrentSelectedType == NODE_WINSTATION)
    {
        // create a reset parameters structure
        ResetParms *pResetParms = new ResetParms;

        if(pResetParms)
        {
            pResetParms->pWinStation = (CWinStation*)m_CurrentSelectedNode;

            pResetParms->bReset = bReset;

            AfxBeginThread((AFX_THREADPROC)CWinStation::Reset, pResetParms);

            // the thread will delete pResetParms
        }
    }
    // Go through the list of WinStations on the currently selected server
    // and reset those that are selected
    else if(m_CurrentView == VIEW_SERVER)
    {
        // Get a pointer to the selected server
        CServer *pServer = (CServer*)m_CurrentSelectedNode;
        // Lock the server's list of WinStations
        pServer->LockWinStationList();
        // Get a pointer to the server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();
        
        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();
        
        while(pos)
        {
            CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

            if(pWinStation->IsSelected())
            {
                // create a reset parameters structure
                ResetParms *pResetParms = new ResetParms;

                if(pResetParms)
                {
                    pResetParms->pWinStation = pWinStation;

                    pResetParms->bReset = bReset;
                    // Start a thread to do the reset
                    AfxBeginThread((AFX_THREADPROC)CWinStation::Reset, pResetParms);
                    // the thread will delete pResetParms
                }
            }
        }
        
        // Unlock the list of WinStations
        pServer->UnlockWinStationList();
    }
    else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN)
    {
        LockServerList();
        POSITION pos2 = m_ServerList.GetHeadPosition();
        while(pos2)
        {
            // Get a pointer to the server
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
            // Lock the server's list of WinStations
            pServer->LockWinStationList();
            // Get a pointer to the server's list of WinStations
            CObList *pWinStationList = pServer->GetWinStationList();            
            // Iterate through the WinStation list
            POSITION pos = pWinStationList->GetHeadPosition();
            
            while(pos)
            {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                if( pWinStationList != NULL && pWinStation->IsSelected() )
                {                           
                    if( GetCurrentPage( ) == PAGE_AS_USERS && pWinStation->GetState() == State_Listen )
                    {
                        // from a user experience if the listener winstation has been selected from a 
                        // previous page that went out of focus - then not skipping this winstation
                        // would appear as if we disconnected from every connected winstation.

                        continue;
                    }
                    // create a reset parameters structure
                    ResetParms *pResetParms = new ResetParms;
                    if( pResetParms != NULL )
                    {
                        pResetParms->pWinStation = pWinStation;
                        pResetParms->bReset = bReset;
                        // Start a thread to do the reset
                        DBGMSG( L"TSMAN!CWinAdminDoc_ResetWinStation %s\n", pWinStation->GetName() );
                        AfxBeginThread((AFX_THREADPROC)CWinStation::Reset, pResetParms);
                    }                 
                }
            }
            
            // Unlock the list of WinStations
            pServer->UnlockWinStationList();
        }
        
        UnlockServerList();
    }
    
}       // end CWinAdminDoc::ResetWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ShadowWinStation
//
//      bTemp is TRUE if we are to shadow the temporarily selected tree item.
//
void CWinAdminDoc::ShadowWinStation(BOOL bTemp)
{
        // Are we resetting the temporarily selected tree item?
        if(bTemp) {
                // Is the temporarily selected item in the tree a WinStation?
                if(m_TempSelectedType == NODE_WINSTATION) {
                        ((CWinStation*)m_pTempSelectedNode)->Shadow();
                }

                return;
        }

        // Is the WinStation selected in the tree?
        if(m_CurrentSelectedType == NODE_WINSTATION) {
                ((CWinStation*)m_CurrentSelectedNode)->Shadow();
        }
        // Go through the list of WinStations on the currently selected server
        // and send messages to those that are selected
        else if(m_CurrentView == VIEW_SERVER) {
                // Get a pointer to the selected server
                CServer *pServer = (CServer*)m_CurrentSelectedNode;
                // Lock the server's list of WinStations
                pServer->LockWinStationList();
                // Get a pointer to the server's list of WinStations
                CObList *pWinStationList = pServer->GetWinStationList();
        BOOL IsLockAlreadyReleased = FALSE;

                // Iterate through the WinStation list
                POSITION pos = pWinStationList->GetHeadPosition();

                while(pos) {
                        CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                        if(pWinStation->IsSelected()) {
                        pServer->UnlockWinStationList();
                IsLockAlreadyReleased = TRUE;
                                pWinStation->Shadow();
                                break;  // we can only shadow one WinStation
                        }
                }

                // Unlock the list of WinStations
        if (IsLockAlreadyReleased == FALSE) {
                    pServer->UnlockWinStationList();
        }
        }
        else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
                LockServerList();
                POSITION pos2 = m_ServerList.GetHeadPosition();
                while(pos2) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
                        // Lock the server's list of WinStations
                        pServer->LockWinStationList();
                        // Get a pointer to the server's list of WinStations
                        CObList *pWinStationList = pServer->GetWinStationList();
            BOOL IsLockAlreadyReleased = FALSE;

                        // Iterate through the WinStation list
                        POSITION pos = pWinStationList->GetHeadPosition();

                        while(pos) {
                                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                                if(pWinStation->IsSelected()) {
                                pServer->UnlockWinStationList();
                    IsLockAlreadyReleased = TRUE;
                                        pWinStation->Shadow();
                                        break;  // we can only shadow one WinStation
                                }
                        }

                        // Unlock the list of WinStations
            if (IsLockAlreadyReleased == FALSE) {
                            pServer->UnlockWinStationList();
            }
            else
            {
                break;  // we can only shadow one WinStation
            }
                }
                UnlockServerList();
        }

}       // end CWinAdminDoc::ShadowWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ServerConnect
//
void CWinAdminDoc::ServerConnect()
{
    ODS( L"CWinAdminDoc::ServerConnect\n" );
    // Is the Server selected in the tree?
    if(m_TempSelectedType == NODE_SERVER)
    {
        CServer *pServer = (CServer*)m_pTempSelectedNode;
        // Tell the server to connect        
        if( pServer->GetState() == SS_BAD && pServer->HasLostConnection( ) )
        {
            ODS( L"\tDisconnecting from server\n" );
            /* disconnect */
            pServer->Disconnect( );
        }
        pServer->Connect();
    }
    else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN)
    {
        LockServerList();
        POSITION pos = m_ServerList.GetHeadPosition();
        ODS( L"\tenumerating from server list\n" );
        while(pos) {
            // Get a pointer to the server
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
            // If this Server is selected, connect to it
            if( pServer->IsSelected() )
            {
                // Tell the server to connect
                
                if( pServer->GetState() == SS_BAD && pServer->HasLostConnection( ) )
                {
                    ODS( L"\tDisconnecting from server\n" );
                    /* disconnect */
                    pServer->Disconnect( );
                }
                pServer->Connect();
            }
        }
        UnlockServerList();
    }

}  // end CWinAdminDoc::ServerConnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ServerDisconnect
//
void CWinAdminDoc::ServerDisconnect()
{
        // Is the Server selected in the tree?
        if(m_TempSelectedType == NODE_SERVER) {
                CServer *pServer = (CServer*)m_pTempSelectedNode;
                // Tell the server to disconnect
                pServer->Disconnect();
        }
        else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
        CString AString;
            CDialog dlgWait;
            dlgWait.Create(IDD_SHUTDOWN, NULL);

                LockServerList();
        // Do a first loop to signal the server background threads that they must stop
                POSITION pos = m_ServerList.GetHeadPosition();
                while(pos) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
                        // If this Server is selected, stop its background thread
                        if(pServer->IsSelected()) {
                // thell the server background thread to stop
                pServer->ClearBackgroundContinue();
            }
                }
        // do a second loop to disconnect the servers
                pos = m_ServerList.GetHeadPosition();
                while(pos) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
                        // If this Server is selected, disconnect from it
                        if(pServer->IsSelected()) {
                            AString.Format(IDS_DISCONNECTING, pServer->GetName());
                            dlgWait.SetDlgItemText(IDC_SHUTDOWN_MSG, AString);

                        // Tell the server to disconnect
                        pServer->Disconnect();
                        }
                }
                UnlockServerList();

        dlgWait.PostMessage(WM_CLOSE);

        }

}  // end CWinAdminDoc::ServerDisconnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::TempDomainConnectAllServers
//
// Connect to all the servers in temporarily selected Domain
//
void CWinAdminDoc::TempDomainConnectAllServers()
{
        if(m_TempSelectedType == NODE_DOMAIN) {
                ((CDomain*)m_pTempSelectedNode)->ConnectAllServers();
        }

}  // end CWinAdminDoc::TempDomainConnectAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::TempDomainDisconnectAllServers
//
// Disconnect from all servers in temporarily selected Domain
//
void CWinAdminDoc::TempDomainDisconnectAllServers()
{
        if(m_TempSelectedType == NODE_DOMAIN) {

                ((CDomain*)m_pTempSelectedNode)->DisconnectAllServers();
        }

}       // end CWinAdminDoc::TempDomainDisconnectAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CurrentDomainConnectAllServers
//
// Connect to all the servers in currently selected Domain
//
void CWinAdminDoc::CurrentDomainConnectAllServers()
{
        if(m_CurrentSelectedType == NODE_DOMAIN) {

                ((CDomain*)m_CurrentSelectedNode)->ConnectAllServers();

        }

}  // end CWinAdminDoc::CurrentDomainConnectAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CurrentDomainDisconnectAllServers
//
// Disconnect from all servers in currently selected Domain
//
void CWinAdminDoc::CurrentDomainDisconnectAllServers()
{
        if(m_CurrentSelectedType == NODE_DOMAIN) {

                ((CDomain*)m_CurrentSelectedNode)->DisconnectAllServers();
        }

}       // end CWinAdminDoc::CurrentDomainDisconnectAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::DomainFindServers
//
// Find all servers in a Domain
//
void CWinAdminDoc::DomainFindServers()
{
        if(m_TempSelectedType == NODE_DOMAIN) {
                CDomain *pDomain = (CDomain*)m_pTempSelectedNode;

                if(!pDomain->GetThreadPointer()) pDomain->StartEnumerating();
        }

}       // end CWinAdminDoc::DomainFindServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ConnectToAllServers
//
// Connect to all the servers
//
void CWinAdminDoc::ConnectToAllServers()
{
        LockServerList();
        POSITION pos = m_ServerList.GetHeadPosition();
        while(pos) {
                // Get a pointer to the server
                CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
                // If this server isn't currently connected, connect to it
                if(pServer->IsState(SS_NOT_CONNECTED)) {
                        // Tell the server to connect
                    pServer->Connect();
                }
        }

        UnlockServerList();

}  // end CWinAdminDoc::ConnectToAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::DisconnectFromAllServers
//
// Disconnect from all the servers
//
void CWinAdminDoc::DisconnectFromAllServers()
{
    CString AString;
    CDialog dlgWait;
    dlgWait.Create(IDD_SHUTDOWN, NULL);
    
    
    // tell each domain thread to stop enumerating while we're shutting down all servers

#ifdef _STRESS_BUILD
    g_fWaitForAllServersToDisconnect = 1;
#endif

    POSITION pos;
    
    LockServerList();    
    
    // Do a first loop to signal the server background threads that they must stop
    pos = m_ServerList.GetHeadPosition();

    while( pos )
    {
        // Get a pointer to the server
        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
        
        // If this Server is currently connected, tell the server background thread to stop
        if(pServer->GetState() != SS_NOT_CONNECTED)
        {
            pServer->ClearBackgroundContinue();
        }
    }
    // do a second loop to disconnect the servers
    pos = m_ServerList.GetHeadPosition();
    while(pos)
    {
        // Get a pointer to the server
        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
        // If this server is currently connected, disconnect from it
        if(pServer->GetState() != SS_NOT_CONNECTED)
        {
            AString.Format(IDS_DISCONNECTING, pServer->GetName());
            dlgWait.SetDlgItemText(IDC_SHUTDOWN_MSG, AString);
            // Tell the server to disconnect
            pServer->Disconnect();
        }
    }
    
    UnlockServerList();
    
    dlgWait.PostMessage(WM_CLOSE);

#ifdef _STRESS_BUILD
    g_fWaitForAllServersToDisconnect = 0;
#endif
    
}  // end CWinAdminDoc::DisconnectFromAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::FindAllServers
//
// find all Servers in all Domains
//
void CWinAdminDoc::FindAllServers()
{
        if(m_bInShutdown) return;

        POSITION pos = m_DomainList.GetHeadPosition();
        while(pos) {
                // Get a pointer to the domain
                CDomain *pDomain = (CDomain*)m_DomainList.GetNext(pos);
                // If this domain isn't currently enumerating servers, tell it to
                if(!pDomain->GetThreadPointer()) pDomain->StartEnumerating();

        }

}  // end CWinAdminDoc::FindAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::TerminateProcess
//
void CWinAdminDoc::TerminateProcess()
{
        if(m_CurrentView == VIEW_SERVER) {
                // Get a pointer to the selected server
                CServer *pServer = (CServer*)m_CurrentSelectedNode;
                // Lock the server's list of Processes
                pServer->LockProcessList();
                // Get a pointer to the server's list of Processes
                CObList *pProcessList = pServer->GetProcessList();

                // Iterate through the Process list
                POSITION pos = pProcessList->GetHeadPosition();

                while(pos) {
                        CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);
                        if(pProcess->IsSelected() && !pProcess->IsTerminating()) {
                                // Start a thread to do the terminate
                                AfxBeginThread((AFX_THREADPROC)CWinAdminDoc::TerminateProc, pProcess);
                        }
                }

                // Unlock the list of Processes
                pServer->UnlockProcessList();
        }

        else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
                POSITION pos2 = m_ServerList.GetHeadPosition();
                while(pos2) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
                        // Lock the server's list of Processes
                        pServer->LockProcessList();
                        // Get a pointer to the server's list of Processes
                        CObList *pProcessList = pServer->GetProcessList();

                        // Iterate through the Process list
                        POSITION pos = pProcessList->GetHeadPosition();

                        while(pos) {
                                CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);
                                if(pProcess->IsSelected() && !pProcess->IsTerminating()) {
                                        // Start a thread to do the terminate
                                        AfxBeginThread((AFX_THREADPROC)CWinAdminDoc::TerminateProc, pProcess);
                                }
                        }

                        // Unlock the list of Processes
                        pServer->UnlockProcessList();
                }
        }

        else if(m_CurrentView == VIEW_WINSTATION) {
                 // Get the Server for the currently viewed WinStation
                 CServer *pServer = (CServer*)((CWinStation*)m_CurrentSelectedNode)->GetServer();

          // Lock the server's list of Processes
          pServer->LockProcessList();
          // Get a pointer to the server's list of Processes
          CObList *pProcessList = pServer->GetProcessList();

          // Iterate through the Process list
          POSITION pos = pProcessList->GetHeadPosition();

          while(pos) {
                  CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);
                  if(pProcess->IsSelected() && !pProcess->IsTerminating()
                                        && (pProcess->GetWinStation() == (CWinStation*)m_CurrentSelectedNode)) {
                          // Start a thread to do the terminate
                          AfxBeginThread((AFX_THREADPROC)CWinAdminDoc::TerminateProc, pProcess);
                  }
          }

          // Unlock the list of Processes
          pServer->UnlockProcessList();
        }

}       // end CWinAdminDoc::TerminateProcess


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::TerminateProc
//
UINT CWinAdminDoc::TerminateProc(LPVOID parms)
{
        ASSERT(parms);

        CProcess *pProcess = (CProcess*)parms;
        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        // Set the flag to say that we are trying to terminate this process
        pProcess->SetTerminating();

        CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();


        if(WinStationTerminateProcess(pProcess->GetServer()->GetHandle(),pProcess->GetPID(), 0))
        {
                // Send a message to remove the process from the view
        if(p && ::IsWindow(p->GetSafeHwnd()))
                {
                p->SendMessage(WM_ADMIN_REMOVE_PROCESS, 0, (LPARAM)pProcess);

        }
    }
        else
        {
                pProcess->ClearTerminating();
                //Display Error Message
                if(p && ::IsWindow(p->GetSafeHwnd()))
                {
                        DWORD Error = GetLastError();
                        
                        //We need this to know the length of the error message
                        //now that StandardErrorMessage requires that
                        CString tempErrorMessage;
                        tempErrorMessage.LoadString(IDS_CANNOT_TERMINATE);
                        StandardErrorMessage(AfxGetAppName(), AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
                                             LOGONID_NONE,Error,tempErrorMessage.GetLength(),wcslen(pProcess->GetImageName()),
                                             IDS_CANNOT_TERMINATE,pProcess->GetImageName());
                }

        }

        return 0;

}       // end CWinAdminDoc::TerminateProc


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckConnectAllowed
//
BOOL CWinAdminDoc::CheckConnectAllowed(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        // If they are the same WinStation, don't let them connect
        if(pWinStation->GetServer()->IsCurrentServer()
                && ((CWinAdminApp*)AfxGetApp())->GetCurrentLogonId() == pWinStation->GetLogonId())
                        return FALSE;

        if((((CWinAdminApp*)AfxGetApp())->GetCurrentWSFlags() & WDF_SHADOW_SOURCE)
                && !pWinStation->HasOutstandingThreads()
                && !pWinStation->IsDown()
        && !pWinStation->IsListener()
                && !pWinStation->IsSystemConsole()
                && (pWinStation->IsDisconnected() || pWinStation->IsActive())
                && pWinStation->IsOnCurrentServer())
                        return TRUE;

        return FALSE;

}       // end CWinAdminDoc::CheckConnectAllowed


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckDisconnectAllowed
//
BOOL CWinAdminDoc::CheckDisconnectAllowed(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        if(!pWinStation->HasOutstandingThreads()
                && !pWinStation->IsDown()
        && !pWinStation->IsListener()
                && !pWinStation->IsSystemConsole()
                && pWinStation->IsConnected())
                        return TRUE;

        return FALSE;

}       // end CWinAdminDoc::CheckDisconnectAllowed


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckResetAllowed
//
BOOL CWinAdminDoc::CheckResetAllowed(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        if(!pWinStation->HasOutstandingThreads()
                && !pWinStation->IsSystemConsole())
                        return TRUE;

        return FALSE;

}       // end CWinAdminDoc::CheckResetAllowed


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckShadowAllowed
//
BOOL CWinAdminDoc::CheckShadowAllowed(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        // If they are the same WinStation, don't let them shadow
        if( pWinStation->GetServer()->IsCurrentServer() &&
            ((CWinAdminApp*)AfxGetApp())->GetCurrentLogonId() == pWinStation->GetLogonId() )
        {
            return FALSE;
        }

        if(!pWinStation->HasOutstandingThreads() &&
           !pWinStation->IsDown() &&    // winstation is not down
           !pWinStation->IsListener() &&    // not a listening winstation
           (((CWinAdminApp*)AfxGetApp())->GetCurrentWSFlags() & WDF_SHADOW_SOURCE) && // We are valid shadow source, query winstation's wdflag in registry
           (pWinStation->CanBeShadowed()) &&  // target can be shadow.
           ( pWinStation->GetState() != State_Shadow ) ) // target is not already in shadow
        {
            return TRUE;
        }

        return FALSE;

}       // end CWinAdminDoc::CheckShadowAllowed



/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckSendMessageAllowed
//
BOOL CWinAdminDoc::CheckSendMessageAllowed(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        if(!pWinStation->HasOutstandingThreads()
                && !pWinStation->IsDown()
        && !pWinStation->IsListener()
                && pWinStation->IsConnected())
                        return TRUE;

        return FALSE;

}       // end CWinAdminDoc::CheckSendMessageAllowed


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckStatusAllowed
//
BOOL CWinAdminDoc::CheckStatusAllowed(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        if(!pWinStation->HasOutstandingThreads()
                && !pWinStation->IsDown()
                && !pWinStation->IsDisconnected()
                && !pWinStation->IsIdle()
                && !pWinStation->IsListener()
                && !pWinStation->IsSystemConsole())
                        return TRUE;

        return FALSE;

}       // end CWinAdminDoc::CheckStatusAllowed


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckActionAllowed
//
BOOL CWinAdminDoc::CheckActionAllowed(BOOL (*CheckFunction)(CWinStation *pWinStation), BOOL AllowMultipleSelected)
{
    ASSERT(CheckFunction);
    
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_CurrentSelectedType == NODE_WINSTATION)
    { 
        CWinStation *pWinStation = (CWinStation*)m_CurrentSelectedNode;
        return CheckFunction(pWinStation);
    }
    
    // We only care if the current view is Server or All Listed Servers
    if(m_CurrentView == VIEW_SERVER)
    {     
        // We need to make sure we are on the WinStation or Users page
        if(m_CurrentPage != PAGE_WINSTATIONS && m_CurrentPage != PAGE_USERS)
        {       
            return FALSE;
        }
        int NumSelected = 0;
        CServer *pServer = (CServer*)m_CurrentSelectedNode;
        // If there aren't any WinStations selected on this server, return
        if(!pServer->GetNumWinStationsSelected())
        {     
            return FALSE;
        }
        
        pServer->LockWinStationList();
        CObList *pWinStationList = pServer->GetWinStationList();
        
        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();
        
        while(pos)
        {
            CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
            if(pWinStation->IsSelected())
            {
                if(!CheckFunction(pWinStation))
                {
                    pServer->UnlockWinStationList();
                    return FALSE;
                }
                NumSelected++;
                if(!AllowMultipleSelected && NumSelected > 1)
                {
                    pServer->UnlockWinStationList();
                    return FALSE;
                }
            }
        }
        
        pServer->UnlockWinStationList();
        // If we got here, all the selected WinStations passed our criteria
        if(NumSelected) return TRUE;
    }
    else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN)
    {        
        // If we are doing a refresh, we can't do anything else
        if(m_InRefresh) return FALSE;
        // We need to make sure we are on the WinStation or Users page
        if(m_CurrentPage != PAGE_AS_WINSTATIONS && m_CurrentPage != PAGE_AS_USERS
            && m_CurrentPage != PAGE_DOMAIN_WINSTATIONS && m_CurrentPage != PAGE_DOMAIN_USERS)
            return FALSE;
        int NumSelected = 0;
        
        LockServerList();
        POSITION pos1 = m_ServerList.GetHeadPosition();
        
        while(pos1) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos1);
            // Are there any WinStations selected on this server?
            if(pServer->GetNumWinStationsSelected()) {
                pServer->LockWinStationList();
                CObList *pWinStationList = pServer->GetWinStationList();
                // Iterate through the WinStation list
                POSITION pos = pWinStationList->GetHeadPosition();
                
                while(pos) {
                    CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                    if(pWinStation->IsSelected()) {
                        if(!CheckFunction(pWinStation)) {
                            pServer->UnlockWinStationList();
                            UnlockServerList();
                            return FALSE;
                        }
                        NumSelected++;
                        if(!AllowMultipleSelected && NumSelected > 1) {
                            pServer->UnlockWinStationList();
                            UnlockServerList();
                            return FALSE;
                        }
                    }
                }
                pServer->UnlockWinStationList();
            } // end if(pServer->GetNumWinStationsSelected())
        }
        
        UnlockServerList();

        // If we got this far, all the selected WinStations passed the criteria
        if(NumSelected) return TRUE;
    }
    
    return FALSE;
    
} // end CWinAdminDoc::CheckActionAllowed


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanConnect
//
// Returns TRUE if the currently selected item in views can be Connected to
//
BOOL CWinAdminDoc::CanConnect()
{
        return CheckActionAllowed(CheckConnectAllowed, FALSE);

}       // end CWinAdminDoc::CanConnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanDisconnect
//
// Returns TRUE if the currently selected item in views can be Disconnected
//
BOOL CWinAdminDoc::CanDisconnect()
{    
    return CheckActionAllowed(CheckDisconnectAllowed, TRUE);

}       // end CWinAdminDoc::CanDisconnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanReset
//
// Returns TRUE if the currently selected item in views can be Reset
//
BOOL CWinAdminDoc::CanReset()
{
        return CheckActionAllowed(CheckResetAllowed, TRUE);

}       // end CWinAdminDoc::CanReset


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanShadow
//
// Returns TRUE if the currently selected item in views can be Shadowed
//
BOOL CWinAdminDoc::CanShadow()
{
        return CheckActionAllowed(CheckShadowAllowed, FALSE);

}       // end CWinAdminDoc::CanShadow


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanSendMessage
//
// Returns TRUE if the currently selected item in views can be sent a message
//
BOOL CWinAdminDoc::CanSendMessage()
{
        return CheckActionAllowed(CheckSendMessageAllowed, TRUE);

}       // end CWinAdminDoc::CanSendMessage


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanStatus
//
// Returns TRUE if the currently selected item in views can show Status
//
BOOL CWinAdminDoc::CanStatus()
{
        return CheckActionAllowed(CheckStatusAllowed, TRUE);

}       // end CWinAdminDoc::CanStatus


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanLogoff
//
// Returns TRUE if the currently selected item in views can be Logged Off
//
BOOL CWinAdminDoc::CanLogoff()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_CurrentSelectedType == NODE_WINSTATION) {
        return FALSE;
    }
    
    // We only care if the current view is Server or All Listed Servers
    if(m_CurrentView == VIEW_SERVER) {
        // We need to make sure we are on the Users page
        if(m_CurrentPage != PAGE_USERS) return FALSE;
        BOOL Answer = FALSE;
        CServer *pServer = (CServer*)m_CurrentSelectedNode;
        // If there aren't any WinStations selected on this server, return
        if(!pServer->GetNumWinStationsSelected()) return FALSE;
        
        pServer->LockWinStationList();
        CObList *pWinStationList = pServer->GetWinStationList();
        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();
        
        while(pos) {
            CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
            if(pWinStation->IsSelected()) {
                if(!pWinStation->HasOutstandingThreads()
                    && !pWinStation->IsSystemConsole())
                    Answer = TRUE;
            }
        }
        
        pServer->UnlockWinStationList();
        return Answer;
    } else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
        // If we are doing a refesh, we can't do anything else
        if(m_InRefresh) return FALSE;
        // We need to make sure we are on the Users page
        if(m_CurrentPage != PAGE_AS_USERS && m_CurrentPage != PAGE_DOMAIN_USERS) return FALSE;
        BOOL Answer = FALSE;
        
        LockServerList();
        POSITION pos1 = m_ServerList.GetHeadPosition();
        
        while(pos1) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos1);
            
            // Are there any WinStations selected on this server?
            if(pServer->GetNumWinStationsSelected()) {
                pServer->LockWinStationList();
                CObList *pWinStationList = pServer->GetWinStationList();
                // Iterate through the WinStation list
                POSITION pos = pWinStationList->GetHeadPosition();
                
                while(pos) {
                    CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                    if(pWinStation->IsSelected()) {
                        if(!pWinStation->HasOutstandingThreads()
                            && !pWinStation->IsSystemConsole())
                            Answer = TRUE;
                    }
                }
                pServer->UnlockWinStationList();
            } // end if(pServer->GetNumWinStationsSelected())
        }
        
        UnlockServerList();
        return Answer;
    }
    
    return FALSE;

}       // end CWinAdminDoc::CanLogoff


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTerminate
//
// Returns TRUE if the currently selected item in views can be Terminated
//
BOOL CWinAdminDoc::CanTerminate()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    // We have to be in All Selected Servers, Server, or WinStation view
    if((m_CurrentView == VIEW_ALL_SERVERS && m_CurrentPage == PAGE_AS_PROCESSES)
        || (m_CurrentView == VIEW_DOMAIN && m_CurrentPage == PAGE_DOMAIN_PROCESSES)) {
        // If we are doing a refresh, we can't do anything else
        if(m_InRefresh) return FALSE;
        // Loop through all the servers and see if any processes are selected
        LockServerList();
        
        POSITION pos2 = m_ServerList.GetHeadPosition();
        while(pos2) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
            
            // Are there any processes selected on this server?
            if(pServer->GetNumProcessesSelected()) {
                pServer->LockProcessList();
                CObList *pProcessList = pServer->GetProcessList();
                
                POSITION pos = pProcessList->GetHeadPosition();
                while(pos) {
                    CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);
                    // We only need one process to be selected
                    if(pProcess->IsSelected() && !pProcess->IsTerminating()) {
                        pServer->UnlockProcessList();
                        UnlockServerList();
                        return TRUE;
                    }
                }
                
                pServer->UnlockProcessList();
            } // end if(pServer->GetNumProcessesSelected())
        }
        UnlockServerList();
        return FALSE;
    }
    
    if(m_CurrentView == VIEW_SERVER && m_CurrentPage == PAGE_PROCESSES) {
        CServer *pServer = (CServer*)m_CurrentSelectedNode;
        
        // If there aren't any processes selected on this server, return
        if(!pServer->GetNumProcessesSelected()) return FALSE;
        
        pServer->LockProcessList();
        CObList *pProcessList = pServer->GetProcessList();
        
        POSITION pos = pProcessList->GetHeadPosition();
        while(pos) {
            CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);
            // We only need one process to be selected
            if(pProcess->IsSelected() && !pProcess->IsTerminating()) {
                pServer->UnlockProcessList();
                return TRUE;
            }
        }
        
        pServer->UnlockProcessList();
        return FALSE;
    }
    
    if(m_CurrentView == VIEW_WINSTATION && m_CurrentPage == PAGE_WS_PROCESSES) {
        CServer *pServer = (CServer*)((CWinStation*)m_CurrentSelectedNode)->GetServer();
        
        pServer->LockProcessList();
        CObList *pProcessList = pServer->GetProcessList();
        
        POSITION pos = pProcessList->GetHeadPosition();
        while(pos) {
            CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);
            // We only need one process to be selected
            if(pProcess->IsSelected() && !pProcess->IsTerminating()) {
                pServer->UnlockProcessList();
                return TRUE;
            }
        }
        
        pServer->UnlockProcessList();
        return FALSE;
        
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTerminate

//=--------------------------------------------------------
BOOL CWinAdminDoc::IsAlreadyFavorite( )
{
    if(m_TempSelectedType == NODE_SERVER)
    {
        CServer *pServer = (CServer*)m_pTempSelectedNode;
        
        if( pServer->GetTreeItemFromFav( ) != NULL )
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanServerConnect
//
// Returns TRUE if the currently selected server in views can be connected to
//
BOOL CWinAdminDoc::CanServerConnect()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a Server selected in the tree?
    if(m_TempSelectedType == NODE_SERVER) {
        if(((CServer*)m_pTempSelectedNode)->GetState() == SS_NOT_CONNECTED || 
            ((CServer*)m_pTempSelectedNode)->GetState() == SS_BAD ) return TRUE;
    }
    
    // Is a Server selected in the tree?
    else if(m_CurrentSelectedType == NODE_SERVER) {
        if(((CServer*)m_CurrentSelectedNode)->GetState() == SS_NOT_CONNECTED ||
            ((CServer*)m_CurrentSelectedNode)->GetState() == SS_BAD ) return TRUE;
    }
    
    // We only care if the current view is Domain or All Listed Servers
    else if(m_CurrentView == VIEW_DOMAIN) {
        // We need to make sure we are on the Servers page
        if(m_CurrentPage != PAGE_DOMAIN_SERVERS) return FALSE;
        int NumSelected = 0;
        CDomain *pDomain = (CDomain*)m_CurrentSelectedNode;
        
        LockServerList();
        
        // Iterate through the Server list
        POSITION pos = m_ServerList.GetHeadPosition();
        
        while(pos) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
            if(pServer->IsSelected() && pServer->GetDomain() == pDomain) {
                if(!pServer->IsState(SS_NOT_CONNECTED)) {
                    UnlockServerList();
                    return FALSE;
                }
                NumSelected++;
            }
        }
        
        UnlockServerList();
        // If we got here, all the selected Servers passed our criteria
        if(NumSelected) return TRUE;
    }
    
    else if(m_CurrentView == VIEW_ALL_SERVERS) {
        // We need to make sure we are on the Servers page
        if(m_CurrentPage != PAGE_AS_SERVERS) return FALSE;
        int NumSelected = 0;
        
        LockServerList();
        
        // Iterate through the Server list
        POSITION pos = m_ServerList.GetHeadPosition();
        
        while(pos) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
            if(pServer->IsSelected()) {
                if(!pServer->IsState(SS_NOT_CONNECTED)) {
                    UnlockServerList();
                    return FALSE;
                }
                NumSelected++;
            }
        }
        
        UnlockServerList();
        // If we got here, all the selected Servers passed our criteria
        if(NumSelected) return TRUE;
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanServerConnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanServerDisconnect
//
// Returns TRUE if the currently selected server in views can be disconnected from
//
BOOL CWinAdminDoc::CanServerDisconnect()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a Server selected in the tree?
    if(m_TempSelectedType == NODE_SERVER) {
        if(((CServer*)m_pTempSelectedNode)->GetState() == SS_GOOD) return TRUE;
    }
    
    // Is a Server selected in the tree?
    else if(m_CurrentSelectedType == NODE_SERVER) {
        if(((CServer*)m_CurrentSelectedNode)->GetState() == SS_GOOD) return TRUE;
    }
    
    // We only care if the current view is Domain or All Listed Servers
    else if(m_CurrentView == VIEW_DOMAIN) {
        // We need to make sure we are on the Servers page
        if(m_CurrentPage != PAGE_DOMAIN_SERVERS) return FALSE;
        int NumSelected = 0;
        CDomain *pDomain = (CDomain*)m_CurrentSelectedNode;
        
        LockServerList();
        
        // Iterate through the Server list
        POSITION pos = m_ServerList.GetHeadPosition();
        
        while(pos) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
            if(pServer->IsSelected() && pServer->GetDomain() == pDomain) {
                if(!pServer->IsState(SS_GOOD)) {
                    UnlockServerList();
                    return FALSE;
                }
                NumSelected++;
            }
        }
        
        UnlockServerList();
        // If we got here, all the selected Servers passed our criteria
        if(NumSelected) return TRUE;
    }
    
    else if(m_CurrentView == VIEW_ALL_SERVERS) {
        // We need to make sure we are on the Servers page
        if(m_CurrentPage != PAGE_AS_SERVERS) return FALSE;
        int NumSelected = 0;
        
        LockServerList();
        
        // Iterate through the Server list
        POSITION pos = m_ServerList.GetHeadPosition();
        
        while(pos) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
            if(pServer->IsSelected()) {
                if(!pServer->IsState(SS_GOOD)) {
                    UnlockServerList();
                    return FALSE;
                }
                NumSelected++;
            }
        }
        
        UnlockServerList();
        // If we got here, all the selected Servers passed our criteria
        if(NumSelected) return TRUE;
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanServerDisconnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempConnect
//
// Returns TRUE if the temporarily selected item in views can be Connected to
//
BOOL CWinAdminDoc::CanTempConnect()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_TempSelectedType == NODE_WINSTATION) {
        return CheckConnectAllowed((CWinStation*)m_pTempSelectedNode);
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempConnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempDisconnect
//
// Returns TRUE if the temporarily selected item in views can be Disconnected
//
BOOL CWinAdminDoc::CanTempDisconnect()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_TempSelectedType == NODE_WINSTATION) {
        return CheckDisconnectAllowed((CWinStation*)m_pTempSelectedNode);
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempDisconnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempReset
//
// Returns TRUE if the temporarily selected item in views can be Reset
//
BOOL CWinAdminDoc::CanTempReset()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_TempSelectedType == NODE_WINSTATION) {
        return CheckResetAllowed((CWinStation*)m_pTempSelectedNode);
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempReset


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempShadow
//
// Returns TRUE if the temporarily selected item in views can be Shadowed
//
BOOL CWinAdminDoc::CanTempShadow()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_TempSelectedType == NODE_WINSTATION) {
        return CheckShadowAllowed((CWinStation*)m_pTempSelectedNode);
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempShadow


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempSendMessage
//
// Returns TRUE if the temporarily selected item in views can be sent a message
//
BOOL CWinAdminDoc::CanTempSendMessage()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_TempSelectedType == NODE_WINSTATION) {
        return CheckSendMessageAllowed((CWinStation*)m_pTempSelectedNode);
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempSendMessage


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempStatus
//
// Returns TRUE if the temporarily selected item in views can show Status
//
BOOL CWinAdminDoc::CanTempStatus()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_TempSelectedType == NODE_WINSTATION) {
        return CheckStatusAllowed((CWinStation*)m_pTempSelectedNode);
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempStatus


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempDomainConnect
//
// Returns TRUE if the temporarily selected Domain in tree can have all it's
// Servers connected/disconnected to/from.
//
BOOL CWinAdminDoc::CanTempDomainConnect()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a Domain selected in the tree?
    if(m_TempSelectedType == NODE_DOMAIN) {
        if(((CDomain*)m_pTempSelectedNode)->IsState(DS_ENUMERATING))
            return TRUE;
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempDomainConnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempDomainFindServers
//
// Returns TRUE if the temporarily selected Domain in tree can go out
// and find Servers
//
BOOL CWinAdminDoc::CanTempDomainFindServers()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a Domain selected in the tree?
    if(m_TempSelectedType == NODE_DOMAIN) {
        if(!((CDomain*)m_pTempSelectedNode)->GetThreadPointer())
            return TRUE;
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempDomainFindServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanDomainConnect
//
// Returns TRUE if the currently selected Domain in tree can have all it's
// Servers connected/disconnected to/from.
//
BOOL CWinAdminDoc::CanDomainConnect()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a Domain selected in the tree?
    if(m_CurrentSelectedType == NODE_DOMAIN) {
        if(((CDomain*)m_CurrentSelectedNode)->IsState(DS_ENUMERATING))
            return TRUE;
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanDomainConnect

//------------------------------------------------------------------------------
void CWinAdminDoc::ServerAddToFavorites( BOOL bAdd )
{
    ODS( L"CWinAdminDoc::ServerAddToFavorites\n");
    // we got here from a context menu selection    
    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
    
    if(m_TempSelectedType == NODE_SERVER && pDoc != NULL )
    {
        CServer* pServer = ( CServer* )m_pTempSelectedNode;
        
        if( pServer != NULL )
        {
            
            // test to see if the server is being removed
            
            if( pServer->IsState(SS_DISCONNECTING) )
            {
                ODS( L"=-sneaky popup menu was up when server went away\n=-not adding server to favs\n");
                
                return;
            }
            
            CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
            
            if( p !=NULL && ::IsWindow(p->GetSafeHwnd() ) )
            {
                // ok we're off to treeview ville
                
                if( bAdd )
                {
                    p->SendMessage(WM_ADMIN_ADDSERVERTOFAV , 0 , (LPARAM)pServer);
                }
                else
                {
                    p->SendMessage( WM_ADMIN_REMOVESERVERFROMFAV, 0 , (LPARAM)pServer);
                }
            }
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////////
//
//      CWinStation Member Functions
//
//////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CWinStation::CWinStation
//
CWinStation::CWinStation(CServer *pServer, PLOGONID pLogonId)
{
    ASSERT(pServer);
    
    m_WinStationFlags = 0L;
    m_OutstandingThreads = 0;
    
    m_hTreeItem = NULL;
    m_hFavTree = NULL;
    m_hTreeThisComputer = NULL;
    
    m_pWd = NULL;
    m_UserName[0] = '\0';
    m_WdName[0] = '\0';
    m_ClientName[0] = '\0';
    m_Comment[0] = '\0';
    m_SdClass = SdNone;
    m_LogonTime.HighPart = 0L;
    m_LogonTime.LowPart = 0L;
    m_LastInputTime.HighPart = 0L;
    m_LastInputTime.LowPart = 0L;
    m_CurrentTime.HighPart = 0L;
    m_CurrentTime.LowPart = 0L;
    m_IdleTime.days = 0;
    m_IdleTime.hours = 0;
    m_IdleTime.minutes = 0;
    m_IdleTime.seconds = 0;
    m_pExtensionInfo = NULL;
    m_pExtWinStationInfo = NULL;
    m_pExtModuleInfo = NULL;
    m_NumModules = 0;
    m_ProtocolType = 0;
    m_clientDigProductId[0] = '\0';
    
    
    
    SetCurrent();
    
    m_pServer = pServer;
    m_LogonId = pLogonId->LogonId;
    wcscpy(m_Name, pLogonId->WinStationName);
    m_State = pLogonId->State;
    m_SortOrder = SortOrder[pLogonId->State];
    
    HANDLE Handle = m_pServer->GetHandle();
    
    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
    
    ULONG Length;
    PDCONFIG PdConfig;
    
    if(WinStationQueryInformation(Handle, m_LogonId, WinStationPd, &PdConfig,
        sizeof(PDCONFIG), &Length)) {
        m_SdClass = PdConfig.Create.SdClass;
        wcscpy(m_PdName, PdConfig.Create.PdName);
        
        if(m_SdClass == SdAsync) {
            CDCONFIG CdConfig;
            if(WinStationQueryInformation(Handle, m_LogonId, WinStationCd, &CdConfig,
                sizeof(CDCONFIG), &Length)) {
                if(CdConfig.CdClass != CdModem) SetDirectAsync();
            }
        }
    }
    
    WDCONFIG WdConfig;
    
    if(WinStationQueryInformation(Handle, m_LogonId, WinStationWd, &WdConfig,
        sizeof(WDCONFIG), &Length)) {
        wcscpy(m_WdName, WdConfig.WdName);
        m_pWd = pDoc->FindWdByName(m_WdName);
        
        //      if(WdConfig.WdFlag & WDF_SHADOW_TARGET) SetCanBeShadowed();
        
        
        WINSTATIONCLIENT WsClient;
        
        if(WinStationQueryInformation(Handle, m_LogonId, WinStationClient, &WsClient,
            sizeof(WINSTATIONCLIENT), &Length)) {
            wcscpy(m_ClientName, WsClient.ClientName);
            wcscpy(m_clientDigProductId, WsClient.clientDigProductId);
        }
    }
    
    WINSTATIONCONFIG WsConfig;
    
    if(WinStationQueryInformation(Handle, m_LogonId, WinStationConfiguration,
        &WsConfig, sizeof(WINSTATIONCONFIG), &Length)) {
        
        wcscpy(m_Comment, WsConfig.Comment);

        if(WdConfig.WdFlag & WDF_SHADOW_TARGET)
        {
            //
            // WHY we have IsDisconnected() then IsConnected() ?
            // WHY we don't allow shadowing view only session
            //
            if( (!((IsDisconnected()) &&
                ((WsConfig.User.Shadow == Shadow_EnableInputNotify) ||
                (WsConfig.User.Shadow == Shadow_EnableNoInputNotify))))
                || (IsConnected()) )
            {
                SetCanBeShadowed();
            }
        }
    }
    
    WINSTATIONINFORMATION WsInfo;
    
    if(WinStationQueryInformation(Handle, m_LogonId, WinStationInformation, &WsInfo,
        sizeof(WINSTATIONINFORMATION), &Length))
    {
        // the state may have already changed
        
        m_State = WsInfo.ConnectState;
        wcscpy(m_UserName, WsInfo.UserName);
        
        m_LogonTime = WsInfo.LogonTime;
        
        m_LastInputTime = IsActive() ? WsInfo.LastInputTime : WsInfo.DisconnectTime;
        m_CurrentTime = WsInfo.CurrentTime;            
        // Calculate elapsed time
        if((IsActive() || IsDisconnected()) && m_LastInputTime.QuadPart <= m_CurrentTime.QuadPart && m_LastInputTime.QuadPart)
        {                
            LARGE_INTEGER DiffTime = CalculateDiffTime(m_LastInputTime, m_CurrentTime);
            ULONG_PTR d_time = ( ULONG_PTR )DiffTime.QuadPart;
            ELAPSEDTIME IdleTime;
            // Calculate the days, hours, minutes, seconds since specified time.
            IdleTime.days = (USHORT)(d_time / 86400L); // days since
            d_time = d_time % 86400L;                  // seconds => partial day
            IdleTime.hours = (USHORT)(d_time / 3600L); // hours since
            d_time  = d_time % 3600L;                  // seconds => partial hour
            IdleTime.minutes = (USHORT)(d_time / 60L); // minutes since
            IdleTime.seconds = (USHORT)(d_time % 60L);// seconds remaining               
            m_IdleTime = IdleTime;
            TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];
            ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
        }
    }
    
    WINSTATIONCLIENT ClientData;
    
    // Get the protocol this WinStation is using
    if(WinStationQueryInformation(  Handle,
        m_LogonId,
        WinStationClient,
        &ClientData,
        sizeof(WINSTATIONCLIENT),
        &Length ) ) {
        m_ProtocolType = ClientData.ProtocolType;
        m_EncryptionLevel = ClientData.EncryptionLevel;
    }
    
    // If there is a user, set a flag bit
    if(wcslen(m_UserName)) SetHasUser();
    else ClearHasUser();
    
    // Remember when we got this information
    SetLastUpdateClock();
    SetQueriesSuccessful();        
    
    // If there is an extension DLL loaded, allow it to add it's own info for this WinStation
    LPFNEXWINSTATIONINITPROC InitProc = ((CWinAdminApp*)AfxGetApp())->GetExtWinStationInitProc();
    if(InitProc) {
        m_pExtensionInfo = (*InitProc)(Handle, m_LogonId);
        if(m_pExtensionInfo) {
            LPFNEXGETWINSTATIONINFOPROC InfoProc = ((CWinAdminApp*)AfxGetApp())->GetExtGetWinStationInfoProc();
            if(InfoProc) {
                m_pExtWinStationInfo = (*InfoProc)(m_pExtensionInfo);
            }
        }
    }
    
}       // end CWinStation::CWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinStation::~CWinStation
//
CWinStation::~CWinStation()
{
    // Remove all of the processes attributed to this WinStation
    // from the Server's list
    m_pServer->RemoveWinStationProcesses(this);
    
    // If there is an extension DLL, let it cleanup anything it added to this WinStation
    LPFNEXWINSTATIONCLEANUPPROC CleanupProc = ((CWinAdminApp*)AfxGetApp())->GetExtWinStationCleanupProc();
    if(CleanupProc) {
        (*CleanupProc)(m_pExtensionInfo);
    }
    
    if(m_pExtModuleInfo) {
        // Get the extension DLL's function to free the module info
        LPFNEXFREEWINSTATIONMODULESPROC FreeModulesProc = ((CWinAdminApp*)AfxGetApp())->GetExtFreeWinStationModulesProc();
        if(FreeModulesProc) {
            (*FreeModulesProc)(m_pExtModuleInfo);
        } else {
            TRACE0("WAExGetWinStationModules exists without WAExFreeWinStationModules\n");
            ASSERT(0);
        }
    }
    
}       // end CWinStation::~CWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinStation::Update
//
// Updates this WinStation with new data from another CWinStation
//
BOOL CWinStation::Update(CWinStation *pWinStation)
{
    ASSERT(pWinStation);
    
    // Check for any information that has changed
    BOOL bInfoChanged = FALSE;
    
    // Check the State
    if(m_State != pWinStation->GetState()) {
        // If the old state was disconnected, then we want to
        // go out and get the module (client) information again
        if(m_State == State_Disconnected)
            ClearAdditionalDone();
        m_State = pWinStation->GetState();
        // Sort order only changes when state changes
        m_SortOrder = pWinStation->GetSortOrder();
        bInfoChanged = TRUE;
    }
    
    // Check the UserName
    if(wcscmp(m_UserName, pWinStation->GetUserName()) != 0) {
        SetUserName(pWinStation->GetUserName());
        if(pWinStation->HasUser()) SetHasUser();
        else ClearHasUser();
        bInfoChanged = TRUE;
    }
    
    // Check the SdClass
    if(m_SdClass != pWinStation->GetSdClass()) {
        m_SdClass = pWinStation->GetSdClass();
        bInfoChanged = TRUE;
    }
    
    // Check the Comment
    if(wcscmp(m_Comment, pWinStation->GetComment()) != 0) {
        SetComment(pWinStation->GetComment());
        bInfoChanged = TRUE;
    }
    
    // Check the WdName
    if(wcscmp(m_WdName, pWinStation->GetWdName()) != 0) {
        SetWdName(pWinStation->GetWdName());
        SetWd(pWinStation->GetWd());
        bInfoChanged = TRUE;
    }
    
    // Check the Encryption Level
    if (GetEncryptionLevel() != pWinStation->GetEncryptionLevel() ) {
        SetEncryptionLevel(pWinStation->GetEncryptionLevel());
        bInfoChanged = TRUE;
    }
    
    // Check the Name
    if(wcscmp(m_Name, pWinStation->GetName()) != 0) {
        SetName(pWinStation->GetName());
        bInfoChanged = TRUE;
    }
    
    // Check the Client Name
    if(wcscmp(m_ClientName, pWinStation->GetClientName()) != 0) {
        SetClientName(pWinStation->GetClientName());
        bInfoChanged = TRUE;
    }

    if(wcscmp(m_clientDigProductId, pWinStation->GetClientDigProductId()) != 0) {
        SetClientDigProductId(pWinStation->GetClientDigProductId());
        bInfoChanged = TRUE;
    }

    
    // Always copy the LastInputTime
    SetLastInputTime(pWinStation->GetLastInputTime());
    // Always copy the CurrentTime
    SetCurrentTime(pWinStation->GetCurrentTime());
    // Always copy the LogonTime
    // (The logon time is not set when we create a CWinStation on the fly)
    SetLogonTime(pWinStation->GetLogonTime());
    // Always copy the IdleTime
    SetIdleTime(pWinStation->GetIdleTime());
    // Always copy the Can Shadow flag
    if(pWinStation->CanBeShadowed()) SetCanBeShadowed();
    
    // Copy the Extension Info pointer if necessary
    if(pWinStation->GetExtensionInfo() && !m_pExtensionInfo) {
        m_pExtensionInfo = pWinStation->GetExtensionInfo();
        pWinStation->SetExtensionInfo(NULL);
    }
    
    // Copy the Extended Info pointer if necessary
    if(pWinStation->GetExtendedInfo() && !m_pExtWinStationInfo) {
        m_pExtWinStationInfo = pWinStation->GetExtendedInfo();
        pWinStation->SetExtendedInfo(NULL);
    }
    
    // If this guy hasn't been updated in a while, do it now
    if(!bInfoChanged) {
        clock_t now = clock();
        if((now - GetLastUpdateClock()) > 30)
            bInfoChanged = TRUE;
    }
    
    if(bInfoChanged) {
        SetChanged();
        SetLastUpdateClock();
    }
    
    return bInfoChanged;
    
}       // end CWinStation::Update


/////////////////////////////////////////////////////////////////////////////
// CWinStation::Connect
//
void CWinStation::Connect(BOOL bUser)
{
    TCHAR szPassword[PASSWORD_LENGTH+1];
    BOOL bFirstTime = TRUE;
    DWORD Error;
    HANDLE hServer = m_pServer->GetHandle();
    
    // Start the connect loop with null password to try first.
    szPassword[0] = '\0';
    while(1) {
        if(WinStationConnect(hServer, m_LogonId, LOGONID_CURRENT, szPassword, TRUE))
            break;  // success - break out of loop
        
        if(((Error = GetLastError()) != ERROR_LOGON_FAILURE) || !bFirstTime ) {
            //We need this to know the length of the error message
            //now that StandardErrorMessage requires that
            CString tempErrorMessage;
            tempErrorMessage.LoadString(IDS_ERR_CONNECT);
            StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            m_LogonId, Error, tempErrorMessage.GetLength(), 10, IDS_ERR_CONNECT, m_LogonId);
        }
        
        // If a 'logon failure' brought us here, issue password dialog.
        // Otherwise, break the connect loop.
        if(Error == ERROR_LOGON_FAILURE) {
            
            CPasswordDlg CPDlg;
            
            CPDlg.SetDialogMode(bUser ? PwdDlg_UserMode : PwdDlg_WinStationMode);
            if(CPDlg.DoModal() == IDOK ) {
                lstrcpy(szPassword, CPDlg.GetPassword());
            } else {
                break;  // user CANCEL: break connect loop
            }
        } else
            break;      // other error: break connect loop
        
        // the next time through the loop won't be the first
        bFirstTime = FALSE;
    }
    
    return;
    
}       // end CWinStation::Connect


/////////////////////////////////////////////////////////////////////////////
// CWinStation::ShowStatus
//
void CWinStation::ShowStatus()
{
    switch(m_SdClass) {
    case SdNetwork:
    case SdNasi:
        new CNetworkStatusDlg(this);
        break;
        
    case SdAsync:
        new CAsyncStatusDlg(this);
        break;
        
    default:
        break;
    }
    
}       // end CWinStation::ShowStatus


/////////////////////////////////////////////////////////////////////////////
// CWinStation::Shadow
//
void CWinStation::Shadow()
{
    WINSTATIONCONFIG WSConfig;
    SHADOWCLASS Shadow;
    ULONG ReturnLength;
    DWORD ShadowError;
    HANDLE hServer = m_pServer->GetHandle();
    
    // Determine the WinStation's shadow state.
    if(!WinStationQueryInformation(hServer,
        m_LogonId,
        WinStationConfiguration,
        &WSConfig, sizeof(WINSTATIONCONFIG),
        &ReturnLength ) ) {
        // Can't query WinStation configuration; complain and return
        return;
    }
    Shadow = WSConfig.User.Shadow;
    
    // If shadowing is disabled, let the user know and return
    if(Shadow == Shadow_Disable ) {
        DWORD Error = GetLastError();  

        //We need this to know the length of the error message
        //now that StandardErrorMessage requires that
        CString tempErrorMessage;
        tempErrorMessage.LoadString(IDS_ERR_SHADOW_DISABLED);
        StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            m_LogonId, Error, tempErrorMessage.GetLength(), 10, IDS_ERR_SHADOW_DISABLED, m_LogonId);
        
        return;
    }
    
    // If the WinStation is disconnected and shadow notify is 'on',
    // let the user know and break out.
    if((m_State == State_Disconnected) &&
        ((Shadow == Shadow_EnableInputNotify) ||
        (Shadow == Shadow_EnableNoInputNotify)) ) {
        DWORD Error = GetLastError();

        //We need this to know the length of the error message
        //now that StandardErrorMessage requires that
        CString tempErrorMessage;
        tempErrorMessage.LoadString(IDS_ERR_SHADOW_DISCONNECTED_NOTIFY_ON);
        StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            m_LogonId, Error, tempErrorMessage.GetLength(), 10, IDS_ERR_SHADOW_DISCONNECTED_NOTIFY_ON, m_LogonId);
        
        return;
    }
    
    // Display the 'start shadow' dialog for hotkey reminder and
    // final 'ok' prior to shadowing.
    CShadowStartDlg SSDlg;
    SSDlg.m_ShadowHotkeyKey = ((CWinAdminApp*)AfxGetApp())->GetShadowHotkeyKey();
    SSDlg.m_ShadowHotkeyShift = ((CWinAdminApp*)AfxGetApp())->GetShadowHotkeyShift();
    
    if(SSDlg.DoModal() != IDOK) {
        return;
    }
    
    // launch UI thread.
    
    DWORD tid;
    
    HANDLE hThread = ::CreateThread( NULL , 0 , ( LPTHREAD_START_ROUTINE )Shadow_WarningProc , ( LPVOID )AfxGetInstanceHandle() , 0 , &tid );
   
    
    ((CWinAdminApp*)AfxGetApp())->SetShadowHotkeyKey(SSDlg.m_ShadowHotkeyKey);
    ((CWinAdminApp*)AfxGetApp())->SetShadowHotkeyShift(SSDlg.m_ShadowHotkeyShift);
    
    // Invoke the shadow DLL.
    CWaitCursor Nikki;
    
    // allow UI thread to init window
    Sleep( 900 );
    
    // Shadow API always connects to local server,
    // passing target servername as a parameter.
    
    
    BOOL bOK = WinStationShadow(SERVERNAME_CURRENT, m_pServer->GetName(), m_LogonId,
        (BYTE)((CWinAdminApp*)AfxGetApp())->GetShadowHotkeyKey(),
        (WORD)((CWinAdminApp*)AfxGetApp())->GetShadowHotkeyShift());
    if (!bOK)
    {
        ShadowError = GetLastError();
    }
    
   
    if( g_hwndShadowWarn != NULL )
    {
        OutputDebugString( L"Posting WM_DESTROY to dialog\n");
        
        EndDialog( g_hwndShadowWarn , 0 );
        //PostMessage( g_hwndShadowWarn , WM_CLOSEDIALOG , 0 , 0 );
    }
    
    
    if( !bOK )
    {
        //We need this to know the length of the error message
        //now that StandardErrorMessage requires that
        CString tempErrorMessage;
        tempErrorMessage.LoadString(IDS_ERR_SHADOW);
        StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            m_LogonId, ShadowError, tempErrorMessage.GetLength(), 10, IDS_ERR_SHADOW, m_LogonId);
    }
    
    CloseHandle( hThread );
    
}       // end CWinStation::Shadow


/////////////////////////////////////////////////////////////////////////////
// CWinStation::SendMessage
//
UINT CWinStation::SendMessage(LPVOID pParam)
{
    ASSERT(pParam);
    
    ULONG Response;
    UINT RetVal = 0;
    
    ((CWinAdminApp*)AfxGetApp())->BeginOutstandingThread();
    
    MessageParms *pMsgParms = (MessageParms*)pParam;
    HANDLE hServer = pMsgParms->pWinStation->m_pServer->GetHandle();
    
    if(!WinStationSendMessage(hServer,
        pMsgParms->pWinStation->m_LogonId,
        pMsgParms->MessageTitle, (wcslen(pMsgParms->MessageTitle)+1)*sizeof(TCHAR),
        pMsgParms->MessageBody, (wcslen(pMsgParms->MessageBody)+1)*sizeof(TCHAR),
        MB_OK, 60, &Response, TRUE ) ) {
        DWORD Error = GetLastError();

        //We need this to know the length of the error message
        //now that StandardErrorMessage requires that
        CString tempErrorMessage;
        tempErrorMessage.LoadString(IDS_ERR_MESSAGE);
        StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            pMsgParms->pWinStation->m_LogonId, Error, tempErrorMessage.GetLength(),
            10, IDS_ERR_MESSAGE, pMsgParms->pWinStation->m_LogonId);
        
        RetVal = 1;
    }
    
    delete pMsgParms;
    ((CWinAdminApp*)AfxGetApp())->EndOutstandingThread();
    
    return RetVal;
    
}       // end CWinStation::SendMessage


/////////////////////////////////////////////////////////////////////////////
// CWinStation::Disconnect
//
UINT CWinStation::Disconnect(LPVOID pParam)
{
    ASSERT(pParam);
    
    UINT RetVal = 0;
    
    ((CWinAdminApp*)AfxGetApp())->BeginOutstandingThread();
    
    CWinStation *pWinStation = (CWinStation*)pParam;
    HANDLE hServer = pWinStation->m_pServer->GetHandle();
    
    if(!WinStationDisconnect(hServer, pWinStation->m_LogonId, TRUE)) {
        DWORD Error = GetLastError();

        //We need this to know the length of the error message
        //now that StandardErrorMessage requires that
        CString tempErrorMessage;
        tempErrorMessage.LoadString(IDS_ERR_DISCONNECT);
        StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            pWinStation->m_LogonId, Error, tempErrorMessage.GetLength(), 10, IDS_ERR_DISCONNECT, pWinStation->m_LogonId);
        RetVal = 1;
    }
    
    ((CWinAdminApp*)AfxGetApp())->EndOutstandingThread();
    return RetVal;
    
}       // end CWinStation::Disconnect


/////////////////////////////////////////////////////////////////////////////
// CWinStation::Reset
//
UINT CWinStation::Reset(LPVOID pParam)
{
    ASSERT(pParam);
    
    UINT RetVal = 0;
    
    ((CWinAdminApp*)AfxGetApp())->BeginOutstandingThread();
    
    ResetParms *pResetParms = (ResetParms*)pParam;
    
    HANDLE hServer = pResetParms->pWinStation->m_pServer->GetHandle();
    
    if(!WinStationReset(hServer, pResetParms->pWinStation->m_LogonId, TRUE))
    {
        DWORD Error = GetLastError();
        
        //We need this to know the length of the error message
        //now that StandardErrorMessage requires that
        CString tempErrorMessage1, tempErrorMessage2;
        tempErrorMessage1.LoadString(IDS_ERR_RESET);
        tempErrorMessage2.LoadString(IDS_ERR_USER_LOGOFF);

        StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            pResetParms->pWinStation->m_LogonId, Error, 
            pResetParms->bReset ? tempErrorMessage1.GetLength() : tempErrorMessage2.GetLength(), 10,
            pResetParms->bReset ? IDS_ERR_RESET : IDS_ERR_USER_LOGOFF, pResetParms->pWinStation->m_LogonId);
        RetVal = 1;
    }
    
    ((CWinAdminApp*)AfxGetApp())->EndOutstandingThread();
    
    delete pParam;
    
    return RetVal;
    
}       // end CWinStation::Reset


/////////////////////////////////////////////////////////////////////////////
// CWinStation::QueryAdditionalInformation
//
void CWinStation::QueryAdditionalInformation()
{
    ULONG ReturnLength;
    HANDLE hServer = m_pServer->GetHandle();
    WINSTATIONCLIENT ClientData;
    
    // Set all the strings to start with a NULL
    m_ClientDir[0] = '\0';
    m_ModemName[0] = '\0';
    m_ClientLicense[0] = '\0';
    m_ClientAddress[0] = '\0';
    m_Colors[0] = '\0';
    
    // Set all the values to 0
    m_ClientBuildNumber = 0;
    m_ClientProductId = 0;
    m_HostBuffers = 0;
    m_ClientBuffers = 0;
    m_BufferLength = 0;
    m_ClientSerialNumber = 0;
    m_VRes = 0;
    m_HRes = 0;
    
    SetAdditionalDone();
    
    if ( WinStationQueryInformation( hServer,
        m_LogonId,
        WinStationClient,
        &ClientData,
        sizeof(WINSTATIONCLIENT),
        &ReturnLength ) ) {
        
        // Assign string values.
        wcscpy(m_ClientDir, ClientData.ClientDirectory);
        wcscpy(m_ModemName, ClientData.ClientModem);
        wcscpy(m_ClientLicense, ClientData.ClientLicense);
        wcscpy(m_ClientAddress, ClientData.ClientAddress);
        
        switch ( ClientData.ColorDepth ) {
        case 0x0001:
            wcscpy(m_Colors, TEXT("16"));
            break;
        case 0x0002:
            wcscpy(m_Colors, TEXT("256"));
            break;
        case 0x0004:
            wcscpy(m_Colors, TEXT("64K"));
            break;
        case 0x0008:
            wcscpy(m_Colors, TEXT("16M"));
            break;
        case 0x0010:
            wcscpy(m_Colors, TEXT("32M"));
            break;
            
        }
        
        // Assign numeric values.
        m_ClientBuildNumber = ClientData.ClientBuildNumber;
        m_ClientProductId = ClientData.ClientProductId;
        m_HostBuffers = ClientData.OutBufCountHost;
        m_ClientBuffers = ClientData.OutBufCountClient;
        m_BufferLength = ClientData.OutBufLength;
        m_ClientSerialNumber = ClientData.SerialNumber;
        m_HRes = ClientData.HRes;
        m_VRes = ClientData.VRes;
    }
    
    // If there is an extension DLL loaded, allow it to add it's own info for this WinStation
    LPFNEXWINSTATIONINFOPROC InfoProc = ((CWinAdminApp*)AfxGetApp())->GetExtWinStationInfoProc();
    if(InfoProc) {
        (*InfoProc)(m_pExtensionInfo, m_State);
    }
    
    LPFNEXGETWINSTATIONMODULESPROC ModuleProc = ((CWinAdminApp*)AfxGetApp())->GetExtGetWinStationModulesProc();
    if(ModuleProc) {
        if(m_pExtModuleInfo) {
            // Get the extension DLL's function to free the module info
            LPFNEXFREEWINSTATIONMODULESPROC FreeModulesProc = ((CWinAdminApp*)AfxGetApp())->GetExtFreeWinStationModulesProc();
            if(FreeModulesProc) {
                (*FreeModulesProc)(m_pExtModuleInfo);
            } else {
                TRACE0("WAExGetWinStationModules exists without WAExFreeWinStationModules\n");
                ASSERT(0);
            }
        }
        
        m_pExtModuleInfo = (*ModuleProc)(GetExtensionInfo(), &m_NumModules);
    }
    
}       //      end CWinStation::QueryAdditionalInformation


//////////////////////////////////////////////////////////////////////////////////////////
//
//      CProcess Member Functions
//
//////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CProcess::CProcess
//
CProcess::CProcess( ULONG PID,
                   ULONG LogonId,
                   CServer *pServer,
                   PSID pSID,
                   CWinStation *pWinStation,
                   TCHAR *ImageName)
{
    ASSERT(pServer);
    
    m_Flags = PF_CURRENT;
    m_PID = PID;
    m_LogonId = LogonId;
    m_pServer = pServer;
    m_pWinStation = pWinStation;
    wcscpy(m_ImageName, ImageName);
    
    if(PID == 0 && !pSID)
    {
        CString sTemp;
        sTemp.LoadString(IDS_SYSTEM_IDLE_PROCESS);
        wcscpy(m_ImageName, sTemp);
        SetSystemProcess();
        wcscpy(m_UserName, TEXT("System"));
        m_SidCrc = 0;
    }
    else
    {
        
        if(pSID) {
            DWORD SidLength = GetLengthSid(pSID);
            m_SidCrc = CalculateCrc16((PBYTE)pSID, (USHORT)SidLength);
        } else m_SidCrc = 0;
        
        DetermineProcessUser(pSID);
        
        if(QuerySystemProcess()) SetSystemProcess();
    }
    
    
}       // end CProcess::CProcess


TCHAR *SysProcTable[] = {
    TEXT("csrss.exe"),
        TEXT("smss.exe"),
        TEXT("screg.exe"),
        TEXT("lsass.exe"),
        TEXT("spoolss.exe"),
        TEXT("EventLog.exe"),
        TEXT("netdde.exe"),
        TEXT("clipsrv.exe"),
        TEXT("lmsvcs.exe"),
        TEXT("MsgSvc.exe"),
        TEXT("winlogon.exe"),
        TEXT("NETSTRS.EXE"),
        TEXT("nddeagnt.exe"),
        TEXT("wfshell.exe"),
        TEXT("chgcdm.exe"),
        TEXT("userinit.exe"),
        NULL
};


/////////////////////////////////////////////////////////////////////////////
// CProcess::QuerySystemProcess
//
BOOL CProcess::QuerySystemProcess()
{
    // First: if the user name is 'system' or no image name is present, treat
    // as a 'system' process.
    if(!lstrcmpi(m_UserName, TEXT("system")) ||
        !(*m_ImageName) )
        return TRUE;
    
    // Last: if the image name is one of the well known 'system' images,
    // treat it as a 'system' process.
    for(int i = 0; SysProcTable[i]; i++)
        if(!lstrcmpi( m_ImageName, SysProcTable[i]))
            return TRUE;
        
        // Not a 'system' process.
        return FALSE;
        
}       // end CProcess::QuerySystemProcess


/////////////////////////////////////////////////////////////////////////////
// CProcess::DetermineProcessUser
//
void CProcess::DetermineProcessUser(PSID pSid)
{
    CObList *pUserSidList = m_pServer->GetUserSidList();
    
    // Look for the user Sid in the list
    POSITION pos = pUserSidList->GetHeadPosition();
    
    while(pos)
    {
        CUserSid *pUserSid = (CUserSid*)pUserSidList->GetNext(pos);
        
        if(pUserSid->m_SidCrc == m_SidCrc)
        {
            wcscpy(m_UserName, pUserSid->m_UserName);
            
            return;
            
        }
    }
    
    // It wasn't in the list
    // Get the user from the Sid and put it in our list
    
    GetUserFromSid(pSid, m_UserName, USERNAME_LENGTH);
    
    if (!lstrcmpi(m_UserName,TEXT("system")))
    {
        wcscpy(m_UserName, TEXT("System")); // to make the UI guys happy
    }
    
    CUserSid *pUserSid = new CUserSid;
    if(pUserSid)
    {
        pUserSid->m_SidCrc = m_SidCrc;
    }
    
    memset(pUserSid->m_UserName, 0, sizeof(pUserSid->m_UserName));
    
    lstrcpy(pUserSid->m_UserName, m_UserName);
    
    pUserSidList->AddTail(pUserSid);
    
    
}       // end CProcess::DetermineProcessUser


/////////////////////////////////////////////////////////////////////////////
// CProcess::Update
//
BOOL CProcess::Update(CProcess *pProcess)
{
    ASSERT(pProcess);
    
    BOOL bChanged = FALSE;
    
    // Check the WinStation
    if(m_pWinStation != pProcess->GetWinStation())
    {
        m_pWinStation = pProcess->GetWinStation();
        bChanged = TRUE;
    }
    else
    {
        if(m_pWinStation->IsChanged())
        {
            bChanged = TRUE;
        }
    }
    
    if(bChanged) SetChanged();
    
    return bChanged;
    
}       // end CProcess::Update


//////////////////////////////////////////////////////////////////////////////////////////
//
//      CLicense Member Functions
//
//////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CLicense::CLicense
//
CLicense::CLicense(CServer *pServer, ExtLicenseInfo *pLicenseInfo)
{
    ASSERT(pServer);
    ASSERT(pLicenseInfo);
    
    m_pServer = pServer;
    m_Class = pLicenseInfo->Class;
    m_PoolLicenseCount = pLicenseInfo->PoolLicenseCount;
    m_LicenseCount = pLicenseInfo->LicenseCount;
    m_Flags = pLicenseInfo->Flags;
    wcscpy(m_RegSerialNumber, pLicenseInfo->RegSerialNumber);
    wcscpy(m_LicenseNumber, pLicenseInfo->LicenseNumber);
    wcscpy(m_Description, pLicenseInfo->Description);
    
    // Figure out the pooling count
    if(m_Flags & ELF_POOLING)
        m_PoolCount = m_PoolLicenseCount;
    else m_PoolCount = 0xFFFFFFFF;
    
}       // end CLicense::CLicense


//////////////////////////////////////////////////////////////////////////////////////////
//
//      CWd Member Functions
//
//////////////////////////////////////////////////////////////////////////////////////////
static CHAR szEncryptionLevels[] = "ExtEncryptionLevels";


/////////////////////////////////////////////////////////////////////////////
// CWd::CWd
//
CWd::CWd(PWDCONFIG2 pWdConfig, PWDNAME pRegistryName)
{
    m_pEncryptionLevels = NULL;
    m_NumEncryptionLevels = 0L;
    
    wcscpy(m_WdName, pWdConfig->Wd.WdName);
    wcscpy(m_RegistryName, pRegistryName);
    
    // Load the extension DLL for this WD
    m_hExtensionDLL = ::LoadLibrary(pWdConfig->Wd.CfgDLL);
    if(m_hExtensionDLL) {
        // Get the entry points
        m_lpfnExtEncryptionLevels = (LPFNEXTENCRYPTIONLEVELSPROC)::GetProcAddress(m_hExtensionDLL, szEncryptionLevels);
        if(m_lpfnExtEncryptionLevels) {
            m_NumEncryptionLevels = (*m_lpfnExtEncryptionLevels)(NULL, &m_pEncryptionLevels);
        }
    }
    
}       // end CWd::CWd


/////////////////////////////////////////////////////////////////////////////
// CWd::~CWd
//
CWd::~CWd()
{
    if(m_hExtensionDLL) {
        ::FreeLibrary(m_hExtensionDLL);
    }
    
    
}       // end CWd::~CWd


/////////////////////////////////////////////////////////////////////////////
// CWd::GetEncryptionLevelString
//
BOOL CWd::GetEncryptionLevelString(DWORD Value, CString *pString)
{
    if(!m_NumEncryptionLevels) return FALSE;
    
    for(LONG i = 0; i < m_NumEncryptionLevels; i++) {
        // Is this the right encryption level
        if(Value == m_pEncryptionLevels[i].RegistryValue) {
            TCHAR estring[128];
            if(::LoadString(m_hExtensionDLL,
                m_pEncryptionLevels[i].StringID, estring, 127)) {
                pString->Format(TEXT("%s"), estring);
                return TRUE;
            }
            return FALSE;
        }
    }
    
    return FALSE;
}       // end CWd::GetEncryptionLevelString

//------------------------------------------------
DWORD Shadow_WarningProc( LPVOID param )
{
    HINSTANCE hInst = ( HINSTANCE )param;
    
    OutputDebugString( L"Shadow_WarningProc called\n" );
    
    DialogBox( hInst , MAKEINTRESOURCE( IDD_DIALOG_SHADOWWARN ) , NULL , ShadowWarn_WndProc );
    
    OutputDebugString( L"Shadow_WarningProc exiting thread\n" );
    
    ExitThread( 0 );
    
    return 0;
}



//------------------------------------------------
INT_PTR CALLBACK ShadowWarn_WndProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    switch( msg )
    {
    case WM_INITDIALOG:
        
        g_hwndShadowWarn = hwnd;
        
        OutputDebugString( L"WM_INITDIALOG -- in ShadowWarn_WndProc\n" );
        
        CenterDlg( GetDesktopWindow( ) , hwnd );
        
        break;
        
        
    case WM_CLOSE:
        
        EndDialog( hwnd , 0 );
        
        break;
    }
    
    return FALSE;
}


void CenterDlg(HWND hwndToCenterOn , HWND hDlg )
{
    RECT rc, rcwk, rcToCenterOn;
    
    
    SetRect( &rcToCenterOn , 0 , 0 , GetSystemMetrics(SM_CXSCREEN) , GetSystemMetrics( SM_CYSCREEN ) );
    
    if (hwndToCenterOn != NULL)
    {
        ::GetWindowRect(hwndToCenterOn, &rcToCenterOn);
    }
    
    ::GetWindowRect( hDlg , &rc);
    
    UINT uiWidth = rc.right - rc.left;
    UINT uiHeight = rc.bottom - rc.top;
    
    rc.left = (rcToCenterOn.left + rcToCenterOn.right)  / 2 - ( rc.right - rc.left )   / 2;
    rc.top  = (rcToCenterOn.top  + rcToCenterOn.bottom) / 2 - ( rc.bottom - rc.top ) / 2;
    
    //ensure the dialog always with the work area
    if(SystemParametersInfo(SPI_GETWORKAREA, 0, &rcwk, 0))
    {
        UINT wkWidth = rcwk.right - rcwk.left;
        UINT wkHeight = rcwk.bottom - rcwk.top;
        
        if(rc.left + uiWidth > wkWidth)     //right cut
            rc.left = wkWidth - uiWidth;
        
        if(rc.top + uiHeight > wkHeight)    //bottom cut
            rc.top = wkHeight - uiHeight;
        
        if(rc.left < rcwk.left)             //left cut
            rc.left += rcwk.left - rc.left;
        
        if(rc.top < rcwk.top)               //top cut
            rc.top +=  rcwk.top - rc.top;
        
    }
    
    ::SetWindowPos( hDlg, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER |
        SWP_NOCOPYBITS | SWP_DRAWFRAME);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\admindoc.h ===
/*******************************************************************************
*
* admindoc.h
*
* interface of the CWinAdminDoc class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\admindoc.h  $
*  
*     Rev 1.8   19 Feb 1998 17:39:36   donm
*  removed latest extension DLL support
*  
*     Rev 1.6   19 Jan 1998 16:45:32   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.5   03 Nov 1997 15:17:26   donm
*  Added Domains
*  
*     Rev 1.4   22 Oct 1997 21:06:10   donm
*  update
*  
*     Rev 1.3   18 Oct 1997 18:49:30   donm
*  update
*  
*     Rev 1.2   13 Oct 1997 18:41:42   donm
*  update
*  
*     Rev 1.1   26 Aug 1997 19:13:28   donm
*  bug fixes/changes from WinFrame 1.7
*  
*     Rev 1.0   30 Jul 1997 17:10:14   butchd
*  Initial revision.
*
*******************************************************************************/

#ifndef _ADMINDOC_H
#define _ADMINDOC_H

#include <afxmt.h>

#define TV_THISCOMP     0x1
#define TV_FAVS         0x2
#define TV_ALLSERVERS   0x4

enum FOCUS_STATE { TREE_VIEW , TAB_CTRL , PAGED_ITEM };
class CWinAdminDoc : public CDocument
{
protected: // create from serialization only
	CWinAdminDoc();
	DECLARE_DYNCREATE(CWinAdminDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinAdminDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual BOOL CanCloseFrame(CFrameWnd *pFW);
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWinAdminDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// return a pointer to the server linked list
	CObList *GetServerList() { return &m_ServerList; }
	// return a pointer to the Wd linked list
	CObList *GetWdList() { return &m_WdList; }
    // return a pointer to the domain linked list
    CObList *GetDomainList() { return &m_DomainList; }
	// remember currently selected node in tree
	void SetTreeCurrent(CObject* selected, NODETYPE type);
	// remember a temporary tree item (for some context menus)
	void SetTreeTemp(CObject* selected, NODETYPE type) {
			m_pTempSelectedNode = selected;
		m_TempSelectedType = type;
	}
	// Returns the current view
	VIEW GetCurrentView() { return m_CurrentView; }
	// sets the  current view
	void SetCurrentView(VIEW view) { m_CurrentView = view; }
	// Returns the current page
	int GetCurrentPage() { return m_CurrentPage; }
	// sets the current page
	void SetCurrentPage(int page) { m_CurrentPage = page; }
	// Returns a pointer to the currently selected tree node
	CObject *GetCurrentSelectedNode() { return m_CurrentSelectedNode; }
	// Returns a pointer to the temp selected tree node
	CObject *GetTempSelectedNode() { return m_pTempSelectedNode; }
	// send a message to selected WinStations
	void SendWinStationMessage(BOOL bTemp, MessageParms* pParms);
	// connect to selected WinStation
	void ConnectWinStation(BOOL bTemp, BOOL bUser);	// TRUE if User, FALSE if WinStation
	// disconnect selected WinStations
	void DisconnectWinStation(BOOL bTemp);
	// reset selected WinStations
	void ResetWinStation(BOOL bTemp, BOOL bReset);	// TRUE if Reset, FALSE if Logoff
	// shadow selected WinStations
	void ShadowWinStation(BOOL bTemp);
	// show status dialog for selected WinStations
	void StatusWinStation(BOOL bTemp);
	// terminate selected processes
	void TerminateProcess();
	// do a refresh
	void Refresh();
	// Connect to selected Server(s)
	void ServerConnect();
    // Disconnect from the selected Server(s)
    void ServerDisconnect();
	// Connect to all the servers in temporarily selected Domain
	void TempDomainConnectAllServers();
	// Disconnect from all servers in temporarily selected Domain
	void TempDomainDisconnectAllServers();
	// Find all the servers in a Domain
	void DomainFindServers();
	// Connect to all the servers in currently selected Domain
	void CurrentDomainConnectAllServers();
	// Disconnect from all servers in currently selected Domain
	void CurrentDomainDisconnectAllServers();
	// Connect to all servers
	void ConnectToAllServers();
	// Disconnect from all servers
	void DisconnectFromAllServers();
	// Find all servers in all domains
	void FindAllServers();
	// lock the server linked list
	void LockServerList() { m_ServerListCriticalSection.Lock(); }
	// unlock the server linked list
	void UnlockServerList() { m_ServerListCriticalSection.Unlock(); }
	// lock the Wd linked list
	void LockWdList() { m_WdListCriticalSection.Lock(); }
	// unlock the Wd linked list
	void UnlockWdList() { m_WdListCriticalSection.Unlock(); }
	// returns a pointer to a given CServer object if it is in our list
	CServer *FindServerByName(TCHAR *pServerName);
	// returns a pointer to a given CWd object if it is in our list
	CWd *FindWdByName(TCHAR *pWdName);
	// sets the AllViewsReady variable
	void SetAllViewsReady() { 
		if(m_pMainWnd && ::IsWindow(m_pMainWnd->GetSafeHwnd())) {
			m_pMainWnd->SendMessage(WM_ADMIN_VIEWS_READY, 0, 0);
		}
		m_AllViewsReady = TRUE; 
	}
	// returns TRUE if all the views are ready
	BOOL AreAllViewsReady() { return m_AllViewsReady; }
	// sets the m_pMainWnd variable
	void SetMainWnd(CWnd *pWnd) { m_pMainWnd = pWnd; }
	// returns the m_pMainWnd variable
	CWnd *GetMainWnd() { return m_pMainWnd; }
	// returns TRUE as long as the process enum thread should keep running
	static BOOL ShouldProcessContinue() { return m_ProcessContinue; }
	// Add a Server to ServerList in sorted order
	void AddServer(CServer *pServer);
	// Inform the document that the Process List Refresh Time has changed
	void ProcessListRefreshChanged(UINT refresh) { m_ProcessWakeUpEvent.SetEvent(); }
	void FixUnknownString(TCHAR *string) { if(!wcscmp(string, m_UnknownString)) wcscpy(string,TEXT(" ")); }
	ULONG GetCurrentSubNet() { return m_CurrentSubNet; }
	void SetCurrentSubNet(ULONG sn) { m_CurrentSubNet = sn; }
	ExtServerInfo *GetDefaultExtServerInfo() { return m_pDefaultExtServerInfo; }
	ExtGlobalInfo *GetExtGlobalInfo() { return m_pExtGlobalInfo; }
    // Returns a pointer to the current domain object
    CDomain *GetCurrentDomain() { return m_pCurrentDomain; }
    // Returns a pointer to the current server object
    CServer *GetCurrentServer() { return m_pCurrentServer; }

	// Functions to check whether certain actions can be performed on the
	// currently selected items in the views
	BOOL CanConnect();
	BOOL CanDisconnect();
	BOOL CanRefresh() { return !m_InRefresh; }
	BOOL CanReset();
	BOOL CanShadow();
	BOOL CanSendMessage();
	BOOL CanStatus();
	BOOL CanLogoff();
	BOOL CanTerminate();
    BOOL CanServerConnect();
    BOOL CanServerDisconnect();
	BOOL CanTempConnect();
	BOOL CanTempDisconnect();
	BOOL CanTempReset();
	BOOL CanTempShadow();
	BOOL CanTempSendMessage();
	BOOL CanTempStatus();
	BOOL CanTempDomainConnect();
	BOOL CanTempDomainFindServers();
	BOOL CanDomainConnect();
    BOOL IsAlreadyFavorite( );

    void SetOnTabFlag( ){ m_fOnTab = TRUE; }
    void ResetOnTabFlag( ) { m_fOnTab = FALSE; }
    BOOL IsOnTabFlagged( ) { return m_fOnTab; }
	
	// Background thread to enumerate processes for the current server
	// Called with AfxBeginThread
	static UINT ProcessThreadProc(LPVOID);
	CWinThread *m_pProcessThread;
	static BOOL m_ProcessContinue;
	// Event to wakeup process thread so that
	// he can exit (WaitForSingleEvent instead of Sleep)
	// or enumerate processes
	CEvent m_ProcessWakeUpEvent;

	// Function to terminate a process
	// Called with AfxBeginThread
	static UINT TerminateProc(LPVOID);

    // Set the connections persistent preference
    void SetConnectionsPersistent(BOOL p) { m_ConnectionsPersistent = p; }
    // Should connections be persistent?
    BOOL AreConnectionsPersistent() { return(m_ConnectionsPersistent == TRUE); }   
    // Should we connect to a particular server?
    BOOL ShouldConnect(LPWSTR pServerName);

    BOOL ShouldAddToFav( LPTSTR pServerName );


    // Are we shutting down
    BOOL IsInShutdown() { return m_bInShutdown; }

    void ServerAddToFavorites( BOOL );

    FOCUS_STATE GetLastRegisteredFocus( ){ return m_focusstate; }
    void RegisterLastFocus( FOCUS_STATE x ) { m_focusstate = x; }

    FOCUS_STATE GetPrevFocus( ) { return m_prevFocusState; }
    void SetPrevFocus( FOCUS_STATE x ) { m_prevFocusState = x; }

    void AddToFavoritesNow();
    
    // Add a Domain to DomainList in sorted order
    void AddDomain(CDomain *pDomain);


private:
    
	// Read the list of trusted domains and builds linked list of domains
	void BuildDomainList();
	// builds the list of CWd objects
	void BuildWdList();
	// Helper function for the above
	BOOL CheckActionAllowed(BOOL (*CheckFunction)(CWinStation *pWinStation), BOOL AllowMultileSelected);
	// Callbacks passed to CheckActionAllowed
	static BOOL CheckConnectAllowed(CWinStation *pWinStation);
	static BOOL CheckDisconnectAllowed(CWinStation *pWinStation);
	static BOOL CheckResetAllowed(CWinStation *pWinStation);
	static BOOL CheckSendMessageAllowed(CWinStation *pWinStation);
	static BOOL CheckShadowAllowed(CWinStation *pWinStation);
	static BOOL CheckStatusAllowed(CWinStation *pWinStation);
	// Called when the CMainFrame is about to close
	// Does what the destructor used to do
	void Shutdown(CDialog *pDlg);
	// Display message string in shutdown dialog
	void ShutdownMessage(UINT id, CDialog *dlg);
	// Read the user preferences
	void ReadPreferences();
	// Write the user preferences
	void WritePreferences();

    // Function to Enumerate the Hydra Servers on the Network.
    static LPWSTR EnumHydraServers(LPWSTR pDomain, DWORD VerMajor, DWORD VerMinor);

	CObList m_ServerList;				// List of CServer objects
	CCriticalSection m_ServerListCriticalSection;

	CObList m_WdList;					// List of CWd objects
	CCriticalSection m_WdListCriticalSection;

	// List of Domains
	// This list does not have a critical section (and lock/unlock functions)
	// because it is never used by two different threads at the same time
    CObList m_DomainList;				
	CObject* m_CurrentSelectedNode;
	NODETYPE m_CurrentSelectedType;
	// TempSelected are for server context menus in the tree
	// so that tree item doesn't have to be selected to
	// make popup menu work
	CObject* m_pTempSelectedNode;
	NODETYPE m_TempSelectedType;

	void UpdateAllProcesses();
	LPCTSTR m_UnknownString;	// Pointer to the "(unknown)" string from UTILDLL.DLL
	ULONG m_CurrentSubNet;		// Subnet of the current server

	VIEW m_CurrentView;
	int m_CurrentPage;
	BOOL m_AllViewsReady;
	BOOL m_InRefresh;
	BOOL m_bInShutdown;
	CWnd *m_pMainWnd;
    CDomain *m_pCurrentDomain;
	CServer *m_pCurrentServer;
	ExtServerInfo *m_pDefaultExtServerInfo;
	ExtGlobalInfo *m_pExtGlobalInfo;

    // user preferences
    UINT m_ConnectionsPersistent;
    LPWSTR m_pPersistentConnections;
    LPWSTR m_pszFavList;

    FOCUS_STATE m_focusstate;
    FOCUS_STATE m_prevFocusState;

    BOOL m_fOnTab;

// Generated message map functions
protected:
	//{{AFX_MSG(CWinAdminDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif	// _ADMINDOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\allsrvvw.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* servervw.h
*
* declarations for the CAllServersView class
*
*
*******************************************************************************/

#ifndef _ALLSERVERSVIEW_H
#define _ALLSERVERSVIEW_H

#include "allsrvpg.h"

const int NUMBER_OF_AS_PAGES = 5;

////////////////////
// CLASS: CAllServersView
//
class CAllServersView : public CAdminView
{
friend class CRightPane;

private:
	CMyTabCtrl*	m_pTabs;
	CFont*      m_pTabFont;
	int m_CurrPage;

		
protected:
	CAllServersView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAllServersView)

// Attributes
public:

protected:
   static PageDef pages[NUMBER_OF_AS_PAGES];

// Operations
public:
	int GetCurrentPage() { return m_CurrPage; }
protected:
	virtual void Reset(void *);

	void AddTab(int index, TCHAR* text, ULONG pageindex);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAllServersView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAllServersView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    
	// Generated message map functions
protected:
	//{{AFX_MSG(CAllServersView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg LRESULT OnChangePage(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminAddServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnTabbed( WPARAM , LPARAM ) ;
    afx_msg LRESULT OnShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnNextPane( WPARAM , LPARAM );
    
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAllServersView


#endif  // _ALLSERVERSVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\allsrvvw.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* allsrvvw.cpp
*
* implementation of the CServerView class
*
*  
*******************************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "allsrvvw.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


PageDef CAllServersView::pages[] = {
	{ NULL, RUNTIME_CLASS( CAllServerServersPage ),    IDS_TAB_SERVERS,     PAGE_AS_SERVERS,	PF_PICASSO_ONLY},
	{ NULL, RUNTIME_CLASS( CAllServerUsersPage ),      IDS_TAB_USERS,       PAGE_AS_USERS,		NULL           },
	{ NULL, RUNTIME_CLASS( CAllServerWinStationsPage ),IDS_TAB_WINSTATIONS, PAGE_AS_WINSTATIONS,NULL           },
	{ NULL, RUNTIME_CLASS( CAllServerProcessesPage ),  IDS_TAB_PROCESSES,   PAGE_AS_PROCESSES,	NULL           },
	{ NULL, RUNTIME_CLASS( CAllServerLicensesPage ),   IDS_TAB_LICENSES,    PAGE_AS_LICENSES,	PF_PICASSO_ONLY}    
};


//////////////////////////
// MESSAGE MAP: CAllServersView
//
IMPLEMENT_DYNCREATE(CAllServersView, CView)

BEGIN_MESSAGE_MAP(CAllServersView, CView)
	//{{AFX_MSG_MAP(CAllServersView)
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_WA_SERVER_CHANGEPAGE, OnChangePage)
	ON_MESSAGE(WM_ADMIN_ADD_SERVER, OnAdminAddServer)
	ON_MESSAGE(WM_ADMIN_REMOVE_SERVER, OnAdminRemoveServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER, OnAdminUpdateServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_PROCESSES, OnAdminUpdateProcesses)
	ON_MESSAGE(WM_ADMIN_REMOVE_PROCESS, OnAdminRemoveProcess)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_PROCESSES, OnAdminRedisplayProcesses)
	ON_NOTIFY(TCN_SELCHANGE, IDC_ALL_SERVERS_TABS, OnTabSelChange)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER_INFO, OnAdminUpdateServerInfo)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_LICENSES, OnAdminRedisplayLicenses)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATIONS, OnAdminUpdateWinStations)
    ON_MESSAGE( WM_ADMIN_TABBED_VIEW , OnTabbed )
    ON_MESSAGE( WM_ADMIN_SHIFTTABBED_VIEW , OnShiftTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLTABBED_VIEW , OnCtrlTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLSHIFTTABBED_VIEW , OnCtrlShiftTabbed )
    ON_MESSAGE( WM_ADMIN_NEXTPANE_VIEW , OnNextPane )

END_MESSAGE_MAP()


///////////////////////
// F'N: CServerView ctor
//
CAllServersView::CAllServersView()
{
	m_pTabs       = NULL;
	m_pTabFont    = NULL;

	m_CurrPage = PAGE_AS_USERS;

}  // end CAllServersView ctor


///////////////////////
// F'N: CAllServersView dtor
//
CAllServersView::~CAllServersView()
{
	if(m_pTabs)    delete m_pTabs;
	if(m_pTabFont) delete m_pTabFont;

}  // end CAllServersView dtor


#ifdef _DEBUG
///////////////////////////////
// F'N: CAllServersView::AssertValid
//
void CAllServersView::AssertValid() const
{
	CView::AssertValid();

}  // end CAllServersView::AssertValid


////////////////////////
// F'N: CAllServersView::Dump
//
void CAllServersView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CAllServersView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CAllServersView::OnCreate
//
int CAllServersView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;

}  // end CAllServersView::OnCreate


///////////////////////////////////
// F'N: CAllServersView::OnInitialUpdate
//
// - pointers to the pages of the sheet are obtained
//
void CAllServersView::OnInitialUpdate() 
{
	// Determine whether we are running under Picasso
	BOOL bPicasso = ((CWinAdminApp*)AfxGetApp())->IsPicasso();

	// create the Tabs
	m_pTabs = new CMyTabCtrl;
    if(!m_pTabs) return;
	m_pTabs->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, CRect(0,0,0,0), this, IDC_ALL_SERVERS_TABS);


	m_pTabFont = new CFont;
    if(m_pTabFont) {
	    m_pTabFont->CreateStockObject(DEFAULT_GUI_FONT);
	    m_pTabs->SetFont(m_pTabFont, TRUE);
    }

	TCHAR szTemp[40];
	CString tabString;

	int index = 0;
	for(int i = 0; i < NUMBER_OF_AS_PAGES; i++) {
		// If the page is shown under Picasso only and we're not running
		// under Picasso, skip to the next one
		if((pages[i].flags & PF_PICASSO_ONLY) && !bPicasso) continue;
		tabString.LoadString(pages[i].tabStringID);
		wcscpy(szTemp,tabString);
		AddTab(index, szTemp, i);
		pages[i].m_pPage = (CAdminPage*)pages[i].m_pRuntimeClass->CreateObject();
		pages[i].m_pPage->Create(NULL, NULL, WS_CHILD, CRect(0, 0, 0, 0), this, i, NULL);
		GetDocument()->AddView(pages[i].m_pPage);
		index++;
	}

	m_pTabs->SetCurSel(0);	

	m_CurrPage = bPicasso ? PAGE_AS_SERVERS : PAGE_AS_USERS;

	// post a changepage msg to display the page for the currently selected tab
//	PostMessage(WM_WA_SERVER_CHANGEPAGE);

}  // end CAllServersView::OnInitialUpdate


//////////////////////////
// F'N: CAllServersView::OnSize
//
// 
//
void CAllServersView::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);
	if(m_pTabs->GetSafeHwnd())  {			// make sure the Tabs object is valid
		m_pTabs->MoveWindow(&rect, TRUE);	// size the tabs

		// for the next part (sizing of pages), we might want to add a member var
		// that keeps track of which page/tab is current... this way we could
		// only actually do a redraw (MoveWindow second parm == TRUE) for the
		// guy who is currently visible--DJM
	
		// we want to size the pages, too
		m_pTabs->AdjustRect(FALSE, &rect);

      for(int i = 0; i < NUMBER_OF_AS_PAGES; i++) {
         if(pages[i].m_pPage && pages[i].m_pPage->GetSafeHwnd())
            pages[i].m_pPage->MoveWindow(&rect, TRUE);
      }
	}
}  // end CAllServersView::OnSize


//////////////////////////
// F'N: CAllServersView::OnDraw
//
// - the CAllServersView and it's pages draw themselves, so there isn't anything
//   to do here...
//
void CAllServersView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here

}  // end CAllServersView::OnDraw


/////////////////////////
// F'N: CAllServersView::Reset
//
// - 'resets' the view
//
void CAllServersView::Reset(void *p)
{
	CWaitCursor Nikki;
	SendMessage(WM_WA_SERVER_CHANGEPAGE);	// ???	Post

	// Clear out the selected flags for each server
	// Get a pointer to our document
	CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

	// Get a pointer to the list of servers
	doc->LockServerList();
	CObList *pServerList = doc->GetServerList();

	// Iterate through the Server list
	POSITION pos = pServerList->GetHeadPosition();

	while(pos) {
		CServer *pServer = (CServer*)pServerList->GetNext(pos);
		pServer->ClearAllSelected();
	}

	doc->UnlockServerList();

	// This is necessary until we update on the fly
	for(int i = 0; i < NUMBER_OF_AS_PAGES; i++) {
		if(pages[i].m_pPage)
			pages[i].m_pPage->Reset( p ); //NULL);
	}

	((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);

}  // end CAllServersView::Reset


//////////////////////////
// F'N: CAllServersView::AddTab
//
void CAllServersView::AddTab(int index, TCHAR* text, ULONG pageindex)
{
	TC_ITEM tc;
	tc.mask = TCIF_TEXT | TCIF_PARAM;
	tc.pszText = text;
	tc.lParam = pageindex;

	m_pTabs->InsertItem(index, &tc);

}  // end CAllServersView::AddTab


////////////////////////////////
// F'N: CAllServersView::OnChangePage
//
// - changes to a new server page based on currently selected tab
// - OnChangePage needs to force recalculation of scroll bars!!!--DJM
//
// If wParam is set, sets the focus to the page. This is currently
// only done when the user clicks on a tab
//
LRESULT CAllServersView::OnChangePage(WPARAM wParam, LPARAM lParam)
{
	// find out which tab is now selected
	int tab = m_pTabs->GetCurSel();
	TC_ITEM tc;
	tc.mask = TCIF_PARAM;
	m_pTabs->GetItem(tab, &tc);
	int index = (int)tc.lParam;
				
	// switch to the appropriate view
	pages[m_CurrPage].m_pPage->ModifyStyle(WS_VISIBLE, WS_DISABLED);
    pages[m_CurrPage].m_pPage->ClearSelections();

	m_CurrPage = index;
	((CWinAdminDoc*)GetDocument())->SetCurrentPage(index);
	// show the new page
	pages[index].m_pPage->ModifyStyle(WS_DISABLED, WS_VISIBLE);
	pages[index].m_pPage->ScrollToPosition(CPoint(0,0));
	pages[index].m_pPage->Invalidate();
	if( wParam )
    {
        pages[index].m_pPage->SetFocus();
    }
    

	// Clear out the selected flags for each server
	// Get a pointer to our document
	CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

	// Get a pointer to the list of servers
	doc->LockServerList();
	CObList *pServerList = doc->GetServerList();

	// Iterate through the Server list
	POSITION pos = pServerList->GetHeadPosition();

	while(pos) {
		CServer *pServer = (CServer*)pServerList->GetNext(pos);
		pServer->ClearAllSelected();
	}

	doc->UnlockServerList();

	// If the new page is the processes page, we want to display the processes now
	if(index == PAGE_AS_PROCESSES)
    {
        void *pCurrentSelectedNode = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode();

        CNodeType *pNodeType = ( CNodeType * )pCurrentSelectedNode;

        NODETYPE m;

        if( pNodeType == NULL )
        {
            m = NODE_NONE;
        }
        else
        {
            m = pNodeType->m_nodetype;
        }

        ((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->DisplayProcesses( m );
    }

	return 0;

}  // end CAllServersView::OnChangeview


void CAllServersView::OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult) 
{
    ODS( L"AllServersView::OnTabSelChange\n" );
	OnChangePage( 0 , 0);
	*pResult = 0;

}  // end CAllServersView::OnTabSelChange


LRESULT CAllServersView::OnAdminAddServer(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_AS_SERVERS].m_pPage) {
		((CAllServerServersPage*)pages[PAGE_AS_SERVERS].m_pPage)->AddServer((CServer*)lParam);
	}		
	((CAllServerUsersPage*)pages[PAGE_AS_USERS].m_pPage)->AddServer((CServer*)lParam);
	((CAllServerWinStationsPage*)pages[PAGE_AS_WINSTATIONS].m_pPage)->AddServer((CServer*)lParam);
	((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->AddServer((CServer*)lParam);

    if(pages[PAGE_AS_LICENSES].m_pPage) {
        ((CAllServerLicensesPage*)pages[PAGE_AS_LICENSES].m_pPage)->AddServer((CServer*)lParam);
    }
	
	return 0;

}  // end CAllServersView::OnAdminAddServer


LRESULT CAllServersView::OnAdminRemoveServer(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_AS_SERVERS].m_pPage) {
		((CAllServerServersPage*)pages[PAGE_AS_SERVERS].m_pPage)->RemoveServer((CServer*)lParam);
	}
	((CAllServerUsersPage*)pages[PAGE_AS_USERS].m_pPage)->RemoveServer((CServer*)lParam);
	((CAllServerWinStationsPage*)pages[PAGE_AS_WINSTATIONS].m_pPage)->RemoveServer((CServer*)lParam);
	((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->RemoveServer((CServer*)lParam);

    if(pages[PAGE_AS_LICENSES].m_pPage) {
        ((CAllServerLicensesPage*)pages[PAGE_AS_LICENSES].m_pPage)->RemoveServer((CServer*)lParam);
    }

	return 0;

}  // end CAllServersView::OnAdminRemoveServer


LRESULT CAllServersView::OnAdminUpdateServer(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_AS_SERVERS].m_pPage) {
		((CAllServerServersPage*)pages[PAGE_AS_SERVERS].m_pPage)->UpdateServer((CServer*)lParam);
	}
	((CAllServerUsersPage*)pages[PAGE_AS_USERS].m_pPage)->UpdateServer((CServer*)lParam);
	((CAllServerWinStationsPage*)pages[PAGE_AS_WINSTATIONS].m_pPage)->UpdateServer((CServer*)lParam);
	((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->UpdateServer((CServer*)lParam);

    if(pages[PAGE_AS_LICENSES].m_pPage) {
        ((CAllServerLicensesPage*)pages[PAGE_AS_LICENSES].m_pPage)->UpdateServer((CServer*)lParam);
    }

	return 0;

}  // end CAllServersView::OnAdminUpdateServer


LRESULT CAllServersView::OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam)
{
	((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->UpdateProcesses((CServer*)lParam);

	return 0;

}  // end CAllServersView::OnAdminUpdateProcesses


LRESULT CAllServersView::OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam)
{
	((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->RemoveProcess((CProcess*)lParam);

	return 0;

}  // end CAllServersView::OnAdminRemoveProcess


LRESULT CAllServersView::OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam)
{
    NODETYPE m;

    CNodeType *pNodeType = ( CNodeType * )lParam;

    if( pNodeType == NULL )
    {
        m = NODE_NONE;
    }
    else
    {
        m = pNodeType->m_nodetype;
    }

	((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->DisplayProcesses( m );

	return 0;

}  // end CAllServersView::OnAdminRedisplayProcesses


LRESULT CAllServersView::OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam)
{
	((CAllServerUsersPage*)pages[PAGE_AS_USERS].m_pPage)->UpdateWinStations((CServer*)lParam);
	((CAllServerWinStationsPage*)pages[PAGE_AS_WINSTATIONS].m_pPage)->UpdateWinStations((CServer*)lParam);

	return 0;

}  // end CAllServersView::OnAdminUpdateWinStations


LRESULT CAllServersView::OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_AS_SERVERS].m_pPage)
		((CAllServerServersPage*)pages[PAGE_AS_SERVERS].m_pPage)->UpdateServer((CServer*)lParam);

    if(pages[PAGE_AS_LICENSES].m_pPage)
        ((CAllServerLicensesPage*)pages[PAGE_AS_LICENSES].m_pPage)->DisplayLicenseCounts();

	return 0;

}  // end CAllServersView::OnAdminUpdateServerInfo
 

LRESULT CAllServersView::OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam)
{
    if(pages[PAGE_AS_LICENSES].m_pPage)
        ((CAllServerLicensesPage*)pages[PAGE_AS_LICENSES].m_pPage)->Reset((CServer*)lParam);

	return 0;

}  // end CAllServersView::OnAdminRedisplayLicenses

//=-------------------------------------------------------------------------
// OnTabbed is called when the mainframe received VK_TAB
// this hacked fix takes advantage of the known ui layout of tsadmin
// we know we are in either three places -- treeview tabctrl listctrl
// tabbing is a forward motion so focus is moved with respect to the layout
// this code is duplicated in all view classes
//
LRESULT CAllServersView::OnTabbed( WPARAM wp , LPARAM lp )
{
    ODS( L"CAllServersView::OnTabbed " );
    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );
            // 
            // treeview should've started off with initial focus
            // we should 
            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                int nTab = m_pTabs->GetCurSel();
                
                m_pTabs->SetFocus( );
                m_pTabs->SetCurFocus( nTab );
                
                pDoc->RegisterLastFocus( TAB_CTRL );
            }
            else if( nFocus == TAB_CTRL )
            {
                ODS( L"from tab to item\n" );
                // set focus to item in page
                pages[ m_CurrPage ].m_pPage->SetFocus( );
                pDoc->RegisterLastFocus( PAGED_ITEM );
            }
            else
            {
                ODS( L"from item to treeview\n" );
                // set focus back to treeview

                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );
            }

            pDoc->SetPrevFocus( nFocus );
        }


    }

    return 0;
}

//=-------------------------------------------------------------------------
// OnShiftTabbed is called when the user wants to go back one 
// this code is duplicated in all view classes
LRESULT CAllServersView::OnShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CAllServersView::OnShiftTabbed " );

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            switch( nFocus )
            {
            case TREE_VIEW:

                ODS( L"going back from tree to paged item\n" );

                pages[ m_CurrPage ].m_pPage->SetFocus( );

                pDoc->RegisterLastFocus( PAGED_ITEM );

                break;
            case TAB_CTRL:
                {
                    ODS( L"going back from tab to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );
                }
                break;
            case PAGED_ITEM:
                {
                    ODS( L"going back from paged item to tab\n" );

                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                break;
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}

//=-------------------------------------------------------------------------
// ctrl + tab works the same as tab but because of our unorthodox ui
// when under a tab control it will cycle over the tabs and back to the treeview
//
LRESULT CAllServersView::OnCtrlTabbed( WPARAM , LPARAM )
{
    ODS( L"CAllServersView::OnCtrlTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );

                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    m_pTabs->SetCurSel( 0 );
                    
                    OnChangePage( 0 , 0 );

                    nTab = 0;
                }

                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nTab );
                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                else
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab + 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab + 1 );

                }
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}


//=----------------------------------------------------------------------------
// same as OnCtrlTab but we focus on moving in the other direction
// tree_view to last tab -- current tab to ct - 1
//
LRESULT CAllServersView::OnCtrlShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CAllServersView::OnCtrlShiftTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                
                nMaxTab = m_pTabs->GetItemCount( );
                
                m_pTabs->SetCurSel( nMaxTab - 1 );
                
                OnChangePage( 0 , 0 );
                
                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nMaxTab - 1 );                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab > 0 )
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab - 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab - 1 );
                }
                else
                {

                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}

//=----------------------------------------------------------------------------
// When the user hits F6 we need to switch between pains
LRESULT CAllServersView::OnNextPane( WPARAM , LPARAM )
{
    ODS( L"CAllServersView::OnNextPane\n" );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            FOCUS_STATE nPrevFocus = pDoc->GetPrevFocus( );

            if( nFocus == TREE_VIEW )
            {
                if( nPrevFocus == TAB_CTRL )
                {
                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );
                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                else
                {
                    pages[ m_CurrPage ].m_pPage->SetFocus( );
                    
                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }
            }
            else
            {
                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );

            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\allsrvpg.h ===
/*******************************************************************************
*
* allsrvpg.h
*
* - declarations for the All Servers info pages
* - the all server info pages are all CFormView derivatives
* based on dialog templates
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\allsrvpg.h  $
*  
*     Rev 1.4   19 Jan 1998 16:45:38   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.3   03 Nov 1997 15:18:32   donm
*  Added descending sort
*  
*     Rev 1.2   13 Oct 1997 18:41:14   donm
*  update
*  
*     Rev 1.1   26 Aug 1997 19:13:58   donm
*  bug fixes/changes from WinFrame 1.7
*  
*     Rev 1.0   30 Jul 1997 17:10:26   butchd
*  Initial revision.
*  
*******************************************************************************/


#ifndef _ALLSERVERPAGES_H
#define _ALLSERVERPAGES_H

#include "Resource.h"
#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "winadmin.h"


//////////////////////////
// CLASS: CAllServerServersPage
//
class CAllServerServersPage : public CAdminPage
{
friend class CAllServersView;

protected:
	CAllServerServersPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAllServerServersPage)

// Form Data
public:
	//{{AFX_DATA(CAllServerServersPage)
	enum { IDD = IDD_ALL_SERVER_SERVERS };
	CListCtrl	m_ServerList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxServer;		// index of Server image
	int m_idxCurrentServer;	// index of Current Server image
	int m_idxNotSign;		// index of Not Sign overlay (for non-sane servers)
	int m_idxQuestion;	// index of Question Mark overlay (for non-opened servers)

private:
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
	
protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayServers( NODETYPE );			
	virtual void Reset(void *);
	BOOL AddServerToList(CServer *pServer);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAllServerServersPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAllServerServersPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CAllServerServersPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnServerItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusServerList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusServerList(NMHDR* , LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAllServerServersPage


//////////////////////////
// CLASS: CAllServerUsersPage
//
class CAllServerUsersPage : public CAdminPage
{
friend class CAllServersView;

protected:
	CAllServerUsersPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAllServerUsersPage)

// Form Data
public:
	//{{AFX_DATA(CAllServerUsersPage)
	enum { IDD = IDD_ALL_SERVER_USERS };
	CListCtrl	m_UserList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxUser;			// index of User image
	int m_idxCurrentUser;	// index of Current User image

private:
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
    virtual void ClearSelections();
protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);
	void UpdateWinStations(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayUsers( NODETYPE );			
	virtual void Reset(void *);
	BOOL AddServerToList(CServer *pServer);
	int AddUserToList(CWinStation *pWinStation);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAllServerUsersPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAllServerUsersPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CAllServerUsersPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUserItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusUserList( NMHDR* , LRESULT* );
    afx_msg void OnSetFocus( CWnd * );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAllServerUsersPage


//////////////////////////
// CLASS: CAllServerWinStationsPage
//
class CAllServerWinStationsPage : public CAdminPage
{
friend class CAllServersView;

protected:
	CAllServerWinStationsPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAllServerWinStationsPage)

// Form Data
public:
	//{{AFX_DATA(CAllServerWinStationsPage)
	enum { IDD = IDD_ALL_SERVER_WINSTATIONS };
	CListCtrl	m_StationList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxBlank;			// index of Blank image
	int m_idxCitrix;		// index of Citrix image
	int m_idxServer;		// index of Server image 
	int m_idxConsole;		// index of Console image
	int m_idxNet;			// index of Net image
	int m_idxAsync;			// index of Async image
	int m_idxCurrentConsole;// index of Current Console image
	int m_idxCurrentNet;	// index of Current Net image
	int m_idxCurrentAsync;	// index of Current Async image
	int m_idxDirectAsync;	// index of Direct Async image
	int m_idxCurrentDirectAsync; // index of Current Direct Async image

private:
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
    virtual void ClearSelections();
protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);
	void UpdateWinStations(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayStations( NODETYPE );			
    virtual void Reset(void *);
	BOOL AddServerToList(CServer *pServer);
	int AddWinStationToList(CWinStation *pWinStation);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual f